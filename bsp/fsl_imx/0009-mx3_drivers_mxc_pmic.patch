From d24c8ffd71694c7e39b7b992ce84d4fb73b7f25b Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 11:31:18 +0800
Subject: [PATCH 09/40] mx3_drivers_mxc_pmic

MX3 pmic drivers.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/pmic/Kconfig                     |   43 +
 drivers/mxc/pmic/Makefile                    |    6 +
 drivers/mxc/pmic/core/Makefile               |   11 +
 drivers/mxc/pmic/core/mc13783.c              |  367 ++
 drivers/mxc/pmic/core/pmic-dev.c             |  324 ++
 drivers/mxc/pmic/core/pmic.h                 |  128 +
 drivers/mxc/pmic/core/pmic_core_spi.c        |  322 ++
 drivers/mxc/pmic/core/pmic_event.c           |  234 ++
 drivers/mxc/pmic/core/pmic_external.c        |   99 +
 drivers/mxc/pmic/mc13783/Kconfig             |   55 +
 drivers/mxc/pmic/mc13783/Makefile            |   18 +
 drivers/mxc/pmic/mc13783/pmic_adc.c          | 1481 +++++++
 drivers/mxc/pmic/mc13783/pmic_adc_defs.h     |  325 ++
 drivers/mxc/pmic/mc13783/pmic_audio.c        | 5673 ++++++++++++++++++++++++++
 drivers/mxc/pmic/mc13783/pmic_battery.c      | 1078 +++++
 drivers/mxc/pmic/mc13783/pmic_battery_defs.h |   81 +
 drivers/mxc/pmic/mc13783/pmic_convity.c      | 2517 ++++++++++++
 drivers/mxc/pmic/mc13783/pmic_light.c        | 2694 ++++++++++++
 drivers/mxc/pmic/mc13783/pmic_light_defs.h   |  144 +
 drivers/mxc/pmic/mc13783/pmic_power.c        | 3061 ++++++++++++++
 drivers/mxc/pmic/mc13783/pmic_power_defs.h   |  509 +++
 drivers/mxc/pmic/mc13783/pmic_rtc.c          |  560 +++
 drivers/mxc/pmic/mc13783/pmic_rtc_defs.h     |   47 +
 23 files changed, 19777 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/pmic/Kconfig
 create mode 100644 drivers/mxc/pmic/Makefile
 create mode 100644 drivers/mxc/pmic/core/Makefile
 create mode 100644 drivers/mxc/pmic/core/mc13783.c
 create mode 100644 drivers/mxc/pmic/core/pmic-dev.c
 create mode 100644 drivers/mxc/pmic/core/pmic.h
 create mode 100644 drivers/mxc/pmic/core/pmic_core_spi.c
 create mode 100644 drivers/mxc/pmic/core/pmic_event.c
 create mode 100644 drivers/mxc/pmic/core/pmic_external.c
 create mode 100644 drivers/mxc/pmic/mc13783/Kconfig
 create mode 100644 drivers/mxc/pmic/mc13783/Makefile
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_adc.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_adc_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_audio.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_battery.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_battery_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_convity.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_light.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_light_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_power.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_power_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_rtc.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_rtc_defs.h

diff --git a/drivers/mxc/pmic/Kconfig b/drivers/mxc/pmic/Kconfig
new file mode 100644
index 0000000..ac9c05b
--- /dev/null
+++ b/drivers/mxc/pmic/Kconfig
@@ -0,0 +1,43 @@
+#
+# PMIC device driver configuration
+#
+
+menu "MXC PMIC support"
+
+config MXC_SPI_PMIC_CORE
+	tristate "PMIC Protocol support (SPI interface)"
+	depends on ARCH_MXC && SPI_MXC
+	default n
+	help
+	This is the PMIC core/protocol driver for the Freescale MXC application.
+	SPI should be providing the interface between the PMIC and the MCU.
+	You must select the SPI driver support to enable this option.
+
+config MXC_PMIC
+	boolean
+	default MXC_SPI_PMIC_CORE
+
+config MXC_PMIC_CHARDEV
+	tristate "MXC PMIC device interface"
+	depends on MXC_PMIC
+	help
+	  Say Y here to use "pmic" device files, found in the /dev directory
+	  on the system.  They make it possible to have user-space programs
+	  use or controll PMIC. Mainly its useful for notifying PMIC events
+	  to user-space programs.
+
+comment "MXC PMIC Client Drivers"
+	depends on MXC_PMIC
+
+config MXC_PMIC_MC13783
+	tristate "MC13783 Client Drivers"
+	depends on MXC_SPI_PMIC_CORE && (ARCH_MX3 || ARCH_MX27)
+	default n
+	help
+	This is the MXC MC13783(PMIC) client drivers support. It include
+	ADC, Audio, Battery, Connectivity, Light, Power and RTC.
+
+source "drivers/mxc/pmic/mc13783/Kconfig"
+
+endmenu
+
diff --git a/drivers/mxc/pmic/Makefile b/drivers/mxc/pmic/Makefile
new file mode 100644
index 0000000..b4312cc
--- /dev/null
+++ b/drivers/mxc/pmic/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the MXC PMIC drivers.
+#
+
+obj-y				+= core/
+obj-$(CONFIG_MXC_PMIC_MC13783)	+= mc13783/
diff --git a/drivers/mxc/pmic/core/Makefile b/drivers/mxc/pmic/core/Makefile
new file mode 100644
index 0000000..70ac6e3
--- /dev/null
+++ b/drivers/mxc/pmic/core/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the PMIC core drivers.
+#
+obj-$(CONFIG_MXC_SPI_PMIC_CORE) += pmic_core_spi_mod.o
+obj-$(CONFIG_MXC_PMIC_CHARDEV)	+= pmic-dev.o
+
+pmic_core_spi_mod-objs := pmic_external.o pmic_event.o pmic_core_spi.o
+
+ifeq ($(CONFIG_MXC_PMIC_MC13783),y)
+pmic_core_spi_mod-objs += mc13783.o
+endif
diff --git a/drivers/mxc/pmic/core/mc13783.c b/drivers/mxc/pmic/core/mc13783.c
new file mode 100644
index 0000000..9efb752
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc13783.c
@@ -0,0 +1,367 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic/core/mc13783.c
+ * @brief This file contains MC13783 specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+
+#include <mach/gpio.h>
+
+#include <asm/plat-mxc/pmic_external.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include "pmic.h"
+
+/*
+ * Defines
+ */
+#define EVENT_MASK_0			0x697fdf
+#define EVENT_MASK_1			0x3efffb
+#define MXC_PMIC_FRAME_MASK		0x00FFFFFF
+#define MXC_PMIC_MAX_REG_NUM		0x3F
+#define MXC_PMIC_REG_NUM_SHIFT		0x19
+#define MXC_PMIC_WRITE_BIT_SHIFT	31
+
+static unsigned int events_enabled0;
+static unsigned int events_enabled1;
+static struct mxc_pmic pmic_drv_data;
+
+/*!
+ * This function is called to read a register on PMIC.
+ *
+ * @param        reg_num     number of the pmic register to be read
+ * @param        reg_val   return value of register
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+int pmic_read(unsigned int reg_num, unsigned int *reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (reg_num > MXC_PMIC_MAX_REG_NUM)
+		return PMIC_ERROR;
+
+	frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+	ret = spi_rw(pmic_drv_data.spi, (u8 *)&frame, 1);
+
+	*reg_val = frame & MXC_PMIC_FRAME_MASK;
+
+	return ret;
+}
+
+/*!
+ * This function is called to write a value to the register on PMIC.
+ *
+ * @param        reg_num     number of the pmic register to be written
+ * @param        reg_val   value to be written
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+int pmic_write(int reg_num, const unsigned int reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (reg_num > MXC_PMIC_MAX_REG_NUM)
+		return PMIC_ERROR;
+
+	frame |= (1 << MXC_PMIC_WRITE_BIT_SHIFT);
+
+	frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+	frame |= reg_val & MXC_PMIC_FRAME_MASK;
+
+	ret = spi_rw(pmic_drv_data.spi, (u8 *)&frame, 1);
+
+	return ret;
+}
+
+/*!
+ * This function initializes the SPI device parameters for this PMIC.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ *
+ * @return   None
+ */
+int pmic_spi_setup(struct spi_device *spi)
+{
+	/* Setup the SPI slave i.e.PMIC */
+	pmic_drv_data.spi = spi;
+
+	spi->mode = SPI_MODE_2 | SPI_CS_HIGH;
+	spi->bits_per_word = 32;
+
+	return spi_setup(spi);
+}
+
+/*!
+ * This function initializes the PMIC registers.
+ *
+ * @return   None
+ */
+int pmic_init_registers(void)
+{
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_MASK_0, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_MASK_1, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_STATUS_0, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_STATUS_1, MXC_PMIC_FRAME_MASK));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param 	ver	pointer to the pmic_version_t structure
+ *
+ * @return       This function returns PMIC version.
+ */
+void pmic_get_revision(pmic_version_t *ver)
+{
+	int rev_id = 0;
+	int rev1 = 0;
+	int rev2 = 0;
+	int finid = 0;
+	int icid = 0;
+
+	ver->id = PMIC_MC13783;
+	pmic_read(REG_REVISION, &rev_id);
+
+	rev1 = (rev_id & 0x018) >> 3;
+	rev2 = (rev_id & 0x007);
+	icid = (rev_id & 0x01C0) >> 6;
+	finid = (rev_id & 0x01E00) >> 9;
+
+	/* Ver 0.2 is actually 3.2a.  Report as 3.2 */
+	if ((rev1 == 0) && (rev2 == 2))
+		rev1 = 3;
+
+	if (rev1 == 0 || icid != 2) {
+		ver->revision = -1;
+		printk(KERN_NOTICE
+		       "mc13783: Not detected.\tAccess failed\t!!!\n");
+		return;
+	} else {
+		ver->revision = ((rev1 * 10) + rev2);
+		printk(KERN_INFO "mc13783 Rev %d.%d FinVer %x detected\n", rev1,
+		       rev2, finid);
+	}
+
+	return;
+
+}
+
+/*!
+ * This function reads the interrupt status registers of PMIC
+ * and determine the current active events.
+ *
+ * @param 	active_events array pointer to be used to return active
+ *		event numbers.
+ *
+ * @return       This function returns PMIC version.
+ */
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	unsigned int count = 0;
+	unsigned int status0, status1;
+	int bit_set;
+
+	pmic_read(REG_INTERRUPT_STATUS_0, &status0);
+	pmic_read(REG_INTERRUPT_STATUS_1, &status1);
+	pmic_write(REG_INTERRUPT_STATUS_0, status0);
+	pmic_write(REG_INTERRUPT_STATUS_1, status1);
+	status0 &= events_enabled0;
+	status1 &= events_enabled1;
+
+	while (status0) {
+		bit_set = ffs(status0) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		status0 ^= (1 << bit_set);
+	}
+	while (status1) {
+		bit_set = ffs(status1) - 1;
+		*(active_events + count) = bit_set + 24;
+		count++;
+		status1 ^= (1 << bit_set);
+	}
+
+	return count;
+}
+
+/*!
+ * This function unsets a bit in mask register of pmic to unmask an event IT.
+ *
+ * @param	event 	the event to be unmasked
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_unmask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_E1HZI) {
+		mask_reg = REG_INTERRUPT_MASK_0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 |= event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INTERRUPT_MASK_1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 |= event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: unmasking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, 0, event_bit);
+
+	pr_debug("Enable Event : %d\n", event);
+
+	return ret;
+}
+
+/*!
+ * This function sets a bit in mask register of pmic to disable an event IT.
+ *
+ * @param	event 	the event to be masked
+ *
+ * @return     This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_mask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_E1HZI) {
+		mask_reg = REG_INTERRUPT_MASK_0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 &= ~event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INTERRUPT_MASK_1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 &= ~event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: masking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, event_bit, event_bit);
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return ret;
+}
+
+/*!
+ * This function is called to read all sensor bits of PMIC.
+ *
+ * @param        sensor    Sensor to be checked.
+ *
+ * @return       This function returns true if the sensor bit is high;
+ *               or returns false if the sensor bit is low.
+ */
+bool pmic_check_sensor(t_sensor sensor)
+{
+	unsigned int reg_val = 0;
+
+	CHECK_ERROR(pmic_read_reg
+		(REG_INTERRUPT_SENSE_0, &reg_val, PMIC_ALL_BITS));
+
+	if ((1 << sensor) & reg_val)
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(pmic_check_sensor);
+
+/*!
+ * This function checks one sensor of PMIC.
+ *
+ * @param        sensor_bits  structure of all sensor bits.
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits)
+{
+	int sense_0 = 0;
+	int sense_1 = 0;
+
+	memset(sensor_bits, 0, sizeof(t_sensor_bits));
+
+	pmic_read_reg(REG_INTERRUPT_SENSE_0, &sense_0, 0xffffff);
+	pmic_read_reg(REG_INTERRUPT_SENSE_1, &sense_1, 0xffffff);
+
+	sensor_bits->sense_chgdets = (sense_0 & (1 << 6)) ? true : false;
+	sensor_bits->sense_chgovs = (sense_0 & (1 << 7)) ? true : false;
+	sensor_bits->sense_chgrevs = (sense_0 & (1 << 8)) ? true : false;
+	sensor_bits->sense_chgshorts = (sense_0 & (1 << 9)) ? true : false;
+	sensor_bits->sense_cccvs = (sense_0 & (1 << 10)) ? true : false;
+	sensor_bits->sense_chgcurrs = (sense_0 & (1 << 11)) ? true : false;
+	sensor_bits->sense_bpons = (sense_0 & (1 << 12)) ? true : false;
+	sensor_bits->sense_lobatls = (sense_0 & (1 << 13)) ? true : false;
+	sensor_bits->sense_lobaths = (sense_0 & (1 << 14)) ? true : false;
+	sensor_bits->sense_usb4v4s = (sense_0 & (1 << 16)) ? true : false;
+	sensor_bits->sense_usb2v0s = (sense_0 & (1 << 17)) ? true : false;
+	sensor_bits->sense_usb0v8s = (sense_0 & (1 << 18)) ? true : false;
+	sensor_bits->sense_id_floats = (sense_0 & (1 << 19)) ? true : false;
+	sensor_bits->sense_id_gnds = (sense_0 & (1 << 20)) ? true : false;
+	sensor_bits->sense_se1s = (sense_0 & (1 << 21)) ? true : false;
+	sensor_bits->sense_ckdets = (sense_0 & (1 << 22)) ? true : false;
+
+	sensor_bits->sense_onofd1s = (sense_1 & (1 << 3)) ? true : false;
+	sensor_bits->sense_onofd2s = (sense_1 & (1 << 4)) ? true : false;
+	sensor_bits->sense_onofd3s = (sense_1 & (1 << 5)) ? true : false;
+	sensor_bits->sense_pwrrdys = (sense_1 & (1 << 11)) ? true : false;
+	sensor_bits->sense_thwarnhs = (sense_1 & (1 << 12)) ? true : false;
+	sensor_bits->sense_thwarnls = (sense_1 & (1 << 13)) ? true : false;
+	sensor_bits->sense_clks = (sense_1 & (1 << 14)) ? true : false;
+	sensor_bits->sense_mc2bs = (sense_1 & (1 << 17)) ? true : false;
+	sensor_bits->sense_hsdets = (sense_1 & (1 << 18)) ? true : false;
+	sensor_bits->sense_hsls = (sense_1 & (1 << 19)) ? true : false;
+	sensor_bits->sense_alspths = (sense_1 & (1 << 20)) ? true : false;
+	sensor_bits->sense_ahsshorts = (sense_1 & (1 << 21)) ? true : false;
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_get_sensors);
diff --git a/drivers/mxc/pmic/core/pmic-dev.c b/drivers/mxc/pmic/core/pmic-dev.c
new file mode 100644
index 0000000..cbfb89b
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic-dev.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic-dev.c
+ * @brief This provides /dev interface to the user program. They make it
+ * possible to have user-space programs use or control PMIC. Mainly its
+ * useful for notifying PMIC events to user-space programs.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kdev_t.h>
+#include <linux/circ_buf.h>
+#include <linux/major.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+#include <asm/plat-mxc/pmic_external.h>
+
+#define PMIC_NAME	"pmic"
+#define CIRC_BUF_MAX	16
+#define CIRC_ADD(elem, cir_buf, size)				\
+	do { \
+		down(&event_mutex);					\
+		if (CIRC_SPACE(cir_buf.head, cir_buf.tail, size)) {	\
+			cir_buf.buf[cir_buf.head] = (char)elem;		\
+			cir_buf.head = (cir_buf.head + 1) & (size - 1);	\
+		} else {						\
+			pr_info("Failed to notify event to the user\n");\
+		}							\
+		up(&event_mutex); \
+	} while (0)
+
+#define CIRC_REMOVE(elem, cir_buf, size) \
+	do { \
+		down(&event_mutex);					\
+		if (CIRC_CNT(cir_buf.head, cir_buf.tail, size)) {         \
+			elem = (int)cir_buf.buf[cir_buf.tail];          \
+			cir_buf.tail = (cir_buf.tail + 1) & (size - 1); \
+		} else {                                                \
+			elem = -1;                                      \
+			pr_info("No valid notified event\n");           \
+		}							\
+		up(&event_mutex); \
+	} while (0)
+
+void pmic_class_dev_release(struct device *dev);
+
+static int pmic_major;
+static struct class pmic_class = {
+	.owner		= THIS_MODULE,
+	.name		= PMIC_NAME,
+	.dev_release	= pmic_class_dev_release,
+};
+
+static struct fasync_struct *pmic_dev_queue;
+
+static DECLARE_MUTEX(event_mutex);
+static struct circ_buf pmic_events;
+
+static void callbackfn(void *event)
+{
+	printk(KERN_INFO "\n\n DETECTED PMIC EVENT : %d\n\n",
+			(unsigned int)event);
+}
+
+static void user_notify_callback(void *event)
+{
+	CIRC_ADD((int)event, pmic_events, CIRC_BUF_MAX);
+	kill_fasync(&pmic_dev_queue, SIGIO, POLL_IN);
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_dev_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	register_info reg_info;
+	pmic_event_callback_t event_sub;
+	type_event event;
+	int ret = 0;
+
+	if (_IOC_TYPE(cmd) != 'P')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_READ_REG:
+			if (copy_from_user(&reg_info, (register_info *) arg,
+						sizeof(register_info)))
+				return -EFAULT;
+			ret =
+				pmic_read_reg(reg_info.reg,
+						&(reg_info.reg_value),
+						0x00ffffff);
+			pr_debug("read reg %d %x\n",
+					reg_info.reg, reg_info.reg_value);
+			if (copy_to_user((register_info *) arg, &reg_info,
+						sizeof(register_info)))
+				return -EFAULT;
+			break;
+
+	case PMIC_WRITE_REG:
+			if (copy_from_user(&reg_info, (register_info *) arg,
+						sizeof(register_info)))
+				return -EFAULT;
+			ret =
+				pmic_write_reg(reg_info.reg,
+						reg_info.reg_value,
+						0x00ffffff);
+			pr_debug("write reg %d %x\n",
+					reg_info.reg, reg_info.reg_value);
+			if (copy_to_user((register_info *) arg, &reg_info,
+						sizeof(register_info)))
+				return -EFAULT;
+			break;
+
+	case PMIC_SUBSCRIBE:
+			if (get_user(event, (int __user *)arg))
+				return -EFAULT;
+
+			event_sub.func = callbackfn;
+			event_sub.param = (void *)event;
+			ret = pmic_event_subscribe(event, event_sub);
+			pr_debug("subscribe done\n");
+			break;
+
+	case PMIC_UNSUBSCRIBE:
+			if (get_user(event, (int __user *)arg))
+				return -EFAULT;
+
+			event_sub.func = callbackfn;
+			event_sub.param = (void *)event;
+			ret = pmic_event_unsubscribe(event, event_sub);
+			pr_debug("unsubscribe done\n");
+			break;
+
+	case PMIC_NOTIFY_USER:
+			if (get_user(event, (int __user *)arg))
+				return -EFAULT;
+
+			event_sub.func = user_notify_callback;
+			event_sub.param = (void *)event;
+			ret = pmic_event_subscribe(event, event_sub);
+			break;
+
+	case PMIC_GET_NOTIFY:
+			CIRC_REMOVE(event, pmic_events, CIRC_BUF_MAX);
+			if (put_user(event, (int __user *)arg))
+				return -EFAULT;
+			break;
+
+	default:
+			printk(KERN_ERR "%d unsupported ioctl command\n", (int)cmd);
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*!
+ * This function implements the open method on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_dev_open(struct inode *inode, struct file *file)
+{
+	pr_debug("open\n");
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function implements the release method on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ *
+ * @return       This function returns 0.
+ */
+static int pmic_dev_free(struct inode *inode, struct file *file)
+{
+	pr_debug("free\n");
+	return PMIC_SUCCESS;
+}
+
+static int pmic_dev_fasync(int fd, struct file *filp, int mode)
+{
+	return fasync_helper(fd, filp, mode, &pmic_dev_queue);
+}
+
+/*!
+ * This structure defines file operations for a PMIC device.
+ */
+static struct file_operations pmic_fops = {
+	/*!
+	 * the owner
+	 */
+	.owner = THIS_MODULE,
+	/*!
+	 * the ioctl operation
+	 */
+	.ioctl = pmic_dev_ioctl,
+	/*!
+	 * the open operation
+	 */
+	.open = pmic_dev_open,
+	/*!
+	 * the release operation
+	 */
+	.release = pmic_dev_free,
+	/*!
+	 * the release operation
+	 */
+	.fasync = pmic_dev_fasync,
+};
+
+void pmic_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+/*!
+ * This function implements the init function of the PMIC char device.
+ * This function is called when the module is loaded. It registers
+ * the character device for PMIC to be used by user-space programs.
+ *
+ * @return       This function returns 0.
+ */
+static int __init pmic_dev_init(void)
+{
+	int ret = 0;
+	struct device	*pmic_device;
+
+	pmic_major = register_chrdev(0, PMIC_NAME, &pmic_fops);
+	if (pmic_major < 0) {
+		printk(KERN_ERR "unable to get a major for pmic\n");
+		return pmic_major;
+	}
+
+	ret = class_register(&pmic_class);
+	if (ret)
+		goto err;
+
+	pmic_device = device_create_drvdata(&pmic_class,
+			NULL, MKDEV(pmic_major, 0), NULL, PMIC_NAME);
+	if (IS_ERR(pmic_device)) {
+		printk(KERN_ERR "Error creating pmic class device.\n");
+		ret = PMIC_ERROR;
+		goto err1;
+	}
+
+
+	pmic_events.buf = kmalloc(CIRC_BUF_MAX * sizeof(char), GFP_KERNEL);
+	if (NULL == pmic_events.buf) {
+		ret = -ENOMEM;
+		goto err2;
+	}
+	pmic_events.head = pmic_events.tail = 0;
+
+	printk(KERN_INFO "PMIC Character device: successfully loaded\n");
+	return ret;
+
+err2:
+	device_unregister(pmic_device);
+err1:
+	class_unregister(&pmic_class);
+err:
+	unregister_chrdev(pmic_major, PMIC_NAME);
+	return ret;
+
+}
+
+/*!
+ * This function implements the exit function of the PMIC character device.
+ * This function is called when the module is unloaded. It unregisters
+ * the PMIC character device.
+ *
+ */
+static void __exit pmic_dev_exit(void)
+{
+	class_unregister(&pmic_class);
+
+	unregister_chrdev(pmic_major, PMIC_NAME);
+
+	printk(KERN_INFO "PMIC Character device: successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_dev_init);
+module_exit(pmic_dev_exit);
+
+MODULE_DESCRIPTION("PMIC Protocol /dev entries driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic.h b/drivers/mxc/pmic/core/pmic.h
new file mode 100644
index 0000000..aa85d52
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __PMIC_H__
+#define __PMIC_H__
+
+ /*!
+  * @file pmic.h
+  * @brief This file contains prototypes of all the functions to be
+  * defined for each PMIC chip. The implementation of these may differ
+  * from PMIC chip to PMIC chip.
+  *
+  * @ingroup PMIC_CORE
+  */
+
+#include <linux/spi/spi.h>
+
+#define MAX_ACTIVE_EVENTS		10
+
+/*!
+ * This structure is a way for the PMIC core driver to define their own
+ * \b spi_device structure. This structure includes the core \b spi_device
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and may contain other elements that are required by core driver.
+ */
+struct mxc_pmic {
+	/*!
+	 * Master side proxy for an SPI slave device(PMIC)
+	 */
+	struct spi_device *spi;
+};
+
+/*!
+ * This function is called to transfer data to PMIC on SPI.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ * @param    buf   	the pointer to the data buffer
+ * @param    len    	the length of the data to be transferred
+ *
+ * @return   Returns 0 on success -1 on failure.
+ */
+static inline int spi_rw(struct spi_device *spi, u8 *buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	if (spi_sync(spi, &m) != 0 || m.status != 0)
+		return PMIC_ERROR;
+	return len - m.actual_length;
+}
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param 	ver	pointer to the pmic_version_t structure
+ *
+ * @return       This function returns PMIC version.
+ */
+void pmic_get_revision(pmic_version_t *ver);
+
+/*!
+ * This function initializes the SPI device parameters for this PMIC.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ *
+ * @return   None
+ */
+int pmic_spi_setup(struct spi_device *spi);
+
+/*!
+ * This function initializes the PMIC registers.
+ *
+ * @return   None
+ */
+int pmic_init_registers(void);
+
+/*!
+ * This function reads the interrupt status registers of PMIC
+ * and determine the current active events.
+ *
+ * @param 	active_events array pointer to be used to return active
+ *		event numbers.
+ *
+ * @return       This function returns PMIC version.
+ */
+unsigned int pmic_get_active_events(unsigned int *active_events);
+
+/*!
+ * This function sets a bit in mask register of pmic to disable an event IT.
+ *
+ * @param	event 	the event to be masked
+ *
+ * @return     This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_mask(type_event event);
+
+/*!
+ * This function unsets a bit in mask register of pmic to unmask an event IT.
+ *
+ * @param	event 	the event to be unmasked
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_unmask(type_event event);
+
+static inline PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+
+#endif				/* __PMIC_H__ */
diff --git a/drivers/mxc/pmic/core/pmic_core_spi.c b/drivers/mxc/pmic/core/pmic_core_spi.c
new file mode 100644
index 0000000..18fabc1
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_spi.c
@@ -0,0 +1,322 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_core_spi.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. SPI
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+
+#include <mach/gpio.h>
+
+#include <asm/plat-mxc/pmic_external.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include "pmic.h"
+
+/*
+ * Global variables
+ */
+static pmic_version_t mxc_pmic_version;
+unsigned int active_events[MAX_ACTIVE_EVENTS];
+
+/*
+ * Static functions
+ */
+void pmic_bh_handler(struct work_struct *ignored);
+
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+
+/*
+ * External functions
+ */
+extern void pmic_event_list_init(void);
+extern void pmic_event_callback(type_event event);
+extern void gpio_pmic_active(void);
+
+/*!
+ * Bottom half handler of PMIC event handling.
+ */
+DECLARE_WORK(pmic_ws, pmic_bh_handler);
+
+/*!
+ * This function registers platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_register(void)
+{
+	platform_device_register(&adc_ldm);
+	platform_device_register(&battery_ldm);
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+}
+
+/*!
+ * This function is called when pmic interrupt occurs on the processor.
+ * It is the interrupt handler for the pmic module.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t pmic_irq_handler(int irq, void *dev_id)
+{
+	/* prepare a task */
+	schedule_work(&pmic_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is the bottom half handler of the PMIC interrupt.
+ * It checks for active events and launches callback for the
+ * active events.
+ */
+void pmic_bh_handler(struct work_struct *ignored)
+{
+	unsigned int loop;
+	unsigned int count = 0;
+
+	count = pmic_get_active_events(active_events);
+
+	for (loop = 0; loop < count; loop++)
+		pmic_event_callback(active_events[loop]);
+
+	return;
+}
+
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+
+pmic_version_t pmic_get_version(void)
+{
+	return mxc_pmic_version;
+}
+EXPORT_SYMBOL(pmic_get_version);
+
+/*!
+ * This function puts the SPI slave device in low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ * @param	message	the power state to enter
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_suspend(struct spi_device *spi, pm_message_t message)
+{
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function brings the SPI slave device back from low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_resume(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit pmic_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	printk("entered %s\n", __func__);
+
+	if (!strcmp(spi->dev.bus_id, PMIC_ARBITRATION)) {
+		if (PMIC_SUCCESS != pmic_fix_arbitration(spi)) {
+			dev_err((struct device *)spi,
+				"Unable to fix arbitration!! Access Failed\n");
+			return -EACCES;
+		}
+		return PMIC_SUCCESS;
+	}
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_spi_setup(spi);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	gpio_pmic_active();
+
+	/* Get the PMIC Version */
+	pmic_get_revision(&mxc_pmic_version);
+	if (mxc_pmic_version.revision < 0) {
+		dev_err((struct device *)spi,
+			"PMIC not detected!!! Access Failed\n");
+		return -ENODEV;
+	} else {
+		dev_dbg((struct device *)spi,
+			"Detected pmic core IC version number is %d\n",
+			mxc_pmic_version.revision);
+	}
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_init_registers();
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	/* Set and install PMIC IRQ handler */
+	set_irq_type(spi->irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(spi->irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
+	if (ret) {
+		dev_err((struct device *)spi, "gpio1: irq%d error.", spi->irq);
+		return ret;
+	}
+
+	pmic_pdev_register();
+
+	printk(KERN_INFO "Device %s probed\n", spi->dev.bus_id);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is called whenever the SPI slave device is removed.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devexit pmic_remove(struct spi_device *spi)
+{
+	free_irq(spi->irq, 0);
+
+	pmic_pdev_unregister();
+
+	printk(KERN_INFO "Device %s removed\n", spi->dev.bus_id);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct spi_driver pmic_driver = {
+	.driver = {
+		   .name = "pmic_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = pmic_probe,
+	.remove = __devexit_p(pmic_remove),
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+/*!
+ * This function implements the init function of the PMIC device.
+ * This function is called when the module is loaded. It registers
+ * the PMIC Protocol driver.
+ *
+ * @return       This function returns 0.
+ */
+static int __init pmic_init(void)
+{
+	pr_debug("Registering the PMIC Protocol Driver\n");
+	return spi_register_driver(&pmic_driver);
+}
+
+/*!
+ * This function implements the exit function of the PMIC device.
+ * This function is called when the module is unloaded. It unregisters
+ * the PMIC Protocol driver.
+ *
+ */
+static void __exit pmic_exit(void)
+{
+	pr_debug("Unregistering the PMIC Protocol Driver\n");
+	spi_unregister_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic_event.c b/drivers/mxc/pmic/core/pmic_event.c
new file mode 100644
index 0000000..78cf5b7
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_event.c
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_event.c
+ * @brief This file manage all event of PMIC component.
+ *
+ * It contains event subscription, unsubscription and callback
+ * launch methods implemeted.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/uaccess.h>
+
+#include <asm/plat-mxc/pmic_external.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include "pmic.h"
+
+/*!
+ * This structure is used to keep a list of subscribed
+ * callbacks for an event.
+ */
+typedef struct {
+	/*!
+	 * Keeps a list of subscribed clients to an event.
+	 */
+	struct list_head list;
+
+	/*!
+	 * Callback function with parameter, called when event occurs
+	 */
+	pmic_event_callback_t callback;
+} pmic_event_callback_list_t;
+
+/* Create a mutex to be used to prevent concurrent access to the event list */
+static DECLARE_MUTEX(event_mutex);
+
+/* This is a pointer to the event handler array. It defines the currently
+ * active set of events and user-defined callback functions.
+ */
+static struct list_head pmic_events[PMIC_MAX_EVENTS];
+
+/*!
+ * This function initializes event list for PMIC event handling.
+ *
+ */
+void pmic_event_list_init(void)
+{
+	int i;
+
+	for (i = 0; i < PMIC_MAX_EVENTS; i++)
+		INIT_LIST_HEAD(&pmic_events[i]);
+
+	sema_init(&event_mutex, 1);
+	return;
+}
+
+/*!
+ * This function is used to subscribe on an event.
+ *
+ * @param	event   the event number to be subscribed
+ * @param	callback the callback funtion to be subscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback)
+{
+	pmic_event_callback_list_t *new = NULL;
+
+	pr_debug("Event:%d Subscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Create a new linked list entry */
+	new = kmalloc(sizeof(pmic_event_callback_list_t), GFP_KERNEL);
+	if (NULL == new) {
+		return -ENOMEM;
+	}
+	/* Initialize the list node fields */
+	new->callback.func = callback.func;
+	new->callback.param = callback.param;
+	INIT_LIST_HEAD(&new->list);
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex)) {
+		kfree(new);
+		return PMIC_SYSTEM_ERROR_EINTR;
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_unmask(event) != PMIC_SUCCESS) {
+			kfree(new);
+			up(&event_mutex);
+			return PMIC_ERROR;
+		}
+	}
+
+	/* Add this entry to the event list */
+	list_add_tail(&new->list, &pmic_events[event]);
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_event_subscribe);
+
+/*!
+ * This function is used to unsubscribe on an event.
+ *
+ * @param	event   the event number to be unsubscribed
+ * @param	callback the callback funtion to be unsubscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback)
+{
+	struct list_head *p;
+	struct list_head *n;
+	pmic_event_callback_list_t *temp = NULL;
+	int ret = PMIC_EVENT_NOT_SUBSCRIBED;
+
+	pr_debug("Event:%d Unsubscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Find the entry in the list */
+	list_for_each_safe(p, n, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		if (temp->callback.func == callback.func
+		    && temp->callback.param == callback.param) {
+			/* Remove the entry from the list */
+			list_del(p);
+			kfree(temp);
+			ret = PMIC_SUCCESS;
+			break;
+		}
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_mask(event) != PMIC_SUCCESS) {
+			ret = PMIC_UNSUBSCRIBE_ERROR;
+		}
+	}
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_event_unsubscribe);
+
+/*!
+ * This function calls all callback of a specific event.
+ *
+ * @param	event   the active event number
+ *
+ * @return 	None
+ */
+void pmic_event_callback(type_event event)
+{
+	struct list_head *p;
+	pmic_event_callback_list_t *temp = NULL;
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex))
+		return;
+
+	if (list_empty(&pmic_events[event])) {
+		pr_debug("PMIC Event:%d detected. No callback subscribed\n",
+			 event);
+		up(&event_mutex);
+		return;
+	}
+
+	list_for_each(p, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		temp->callback.func(temp->callback.param);
+	}
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return;
+
+}
diff --git a/drivers/mxc/pmic/core/pmic_external.c b/drivers/mxc/pmic/core/pmic_external.c
new file mode 100644
index 0000000..3aa511e
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_external.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_external.c
+ * @brief This file contains all external functions of PMIC drivers.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/plat-mxc/pmic_external.h>
+#include <asm/plat-mxc/pmic_status.h>
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  return value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	*reg_value = (temp & reg_mask);
+
+	pr_debug("Read REG[ %d ] = 0x%x\n", reg, *reg_value);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_read_reg);
+
+/*!
+ * This function is called by PMIC clients to write a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	temp = (temp & (~reg_mask)) | reg_value;
+
+#ifdef CONFIG_MXC_PMIC_MC13783
+	if (reg == REG_POWER_MISCELLANEOUS)
+		temp &= 0xFFFE7FFF;
+#endif
+
+	ret = pmic_write(reg, temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	pr_debug("Write REG[ %d ] = 0x%x\n", reg, reg_value);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_write_reg);
diff --git a/drivers/mxc/pmic/mc13783/Kconfig b/drivers/mxc/pmic/mc13783/Kconfig
new file mode 100644
index 0000000..d9d05cf
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/Kconfig
@@ -0,0 +1,55 @@
+#
+# PMIC Modules configuration
+#
+
+config MXC_MC13783_ADC
+	tristate "MC13783 ADC support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 ADC module driver. This module provides kernel API
+	  for the ADC system of MC13783.
+	  It controls also the touch screen interface.
+	  If you want MC13783 ADC support, you should say Y here
+
+config MXC_MC13783_AUDIO
+	tristate "MC13783 Audio support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 audio module driver. This module provides kernel API
+	  for audio part of MC13783.
+	  If you want MC13783 audio support, you should say Y here
+config MXC_MC13783_RTC
+	tristate "MC13783 Real Time Clock (RTC) support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 RTC module driver. This module provides kernel API
+	  for RTC part of MC13783.
+	  If you want MC13783 RTC support, you should say Y here
+config MXC_MC13783_LIGHT
+	tristate "MC13783 Light and Backlight support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 Light module driver. This module provides kernel API
+	  for led and backlight control part of MC13783.
+	  If you want MC13783 Light support, you should say Y here
+config MXC_MC13783_BATTERY
+	tristate "MC13783 Battery API support"
+	depends on MXC_PMIC_MC13783
+	help
+	This is the MC13783 battery module driver. This module provides kernel API
+	for battery control part of MC13783.
+	If you want MC13783 battery support, you should say Y here
+config MXC_MC13783_CONNECTIVITY
+	tristate "MC13783 Connectivity API support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 connectivity module driver. This module provides kernel API
+	  for USB/RS232 connectivity control part of MC13783.
+	  If you want MC13783 connectivity support, you should say Y here
+config MXC_MC13783_POWER
+	tristate "MC13783 Power API support"
+	depends on MXC_PMIC_MC13783
+	help
+	  This is the MC13783 power and supplies module driver. This module provides kernel API
+	  for power and regulator control part of MC13783.
+	  If you want MC13783 power support, you should say Y here
diff --git a/drivers/mxc/pmic/mc13783/Makefile b/drivers/mxc/pmic/mc13783/Makefile
new file mode 100644
index 0000000..7bbba23
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for the mc13783 pmic drivers.
+#
+
+obj-$(CONFIG_MXC_MC13783_ADC) += pmic_adc-mod.o
+obj-$(CONFIG_MXC_MC13783_AUDIO) += pmic_audio-mod.o
+obj-$(CONFIG_MXC_MC13783_RTC) += pmic_rtc-mod.o
+obj-$(CONFIG_MXC_MC13783_LIGHT) += pmic_light-mod.o
+obj-$(CONFIG_MXC_MC13783_BATTERY) += pmic_battery-mod.o
+obj-$(CONFIG_MXC_MC13783_CONNECTIVITY) += pmic_convity-mod.o
+obj-$(CONFIG_MXC_MC13783_POWER) += pmic_power-mod.o
+pmic_adc-mod-objs := pmic_adc.o
+pmic_audio-mod-objs := pmic_audio.o
+pmic_rtc-mod-objs := pmic_rtc.o
+pmic_light-mod-objs := pmic_light.o
+pmic_battery-mod-objs := pmic_battery.o
+pmic_convity-mod-objs := pmic_convity.o
+pmic_power-mod-objs := pmic_power.o
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc.c b/drivers/mxc/pmic/mc13783/pmic_adc.c
new file mode 100644
index 0000000..16effe8
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_adc.c
@@ -0,0 +1,1481 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_adc.c
+ * @brief This is the main file of PMIC(mc13783) ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+
+#include <asm/plat-mxc/pmic_adc.h>
+#include <asm/plat-mxc/pmic_power.h>
+
+#include "../core/pmic.h"
+#include "pmic_adc_defs.h"
+
+#define NB_ADC_REG      5
+
+static int pmic_adc_major;
+
+/* internal function */
+static void callback_tsi(void *);
+static void callback_adcdone(void *);
+static void callback_adcbisdone(void *);
+static void callback_adc_comp_high(void *);
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the adc devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used by blocking application calls
+ */
+static wait_queue_head_t suspendq;
+
+void pmic_adc_class_dev_release(struct device *dev);
+
+static struct class pmic_adc_class = {
+	.owner		= THIS_MODULE,
+	.name		= "pmic_adc",
+	.dev_release = pmic_adc_class_dev_release,
+};
+
+static DECLARE_COMPLETION(adcdone_it);
+static DECLARE_COMPLETION(adcbisdone_it);
+static DECLARE_COMPLETION(adc_tsi);
+static pmic_event_callback_t tsi_event;
+static pmic_event_callback_t event_adc;
+static pmic_event_callback_t event_adc_bis;
+static pmic_event_callback_t adc_comp_h;
+static bool data_ready_adc_1;
+static bool data_ready_adc_2;
+static bool adc_ts;
+static bool wait_ts;
+static bool monitor_en;
+static bool monitor_adc;
+static t_check_mode wcomp_mode;
+void (*monitoring_cb) (void);	/*call back to be */
+/* called when event is detected. */
+
+static DECLARE_WAIT_QUEUE_HEAD(queue_adc_busy);
+static t_adc_state adc_dev[2];
+
+static unsigned channel_num[] = {
+	0, 1, 3, 4, 2, 12, 13, 14, 15, -1, 5, 6, 7,
+	8, 9, 10, 11, 7, 6, -1, -1, -1, -1, 5, 7
+};
+
+/*!
+ * This is the suspend of power management
+ * for the mc13783 ADC API.
+ * It supports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	unsigned int reg_value = 0;
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_2, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_4, reg_value, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the
+ * mc13783 adc API.
+ * It supports RESTORE state.
+ *
+ * @param        pdev           the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_resume(struct platform_device *pdev)
+{
+	/* nothing for mc13783 adc */
+	suspend_flag = 0;
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*
+ * Call back functions
+ */
+
+/*!
+ * This is the callback function called on TSI
+ * mc13783 event, used in synchronous call.
+ */
+static void callback_tsi(void *unused)
+{
+	pr_debug("*** TSI IT mc13783 PMIC_ADC_GET_TOUCH_SAMPLE ***\n");
+	if (wait_ts) {
+		complete(&adc_tsi);
+		pmic_event_mask(EVENT_TSI);
+	}
+}
+
+/*!
+ * This is the callback function called on ADCDone
+ * mc13783 event.
+ */
+static void callback_adcdone(void *unused)
+{
+	if (data_ready_adc_1)
+		complete(&adcdone_it);
+}
+
+/*!
+ * This is the callback function called on
+ * ADCDone mc13783 event.
+ */
+static void callback_adcbisdone(void *unused)
+{
+	pr_debug("* adcdone bis it callback *\n");
+	if (data_ready_adc_2)
+		complete(&adcbisdone_it);
+}
+
+/*!
+ * This is the callback function called on mc13783 event.
+ */
+static void callback_adc_comp_high(void *unused)
+{
+	pr_debug("* adc comp it high *\n");
+	if (wcomp_mode == CHECK_HIGH || wcomp_mode == CHECK_LOW_OR_HIGH) {
+		/* launch callback */
+		if (monitoring_cb != NULL)
+			monitoring_cb();
+	}
+}
+
+/*!
+ * This function performs filtering and rejection
+ * of excessive noise prone
+ * samples.
+ *
+ * @param        ts_curr     Touch screen value
+ *
+ * @return       This function returns 0 on success, -1 otherwise.
+ */
+static int pmic_adc_filter(t_touch_screen *ts_curr)
+{
+	unsigned int ydiff1, ydiff2, ydiff3, xdiff1, xdiff2, xdiff3;
+	unsigned int sample_sumx, sample_sumy;
+	static unsigned int prev_x[FILTLEN], prev_y[FILTLEN];
+	int index = 0;
+	unsigned int y_curr, x_curr;
+	static int filt_count;
+	/* Added a variable filt_type to decide
+	 * filtering at run-time
+	 * */
+	unsigned int filt_type = 0;
+
+	if (ts_curr->contact_resistance == 0) {
+		ts_curr->x_position = 0;
+		ts_curr->y_position = 0;
+		filt_count = 0;
+		return 0;
+	}
+
+	ydiff1 = abs(ts_curr->y_position1 - ts_curr->y_position2);
+	ydiff2 = abs(ts_curr->y_position2 - ts_curr->y_position3);
+	ydiff3 = abs(ts_curr->y_position1 - ts_curr->y_position3);
+	if ((ydiff1 > DELTA_Y_MAX) ||
+	    (ydiff2 > DELTA_Y_MAX) ||
+		(ydiff3 > DELTA_Y_MAX)) {
+		pr_debug("pmic_adc_filter: Ret pos 1\n");
+		return -1;
+	}
+
+	xdiff1 = abs(ts_curr->x_position1 - ts_curr->x_position2);
+	xdiff2 = abs(ts_curr->x_position2 - ts_curr->x_position3);
+	xdiff3 = abs(ts_curr->x_position1 - ts_curr->x_position3);
+
+	if ((xdiff1 > DELTA_X_MAX) ||
+	    (xdiff2 > DELTA_X_MAX) ||
+		(xdiff3 > DELTA_X_MAX)) {
+		pr_debug("mc13783_adc_filter: Ret pos 2\n");
+		return -1;
+	}
+	/* Compute two closer values among the
+	 * three available Y readouts
+	 * */
+
+	if (ydiff1 < ydiff2) {
+		if (ydiff1 < ydiff3)
+			sample_sumy = ts_curr->y_position1 +
+			    ts_curr->y_position2;
+		else
+			sample_sumy = ts_curr->y_position1 +
+			    ts_curr->y_position3;
+	} else {
+		if (ydiff2 < ydiff3)
+			sample_sumy = ts_curr->y_position2 +
+			    ts_curr->y_position3;
+		else
+			sample_sumy = ts_curr->y_position1 +
+			    ts_curr->y_position3;
+	}
+
+	/*
+	 * Compute two closer values among the three available X
+	 * readouts
+	 */
+	if (xdiff1 < xdiff2) {
+		if (xdiff1 < xdiff3)
+			sample_sumx = ts_curr->x_position1 +
+			    ts_curr->x_position2;
+		else
+			sample_sumx = ts_curr->x_position1 +
+			    ts_curr->x_position3;
+	} else {
+		if (xdiff2 < xdiff3)
+			sample_sumx = ts_curr->x_position2 +
+			    ts_curr->x_position3;
+		else
+			sample_sumx = ts_curr->x_position1 +
+			    ts_curr->x_position3;
+	}
+	/*
+	 * Wait FILTER_MIN_DELAY number of samples to restart
+	 * filtering
+	 */
+	if (filt_count < FILTER_MIN_DELAY) {
+		/*
+		 * Current output is the average of the two closer
+		 * values and no filtering is used
+		 */
+		y_curr = (sample_sumy / 2);
+		x_curr = (sample_sumx / 2);
+		ts_curr->y_position = y_curr;
+		ts_curr->x_position = x_curr;
+		filt_count++;
+	} else {
+		if (abs(sample_sumx - (prev_x[0] + prev_x[1])) >
+		    (DELTA_X_MAX * 16)) {
+			pr_debug("pmic_adc_filter: : Ret pos 3\n");
+			return -1;
+		}
+		if (abs(sample_sumy - (prev_y[0] + prev_y[1])) >
+		    (DELTA_Y_MAX * 16))
+			return -1;
+
+		sample_sumy /= 2;
+		sample_sumx /= 2;
+		/* Use hard filtering if the sample difference < 10 */
+		if ((abs(sample_sumy - prev_y[0]) > 10) ||
+		    (abs(sample_sumx - prev_x[0]) > 10))
+			filt_type = 1;
+
+		/*
+		 * Current outputs are the average of three previous
+		 * values and the present readout
+		 */
+		y_curr = sample_sumy;
+		for (index = 0; index < FILTLEN; index++) {
+			if (filt_type == 0)
+				y_curr = y_curr + (prev_y[index]);
+			else
+				y_curr = y_curr + (prev_y[index] / 3);
+		}
+		if (filt_type == 0)
+			y_curr = y_curr >> 2;
+		else
+			y_curr = y_curr >> 1;
+
+		ts_curr->y_position = y_curr;
+
+		x_curr = sample_sumx;
+		for (index = 0; index < FILTLEN; index++) {
+			if (filt_type == 0)
+				x_curr = x_curr + (prev_x[index]);
+			else
+				x_curr = x_curr + (prev_x[index] / 3);
+		}
+		if (filt_type == 0)
+			x_curr = x_curr >> 2;
+		else
+			x_curr = x_curr >> 1;
+
+		ts_curr->x_position = x_curr;
+
+	}
+
+	/* Update previous X and Y values */
+	for (index = (FILTLEN - 1); index > 0; index--) {
+		prev_x[index] = prev_x[index - 1];
+		prev_y[index] = prev_y[index - 1];
+	}
+
+	/*
+	 * Current output will be the most recent past for the
+	 * next sample
+	 */
+	prev_y[0] = y_curr;
+	prev_x[0] = x_curr;
+
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a
+ * MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_adc_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq,
+					(suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+
+	pr_debug("mc13783_adc : mc13783_adc_open()\n");
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_adc_free(struct inode *inode, struct file *file)
+{
+	pr_debug("mc13783_adc : mc13783_adc_free()\n");
+	return 0;
+}
+
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+int pmic_adc_init(void)
+{
+	unsigned int reg_value = 0, i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	for (i = 0; i < ADC_NB_AVAILABLE; i++)
+		adc_dev[i] = ADC_FREE;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_2, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_4, reg_value, PMIC_ALL_BITS));
+
+	data_ready_adc_1 = false;
+	data_ready_adc_2 = false;
+	adc_ts = false;
+	wait_ts = false;
+	monitor_en = false;
+	monitor_adc = false;
+	wcomp_mode = CHECK_LOW;
+	monitoring_cb = NULL;
+	/* sub to ADCDone IT */
+	event_adc.param = NULL;
+	event_adc.func = callback_adcdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCDONEI, event_adc));
+
+	/* sub to ADCDoneBis IT */
+	event_adc_bis.param = NULL;
+	event_adc_bis.func = callback_adcbisdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCBISDONEI, event_adc_bis));
+
+	/* sub to Touch Screen IT */
+	tsi_event.param = NULL;
+	tsi_event.func = callback_tsi;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TSI, tsi_event));
+
+	/* ADC reading above high limit */
+	adc_comp_h.param = NULL;
+	adc_comp_h.func = callback_adc_comp_high;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_WHIGHI, adc_comp_h));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_init);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void)
+{
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCDONEI, event_adc));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCBISDONEI, event_adc_bis));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TSI, tsi_event));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_WHIGHI, adc_comp_h));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_deinit);
+
+/*!
+ * This function initializes adc_param structure.
+ *
+ * @param        adc_param     Structure to be initialized.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_init_param(t_adc_param *adc_param)
+{
+	int i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	adc_param->delay = 0;
+	adc_param->conv_delay = false;
+	adc_param->single_channel = false;
+	adc_param->group = false;
+	adc_param->channel_0 = BATTERY_VOLTAGE;
+	adc_param->channel_1 = BATTERY_VOLTAGE;
+	adc_param->read_mode = 0;
+	adc_param->wait_tsi = 0;
+	adc_param->chrgraw_devide_5 = true;
+	adc_param->read_ts = false;
+	adc_param->ts_value.x_position = 0;
+	adc_param->ts_value.y_position = 0;
+	adc_param->ts_value.contact_resistance = 0;
+
+	for (i = 0; i <= MAX_CHANNEL; i++)
+		adc_param->value[i] = 0;
+
+	return 0;
+}
+
+/*!
+ * This function starts the convert.
+ *
+ * @param        adc_param      contains all
+ * adc configuration and return value.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS mc13783_adc_convert(t_adc_param *adc_param)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, reg_1 = 0, result_reg =
+	    0, i = 0;
+	unsigned int result = 0, temp = 0;
+	pmic_version_t mc13783_ver;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (adc_param->wait_tsi) {
+		/* we need to set ADCEN 1 for TSI interrupt on mc13783 1.x */
+		/* configure adc to wait tsi interrupt */
+		INIT_COMPLETION(adc_tsi);
+		pr_debug("mc13783 ADC - pmic_write_reg ....\n");
+		adc_0_reg = 0x001c00 | (ADC_BIS * use_bis);
+		pmic_event_unmask(EVENT_TSI);
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+		adc_1_reg = 0x200001 | (ADC_BIS * adc_ts);
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+		pr_debug("wait tsi ....\n");
+		wait_ts = true;
+		wait_for_completion_interruptible(&adc_tsi);
+		wait_ts = false;
+	}
+	use_bis = mc13783_adc_request();
+	if (use_bis < 0) {
+		pr_debug("process has received a signal and got interrupted\n");
+		return -EINTR;
+	}
+
+	/* CONFIGURE ADC REG 0 */
+	adc_0_reg = 0;
+	adc_1_reg = 0;
+	if (adc_param->read_ts == false) {
+		adc_0_reg = adc_param->read_mode & 0x00003F;
+		/* add auto inc */
+		adc_0_reg |= ADC_INC;
+		if (use_bis)
+			/* add adc bis */
+			adc_0_reg |= ADC_BIS;
+
+		mc13783_ver = pmic_get_version();
+		if (mc13783_ver.revision >= 20) {
+			if (adc_param->chrgraw_devide_5)
+				adc_0_reg |= ADC_CHRGRAW_D5;
+		}
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		if (adc_param->conv_delay)
+			adc_1_reg |= ADC_ATO;
+
+		if (adc_param->group)
+			adc_1_reg |= ADC_ADSEL;
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		adc_1_reg |= (adc_param->channel_0 << ADC_CH_0_POS) &
+		    ADC_CH_0_MASK;
+		adc_1_reg |= (adc_param->channel_1 << ADC_CH_1_POS) &
+		    ADC_CH_1_MASK;
+	} else
+		adc_0_reg = (0x003c00 | (ADC_BIS * use_bis) | ADC_INC);
+
+	pr_debug("Write Reg %i = %x\n", REG_ADC_0, adc_0_reg);
+	/*Change has been made here */
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg,
+				   ADC_INC | ADC_BIS | ADC_CHRGRAW_D5 |
+				   0xfff00ff));
+	/* CONFIGURE ADC REG 1 */
+	if (adc_param->read_ts == false) {
+		adc_1_reg |= ADC_NO_ADTRIG;
+		adc_1_reg |= ADC_EN;
+		adc_1_reg |= (adc_param->delay << ADC_DELAY_POS) &
+		    ADC_DELAY_MASK;
+		if (use_bis)
+			adc_1_reg |= ADC_BIS;
+	} else
+		/* configure and start convert to read x and y position */
+		/* configure to read 2 value in channel selection 1 & 2 */
+		adc_1_reg = 0x100409 | (ADC_BIS * use_bis) | ADC_NO_ADTRIG;
+
+	reg_1 = adc_1_reg;
+	if (use_bis == 0) {
+		data_ready_adc_1 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_1 = true;
+		pr_debug("Write Reg %i = %x\n", REG_ADC_1, adc_1_reg);
+		INIT_COMPLETION(adcdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg,
+					   ADC_SGL_CH | ADC_ATO | ADC_ADSEL
+					   | ADC_CH_0_MASK | ADC_CH_1_MASK |
+					   ADC_NO_ADTRIG | ADC_EN |
+					   ADC_DELAY_MASK | ASC_ADC | ADC_BIS));
+		pr_debug("wait adc done \n");
+		wait_for_completion_interruptible(&adcdone_it);
+		data_ready_adc_1 = false;
+	} else {
+		data_ready_adc_2 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_2 = true;
+		INIT_COMPLETION(adcbisdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, 0xFFFFFF));
+		temp = 0x800000;
+		CHECK_ERROR(pmic_write_reg(REG_ADC_3, temp, 0xFFFFFF));
+		temp = 0x001000;
+		pmic_write_reg(REG_ARBITRATION_PERIPHERAL_AUDIO, temp,
+			       0xFFFFFF);
+		pr_debug("wait adc done bis\n");
+		wait_for_completion_interruptible(&adcbisdone_it);
+		data_ready_adc_2 = false;
+	}
+	/* read result and store in adc_param */
+	result = 0;
+	if (use_bis == 0)
+		result_reg = REG_ADC_2;
+	else
+		result_reg = REG_ADC_4;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, 4 << ADC_CH_1_POS,
+				   ADC_CH_0_MASK | ADC_CH_1_MASK));
+
+	for (i = 0; i <= 3; i++) {
+		CHECK_ERROR(pmic_read_reg(result_reg, &result, PMIC_ALL_BITS));
+		pr_debug("result %i = %x\n", result_reg, result);
+		adc_param->value[i] = ((result & ADD1_RESULT_MASK) >> 2);
+		adc_param->value[i + 4] = ((result & ADD2_RESULT_MASK) >> 14);
+	}
+	if (adc_param->read_ts) {
+		adc_param->ts_value.x_position = adc_param->value[2];
+		adc_param->ts_value.x_position1 = adc_param->value[0];
+		adc_param->ts_value.x_position2 = adc_param->value[1];
+		adc_param->ts_value.x_position3 = adc_param->value[2];
+		adc_param->ts_value.y_position1 = adc_param->value[3];
+		adc_param->ts_value.y_position2 = adc_param->value[4];
+		adc_param->ts_value.y_position3 = adc_param->value[5];
+		adc_param->ts_value.y_position = adc_param->value[5];
+		adc_param->ts_value.contact_resistance = adc_param->value[6];
+
+	}
+
+	mc13783_adc_release(use_bis);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function select the required read_mode for a specific channel.
+ *
+ * @param        channel   The channel to be sampled
+ *
+ * @return       This function returns the requires read_mode
+ */
+t_reading_mode mc13783_set_read_mode(t_channel channel)
+{
+	t_reading_mode read_mode = 0;
+
+	switch (channel) {
+	case LICELL:
+		read_mode = M_LITHIUM_CELL;
+		break;
+	case CHARGE_CURRENT:
+		read_mode = M_CHARGE_CURRENT;
+		break;
+	case BATTERY_CURRENT:
+		read_mode = M_BATTERY_CURRENT;
+		break;
+	case THERMISTOR:
+		read_mode = M_THERMISTOR;
+		break;
+	case DIE_TEMP:
+		read_mode = M_DIE_TEMPERATURE;
+		break;
+	case USB_ID:
+		read_mode = M_UID;
+		break;
+	default:
+		read_mode = 0;
+	}
+
+	return read_mode;
+}
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	PMIC_STATUS ret;
+
+	if (suspend_flag == 1) {
+		return -EBUSY;
+	}
+
+	channel = channel_num[channel];
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert\n");
+	adc_param.read_ts = false;
+	adc_param.read_mode = mc13783_set_read_mode(channel);
+
+	adc_param.single_channel = true;
+	/* Find the group */
+	if ((channel >= 0) && (channel <= 7)) {
+		adc_param.channel_0 = channel;
+		adc_param.group = false;
+	} else if ((channel >= 8) && (channel <= 15)) {
+		adc_param.channel_0 = channel & 0x07;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+	ret = mc13783_adc_convert(&adc_param);
+	*result = adc_param.value[0];
+	return ret;
+}
+EXPORT_SYMBOL(pmic_adc_convert);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1) {
+		return -EBUSY;
+	}
+
+	channel = channel_num[channel];
+
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_8x\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13783_set_read_mode(channel);
+	if ((channel >= 0) && (channel <= 7)) {
+		adc_param.channel_0 = channel;
+		adc_param.channel_1 = channel;
+		adc_param.group = false;
+	} else if ((channel >= 8) && (channel <= 15)) {
+		adc_param.channel_0 = channel & 0x07;
+		adc_param.channel_1 = channel & 0x07;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	ret = mc13783_adc_convert(&adc_param);
+	for (i = 0; i <= 7; i++) {
+		result[i] = adc_param.value[i];
+	}
+	return ret;
+}
+EXPORT_SYMBOL(pmic_adc_convert_8x);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1) {
+		return -EBUSY;
+	}
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_multichnnel\n");
+
+	channels = channel_num[channels];
+
+	if (channels == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	adc_param.read_ts = false;
+	adc_param.single_channel = false;
+	if ((channels >= 0) && (channels <= 7)) {
+		adc_param.channel_0 = channels;
+		adc_param.channel_1 = ((channels + 4) % 4) + 4;
+		adc_param.group = false;
+	} else if ((channels >= 8) && (channels <= 15)) {
+		channels = channels & 0x07;
+		adc_param.channel_0 = channels;
+		adc_param.channel_1 = ((channels + 4) % 4) + 4;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+	adc_param.read_mode = 0x00003f;
+	adc_param.read_ts = false;
+	ret = mc13783_adc_convert(&adc_param);
+
+	for (i = 0; i <= 7; i++) {
+		result[i] = adc_param.value[i];
+	}
+	return ret;
+}
+EXPORT_SYMBOL(pmic_adc_convert_multichnnel);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode)
+{
+	if (suspend_flag == 1) {
+		return -EBUSY;
+	}
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0,
+				   BITFVAL(MC13783_ADC0_TS_M, touch_mode),
+				   BITFMASK(MC13783_ADC0_TS_M)));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_set_touch_mode);
+
+/*!
+ * This function retrieves the current touch screen
+ * operation mode.
+ *
+ * @param        touch_mode   Pointer to the
+ * retrieved touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode)
+{
+	unsigned int value;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(REG_ADC_0, &value, PMIC_ALL_BITS));
+
+	*touch_mode = BITFEXT(value, MC13783_ADC0_TS_M);
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_get_touch_mode);
+
+/*!
+ * This function retrieves the current touch
+ * screen (X,Y) coordinates.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	indicates whether this call
+ * must block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *touch_sample, int wait)
+{
+	mc13783_adc_read_ts(touch_sample, wait);
+	pmic_adc_filter(touch_sample);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_get_touch_sample);
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        ts_value    return value of touch screen
+ * @param        wait_tsi    if true, this function
+ * is synchronous (wait in TSI event).
+ *
+ * @return       This function returns 0.
+ */
+PMIC_STATUS mc13783_adc_read_ts(t_touch_screen *ts_value, int wait_tsi)
+{
+	t_adc_param param;
+
+	pr_debug("mc13783_adc : mc13783_adc_read_ts\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (wait_ts) {
+		pr_debug("mc13783_adc : error TS busy \n");
+		return PMIC_ERROR;
+	}
+	mc13783_adc_init_param(&param);
+	param.wait_tsi = wait_tsi;
+	param.read_ts = true;
+	mc13783_adc_convert(&param);
+	/* check if x-y is ok */
+	if ((param.ts_value.x_position1 < TS_X_MAX) &&
+	    (param.ts_value.x_position1 >= TS_X_MIN) &&
+	    (param.ts_value.y_position1 < TS_Y_MAX) &&
+	    (param.ts_value.y_position1 >= TS_Y_MIN) &&
+	    (param.ts_value.x_position2 < TS_X_MAX) &&
+	    (param.ts_value.x_position2 >= TS_X_MIN) &&
+	    (param.ts_value.y_position2 < TS_Y_MAX) &&
+	    (param.ts_value.y_position2 >= TS_Y_MIN) &&
+	    (param.ts_value.x_position3 < TS_X_MAX) &&
+	    (param.ts_value.x_position3 >= TS_X_MIN) &&
+	    (param.ts_value.y_position3 < TS_Y_MAX) &&
+	    (param.ts_value.y_position3 >= TS_Y_MIN)) {
+		ts_value->x_position = param.ts_value.x_position;
+		ts_value->x_position1 = param.ts_value.x_position1;
+		ts_value->x_position2 = param.ts_value.x_position2;
+		ts_value->x_position3 = param.ts_value.x_position3;
+		ts_value->y_position = param.ts_value.y_position;
+		ts_value->y_position1 = param.ts_value.y_position1;
+		ts_value->y_position2 = param.ts_value.y_position2;
+		ts_value->y_position3 = param.ts_value.y_position3;
+		ts_value->contact_resistance =
+		    param.ts_value.contact_resistance + 1;
+
+	} else {
+		ts_value->x_position = 0;
+		ts_value->y_position = 0;
+		ts_value->contact_resistance = 0;
+
+	}
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *               if \a mode = ADC_8CHAN_1X, the result is \n
+ *               result[0] = (BATTP - BATT_I) \n
+ *               if \a mode = ADC_1CHAN_8X, the result is \n
+ *               result[0] = BATTP \n
+ *               result[1] = BATT_I \n
+ *               result[2] = BATTP \n
+ *               result[3] = BATT_I \n
+ *               result[4] = BATTP \n
+ *               result[5] = BATT_I \n
+ *               result[6] = BATTP \n
+ *               result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result)
+{
+	PMIC_STATUS ret;
+	t_channel channel;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = BATTERY_CURRENT;
+	if (mode == ADC_8CHAN_1X)
+		ret = pmic_adc_convert(channel, result);
+	else
+		ret = pmic_adc_convert_8x(channel, result);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_adc_get_battery_current);
+
+/*!
+ * This function request a ADC.
+ *
+ * @return      This function returns index of ADC to be
+ * used (0 or 1) if successful. return -1 if error.
+ * */
+int mc13783_adc_request(void)
+{
+	int adc_index = -1;
+	if (((adc_dev[0] == ADC_USED) && (adc_dev[1] == ADC_USED)))
+		/* all ADC is used wait... */
+		wait_event(queue_adc_busy, 0);
+	else if (adc_dev[0] == ADC_FREE) {
+		adc_dev[0] = ADC_USED;
+		adc_index = 0;
+	} else if (adc_dev[1] == ADC_FREE) {
+		adc_dev[1] = ADC_USED;
+		adc_index = 1;
+	}
+
+	pr_debug("mc13783_adc : request ADC %d\n", adc_index);
+	return adc_index;
+}
+
+/*!
+ * This function release an ADC.
+ *
+ * @param  adc_index	index of ADC to be released.
+ *
+ * @return This function returns 0 if successful.
+ */
+int mc13783_adc_release(int adc_index)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+
+	pr_debug("mc13783_adc : release ADC %d\n", adc_index);
+	if ((adc_dev[adc_index] == ADC_MONITORING) ||
+	    (adc_dev[adc_index] == ADC_USED)) {
+		adc_dev[adc_index] = ADC_FREE;
+		wake_up(&queue_adc_busy);
+		return 0;
+	}
+	return -1;
+}
+
+/*!
+ * This function initializes monitoring structure.
+ *
+ * @param        monitor     Structure to be initialized.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_init_monitor_param(t_monitoring_param *monitor)
+{
+	pr_debug("mc13783_adc : init monitor\n");
+	monitor->delay = 0;
+	monitor->conv_delay = false;
+	monitor->channel = BATTERY_VOLTAGE;
+	monitor->read_mode = 0;
+	monitor->comp_low = 0;
+	monitor->comp_high = 0;
+	monitor->group = 0;
+	monitor->check_mode = CHECK_LOW_OR_HIGH;
+	monitor->callback = NULL;
+	return 0;
+}
+
+/*!
+ * This function actives the comparator.  When comparator is active and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        channel  The channel to be sampled
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, adc_3_reg = 0;
+	t_monitoring_param monitoring;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (monitor_en) {
+		pr_debug("mc13783_adc : monitoring already configured\n");
+		return PMIC_ERROR;
+	}
+	monitor_en = true;
+	mc13783_adc_init_monitor_param(&monitoring);
+	monitoring.comp_low = low;
+	monitoring.comp_high = high;
+	monitoring.channel = channel;
+	monitoring.callback = (void *)callback;
+
+	use_bis = mc13783_adc_request();
+	if (use_bis < 0) {
+		pr_debug("mc13783_adc : request error\n");
+		return PMIC_ERROR;
+	}
+	monitor_adc = use_bis;
+
+	adc_0_reg = 0;
+
+	/* TO DO ADOUT CONFIGURE */
+	adc_0_reg = monitoring.read_mode & ADC_MODE_MASK;
+	if (use_bis)
+		/* add adc bis */
+		adc_0_reg |= ADC_BIS;
+
+	adc_0_reg |= ADC_WCOMP;
+
+	/* CONFIGURE ADC REG 1 */
+	adc_1_reg = 0;
+	adc_1_reg |= ADC_EN;
+	if (monitoring.conv_delay)
+		adc_1_reg |= ADC_ATO;
+
+	if (monitoring.group)
+		adc_1_reg |= ADC_ADSEL;
+
+	adc_1_reg |= (monitoring.channel << ADC_CH_0_POS) & ADC_CH_0_MASK;
+	adc_1_reg |= (monitoring.delay << ADC_DELAY_POS) & ADC_DELAY_MASK;
+	if (use_bis)
+		adc_1_reg |= ADC_BIS;
+
+	adc_3_reg |= (monitoring.comp_high << ADC_WCOMP_H_POS) &
+	    ADC_WCOMP_H_MASK;
+	adc_3_reg |= (monitoring.comp_low << ADC_WCOMP_L_POS) &
+	    ADC_WCOMP_L_MASK;
+	if (use_bis)
+		adc_3_reg |= ADC_BIS;
+
+
+	wcomp_mode = monitoring.check_mode;
+	/* call back to be called when event is detected. */
+	monitoring_cb = monitoring.callback;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, adc_3_reg, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_active_comparator);
+
+/*!
+ * This function deactivates the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (!monitor_en) {
+		pr_debug("mc13783_adc : adc monitoring free\n");
+		return PMIC_ERROR;
+	}
+
+	if (monitor_en)
+		reg_value = ADC_BIS;
+
+	/* clear all reg value */
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, reg_value, PMIC_ALL_BITS));
+
+	reg_value = 0;
+
+	if (monitor_adc)
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_4, reg_value, PMIC_ALL_BITS));
+	else
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_2, reg_value, PMIC_ALL_BITS));
+
+	mc13783_adc_release(monitor_adc);
+	monitor_en = false;
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_adc_deactive_comparator);
+
+/*!
+ * This function implements IOCTL controls on a MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	t_adc_convert_param *convert_param;
+	t_touch_mode touch_mode;
+	t_touch_screen touch_sample;
+	unsigned short b_current;
+	t_adc_comp_param *comp_param;
+	if ((_IOC_TYPE(cmd) != 'p') && (_IOC_TYPE(cmd) != 'D'))
+		return -ENOTTY;
+
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0))) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	switch (cmd) {
+	case PMIC_ADC_INIT:
+		pr_debug("init adc\n");
+		CHECK_ERROR(pmic_adc_init());
+		break;
+
+	case PMIC_ADC_DEINIT:
+		pr_debug("deinit adc\n");
+		CHECK_ERROR(pmic_adc_deinit());
+		break;
+
+	case PMIC_ADC_CONVERT:
+		convert_param = kmalloc(sizeof(t_adc_convert_param),
+				GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_convert(convert_param->channel,
+						   convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_CONVERT_8X:
+		convert_param = kmalloc(sizeof(t_adc_convert_param),
+				GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_convert_8x(convert_param->channel,
+						      convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_CONVERT_MULTICHANNEL:
+		convert_param = kmalloc(sizeof(t_adc_convert_param),
+				GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_adc_convert_multichnnel
+				  (convert_param->channel,
+				   convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_SET_TOUCH_MODE:
+		CHECK_ERROR(pmic_adc_set_touch_mode((t_touch_mode) arg));
+		break;
+
+	case PMIC_ADC_GET_TOUCH_MODE:
+		CHECK_ERROR(pmic_adc_get_touch_mode(&touch_mode));
+		if (copy_to_user((t_touch_mode *) arg, &touch_mode,
+				 sizeof(t_touch_mode)))
+			return -EFAULT;
+		break;
+
+	case PMIC_ADC_GET_TOUCH_SAMPLE:
+		pr_debug("pmic_adc_ioctl: " "PMIC_ADC_GET_TOUCH_SAMPLE\n");
+		CHECK_ERROR(pmic_adc_get_touch_sample(&touch_sample, 1));
+		if (copy_to_user((t_touch_screen *) arg, &touch_sample,
+				 sizeof(t_touch_screen)))
+			return -EFAULT;
+		break;
+
+	case PMIC_ADC_GET_BATTERY_CURRENT:
+		CHECK_ERROR(pmic_adc_get_battery_current(ADC_8CHAN_1X,
+							 &b_current));
+		if (copy_to_user((unsigned short *)arg, &b_current,
+				 sizeof(unsigned short)))
+			return -EFAULT;
+		break;
+
+	case PMIC_ADC_ACTIVATE_COMPARATOR:
+		comp_param = kmalloc(sizeof(t_adc_comp_param),
+				GFP_KERNEL);
+		if (comp_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(comp_param, (t_adc_comp_param *) arg,
+				   sizeof(t_adc_comp_param))) {
+			kfree(comp_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_active_comparator(comp_param->wlow,
+							     comp_param->whigh,
+							     comp_param->
+							     channel,
+							     comp_param->
+							     callback),
+				  (kfree(comp_param)));
+		break;
+
+	case PMIC_ADC_DEACTIVE_COMPARATOR:
+		CHECK_ERROR(pmic_adc_deactive_comparator());
+		break;
+
+	default:
+		pr_debug("pmic_adc_ioctl: unsupported ioctl command 0x%x\n",
+			 cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+void pmic_adc_class_dev_release(struct device *dev)
+{
+		put_device(dev);
+}
+
+static struct file_operations mc13783_adc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_adc_ioctl,
+	.open = pmic_adc_open,
+	.release = pmic_adc_free,
+};
+
+
+
+static int pmic_adc_module_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device	*temp_dev;
+
+	pmic_adc_major = register_chrdev(0, "pmic_adc",
+			&mc13783_adc_fops);
+
+	if (pmic_adc_major < 0) {
+		pr_debug(KERN_ERR "Unable to get a major for pmic_adc\n");
+		return pmic_adc_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	ret = class_register(&pmic_adc_class);
+	if (ret) {
+		pr_debug(KERN_ERR "Error creating pmic_adc class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&pmic_adc_class,
+			&pdev->dev, MKDEV(pmic_adc_major, 0), NULL, "pmic_adc");
+
+	if (IS_ERR(temp_dev)) {
+		pr_debug(KERN_ERR "Error creating pmic_adc class device.\n");
+		ret = PTR_ERR(temp_dev);
+		goto err_out2;
+	}
+
+
+	ret = pmic_adc_init();
+	if (ret != PMIC_SUCCESS) {
+		pr_debug(KERN_ERR "Error in pmic_adc_init.\n");
+		goto err_out4;
+	}
+
+	pr_debug(KERN_INFO "PMIC ADC successfully probed\n");
+	return ret;
+
+err_out4:
+	device_unregister(temp_dev);
+err_out2:
+	class_unregister(&pmic_adc_class);
+err_out1:
+	unregister_chrdev(pmic_adc_major, "pmic_adc");
+	return ret;
+}
+
+static int pmic_adc_module_remove(struct platform_device *pdev)
+{
+	pmic_adc_deinit();
+	class_unregister(&pmic_adc_class);
+	unregister_chrdev(pmic_adc_major, "pmic_adc");
+	pr_debug(KERN_INFO "PMIC ADC successfully removed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_adc_driver_ldm = {
+	.driver = {
+		   .name = "pmic_adc",
+		   },
+	.suspend = pmic_adc_suspend,
+	.resume = pmic_adc_resume,
+	.probe = pmic_adc_module_probe,
+	.remove = pmic_adc_module_remove,
+};
+
+/*
+ * Initialization and Exit
+ */
+static int __init pmic_adc_module_init(void)
+{
+	pr_debug("PMIC ADC driver loading...\n");
+	return platform_driver_register(&pmic_adc_driver_ldm);
+}
+
+static void __exit pmic_adc_module_exit(void)
+{
+	platform_driver_unregister(&pmic_adc_driver_ldm);
+	pr_debug("PMIC ADC driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+module_init(pmic_adc_module_init);
+module_exit(pmic_adc_module_exit);
+
+MODULE_DESCRIPTION("PMIC ADC device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc_defs.h b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
new file mode 100644
index 0000000..06395fa
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
@@ -0,0 +1,325 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_adc_defs.h
+ * @brief This header contains all defines for PMIC(mc13783) ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#ifndef __MC13783_ADC__DEFS_H__
+#define __MC13783_ADC__DEFS_H__
+
+#define MC13783_ADC_DEVICE "/dev/mc13783_adc"
+
+#define         DEF_ADC_0     0x008000
+#define         DEF_ADC_3     0x000080
+
+#define ADC_NB_AVAILABLE        2
+
+#define MAX_CHANNEL             7
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch-screen
+ */
+#define DELTA_Y_MAX             50
+#define DELTA_X_MAX             50
+
+/* Upon clearing the filter, this is the delay in restarting the filter */
+#define FILTER_MIN_DELAY        4
+
+/* Length of X and Y Touch screen filters */
+#define FILTLEN                 3
+
+#define TS_X_MAX                1000
+#define TS_Y_MAX                1000
+
+#define TS_X_MIN                80
+#define TS_Y_MIN                80
+
+#define MC13783_ADC0_TS_M_LSH	14
+#define MC13783_ADC0_TS_M_WID	3
+/*
+ * ADC 0
+ */
+#define ADC_WAIT_TSI_0		0x001C00
+
+/*
+ * ADC 1
+ */
+
+#define ADC_EN                  0x000001
+#define ADC_SGL_CH              0x000002
+#define ADC_ADSEL               0x000008
+#define ADC_CH_0_POS            5
+#define ADC_CH_0_MASK           0x0000E0
+#define ADC_CH_1_POS            8
+#define ADC_CH_1_MASK           0x000700
+#define ADC_DELAY_POS           11
+#define ADC_DELAY_MASK          0x07F800
+#define ADC_ATO                 0x080000
+#define ASC_ADC                 0x100000
+#define ADC_WAIT_TSI_1		0x300001
+#define ADC_CHRGRAW_D5          0x008000
+
+/*
+ * ADC 2 - 4
+ */
+#define ADD1_RESULT_MASK        0x00000FFC
+#define ADD2_RESULT_MASK        0x00FFC000
+#define ADC_TS_MASK             0x00FFCFFC
+
+/*
+ * ADC 3
+ */
+#define ADC_INC                 0x030000
+#define ADC_BIS                 0x800000
+
+/*
+ * ADC 3
+ */
+#define ADC_NO_ADTRIG           0x200000
+#define ADC_WCOMP               0x040000
+#define ADC_WCOMP_H_POS         0
+#define ADC_WCOMP_L_POS         9
+#define ADC_WCOMP_H_MASK        0x00003F
+#define ADC_WCOMP_L_MASK        0x007E00
+
+#define ADC_MODE_MASK           0x00003F
+
+/*
+ * Interrupt Status 0
+ */
+#define ADC_INT_BISDONEI        0x02
+
+/*!
+ * Define state mode of ADC.
+ */
+typedef enum adc_state {
+	/*!
+	 * Free.
+	 */
+	ADC_FREE,
+	/*!
+	 * Used.
+	 */
+	ADC_USED,
+	/*!
+	 * Monitoring
+	 */
+	ADC_MONITORING,
+} t_adc_state;
+
+/*!
+ * This enumeration, is used to configure the mode of ADC.
+ */
+typedef enum reading_mode {
+	/*!
+	 * Enables lithium cell reading
+	 */
+	M_LITHIUM_CELL = 0x000001,
+	/*!
+	 * Enables charge current reading
+	 */
+	M_CHARGE_CURRENT = 0x000002,
+	/*!
+	 * Enables battery current reading
+	 */
+	M_BATTERY_CURRENT = 0x000004,
+	/*!
+	 * Enables thermistor reading
+	 */
+	M_THERMISTOR = 0x000008,
+	/*!
+	 * Enables die temperature reading
+	 */
+	M_DIE_TEMPERATURE = 0x000010,
+	/*!
+	 * Enables UID reading
+	 */
+	M_UID = 0x000020,
+} t_reading_mode;
+
+/*!
+ * This enumeration, is used to configure the monitoring mode.
+ */
+typedef enum check_mode {
+	/*!
+	 * Comparator low level
+	 */
+	CHECK_LOW,
+	/*!
+	 * Comparator high level
+	 */
+	CHECK_HIGH,
+	/*!
+	 * Comparator low or high level
+	 */
+	CHECK_LOW_OR_HIGH,
+} t_check_mode;
+
+/*!
+ * This structure is used to configure and report adc value.
+ */
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Sets the single channel mode
+	 */
+	bool single_channel;
+	/*!
+	 * Selects the set of inputs
+	 */
+	bool group;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel_0;
+	/*!
+	 * Channel selection 2
+	 */
+	t_channel channel_1;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	t_reading_mode read_mode;
+	/*!
+	 * Sets the Touch screen mode
+	 */
+	bool read_ts;
+	/*!
+	 * Wait TSI event before touch screen reading
+	 */
+	bool wait_tsi;
+	/*!
+	 * Sets CHRGRAW scaling to divide by 5
+	 * Only supported on 2.0 and higher
+	 */
+	bool chrgraw_devide_5;
+	/*!
+	 * Return ADC values
+	 */
+	unsigned int value[8];
+	/*!
+	 * Return touch screen values
+	 */
+	t_touch_screen ts_value;
+} t_adc_param;
+
+/*!
+ * This structure is used to configure the monitoring mode of ADC.
+ */
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel;
+	/*!
+	 * Selects the set of inputs
+	 */
+	bool group;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	unsigned int read_mode;
+	/*!
+	 * Comparator low level in WCOMP mode
+	 */
+	unsigned int comp_low;
+	/*!
+	 * Comparator high level in WCOMP mode
+	 */
+	unsigned int comp_high;
+	/*!
+	 * Sets type of monitoring (low, high or both)
+	 */
+	t_check_mode check_mode;
+	/*!
+	 * Callback to be launched when event is detected
+	 */
+	void (*callback) (void);
+} t_monitoring_param;
+
+/*!
+ * This function performs filtering and rejection
+ * of excessive noise prone samples.
+ *
+ * @param        ts_curr     Touch screen value
+ *
+ * @return       This function returns 0 on success,
+ *					-1 otherwise.
+ */
+static int pmic_adc_filter(t_touch_screen *ts_curr);
+
+/*!
+ * This function request a ADC.
+ *
+ * @return      This function returns index of ADC to
+ * be used (0 or 1) if successful.
+ * return -1 if error.
+ */
+int mc13783_adc_request(void);
+
+/*!
+ * This function is used to update buffer of touch screen value in read mode.
+ */
+void update_buffer(void);
+
+/*!
+ * This function release an ADC.
+ *
+ * @param        adc_index     index of ADC to be released.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_release(int adc_index);
+
+/*!
+ * This function select the required read_mode for a specific channel.
+ *
+ * @param        channel   The channel to be sampled
+ *
+ * @return       This function returns the requires read_mode
+ */
+t_reading_mode mc13783_set_read_mode(t_channel channel);
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        touch_sample    return value of touch screen
+ * @param        wait_tsi    if true,
+ *				 this function is synchronous (wait in TSI event).
+ *
+ * @return       This function returns 0.
+ */
+PMIC_STATUS mc13783_adc_read_ts(t_touch_screen *touch_sample, int wait_tsi);
+
+#endif				/* __MC13783_ADC__DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_audio.c b/drivers/mxc/pmic/mc13783/pmic_audio.c
new file mode 100644
index 0000000..7046f00
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_audio.c
@@ -0,0 +1,5673 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_audio.c
+ * @brief Implementation of the PMIC(mc13783) Audio driver APIs.
+ *
+ * The PMIC Audio driver and this API were developed to support the
+ * audio playback, recording, and mixing capabilities of the power
+ * management ICs that are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes are supported:
+ *
+ * @verbatim
+ Operating Mode               mc13783
+ ---------------------------- -------
+ Stereo DAC Playback           Yes
+ Stereo DAC Input Mixing       Yes
+ Voice CODEC Playback          Yes
+ Voice CODEC Input Mixing      Yes
+ Voice CODEC Mono Recording    Yes
+ Voice CODEC Stereo Recording  Yes
+ Microphone Bias Control       Yes
+ Output Amplifier Control      Yes
+ Output Mixing Control         Yes
+ Input Amplifier Control       Yes
+ Master/Slave Mode Select      Yes
+ Anti Pop Bias Circuit Control Yes
+ @endverbatim
+ *
+ * Note that the Voice CODEC may also be referred to as the Telephone
+ * CODEC in the PMIC DTS documentation. Also note that, while the power
+ * management ICs do provide similar audio capabilities, each PMIC may
+ * support additional configuration settings and features. Therefore, it
+ * is highly recommended that the appropriate power management IC DTS
+ * documents be used in conjunction with this API interface.
+ *
+ * @ingroup PMIC_AUDIO
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+
+#include <asm/plat-mxc/pmic_audio.h>
+#include <asm/plat-mxc/pmic_adc.h>
+
+
+#ifdef DEBUG_AUDIO
+EXPORT_SYMBOL(pmic_audio_dump_registers);
+#endif				/* DEBUG_AUDIO */
+
+/*!
+ * Define the minimum sampling rate (in Hz) that is supported by the
+ * Stereo DAC.
+ */
+const unsigned MIN_STDAC_SAMPLING_RATE_HZ = 8000;
+EXPORT_SYMBOL(MIN_STDAC_SAMPLING_RATE_HZ);
+
+/*!
+ * Define the maximum sampling rate (in Hz) that is supported by the
+ * Stereo DAC.
+ */
+const unsigned MAX_STDAC_SAMPLING_RATE_HZ = 96000;
+EXPORT_SYMBOL(MAX_STDAC_SAMPLING_RATE_HZ);
+
+/*! @def SET_BITS
+ * Set a register field to a given value.
+ */
+#define SET_BITS(reg, field, value)    (((value) << reg.field.offset) & \
+		reg.field.mask)
+/*! @def GET_BITS
+ * Get the current value of a given register field.
+ */
+#define GET_BITS(reg, field, value)    (((value) & reg.field.mask) >> \
+		reg.field.offset)
+
+/*!
+ * @brief Define the possible states for a device handle.
+ *
+ * This enumeration is used to track the current state of each device handle.
+ */
+typedef enum {
+	HANDLE_FREE,		/*!< Handle is available for use. */
+	HANDLE_IN_USE		/*!< Handle is currently in use.  */
+} HANDLE_STATE;
+
+/*!
+ * @brief Identifies the hardware interrupt source.
+ *
+ * This enumeration identifies which of the possible hardware interrupt
+ * sources actually caused the current interrupt handler to be called.
+ */
+typedef enum {
+	CORE_EVENT_MC2BI,	/*!< Microphone Bias 2 detect. */
+	CORE_EVENT_HSDETI,	/*!< Detect Headset attach  */
+	CORE_EVENT_HSLI,	/*!< Detect Stereo Headset  */
+	CORE_EVENT_ALSPTHI,	/*!< Detect Thermal shutdown of ALSP  */
+	CORE_EVENT_AHSSHORTI	/*!< Detect Short circuit on AHS outputs  */
+} PMIC_CORE_EVENT;
+
+/*!
+ * @brief This structure is used to track the state of a microphone input.
+ */
+typedef struct {
+	PMIC_AUDIO_INPUT_PORT mic;
+	/*!< Microphone input port.      */
+	PMIC_AUDIO_INPUT_MIC_STATE micOnOff;
+	/*!< Microphone On/Off state. */
+	PMIC_AUDIO_MIC_AMP_MODE ampMode;
+	/*!< Input amplifier mode.       */
+	PMIC_AUDIO_MIC_GAIN gain;
+	/*!< Input amplifier gain level. */
+} PMIC_MICROPHONE_STATE;
+
+/*!
+ * @brief Tracks whether a headset is currently attached or not.
+ */
+typedef enum {
+	NO_HEADSET,		/*!< No headset currently attached. */
+	HEADSET_ON		/*!< Headset has been attached.     */
+} HEADSET_STATUS;
+
+/*!
+ * @brief mc13783 only enum that indicates the path
+ * to output taken by the voice codec output
+ */
+typedef enum {
+	VCODEC_DIRECT_OUT,	/*!< Vcodec signal out direct */
+	VCODEC_MIXER_OUT	/*!< Output via the mixer     */
+} PMIC_AUDIO_VCODEC_OUTPUT_PATH;
+
+/*!
+ * @brief This structure is used to define a specific
+ * hardware register field.
+ *
+ * All hardware register fields are defined using
+ * an offset to the LSB and a mask. The offset is
+ * used to right shift a register value before
+ * applying the mask to actually obtain the value of the field.
+ */
+typedef struct {
+	const unsigned char offset;
+	/*!< Offset of LSB of register field.          */
+	const unsigned int mask;
+	/*!< Mask value used to isolate register field. */
+} REGFIELD;
+
+/*!
+ * @brief This structure lists all fields of the AUD_CODEC hardware register.
+ */
+typedef struct {
+	REGFIELD CDCSSISEL;
+	/*!< codec SSI bus select              */
+	REGFIELD CDCCLKSEL;
+	/*!< Codec clock input select          */
+	REGFIELD CDCSM;
+	/*!< Codec slave / master select       */
+	REGFIELD CDCBCLINV;
+	/*!< Codec bitclock inversion          */
+	REGFIELD CDCFSINV;
+	/*!< Codec framesync inversion         */
+	REGFIELD CDCFS;
+	/*!< Bus protocol selection - 2 bits   */
+	REGFIELD CDCCLK;
+	/*!< Codec clock setting - 3 bits      */
+	REGFIELD CDCFS8K16K;
+	/*!< Codec framesync select            */
+	REGFIELD CDCEN;
+	/*!< Codec enable                      */
+	REGFIELD CDCCLKEN;
+	/*!< Codec clocking enable             */
+	REGFIELD CDCTS;
+	/*!< Codec SSI tristate                */
+	REGFIELD CDCDITH;
+	/*!< Codec dithering                   */
+	REGFIELD CDCRESET;
+	/*!< Codec filter reset                */
+	REGFIELD CDCBYP;
+	/*!< Codec bypass                      */
+	REGFIELD CDCALM;
+	/*!< Codec analog loopback             */
+	REGFIELD CDCDLM;
+	/*!< Codec digital loopback            */
+	REGFIELD AUDIHPF;
+	/*!< Transmit high pass filter enable  */
+	REGFIELD AUDOHPF;
+	/*!< Receive high pass filter enable   */
+} REGISTER_AUD_CODEC;
+
+/*!
+ * @brief This variable is used to access
+ * the AUD_CODEC hardware register.
+ *
+ * This variable defines how to access all
+ * of the fields within the
+ * AUD_CODEC hardware register. The initial
+ * values consist of the offset
+ * and mask values needed to access each of
+ * the register fields.
+ */
+static const REGISTER_AUD_CODEC regAUD_CODEC = {
+	{0, 0x000001},		/* CDCSSISEL    */
+	{1, 0x000002},		/* CDCCLKSEL    */
+	{2, 0x000004},		/* CDCSM        */
+	{3, 0x000008},		/* CDCBCLINV    */
+	{4, 0x000010},		/* CDCFSINV     */
+	{5, 0x000060},		/* CDCFS        */
+	{7, 0x000380},		/* CDCCLK       */
+	{10, 0x000400},		/* CDCFS8K16K   */
+	{11, 0x000800},		/* CDCEN        */
+	{12, 0x001000},		/* CDCCLKEN     */
+	{13, 0x002000},		/* CDCTS        */
+	{14, 0x004000},		/* CDCDITH      */
+	{15, 0x008000},		/* CDCRESET     */
+	{16, 0x010000},		/* CDCBYP       */
+	{17, 0x020000},		/* CDCALM       */
+	{18, 0x040000},		/* CDCDLM       */
+	{19, 0x080000},		/* AUDIHPF      */
+	{20, 0x100000}		/* AUDOHPF      */
+	/* Unused       */
+	/* Unused       */
+	/* Unused       */
+
+};
+
+/*!
+ * @brief This structure lists all fields of the ST_DAC hardware register.
+ */
+/* VVV */
+typedef struct {
+	REGFIELD STDCSSISEL;	/*!< Stereo DAC SSI bus select                            */
+	REGFIELD STDCCLKSEL;	/*!< Stereo DAC clock input select                        */
+	REGFIELD STDCSM;	/*!< Stereo DAC slave / master select                     */
+	REGFIELD STDCBCLINV;	/*!< Stereo DAC bitclock inversion                        */
+	REGFIELD STDCFSINV;	/*!< Stereo DAC framesync inversion                       */
+	REGFIELD STDCFS;	/*!< Bus protocol selection - 2 bits                      */
+	REGFIELD STDCCLK;	/*!< Stereo DAC clock setting - 3 bits                    */
+	REGFIELD STDCFSDLYB;	/*!< Stereo DAC framesync delay bar                       */
+	REGFIELD STDCEN;	/*!< Stereo DAC enable                                    */
+	REGFIELD STDCCLKEN;	/*!< Stereo DAC clocking enable                           */
+	REGFIELD STDCRESET;	/*!< Stereo DAC filter reset                              */
+	REGFIELD SPDIF;		/*!< Stereo DAC SSI SPDIF mode. Mode no longer available. */
+	REGFIELD SR;		/*!< Stereo DAC sample rate - 4 bits                      */
+} REGISTER_ST_DAC;
+
+/*!
+ * @brief This variable is used to access the ST_DAC hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * ST_DAC hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_ST_DAC regST_DAC = {
+	{0, 0x000001},		/* STDCSSISEL        */
+	{1, 0x000002},		/* STDCCLKSEL        */
+	{2, 0x000004},		/* STDCSM            */
+	{3, 0x000008},		/* STDCBCLINV        */
+	{4, 0x000010},		/* STDCFSINV         */
+	{5, 0x000060},		/* STDCFS            */
+	{7, 0x000380},		/* STDCCLK           */
+	{10, 0x000400},		/* STDCFSDLYB        */
+	{11, 0x000800},		/* STDCEN            */
+	{12, 0x001000},		/* STDCCLKEN         */
+	{15, 0x008000},		/* STDCRESET         */
+	{16, 0x010000},		/* SPDIF             */
+	{17, 0x1E0000}		/* SR                */
+};
+
+/*!
+ * @brief This structure lists all of the fields in the SSI_NETWORK hardware register.
+ */
+typedef struct {
+	REGFIELD CDCTXRXSLOT;	/*!< Codec timeslot assignment  - 2 bits                                  */
+	REGFIELD CDCTXSECSLOT;	/*!< Codec secondary transmit timeslot - 2 bits                           */
+	REGFIELD CDCRXSECSLOT;	/*!< Codec secondary receive timeslot - 2 bits                            */
+	REGFIELD CDCRXSECGAIN;	/*!< Codec secondary receive channel gain setting - 2 bits                */
+	REGFIELD CDCSUMGAIN;	/*!< Codec summed receive signal gain setting                             */
+	REGFIELD CDCFSDLY;	/*!< Codec framesync delay                                                */
+	REGFIELD STDCSLOTS;	/*!< Stereo DAC number of timeslots select  - 2 bits                      */
+	REGFIELD STDCRXSLOT;	/*!< Stereo DAC timeslot assignment - 2 bits                              */
+	REGFIELD STDCRXSECSLOT;	/*!< Stereo DAC secondary receive timeslot  - 2 bits                      */
+	REGFIELD STDCRXSECGAIN;	/*!< Stereo DAC secondary receive channel gain setting   - 2 bits         */
+	REGFIELD STDCSUMGAIN;	/*!< Stereo DAC summed receive signal gain setting                        */
+} REGISTER_SSI_NETWORK;
+
+/*!
+ * @brief This variable is used to access the SSI_NETWORK hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * SSI_NETWORK hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_SSI_NETWORK regSSI_NETWORK = {
+	{2, 0x00000c},		/* CDCTXRXSLOT          */
+	{4, 0x000030},		/* CDCTXSECSLOT         */
+	{6, 0x0000c0},		/* CDCRXSECSLOT         */
+	{8, 0x000300},		/* CDCRXSECGAIN         */
+	{10, 0x000400},		/* CDCSUMGAIN           */
+	{11, 0x000800},		/* CDCFSDLY             */
+	{12, 0x003000},		/* STDCSLOTS            */
+	{14, 0x00c000},		/* STDCRXSLOT           */
+	{16, 0x030000},		/* STDCRXSECSLOT        */
+	{18, 0x0c0000},		/* STDCRXSECGAIN        */
+	{20, 0x100000}		/* STDCSUMGAIN          */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_TX hardware register.
+ *
+ *
+ */
+typedef struct {
+	REGFIELD MC1BEN;	/*!< Microphone bias 1 enable                                */
+	REGFIELD MC2BEN;	/*!< Microphone bias 2 enable                                */
+	REGFIELD MC2BDETDBNC;	/*!< Microphone bias detect debounce setting                 */
+	REGFIELD MC2BDETEN;	/*!< Microphone bias 2 detect enable                         */
+	REGFIELD AMC1REN;	/*!< Amplifier Amc1R enable                                  */
+	REGFIELD AMC1RITOV;	/*!< Amplifier Amc1R current to voltage mode enable          */
+	REGFIELD AMC1LEN;	/*!< Amplifier Amc1L enable                                  */
+	REGFIELD AMC1LITOV;	/*!< Amplifier Amc1L current to voltage mode enable          */
+	REGFIELD AMC2EN;	/*!< Amplifier Amc2 enable                                   */
+	REGFIELD AMC2ITOV;	/*!< Amplifier Amc2 current to voltage mode enable           */
+	REGFIELD ATXINEN;	/*!< Amplifier Atxin enable                                  */
+	REGFIELD ATXOUTEN;	/*!< Reserved for output TXOUT enable, currently not used    */
+	REGFIELD RXINREC;	/*!< RXINR/RXINL to voice CODEC ADC routing enable           */
+	REGFIELD PGATXR;	/*!< Transmit gain setting right - 5 bits                    */
+	REGFIELD PGATXL;	/*!< Transmit gain setting left  - 5 bits                    */
+} REGISTER_AUDIO_TX;
+
+/*!
+ * @brief This variable is used to access the AUDIO_TX hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_TX hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_TX regAUDIO_TX = {
+	{0, 0x000001},		/* MC1BEN              */
+	{1, 0x000002},		/* MC2BEN              */
+	{2, 0x000004},		/* MC2BDETDBNC         */
+	{3, 0x000008},		/* MC2BDETEN           */
+	{5, 0x000020},		/* AMC1REN             */
+	{6, 0x000040},		/* AMC1RITOV           */
+	{7, 0x000080},		/* AMC1LEN             */
+	{8, 0x000100},		/* AMC1LITOV           */
+	{9, 0x000200},		/* AMC2EN              */
+	{10, 0x000400},		/* AMC2ITOV            */
+	{11, 0x000800},		/* ATXINEN             */
+	{12, 0x001000},		/* ATXOUTEN            */
+	{13, 0x002000},		/* RXINREC             */
+	{14, 0x07c000},		/* PGATXR              */
+	{19, 0xf80000}		/* PGATXL              */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_RX_0 hardware register.
+ */
+typedef struct {
+	REGFIELD VAUDIOON;	/*!<    Forces VAUDIO in active on mode               */
+	REGFIELD BIASEN;	/*!<    Audio bias enable                             */
+	REGFIELD BIASSPEED;	/*!<    Turn on ramp speed of the audio bias          */
+	REGFIELD ASPEN;		/*!<    Amplifier Asp enable                          */
+	REGFIELD ASPSEL;	/*!<    Asp input selector                            */
+	REGFIELD ALSPEN;	/*!<    Amplifier Alsp enable                         */
+	REGFIELD ALSPREF;	/*!<    Bias Alsp at common audio reference           */
+	REGFIELD ALSPSEL;	/*!<    Alsp input selector                           */
+	REGFIELD LSPLEN;	/*!<    Output LSPL enable                            */
+	REGFIELD AHSREN;	/*!<    Amplifier AhsR enable                         */
+	REGFIELD AHSLEN;	/*!<    Amplifier AhsL enable                         */
+	REGFIELD AHSSEL;	/*!<    Ahsr and Ahsl input selector                  */
+	REGFIELD HSPGDIS;	/*!<    Phantom ground disable                        */
+	REGFIELD HSDETEN;	/*!<    Headset detect enable                         */
+	REGFIELD HSDETAUTOB;	/*!<    Amplifier state determined by headset detect  */
+	REGFIELD ARXOUTREN;	/*!<    Output RXOUTR enable                          */
+	REGFIELD ARXOUTLEN;	/*!<    Output RXOUTL enable                          */
+	REGFIELD ARXOUTSEL;	/*!<    Arxout input selector                         */
+	REGFIELD CDCOUTEN;	/*!<    Output CDCOUT enable                          */
+	REGFIELD HSLDETEN;	/*!<    Headset left channel detect enable            */
+	REGFIELD ADDCDC;	/*!<    Adder channel codec selection                 */
+	REGFIELD ADDSTDC;	/*!<    Adder channel stereo DAC selection            */
+	REGFIELD ADDRXIN;	/*!<    Adder channel line in selection               */
+} REGISTER_AUDIO_RX_0;
+
+/*!
+ * @brief This variable is used to access the AUDIO_RX_0 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_RX_0 hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_RX_0 regAUDIO_RX_0 = {
+	{0, 0x000001},		/* VAUDIOON    */
+	{1, 0x000002},		/* BIASEN      */
+	{2, 0x000004},		/* BIASSPEED   */
+	{3, 0x000008},		/* ASPEN       */
+	{4, 0x000010},		/* ASPSEL      */
+	{5, 0x000020},		/* ALSPEN      */
+	{6, 0x000040},		/* ALSPREF     */
+	{7, 0x000080},		/* ALSPSEL     */
+	{8, 0x000100},		/* LSPLEN      */
+	{9, 0x000200},		/* AHSREN      */
+	{10, 0x000400},		/* AHSLEN      */
+	{11, 0x000800},		/* AHSSEL      */
+	{12, 0x001000},		/* HSPGDIS     */
+	{13, 0x002000},		/* HSDETEN     */
+	{14, 0x004000},		/* HSDETAUTOB  */
+	{15, 0x008000},		/* ARXOUTREN   */
+	{16, 0x010000},		/* ARXOUTLEN   */
+	{17, 0x020000},		/* ARXOUTSEL   */
+	{18, 0x040000},		/* CDCOUTEN    */
+	{19, 0x080000},		/* HSLDETEN    */
+	{21, 0x200000},		/* ADDCDC      */
+	{22, 0x400000},		/* ADDSTDC     */
+	{23, 0x800000}		/* ADDRXIN     */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_RX_1 hardware register.
+ */
+typedef struct {
+	REGFIELD PGARXEN;	/*!<    Codec receive PGA enable                 */
+	REGFIELD PGARX;		/*!<    Codec receive gain setting - 4 bits      */
+	REGFIELD PGASTEN;	/*!<    Stereo DAC PGA enable                    */
+	REGFIELD PGAST;		/*!<    Stereo DAC gain setting  - 4 bits        */
+	REGFIELD ARXINEN;	/*!<    Amplifier Arx enable                     */
+	REGFIELD ARXIN;		/*!<    Amplifier Arx additional gain setting    */
+	REGFIELD PGARXIN;	/*!<    PGArxin gain setting  - 4 bits           */
+	REGFIELD MONO;		/*!<    Mono adder setting   - 2 bits            */
+	REGFIELD BAL;		/*!<    Balance control      - 3 bits            */
+	REGFIELD BALLR;		/*!<    Left / right balance                     */
+} REGISTER_AUDIO_RX_1;
+
+/*!
+ * @brief This variable is used to access the AUDIO_RX_1 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_RX_1 hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_RX_1 regAUDIO_RX_1 = {
+	{0, 0x000001},		/* PGARXEN    */
+	{1, 0x00001e},		/* PGARX      */
+	{5, 0x000020},		/* PGASTEN   */
+	{6, 0x0003c0},		/* PGAST       */
+	{10, 0x000400},		/* ARXINEN      */
+	{11, 0x000800},		/* ARXIN      */
+	{12, 0x00f000},		/* PGARXIN     */
+	{16, 0x030000},		/* MONO     */
+	{18, 0x1c0000},		/* BAL      */
+	{21, 0x200000}		/* BALLR      */
+};
+
+/*! Define a mask to access the entire hardware register. */
+static const unsigned int REG_FULLMASK = 0xffffff;
+
+/*! Reset value for the AUD_CODEC register. */
+static const unsigned int RESET_AUD_CODEC = 0x180027;
+
+/*! Reset value for the ST_DAC register.
+ *
+ *  Note that we avoid resetting any of the arbitration bits.
+ */
+static const unsigned int RESET_ST_DAC = 0x0E0004;
+
+/*! Reset value for the SSI_NETWORK register. */
+static const unsigned int RESET_SSI_NETWORK = 0x013060;
+
+/*! Reset value for the AUDIO_TX register.
+ *
+ *  Note that we avoid resetting any of the arbitration bits.
+ */
+static const unsigned int RESET_AUDIO_TX = 0x420000;
+
+/*! Reset value for the AUDIO_RX_0 register. */
+static const unsigned int RESET_AUDIO_RX_0 = 0x001000;
+
+/*! Reset value for the AUDIO_RX_1 register. */
+static const unsigned int RESET_AUDIO_RX_1 = 0x00D35A;
+
+/*! Reset mask for the SSI network Vcodec part. first 12 bits
+ * 0 - 11 */
+static const unsigned int REG_SSI_VCODEC_MASK = 0x000fff;
+
+/*! Reset mask for the SSI network STDAC part. last 12 bits
+ * 12 - 24 */
+static const unsigned int REG_SSI_STDAC_MASK = 0xfff000;
+
+/*! Constant NULL value for initializing/reseting the audio handles. */
+static const PMIC_AUDIO_HANDLE AUDIO_HANDLE_NULL = (PMIC_AUDIO_HANDLE) NULL;
+
+/*!
+ * @brief This structure maintains the current state of the Stereo DAC.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;
+	/*!< Handle used to access the Stereo DAC.   */
+	HANDLE_STATE handleState;
+	/*!< Current handle state.   */
+	PMIC_AUDIO_DATA_BUS busID;
+	/*!< Data bus used to access the Stereo DAC. */
+	bool protocol_set;
+	PMIC_AUDIO_BUS_PROTOCOL protocol;
+	/*!< Data bus protocol.      */
+	PMIC_AUDIO_BUS_MODE masterSlave;
+	/*!< Master/Slave mode select.*/
+	PMIC_AUDIO_NUMSLOTS numSlots;
+	/*!< Number of timeslots used.*/
+	PMIC_AUDIO_CALLBACK callback;
+	/*!< Event notification callback function pointer.*/
+	PMIC_AUDIO_EVENTS eventMask;
+	/*!< Event notification mask. */
+	PMIC_AUDIO_CLOCK_IN_SOURCE clockIn;
+	/*!< Stereo DAC clock input source select. */
+	PMIC_AUDIO_STDAC_SAMPLING_RATE samplingRate;
+	/*!< Stereo DAC sampling rate  select. */
+	PMIC_AUDIO_STDAC_CLOCK_IN_FREQ clockFreq;
+	/*!< Stereo DAC clock input frequency. */
+	PMIC_AUDIO_CLOCK_INVERT invert;
+	/*!< Stereo DAC clock signal invert select. */
+	PMIC_AUDIO_STDAC_TIMESLOTS timeslot;
+	/*!< Stereo DAC data timeslots select. */
+	PMIC_AUDIO_STDAC_CONFIG config;
+	/*!< Stereo DAC configuration options.*/
+} PMIC_AUDIO_STDAC_STATE;
+
+/*!
+ * @brief This variable maintains the current
+ * state of the Stereo DAC.
+ *
+ * This variable tracks the current state of
+ * the Stereo DAC audio hardware
+ * along with any information that is required
+ * by the device driver to
+ * manage the hardware (e.g., callback functions
+ * and event notification * masks).
+ *
+ * The initial values represent the reset/power
+ * on state of the Stereo DAC.
+ */
+static PMIC_AUDIO_STDAC_STATE stDAC = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle       */
+	HANDLE_FREE,		/* handleState  */
+	AUDIO_DATA_BUS_1,	/* busID        */
+	false,
+	NORMAL_MSB_JUSTIFIED_MODE,	/* protocol     */
+	BUS_MASTER_MODE,	/* masterSlave  */
+	USE_2_TIMESLOTS,	/* numSlots     */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback     */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask    */
+	CLOCK_IN_CLIA,		/* clockIn      */
+	STDAC_RATE_44_1_KHZ,	/* samplingRate */
+	STDAC_CLI_13MHZ,	/* clockFreq    */
+	NO_INVERT,		/* invert       */
+	USE_TS0_TS1,		/* timeslot     */
+	(PMIC_AUDIO_STDAC_CONFIG) 0	/* config       */
+};
+
+/*!
+ * @brief This structure maintains the current state of the Voice CODEC.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;	/*!< Handle used to access
+								  the Voice CODEC.       */
+	HANDLE_STATE handleState;	/*!< Current handle state.  */
+	PMIC_AUDIO_DATA_BUS busID;	/*!< Data bus used to access
+								  the Voice CODEC.       */
+	bool protocol_set;
+	PMIC_AUDIO_BUS_PROTOCOL protocol;	/*!< Data bus protocol.     */
+	PMIC_AUDIO_BUS_MODE masterSlave;	/*!< Master/Slave mode
+										  select.                */
+	PMIC_AUDIO_NUMSLOTS numSlots;	/*!< Number of timeslots
+									  used.                  */
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification
+									  callback function
+									  pointer.               */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification
+									  mask.                  */
+	PMIC_AUDIO_CLOCK_IN_SOURCE clockIn;	/*!< Voice CODEC clock input
+										  source select.         */
+	PMIC_AUDIO_VCODEC_SAMPLING_RATE samplingRate;	/*!< Voice CODEC sampling
+													  rate select.           */
+	PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ clockFreq;	/*!< Voice CODEC clock input
+												  frequency.             */
+	PMIC_AUDIO_CLOCK_INVERT invert;	/*!< Voice CODEC clock
+									  signal invert select.  */
+	PMIC_AUDIO_VCODEC_TIMESLOT timeslot;	/*!< Voice CODEC data
+											  timeslot select.       */
+	PMIC_AUDIO_VCODEC_TIMESLOT secondaryTXtimeslot;
+
+	PMIC_AUDIO_VCODEC_CONFIG config;	/*!< Voice CODEC
+										  configuration
+										  options.            */
+	PMIC_MICROPHONE_STATE leftChannelMic;	/*!< Left channel
+											  microphone
+											  configuration.      */
+	PMIC_MICROPHONE_STATE rightChannelMic;	/*!< Right channel
+											  microphone
+											  configuration.      */
+} PMIC_AUDIO_VCODEC_STATE;
+
+/*!
+ * @brief This variable maintains the current state of the Voice CODEC.
+ *
+ * This variable tracks the current state of the Voice CODEC audio hardware
+ * along with any information that is required by the device driver to
+ * manage the hardware (e.g., callback functions and event notification
+ * masks).
+ *
+ * The initial values represent the reset/power on state of the Voice CODEC.
+ */
+static PMIC_AUDIO_VCODEC_STATE vCodec = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle          */
+	HANDLE_FREE,		/* handleState     */
+	AUDIO_DATA_BUS_2,	/* busID           */
+	false,
+	NETWORK_MODE,		/* protocol        */
+	BUS_SLAVE_MODE,		/* masterSlave     */
+	USE_4_TIMESLOTS,	/* numSlots        */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback        */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask       */
+	CLOCK_IN_CLIB,		/* clockIn         */
+	VCODEC_RATE_8_KHZ,	/* samplingRate    */
+	VCODEC_CLI_13MHZ,	/* clockFreq       */
+	NO_INVERT,		/* invert          */
+	USE_TS0,		/* timeslot pri    */
+	USE_TS2,		/* timeslot sec TX */
+	INPUT_HIGHPASS_FILTER | OUTPUT_HIGHPASS_FILTER,	/* config          */
+	/* leftChannelMic  */
+	{NO_MIC,		/*    mic          */
+		MICROPHONE_OFF,	/*    micOnOff     */
+		AMP_OFF,		/*    ampMode      */
+		MIC_GAIN_0DB		/*    gain         */
+	},
+	/* rightChannelMic */
+	{NO_MIC,		/*    mic          */
+		MICROPHONE_OFF,	/*    micOnOff     */
+		AMP_OFF,		/*    ampMode      */
+		MIC_GAIN_0DB		/*    gain         */
+	}
+};
+
+/*!
+ * @brief This maintains the current state of the External Stereo Input.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;	/*!< Handle used to access the
+								  External Stereo Inputs.     */
+	HANDLE_STATE handleState;	/*!< Current handle state.       */
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification callback
+									  function pointer.           */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification mask.    */
+	PMIC_AUDIO_STEREO_IN_GAIN inputGain;	/*!< External Stereo Input
+											  amplifier gain level.       */
+} PMIC_AUDIO_EXT_STEREO_IN_STATE;
+
+/*!
+ * @brief This maintains the current state of the External Stereo Input.
+ *
+ * This variable tracks the current state of the External Stereo Input audio
+ * hardware along with any information that is required by the device driver
+ * to manage the hardware (e.g., callback functions and event notification
+ * masks).
+ *
+ * The initial values represent the reset/power on state of the External
+ * Stereo Input.
+ */
+static PMIC_AUDIO_EXT_STEREO_IN_STATE extStereoIn = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle      */
+	HANDLE_FREE,		/* handleState */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback    */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask   */
+	STEREO_IN_GAIN_0DB	/* inputGain   */
+};
+
+/*!
+ * @brief This maintains the current state of the Audio Output Section.
+ */
+typedef struct {
+	PMIC_AUDIO_OUTPUT_PORT outputPort;
+	/*!< Current audio output port.     */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN vCodecoutputPGAGain;
+	/*!< Output PGA gain level codec      */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN stDacoutputPGAGain;
+	/*!< Output PGA gain level stDAC      */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN extStereooutputPGAGain;
+	/*!< Output PGA gain level stereo ext */
+	PMIC_AUDIO_OUTPUT_BALANCE_GAIN balanceLeftGain;
+	/*!< Left channel balance gain level.*/
+	PMIC_AUDIO_OUTPUT_BALANCE_GAIN balanceRightGain;
+	/*!< Right channel balance gain level.*/
+	PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN monoAdderGain;
+	/*!< Mono adder gain  level. */
+	PMIC_AUDIO_OUTPUT_CONFIG config;
+	/*!< Audio output  section config options.*/
+	PMIC_AUDIO_VCODEC_OUTPUT_PATH vCodecOut;
+} PMIC_AUDIO_AUDIO_OUTPUT_STATE;
+
+/*!
+ * @brief This variable maintains the current state of the Audio Output Section.
+ *
+ * This variable tracks the current state of the Audio Output Section.
+ *
+ * The initial values represent the reset/power on state of the Audio
+ * Output Section.
+ */
+static PMIC_AUDIO_AUDIO_OUTPUT_STATE audioOutput = {
+	(PMIC_AUDIO_OUTPUT_PORT) NULL,	/* outputPort       */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	BAL_GAIN_0DB,		/* balanceLeftGain  */
+	BAL_GAIN_0DB,		/* balanceRightGain */
+	MONOADD_GAIN_0DB,	/* monoAdderGain    */
+	(PMIC_AUDIO_OUTPUT_CONFIG) 0,	/* config           */
+	VCODEC_DIRECT_OUT
+};
+
+/*! The current headset status. */
+static HEADSET_STATUS headsetState = NO_HEADSET;
+
+/* Removed PTT variable */
+/*! Define a 1 ms wait interval that is needed to ensure that certain
+ *  hardware operations are successfully completed.
+ */
+static const unsigned long delay_1ms = (HZ / 1000);
+
+/*!
+ * @brief This spinlock is used to provide mutual exclusion.
+ *
+ * Create a spinlock that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the audio data structures are consistent at all times
+ * when possibly accessed by multiple threads of execution (for example,
+ * while simultaneously handling a user request and an interrupt event).
+ *
+ * We need to use a spinlock whenever we do need to provide mutual
+ * exclusion while possibly executing in a hardware interrupt context.
+ * Spinlocks should be held for the minimum time that is necessary
+ * because hardware interrupts are disabled while a spinlock is held.
+ *
+ *static spinlock_t lock = SPIN_LOCK_UNLOCKED;
+ */
+
+/*!
+ * @brief This mutex is used to provide mutual exclusion.
+ *
+ * Create a mutex that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the audio data structures are consistent at all times
+ * when possibly accessed by multiple threads of execution.
+ *
+ * Note that we use a mutex instead of the spinlock whenever disabling
+ * interrupts while in the critical section is not required. This helps
+ * to minimize kernel interrupt handling latency.
+ */
+static DECLARE_MUTEX(mutex);
+
+/* Prototype for the audio driver tasklet function. */
+static void pmic_audio_tasklet(unsigned long arg);
+
+/*!
+ * @brief Tasklet handler for the audio driver.
+ *
+ * Declare a tasklet that will do most of the processing for
+ * mc13783 audio interrupt events. Note that we cannot do all of the required
+ * processing within the interrupt handler itself because we may need to
+ * call the ADC driver to measure voltages as well as calling any
+ * user-registered callback functions.
+ */
+DECLARE_TASKLET(audioTasklet, pmic_audio_tasklet, 0);
+
+/*!
+ * @brief Global variable to track currently active interrupt events.
+ *
+ * This global variable is used to keep track of all of the currently
+ * active interrupt events for the audio driver. Note that access to this
+ * variable may occur while within an interrupt context and, therefore,
+ * must be guarded by using a spinlock.
+ */
+/* static PMIC_CORE_EVENT eventID = 0; */
+
+/* Prototypes for all static audio driver functions. */
+/*
+   static PMIC_STATUS pmic_audio_mic_boost_enable(void);
+   static PMIC_STATUS pmic_audio_mic_boost_disable(void);*/
+static PMIC_STATUS pmic_audio_close_handle(const PMIC_AUDIO_HANDLE handle);
+static PMIC_STATUS pmic_audio_reset_device(const PMIC_AUDIO_HANDLE handle);
+/*
+   static PMIC_STATUS pmic_audio_deregister(PMIC_AUDIO_CALLBACK * const callback,
+   PMIC_AUDIO_EVENTS * const eventMask);
+   static void pmic_audio_event_handler(void *param);*/
+
+/*************************************************************************
+ * Audio device access APIs.
+ *************************************************************************
+ */
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Audio
+ * hardware.
+ */
+/*@{*/
+
+PMIC_STATUS pmic_audio_set_autodetect(int val)
+{
+	PMIC_STATUS status;
+	unsigned int reg_mask = 0;
+	reg_mask = SET_BITS(regAUDIO_RX_0, VAUDIOON, 1);
+	status = pmic_write_reg(REG_AUDIO_RX_0, reg_mask, reg_mask);
+	if (status != PMIC_SUCCESS)
+		return status;
+	reg_mask = 0;
+	reg_mask =
+		SET_BITS(regAUDIO_RX_0, HSDETEN, 1) | SET_BITS(regAUDIO_RX_0,
+				HSDETAUTOB, 1);
+	status = pmic_write_reg(REG_AUDIO_RX_0, reg_mask, reg_mask);
+	return status;
+}
+EXPORT_SYMBOL(pmic_audio_set_autodetect);
+
+/*!
+ * @brief Request exclusive access to the PMIC Audio hardware.
+ *
+ * Attempt to open and gain exclusive access to a key PMIC audio hardware
+ * component (e.g., the Stereo DAC or the Voice CODEC). Depending upon the
+ * type of audio operation that is desired and the nature of the audio data
+ * stream, the Stereo DAC and/or the Voice CODEC will be a required hardware
+ * component and needs to be acquired by calling this function.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls to complete
+ * the configuration of either the Stereo DAC or the Voice CODEC and along
+ * with any other associated audio hardware components that will be needed.
+ *
+ * The same handle must also be used in the close call when use of the PMIC
+ * audio hardware is no longer required.
+ *
+ * The open request will fail if the requested audio hardware component has
+ * already been acquired by a previous open call but not yet closed.
+ *
+ * @param  handle          Device handle to be used for subsequent PMIC
+ *                              audio API calls.
+ * @param  device          The required PMIC audio hardware component.
+ *
+ * @retval      PMIC_SUCCESS         If the open request was successful
+ * @retval      PMIC_PARAMETER_ERROR If the handle argument is NULL.
+ * @retval      PMIC_ERROR           If the audio hardware component is
+ *                                   unavailable.
+ */
+PMIC_STATUS pmic_audio_open(PMIC_AUDIO_HANDLE * const handle,
+		const PMIC_AUDIO_SOURCE device)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	if (handle == (PMIC_AUDIO_HANDLE *) NULL) {
+		/* Do not dereference a NULL pointer. */
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	/* We only need to acquire a mutex here because the interrupt handler
+	 * never modifies the device handle or device handle state. Therefore,
+	 * we don't need to worry about conflicts with the interrupt handler
+	 * or the need to execute in an interrupt context.
+	 *
+	 * But we do need a critical section here to avoid problems in case
+	 * multiple calls to pmic_audio_open() are made since we can only allow
+	 * one of them to succeed.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Check the current device handle state and acquire the handle if
+	 * it is available.
+	 */
+	if ((device == STEREO_DAC) && (stDAC.handleState == HANDLE_FREE)) {
+		stDAC.handle = (PMIC_AUDIO_HANDLE) (&stDAC);
+		stDAC.handleState = HANDLE_IN_USE;
+		*handle = stDAC.handle;
+		rc = PMIC_SUCCESS;
+	} else if ((device == VOICE_CODEC)
+			&& (vCodec.handleState == HANDLE_FREE)) {
+		vCodec.handle = (PMIC_AUDIO_HANDLE) (&vCodec);
+		vCodec.handleState = HANDLE_IN_USE;
+		*handle = vCodec.handle;
+		rc = PMIC_SUCCESS;
+	} else if ((device == EXTERNAL_STEREO_IN) &&
+			(extStereoIn.handleState == HANDLE_FREE)) {
+		extStereoIn.handle = (PMIC_AUDIO_HANDLE) (&extStereoIn);
+		extStereoIn.handleState = HANDLE_IN_USE;
+		*handle = extStereoIn.handle;
+		rc = PMIC_SUCCESS;
+	} else {
+		*handle = AUDIO_HANDLE_NULL;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_open);
+
+/*!
+ * @brief Terminate further access to the PMIC audio hardware.
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * Note that we will shutdown/reset the Voice CODEC or Stereo DAC as well as
+ * any associated audio input/output components that are no longer required.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_close(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* We need a critical section here to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* We can now call pmic_audio_close_handle() to actually do the work. */
+	rc = pmic_audio_close_handle(handle);
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_close);
+
+/*!
+ * @brief Configure the data bus protocol to be used.
+ *
+ * Provide the parameters needed to properly configure the audio data bus
+ * protocol so that data can be read/written to either the Stereo DAC or
+ * the Voice CODEC.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   busID           Select data bus to be used.
+ * @param   protocol        Select the data bus protocol.
+ * @param   masterSlave     Select the data bus timing mode.
+ * @param   numSlots        Define the number of timeslots (only if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the protocol parameters
+ *                                   are invalid.
+ */
+PMIC_STATUS pmic_audio_set_protocol(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_DATA_BUS busID,
+		const PMIC_AUDIO_BUS_PROTOCOL protocol,
+		const PMIC_AUDIO_BUS_MODE masterSlave,
+		const PMIC_AUDIO_NUMSLOTS numSlots)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int ST_DAC_MASK = SET_BITS(regST_DAC, STDCSSISEL, 1) |
+		SET_BITS(regST_DAC, STDCFS, 3) | SET_BITS(regST_DAC, STDCSM, 1);
+
+	unsigned int reg_mask;
+	/*unsigned int VCODEC_MASK = SET_BITS(regAUD_CODEC, CDCSSISEL, 1) |
+	  SET_BITS(regAUD_CODEC, CDCFS, 3) | SET_BITS(regAUD_CODEC, CDCSM, 1); */
+
+	unsigned int SSI_NW_MASK = SET_BITS(regSSI_NETWORK, STDCSLOTS, 1);
+	unsigned int reg_value = 0;
+	unsigned int ssi_nw_value = 0;
+
+	/* Enter a critical section so that we can ensure only one
+	 * state change request is completed at a time.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (handle == (PMIC_AUDIO_HANDLE) NULL)
+		rc = PMIC_PARAMETER_ERROR;
+	else {
+		if ((handle == vCodec.handle) &&
+				(vCodec.handleState == HANDLE_IN_USE)) {
+			if ((stDAC.handleState == HANDLE_IN_USE) &&
+					(stDAC.busID == busID) && (stDAC.protocol_set)) {
+				pr_debug("The requested bus already in USE\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if ((masterSlave == BUS_MASTER_MODE)
+					&& (numSlots != USE_4_TIMESLOTS)) {
+				pr_debug
+					("mc13783 supports only 4 slots in Master mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else if ((masterSlave == BUS_SLAVE_MODE)
+					&& (numSlots != USE_4_TIMESLOTS)) {
+				pr_debug
+					("Driver currently supports only 4 slots in Slave mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else if (!((protocol == NETWORK_MODE) ||
+						(protocol == I2S_MODE))) {
+				pr_debug
+					("mc13783 Voice codec works only in Network and I2S modes\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else {
+				pr_debug
+					("Proceeding to configure Voice Codec\n");
+				if (busID == AUDIO_DATA_BUS_1)
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCSSISEL,
+								0);
+				else
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCSSISEL,
+								1);
+
+				reg_mask = SET_BITS(regAUD_CODEC, CDCSSISEL, 1);
+				if (PMIC_SUCCESS !=
+						pmic_write_reg(REG_AUDIO_CODEC,
+							reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				if (masterSlave == BUS_MASTER_MODE)
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCSM, 0);
+				else
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCSM, 1);
+
+				reg_mask = SET_BITS(regAUD_CODEC, CDCSM, 1);
+				if (PMIC_SUCCESS !=
+						pmic_write_reg(REG_AUDIO_CODEC,
+							reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				if (protocol == NETWORK_MODE)
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCFS, 1);
+				else
+					reg_value =
+						SET_BITS(regAUD_CODEC, CDCFS, 2);
+
+				reg_mask = SET_BITS(regAUD_CODEC, CDCFS, 3);
+				if (PMIC_SUCCESS !=
+						pmic_write_reg(REG_AUDIO_CODEC,
+							reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				ssi_nw_value =
+					SET_BITS(regSSI_NETWORK, CDCFSDLY, 1);
+
+				vCodec.busID = busID;
+				vCodec.protocol = protocol;
+				vCodec.masterSlave = masterSlave;
+				vCodec.numSlots = numSlots;
+				vCodec.protocol_set = true;
+
+				pr_debug
+					("mc13783 Voice codec successfully configured\n");
+				rc = PMIC_SUCCESS;
+
+			}
+
+		} else if ((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) {
+			if ((vCodec.handleState == HANDLE_IN_USE) &&
+					(vCodec.busID == busID) && (vCodec.protocol_set)) {
+				pr_debug("The requested bus already in USE\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if (((protocol == NORMAL_MSB_JUSTIFIED_MODE) ||
+						(protocol == I2S_MODE))
+					&& (numSlots != USE_2_TIMESLOTS)) {
+				pr_debug
+					("STDAC uses only 2 slots in Normal and I2S modes\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if ((protocol == NETWORK_MODE) &&
+					!((numSlots == USE_2_TIMESLOTS) ||
+						(numSlots == USE_4_TIMESLOTS) ||
+						(numSlots == USE_8_TIMESLOTS))) {
+				pr_debug
+					("STDAC uses only 2,4 or 8 slots in Network mode\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if (protocol == SPD_IF_MODE) {
+				pr_debug
+					("STDAC driver currently does not support SPD IF mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else {
+				pr_debug
+					("Proceeding to configure Stereo DAC\n");
+				if (busID == AUDIO_DATA_BUS_1)
+					reg_value =
+						SET_BITS(regST_DAC, STDCSSISEL, 0);
+				else
+					reg_value =
+						SET_BITS(regST_DAC, STDCSSISEL, 1);
+
+				if (masterSlave == BUS_MASTER_MODE)
+					reg_value |=
+						SET_BITS(regST_DAC, STDCSM, 0);
+				else
+					reg_value |=
+						SET_BITS(regST_DAC, STDCSM, 1);
+
+				if (protocol == NETWORK_MODE)
+					reg_value |=
+						SET_BITS(regST_DAC, STDCFS, 1);
+				else if (protocol ==
+						NORMAL_MSB_JUSTIFIED_MODE)
+					reg_value |=
+						SET_BITS(regST_DAC, STDCFS, 0);
+				else
+					/* I2S mode as the other option has already been eliminated */
+					reg_value |=
+						SET_BITS(regST_DAC, STDCFS, 2);
+
+				if (pmic_write_reg
+						(REG_AUDIO_STEREO_DAC,
+						 reg_value, ST_DAC_MASK) != PMIC_SUCCESS)
+					rc = PMIC_ERROR;
+				else {
+					if (numSlots == USE_2_TIMESLOTS)
+						reg_value =
+							SET_BITS(regSSI_NETWORK,
+									STDCSLOTS, 3);
+					else if (numSlots == USE_4_TIMESLOTS)
+						reg_value =
+							SET_BITS(regSSI_NETWORK,
+									STDCSLOTS, 2);
+					else
+						/* Use 8 timeslots - L , R and 6 other */
+						reg_value =
+							SET_BITS(regSSI_NETWORK,
+									STDCSLOTS, 1);
+
+					if (pmic_write_reg
+							(REG_AUDIO_SSI_NETWORK,
+							 reg_value,
+							 SSI_NW_MASK) != PMIC_SUCCESS)
+						rc = PMIC_ERROR;
+					else {
+						stDAC.busID = busID;
+						stDAC.protocol = protocol;
+						stDAC.protocol_set = true;
+						stDAC.masterSlave = masterSlave;
+						stDAC.numSlots = numSlots;
+						pr_debug
+							("mc13783 Stereo DAC successfully configured\n");
+						rc = PMIC_SUCCESS;
+					}
+				}
+
+			}
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+			/* Handle  can only be Voice Codec or Stereo DAC */
+			pr_debug("Handles only STDAC and VCODEC\n");
+		}
+
+	}
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_set_protocol);
+
+/*!
+ * @brief Retrieve the current data bus protocol configuration.
+ *
+ * Retrieve the parameters that define the current audio data bus protocol.
+ *
+ * @param  handle          Device handle from pmic_audio_open() call.
+ * @param  busID           The data bus being used.
+ * @param  protocol        The data bus protocol being used.
+ * @param  masterSlave     The data bus timing mode being used.
+ * @param  numSlots        The number of timeslots being used (if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_protocol(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_DATA_BUS * const busID,
+		PMIC_AUDIO_BUS_PROTOCOL * const protocol,
+		PMIC_AUDIO_BUS_MODE * const masterSlave,
+		PMIC_AUDIO_NUMSLOTS * const numSlots)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	if ((busID != (PMIC_AUDIO_DATA_BUS *) NULL) &&
+			(protocol != (PMIC_AUDIO_BUS_PROTOCOL *) NULL) &&
+			(masterSlave != (PMIC_AUDIO_BUS_MODE *) NULL) &&
+			(numSlots != (PMIC_AUDIO_NUMSLOTS *) NULL)) {
+		/* Enter a critical section so
+		 * that we return a consistent state. */
+		if (down_interruptible(&mutex))
+			return PMIC_SYSTEM_ERROR_EINTR;
+
+		if ((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) {
+			*busID = stDAC.busID;
+			*protocol = stDAC.protocol;
+			*masterSlave = stDAC.masterSlave;
+			*numSlots = stDAC.numSlots;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == vCodec.handle) &&
+				(vCodec.handleState == HANDLE_IN_USE)) {
+			*busID = vCodec.busID;
+			*protocol = vCodec.protocol;
+			*masterSlave = vCodec.masterSlave;
+			*numSlots = vCodec.numSlots;
+			rc = PMIC_SUCCESS;
+		}
+
+		/* Exit critical section. */
+		up(&mutex);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_get_protocol);
+
+/*!
+ * @brief Enable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly enable the Stereo DAC or the Voice
+ * CODEC to begin audio
+ * playback or recording as required. This should
+ * only be done after
+ * successfully configuring all of the associated
+ * audio components (e.g.,
+ * microphones, amplifiers, etc.).
+ *
+ * Note that the timed delays used in this function
+ * are necessary to
+ * ensure reliable operation of the Voice CODEC and
+ * Stereo DAC. The
+ * Stereo DAC seems to be particularly sensitive and
+ * it has been observed
+ * to fail to generate the required master mode clock
+ * signals if it is
+ * not allowed enough time to initialize properly.
+ *
+ * @param      handle          Device handle from
+ * pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was
+ * successful enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is
+ * invalid.
+ * @retval      PMIC_ERROR           If the device could
+ * not be enabled.
+ */
+PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle)
+{
+	const unsigned int AUDIO_BIAS_ENABLE = SET_BITS(regAUDIO_RX_0,
+			VAUDIOON, 1);
+	const unsigned int STDAC_ENABLE = SET_BITS(regST_DAC, STDCEN, 1);
+	const unsigned int VCODEC_ENABLE = SET_BITS(regAUD_CODEC, CDCEN, 1);
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a
+	 * consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		/* Must first set the audio bias
+		 * bit to power up the audio circuits. */
+		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
+				AUDIO_BIAS_ENABLE);
+		reg_mask = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+			SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+			SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+		/* Then we can enable the Stereo DAC. */
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+				STDAC_ENABLE, STDAC_ENABLE);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug("Failed to enable the Stereo DAC\n");
+			rc = PMIC_ERROR;
+		}
+	} else if ((handle == vCodec.handle)
+			&& (vCodec.handleState == HANDLE_IN_USE)) {
+		/* Must first set the audio bias bit
+		 * to power up the audio circuits. */
+		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
+				AUDIO_BIAS_ENABLE);
+		reg_mask = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+			SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+			SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+		/* Then we can enable the Voice CODEC. */
+		rc = pmic_write_reg(REG_AUDIO_CODEC, VCODEC_ENABLE,
+				VCODEC_ENABLE);
+
+		/* pmic_read_reg(REG_AUDIO_CODEC, &reg_value); */
+		if (rc != PMIC_SUCCESS) {
+			pr_debug("Failed to enable the Voice codec\n");
+			rc = PMIC_ERROR;
+		}
+	}
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_enable);
+
+/*!
+ * @brief Disable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly disable the Stereo DAC or the Voice
+ * CODEC to end audio
+ * playback or recording as required.
+ *
+ * @param   	handle          Device handle from
+ * pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was
+ * successful disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could
+ * not be disabled.
+ */
+PMIC_STATUS pmic_audio_disable(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int STDAC_DISABLE = SET_BITS(regST_DAC, STDCEN, 1);
+	const unsigned int VCODEC_DISABLE = SET_BITS(regAUD_CODEC, CDCEN, 1);
+
+	/* Use a critical section to ensure a
+	 * consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC, 0, STDAC_DISABLE);
+	else if ((handle == vCodec.handle)
+			&& (vCodec.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_CODEC, 0, VCODEC_DISABLE);
+
+	if (rc == PMIC_SUCCESS)
+		pr_debug("Disabled successfully\n");
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_disable);
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their initial power on state.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	rc = pmic_audio_reset_device(handle);
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_reset);
+
+/*!
+ * @brief Reset all audio hardware control registers to their power on state.
+ *
+ * This resets all of the audio hardware control registers back to their
+ * power on states. Use this function with care since it also invalidates
+ * (i.e., automatically closes) all currently opened device handles.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset_all(void)
+{
+	PMIC_STATUS rc = PMIC_SUCCESS;
+	unsigned int audio_ssi_reset = 0;
+	unsigned int audio_rx1_reset = 0;
+	/* We need a critical section here to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* First close all opened device handles, also deregisters callbacks. */
+	pmic_audio_close_handle(stDAC.handle);
+	pmic_audio_close_handle(vCodec.handle);
+	pmic_audio_close_handle(extStereoIn.handle);
+
+	if (pmic_write_reg(REG_AUDIO_RX_1, RESET_AUDIO_RX_1,
+				PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else
+		audio_rx1_reset = 1;
+
+	if (pmic_write_reg(REG_AUDIO_SSI_NETWORK, RESET_SSI_NETWORK,
+				PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else
+		audio_ssi_reset = 1;
+
+	if (pmic_write_reg
+			(REG_AUDIO_STEREO_DAC, RESET_ST_DAC,
+			 PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else {
+		/* Also reset the driver state
+		 * information to match. Note that we
+		 * keep the device handle and event
+		 * callback settings unchanged
+		 * since these don't affect the actual
+		 * hardware and we rely on
+		 * the user to explicitly close the handle
+		 * or deregister callbacks
+		 */
+		if (audio_ssi_reset) {
+			/* better to check if SSI is also reset
+			 * as some fields are represennted in SSI reg */
+			stDAC.busID = AUDIO_DATA_BUS_1;
+			stDAC.protocol = NORMAL_MSB_JUSTIFIED_MODE;
+			stDAC.masterSlave = BUS_MASTER_MODE;
+			stDAC.protocol_set = false;
+			stDAC.numSlots = USE_2_TIMESLOTS;
+			stDAC.clockIn = CLOCK_IN_CLIA;
+			stDAC.samplingRate = STDAC_RATE_44_1_KHZ;
+			stDAC.clockFreq = STDAC_CLI_13MHZ;
+			stDAC.invert = NO_INVERT;
+			stDAC.timeslot = USE_TS0_TS1;
+			stDAC.config = (PMIC_AUDIO_STDAC_CONFIG) 0;
+		}
+	}
+
+	if (pmic_write_reg(REG_AUDIO_CODEC, RESET_AUD_CODEC,
+				PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else {
+		/* Also reset the driver state information to match.
+		 * Note that we
+		 * keep the device handle and event callback settings
+		 * unchanged
+		 * since these don't affect the actual hardware and
+		 * we rely on
+		 * the user to explicitly close the handle or
+		 * deregister callbacks
+		 */
+		if (audio_ssi_reset) {
+			vCodec.busID = AUDIO_DATA_BUS_2;
+			vCodec.protocol = NETWORK_MODE;
+			vCodec.masterSlave = BUS_SLAVE_MODE;
+			vCodec.protocol_set = false;
+			vCodec.numSlots = USE_4_TIMESLOTS;
+			vCodec.clockIn = CLOCK_IN_CLIB;
+			vCodec.samplingRate = VCODEC_RATE_8_KHZ;
+			vCodec.clockFreq = VCODEC_CLI_13MHZ;
+			vCodec.invert = NO_INVERT;
+			vCodec.timeslot = USE_TS0;
+			vCodec.config =
+				INPUT_HIGHPASS_FILTER | OUTPUT_HIGHPASS_FILTER;
+		}
+	}
+
+	if (pmic_write_reg(REG_AUDIO_RX_0, RESET_AUDIO_RX_0,
+				PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else {
+		/* Also reset the driver state information to match. */
+		audioOutput.outputPort = (PMIC_AUDIO_OUTPUT_PORT) NULL;
+		audioOutput.vCodecoutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.stDacoutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.extStereooutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.balanceLeftGain = BAL_GAIN_0DB;
+		audioOutput.balanceRightGain = BAL_GAIN_0DB;
+		audioOutput.monoAdderGain = MONOADD_GAIN_0DB;
+		audioOutput.config = (PMIC_AUDIO_OUTPUT_CONFIG) 0;
+		audioOutput.vCodecOut = VCODEC_DIRECT_OUT;
+	}
+
+	if (pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX,
+				PMIC_ALL_BITS) != PMIC_SUCCESS)
+		rc = PMIC_ERROR;
+	else {
+		/* Also reset the driver state information to
+		 * match. Note that we
+		 * reset the vCodec fields since all of the
+		 * input/recording
+		 * devices are only connected to the Voice CODEC
+		 * and are managed
+		 * as part of the Voice CODEC state.
+		 */
+		if (audio_rx1_reset) {
+			vCodec.leftChannelMic.mic = NO_MIC;
+			vCodec.leftChannelMic.micOnOff = MICROPHONE_OFF;
+			vCodec.leftChannelMic.ampMode = CURRENT_TO_VOLTAGE;
+			vCodec.leftChannelMic.gain = MIC_GAIN_0DB;
+			vCodec.rightChannelMic.mic = NO_MIC;
+			vCodec.rightChannelMic.micOnOff = MICROPHONE_OFF;
+			vCodec.rightChannelMic.ampMode = AMP_OFF;
+			vCodec.rightChannelMic.gain = MIC_GAIN_0DB;
+		}
+	}
+	/* Finally, also reset any global
+	 * state variables. */
+	headsetState = NO_HEADSET;
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_reset_all);
+
+/*!
+ * @brief Set the Audio callback function.
+ *
+ * Register a callback function that will be used
+ * to signal PMIC audio
+ * events. For example, the OSS audio driver should
+ * register a callback
+ * function in order to be notified of headset
+ * connect/disconnect events.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   func            A pointer to the callback function.
+ * @param   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was
+ * successfully registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the
+ * eventMask is invalid.
+ */
+PMIC_STATUS pmic_audio_set_callback(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CALLBACK func,
+		const PMIC_AUDIO_EVENTS eventMask)
+{
+	/* Event handling and callback are currently
+	 * not supported for mc13783 */
+	/* Both in case of PMIC and old API */
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_set_callback);
+
+/*!
+ * @brief Deregisters the existing audio callback function.
+ *
+ * Deregister the callback function that was
+ * previously registered by calling
+ * pmic_audio_set_callback().
+ *
+ * @param       handle          Device handle from
+ * pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_clear_callback(const PMIC_AUDIO_HANDLE handle)
+{
+	/* Event handling and callback are
+	 * currently not supported for mc13783 */
+	/* Both in case of PMIC and old API */
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_clear_callback);
+
+/*!
+ * @brief Get the current audio callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   func            The current callback function.
+ * @param   eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_callback(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CALLBACK * const func,
+		PMIC_AUDIO_EVENTS * const eventMask)
+{
+	/* Event handling and callback are currently
+	 * not supported for mc13783 */
+	/* Both in case of PMIC and old API */
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_get_callback);
+
+/*!
+ * @brief Enable the anti-pop circuitry to avoid
+ * extra noise when inserting
+ * or removing a external device (e.g., a headset).
+ *
+ * Enable the use of the built-in anti-pop circuitry
+ * to prevent noise from
+ * being generated when an external audio device is
+ * inserted or removed
+ * from an audio plug. A slow ramp speed may be needed
+ * to avoid extra noise.
+ *
+ * @param       rampSpeed       The desired anti-pop
+ * circuitry ramp speed.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop
+ * circuitry was successfully
+ *                                   enabled.
+ * @retval      PMIC_ERROR           If the anti-pop
+ * circuitry could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_antipop_enable(const PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+		rampSpeed)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, BIASEN, 1) |
+		SET_BITS(regAUDIO_RX_0, BIASSPEED, 1);
+
+	/* No critical section required here since we are
+	 * not updating any
+	 * global data.
+	 */
+
+	/*
+	 * Antipop is enabled by enabling the BIAS (BIASEN) and
+	 * setting the BIASSPEED .
+	 * BIASEN is just to make sure that BIAS is enabled
+	 */
+	reg_value = SET_BITS(regAUDIO_RX_0, BIASEN, 1) |
+		SET_BITS(regAUDIO_RX_0, BIASSPEED, 1);
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_value, reg_mask);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_antipop_enable);
+
+/*!
+ * @brief Disable the anti-pop circuitry.
+ *
+ * Disable the use of the built-in anti-pop circuitry
+ * to prevent noise from
+ * being generated when an external audio device
+ * is inserted or removed
+ * from an audio plug.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   disabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_antipop_disable(void)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, BIASSPEED, 1) |
+		SET_BITS(regAUDIO_RX_0, BIASEN, 1);
+	const unsigned int reg_write = SET_BITS(regAUDIO_RX_0, BIASSPEED, 1) |
+		SET_BITS(regAUDIO_RX_0, BIASEN, 0);
+
+	/* No critical section required here since we
+	 * are not updating any global data.
+	 */
+
+	/*
+	 * Antipop is disabled by setting BIASSPEED  = 0.
+	 * BIASEN bit remains set as only antipop needs to be disabled
+	 */
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_antipop_disable);
+
+/*!
+ * @brief Performs a reset of the Voice CODEC/Stereo DAC
+ * digital filter.
+ *
+ * The digital filter should be reset whenever the clock
+ * or sampling rateconfiguration has been changed.
+ *
+ * @param       handle          Device handle from
+ * pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the digital filter was successfully
+ *                                   reset.
+ * @retval      PMIC_ERROR           If the digital filter could not be reset.
+ */
+PMIC_STATUS pmic_audio_digital_filter_reset(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are
+	 * not updating any global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regST_DAC, STDCRESET, 1);
+#ifdef CONFIG_MACH_MX31LITE
+		if (pmic_write_reg(REG_AUDIO_STEREO_DAC, 1,
+#else
+		if (pmic_write_reg(REG_AUDIO_STEREO_DAC, reg_mask,
+#endif
+					reg_mask) != PMIC_SUCCESS)
+			rc = PMIC_ERROR;
+		else
+			pr_debug("STDAC filter reset\n");
+
+	} else if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUD_CODEC, CDCRESET, 1);
+		if (pmic_write_reg(REG_AUDIO_CODEC, reg_mask,
+					reg_mask) != PMIC_SUCCESS)
+			rc = PMIC_ERROR;
+		else
+			pr_debug("CODEC filter reset\n");
+	}
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_digital_filter_reset);
+
+/*!
+ * @brief Get the most recent PTT button voltage reading.
+ *
+ * This feature is not supported by mc13783
+ * @param       level                PTT button level.
+ *
+ * @retval      PMIC_SUCCESS         If the most recent
+ * PTT button voltage was returned.
+ * @retval      PMIC_PARAMETER_ERROR If a NULL pointer
+ * argument was given.
+ */
+PMIC_STATUS pmic_audio_get_ptt_button_level(unsigned int *const level)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+#ifdef DEBUG_AUDIO
+
+/*!
+ * @brief Provide a hexadecimal dump of all PMIC
+ * audio registers (DEBUG only)
+ *
+ * This function is intended strictly for debugging
+ * purposes only and will
+ * print the current values of the following PMIC registers:
+ *
+ * - AUD_CODEC
+ * - ST_DAC
+ * - AUDIO_RX_0
+ * - AUDIO_RX_1
+ * - AUDIO_TX
+ * - AUDIO_SSI_NW
+ *
+ * The register fields will not be decoded.
+ *
+ * Note that we don't dump any of the arbitration bits
+ * because we cannot
+ * access the true arbitration bit settings when reading
+ * the registers
+ * from the secondary SPI bus.
+ *
+ * Also note that we must not call this function with
+ * interrupts disabled,
+ * for example, while holding a spinlock, because calls
+ * to pmic_read_reg()
+ * eventually end up in the SPI driver which will want
+ * to perform a
+ * schedule() operation. If schedule() is called with
+ * interrupts disabled,
+ * then you will see messages like the following:
+ *
+ * BUG: scheduling while atomic: ...
+ *
+ */
+void pmic_audio_dump_registers(void)
+{
+	unsigned int reg_value = 0;
+
+	/* Dump the AUD_CODEC (Voice CODEC) register. */
+	if (pmic_read_reg(REG_AUDIO_CODEC, &reg_value, REG_FULLMASK)
+			== PMIC_SUCCESS)
+		pr_debug("Audio Codec = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read audio codec\n");
+
+	/* Dump the ST DAC (Stereo DAC) register. */
+	if (pmic_read_reg
+			(REG_AUDIO_STEREO_DAC, &reg_value, REG_FULLMASK) == PMIC_SUCCESS)
+		pr_debug("Stereo DAC = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read Stereo DAC\n");
+
+	/* Dump the SSI NW register. */
+	if (pmic_read_reg
+			(REG_AUDIO_SSI_NETWORK, &reg_value, REG_FULLMASK) == PMIC_SUCCESS)
+		pr_debug("SSI Network = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read SSI network\n");
+
+	/* Dump the Audio RX 0 register. */
+	if (pmic_read_reg(REG_AUDIO_RX_0, &reg_value, REG_FULLMASK)
+			== PMIC_SUCCESS)
+		pr_debug("Audio RX 0 = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read audio RX 0\n");
+
+	/* Dump the Audio RX 1 register. */
+	if (pmic_read_reg(REG_AUDIO_RX_1, &reg_value, REG_FULLMASK)
+			== PMIC_SUCCESS)
+		pr_debug("Audio RX 1 = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read audio RX 1\n");
+	/* Dump the Audio TX register. */
+	if (pmic_read_reg(REG_AUDIO_TX, &reg_value, REG_FULLMASK) ==
+			PMIC_SUCCESS)
+		pr_debug("Audio Tx = 0x%x\n", reg_value);
+	else
+		pr_debug("Failed to read audio TX\n");
+
+}
+
+#endif				/* DEBUG_AUDIO */
+
+/*@}*/
+
+/*********************************************************
+ * General Voice CODEC configuration.
+ *********************************************************
+ */
+
+/*!
+ * @name General Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the
+ * PMIC Voice
+ * CODEC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Voice CODEC clock source and operating
+ * characteristics.
+ *
+ * Define the Voice CODEC clock source and operating
+ * characteristics. This
+ * must be done before the Voice CODEC is enabled.
+ *
+ *
+ *
+ * @param       handle          Device handle from
+ * pmic_audio_open() call.
+ * @param       clockIn         Select the clock
+ * signal source.
+ * @param       clockFreq       Select the clock
+ * signal frequency.
+ * @param       samplingRate    Select the audio data
+ * sampling rate.
+ * @param       invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock
+ * settings were successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock
+ * configuration was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock
+ * configuration could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE
+		clockIn,
+		const PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_VCODEC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Validate all of the calling parameters. */
+	if (handle == (PMIC_AUDIO_HANDLE) NULL)
+		rc = PMIC_PARAMETER_ERROR;
+	else if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if ((clockIn != CLOCK_IN_CLIA) && (clockIn != CLOCK_IN_CLIB))
+			rc = PMIC_PARAMETER_ERROR;
+		else if (!((clockFreq >= VCODEC_CLI_13MHZ)
+					&& (clockFreq <= VCODEC_CLI_33_6MHZ)))
+			rc = PMIC_PARAMETER_ERROR;
+		else if ((samplingRate != VCODEC_RATE_8_KHZ)
+				&& (samplingRate != VCODEC_RATE_16_KHZ))
+			rc = PMIC_PARAMETER_ERROR;
+		else if (!((invert >= NO_INVERT) &&
+					(invert <= INVERT_FRAMESYNC)))
+			rc = PMIC_PARAMETER_ERROR;
+		else {
+
+			if (clockIn == CLOCK_IN_CLIA)
+				reg_value =
+					SET_BITS(regAUD_CODEC, CDCCLKSEL, 0);
+			else
+				reg_value =
+					SET_BITS(regAUD_CODEC, CDCCLKSEL, 1);
+
+			reg_mask = SET_BITS(regAUD_CODEC, CDCCLKSEL, 1);
+			if (PMIC_SUCCESS !=
+					pmic_write_reg(REG_AUDIO_CODEC,
+						reg_value, reg_mask))
+				return PMIC_ERROR;
+
+			reg_value = 0;
+			if (clockFreq == VCODEC_CLI_13MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 0);
+			else if (clockFreq == VCODEC_CLI_15_36MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 1);
+			else if (clockFreq == VCODEC_CLI_16_8MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 2);
+			else if (clockFreq == VCODEC_CLI_26MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 4);
+			else
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 7);
+
+			reg_mask = SET_BITS(regAUD_CODEC, CDCCLK, 7);
+			if (PMIC_SUCCESS !=
+					pmic_write_reg(REG_AUDIO_CODEC,
+						reg_value, reg_mask))
+				return PMIC_ERROR;
+
+			reg_value = 0;
+			reg_mask = 0;
+
+			if (samplingRate == VCODEC_RATE_8_KHZ)
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCFS8K16K, 0);
+			else
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCFS8K16K, 1);
+
+			reg_mask = SET_BITS(regAUD_CODEC, CDCFS8K16K, 1);
+			if (PMIC_SUCCESS !=
+					pmic_write_reg(REG_AUDIO_CODEC,
+						reg_value, reg_mask))
+				return PMIC_ERROR;
+			reg_value = 0;
+			reg_mask =
+				SET_BITS(regAUD_CODEC, CDCBCLINV,
+						1) | SET_BITS(regAUD_CODEC, CDCFSINV, 1);
+
+			if (invert & INVERT_BITCLOCK)
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCBCLINV, 1);
+
+			if (invert & INVERT_FRAMESYNC)
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCFSINV, 1);
+
+			if (invert & NO_INVERT) {
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCBCLINV, 0);
+				reg_value |=
+					SET_BITS(regAUD_CODEC, CDCFSINV, 0);
+			}
+			if (pmic_write_reg
+					(REG_AUDIO_CODEC, reg_value,
+					 reg_mask) != PMIC_SUCCESS)
+				rc = PMIC_ERROR;
+			else {
+				pr_debug("CODEC clock set\n");
+				vCodec.clockIn = clockIn;
+				vCodec.clockFreq = clockFreq;
+				vCodec.samplingRate = samplingRate;
+				vCodec.invert = invert;
+			}
+
+		}
+
+	} else
+		rc = PMIC_PARAMETER_ERROR;
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_clock);
+
+/*!
+ * @brief Get the Voice CODEC clock source and
+ * operating characteristics.
+ *
+ * Get the current Voice CODEC clock source and
+ * operating characteristics.
+ *
+ * @param  	handle          Device handle from
+ * pmic_audio_open() call.
+ * @param  	clockIn         The clock signal source.
+ * @param  	clockFreq       The clock signal frequency.
+ * @param  	samplingRate    The audio data sampling rate.
+ * @param       invert          Inversion of the frame
+ * sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC
+ * clock settings were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock
+ * configuration could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_VCODEC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_CLOCK_INVERT * const invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure
+	 * that we return a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(clockIn != (PMIC_AUDIO_CLOCK_IN_SOURCE *) NULL) &&
+			(clockFreq != (PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *) NULL) &&
+			(samplingRate != (PMIC_AUDIO_VCODEC_SAMPLING_RATE *) NULL) &&
+			(invert != (PMIC_AUDIO_CLOCK_INVERT *) NULL)) {
+		*clockIn = vCodec.clockIn;
+		*clockFreq = vCodec.clockFreq;
+		*samplingRate = vCodec.samplingRate;
+		*invert = vCodec.invert;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_clock);
+
+/*!
+ * @brief Set the Voice CODEC primary audio channel timeslot.
+ *
+ * Set the Voice CODEC primary audio channel timeslot.
+ * This function must be
+ * used if the default timeslot for the primary audio
+ * channel is to be changed.
+ *
+ * @param       handle          Device handle from
+ * pmic_audio_open() call.
+ * @param       timeslot        Select the primary
+ * audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC
+ * primary audio channel timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio
+ * channel timeslot was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC
+ * primary audio channel timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regSSI_NETWORK, CDCTXRXSLOT, 3);
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			((timeslot == USE_TS0) || (timeslot == USE_TS1) ||
+			 (timeslot == USE_TS2) || (timeslot == USE_TS3))) {
+		reg_write = SET_BITS(regSSI_NETWORK, CDCTXRXSLOT, timeslot);
+
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.timeslot = timeslot;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_rxtx_timeslot);
+
+/*!
+ * @brief Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param       timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(timeslot != (PMIC_AUDIO_VCODEC_TIMESLOT *) NULL)) {
+		*timeslot = vCodec.timeslot;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_rxtx_timeslot);
+
+/*!
+ * @brief Set the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Set the Voice CODEC secondary audio channel timeslot.
+ * This function must be
+ * used if the default timeslot for the secondary audio
+ * channel is to be
+ * changed. The secondary audio channel timeslot is used
+ * to transmit the audio
+ * data that was recorded by the Voice CODEC from the
+ * secondary audio input
+ * channel.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   timeslot        Select the secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary
+ * audio channel timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio
+ * channel timeslot was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary
+ * audio channel timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		const
+		PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regSSI_NETWORK, CDCTXSECSLOT, 3);
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a
+	 * consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		/* How to handle primary slot and
+		 * secondary slot being the same */
+		if ((timeslot >= USE_TS0) && (timeslot <= USE_TS3)
+				&& (timeslot != vCodec.timeslot)) {
+			reg_write =
+				SET_BITS(regSSI_NETWORK, CDCTXSECSLOT, timeslot);
+
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				vCodec.secondaryTXtimeslot = timeslot;
+		}
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_secondary_txslot);
+
+/*!
+ * @brief Get the Voice CODEC secondary recording
+ * audio channel timeslot.
+ *
+ * Get the Voice CODEC secondary audio channel timeslot.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       timeslot        The secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(timeslot != (PMIC_AUDIO_VCODEC_TIMESLOT *) NULL)) {
+		rc = PMIC_SUCCESS;
+		*timeslot = vCodec.secondaryTXtimeslot;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_secondary_txslot);
+
+/*!
+ * @brief Set/Enable the Voice CODEC options.
+ *
+ * Set or enable various Voice CODEC options. The available options include
+ * the use of dithering, highpass digital filters, and loopback modes.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       config          The Voice CODEC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (config & DITHERING) {
+			reg_write = SET_BITS(regAUD_CODEC, CDCDITH, 0);
+			reg_mask = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+		}
+
+		if (config & INPUT_HIGHPASS_FILTER) {
+			reg_write |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+		}
+
+		if (config & OUTPUT_HIGHPASS_FILTER) {
+			reg_write |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+		}
+
+		if (config & DIGITAL_LOOPBACK) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+		}
+
+		if (config & ANALOG_LOOPBACK) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+		}
+
+		if (config & VCODEC_MASTER_CLOCK_OUTPUTS) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1) |
+				SET_BITS(regAUD_CODEC, CDCTS, 0);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1) |
+				SET_BITS(regAUD_CODEC, CDCTS, 1);
+
+		}
+
+		if (config & TRISTATE_TS) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+		}
+
+		if (reg_mask == 0)
+			/* We should not reach this point without having to configure
+			 * anything so we flag it as an error.
+			 */
+			rc = PMIC_ERROR;
+		else
+			rc = pmic_write_reg(REG_AUDIO_CODEC,
+					reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.config |= config;
+	}
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_config);
+
+/*!
+ * @brief Clear/Disable the Voice CODEC options.
+ *
+ * Clear or disable various Voice CODEC options.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   config          The Voice CODEC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG
+		config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (config & DITHERING) {
+			reg_mask = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+			reg_write = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+		}
+
+		if (config & INPUT_HIGHPASS_FILTER)
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+
+		if (config & OUTPUT_HIGHPASS_FILTER)
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+
+		if (config & DIGITAL_LOOPBACK)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+
+		if (config & ANALOG_LOOPBACK)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+
+		if (config & VCODEC_MASTER_CLOCK_OUTPUTS)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1);
+
+		if (config & TRISTATE_TS)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+
+		if (reg_mask == 0)
+			/* We should not reach this point without having to configure
+			 * anything so we flag it as an error.
+			 */
+			rc = PMIC_ERROR;
+		else
+			rc = pmic_write_reg(REG_AUDIO_CODEC,
+					reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.config |= config;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_clear_config);
+
+/*!
+ * @brief Get the current Voice CODEC options.
+ *
+ * Get the current Voice CODEC options.
+ *
+ * @param   	handle          Device handle from pmic_audio_open() call.
+ * @param	config          The current set of Voice CODEC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_CONFIG *
+		const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(config != (PMIC_AUDIO_VCODEC_CONFIG *) NULL)) {
+		*config = vCodec.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_config);
+
+/*!
+ * @brief Enable the Voice CODEC bypass audio pathway.
+ *
+ * Enables the Voice CODEC bypass pathway for audio data. This allows direct
+ * output of the voltages on the TX data bus line to the output amplifiers
+ * (bypassing the digital-to-analog converters within the Voice CODEC).
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_bypass(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+	const unsigned int reg_mask = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_CODEC, reg_write, reg_mask);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_bypass);
+
+/*!
+ * @brief Disable the Voice CODEC bypass audio pathway.
+ *
+ * Disables the Voice CODEC bypass pathway for audio data. This means that
+ * the TX data bus line will deliver digital data to the digital-to-analog
+ * converters within the Voice CODEC.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_bypass(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_CODEC, reg_write, reg_mask);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_bypass);
+
+/*@}*/
+
+/*************************************************************************
+ * General Stereo DAC configuration.
+ *************************************************************************
+ */
+
+/*!
+ * @name General Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo
+ * DAC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Stereo DAC clock source and operating characteristics.
+ *
+ * Define the Stereo DAC clock source and operating characteristics. This
+ * must be done before the Stereo DAC is enabled.
+ *
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   clockIn         Select the clock signal source.
+ * @param   clockFreq       Select the clock signal frequency.
+ * @param   samplingRate    Select the audio data sampling rate.
+ * @param   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE clockIn,
+		const PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_STDAC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	/* Validate all of the calling parameters. */
+	if (handle == (PMIC_AUDIO_HANDLE) NULL)
+		rc = PMIC_PARAMETER_ERROR;
+	else if ((handle == stDAC.handle) &&
+			(stDAC.handleState == HANDLE_IN_USE)) {
+		if ((clockIn != CLOCK_IN_CLIA) && (clockIn != CLOCK_IN_CLIB))
+			rc = PMIC_PARAMETER_ERROR;
+		else if ((stDAC.masterSlave == BUS_MASTER_MODE)
+				&& !((clockFreq >= STDAC_CLI_3_36864MHZ)
+					&& (clockFreq <= STDAC_CLI_33_6MHZ)))
+			rc = PMIC_PARAMETER_ERROR;
+		else if ((stDAC.masterSlave == BUS_SLAVE_MODE)
+				&& !((clockFreq >= STDAC_MCLK_PLL_DISABLED)
+					&& (clockFreq <= STDAC_BCLK_IN_PLL)))
+			rc = PMIC_PARAMETER_ERROR;
+		else if (!((samplingRate >= STDAC_RATE_8_KHZ)
+					&& (samplingRate <= STDAC_RATE_96_KHZ)))
+			rc = PMIC_PARAMETER_ERROR;
+		else {
+			reg_mask = SET_BITS(regST_DAC, STDCCLK, 7) |
+				SET_BITS(regST_DAC, STDCCLKSEL, 1) |
+				SET_BITS(regST_DAC, SR, 15) |
+				SET_BITS(regST_DAC, STDCBCLINV, 1) |
+				SET_BITS(regST_DAC, STDCFSINV, 1);
+			if (clockIn == CLOCK_IN_CLIA)
+				reg_value = SET_BITS(regST_DAC, STDCCLKSEL, 0);
+			else
+				reg_value = SET_BITS(regST_DAC, STDCCLKSEL, 1);
+
+			/* How to take care of sample rates in SLAVE mode */
+			if ((clockFreq == STDAC_CLI_3_36864MHZ)
+					|| ((clockFreq == STDAC_FSYNC_IN_PLL)))
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 6);
+			else if ((clockFreq == STDAC_CLI_12MHZ)
+					|| (clockFreq == STDAC_MCLK_PLL_DISABLED))
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 5);
+			else if (clockFreq == STDAC_CLI_13MHZ)
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 0);
+			else if (clockFreq == STDAC_CLI_15_36MHZ)
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 1);
+			else if (clockFreq == STDAC_CLI_16_8MHZ)
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 2);
+			else if (clockFreq == STDAC_CLI_26MHZ)
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 4);
+			else if ((clockFreq == STDAC_CLI_33_6MHZ)
+					|| (clockFreq == STDAC_BCLK_IN_PLL))
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 7);
+
+			reg_value |= SET_BITS(regST_DAC, SR, samplingRate);
+
+			if (invert & INVERT_BITCLOCK)
+				reg_value |= SET_BITS(regST_DAC, STDCBCLINV, 1);
+
+			if (invert & INVERT_FRAMESYNC)
+				reg_value |= SET_BITS(regST_DAC, STDCFSINV, 1);
+
+			if (invert & NO_INVERT) {
+				reg_value |= SET_BITS(regST_DAC, STDCBCLINV, 0);
+				reg_value |= SET_BITS(regST_DAC, STDCFSINV, 0);
+			}
+			if (pmic_write_reg
+					(REG_AUDIO_STEREO_DAC, reg_value,
+					 reg_mask) != PMIC_SUCCESS)
+				rc = PMIC_ERROR;
+			else {
+				pr_debug("STDAC clock set\n");
+				rc = PMIC_SUCCESS;
+				stDAC.clockIn = clockIn;
+				stDAC.clockFreq = clockFreq;
+				stDAC.samplingRate = samplingRate;
+				stDAC.invert = invert;
+			}
+
+		}
+
+	} else
+		rc = PMIC_PARAMETER_ERROR;
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_set_clock);
+
+/*!
+ * @brief Get the Stereo DAC clock source and operating characteristics.
+ *
+ * Get the current Stereo DAC clock source and operating characteristics.
+ *
+ * @param  handle          Device handle from pmic_audio_open() call.
+ * @param  clockIn         The clock signal source.
+ * @param  clockFreq       The clock signal frequency.
+ * @param  samplingRate    The audio data sampling rate.
+ * @param  invert          Inversion of the frame sync and/or
+ *                         bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_STDAC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_CLOCK_INVERT * const invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+			(stDAC.handleState == HANDLE_IN_USE) &&
+			(clockIn != (PMIC_AUDIO_CLOCK_IN_SOURCE *) NULL) &&
+			(samplingRate != (PMIC_AUDIO_STDAC_SAMPLING_RATE *) NULL) &&
+			(clockFreq != (PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *) NULL) &&
+			(invert != (PMIC_AUDIO_CLOCK_INVERT *) NULL)) {
+		*clockIn = stDAC.clockIn;
+		*samplingRate = stDAC.samplingRate;
+		*clockFreq = stDAC.clockFreq;
+		*invert = stDAC.invert;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_get_clock);
+
+/*!
+ * @brief Set the Stereo DAC primary audio channel timeslot.
+ *
+ * Set the Stereo DAC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param	timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regSSI_NETWORK, STDCRXSLOT, 3);
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if ((timeslot == USE_TS0_TS1) || (timeslot == USE_TS2_TS3)
+				|| (timeslot == USE_TS4_TS5) || (timeslot == USE_TS6_TS7)) {
+			if (pmic_write_reg
+					(REG_AUDIO_SSI_NETWORK, timeslot,
+					 reg_mask) != PMIC_SUCCESS) {
+				rc = PMIC_ERROR;
+			} else {
+				pr_debug("STDAC primary timeslot set\n");
+				stDAC.timeslot = timeslot;
+				rc = PMIC_SUCCESS;
+			}
+
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_set_rxtx_timeslot);
+
+/*!
+ * @brief Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_TIMESLOTS *
+		const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+			(stDAC.handleState == HANDLE_IN_USE) &&
+			(timeslot != (PMIC_AUDIO_STDAC_TIMESLOTS *) NULL)) {
+		*timeslot = stDAC.timeslot;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_get_rxtx_timeslot);
+
+/*!
+ * @brief Set/Enable the Stereo DAC options.
+ *
+ * Set or enable various Stereo DAC options. The available options include
+ * resetting the digital filter and enabling the bus master clock outputs.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   config          The Stereo DAC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if (config & STDAC_MASTER_CLOCK_OUTPUTS) {
+			reg_write |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+			reg_mask |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+		}
+
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			stDAC.config |= config;
+			pr_debug("STDAC config set\n");
+
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_set_config);
+
+/*!
+ * @brief Clear/Disable the Stereo DAC options.
+ *
+ * Clear or disable various Stereo DAC options.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       config          The Stereo DAC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+
+		if (config & STDAC_MASTER_CLOCK_OUTPUTS)
+			reg_mask |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				stDAC.config &= ~config;
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_clear_config);
+
+/*!
+ * @brief Get the current Stereo DAC options.
+ *
+ * Get the current Stereo DAC options.
+ *
+ * @param   	handle          Device handle from pmic_audio_open() call.
+ * @param   	config          The current set of Stereo DAC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_CONFIG * const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+			(stDAC.handleState == HANDLE_IN_USE) &&
+			(config != (PMIC_AUDIO_STDAC_CONFIG *) NULL)) {
+		*config = stDAC.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_get_config);
+
+/*@}*/
+
+/*************************************************************************
+ * Audio input section configuration.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Input Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio
+ * input hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set/Enable the audio input section options.
+ *
+ * Set or enable various audio input section options. The only available
+ * option right now is to enable the automatic disabling of the microphone
+ * input amplifiers when a microphone/headset is inserted or removed.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @param  	handle          Device handle from pmic_audio_open() call.
+ * @param   	config          The audio input section options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_input_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_input_set_config);
+
+/*!
+ * @brief Clear/Disable the audio input section options.
+ *
+ * Clear or disable various audio input section options.
+ *
+ * @param   	handle          Device handle from pmic_audio_open() call.
+ * @param   	config          The audio input section options to be
+ *                              cleared/disabled.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_input_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+
+}
+EXPORT_SYMBOL(pmic_audio_input_clear_config);
+
+/*!
+ * @brief Get the current audio input section options.
+ *
+ * Get the current audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of audio input section options.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_input_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_CONFIG * const config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_input_get_config);
+
+/*@}*/
+
+/*************************************************************************
+ * Audio recording using the Voice CODEC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Recording Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio recording.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the microphone inputs to be used for Voice CODEC recording.
+ *
+ * Select left (mc13783-only) and right microphone inputs for Voice CODEC
+ * recording. It is possible to disable or not use a particular microphone
+ * input channel by specifying NO_MIC as a parameter.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       leftChannel     Select the left microphone input channel.
+ * @param       rightChannel    Select the right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input ports
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be successfully enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_PORT leftChannel,
+		const PMIC_AUDIO_INPUT_PORT rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (!((leftChannel == NO_MIC) ||
+					(leftChannel == MIC1_LEFT)))
+			rc = PMIC_PARAMETER_ERROR;
+		else if (!((rightChannel == NO_MIC)
+					|| (rightChannel == MIC1_RIGHT_MIC_MONO)
+					|| (rightChannel == TXIN_EXT)
+					|| (rightChannel == MIC2_AUX)))
+			rc = PMIC_PARAMETER_ERROR;
+		else {
+			if (leftChannel != NO_MIC) {
+				/* Left channel MIC enable */
+				reg_mask = SET_BITS(regAUDIO_TX, AMC1LEN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1);
+				reg_write = SET_BITS(regAUDIO_TX, AMC1LEN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0);
+			}
+			/*For right channel enable one and
+			 * clear the other two as well as RXINREC */
+			if (rightChannel == MIC1_RIGHT_MIC_MONO) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 0) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 0);
+			} else if (rightChannel == MIC2_AUX) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 0) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 0);
+			} else {	/* TX line in */
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 0) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 0) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+			}
+
+			if (reg_mask == 0)
+				rc = PMIC_PARAMETER_ERROR;
+			else {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug
+						("MIC inputs configured"
+						 "successfully\n");
+					vCodec.leftChannelMic.mic = leftChannel;
+					vCodec.rightChannelMic.mic =
+						rightChannel;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_mic);
+
+/*!
+ * @brief Get the current microphone inputs being used for Voice CODEC
+ *        recording.
+ *
+ * Get the left (mc13783-only) and right microphone inputs currently being
+ * used for Voice CODEC recording.
+ *
+ * @param   	handle          Device handle from pmic_audio_open() call.
+ * @param 	leftChannel     The left microphone input channel.
+ * @param	rightChannel    The right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_PORT * const leftChannel,
+		PMIC_AUDIO_INPUT_PORT *
+		const rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(leftChannel != (PMIC_AUDIO_INPUT_PORT *) NULL) &&
+			(rightChannel != (PMIC_AUDIO_INPUT_PORT *) NULL)) {
+		*leftChannel = vCodec.leftChannelMic.mic;
+		*rightChannel = vCodec.rightChannelMic.mic;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_mic);
+
+/*!
+ * @brief Enable/disable the microphone input.
+ *
+ * This function enables/disables the current microphone input channel. The
+ * input amplifier is automatically turned off when the microphone input is
+ * disabled.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       leftChannel     The left microphone input channel state.
+ * @param       rightChannel    the right microphone input channel state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input states
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		leftChannel,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+	unsigned int curr_left = 0;
+	unsigned int curr_right = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		curr_left = vCodec.leftChannelMic.mic;
+		curr_right = vCodec.rightChannelMic.mic;
+		if ((curr_left == NO_MIC) && (curr_right == NO_MIC)) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else {
+			if (curr_left == MIC1_LEFT) {
+				if ((leftChannel == MICROPHONE_ON) &&
+						(vCodec.leftChannelMic.micOnOff ==
+						 MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1LEN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1LEN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC, 0);
+
+				} else if ((leftChannel == MICROPHONE_OFF) &&
+						(vCodec.leftChannelMic.micOnOff ==
+						 MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1LEN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1LEN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC, 0);
+
+				}
+
+			}
+			if (curr_right == MIC1_RIGHT_MIC_MONO) {
+				if ((rightChannel == MICROPHONE_ON) &&
+						(vCodec.leftChannelMic.micOnOff ==
+						 MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											0) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 0);
+				} else if ((rightChannel == MICROPHONE_OFF)
+						&& (vCodec.leftChannelMic.micOnOff ==
+							MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											0) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 0);
+				}
+			} else if (curr_right == MIC2_AUX) {
+				if ((rightChannel == MICROPHONE_ON)
+						&& (vCodec.leftChannelMic.micOnOff ==
+							MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 0);
+				} else if ((rightChannel == MICROPHONE_OFF)
+						&& (vCodec.leftChannelMic.micOnOff ==
+							MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											0) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 0);
+				}
+			} else if (curr_right == TXIN_EXT) {
+				if ((rightChannel == MICROPHONE_ON)
+						&& (vCodec.leftChannelMic.micOnOff ==
+							MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											0) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+				} else if ((rightChannel == MICROPHONE_OFF)
+						&& (vCodec.leftChannelMic.micOnOff ==
+							MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								1) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									1) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											1) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 1);
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1REN,
+								0) | SET_BITS(regAUDIO_TX,
+									RXINREC,
+									0) |
+									SET_BITS(regAUDIO_TX, AMC2EN,
+											0) | SET_BITS(regAUDIO_TX,
+												ATXINEN, 0);
+				}
+			}
+
+			if (reg_mask != 0) {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug
+						("MIC states configured successfully\n");
+					vCodec.leftChannelMic.micOnOff =
+						leftChannel;
+					vCodec.rightChannelMic.micOnOff =
+						rightChannel;
+				}
+			}
+		}
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_mic_on_off);
+
+/*!
+ * @brief Return the current state of the microphone inputs.
+ *
+ * This function returns the current state (on/off) of the microphone
+ * input channels.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param	leftChannel     The current left microphone input channel
+ *                              state.
+ * @param	rightChannel    the current right microphone input channel
+ *                              state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channel states
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channel states
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const leftChannel,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(leftChannel != (PMIC_AUDIO_INPUT_MIC_STATE *) NULL) &&
+			(rightChannel != (PMIC_AUDIO_INPUT_MIC_STATE *) NULL)) {
+		*leftChannel = vCodec.leftChannelMic.micOnOff;
+		*rightChannel = vCodec.rightChannelMic.micOnOff;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_mic_on_off);
+
+/*!
+ * @brief Set the microphone input amplifier mode and gain level.
+ *
+ * This function sets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param       handle           Device handle from pmic_audio_open() call.
+ * @param       leftChannelMode  The left microphone input amplifier mode.
+ * @param       leftChannelGain  The left microphone input amplifier gain level.
+ * @param       rightChannelMode The right microphone input amplifier mode.
+ * @param       rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifiers were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input amplifier
+ *                                   modes or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifiers could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_record_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		leftChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		leftChannelGain,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		rightChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		rightChannelGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (!(((leftChannelGain >= MIC_GAIN_MINUS_8DB)
+						&& (leftChannelGain <= MIC_GAIN_PLUS_23DB))
+					&& ((rightChannelGain >= MIC_GAIN_MINUS_8DB)
+						&& (rightChannelGain <= MIC_GAIN_PLUS_23DB)))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("VCODEC set record gain - wrong gain value\n");
+		} else if (((leftChannelMode != AMP_OFF)
+					&& (leftChannelMode != VOLTAGE_TO_VOLTAGE)
+					&& (leftChannelMode != CURRENT_TO_VOLTAGE))
+				|| ((rightChannelMode != VOLTAGE_TO_VOLTAGE)
+					&& (rightChannelMode != CURRENT_TO_VOLTAGE)
+					&& (rightChannelMode != AMP_OFF))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("VCODEC set record gain - wrong amp mode\n");
+		} else {
+			if (vCodec.leftChannelMic.mic == MIC1_LEFT) {
+				reg_mask = SET_BITS(regAUDIO_TX, AMC1LITOV, 1) |
+					SET_BITS(regAUDIO_TX, PGATXL, 31);
+				if (leftChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write =
+						SET_BITS(regAUDIO_TX, AMC1LITOV, 0);
+				} else {
+					reg_write =
+						SET_BITS(regAUDIO_TX, AMC1LITOV, 1);
+				}
+				reg_write |=
+					SET_BITS(regAUDIO_TX, PGATXL,
+							leftChannelGain);
+			}
+			if (vCodec.rightChannelMic.mic == MIC1_RIGHT_MIC_MONO) {
+				reg_mask |=
+					SET_BITS(regAUDIO_TX, AMC1RITOV,
+							1) | SET_BITS(regAUDIO_TX, PGATXR,
+								31);
+				if (rightChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1RITOV, 0);
+				} else {
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC1RITOV, 1);
+				}
+				reg_write |=
+					SET_BITS(regAUDIO_TX, PGATXR,
+							rightChannelGain);
+			} else if (vCodec.rightChannelMic.mic == MIC2_AUX) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC2ITOV, 1);
+				reg_mask |= SET_BITS(regAUDIO_TX, PGATXR, 31);
+				if (rightChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC2ITOV, 0);
+				} else {
+					reg_write |=
+						SET_BITS(regAUDIO_TX, AMC2ITOV, 1);
+				}
+				reg_write |=
+					SET_BITS(regAUDIO_TX, PGATXR,
+							rightChannelGain);
+			} else if (vCodec.rightChannelMic.mic == TXIN_EXT) {
+				reg_mask |= SET_BITS(regAUDIO_TX, PGATXR, 31);
+				/* No current to voltage option for TX IN amplifier */
+				reg_write |=
+					SET_BITS(regAUDIO_TX, PGATXR,
+							rightChannelGain);
+			}
+
+			if (reg_mask != 0) {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						reg_write, reg_mask);
+				reg_write =
+					SET_BITS(regAUDIO_TX, PGATXL,
+							leftChannelGain);
+				reg_mask = SET_BITS(regAUDIO_TX, PGATXL, 31);
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("MIC amp mode and gain set\n");
+					vCodec.leftChannelMic.ampMode =
+						leftChannelMode;
+					vCodec.leftChannelMic.gain =
+						leftChannelGain;
+					vCodec.rightChannelMic.ampMode =
+						rightChannelMode;
+					vCodec.rightChannelMic.gain =
+						rightChannelGain;
+
+				}
+			}
+		}
+	}
+
+	/* Exit critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_set_record_gain);
+
+/*!
+ * @brief Get the current microphone input amplifier mode and gain level.
+ *
+ * This function gets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param	handle           Device handle from pmic_audio_open() call.
+ * @param	leftChannelMode  The left microphone input amplifier mode.
+ * @param	leftChannelGain  The left microphone input amplifier gain level.
+ * @param 	rightChannelMode The right microphone input amplifier mode.
+ * @param       rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifier modes
+ *                                   and gain levels were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifier modes
+ *                                   and gain levels could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_record_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const leftChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const leftChannelGain,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const rightChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const rightChannelGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE) &&
+			(leftChannelMode != (PMIC_AUDIO_MIC_AMP_MODE *) NULL) &&
+			(leftChannelGain != (PMIC_AUDIO_MIC_GAIN *) NULL) &&
+			(rightChannelMode != (PMIC_AUDIO_MIC_AMP_MODE *) NULL) &&
+			(rightChannelGain != (PMIC_AUDIO_MIC_GAIN *) NULL)) {
+		*leftChannelMode = vCodec.leftChannelMic.ampMode;
+		*leftChannelGain = vCodec.leftChannelMic.gain;
+		*rightChannelMode = vCodec.rightChannelMic.ampMode;
+		*rightChannelGain = vCodec.rightChannelMic.gain;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_get_record_gain);
+
+/*!
+ * @brief Enable a microphone bias circuit.
+ *
+ * This function enables one of the available microphone bias circuits.
+ *
+ * @param       handle           Device handle from pmic_audio_open() call.
+ * @param       biasCircuit      The microphone bias circuit to be enabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (biasCircuit & MIC_BIAS1) {
+			reg_write = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+			reg_mask = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+		}
+		if (biasCircuit & MIC_BIAS2) {
+			reg_write |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+			reg_mask |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+		}
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_TX, reg_write, reg_mask);
+		}
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_micbias);
+
+/*!
+ * @brief Disable a microphone bias circuit.
+ *
+ * This function disables one of the available microphone bias circuits.
+ *
+ * @param      handle           Device handle from pmic_audio_open() call.
+ * @param      biasCircuit      The microphone bias circuit to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (biasCircuit & MIC_BIAS1)
+			reg_mask = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+
+		if (biasCircuit & MIC_BIAS2)
+			reg_mask |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+
+		if (reg_mask != 0)
+			rc = pmic_write_reg(REG_AUDIO_TX, reg_write, reg_mask);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_micbias);
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Playback Using the Voice CODEC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Playback Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Voice CODEC mixer.
+ *
+ * This function configures and enables the Voice CODEC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ * @param       rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param       gainIn              The secondary audio channel gain level.
+ * @param       gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+		gainOut)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		if (!((rxSecondaryTimeslot >= USE_TS0)
+					&& (rxSecondaryTimeslot <= USE_TS3)))
+			pr_debug
+				("VCODEC enable mixer - wrong sec rx timeslot\n");
+		else if (!((gainIn >= VCODEC_NO_MIX)
+					&& (gainIn <= VCODEC_MIX_IN_MINUS_12DB)))
+			pr_debug("VCODEC enable mixer - wrong mix in gain\n");
+
+		else if (!((gainOut >= VCODEC_MIX_OUT_0DB)
+					&& (gainOut <= VCODEC_MIX_OUT_MINUS_6DB)))
+			pr_debug("VCODEC enable mixer - wrong mix out gain\n");
+		else {
+
+			reg_mask = SET_BITS(regSSI_NETWORK, CDCRXSECSLOT, 3) |
+				SET_BITS(regSSI_NETWORK, CDCRXSECGAIN, 3) |
+				SET_BITS(regSSI_NETWORK, CDCSUMGAIN, 1);
+			reg_write =
+				SET_BITS(regSSI_NETWORK, CDCRXSECSLOT,
+						rxSecondaryTimeslot) |
+				SET_BITS(regSSI_NETWORK, CDCRXSECGAIN,
+						gainIn) | SET_BITS(regSSI_NETWORK,
+							CDCSUMGAIN, gainOut);
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Vcodec mixer enabled\n");
+		}
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_mixer);
+
+/*!
+ * @brief Disable the Voice CODEC mixer.
+ *
+ * This function disables the Voice CODEC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask;
+
+	if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regSSI_NETWORK, CDCRXSECGAIN, 1);
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+				VCODEC_NO_MIX, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			pr_debug("Vcodec mixer disabled\n");
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_mixer);
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Playback Using the Stereo DAC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Playback Using the Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo DAC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Stereo DAC mixer.
+ *
+ * This function configures and enables the Stereo DAC mixer.
+ *
+ * @param      handle              Device handle from pmic_audio_open() call.
+ * @param      rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param      gainIn              The secondary audio channel gain level.
+ * @param      gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_STDAC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+		gainOut)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if (!((rxSecondaryTimeslot >= USE_TS0_TS1)
+					&& (rxSecondaryTimeslot <= USE_TS6_TS7))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong sec timeslot\n");
+		} else if (!((gainIn >= STDAC_NO_MIX)
+					&& (gainIn <= STDAC_MIX_IN_MINUS_12DB))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong mix in gain\n");
+		} else if (!((gainOut >= STDAC_MIX_OUT_0DB)
+					&& (gainOut <= STDAC_MIX_OUT_MINUS_6DB))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong mix out gain\n");
+		} else {
+
+			reg_mask = SET_BITS(regSSI_NETWORK, STDCRXSECSLOT, 3) |
+				SET_BITS(regSSI_NETWORK, STDCRXSECGAIN, 3) |
+				SET_BITS(regSSI_NETWORK, STDCSUMGAIN, 1);
+			reg_write =
+				SET_BITS(regSSI_NETWORK, STDCRXSECSLOT,
+						rxSecondaryTimeslot) |
+				SET_BITS(regSSI_NETWORK, STDCRXSECGAIN,
+						gainIn) | SET_BITS(regSSI_NETWORK,
+							STDCSUMGAIN, gainOut);
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("STDAC mixer enabled\n");
+			}
+		}
+
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_enable_mixer);
+
+/*!
+ * @brief Disable the Stereo DAC mixer.
+ *
+ * This function disables the Stereo DAC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask =
+		SET_BITS(regSSI_NETWORK, STDCRXSECGAIN, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK, reg_write, reg_mask);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_stdac_disable_mixer);
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Output Control
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Output Section Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio output
+ * section to support playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the audio output ports.
+ *
+ * This function selects the audio output ports to be used. This also enables
+ * the appropriate output amplifiers.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports to be used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   acquired.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   acquired.
+ */
+PMIC_STATUS pmic_audio_output_set_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((port == MONO_ALERT) || (port == MONO_EXTOUT)) {
+		rc = PMIC_NOT_SUPPORTED;
+	} else {
+		if (((handle == stDAC.handle)
+					&& (stDAC.handleState == HANDLE_IN_USE))
+				|| ((handle == extStereoIn.handle)
+					&& (extStereoIn.handleState == HANDLE_IN_USE))
+				|| ((handle == vCodec.handle)
+					&& (vCodec.handleState == HANDLE_IN_USE)
+					&& (audioOutput.vCodecOut == VCODEC_MIXER_OUT))) {
+			/* Stereo signal and MIXER source needs to be routed to the port
+			   / Avoid Codec direct out */
+
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPREF, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ALSPEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ALSPREF,
+								1) |
+								SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1) |
+					SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, AHSLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								AHSSEL, 1);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1) |
+					SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, AHSREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								AHSSEL, 1);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+			}
+			if (port & STEREO_LEFT_LOW_POWER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+
+				reg_write |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+			}
+		} else if ((handle == vCodec.handle)
+				&& (vCodec.handleState == HANDLE_IN_USE)
+				&& (audioOutput.vCodecOut = VCODEC_DIRECT_OUT)) {
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ASPSEL, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPREF, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ALSPEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ALSPREF,
+								1) |
+								SET_BITS(regAUDIO_RX_0, ALSPSEL, 0);
+			}
+
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1) |
+					SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, AHSLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								AHSSEL, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1) |
+					SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, AHSREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								AHSSEL, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+							1) | SET_BITS(regAUDIO_RX_0,
+								ARXOUTSEL, 0);
+			}
+			if (port & MONO_CDCOUT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+			}
+		}
+
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("output ports enabled\n");
+				audioOutput.outputPort = port;
+
+			}
+		}
+	}
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_port);
+
+/*!
+ * @brief Deselect/disable the audio output ports.
+ *
+ * This function disables the audio output ports that were previously enabled
+ * by calling pmic_audio_output_set_port().
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_output_clear_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((port == MONO_ALERT) || (port == MONO_EXTOUT)) {
+		rc = PMIC_NOT_SUPPORTED;
+	} else {
+		if (((handle == stDAC.handle)
+					&& (stDAC.handleState == HANDLE_IN_USE))
+				|| ((handle == extStereoIn.handle)
+					&& (extStereoIn.handleState == HANDLE_IN_USE))
+				|| ((handle == vCodec.handle)
+					&& (vCodec.handleState == HANDLE_IN_USE)
+					&& (audioOutput.vCodecOut = VCODEC_MIXER_OUT))) {
+			/* Stereo signal and MIXER source needs to be routed to the port /
+			   Avoid Codec direct out */
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ALSPEN,
+							0) | SET_BITS(regAUDIO_RX_0,
+								ALSPREF, 0);
+
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN, 0);
+			}
+			if (port & STEREO_LEFT_LOW_POWER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, LSPLEN, 0);
+			}
+		} else if ((handle == vCodec.handle)
+				&& (vCodec.handleState == HANDLE_IN_USE)
+				&& (audioOutput.vCodecOut = VCODEC_DIRECT_OUT)) {
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+					SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ALSPEN,
+							0) | SET_BITS(regAUDIO_RX_0,
+								ALSPREF, 0);
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, ARXOUTREN, 0);
+			}
+			if (port & MONO_CDCOUT) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, CDCOUTEN, 0);
+			}
+		}
+
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("output ports disabled\n");
+				audioOutput.outputPort &= ~port;
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current audio output ports.
+ *
+ * This function retrieves the audio output ports that are currently being
+ * used.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports currently being used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_port(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PORT * const port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+					(stDAC.handleState == HANDLE_IN_USE)) ||
+				((handle == vCodec.handle) &&
+				 (vCodec.handleState == HANDLE_IN_USE)) ||
+				((handle == extStereoIn.handle) &&
+				 (extStereoIn.handleState == HANDLE_IN_USE))) &&
+			(port != (PMIC_AUDIO_OUTPUT_PORT *) NULL)) {
+		*port = audioOutput.outputPort;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_port);
+
+/*!
+ * @brief Set the gain level for the external stereo inputs.
+ *
+ * This function sets the gain levels for the external stereo inputs.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The external stereo input gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STEREO_IN_GAIN
+		gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1) |
+		SET_BITS(regAUDIO_RX_1, ARXIN, 1);
+	unsigned int reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	/* The ARX amplifier for stereo is also enabled over here */
+
+	if ((gain == STEREO_IN_GAIN_0DB) ||
+			(gain == STEREO_IN_GAIN_PLUS_18DB)) {
+		if ((handle == extStereoIn.handle) &&
+				(extStereoIn.handleState == HANDLE_IN_USE)) {
+
+			if (gain == STEREO_IN_GAIN_0DB) {
+				reg_write |= SET_BITS(regAUDIO_RX_1, ARXIN, 1);
+			} else {
+				reg_write |= SET_BITS(regAUDIO_RX_1, ARXIN, 0);
+			}
+
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Ext stereo gain set\n");
+				extStereoIn.inputGain = gain;
+
+			}
+
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_stereo_in_gain);
+
+/*!
+ * @brief Get the current gain level for the external stereo inputs.
+ *
+ * This function retrieves the current gain levels for the external stereo
+ * inputs.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current external stereo input gain
+ *                                  level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STEREO_IN_GAIN *
+		const gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == extStereoIn.handle) &&
+			(extStereoIn.handleState == HANDLE_IN_USE) &&
+			(gain != (PMIC_AUDIO_STEREO_IN_GAIN *) NULL)) {
+		*gain = extStereoIn.inputGain;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_stereo_in_gain);
+
+/*!
+ * @brief Set the output PGA gain level.
+ *
+ * This function sets the audio output PGA gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PGA_GAIN gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+	unsigned int reg_gain;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (!((gain >= OUTPGA_GAIN_MINUS_33DB)
+				&& (gain <= OUTPGA_GAIN_PLUS_6DB))) {
+		rc = PMIC_NOT_SUPPORTED;
+		pr_debug("output set PGA gain - wrong gain value\n");
+	} else {
+		if ((gain >= OUTPGA_GAIN_MINUS_33DB)
+				&& (gain <= OUTPGA_GAIN_PLUS_6DB)) {
+			reg_gain = gain + 2;
+		} else {
+			reg_gain = gain;
+		}
+		if ((handle == extStereoIn.handle) &&
+				(extStereoIn.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, ARXIN, 15) |
+				SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+			reg_write = SET_BITS(regAUDIO_RX_1, ARXIN, reg_gain) |
+				SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		} else if ((handle == vCodec.handle) &&
+				(vCodec.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, PGARX, 15);
+			reg_write = SET_BITS(regAUDIO_RX_1, PGARX, reg_gain);
+		} else if ((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, PGAST, 15) |
+				SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+			reg_write = SET_BITS(regAUDIO_RX_1, PGAST, reg_gain) |
+				SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		}
+
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Output PGA gains set\n");
+
+				if (handle == stDAC.handle) {
+					audioOutput.stDacoutputPGAGain = gain;
+				} else if (handle == vCodec.handle) {
+					audioOutput.vCodecoutputPGAGain = gain;
+				} else {
+					audioOutput.extStereooutputPGAGain =
+						gain;
+				}
+			} else {
+				pr_debug
+					("Error writing PGA gains to register\n");
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_pgaGain);
+
+/*!
+ * @brief Get the output PGA gain level.
+ *
+ * This function retrieves the current audio output PGA gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PGA_GAIN *
+		const gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (gain != (PMIC_AUDIO_OUTPUT_PGA_GAIN *) NULL) {
+		if ((handle == extStereoIn.handle) &&
+				(extStereoIn.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.extStereooutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == vCodec.handle) &&
+				(vCodec.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.vCodecoutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.stDacoutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	} else {
+		rc = PMIC_PARAMETER_ERROR;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_pgaGain);
+
+/*!
+ * @brief Enable the output mixer.
+ *
+ * This function enables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask_mix = 0;
+	unsigned int reg_write_mix = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE))) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+	} else if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		audioOutput.vCodecOut = VCODEC_MIXER_OUT;
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+	} else if ((handle == extStereoIn.handle) &&
+			(extStereoIn.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+	}
+
+	if (reg_mask != 0) {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					reg_write_mix, reg_mask_mix);
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Output PGA mixers enabled\n");
+				rc = PMIC_SUCCESS;
+			}
+
+		} else
+			pr_debug("Error writing mixer enable to register\n");
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_enable_mixer);
+
+/*!
+ * @brief Disable the output mixer.
+ *
+ * This function disables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	unsigned int reg_mask_mix = 0;
+	unsigned int reg_write_mix = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE))) {
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 0);
+	} else if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGARXEN, 0);
+		audioOutput.vCodecOut = VCODEC_DIRECT_OUT;
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 0);
+	} else if ((handle == extStereoIn.handle) &&
+			(extStereoIn.handleState == HANDLE_IN_USE)) {
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+	}
+
+	if (reg_mask != 0) {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					reg_write_mix, reg_mask_mix);
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Output PGA mixers disabled\n");
+		}
+	}
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_disable_mixer);
+
+/*!
+ * @brief Configure and enable the output balance amplifiers.
+ *
+ * This function configures and enables the output balance amplifiers.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   leftGain            The desired left channel gain level.
+ * @param   rightGain           The desired right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifiers were
+ *                                   successfully configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifiers could not
+ *                                   be reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_output_set_balance(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		leftGain,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		rightGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask_ch = 0;
+	unsigned int reg_write_ch = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (!((leftGain >= BAL_GAIN_MINUS_21DB) && (leftGain <= BAL_GAIN_0DB)))
+		rc = PMIC_PARAMETER_ERROR;
+	else if (!((rightGain >= BAL_GAIN_MINUS_21DB)
+				&& (rightGain <= BAL_GAIN_0DB)))
+		rc = PMIC_PARAMETER_ERROR;
+	else {
+		if (((handle == stDAC.handle) &&
+					(stDAC.handleState == HANDLE_IN_USE)) ||
+				((handle == vCodec.handle) &&
+				 (vCodec.handleState == HANDLE_IN_USE)) ||
+				((handle == extStereoIn.handle) &&
+				 (extStereoIn.handleState == HANDLE_IN_USE))) {
+			/* In mc13783 only one channel can
+			 * be attenuated wrt the other.
+			 * It is not possible to specify attenuation for both
+			 * This function will return an error if both channels
+			 * are required to be attenuated
+			 * The BALLR bit is set/reset depending
+			 * on whether leftGain
+			 * or rightGain is specified*/
+			if ((rightGain != BAL_GAIN_0DB)
+					&& (leftGain == BAL_GAIN_0DB)) {
+				/* Attenuate right channel */
+				reg_mask = SET_BITS(regAUDIO_RX_1, BAL, 7);
+				reg_mask_ch = SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				reg_write =
+					SET_BITS(regAUDIO_RX_1, BAL,
+							(BAL_GAIN_0DB - rightGain));
+				/* The enum and the register values are reversed in order .. */
+				reg_write_ch =
+					SET_BITS(regAUDIO_RX_1, BALLR, 0);
+				/* BALLR = 0 selects right channel for atten */
+			} else if ((rightGain == BAL_GAIN_0DB)
+					&& (leftGain != BAL_GAIN_0DB)) {
+				/* Attenuate left channel */
+
+				reg_mask = SET_BITS(regAUDIO_RX_1, BAL, 7);
+				reg_mask_ch = SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				reg_write =
+					SET_BITS(regAUDIO_RX_1, BAL,
+							(BAL_GAIN_0DB - leftGain));
+				reg_write_ch =
+					SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				/* BALLR = 1 selects left channel for atten */
+			} else
+				rc = PMIC_PARAMETER_ERROR;
+
+			if ((reg_mask != 0) && (reg_mask_ch != 0)) {
+				rc = pmic_write_reg(REG_AUDIO_RX_1,
+						reg_write_ch, reg_mask_ch);
+
+				if (rc == PMIC_SUCCESS) {
+					rc = pmic_write_reg(REG_AUDIO_RX_1,
+							reg_write,
+							reg_mask);
+
+					if (rc == PMIC_SUCCESS) {
+						pr_debug
+							("Output balance"
+							 "attenuation set\n");
+						audioOutput.balanceLeftGain =
+							leftGain;
+						audioOutput.balanceRightGain =
+							rightGain;
+					}
+				}
+			}
+		}
+	}
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_balance);
+
+/*!
+ * @brief Get the current output balance amplifier gain levels.
+ *
+ * This function retrieves the current output balance amplifier gain levels.
+ *
+ * @param   	handle              Device handle from pmic_audio_open() call.
+ * @param  	leftGain            The current left channel gain level.
+ * @param 	rightGain           The current right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifier gain levels
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifier gain levels
+ *                                   could be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_balance(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const leftGain,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const rightGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+					(stDAC.handleState == HANDLE_IN_USE)) ||
+				((handle == vCodec.handle) &&
+				 (vCodec.handleState == HANDLE_IN_USE)) ||
+				((handle == extStereoIn.handle) &&
+				 (extStereoIn.handleState == HANDLE_IN_USE))) &&
+			((leftGain != (PMIC_AUDIO_OUTPUT_BALANCE_GAIN *) NULL) &&
+			 (rightGain != (PMIC_AUDIO_OUTPUT_BALANCE_GAIN *) NULL))) {
+		*leftGain = audioOutput.balanceLeftGain;
+		*rightGain = audioOutput.balanceRightGain;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_balance);
+
+/*!
+ * @brief Configure and enable the output mono adder.
+ *
+ * This function configures and enables the output mono adder.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   mode                The desired mono adder operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mono adder mode was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be reconfigured
+ *                                   or enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mono_adder(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_MODE
+		mode)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, MONO, 3);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((mode >= MONO_ADDER_OFF) && (mode <= STEREO_OPPOSITE_PHASE)) {
+		if (((handle == stDAC.handle) &&
+					(stDAC.handleState == HANDLE_IN_USE)) ||
+				((handle == vCodec.handle) &&
+				 (vCodec.handleState == HANDLE_IN_USE)) ||
+				((handle == extStereoIn.handle) &&
+				 (extStereoIn.handleState == HANDLE_IN_USE))) {
+			if (mode == MONO_ADDER_OFF) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 0);
+			} else if (mode == MONO_ADD_LEFT_RIGHT) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 2);
+			} else if (mode == MONO_ADD_OPPOSITE_PHASE) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 3);
+			} else {	/* stereo opposite */
+
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 1);
+			}
+
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Output mono adder mode set\n");
+
+		} else
+			rc = PMIC_PARAMETER_ERROR;
+	} else
+		rc = PMIC_PARAMETER_ERROR;
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_enable_mono_adder);
+
+/*!
+ * @brief Disable the output mono adder.
+ *
+ * This function disables the output mono adder.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mono_adder(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, MONO, 3);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) ||
+			((handle == vCodec.handle) &&
+			 (vCodec.handleState == HANDLE_IN_USE)) ||
+			((handle == extStereoIn.handle) &&
+			 (extStereoIn.handleState == HANDLE_IN_USE))) {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_disable_mono_adder);
+
+/*!
+ * @brief Configure the mono adder output gain level.
+ *
+ * This function configures the mono adder output amplifier gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The desired output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_output_set_mono_adder_gain(const PMIC_AUDIO_HANDLE
+		handle,
+		const
+		PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+		gain)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_mono_adder_gain);
+
+/*!
+ * @brief Get the current mono adder output gain level.
+ *
+ * This function retrieves the current mono adder output amplifier gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_mono_adder_gain(const PMIC_AUDIO_HANDLE
+		handle,
+		const PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+		*gain)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_mono_adder_gain);
+
+/*!
+ * @brief Set various audio output section options.
+ *
+ * This function sets one or more audio output section configuration
+ * options. The currently supported options include whether to disable
+ * the non-inverting mono speaker output, enabling the loudspeaker common
+ * bias circuit, enabling detection of headset insertion/removal, and
+ * whether to automatically disable the headset amplifiers when a headset
+ * insertion/removal has been detected.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   config              The desired audio output section
+ *                                  configuration options to be set.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) ||
+			((handle == vCodec.handle) &&
+			 (vCodec.handleState == HANDLE_IN_USE)) ||
+			((handle == extStereoIn.handle) &&
+			 (extStereoIn.handleState == HANDLE_IN_USE))) {
+		if (config & MONO_SPEAKER_INVERT_OUT_ONLY) {
+			/* If this is one of the parameters */
+			rc = PMIC_NOT_SUPPORTED;
+		} else {
+			if (config & MONO_LOUDSPEAKER_COMMON_BIAS) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+			}
+			if (config & HEADSET_DETECT_ENABLE) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+			}
+			if (config & STEREO_HEADSET_AMP_AUTO_DISABLE) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+			}
+
+			if (reg_mask == 0)
+				rc = PMIC_PARAMETER_ERROR;
+			else {
+				rc = pmic_write_reg(REG_AUDIO_RX_0,
+						reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("Output config set\n");
+					audioOutput.config |= config;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_set_config);
+
+/*!
+ * @brief Clear various audio output section options.
+ *
+ * This function clears one or more audio output section configuration
+ * options.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   config              The desired audio output section
+ *                                  configuration options to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be cleared.
+ */
+PMIC_STATUS pmic_audio_output_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG
+		config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	/*unsigned int reg_write_RX = 0;
+	  unsigned int reg_mask_RX  = 0;
+	  unsigned int reg_write_TX = 0;
+	  unsigned int reg_mask_TX  = 0; */
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) ||
+			((handle == vCodec.handle) &&
+			 (vCodec.handleState == HANDLE_IN_USE)) ||
+			((handle == extStereoIn.handle) &&
+			 (extStereoIn.handleState == HANDLE_IN_USE))) {
+		if (config & MONO_SPEAKER_INVERT_OUT_ONLY) {
+			/* If this is one of the parameters */
+			rc = PMIC_NOT_SUPPORTED;
+		} else {
+			if (config & MONO_LOUDSPEAKER_COMMON_BIAS) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ALSPREF, 0);
+			}
+
+			if (config & HEADSET_DETECT_ENABLE) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, HSDETEN, 0);
+			}
+
+			if (config & STEREO_HEADSET_AMP_AUTO_DISABLE) {
+				reg_mask |=
+					SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+				reg_write |=
+					SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 0);
+			}
+
+			if (reg_mask == 0)
+				rc = PMIC_PARAMETER_ERROR;
+			else {
+				rc = pmic_write_reg(REG_AUDIO_RX_0,
+						reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("Output config cleared\n");
+					audioOutput.config &= ~config;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_clear_config);
+
+/*!
+ * @brief Get the current audio output section options.
+ *
+ * This function retrieves the current audio output section configuration
+ * option settings.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param  config              The current audio output section
+ *                                  configuration option settings.
+ *
+ * @retval      PMIC_SUCCESS         If the current configuration options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the current configuration options
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_CONFIG *
+		const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+					(stDAC.handleState == HANDLE_IN_USE)) ||
+				((handle == vCodec.handle) &&
+				 (vCodec.handleState == HANDLE_IN_USE)) ||
+				((handle == extStereoIn.handle) &&
+				 (extStereoIn.handleState == HANDLE_IN_USE))) &&
+			(config != (PMIC_AUDIO_OUTPUT_CONFIG *) NULL)) {
+		*config = audioOutput.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_get_config);
+
+/*!
+ * @brief Enable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function enables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_phantom_ground(const PMIC_AUDIO_HANDLE
+		handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) ||
+			((handle == vCodec.handle) &&
+			 (vCodec.handleState == HANDLE_IN_USE)) ||
+			((handle == extStereoIn.handle) &&
+			 (extStereoIn.handleState == HANDLE_IN_USE))) {
+		rc = pmic_write_reg(REG_AUDIO_RX_0, 0, reg_mask);
+		if (rc == PMIC_SUCCESS)
+			pr_debug("Phantom ground enabled\n");
+	}
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_enable_phantom_ground);
+
+/*!
+ * @brief Disable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function disables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_phantom_ground(const PMIC_AUDIO_HANDLE
+		handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) &&
+				(stDAC.handleState == HANDLE_IN_USE)) ||
+			((handle == vCodec.handle) &&
+			 (vCodec.handleState == HANDLE_IN_USE)) ||
+			((handle == extStereoIn.handle) &&
+			 (extStereoIn.handleState == HANDLE_IN_USE))) {
+		rc = pmic_write_reg(REG_AUDIO_RX_0, 1, reg_mask);
+		if (rc == PMIC_SUCCESS)
+			pr_debug("Phantom ground disabled\n");
+	}
+	return rc;
+}
+EXPORT_SYMBOL(pmic_audio_output_disable_phantom_ground);
+
+/*@}*/
+
+/**************************************************************************
+ * Static functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name Audio Driver Internal Support Functions
+ * These non-exported internal functions are used to support the functionality
+ * of the exported audio APIs.
+ */
+/*@{*/
+
+/*!
+ * @brief Enables the 5.6V boost for the microphone bias 2 circuit.
+ *
+ * This function enables the switching regulator SW3 and configures it to
+ * provide the 5.6V boost that is required for driving the microphone bias 2
+ * circuit when using a 5-pole jack configuration (which is the case for the
+ * Sphinx board).
+ *
+ * @retval      PMIC_SUCCESS         The 5.6V boost was successfully enabled.
+ * @retval      PMIC_ERROR           Failed to enable the 5.6V boost.
+ */
+/*
+   static PMIC_STATUS pmic_audio_mic_boost_enable(void)
+   {
+   PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+   return rc;
+   }
+   */
+/*!
+ * @brief Disables the 5.6V boost for the microphone bias 2 circuit.
+ *
+ * This function disables the switching regulator SW3 to turn off the 5.6V
+ * boost for the microphone bias 2 circuit.
+ *
+ * @retval      PMIC_SUCCESS         The 5.6V boost was successfully disabled.
+ * @retval      PMIC_ERROR           Failed to disable the 5.6V boost.
+ */
+/*
+   static PMIC_STATUS pmic_audio_mic_boost_disable(void)
+   {
+   PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+   return rc;
+   }
+   */
+
+/*!
+ * @brief Free a device handle previously acquired by calling pmic_audio_open().
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * Note that we will shutdown/reset the Voice CODEC or Stereo DAC as well as
+ * any associated audio input/output components that are no longer required.
+ *
+ * Also note that this function should only be called with the mutex already
+ * acquired.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+static PMIC_STATUS pmic_audio_close_handle(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Match up the handle to the audio device and then close it. */
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the Stereo DAC hardware. The simplest way to
+		 * do this is to simply call pmic_audio_reset_device() which will
+		 * restore the ST_DAC register to it's initial power-on state.
+		 *
+		 * This will also shutdown the audio output section if no one
+		 * else is still using it.
+		 */
+		rc = pmic_audio_reset_device(stDAC.handle);
+
+		if (rc == PMIC_SUCCESS) {
+			stDAC.handle = AUDIO_HANDLE_NULL;
+			stDAC.handleState = HANDLE_FREE;
+		}
+	} else if ((handle == vCodec.handle) &&
+			(vCodec.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the Voice CODEC and audio input hardware. The
+		 * simplest way to do this is to simply call
+		 * pmic_audio_reset_device()
+		 * which will restore the AUD_CODEC register to it's initial
+		 * power-on state.
+		 *
+		 * This will also shutdown the audio output section if no one
+		 * else is still using it.
+		 */
+		rc = pmic_audio_reset_device(vCodec.handle);
+		if (rc == PMIC_SUCCESS) {
+			vCodec.handle = AUDIO_HANDLE_NULL;
+			vCodec.handleState = HANDLE_FREE;
+		}
+	} else if ((handle == extStereoIn.handle) &&
+			(extStereoIn.handleState == HANDLE_IN_USE)) {
+
+		/* Call pmic_audio_reset_device() here to shutdown the audio output
+		 * section if no one else is still using it.
+		 */
+		rc = pmic_audio_reset_device(extStereoIn.handle);
+
+		if (rc == PMIC_SUCCESS) {
+			extStereoIn.handle = AUDIO_HANDLE_NULL;
+			extStereoIn.handleState = HANDLE_FREE;
+		}
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their initial power on state.
+ *
+ * This function can only be called if the mutex has already been acquired.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+static PMIC_STATUS pmic_audio_reset_device(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the audio output section if nobody else is using it.
+		   if ((vCodec.handleState == HANDLE_FREE) &&
+		   (extStereoIn.handleState == HANDLE_FREE))
+		   {
+		   pmic_write_reg(REG_RX_AUD_AMPS, RESET_RX_AUD_AMPS,
+		   REG_FULLMASK);
+		   } */
+
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+				RESET_ST_DAC, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS) {
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					RESET_SSI_NETWORK,
+					REG_SSI_STDAC_MASK);
+			if (rc == PMIC_SUCCESS) {
+				/* Also reset the driver state information to match. Note that we
+				 * keep the device handle and event callback settings unchanged
+				 * since these don't affect the actual hardware and we rely on
+				 * the user to explicitly close the handle or deregister callbacks
+				 */
+				stDAC.busID = AUDIO_DATA_BUS_1;
+				stDAC.protocol = NORMAL_MSB_JUSTIFIED_MODE;
+				stDAC.protocol_set = false;
+				stDAC.masterSlave = BUS_MASTER_MODE;
+				stDAC.numSlots = USE_2_TIMESLOTS;
+				stDAC.clockIn = CLOCK_IN_CLIA;
+				stDAC.samplingRate = STDAC_RATE_44_1_KHZ;
+				stDAC.clockFreq = STDAC_CLI_13MHZ;
+				stDAC.invert = NO_INVERT;
+				stDAC.timeslot = USE_TS0_TS1;
+				stDAC.config = (PMIC_AUDIO_STDAC_CONFIG) 0;
+
+			}
+		}
+	} else if ((handle == vCodec.handle)
+			&& (vCodec.handleState == HANDLE_IN_USE)) {
+		/* Disable the audio input section when
+		 * disabling the Voice CODEC. */
+		pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX, REG_FULLMASK);
+
+		rc = pmic_write_reg(REG_AUDIO_CODEC,
+				RESET_AUD_CODEC, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS) {
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					RESET_SSI_NETWORK,
+					REG_SSI_VCODEC_MASK);
+			if (rc == PMIC_SUCCESS) {
+
+				/* Also reset the driver state information
+				 * to match. Note that we
+				 * keep the device handle and event
+				 * callback settings unchanged
+				 * since these don't affect the actual
+				 * hardware and we rely on
+				 * the user to explicitly close the handle or
+				 * deregister callbacks
+				 */
+				vCodec.busID = AUDIO_DATA_BUS_2;
+				vCodec.protocol = NETWORK_MODE;
+				vCodec.protocol_set = false;
+				vCodec.masterSlave = BUS_SLAVE_MODE;
+				vCodec.numSlots = USE_4_TIMESLOTS;
+				vCodec.clockIn = CLOCK_IN_CLIB;
+				vCodec.samplingRate = VCODEC_RATE_8_KHZ;
+				vCodec.clockFreq = VCODEC_CLI_13MHZ;
+				vCodec.invert = NO_INVERT;
+				vCodec.timeslot = USE_TS0;
+				vCodec.config =
+					INPUT_HIGHPASS_FILTER |
+					OUTPUT_HIGHPASS_FILTER;
+
+			}
+		}
+
+	} else if ((handle == extStereoIn.handle) &&
+			(extStereoIn.handleState == HANDLE_IN_USE)) {
+		/* Disable the Ext stereo Amplifier and
+		 * disable it as analog mixer input */
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		pmic_write_reg(REG_AUDIO_RX_1, 0, reg_mask);
+
+		reg_mask = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		pmic_write_reg(REG_AUDIO_RX_0, 0, reg_mask);
+
+		/* We don't need to reset any other registers for this case. */
+		rc = PMIC_SUCCESS;
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Deregister the callback function and event
+ * mask currently associated
+ *        with an audio device handle.
+ *
+ * This function deregisters any existing callback function and event mask for
+ * the given audio device handle. This is done by either calling the
+ * pmic_audio_clear_callback() API or by closing the device handle.
+ *
+ * Note that this function should only be called with the mutex already
+ * acquired. We will also acquire the spinlock here to prevent possible
+ * race conditions with the interrupt handler.
+ *
+ * @param[in]   callback            The current event callback function pointer.
+ * @param[in]   eventMask           The current audio event mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback function and event mask
+ *                                   were both successfully deregistered.
+ * @retval      PMIC_ERROR           If either the callback function or the
+ *                                   event mask was not successfully
+ *                                   deregistered.
+ */
+/*
+   static PMIC_STATUS pmic_audio_deregister(PMIC_AUDIO_CALLBACK * const callback,
+   PMIC_AUDIO_EVENTS * const eventMask)
+   {
+
+   PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+   return rc;
+   }
+   */
+/*!
+ * @brief This is the default event handler for the audio driver.
+ *
+ * This function is called by the low-level PMIC interrupt handler whenever
+ * a registered event occurs. This function will perform whatever additional
+ * processing may be required to fully identify the event that just occur and
+ * then call the appropriate callback function to complete the handling of the
+ * event.
+ *
+ * @param[in]   param               The parameter that was provided when this
+ *                                  event handler was registered (unused).
+ */
+/*
+   static void pmic_audio_event_handler(void *param)
+   {
+   }
+   */
+
+/*!
+ * @brief This is the audio driver tasklet that handles interrupt events.
+ *
+ * This is currently not supported by MC13783
+ *
+ * @param[in]   arg                 The parameter that was provided above in
+ *                                  the DECLARE_TASKLET() macro (unused).
+ */
+void pmic_audio_tasklet(unsigned long arg)
+{
+
+}
+
+/*@}*/
+
+/**************************************************************************
+ * Module initialization and termination functions.
+ *
+ * Note that if this code is compiled into the kernel, then the
+ * module_init() function will be called within the device_initcall()
+ * group.
+ **************************************************************************
+ */
+
+/*!
+ * @name Audio Driver Loading/Unloading Functions
+ * These non-exported internal functions are used to support the audio
+ * device driver initialization and de-initialization operations.
+ */
+/*@{*/
+
+/*!
+ * @brief This is the audio device driver initialization function.
+ *
+ * This function is called by the kernel when this device driver is first
+ * loaded.
+ */
+static int __init mc13783_pmic_audio_init(void)
+{
+	printk(KERN_INFO "PMIC Audio driver loading...\n");
+
+	return 0;
+}
+
+/*!
+ * @brief This is the audio device driver de-initialization function.
+ *
+ * This function is called by the kernel when this device driver is about
+ * to be unloaded.
+ */
+static void __exit mc13783_pmic_audio_exit(void)
+{
+	printk(KERN_INFO "PMIC Audio driver unloading...\n");
+
+	/* Close all device handles that are still open. This will also
+	 * deregister any callbacks that may still be active.
+	 */
+	if (stDAC.handleState == HANDLE_IN_USE)
+		pmic_audio_close(stDAC.handle);
+	if (vCodec.handleState == HANDLE_IN_USE)
+		pmic_audio_close(vCodec.handle);
+	if (extStereoIn.handleState == HANDLE_IN_USE)
+		pmic_audio_close(extStereoIn.handle);
+
+	/* Explicitly reset all of the audio registers so that there is no
+	 * possibility of leaving the  audio hardware in a state
+	 * where it can cause problems if there is no device driver loaded.
+	 */
+	pmic_write_reg(REG_AUDIO_STEREO_DAC, RESET_ST_DAC, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_CODEC, RESET_AUD_CODEC, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_SSI_NETWORK, RESET_SSI_NETWORK, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_RX_0, RESET_AUDIO_RX_0, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_RX_1, RESET_AUDIO_RX_1, REG_FULLMASK);
+}
+
+/*@}*/
+
+/*
+ * Module entry points and description information.
+ */
+
+module_init(mc13783_pmic_audio_init);
+module_exit(mc13783_pmic_audio_exit);
+
+MODULE_DESCRIPTION("PMIC - mc13783 ADC driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_battery.c b/drivers/mxc/pmic/mc13783/pmic_battery.c
new file mode 100644
index 0000000..f14d599
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_battery.c
@@ -0,0 +1,1078 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_battery.c
+ * @brief This is the main file of PMIC(mc13783) Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+/*
+ * Includes
+ */
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+
+#include <asm/plat-mxc/pmic_battery.h>
+#include <asm/plat-mxc/pmic_adc.h>
+
+#include "pmic_battery_defs.h"
+
+static int pmic_battery_major;
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the battery devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used to block application calls
+ */
+static wait_queue_head_t suspendq;
+
+void pmic_battery_class_dev_release(struct device *dev);
+
+static struct class pmic_battery_class = {
+	.owner		= THIS_MODULE,
+	.name		= PMIC_BATTERY_STRING,
+	.dev_release = pmic_battery_class_dev_release,
+};
+
+/*!
+ * This is the suspend of power management for the pmic battery API.
+ * It suports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	unsigned int reg_value = 0;
+
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, reg_value, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the pmic battery API.
+ * It suports RESTORE state.
+ *
+ * @param        pdev           the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_resume(struct platform_device *pdev)
+{
+	suspend_flag = 0;
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, c_current) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_V_COIN, c_voltage) |
+		    BITFVAL(MC13783_BATT_DAC_COIN_CH_EN,
+			    MC13783_BATT_DAC_COIN_CH_EN_ENABLED);
+		mask = BITFMASK(MC13783_BATT_DAC_V_COIN) |
+		    BITFMASK(MC13783_BATT_DAC_COIN_CH_EN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, c_current);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_enable_charger);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, 0) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_COIN_CH_EN,
+			      MC13783_BATT_DAC_COIN_CH_EN_DISABLED);
+		mask = BITFMASK(MC13783_BATT_DAC_COIN_CH_EN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_disable_charger);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, c_current) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_V_COIN, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_V_COIN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, c_current);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_charger);
+
+/*!
+ * This function is used to retrive the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current)
+{
+	unsigned int val, reg;
+
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+	case BATT_TRCKLE_CHGR:
+		reg = REG_CHARGER;
+		break;
+	case BATT_CELL_CHGR:
+		reg = REG_POWER_CONTROL_0;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &val, PMIC_ALL_BITS));
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		*c_voltage = BITFEXT(val, MC13783_BATT_DAC_V_DAC);;
+		*c_current = BITFEXT(val, MC13783_BATT_DAC_DAC);
+		break;
+
+	case BATT_CELL_CHGR:
+		*c_voltage = BITFEXT(val, MC13783_BATT_DAC_V_COIN);
+		*c_current = 0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		*c_voltage = 0;
+		*c_current = BITFEXT(val, MC13783_BATT_DAC_TRCKLE);
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_get_charger_setting);
+
+/*!
+ * This function is retrives the main battery voltage.
+ *
+ * @param      b_voltage   Output parameter for voltage setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_voltage(unsigned short *b_voltage)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = BATTERY_VOLTAGE;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_voltage = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery current.
+ *
+ * @param      b_current   Output parameter for current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_current(unsigned short *b_current)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = BATTERY_CURRENT;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_current = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery temperature.
+ *
+ * @param      b_temper   Output parameter for temperature setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_temperature(unsigned short *b_temper)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = GEN_PURPOSE_AD5;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_temper = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery charging voltage.
+ *
+ * @param      c_voltage   Output parameter for charging voltage setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charge_voltage(unsigned short *c_voltage)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = CHARGE_VOLTAGE;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*c_voltage = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery charging current.
+ *
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = CHARGE_CURRENT;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*c_current = result[0];
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_get_charge_current);
+
+/*!
+ * This function enables End-of-Life comparator. Not supported on
+ * mc13783. Use pmic_batt_bp_enable_eol function.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_UNSUPPORTED
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_batt_enable_eol);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ * 			@verbatim
+			BPDET	UVDET	LOBATL
+			____	_____   ___________
+			0	2.6	UVDET + 0.2
+			1	2.6	UVDET + 0.3
+			2	2.6	UVDET + 0.4
+			3	2.6	UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_EOL_CMP_EN,
+		      MC13783_BATT_DAC_EOL_CMP_EN_ENABLE) |
+	    BITFVAL(MC13783_BATT_DAC_EOL_SEL, typical);
+	mask = BITFMASK(MC13783_BATT_DAC_EOL_CMP_EN) |
+	    BITFMASK(MC13783_BATT_DAC_EOL_SEL);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_bp_enable_eol);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_EOL_CMP_EN,
+		      MC13783_BATT_DAC_EOL_CMP_EN_DISABLE);
+	mask = BITFMASK(MC13783_BATT_DAC_EOL_CMP_EN);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_disable_eol);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control)
+{
+	unsigned int val, mask;
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (control) {
+	case CONTROL_HARDWARE:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 0) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	case CONTROL_BPFET_LOW:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 1) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	case CONTROL_BPFET_HIGH:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 1) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 1);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_out_control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	if (threshold > BAT_THRESHOLD_MAX)
+		return PMIC_PARAMETER_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_OVCTRL, threshold);
+	mask = BITFMASK(MC13783_BATT_DAC_OVCTRL);
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is ture, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_LED_EN, on);
+	mask = BITFMASK(MC13783_BATT_DAC_LED_EN);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_led_control);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is ture, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_REVERSE_SUPPLY, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_REVERSE_SUPPLY);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_reverse_supply);
+
+/*!
+ * This function sets unregulatored charging mode on main battery.
+ *
+ * @param      enable     If enable is ture, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_UNREGULATED, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_UNREGULATED);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_unregulated);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_5K, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_5K);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_batt_set_5k_pull);
+
+/*!
+ * This function is used to un/subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ * @param        sub            define if Un/subscribe event.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS mc13783_battery_event(t_batt_event event, void *callback, bool sub)
+{
+	pmic_event_callback_t bat_callback;
+	type_event bat_event;
+
+	bat_callback.func = callback;
+	bat_callback.param = NULL;
+	switch (event) {
+	case BAT_IT_CHG_DET:
+		bat_event = EVENT_WLOWI;
+		break;
+	case BAT_IT_CHG_OVERVOLT:
+		bat_event = EVENT_CHGOVI;
+		break;
+	case BAT_IT_CHG_REVERSE:
+		bat_event = EVENT_CHGREVI;
+		break;
+	case BAT_IT_CHG_SHORT_CIRCUIT:
+		bat_event = EVENT_CHGSHORTI;
+		break;
+	case BAT_IT_CCCV:
+		bat_event = EVENT_CCCVI;
+		break;
+	case BAT_IT_BELOW_THRESHOLD:
+		bat_event = EVENT_CHRGCURRI;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (sub == true)
+		CHECK_ERROR(pmic_event_subscribe(bat_event, bat_callback));
+	else
+		CHECK_ERROR(pmic_event_unsubscribe(bat_event, bat_callback));
+
+	return 0;
+}
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback)
+{
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	return mc13783_battery_event(event, callback, true);
+}
+EXPORT_SYMBOL(pmic_batt_event_subscribe);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback)
+{
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	return mc13783_battery_event(event, callback, false);
+}
+EXPORT_SYMBOL(pmic_batt_event_unsubscribe);
+
+/*!
+ * This function implements IOCTL controls on a PMIC Battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_ioctl(struct inode *inode, struct file *file,
+			      unsigned int cmd, unsigned long arg)
+{
+	t_charger_setting *chgr_setting = NULL;
+	unsigned short c_current;
+	unsigned int bc_info;
+	t_eol_setting *eol_setting;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_BATT_CHARGER_CONTROL:
+		chgr_setting = kmalloc(sizeof(t_charger_setting),
+				GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		if (chgr_setting->on != false) {
+			CHECK_ERROR_KFREE(pmic_batt_enable_charger
+					  (chgr_setting->chgr,
+					   chgr_setting->c_voltage,
+					   chgr_setting->c_current),
+					  (kfree(chgr_setting)));
+		} else
+			CHECK_ERROR(pmic_batt_disable_charger
+				    (chgr_setting->chgr));
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_SET_CHARGER:
+		chgr_setting = kmalloc(sizeof(t_charger_setting),
+				GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_batt_set_charger(chgr_setting->chgr,
+							chgr_setting->c_voltage,
+							chgr_setting->
+							c_current),
+				  (kfree(chgr_setting)));
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_GET_CHARGER:
+		chgr_setting = kmalloc(sizeof(t_charger_setting),
+				GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_batt_get_charger_setting
+				  (chgr_setting->chgr, &chgr_setting->c_voltage,
+				   &chgr_setting->c_current),
+				  (kfree(chgr_setting)));
+		if (copy_to_user
+		    ((t_charger_setting *) arg, chgr_setting,
+		     sizeof(t_charger_setting)))
+			return -EFAULT;
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_GET_CHARGER_SENSOR:
+		{
+			t_sensor_bits sensor;
+			pmic_get_sensors(&sensor);
+			if (copy_to_user
+				((unsigned int *)arg, &sensor.sense_chgdets,
+				sizeof(unsigned int)))
+			return -EFAULT;
+			break;
+		}
+
+	case PMIC_BATT_GET_BATTERY_VOLTAGE:
+		CHECK_ERROR(pmic_batt_get_batt_voltage(&c_current));
+		bc_info = (unsigned int)c_current * 2300 / 1023 + 2400;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_BATTERY_CURRENT:
+		CHECK_ERROR(pmic_batt_get_batt_current(&c_current));
+		bc_info = (unsigned int)c_current * 5750 / 1023;
+
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_BATTERY_TEMPERATURE:
+		CHECK_ERROR(pmic_batt_get_batt_temperature(&c_current));
+		bc_info = (unsigned int)c_current;
+
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_CHARGER_VOLTAGE:
+		CHECK_ERROR(pmic_batt_get_charge_voltage(&c_current));
+		bc_info = (unsigned int)c_current * 23000 / 1023;
+
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_CHARGER_CURRENT:
+		CHECK_ERROR(pmic_batt_get_charge_current(&c_current));
+		bc_info = (unsigned int)c_current * 5750 / 1023;
+
+		if (copy_to_user((unsigned char *)arg, &c_current,
+				 sizeof(unsigned char *)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_EOL_CONTROL:
+		eol_setting = kmalloc(sizeof(t_eol_setting),
+				GFP_KERNEL);
+		if (eol_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(eol_setting, (t_eol_setting *) arg,
+				   sizeof(t_eol_setting))) {
+			kfree(eol_setting);
+			return -EFAULT;
+		}
+
+		if (eol_setting->enable != false) {
+			CHECK_ERROR_KFREE(pmic_batt_bp_enable_eol
+					  (eol_setting->typical),
+					  (kfree(chgr_setting)));
+		} else {
+			CHECK_ERROR_KFREE(pmic_batt_disable_eol(),
+					  (kfree(chgr_setting)));
+		}
+
+		kfree(eol_setting);
+		break;
+
+	case PMIC_BATT_SET_OUT_CONTROL:
+		CHECK_ERROR(pmic_batt_set_out_control((t_control) arg));
+		break;
+
+	case PMIC_BATT_SET_THRESHOLD:
+		CHECK_ERROR(pmic_batt_set_threshold((int)arg));
+		break;
+
+	case PMIC_BATT_LED_CONTROL:
+		CHECK_ERROR(pmic_batt_led_control((bool) arg));
+		break;
+
+	case PMIC_BATT_REV_SUPP_CONTROL:
+		CHECK_ERROR(pmic_batt_set_reverse_supply((bool) arg));
+		break;
+
+	case PMIC_BATT_UNREG_CONTROL:
+		CHECK_ERROR(pmic_batt_set_unregulated((bool) arg));
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a Pmic battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_battery_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a Pmic battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_battery_release(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+	return 0;
+}
+
+static struct file_operations pmic_battery_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_battery_ioctl,
+	.open = pmic_battery_open,
+	.release = pmic_battery_release,
+};
+
+
+void pmic_battery_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+static int pmic_battery_remove(struct platform_device *pdev)
+{
+	class_unregister(&pmic_battery_class);
+	unregister_chrdev(pmic_battery_major, PMIC_BATTERY_STRING);
+	return 0;
+}
+
+static int pmic_battery_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_dev;
+
+	pmic_battery_major = register_chrdev(0, PMIC_BATTERY_STRING,
+					     &pmic_battery_fops);
+
+	if (pmic_battery_major < 0) {
+		printk(KERN_ERR "Unable to get a major for pmic_battery\n");
+		return pmic_battery_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	ret = class_register(&pmic_battery_class);
+	if (ret) {
+		printk(KERN_ERR "Error creating PMIC battery class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&pmic_battery_class, &pdev->dev,
+			MKDEV(pmic_battery_major, 0), NULL, PMIC_BATTERY_STRING);
+	if (IS_ERR(temp_dev)) {
+			printk(KERN_ERR "Error creating PMIC battery class device.\n");
+			ret = PTR_ERR(temp_dev);
+			goto err_out2;
+	}
+
+	pmic_batt_led_control(true);
+	pmic_batt_set_5k_pull(true);
+
+	printk(KERN_INFO "PMIC Battery successfully probed\n");
+
+	return ret;
+
+err_out2:
+	class_unregister(&pmic_battery_class);
+err_out1:
+	unregister_chrdev(pmic_battery_major, PMIC_BATTERY_STRING);
+	return ret;
+}
+
+static struct platform_driver pmic_battery_driver_ldm = {
+	.driver = {
+		   .name = "pmic_battery",
+		   .bus = &platform_bus_type,
+		   },
+	.suspend = pmic_battery_suspend,
+	.resume = pmic_battery_resume,
+	.probe = pmic_battery_probe,
+	.remove = pmic_battery_remove,
+};
+
+/*
+ * Init and Exit
+ */
+
+static int __init pmic_battery_init(void)
+{
+	pr_debug("PMIC Battery driver loading...\n");
+	return platform_driver_register(&pmic_battery_driver_ldm);
+}
+
+static void __exit pmic_battery_exit(void)
+{
+	platform_driver_unregister(&pmic_battery_driver_ldm);
+	pr_debug("PMIC Battery driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+module_init(pmic_battery_init);
+module_exit(pmic_battery_exit);
+
+MODULE_DESCRIPTION("pmic_battery driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_battery_defs.h b/drivers/mxc/pmic/mc13783/pmic_battery_defs.h
new file mode 100644
index 0000000..c61ba1c
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_battery_defs.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_battery_defs.h
+ * @brief This is the internal header for PMIC(mc13783) Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#ifndef __PMIC_BATTERY_DEFS_H__
+#define __PMIC_BATTERY_DEFS_H__
+
+#define         PMIC_BATTERY_STRING    "pmic_battery"
+
+/* REG_CHARGE */
+#define MC13783_BATT_DAC_V_DAC_LSH		0
+#define MC13783_BATT_DAC_V_DAC_WID		3
+#define MC13783_BATT_DAC_DAC_LSH			3
+#define MC13783_BATT_DAC_DAC_WID			4
+#define	MC13783_BATT_DAC_TRCKLE_LSH		7
+#define	MC13783_BATT_DAC_TRCKLE_WID		3
+#define MC13783_BATT_DAC_FETOVRD_EN_LSH		10
+#define MC13783_BATT_DAC_FETOVRD_EN_WID		1
+#define MC13783_BATT_DAC_FETCTRL_EN_LSH		11
+#define MC13783_BATT_DAC_FETCTRL_EN_WID		1
+#define MC13783_BATT_DAC_REVERSE_SUPPLY_LSH	13
+#define MC13783_BATT_DAC_REVERSE_SUPPLY_WID	1
+#define MC13783_BATT_DAC_OVCTRL_LSH		15
+#define MC13783_BATT_DAC_OVCTRL_WID		2
+#define MC13783_BATT_DAC_UNREGULATED_LSH		17
+#define MC13783_BATT_DAC_UNREGULATED_WID		1
+#define MC13783_BATT_DAC_LED_EN_LSH		18
+#define MC13783_BATT_DAC_LED_EN_WID		1
+#define MC13783_BATT_DAC_5K_LSH			19
+#define MC13783_BATT_DAC_5K_WID			1
+
+#define         BITS_OUT_VOLTAGE        0
+#define         LONG_OUT_VOLTAGE        3
+#define         BITS_CURRENT_MAIN       3
+#define         LONG_CURRENT_MAIN       4
+#define         BITS_CURRENT_TRICKLE    7
+#define         LONG_CURRENT_TRICKLE    3
+#define         BIT_FETOVRD             10
+#define         BIT_FETCTRL             11
+#define         BIT_RVRSMODE            13
+#define         BITS_OVERVOLTAGE        15
+#define         LONG_OVERVOLTAGE        2
+#define         BIT_UNREGULATED         17
+#define         BIT_CHRG_LED            18
+#define         BIT_CHRGRAWPDEN         19
+
+/* REG_POWXER_CONTROL_0 */
+#define MC13783_BATT_DAC_V_COIN_LSH		20
+#define MC13783_BATT_DAC_V_COIN_WID		3
+#define MC13783_BATT_DAC_COIN_CH_EN_LSH		23
+#define MC13783_BATT_DAC_COIN_CH_EN_WID		1
+#define MC13783_BATT_DAC_COIN_CH_EN_ENABLED	1
+#define MC13783_BATT_DAC_COIN_CH_EN_DISABLED	0
+#define MC13783_BATT_DAC_EOL_CMP_EN_LSH		18
+#define MC13783_BATT_DAC_EOL_CMP_EN_WID		1
+#define MC13783_BATT_DAC_EOL_CMP_EN_ENABLE	1
+#define MC13783_BATT_DAC_EOL_CMP_EN_DISABLE	0
+#define MC13783_BATT_DAC_EOL_SEL_LSH		16
+#define MC13783_BATT_DAC_EOL_SEL_WID		2
+
+#define         DEF_VALUE               0
+
+#define         BAT_THRESHOLD_MAX       3
+
+#endif				/*  __PMIC_BATTERY_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_convity.c b/drivers/mxc/pmic/mc13783/pmic_convity.c
new file mode 100644
index 0000000..35758ca
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_convity.c
@@ -0,0 +1,2517 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_convity.c
+ * @brief Implementation of the PMIC Connectivity driver APIs.
+ *
+ * The PMIC connectivity device driver and this API were developed to support
+ * the external connectivity capabilities of several power management ICs that
+ * are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes, in terms of external connectivity, are
+ * supported:
+ *
+ * @verbatim
+ Operating Mode     mc13783
+ ---------------    -------
+ USB (incl. OTG)     Yes
+ RS-232              Yes
+ CEA-936             Yes
+
+ @endverbatim
+ *
+ * @ingroup PMIC_CONNECTIVITY
+ */
+
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#include <asm/plat-mxc/pmic_convity.h>
+#include <asm/plat-mxc/pmic_adc.h>
+
+/*! @def SET_BITS
+ * Set a register field to a given value.
+ */
+
+#define SET_BITS(reg, field, value)    (((value) << reg.field.offset) & \
+		reg.field.mask)
+
+/*! @def GET_BITS
+ * Get the current value of a given register field.
+ */
+#define GET_BITS(reg, value)    (((value) & reg.mask) >> \
+		reg.offset)
+
+/*!
+ * @brief Define the possible states for a device handle.
+ *
+ * This enumeration is used to track the current state
+ * of each device handle.
+ */
+typedef enum {
+	HANDLE_FREE,
+	/*!< Handle is available for use. */
+	HANDLE_IN_USE
+		/*!< Handle is currently in use.  */
+} HANDLE_STATE;
+
+/*
+ * This structure is used to define a specific hardware register field.
+ *
+ * All hardware register fields are defined using an offset to the LSB
+ * and a mask. The offset is used to right shift a register value before
+ * applying the mask to actually obtain the value of the field.
+ */
+typedef struct {
+	const unsigned char offset;
+	/* Offset of LSB of register field.           */
+	const unsigned int mask;
+	/* Mask value used to isolate register field. */
+} REGFIELD;
+
+/*!
+ * @brief This structure is used to identify the
+ * fields in the USBCNTRL_REG_0 hardware register.
+ *
+ * This structure lists all of the fields within
+ * the USBCNTRL_REG_0 hardware
+ * register.
+ */
+typedef struct {
+	REGFIELD FSENB;
+	/*!< USB Full Speed Enable */
+	REGFIELD USB_SUSPEND;
+	/*!< USB Suspend Mode Enable */
+	REGFIELD USB_PU;
+	/*!< USB Pullup Enable                                */
+	REGFIELD UDP_PD;
+	/*!< USB Data Plus Pulldown Enable                    */
+	REGFIELD UDM_PD;
+	/*!< USB 150K UDP Pullup Enable                       */
+	REGFIELD DP150K_PU;
+	/*!< USB Pullup/Pulldown Override Enable              */
+	REGFIELD VBUSPDENB;
+	/*!< USB VBUS Pulldown NMOS Switch Enable             */
+	REGFIELD CURRENT_LIMIT;
+	/*!< USB Regulator Current Limit Setting-3 bits       */
+	REGFIELD DLP_SRP;
+	/*!< USB Data Line Pulsing Timer Enable               */
+	REGFIELD SE0_CONN;
+	/*!< USB Pullup Connect When SE0 Detected             */
+	REGFIELD USBXCVREN;
+	/*!< USB Transceiver Enabled When INTERFACE_MODE[2:0]=000 and RESETB=high */
+	REGFIELD PULLOVR;
+	/*!< 1K5 Pullup and UDP/UDM Pulldown Disable When UTXENB=Low             */
+	REGFIELD INTERFACE_MODE;
+	/*!< Connectivity Interface Mode Select-3 Bits        */
+	REGFIELD DATSE0;
+	/*!< USB Single or Differential Mode Select           */
+	REGFIELD BIDIR;
+	/*!< USB Unidirectional/Bidirectional Transmission    */
+	REGFIELD USBCNTRL;
+	/*!< USB Mode of Operation controlled By USBEN/SPI Pin */
+	REGFIELD IDPD;
+	/*!< USB UID Pulldown Enable                          */
+	REGFIELD IDPULSE;
+	/*!< USB Pulse to Gnd on UID Line Generated           */
+	REGFIELD IDPUCNTRL;
+	/*!< USB UID Pin pulled high By 5ua Curr Source       */
+	REGFIELD DMPULSE;
+	/*!< USB Positive pulse on the UDM Line Generated     */
+} USBCNTRL_REG_0;
+
+/*!
+ * @brief This variable is used to access the USBCNTRL_REG_0 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * USBCNTRL_REG_0  hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const USBCNTRL_REG_0 regUSB0 = {
+	{0, 0x000001},		/*!< FSENB        */
+	{1, 0x000002},		/*!< USB_SUSPEND  */
+	{2, 0x000004},		/*!< USB_PU       */
+	{3, 0x000008},		/*!< UDP_PD       */
+	{4, 0x000010},		/*!< UDM_PD       */
+	{5, 0x000020},		/*!< DP150K_PU    */
+	{6, 0x000040},		/*!< VBUSPDENB    */
+	{7, 0x000380},		/*!< CURRENT_LIMIT */
+	{10, 0x000400},		/*!< DLP_SRP      */
+	{11, 0x000800},		/*!< SE0_CONN     */
+	{12, 0x001000},		/*!< USBXCVREN    */
+	{13, 0x002000},		/*!< PULLOVR      */
+	{14, 0x01c000},		/*!< INTERFACE_MODE */
+	{17, 0x020000},		/*!< DATSE0       */
+	{18, 0x040000},		/*!< BIDIR        */
+	{19, 0x080000},		/*!< USBCNTRL     */
+	{20, 0x100000},		/*!< IDPD         */
+	{21, 0x200000},		/*!< IDPULSE      */
+	{22, 0x400000},		/*!< IDPUCNTRL    */
+	{23, 0x800000}		/*!< DMPULSE      */
+
+};
+
+/*!
+ * @brief This structure is used to identify
+ * the fields in the USBCNTRL_REG_1 hardware register.
+ *
+ * This structure lists all of the fields
+ * within the USBCNTRL_REG_1 hardware
+ * register.
+ */
+typedef struct {
+	REGFIELD VUSBIN;
+	/*!< Controls The Input Source For VUSB */
+	REGFIELD VUSB;
+	/*!< VUSB Output Voltage Select-High=3.3V Low=2.775V */
+	REGFIELD VUSBEN;
+	/*!< VUSB Output Enable-*/
+	REGFIELD VBUSEN;
+	/*!< VBUS Output Enable-*/
+	REGFIELD RSPOL;
+	/*!< Low=RS232 TX on UDM, RX on UDP High =
+	 * RS232 TX on UDP, RX on UDM               */
+	REGFIELD RSTRI;
+	/*!< TX Forced To Tristate in RS232 Mode Only       */
+	REGFIELD ID100kPU;
+	/*!< 100k UID Pullup Enable      */
+} USBCNTRL_REG_1;
+
+/*!
+ * @brief This variable is used to access the
+ * USBCNTRL_REG_1 hardware register.
+ *
+ * This variable defines how to access all of
+ * the fields within the
+ * USBCNTRL_REG_1  hardware register. The initial
+ * values consist of the offset
+ * and mask values needed to access each of the
+ * register fields.
+ */
+static const USBCNTRL_REG_1 regUSB1 = {
+	{0, 0x000003},		/*!< VUSBIN-2 Bits  */
+	{2, 0x000004},		/*!< VUSB           */
+	{3, 0x000008},		/*!< VUSBEN         */
+	{5, 0x000020},		/*!< VBUSEN         */
+	{6, 0x000040},		/*!< RSPOL          */
+	{7, 0x000080},		/*!< RSTRI          */
+	{8, 0x000100}		/*!< ID100kPU       */
+};
+
+/*! Define a mask to access the entire hardware register. */
+static const unsigned int REG_FULLMASK = 0xffffff;
+
+/*! Define the mc13783 USBCNTRL_REG_0 register
+ * power on reset state. */
+static const unsigned int RESET_USBCNTRL_REG_0 = 0x080060;
+
+/*! Define the mc13783 USBCNTRL_REG_1 register power
+ * on reset state. */
+static const unsigned int RESET_USBCNTRL_REG_1 = 0x000006;
+
+static pmic_event_callback_t eventNotify;
+
+/*!
+ * @brief This structure is used to maintain the current
+ * device driver state.
+ *
+ * This structure maintains the current state of
+ * the connectivity driver. This
+ * includes both the PMIC hardware state as well as
+ * the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;
+	/*!< Device handle.   */
+	HANDLE_STATE handleState;
+	/*!< Device handle state.           */
+	PMIC_CONVITY_MODE mode;
+	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;
+	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;
+	/*!< Event mask.      */
+	PMIC_CONVITY_USB_SPEED usbSpeed;
+	/*!< USB connection speed.           */
+	PMIC_CONVITY_USB_MODE usbMode;
+	/*!< USB connection  mode. */
+	PMIC_CONVITY_USB_POWER_IN usbPowerIn;
+	/*!< USB transceiver power source.    */
+	PMIC_CONVITY_USB_POWER_OUT usbPowerOut;
+	/*!< USB transceiver power output level. */
+	PMIC_CONVITY_USB_TRANSCEIVER_MODE usbXcvrMode;
+	/*!< USB transceiver mode.            */
+	unsigned int usbDlpDuration;
+	/*!< USB Data Line Pulsing duration. */
+	PMIC_CONVITY_USB_OTG_CONFIG usbOtgCfg;
+	/*!< USB OTG configuration options. */
+	PMIC_CONVITY_RS232_INTERNAL rs232CfgInternal;
+	/*!< RS-232 internal connections.     */
+	PMIC_CONVITY_RS232_EXTERNAL rs232CfgExternal;
+	/*!< RS-232 external connections.     */
+} PMIC_CONVITY_STATE_STRUCT;
+
+/*!
+ * @brief Identifies the hardware interrupt source.
+ *
+ * This enumeration identifies which of the possible hardware interrupt
+ * sources actually caused the current interrupt handler to be called.
+ */
+typedef enum {
+	CORE_EVENT_4V4,
+	/*!< Detected USB 4.4 V event.              */
+	CORE_EVENT_2V0,
+	/*!< Detected USB 2.0 V event.              */
+	CORE_EVENT_0V8,
+	/*!< Detected USB 0.8 V event.              */
+	CORE_EVENT_ABDET
+	/*!< Detected USB mini A-B connector event. */
+} PMIC_CORE_EVENT;
+
+/*! Define the maximum Data Line Pulse duration in milliseconds. */
+
+/*!
+ * @brief This structure defines the reset/power on state for the Connectivity driver.
+ */
+static const PMIC_CONVITY_STATE_STRUCT reset = {
+	0,
+	HANDLE_FREE,
+	USB,
+	NULL,
+	0,
+	USB_FULL_SPEED,
+	USB_PERIPHERAL,
+	USB_POWER_INTERNAL,
+	USB_POWER_3V3,
+	USB_TRANSCEIVER_OFF,
+	0,
+	USB_PULL_OVERRIDE | USB_VBUS_CURRENT_LIMIT_HIGH,
+	RS232_TX_USE0VM_RX_UDATVP,
+	RS232_TX_UDM_RX_UDP
+};
+
+/*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static PMIC_CONVITY_STATE_STRUCT convity = {
+	0,
+	HANDLE_FREE,
+	USB,
+	NULL,
+	0,
+	USB_FULL_SPEED,
+	USB_PERIPHERAL,
+	USB_POWER_INTERNAL,
+	USB_POWER_3V3,
+	USB_TRANSCEIVER_OFF,
+	0,
+	USB_PULL_OVERRIDE | USB_VBUS_CURRENT_LIMIT_HIGH,
+	RS232_TX_USE0VM_RX_UDATVP,
+	RS232_TX_UDM_RX_UDP
+};
+
+/*!
+ * @brief This spinlock is used to provide mutual exclusion.
+ *
+ * Create a spinlock that can be used to provide mutually exclusive
+ * read/write access to the globally accessible "convity" data structure
+ * that was defined above. Mutually exclusive access is required to
+ * ensure that the convity data structure is consistent at all times
+ * when possibly accessed by multiple threads of execution (for example,
+ * while simultaneously handling a user request and an interrupt event).
+ *
+ * We need to use a spinlock sometimes because we need to provide mutual
+ * exclusion while handling a hardware interrupt.
+ */
+static DEFINE_SPINLOCK(lock);
+
+/*!
+ * @brief This mutex is used to provide mutual exclusion.
+ *
+ * Create a mutex that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the Connectivity data structures are consistent at all
+ * times when possibly accessed by multiple threads of execution.
+ *
+ * Note that we use a mutex instead of the spinlock whenever disabling
+ * interrupts while in the critical section is not required. This helps
+ * to minimize kernel interrupt handling latency.
+ */
+static DECLARE_MUTEX(mutex);
+
+/* Prototype for the connectivity driver tasklet function. */
+static void pmic_convity_tasklet(unsigned long arg);
+
+/*!
+ * @brief Tasklet handler for the connectivity driver.
+ *
+ * Declare a tasklet that will do most of the processing for all of the
+ * connectivity-related interrupt events (USB4.4VI, USB2.0VI, USB0.8VI,
+ * and AB_DETI). Note that we cannot do all of the required processing
+ * within the interrupt handler itself because we may need to call the
+ * ADC driver to measure voltages as well as calling any user-registered
+ * callback functions.
+ */
+DECLARE_TASKLET(convityTasklet, pmic_convity_tasklet, 0);
+
+/*!
+ * @brief Global variable to track currently active interrupt events.
+ *
+ * This global variable is used to keep track of all of the currently
+ * active interrupt events for the connectivity driver. Note that access
+ * to this variable may occur while within an interrupt context and,
+ * therefore, must be guarded by using a spinlock.
+ */
+static PMIC_CORE_EVENT eventID;
+
+/* Prototypes for all static connectivity driver functions. */
+static PMIC_STATUS pmic_convity_set_mode_internal(const PMIC_CONVITY_MODE mode);
+static PMIC_STATUS pmic_convity_deregister_all(void);
+static void pmic_convity_event_handler(void *param);
+
+/**************************************************************************
+ * General setup and configuration functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name General Setup and Configuration Connectivity APIs
+ * Functions for setting up and configuring the connectivity hardware.
+ */
+/*@{*/
+
+/*!
+ * Attempt to open and gain exclusive access to the PMIC connectivity
+ * hardware. An initial operating mode must also be specified.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls. The
+ * same handle must also be used in the pmic_convity_close() call when use
+ * of the PMIC connectivity hardware is no longer required.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            initial connectivity operating mode
+ *
+ * @return      PMIC_SUCCESS    if the open request was successful
+ */
+PMIC_STATUS pmic_convity_open(PMIC_CONVITY_HANDLE * const handle,
+		const PMIC_CONVITY_MODE mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	if (handle == (PMIC_CONVITY_HANDLE *) NULL) {
+		/* Do not dereference a NULL pointer. */
+		return PMIC_ERROR;
+	}
+
+	/* We only need to acquire a mutex here because the interrupt handler
+	 * never modifies the device handle or device handle state. Therefore,
+	 * we don't need to worry about conflicts with the interrupt handler
+	 * or the need to execute in an interrupt context.
+	 *
+	 * But we do need a critical section here to avoid problems in case
+	 * multiple calls to pmic_convity_open() are made since we can only
+	 * allow one of them to succeed.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Check the current device handle state and acquire the handle if
+	 * it is available.
+	 */
+	if (convity.handleState != HANDLE_FREE) {
+		/* Cannot open the PMIC connectivity hardware at this time or an invalid
+		 * mode was requested.
+		 */
+		*handle = reset.handle;
+	} else {
+		/* Let's begin by acquiring the connectivity device handle. */
+		convity.handle = (PMIC_CONVITY_HANDLE) (&convity);
+		convity.handleState = HANDLE_IN_USE;
+		/* Then we can try to set the desired operating mode. */
+		rc = pmic_convity_set_mode_internal(mode);
+
+		if (rc == PMIC_SUCCESS) {
+			/* Successfully set the desired operating mode, now return the
+			 * handle to the caller.
+			 */
+			*handle = convity.handle;
+		} else {
+			/* Failed to set the desired mode, return the handle to an unused
+			 * state.
+			 */
+			convity.handle = reset.handle;
+			convity.handleState = reset.handleState;
+
+			*handle = reset.handle;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_open);
+
+/*!
+ * Terminate further access to the PMIC connectivity hardware. Also allows
+ * another process to call pmic_convity_open() to gain access.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the close request was successful
+ */
+PMIC_STATUS pmic_convity_close(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Begin a critical section here to
+	 * avoid the possibility of race
+	 * conditions if multiple threads
+	 * happen to call this function and
+	 * pmic_convity_open() at the same time.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Confirm that the device handle
+	 * matches the one assigned in the
+	 * pmic_convity_open() call and
+	 * then close the connection.
+	 */
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		rc = PMIC_SUCCESS;
+
+		/* Deregister for all existing callbacks
+		 * if necessary and make sure
+		 * that the event handling settings are
+		 * consistent following the
+		 * close operation.
+		 */
+		if (convity.callback != reset.callback)
+			/* Deregister the existing callback
+			 * function and all registered
+			 * events before we completely close the handle.
+			 */
+			rc = pmic_convity_deregister_all();
+
+		else if (convity.eventMask != reset.eventMask)
+			/* Having a non-zero eventMask without
+			 * a callback function being
+			 * defined should never occur but let's
+			 * just make sure here that
+			 * we keep things consistent.
+			 */
+			convity.eventMask = reset.eventMask;
+
+		if (rc == PMIC_SUCCESS) {
+			/* Mark the connectivity device
+			 * handle as being closed. */
+
+			convity.handle = reset.handle;
+			convity.handleState = reset.handleState;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_close);
+
+/*!
+ * Change the current operating mode of the
+ * PMIC connectivity hardware.
+ * The available connectivity operating modes
+ * is hardware dependent and
+ * consists of one or more of the following:
+ * USB (including USB On-the-Go),
+ * RS-232, and CEA-936. Requesting an operating
+ * mode that is not supported
+ * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            desired operating mode
+ *
+ * @return      PMIC_SUCCESS    if the requested
+ * mode was successfully set
+ */
+PMIC_STATUS pmic_convity_set_mode(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_MODE mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE))
+		rc = pmic_convity_set_mode_internal(mode);
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_set_mode);
+
+/*!
+ * Get the current operating mode for the PMIC connectivity hardware.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            the current PMIC
+ * connectivity operating mode
+ *
+ * @return      PMIC_SUCCESS    if the requested
+ * mode was successfully set
+ */
+PMIC_STATUS pmic_convity_get_mode(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_MODE * const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(mode != (PMIC_CONVITY_MODE *) NULL)) {
+
+		*mode = convity.mode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_get_mode);
+
+/*!
+ * Restore all registers to the initial power-on/reset state.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the reset was successful
+ */
+PMIC_STATUS pmic_convity_reset(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		/* Reset the PMIC Connectivity
+		 * register to it's power on state. */
+		rc = pmic_write_reg(REG_USB, RESET_USBCNTRL_REG_0,
+				REG_FULLMASK);
+
+		rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+				RESET_USBCNTRL_REG_1, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS)
+			/* Also reset the device
+			 * driver state data structure. */
+			convity = reset;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_reset);
+
+/*!
+ * Register a callback function that will be
+ * used to signal PMIC connectivity
+ * events. For example, the USB subsystem
+ * should register a callback function
+ * in order to be notified of device
+ * connect/disconnect events. Note, however,
+ * that non-USB events may also be signalled
+ * depending upon the PMIC hardware
+ * capabilities. Therefore, the callback
+ * function must be able to properly
+ * handle all of the possible events if
+ * support for non-USB peripherals is
+ * also to be included.
+ *
+ * @param       handle          device handle from open() call
+ * @param       func            a pointer to the callback function
+ * @param       eventMask       a mask selecting events
+ * to be notified
+ *
+ * @return      PMIC_SUCCESS    if the callback was
+ * successful registered
+ */
+PMIC_STATUS pmic_convity_set_callback(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_CALLBACK func,
+		const PMIC_CONVITY_EVENTS eventMask)
+{
+	unsigned long flags;
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* We need to start a critical section
+	 * here to ensure a consistent state
+	 * in case simultaneous calls to
+	 * pmic_convity_set_callback() are made. In
+	 * that case, we must serialize the calls
+	 * to ensure that the "callback"
+	 * and "eventMask" state variables are
+	 * always consistent.
+	 *
+	 * Note that we don't actually need to
+	 * acquire the spinlock until later
+	 * when we are finally ready to update
+	 * the "callback" and "eventMask"
+	 * state variables which are shared
+	 * with the interrupt handler.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+
+		/* Return an error if either the callback
+		 * function or event mask
+		 * is not properly defined.
+		 *
+		 * It is also considered an error if a
+		 * callback function has already
+		 * been defined. If you wish to register
+		 * for a new set of events,
+		 * then you must first call pmic_convity
+		 * clear_callback() to
+		 * deregister the existing callback
+		 * function and list of events
+		 * before trying to register a
+		 * new callback function.
+		 */
+		if ((func == NULL) ||
+				(eventMask == 0) ||
+				(convity.callback != NULL)) {
+			rc = PMIC_ERROR;
+
+			/* Register for PMIC events from the core protocol driver. */
+		} else {
+
+			if ((eventMask & USB_DETECT_4V4_RISE) ||
+					(eventMask & USB_DETECT_4V4_FALL)) {
+				/* We need to register for the 4.4V interrupt. */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_4V4);
+				rc = pmic_event_subscribe(EVENT_USBI,
+						eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					return rc;
+			}
+
+			if ((eventMask & USB_DETECT_2V0_RISE) ||
+					(eventMask & USB_DETECT_2V0_FALL)) {
+				/* We need to register for the 2.0V interrupt. */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_2V0);
+				rc = pmic_event_subscribe(EVENT_USBI,
+						eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_4V4;
+			}
+
+			if ((eventMask & USB_DETECT_0V8_RISE) ||
+					(eventMask & USB_DETECT_0V8_FALL)) {
+				/* We need to register for the 0.8V interrupt. */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_0V8);
+				rc = pmic_event_subscribe(EVENT_USBI,
+						eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_2V0;
+			}
+
+			if ((eventMask & USB_DETECT_MINI_A) ||
+					(eventMask & USB_DETECT_MINI_B)
+					|| (eventMask & USB_DETECT_NON_USB_ACCESSORY)
+					|| (eventMask & USB_DETECT_FACTORY_MODE)) {
+				/* We need to register for the AB_DET interrupt. */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_ABDET);
+				rc = pmic_event_subscribe(EVENT_IDI,
+						eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_0V8;
+			}
+
+			/* Use a critical section to maintain
+			 * a consistent state. */
+			spin_lock_irqsave(&lock, flags);
+
+			/* Successfully registered for all events. */
+			convity.callback = func;
+			convity.eventMask = eventMask;
+			spin_unlock_irqrestore(&lock, flags);
+
+			goto End;
+
+			/* This section unregisters any already
+			 * registered events if we should
+			 * encounter an error partway through
+			 * the registration process. Note
+			 * that we don't check the return
+			 * status here since it is already set
+			 * to PMIC_ERROR before we get here.
+			 */
+Cleanup_0V8:
+
+			if ((eventMask & USB_DETECT_0V8_RISE) ||
+					(eventMask & USB_DETECT_0V8_FALL)) {
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_0V8);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+				goto End;
+			}
+
+Cleanup_2V0:
+
+			if ((eventMask & USB_DETECT_2V0_RISE) ||
+					(eventMask & USB_DETECT_2V0_FALL)) {
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_2V0);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+				goto End;
+			}
+
+Cleanup_4V4:
+
+			if ((eventMask & USB_DETECT_4V4_RISE) ||
+					(eventMask & USB_DETECT_4V4_FALL)) {
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_4V4);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+			}
+		}
+		/* Exit the critical section. */
+
+	}
+End:
+	up(&mutex);
+	return rc;
+
+}
+EXPORT_SYMBOL(pmic_convity_set_callback);
+
+/*!
+ * Clears the current callback function.
+ * If this function returns successfully
+ * then all future Connectivity events
+ * will only be handled by the default
+ * handler within the Connectivity driver.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the callback was
+ * successful cleared
+ */
+PMIC_STATUS pmic_convity_clear_callback(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE))
+		rc = pmic_convity_deregister_all();
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_clear_callback);
+
+/*!
+ * Get the current callback function and event mask.
+ *
+ * @param       handle          device handle from open() call
+ * @param       func            the current callback function
+ * @param       eventMask       the current event selection mask
+ *
+ * @return      PMIC_SUCCESS    if the callback information
+ * was successful
+ *                              retrieved
+ */
+PMIC_STATUS pmic_convity_get_callback(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_CALLBACK * const func,
+		PMIC_CONVITY_EVENTS * const eventMask)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(func != (PMIC_CONVITY_CALLBACK *) NULL) &&
+			(eventMask != (PMIC_CONVITY_EVENTS *) NULL)) {
+		*func = convity.callback;
+		*eventMask = convity.eventMask;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_get_callback);
+
+/*@*/
+
+/**********************************************************
+ * USB-specific configuration and setup functions.
+ **********************************************************
+ */
+
+/*!
+ * @name USB and USB-OTG Connectivity APIs
+ * Functions for controlling USB and USB-OTG connectivity.
+ */
+/*@{*/
+
+/*!
+ * Set the USB transceiver speed.
+ *
+ * @param       handle          device handle from open() call
+ * @param       speed           the desired USB transceiver speed
+ *
+ * @return      PMIC_SUCCESS    if the transceiver speed
+ * was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_set_speed(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_SPEED speed)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = SET_BITS(regUSB0, FSENB, 1);
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		/* Validate the function parameters and
+		 * if they are valid, then
+		 * configure the pull-up and pull-down
+		 * resistors as required for
+		 * the desired operating mode.
+		 */
+		if ((speed == USB_HIGH_SPEED))
+			/*
+			 * The USB transceiver also does not
+			 * support the high speed mode
+			 * (which is also optional under the
+			 * USB OTG specification).
+			 */
+			rc = PMIC_NOT_SUPPORTED;
+		else if ((speed != USB_LOW_SPEED)
+				&& (speed != USB_FULL_SPEED))
+			/* Final validity check on the speed parameter. */
+			rc = PMIC_ERROR;
+		else {
+			/* First configure the D+ and D-
+			 * pull-up/pull-down resistors as
+			 * per the USB OTG specification.
+			 */
+			if (speed == USB_FULL_SPEED)
+				/* Activate pull-up on D+
+				 * and pull-down on D-. */
+				reg_value = SET_BITS(regUSB0, UDM_PD, 1);
+			else if (speed == USB_LOW_SPEED)
+				/* Activate pull-up on D+
+				 * and pull-down on D-. */
+				reg_value = SET_BITS(regUSB0, FSENB, 1);
+
+			/* Now set the desired USB transceiver
+			 * speed. Note that
+			 * USB_FULL_SPEED simply requires
+			 * FSENB=0 (which it
+			 * already is).
+			 */
+
+			rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				convity.usbSpeed = speed;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_set_speed);
+
+/*!
+ * Get the USB transceiver speed.
+ *
+ * @param       handle          device handle from open() call
+ * @param       speed           the current USB transceiver speed
+ * @param       mode            the current USB transceiver mode
+ *
+ * @return      PMIC_SUCCESS    if the transceiver speed
+ * was successfully
+ *                              obtained
+ */
+PMIC_STATUS pmic_convity_usb_get_speed(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_SPEED * const speed,
+		PMIC_CONVITY_USB_MODE * const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(speed !=
+			 (PMIC_CONVITY_USB_SPEED *) NULL) &&
+			(mode !=
+			 (PMIC_CONVITY_USB_MODE *) NULL)) {
+		*speed = convity.usbSpeed;
+		*mode = convity.usbMode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_get_speed);
+
+/*!
+ * This function enables/disables VUSB and VBUS output.
+ * This API configures the VUSBEN and VBUSEN bits of USB register
+ *
+ * @param       handle          device handle from open() call
+ * @param        out_type true, for VBUS
+ *                        false, for VUSB
+ * @param        out 	if true, output is enabled
+ *                      if false, output is disabled
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_convity_set_output(const PMIC_CONVITY_HANDLE handle,
+		bool out_type, bool out)
+{
+
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+
+		if ((out_type == 0) && (out == 1)) {
+
+			reg_value = SET_BITS(regUSB1, VUSBEN, 1);
+			reg_mask = SET_BITS(regUSB1, VUSBEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					reg_value, reg_mask);
+		} else if (out_type == 0 && out == 0) {
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					reg_value, reg_mask);
+		} else if (out_type == 1 && out == 1) {
+
+			reg_value = SET_BITS(regUSB1, VBUSEN, 1);
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					reg_value, reg_mask);
+		}
+
+		else if (out_type == 1 && out == 0) {
+
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					reg_value, reg_mask);
+		}
+
+	}
+
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_set_output);
+
+/*!
+ * Set the USB transceiver's power supply configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       pwrin           USB transceiver regulator
+ * input power source
+ * @param       pwrout          USB transceiver regulator
+ * output power level
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's power supply
+ *                              configuration was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_set_power_source(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_POWER_IN
+		pwrin,
+		const PMIC_CONVITY_USB_POWER_OUT
+		pwrout)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+
+		if (pwrin == USB_POWER_INTERNAL_BOOST) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 0);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		} else if (pwrin == USB_POWER_VBUS) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 1);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		}
+
+		else if (pwrin == USB_POWER_INTERNAL) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 2);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		}
+
+		if (pwrout == USB_POWER_3V3) {
+			reg_value |= SET_BITS(regUSB1, VUSB, 1);
+			reg_mask |= SET_BITS(regUSB1, VUSB, 1);
+		}
+
+		else if (pwrout == USB_POWER_2V775) {
+			reg_value |= SET_BITS(regUSB1, VUSB, 0);
+			reg_mask |= SET_BITS(regUSB1, VUSB, 1);
+		}
+		rc = pmic_write_reg(REG_CHARGE_USB_SPARE, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			convity.usbPowerIn = pwrin;
+			convity.usbPowerOut = pwrout;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_set_power_source);
+
+/*!
+ * Get the USB transceiver's current power supply configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       pwrin           USB transceiver regulator
+ * input power source
+ * @param       pwrout          USB transceiver regulator
+ * output power level
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's power supply
+ * configuration was successfully retrieved
+ */
+PMIC_STATUS pmic_convity_usb_get_power_source(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_POWER_IN *
+		const pwrin,
+		PMIC_CONVITY_USB_POWER_OUT *
+		const pwrout)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(pwrin != (PMIC_CONVITY_USB_POWER_IN *) NULL) &&
+			(pwrout != (PMIC_CONVITY_USB_POWER_OUT *) NULL)) {
+		*pwrin = convity.usbPowerIn;
+		*pwrout = convity.usbPowerOut;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_get_power_source);
+
+/*!
+ * Set the USB transceiver's operating mode.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            desired operating mode
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's operating mode
+ * was successfully configured
+ */
+PMIC_STATUS pmic_convity_usb_set_xcvr(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_TRANSCEIVER_MODE
+		mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain
+	 * a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+
+		if (mode == USB_TRANSCEIVER_OFF) {
+			reg_value = SET_BITS(regUSB0, USBXCVREN, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+
+			rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		}
+
+		if (mode == USB_SINGLE_ENDED_UNIDIR) {
+			reg_value |=
+				SET_BITS(regUSB0, DATSE0, 1) | SET_BITS(regUSB0,
+						BIDIR, 0);
+			reg_mask |=
+				SET_BITS(regUSB0, USB_SUSPEND,
+						1) | SET_BITS(regUSB0, DATSE0,
+							1) | SET_BITS(regUSB0, BIDIR,
+								1);
+		} else if (mode == USB_SINGLE_ENDED_BIDIR) {
+			reg_value |=
+				SET_BITS(regUSB0, DATSE0, 1) | SET_BITS(regUSB0,
+						BIDIR, 1);
+			reg_mask |=
+				SET_BITS(regUSB0, USB_SUSPEND,
+						1) | SET_BITS(regUSB0, DATSE0,
+							1) | SET_BITS(regUSB0, BIDIR,
+								1);
+		} else if (mode == USB_DIFFERENTIAL_UNIDIR) {
+			reg_value |=
+				SET_BITS(regUSB0, DATSE0, 0) | SET_BITS(regUSB0,
+						BIDIR, 0);
+			reg_mask |=
+				SET_BITS(regUSB0, USB_SUSPEND,
+						1) | SET_BITS(regUSB0, DATSE0,
+							1) | SET_BITS(regUSB0, BIDIR,
+								1);
+		} else if (mode == USB_DIFFERENTIAL_BIDIR) {
+			reg_value |=
+				SET_BITS(regUSB0, DATSE0, 0) | SET_BITS(regUSB0,
+						BIDIR, 1);
+			reg_mask |=
+				SET_BITS(regUSB0, USB_SUSPEND,
+						1) | SET_BITS(regUSB0, DATSE0,
+							1) | SET_BITS(regUSB0, BIDIR,
+								1);
+		}
+
+		if (mode == USB_SUSPEND_ON) {
+			reg_value |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		} else if (mode == USB_SUSPEND_OFF) {
+			reg_value |= SET_BITS(regUSB0, USB_SUSPEND, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		}
+
+		if (mode == USB_OTG_SRP_DLP_START) {
+			reg_value |= SET_BITS(regUSB0, USB_PU, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		} else if (mode == USB_OTG_SRP_DLP_STOP) {
+			reg_value &= SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+		}
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			convity.usbXcvrMode = mode;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_set_xcvr);
+
+/*!
+ * Get the USB transceiver's current operating mode.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            current operating mode
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's
+ * operating mode was successfully retrieved
+ */
+PMIC_STATUS pmic_convity_usb_get_xcvr(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_TRANSCEIVER_MODE *
+		const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(mode !=
+			 (PMIC_CONVITY_USB_TRANSCEIVER_MODE *) NULL)) {
+		*mode = convity.usbXcvrMode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_get_xcvr);
+
+/*!
+ * Set the Data Line Pulse duration
+ * (in milliseconds) for the USB OTG
+ * Session Request Protocol.
+ *
+ * For mc13783, this feature is not supported.
+ * So return PMIC_NOT_SUPPORTED
+ *
+ * @param       handle          device handle from open() call
+ * @param       duration        the data line pulse duration (ms)
+ *
+ * @return      PMIC_SUCCESS    if the pulse duration
+ * was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_dlp_duration(const PMIC_CONVITY_HANDLE
+		handle,
+		const unsigned int duration)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+
+	/* No critical section is required. */
+
+	if ((handle != convity.handle)
+			|| (convity.handleState !=
+				HANDLE_IN_USE))
+		/* Must return error indication
+		 * for invalid handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_otg_set_dlp_duration);
+
+/*!
+ * Get the current Data Line Pulse duration
+ * (in milliseconds) for the USB
+ * OTG Session Request Protocol.
+ *
+ * @param       handle          device handle from open() call
+ * @param       duration        the data line pulse duration (ms)
+ *
+ * @return      PMIC_SUCCESS    if the pulse duration was
+ * successfully obtained
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_dlp_duration(const PMIC_CONVITY_HANDLE
+		handle,
+		unsigned int *const duration)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+
+	/* No critical section is required. */
+
+	if ((handle != convity.handle) ||
+			(convity.handleState != HANDLE_IN_USE)) {
+		/* Must return error indication
+		 * for invalid handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_otg_get_dlp_duration);
+
+/*!
+ * Set the USB On-The-Go (OTG) configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfg             desired USB OTG configuration
+ *
+ * @return      PMIC_SUCCESS    if the OTG configuration
+ * was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_OTG_CONFIG
+		cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to
+	 * maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		if (cfg & USB_OTG_SE0CONN) {
+			reg_value = SET_BITS(regUSB0, SE0_CONN, 1);
+			reg_mask = SET_BITS(regUSB0, SE0_CONN, 1);
+		}
+		if (cfg & USBXCVREN) {
+			reg_value |= SET_BITS(regUSB0, USBXCVREN, 1);
+			reg_mask |= SET_BITS(regUSB0, USBXCVREN, 1);
+		}
+
+		if (cfg & USB_OTG_DLP_SRP) {
+			reg_value |= SET_BITS(regUSB0, DLP_SRP, 1);
+			reg_mask |= SET_BITS(regUSB0, DLP_SRP, 1);
+		}
+
+		if (cfg & USB_PULL_OVERRIDE) {
+			reg_value |= SET_BITS(regUSB0, PULLOVR, 1);
+			reg_mask |= SET_BITS(regUSB0, PULLOVR, 1);
+		}
+
+		if (cfg & USB_PU) {
+			reg_value |= SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+		}
+
+		if (cfg & USB_UDM_PD) {
+			reg_value |= SET_BITS(regUSB0, UDM_PD, 1);
+			reg_mask |= SET_BITS(regUSB0, UDM_PD, 1);
+		}
+
+		if (cfg & USB_UDP_PD) {
+			reg_value |= SET_BITS(regUSB0, UDP_PD, 1);
+			reg_mask |= SET_BITS(regUSB0, UDP_PD, 1);
+		}
+
+		if (cfg & USB_DP150K_PU) {
+			reg_value |= SET_BITS(regUSB0, DP150K_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, DP150K_PU, 1);
+		}
+
+		if (cfg & USB_USBCNTRL) {
+			reg_value |= SET_BITS(regUSB0, USBCNTRL, 1);
+			reg_mask |= SET_BITS(regUSB0, USBCNTRL, 1);
+		}
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_HIGH)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 0);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 1);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 2);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 3);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 4);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 5);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 6);
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_LOW) {
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 7);
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 7);
+		}
+
+		if (cfg & USB_VBUS_PULLDOWN) {
+			reg_value |= SET_BITS(regUSB0, VBUSPDENB, 1);
+			reg_mask |= SET_BITS(regUSB0, VBUSPDENB, 1);
+		}
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			if ((cfg & USB_VBUS_CURRENT_LIMIT_HIGH) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS) ||
+					(cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)) {
+				/* Make sure that the VBUS current limit state is
+				 * correctly set to either USB_VBUS_CURRENT_LIMIT_HIGH
+				 * or USB_VBUS_CURRENT_LIMIT_LOW but never both at the
+				 * same time.
+				 *
+				 * We guarantee this by first clearing both of the
+				 * status bits and then resetting the correct one.
+				 */
+				convity.usbOtgCfg &=
+					~(USB_VBUS_CURRENT_LIMIT_HIGH |
+							USB_VBUS_CURRENT_LIMIT_LOW |
+							USB_VBUS_CURRENT_LIMIT_LOW_10MS |
+							USB_VBUS_CURRENT_LIMIT_LOW_20MS |
+							USB_VBUS_CURRENT_LIMIT_LOW_30MS |
+							USB_VBUS_CURRENT_LIMIT_LOW_40MS |
+							USB_VBUS_CURRENT_LIMIT_LOW_50MS |
+							USB_VBUS_CURRENT_LIMIT_LOW_60MS);
+			}
+
+			convity.usbOtgCfg |= cfg;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_otg_set_config);
+
+/*!
+ * Clears the USB On-The-Go (OTG) configuration.
+ * Multiple configuration settings
+ * may be OR'd together in a single call.
+ * However, selecting conflicting
+ * settings (e.g., multiple VBUS current
+ * limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             USB OTG configuration settings to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration
+ * was successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB
+ * OTG configuration is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_clear_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_OTG_CONFIG
+		cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		if (cfg & USB_OTG_SE0CONN)
+			reg_mask = SET_BITS(regUSB0, SE0_CONN, 1);
+
+		if (cfg & USB_OTG_DLP_SRP)
+			reg_mask |= SET_BITS(regUSB0, DLP_SRP, 1);
+
+		if (cfg & USB_DP150K_PU)
+			reg_mask |= SET_BITS(regUSB0, DP150K_PU, 1);
+
+		if (cfg & USB_PULL_OVERRIDE)
+			reg_mask |= SET_BITS(regUSB0, PULLOVR, 1);
+
+		if (cfg & USB_PU)
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+
+		if (cfg & USB_UDM_PD)
+			reg_mask |= SET_BITS(regUSB0, UDM_PD, 1);
+
+		if (cfg & USB_UDP_PD)
+			reg_mask |= SET_BITS(regUSB0, UDP_PD, 1);
+
+		if (cfg & USB_USBCNTRL)
+			reg_mask |= SET_BITS(regUSB0, USBCNTRL, 1);
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_HIGH)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 0);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 1);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 2);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 3);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 4);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 5);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 6);
+
+		if (cfg & USB_VBUS_PULLDOWN)
+			reg_mask |= SET_BITS(regUSB0, VBUSPDENB, 1);
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			convity.usbOtgCfg &= ~cfg;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_otg_clear_config);
+
+/*!
+ * Get the current USB On-The-Go (OTG) configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfg             the current USB OTG configuration
+ *
+ * @return      PMIC_SUCCESS    if the OTG configuration was
+ * successfully retrieved
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_config(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_OTG_CONFIG *
+		const cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(cfg != (PMIC_CONVITY_USB_OTG_CONFIG *) NULL)) {
+		*cfg = convity.usbOtgCfg;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_usb_otg_get_config);
+
+/*********************************************************
+ * RS-232-specific configuration and setup functions.
+ *********************************************************
+ */
+
+/*!
+ * @name RS-232 Serial Connectivity APIs
+ * Functions for controlling RS-232 serial connectivity.
+ */
+/*@{*/
+
+/*!
+ * Set the connectivity interface to the selected
+ * RS-232 operating
+ * configuration. Note that the RS-232 operating mode
+ * will be automatically
+ * overridden if the USB_EN is asserted at any time
+ * (e.g., when a USB device
+ * is attached). However, we will also automatically
+ * return to the RS-232
+ * mode once the USB device is detached.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfgInternal     RS-232 transceiver
+ * internal connections
+ * @param       cfgExternal     RS-232 transceiver
+ * external connections
+ *
+ * @return      PMIC_SUCCESS    if the requested mode was set
+ */
+PMIC_STATUS pmic_convity_rs232_set_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_RS232_INTERNAL
+		cfgInternal,
+		const PMIC_CONVITY_RS232_EXTERNAL
+		cfgExternal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value0 = 0, reg_value1 = 0;
+	unsigned int reg_mask = SET_BITS(regUSB1, RSPOL, 1);
+
+	/* Use a critical section to
+	 * maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE)) {
+		rc = PMIC_SUCCESS;
+
+		if (cfgInternal ==
+				RS232_TX_USE0VM_RX_UDATVP)
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 1);
+
+		else if (cfgInternal ==
+				RS232_TX_RX_INTERNAL_DEFAULT) {
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 1);
+			reg_mask |= SET_BITS(regUSB1, RSPOL, 1);
+
+		} else if (cfgInternal ==
+				RS232_TX_UDATVP_RX_URXVM) {
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 2);
+			reg_value1 |= SET_BITS(regUSB1, RSPOL, 1);
+
+		} else if ((cfgExternal == RS232_TX_UDM_RX_UDP) ||
+				(cfgExternal ==
+				 RS232_TX_RX_EXTERNAL_DEFAULT)) {
+			/* Configure for TX on D+ and RX on D-. */
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 1);
+			reg_value1 |= SET_BITS(regUSB1, RSPOL, 0);
+		} else if (cfgExternal != RS232_TX_UDM_RX_UDP)
+			/* Any other RS-232 configuration is an error. */
+			rc = PMIC_ERROR;
+
+		if (rc == PMIC_SUCCESS) {
+			/* Configure for TX on D- and RX on D+. */
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					reg_value1, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				convity.rs232CfgInternal = cfgInternal;
+				convity.rs232CfgExternal = cfgExternal;
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_rs232_set_config);
+
+/*!
+ * Get the connectivity interface's current RS-232
+ * operating configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfgInternal     RS-232 transceiver
+ * internal connections
+ * @param       cfgExternal     RS-232 transceiver
+ * external connections
+ *
+ * @return      PMIC_SUCCESS    if the requested
+ * mode was retrieved
+ */
+PMIC_STATUS pmic_convity_rs232_get_config(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_RS232_INTERNAL *
+		const cfgInternal,
+		PMIC_CONVITY_RS232_EXTERNAL *
+		const cfgExternal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == convity.handle) &&
+			(convity.handleState == HANDLE_IN_USE) &&
+			(cfgInternal !=
+			 (PMIC_CONVITY_RS232_INTERNAL *) NULL) &&
+			(cfgExternal !=
+			 (PMIC_CONVITY_RS232_EXTERNAL *) NULL)) {
+		*cfgInternal = convity.rs232CfgInternal;
+		*cfgExternal = convity.rs232CfgExternal;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_rs232_get_config);
+
+/***************************************************************
+ * CEA-936-specific configuration and setup functions.
+ ***************************************************************
+ */
+
+/*!
+ * @name CEA-936 Connectivity APIs
+ * Functions for controlling CEA-936 connectivity.
+ */
+/*@{*/
+
+/*!
+ * Signal the attached device to exit the current
+ * CEA-936 operating mode.
+ * Returns an error if the current operating mode
+ * is not CEA-936.
+ *
+ * @param       handle          device handle from open() call
+ * @param       signal          type of exit signal to be sent
+ *
+ * @return      PMIC_SUCCESS    if exit signal was sent
+ */
+PMIC_STATUS pmic_convity_cea936_exit_signal(const PMIC_CONVITY_HANDLE handle,
+		const
+		PMIC_CONVITY_CEA936_EXIT_SIGNAL
+		signal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask =
+		SET_BITS(regUSB0, IDPD, 1) | SET_BITS(regUSB0, IDPULSE, 1);
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle != convity.handle)
+			|| (convity.handleState != HANDLE_IN_USE))
+		/* Must return error indication for invalid
+		 * handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+	else if (signal == CEA936_UID_PULLDOWN_6MS)
+		reg_value =
+			SET_BITS(regUSB0, IDPULSE, 0) | SET_BITS(regUSB0, IDPD, 0);
+	else if (signal == CEA936_UID_PULLDOWN_6MS)
+		reg_value = SET_BITS(regUSB0, IDPULSE, 1);
+	else if (signal == CEA936_UID_PULLDOWN)
+		reg_value = SET_BITS(regUSB0, IDPD, 1);
+	else if (signal == CEA936_UDMPULSE)
+		reg_value = SET_BITS(regUSB0, DMPULSE, 1);
+
+	rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+	up(&mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL(pmic_convity_cea936_exit_signal);
+
+/*@}*/
+
+/**********************************************************
+ * Static functions.
+ **********************************************************
+ */
+
+/*!
+ * @name Connectivity Driver Internal Support Functions
+ * These non-exported internal functions are used to
+ * support the functionality
+ * of the exported connectivity APIs.
+ */
+/*@{*/
+
+/*!
+ * This internal helper function sets the desired
+ * operating mode (either USB
+ * OTG or RS-232). It must be called with the mutex
+ * already acquired.
+ *
+ * @param       mode               the desired operating
+ * mode (USB or RS232)
+ *
+ * @return      PMIC_SUCCESS       if the desired operating
+ * mode was set
+ * @return      PMIC_NOT_SUPPORTED if the desired operating
+ * mode is invalid
+ */
+static PMIC_STATUS pmic_convity_set_mode_internal(const PMIC_CONVITY_MODE mode)
+{
+	unsigned int reg_value0 = 0, reg_value1 = 0;
+	unsigned int reg_mask0 = 0, reg_mask1 = 0;
+
+	PMIC_STATUS rc = PMIC_SUCCESS;
+
+	switch (mode) {
+	case USB:
+			/* For the USB mode, we start
+			 * by tri-stating the USB bus (by
+			 * setting VBUSEN = 0) until a
+			 * device is connected (i.e.,
+			 * until we receive a 4.4V rising
+			 * edge event). All pull-up
+			 * and pull-down resistors are also
+			 * disabled until a USB
+			 * device is actually connected and we
+			 * have determined which
+			 * device is the host and the desired
+			 * USB bus speed.
+			 *
+			 * Also tri-state the RS-232 buffers
+			 * (by setting RSTRI = 1).
+			 * This prevents the hardware from
+			 * automatically returning to
+			 * the RS-232 mode when the USB
+			 * device is detached.
+			 */
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 0);
+			reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+			break;
+
+	case RS232_1:
+			/* For the RS-232 mode, we tri-state
+			 * the USB bus (by setting
+			 * VBUSEN = 0) and enable the RS-232
+			 * transceiver (by setting
+			 * RS232ENB = 0).
+			 *
+			 * Note that even in the RS-232 mode,
+			 * if a USB device is
+			 * plugged in, we will receive a 4.4V
+			 * rising edge event which
+			 * will automatically disable the RS-232
+			 * transceiver and
+			 * tri-state the RS-232 buffers.
+			 * This allows us to temporarily
+			 * switch over to USB mode while
+			 * the USB device is attached.
+			 * The RS-232 transceiver and buffers
+			 * will be automatically
+			 * re-enabled when the USB device
+			 * is detached.
+			 */
+
+			/* Explicitly disconnect all of the
+			 * USB pull-down resistors
+			 * and the VUSB power regulator here
+			 * just to be safe.
+			 *
+			 * But we do connect the internal
+			 * pull-up resistor on USB_D+
+			 * to avoid having an extra load on
+			 * the USB_D+ line when in
+			 * RS-232 mode.
+			 */
+
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 1) |
+				SET_BITS(regUSB0, VBUSPDENB, 1) |
+				SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask0 =
+				SET_BITS(regUSB0, INTERFACE_MODE, 7) | SET_BITS(regUSB0,
+						VBUSPDENB,
+						1) |
+				SET_BITS(regUSB0, USB_PU, 1);
+
+			reg_value1 = SET_BITS(regUSB1, RSPOL, 0);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+
+			if (rc == PMIC_SUCCESS) {
+				CHECK_ERROR(pmic_write_reg
+						(REG_CHARGE_USB_SPARE,
+						 reg_value1, reg_mask1));
+			}
+			break;
+
+	case RS232_2:
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 2) |
+				SET_BITS(regUSB0, VBUSPDENB, 1) |
+				SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask0 =
+				SET_BITS(regUSB0, INTERFACE_MODE, 7) | SET_BITS(regUSB0,
+						VBUSPDENB,
+						1) |
+				SET_BITS(regUSB0, USB_PU, 1);
+
+			reg_value1 = SET_BITS(regUSB1, RSPOL, 1);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+
+			if (rc == PMIC_SUCCESS) {
+				CHECK_ERROR(pmic_write_reg
+						(REG_CHARGE_USB_SPARE,
+						 reg_value1, reg_mask1));
+			}
+			break;
+
+	case CEA936_MONO:
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 4);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+			break;
+
+	case CEA936_STEREO:
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 5);
+			reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+			break;
+
+	case CEA936_TEST_RIGHT:
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 6);
+			reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+			break;
+
+	case CEA936_TEST_LEFT:
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 7);
+			reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+			break;
+
+	default:
+			rc = PMIC_NOT_SUPPORTED;
+	}
+
+	if (rc == PMIC_SUCCESS)
+		convity.mode = mode;
+
+	return rc;
+}
+
+/*!
+ * This internal helper function deregisters
+ * all of the currently registered
+ * callback events. It must be called with
+ * the mutual exclusion spinlock
+ * already acquired.
+ *
+ * We've defined the event and callback
+ * deregistration code here as a separate
+ * function because it can be called by
+ * either the pmic_convity_close() or the
+ * pmic_convity_clear_callback() APIs. We
+ * also wanted to avoid any possible
+ * issues with having the same thread calling
+ * spin_lock_irq() twice.
+ *
+ * Note that the mutex must have already been
+ * acquired. We will also acquire
+ * the spinlock here to avoid any possible
+ * race conditions with the interrupt
+ * handler.
+ *
+ * @return      PMIC_SUCCESS    if all of
+ * the callback events were cleared
+ */
+static PMIC_STATUS pmic_convity_deregister_all(void)
+{
+	unsigned long flags;
+	PMIC_STATUS rc = PMIC_SUCCESS;
+
+	/* Deregister each of the PMIC
+	 * events that we had previously
+	 * registered for by using pmic_event_subscribe().
+	 */
+
+	if ((convity.eventMask & USB_DETECT_MINI_A) ||
+			(convity.eventMask & USB_DETECT_MINI_B) ||
+			(convity.eventMask & USB_DETECT_NON_USB_ACCESSORY) ||
+			(convity.eventMask & USB_DETECT_FACTORY_MODE)) {
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_ABDET);
+
+		if (pmic_event_unsubscribe(EVENT_IDI, eventNotify) ==
+				PMIC_SUCCESS) {
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+
+			spin_lock_irqsave(&lock, flags);
+
+			convity.eventMask &= ~(USB_DETECT_MINI_A |
+					USB_DETECT_MINI_B |
+					USB_DETECT_NON_USB_ACCESSORY |
+					USB_DETECT_FACTORY_MODE);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+				("%s: pmic_event_unsubscribe() for EVENT_AB_DETI failed\n",
+				 __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	else if ((convity.eventMask & USB_DETECT_0V8_RISE) ||
+			(convity.eventMask & USB_DETECT_0V8_FALL)) {
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_0V8);
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+				PMIC_SUCCESS) {
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			convity.eventMask &= ~(USB_DETECT_0V8_RISE |
+					USB_DETECT_0V8_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+				("%s: pmic_event_unsubscribe() for EVENT_USB_08VI failed\n",
+				 __FILE__);
+			rc = PMIC_ERROR;
+		}
+
+	}
+
+	else if ((convity.eventMask & USB_DETECT_2V0_RISE) ||
+			(convity.eventMask & USB_DETECT_2V0_FALL)) {
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_2V0);
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+				PMIC_SUCCESS) {
+			/* Also acquire the spinlock here
+			 * to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			convity.eventMask &= ~(USB_DETECT_2V0_RISE |
+					USB_DETECT_2V0_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+				("%s: pmic_event_unsubscribe() for EVENT_USB_20VI failed\n",
+				 __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	else if ((convity.eventMask & USB_DETECT_4V4_RISE) ||
+			(convity.eventMask & USB_DETECT_4V4_FALL)) {
+
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_4V4);
+
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+				PMIC_SUCCESS) {
+
+			/* Also acquire the spinlock here
+			 * to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			convity.eventMask &= ~(USB_DETECT_4V4_RISE |
+					USB_DETECT_4V4_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+				("%s: pmic_event_unsubscribe() for EVENT_USB_44VI failed\n",
+				 __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	if (rc == PMIC_SUCCESS) {
+		/* Also acquire the spinlock here
+		 * to avoid any possible race
+		 * conditions with the interrupt handler.
+		 */
+		spin_lock_irqsave(&lock, flags);
+
+		/* Restore the initial reset values
+		 * for the callback function
+		 * and event mask parameters. This
+		 * should be NULL and zero,
+		 * respectively.
+		 *
+		 * Note that we wait until the end
+		 * here to fully reset everything
+		 * just in case some of the pmic_event_unsubscribe()
+		 * calls above
+		 * failed for some reason
+		 * (which normally shouldn't happen).
+		 */
+		convity.callback = reset.callback;
+		convity.eventMask = reset.eventMask;
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+	return rc;
+}
+
+/*!
+ * This is the default event handler for all
+ * connectivity-related events
+ * and hardware interrupts.
+ *
+ * @param       param           event ID
+ */
+static void pmic_convity_event_handler(void *param)
+{
+	unsigned long flags;
+
+	/* Update the global list of
+	 * active interrupt events. */
+	spin_lock_irqsave(&lock, flags);
+	eventID |= (PMIC_CORE_EVENT) (param);
+	spin_unlock_irqrestore(&lock, flags);
+
+	/* Schedule the tasklet to be run as
+	 * soon as it is convenient to do so. */
+	tasklet_schedule(&convityTasklet);
+}
+
+/*!
+ * @brief This is the connectivity driver
+ * tasklet that handles interrupt events.
+ *
+ * This function is scheduled by the
+ * connectivity driver interrupt handler
+ * pmic_convity_event_handler() to
+ * complete the processing of all of the
+ * connectivity-related interrupt events.
+ *
+ * Since this tasklet runs with
+ * interrupts enabled, we can safely call
+ * the ADC driver, if necessary,
+ * to properly detect the type of USB connection
+ * that is being made and to call
+ * any user-registered callback functions.
+ *
+ * @param   arg                The parameter that was
+ * provided above in
+ * the DECLARE_TASKLET() macro (unused).
+ */
+static void pmic_convity_tasklet(unsigned long arg)
+{
+
+	static const unsigned USB_ID_ADC_CHANNEL = USB_ID;
+	static const unsigned short ADC_FULLSCALE = 0x3ff;
+	static const unsigned short ADC_FULLSCALE_VOLTAGE = 230;
+	static const unsigned short ADC_SCALE_FACTOR = 100;
+	static const unsigned USB_MINI_A_DETECT_THRESHOLD = 0.15 * 250;
+	static const unsigned USB_NON_USB_DETECT_THRESHOLD = 0.85 * 250;
+	unsigned short adcResult = 0;
+	unsigned voltageUSB_IDScaled = 0;
+	PMIC_CONVITY_EVENTS activeEvents = 0;
+	unsigned long flags = 0;
+
+	/* Check the interrupt sense bits to determine exactly what
+	 * event just occurred.
+	 */
+	if (eventID & CORE_EVENT_4V4) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_4V4;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents = pmic_check_sensor(SENSE_USB4V4S) ?
+			USB_DETECT_4V4_RISE : USB_DETECT_4V4_FALL;
+
+	} else if (eventID & CORE_EVENT_2V0) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_2V0;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents = pmic_check_sensor(SENSE_USB2V0S) ?
+			USB_DETECT_2V0_RISE : USB_DETECT_2V0_FALL;
+
+	} else if (eventID & CORE_EVENT_0V8) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_0V8;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents = pmic_check_sensor(SENSE_USB0V8S) ?
+			USB_DETECT_0V8_RISE : USB_DETECT_0V8_FALL;
+
+	} else if (eventID & CORE_EVENT_ABDET) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_ABDET;
+		spin_unlock_irqrestore(&lock, flags);
+
+		/* We need to read the ADC comparator
+		 * voltage level to determine
+		 * the type of USB connector. Note
+		 * that channel 8 of the first
+		 * group of ADC channels (AD_SEL = 0
+		 * and ADA[2:0] = 111) is reserved
+		 * for reading the USB_ID input.
+		 */
+		if (pmic_adc_convert(USB_ID_ADC_CHANNEL, &adcResult) ==
+				PMIC_SUCCESS) {
+			/* As stated in the mc13783 DTS
+			 * document, the voltage scaling
+			 * function is:
+			 *
+			 * V_USB_ID_SENSE = V_USB_ID * 0.9 (+/-5%)
+			 *
+			 * But note that the ADC specifications
+			 * also state that the full
+			 * input voltage range is 0 V - 2.30 V
+			 * with a 10-bit output.
+			 * Therefore, we must first convert the
+			 * ADC reading back into a
+			 * voltage level before using the above
+			 * equation to calculate the
+			 * actual voltage on the USB ID line.
+			 *
+			 * Another important thing to note is
+			 * that we must avoid using
+			 * floating-point arithmetic here by employing
+			 * an appropriate
+			 * scaling factor of our own. The scaling factor
+			 * must also provide
+			 * at least one digit of precision in the final
+			 * result.
+			 *
+			 * To make things clear, we'll calculate the USB
+			 * ID voltage in two
+			 * steps. The first step is to calculate the
+			 * voltage level as
+			 * measured by the ADC. Here we simply scale
+			 * the ADC result by
+			 * 100 to keep some precision in the division
+			 * operation. Then we
+			 * multiply by the ADC full scale voltage of
+			 * 2.30 V (also scaled
+			 * by 100 to avoid floating-point math).
+			 * This gives us the ADC
+			 * measured voltage scaled by 10000.
+			 */
+			voltageUSB_IDScaled =
+				((unsigned)adcResult * ADC_SCALE_FACTOR) /
+				ADC_FULLSCALE * ADC_FULLSCALE_VOLTAGE;
+
+			/* The second step now is to apply the
+			 * scaling equation given
+			 * above to calculate the actual USB ID
+			 * voltage level. Here we
+			 * can divide by 80 because the scaling
+			 * factor from the previous
+			 * calculation was 10000. Therefore, we
+			 * can reduce the overall
+			 * scaling factor to be 100 by simply multiplying
+			 * the denominator
+			 * by 100. This also helps us to avoid having
+			 * to use floating-point
+			 * math in the division operation.
+			 *
+			 * The resulting value is the actual USB ID
+			 * voltage and is still
+			 * scaled by 100 which gives us two decimal
+			 * places of precision.
+			 */
+			voltageUSB_IDScaled = voltageUSB_IDScaled / 80;
+
+			if (voltageUSB_IDScaled < USB_MINI_A_DETECT_THRESHOLD)
+				/* Consider voltage as ground
+				 * (mini-A connected). */
+				activeEvents = USB_DETECT_MINI_A;
+			else if (voltageUSB_IDScaled >
+					USB_MINI_A_DETECT_THRESHOLD
+					&& voltageUSB_IDScaled <
+					USB_NON_USB_DETECT_THRESHOLD)
+
+				/*    Connection of non-usb accessory   */
+				activeEvents = USB_DETECT_NON_USB_ACCESSORY;
+			else if (voltageUSB_IDScaled >
+					USB_NON_USB_DETECT_THRESHOLD
+					&& voltageUSB_IDScaled < 300)
+
+				/* Consider voltage as
+				 * floating/connected with high impedence
+				 * (mini-B connected).
+				 */
+				activeEvents = USB_DETECT_MINI_B;
+		} else if (voltageUSB_IDScaled > 300)
+			activeEvents = USB_DETECT_FACTORY_MODE;
+	}
+
+	/* Begin a critical section here so
+	 * that we don't register/deregister
+	 * for events or open/close the connectivity
+	 * driver while the existing
+	 * event handler (if it is currently defined)
+	 * is in the middle of handling
+	 * the current event.
+	 */
+	spin_lock_irqsave(&lock, flags);
+
+	/* Finally, call the user-defined
+	 * callback function if required. */
+	if ((convity.handleState == HANDLE_IN_USE) &&
+			(convity.callback != NULL) &&
+			(activeEvents & convity.eventMask))
+		(*convity.callback) (activeEvents);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/*@}*/
+
+/**********************************************************
+ * Module initialization and termination functions.
+ *
+ * Note that if this code is compiled into the
+ * kernel, then the
+ * module_init() function will be called within
+ * the device_initcall()
+ * group.
+ ***********************************************************
+ */
+
+/*!
+ * @name Connectivity Driver Loading/Unloading Functions
+ * These non-exported internal functions are used
+ * to support the connectivity
+ * device driver initialization and de-initialization
+ * operations.
+ */
+/*@{*/
+
+/*!
+ * @brief This is the connectivity device driver
+ * initialization function.
+ *
+ * This function is called by the kernel when this
+ * device driver is first
+ * loaded.
+ */
+static int __init mc13783_pmic_convity_init(void)
+{
+	printk(KERN_INFO "PMIC Connectivity driver loading..\n");
+
+	return 0;
+}
+
+/*!
+ * @brief This is the Connectivity device driver
+ * de-initialization function.
+ *
+ * This function is called by the kernel when
+ * this device driver is about
+ * to be unloaded.
+ */
+static void __exit mc13783_pmic_convity_exit(void)
+{
+	printk(KERN_INFO "PMIC Connectivity driver unloading\n");
+
+	/* Close the device handle if it is still open.
+	 * This will also
+	 * deregister any callbacks that may still
+	 * be active.
+	 */
+	if (convity.handleState == HANDLE_IN_USE)
+		pmic_convity_close(convity.handle);
+
+	/* Reset the PMIC Connectivity register to
+	 * it's power on state.
+	 * We should do this when unloading the
+	 * module so that we don't
+	 * leave the hardware in a state which
+	 * could cause problems when
+	 * no device driver is loaded.
+	 */
+	pmic_write_reg(REG_USB, RESET_USBCNTRL_REG_0, REG_FULLMASK);
+	pmic_write_reg(REG_CHARGE_USB_SPARE, RESET_USBCNTRL_REG_1,
+			REG_FULLMASK);
+	/* Note that there is no need to reset
+	 * the "convity" device driver
+	 * state structure to the reset state
+	 * since we are in the final
+	 * stage of unloading the device driver.
+	 * The device driver state
+	 * structure will be automatically and
+	 * properly reinitialized if
+	 * this device driver is reloaded.
+	 */
+}
+
+/*@}*/
+
+/*
+ * Module entry points and description information.
+ */
+
+module_init(mc13783_pmic_convity_init);
+module_exit(mc13783_pmic_convity_exit);
+
+MODULE_DESCRIPTION("mc13783 Connectivity device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_light.c b/drivers/mxc/pmic/mc13783/pmic_light.c
new file mode 100644
index 0000000..68fc5ef
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_light.c
@@ -0,0 +1,2694 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_light.c
+ * @brief This is the main file of PMIC(mc13783) Light and Backlight driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+
+#include <asm/plat-mxc/pmic_light.h>
+
+#include "pmic_light_defs.h"
+
+#define NB_LIGHT_REG      6
+
+static int pmic_light_major;
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the light devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used to block application calls
+ */
+static wait_queue_head_t suspendq;
+
+void pmic_light_class_dev_release(struct device *dev);
+
+static struct class pmic_light_class = {
+	.owner		= THIS_MODULE,
+	.name		= "pmic_light",
+	.dev_release	= pmic_light_class_dev_release,
+};
+
+
+/*!
+ * This is the suspend of power management for the pmic light API.
+ * It suports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_suspend(struct platform_device *dev, pm_message_t state)
+{
+	suspend_flag = 1;
+	/* switch off all leds and backlights */
+	CHECK_ERROR(pmic_light_init_reg());
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the pmic light API.
+ * It suports RESTORE state.
+ *
+ * @param        dev            the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_resume(struct platform_device *pdev)
+{
+	suspend_flag = 0;
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	reg_value = BITFVAL(BIT_LEDEN, 1);
+	mask = BITFMASK(BIT_LEDEN);
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_tcled_master_enable);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	reg_value = BITFVAL(BIT_LEDEN, 0);
+	mask = BITFMASK(BIT_LEDEN);
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_tcled_master_disable);
+
+/*!
+ * This function enables backlight. Not supported on mc13783
+ * Use pmic_bklit_tcled_master_enable.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED
+ */
+PMIC_STATUS pmic_bklit_master_enable(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_master_enable);
+
+/*!
+ * This function disables backlight. Not supported on mc13783
+ * Use pmic_bklit_tcled_master_enable.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED
+ */
+PMIC_STATUS pmic_bklit_master_disable(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_master_disable);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ level     main & aux   keyboard
+ ------    -----------  --------
+ 0         0 mA         0 mA
+ 1         3 mA         12 mA
+ 2         6 mA         24 mA
+ 3         9 mA         36 mA
+ 4         12 mA        48 mA
+ 5         15 mA        60 mA
+ 6         18 mA        72 mA
+ 7         21 mA        84 mA
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+		unsigned char level)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			value = BITFVAL(BIT_CL_MAIN, level);
+			mask = BITFMASK(BIT_CL_MAIN);
+			break;
+	case BACKLIGHT_LED2:
+			value = BITFVAL(BIT_CL_AUX, level);
+			mask = BITFMASK(BIT_CL_AUX);
+			break;
+	case BACKLIGHT_LED3:
+			value = BITFVAL(BIT_CL_KEY, level);
+			mask = BITFMASK(BIT_CL_KEY);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_set_current);
+
+/*!
+ * This function retrives backlight current level.
+ * The channels are not individually adjustable, hence
+ * the channel parameter is ignored.
+ *
+ * @param        channel   Backlight channel (Ignored because the
+ *                         channels are not individually adjustable)
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+		unsigned char *level)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_CL_MAIN);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_CL_AUX);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_CL_KEY);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, mask));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			*level = BITFEXT(reg_value, BIT_CL_MAIN);
+			break;
+	case BACKLIGHT_LED2:
+			*level = BITFEXT(reg_value, BIT_CL_AUX);
+			break;
+	case BACKLIGHT_LED3:
+			*level = BITFEXT(reg_value, BIT_CL_KEY);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_get_current);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ dc        Duty Cycle (% On-time over Cycle Time)
+ ------    ---------------------------------------
+ 0        0%
+ 1        6.7%
+ 2        13.3%
+ 3        20%
+ 4        26.7%
+ 5        33.3%
+ 6        40%
+ 7        46.7%
+ 8        53.3%
+ 9        60%
+ 10        66.7%
+ 11        73.3%
+ 12        80%
+ 13        86.7%
+ 14        93.3%
+ 15        100%
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (dc > 15)
+		return PMIC_PARAMETER_ERROR;
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			reg_value = reg_value & (~MASK_DUTY_CYCLE);
+			reg_value = reg_value | (dc << BIT_DUTY_CYCLE);
+			break;
+	case BACKLIGHT_LED2:
+			reg_value = reg_value & (~(MASK_DUTY_CYCLE << INDEX_AUX));
+			reg_value = reg_value | (dc << (BIT_DUTY_CYCLE + INDEX_AUX));
+			break;
+	case BACKLIGHT_LED3:
+			reg_value = reg_value & (~(MASK_DUTY_CYCLE << INDEX_KYD));
+			reg_value = reg_value | (dc << (BIT_DUTY_CYCLE + INDEX_KYD));
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(LREG_2, reg_value, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+
+}
+EXPORT_SYMBOL(pmic_bklit_set_dutycycle);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel, unsigned char *dc)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			*dc = (int)((reg_value & (MASK_DUTY_CYCLE))
+					>> BIT_DUTY_CYCLE);
+
+			break;
+	case BACKLIGHT_LED2:
+			*dc = (int)((reg_value & (MASK_DUTY_CYCLE << INDEX_AUX))
+					>> (BIT_DUTY_CYCLE + INDEX_AUX));
+			break;
+	case BACKLIGHT_LED3:
+			*dc = (int)((reg_value & (MASK_DUTY_CYCLE <<
+							INDEX_KYD)) >> (BIT_DUTY_CYCLE +
+							INDEX_KYD));
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_get_dutycycle);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ period      Cycle Time
+ --------    ------------
+ 0          0.01 seconds
+ 1          0.1 seconds
+ 2          0.5 seconds
+ 3          2 seconds
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (period > 3)
+		return PMIC_PARAMETER_ERROR;
+
+	mask = BITFMASK(BIT_PERIOD);
+	value = BITFVAL(BIT_PERIOD, period);
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_set_cycle_time);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_PERIOD);
+	CHECK_ERROR(pmic_read_reg(LREG_2, &value, mask));
+	*period = BITFEXT(value, BIT_PERIOD);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_get_cycle_time);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode)
+{
+	unsigned int reg_value = 0;
+	unsigned int clear_val = 0;
+	unsigned int triode_val = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			clear_val = ~(MASK_TRIODE_MAIN_BL);
+			triode_val = MASK_TRIODE_MAIN_BL;
+			break;
+	case BACKLIGHT_LED2:
+			clear_val = ~(MASK_TRIODE_MAIN_BL << INDEX_AUXILIARY);
+			triode_val = (MASK_TRIODE_MAIN_BL << INDEX_AUXILIARY);
+			break;
+	case BACKLIGHT_LED3:
+			clear_val = ~(MASK_TRIODE_MAIN_BL << INDEX_KEYPAD);
+			triode_val = (MASK_TRIODE_MAIN_BL << INDEX_KEYPAD);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	reg_value = (reg_value & clear_val);
+
+	if (mode == BACKLIGHT_TRIODE_MODE)
+		reg_value = (reg_value | triode_val);
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_set_mode);
+
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_TRIODE_MAIN_BL);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_TRIODE_AUX_BL);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_TRIODE_KEY_BL);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &reg_value, mask));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			*mode = BITFEXT(reg_value, BIT_TRIODE_MAIN_BL);
+			break;
+	case BACKLIGHT_LED2:
+			*mode = BITFEXT(reg_value, BIT_TRIODE_AUX_BL);
+			break;
+	case BACKLIGHT_LED3:
+			*mode = BITFEXT(reg_value, BIT_TRIODE_KEY_BL);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_get_mode);
+
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_UP_MAIN_BL);
+			reg_value = BITFVAL(BIT_UP_MAIN_BL, 1);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_UP_AUX_BL);
+			reg_value = BITFVAL(BIT_UP_AUX_BL, 1);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_UP_KEY_BL);
+			reg_value = BITFVAL(BIT_UP_KEY_BL, 1);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_rampup);
+
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_UP_MAIN_BL);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_UP_AUX_BL);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_UP_KEY_BL);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_off_rampup);
+
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_DOWN_MAIN_BL);
+			reg_value = BITFVAL(BIT_DOWN_MAIN_BL, 1);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_DOWN_AUX_BL);
+			reg_value = BITFVAL(BIT_DOWN_AUX_BL, 1);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_DOWN_KEY_BL);
+			reg_value = BITFVAL(BIT_DOWN_KEY_BL, 1);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_rampdown);
+
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+			mask = BITFMASK(BIT_DOWN_MAIN_BL);
+			break;
+	case BACKLIGHT_LED2:
+			mask = BITFMASK(BIT_DOWN_AUX_BL);
+			break;
+	case BACKLIGHT_LED3:
+			mask = BITFMASK(BIT_DOWN_KEY_BL);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_off_rampdown);
+
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	value = BITFVAL(BIT_SLEWLIMBL, 1);
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_enable_edge_slow);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an <93>Instant On<94> mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void)
+{
+	unsigned int mask;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	CHECK_ERROR(pmic_write_reg(LREG_2, 0, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_disable_edge_slow);
+
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	CHECK_ERROR(pmic_read_reg(LREG_2, &value, mask));
+	*edge = (bool) BITFEXT(value, BIT_SLEWLIMBL);
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_bklit_get_edge_slow);
+
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+		t_bklit_strobe_mode mode)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_set_strobemode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ * @param	 bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (mode) {
+	case TCLED_FUN_MODE:
+			switch (bank) {
+			case TCLED_FUN_BANK1:
+					mask = MASK_BK1_FL;
+					value = MASK_BK1_FL;
+					break;
+			case TCLED_FUN_BANK2:
+					mask = MASK_BK2_FL;
+					value = MASK_BK2_FL;
+					break;
+			case TCLED_FUN_BANK3:
+					mask = MASK_BK3_FL;
+					value = MASK_BK3_FL;
+					break;
+			default:
+					return PMIC_PARAMETER_ERROR;
+			}
+			break;
+	case TCLED_IND_MODE:
+			mask = MASK_BK1_FL | MASK_BK2_FL | MASK_BK3_FL;
+			break;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_enable);
+
+/*!
+ * This function disables tri-color LED.
+ *
+ * @param        bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ *
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank)
+{
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = MASK_BK1_FL;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = MASK_BK2_FL;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = MASK_BK3_FL;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, 0, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_disable);
+
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ * @param        bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank)
+{
+	unsigned int val;
+	unsigned int mask;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = MASK_BK1_FL;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = MASK_BK2_FL;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = MASK_BK3_FL;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &val, mask));
+
+	if (val)
+		*mode = TCLED_FUN_MODE;
+	else
+		*mode = TCLED_IND_MODE;
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_get_mode);
+
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+		t_tcled_cur_level level,
+		t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (level > TCLED_CUR_LEVEL_4)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			value = BITFVAL(BITS_CL_RED, level);
+			mask = BITFMASK(BITS_CL_RED);
+			break;
+	case TCLED_IND_GREEN:
+			value = BITFVAL(BITS_CL_GREEN, level);
+			mask = BITFMASK(BITS_CL_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			value = BITFVAL(BITS_CL_BLUE, level);
+			mask = BITFMASK(BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_ind_set_current);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+		t_tcled_cur_level *level,
+		t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			mask = BITFMASK(BITS_CL_RED);
+			break;
+	case TCLED_IND_GREEN:
+			mask = BITFMASK(BITS_CL_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			mask = BITFMASK(BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			*level = BITFEXT(value, BITS_CL_RED);
+			break;
+	case TCLED_IND_GREEN:
+			*level = BITFEXT(value, BITS_CL_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			*level = BITFEXT(value, BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_ind_get_current);
+
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+		t_tcled_ind_blink_pattern pattern,
+		bool skip, t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (skip == true)
+		return PMIC_NOT_SUPPORTED;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			value = BITFVAL(BITS_DC_RED, pattern);
+			mask = BITFMASK(BITS_DC_RED);
+			break;
+	case TCLED_IND_GREEN:
+			value = BITFVAL(BITS_DC_GREEN, pattern);
+			mask = BITFMASK(BITS_DC_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			value = BITFVAL(BITS_DC_BLUE, pattern);
+			mask = BITFMASK(BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_ind_set_blink_pattern);
+
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean varible indicating if skip
+ * @param        bank         Selected tri-color bank
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+		t_tcled_ind_blink_pattern *pattern,
+		bool *skip, t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			mask = BITFMASK(BITS_DC_RED);
+			break;
+	case TCLED_IND_GREEN:
+			mask = BITFMASK(BITS_DC_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			mask = BITFMASK(BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_IND_RED:
+			*pattern = BITFEXT(value, BITS_DC_RED);
+			break;
+	case TCLED_IND_GREEN:
+			*pattern = BITFEXT(value, BITS_DC_GREEN);
+			break;
+	case TCLED_IND_BLUE:
+			*pattern = BITFEXT(value, BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_ind_get_blink_pattern);
+
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_cur_level level)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (level > TCLED_CUR_LEVEL_4)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			value = BITFVAL(BITS_CL_RED, level);
+			mask = BITFMASK(BITS_CL_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			value = BITFVAL(BITS_CL_GREEN, level);
+			mask = BITFMASK(BITS_CL_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			value = BITFVAL(BITS_CL_BLUE, level);
+			mask = BITFMASK(BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_set_current);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_cur_level *level)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = BITFMASK(BITS_CL_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = BITFMASK(BITS_CL_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = BITFMASK(BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			*level = BITFEXT(value, BITS_CL_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			*level = BITFEXT(value, BITS_CL_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			*level = BITFEXT(value, BITS_CL_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_get_current);
+
+/*!
+ * This function sets tri-color LED cycle time.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+		t_tcled_fun_cycle_time ct)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (ct > TC_CYCLE_TIME_4)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	value = BITFVAL(BIT_PERIOD, ct);
+	mask = BITFMASK(BIT_PERIOD);
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_set_cycletime);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+		t_tcled_fun_cycle_time *ct)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (*ct > TC_CYCLE_TIME_4)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BIT_PERIOD);
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	*ct = BITFVAL(BIT_PERIOD, value);
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_get_cycletime);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+		t_funlight_channel channel,
+		unsigned char dc)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			value = BITFVAL(BITS_DC_RED, dc);
+			mask = BITFMASK(BITS_DC_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			value = BITFVAL(BITS_DC_GREEN, dc);
+			mask = BITFMASK(BITS_DC_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			value = BITFVAL(BITS_DC_BLUE, dc);
+			mask = BITFMASK(BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_set_dutycycle);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+		t_funlight_channel channel,
+		unsigned char *dc)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			reg_conf = LREG_3;
+			break;
+	case TCLED_FUN_BANK2:
+			reg_conf = LREG_4;
+			break;
+	case TCLED_FUN_BANK3:
+			reg_conf = LREG_5;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = BITFMASK(BITS_DC_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = BITFMASK(BITS_DC_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = BITFMASK(BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			*dc = BITFEXT(value, BITS_DC_RED);
+			break;
+	case TCLED_FUN_CHANNEL2:
+			*dc = BITFEXT(value, BITS_DC_GREEN);
+			break;
+	case TCLED_FUN_CHANNEL3:
+			*dc = BITFEXT(value, BITS_DC_BLUE);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_get_dutycycle);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+		t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (speed) {
+	case TC_OFF:
+			value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+			break;
+	case TC_SLOW:
+			value = BITFVAL(BITS_FUN_LIGHT, BLENDED_RAMPS_SLOW);
+			break;
+	case TC_FAST:
+			value = BITFVAL(BITS_FUN_LIGHT, BLENDED_RAMPS_FAST);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_blendedramps);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+		t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (speed) {
+	case TC_OFF:
+			value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+			break;
+	case TC_SLOW:
+			value = BITFVAL(BITS_FUN_LIGHT, SAW_RAMPS_SLOW);
+			break;
+	case TC_FAST:
+			value = BITFVAL(BITS_FUN_LIGHT, SAW_RAMPS_FAST);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_sawramps);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+		t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (speed) {
+	case TC_OFF:
+			value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+			break;
+	case TC_SLOW:
+			value = BITFVAL(BITS_FUN_LIGHT, BLENDED_INVERSE_RAMPS_SLOW);
+			break;
+	case TC_FAST:
+			value = BITFVAL(BITS_FUN_LIGHT, BLENDED_INVERSE_RAMPS_FAST);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_blendedbowtie);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+		t_chaselight_pattern pattern,
+		t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (pattern > BGR)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (speed) {
+	case TC_OFF:
+			value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+			break;
+	case TC_SLOW:
+			if (pattern == PMIC_RGB)
+				value =
+					BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_RGB_SLOW);
+			else
+				value =
+					BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_BGR_SLOW);
+			break;
+	case TC_FAST:
+			if (pattern == PMIC_RGB)
+				value =
+					BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_RGB_FAST);
+			else
+				value =
+					BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_BGR_FAST);
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_chasinglightspattern);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_fun_strobe_speed speed)
+{
+	/* not supported on mc13783 */
+
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_strobe);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+		t_funlight_channel channel, bool rampup)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = LEDR1RAMPUP;
+			value = LEDR1RAMPUP;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = LEDR2RAMPUP;
+			value = LEDR2RAMPUP;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = LEDR3RAMPUP;
+			value = LEDR3RAMPUP;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = mask;
+			value = value;
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = mask * 2;
+			value = value * 2;
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = mask * 4;
+			value = value * 4;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	if (!rampup)
+		value = 0;
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_rampup);
+
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+		t_funlight_channel channel, bool *rampup)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = LEDR1RAMPUP;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = LEDR2RAMPUP;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = LEDR3RAMPUP;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = mask;
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = mask * 2;
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = mask * 4;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_1, &value, mask));
+	if (value)
+		*rampup = true;
+	else
+		*rampup = false;
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_get_fun_rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+		t_funlight_channel channel, bool rampdown)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = LEDR1RAMPDOWN;
+			value = LEDR1RAMPDOWN;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = LEDR2RAMPDOWN;
+			value = LEDR2RAMPDOWN;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = LEDR3RAMPDOWN;
+			value = LEDR3RAMPDOWN;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = mask;
+			value = value;
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = mask * 2;
+			value = value * 2;
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = mask * 4;
+			value = value * 4;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	if (!rampdown)
+		value = 0;
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_rampdown);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+		t_funlight_channel channel,
+		bool *rampdown)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = LEDR1RAMPDOWN;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = LEDR2RAMPDOWN;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = LEDR3RAMPDOWN;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+			mask = mask;
+			break;
+	case TCLED_FUN_CHANNEL2:
+			mask = mask * 2;
+			break;
+	case TCLED_FUN_CHANNEL3:
+			mask = mask * 4;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_1, &value, mask));
+	if (value)
+		*rampdown = true;
+	else
+		*rampdown = false;
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_get_fun_rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+		t_funlight_channel channel)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = MASK_BK1_FL;
+			value = ENABLE_BK1_FL;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = MASK_BK2_FL;
+			value = ENABLE_BK2_FL;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = MASK_BK3_FL;
+			value = ENABLE_BK2_FL;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_triode_on);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+		t_funlight_channel channel)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+			mask = MASK_BK1_FL;
+			break;
+	case TCLED_FUN_BANK2:
+			mask = MASK_BK2_FL;
+			break;
+	case TCLED_FUN_BANK3:
+			mask = MASK_BK3_FL;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_fun_triode_off);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	value = BITFVAL(BIT_SLEWLIMTC, 1);
+	mask = BITFMASK(BIT_SLEWLIMTC);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_enable_edge_slow);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	value = BITFVAL(BIT_SLEWLIMTC, 0);
+	mask = BITFMASK(BIT_SLEWLIMTC);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_disable_edge_slow);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	value = BITFVAL(BIT_TC1HALF, 1);
+	mask = BITFMASK(BIT_TC1HALF);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_enable_half_current);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	value = BITFVAL(BIT_TC1HALF, 0);
+	mask = BITFMASK(BIT_TC1HALF);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_tcled_disable_half_current);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+		t_aud_path path,
+		t_aud_gain gain, bool lpf_bypass)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_tcled_enable_audio_modulation);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_tcled_disable_audio_modulation);
+
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis)
+{
+
+	pmic_version_t mc13783_ver;
+	unsigned int mask;
+	unsigned int value;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+		value = BITFVAL(BIT_BOOSTEN, en_dis);
+		mask = BITFMASK(BIT_BOOSTEN);
+		CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_set_boost_mode);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis)
+{
+	pmic_version_t mc13783_ver;
+	unsigned int mask;
+	unsigned int value;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+
+		if (suspend_flag == 1)
+			return -EBUSY;
+		mask = BITFMASK(BIT_BOOSTEN);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*en_dis = BITFEXT(value, BIT_BOOSTEN);
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_get_boost_mode);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr)
+{
+	unsigned int conf_boost = 0;
+	unsigned int mask;
+	unsigned int value;
+	pmic_version_t mc13783_ver;
+
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+		if (abms > MAX_BOOST_ABMS)
+			return PMIC_PARAMETER_ERROR;
+
+		if (abr > MAX_BOOST_ABR)
+			return PMIC_PARAMETER_ERROR;
+
+		conf_boost = abms | (abr << 3);
+
+		value = BITFVAL(BITS_BOOST, conf_boost);
+		mask = BITFMASK(BITS_BOOST);
+		CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_config_boost_mode);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr)
+{
+	unsigned int mask;
+	unsigned int value;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+		mask = BITFMASK(BITS_BOOST_ABMS);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*abms = BITFEXT(value, BITS_BOOST_ABMS);
+
+		mask = BITFMASK(BITS_BOOST_ABR);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*abr = BITFEXT(value, BITS_BOOST_ABR);
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_bklit_gets_boost_mode);
+
+/*!
+ * This function implements IOCTL controls on a PMIC Light device.
+ *
+
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	t_bklit_setting_param *bklit_setting = NULL;
+	t_tcled_enable_param *tcled_setting;
+	t_fun_param *fun_param;
+	t_tcled_ind_param *tcled_ind;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_BKLIT_TCLED_ENABLE:
+			pmic_bklit_tcled_master_enable();
+			break;
+
+	case PMIC_BKLIT_TCLED_DISABLE:
+			pmic_bklit_tcled_master_disable();
+			break;
+
+	case PMIC_BKLIT_ENABLE:
+			pmic_bklit_master_enable();
+			break;
+
+	case PMIC_BKLIT_DISABLE:
+			pmic_bklit_master_disable();
+			break;
+
+	case PMIC_SET_BKLIT:
+			bklit_setting = kmalloc(sizeof(t_bklit_setting_param),
+					GFP_KERNEL);
+			if (bklit_setting == NULL)
+				return -ENOMEM;
+			if (copy_from_user(bklit_setting, (t_bklit_setting_param *) arg,
+						sizeof(t_bklit_setting_param))) {
+				kfree(bklit_setting);
+				return -EFAULT;
+			}
+
+			CHECK_ERROR_KFREE(pmic_bklit_set_mode(bklit_setting->channel,
+						bklit_setting->mode),
+					(kfree(bklit_setting)));
+			CHECK_ERROR_KFREE(pmic_bklit_set_current(bklit_setting->channel,
+						bklit_setting->
+						current_level),
+					(kfree(bklit_setting)));
+			CHECK_ERROR_KFREE(pmic_bklit_set_dutycycle
+					(bklit_setting->channel,
+					 bklit_setting->duty_cycle),
+					(kfree(bklit_setting)));
+			CHECK_ERROR_KFREE(pmic_bklit_set_cycle_time
+					(bklit_setting->cycle_time),
+					(kfree(bklit_setting)));
+			pmic_bklit_set_boost_mode(bklit_setting->en_dis);
+			pmic_bklit_config_boost_mode(bklit_setting->abms,
+					bklit_setting->abr);
+			if (bklit_setting->edge_slow != false) {
+				CHECK_ERROR_KFREE(pmic_bklit_enable_edge_slow(),
+						(kfree(bklit_setting)));
+			} else {
+				CHECK_ERROR_KFREE(pmic_bklit_disable_edge_slow(),
+						(kfree(bklit_setting)));
+			}
+
+			kfree(bklit_setting);
+			break;
+
+	case PMIC_GET_BKLIT:
+			bklit_setting = kmalloc(sizeof(t_bklit_setting_param),
+					GFP_KERNEL);
+			if (bklit_setting == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(bklit_setting, (t_bklit_setting_param *) arg,
+						sizeof(t_bklit_setting_param))) {
+				kfree(bklit_setting);
+				return -EFAULT;
+			}
+
+			pmic_bklit_get_current(bklit_setting->channel,
+					&bklit_setting->current_level);
+			pmic_bklit_get_cycle_time(&bklit_setting->cycle_time);
+			pmic_bklit_get_dutycycle(bklit_setting->channel,
+					&bklit_setting->duty_cycle);
+			bklit_setting->strobe = BACKLIGHT_STROBE_NONE;
+			pmic_bklit_get_mode(bklit_setting->channel,
+					&bklit_setting->mode);
+			pmic_bklit_get_edge_slow(&bklit_setting->edge_slow);
+			pmic_bklit_get_boost_mode(&bklit_setting->en_dis);
+			pmic_bklit_gets_boost_mode(&bklit_setting->abms,
+					&bklit_setting->abr);
+
+			if (copy_to_user((t_bklit_setting_param *) arg, bklit_setting,
+						sizeof(t_bklit_setting_param))) {
+				kfree(bklit_setting);
+				return -EFAULT;
+			}
+			kfree(bklit_setting);
+			break;
+
+	case PMIC_RAMPUP_BKLIT:
+			CHECK_ERROR(pmic_bklit_rampup((t_bklit_channel) arg));
+			break;
+
+	case PMIC_RAMPDOWN_BKLIT:
+			CHECK_ERROR(pmic_bklit_rampdown((t_bklit_channel) arg));
+			break;
+
+	case PMIC_OFF_RAMPUP_BKLIT:
+			CHECK_ERROR(pmic_bklit_off_rampup((t_bklit_channel) arg));
+			break;
+
+	case PMIC_OFF_RAMPDOWN_BKLIT:
+			CHECK_ERROR(pmic_bklit_off_rampdown((t_bklit_channel) arg));
+			break;
+
+	case PMIC_TCLED_ENABLE:
+			tcled_setting = kmalloc(sizeof(t_tcled_enable_param),
+					GFP_KERNEL);
+			if (tcled_setting == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(tcled_setting, (t_tcled_enable_param *) arg,
+						sizeof(t_tcled_enable_param))) {
+				kfree(tcled_setting);
+				return -EFAULT;
+			}
+			CHECK_ERROR_KFREE(pmic_tcled_enable(tcled_setting->mode,
+						tcled_setting->bank),
+					(kfree(bklit_setting)));
+			break;
+
+	case PMIC_TCLED_DISABLE:
+			CHECK_ERROR(pmic_tcled_disable((t_funlight_bank) arg));
+			break;
+
+	case PMIC_TCLED_PATTERN:
+			fun_param = kmalloc(sizeof(t_fun_param),
+					GFP_KERNEL);
+			if (fun_param == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(fun_param,
+						(t_fun_param *) arg, sizeof(t_fun_param))) {
+				kfree(fun_param);
+				return -EFAULT;
+			}
+
+			switch (fun_param->pattern) {
+			case BLENDED_RAMPS_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_blendedramps
+							(fun_param->bank, TC_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case BLENDED_RAMPS_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_blendedramps
+							(fun_param->bank, TC_FAST),
+							(kfree(fun_param)));
+					break;
+
+			case SAW_RAMPS_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_sawramps
+							(fun_param->bank, TC_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case SAW_RAMPS_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_sawramps
+							(fun_param->bank, TC_FAST),
+							(kfree(fun_param)));
+					break;
+
+			case BLENDED_BOWTIE_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_blendedbowtie
+							(fun_param->bank, TC_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case BLENDED_BOWTIE_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_blendedbowtie
+							(fun_param->bank, TC_FAST),
+							(kfree(fun_param)));
+					break;
+
+			case STROBE_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_strobe
+							(fun_param->bank, fun_param->channel,
+							 TC_STROBE_SLOW), (kfree(fun_param)));
+					break;
+
+			case STROBE_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_strobe
+							(fun_param->bank,
+							 fun_param->channel, TC_STROBE_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case CHASING_LIGHT_RGB_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+							(fun_param->bank, PMIC_RGB, TC_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case CHASING_LIGHT_RGB_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+							(fun_param->bank, PMIC_RGB, TC_FAST),
+							(kfree(fun_param)));
+					break;
+
+			case CHASING_LIGHT_BGR_SLOW:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+							(fun_param->bank, BGR, TC_SLOW),
+							(kfree(fun_param)));
+					break;
+
+			case CHASING_LIGHT_BGR_FAST:
+					CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+							(fun_param->bank, BGR, TC_FAST),
+							(kfree(fun_param)));
+					break;
+			}
+
+			kfree(fun_param);
+			break;
+
+	case PMIC_SET_TCLED:
+			tcled_ind = kmalloc(sizeof(t_tcled_ind_param),
+					GFP_KERNEL);
+			if (tcled_ind == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(tcled_ind, (t_tcled_ind_param *) arg,
+						sizeof(t_tcled_ind_param))) {
+				kfree(tcled_ind);
+				return -EFAULT;
+			}
+			CHECK_ERROR_KFREE(pmic_tcled_ind_set_current(tcled_ind->channel,
+						tcled_ind->level,
+						tcled_ind->bank),
+					(kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_ind_set_blink_pattern
+					(tcled_ind->channel, tcled_ind->pattern,
+					 tcled_ind->skip, tcled_ind->bank),
+					(kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_fun_rampup
+					(tcled_ind->bank, tcled_ind->channel,
+					 tcled_ind->rampup), (kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_fun_rampdown
+					(tcled_ind->bank, tcled_ind->channel,
+					 tcled_ind->rampdown), (kfree(tcled_ind)));
+			if (tcled_ind->half_current) {
+				CHECK_ERROR_KFREE(pmic_tcled_enable_half_current(),
+						(kfree(tcled_ind)));
+			} else {
+				CHECK_ERROR_KFREE(pmic_tcled_disable_half_current(),
+						(kfree(tcled_ind)));
+			}
+
+			kfree(tcled_ind);
+			break;
+
+	case PMIC_GET_TCLED:
+			tcled_ind = kmalloc(sizeof(t_tcled_ind_param),
+					GFP_KERNEL);
+			if (tcled_ind == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(tcled_ind, (t_tcled_ind_param *) arg,
+						sizeof(t_tcled_ind_param))) {
+				kfree(tcled_ind);
+				return -EFAULT;
+			}
+			CHECK_ERROR_KFREE(pmic_tcled_ind_get_current(tcled_ind->channel,
+						&tcled_ind->level,
+						tcled_ind->bank),
+					(kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_ind_get_blink_pattern
+					(tcled_ind->channel, &tcled_ind->pattern,
+					 &tcled_ind->skip, tcled_ind->bank),
+					(kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_get_fun_rampup
+					(tcled_ind->bank, tcled_ind->channel,
+					 &tcled_ind->rampup), (kfree(tcled_ind)));
+			CHECK_ERROR_KFREE(pmic_tcled_get_fun_rampdown
+					(tcled_ind->bank, tcled_ind->channel,
+					 &tcled_ind->rampdown), (kfree(tcled_ind)));
+			if (copy_to_user
+					((t_tcled_ind_param *) arg, tcled_ind,
+					 sizeof(t_tcled_ind_param))) {
+				return -EFAULT;
+			}
+			kfree(tcled_ind);
+
+			break;
+
+	default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * This function initialize Light registers of mc13783 with 0.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int pmic_light_init_reg(void)
+{
+	CHECK_ERROR(pmic_write_reg(LREG_0, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_3, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_4, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_5, 0, PMIC_ALL_BITS));
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a mc13783 light device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_light_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a mc13783 light device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_light_release(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+	return 0;
+}
+
+
+void pmic_light_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+static struct file_operations pmic_light_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_light_ioctl,
+	.open = pmic_light_open,
+	.release = pmic_light_release,
+};
+
+static int pmic_light_remove(struct platform_device *pdev)
+{
+	class_unregister(&pmic_light_class);
+	unregister_chrdev(pmic_light_major, "pmic_light");
+	return 0;
+}
+
+static int pmic_light_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_dev;
+
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+	pmic_light_major = register_chrdev(0, "pmic_light", &pmic_light_fops);
+
+	if (pmic_light_major < 0) {
+		printk(KERN_ERR "Unable to get a major for pmic_light\n");
+		return pmic_light_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	ret = class_register(&pmic_light_class);
+	if (ret) {
+		printk(KERN_ERR "Error creating pmic_light class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&pmic_light_class, &pdev->dev,
+			MKDEV(pmic_light_major, 0), NULL, "pmic_light");
+
+	if (IS_ERR(temp_dev)) {
+		printk(KERN_ERR "Error creating pmic_light class device.\n");
+		ret = PTR_ERR(temp_dev);
+		goto err_out2;
+	}
+
+	ret = pmic_light_init_reg();
+	if (ret != PMIC_SUCCESS)
+		goto err_out3;
+
+	printk(KERN_INFO "PMIC Light successfully loaded\n");
+	return ret;
+
+err_out3:
+	device_unregister(temp_dev);
+err_out2:
+	class_unregister(&pmic_light_class);
+err_out1:
+	unregister_chrdev(pmic_light_major, "pmic_light");
+	return ret;
+}
+
+static struct platform_driver pmic_light_driver_ldm = {
+	.driver = {
+		.name = "pmic_light",
+	},
+	.suspend = pmic_light_suspend,
+	.resume = pmic_light_resume,
+	.probe = pmic_light_probe,
+	.remove = pmic_light_remove,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+static int __init pmic_light_init(void)
+{
+	pr_debug("PMIC Light driver loading...\n");
+	return platform_driver_register(&pmic_light_driver_ldm);
+}
+static void __exit pmic_light_exit(void)
+{
+	platform_driver_unregister(&pmic_light_driver_ldm);
+	pr_debug("PMIC Light driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_light_init);
+module_exit(pmic_light_exit);
+
+MODULE_DESCRIPTION("PMIC_LIGHT");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_light_defs.h b/drivers/mxc/pmic/mc13783/pmic_light_defs.h
new file mode 100644
index 0000000..c10df00
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_light_defs.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_light_defs.h
+ * @brief This is the internal header PMIC(mc13783) Light and Backlight driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#ifndef __MC13783_LIGHT_DEFS_H__
+#define __MC13783_LIGHT_DEFS_H__
+
+#define LREG_0   REG_LED_CONTROL_0
+#define LREG_1   REG_LED_CONTROL_1
+#define LREG_2   REG_LED_CONTROL_2
+#define LREG_3   REG_LED_CONTROL_3
+#define LREG_4   REG_LED_CONTROL_4
+#define LREG_5   REG_LED_CONTROL_5
+
+/* REG_LED_CONTROL_0 */
+
+#define         BIT_LEDEN_LSH           0
+#define         BIT_LEDEN_WID           1
+#define         MASK_TRIODE_MAIN_BL     0x080
+#define         INDEX_AUXILIARY         1
+#define         INDEX_KEYPAD            2
+#define         BITS_FUN_LIGHT_LSH      17
+#define         BITS_FUN_LIGHT_WID      4
+#define         MASK_FUN_LIGHT          0x1E0000
+#define         MASK_BK1_FL             0x200000
+#define         ENABLE_BK1_FL           0x200000
+#define         MASK_BK2_FL             0x400000
+#define         ENABLE_BK2_FL           0x400000
+#define         MASK_BK3_FL             0x800000
+#define         ENABLE_BK3_FL           0x800000
+#define 	BIT_UP_MAIN_BL_LSH	1
+#define 	BIT_UP_MAIN_BL_WID	1
+#define 	BIT_UP_AUX_BL_LSH	2
+#define 	BIT_UP_AUX_BL_WID	1
+#define 	BIT_UP_KEY_BL_LSH	3
+#define 	BIT_UP_KEY_BL_WID	1
+#define 	BIT_DOWN_MAIN_BL_LSH	4
+#define 	BIT_DOWN_MAIN_BL_WID	1
+#define 	BIT_DOWN_AUX_BL_LSH	5
+#define 	BIT_DOWN_AUX_BL_WID	1
+#define 	BIT_DOWN_KEY_BL_LSH	6
+#define 	BIT_DOWN_KEY_BL_WID	1
+#define 	BIT_TRIODE_MAIN_BL_LSH	7
+#define 	BIT_TRIODE_MAIN_BL_WID	1
+#define 	BIT_TRIODE_AUX_BL_LSH	8
+#define 	BIT_TRIODE_AUX_BL_WID	1
+#define 	BIT_TRIODE_KEY_BL_LSH	9
+#define 	BIT_TRIODE_KEY_BL_WID	1
+
+#define         BIT_BOOSTEN_LSH         10
+#define         BIT_BOOSTEN_WID         1
+#define         BITS_BOOST_LSH          11
+#define         BITS_BOOST_WID          5
+#define         BITS_BOOST_ABMS_LSH     11
+#define         BITS_BOOST_ABMS_WID     3
+#define         BITS_BOOST_ABR_LSH      14
+#define         BITS_BOOST_ABR_WID      2
+
+#define         MAX_BOOST_ABMS          7
+#define         MAX_BOOST_ABR           3
+
+/* REG_LED_CONTROL_1 */
+
+#define         BIT_SLEWLIMTC_LSH       23
+#define         BIT_SLEWLIMTC_WID       1
+#define         BIT_TC1HALF_LSH         18
+#define         BIT_TC1HALF_WID         1
+#define         LEDR1RAMPUP             0x000001
+#define         LEDR2RAMPUP             0x000040
+#define         LEDR3RAMPUP             0x001000
+#define         LEDR1RAMPDOWN           0x000008
+#define         LEDR2RAMPDOWN           0x000200
+#define         LEDR3RAMPDOWN           0x008000
+
+/* REG_LED_CONTROL_2 */
+
+#define         BIT_SLEWLIMBL_LSH       23
+#define         BIT_SLEWLIMBL_WID       1
+#define         BIT_DUTY_CYCLE          9
+#define         MASK_DUTY_CYCLE         0x001E00
+#define         INDEX_AUX               4
+#define         INDEX_KYD               8
+#define         BIT_CL_MAIN_LSH		0
+#define         BIT_CL_MAIN_WID		3
+#define         BIT_CL_AUX_LSH		3
+#define         BIT_CL_AUX_WID		3
+#define         BIT_CL_KEY_LSH		6
+#define         BIT_CL_KEY_WID		3
+
+/* REG_LED_CONTROL_3 4 5 */
+#define         BITS_CL_RED_LSH         0
+#define         BITS_CL_RED_WID         2
+#define         BITS_CL_GREEN_LSH       2
+#define         BITS_CL_GREEN_WID       2
+#define         BITS_CL_BLUE_LSH        4
+#define         BITS_CL_BLUE_WID        2
+#define         BITS_DC_RED_LSH         6
+#define         BITS_DC_RED_WID         5
+#define         BITS_DC_GREEN_LSH       11
+#define         BITS_DC_GREEN_WID       5
+#define         BITS_DC_BLUE_LSH        16
+#define         BITS_DC_BLUE_WID        5
+#define         BIT_PERIOD_LSH          21
+#define         BIT_PERIOD_WID          2
+
+#define         DUTY_CYCLE_MAX          31
+
+/* Fun light pattern */
+#define		BLENDED_RAMPS_SLOW      	0
+#define		BLENDED_RAMPS_FAST      	1
+#define		SAW_RAMPS_SLOW  		2
+#define		SAW_RAMPS_FAST	     		3
+#define		BLENDED_INVERSE_RAMPS_SLOW	4
+#define		BLENDED_INVERSE_RAMPS_FAST	5
+#define		CHASING_LIGHTS_RGB_SLOW		6
+#define		CHASING_LIGHTS_RGB_FAST		7
+#define		CHASING_LIGHTS_BGR_SLOW		8
+#define		CHASING_LIGHTS_BGR_FAST		9
+#define		FUN_LIGHTS_OFF			15
+
+/*!
+ * This function initialize Light registers of mc13783 with 0.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int pmic_light_init_reg(void);
+
+#endif				/*  __MC13783_LIGHT_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_power.c b/drivers/mxc/pmic/mc13783/pmic_power.c
new file mode 100644
index 0000000..7080310
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_power.c
@@ -0,0 +1,3061 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_power.c
+ * @brief This is the main file of PMIC(mc13783) Power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+
+#include <asm/plat-mxc/pmic_power.h>
+
+#include "pmic_power_defs.h"
+
+static bool VBKUP1_EN;
+static bool VBKUP2_EN;
+
+/*!
+ * This function is called to put the power in a low power state.
+ * Switching off the platform cannot be decided by
+ * the power module. It has to be handled by the
+ * client application.
+ *
+ * @param   pdev  the device structure used to give information on which power
+ *                device (0 through 3 channels) to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_power_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+};
+
+/*!
+ * This function is called to resume the power from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which power
+ *                device (0 through 3 channels) to suspend
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_power_resume(struct platform_device *pdev)
+{
+	return 0;
+};
+
+/*!
+ * This function sets user power off in power
+ * control register and thus powers
+ * off the phone.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_power_off(void)
+{
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_PWRCTRL_USER_OFF_SPI);
+	value = BITFVAL(MC13783_PWRCTRL_USER_OFF_SPI,
+			MC13783_PWRCTRL_USER_OFF_SPI_ENABLE);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_off);
+
+/*!
+ * This function sets the power control configuration.
+ *
+ * @param        pc_config   power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_power_set_pc_config(t_pc_config *pc_config)
+{
+	unsigned int pwrctrl_val_reg0 = 0;
+	unsigned int pwrctrl_val_reg1 = 0;
+	unsigned int pwrctrl_mask_reg0 = 0;
+	unsigned int pwrctrl_mask_reg1 = 0;
+
+	if (pc_config == NULL)
+		return PMIC_PARAMETER_ERROR;
+
+	if (pc_config->pc_enable != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PCEN,
+					    MC13783_PWRCTRL_PCEN_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PCT,
+					    pc_config->pc_timer);
+	} else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PCEN,
+					    MC13783_PWRCTRL_PCEN_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_PCEN);
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_PCT);
+
+	if (pc_config->pc_count_enable != false) {
+
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT_EN,
+					    MC13783_PWRCTRL_PC_COUNT_EN_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT,
+					    pc_config->pc_count);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PC_MAX_CNT,
+					    pc_config->pc_max_count);
+	} else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT_EN,
+					    MC13783_PWRCTRL_PC_COUNT_EN_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_PC_COUNT_EN);
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_PC_MAX_CNT) |
+	    BITFMASK(MC13783_PWRCTRL_PC_COUNT);
+
+	if (pc_config->warm_enable != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_WARM_EN_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_WARM_EN_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_WARM_EN);
+
+	if (pc_config->user_off_pc != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_USER_OFF_PC,
+					    MC13783_PWRCTRL_USER_OFF_PC_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_USER_OFF_PC_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_USER_OFF_PC);
+
+	if (pc_config->clk_32k_user_off != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_USER_OFF,
+					    MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_USER_OFF,
+					    MC13783_PWRCTRL_32OUT_USER_OFF_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_32OUT_USER_OFF);
+
+	if (pc_config->clk_32k_enable != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_EN,
+					    MC13783_PWRCTRL_32OUT_EN_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_EN,
+					    MC13783_PWRCTRL_32OUT_EN_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_32OUT_EN);
+
+	if (pc_config->en_vbkup1 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+		VBKUP1_EN = true;
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+		VBKUP1_EN = false;
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1_EN);
+
+	if (pc_config->en_vbkup2 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+		VBKUP2_EN = true;
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+		VBKUP2_EN = false;
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP2_EN);
+
+	if (pc_config->auto_en_vbkup1 != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1_AUTO_EN);
+
+	if (pc_config->auto_en_vbkup2 != false)
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+	else
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP2_AUTO_EN);
+
+	if (VBKUP1_EN != false) {
+		if (pc_config->vhold_voltage > 3
+		    || pc_config->vhold_voltage < 0)
+			return PMIC_PARAMETER_ERROR;
+		else
+			pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1,
+						    pc_config->vhold_voltage);
+	}
+	if (VBKUP2_EN != false) {
+		if (pc_config->vhold_voltage > 3
+		    || pc_config->vhold_voltage < 0)
+			return PMIC_PARAMETER_ERROR;
+		else
+			pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2,
+						    pc_config->vhold_voltage2);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1) |
+	    BITFMASK(MC13783_PWRCTRL_VBKUP2);
+
+	if (pc_config->mem_allon != false) {
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_ALLON,
+					    MC13783_PWRCTRL_MEM_ALLON_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_TMR,
+					    pc_config->mem_timer);
+	} else
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_ALLON,
+					    MC13783_PWRCTRL_MEM_ALLON_DISABLE);
+
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_MEM_ALLON) |
+	    BITFMASK(MC13783_PWRCTRL_MEM_TMR);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+				   pwrctrl_val_reg0, pwrctrl_mask_reg0));
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_1,
+				   pwrctrl_val_reg1, pwrctrl_mask_reg1));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_set_pc_config);
+
+/*!
+ * This function retrives the power control configuration.
+ *
+ * @param        pc_config   pointer to power
+ * control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_power_get_pc_config(t_pc_config *pc_config)
+{
+	unsigned int pwrctrl_val_reg0 = 0;
+	unsigned int pwrctrl_val_reg1 = 0;
+
+	if (pc_config == NULL)
+		return PMIC_PARAMETER_ERROR;
+
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+				  &pwrctrl_val_reg0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_1,
+				  &pwrctrl_val_reg1, PMIC_ALL_BITS));
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_PCEN)
+	    == MC13783_PWRCTRL_PCEN_ENABLE) {
+		pc_config->pc_enable = true;
+		pc_config->pc_timer = BITFEXT(pwrctrl_val_reg1,
+					      MC13783_PWRCTRL_PCT);
+
+	} else {
+		pc_config->pc_enable = false;
+		pc_config->pc_timer = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_PC_COUNT_EN)
+	    == MC13783_PWRCTRL_PCEN_ENABLE) {
+		pc_config->pc_count_enable = true;
+		pc_config->pc_count = BITFEXT(pwrctrl_val_reg1,
+					      MC13783_PWRCTRL_PC_COUNT);
+		pc_config->pc_max_count = BITFEXT(pwrctrl_val_reg1,
+						  MC13783_PWRCTRL_PC_MAX_CNT);
+	} else {
+		pc_config->pc_count_enable = false;
+		pc_config->pc_count = 0;
+		pc_config->pc_max_count = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_WARM_EN)
+	    == MC13783_PWRCTRL_WARM_EN_ENABLE)
+		pc_config->warm_enable = true;
+	else
+		pc_config->warm_enable = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_USER_OFF_PC)
+	    == MC13783_PWRCTRL_USER_OFF_PC_ENABLE)
+		pc_config->user_off_pc = true;
+	else
+		pc_config->user_off_pc = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_32OUT_USER_OFF)
+	    == MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE)
+		pc_config->clk_32k_user_off = true;
+	else
+		pc_config->clk_32k_user_off = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_32OUT_EN)
+	    == MC13783_PWRCTRL_32OUT_EN_ENABLE)
+		pc_config->clk_32k_enable = true;
+	else
+		pc_config->clk_32k_enable = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP1_AUTO_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE)
+		pc_config->auto_en_vbkup1 = true;
+	else
+		pc_config->auto_en_vbkup1 = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP2_AUTO_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE)
+		pc_config->auto_en_vbkup2 = true;
+	else
+		pc_config->auto_en_vbkup2 = false;
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP1_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->en_vbkup1 = true;
+		pc_config->vhold_voltage = BITFEXT(pwrctrl_val_reg0,
+						   MC13783_PWRCTRL_VBKUP1);
+	} else {
+		pc_config->en_vbkup1 = false;
+		pc_config->vhold_voltage = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP2_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->en_vbkup2 = true;
+		pc_config->vhold_voltage2 = BITFEXT(pwrctrl_val_reg0,
+						    MC13783_PWRCTRL_VBKUP2);
+	} else {
+		pc_config->en_vbkup2 = false;
+		pc_config->vhold_voltage2 = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg1, MC13783_PWRCTRL_MEM_ALLON) ==
+	    MC13783_PWRCTRL_MEM_ALLON_ENABLE) {
+		pc_config->mem_allon = true;
+		pc_config->mem_timer = BITFEXT(pwrctrl_val_reg1,
+					       MC13783_PWRCTRL_MEM_TMR);
+	} else {
+		pc_config->mem_allon = false;
+		pc_config->mem_timer = 0;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_pc_config);
+
+/*!
+ * This function turns on a regulator.
+ *
+ * @param        regulator    The regulator to be truned on.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_PLL:
+		reg_val = BITFVAL(MC13783_SWCTRL_PLL_EN,
+				  MC13783_SWCTRL_PLL_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_PLL_EN);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_EN,
+				  MC13783_SWCTRL_SW3_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_EN);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_EN,
+				  MC13783_REGCTRL_VAUDIO_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_EN,
+				  MC13783_REGCTRL_VIOHI_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_EN,
+				  MC13783_REGCTRL_VIOLO_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_EN,
+				  MC13783_REGCTRL_VDIG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_EN,
+				  MC13783_REGCTRL_VGEN_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_EN,
+				  MC13783_REGCTRL_VRFDIG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_EN,
+				  MC13783_REGCTRL_VRFREF_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_EN,
+				  MC13783_REGCTRL_VRFCP_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_EN,
+				  MC13783_REGCTRL_VSIM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_EN,
+				  MC13783_REGCTRL_VESIM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_EN,
+				  MC13783_REGCTRL_VCAM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_EN,
+				  MC13783_REGCTRL_VRFBG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VVIB:
+		reg_val = BITFVAL(MC13783_REGCTRL_VVIB_EN,
+				  MC13783_REGCTRL_VVIB_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VVIB_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_EN,
+				  MC13783_REGCTRL_VRF1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_EN,
+				  MC13783_REGCTRL_VRF2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_EN,
+				  MC13783_REGCTRL_VMMC1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_EN,
+				  MC13783_REGCTRL_VMMC2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO1_EN,
+				  MC13783_REGCTRL_GPO1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO1_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO2_EN,
+				  MC13783_REGCTRL_GPO2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO2_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO3_EN,
+				  MC13783_REGCTRL_GPO3_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO3_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO4_EN,
+				  MC13783_REGCTRL_GPO4_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO4_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_on);
+
+/*!
+ * This function turns off a regulator.
+ *
+ * @param        regulator    The regulator to be truned off.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_PLL:
+		reg_val = BITFVAL(MC13783_SWCTRL_PLL_EN,
+				  MC13783_SWCTRL_PLL_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_PLL_EN);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_EN,
+				  MC13783_SWCTRL_SW3_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_EN);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_EN,
+				  MC13783_REGCTRL_VAUDIO_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_EN,
+				  MC13783_REGCTRL_VIOHI_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_EN,
+				  MC13783_REGCTRL_VIOLO_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_EN,
+				  MC13783_REGCTRL_VDIG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_EN,
+				  MC13783_REGCTRL_VGEN_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_EN,
+				  MC13783_REGCTRL_VRFDIG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_EN,
+				  MC13783_REGCTRL_VRFREF_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_EN,
+				  MC13783_REGCTRL_VRFCP_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_EN,
+				  MC13783_REGCTRL_VSIM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_EN,
+				  MC13783_REGCTRL_VESIM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_EN,
+				  MC13783_REGCTRL_VCAM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_EN,
+				  MC13783_REGCTRL_VRFBG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VVIB:
+		reg_val = BITFVAL(MC13783_REGCTRL_VVIB_EN,
+				  MC13783_REGCTRL_VVIB_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VVIB_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_EN,
+				  MC13783_REGCTRL_VRF1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_EN,
+				  MC13783_REGCTRL_VRF2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_EN,
+				  MC13783_REGCTRL_VMMC1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_EN,
+				  MC13783_REGCTRL_VMMC2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO1_EN,
+				  MC13783_REGCTRL_GPO1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO1_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO2_EN,
+				  MC13783_REGCTRL_GPO2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO2_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO3_EN,
+				  MC13783_REGCTRL_GPO3_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO3_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO4_EN,
+				  MC13783_REGCTRL_GPO4_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO4_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_off);
+
+/*!
+ * This function sets the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        voltage      The regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage voltage)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((voltage.sw1a < SW1A_0_9V) ||
+				(voltage.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1A, voltage.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((voltage.sw1b < SW1B_0_9V) ||
+				(voltage.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1B, voltage.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((voltage.sw2a < SW2A_0_9V) ||
+				(voltage.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2A, voltage.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((voltage.sw2b < SW2B_0_9V) ||
+				(voltage.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2B, voltage.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A);
+		reg = REG_SWITCHERS_3;
+		break;
+	case SW_SW3:
+		if (voltage.sw3 != SW3_5V)
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW3, voltage.sw3);
+		reg_mask = BITFMASK(MC13783_SWSET_SW3);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VIOLO:
+		if ((voltage.violo < VIOLO_1_2V) ||
+				(voltage.violo > VIOLO_1_8V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VIOLO, voltage.violo);
+		reg_mask = BITFMASK(MC13783_REGSET_VIOLO);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VDIG:
+		if ((voltage.vdig < VDIG_1_2V) ||
+				(voltage.vdig > VDIG_1_8V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VDIG, voltage.vdig);
+		reg_mask = BITFMASK(MC13783_REGSET_VDIG);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VGEN:
+		if ((voltage.vgen < VGEN_1_2V) ||
+				(voltage.vgen > VGEN_2_4V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VGEN, voltage.vgen);
+		reg_mask = BITFMASK(MC13783_REGSET_VGEN);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFDIG:
+		if ((voltage.vrfdig < VRFDIG_1_2V) ||
+				(voltage.vrfdig > VRFDIG_1_875V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRFDIG, voltage.vrfdig);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFDIG);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFREF:
+		if ((voltage.vrfref < VRFREF_2_475V) ||
+				(voltage.vrfref > VRFREF_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRFREF, voltage.vrfref);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFREF);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFCP:
+		if ((voltage.vrfcp < VRFCP_2_7V) ||
+				(voltage.vrfcp > VRFCP_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRFCP, voltage.vrfcp);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFCP);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VSIM:
+		if ((voltage.vsim < VSIM_1_8V) ||
+				(voltage.vsim > VSIM_2_9V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VSIM, voltage.vsim);
+		reg_mask = BITFMASK(MC13783_REGSET_VSIM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VESIM:
+		if ((voltage.vesim < VESIM_1_8V) ||
+				(voltage.vesim > VESIM_2_9V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VESIM, voltage.vesim);
+		reg_mask = BITFMASK(MC13783_REGSET_VESIM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VCAM:
+		if ((voltage.vcam < VCAM_1_5V) ||
+				(voltage.vcam > VCAM_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VCAM, voltage.vcam);
+		reg_mask = BITFMASK(MC13783_REGSET_VCAM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VVIB:
+		if ((voltage.vvib < VVIB_1_3V) ||
+				(voltage.vvib > VVIB_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VVIB, voltage.vvib);
+		reg_mask = BITFMASK(MC13783_REGSET_VVIB);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VRF1:
+		if ((voltage.vrf1 < VRF1_1_5V) ||
+				(voltage.vrf1 > VRF1_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRF1, voltage.vrf1);
+		reg_mask = BITFMASK(MC13783_REGSET_VRF1);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VRF2:
+		if ((voltage.vrf2 < VRF2_1_5V) ||
+				(voltage.vrf2 > VRF2_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRF2, voltage.vrf2);
+		reg_mask = BITFMASK(MC13783_REGSET_VRF2);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VMMC1:
+		if ((voltage.vmmc1 < VMMC1_1_6V) ||
+				(voltage.vmmc1 > VMMC1_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VMMC1, voltage.vmmc1);
+		reg_mask = BITFMASK(MC13783_REGSET_VMMC1);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VMMC2:
+		if ((voltage.vmmc2 < VMMC2_1_6V) ||
+				(voltage.vmmc2 > VMMC2_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VMMC2, voltage.vmmc2);
+		reg_mask = BITFMASK(MC13783_REGSET_VMMC2);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+	case REGU_GPO1:
+	case REGU_GPO2:
+	case REGU_GPO3:
+	case REGU_GPO4:
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_set_voltage);
+
+/*!
+ * This function retrives the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be truned off.
+ * @param        voltage      Pointer to regulator
+ * output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage *voltage)
+{
+	unsigned int reg_val = 0;
+
+	if (regulator == SW_SW1A)
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_0,
+					  &reg_val, PMIC_ALL_BITS));
+	else if (regulator == SW_SW1B)
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_1,
+					  &reg_val, PMIC_ALL_BITS));
+	else if (regulator == SW_SW2A)
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_2,
+					  &reg_val, PMIC_ALL_BITS));
+	else if (regulator == SW_SW2B)
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_3,
+					  &reg_val, PMIC_ALL_BITS));
+	else if (regulator == SW_SW3)
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_5,
+					  &reg_val, PMIC_ALL_BITS));
+	else if ((regulator == REGU_VIOLO) ||
+			(regulator == REGU_VDIG) ||
+			(regulator == REGU_VGEN) ||
+			(regulator == REGU_VRFDIG) ||
+			(regulator == REGU_VRFREF) ||
+			(regulator == REGU_VRFCP) ||
+			(regulator == REGU_VSIM) ||
+			(regulator == REGU_VESIM) ||
+			(regulator == REGU_VCAM))
+		CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+					  &reg_val, PMIC_ALL_BITS));
+	else if ((regulator == REGU_VVIB) ||
+			(regulator == REGU_VRF1) ||
+			(regulator == REGU_VRF2) ||
+			(regulator == REGU_VMMC1) ||
+			(regulator == REGU_VMMC2))
+		CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_1,
+					  &reg_val, PMIC_ALL_BITS));
+
+	switch (regulator) {
+	case SW_SW1A:
+		voltage->sw1a = BITFEXT(reg_val, MC13783_SWSET_SW1A);
+		break;
+	case SW_SW1B:
+		voltage->sw1b = BITFEXT(reg_val, MC13783_SWSET_SW1B);
+		break;
+	case SW_SW2A:
+		voltage->sw2a = BITFEXT(reg_val, MC13783_SWSET_SW2A);
+		break;
+	case SW_SW2B:
+		voltage->sw2b = BITFEXT(reg_val, MC13783_SWSET_SW2B);
+		break;
+	case SW_SW3:
+		voltage->sw3 = BITFEXT(reg_val, MC13783_SWSET_SW3);
+		break;
+	case REGU_VIOLO:
+		voltage->violo = BITFEXT(reg_val, MC13783_REGSET_VIOLO);
+		break;
+	case REGU_VDIG:
+		voltage->vdig = BITFEXT(reg_val, MC13783_REGSET_VDIG);
+		break;
+	case REGU_VGEN:
+		voltage->vgen = BITFEXT(reg_val, MC13783_REGSET_VGEN);
+		break;
+	case REGU_VRFDIG:
+		voltage->vrfdig = BITFEXT(reg_val, MC13783_REGSET_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		voltage->vrfref = BITFEXT(reg_val, MC13783_REGSET_VRFREF);
+		break;
+	case REGU_VRFCP:
+		voltage->vrfcp = BITFEXT(reg_val, MC13783_REGSET_VRFCP);
+		break;
+	case REGU_VSIM:
+		voltage->vsim = BITFEXT(reg_val, MC13783_REGSET_VSIM);
+		break;
+	case REGU_VESIM:
+		voltage->vesim = BITFEXT(reg_val, MC13783_REGSET_VESIM);
+		break;
+	case REGU_VCAM:
+		voltage->vcam = BITFEXT(reg_val, MC13783_REGSET_VCAM);
+		break;
+	case REGU_VVIB:
+		voltage->vvib = BITFEXT(reg_val, MC13783_REGSET_VVIB);
+		break;
+	case REGU_VRF1:
+		voltage->vrf1 = BITFEXT(reg_val, MC13783_REGSET_VRF1);
+		break;
+	case REGU_VRF2:
+		voltage->vrf2 = BITFEXT(reg_val, MC13783_REGSET_VRF2);
+		break;
+	case REGU_VMMC1:
+		voltage->vmmc1 = BITFEXT(reg_val, MC13783_REGSET_VMMC1);
+		break;
+	case REGU_VMMC2:
+		voltage->vmmc2 = BITFEXT(reg_val, MC13783_REGSET_VMMC2);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_get_voltage);
+
+/*!
+ * This function sets the DVS voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage dvs)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((dvs.sw1a < SW1A_0_9V) ||
+				(dvs.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW1A_DVS, dvs.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_DVS);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((dvs.sw1b < SW1B_0_9V) ||
+				(dvs.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW1B_DVS, dvs.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_DVS);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((dvs.sw2a < SW2A_0_9V) ||
+				(dvs.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW2A_DVS, dvs.sw2a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_DVS);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((dvs.sw2b < SW2B_0_9V) ||
+				(dvs.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW2B_DVS, dvs.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_DVS);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the DVS voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage *dvs)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_DVS);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_DVS);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_DVS);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_DVS);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW1A_DVS);
+		break;
+	case SW_SW1B:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW1B_DVS);
+		break;
+	case SW_SW2A:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW2A_DVS);
+		break;
+	case SW_SW2B:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW2B_DVS);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the standiby voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((stby.sw1a < SW1A_0_9V) ||
+				(stby.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW1A_STDBY, stby.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_STDBY);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((stby.sw1b < SW1B_0_9V) ||
+				(stby.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW1B_STDBY, stby.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_STDBY);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((stby.sw2a < SW2A_0_9V) ||
+				(stby.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW2A_STDBY, stby.sw2a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_STDBY);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((stby.sw2b < SW2B_0_9V) ||
+				(stby.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+		reg_val = BITFVAL(MC13783_SWSET_SW2B_STDBY, stby.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_STDBY);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the standiby voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage *stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_STDBY);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_STDBY);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_STDBY);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_STDBY);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW1A_STDBY);
+		break;
+	case SW_SW1B:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW1B_STDBY);
+		break;
+	case SW_SW2A:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW2A_STDBY);
+		break;
+	case SW_SW2B:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+				MC13783_SWSET_SW2B_STDBY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switchers mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode	      The switcher mode
+ * @param        stby	      Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode mode, bool stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode;
+
+	if (mode == SYNC_RECT)
+		l_mode = MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN;
+	else if (mode == NO_PULSE_SKIP)
+		l_mode = MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN;
+	else if (mode == PULSE_SKIP)
+		l_mode = MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN;
+	else if (mode == LOW_POWER)
+		l_mode = MC13783_SWCTRL_SW_MODE_LOW_POWER_EN;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW1A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW1A_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_MODE);
+		}
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW1B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW1B_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_MODE);
+		}
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW2A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW2A_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_MODE);
+		}
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW2B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW2B_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_MODE);
+		}
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switchers mode.
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        mode         The switcher mode.
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode *mode, bool stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg = 0;
+	unsigned int l_mode = 0;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby)
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW1A_STBY_MODE);
+		else
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_MODE);
+		break;
+	case SW_SW1B:
+		if (stby)
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW1B_STBY_MODE);
+		else
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_MODE);
+		break;
+	case SW_SW2A:
+		if (stby)
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW2A_STBY_MODE);
+		else
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_MODE);
+		break;
+	case SW_SW2B:
+		if (stby)
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW2B_STBY_MODE);
+		else
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_MODE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (l_mode == MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN)
+		*mode = SYNC_RECT;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN)
+		*mode = NO_PULSE_SKIP;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN)
+		*mode = PULSE_SKIP;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_LOW_POWER_EN)
+		*mode = LOW_POWER;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        speed	      The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed speed)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	if (speed > 3 || speed < 0)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed *speed)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_DVS_SPEED);
+		break;
+	case SW_SW1B:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_DVS_SPEED);
+		break;
+	case SW_SW2A:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_DVS_SPEED);
+		break;
+	case SW_SW2B:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_DVS_SPEED);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch panic mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_panic_mode(t_pmic_regulator regulator,
+					       bool panic_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch panic mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_panic_mode(t_pmic_regulator regulator,
+					       bool *panic_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_PANIC_MODE);
+		break;
+	case SW_SW1B:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_PANIC_MODE);
+		break;
+	case SW_SW2A:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_PANIC_MODE);
+		break;
+	case SW_SW2B:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_PANIC_MODE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_softstart(t_pmic_regulator regulator,
+					      bool softstart)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_softstart(t_pmic_regulator regulator,
+					      bool *softstart)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_SOFTSTART);
+		break;
+	case SW_SW1B:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_SOFTSTART);
+		break;
+	case SW_SW2A:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_SOFTSTART);
+		break;
+	case SW_SW2B:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_SOFTSTART);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_factor(t_pmic_regulator regulator,
+					   t_switcher_factor factor)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	if (regulator != SW_PLL)
+		return PMIC_PARAMETER_ERROR;
+
+	if (factor < FACTOR_28 || factor > FACTOR_35)
+		return PMIC_PARAMETER_ERROR;
+
+	reg_val = BITFVAL(MC13783_SWCTRL_PLL_FACTOR, factor);
+	reg_mask = BITFMASK(MC13783_SWCTRL_PLL_FACTOR);
+
+	CHECK_ERROR(pmic_write_reg(REG_SWITCHERS_4, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_factor(t_pmic_regulator regulator,
+					   t_switcher_factor *factor)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	if (regulator != SW_PLL)
+		return PMIC_PARAMETER_ERROR;
+
+	reg_mask = BITFMASK(MC13783_SWCTRL_PLL_FACTOR);
+
+	CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_4, &reg_val, reg_mask));
+
+	*factor = BITFEXT(reg_val, MC13783_SWCTRL_PLL_FACTOR);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables or disables low power mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        lp_mode      Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode lp_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode, l_stby;
+
+	if (lp_mode == LOW_POWER_DISABLED) {
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_DISABLE;
+	} else if (lp_mode == LOW_POWER_CTRL_BY_PIN) {
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_ENABLE;
+	} else if (lp_mode == LOW_POWER_EN) {
+		l_mode = MC13783_REGTRL_LP_MODE_ENABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_DISABLE;
+	} else if (lp_mode == LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN) {
+		l_mode = MC13783_REGTRL_LP_MODE_ENABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_ENABLE;
+	} else
+		return PMIC_PARAMETER_ERROR;
+
+	switch (regulator) {
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_MODE, l_mode) |
+			BITFVAL(MC13783_SWCTRL_SW3_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_MODE) |
+			BITFMASK(MC13783_SWCTRL_SW3_STBY);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VAUDIO_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_MODE) |
+			BITFMASK(MC13783_REGCTRL_VAUDIO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VIOHI_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_MODE) |
+			BITFMASK(MC13783_REGCTRL_VIOHI_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VIOLO_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_MODE) |
+			BITFMASK(MC13783_REGCTRL_VIOLO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VDIG_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_MODE) |
+			BITFMASK(MC13783_REGCTRL_VDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VGEN_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_MODE) |
+			BITFMASK(MC13783_REGCTRL_VGEN_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VRFDIG_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_MODE) |
+			BITFMASK(MC13783_REGCTRL_VRFDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VRFREF_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_MODE) |
+			BITFMASK(MC13783_REGCTRL_VRFREF_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VRFCP_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_MODE) |
+			BITFMASK(MC13783_REGCTRL_VRFCP_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VSIM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_MODE) |
+			BITFMASK(MC13783_REGCTRL_VSIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VESIM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_MODE) |
+			BITFMASK(MC13783_REGCTRL_VESIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VCAM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_MODE) |
+			BITFMASK(MC13783_REGCTRL_VCAM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		if ((lp_mode == LOW_POWER) ||
+				(lp_mode == LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_STBY, l_mode);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VRF1_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_MODE) |
+			BITFMASK(MC13783_REGCTRL_VRF1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VRF2_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_MODE) |
+			BITFMASK(MC13783_REGCTRL_VRF2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VMMC1_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_MODE) |
+			BITFMASK(MC13783_REGCTRL_VMMC1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_MODE, l_mode) |
+			BITFVAL(MC13783_REGCTRL_VMMC2_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_MODE) |
+			BITFMASK(MC13783_REGCTRL_VMMC2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_set_lp_mode);
+
+/*!
+ * This function gets low power mode.
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        lp_mode      Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode *lp_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode, l_stby;
+
+	switch (regulator) {
+	case SW_SW3:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_MODE) |
+		    BITFMASK(MC13783_SWCTRL_SW3_STBY);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VAUDIO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOHI_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOLO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VGEN_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFREF_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFCP_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VSIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VESIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VCAM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW3:
+		l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW3_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_SWCTRL_SW3_STBY);
+		break;
+	case REGU_VAUDIO:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VAUDIO_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VAUDIO_STBY);
+		break;
+	case REGU_VIOHI:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VIOHI_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VIOHI_STBY);
+		break;
+	case REGU_VIOLO:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VIOLO_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VIOLO_STBY);
+		break;
+	case REGU_VDIG:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VDIG_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VDIG_STBY);
+		break;
+	case REGU_VGEN:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VGEN_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VGEN_STBY);
+		break;
+	case REGU_VRFDIG:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFDIG_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFDIG_STBY);
+		break;
+	case REGU_VRFREF:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFREF_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFREF_STBY);
+		break;
+	case REGU_VRFCP:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFCP_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFCP_STBY);
+		break;
+	case REGU_VSIM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VSIM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VSIM_STBY);
+		break;
+	case REGU_VESIM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VESIM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VESIM_STBY);
+		break;
+	case REGU_VCAM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VCAM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VCAM_STBY);
+		break;
+	case REGU_VRFBG:
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFBG_STBY);
+		break;
+	case REGU_VRF1:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRF1_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRF1_STBY);
+		break;
+	case REGU_VRF2:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRF2_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRF2_STBY);
+		break;
+	case REGU_VMMC1:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VMMC1_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VMMC1_STBY);
+		break;
+	case REGU_VMMC2:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VMMC2_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VMMC2_STBY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if ((l_mode == MC13783_REGTRL_LP_MODE_DISABLE) &&
+	    (l_stby == MC13783_REGTRL_STBY_MODE_DISABLE))
+		*lp_mode = LOW_POWER_DISABLED;
+	else if ((l_mode == MC13783_REGTRL_LP_MODE_DISABLE) &&
+		   (l_stby == MC13783_REGTRL_STBY_MODE_ENABLE))
+		*lp_mode = LOW_POWER_CTRL_BY_PIN;
+	else if ((l_mode == MC13783_REGTRL_LP_MODE_ENABLE) &&
+		   (l_stby == MC13783_REGTRL_STBY_MODE_DISABLE))
+		*lp_mode = LOW_POWER_EN;
+	else
+		*lp_mode = LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN;
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the regulator configuration.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        config       The regulator output configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_config(t_pmic_regulator regulator,
+					    t_regulator_config *config)
+{
+	if (config == NULL)
+		return PMIC_ERROR;
+
+	switch (regulator) {
+	case SW_SW1A:
+	case SW_SW1B:
+	case SW_SW2A:
+	case SW_SW2B:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		CHECK_ERROR(pmic_power_switcher_set_dvs
+			    (regulator, config->voltage_lvs));
+		CHECK_ERROR(pmic_power_switcher_set_stby
+			    (regulator, config->voltage_stby));
+		CHECK_ERROR(pmic_power_switcher_set_mode
+			    (regulator, config->mode, false));
+		CHECK_ERROR(pmic_power_switcher_set_mode
+			    (regulator, config->stby_mode, true));
+		CHECK_ERROR(pmic_power_switcher_set_dvs_speed
+			    (regulator, config->dvs_speed));
+		CHECK_ERROR(pmic_power_switcher_set_panic_mode
+			    (regulator, config->panic_mode));
+		CHECK_ERROR(pmic_power_switcher_set_softstart
+			    (regulator, config->softstart));
+		break;
+	case SW_PLL:
+		CHECK_ERROR(pmic_power_switcher_set_factor
+			    (regulator, config->factor));
+		break;
+	case SW_SW3:
+	case REGU_VIOLO:
+	case REGU_VDIG:
+	case REGU_VGEN:
+	case REGU_VRFDIG:
+	case REGU_VRFREF:
+	case REGU_VRFCP:
+	case REGU_VSIM:
+	case REGU_VESIM:
+	case REGU_VCAM:
+	case REGU_VRF1:
+	case REGU_VRF2:
+	case REGU_VMMC1:
+	case REGU_VMMC2:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		CHECK_ERROR(pmic_power_regulator_set_lp_mode
+			    (regulator, config->lp_mode));
+		break;
+	case REGU_VVIB:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+		CHECK_ERROR(pmic_power_regulator_set_lp_mode
+			    (regulator, config->lp_mode));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_set_config);
+
+/*!
+ * This function retrives the regulator output configuration.
+ *
+ * @param        regulator    The regulator to be truned off.
+ * @param        config       Pointer to regulator configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_config(t_pmic_regulator regulator,
+					    t_regulator_config *config)
+{
+	if (config == NULL)
+		return PMIC_ERROR;
+
+	switch (regulator) {
+	case SW_SW1A:
+	case SW_SW1B:
+	case SW_SW2A:
+	case SW_SW2B:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		CHECK_ERROR(pmic_power_switcher_get_dvs
+			    (regulator, &config->voltage_lvs));
+		CHECK_ERROR(pmic_power_switcher_get_stby
+			    (regulator, &config->voltage_stby));
+		CHECK_ERROR(pmic_power_switcher_get_mode
+			    (regulator, &config->mode, false));
+		CHECK_ERROR(pmic_power_switcher_get_mode
+			    (regulator, &config->stby_mode, true));
+		CHECK_ERROR(pmic_power_switcher_get_dvs_speed
+			    (regulator, &config->dvs_speed));
+		CHECK_ERROR(pmic_power_switcher_get_panic_mode
+			    (regulator, &config->panic_mode));
+		CHECK_ERROR(pmic_power_switcher_get_softstart
+			    (regulator, &config->softstart));
+		break;
+	case SW_PLL:
+		CHECK_ERROR(pmic_power_switcher_get_factor
+			    (regulator, &config->factor));
+		break;
+	case SW_SW3:
+	case REGU_VIOLO:
+	case REGU_VDIG:
+	case REGU_VGEN:
+	case REGU_VRFDIG:
+	case REGU_VRFREF:
+	case REGU_VRFCP:
+	case REGU_VSIM:
+	case REGU_VESIM:
+	case REGU_VCAM:
+	case REGU_VRF1:
+	case REGU_VRF2:
+	case REGU_VMMC1:
+	case REGU_VMMC2:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		CHECK_ERROR(pmic_power_regulator_get_lp_mode
+			    (regulator, &config->lp_mode));
+		break;
+	case REGU_VVIB:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+		CHECK_ERROR(pmic_power_regulator_get_lp_mode
+			    (regulator, &config->lp_mode));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_regulator_get_config);
+
+/*!
+ * This function enables automatically VBKUP2 in the memory hold modes.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable VBKUP2AUTOMH
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vbkup2_auto_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_VBKUP2AUTOMH, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VBKUP2AUTOMH);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_vbkup2_auto_en);
+
+/*!
+ * This function gets state of automatically VBKUP2.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, VBKUP2AUTOMH is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_vbkup2_auto_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_VBKUP2AUTOMH);
+		CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_VBKUP2AUTOMH);
+
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_get_vbkup2_auto_state);
+
+/*!
+ * This function enables battery detect function.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable BATTDETEN
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_bat_det_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_BATTDETEN, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_BATTDETEN);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_bat_det_en);
+
+/*!
+ * This function gets state of battery detect function.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, BATTDETEN is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_bat_det_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_BATTDETEN);
+
+		CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_BATTDETEN);
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_get_bat_det_state);
+
+/*!
+ * This function enables control of VVIB by VIBEN pin.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable VIBPINCTRL
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vib_pin_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_VIBPINCTRL, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIBPINCTRL);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_MISCELLANEOUS,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_vib_pin_en);
+
+/*!
+ * This function gets state of control of VVIB by VIBEN pin.
+ * Only on mc13783 2.0 or higher
+ * @param        en           if true, VIBPINCTRL is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_gets_vib_pin_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIBPINCTRL);
+		CHECK_ERROR(pmic_read_reg(REG_POWER_MISCELLANEOUS,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_VIBPINCTRL);
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_gets_vib_pin_state);
+
+/*!
+ * This function returns power up sense value
+ *
+ * @param        p_up_sense     value of power up sense
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_power_mode_sense(struct t_p_up_sense *p_up_sense)
+{
+	unsigned int reg_value = 0;
+	CHECK_ERROR(pmic_read_reg(REG_POWER_UP_MODE_SENSE,
+				  &reg_value, PMIC_ALL_BITS));
+	p_up_sense->state_ictest = (STATE_ICTEST_MASK & reg_value);
+	p_up_sense->state_clksel = ((STATE_CLKSEL_MASK & reg_value)
+				    >> STATE_CLKSEL_BIT);
+	p_up_sense->state_pums1 = ((STATE_PUMS1_MASK & reg_value)
+				   >> STATE_PUMS1_BITS);
+	p_up_sense->state_pums2 = ((STATE_PUMS2_MASK & reg_value)
+				   >> STATE_PUMS2_BITS);
+	p_up_sense->state_pums3 = ((STATE_PUMS3_MASK & reg_value)
+				   >> STATE_PUMS3_BITS);
+	p_up_sense->state_chrgmode0 = ((STATE_CHRGM1_MASK & reg_value)
+				       >> STATE_CHRGM1_BITS);
+	p_up_sense->state_chrgmode1 = ((STATE_CHRGM2_MASK & reg_value)
+				       >> STATE_CHRGM2_BITS);
+	p_up_sense->state_umod = ((STATE_UMOD_MASK & reg_value)
+				  >> STATE_UMOD_BITS);
+	p_up_sense->state_usben = ((STATE_USBEN_MASK & reg_value)
+				   >> STATE_USBEN_BIT);
+	p_up_sense->state_sw_1a1b_joined = ((STATE_SW1A_J_B_MASK & reg_value)
+					    >> STATE_SW1A_J_B_BIT);
+	p_up_sense->state_sw_2a2b_joined = ((STATE_SW2A_J_B_MASK & reg_value)
+					    >> STATE_SW2A_J_B_BIT);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_power_mode_sense);
+
+/*!
+ * This function configures the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         if true, the regulator is enabled by regen.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_assig(t_pmic_regulator regulator, bool en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGGEN_VAUDIO, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGGEN_VIOHI, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGGEN_VIOLO, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGGEN_VDIG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGGEN_VGEN, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFDIG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFREF, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFCP, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGGEN_VCAM, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFBG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGGEN_VRF1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGGEN_VRF2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGGEN_VMMC1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGGEN_VMMC2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO3, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO4, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO4);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_set_regen_assig);
+
+/*!
+ * This function gets the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         return value, if true :
+ *                              the regulator is enabled by regen.
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_assig(t_pmic_regulator regulator,
+				       bool *en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		reg_mask = BITFMASK(MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		reg_mask = BITFMASK(MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		reg_mask = BITFMASK(MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO4);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO4);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_regen_assig);
+
+/*!
+ * This function sets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_inv(bool en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_val = BITFVAL(MC13783_REGGEN_INV, en_dis);
+	reg_mask = BITFMASK(MC13783_REGGEN_INV);
+
+	CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT, reg_val, reg_mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_set_regen_inv);
+
+/*!
+ * This function gets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_inv(bool *en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_mask = BITFMASK(MC13783_REGGEN_INV);
+	CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT, &reg_val, reg_mask));
+	*en_dis = BITFEXT(reg_val, MC13783_REGGEN_INV);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_regen_inv);
+
+/*!
+ * This function enables esim control voltage.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_esim_v_en(bool vesim, bool vmmc1, bool vmmc2)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGGEN_VESIMESIM, vesim) |
+		    BITFVAL(MC13783_REGGEN_VMMC1ESIM, vesim) |
+		    BITFVAL(MC13783_REGGEN_VMMC2ESIM, vesim);
+		reg_mask = BITFMASK(MC13783_REGGEN_VESIMESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC1ESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC2ESIM);
+		CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_esim_v_en);
+
+/*!
+ * This function gets esim control voltage values.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_gets_esim_v_state(bool *vesim, bool *vmmc1,
+					 bool *vmmc2)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGGEN_VESIMESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC1ESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC2ESIM);
+		CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT,
+					  &reg_val, reg_mask));
+		*vesim = BITFEXT(reg_val, MC13783_REGGEN_VESIMESIM);
+		*vmmc1 = BITFEXT(reg_val, MC13783_REGGEN_VMMC1ESIM);
+		*vmmc2 = BITFEXT(reg_val, MC13783_REGGEN_VMMC2ESIM);
+		return PMIC_SUCCESS;
+	} else
+		return PMIC_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL(pmic_power_gets_esim_v_state);
+
+/*!
+ * This function enables auto reset after a system reset.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_auto_reset_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_val = BITFVAL(MC13783_AUTO_RESTART, en);
+	reg_mask = BITFMASK(MC13783_AUTO_RESTART);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_2, reg_val, reg_mask));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_set_auto_reset_en);
+
+/*!
+ * This function gets auto reset configuration.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_auto_reset_en(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_mask = BITFMASK(MC13783_AUTO_RESTART);
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_2, &reg_val, reg_mask));
+	*en = BITFEXT(reg_val, MC13783_AUTO_RESTART);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_auto_reset_en);
+
+/*!
+ * This function configures a system reset on a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, enable the system reset on this button
+ * @param       deb_time   sets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_conf_button(t_button bt, bool sys_rst, int deb_time)
+{
+	int max_val = 0;
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	max_val = (1 << MC13783_DEB_BT_ON1B_WID) - 1;
+	if (deb_time > max_val)
+		return PMIC_PARAMETER_ERROR;
+
+	switch (bt) {
+	case BT_ON1B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON1B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON1B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON1B) |
+		    BITFMASK(MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON2B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON2B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON2B) |
+		    BITFMASK(MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON3B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON3B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON3B) |
+		    BITFMASK(MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_2, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_set_conf_button);
+
+/*!
+ * This function gets configuration of a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, the system reset is enabled on this button
+ * @param       deb_time   gets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_conf_button(t_button bt,
+				       bool *sys_rst, int *deb_time)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (bt) {
+	case BT_ON1B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON1B) |
+		    BITFMASK(MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON2B) |
+		    BITFMASK(MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON3B) |
+		    BITFMASK(MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_2, &reg_val, reg_mask));
+
+	switch (bt) {
+	case BT_ON1B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON1B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON2B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON3B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_power_get_conf_button);
+
+/*!
+ * This function is used to un/subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ * @param        sub            define if Un/subscribe event.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event(t_pwr_int event, void *callback, bool sub)
+{
+	pmic_event_callback_t power_callback;
+	type_event power_event;
+
+	power_callback.func = callback;
+	power_callback.param = NULL;
+	switch (event) {
+	case PWR_IT_BPONI:
+		power_event = EVENT_BPONI;
+		break;
+	case PWR_IT_LOBATLI:
+		power_event = EVENT_LOBATLI;
+		break;
+	case PWR_IT_LOBATHI:
+		power_event = EVENT_LOBATHI;
+		break;
+	case PWR_IT_ONOFD1I:
+		power_event = EVENT_ONOFD1I;
+		break;
+	case PWR_IT_ONOFD2I:
+		power_event = EVENT_ONOFD2I;
+		break;
+	case PWR_IT_ONOFD3I:
+		power_event = EVENT_ONOFD3I;
+		break;
+	case PWR_IT_SYSRSTI:
+		power_event = EVENT_SYSRSTI;
+		break;
+	case PWR_IT_PWRRDYI:
+		power_event = EVENT_PWRRDYI;
+		break;
+	case PWR_IT_PCI:
+		power_event = EVENT_PCI;
+		break;
+	case PWR_IT_WARMI:
+		power_event = EVENT_WARMI;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	if (sub == true)
+		CHECK_ERROR(pmic_event_subscribe(power_event, power_callback));
+	else
+		CHECK_ERROR(pmic_event_unsubscribe
+			    (power_event, power_callback));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_sub(t_pwr_int event, void *callback)
+{
+	return pmic_power_event(event, callback, true);
+}
+EXPORT_SYMBOL(pmic_power_event_sub);
+
+/*!
+ * This function is used to un subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_unsub(t_pwr_int event, void *callback)
+{
+	return pmic_power_event(event, callback, false);
+}
+EXPORT_SYMBOL(pmic_power_event_unsub);
+
+/*
+ * Init and Exit
+ */
+
+static int pmic_power_probe(struct platform_device *pdev)
+{
+	printk(KERN_INFO "PMIC Power successfully probed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_power_driver_ldm = {
+	.driver = {
+		   .name = "pmic_power",
+		   },
+	.suspend = pmic_power_suspend,
+	.resume = pmic_power_resume,
+	.probe = pmic_power_probe,
+	.remove = NULL,
+};
+
+static int __init pmic_power_init(void)
+{
+	pr_debug("PMIC Power driver loading..\n");
+	return platform_driver_register(&pmic_power_driver_ldm);
+}
+static void __exit pmic_power_exit(void)
+{
+	platform_driver_unregister(&pmic_power_driver_ldm);
+	pr_debug("PMIC Power driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_power_init);
+module_exit(pmic_power_exit);
+
+MODULE_DESCRIPTION("pmic_power driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_power_defs.h b/drivers/mxc/pmic/mc13783/pmic_power_defs.h
new file mode 100644
index 0000000..c1813a0
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_power_defs.h
@@ -0,0 +1,509 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_power_defs.h
+ * @brief This is the internal header define of PMIC(mc13783) Power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+/*
+ * Includes
+ */
+
+#ifndef __MC13783_POWER_DEFS_H__
+#define __MC13783_POWER_DEFS_H__
+
+/*
+ * Power Up Mode Sense bits
+ */
+
+#define         STATE_ICTEST_MASK       0x000001
+
+#define         STATE_CLKSEL_BIT        1
+#define         STATE_CLKSEL_MASK       0x000002
+
+#define         STATE_PUMS1_BITS        2
+#define         STATE_PUMS1_MASK        0x00000C
+
+#define         STATE_PUMS2_BITS        4
+#define         STATE_PUMS2_MASK        0x000030
+
+#define         STATE_PUMS3_BITS        6
+#define         STATE_PUMS3_MASK        0x0000C0
+
+#define         STATE_CHRGM1_BITS       8
+#define         STATE_CHRGM1_MASK       0x000300
+
+#define         STATE_CHRGM2_BITS       10
+#define         STATE_CHRGM2_MASK       0x000C00
+
+#define         STATE_UMOD_BITS         12
+#define         STATE_UMOD_MASK         0x003000
+
+#define         STATE_USBEN_BIT         14
+#define         STATE_USBEN_MASK        0x004000
+
+#define         STATE_SW1A_J_B_BIT      15
+#define         STATE_SW1A_J_B_MASK     0x008000
+
+#define         STATE_SW2A_J_B_BIT      16
+#define         STATE_SW2A_J_B_MASK     0x010000
+
+#define         PC_COUNT_MAX            3
+#define         PC_COUNT_MIN            0
+/*
+ * Reg Regen
+ */
+#define MC13783_REGGEN_VAUDIO_LSH			0
+#define MC13783_REGGEN_VAUDIO_WID			1
+#define MC13783_REGGEN_VIOHI_LSH			1
+#define MC13783_REGGEN_VIOHI_WID			1
+#define MC13783_REGGEN_VIOLO_LSH			2
+#define MC13783_REGGEN_VIOLO_WID			1
+#define MC13783_REGGEN_VDIG_LSH			3
+#define MC13783_REGGEN_VDIG_WID			1
+#define MC13783_REGGEN_VGEN_LSH			4
+#define MC13783_REGGEN_VGEN_WID			1
+#define MC13783_REGGEN_VRFDIG_LSH			5
+#define MC13783_REGGEN_VRFDIG_WID			1
+#define MC13783_REGGEN_VRFREF_LSH			6
+#define MC13783_REGGEN_VRFREF_WID			1
+#define MC13783_REGGEN_VRFCP_LSH			7
+#define MC13783_REGGEN_VRFCP_WID			1
+#define MC13783_REGGEN_VCAM_LSH			8
+#define MC13783_REGGEN_VCAM_WID			1
+#define MC13783_REGGEN_VRFBG_LSH			9
+#define MC13783_REGGEN_VRFBG_WID			1
+#define MC13783_REGGEN_VRF1_LSH			10
+#define MC13783_REGGEN_VRF1_WID			1
+#define MC13783_REGGEN_VRF2_LSH			11
+#define MC13783_REGGEN_VRF2_WID			1
+#define MC13783_REGGEN_VMMC1_LSH			12
+#define MC13783_REGGEN_VMMC1_WID			1
+#define MC13783_REGGEN_VMMC2_LSH			13
+#define MC13783_REGGEN_VMMC2_WID			1
+#define MC13783_REGGEN_GPO1_LSH			16
+#define MC13783_REGGEN_GPO1_WID			1
+#define MC13783_REGGEN_GPO2_LSH			17
+#define MC13783_REGGEN_GPO2_WID			1
+#define MC13783_REGGEN_GPO3_LSH			18
+#define MC13783_REGGEN_GPO3_WID			1
+#define MC13783_REGGEN_GPO4_LSH			19
+#define MC13783_REGGEN_GPO4_WID			1
+#define MC13783_REGGEN_INV_LSH			20
+#define MC13783_REGGEN_INV_WID			1
+#define MC13783_REGGEN_VESIMESIM_LSH		21
+#define MC13783_REGGEN_VESIMESIM_WID		1
+#define MC13783_REGGEN_VMMC1ESIM_LSH		22
+#define MC13783_REGGEN_VMMC1ESIM_WID		1
+#define MC13783_REGGEN_VMMC2ESIM_LSH		23
+#define MC13783_REGGEN_VMMC2ESIM_WID		1
+
+/*
+ * Reg Power Control 0
+ */
+#define MC13783_PWRCTRL_PCEN_LSH			0
+#define MC13783_PWRCTRL_PCEN_WID			1
+#define MC13783_PWRCTRL_PCEN_ENABLE		1
+#define MC13783_PWRCTRL_PCEN_DISABLE		0
+#define MC13783_PWRCTRL_PC_COUNT_EN_LSH		1
+#define MC13783_PWRCTRL_PC_COUNT_EN_WID		1
+#define MC13783_PWRCTRL_PC_COUNT_EN_ENABLE	1
+#define MC13783_PWRCTRL_PC_COUNT_EN_DISABLE	0
+#define MC13783_PWRCTRL_WARM_EN_LSH		2
+#define MC13783_PWRCTRL_WARM_EN_WID		1
+#define MC13783_PWRCTRL_WARM_EN_ENABLE		1
+#define MC13783_PWRCTRL_WARM_EN_DISABLE		0
+#define MC13783_PWRCTRL_USER_OFF_SPI_LSH		3
+#define MC13783_PWRCTRL_USER_OFF_SPI_WID		1
+#define MC13783_PWRCTRL_USER_OFF_SPI_ENABLE	1
+#define MC13783_PWRCTRL_USER_OFF_PC_LSH		4
+#define MC13783_PWRCTRL_USER_OFF_PC_WID		1
+#define MC13783_PWRCTRL_USER_OFF_PC_ENABLE	1
+#define MC13783_PWRCTRL_USER_OFF_PC_DISABLE	0
+#define MC13783_PWRCTRL_32OUT_USER_OFF_LSH	5
+#define MC13783_PWRCTRL_32OUT_USER_OFF_WID	1
+#define MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE	1
+#define MC13783_PWRCTRL_32OUT_USER_OFF_DISABLE	0
+#define MC13783_PWRCTRL_32OUT_EN_LSH		6
+#define MC13783_PWRCTRL_32OUT_EN_WID		1
+#define MC13783_PWRCTRL_32OUT_EN_ENABLE		1
+#define MC13783_PWRCTRL_32OUT_EN_DISABLE		0
+#define MC13783_REGCTRL_VBKUP2AUTOMH_LSH		7
+#define MC13783_REGCTRL_VBKUP2AUTOMH_WID		1
+#define MC13783_PWRCTRL_VBKUP1_EN_LSH		8
+#define MC13783_PWRCTRL_VBKUP1_EN_WID		1
+#define MC13783_PWRCTRL_VBKUP_ENABLE		1
+#define MC13783_PWRCTRL_VBKUP_DISABLE		0
+#define MC13783_PWRCTRL_VBKUP1_AUTO_EN_LSH	9
+#define MC13783_PWRCTRL_VBKUP1_AUTO_EN_WID	1
+#define MC13783_PWRCTRL_VBKUP1_LSH		10
+#define MC13783_PWRCTRL_VBKUP1_WID		2
+#define MC13783_PWRCTRL_VBKUP2_EN_LSH		12
+#define MC13783_PWRCTRL_VBKUP2_EN_WID		1
+#define MC13783_PWRCTRL_VBKUP2_AUTO_EN_LSH	13
+#define MC13783_PWRCTRL_VBKUP2_AUTO_EN_WID	1
+#define MC13783_PWRCTRL_VBKUP2_LSH		14
+#define MC13783_PWRCTRL_VBKUP2_WID		2
+#define MC13783_REGCTRL_BATTDETEN_LSH		19
+#define MC13783_REGCTRL_BATTDETEN_WID		1
+
+/*
+ * Reg Power Control 1
+ */
+#define MC13783_PWRCTRL_PCT_LSH		0
+#define MC13783_PWRCTRL_PCT_WID		8
+#define MC13783_PWRCTRL_PC_COUNT_LSH	8
+#define MC13783_PWRCTRL_PC_COUNT_WID	4
+#define MC13783_PWRCTRL_PC_MAX_CNT_LSH	12
+#define MC13783_PWRCTRL_PC_MAX_CNT_WID	4
+#define MC13783_PWRCTRL_MEM_TMR_LSH	16
+#define MC13783_PWRCTRL_MEM_TMR_WID	4
+#define MC13783_PWRCTRL_MEM_ALLON_LSH	20
+#define MC13783_PWRCTRL_MEM_ALLON_WID	1
+#define MC13783_PWRCTRL_MEM_ALLON_ENABLE	1
+#define MC13783_PWRCTRL_MEM_ALLON_DISABLE	0
+
+/*
+ * Reg Power Control 2
+ */
+#define MC13783_AUTO_RESTART_LSH	0
+#define MC13783_AUTO_RESTART_WID	1
+#define MC13783_EN_BT_ON1B_LSH		1
+#define MC13783_EN_BT_ON1B_WID		1
+#define MC13783_EN_BT_ON2B_LSH		2
+#define MC13783_EN_BT_ON2B_WID		1
+#define MC13783_EN_BT_ON3B_LSH		3
+#define MC13783_EN_BT_ON3B_WID		1
+#define MC13783_DEB_BT_ON1B_LSH		4
+#define MC13783_DEB_BT_ON1B_WID		2
+#define MC13783_DEB_BT_ON2B_LSH		6
+#define MC13783_DEB_BT_ON2B_WID		2
+#define MC13783_DEB_BT_ON3B_LSH		8
+#define MC13783_DEB_BT_ON3B_WID		2
+
+/*
+ * Reg Regulator Mode 0
+ */
+#define MC13783_REGCTRL_VAUDIO_EN_LSH	0
+#define MC13783_REGCTRL_VAUDIO_EN_WID	1
+#define MC13783_REGCTRL_VAUDIO_EN_ENABLE	1
+#define MC13783_REGCTRL_VAUDIO_EN_DISABLE	0
+#define MC13783_REGCTRL_VAUDIO_STBY_LSH	1
+#define MC13783_REGCTRL_VAUDIO_STBY_WID	1
+#define MC13783_REGCTRL_VAUDIO_MODE_LSH	2
+#define MC13783_REGCTRL_VAUDIO_MODE_WID	1
+#define MC13783_REGCTRL_VIOHI_EN_LSH	3
+#define MC13783_REGCTRL_VIOHI_EN_WID	1
+#define MC13783_REGCTRL_VIOHI_EN_ENABLE	1
+#define MC13783_REGCTRL_VIOHI_EN_DISABLE	0
+#define MC13783_REGCTRL_VIOHI_STBY_LSH	4
+#define MC13783_REGCTRL_VIOHI_STBY_WID	1
+#define MC13783_REGCTRL_VIOHI_MODE_LSH	5
+#define MC13783_REGCTRL_VIOHI_MODE_WID	1
+#define MC13783_REGCTRL_VIOLO_EN_LSH	6
+#define MC13783_REGCTRL_VIOLO_EN_WID	1
+#define MC13783_REGCTRL_VIOLO_EN_ENABLE	1
+#define MC13783_REGCTRL_VIOLO_EN_DISABLE	0
+#define MC13783_REGCTRL_VIOLO_STBY_LSH	7
+#define MC13783_REGCTRL_VIOLO_STBY_WID	1
+#define MC13783_REGCTRL_VIOLO_MODE_LSH	8
+#define MC13783_REGCTRL_VIOLO_MODE_WID	1
+#define MC13783_REGCTRL_VDIG_EN_LSH	9
+#define MC13783_REGCTRL_VDIG_EN_WID	1
+#define MC13783_REGCTRL_VDIG_EN_ENABLE	1
+#define MC13783_REGCTRL_VDIG_EN_DISABLE	0
+#define MC13783_REGCTRL_VDIG_STBY_LSH	10
+#define MC13783_REGCTRL_VDIG_STBY_WID	1
+#define MC13783_REGCTRL_VDIG_MODE_LSH	11
+#define MC13783_REGCTRL_VDIG_MODE_WID	1
+#define MC13783_REGCTRL_VGEN_EN_LSH	12
+#define MC13783_REGCTRL_VGEN_EN_WID	1
+#define MC13783_REGCTRL_VGEN_EN_ENABLE	1
+#define MC13783_REGCTRL_VGEN_EN_DISABLE	0
+#define MC13783_REGCTRL_VGEN_STBY_LSH	13
+#define MC13783_REGCTRL_VGEN_STBY_WID	1
+#define MC13783_REGCTRL_VGEN_MODE_LSH	14
+#define MC13783_REGCTRL_VGEN_MODE_WID	1
+#define MC13783_REGCTRL_VRFDIG_EN_LSH	15
+#define MC13783_REGCTRL_VRFDIG_EN_WID	1
+#define MC13783_REGCTRL_VRFDIG_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFDIG_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFDIG_STBY_LSH	16
+#define MC13783_REGCTRL_VRFDIG_STBY_WID	1
+#define MC13783_REGCTRL_VRFDIG_MODE_LSH	17
+#define MC13783_REGCTRL_VRFDIG_MODE_WID	1
+#define MC13783_REGCTRL_VRFREF_EN_LSH	18
+#define MC13783_REGCTRL_VRFREF_EN_WID	1
+#define MC13783_REGCTRL_VRFREF_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFREF_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFREF_STBY_LSH	19
+#define MC13783_REGCTRL_VRFREF_STBY_WID	1
+#define MC13783_REGCTRL_VRFREF_MODE_LSH	20
+#define MC13783_REGCTRL_VRFREF_MODE_WID	1
+#define MC13783_REGCTRL_VRFCP_EN_LSH	21
+#define MC13783_REGCTRL_VRFCP_EN_WID	1
+#define MC13783_REGCTRL_VRFCP_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFCP_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFCP_STBY_LSH	22
+#define MC13783_REGCTRL_VRFCP_STBY_WID	1
+#define MC13783_REGCTRL_VRFCP_MODE_LSH	23
+#define MC13783_REGCTRL_VRFCP_MODE_WID	1
+
+/*
+ * Reg Regulator Mode 1
+ */
+#define MC13783_REGCTRL_VSIM_EN_LSH	0
+#define MC13783_REGCTRL_VSIM_EN_WID	1
+#define MC13783_REGCTRL_VSIM_EN_ENABLE	1
+#define MC13783_REGCTRL_VSIM_EN_DISABLE	0
+#define MC13783_REGCTRL_VSIM_STBY_LSH	1
+#define MC13783_REGCTRL_VSIM_STBY_WID	1
+#define MC13783_REGCTRL_VSIM_MODE_LSH	2
+#define MC13783_REGCTRL_VSIM_MODE_WID	1
+#define MC13783_REGCTRL_VESIM_EN_LSH	3
+#define MC13783_REGCTRL_VESIM_EN_WID	1
+#define MC13783_REGCTRL_VESIM_EN_ENABLE	1
+#define MC13783_REGCTRL_VESIM_EN_DISABLE	0
+#define MC13783_REGCTRL_VESIM_STBY_LSH	4
+#define MC13783_REGCTRL_VESIM_STBY_WID	1
+#define MC13783_REGCTRL_VESIM_MODE_LSH	5
+#define MC13783_REGCTRL_VESIM_MODE_WID	1
+#define MC13783_REGCTRL_VCAM_EN_LSH	6
+#define MC13783_REGCTRL_VCAM_EN_WID	1
+#define MC13783_REGCTRL_VCAM_EN_ENABLE	1
+#define MC13783_REGCTRL_VCAM_EN_DISABLE	0
+#define MC13783_REGCTRL_VCAM_STBY_LSH	7
+#define MC13783_REGCTRL_VCAM_STBY_WID	1
+#define MC13783_REGCTRL_VCAM_MODE_LSH	8
+#define MC13783_REGCTRL_VCAM_MODE_WID	1
+#define	MC13783_REGCTRL_VRFBG_EN_LSH	9
+#define	MC13783_REGCTRL_VRFBG_EN_WID	1
+#define MC13783_REGCTRL_VRFBG_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFBG_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFBG_STBY_LSH	10
+#define MC13783_REGCTRL_VRFBG_STBY_WID	1
+#define MC13783_REGCTRL_VVIB_EN_LSH	11
+#define MC13783_REGCTRL_VVIB_EN_WID	1
+#define MC13783_REGCTRL_VVIB_EN_ENABLE	1
+#define MC13783_REGCTRL_VVIB_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF1_EN_LSH	12
+#define MC13783_REGCTRL_VRF1_EN_WID	1
+#define MC13783_REGCTRL_VRF1_EN_ENABLE	1
+#define MC13783_REGCTRL_VRF1_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF1_STBY_LSH	13
+#define MC13783_REGCTRL_VRF1_STBY_WID	1
+#define MC13783_REGCTRL_VRF1_MODE_LSH	14
+#define MC13783_REGCTRL_VRF1_MODE_WID	1
+#define MC13783_REGCTRL_VRF2_EN_LSH	15
+#define MC13783_REGCTRL_VRF2_EN_WID	1
+#define MC13783_REGCTRL_VRF2_EN_ENABLE	1
+#define MC13783_REGCTRL_VRF2_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF2_STBY_LSH	16
+#define MC13783_REGCTRL_VRF2_STBY_WID	1
+#define MC13783_REGCTRL_VRF2_MODE_LSH	17
+#define MC13783_REGCTRL_VRF2_MODE_WID	1
+#define MC13783_REGCTRL_VMMC1_EN_LSH	18
+#define MC13783_REGCTRL_VMMC1_EN_WID	1
+#define MC13783_REGCTRL_VMMC1_EN_ENABLE	1
+#define MC13783_REGCTRL_VMMC1_EN_DISABLE	0
+#define MC13783_REGCTRL_VMMC1_STBY_LSH	19
+#define MC13783_REGCTRL_VMMC1_STBY_WID	1
+#define MC13783_REGCTRL_VMMC1_MODE_LSH	20
+#define MC13783_REGCTRL_VMMC1_MODE_WID	1
+#define MC13783_REGCTRL_VMMC2_EN_LSH	21
+#define MC13783_REGCTRL_VMMC2_EN_WID	1
+#define MC13783_REGCTRL_VMMC2_EN_ENABLE	1
+#define MC13783_REGCTRL_VMMC2_EN_DISABLE	0
+#define MC13783_REGCTRL_VMMC2_STBY_LSH	22
+#define MC13783_REGCTRL_VMMC2_STBY_WID	1
+#define MC13783_REGCTRL_VMMC2_MODE_LSH	23
+#define MC13783_REGCTRL_VMMC2_MODE_WID	1
+
+/*
+ * Reg Regulator Misc.
+ */
+#define MC13783_REGCTRL_GPO1_EN_LSH	6
+#define MC13783_REGCTRL_GPO1_EN_WID	1
+#define MC13783_REGCTRL_GPO1_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO1_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO2_EN_LSH	8
+#define MC13783_REGCTRL_GPO2_EN_WID	1
+#define MC13783_REGCTRL_GPO2_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO2_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO3_EN_LSH	10
+#define MC13783_REGCTRL_GPO3_EN_WID	1
+#define MC13783_REGCTRL_GPO3_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO3_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO4_EN_LSH	12
+#define MC13783_REGCTRL_GPO4_EN_WID	1
+#define MC13783_REGCTRL_GPO4_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO4_EN_DISABLE	0
+#define MC13783_REGCTRL_VIBPINCTRL_LSH	14
+#define MC13783_REGCTRL_VIBPINCTRL_WID	1
+
+/*
+ * Reg Regulator Setting 0
+ */
+#define MC13783_REGSET_VIOLO_LSH		2
+#define MC13783_REGSET_VIOLO_WID		2
+#define MC13783_REGSET_VDIG_LSH		4
+#define MC13783_REGSET_VDIG_WID		2
+#define MC13783_REGSET_VGEN_LSH		6
+#define MC13783_REGSET_VGEN_WID		3
+#define MC13783_REGSET_VRFDIG_LSH		9
+#define MC13783_REGSET_VRFDIG_WID		2
+#define MC13783_REGSET_VRFREF_LSH		11
+#define MC13783_REGSET_VRFREF_WID		2
+#define MC13783_REGSET_VRFCP_LSH		13
+#define MC13783_REGSET_VRFCP_WID		1
+#define MC13783_REGSET_VSIM_LSH		14
+#define MC13783_REGSET_VSIM_WID		1
+#define MC13783_REGSET_VESIM_LSH		15
+#define MC13783_REGSET_VESIM_WID		1
+#define MC13783_REGSET_VCAM_LSH		16
+#define MC13783_REGSET_VCAM_WID		3
+
+/*
+ * Reg Regulator Setting 1
+ */
+#define MC13783_REGSET_VVIB_LSH		0
+#define MC13783_REGSET_VVIB_WID		2
+#define MC13783_REGSET_VRF1_LSH		2
+#define MC13783_REGSET_VRF1_WID		2
+#define MC13783_REGSET_VRF2_LSH		4
+#define MC13783_REGSET_VRF2_WID		2
+#define MC13783_REGSET_VMMC1_LSH		6
+#define MC13783_REGSET_VMMC1_WID		3
+#define MC13783_REGSET_VMMC2_LSH		9
+#define MC13783_REGSET_VMMC2_WID		3
+
+/*
+ * Reg Switcher 0
+ */
+#define MC13783_SWSET_SW1A_LSH		0
+#define MC13783_SWSET_SW1A_WID		6
+#define MC13783_SWSET_SW1A_DVS_LSH	6
+#define MC13783_SWSET_SW1A_DVS_WID	6
+#define MC13783_SWSET_SW1A_STDBY_LSH	12
+#define MC13783_SWSET_SW1A_STDBY_WID	6
+
+/*
+ * Reg Switcher 1
+ */
+#define MC13783_SWSET_SW1B_LSH		0
+#define MC13783_SWSET_SW1B_WID		6
+#define MC13783_SWSET_SW1B_DVS_LSH	6
+#define MC13783_SWSET_SW1B_DVS_WID	6
+#define MC13783_SWSET_SW1B_STDBY_LSH	12
+#define MC13783_SWSET_SW1B_STDBY_WID	6
+
+/*
+ * Reg Switcher 2
+ */
+#define MC13783_SWSET_SW2A_LSH		0
+#define MC13783_SWSET_SW2A_WID		6
+#define MC13783_SWSET_SW2A_DVS_LSH	6
+#define MC13783_SWSET_SW2A_DVS_WID	6
+#define MC13783_SWSET_SW2A_STDBY_LSH	12
+#define MC13783_SWSET_SW2A_STDBY_WID	6
+
+/*
+ * Reg Switcher 3
+ */
+#define MC13783_SWSET_SW2B_LSH		0
+#define MC13783_SWSET_SW2B_WID		6
+#define MC13783_SWSET_SW2B_DVS_LSH	6
+#define MC13783_SWSET_SW2B_DVS_WID	6
+#define MC13783_SWSET_SW2B_STDBY_LSH	12
+#define MC13783_SWSET_SW2B_STDBY_WID	6
+
+/*
+ * Reg Switcher 4
+ */
+#define MC13783_SWCTRL_SW1A_MODE_LSH		0
+#define MC13783_SWCTRL_SW1A_MODE_WID		2
+#define MC13783_SWCTRL_SW1A_STBY_MODE_LSH		2
+#define MC13783_SWCTRL_SW1A_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW1A_DVS_SPEED_LSH		6
+#define MC13783_SWCTRL_SW1A_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW1A_PANIC_MODE_LSH	8
+#define MC13783_SWCTRL_SW1A_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW1A_SOFTSTART_LSH		9
+#define MC13783_SWCTRL_SW1A_SOFTSTART_WID		1
+#define MC13783_SWCTRL_SW1B_MODE_LSH		10
+#define MC13783_SWCTRL_SW1B_MODE_WID		2
+#define MC13783_SWCTRL_SW1B_STBY_MODE_LSH		12
+#define MC13783_SWCTRL_SW1B_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW1B_DVS_SPEED_LSH		14
+#define MC13783_SWCTRL_SW1B_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW1B_PANIC_MODE_LSH	16
+#define MC13783_SWCTRL_SW1B_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW1B_SOFTSTART_LSH		17
+#define MC13783_SWCTRL_SW1B_SOFTSTART_WID		1
+#define MC13783_SWCTRL_PLL_EN_LSH			18
+#define MC13783_SWCTRL_PLL_EN_WID			1
+#define MC13783_SWCTRL_PLL_EN_ENABLE		1
+#define MC13783_SWCTRL_PLL_EN_DISABLE		0
+#define MC13783_SWCTRL_PLL_FACTOR_LSH		19
+#define MC13783_SWCTRL_PLL_FACTOR_WID		3
+
+/*
+ * Reg Switcher 5
+ */
+#define MC13783_SWCTRL_SW2A_MODE_LSH		0
+#define MC13783_SWCTRL_SW2A_MODE_WID		2
+#define MC13783_SWCTRL_SW2A_STBY_MODE_LSH		2
+#define MC13783_SWCTRL_SW2A_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW2A_DVS_SPEED_LSH		6
+#define MC13783_SWCTRL_SW2A_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW2A_PANIC_MODE_LSH	8
+#define MC13783_SWCTRL_SW2A_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW2A_SOFTSTART_LSH		9
+#define MC13783_SWCTRL_SW2A_SOFTSTART_WID		1
+#define MC13783_SWCTRL_SW2B_MODE_LSH		10
+#define MC13783_SWCTRL_SW2B_MODE_WID		2
+#define MC13783_SWCTRL_SW2B_STBY_MODE_LSH		12
+#define MC13783_SWCTRL_SW2B_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW2B_DVS_SPEED_LSH		14
+#define MC13783_SWCTRL_SW2B_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW2B_PANIC_MODE_LSH	16
+#define MC13783_SWCTRL_SW2B_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW2B_SOFTSTART_LSH		17
+#define MC13783_SWCTRL_SW2B_SOFTSTART_WID		1
+#define MC13783_SWSET_SW3_LSH			18
+#define MC13783_SWSET_SW3_WID			2
+#define MC13783_SWCTRL_SW3_EN_LSH			20
+#define MC13783_SWCTRL_SW3_EN_WID			2
+#define MC13783_SWCTRL_SW3_EN_ENABLE		1
+#define MC13783_SWCTRL_SW3_EN_DISABLE		0
+#define MC13783_SWCTRL_SW3_STBY_LSH		21
+#define MC13783_SWCTRL_SW3_STBY_WID		1
+#define MC13783_SWCTRL_SW3_MODE_LSH		22
+#define MC13783_SWCTRL_SW3_MODE_WID		1
+
+/*
+ * Switcher configuration
+ */
+#define MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN	0
+#define MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN	1
+#define MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN	2
+#define MC13783_SWCTRL_SW_MODE_LOW_POWER_EN	3
+#define MC13783_REGTRL_LP_MODE_ENABLE		1
+#define MC13783_REGTRL_LP_MODE_DISABLE		0
+#define MC13783_REGTRL_STBY_MODE_ENABLE		1
+#define MC13783_REGTRL_STBY_MODE_DISABLE		0
+
+#endif				/*  __MC13783_POWER_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_rtc.c b/drivers/mxc/pmic/mc13783/pmic_rtc.c
new file mode 100644
index 0000000..4abd46f
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_rtc.c
@@ -0,0 +1,560 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_rtc.c
+ * @brief This is the main file of PMIC(mc13783) RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+
+#include <asm/plat-mxc/pmic_rtc.h>
+
+#include "pmic_rtc_defs.h"
+
+#define PMIC_LOAD_ERROR_MSG		\
+	"PMIC card was not correctly detected. Stop loading PMIC RTC driver\n"
+
+/*
+ * Global variables
+ */
+static int pmic_rtc_major;
+static void callback_alarm_asynchronous(void *);
+static void callback_alarm_synchronous(void *);
+static unsigned int pmic_rtc_poll(struct file *file, poll_table *wait);
+static DECLARE_WAIT_QUEUE_HEAD(queue_alarm);
+static DECLARE_WAIT_QUEUE_HEAD(pmic_rtc_wait);
+static pmic_event_callback_t alarm_callback;
+static pmic_event_callback_t rtc_callback;
+static int pmic_rtc_detected;
+static bool pmic_rtc_done;
+
+void pmic_rtc_class_dev_release(struct device *dev);
+
+static struct class pmic_rtc_class = {
+	.owner		=	THIS_MODULE,
+	.name		=	"pmic_rtc",
+	.dev_release	=	pmic_rtc_class_dev_release,
+};
+
+static DECLARE_MUTEX(mutex);
+
+/*!
+ * This is the callback function called on
+ * TSI Pmic event, used in asynchronous
+ * call.
+ */
+static void callback_alarm_asynchronous(void *unused)
+{
+	pmic_rtc_done = true;
+}
+
+/*!
+ * This is the callback function is used in test code for (un)sub.
+ */
+static void callback_test_sub(void)
+{
+	printk(KERN_INFO "*****************************************\n");
+	printk(KERN_INFO "***** PMIC RTC 'Alarm IT CallBack' ******\n");
+	printk(KERN_INFO "*****************************************\n");
+}
+
+/*!
+ * This is the callback function called on TSI Pmic event, used in synchronous
+ * call.
+ */
+static void callback_alarm_synchronous(void *unused)
+{
+	printk(KERN_INFO "*** Alarm IT Pmic ***\n");
+	wake_up(&queue_alarm);
+}
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void)
+{
+	DEFINE_WAIT(wait);
+	alarm_callback.func = callback_alarm_synchronous;
+	alarm_callback.param = NULL;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TODAI, alarm_callback));
+	prepare_to_wait(&queue_alarm, &wait, TASK_UNINTERRUPTIBLE);
+	schedule();
+	finish_wait(&queue_alarm, &wait);
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TODAI, alarm_callback));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_wait_alarm);
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	tod_reg_val = pmic_time->tv_sec % 86400;
+	day_reg_val = pmic_time->tv_sec / 86400;
+
+	mask = BITFMASK(MC13783_RTCTIME_TIME);
+	value = BITFVAL(MC13783_RTCTIME_TIME, tod_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_TIME, value, mask));
+
+	mask = BITFMASK(MC13783_RTCDAY_DAY);
+	value = BITFVAL(MC13783_RTCDAY_DAY, day_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_DAY, value, mask));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_set_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns
+ * PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_RTCTIME_TIME);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_TIME, &value, mask));
+	tod_reg_val = BITFEXT(value, MC13783_RTCTIME_TIME);
+
+	mask = BITFMASK(MC13783_RTCDAY_DAY);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_DAY, &value, mask));
+	day_reg_val = BITFEXT(value, MC13783_RTCDAY_DAY);
+
+	pmic_time->tv_sec = (unsigned long)((unsigned long)
+			(tod_reg_val & 0x0001FFFF) +
+			(unsigned long)(day_reg_val * 86400));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_get_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns
+ * PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+	int ret = 0;
+
+	/*for eliminate warning*/
+	ret = down_interruptible(&mutex);
+	tod_reg_val = pmic_time->tv_sec % 86400;
+	day_reg_val = pmic_time->tv_sec / 86400;
+
+	mask = BITFMASK(MC13783_RTCALARM_TIME);
+	value = BITFVAL(MC13783_RTCALARM_TIME, tod_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_ALARM, value, mask));
+
+	mask = BITFMASK(MC13783_RTCALARM_DAY);
+	value = BITFVAL(MC13783_RTCALARM_DAY, day_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_DAY_ALARM, value, mask));
+	up(&mutex);
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_set_time_alarm);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS
+ * if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_RTCALARM_TIME);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_ALARM, &value, mask));
+	tod_reg_val = BITFEXT(value, MC13783_RTCALARM_TIME);
+
+	mask = BITFMASK(MC13783_RTCALARM_DAY);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_DAY_ALARM, &value, mask));
+	day_reg_val = BITFEXT(value, MC13783_RTCALARM_DAY);
+
+	pmic_time->tv_sec = (unsigned long)((unsigned long)
+			(tod_reg_val & 0x0001FFFF) +
+			(unsigned long)(day_reg_val * 86400));
+
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_get_time_alarm);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub)
+{
+	type_event rtc_event;
+	if (callback == NULL)
+		return PMIC_ERROR;
+	else {
+		rtc_callback.func = callback;
+		rtc_callback.param = NULL;
+	}
+	switch (event) {
+	case RTC_IT_ALARM:
+			rtc_event = EVENT_TODAI;
+			break;
+	case RTC_IT_1HZ:
+			rtc_event = EVENT_E1HZI;
+			break;
+	case RTC_IT_RST:
+			rtc_event = EVENT_RTCRSTI;
+			break;
+	default:
+			return PMIC_PARAMETER_ERROR;
+	}
+
+	if (sub == true)
+		CHECK_ERROR(pmic_event_subscribe(rtc_event, rtc_callback));
+	else
+		CHECK_ERROR(pmic_event_unsubscribe(rtc_event, rtc_callback));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback)
+{
+	CHECK_ERROR(pmic_rtc_event(event, callback, true));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_event_sub);
+
+/*!
+ * This function is used to un subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback)
+{
+	CHECK_ERROR(pmic_rtc_event(event, callback, false));
+	return PMIC_SUCCESS;
+}
+EXPORT_SYMBOL(pmic_rtc_event_unsub);
+
+/* Called without the kernel lock - fine */
+static unsigned int pmic_rtc_poll(struct file *file, poll_table *wait)
+{
+
+	if (pmic_rtc_done)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_rtc_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct timeval *pmic_time = NULL;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	if (arg) {
+		pmic_time = kmalloc(sizeof(struct timeval),
+				GFP_KERNEL);
+		if (pmic_time == NULL)
+			return -ENOMEM;
+	}
+
+	switch (cmd) {
+	case PMIC_RTC_SET_TIME:
+			if (copy_from_user(pmic_time, (struct timeval *)arg,
+						sizeof(struct timeval)))
+				return -EFAULT;
+			pr_debug("SET RTC\n");
+			CHECK_ERROR(pmic_rtc_set_time(pmic_time));
+			break;
+	case PMIC_RTC_GET_TIME:
+			if (copy_to_user((struct timeval *)arg, pmic_time,
+						sizeof(struct timeval)))
+				return -EFAULT;
+			pr_debug("GET RTC\n");
+			CHECK_ERROR(pmic_rtc_get_time(pmic_time));
+			break;
+	case PMIC_RTC_SET_ALARM:
+			if (copy_from_user(pmic_time, (struct timeval *)arg,
+						sizeof(struct timeval)))
+				return -EFAULT;
+			pr_debug("SET RTC ALARM\n");
+			CHECK_ERROR(pmic_rtc_set_time_alarm(pmic_time));
+			break;
+	case PMIC_RTC_GET_ALARM:
+			if (copy_to_user((struct timeval *)arg, pmic_time,
+						sizeof(struct timeval)))
+				return -EFAULT;
+			pr_debug("GET RTC ALARM\n");
+			CHECK_ERROR(pmic_rtc_get_time_alarm(pmic_time));
+			break;
+	case PMIC_RTC_WAIT_ALARM:
+			printk(KERN_INFO "WAIT ALARM...\n");
+			CHECK_ERROR(pmic_rtc_event_sub(RTC_IT_ALARM,
+						callback_test_sub));
+			CHECK_ERROR(pmic_rtc_wait_alarm());
+			printk(KERN_INFO "ALARM DONE\n");
+			CHECK_ERROR(pmic_rtc_event_unsub(RTC_IT_ALARM,
+						callback_test_sub));
+			break;
+	case PMIC_RTC_ALARM_REGISTER:
+			printk(KERN_INFO "PMIC RTC ALARM REGISTER\n");
+			alarm_callback.func = callback_alarm_asynchronous;
+			alarm_callback.param = NULL;
+			CHECK_ERROR(pmic_event_subscribe(EVENT_TODAI, alarm_callback));
+			break;
+	case PMIC_RTC_ALARM_UNREGISTER:
+			printk(KERN_INFO "PMIC RTC ALARM UNREGISTER\n");
+			alarm_callback.func = callback_alarm_asynchronous;
+			alarm_callback.param = NULL;
+			CHECK_ERROR(pmic_event_unsubscribe
+					(EVENT_TODAI, alarm_callback));
+			pmic_rtc_done = false;
+			break;
+	default:
+			pr_debug("%d unsupported ioctl command\n", (int)cmd);
+			return -EINVAL;
+	}
+
+	if (arg) {
+		if (copy_to_user((struct timeval *)arg, pmic_time,
+					sizeof(struct timeval)))
+			return -EFAULT;
+		kfree(pmic_time);
+	}
+
+	return 0;
+}
+
+/*!
+ * This function implements the open method on
+ * a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_rtc_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/*!
+ * This function implements the release method
+ * on a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_rtc_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/*!
+ * This function is called to put the RTC in
+ * a low power state.
+ * There is no need for power handlers for
+ * the RTC device.
+ * The RTC cannot be suspended.
+ *
+ * @param   pdev  the device structure used to
+ * give information on which RTC device (0 through
+ * 3 channels) to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+/*!
+ * This function is called to resume the RTC from
+ * a low power state.
+ *
+ * @param   pdev  the device structure used to give
+ * information on which RTC device (0 through 3 channels)
+ * to suspend
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_rtc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+
+void pmic_rtc_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+/*!
+ * This structure contains pointers to the
+ * power management callback functions.
+ */
+
+static struct file_operations pmic_rtc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_rtc_ioctl,
+	.poll = pmic_rtc_poll,
+	.open = pmic_rtc_open,
+	.release = pmic_rtc_release,
+};
+
+int pmic_rtc_loaded(void)
+{
+	return pmic_rtc_detected;
+}
+EXPORT_SYMBOL(pmic_rtc_loaded);
+
+static int pmic_rtc_remove(struct platform_device *pdev)
+{
+	class_unregister(&pmic_rtc_class);
+	unregister_chrdev(pmic_rtc_major, "pmic_rtc");
+	return 0;
+}
+
+static int pmic_rtc_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_dev;
+
+	pmic_rtc_major = register_chrdev(0, "pmic_rtc", &pmic_rtc_fops);
+	if (pmic_rtc_major < 0) {
+		printk(KERN_ERR "Unable to get a"
+				"major for pmic_rtc\n");
+		return pmic_rtc_major;
+	}
+
+	ret = class_register(&pmic_rtc_class);
+	if (ret) {
+		printk(KERN_ERR "Error creating"
+				"pmic rtc class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&pmic_rtc_class,
+			&pdev->dev, MKDEV(pmic_rtc_major, 0), NULL, "pmic_rtc");
+	if (IS_ERR(temp_dev)) {
+		printk(KERN_ERR "Error creating"
+				"pmic rtc class device.\n");
+		ret = PTR_ERR(temp_dev);
+		goto err_out2;
+	}
+
+	pmic_rtc_detected = 1;
+	printk(KERN_INFO "PMIC RTC successfully probed\n");
+	return ret;
+
+err_out2:
+	class_unregister(&pmic_rtc_class);
+err_out1:
+	unregister_chrdev(pmic_rtc_major, "pmic_rtc");
+	return ret;
+}
+
+static struct platform_driver pmic_rtc_driver_ldm = {
+	.driver = {
+		.name = "pmic_rtc",
+		.owner = THIS_MODULE,
+	},
+	.suspend = pmic_rtc_suspend,
+	.resume = pmic_rtc_resume,
+	.probe = pmic_rtc_probe,
+	.remove = pmic_rtc_remove,
+};
+
+static int __init pmic_rtc_init(void)
+{
+	pr_debug("PMIC RTC driver loading...\n");
+	return platform_driver_register(&pmic_rtc_driver_ldm);
+}
+static void __exit pmic_rtc_exit(void)
+{
+	platform_driver_unregister(&pmic_rtc_driver_ldm);
+	pr_debug("PMIC RTC driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_rtc_init);
+module_exit(pmic_rtc_exit);
+
+MODULE_DESCRIPTION("Pmic_rtc driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h b/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h
new file mode 100644
index 0000000..595f9e2
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MC13783_RTC_DEFS_H__
+#define __MC13783_RTC_DEFS_H__
+
+/*!
+ * @file pmic_rtc_defs.h
+ * @brief This is the internal header of PMIC(mc13783) RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * RTC Time
+ */
+#define MC13783_RTCTIME_TIME_LSH	0
+#define MC13783_RTCTIME_TIME_WID	17
+
+/*
+ * RTC Alarm
+ */
+#define MC13783_RTCALARM_TIME_LSH	0
+#define MC13783_RTCALARM_TIME_WID	17
+
+/*
+ * RTC Day
+ */
+#define MC13783_RTCDAY_DAY_LSH		0
+#define MC13783_RTCDAY_DAY_WID		15
+
+/*
+ * RTC Day alarm
+ */
+#define MC13783_RTCALARM_DAY_LSH	0
+#define MC13783_RTCALARM_DAY_WID	15
+
+#endif				/* __MC13783_RTC_DEFS_H__ */
-- 
1.6.3.1

