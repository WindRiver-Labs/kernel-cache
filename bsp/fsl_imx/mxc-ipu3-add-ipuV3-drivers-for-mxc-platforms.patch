From f7ed9029c4ecad6063b0ebe6117dc44c54641361 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 20 May 2010 15:05:56 +0800
Subject: [PATCH 22/30] mxc/ipu3: add ipuV3 drivers for mxc platforms

On mx5 series platforms, the IPUv3(image process unit version 3)
can handle capture to mem, mem to mem and mem to framebuffer data
transfer, it can also handle image conversion, clip and so on.
This driver is the core of grahpics and v4l2 drivers.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/mxc/Kconfig                       |    1 +
 drivers/mxc/Makefile                      |    2 +
 drivers/mxc/ipu3/Kconfig                  |    5 +
 drivers/mxc/ipu3/Makefile                 |    4 +
 drivers/mxc/ipu3/ipu_calc_stripes_sizes.c |  374 +++++
 drivers/mxc/ipu3/ipu_capture.c            |  713 +++++++++
 drivers/mxc/ipu3/ipu_common.c             | 2468 +++++++++++++++++++++++++++++
 drivers/mxc/ipu3/ipu_device.c             |  486 ++++++
 drivers/mxc/ipu3/ipu_disp.c               | 1706 ++++++++++++++++++++
 drivers/mxc/ipu3/ipu_ic.c                 |  835 ++++++++++
 drivers/mxc/ipu3/ipu_param_mem.h          |  513 ++++++
 drivers/mxc/ipu3/ipu_prv.h                |  102 ++
 drivers/mxc/ipu3/ipu_regs.h               |  658 ++++++++
 13 files changed, 7867 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/ipu3/Kconfig
 create mode 100644 drivers/mxc/ipu3/Makefile
 create mode 100644 drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
 create mode 100644 drivers/mxc/ipu3/ipu_capture.c
 create mode 100644 drivers/mxc/ipu3/ipu_common.c
 create mode 100644 drivers/mxc/ipu3/ipu_device.c
 create mode 100644 drivers/mxc/ipu3/ipu_disp.c
 create mode 100644 drivers/mxc/ipu3/ipu_ic.c
 create mode 100644 drivers/mxc/ipu3/ipu_param_mem.h
 create mode 100644 drivers/mxc/ipu3/ipu_prv.h
 create mode 100644 drivers/mxc/ipu3/ipu_regs.h

diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 1c7e70f..16beb6c 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -18,6 +18,7 @@ config MXC_IPU
 	  Y here. IPU is needed by Framebuffer and V4L2 drivers.
 
 source "drivers/mxc/ipu/Kconfig"
+source "drivers/mxc/ipu3/Kconfig"
 
 endmenu
 
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index 1b901b2..d515980 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -1 +1,3 @@
 obj-$(CONFIG_MXC_IPU_V1)		+= ipu/
+obj-$(CONFIG_MXC_IPU_V3)		+= ipu3/
+
diff --git a/drivers/mxc/ipu3/Kconfig b/drivers/mxc/ipu3/Kconfig
new file mode 100644
index 0000000..0ae0ffa
--- /dev/null
+++ b/drivers/mxc/ipu3/Kconfig
@@ -0,0 +1,5 @@
+config MXC_IPU_V3
+	bool
+
+config MXC_IPU_V3D
+	bool
diff --git a/drivers/mxc/ipu3/Makefile b/drivers/mxc/ipu3/Makefile
new file mode 100644
index 0000000..aa3e7b1
--- /dev/null
+++ b/drivers/mxc/ipu3/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MXC_IPU_V3) = mxc_ipu.o
+
+mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o ipu_capture.o ipu_device.o ipu_calc_stripes_sizes.o
+
diff --git a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
new file mode 100644
index 0000000..09c7664
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_calc_stripes_sizes.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/module.h>
+#include <linux/ipu.h>
+#include <asm/div64.h>
+
+#define BPP_32 0
+#define BPP_16 3
+#define BPP_8 5
+#define BPP_24 1
+#define BPP_12 4
+#define BPP_18 2
+
+static u64 _do_div(u64 a, u32 b)
+{
+	u64 div;
+	div = a;
+	do_div(div, b);
+	return div;
+}
+
+static u32 truncate(u32 up, /* 0: down; else: up */
+					u64 a, /* must be non-negative */
+					u32 b)
+{
+	u32 d;
+	u64 div;
+	div = _do_div(a, b);
+	d = b * (div >> 32);
+	if (up && (a > (((u64)d) << 32)))
+		return d+b;
+	else
+		return d;
+}
+
+static unsigned int f_calc(unsigned int pfs, unsigned int bpp, unsigned int *write)
+{/* return input_f */
+	unsigned int f_calculated = 0;
+	switch (pfs) {
+	case IPU_PIX_FMT_YVU422P:
+	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		f_calculated = 16;
+		break;
+
+	case IPU_PIX_FMT_NV12:
+		f_calculated = 8;
+		break;
+
+	default:
+		f_calculated = 0;
+		break;
+
+	}
+	if (!f_calculated) {
+		switch (bpp) {
+		case BPP_32:
+			f_calculated = 2;
+			break;
+
+		case BPP_16:
+			f_calculated = 4;
+			break;
+
+		case BPP_8:
+		case BPP_24:
+			f_calculated = 8;
+			break;
+
+		case BPP_12:
+			f_calculated = 16;
+			break;
+
+		case BPP_18:
+			f_calculated = 32;
+			break;
+
+		default:
+			f_calculated = 0;
+			break;
+			}
+		}
+	return f_calculated;
+}
+
+
+static unsigned int m_calc(unsigned int pfs)
+{
+	unsigned int m_calculated = 0;
+	switch (pfs) {
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YVU422P:
+	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YVU420P:
+	case IPU_PIX_FMT_NV12:
+		m_calculated = 8;
+		break;
+
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		m_calculated = 2;
+		break;
+
+	default:
+		m_calculated = 1;
+		break;
+
+	}
+	return m_calculated;
+}
+
+
+/* Stripe parameters calculator */
+/**************************************************************************
+Notes:
+MSW = the maximal width allowed for a stripe
+	i.MX31: 720, i.MX35: 800, i.MX37/51/53: 1024
+cirr = the maximal inverse resizing ratio for which overlap in the input
+	is requested; typically cirr~2
+equal_stripes:
+	0: each stripe is allowed to have independent parameters
+		for maximal image quality
+	1: the stripes are requested to have identical parameters
+	(except the base address), for maximal performance
+If performance is the top priority (above image quality)
+	Avoid overlap, by setting CIRR = 0
+		This will also force effectively identical_stripes = 1
+	Choose IF & OF that corresponds to the same IOX/SX for both stripes
+	Choose IFW & OFW such that
+	IFW/IM, IFW/IF, OFW/OM, OFW/OF are even integers
+	The function returns an error status:
+	0: no error
+	1: invalid input parameters -> aborted without result
+		Valid parameters should satisfy the following conditions
+		IFW <= OFW, otherwise downsizing is required
+					 - which is not supported yet
+		4 <= IFW,OFW, so some interpolation may be needed even without overlap
+		IM, OM, IF, OF should not vanish
+		2*IF <= IFW
+		so the frame can be split to two equal stripes, even without overlap
+		2*(OF+IF/irr_opt) <= OFW
+		so a valid positive INW exists even for equal stripes
+		OF <= MSW, otherwise, the left stripe cannot be sufficiently large
+		MSW < OFW, so splitting to stripes is required
+		OFW <= 2*MSW, so two stripes are sufficient
+		(this also implies that 2<=MSW)
+	2: OF is not a multiple of OM - not fully-supported yet
+	Output is produced but OW is not guaranited to be a multiple of OM
+	4: OFW reduced to be a multiple of OM
+	8: CIRR > 1: truncated to 1
+	Overlap is not supported (and not needed) y for upsizing)
+**************************************************************************/
+int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
+			   /* input frame width;>1 */
+			   unsigned int output_frame_width, /* output frame width; >1 */
+			   const unsigned int maximal_stripe_width,
+			   /* the maximal width allowed for a stripe */
+			   const unsigned long long cirr, /* see above */
+			   const unsigned int equal_stripes, /* see above */
+			   u32 input_pixelformat,/* pixel format after of read channel*/
+			   u32 output_pixelformat,/* pixel format after of write channel*/
+			   struct stripe_param *left,
+			   struct stripe_param *right)
+{
+	const unsigned int irr_frac_bits = 13;
+	const unsigned long irr_steps = 1 << irr_frac_bits;
+	const u64 dirr = ((u64)1) << (32 - 2);
+	/* The maximum relative difference allowed between the irrs */
+	const u64 cr = ((u64)4) << 32;
+	/* The importance ratio between the two terms in the cost function below */
+
+	unsigned int status;
+	unsigned int temp;
+	unsigned int onw_min;
+	unsigned int inw, onw, inw_best = 0;
+	/* number of pixels in the left stripe NOT hidden by the right stripe */
+	u64 irr_opt; /* the optimal inverse resizing ratio */
+	u64 rr_opt; /* the optimal resizing ratio = 1/irr_opt*/
+	u64 dinw; /* the misalignment between the stripes */
+	/* (measured in units of input columns) */
+	u64 difwl, difwr;
+	/* The number of input columns not reflected in the output */
+	/* the resizing ratio used for the right stripe is */
+	/*   left->irr and right->irr respectively */
+	u64 cost, cost_min;
+	u64 div; /* result of division */
+
+	unsigned int input_m, input_f, output_m, output_f; /* parameters for upsizing by stripes */
+
+	status = 0;
+
+	/* M, F calculations */
+	/* read back pfs from params */
+
+	input_f = f_calc(input_pixelformat, 0, NULL);
+	input_m = 16;
+	/* BPP should be used in the out_F calc */
+	/* Temporarily not used */
+	/* out_F = F_calc(idmac->pfs, idmac->bpp, NULL); */
+
+	output_f = 16;
+	output_m = m_calc(output_pixelformat);
+
+
+	if ((output_frame_width < input_frame_width) || (input_frame_width < 4)
+	    || (output_frame_width < 4))
+		return 1;
+
+	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+			  (output_frame_width - 1));
+	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+			 (input_frame_width - 1));
+
+	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
+	    || (input_frame_width < (2 * input_f))
+	    || ((((u64)output_frame_width) << 32) <
+		(2 * ((((u64)output_f) << 32) + (input_f * rr_opt))))
+	    || (maximal_stripe_width < output_f)
+	    || (output_frame_width <= maximal_stripe_width)
+	    || ((2 * maximal_stripe_width) < output_frame_width))
+		return 1;
+
+	if (output_f % output_m)
+		status += 2;
+
+	temp = truncate(0, (((u64)output_frame_width) << 32), output_m);
+	if (temp < output_frame_width) {
+		output_frame_width = temp;
+		status += 4;
+	}
+
+	if (equal_stripes) {
+		if ((irr_opt > cirr) /* overlap in the input is not requested */
+		    && ((input_frame_width % (input_m << 1)) == 0)
+		    && ((input_frame_width % (input_f << 1)) == 0)
+		    && ((output_frame_width % (output_m << 1)) == 0)
+		    && ((output_frame_width % (output_f << 1)) == 0)) {
+			/* without overlap */
+			left->input_width = right->input_width = right->input_column =
+				input_frame_width >> 1;
+			left->output_width = right->output_width = right->output_column =
+				output_frame_width >> 1;
+			left->input_column = right->input_column = 0;
+			div = _do_div(((((u64)irr_steps) << 32) *
+				       (right->input_width - 1)), (right->output_width - 1));
+			left->irr = right->irr = truncate(0, div, 1);
+		} else { /* with overlap */
+			onw = truncate(0, (((u64)output_frame_width) << 32) >> 1,
+				       output_f);
+			inw = truncate(0, onw * irr_opt, input_f);
+			/* this is the maximal inw which allows the same resizing ratio */
+			/* in both stripes */
+			onw = truncate(1, (inw * rr_opt), output_f);
+			div = _do_div((((u64)(irr_steps * inw)) <<
+				       32), onw);
+			left->irr = right->irr = truncate(0, div, 1);
+			left->output_width = right->output_width =
+				output_frame_width - onw;
+			/* These are valid assignments for output_width, */
+			/* assuming output_f is a multiple of output_m */
+			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
+			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+
+			left->input_width = right->input_width = truncate(1, div, input_m);
+
+			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+				       32), irr_steps);
+			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
+			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			left->input_column = truncate(0, div, input_f);
+
+
+			/* This splits the truncated input columns evenly */
+			/*    between the left and right margins */
+			right->input_column = left->input_column + inw;
+			left->output_column = 0;
+			right->output_column = onw;
+		}
+	} else { /* independent stripes */
+		onw_min = output_frame_width - maximal_stripe_width;
+		/* onw is a multiple of output_f, in the range */
+		/* [max(output_f,output_frame_width-maximal_stripe_width),*/
+		/*min(output_frame_width-2,maximal_stripe_width)] */
+		/* definitely beyond the cost of any valid setting */
+		cost_min = (((u64)input_frame_width) << 32) + cr;
+		onw = truncate(0, ((u64)maximal_stripe_width), output_f);
+		if (output_frame_width - onw == 1)
+			onw -= output_f; /*  => onw and output_frame_width-1-onw are positive */
+		inw = truncate(0, onw * irr_opt, input_f);
+		/* this is the maximal inw which allows the same resizing ratio */
+		/* in both stripes */
+		onw = truncate(1, inw * rr_opt, output_f);
+		do {
+			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			left->irr = truncate(0, div, 1);
+			div = _do_div((((u64)(onw * left->irr)) << 32),
+				      irr_steps);
+			dinw = (((u64)inw) << 32) - div;
+
+			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+				       32), irr_steps);
+
+			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
+
+			cost = difwl + (((u64)(cr * dinw)) >> 32);
+
+			if (cost < cost_min) {
+				inw_best = inw;
+				cost_min = cost;
+			}
+
+			inw -= input_f;
+			onw = truncate(1, inw * rr_opt, output_f);
+			/* This is the minimal onw which allows the same resizing ratio */
+			/*     in both stripes */
+		} while (onw >= onw_min);
+
+		inw = inw_best;
+		onw = truncate(1, inw * rr_opt, output_f);
+		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		left->irr = truncate(0, div, 1);
+
+		left->output_width = onw;
+		right->output_width = output_frame_width - onw;
+		/* These are valid assignments for output_width, */
+		/* assuming output_f is a multiple of output_m */
+		left->input_width = truncate(1, ((u64)(inw + 1)) << 32, input_m);
+		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
+					      32, input_m);
+
+		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+			       32), (right->output_width - 1));
+		right->irr = truncate(0, div, 1);
+		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
+		if (temp < right->irr)
+			right->irr = temp;
+		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+			       32), irr_steps);
+		difwr = (u64)(input_frame_width - 1 - inw) - div;
+
+
+		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		left->input_column = truncate(0, div, input_f);
+
+		/* This splits the truncated input columns evenly */
+		/*    between the left and right margins */
+		right->input_column = left->input_column + inw;
+		left->output_column = 0;
+		right->output_column = onw;
+	}
+	return status;
+}
+EXPORT_SYMBOL(ipu_calc_stripes_sizes);
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
new file mode 100644
index 0000000..b71ef0a
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -0,0 +1,713 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_capture.c
+ *
+ * @brief IPU capture dase functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/ipu.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+
+/*!
+ * ipu_csi_init_interface
+ *	Sets initial values for the CSI registers.
+ *	The width and height of the sensor and the actual frame size will be
+ *	set to the same values.
+ * @param	width		Sensor width
+ * @param       height		Sensor height
+ * @param       pixel_fmt	pixel format
+ * @param       cfg_param	ipu_csi_signal_cfg_t structure
+ * @param       csi             csi 0 or csi 1
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t
+ipu_csi_init_interface(uint16_t width, uint16_t height, uint32_t pixel_fmt,
+	ipu_csi_signal_cfg_t cfg_param)
+{
+	uint32_t data = 0;
+	uint32_t csi = cfg_param.csi;
+	unsigned long lock_flags;
+
+	/* Set SENS_DATA_FORMAT bits (8, 9 and 10)
+	   RGB or YUV444 is 0 which is current value in data so not set
+	   explicitly
+	   This is also the default value if attempts are made to set it to
+	   something invalid. */
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_YUYV:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;
+		break;
+	case IPU_PIX_FMT_UYVY:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR24:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
+		break;
+	case IPU_PIX_FMT_GENERIC:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		break;
+	case IPU_PIX_FMT_RGB565:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;
+		break;
+	case IPU_PIX_FMT_RGB555:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	data |= cfg_param.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
+		cfg_param.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |
+		cfg_param.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
+		cfg_param.Vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
+		cfg_param.Hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
+		cfg_param.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
+		cfg_param.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
+		cfg_param.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
+		cfg_param.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |
+		cfg_param.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |
+		cfg_param.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel(data, CSI_SENS_CONF(csi));
+
+	/* Setup sensor frame size */
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE(csi));
+
+	/* Set CCIR registers */
+	if ((cfg_param.clk_mode == IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE) ||
+	    (cfg_param.clk_mode == IPU_CSI_CLK_MODE_CCIR656_INTERLACED)) {
+		_ipu_csi_ccir_err_detection_enable(csi);
+		__raw_writel(0x40030, CSI_CCIR_CODE_1(csi));
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3(csi));
+	} else if ((cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR)) {
+		_ipu_csi_ccir_err_detection_enable(csi);
+		__raw_writel(0x40030, CSI_CCIR_CODE_1(csi));
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3(csi));
+	} else if ((cfg_param.clk_mode == IPU_CSI_CLK_MODE_GATED_CLK) ||
+		   (cfg_param.clk_mode == IPU_CSI_CLK_MODE_NONGATED_CLK)) {
+		_ipu_csi_ccir_err_detection_disable(csi);
+	}
+
+	dev_dbg(g_ipu_dev, "CSI_SENS_CONF = 0x%08X\n",
+		__raw_readl(CSI_SENS_CONF(csi)));
+	dev_dbg(g_ipu_dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
+		__raw_readl(CSI_ACT_FRM_SIZE(csi)));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_init_interface);
+
+/*! _ipu_csi_mclk_set
+ *
+ * @param	pixel_clk   desired pixel clock frequency in Hz
+ * @param	csi         csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_mclk_set(uint32_t pixel_clk, uint32_t csi)
+{
+	uint32_t temp;
+	uint32_t div_ratio;
+
+	div_ratio = (clk_get_rate(g_ipu_clk) / pixel_clk) - 1;
+
+	if (div_ratio > 0xFF || div_ratio < 0) {
+		dev_dbg(g_ipu_dev, "The value of pixel_clk extends normal range\n");
+		return -EINVAL;
+	}
+
+	temp = __raw_readl(CSI_SENS_CONF(csi));
+	temp &= ~CSI_SENS_CONF_DIVRATIO_MASK;
+	__raw_writel(temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),
+			CSI_SENS_CONF(csi));
+
+	return 0;
+}
+
+/*!
+ * ipu_csi_enable_mclk
+ *
+ * @param	csi         csi 0 or csi 1
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      Returns 0 on success
+ */
+int ipu_csi_enable_mclk(int csi, bool flag, bool wait)
+{
+	if (flag) {
+		clk_enable(g_csi_clk[csi]);
+		if (wait == true)
+			msleep(10);
+	} else {
+		if (clk_get_usecount(g_csi_clk[csi]) > 0)
+			clk_disable(g_csi_clk[csi]);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_enable_mclk);
+
+/*!
+ * ipu_csi_get_window_size
+ *
+ * @param	width	pointer to window width
+ * @param	height	pointer to window height
+ * @param	csi	csi 0 or csi 1
+ */
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(CSI_ACT_FRM_SIZE(csi));
+	*width = (reg & 0xFFFF) + 1;
+	*height = (reg >> 16 & 0xFFFF) + 1;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_get_window_size);
+
+/*!
+ * ipu_csi_set_window_size
+ *
+ * @param	width	window width
+ * @param       height	window height
+ * @param       csi	csi 0 or csi 1
+ */
+void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi)
+{
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_ACT_FRM_SIZE(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_size);
+
+/*!
+ * ipu_csi_set_window_pos
+ *
+ * @param       left	uint32 window x start
+ * @param       top	uint32 window y start
+ * @param       csi	csi 0 or csi 1
+ */
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~(CSI_HSC_MASK | CSI_VSC_MASK);
+	temp |= ((top << CSI_VSC_SHIFT) | (left << CSI_HSC_SHIFT));
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_pos);
+
+/*!
+ * _ipu_csi_horizontal_downsize_enable
+ *	Enable horizontal downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_horizontal_downsize_enable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp |= CSI_HORI_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_horizontal_downsize_disable
+ *	Disable horizontal downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_horizontal_downsize_disable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~CSI_HORI_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_vertical_downsize_enable
+ *	Enable vertical downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_vertical_downsize_enable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp |= CSI_VERT_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_vertical_downsize_disable
+ *	Disable vertical downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_vertical_downsize_disable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~CSI_VERT_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * ipu_csi_set_test_generator
+ *
+ * @param	active       1 for active and 0 for inactive
+ * @param       r_value	     red value for the generated pattern of even pixel
+ * @param       g_value      green value for the generated pattern of even
+ *			     pixel
+ * @param       b_value      blue value for the generated pattern of even pixel
+ * @param	pixel_clk   desired pixel clock frequency in Hz
+ * @param       csi          csi 0 or csi 1
+ */
+void ipu_csi_set_test_generator(bool active, uint32_t r_value,
+	uint32_t g_value, uint32_t b_value, uint32_t pix_clk, uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_TST_CTRL(csi));
+
+	if (active == false) {
+		temp &= ~CSI_TEST_GEN_MODE_EN;
+		__raw_writel(temp, CSI_TST_CTRL(csi));
+	} else {
+		/* Set sensb_mclk div_ratio*/
+		_ipu_csi_mclk_set(pix_clk, csi);
+
+		temp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |
+			CSI_TEST_GEN_B_MASK);
+		temp |= CSI_TEST_GEN_MODE_EN;
+		temp |= (r_value << CSI_TEST_GEN_R_SHIFT) |
+			(g_value << CSI_TEST_GEN_G_SHIFT) |
+			(b_value << CSI_TEST_GEN_B_SHIFT);
+		__raw_writel(temp, CSI_TST_CTRL(csi));
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_test_generator);
+
+/*!
+ * _ipu_csi_ccir_err_detection_en
+ *	Enable error detection and correction for
+ *	CCIR interlaced mode with protection bit.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_ccir_err_detection_enable(uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(CSI_CCIR_CODE_1(csi));
+	temp |= CSI_CCIR_ERR_DET_EN;
+	__raw_writel(temp, CSI_CCIR_CODE_1(csi));
+}
+
+/*!
+ * _ipu_csi_ccir_err_detection_disable
+ *	Disable error detection and correction for
+ *	CCIR interlaced mode with protection bit.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_ccir_err_detection_disable(uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(CSI_CCIR_CODE_1(csi));
+	temp &= ~CSI_CCIR_ERR_DET_EN;
+	__raw_writel(temp, CSI_CCIR_CODE_1(csi));
+}
+
+/*!
+ * _ipu_csi_set_mipi_di
+ *
+ * @param	num	MIPI data identifier 0-3 handled by CSI
+ * @param	di_val	data identifier value
+ * @param	csi	csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_mipi_di(uint32_t num, uint32_t di_val, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (di_val > 0xFFL) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_MIPI_DI(csi));
+
+	switch (num) {
+	case IPU_CSI_MIPI_DI0:
+		temp &= ~CSI_MIPI_DI0_MASK;
+		temp |= (di_val << CSI_MIPI_DI0_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI1:
+		temp &= ~CSI_MIPI_DI1_MASK;
+		temp |= (di_val << CSI_MIPI_DI1_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI2:
+		temp &= ~CSI_MIPI_DI2_MASK;
+		temp |= (di_val << CSI_MIPI_DI2_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI3:
+		temp &= ~CSI_MIPI_DI3_MASK;
+		temp |= (di_val << CSI_MIPI_DI3_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_csi_set_skip_isp
+ *
+ * @param	skip		select frames to be skipped and set the
+ *				correspond bits to 1
+ * @param	max_ratio	number of frames in a skipping set and the
+ *				maximum value of max_ratio is 5
+ * @param	csi		csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_skip_isp(uint32_t skip, uint32_t max_ratio, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (max_ratio > 5) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_SKIP(csi));
+	temp &= ~(CSI_MAX_RATIO_SKIP_ISP_MASK | CSI_SKIP_ISP_MASK);
+	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_ISP_SHIFT) |
+		(skip << CSI_SKIP_ISP_SHIFT);
+	__raw_writel(temp, CSI_SKIP(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_csi_set_skip_smfc
+ *
+ * @param	skip		select frames to be skipped and set the
+ *				correspond bits to 1
+ * @param	max_ratio	number of frames in a skipping set and the
+ *				maximum value of max_ratio is 5
+ * @param	id		csi to smfc skipping id
+ * @param	csi		csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_skip_smfc(uint32_t skip, uint32_t max_ratio,
+	uint32_t id, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (max_ratio > 5 || id > 3) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_SKIP(csi));
+	temp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |
+			CSI_SKIP_SMFC_MASK);
+	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |
+			(id << CSI_ID_2_SKIP_SHIFT) |
+			(skip << CSI_SKIP_SMFC_SHIFT);
+	__raw_writel(temp, CSI_SKIP(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_smfc_init
+ *	Map CSI frames to IDMAC channels.
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	mipi_id		mipi id number 0-3
+ * @param	csi		csi0 or csi1
+ */
+void _ipu_smfc_init(ipu_channel_t channel, uint32_t mipi_id, uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(SMFC_MAP);
+
+	switch (channel) {
+	case CSI_MEM0:
+		temp &= ~SMFC_MAP_CH0_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH0_SHIFT;
+		break;
+	case CSI_MEM1:
+		temp &= ~SMFC_MAP_CH1_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH1_SHIFT;
+		break;
+	case CSI_MEM2:
+		temp &= ~SMFC_MAP_CH2_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH2_SHIFT;
+		break;
+	case CSI_MEM3:
+		temp &= ~SMFC_MAP_CH3_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH3_SHIFT;
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_MAP);
+}
+
+/*!
+ * _ipu_smfc_set_wmc
+ *	Caution: The number of required channels,  the enabled channels
+ *	and the FIFO size per channel are configured restrictedly.
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	set		set 1 or clear 0
+ * @param	level		water mark level when FIFO is on the
+ *				relative size
+ */
+void _ipu_smfc_set_wmc(ipu_channel_t channel, bool set, uint32_t level)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(SMFC_WMC);
+
+	switch (channel) {
+	case CSI_MEM0:
+		if (set == true) {
+			temp &= ~SMFC_WM0_SET_MASK;
+			temp |= level << SMFC_WM0_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM0_CLR_MASK;
+			temp |= level << SMFC_WM0_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM1:
+		if (set == true) {
+			temp &= ~SMFC_WM1_SET_MASK;
+			temp |= level << SMFC_WM1_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM1_CLR_MASK;
+			temp |= level << SMFC_WM1_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM2:
+		if (set == true) {
+			temp &= ~SMFC_WM2_SET_MASK;
+			temp |= level << SMFC_WM2_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM2_CLR_MASK;
+			temp |= level << SMFC_WM2_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM3:
+		if (set == true) {
+			temp &= ~SMFC_WM3_SET_MASK;
+			temp |= level << SMFC_WM3_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM3_CLR_MASK;
+			temp |= level << SMFC_WM3_CLR_SHIFT;
+		}
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_WMC);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_smfc_set_burst_size
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	bs		burst size of IDMAC channel,
+ *				the value programmed here shoud be BURST_SIZE-1
+ */
+void _ipu_smfc_set_burst_size(ipu_channel_t channel, uint32_t bs)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(SMFC_BS);
+
+	switch (channel) {
+	case CSI_MEM0:
+		temp &= ~SMFC_BS0_MASK;
+		temp |= bs << SMFC_BS0_SHIFT;
+		break;
+	case CSI_MEM1:
+		temp &= ~SMFC_BS1_MASK;
+		temp |= bs << SMFC_BS1_SHIFT;
+		break;
+	case CSI_MEM2:
+		temp &= ~SMFC_BS2_MASK;
+		temp |= bs << SMFC_BS2_SHIFT;
+		break;
+	case CSI_MEM3:
+		temp &= ~SMFC_BS3_MASK;
+		temp |= bs << SMFC_BS3_SHIFT;
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_BS);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_init
+ *
+ * @param	channel      IDMAC channel
+ * @param	csi	     csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_init(ipu_channel_t channel, uint32_t csi)
+{
+	uint32_t csi_sens_conf, csi_dest;
+	int retval = 0;
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		csi_dest = CSI_DATA_DEST_IDMAC;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case CSI_PRP_VF_MEM:
+		csi_dest = CSI_DATA_DEST_IC;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	csi_sens_conf = __raw_readl(CSI_SENS_CONF(csi));
+	csi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;
+	__raw_writel(csi_sens_conf | (csi_dest <<
+		CSI_SENS_CONF_DATA_DEST_SHIFT), CSI_SENS_CONF(csi));
+err:
+	return retval;
+}
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
new file mode 100644
index 0000000..29d0f76
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -0,0 +1,2468 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_common.c
+ *
+ * @brief This file contains the IPU driver common API functions.
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <asm/clkdev.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+struct ipu_irq_node {
+	irqreturn_t(*handler) (int, void *);	/*!< the ISR */
+	const char *name;	/*!< device associated with the interrupt */
+	void *dev_id;		/*!< some unique information for the ISR */
+	__u32 flags;		/*!< not used */
+};
+
+/* Globals */
+struct clk *g_ipu_clk;
+bool g_ipu_clk_enabled;
+struct clk *g_di_clk[2];
+struct clk *g_pixel_clk[2];
+struct clk *g_csi_clk[2];
+unsigned char g_dc_di_assignment[10];
+ipu_channel_t g_ipu_csi_channel[2];
+int g_ipu_irq[2];
+int g_ipu_hw_rev;
+bool g_sec_chan_en[22];
+bool g_thrd_chan_en[21];
+uint32_t g_channel_init_mask;
+uint32_t g_channel_enable_mask;
+DEFINE_SPINLOCK(ipu_lock);
+struct device *g_ipu_dev;
+
+static struct ipu_irq_node ipu_irq_list[IPU_IRQ_COUNT];
+static const char driver_name[] = "mxc_ipu";
+
+static int ipu_dc_use_count;
+static int ipu_dp_use_count;
+static int ipu_dmfc_use_count;
+static int ipu_smfc_use_count;
+static int ipu_ic_use_count;
+static int ipu_rot_use_count;
+static int ipu_vdi_use_count;
+static int ipu_di_use_count[2];
+static int ipu_csi_use_count[2];
+/* Set to the follow using IC direct channel, default non */
+static ipu_channel_t using_ic_dirct_ch;
+
+/* for power gating */
+static uint32_t ipu_conf_reg;
+static uint32_t ic_conf_reg;
+static uint32_t ipu_cha_db_mode_reg[4];
+static uint32_t ipu_cha_cur_buf_reg[4];
+static uint32_t idma_enable_reg[2];
+static uint32_t buf_ready_reg[8];
+
+u32 *ipu_cm_reg;
+u32 *ipu_idmac_reg;
+u32 *ipu_dp_reg;
+u32 *ipu_ic_reg;
+u32 *ipu_dc_reg;
+u32 *ipu_dc_tmpl_reg;
+u32 *ipu_dmfc_reg;
+u32 *ipu_di_reg[2];
+u32 *ipu_smfc_reg;
+u32 *ipu_csi_reg[2];
+u32 *ipu_cpmem_base;
+u32 *ipu_tpmem_base;
+u32 *ipu_disp_base[2];
+u32 *ipu_vdi_reg;
+
+/* Static functions */
+static irqreturn_t ipu_irq_handler(int irq, void *desc);
+
+static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
+{
+	return ((uint32_t) ch >> (6 * type)) & 0x3F;
+};
+
+static inline int _ipu_is_ic_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 11) && (dma_chan <= 22) && (dma_chan != 17) && (dma_chan != 18));
+}
+
+static inline int _ipu_is_ic_graphic_chan(uint32_t dma_chan)
+{
+	return (dma_chan == 14 || dma_chan == 15);
+}
+
+/* Either DP BG or DP FG can be graphic window */
+static inline int _ipu_is_dp_graphic_chan(uint32_t dma_chan)
+{
+	return (dma_chan == 23 || dma_chan == 27);
+}
+
+static inline int _ipu_is_irt_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 45) && (dma_chan <= 50));
+}
+
+static inline int _ipu_is_dmfc_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 23) && (dma_chan <= 29));
+}
+
+static inline int _ipu_is_smfc_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 0) && (dma_chan <= 3));
+}
+
+#define idma_is_valid(ch)	(ch != NO_DMA)
+#define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
+#define idma_is_set(reg, dma)	(__raw_readl(reg(dma)) & idma_mask(dma))
+
+static unsigned long _ipu_pixel_clk_getrate(struct clk *clk)
+{
+	u32 ret;
+	u32 div = __raw_readl(DI_BS_CLKGEN0(clk->id));
+	if (div == 0)
+		ret = 0;
+	else
+		ret = (clk_get_rate(clk->parent) * 16) / div;
+
+	return ret;
+}
+
+static unsigned long _ipu_pixel_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div, div1;
+	u32 tmp;
+	/*
+	 * Calculate divider
+	 * Fractional part is 4 bits,
+	 * so simply multiply by 2^4 to get fractional part.
+	 */
+	tmp = clk_get_rate(clk->parent) * 16;
+
+	div = tmp / rate;
+
+	if (div < 0x10)            /* Min DI disp clock divider is 1 */
+		div = 0x10;
+	if (div & ~0xFEF)
+		div &= 0xFF8;
+	else {
+		div1 = div & 0xFE0;
+		if ((tmp/div1 - tmp/div) < rate / 4)
+			div = div1;
+		else
+			div &= 0xFF8;
+	}
+
+	return (clk_get_rate(clk->parent) * 16) / div;
+}
+
+static int _ipu_pixel_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div = (clk_get_rate(clk->parent) * 16) / rate;
+
+	__raw_writel(div, DI_BS_CLKGEN0(clk->id));
+
+	/* Setup pixel clock timing */
+	/* FIXME: needs to be more flexible */
+	/* Down time is half of period */
+	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(clk->id));
+
+	return 0;
+}
+
+static int _ipu_pixel_clk_enable(struct clk *clk)
+{
+	u32 disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen |= clk->id ? DI1_COUNTER_RELEASE : DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	start_dvfs_per();
+
+	return 0;
+}
+
+static void _ipu_pixel_clk_disable(struct clk *clk)
+{
+	u32 disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen &= clk->id ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	start_dvfs_per();
+}
+
+static int _ipu_pixel_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 di_gen = __raw_readl(DI_GENERAL(clk->id));
+
+	if (parent == g_ipu_clk)
+		di_gen &= ~DI_GEN_DI_CLK_EXT;
+	else if (!IS_ERR(g_di_clk[clk->id]) && parent == g_di_clk[clk->id])
+		di_gen |= DI_GEN_DI_CLK_EXT;
+	else
+		return -EINVAL;
+
+	__raw_writel(di_gen, DI_GENERAL(clk->id));
+
+	return 0;
+}
+
+static struct clk pixel_clk[] = {
+	{
+	.id = 0,
+	.get_rate = _ipu_pixel_clk_getrate,
+	.set_rate = _ipu_pixel_clk_set_rate,
+	.round_rate = _ipu_pixel_clk_round_rate,
+	.set_parent = _ipu_pixel_clk_set_parent,
+	.enable = _ipu_pixel_clk_enable,
+	.disable = _ipu_pixel_clk_disable,
+	},
+	{
+	.id = 1,
+	.get_rate = _ipu_pixel_clk_getrate,
+	.set_rate = _ipu_pixel_clk_set_rate,
+	.round_rate = _ipu_pixel_clk_round_rate,
+	.set_parent = _ipu_pixel_clk_set_parent,
+	.enable = _ipu_pixel_clk_enable,
+	.disable = _ipu_pixel_clk_disable,
+	},
+};
+
+
+#define _REGISTER_CLOCK(d, n, c) \
+       { \
+		.dev_id = d, \
+		.con_id = n, \
+		.clk = &c,   \
+       },
+
+static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "pixel_clk.0", pixel_clk[0])
+	_REGISTER_CLOCK(NULL, "pixel_clk.1", pixel_clk[1])
+};
+
+/*!
+ * This function resets IPU
+ */
+void ipu_reset(void)
+{
+	u32 *reg;
+	u32 value;
+	reg = ioremap(SRC_BASE_ADDR, PAGE_SIZE);
+	value = __raw_readl(reg);
+	value = value | SW_IPU_RST;
+	__raw_writel(value, reg);
+	iounmap(reg);
+}
+EXPORT_SYMBOL(ipu_reset);
+
+/*!
+ * This function is called by the driver framework to initialize the IPU
+ * hardware.
+ *
+ * @param	dev	The device structure for the IPU passed in by the
+ *			driver framework.
+ *
+ * @return      Returns 0 on success or negative error code on error
+ */
+static int ipu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct mxc_ipu_config *plat_data = pdev->dev.platform_data;
+	unsigned long ipu_base;
+	int i;
+
+	spin_lock_init(&ipu_lock);
+
+	g_ipu_hw_rev = plat_data->rev;
+
+	g_ipu_dev = &pdev->dev;
+
+	/* Register IPU interrupts */
+	g_ipu_irq[0] = platform_get_irq(pdev, 0);
+	if (g_ipu_irq[0] < 0)
+		return -EINVAL;
+
+	if (request_irq(g_ipu_irq[0], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+		dev_err(g_ipu_dev, "request SYNC interrupt failed\n");
+		return -EBUSY;
+	}
+	/* Some platforms have 2 IPU interrupts */
+	g_ipu_irq[1] = platform_get_irq(pdev, 1);
+	if (g_ipu_irq[1] >= 0) {
+		if (request_irq
+		    (g_ipu_irq[1], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+			dev_err(g_ipu_dev, "request ERR interrupt failed\n");
+			return -EBUSY;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res))
+		return -ENODEV;
+
+	ipu_base = res->start;
+	ipu_cm_reg = ioremap(ipu_base + IPU_CM_REG_BASE, PAGE_SIZE);
+	ipu_ic_reg = ioremap(ipu_base + IPU_IC_REG_BASE, PAGE_SIZE);
+	ipu_idmac_reg = ioremap(ipu_base + IPU_IDMAC_REG_BASE, PAGE_SIZE);
+	/* DP Registers are accessed thru the SRM */
+	ipu_dp_reg = ioremap(ipu_base + IPU_SRM_REG_BASE, PAGE_SIZE);
+	ipu_dc_reg = ioremap(ipu_base + IPU_DC_REG_BASE, PAGE_SIZE);
+	ipu_dmfc_reg = ioremap(ipu_base + IPU_DMFC_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[0] = ioremap(ipu_base + IPU_DI0_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[1] = ioremap(ipu_base + IPU_DI1_REG_BASE, PAGE_SIZE);
+	ipu_smfc_reg = ioremap(ipu_base + IPU_SMFC_REG_BASE, PAGE_SIZE);
+	ipu_csi_reg[0] = ioremap(ipu_base + IPU_CSI0_REG_BASE, PAGE_SIZE);
+	ipu_csi_reg[1] = ioremap(ipu_base + IPU_CSI1_REG_BASE, PAGE_SIZE);
+	ipu_cpmem_base = ioremap(ipu_base + IPU_CPMEM_REG_BASE, PAGE_SIZE);
+	ipu_tpmem_base = ioremap(ipu_base + IPU_TPM_REG_BASE, SZ_64K);
+	ipu_dc_tmpl_reg = ioremap(ipu_base + IPU_DC_TMPL_REG_BASE, SZ_128K);
+	ipu_disp_base[1] = ioremap(ipu_base + IPU_DISP1_BASE, SZ_4K);
+	ipu_vdi_reg = ioremap(ipu_base + IPU_VDI_REG_BASE, PAGE_SIZE);
+
+	dev_dbg(g_ipu_dev, "IPU VDI Regs = %p\n", ipu_vdi_reg);
+	dev_dbg(g_ipu_dev, "IPU CM Regs = %p\n", ipu_cm_reg);
+	dev_dbg(g_ipu_dev, "IPU IC Regs = %p\n", ipu_ic_reg);
+	dev_dbg(g_ipu_dev, "IPU IDMAC Regs = %p\n", ipu_idmac_reg);
+	dev_dbg(g_ipu_dev, "IPU DP Regs = %p\n", ipu_dp_reg);
+	dev_dbg(g_ipu_dev, "IPU DC Regs = %p\n", ipu_dc_reg);
+	dev_dbg(g_ipu_dev, "IPU DMFC Regs = %p\n", ipu_dmfc_reg);
+	dev_dbg(g_ipu_dev, "IPU DI0 Regs = %p\n", ipu_di_reg[0]);
+	dev_dbg(g_ipu_dev, "IPU DI1 Regs = %p\n", ipu_di_reg[1]);
+	dev_dbg(g_ipu_dev, "IPU SMFC Regs = %p\n", ipu_smfc_reg);
+	dev_dbg(g_ipu_dev, "IPU CSI0 Regs = %p\n", ipu_csi_reg[0]);
+	dev_dbg(g_ipu_dev, "IPU CSI1 Regs = %p\n", ipu_csi_reg[1]);
+	dev_dbg(g_ipu_dev, "IPU CPMem = %p\n", ipu_cpmem_base);
+	dev_dbg(g_ipu_dev, "IPU TPMem = %p\n", ipu_tpmem_base);
+	dev_dbg(g_ipu_dev, "IPU DC Template Mem = %p\n", ipu_dc_tmpl_reg);
+	dev_dbg(g_ipu_dev, "IPU Display Region 1 Mem = %p\n", ipu_disp_base[1]);
+
+	g_pixel_clk[0] = &pixel_clk[0];
+	g_pixel_clk[1] = &pixel_clk[1];
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
+	/* Enable IPU and CSI clocks */
+	/* Get IPU clock freq */
+	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
+	dev_dbg(g_ipu_dev, "ipu_clk = %lu\n", clk_get_rate(g_ipu_clk));
+
+	ipu_reset();
+
+	clk_set_parent(g_pixel_clk[0], g_ipu_clk);
+	clk_set_parent(g_pixel_clk[1], g_ipu_clk);
+	clk_enable(g_ipu_clk);
+
+	g_di_clk[0] = plat_data->di_clk[0];
+	g_di_clk[1] = plat_data->di_clk[1];
+
+	g_csi_clk[0] = clk_get(&pdev->dev, "csi_mclk1");
+	g_csi_clk[1] = clk_get(&pdev->dev, "csi_mclk2");
+
+	__raw_writel(0x807FFFFF, IPU_MEM_RST);
+	while (__raw_readl(IPU_MEM_RST) & 0x80000000)
+		;
+	_ipu_init_dc_mappings();
+
+	/* Enable error interrupts by default */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	/* DMFC Init */
+	_ipu_dmfc_init(DMFC_NORMAL, 1);
+
+	/* Set sync refresh channels as high priority */
+	__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
+
+	/* Set MCU_T to divide MCU access window into 2 */
+	__raw_writel(0x00400000L | (IPU_MCU_T_DEFAULT << 18), IPU_DISP_GEN);
+
+	clk_disable(g_ipu_clk);
+
+	register_ipu_device();
+
+	return 0;
+}
+
+int ipu_remove(struct platform_device *pdev)
+{
+	if (g_ipu_irq[0])
+		free_irq(g_ipu_irq[0], 0);
+	if (g_ipu_irq[1])
+		free_irq(g_ipu_irq[1], 0);
+
+	clk_put(g_ipu_clk);
+
+	iounmap(ipu_cm_reg);
+	iounmap(ipu_ic_reg);
+	iounmap(ipu_idmac_reg);
+	iounmap(ipu_dc_reg);
+	iounmap(ipu_dp_reg);
+	iounmap(ipu_dmfc_reg);
+	iounmap(ipu_di_reg[0]);
+	iounmap(ipu_di_reg[1]);
+	iounmap(ipu_smfc_reg);
+	iounmap(ipu_csi_reg[0]);
+	iounmap(ipu_csi_reg[1]);
+	iounmap(ipu_cpmem_base);
+	iounmap(ipu_tpmem_base);
+	iounmap(ipu_dc_tmpl_reg);
+	iounmap(ipu_disp_base[1]);
+	iounmap(ipu_vdi_reg);
+
+	return 0;
+}
+
+void ipu_dump_registers(void)
+{
+	printk(KERN_DEBUG "IPU_CONF = \t0x%08X\n", __raw_readl(IPU_CONF));
+	printk(KERN_DEBUG "IDMAC_CONF = \t0x%08X\n", __raw_readl(IDMAC_CONF));
+	printk(KERN_DEBUG "IDMAC_CHA_EN1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_EN(0)));
+	printk(KERN_DEBUG "IDMAC_CHA_EN2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_EN(32)));
+	printk(KERN_DEBUG "IDMAC_CHA_PRI1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_PRI(0)));
+	printk(KERN_DEBUG "IDMAC_CHA_PRI2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_PRI(32)));
+	printk(KERN_DEBUG "IDMAC_BAND_EN1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_BAND_EN(0)));
+	printk(KERN_DEBUG "IDMAC_BAND_EN2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_BAND_EN(32)));
+	printk(KERN_DEBUG "IPU_CHA_DB_MODE_SEL0 = \t0x%08X\n",
+	       __raw_readl(IPU_CHA_DB_MODE_SEL(0)));
+	printk(KERN_DEBUG "IPU_CHA_DB_MODE_SEL1 = \t0x%08X\n",
+	       __raw_readl(IPU_CHA_DB_MODE_SEL(32)));
+	printk(KERN_DEBUG "DMFC_WR_CHAN = \t0x%08X\n",
+	       __raw_readl(DMFC_WR_CHAN));
+	printk(KERN_DEBUG "DMFC_WR_CHAN_DEF = \t0x%08X\n",
+	       __raw_readl(DMFC_WR_CHAN_DEF));
+	printk(KERN_DEBUG "DMFC_DP_CHAN = \t0x%08X\n",
+	       __raw_readl(DMFC_DP_CHAN));
+	printk(KERN_DEBUG "DMFC_DP_CHAN_DEF = \t0x%08X\n",
+	       __raw_readl(DMFC_DP_CHAN_DEF));
+	printk(KERN_DEBUG "DMFC_IC_CTRL = \t0x%08X\n",
+	       __raw_readl(DMFC_IC_CTRL));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW1 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW1));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW2 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW2));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW3 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW3));
+	printk(KERN_DEBUG "IPU_FS_DISP_FLOW1 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_DISP_FLOW1));
+}
+
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	int ret = 0;
+	uint32_t ipu_conf;
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	/* re-enable error interrupts every time a channel is initialized */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	if (g_ipu_clk_enabled == false) {
+		stop_dvfs_per();
+		g_ipu_clk_enabled = true;
+		clk_enable(g_ipu_clk);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_err(g_ipu_dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	ipu_conf = __raw_readl(IPU_CONF);
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		if (params->csi_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu_smfc_use_count++;
+		ipu_csi_use_count[params->csi_mem.csi]++;
+		g_ipu_csi_channel[params->csi_mem.csi] = channel;
+
+		/*SMFC setting*/
+		if (params->csi_mem.mipi_en) {
+			ipu_conf |= (1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+				params->csi_mem.csi));
+			_ipu_smfc_init(channel, params->csi_mem.mipi_id,
+				params->csi_mem.csi);
+		} else {
+			ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+				params->csi_mem.csi));
+			_ipu_smfc_init(channel, 0, params->csi_mem.csi);
+		}
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_mem.csi);
+		break;
+	case CSI_PRP_ENC_MEM:
+		if (params->csi_prp_enc_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+		if (using_ic_dirct_ch == MEM_VDI_PRP_VF_MEM) {
+			ret = -EINVAL;
+			goto err;
+		}
+		using_ic_dirct_ch = CSI_PRP_ENC_MEM;
+
+		ipu_ic_use_count++;
+		ipu_csi_use_count[params->csi_prp_enc_mem.csi]++;
+		g_ipu_csi_channel[params->csi_prp_enc_mem.csi] = channel;
+
+		/*Without SMFC, CSI only support parallel data source*/
+		ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+			params->csi_prp_enc_mem.csi));
+
+		/*CSI0/1 feed into IC*/
+		ipu_conf &= ~IPU_CONF_IC_INPUT;
+		if (params->csi_prp_enc_mem.csi)
+			ipu_conf |= IPU_CONF_CSI_SEL;
+		else
+			ipu_conf &= ~IPU_CONF_CSI_SEL;
+
+		/*PRP skip buffer in memory, only valid when RWS_EN is true*/
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_prp_enc_mem.csi);
+		_ipu_ic_init_prpenc(params, true);
+		break;
+	case CSI_PRP_VF_MEM:
+		if (params->csi_prp_vf_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+		if (using_ic_dirct_ch == MEM_VDI_PRP_VF_MEM) {
+			ret = -EINVAL;
+			goto err;
+		}
+		using_ic_dirct_ch = CSI_PRP_VF_MEM;
+
+		ipu_ic_use_count++;
+		ipu_csi_use_count[params->csi_prp_vf_mem.csi]++;
+		g_ipu_csi_channel[params->csi_prp_vf_mem.csi] = channel;
+
+		/*Without SMFC, CSI only support parallel data source*/
+		ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+			params->csi_prp_vf_mem.csi));
+
+		/*CSI0/1 feed into IC*/
+		ipu_conf &= ~IPU_CONF_IC_INPUT;
+		if (params->csi_prp_vf_mem.csi)
+			ipu_conf |= IPU_CONF_CSI_SEL;
+		else
+			ipu_conf &= ~IPU_CONF_CSI_SEL;
+
+		/*PRP skip buffer in memory, only valid when RWS_EN is true*/
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_prp_vf_mem.csi);
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		if (params->mem_prp_vf_mem.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, false);
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		if ((using_ic_dirct_ch == CSI_PRP_VF_MEM) ||
+		     (using_ic_dirct_ch == CSI_PRP_ENC_MEM)) {
+			ret = -EINVAL;
+			goto err;
+		}
+		using_ic_dirct_ch = MEM_VDI_PRP_VF_MEM;
+		ipu_ic_use_count++;
+		ipu_vdi_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		reg &= ~FS_VDI_SRC_SEL_MASK;
+		__raw_writel(reg , IPU_FS_PROC_FLOW1);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		_ipu_ic_init_prpvf(params, false);
+		_ipu_vdi_init(channel, params);
+		break;
+	case MEM_VDI_PRP_VF_MEM_P:
+		_ipu_vdi_init(channel, params);
+		break;
+	case MEM_VDI_PRP_VF_MEM_N:
+		_ipu_vdi_init(channel, params);
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_vf(params);
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+		_ipu_ic_init_prpenc(params, false);
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_enc(params);
+		break;
+	case MEM_PP_MEM:
+		if (params->mem_pp_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		if (params->mem_pp_mem.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+		_ipu_ic_init_pp(params);
+		ipu_ic_use_count++;
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_init_rotate_pp(params);
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		break;
+	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[1] = params->mem_dc_sync.di;
+		_ipu_dc_init(1, params->mem_dc_sync.di,
+			     params->mem_dc_sync.interlaced);
+		ipu_di_use_count[params->mem_dc_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		if (params->mem_dp_bg_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (params->mem_dp_bg_sync.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		g_dc_di_assignment[5] = params->mem_dp_bg_sync.di;
+		_ipu_dp_init(channel, params->mem_dp_bg_sync.in_pixel_fmt,
+			     params->mem_dp_bg_sync.out_pixel_fmt);
+		_ipu_dc_init(5, params->mem_dp_bg_sync.di,
+			     params->mem_dp_bg_sync.interlaced);
+		ipu_di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+
+		if (params->mem_dp_fg_sync.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case DIRECT_ASYNC0:
+		if (params->direct_async.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[8] = params->direct_async.di;
+		_ipu_dc_init(8, params->direct_async.di, false);
+		ipu_di_use_count[params->direct_async.di]++;
+		ipu_dc_use_count++;
+		break;
+	case DIRECT_ASYNC1:
+		if (params->direct_async.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[9] = params->direct_async.di;
+		_ipu_dc_init(9, params->direct_async.di, false);
+		ipu_di_use_count[params->direct_async.di]++;
+		ipu_dc_use_count++;
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	/* Enable IPU sub module */
+	g_channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+	if (ipu_ic_use_count == 1)
+		ipu_conf |= IPU_CONF_IC_EN;
+	if (ipu_vdi_use_count == 1) {
+		ipu_conf |= IPU_CONF_VDI_EN;
+		ipu_conf |= IPU_CONF_IC_INPUT;
+	}
+	if (ipu_rot_use_count == 1)
+		ipu_conf |= IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 1)
+		ipu_conf |= IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 1)
+		ipu_conf |= IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 1)
+		ipu_conf |= IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 1)
+		ipu_conf |= IPU_CONF_DI0_EN;
+
+	if (ipu_di_use_count[1] == 1)
+		ipu_conf |= IPU_CONF_DI1_EN;
+
+	if (ipu_smfc_use_count == 1)
+		ipu_conf |= IPU_CONF_SMFC_EN;
+	if (ipu_csi_use_count[0] == 1)
+		ipu_conf |= IPU_CONF_CSI0_EN;
+	if (ipu_csi_use_count[1] == 1)
+		ipu_conf |= IPU_CONF_CSI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_init_channel);
+
+/*!
+ * This function is called to uninitialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to uninit.
+ */
+void ipu_uninit_channel(ipu_channel_t channel)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t in_dma, out_dma = 0;
+	uint32_t ipu_conf;
+
+	if ((g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already uninitialized %d\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	/* Make sure channel is disabled */
+	/* Get input and output dma channels */
+	in_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	out_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if (idma_is_set(IDMAC_CHA_EN, in_dma) ||
+	    idma_is_set(IDMAC_CHA_EN, out_dma)) {
+		dev_err(g_ipu_dev,
+			"Channel %d is not disabled, disable first\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	ipu_conf = __raw_readl(IPU_CONF);
+
+	/* Reset the double buffer */
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(in_dma));
+	__raw_writel(reg & ~idma_mask(in_dma), IPU_CHA_DB_MODE_SEL(in_dma));
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(out_dma));
+	__raw_writel(reg & ~idma_mask(out_dma), IPU_CHA_DB_MODE_SEL(out_dma));
+
+	g_sec_chan_en[IPU_CHAN_ID(channel)] = false;
+	g_thrd_chan_en[IPU_CHAN_ID(channel)] = false;
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		ipu_smfc_use_count--;
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case CSI_PRP_ENC_MEM:
+		ipu_ic_use_count--;
+		if (using_ic_dirct_ch == CSI_PRP_ENC_MEM)
+			using_ic_dirct_ch = 0;
+		_ipu_ic_uninit_prpenc();
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case CSI_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		if (using_ic_dirct_ch == CSI_PRP_VF_MEM)
+			using_ic_dirct_ch = 0;
+		_ipu_ic_uninit_prpvf();
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpvf();
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		ipu_vdi_use_count--;
+		if (using_ic_dirct_ch == MEM_VDI_PRP_VF_MEM)
+			using_ic_dirct_ch = 0;
+		_ipu_ic_uninit_prpvf();
+		_ipu_vdi_uninit();
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_vf();
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpenc();
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_enc();
+		break;
+	case MEM_PP_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_pp();
+		break;
+	case MEM_ROT_PP_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_pp();
+		break;
+	case MEM_DC_SYNC:
+		_ipu_dc_uninit(1);
+		ipu_di_use_count[g_dc_di_assignment[1]]--;
+		ipu_dc_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_BG_SYNC:
+		_ipu_dp_uninit(channel);
+		_ipu_dc_uninit(5);
+		ipu_di_use_count[g_dc_di_assignment[5]]--;
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_uninit(channel);
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case DIRECT_ASYNC0:
+		_ipu_dc_uninit(8);
+		ipu_di_use_count[g_dc_di_assignment[8]]--;
+		ipu_dc_use_count--;
+		break;
+	case DIRECT_ASYNC1:
+		_ipu_dc_uninit(9);
+		ipu_di_use_count[g_dc_di_assignment[9]]--;
+		ipu_dc_use_count--;
+		break;
+	default:
+		break;
+	}
+
+	g_channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	if (ipu_ic_use_count == 0)
+		ipu_conf &= ~IPU_CONF_IC_EN;
+	if (ipu_vdi_use_count == 0) {
+		ipu_conf &= ~IPU_CONF_VDI_EN;
+		ipu_conf &= ~IPU_CONF_IC_INPUT;
+	}
+	if (ipu_rot_use_count == 0)
+		ipu_conf &= ~IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 0)
+		ipu_conf &= ~IPU_CONF_DI0_EN;
+
+	if (ipu_di_use_count[1] == 0)
+		ipu_conf &= ~IPU_CONF_DI1_EN;
+
+	if (ipu_smfc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_SMFC_EN;
+	if (ipu_csi_use_count[0] == 0)
+		ipu_conf &= ~IPU_CONF_CSI0_EN;
+	if (ipu_csi_use_count[1] == 0)
+		ipu_conf &= ~IPU_CONF_CSI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	if (ipu_conf == 0) {
+		clk_disable(g_ipu_clk);
+		g_ipu_clk_enabled = false;
+	}
+
+	WARN_ON(ipu_ic_use_count < 0);
+	WARN_ON(ipu_vdi_use_count < 0);
+	WARN_ON(ipu_rot_use_count < 0);
+	WARN_ON(ipu_dc_use_count < 0);
+	WARN_ON(ipu_dp_use_count < 0);
+	WARN_ON(ipu_dmfc_use_count < 0);
+	WARN_ON(ipu_smfc_use_count < 0);
+}
+EXPORT_SYMBOL(ipu_uninit_channel);
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u, uint32_t v)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(g_ipu_dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC & IRT channels' width must be multiple of 8 pixels */
+	if ((_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan))
+		&& (width % 8)) {
+		dev_err(g_ipu_dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1);
+
+	/* Set correlative channel parameter of local alpha channel */
+	if ((_ipu_is_ic_graphic_chan(dma_chan) ||
+	     _ipu_is_dp_graphic_chan(dma_chan)) &&
+	    (g_thrd_chan_en[IPU_CHAN_ID(channel)] == true)) {
+		_ipu_ch_param_set_alpha_use_separate_channel(dma_chan, true);
+		_ipu_ch_param_set_alpha_buffer_memory(dma_chan);
+		_ipu_ch_param_set_alpha_condition_read(dma_chan);
+		/* fix alpha width as 8 and burst size as 16*/
+		_ipu_ch_params_set_alpha_width(dma_chan, 8);
+		_ipu_ch_param_set_burst_size(dma_chan, 16);
+	} else if (_ipu_is_ic_graphic_chan(dma_chan) &&
+		   ipu_pixel_format_has_alpha(pixel_fmt))
+		_ipu_ch_param_set_alpha_use_separate_channel(dma_chan, false);
+
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if (_ipu_is_ic_chan(dma_chan)) {
+		if ((width % 16) == 0)
+			_ipu_ch_param_set_burst_size(dma_chan, 16);
+		else
+			_ipu_ch_param_set_burst_size(dma_chan, 8);
+	} else if (_ipu_is_irt_chan(dma_chan)) {
+		_ipu_ch_param_set_burst_size(dma_chan, 8);
+		_ipu_ch_param_set_block_mode(dma_chan);
+	} else if (_ipu_is_dmfc_chan(dma_chan)) {
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		_ipu_dmfc_set_wait4eot(dma_chan, width);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	}
+
+	if (_ipu_chan_is_interlaced(channel))
+		_ipu_ch_param_set_interlaced_scan(dma_chan);
+
+
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(dma_chan);
+		_ipu_ic_idma_init(dma_chan, width, height, burst_size,
+			rot_mode);
+	} else if (_ipu_is_smfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(dma_chan);
+		if ((pixel_fmt == IPU_PIX_FMT_GENERIC) &&
+			((_ipu_ch_param_get_bpp(dma_chan) == 5) ||
+			(_ipu_ch_param_get_bpp(dma_chan) == 3)))
+			burst_size = burst_size >> 4;
+		else
+			burst_size = burst_size >> 2;
+		_ipu_smfc_set_burst_size(channel, burst_size-1);
+	}
+
+	if (idma_is_set(IDMAC_CHA_PRI, dma_chan))
+		_ipu_ch_param_set_high_priority(dma_chan);
+
+	_ipu_ch_param_dump(dma_chan);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(dma_chan));
+	if (phyaddr_1)
+		reg |= idma_mask(dma_chan);
+	else
+		reg &= ~idma_mask(dma_chan);
+	__raw_writel(reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+	/* Reset to buffer 0 */
+	__raw_writel(idma_mask(dma_chan), IPU_CHA_CUR_BUF(dma_chan));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer);
+
+/*!
+ * This function is called to update the physical address of a buffer for
+ * a logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for buffer number to update.
+ *                              0 or 1 are the only valid values.
+ *
+ * @param       phyaddr         Input parameter buffer physical address.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail. This function will fail if the buffer is set to ready.
+ */
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr)
+{
+	uint32_t reg;
+	int ret = 0;
+	unsigned long lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bufNum == 0)
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+	else
+		reg = __raw_readl(IPU_CHA_BUF1_RDY(dma_chan));
+
+	if ((reg & idma_mask(dma_chan)) == 0)
+		_ipu_ch_param_set_buffer(dma_chan, bufNum, phyaddr);
+	else
+		ret = -EACCES;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_update_channel_buffer);
+
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       u		predefined private u offset for additional cropping,
+ *								zero if not used.
+ *
+ * @param       v		predefined private v offset for additional cropping,
+ *								zero if not used.
+ *
+ * @param			vertical_offset vertical offset for Y coordinate
+ *								in the existed frame
+ *
+ *
+ * @param			horizontal_offset horizontal offset for X coordinate
+ *								in the existed frame
+ *
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ *              This function will fail if any buffer is set to ready.
+ */
+
+int32_t ipu_update_channel_offset(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				uint32_t u, uint32_t v,
+				uint32_t vertical_offset, uint32_t horizontal_offset)
+{
+	int ret = 0;
+	unsigned long lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if ((__raw_readl(IPU_CHA_BUF0_RDY(dma_chan)) & idma_mask(dma_chan)) ||
+		(__raw_readl(IPU_CHA_BUF0_RDY(dma_chan)) & idma_mask(dma_chan)))
+		ret = -EACCES;
+	else
+		_ipu_ch_offset_update(dma_chan, pixel_fmt, width, height, stride,
+				      u, v, 0, vertical_offset, horizontal_offset);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_update_channel_offset);
+
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_buffer(ipu_channel_t channel, ipu_buffer_t type,
+			  uint32_t bufNum)
+{
+	uint32_t dma_chan = channel_2_dma(channel, type);
+	uint32_t reg;
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+		__raw_writel(idma_mask(dma_chan) | reg,
+			     IPU_CHA_BUF0_RDY(dma_chan));
+	} else {
+		/*Mark buffer 1 as ready. */
+		reg = __raw_readl(IPU_CHA_BUF1_RDY(dma_chan));
+		__raw_writel(idma_mask(dma_chan) | reg,
+			     IPU_CHA_BUF1_RDY(dma_chan));
+	}
+	if (channel == MEM_VDI_PRP_VF_MEM)
+		_ipu_vdi_toggle_top_field_man();
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_buffer);
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_multi_vdi_buffer(uint32_t bufNum)
+{
+
+	uint32_t dma_chan = channel_2_dma(MEM_VDI_PRP_VF_MEM, IPU_INPUT_BUFFER);
+	uint32_t mask_bit =
+		idma_mask(channel_2_dma(MEM_VDI_PRP_VF_MEM_P, IPU_INPUT_BUFFER))|
+		idma_mask(dma_chan)|
+		idma_mask(channel_2_dma(MEM_VDI_PRP_VF_MEM_N, IPU_INPUT_BUFFER));
+	uint32_t reg;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+		__raw_writel(mask_bit | reg, IPU_CHA_BUF0_RDY(dma_chan));
+	} else {
+		/*Mark buffer 1 as ready. */
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+		__raw_writel(mask_bit | reg, IPU_CHA_BUF1_RDY(dma_chan));
+	}
+	_ipu_vdi_toggle_top_field_man();
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_multi_vdi_buffer);
+
+#define NA	-1
+static int proc_dest_sel[] = {
+    0, 1, 1, 3, 5, 5, 4, 7, 8, 9, 10, 11, 12, 14, 15, 16,
+    0, 1, 1, 5, 5, 5, 5, 5, 7, 8, 9, 10, 11, 12, 14, 31 };
+static int proc_src_sel[] = { 0, 6, 7, 6, 7, 8, 5, NA, NA, NA,
+  NA, NA, NA, NA, NA,  1,  2,  3,  4,  7,  8, NA, NA, NA };
+static int disp_src_sel[] = { 0, 6, 7, 8, 3, 4, 5, NA, NA, NA,
+  NA, NA, NA, NA, NA,  1, NA,  2, NA,  3,  4,  4,  4,  4 };
+
+
+/*!
+ * This function links 2 channels together for automatic frame
+ * synchronization. The output of the source channel is linked to the input of
+ * the destination channel.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_proc_flow3;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_proc_flow3 = __raw_readl(IPU_FS_PROC_FLOW3);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case CSI_MEM0:
+		fs_proc_flow3 &= ~FS_SMFC0_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC0_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM1:
+		fs_proc_flow3 &= ~FS_SMFC1_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC1_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM2:
+		fs_proc_flow3 &= ~FS_SMFC2_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC2_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM3:
+		fs_proc_flow3 &= ~FS_SMFC3_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC3_DEST_SEL_OFFSET;
+		break;
+	case CSI_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_PRPENC_DEST_SEL_OFFSET;
+		break;
+	case CSI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_PRPVF_DEST_SEL_OFFSET;
+		break;
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_ROT_DEST_SEL_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPENC_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPENC_ROT_DEST_SEL_OFFSET;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPVF_DEST_SEL_OFFSET;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPVF_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPVF_ROT_DEST_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PP_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PRP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRPENC_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PRPENC_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PRP_SRC_SEL_OFFSET;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PRP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRPVF_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PRPVF_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] << FS_DC1_SRC_SEL_OFFSET;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC0_SRC_SEL_OFFSET;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC1_SRC_SEL_OFFSET;
+		break;
+	case MEM_DC_ASYNC:
+		fs_disp_flow1 &= ~FS_DC2_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] << FS_DC2_SRC_SEL_OFFSET;
+		break;
+	case MEM_BG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC0_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_ASYNC0_SRC_SEL_OFFSET;
+		break;
+	case MEM_FG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_ASYNC1_SRC_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_proc_flow3, IPU_FS_PROC_FLOW3);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_link_channels);
+
+/*!
+ * This function unlinks 2 channels and disables automatic frame
+ * synchronization.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_proc_flow3;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_proc_flow3 = __raw_readl(IPU_FS_PROC_FLOW3);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case CSI_MEM0:
+		fs_proc_flow3 &= ~FS_SMFC0_DEST_SEL_MASK;
+		break;
+	case CSI_MEM1:
+		fs_proc_flow3 &= ~FS_SMFC1_DEST_SEL_MASK;
+		break;
+	case CSI_MEM2:
+		fs_proc_flow3 &= ~FS_SMFC2_DEST_SEL_MASK;
+		break;
+	case CSI_MEM3:
+		fs_proc_flow3 &= ~FS_SMFC3_DEST_SEL_MASK;
+		break;
+	case CSI_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		break;
+	case CSI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_ROT_DEST_SEL_MASK;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRPENC_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRPVF_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		break;
+	case MEM_DC_ASYNC:
+		fs_disp_flow1 &= ~FS_DC2_SRC_SEL_MASK;
+		break;
+	case MEM_BG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC0_SRC_SEL_MASK;
+		break;
+	case MEM_FG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC1_SRC_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_proc_flow3, IPU_FS_PROC_FLOW3);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_unlink_channels);
+
+/*!
+ * This function check whether a logical channel was enabled.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 1 while request channel is enabled or
+ *              0 for not enabled.
+ */
+int32_t ipu_is_channel_busy(ipu_channel_t channel)
+{
+	uint32_t reg;
+	uint32_t in_dma;
+	uint32_t out_dma;
+
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+	if (reg & idma_mask(in_dma))
+		return 1;
+	reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+	if (reg & idma_mask(out_dma))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(ipu_is_channel_busy);
+
+/*!
+ * This function enables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_enable_channel(ipu_channel_t channel)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t sec_dma;
+	uint32_t thrd_dma;
+
+	if (g_channel_enable_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_err(g_ipu_dev, "Warning: channel already enabled %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg | idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg | idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+	}
+
+	if ((g_sec_chan_en[IPU_CHAN_ID(channel)]) &&
+		((channel == MEM_PP_MEM) || (channel == MEM_PRP_VF_MEM) ||
+		 (channel == MEM_VDI_PRP_VF_MEM))) {
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+		reg = __raw_readl(IDMAC_CHA_EN(sec_dma));
+		__raw_writel(reg | idma_mask(sec_dma), IDMAC_CHA_EN(sec_dma));
+	}
+	if ((g_thrd_chan_en[IPU_CHAN_ID(channel)]) &&
+		((channel == MEM_PP_MEM) || (channel == MEM_PRP_VF_MEM))) {
+		thrd_dma = channel_2_dma(channel, IPU_ALPHA_IN_BUFFER);
+		reg = __raw_readl(IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(reg | idma_mask(thrd_dma), IDMAC_CHA_EN(thrd_dma));
+
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+		reg = __raw_readl(IDMAC_SEP_ALPHA);
+		__raw_writel(reg | idma_mask(sec_dma), IDMAC_SEP_ALPHA);
+	} else if ((g_thrd_chan_en[IPU_CHAN_ID(channel)]) &&
+		   ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC))) {
+		thrd_dma = channel_2_dma(channel, IPU_ALPHA_IN_BUFFER);
+		reg = __raw_readl(IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(reg | idma_mask(thrd_dma), IDMAC_CHA_EN(thrd_dma));
+		reg = __raw_readl(IDMAC_SEP_ALPHA);
+		__raw_writel(reg | idma_mask(in_dma), IDMAC_SEP_ALPHA);
+	}
+
+	if ((channel == MEM_DC_SYNC) || (channel == MEM_BG_SYNC) ||
+	    (channel == MEM_FG_SYNC))
+		_ipu_dp_dc_enable(channel);
+
+	if (_ipu_is_ic_chan(in_dma) || _ipu_is_ic_chan(out_dma) ||
+		_ipu_is_irt_chan(in_dma) || _ipu_is_irt_chan(out_dma))
+		_ipu_ic_enable_task(channel);
+
+	g_channel_enable_mask |= 1L << IPU_CHAN_ID(channel);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_enable_channel);
+
+static irqreturn_t disable_chan_irq_handler(int irq, void *dev_id)
+{
+	struct completion *comp = dev_id;
+
+	complete(comp);
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function disables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       wait_for_stop   Flag to set whether to wait for channel end
+ *                              of frame or return immediately.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t sec_dma = NO_DMA;
+	uint32_t thrd_dma = NO_DMA;
+
+	if ((g_channel_enable_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already disabled %d\n",
+			IPU_CHAN_ID(channel));
+		return 0;
+	}
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if ((idma_is_valid(in_dma) &&
+		!idma_is_set(IDMAC_CHA_EN, in_dma))
+		&& (idma_is_valid(out_dma) &&
+		!idma_is_set(IDMAC_CHA_EN, out_dma)))
+		return -EINVAL;
+
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)])
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)]) {
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+		thrd_dma = channel_2_dma(channel, IPU_ALPHA_IN_BUFFER);
+	}
+
+	if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC) ||
+	    (channel == MEM_DC_SYNC)) {
+		_ipu_dp_dc_disable(channel, false);
+	} else if (wait_for_stop) {
+		while (idma_is_set(IDMAC_CHA_BUSY, in_dma) ||
+		       idma_is_set(IDMAC_CHA_BUSY, out_dma) ||
+			(g_sec_chan_en[IPU_CHAN_ID(channel)] &&
+			idma_is_set(IDMAC_CHA_BUSY, sec_dma)) ||
+			(g_thrd_chan_en[IPU_CHAN_ID(channel)] &&
+			idma_is_set(IDMAC_CHA_BUSY, thrd_dma))) {
+			uint32_t ret, irq = 0xffffffff;
+			DECLARE_COMPLETION_ONSTACK(disable_comp);
+
+			if (idma_is_set(IDMAC_CHA_BUSY, out_dma))
+				irq = out_dma;
+			if (g_sec_chan_en[IPU_CHAN_ID(channel)] &&
+				idma_is_set(IDMAC_CHA_BUSY, sec_dma))
+				irq = sec_dma;
+			if (g_thrd_chan_en[IPU_CHAN_ID(channel)] &&
+				idma_is_set(IDMAC_CHA_BUSY, thrd_dma))
+				irq = thrd_dma;
+			if (idma_is_set(IDMAC_CHA_BUSY, in_dma))
+				irq = in_dma;
+
+			if (irq == 0xffffffff) {
+				dev_err(g_ipu_dev, "warning: no channel busy, break\n");
+				break;
+			}
+			ret = ipu_request_irq(irq, disable_chan_irq_handler, 0, NULL, &disable_comp);
+			if (ret < 0) {
+				dev_err(g_ipu_dev, "irq %d in use\n", irq);
+				break;
+			} else {
+				ret = wait_for_completion_timeout(&disable_comp, msecs_to_jiffies(200));
+				ipu_free_irq(irq, &disable_comp);
+				if (ret == 0) {
+					ipu_dump_registers();
+					dev_err(g_ipu_dev, "warning: disable ipu dma channel %d during its busy state\n", irq);
+					break;
+				}
+			}
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Disable IC task */
+	if (_ipu_is_ic_chan(in_dma) || _ipu_is_ic_chan(out_dma) ||
+		_ipu_is_irt_chan(in_dma) || _ipu_is_irt_chan(out_dma))
+		_ipu_ic_disable_task(channel);
+
+	/* Disable DMA channel(s) */
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg & ~idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+		__raw_writel(idma_mask(in_dma), IPU_CHA_CUR_BUF(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg & ~idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+		__raw_writel(idma_mask(out_dma), IPU_CHA_CUR_BUF(out_dma));
+	}
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(sec_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(sec_dma));
+		__raw_writel(reg & ~idma_mask(sec_dma), IDMAC_CHA_EN(sec_dma));
+		__raw_writel(idma_mask(sec_dma), IPU_CHA_CUR_BUF(sec_dma));
+	}
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(thrd_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(reg & ~idma_mask(thrd_dma), IDMAC_CHA_EN(thrd_dma));
+		if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC) {
+			reg = __raw_readl(IDMAC_SEP_ALPHA);
+			__raw_writel(reg & ~idma_mask(in_dma), IDMAC_SEP_ALPHA);
+		} else {
+			reg = __raw_readl(IDMAC_SEP_ALPHA);
+			__raw_writel(reg & ~idma_mask(sec_dma), IDMAC_SEP_ALPHA);
+		}
+		__raw_writel(idma_mask(thrd_dma), IPU_CHA_CUR_BUF(thrd_dma));
+	}
+
+	/* Set channel buffers NOT to be ready */
+	__raw_writel(0xF0000000, IPU_GPR); /* write one to clear */
+	if (idma_is_valid(in_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, in_dma)) {
+			__raw_writel(idma_mask(in_dma),
+				     IPU_CHA_BUF0_RDY(in_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, in_dma)) {
+			__raw_writel(idma_mask(in_dma),
+				     IPU_CHA_BUF1_RDY(in_dma));
+		}
+	}
+	if (idma_is_valid(out_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, out_dma)) {
+			__raw_writel(idma_mask(out_dma),
+				     IPU_CHA_BUF0_RDY(out_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, out_dma)) {
+			__raw_writel(idma_mask(out_dma),
+				     IPU_CHA_BUF1_RDY(out_dma));
+		}
+	}
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(sec_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, sec_dma)) {
+			__raw_writel(idma_mask(sec_dma),
+				     IPU_CHA_BUF0_RDY(sec_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, sec_dma)) {
+			__raw_writel(idma_mask(sec_dma),
+				     IPU_CHA_BUF1_RDY(sec_dma));
+		}
+	}
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(thrd_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, thrd_dma)) {
+			__raw_writel(idma_mask(thrd_dma),
+				     IPU_CHA_BUF0_RDY(thrd_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, thrd_dma)) {
+			__raw_writel(idma_mask(thrd_dma),
+				     IPU_CHA_BUF1_RDY(thrd_dma));
+		}
+	}
+	__raw_writel(0x0, IPU_GPR); /* write one to set */
+
+	g_channel_enable_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disable_channel);
+
+static irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	int i;
+	uint32_t line;
+	irqreturn_t result = IRQ_NONE;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
+
+	for (i = 0;; i++) {
+		if (err_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(err_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			__raw_writel(int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_err(g_ipu_dev,
+				"IPU Error - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+			/* Disable interrupts so we only get error once */
+			int_stat =
+			    __raw_readl(IPU_INT_CTRL(err_reg[i])) & ~int_stat;
+			__raw_writel(int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	for (i = 0;; i++) {
+		if (int_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(int_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(int_reg[i]));
+		__raw_writel(int_stat, IPU_INT_STAT(int_reg[i]));
+		while ((line = ffs(int_stat)) != 0) {
+			line--;
+			int_stat &= ~(1UL << line);
+			line += (int_reg[i] - 1) * 32;
+			result |=
+			    ipu_irq_list[line].handler(line,
+						       ipu_irq_list[line].
+						       dev_id);
+		}
+	}
+
+	return result;
+}
+
+/*!
+ * This function enables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to enable interrupt for.
+ *
+ */
+void ipu_enable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_enable_irq);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_disable_irq);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq(uint32_t irq)
+{
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_clear_irq);
+
+/*!
+ * This function returns the current interrupt status for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @return      Returns true if the interrupt is pending/asserted or false if
+ *              the interrupt is not pending.
+ */
+bool ipu_get_irq_status(uint32_t irq)
+{
+	uint32_t reg;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	if (reg & IPUIRQ_2_MASK(irq))
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(ipu_get_irq_status);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	unsigned long lock_flags;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (ipu_irq_list[irq].handler != NULL) {
+		dev_err(g_ipu_dev,
+			"handler already installed on irq %d\n", irq);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	ipu_irq_list[irq].handler = handler;
+	ipu_irq_list[irq].flags = irq_flags;
+	ipu_irq_list[irq].dev_id = dev_id;
+	ipu_irq_list[irq].name = devname;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	ipu_enable_irq(irq);	/* enable the interrupt */
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_request_irq);
+
+/*!
+ * This function unregisters an interrupt handler for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler. This must match value passed to
+ *                              ipu_request_irq().
+ *
+ */
+void ipu_free_irq(uint32_t irq, void *dev_id)
+{
+	ipu_disable_irq(irq);	/* disable the interrupt */
+
+	if (ipu_irq_list[irq].dev_id == dev_id)
+		ipu_irq_list[irq].handler = NULL;
+}
+EXPORT_SYMBOL(ipu_free_irq);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel)
+{
+	uint32_t stat = 0;
+	uint32_t task_stat_reg = __raw_readl(IPU_PROC_TASK_STAT);
+
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_VF_ROT_MASK) >> TSTAT_VF_ROT_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		stat = (task_stat_reg & TSTAT_ENC_MASK) >> TSTAT_ENC_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_ENC_ROT_MASK) >>
+		    TSTAT_ENC_ROT_OFFSET;
+		break;
+	case MEM_PP_MEM:
+		stat = (task_stat_reg & TSTAT_PP_MASK) >> TSTAT_PP_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_PP_ROT_MASK) >> TSTAT_PP_ROT_OFFSET;
+		break;
+
+	default:
+		stat = TASK_STAT_IDLE;
+		break;
+	}
+	return stat;
+}
+
+int32_t ipu_swap_channel(ipu_channel_t from_ch, ipu_channel_t to_ch)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	int from_dma = channel_2_dma(from_ch, IPU_INPUT_BUFFER);
+	int to_dma = channel_2_dma(to_ch, IPU_INPUT_BUFFER);
+
+	/* enable target channel */
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IDMAC_CHA_EN(to_dma));
+	__raw_writel(reg | idma_mask(to_dma), IDMAC_CHA_EN(to_dma));
+
+	g_channel_enable_mask |= 1L << IPU_CHAN_ID(to_ch);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	/* switch dp dc */
+	_ipu_dp_dc_disable(from_ch, true);
+
+	/* disable source channel */
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IDMAC_CHA_EN(from_dma));
+	__raw_writel(reg & ~idma_mask(from_dma), IDMAC_CHA_EN(from_dma));
+	__raw_writel(idma_mask(from_dma), IPU_CHA_CUR_BUF(from_dma));
+
+	g_channel_enable_mask &= ~(1L << IPU_CHAN_ID(from_ch));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_swap_channel);
+
+uint32_t bytes_per_pixel(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/*generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+		break;
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+		break;
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+		break;
+	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bytes_per_pixel);
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB666:
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+	case IPU_PIX_FMT_LVDS666:
+	case IPU_PIX_FMT_LVDS888:
+		return RGB;
+		break;
+
+	default:
+		return YCbCr;
+		break;
+	}
+	return RGB;
+}
+
+bool ipu_pixel_format_has_alpha(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_ABGR32:
+		return true;
+		break;
+	default:
+		return false;
+		break;
+	}
+	return false;
+}
+
+void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3])
+{
+	_ipu_dp_set_csc_coefficients(channel, param);
+}
+EXPORT_SYMBOL(ipu_set_csc_coefficients);
+
+static int ipu_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (g_ipu_clk_enabled) {
+		/* save and disable enabled channels*/
+		idma_enable_reg[0] = __raw_readl(IDMAC_CHA_EN(0));
+		idma_enable_reg[1] = __raw_readl(IDMAC_CHA_EN(32));
+		while ((__raw_readl(IDMAC_CHA_BUSY(0)) & idma_enable_reg[0])
+			|| (__raw_readl(IDMAC_CHA_BUSY(32)) &
+				idma_enable_reg[1])) {
+			/* disable channel not busy already */
+			uint32_t chan_should_disable, timeout = 1000, time = 0;
+
+			chan_should_disable =
+				__raw_readl(IDMAC_CHA_BUSY(0))
+					^ idma_enable_reg[0];
+			__raw_writel((~chan_should_disable) &
+					idma_enable_reg[0], IDMAC_CHA_EN(0));
+			chan_should_disable =
+				__raw_readl(IDMAC_CHA_BUSY(1))
+					^ idma_enable_reg[1];
+			__raw_writel((~chan_should_disable) &
+					idma_enable_reg[1], IDMAC_CHA_EN(32));
+			msleep(2);
+			time += 2;
+			if (time >= timeout)
+				return -1;
+		}
+		__raw_writel(0, IDMAC_CHA_EN(0));
+		__raw_writel(0, IDMAC_CHA_EN(32));
+
+		/* save double buffer select regs */
+		ipu_cha_db_mode_reg[0] = __raw_readl(IPU_CHA_DB_MODE_SEL(0));
+		ipu_cha_db_mode_reg[1] = __raw_readl(IPU_CHA_DB_MODE_SEL(32));
+		ipu_cha_db_mode_reg[2] =
+			__raw_readl(IPU_ALT_CHA_DB_MODE_SEL(0));
+		ipu_cha_db_mode_reg[3] =
+			__raw_readl(IPU_ALT_CHA_DB_MODE_SEL(32));
+
+		/* save current buffer regs */
+		ipu_cha_cur_buf_reg[0] = __raw_readl(IPU_CHA_CUR_BUF(0));
+		ipu_cha_cur_buf_reg[1] = __raw_readl(IPU_CHA_CUR_BUF(32));
+		ipu_cha_cur_buf_reg[2] = __raw_readl(IPU_ALT_CUR_BUF0);
+		ipu_cha_cur_buf_reg[3] = __raw_readl(IPU_ALT_CUR_BUF1);
+
+		/* save sub-modules status and disable all */
+		ic_conf_reg = __raw_readl(IC_CONF);
+		__raw_writel(0, IC_CONF);
+		ipu_conf_reg = __raw_readl(IPU_CONF);
+		__raw_writel(0, IPU_CONF);
+
+		/* save buf ready regs */
+		buf_ready_reg[0] = __raw_readl(IPU_CHA_BUF0_RDY(0));
+		buf_ready_reg[1] = __raw_readl(IPU_CHA_BUF0_RDY(32));
+		buf_ready_reg[2] = __raw_readl(IPU_CHA_BUF1_RDY(0));
+		buf_ready_reg[3] = __raw_readl(IPU_CHA_BUF1_RDY(32));
+		buf_ready_reg[4] = __raw_readl(IPU_ALT_CHA_BUF0_RDY(0));
+		buf_ready_reg[5] = __raw_readl(IPU_ALT_CHA_BUF0_RDY(32));
+		buf_ready_reg[6] = __raw_readl(IPU_ALT_CHA_BUF1_RDY(0));
+		buf_ready_reg[7] = __raw_readl(IPU_ALT_CHA_BUF1_RDY(32));
+	}
+
+	mxc_pg_enable(pdev);
+
+	return 0;
+}
+
+static int ipu_resume(struct platform_device *pdev)
+{
+	mxc_pg_disable(pdev);
+
+	if (g_ipu_clk_enabled) {
+
+		/* restore buf ready regs */
+		__raw_writel(buf_ready_reg[0], IPU_CHA_BUF0_RDY(0));
+		__raw_writel(buf_ready_reg[1], IPU_CHA_BUF0_RDY(32));
+		__raw_writel(buf_ready_reg[2], IPU_CHA_BUF1_RDY(0));
+		__raw_writel(buf_ready_reg[3], IPU_CHA_BUF1_RDY(32));
+		__raw_writel(buf_ready_reg[4], IPU_ALT_CHA_BUF0_RDY(0));
+		__raw_writel(buf_ready_reg[5], IPU_ALT_CHA_BUF0_RDY(32));
+		__raw_writel(buf_ready_reg[6], IPU_ALT_CHA_BUF1_RDY(0));
+		__raw_writel(buf_ready_reg[7], IPU_ALT_CHA_BUF1_RDY(32));
+
+		/* re-enable sub-modules*/
+		__raw_writel(ipu_conf_reg, IPU_CONF);
+		__raw_writel(ic_conf_reg, IC_CONF);
+
+		/* restore double buffer select regs */
+		__raw_writel(ipu_cha_db_mode_reg[0], IPU_CHA_DB_MODE_SEL(0));
+		__raw_writel(ipu_cha_db_mode_reg[1], IPU_CHA_DB_MODE_SEL(32));
+		__raw_writel(ipu_cha_db_mode_reg[2],
+				IPU_ALT_CHA_DB_MODE_SEL(0));
+		__raw_writel(ipu_cha_db_mode_reg[3],
+				IPU_ALT_CHA_DB_MODE_SEL(32));
+
+		/* restore current buffer select regs */
+		__raw_writel(~(ipu_cha_cur_buf_reg[0]), IPU_CHA_CUR_BUF(0));
+		__raw_writel(~(ipu_cha_cur_buf_reg[1]), IPU_CHA_CUR_BUF(32));
+		__raw_writel(~(ipu_cha_cur_buf_reg[2]), IPU_ALT_CUR_BUF0);
+		__raw_writel(~(ipu_cha_cur_buf_reg[3]), IPU_ALT_CUR_BUF1);
+
+		/* restart idma channel*/
+		__raw_writel(idma_enable_reg[0], IDMAC_CHA_EN(0));
+		__raw_writel(idma_enable_reg[1], IDMAC_CHA_EN(32));
+	} else {
+		clk_enable(g_ipu_clk);
+		_ipu_dmfc_init(dmfc_type_setup, 1);
+		_ipu_init_dc_mappings();
+
+		/* Set sync refresh channels as high priority */
+		__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
+		clk_disable(g_ipu_clk);
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		   .name = "mxc_ipu",
+		   },
+	.probe = ipu_probe,
+	.remove = ipu_remove,
+	.suspend = ipu_suspend,
+	.resume = ipu_resume,
+};
+
+int32_t __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	platform_driver_unregister(&mxcipu_driver);
+}
+
+module_exit(ipu_gen_uninit);
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
new file mode 100644
index 0000000..a658d8c
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -0,0 +1,486 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_device.c
+ *
+ * @brief This file contains the IPUv3 driver device interface and fops functions.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <asm/cacheflush.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/* Strucutures and variables for exporting MXC IPU as device*/
+
+static int mxc_ipu_major;
+static struct class *mxc_ipu_class;
+
+DEFINE_SPINLOCK(event_lock);
+
+struct ipu_dev_irq_info {
+	wait_queue_head_t waitq;
+	int irq_pending;
+} irq_info[480];
+
+int register_ipu_device(void);
+
+/* Static functions */
+
+int get_events(ipu_event_info *p)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&event_lock, flags);
+	if (irq_info[p->irq].irq_pending > 0)
+		irq_info[p->irq].irq_pending--;
+	else
+		ret = -1;
+	spin_unlock_irqrestore(&event_lock, flags);
+
+	return ret;
+}
+
+static irqreturn_t mxc_ipu_generic_handler(int irq, void *dev_id)
+{
+	irq_info[irq].irq_pending++;
+
+	/* Wakeup any blocking user context */
+	wake_up_interruptible(&(irq_info[irq].waitq));
+	return IRQ_HANDLED;
+}
+
+static int mxc_ipu_open(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	return ret;
+}
+static int mxc_ipu_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case IPU_INIT_CHANNEL:
+		{
+			ipu_channel_parm parm;
+
+			if (copy_from_user
+					(&parm, (ipu_channel_parm *) arg,
+					 sizeof(ipu_channel_parm)))
+				return -EFAULT;
+
+			if (!parm.flag) {
+				ret =
+					ipu_init_channel(parm.channel,
+							&parm.params);
+			} else {
+				ret = ipu_init_channel(parm.channel, NULL);
+			}
+		}
+		break;
+	case IPU_UNINIT_CHANNEL:
+		{
+		ipu_channel_t ch;
+		int __user *argp = (void __user *)arg;
+		if (get_user(ch, argp))
+				return -EFAULT;
+			ipu_uninit_channel(ch);
+		}
+		break;
+	case IPU_INIT_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			ret =
+				ipu_init_channel_buffer(
+						parm.channel, parm.type,
+						parm.pixel_fmt,
+						parm.width, parm.height,
+						parm.stride,
+						parm.rot_mode,
+						parm.phyaddr_0,
+						parm.phyaddr_1,
+						parm.u_offset,
+						parm.v_offset);
+
+		}
+		break;
+	case IPU_UPDATE_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			if ((parm.phyaddr_0 != (dma_addr_t) NULL)
+				&& (parm.phyaddr_1 == (dma_addr_t) NULL)) {
+				ret =
+					ipu_update_channel_buffer(
+							parm.channel,
+							parm.type,
+							parm.bufNum,
+							parm.phyaddr_0);
+			} else if ((parm.phyaddr_0 == (dma_addr_t) NULL)
+				&& (parm.phyaddr_1 != (dma_addr_t) NULL)) {
+				ret =
+					ipu_update_channel_buffer(
+							parm.channel,
+							parm.type,
+							parm.bufNum,
+							parm.phyaddr_1);
+			} else {
+				ret = -1;
+			}
+
+		}
+		break;
+	case IPU_SELECT_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			ret =
+				ipu_select_buffer(parm.channel,
+					parm.type, parm.bufNum);
+
+		}
+		break;
+	case IPU_LINK_CHANNELS:
+		{
+			ipu_channel_link link;
+			if (copy_from_user
+				(&link, (ipu_channel_link *) arg,
+				sizeof(ipu_channel_link)))
+				return -EFAULT;
+
+			ret = ipu_link_channels(link.src_ch,
+				link.dest_ch);
+
+		}
+		break;
+	case IPU_UNLINK_CHANNELS:
+		{
+			ipu_channel_link link;
+			if (copy_from_user
+				(&link, (ipu_channel_link *) arg,
+				sizeof(ipu_channel_link)))
+				return -EFAULT;
+
+			ret = ipu_unlink_channels(link.src_ch,
+				link.dest_ch);
+
+		}
+		break;
+	case IPU_ENABLE_CHANNEL:
+		{
+			ipu_channel_t ch;
+			int __user *argp = (void __user *)arg;
+			if (get_user(ch, argp))
+				return -EFAULT;
+			ipu_enable_channel(ch);
+		}
+		break;
+	case IPU_DISABLE_CHANNEL:
+		{
+			ipu_channel_info info;
+			if (copy_from_user
+				(&info, (ipu_channel_info *) arg,
+				 sizeof(ipu_channel_info)))
+				return -EFAULT;
+
+			ret = ipu_disable_channel(info.channel,
+				info.stop);
+		}
+		break;
+	case IPU_ENABLE_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_enable_irq(irq);
+		}
+		break;
+	case IPU_DISABLE_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_disable_irq(irq);
+		}
+		break;
+	case IPU_CLEAR_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_clear_irq(irq);
+		}
+		break;
+	case IPU_FREE_IRQ:
+		{
+			ipu_irq_info info;
+
+			if (copy_from_user
+					(&info, (ipu_irq_info *) arg,
+					 sizeof(ipu_irq_info)))
+				return -EFAULT;
+
+			ipu_free_irq(info.irq, info.dev_id);
+			irq_info[info.irq].irq_pending = 0;
+		}
+		break;
+	case IPU_REQUEST_IRQ_STATUS:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ret = ipu_get_irq_status(irq);
+		}
+		break;
+	case IPU_REGISTER_GENERIC_ISR:
+		{
+			ipu_event_info info;
+			if (copy_from_user
+					(&info, (ipu_event_info *) arg,
+					 sizeof(ipu_event_info)))
+				return -EFAULT;
+
+			ret =
+				ipu_request_irq(info.irq,
+					mxc_ipu_generic_handler,
+					0, "video_sink", info.dev);
+			if (ret == 0)
+				init_waitqueue_head(&(irq_info[info.irq].waitq));
+		}
+		break;
+	case IPU_GET_EVENT:
+		/* User will have to allocate event_type
+		structure and pass the pointer in arg */
+		{
+			ipu_event_info info;
+			int r = -1;
+
+			if (copy_from_user
+					(&info, (ipu_event_info *) arg,
+					 sizeof(ipu_event_info)))
+				return -EFAULT;
+
+			r = get_events(&info);
+			if (r == -1) {
+				if ((file->f_flags & O_NONBLOCK) &&
+					(irq_info[info.irq].irq_pending == 0))
+					return -EAGAIN;
+				wait_event_interruptible_timeout(irq_info[info.irq].waitq,
+						(irq_info[info.irq].irq_pending != 0), 2 * HZ);
+				r = get_events(&info);
+			}
+			ret = -1;
+			if (r == 0) {
+				if (!copy_to_user((ipu_event_info *) arg,
+					&info, sizeof(ipu_event_info)))
+					ret = 0;
+			}
+		}
+		break;
+	case IPU_ALOC_MEM:
+		{
+			ipu_mem_info info;
+			if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					 sizeof(ipu_mem_info)))
+				return -EFAULT;
+
+			info.vaddr = dma_alloc_coherent(0,
+					PAGE_ALIGN(info.size),
+					&info.paddr,
+					GFP_DMA | GFP_KERNEL);
+			if (info.vaddr == 0) {
+				printk(KERN_ERR "dma alloc failed!\n");
+				return -ENOBUFS;
+			}
+			if (copy_to_user((ipu_mem_info *) arg, &info,
+					sizeof(ipu_mem_info)) > 0)
+				return -EFAULT;
+		}
+		break;
+	case IPU_FREE_MEM:
+		{
+			ipu_mem_info info;
+			if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					 sizeof(ipu_mem_info)))
+				return -EFAULT;
+
+			if (info.vaddr)
+				dma_free_coherent(0, PAGE_ALIGN(info.size),
+					info.vaddr, info.paddr);
+			else
+				return -EFAULT;
+		}
+		break;
+	case IPU_IS_CHAN_BUSY:
+		{
+			ipu_channel_t chan;
+			if (copy_from_user
+					(&chan, (ipu_channel_t *)arg,
+					 sizeof(ipu_channel_t)))
+				return -EFAULT;
+
+			if (ipu_is_channel_busy(chan))
+				ret = 1;
+			else
+				ret = 0;
+		}
+		break;
+	case IPU_CALC_STRIPES_SIZE:
+		{
+			ipu_stripe_parm stripe_parm;
+
+			if (copy_from_user (&stripe_parm, (ipu_stripe_parm *)arg,
+					 sizeof(ipu_stripe_parm)))
+				return -EFAULT;
+			ipu_calc_stripes_sizes(stripe_parm.input_width,
+						stripe_parm.output_width,
+						stripe_parm.maximal_stripe_width,
+						stripe_parm.cirr,
+						stripe_parm.equal_stripes,
+						stripe_parm.input_pixelformat,
+						stripe_parm.output_pixelformat,
+						&stripe_parm.left,
+						&stripe_parm.right);
+			if (copy_to_user((ipu_stripe_parm *) arg, &stripe_parm,
+					sizeof(ipu_stripe_parm)) > 0)
+				return -EFAULT;
+		}
+		break;
+	case IPU_UPDATE_BUF_OFFSET:
+		{
+			ipu_buf_offset_parm offset_parm;
+
+			if (copy_from_user(&offset_parm, (ipu_buf_offset_parm *)arg,
+					 sizeof(ipu_buf_offset_parm)))
+				return -EFAULT;
+			ret = ipu_update_channel_offset(offset_parm.channel,
+							offset_parm.type,
+							offset_parm.pixel_fmt,
+							offset_parm.width,
+							offset_parm.height,
+							offset_parm.stride,
+							offset_parm.u_offset,
+							offset_parm.v_offset,
+							offset_parm.vertical_offset,
+							offset_parm.horizontal_offset);
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static int mxc_ipu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	/*	vma->vm_page_prot = pgprot_writethru(vma->vm_page_prot); */
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		printk(KERN_ERR
+				"mmap failed!\n");
+		return -ENOBUFS;
+	}
+	return 0;
+}
+
+static int mxc_ipu_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations mxc_ipu_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_ipu_open,
+	.mmap = mxc_ipu_mmap,
+	.release = mxc_ipu_release,
+	.ioctl = mxc_ipu_ioctl
+};
+
+int register_ipu_device()
+{
+	int ret = 0;
+	struct device *temp;
+	mxc_ipu_major = register_chrdev(0, "mxc_ipu", &mxc_ipu_fops);
+	if (mxc_ipu_major < 0) {
+		printk(KERN_ERR
+			"Unable to register Mxc Ipu as a char device\n");
+		return mxc_ipu_major;
+	}
+
+	mxc_ipu_class = class_create(THIS_MODULE, "mxc_ipu");
+	if (IS_ERR(mxc_ipu_class)) {
+		printk(KERN_ERR "Unable to create class for Mxc Ipu\n");
+		ret = PTR_ERR(mxc_ipu_class);
+		goto err1;
+	}
+
+	temp = device_create(mxc_ipu_class, NULL, MKDEV(mxc_ipu_major, 0),
+			NULL, "mxc_ipu");
+
+	if (IS_ERR(temp)) {
+		printk(KERN_ERR "Unable to create class device for Mxc Ipu\n");
+		ret = PTR_ERR(temp);
+		goto err2;
+	}
+	spin_lock_init(&event_lock);
+
+	return ret;
+
+err2:
+	class_destroy(mxc_ipu_class);
+err1:
+	unregister_chrdev(mxc_ipu_major, "mxc_ipu");
+	return ret;
+
+}
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
new file mode 100644
index 0000000..b953271
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -0,0 +1,1706 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_disp.c
+ *
+ * @brief IPU display submodule API functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <linux/clk.h>
+#include <asm/atomic.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/clock.h>
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum csc_type_t {
+	RGB2YUV = 0,
+	YUV2RGB,
+	RGB2RGB,
+	YUV2YUV,
+	CSC_NONE,
+	CSC_NUM
+};
+
+struct dp_csc_param_t {
+	int mode;
+	void *coeff;
+};
+
+#define SYNC_WAVE 0
+#define ASYNC_SER_WAVE 6
+
+/* DC display ID assignments */
+#define DC_DISP_ID_SYNC(di)	(di)
+#define DC_DISP_ID_SERIAL	2
+#define DC_DISP_ID_ASYNC	3
+
+int dmfc_type_setup;
+static int dmfc_size_28, dmfc_size_29, dmfc_size_24, dmfc_size_27, dmfc_size_23;
+int g_di1_tvout;
+
+void _ipu_dmfc_init(int dmfc_type, int first)
+{
+	u32 dmfc_wr_chan, dmfc_dp_chan;
+
+	if (first) {
+		if (dmfc_type_setup > dmfc_type)
+			dmfc_type = dmfc_type_setup;
+		else
+			dmfc_type_setup = dmfc_type;
+
+		/* disable DMFC-IC channel*/
+		__raw_writel(0x2, DMFC_IC_CTRL);
+	} else if (dmfc_type_setup >= DMFC_HIGH_RESOLUTION_DC) {
+		printk(KERN_DEBUG "DMFC high resolution has set, will not change\n");
+		return;
+	} else
+		dmfc_type_setup = dmfc_type;
+
+	if (dmfc_type == DMFC_HIGH_RESOLUTION_DC) {
+		/* 1 - segment 0~3;
+		 * 5B - segement 4, 5;
+		 * 5F - segement 6, 7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC DC HIGH RESOLUTION: 1(0~3), 5B(4,5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000088;
+		dmfc_dp_chan = 0x00009694;
+		dmfc_size_28 = 256*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 128*4;
+	} else if (dmfc_type == DMFC_HIGH_RESOLUTION_DP) {
+		/* 1 - segment 0, 1;
+		 * 5B - segement 2~5;
+		 * 5F - segement 6,7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC DP HIGH RESOLUTION: 1(0,1), 5B(2~5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000090;
+		dmfc_dp_chan = 0x0000968a;
+		dmfc_size_28 = 128*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 256*4;
+	} else if (dmfc_type == DMFC_HIGH_RESOLUTION_ONLY_DP) {
+		/* 5B - segement 0~3;
+		 * 5F - segement 4~7;
+		 * 1, 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC ONLY-DP HIGH RESOLUTION: 5B(0~3), 5F(4~7)\n");
+		dmfc_wr_chan = 0x00000000;
+		dmfc_dp_chan = 0x00008c88;
+		dmfc_size_28 = 0;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 256*4;
+		dmfc_size_23 = 256*4;
+	} else {
+		/* 1 - segment 0, 1;
+		 * 5B - segement 4, 5;
+		 * 5F - segement 6, 7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC NORMAL mode: 1(0~1), 5B(4,5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000090;
+		dmfc_dp_chan = 0x00009694;
+		dmfc_size_28 = 128*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 128*4;
+	}
+	__raw_writel(dmfc_wr_chan, DMFC_WR_CHAN);
+	__raw_writel(0x202020F6, DMFC_WR_CHAN_DEF);
+	__raw_writel(dmfc_dp_chan, DMFC_DP_CHAN);
+	/* Enable chan 5 watermark set at 5 bursts and clear at 7 bursts */
+	__raw_writel(0x2020F6F6, DMFC_DP_CHAN_DEF);
+}
+
+static int __init dmfc_setup(char *options)
+{
+	get_option(&options, &dmfc_type_setup);
+	if (dmfc_type_setup > DMFC_HIGH_RESOLUTION_ONLY_DP)
+		dmfc_type_setup = DMFC_HIGH_RESOLUTION_ONLY_DP;
+	return 1;
+}
+__setup("dmfc=", dmfc_setup);
+
+void _ipu_dmfc_set_wait4eot(int dma_chan, int width)
+{
+	u32 dmfc_gen1 = __raw_readl(DMFC_GENERAL1);
+
+	if (width >= HIGH_RESOLUTION_WIDTH) {
+		if (dma_chan == 23)
+			_ipu_dmfc_init(DMFC_HIGH_RESOLUTION_DP, 0);
+		else if (dma_chan == 28)
+			_ipu_dmfc_init(DMFC_HIGH_RESOLUTION_DC, 0);
+	}
+
+	if (dma_chan == 23) { /*5B*/
+		if (dmfc_size_23/width > 3)
+			dmfc_gen1 |= 1UL << 20;
+		else
+			dmfc_gen1 &= ~(1UL << 20);
+	} else if (dma_chan == 24) { /*6B*/
+		if (dmfc_size_24/width > 1)
+			dmfc_gen1 |= 1UL << 22;
+		else
+			dmfc_gen1 &= ~(1UL << 22);
+	} else if (dma_chan == 27) { /*5F*/
+		if (dmfc_size_27/width > 2)
+			dmfc_gen1 |= 1UL << 21;
+		else
+			dmfc_gen1 &= ~(1UL << 21);
+	} else if (dma_chan == 28) { /*1*/
+		if (dmfc_size_28/width > 2)
+			dmfc_gen1 |= 1UL << 16;
+		else
+			dmfc_gen1 &= ~(1UL << 16);
+	} else if (dma_chan == 29) { /*6F*/
+		if (dmfc_size_29/width > 1)
+			dmfc_gen1 |= 1UL << 23;
+		else
+			dmfc_gen1 &= ~(1UL << 23);
+	}
+
+	__raw_writel(dmfc_gen1, DMFC_GENERAL1);
+}
+
+static void _ipu_di_data_wave_config(int di,
+				     int wave_gen,
+				     int access_size, int component_size)
+{
+	u32 reg;
+	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
+	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+}
+
+static void _ipu_di_data_pin_config(int di, int wave_gen, int di_pin, int set,
+				    int up, int down)
+{
+	u32 reg;
+
+	reg = __raw_readl(DI_DW_GEN(di, wave_gen));
+	reg &= ~(0x3 << (di_pin * 2));
+	reg |= set << (di_pin * 2);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+
+	__raw_writel((down << 16) | up, DI_DW_SET(di, wave_gen, set));
+}
+
+static void _ipu_di_sync_config(int di, int wave_gen,
+				int run_count, int run_src,
+				int offset_count, int offset_src,
+				int repeat_count, int cnt_clr_src,
+				int cnt_polarity_gen_en,
+				int cnt_polarity_clr_src,
+				int cnt_polarity_trigger_src,
+				int cnt_up, int cnt_down)
+{
+	u32 reg;
+
+	if ((run_count >= 0x1000) || (offset_count >= 0x1000) || (repeat_count >= 0x1000) ||
+		(cnt_up >= 0x400) || (cnt_down >= 0x400)) {
+		dev_err(g_ipu_dev, "DI%d counters out of range.\n", di);
+		return;
+	}
+
+	reg = (run_count << 19) | (++run_src << 16) |
+	    (offset_count << 3) | ++offset_src;
+	__raw_writel(reg, DI_SW_GEN0(di, wave_gen));
+	reg = (cnt_polarity_gen_en << 29) | (++cnt_clr_src << 25) |
+	    (++cnt_polarity_trigger_src << 12) | (++cnt_polarity_clr_src << 9);
+	reg |= (cnt_down << 16) | cnt_up;
+	if (repeat_count == 0) {
+		/* Enable auto reload */
+		reg |= 0x10000000;
+	}
+	__raw_writel(reg, DI_SW_GEN1(di, wave_gen));
+	reg = __raw_readl(DI_STP_REP(di, wave_gen));
+	reg &= ~(0xFFFF << (16 * ((wave_gen - 1) & 0x1)));
+	reg |= repeat_count << (16 * ((wave_gen - 1) & 0x1));
+	__raw_writel(reg, DI_STP_REP(di, wave_gen));
+}
+
+static void _ipu_dc_map_config(int map, int byte_num, int offset, int mask)
+{
+	int ptr = map * 3 + byte_num;
+	u32 reg;
+
+	reg = __raw_readl(DC_MAP_CONF_VAL(ptr));
+	reg &= ~(0xFFFF << (16 * (ptr & 0x1)));
+	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
+	__raw_writel(reg, DC_MAP_CONF_VAL(ptr));
+
+	reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	reg &= ~(0x1F << ((16 * (map & 0x1)) + (5 * byte_num)));
+	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
+	__raw_writel(reg, DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_map_clear(int map)
+{
+	u32 reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	__raw_writel(reg & ~(0xFFFF << (16 * (map & 0x1))),
+		     DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_write_tmpl(int word, u32 opcode, u32 operand, int map,
+			       int wave, int glue, int sync)
+{
+	u32 reg;
+	int stop = 1;
+
+	reg = sync;
+	reg |= (glue << 4);
+	reg |= (++wave << 11);
+	reg |= (++map << 15);
+	reg |= (operand << 20) & 0xFFF00000;
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2);
+
+	reg = (operand >> 12);
+	reg |= opcode << 4;
+	reg |= (stop << 9);
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2 + 1);
+}
+
+static void _ipu_dc_link_event(int chan, int event, int addr, int priority)
+{
+	u32 reg;
+
+	reg = __raw_readl(DC_RL_CH(chan, event));
+	reg &= ~(0xFFFF << (16 * (event & 0x1)));
+	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+	__raw_writel(reg, DC_RL_CH(chan, event));
+}
+
+/*     Y = R *  1.200 + G *  2.343 + B *  .453 + 0.250;
+       U = R * -.672 + G * -1.328 + B *  2.000 + 512.250.;
+       V = R *  2.000 + G * -1.672 + B * -.328 + 512.250.;*/
+static const int rgb2ycbcr_coeff[5][3] = {
+	{0x4D, 0x96, 0x1D},
+	{0x3D5, 0x3AB, 0x80},
+	{0x80, 0x395, 0x3EB},
+	{0x0000, 0x0200, 0x0200},	/* B0, B1, B2 */
+	{0x2, 0x2, 0x2},	/* S0, S1, S2 */
+};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+static const int ycbcr2rgb_coeff[5][3] = {
+	{0x095, 0x000, 0x0CC},
+	{0x095, 0x3CE, 0x398},
+	{0x095, 0x0FF, 0x000},
+	{0x3E42, 0x010A, 0x3DD6},	/*B0,B1,B2 */
+	{0x1, 0x1, 0x1},	/*S0,S1,S2 */
+};
+
+#define mask_a(a) ((u32)(a) & 0x3FF)
+#define mask_b(b) ((u32)(b) & 0x3FFF)
+
+/* Pls keep S0, S1 and S2 as 0x2 by using this convertion */
+static int _rgb_to_yuv(int n, int red, int green, int blue)
+{
+	int c;
+	c = red * rgb2ycbcr_coeff[n][0];
+	c += green * rgb2ycbcr_coeff[n][1];
+	c += blue * rgb2ycbcr_coeff[n][2];
+	c /= 16;
+	c += rgb2ycbcr_coeff[3][n] * 4;
+	c += 8;
+	c /= 16;
+	if (c < 0)
+		c = 0;
+	if (c > 255)
+		c = 255;
+	return c;
+}
+
+/*
+ * Row is for BG:	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ * Column is for FG:	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ */
+static struct dp_csc_param_t dp_csc_array[CSC_NUM][CSC_NUM] = {
+{{DP_COM_CONF_CSC_DEF_BOTH, &rgb2ycbcr_coeff}, {0, 0}, {0, 0}, {DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff}, {DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff} },
+{{0, 0}, {DP_COM_CONF_CSC_DEF_BOTH, &ycbcr2rgb_coeff}, {DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff}, {0, 0}, {DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff} },
+{{0, 0}, {DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff}, {0, 0}, {0, 0}, {0, 0} },
+{{DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff}, {0, 0}, {0, 0}, {0, 0}, {0, 0} },
+{{DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff}, {DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff}, {0, 0}, {0, 0}, {0, 0} }
+};
+
+static enum csc_type_t fg_csc_type = CSC_NONE, bg_csc_type = CSC_NONE;
+static int color_key_4rgb = 1;
+
+void __ipu_dp_csc_setup(int dp, struct dp_csc_param_t dp_csc_param,
+			bool srm_mode_update)
+{
+	u32 reg;
+	const int (*coeff)[5][3];
+
+	if (dp_csc_param.mode >= 0) {
+		reg = __raw_readl(DP_COM_CONF(dp));
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+		reg |= dp_csc_param.mode;
+		__raw_writel(reg, DP_COM_CONF(dp));
+	}
+
+	coeff = dp_csc_param.coeff;
+
+	if (coeff) {
+		__raw_writel(mask_a((*coeff)[0][0]) |
+				(mask_a((*coeff)[0][1]) << 16), DP_CSC_A_0(dp));
+		__raw_writel(mask_a((*coeff)[0][2]) |
+				(mask_a((*coeff)[1][0]) << 16), DP_CSC_A_1(dp));
+		__raw_writel(mask_a((*coeff)[1][1]) |
+				(mask_a((*coeff)[1][2]) << 16), DP_CSC_A_2(dp));
+		__raw_writel(mask_a((*coeff)[2][0]) |
+				(mask_a((*coeff)[2][1]) << 16), DP_CSC_A_3(dp));
+		__raw_writel(mask_a((*coeff)[2][2]) |
+				(mask_b((*coeff)[3][0]) << 16) |
+				((*coeff)[4][0] << 30), DP_CSC_0(dp));
+		__raw_writel(mask_b((*coeff)[3][1]) | ((*coeff)[4][1] << 14) |
+				(mask_b((*coeff)[3][2]) << 16) |
+				((*coeff)[4][2] << 30), DP_CSC_1(dp));
+	}
+
+	if (srm_mode_update) {
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+	}
+}
+
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt)
+{
+	int in_fmt, out_fmt;
+	int dp;
+	int partial = false;
+	uint32_t reg;
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return -EINVAL;
+	}
+
+	in_fmt = format_to_colorspace(in_pixel_fmt);
+	out_fmt = format_to_colorspace(out_pixel_fmt);
+
+	if (partial) {
+		if (in_fmt == RGB) {
+			if (out_fmt == RGB)
+				fg_csc_type = RGB2RGB;
+			else
+				fg_csc_type = RGB2YUV;
+		} else {
+			if (out_fmt == RGB)
+				fg_csc_type = YUV2RGB;
+			else
+				fg_csc_type = YUV2YUV;
+		}
+	} else {
+		if (in_fmt == RGB) {
+			if (out_fmt == RGB)
+				bg_csc_type = RGB2RGB;
+			else
+				bg_csc_type = RGB2YUV;
+		} else {
+			if (out_fmt == RGB)
+				bg_csc_type = YUV2RGB;
+			else
+				bg_csc_type = YUV2YUV;
+		}
+	}
+
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	reg = __raw_readl(DP_COM_CONF(dp));
+	if (color_key_4rgb && (reg & DP_COM_CONF_GWCKE) &&
+			(((fg_csc_type == RGB2YUV) && (bg_csc_type == YUV2YUV)) ||
+			 ((fg_csc_type == YUV2YUV) && (bg_csc_type == RGB2YUV)) ||
+			 ((fg_csc_type == YUV2YUV) && (bg_csc_type == YUV2YUV)) ||
+			 ((fg_csc_type == YUV2RGB) && (bg_csc_type == YUV2RGB)))) {
+		int red, green, blue;
+		int y, u, v;
+		uint32_t color_key = __raw_readl(DP_GRAPH_WIND_CTRL(dp)) & 0xFFFFFFL;
+
+		dev_dbg(g_ipu_dev, "_ipu_dp_init color key 0x%x need change to yuv fmt!\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(dp)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(dp));
+		color_key_4rgb = 0;
+
+		dev_dbg(g_ipu_dev, "_ipu_dp_init color key change to yuv fmt 0x%x!\n", color_key);
+	}
+
+	__ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], true);
+
+	return 0;
+}
+
+void _ipu_dp_uninit(ipu_channel_t channel)
+{
+	int dp;
+	int partial = false;
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return;
+	}
+
+	if (partial)
+		fg_csc_type = CSC_NONE;
+	else
+		bg_csc_type = CSC_NONE;
+
+	__ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], false);
+}
+
+void _ipu_dc_init(int dc_chan, int di, bool interlaced)
+{
+	u32 reg = 0;
+
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		if (interlaced) {
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 3);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 2);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 1);
+		} else {
+			if (di) {
+				_ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
+				_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
+				_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 4, 1);
+			} else {
+				_ipu_dc_link_event(dc_chan, DC_EVT_NL, 5, 3);
+				_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 6, 2);
+				_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 7, 1);
+			}
+		}
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+
+		reg = 0x2;
+		reg |= DC_DISP_ID_SYNC(di) << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+		reg |= di << 2;
+		if (interlaced)
+			reg |= DC_WR_CH_CONF_FIELD_MODE;
+	} else if ((dc_chan == 8) || (dc_chan == 9)) {
+		/* async channels */
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0x64, 1);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0x64, 1);
+
+		reg = 0x3;
+		reg |= DC_DISP_ID_SERIAL << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+	}
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	__raw_writel(0x00000000, DC_WR_CH_ADDR(dc_chan));
+
+	__raw_writel(0x00000084, DC_GEN);
+}
+
+void _ipu_dc_uninit(int dc_chan)
+{
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+	} else if ((dc_chan == 8) || (dc_chan == 9)) {
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_R_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_R_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_R_1, 0, 0);
+	}
+}
+
+int _ipu_chan_is_interlaced(ipu_channel_t channel)
+{
+	if (channel == MEM_DC_SYNC)
+		return !!(__raw_readl(DC_WR_CH_CONF_1) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	else if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC))
+		return !!(__raw_readl(DC_WR_CH_CONF_5) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	return 0;
+}
+
+void _ipu_dp_dc_enable(ipu_channel_t channel)
+{
+	int di;
+	uint32_t reg;
+	uint32_t dc_chan;
+	int irq = 0;
+
+	if (channel == MEM_FG_SYNC)
+		irq = IPU_IRQ_DP_SF_END;
+	else if (channel == MEM_DC_SYNC)
+		dc_chan = 1;
+	else if (channel == MEM_BG_SYNC)
+		dc_chan = 5;
+	else
+		return;
+
+	if (channel == MEM_FG_SYNC) {
+		/* Enable FG channel */
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		__raw_writel(reg | DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+		return;
+	}
+
+	di = g_dc_di_assignment[dc_chan];
+
+	/* Make sure other DC sync channel is not assigned same DI */
+	reg = __raw_readl(DC_WR_CH_CONF(6 - dc_chan));
+	if ((di << 2) == (reg & DC_WR_CH_CONF_PROG_DI_ID)) {
+		reg &= ~DC_WR_CH_CONF_PROG_DI_ID;
+		reg |= di ? 0 : DC_WR_CH_CONF_PROG_DI_ID;
+		__raw_writel(reg, DC_WR_CH_CONF(6 - dc_chan));
+	}
+
+	reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	clk_enable(g_pixel_clk[di]);
+}
+
+static bool dc_swap;
+
+static irqreturn_t dc_irq_handler(int irq, void *dev_id)
+{
+	struct completion *comp = dev_id;
+
+	complete(comp);
+	return IRQ_HANDLED;
+}
+
+void _ipu_dp_dc_disable(ipu_channel_t channel, bool swap)
+{
+	int ret;
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t csc;
+	uint32_t dc_chan;
+	int irq = 0;
+	int timeout = 50;
+	DECLARE_COMPLETION_ONSTACK(dc_comp);
+
+	dc_swap = swap;
+
+	if (channel == MEM_DC_SYNC) {
+		dc_chan = 1;
+		irq = IPU_IRQ_DC_FC_1;
+	} else if (channel == MEM_BG_SYNC) {
+		dc_chan = 5;
+		irq = IPU_IRQ_DP_SF_END;
+	} else if (channel == MEM_FG_SYNC) {
+		/* Disable FG channel */
+		dc_chan = 5;
+
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		csc = reg & DP_COM_CONF_CSC_DEF_MASK;
+		if (csc == DP_COM_CONF_CSC_DEF_FG)
+			reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+
+		reg &= ~DP_COM_CONF_FG_EN;
+		__raw_writel(reg, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+		__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END),
+			     IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END));
+		while ((__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END)) &
+			IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END)) == 0) {
+			msleep(2);
+			timeout -= 2;
+			if (timeout <= 0)
+				break;
+		}
+
+		timeout = 50;
+
+		/*
+		 * Wait for DC triple buffer to empty,
+		 * this check is useful for tv overlay.
+		 */
+		if (g_dc_di_assignment[dc_chan] == 0)
+			while ((__raw_readl(DC_STAT) & 0x00000002)
+			       != 0x00000002) {
+				msleep(2);
+				timeout -= 2;
+				if (timeout <= 0)
+					break;
+			}
+		else if (g_dc_di_assignment[dc_chan] == 1)
+			while ((__raw_readl(DC_STAT) & 0x00000020)
+			       != 0x00000020) {
+				msleep(2);
+				timeout -= 2;
+				if (timeout <= 0)
+					break;
+			}
+		return;
+	} else {
+		return;
+	}
+
+	if (!dc_swap)
+		__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_VSYNC_PRE_0
+			+ g_dc_di_assignment[dc_chan]),
+		     IPUIRQ_2_STATREG(IPU_IRQ_VSYNC_PRE_0
+			+ g_dc_di_assignment[dc_chan]));
+	ipu_clear_irq(irq);
+	ret = ipu_request_irq(irq, dc_irq_handler, 0, NULL, &dc_comp);
+	if (ret < 0) {
+		dev_err(g_ipu_dev, "DC irq %d in use\n", irq);
+		return;
+	}
+	ret = wait_for_completion_timeout(&dc_comp, msecs_to_jiffies(50));
+
+	dev_dbg(g_ipu_dev, "DC stop timeout - %d * 10ms\n", 5 - ret);
+	ipu_free_irq(irq, &dc_comp);
+
+	if (dc_swap) {
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		/* Swap DC channel 1 and 5 settings, and disable old dc chan */
+		reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+		__raw_writel(reg, DC_WR_CH_CONF(6 - dc_chan));
+		reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+		reg ^= DC_WR_CH_CONF_PROG_DI_ID;
+		__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	} else {
+		timeout = 50;
+
+		/* Wait for DC triple buffer to empty */
+		if (g_dc_di_assignment[dc_chan] == 0)
+			while ((__raw_readl(DC_STAT) & 0x00000002)
+				!= 0x00000002) {
+				msleep(2);
+				timeout -= 2;
+				if (timeout <= 0)
+					break;
+			}
+		else if (g_dc_di_assignment[dc_chan] == 1)
+			while ((__raw_readl(DC_STAT) & 0x00000020)
+				!= 0x00000020) {
+				msleep(2);
+				timeout -= 2;
+				if (timeout <= 0)
+					break;
+			}
+
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+		reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+		__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+		reg = __raw_readl(IPU_DISP_GEN);
+		if (g_dc_di_assignment[dc_chan])
+			reg &= ~DI1_COUNTER_RELEASE;
+		else
+			reg &= ~DI0_COUNTER_RELEASE;
+		__raw_writel(reg, IPU_DISP_GEN);
+
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		/* Clock is already off because it must be done quickly, but
+		   we need to fix the ref count */
+		clk_disable(g_pixel_clk[g_dc_di_assignment[dc_chan]]);
+
+		if (__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_VSYNC_PRE_0
+			+ g_dc_di_assignment[dc_chan])) &
+			IPUIRQ_2_MASK(IPU_IRQ_VSYNC_PRE_0
+			+ g_dc_di_assignment[dc_chan]))
+			dev_dbg(g_ipu_dev,
+				"VSyncPre occurred before DI%d disable\n",
+				g_dc_di_assignment[dc_chan]);
+	}
+}
+
+void _ipu_init_dc_mappings(void)
+{
+	/* IPU_PIX_FMT_RGB24 */
+	_ipu_dc_map_clear(0);
+	_ipu_dc_map_config(0, 0, 7, 0xFF);
+	_ipu_dc_map_config(0, 1, 15, 0xFF);
+	_ipu_dc_map_config(0, 2, 23, 0xFF);
+
+	/* IPU_PIX_FMT_RGB666 */
+	_ipu_dc_map_clear(1);
+	_ipu_dc_map_config(1, 0, 5, 0xFC);
+	_ipu_dc_map_config(1, 1, 11, 0xFC);
+	_ipu_dc_map_config(1, 2, 17, 0xFC);
+
+	/* IPU_PIX_FMT_YUV444 */
+	_ipu_dc_map_clear(2);
+	_ipu_dc_map_config(2, 0, 15, 0xFF);
+	_ipu_dc_map_config(2, 1, 23, 0xFF);
+	_ipu_dc_map_config(2, 2, 7, 0xFF);
+
+	/* IPU_PIX_FMT_RGB565 */
+	_ipu_dc_map_clear(3);
+	_ipu_dc_map_config(3, 0, 4, 0xF8);
+	_ipu_dc_map_config(3, 1, 10, 0xFC);
+	_ipu_dc_map_config(3, 2, 15, 0xF8);
+
+	/* IPU_PIX_FMT_LVDS666 */
+	_ipu_dc_map_clear(4);
+	_ipu_dc_map_config(4, 0, 5, 0xFC);
+	_ipu_dc_map_config(4, 1, 13, 0xFC);
+	_ipu_dc_map_config(4, 2, 21, 0xFC);
+}
+
+int _ipu_pixfmt_to_map(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_RGB24:
+		return 0;
+	case IPU_PIX_FMT_RGB666:
+		return 1;
+	case IPU_PIX_FMT_YUV444:
+		return 2;
+	case IPU_PIX_FMT_RGB565:
+		return 3;
+	case IPU_PIX_FMT_LVDS666:
+		return 4;
+	}
+
+	return -1;
+}
+
+/*!
+ * This function sets the colorspace for of dp.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       param         	If it's not NULL, update the csc table
+ *                              with this parameter.
+ *
+ * @return      N/A
+ */
+void _ipu_dp_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3])
+{
+	int dp;
+	struct dp_csc_param_t dp_csc_param;
+
+	if (channel == MEM_FG_SYNC)
+		dp = DP_SYNC;
+	else if (channel == MEM_BG_SYNC)
+		dp = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		dp = DP_ASYNC0;
+	else
+		return;
+
+	dp_csc_param.mode = -1;
+	dp_csc_param.coeff = param;
+	__ipu_dp_csc_setup(dp, dp_csc_param, true);
+}
+
+/*!
+ * This function is called to adapt synchronous LCD panel to IPU restriction.
+ *
+ */
+void adapt_panel_to_ipu_restricitions(uint16_t *pixel_clk,
+				      uint16_t width, uint16_t height,
+				      uint16_t h_start_width,
+				      uint16_t h_end_width,
+				      uint16_t v_start_width,
+				      uint16_t *v_end_width)
+{
+	if (*v_end_width < 2) {
+		uint16_t total_width = width + h_start_width + h_end_width;
+		uint16_t total_height_old = height + v_start_width + (*v_end_width);
+		uint16_t total_height_new = height + v_start_width + 2;
+		*v_end_width = 2;
+		*pixel_clk = (*pixel_clk) * total_width * total_height_new /
+			(total_width * total_height_old);
+		dev_err(g_ipu_dev, "WARNING: adapt panel end blank lines\n");
+	}
+}
+
+/*!
+ * This function is called to initialize a synchronous LCD panel.
+ *
+ * @param       disp            The DI the panel is attached to.
+ *
+ * @param       pixel_clk       Desired pixel clock frequency in Hz.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           The width of panel in pixels.
+ *
+ * @param       height          The height of panel in pixels.
+ *
+ * @param       hStartWidth     The number of pixel clocks between the HSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       hSyncWidth      The width of the HSYNC signal in units of pixel
+ *                              clocks.
+ *
+ * @param       hEndWidth       The number of pixel clocks between the end of
+ *                              valid data and the HSYNC signal for next line.
+ *
+ * @param       vStartWidth     The number of lines between the VSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       vSyncWidth      The width of the VSYNC signal in units of lines
+ *
+ * @param       vEndWidth       The number of lines between the end of valid
+ *                              data and the VSYNC signal for next frame.
+ *
+ * @param       sig             Bitfield of signal polarities for LCD interface.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+
+int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig)
+{
+	unsigned long lock_flags;
+	uint32_t field0_offset = 0;
+	uint32_t field1_offset;
+	uint32_t reg;
+	uint32_t di_gen, vsync_cnt;
+	uint32_t div, rounded_pixel_clk;
+	uint32_t h_total, v_total;
+	int map;
+	int ipu_freq_scaling_enabled = 0;
+	struct clk *di_parent;
+
+	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
+
+	if ((v_sync_width == 0) || (h_sync_width == 0))
+		return EINVAL;
+
+	adapt_panel_to_ipu_restricitions(&pixel_clk, width, height,
+					 h_start_width, h_end_width,
+					 v_start_width, &v_end_width);
+	h_total = width + h_sync_width + h_start_width + h_end_width;
+	v_total = height + v_sync_width + v_start_width + v_end_width;
+
+	/* Init clocking */
+	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
+
+	if (sig.ext_clk) {
+		if (!(g_di1_tvout && (disp == 1))) { /* not round div for tvout*/
+			/* Set the  PLL to be an even multiple of the pixel clock. */
+			if ((clk_get_usecount(g_pixel_clk[0]) == 0) &&
+					(clk_get_usecount(g_pixel_clk[1]) == 0)) {
+				di_parent = clk_get_parent(g_di_clk[disp]);
+				rounded_pixel_clk =
+					clk_round_rate(g_pixel_clk[disp], pixel_clk);
+				div  = clk_get_rate(di_parent) / rounded_pixel_clk;
+				if (div % 2)
+					div++;
+
+				if (clk_get_rate(di_parent) != div * rounded_pixel_clk)
+					clk_set_rate(di_parent, div * rounded_pixel_clk);
+				msleep(10);
+				clk_set_rate(g_di_clk[disp], 2 * rounded_pixel_clk);
+				msleep(10);
+			}
+		}
+		clk_set_parent(g_pixel_clk[disp], g_di_clk[disp]);
+	} else {
+		if (clk_get_usecount(g_pixel_clk[disp]) != 0)
+			clk_set_parent(g_pixel_clk[disp], g_ipu_clk);
+	}
+	rounded_pixel_clk = clk_round_rate(g_pixel_clk[disp], pixel_clk);
+	clk_set_rate(g_pixel_clk[disp], rounded_pixel_clk);
+	msleep(5);
+	/* Get integer portion of divider */
+	div = clk_get_rate(clk_get_parent(g_pixel_clk[disp])) / rounded_pixel_clk;
+
+	ipu_freq_scaling_enabled = dvfs_per_pixel_clk_limit();
+
+	if (ipu_freq_scaling_enabled) {
+		/* Enable for a divide by 2 clock change. */
+		reg = __raw_readl(IPU_PM);
+		reg &= ~(0x7f << 7);
+		reg |= 0x20 << 7;
+		reg &= ~(0x7f << 23);
+		reg |= 0x20 << 23;
+		__raw_writel(reg, IPU_PM);
+	}
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	_ipu_di_data_wave_config(disp, SYNC_WAVE, div - 1, div - 1);
+	_ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
+
+	map = _ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0) {
+		dev_dbg(g_ipu_dev, "IPU_DISP: No MAP\n");
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	di_gen = __raw_readl(DI_GENERAL(disp));
+
+	if (sig.interlaced) {
+		if (cpu_is_mx51_rev(CHIP_REV_2_0)) {
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					1,				/* counter */
+					h_total/2 - 1,	/* run count */
+					DI_SYNC_CLK,		 /* run_resolution */
+					0,				/* offset */
+					DI_SYNC_NONE,	/* offset resolution */
+					0,				/* repeat count */
+					DI_SYNC_NONE,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Field 1 VSYNC waveform */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					2,				/* counter */
+					h_total - 1,		/* run count */
+					DI_SYNC_CLK,		/* run_resolution */
+					0,				/* offset */
+					DI_SYNC_NONE,	/* offset resolution */
+					0,				/* repeat count */
+					DI_SYNC_NONE,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					3,				/* counter */
+					v_total*2 - 1,	/* run count */
+					DI_SYNC_INT_HSYNC,	/* run_resolution */
+					1,				/* offset */
+					DI_SYNC_INT_HSYNC,	/* offset resolution */
+					0,				/* repeat count */
+					DI_SYNC_NONE,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* Active Field ? */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					4,				/* counter */
+					v_total/2 - 1,	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					v_start_width,	/*  offset */
+					DI_SYNC_HSYNC,	/* offset resolution */
+					2,				/* repeat count */
+					DI_SYNC_VSYNC,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Active Line */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					5,				/* counter */
+					0,				/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					0,				/*  offset */
+					DI_SYNC_NONE,	/* offset resolution */
+					height/2,		/* repeat count */
+					4,				/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Field 0 VSYNC waveform */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					6,				/* counter */
+					v_total - 1,	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					0,				/* offset */
+					DI_SYNC_NONE,	/* offset resolution */
+					0,				/* repeat count */
+					DI_SYNC_NONE,	/* CNT_CLR_SEL  */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* DC VSYNC waveform */
+			vsync_cnt = 7;
+			_ipu_di_sync_config(
+					disp,			/* display */
+					7,				/* counter */
+					v_total/2 - 1,	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution  */
+					9,				/* offset  */
+					DI_SYNC_HSYNC,	/* offset resolution */
+					2,				/* repeat count */
+					DI_SYNC_VSYNC,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* active pixel waveform */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					8,				/* counter */
+					0,	/* run count  */
+					DI_SYNC_CLK,	/* run_resolution */
+					h_start_width,				/* offset  */
+					DI_SYNC_CLK,	/* offset resolution */
+					width,				/* repeat count  */
+					5,	/* CNT_CLR_SEL  */
+					0,				/* CNT_POLARITY_GEN_EN  */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL  */
+					0,				/* COUNT UP  */
+					0				/* COUNT DOWN */
+					);
+
+			/* ??? */
+			_ipu_di_sync_config(
+					disp,			/* display */
+					9,				/* counter */
+					v_total - 1,	/* run count */
+					DI_SYNC_INT_HSYNC,	/* run_resolution */
+					v_total/2,			/* offset  */
+					DI_SYNC_INT_HSYNC,	/* offset resolution  */
+					0,				/* repeat count */
+					DI_SYNC_HSYNC,	/* CNT_CLR_SEL */
+					0,				/* CNT_POLARITY_GEN_EN  */
+					DI_SYNC_NONE,	/* CNT_POLARITY_CLR_SEL  */
+					DI_SYNC_NONE,	/* CNT_POLARITY_TRIGGER_SEL */
+					0,				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* set gentime select and tag sel */
+			reg = __raw_readl(DI_SW_GEN1(disp, 9));
+			reg &= 0x1FFFFFFF;
+			reg |= (3-1)<<29 | 0x00008000;
+			__raw_writel(reg, DI_SW_GEN1(disp, 9));
+
+			__raw_writel(v_total / 2 - 1, DI_SCR_CONF(disp));
+
+			/* set y_sel = 1 */
+			di_gen |= 0x10000000;
+			di_gen |= DI_GEN_POLARITY_5;
+			di_gen |= DI_GEN_POLARITY_8;
+		} else {
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			field1_offset = v_sync_width + v_start_width + height / 2 +
+				v_end_width;
+			if (sig.odd_field_first) {
+				field0_offset = field1_offset - 1;
+				field1_offset = 0;
+			}
+			v_total += v_start_width + v_end_width;
+
+			/* Field 1 VSYNC waveform */
+			_ipu_di_sync_config(disp, 2, v_total - 1, 1,
+					field0_offset,
+					field0_offset ? 1 : DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 0,
+					DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(disp, 3, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0,
+					DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+			/* Active Field ? */
+			_ipu_di_sync_config(disp, 4,
+					field0_offset ?
+					field0_offset : field1_offset - 2,
+					1, v_start_width + v_sync_width, 1, 2, 2,
+					0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+			/* Active Line */
+			_ipu_di_sync_config(disp, 5, 0, 1,
+					0, DI_SYNC_NONE,
+					height / 2, 4, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			/* Field 0 VSYNC waveform */
+			_ipu_di_sync_config(disp, 6, v_total - 1, 1,
+					0, DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			/* DC VSYNC waveform */
+			vsync_cnt = 7;
+			_ipu_di_sync_config(disp, 7, 0, 1,
+					field1_offset,
+					field1_offset ? 1 : DI_SYNC_NONE,
+					1, 2, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+			/* active pixel waveform */
+			_ipu_di_sync_config(disp, 8, 0, DI_SYNC_CLK,
+					h_sync_width + h_start_width, DI_SYNC_CLK,
+					width, 5, 0, DI_SYNC_NONE, DI_SYNC_NONE,
+					0, 0);
+
+			/* ??? */
+			_ipu_di_sync_config(disp, 9, v_total - 1, 2,
+					0, DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 6, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			reg = __raw_readl(DI_SW_GEN1(disp, 9));
+			reg |= 0x8000;
+			__raw_writel(reg, DI_SW_GEN1(disp, 9));
+
+			__raw_writel(v_sync_width + v_start_width +
+					v_end_width + height / 2 - 1, DI_SCR_CONF(disp));
+		}
+
+		/* Init template microcode */
+		_ipu_dc_write_tmpl(0, WROD(0), 0, map, SYNC_WAVE, 0, 8);
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+	} else {
+		/* Setup internal HSYNC waveform */
+		_ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+		/* Setup external (delayed) HSYNC waveform */
+		_ipu_di_sync_config(disp, DI_SYNC_HSYNC, h_total - 1,
+				    DI_SYNC_CLK, div * v_to_h_sync, DI_SYNC_CLK,
+				    0, DI_SYNC_NONE, 1, DI_SYNC_NONE,
+				    DI_SYNC_CLK, 0, h_sync_width * 2);
+		/* Setup VSYNC waveform */
+		vsync_cnt = DI_SYNC_VSYNC;
+		_ipu_di_sync_config(disp, DI_SYNC_VSYNC, v_total - 1,
+				    DI_SYNC_INT_HSYNC, 0, DI_SYNC_NONE, 0,
+				    DI_SYNC_NONE, 1, DI_SYNC_NONE,
+				    DI_SYNC_INT_HSYNC, 0, v_sync_width * 2);
+		__raw_writel(v_total - 1, DI_SCR_CONF(disp));
+
+		/* Setup active data waveform to sync with DC */
+		_ipu_di_sync_config(disp, 4, 0, DI_SYNC_HSYNC,
+				    v_sync_width + v_start_width, DI_SYNC_HSYNC, height,
+				    DI_SYNC_VSYNC, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+		_ipu_di_sync_config(disp, 5, 0, DI_SYNC_CLK,
+				    h_sync_width + h_start_width, DI_SYNC_CLK,
+				    width, 4, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0,
+				    0);
+
+		/* reset all unused counters */
+		__raw_writel(0, DI_SW_GEN0(disp, 6));
+		__raw_writel(0, DI_SW_GEN1(disp, 6));
+		__raw_writel(0, DI_SW_GEN0(disp, 7));
+		__raw_writel(0, DI_SW_GEN1(disp, 7));
+		__raw_writel(0, DI_SW_GEN0(disp, 8));
+		__raw_writel(0, DI_SW_GEN1(disp, 8));
+		__raw_writel(0, DI_SW_GEN0(disp, 9));
+		__raw_writel(0, DI_SW_GEN1(disp, 9));
+
+		reg = __raw_readl(DI_STP_REP(disp, 6));
+		reg &= 0x0000FFFF;
+		__raw_writel(reg, DI_STP_REP(disp, 6));
+		__raw_writel(0, DI_STP_REP(disp, 7));
+		__raw_writel(0, DI_STP_REP(disp, 9));
+
+		if (ipu_freq_scaling_enabled) {
+			h_total = ((width + h_start_width +
+					h_sync_width) / 2) - 2;
+			_ipu_di_sync_config(disp, 6, 1, 0,
+				2, DI_SYNC_CLK,
+				h_total,
+				DI_SYNC_INT_HSYNC, 0, DI_SYNC_NONE,
+				DI_SYNC_NONE, 0, 0);
+		}
+
+		/* Init template microcode */
+		if (disp) {
+			_ipu_dc_write_tmpl(2, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+			_ipu_dc_write_tmpl(3, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+			_ipu_dc_write_tmpl(4, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+		} else {
+			_ipu_dc_write_tmpl(5, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+			_ipu_dc_write_tmpl(6, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+			_ipu_dc_write_tmpl(7, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+		}
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+
+		if (ipu_freq_scaling_enabled)
+			/* Set the clock to stop at counter 6. */
+			di_gen |= 0x6000000;
+	}
+
+	__raw_writel(di_gen, DI_GENERAL(disp));
+
+	if (!ipu_freq_scaling_enabled)
+		__raw_writel((--vsync_cnt << DI_VSYNC_SEL_OFFSET) |
+					0x00000002, DI_SYNC_AS_GEN(disp));
+	else {
+		if (sig.interlaced)
+			__raw_writel((--vsync_cnt << DI_VSYNC_SEL_OFFSET) |
+					0x00000002, DI_SYNC_AS_GEN(disp));
+		else
+			__raw_writel((--vsync_cnt << DI_VSYNC_SEL_OFFSET),
+					DI_SYNC_AS_GEN(disp));
+	}
+
+	reg = __raw_readl(DI_POL(disp));
+	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
+	if (sig.enable_pol)
+		reg |= DI_POL_DRDY_POLARITY_15;
+	if (sig.data_pol)
+		reg |= DI_POL_DRDY_DATA_POLARITY;
+	__raw_writel(reg, DI_POL(disp));
+
+	__raw_writel(width, DC_DISP_CONF2(DC_DISP_ID_SYNC(disp)));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_sync_panel);
+
+
+int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
+			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig)
+{
+	unsigned long lock_flags;
+	int map;
+	u32 ser_conf = 0;
+	u32 div;
+	u32 di_clk = clk_get_rate(g_ipu_clk);
+
+	/* round up cycle_time, then calcalate the divider using scaled math */
+	cycle_time += (1000000000UL / di_clk) - 1;
+	div = (cycle_time * (di_clk / 256UL)) / (1000000000UL / 256UL);
+
+	map = _ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (type == IPU_PANEL_SERIAL) {
+		__raw_writel((div << 24) | ((sig.ifc_width - 1) << 4),
+			     DI_DW_GEN(disp, ASYNC_SER_WAVE));
+
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_CS,
+					0, 0, (div * 2) + 1);
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_SER_CLK,
+					1, div, div * 2);
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_SER_RS,
+					2, 0, 0);
+
+		_ipu_dc_write_tmpl(0x64, WROD(0), 0, map, ASYNC_SER_WAVE, 0, 0);
+
+		/* Configure DC for serial panel */
+		__raw_writel(0x14, DC_DISP_CONF1(DC_DISP_ID_SERIAL));
+
+		if (sig.clk_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_CLK_POL;
+		if (sig.data_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_DATA_POL;
+		if (sig.rs_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_RS_POL;
+		if (sig.cs_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_CS_POL;
+		__raw_writel(ser_conf, DI_SER_CONF(disp));
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_async_panel);
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes. This function also sets the DP graphic plane according to the
+ * parameter of IPUv3 DP channel.
+ *
+ * @param	channel		IPUv3 DP channel
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	unsigned long lock_flags;
+	bool bg_chan;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_BG_ASYNC0 ||
+	    channel == MEM_BG_ASYNC1)
+		bg_chan = true;
+	else
+		bg_chan = false;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bg_chan) {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	}
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		__raw_writel(reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	color_key_4rgb = 1;
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	if (((fg_csc_type == RGB2YUV) && (bg_csc_type == YUV2YUV)) ||
+			((fg_csc_type == YUV2YUV) && (bg_csc_type == RGB2YUV)) ||
+			((fg_csc_type == YUV2YUV) && (bg_csc_type == YUV2YUV)) ||
+			((fg_csc_type == YUV2RGB) && (bg_csc_type == YUV2RGB))) {
+
+		dev_dbg(g_ipu_dev, "color key 0x%x need change to yuv fmt\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		color_key_4rgb = 0;
+
+		dev_dbg(g_ipu_dev, "color key change to yuv fmt 0x%x\n", color_key);
+	}
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key);
+
+/*!
+ * This function sets the gamma correction for DP output.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable gamma correction.
+ *
+ * @param       constk		Gamma piecewise linear approximation constk coeff.
+ *
+ * @param       slopek		Gamma piecewise linear approximation slopek coeff.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_gamma_correction(ipu_channel_t channel, bool enable, int constk[], int slopek[])
+{
+	uint32_t reg, flow, i;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	for (i = 0; i < 8; i++)
+		__raw_writel((constk[2*i] & 0x1ff) | ((constk[2*i+1] & 0x1ff) << 16), DP_GAMMA_C(flow, i));
+	for (i = 0; i < 4; i++)
+		__raw_writel((slopek[4*i] & 0xff) | ((slopek[4*i+1] & 0xff) << 8) |
+			((slopek[4*i+2] & 0xff) << 16) | ((slopek[4*i+3] & 0xff) << 24), DP_GAMMA_S(flow, i));
+
+	reg = __raw_readl(DP_COM_CONF(flow));
+	if (enable) {
+		if ((bg_csc_type == RGB2YUV) || (bg_csc_type == YUV2YUV))
+			reg |= DP_COM_CONF_GAMMA_YUV_EN;
+		else
+			reg &= ~DP_COM_CONF_GAMMA_YUV_EN;
+		__raw_writel(reg | DP_COM_CONF_GAMMA_EN, DP_COM_CONF(flow));
+	} else
+		__raw_writel(reg & ~DP_COM_CONF_GAMMA_EN, DP_COM_CONF(flow));
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_gamma_correction);
+
+/*!
+ * This function sets the window position of the foreground or background plane.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       x_pos           The X coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @param       y_pos           The Y coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos)
+{
+	u32 reg;
+	unsigned long lock_flags;
+	uint32_t flow = 0;
+
+	if (channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel((x_pos << 16) | y_pos, DP_FG_POS(flow));
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_window_pos);
+
+void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset)
+{
+	if (channel == DIRECT_ASYNC0)
+		__raw_writel(value, ipu_disp_base[0] + offset);
+	else if (channel == DIRECT_ASYNC1)
+		__raw_writel(value, ipu_disp_base[1] + offset);
+}
+EXPORT_SYMBOL(ipu_disp_direct_write);
+
+void ipu_reset_disp_panel(void)
+{
+	uint32_t tmp;
+
+	tmp = __raw_readl(DI_GENERAL(1));
+	__raw_writel(tmp | 0x08, DI_GENERAL(1));
+	msleep(10); /* tRES >= 100us */
+	tmp = __raw_readl(DI_GENERAL(1));
+	__raw_writel(tmp & ~0x08, DI_GENERAL(1));
+	msleep(60);
+
+	return;
+}
+EXPORT_SYMBOL(ipu_reset_disp_panel);
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
new file mode 100644
index 0000000..564fab0
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -0,0 +1,835 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_ic.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum {
+	IC_TASK_VIEWFINDER,
+	IC_TASK_ENCODER,
+	IC_TASK_POST_PROCESSOR
+};
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format, int csc_index);
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff);
+
+void _ipu_vdi_set_top_field_man(bool top_field_0)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(VDI_C);
+	if (top_field_0)
+		reg &= ~VDI_C_TOP_FIELD_MAN_1;
+	else
+		reg |= VDI_C_TOP_FIELD_MAN_1;
+	__raw_writel(reg, VDI_C);
+}
+
+void _ipu_vdi_set_motion(ipu_motion_sel motion_sel)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(VDI_C);
+	reg &= ~(VDI_C_MOT_SEL_FULL | VDI_C_MOT_SEL_MED | VDI_C_MOT_SEL_LOW);
+	if (motion_sel == HIGH_MOTION)
+		reg |= VDI_C_MOT_SEL_FULL;
+	else if (motion_sel == MED_MOTION)
+		reg |= VDI_C_MOT_SEL_MED;
+	else
+		reg |= VDI_C_MOT_SEL_LOW;
+
+	__raw_writel(reg, VDI_C);
+}
+
+void ic_dump_register(void)
+{
+	printk(KERN_DEBUG "IC_CONF = \t0x%08X\n", __raw_readl(IC_CONF));
+	printk(KERN_DEBUG "IC_PRP_ENC_RSC = \t0x%08X\n",
+	       __raw_readl(IC_PRP_ENC_RSC));
+	printk(KERN_DEBUG "IC_PRP_VF_RSC = \t0x%08X\n",
+	       __raw_readl(IC_PRP_VF_RSC));
+	printk(KERN_DEBUG "IC_PP_RSC = \t0x%08X\n", __raw_readl(IC_PP_RSC));
+	printk(KERN_DEBUG "IC_IDMAC_1 = \t0x%08X\n", __raw_readl(IC_IDMAC_1));
+	printk(KERN_DEBUG "IC_IDMAC_2 = \t0x%08X\n", __raw_readl(IC_IDMAC_2));
+	printk(KERN_DEBUG "IC_IDMAC_3 = \t0x%08X\n", __raw_readl(IC_IDMAC_3));
+}
+
+void _ipu_ic_enable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_EN;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf |= IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf |= IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_disable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_EN;
+		break;
+	case MEM_VDI_PRP_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_vdi_init(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	uint32_t pixel_fmt;
+	bool top_field_0;
+
+	reg = ((params->mem_prp_vf_mem.in_height-1) << 16) |
+	  (params->mem_prp_vf_mem.in_width-1);
+	__raw_writel(reg, VDI_FSIZE);
+
+	/* Full motion, only vertical filter is used
+	   Burst size is 4 accesses */
+	pixel_fmt =
+	    (params->mem_prp_vf_mem.in_pixel_fmt ==
+	     V4L2_PIX_FMT_YUV422P) ? VDI_C_CH_422 : VDI_C_CH_420;
+
+	reg = __raw_readl(VDI_C);
+	reg |= pixel_fmt;
+	switch (channel) {
+	case MEM_VDI_PRP_VF_MEM:
+		reg |= VDI_C_BURST_SIZE2_4;
+		break;
+	case MEM_VDI_PRP_VF_MEM_P:
+		reg |= VDI_C_BURST_SIZE1_4 | VDI_C_VWM1_SET_1 | VDI_C_VWM1_CLR_2;
+		break;
+	case MEM_VDI_PRP_VF_MEM_N:
+		reg |= VDI_C_BURST_SIZE3_4 | VDI_C_VWM3_SET_1 | VDI_C_VWM3_CLR_2;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(reg, VDI_C);
+
+	/* MED_MOTION and LOW_MOTION algorithm that are using 3 fields
+	 * should start presenting using the 2nd field.
+	 */
+	if (((params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_TB) &&
+	     (params->mem_prp_vf_mem.motion_sel != HIGH_MOTION)) ||
+	    ((params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_BT) &&
+	     (params->mem_prp_vf_mem.motion_sel == HIGH_MOTION)))
+		top_field_0 = false;
+	else
+		top_field_0 = true;
+
+	/* Buffer selection toggle the value therefore init val is inverted. */
+	_ipu_vdi_set_top_field_man(!top_field_0);
+
+	_ipu_vdi_set_motion(params->mem_prp_vf_mem.motion_sel);
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_RWS_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_vdi_uninit(void)
+{
+	__raw_writel(0, VDI_FSIZE);
+	__raw_writel(0, VDI_C);
+}
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_height,
+			    params->mem_prp_vf_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	/* Upadeted for IC split case */
+	if (!(params->mem_prp_vf_mem.out_resize_ratio)) {
+		_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
+				params->mem_prp_vf_mem.out_width,
+				&resizeCoeff, &downsizeCoeff);
+		reg |= (downsizeCoeff << 14) | resizeCoeff;
+	} else
+		reg |= params->mem_prp_vf_mem.out_resize_ratio;
+
+	__raw_writel(reg, IC_PRP_VF_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_prp_vf_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PRPVF_CMB;
+
+		if (!(ic_conf & IC_CONF_PRPVF_CSC1)) {
+			/* need transparent CSC1 conversion */
+			_init_csc(IC_TASK_VIEWFINDER, RGB, RGB, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;  /* Enable RGB->RGB CSC */
+		}
+		in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_g_pixel_fmt);
+		out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+		if (in_fmt == RGB) {
+			if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+				/* Enable RGB->YCBCR CSC2 */
+				_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt, 2);
+				ic_conf |= IC_CONF_PRPVF_CSC2;
+			}
+		}
+		if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+			if (out_fmt == RGB) {
+				/* Enable YCBCR->RGB CSC2 */
+				_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB, 2);
+				ic_conf |= IC_CONF_PRPVF_CSC2;
+			} else {
+				/* TODO: Support YUV<->YCbCr conversion? */
+			}
+		}
+
+		if (params->mem_prp_vf_mem.global_alpha_en) {
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+			reg = __raw_readl(IC_CMBP_1);
+			reg &= ~(0xff);
+			reg |= params->mem_prp_vf_mem.alpha;
+			__raw_writel(reg, IC_CMBP_1);
+		} else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_prp_vf_mem.key_color_en) {
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+			__raw_writel(params->mem_prp_vf_mem.key_color,
+					IC_CMBP_2);
+		} else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PRPVF_CMB;
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpvf(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPVF_EN | IC_CONF_PRPVF_CMB |
+		 IC_CONF_PRPVF_CSC2 | IC_CONF_PRPVF_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_vf(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PRPVF_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_height,
+			    params->mem_prp_enc_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	/* Upadeted for IC split case */
+	if (!(params->mem_prp_enc_mem.out_resize_ratio)) {
+		_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
+				params->mem_prp_enc_mem.out_width,
+				&resizeCoeff, &downsizeCoeff);
+		reg |= (downsizeCoeff << 14) | resizeCoeff;
+	} else
+		reg |= params->mem_prp_enc_mem.out_resize_ratio;
+
+	__raw_writel(reg, IC_PRP_ENC_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_enc_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_enc_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_ENCODER, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_ENCODER, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpenc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_enc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_ROT_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_pp(ipu_channel_params_t *params)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_height,
+			    params->mem_pp_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	/* Upadeted for IC split case */
+	if (!(params->mem_pp_mem.out_resize_ratio)) {
+		_calc_resize_coeffs(params->mem_pp_mem.in_width,
+							params->mem_pp_mem.out_width,
+							&resizeCoeff, &downsizeCoeff);
+		reg |= (downsizeCoeff << 14) | resizeCoeff;
+	} else {
+		reg |= params->mem_pp_mem.out_resize_ratio;
+	}
+
+	__raw_writel(reg, IC_PP_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_pp_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PP_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PP_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_pp_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PP_CMB;
+
+		if (!(ic_conf & IC_CONF_PP_CSC1)) {
+			/* need transparent CSC1 conversion */
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB, 1);
+			ic_conf |= IC_CONF_PP_CSC1;  /* Enable RGB->RGB CSC */
+		}
+
+		in_fmt = format_to_colorspace(params->mem_pp_mem.in_g_pixel_fmt);
+		out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+		if (in_fmt == RGB) {
+			if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+				/* Enable RGB->YCBCR CSC2 */
+				_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt, 2);
+				ic_conf |= IC_CONF_PP_CSC2;
+			}
+		}
+		if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+			if (out_fmt == RGB) {
+				/* Enable YCBCR->RGB CSC2 */
+				_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB, 2);
+				ic_conf |= IC_CONF_PP_CSC2;
+			} else {
+				/* TODO: Support YUV<->YCbCr conversion? */
+			}
+		}
+
+		if (params->mem_pp_mem.global_alpha_en) {
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+			reg = __raw_readl(IC_CMBP_1);
+			reg &= ~(0xff00);
+			reg |= (params->mem_pp_mem.alpha << 8);
+			__raw_writel(reg, IC_CMBP_1);
+		} else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_pp_mem.key_color_en) {
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+			__raw_writel(params->mem_pp_mem.key_color,
+					IC_CMBP_2);
+		} else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PP_CMB;
+	}
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_pp(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PP_EN | IC_CONF_PP_CSC1 | IC_CONF_PP_CSC2 |
+		 IC_CONF_PP_CMB);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_pp(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PP_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot)
+{
+	u32 ic_idmac_1, ic_idmac_2, ic_idmac_3;
+	u32 temp_rot = bitrev8(rot) >> 5;
+	bool need_hor_flip = false;
+
+	if ((burst_size != 8) && (burst_size != 16)) {
+		dev_dbg(g_ipu_dev, "Illegal burst length for IC\n");
+		return -EINVAL;
+	}
+
+	width--;
+	height--;
+
+	if (temp_rot & 0x2)	/* Need horizontal flip */
+		need_hor_flip = true;
+
+	ic_idmac_1 = __raw_readl(IC_IDMAC_1);
+	ic_idmac_2 = __raw_readl(IC_IDMAC_2);
+	ic_idmac_3 = __raw_readl(IC_IDMAC_3);
+	if (dma_chan == 22) {	/* PP output - CB2 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;
+
+	} else if (dma_chan == 11) {	/* PP Input - CB5 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;
+	} else if (dma_chan == 47) {	/* PP Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;
+	}
+
+	if (dma_chan == 12) {	/* PRP Input - CB6 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;
+	}
+
+	if (dma_chan == 20) {	/* PRP ENC output - CB0 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;
+
+	} else if (dma_chan == 45) {	/* PRP ENC Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;
+	}
+
+	if (dma_chan == 21) {	/* PRP VF output - CB1 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;
+
+	} else if (dma_chan == 46) {	/* PRP VF Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;
+	}
+
+	if (dma_chan == 14) {	/* PRP VF graphics combining input - CB3 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;
+	} else if (dma_chan == 15) {	/* PP graphics combining input - CB4 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;
+	}
+
+	__raw_writel(ic_idmac_1, IC_IDMAC_1);
+	__raw_writel(ic_idmac_2, IC_IDMAC_2);
+	__raw_writel(ic_idmac_3, IC_IDMAC_3);
+
+	return 0;
+}
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format, int csc_index)
+{
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+	static const uint32_t rgb2ycbcr_coeff[4][3] = {
+		{0x004D, 0x0096, 0x001D},
+		{0x01D5, 0x01AB, 0x0080},
+		{0x0080, 0x0195, 0x01EB},
+		{0x0000, 0x0200, 0x0200},	/* A0, A1, A2 */
+	};
+
+	/* transparent RGB->RGB matrix for combining
+	 */
+	static const uint32_t rgb2rgb_coeff[4][3] = {
+		{0x0080, 0x0000, 0x0000},
+		{0x0000, 0x0080, 0x0000},
+		{0x0000, 0x0000, 0x0080},
+		{0x0000, 0x0000, 0x0000},	/* A0, A1, A2 */
+	};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+	static const uint32_t ycbcr2rgb_coeff[4][3] = {
+		{149, 0, 204},
+		{149, 462, 408},
+		{149, 255, 0},
+		{8192 - 446, 266, 8192 - 554},	/* A0, A1, A2 */
+	};
+
+	uint32_t param;
+	uint32_t *base = NULL;
+
+	if (ic_task == IC_TASK_ENCODER) {
+		base = ipu_tpmem_base + 0x2008 / 4;
+	} else if (ic_task == IC_TASK_VIEWFINDER) {
+		if (csc_index == 1)
+			base = ipu_tpmem_base + 0x4028 / 4;
+		else
+			base = ipu_tpmem_base + 0x4040 / 4;
+	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+		if (csc_index == 1)
+			base = ipu_tpmem_base + 0x6060 / 4;
+		else
+			base = ipu_tpmem_base + 0x6078 / 4;
+	} else {
+		BUG();
+	}
+
+	if ((in_format == YCbCr) && (out_format == RGB)) {
+		/* Init CSC (YCbCr->RGB) */
+		param = (ycbcr2rgb_coeff[3][0] << 27) |
+			(ycbcr2rgb_coeff[0][0] << 18) |
+			(ycbcr2rgb_coeff[1][1] << 9) | ycbcr2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (ycbcr2rgb_coeff[3][0] >> 5) | (2L << (40 - 32));
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][1] << 27) |
+			(ycbcr2rgb_coeff[0][1] << 18) |
+			(ycbcr2rgb_coeff[1][0] << 9) | ycbcr2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][2] << 27) |
+			(ycbcr2rgb_coeff[0][2] << 18) |
+			(ycbcr2rgb_coeff[1][2] << 9) | ycbcr2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == YCbCr)) {
+		/* Init CSC (RGB->YCbCr) */
+		param = (rgb2ycbcr_coeff[3][0] << 27) |
+			(rgb2ycbcr_coeff[0][0] << 18) |
+			(rgb2ycbcr_coeff[1][1] << 9) | rgb2ycbcr_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 1, sat = 0 */
+		param = (rgb2ycbcr_coeff[3][0] >> 5) | (1UL << 8);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][1] << 27) |
+			(rgb2ycbcr_coeff[0][1] << 18) |
+			(rgb2ycbcr_coeff[1][0] << 9) | rgb2ycbcr_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][2] << 27) |
+			(rgb2ycbcr_coeff[0][2] << 18) |
+			(rgb2ycbcr_coeff[1][2] << 9) | rgb2ycbcr_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == RGB)) {
+		/* Init CSC */
+		param =
+		    (rgb2rgb_coeff[3][0] << 27) | (rgb2rgb_coeff[0][0] << 18) |
+		    (rgb2rgb_coeff[1][1] << 9) | rgb2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (rgb2rgb_coeff[3][0] >> 5) | (2UL << 8);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][1] << 27) | (rgb2rgb_coeff[0][1] << 18) |
+		    (rgb2rgb_coeff[1][0] << 9) | rgb2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][2] << 27) | (rgb2rgb_coeff[0][2] << 18) |
+		    (rgb2rgb_coeff[1][2] << 9) | rgb2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else {
+		dev_err(g_ipu_dev, "Unsupported color space conversion\n");
+	}
+}
+
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff)
+{
+	uint32_t tempSize;
+	uint32_t tempDownsize;
+
+	/* Input size cannot be more than 4096 */
+	/* Output size cannot be more than 1024 */
+	if ((inSize > 4096) || (outSize > 1024))
+		return false;
+
+	/* Cannot downsize more than 8:1 */
+	if ((outSize << 3) < inSize)
+		return false;
+
+	/* Compute downsizing coefficient */
+	/* Output of downsizing unit cannot be more than 1024 */
+	tempDownsize = 0;
+	tempSize = inSize;
+	while (((tempSize > 1024) || (tempSize >= outSize * 2)) &&
+	       (tempDownsize < 2)) {
+		tempSize >>= 1;
+		tempDownsize++;
+	}
+	*downsizeCoeff = tempDownsize;
+
+	/* compute resizing coefficient using the following equation:
+	   resizeCoeff = M*(SI -1)/(SO - 1)
+	   where M = 2^13, SI - input size, SO - output size    */
+	*resizeCoeff = (8192L * (tempSize - 1)) / (outSize - 1);
+	if (*resizeCoeff >= 16384L) {
+		dev_err(g_ipu_dev, "Warning! Overflow on resize coeff.\n");
+		*resizeCoeff = 0x3FFF;
+	}
+
+	dev_dbg(g_ipu_dev, "resizing from %u -> %u pixels, "
+		"downsize=%u, resize=%u.%lu (reg=%u)\n", inSize, outSize,
+		*downsizeCoeff, (*resizeCoeff >= 8192L) ? 1 : 0,
+		((*resizeCoeff & 0x1FFF) * 10000L) / 8192L, *resizeCoeff);
+
+	return true;
+}
+
+void _ipu_vdi_toggle_top_field_man()
+{
+	uint32_t reg;
+	uint32_t mask_reg;
+
+	reg = __raw_readl(VDI_C);
+	mask_reg = reg & VDI_C_TOP_FIELD_MAN_1;
+	if (mask_reg == VDI_C_TOP_FIELD_MAN_1)
+		reg &= ~VDI_C_TOP_FIELD_MAN_1;
+	else
+		reg |= VDI_C_TOP_FIELD_MAN_1;
+
+	__raw_writel(reg, VDI_C);
+}
+
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
new file mode 100644
index 0000000..9a56fd8
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PARAM_MEM_H__
+#define __INCLUDE_IPU_PARAM_MEM_H__
+
+#include <linux/types.h>
+#include <linux/bitrev.h>
+
+extern u32 *ipu_cpmem_base;
+
+struct ipu_ch_param_word {
+	uint32_t data[5];
+	uint32_t res[3];
+};
+
+struct ipu_ch_param {
+	struct ipu_ch_param_word word[2];
+};
+
+#define ipu_ch_param_addr(ch) (((struct ipu_ch_param *)ipu_cpmem_base) + (ch))
+
+#define _param_word(base, w) \
+	(((struct ipu_ch_param *)(base))->word[(w)].data)
+
+#define ipu_ch_param_set_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	_param_word(base, w)[i] |= (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		_param_word(base, w)[i + 1] |= (v) >> (off ? (32 - off) : 0); \
+	} \
+}
+
+#define ipu_ch_param_mod_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp = _param_word(base, w)[i]; \
+	temp &= ~(mask << off); \
+	_param_word(base, w)[i] = temp | (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp = _param_word(base, w)[i + 1]; \
+		temp &= ~(mask >> (32 - off)); \
+		_param_word(base, w)[i + 1] = \
+			temp | ((v) >> (off ? (32 - off) : 0)); \
+	} \
+}
+
+#define ipu_ch_param_read_field(base, w, bit, size) ({ \
+	u32 temp2; \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp1 = _param_word(base, w)[i]; \
+	temp1 = mask & (temp1 >> off); \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp2 = _param_word(base, w)[i + 1]; \
+		temp2 &= mask >> (off ? (32 - off) : 0); \
+		temp1 |= temp2 << (off ? (32 - off) : 0); \
+	} \
+	temp1; \
+})
+
+static inline void _ipu_ch_params_set_packing(struct ipu_ch_param *p,
+					      int red_width, int red_offset,
+					      int green_width, int green_offset,
+					      int blue_width, int blue_offset,
+					      int alpha_width, int alpha_offset)
+{
+	/* Setup red width and offset */
+	ipu_ch_param_set_field(p, 1, 116, 3, red_width - 1);
+	ipu_ch_param_set_field(p, 1, 128, 5, red_offset);
+	/* Setup green width and offset */
+	ipu_ch_param_set_field(p, 1, 119, 3, green_width - 1);
+	ipu_ch_param_set_field(p, 1, 133, 5, green_offset);
+	/* Setup blue width and offset */
+	ipu_ch_param_set_field(p, 1, 122, 3, blue_width - 1);
+	ipu_ch_param_set_field(p, 1, 138, 5, blue_offset);
+	/* Setup alpha width and offset */
+	ipu_ch_param_set_field(p, 1, 125, 3, alpha_width - 1);
+	ipu_ch_param_set_field(p, 1, 143, 5, alpha_offset);
+}
+
+static inline void _ipu_ch_param_dump(int ch)
+{
+	struct ipu_ch_param *p = ipu_ch_param_addr(ch);
+	pr_debug("ch %d word 0 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[0].data[0], p->word[0].data[1], p->word[0].data[2],
+		 p->word[0].data[3], p->word[0].data[4]);
+	pr_debug("ch %d word 1 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[1].data[0], p->word[1].data[1], p->word[1].data[2],
+		 p->word[1].data[3], p->word[1].data[4]);
+	pr_debug("PFS 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 85, 4));
+	pr_debug("BPP 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 107, 3));
+	pr_debug("NPB 0x%x\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7));
+
+	pr_debug("FW %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 125, 13));
+	pr_debug("FH %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 138, 12));
+	pr_debug("Stride %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14));
+
+	pr_debug("Width0 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 116, 3));
+	pr_debug("Width1 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 119, 3));
+	pr_debug("Width2 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 122, 3));
+	pr_debug("Width3 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 125, 3));
+	pr_debug("Offset0 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 128, 5));
+	pr_debug("Offset1 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 133, 5));
+	pr_debug("Offset2 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 138, 5));
+	pr_debug("Offset3 %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 143, 5));
+}
+
+static inline void _ipu_ch_param_init(int ch,
+				      uint32_t pixel_fmt, uint32_t width,
+				      uint32_t height, uint32_t stride,
+				      uint32_t u, uint32_t v,
+				      uint32_t uv_stride, dma_addr_t addr0,
+				      dma_addr_t addr1)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	struct ipu_ch_param params;
+
+	memset(&params, 0, sizeof(params));
+
+	ipu_ch_param_set_field(&params, 0, 125, 13, width - 1);
+
+	if ((ch == 8) || (ch == 9) || (ch == 10)) {
+		ipu_ch_param_set_field(&params, 0, 138, 12, (height / 2) - 1);
+		ipu_ch_param_set_field(&params, 1, 102, 14, (stride * 2) - 1);
+	} else {
+		ipu_ch_param_set_field(&params, 0, 138, 12, height - 1);
+		ipu_ch_param_set_field(&params, 1, 102, 14, stride - 1);
+	}
+
+	ipu_ch_param_set_field(&params, 1, 0, 29, addr0 >> 3);
+	ipu_ch_param_set_field(&params, 1, 29, 29, addr1 >> 3);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/*Represents 8-bit Generic data */
+		ipu_ch_param_set_field(&params, 0, 107, 3, 5);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 63);	/* burst size */
+
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/*Represents 32-bit Generic data */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 5, 0, 6, 5, 5, 11, 8, 16);
+		break;
+	case IPU_PIX_FMT_BGR24:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 8, 24);
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 16, 8, 8, 8, 0, 8, 24);
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 8, 8, 16, 8, 24, 8, 0);
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 24, 8, 16, 8, 8, 8, 0);
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+
+		_ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 8, 24);
+		break;
+	case IPU_PIX_FMT_UYVY:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0xA);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUYV:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0x8);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		ipu_ch_param_set_field(&params, 1, 85, 4, 2);	/* pix format */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = stride * height;
+		v_offset = u_offset + (uv_stride * height / 2);
+		if ((ch == 8) || (ch == 9) || (ch == 10)) {
+			ipu_ch_param_set_field(&params, 1, 78, 7, 15);  /* burst size */
+			uv_stride = uv_stride*2;
+		} else {
+			ipu_ch_param_set_field(&params, 1, 78, 7, 31);  /* burst size */
+		}
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	case IPU_PIX_FMT_NV12:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 4);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		uv_stride = stride;
+		u_offset = (u == 0) ? stride * height : u;
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+	/*set burst size to 16*/
+
+
+	if (uv_stride)
+		ipu_ch_param_set_field(&params, 1, 128, 14, uv_stride - 1);
+
+	if (u > u_offset)
+		u_offset = u;
+
+	if (v > v_offset)
+		v_offset = v;
+
+	ipu_ch_param_set_field(&params, 0, 46, 22, u_offset / 8);
+	ipu_ch_param_set_field(&params, 0, 68, 22, v_offset / 8);
+
+	pr_debug("initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ch));
+	memcpy(ipu_ch_param_addr(ch), &params, sizeof(params));
+};
+
+static inline void _ipu_ch_param_set_burst_size(uint32_t ch,
+						uint16_t burst_pixels)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 78, 7,
+			       burst_pixels - 1);
+};
+
+static inline int _ipu_ch_param_get_burst_size(uint32_t ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7) + 1;
+};
+
+static inline int _ipu_ch_param_get_bpp(uint32_t ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 107, 3);
+};
+
+static inline void _ipu_ch_param_set_buffer(uint32_t ch, int bufNum,
+					    dma_addr_t phyaddr)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 29 * bufNum, 29,
+			       phyaddr / 8);
+};
+
+static inline void _ipu_ch_param_set_rotation(uint32_t ch,
+					      ipu_rotate_mode_t rot)
+{
+	u32 temp_rot = bitrev8(rot) >> 5;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 119, 3, temp_rot);
+};
+
+static inline void _ipu_ch_param_set_block_mode(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 117, 2, 1);
+};
+
+static inline void _ipu_ch_param_set_alpha_use_separate_channel(uint32_t ch,
+								bool option)
+{
+	if (option) {
+		ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 89, 1, 1);
+	} else {
+		ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 89, 1, 0);
+	}
+};
+
+static inline void _ipu_ch_param_set_alpha_condition_read(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 149, 1, 1);
+};
+
+static inline void _ipu_ch_param_set_alpha_buffer_memory(uint32_t ch)
+{
+	int alp_mem_idx;
+
+	switch (ch) {
+	case 14: /* PRP graphic */
+		alp_mem_idx = 0;
+		break;
+	case 15: /* PP graphic */
+		alp_mem_idx = 1;
+		break;
+	case 23: /* DP BG SYNC graphic */
+		alp_mem_idx = 4;
+		break;
+	case 27: /* DP FG SYNC graphic */
+		alp_mem_idx = 2;
+		break;
+	default:
+		dev_err(g_ipu_dev, "unsupported correlative channel of local "
+			"alpha channel\n");
+		return;
+	}
+
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 90, 3, alp_mem_idx);
+};
+
+static inline void _ipu_ch_param_set_interlaced_scan(uint32_t ch)
+{
+	u32 stride;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), 0, 113, 1, 1);
+	stride = ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14) + 1;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 58, 20, stride / 8);
+	stride *= 2;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 102, 14, stride - 1);
+};
+
+static inline void _ipu_ch_param_set_high_priority(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 93, 2, 1);
+};
+
+/* IDMAC U/V offset changing support */
+/* U and V input is not affected, */
+/* the update is done by new calculation according to */
+/* vertical_offset and horizontal_offset */
+static inline void _ipu_ch_offset_update(int ch,
+					uint32_t pixel_fmt,
+					uint32_t width,
+					uint32_t height,
+					uint32_t stride,
+					uint32_t u,
+					uint32_t v,
+					uint32_t uv_stride,
+					uint32_t vertical_offset,
+					uint32_t horizontal_offset)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	uint32_t u_fix = 0;
+	uint32_t v_fix = 0;
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_GENERIC_32:
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_ABGR32:
+	case IPU_PIX_FMT_UYVY:
+	case IPU_PIX_FMT_YUYV:
+		break;
+
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = stride * (height - vertical_offset - 1) +
+					(stride - horizontal_offset) +
+					(uv_stride * vertical_offset / 2) +
+					horizontal_offset / 2;
+		v_offset = u_offset + (uv_stride * height / 2);
+		u_fix = u ? (u + (uv_stride * vertical_offset) +
+					(horizontal_offset / 2) -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					u_offset;
+		v_fix = v ? (v + (uv_stride * vertical_offset / 2) +
+					(horizontal_offset / 2) -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					v_offset;
+
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		v_offset = stride * (height - vertical_offset - 1) +
+					(stride - horizontal_offset) +
+					(uv_stride * vertical_offset) +
+					horizontal_offset / 2;
+		u_offset = v_offset + uv_stride * height;
+		u_fix = u ? (u + (uv_stride * vertical_offset) +
+					horizontal_offset / 2 -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					u_offset;
+		v_fix = v ? (v + (uv_stride * vertical_offset) +
+					horizontal_offset / 2 -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					v_offset;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = stride * (height - vertical_offset - 1) +
+					(stride - horizontal_offset) +
+					(uv_stride * vertical_offset) +
+					horizontal_offset / 2;
+		v_offset = u_offset + uv_stride * height;
+		u_fix = u ? (u + (uv_stride * vertical_offset) +
+					horizontal_offset / 2 -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					u_offset;
+		v_fix = v ? (v + (uv_stride * vertical_offset) +
+					horizontal_offset / 2 -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					v_offset;
+		break;
+
+	case IPU_PIX_FMT_NV12:
+		uv_stride = stride;
+		u_offset = stride * (height - vertical_offset - 1) +
+					(stride - horizontal_offset) +
+					(uv_stride * vertical_offset) +
+					horizontal_offset;
+		u_fix = u ? (u + (uv_stride * vertical_offset) +
+					horizontal_offset -
+					(stride * vertical_offset) - (horizontal_offset)) :
+					u_offset;
+
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+
+
+
+	if (u_fix > u_offset)
+		u_offset = u_fix;
+
+	if (v_fix > v_offset)
+		v_offset = v_fix;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 46, 22, u_offset / 8);
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 68, 22, v_offset / 8);
+
+};
+
+static inline void _ipu_ch_params_set_alpha_width(uint32_t ch, int alpha_width)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), 1, 125, 3, alpha_width - 1);
+};
+
+#endif
diff --git a/drivers/mxc/ipu3/ipu_prv.h b/drivers/mxc/ipu3/ipu_prv.h
new file mode 100644
index 0000000..213ded0
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_prv.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PRV_H__
+#define __INCLUDE_IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+
+/* Globals */
+extern struct device *g_ipu_dev;
+extern spinlock_t ipu_lock;
+extern bool g_ipu_clk_enabled;
+extern struct clk *g_ipu_clk;
+extern struct clk *g_di_clk[2];
+extern struct clk *g_pixel_clk[2];
+extern struct clk *g_csi_clk[2];
+extern unsigned char g_dc_di_assignment[];
+extern int g_ipu_hw_rev;
+extern int dmfc_type_setup;
+
+#define IDMA_CHAN_INVALID	0xFF
+#define HIGH_RESOLUTION_WIDTH	1024
+
+struct ipu_channel {
+	u8 video_in_dma;
+	u8 alpha_in_dma;
+	u8 graph_in_dma;
+	u8 out_dma;
+};
+
+enum ipu_dmfc_type {
+	DMFC_NORMAL = 0,
+	DMFC_HIGH_RESOLUTION_DC,
+	DMFC_HIGH_RESOLUTION_DP,
+	DMFC_HIGH_RESOLUTION_ONLY_DP,
+};
+
+int register_ipu_device(void);
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+bool ipu_pixel_format_has_alpha(uint32_t fmt);
+
+void ipu_dump_registers(void);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel);
+
+void _ipu_init_dc_mappings(void);
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt);
+void _ipu_dp_uninit(ipu_channel_t channel);
+void _ipu_dc_init(int dc_chan, int di, bool interlaced);
+void _ipu_dc_uninit(int dc_chan);
+void _ipu_dp_dc_enable(ipu_channel_t channel);
+void _ipu_dp_dc_disable(ipu_channel_t channel, bool swap);
+void _ipu_dmfc_init(int dmfc_type, int first);
+void _ipu_dmfc_set_wait4eot(int dma_chan, int width);
+int _ipu_chan_is_interlaced(ipu_channel_t channel);
+
+void _ipu_ic_enable_task(ipu_channel_t channel);
+void _ipu_ic_disable_task(ipu_channel_t channel);
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_vdi_init(ipu_channel_t channel, ipu_channel_params_t *params);
+void _ipu_vdi_uninit(void);
+void _ipu_ic_uninit_prpvf(void);
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_vf(void);
+void _ipu_ic_init_csi(ipu_channel_params_t *params);
+void _ipu_ic_uninit_csi(void);
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpenc(void);
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_enc(void);
+void _ipu_ic_init_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_pp(void);
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_pp(void);
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot);
+void _ipu_vdi_toggle_top_field_man(void);
+int _ipu_csi_init(ipu_channel_t channel, uint32_t csi);
+void ipu_csi_set_test_generator(bool active, uint32_t r_value,
+		uint32_t g_value, uint32_t b_value,
+		uint32_t pix_clk, uint32_t csi);
+void _ipu_csi_ccir_err_detection_enable(uint32_t csi);
+void _ipu_csi_ccir_err_detection_disable(uint32_t csi);
+void _ipu_smfc_init(ipu_channel_t channel, uint32_t mipi_id, uint32_t csi);
+void _ipu_smfc_set_burst_size(ipu_channel_t channel, uint32_t bs);
+void _ipu_dp_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
+
+#endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu3/ipu_regs.h b/drivers/mxc/ipu3/ipu_regs.h
new file mode 100644
index 0000000..f31e181
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_regs.h
@@ -0,0 +1,658 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_regs.h
+ *
+ * @brief IPU Register definitions
+ *
+ * @ingroup IPU
+ */
+#ifndef __IPU_REGS_INCLUDED__
+#define __IPU_REGS_INCLUDED__
+
+#define IPU_DISP0_BASE		0x00000000
+#define IPU_MCU_T_DEFAULT	8
+#define IPU_DISP1_BASE		(IPU_MCU_T_DEFAULT << 25)
+#define IPU_CM_REG_BASE		0x1E000000
+#define IPU_IDMAC_REG_BASE	0x1E008000
+#define IPU_ISP_REG_BASE	0x1E010000
+#define IPU_DP_REG_BASE		0x1E018000
+#define IPU_IC_REG_BASE		0x1E020000
+#define IPU_IRT_REG_BASE	0x1E028000
+#define IPU_CSI0_REG_BASE	0x1E030000
+#define IPU_CSI1_REG_BASE	0x1E038000
+#define IPU_DI0_REG_BASE	0x1E040000
+#define IPU_DI1_REG_BASE	0x1E048000
+#define IPU_SMFC_REG_BASE	0x1E050000
+#define IPU_DC_REG_BASE		0x1E058000
+#define IPU_DMFC_REG_BASE	0x1E060000
+#define IPU_CPMEM_REG_BASE	0x1F000000
+#define IPU_LUT_REG_BASE	0x1F020000
+#define IPU_SRM_REG_BASE	0x1F040000
+#define IPU_TPM_REG_BASE	0x1F060000
+#define IPU_DC_TMPL_REG_BASE	0x1F080000
+#define IPU_ISP_TBPR_REG_BASE	0x1F0C0000
+#define IPU_VDI_REG_BASE	0x1E068000
+
+
+extern u32 *ipu_cm_reg;
+extern u32 *ipu_idmac_reg;
+extern u32 *ipu_dp_reg;
+extern u32 *ipu_ic_reg;
+extern u32 *ipu_dc_reg;
+extern u32 *ipu_dc_tmpl_reg;
+extern u32 *ipu_dmfc_reg;
+extern u32 *ipu_di_reg[];
+extern u32 *ipu_smfc_reg;
+extern u32 *ipu_csi_reg[];
+extern u32 *ipu_tpmem_base;
+extern u32 *ipu_disp_base[];
+extern u32 *ipu_vdi_reg;
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CONF		(ipu_cm_reg)
+
+#define IPU_SRM_PRI1		(ipu_cm_reg + 0x00A0/4)
+#define IPU_SRM_PRI2		(ipu_cm_reg + 0x00A4/4)
+#define IPU_FS_PROC_FLOW1	(ipu_cm_reg + 0x00A8/4)
+#define IPU_FS_PROC_FLOW2	(ipu_cm_reg + 0x00AC/4)
+#define IPU_FS_PROC_FLOW3	(ipu_cm_reg + 0x00B0/4)
+#define IPU_FS_DISP_FLOW1	(ipu_cm_reg + 0x00B4/4)
+#define IPU_FS_DISP_FLOW2	(ipu_cm_reg + 0x00B8/4)
+#define IPU_SKIP		(ipu_cm_reg + 0x00BC/4)
+#define IPU_DISP_ALT_CONF	(ipu_cm_reg + 0x00C0/4)
+#define IPU_DISP_GEN		(ipu_cm_reg + 0x00C4/4)
+#define IPU_DISP_ALT1		(ipu_cm_reg + 0x00C8/4)
+#define IPU_DISP_ALT2		(ipu_cm_reg + 0x00CC/4)
+#define IPU_DISP_ALT3		(ipu_cm_reg + 0x00D0/4)
+#define IPU_DISP_ALT4		(ipu_cm_reg + 0x00D4/4)
+#define IPU_SNOOP		(ipu_cm_reg + 0x00D8/4)
+#define IPU_MEM_RST		(ipu_cm_reg + 0x00DC/4)
+#define IPU_PM			(ipu_cm_reg + 0x00E0/4)
+#define IPU_GPR			(ipu_cm_reg + 0x00E4/4)
+#define IPU_CHA_DB_MODE_SEL(ch)	(ipu_cm_reg + 0x0150/4 + (ch / 32))
+#define IPU_ALT_CHA_DB_MODE_SEL(ch) (ipu_cm_reg + 0x0168/4 + (ch / 32))
+#define IPU_CHA_CUR_BUF(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x023C/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0124/4 + (ch / 32)); })
+#define IPU_ALT_CUR_BUF0	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0244/4) : \
+				  (ipu_cm_reg + 0x012C/4); })
+#define IPU_ALT_CUR_BUF1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0248/4) : \
+				  (ipu_cm_reg + 0x0130/4); })
+#define IPU_SRM_STAT		({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x024C/4) : \
+				  (ipu_cm_reg + 0x0134/4); })
+#define IPU_PROC_TASK_STAT	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0250/4) : \
+				  (ipu_cm_reg + 0x0138/4); })
+#define IPU_DISP_TASK_STAT	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0254/4) : \
+				  (ipu_cm_reg + 0x013C/4); })
+#define IPU_CHA_BUF0_RDY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0268/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0140/4 + (ch / 32)); })
+#define IPU_CHA_BUF1_RDY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0270/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0148/4 + (ch / 32)); })
+#define IPU_ALT_CHA_BUF0_RDY(ch) ({g_ipu_hw_rev == 2 ? \
+				   (ipu_cm_reg + 0x0278/4 + (ch / 32)) : \
+				   (ipu_cm_reg + 0x0158/4 + (ch / 32)); })
+#define IPU_ALT_CHA_BUF1_RDY(ch) ({g_ipu_hw_rev == 2 ? \
+				   (ipu_cm_reg + 0x0280/4 + (ch / 32)) : \
+				   (ipu_cm_reg + 0x0160/4 + (ch / 32)); })
+
+#define IPU_INT_CTRL(n)		(ipu_cm_reg + 0x003C/4 + ((n) - 1))
+#define IPU_INT_CTRL_IRQ(irq)	IPU_INT_CTRL(((irq) / 32))
+#define IPU_INT_STAT_IRQ(irq)	IPU_INT_STAT(((irq) / 32))
+#define IPU_INT_STAT(n)		({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0200/4 + ((n) - 1)) : \
+				  (ipu_cm_reg + 0x00E8/4 + ((n) - 1)); })
+
+#define IPUIRQ_2_STATREG(irq)	(IPU_INT_STAT(1) + ((irq) / 32))
+#define IPUIRQ_2_CTRLREG(irq)	(IPU_INT_CTRL(1) + ((irq) / 32))
+#define IPUIRQ_2_MASK(irq)	(1UL << ((irq) & 0x1F))
+
+#define VDI_FSIZE (ipu_vdi_reg)
+#define VDI_C (ipu_vdi_reg + 0x0004/4)
+
+/* CMOS Sensor Interface Registers */
+#define CSI_SENS_CONF(csi)	(ipu_csi_reg[csi])
+#define CSI_SENS_FRM_SIZE(csi)	(ipu_csi_reg[csi] + 0x0004/4)
+#define CSI_ACT_FRM_SIZE(csi)	(ipu_csi_reg[csi] + 0x0008/4)
+#define CSI_OUT_FRM_CTRL(csi)	(ipu_csi_reg[csi] + 0x000C/4)
+#define CSI_TST_CTRL(csi)	(ipu_csi_reg[csi] + 0x0010/4)
+#define CSI_CCIR_CODE_1(csi)	(ipu_csi_reg[csi] + 0x0014/4)
+#define CSI_CCIR_CODE_2(csi)	(ipu_csi_reg[csi] + 0x0018/4)
+#define CSI_CCIR_CODE_3(csi)	(ipu_csi_reg[csi] + 0x001C/4)
+#define CSI_MIPI_DI(csi)	(ipu_csi_reg[csi] + 0x0020/4)
+#define CSI_SKIP(csi)		(ipu_csi_reg[csi] + 0x0024/4)
+#define CSI_CPD_CTRL(csi)	(ipu_csi_reg[csi] + 0x0028/4)
+#define CSI_CPD_RC(csi, n)	(ipu_csi_reg[csi] + 0x002C/4 + n)
+#define CSI_CPD_RS(csi, n)	(ipu_csi_reg[csi] + 0x004C/4 + n)
+#define CSI_CPD_GRC(csi, n)	(ipu_csi_reg[csi] + 0x005C/4 + n)
+#define CSI_CPD_GRS(csi, n)	(ipu_csi_reg[csi] + 0x007C/4 + n)
+#define CSI_CPD_GBC(csi, n)	(ipu_csi_reg[csi] + 0x008C/4 + n)
+#define CSI_CPD_GBS(csi, n)	(ipu_csi_reg[csi] + 0x00AC/4 + n)
+#define CSI_CPD_BC(csi, n)	(ipu_csi_reg[csi] + 0x00BC/4 + n)
+#define CSI_CPD_BS(csi, n)	(ipu_csi_reg[csi] + 0x00DC/4 + n)
+#define CSI_CPD_OFFSET1(csi)	(ipu_csi_reg[csi] + 0x00EC/4)
+#define CSI_CPD_OFFSET2(csi)	(ipu_csi_reg[csi] + 0x00F0/4)
+
+/*SMFC Registers */
+#define SMFC_MAP	(ipu_smfc_reg)
+#define SMFC_WMC	(ipu_smfc_reg + 0x0004/4)
+#define SMFC_BS		(ipu_smfc_reg + 0x0008/4)
+
+/* Image Converter Registers */
+#define IC_CONF			(ipu_ic_reg)
+#define IC_PRP_ENC_RSC		(ipu_ic_reg + 0x0004/4)
+#define IC_PRP_VF_RSC		(ipu_ic_reg + 0x0008/4)
+#define IC_PP_RSC		(ipu_ic_reg + 0x000C/4)
+#define IC_CMBP_1		(ipu_ic_reg + 0x0010/4)
+#define IC_CMBP_2		(ipu_ic_reg + 0x0014/4)
+#define IC_IDMAC_1		(ipu_ic_reg + 0x0018/4)
+#define IC_IDMAC_2		(ipu_ic_reg + 0x001C/4)
+#define IC_IDMAC_3		(ipu_ic_reg + 0x0020/4)
+#define IC_IDMAC_4		(ipu_ic_reg + 0x0024/4)
+
+#define IDMAC_CONF		(ipu_idmac_reg + 0x0000)
+#define IDMAC_CHA_EN(ch)	(ipu_idmac_reg + 0x0004/4 + (ch/32))
+#define IDMAC_SEP_ALPHA		(ipu_idmac_reg + 0x000C/4)
+#define IDMAC_ALT_SEP_ALPHA	(ipu_idmac_reg + 0x0010/4)
+#define IDMAC_CHA_PRI(ch)	(ipu_idmac_reg + 0x0014/4 + (ch/32))
+#define IDMAC_WM_EN(ch)		(ipu_idmac_reg + 0x001C/4 + (ch/32))
+#define IDMAC_CH_LOCK_EN_1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0024/4) : 0; })
+#define IDMAC_CH_LOCK_EN_2	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0028/4) : \
+				  (ipu_idmac_reg + 0x0024/4); })
+#define IDMAC_SUB_ADDR_0	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x002C/4) : \
+				  (ipu_idmac_reg + 0x0028/4); })
+#define IDMAC_SUB_ADDR_1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0030/4) : \
+				  (ipu_idmac_reg + 0x002C/4); })
+#define IDMAC_SUB_ADDR_2	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0034/4) : \
+				  (ipu_idmac_reg + 0x0030/4); })
+#define IDMAC_BAND_EN(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0040/4 + (ch/32)) : \
+				  (ipu_idmac_reg + 0x0034/4 + (ch/32)); })
+#define IDMAC_CHA_BUSY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0100/4 + (ch/32)) : \
+				  (ipu_idmac_reg + 0x0040/4 + (ch/32)); })
+
+#define DI_GENERAL(di)		(ipu_di_reg[di])
+#define DI_BS_CLKGEN0(di)	(ipu_di_reg[di] + 0x0004/4)
+#define DI_BS_CLKGEN1(di)	(ipu_di_reg[di] + 0x0008/4)
+
+#define DI_SW_GEN0(di, gen)	(ipu_di_reg[di] + 0x000C/4 + (gen - 1))
+#define DI_SW_GEN1(di, gen)	(ipu_di_reg[di] + 0x0030/4 + (gen - 1))
+#define DI_STP_REP(di, gen)	(ipu_di_reg[di] + 0x0148/4 + (gen - 1)/2)
+#define DI_SYNC_AS_GEN(di)	(ipu_di_reg[di] + 0x0054/4)
+#define DI_DW_GEN(di, gen)	(ipu_di_reg[di] + 0x0058/4 + gen)
+#define DI_DW_SET(di, gen, set)	(ipu_di_reg[di] + 0x0088/4 + gen + 0xC*set)
+#define DI_SER_CONF(di)		(ipu_di_reg[di] + 0x015C/4)
+#define DI_SSC(di)		(ipu_di_reg[di] + 0x0160/4)
+#define DI_POL(di)		(ipu_di_reg[di] + 0x0164/4)
+#define DI_AW0(di)		(ipu_di_reg[di] + 0x0168/4)
+#define DI_AW1(di)		(ipu_di_reg[di] + 0x016C/4)
+#define DI_SCR_CONF(di)		(ipu_di_reg[di] + 0x0170/4)
+#define DI_STAT(di)		(ipu_di_reg[di] + 0x0174/4)
+
+#define DMFC_RD_CHAN		(ipu_dmfc_reg)
+#define DMFC_WR_CHAN		(ipu_dmfc_reg + 0x0004/4)
+#define DMFC_WR_CHAN_DEF	(ipu_dmfc_reg + 0x0008/4)
+#define DMFC_DP_CHAN		(ipu_dmfc_reg + 0x000C/4)
+#define DMFC_DP_CHAN_DEF	(ipu_dmfc_reg + 0x0010/4)
+#define DMFC_GENERAL1		(ipu_dmfc_reg + 0x0014/4)
+#define DMFC_GENERAL2		(ipu_dmfc_reg + 0x0018/4)
+#define DMFC_IC_CTRL		(ipu_dmfc_reg + 0x001C/4)
+#define DMFC_STAT		(ipu_dmfc_reg + 0x0020/4)
+
+#define DC_MAP_CONF_PTR(n)	(ipu_dc_reg + 0x0108/4 + n/2)
+#define DC_MAP_CONF_VAL(n)	(ipu_dc_reg + 0x0144/4 + n/2)
+
+#define _RL_CH_2_OFFSET(ch)	((ch == 0) ? 8 : ( \
+				 (ch == 1) ? 0x24 : ( \
+				 (ch == 2) ? 0x40 : ( \
+				 (ch == 5) ? 0x64 : ( \
+				 (ch == 6) ? 0x80 : ( \
+				 (ch == 8) ? 0x9C : ( \
+				 (ch == 9) ? 0xBC : (-1))))))))
+#define DC_RL_CH(ch, evt)	(ipu_dc_reg + _RL_CH_2_OFFSET(ch)/4 + evt/2)
+
+#define DC_EVT_NF		0
+#define DC_EVT_NL		1
+#define DC_EVT_EOF		2
+#define DC_EVT_NFIELD		3
+#define DC_EVT_EOL		4
+#define DC_EVT_EOFIELD		5
+#define DC_EVT_NEW_ADDR		6
+#define DC_EVT_NEW_CHAN		7
+#define DC_EVT_NEW_DATA		8
+
+#define DC_EVT_NEW_ADDR_W_0	0
+#define DC_EVT_NEW_ADDR_W_1	1
+#define DC_EVT_NEW_CHAN_W_0	2
+#define DC_EVT_NEW_CHAN_W_1	3
+#define DC_EVT_NEW_DATA_W_0	4
+#define DC_EVT_NEW_DATA_W_1	5
+#define DC_EVT_NEW_ADDR_R_0	6
+#define DC_EVT_NEW_ADDR_R_1	7
+#define DC_EVT_NEW_CHAN_R_0	8
+#define DC_EVT_NEW_CHAN_R_1	9
+#define DC_EVT_NEW_DATA_R_0	10
+#define DC_EVT_NEW_DATA_R_1	11
+
+#define dc_ch_offset(ch) \
+({ \
+	const u8 _offset[] = { \
+		0, 0x1C, 0x38, 0x54, 0x58, 0x5C, 0x78, 0, 0x94, 0xB4}; \
+	_offset[ch]; \
+})
+#define DC_WR_CH_CONF(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4)
+#define DC_WR_CH_ADDR(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4 + 4/4)
+
+#define DC_WR_CH_CONF_1		(ipu_dc_reg + 0x001C/4)
+#define DC_WR_CH_ADDR_1		(ipu_dc_reg + 0x0020/4)
+#define DC_WR_CH_CONF_5		(ipu_dc_reg + 0x005C/4)
+#define DC_WR_CH_ADDR_5		(ipu_dc_reg + 0x0060/4)
+#define DC_GEN			(ipu_dc_reg + 0x00D4/4)
+#define DC_DISP_CONF1(disp)	(ipu_dc_reg + 0x00D8/4 + disp)
+#define DC_DISP_CONF2(disp)	(ipu_dc_reg + 0x00E8/4 + disp)
+#define DC_STAT			(ipu_dc_reg + 0x01C8/4)
+#define DC_UGDE_0(evt)		(ipu_dc_reg + 0x0174/4 + evt*4)
+#define DC_UGDE_1(evt)		(ipu_dc_reg + 0x0178/4 + evt*4)
+#define DC_UGDE_2(evt)		(ipu_dc_reg + 0x017C/4 + evt*4)
+#define DC_UGDE_3(evt)		(ipu_dc_reg + 0x0180/4 + evt*4)
+
+#define DP_SYNC 0
+#define DP_ASYNC0 0x60
+#define DP_ASYNC1 0xBC
+#define DP_COM_CONF(flow)	(ipu_dp_reg + flow/4)
+#define DP_GRAPH_WIND_CTRL(flow) (ipu_dp_reg + 0x0004/4 + flow/4)
+#define DP_FG_POS(flow)		(ipu_dp_reg + 0x0008/4 + flow/4)
+#define DP_GAMMA_C(flow, i)	(ipu_dp_reg + 0x0014/4 + flow/4 + i)
+#define DP_GAMMA_S(flow, i)	(ipu_dp_reg + 0x0034/4 + flow/4 + i)
+#define DP_CSC_A_0(flow)	(ipu_dp_reg + 0x0044/4 + flow/4)
+#define DP_CSC_A_1(flow)	(ipu_dp_reg + 0x0048/4 + flow/4)
+#define DP_CSC_A_2(flow)	(ipu_dp_reg + 0x004C/4 + flow/4)
+#define DP_CSC_A_3(flow)	(ipu_dp_reg + 0x0050/4 + flow/4)
+#define DP_CSC_0(flow)		(ipu_dp_reg + 0x0054/4 + flow/4)
+#define DP_CSC_1(flow)		(ipu_dp_reg + 0x0058/4 + flow/4)
+
+/* Software reset for ipu */
+#define SW_IPU_RST			8
+
+enum {
+	IPU_CONF_CSI0_EN = 0x00000001,
+	IPU_CONF_CSI1_EN = 0x00000002,
+	IPU_CONF_IC_EN = 0x00000004,
+	IPU_CONF_ROT_EN = 0x00000008,
+	IPU_CONF_ISP_EN = 0x00000010,
+	IPU_CONF_DP_EN = 0x00000020,
+	IPU_CONF_DI0_EN = 0x00000040,
+	IPU_CONF_DI1_EN = 0x00000080,
+	IPU_CONF_DMFC_EN = 0x00000400,
+	IPU_CONF_SMFC_EN = 0x00000100,
+	IPU_CONF_DC_EN = 0x00000200,
+	IPU_CONF_VDI_EN = 0x00001000,
+	IPU_CONF_IDMAC_DIS = 0x00400000,
+	IPU_CONF_IC_DMFC_SEL = 0x02000000,
+	IPU_CONF_IC_DMFC_SYNC = 0x04000000,
+	IPU_CONF_VDI_DMFC_SYNC = 0x08000000,
+	IPU_CONF_CSI0_DATA_SOURCE = 0x10000000,
+	IPU_CONF_CSI0_DATA_SOURCE_OFFSET = 28,
+	IPU_CONF_CSI1_DATA_SOURCE = 0x20000000,
+	IPU_CONF_IC_INPUT = 0x40000000,
+	IPU_CONF_CSI_SEL = 0x80000000,
+
+	DI0_COUNTER_RELEASE = 0x01000000,
+	DI1_COUNTER_RELEASE = 0x02000000,
+
+	FS_PRPVF_ROT_SRC_SEL_MASK = 0x00000F00,
+	FS_PRPVF_ROT_SRC_SEL_OFFSET = 8,
+	FS_PRPENC_ROT_SRC_SEL_MASK = 0x0000000F,
+	FS_PRPENC_ROT_SRC_SEL_OFFSET = 0,
+	FS_PP_ROT_SRC_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_SRC_SEL_OFFSET = 16,
+	FS_PP_SRC_SEL_MASK = 0x0000F000,
+	FS_PP_SRC_SEL_OFFSET = 12,
+	FS_PRP_SRC_SEL_MASK = 0x0F000000,
+	FS_PRP_SRC_SEL_OFFSET = 24,
+	FS_VF_IN_VALID = 0x80000000,
+	FS_ENC_IN_VALID = 0x40000000,
+	FS_VDI_SRC_SEL_MASK = 0x30000000,
+	FS_VDI_SRC_SEL_OFFSET = 28,
+
+
+	FS_PRPENC_DEST_SEL_MASK = 0x0000000F,
+	FS_PRPENC_DEST_SEL_OFFSET = 0,
+	FS_PRPVF_DEST_SEL_MASK = 0x000000F0,
+	FS_PRPVF_DEST_SEL_OFFSET = 4,
+	FS_PRPVF_ROT_DEST_SEL_MASK = 0x00000F00,
+	FS_PRPVF_ROT_DEST_SEL_OFFSET = 8,
+	FS_PP_DEST_SEL_MASK = 0x0000F000,
+	FS_PP_DEST_SEL_OFFSET = 12,
+	FS_PP_ROT_DEST_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_DEST_SEL_OFFSET = 16,
+	FS_PRPENC_ROT_DEST_SEL_MASK = 0x00F00000,
+	FS_PRPENC_ROT_DEST_SEL_OFFSET = 20,
+
+	FS_SMFC0_DEST_SEL_MASK = 0x0000000F,
+	FS_SMFC0_DEST_SEL_OFFSET = 0,
+	FS_SMFC1_DEST_SEL_MASK = 0x00000070,
+	FS_SMFC1_DEST_SEL_OFFSET = 4,
+	FS_SMFC2_DEST_SEL_MASK = 0x00000780,
+	FS_SMFC2_DEST_SEL_OFFSET = 7,
+	FS_SMFC3_DEST_SEL_MASK = 0x00003800,
+	FS_SMFC3_DEST_SEL_OFFSET = 11,
+
+	FS_DC1_SRC_SEL_MASK = 0x00F00000,
+	FS_DC1_SRC_SEL_OFFSET = 20,
+	FS_DC2_SRC_SEL_MASK = 0x000F0000,
+	FS_DC2_SRC_SEL_OFFSET = 16,
+	FS_DP_SYNC0_SRC_SEL_MASK = 0x0000000F,
+	FS_DP_SYNC0_SRC_SEL_OFFSET = 0,
+	FS_DP_SYNC1_SRC_SEL_MASK = 0x000000F0,
+	FS_DP_SYNC1_SRC_SEL_OFFSET = 4,
+	FS_DP_ASYNC0_SRC_SEL_MASK = 0x00000F00,
+	FS_DP_ASYNC0_SRC_SEL_OFFSET = 8,
+	FS_DP_ASYNC1_SRC_SEL_MASK = 0x0000F000,
+	FS_DP_ASYNC1_SRC_SEL_OFFSET = 12,
+
+	FS_AUTO_REF_PER_MASK = 0,
+	FS_AUTO_REF_PER_OFFSET = 16,
+
+	TSTAT_VF_MASK = 0x0000000C,
+	TSTAT_VF_OFFSET = 2,
+	TSTAT_VF_ROT_MASK = 0x00000300,
+	TSTAT_VF_ROT_OFFSET = 8,
+	TSTAT_ENC_MASK = 0x00000003,
+	TSTAT_ENC_OFFSET = 0,
+	TSTAT_ENC_ROT_MASK = 0x000000C0,
+	TSTAT_ENC_ROT_OFFSET = 6,
+	TSTAT_PP_MASK = 0x00000030,
+	TSTAT_PP_OFFSET = 4,
+	TSTAT_PP_ROT_MASK = 0x00000C00,
+	TSTAT_PP_ROT_OFFSET = 10,
+
+	TASK_STAT_IDLE = 0,
+	TASK_STAT_ACTIVE = 1,
+	TASK_STAT_WAIT4READY = 2,
+
+	/* Image Converter Register bits */
+	IC_CONF_PRPENC_EN = 0x00000001,
+	IC_CONF_PRPENC_CSC1 = 0x00000002,
+	IC_CONF_PRPENC_ROT_EN = 0x00000004,
+	IC_CONF_PRPVF_EN = 0x00000100,
+	IC_CONF_PRPVF_CSC1 = 0x00000200,
+	IC_CONF_PRPVF_CSC2 = 0x00000400,
+	IC_CONF_PRPVF_CMB = 0x00000800,
+	IC_CONF_PRPVF_ROT_EN = 0x00001000,
+	IC_CONF_PP_EN = 0x00010000,
+	IC_CONF_PP_CSC1 = 0x00020000,
+	IC_CONF_PP_CSC2 = 0x00040000,
+	IC_CONF_PP_CMB = 0x00080000,
+	IC_CONF_PP_ROT_EN = 0x00100000,
+	IC_CONF_IC_GLB_LOC_A = 0x10000000,
+	IC_CONF_KEY_COLOR_EN = 0x20000000,
+	IC_CONF_RWS_EN = 0x40000000,
+	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
+
+	IC_IDMAC_1_CB0_BURST_16 = 0x00000001,
+	IC_IDMAC_1_CB1_BURST_16 = 0x00000002,
+	IC_IDMAC_1_CB2_BURST_16 = 0x00000004,
+	IC_IDMAC_1_CB3_BURST_16 = 0x00000008,
+	IC_IDMAC_1_CB4_BURST_16 = 0x00000010,
+	IC_IDMAC_1_CB5_BURST_16 = 0x00000020,
+	IC_IDMAC_1_CB6_BURST_16 = 0x00000040,
+	IC_IDMAC_1_CB7_BURST_16 = 0x00000080,
+	IC_IDMAC_1_PRPENC_ROT_MASK = 0x00003800,
+	IC_IDMAC_1_PRPENC_ROT_OFFSET = 11,
+	IC_IDMAC_1_PRPVF_ROT_MASK = 0x0001C000,
+	IC_IDMAC_1_PRPVF_ROT_OFFSET = 14,
+	IC_IDMAC_1_PP_ROT_MASK = 0x000E0000,
+	IC_IDMAC_1_PP_ROT_OFFSET = 17,
+	IC_IDMAC_1_PP_FLIP_RS = 0x00400000,
+	IC_IDMAC_1_PRPVF_FLIP_RS = 0x00200000,
+	IC_IDMAC_1_PRPENC_FLIP_RS = 0x00100000,
+
+	IC_IDMAC_2_PRPENC_HEIGHT_MASK = 0x000003FF,
+	IC_IDMAC_2_PRPENC_HEIGHT_OFFSET = 0,
+	IC_IDMAC_2_PRPVF_HEIGHT_MASK = 0x000FFC00,
+	IC_IDMAC_2_PRPVF_HEIGHT_OFFSET = 10,
+	IC_IDMAC_2_PP_HEIGHT_MASK = 0x3FF00000,
+	IC_IDMAC_2_PP_HEIGHT_OFFSET = 20,
+
+	IC_IDMAC_3_PRPENC_WIDTH_MASK = 0x000003FF,
+	IC_IDMAC_3_PRPENC_WIDTH_OFFSET = 0,
+	IC_IDMAC_3_PRPVF_WIDTH_MASK = 0x000FFC00,
+	IC_IDMAC_3_PRPVF_WIDTH_OFFSET = 10,
+	IC_IDMAC_3_PP_WIDTH_MASK = 0x3FF00000,
+	IC_IDMAC_3_PP_WIDTH_OFFSET = 20,
+
+	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
+	CSI_SENS_CONF_DATA_FMT_MASK = 0x00000700,
+	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0L,
+	CSI_SENS_CONF_DATA_FMT_YUV422_YUYV = 1L,
+	CSI_SENS_CONF_DATA_FMT_YUV422_UYVY = 2L,
+	CSI_SENS_CONF_DATA_FMT_BAYER = 3L,
+	CSI_SENS_CONF_DATA_FMT_RGB565 = 4L,
+	CSI_SENS_CONF_DATA_FMT_RGB555 = 5L,
+	CSI_SENS_CONF_DATA_FMT_RGB444 = 6L,
+	CSI_SENS_CONF_DATA_FMT_JPEG = 7L,
+
+	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
+	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
+	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
+	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
+	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
+	CSI_SENS_CONF_PACK_TIGHT_SHIFT = 7,
+	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 11,
+	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
+	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
+
+	CSI_SENS_CONF_DIVRATIO_MASK = 0x00FF0000L,
+	CSI_SENS_CONF_DATA_DEST_SHIFT = 24,
+	CSI_SENS_CONF_DATA_DEST_MASK = 0x07000000L,
+	CSI_SENS_CONF_JPEG8_EN_SHIFT = 27,
+	CSI_SENS_CONF_JPEG_EN_SHIFT = 28,
+	CSI_SENS_CONF_FORCE_EOF_SHIFT = 29,
+	CSI_SENS_CONF_DATA_EN_POL_SHIFT = 31,
+
+	CSI_DATA_DEST_ISP = 1L,
+	CSI_DATA_DEST_IC = 2L,
+	CSI_DATA_DEST_IDMAC = 4L,
+
+	CSI_CCIR_ERR_DET_EN = 0x01000000L,
+	CSI_HORI_DOWNSIZE_EN = 0x80000000L,
+	CSI_VERT_DOWNSIZE_EN = 0x40000000L,
+	CSI_TEST_GEN_MODE_EN = 0x01000000L,
+
+	CSI_HSC_MASK = 0x1FFF0000,
+	CSI_HSC_SHIFT = 16,
+	CSI_VSC_MASK = 0x00000FFF,
+	CSI_VSC_SHIFT = 0,
+
+	CSI_TEST_GEN_R_MASK = 0x000000FFL,
+	CSI_TEST_GEN_R_SHIFT = 0,
+	CSI_TEST_GEN_G_MASK = 0x0000FF00L,
+	CSI_TEST_GEN_G_SHIFT = 8,
+	CSI_TEST_GEN_B_MASK = 0x00FF0000L,
+	CSI_TEST_GEN_B_SHIFT = 16,
+
+	CSI_MIPI_DI0_MASK = 0x000000FFL,
+	CSI_MIPI_DI0_SHIFT = 0,
+	CSI_MIPI_DI1_MASK = 0x0000FF00L,
+	CSI_MIPI_DI1_SHIFT = 8,
+	CSI_MIPI_DI2_MASK = 0x00FF0000L,
+	CSI_MIPI_DI2_SHIFT = 16,
+	CSI_MIPI_DI3_MASK = 0xFF000000L,
+	CSI_MIPI_DI3_SHIFT = 24,
+
+	CSI_MAX_RATIO_SKIP_ISP_MASK = 0x00070000L,
+	CSI_MAX_RATIO_SKIP_ISP_SHIFT = 16,
+	CSI_SKIP_ISP_MASK = 0x00F80000L,
+	CSI_SKIP_ISP_SHIFT = 19,
+	CSI_MAX_RATIO_SKIP_SMFC_MASK = 0x00000007L,
+	CSI_MAX_RATIO_SKIP_SMFC_SHIFT = 0,
+	CSI_SKIP_SMFC_MASK = 0x000000F8L,
+	CSI_SKIP_SMFC_SHIFT = 3,
+	CSI_ID_2_SKIP_MASK = 0x00000300L,
+	CSI_ID_2_SKIP_SHIFT = 8,
+
+	CSI_COLOR_FIRST_ROW_MASK = 0x00000002L,
+	CSI_COLOR_FIRST_COMP_MASK = 0x00000001L,
+
+	SMFC_MAP_CH0_MASK = 0x00000007L,
+	SMFC_MAP_CH0_SHIFT = 0,
+	SMFC_MAP_CH1_MASK = 0x00000038L,
+	SMFC_MAP_CH1_SHIFT = 3,
+	SMFC_MAP_CH2_MASK = 0x000001C0L,
+	SMFC_MAP_CH2_SHIFT = 6,
+	SMFC_MAP_CH3_MASK = 0x00000E00L,
+	SMFC_MAP_CH3_SHIFT = 9,
+
+	SMFC_WM0_SET_MASK = 0x00000007L,
+	SMFC_WM0_SET_SHIFT = 0,
+	SMFC_WM1_SET_MASK = 0x000001C0L,
+	SMFC_WM1_SET_SHIFT = 6,
+	SMFC_WM2_SET_MASK = 0x00070000L,
+	SMFC_WM2_SET_SHIFT = 16,
+	SMFC_WM3_SET_MASK = 0x01C00000L,
+	SMFC_WM3_SET_SHIFT = 22,
+
+	SMFC_WM0_CLR_MASK = 0x00000038L,
+	SMFC_WM0_CLR_SHIFT = 3,
+	SMFC_WM1_CLR_MASK = 0x00000E00L,
+	SMFC_WM1_CLR_SHIFT = 9,
+	SMFC_WM2_CLR_MASK = 0x00380000L,
+	SMFC_WM2_CLR_SHIFT = 19,
+	SMFC_WM3_CLR_MASK = 0x0E000000L,
+	SMFC_WM3_CLR_SHIFT = 25,
+
+	SMFC_BS0_MASK = 0x0000000FL,
+	SMFC_BS0_SHIFT = 0,
+	SMFC_BS1_MASK = 0x000000F0L,
+	SMFC_BS1_SHIFT = 4,
+	SMFC_BS2_MASK = 0x00000F00L,
+	SMFC_BS2_SHIFT = 8,
+	SMFC_BS3_MASK = 0x0000F000L,
+	SMFC_BS3_SHIFT = 12,
+
+	PF_CONF_TYPE_MASK = 0x00000007,
+	PF_CONF_TYPE_SHIFT = 0,
+	PF_CONF_PAUSE_EN = 0x00000010,
+	PF_CONF_RESET = 0x00008000,
+	PF_CONF_PAUSE_ROW_MASK = 0x00FF0000,
+	PF_CONF_PAUSE_ROW_SHIFT = 16,
+
+	DI_DW_GEN_ACCESS_SIZE_OFFSET = 24,
+	DI_DW_GEN_COMPONENT_SIZE_OFFSET = 16,
+
+	DI_GEN_DI_CLK_EXT = 0x100000,
+	DI_GEN_POLARITY_1 = 0x00000001,
+	DI_GEN_POLARITY_2 = 0x00000002,
+	DI_GEN_POLARITY_3 = 0x00000004,
+	DI_GEN_POLARITY_4 = 0x00000008,
+	DI_GEN_POLARITY_5 = 0x00000010,
+	DI_GEN_POLARITY_6 = 0x00000020,
+	DI_GEN_POLARITY_7 = 0x00000040,
+	DI_GEN_POLARITY_8 = 0x00000080,
+
+	DI_POL_DRDY_DATA_POLARITY = 0x00000080,
+	DI_POL_DRDY_POLARITY_15 = 0x00000010,
+
+	DI_VSYNC_SEL_OFFSET = 13,
+
+	DC_WR_CH_CONF_FIELD_MODE = 0x00000200,
+	DC_WR_CH_CONF_PROG_TYPE_OFFSET = 5,
+	DC_WR_CH_CONF_PROG_TYPE_MASK = 0x000000E0,
+	DC_WR_CH_CONF_PROG_DI_ID = 0x00000004,
+	DC_WR_CH_CONF_PROG_DISP_ID_OFFSET = 3,
+	DC_WR_CH_CONF_PROG_DISP_ID_MASK = 0x00000018,
+
+	DC_UGDE_0_ODD_EN = 0x02000000,
+	DC_UGDE_0_ID_CODED_MASK = 0x00000007,
+	DC_UGDE_0_ID_CODED_OFFSET = 0,
+	DC_UGDE_0_EV_PRIORITY_MASK = 0x00000078,
+	DC_UGDE_0_EV_PRIORITY_OFFSET = 3,
+
+	DP_COM_CONF_FG_EN = 0x00000001,
+	DP_COM_CONF_GWSEL = 0x00000002,
+	DP_COM_CONF_GWAM = 0x00000004,
+	DP_COM_CONF_GWCKE = 0x00000008,
+	DP_COM_CONF_CSC_DEF_MASK = 0x00000300,
+	DP_COM_CONF_CSC_DEF_OFFSET = 8,
+	DP_COM_CONF_CSC_DEF_FG = 0x00000300,
+	DP_COM_CONF_CSC_DEF_BG = 0x00000200,
+	DP_COM_CONF_CSC_DEF_BOTH = 0x00000100,
+	DP_COM_CONF_GAMMA_EN = 0x00001000,
+	DP_COM_CONF_GAMMA_YUV_EN = 0x00002000,
+
+	DI_SER_CONF_LLA_SER_ACCESS = 0x00000020,
+	DI_SER_CONF_SERIAL_CLK_POL = 0x00000010,
+	DI_SER_CONF_SERIAL_DATA_POL = 0x00000008,
+	DI_SER_CONF_SERIAL_RS_POL = 0x00000004,
+	DI_SER_CONF_SERIAL_CS_POL = 0x00000002,
+	DI_SER_CONF_WAIT4SERIAL = 0x00000001,
+
+	VDI_C_CH_420 = 0x00000000,
+	VDI_C_CH_422 = 0x00000002,
+	VDI_C_MOT_SEL_FULL = 0x00000008,
+	VDI_C_MOT_SEL_LOW = 0x00000004,
+	VDI_C_MOT_SEL_MED = 0x00000000,
+	VDI_C_BURST_SIZE1_4 = 0x00000030,
+	VDI_C_BURST_SIZE2_4 = 0x00000300,
+	VDI_C_BURST_SIZE3_4 = 0x00003000,
+	VDI_C_VWM1_SET_1 = 0x00000000,
+	VDI_C_VWM1_CLR_2 = 0x00080000,
+	VDI_C_VWM3_SET_1 = 0x00000000,
+	VDI_C_VWM3_CLR_2 = 0x02000000,
+	VDI_C_TOP_FIELD_MAN_1 = 0x40000000,
+	VDI_C_TOP_FIELD_AUTO_1 = 0x80000000,
+};
+
+enum di_pins {
+	DI_PIN11 = 0,
+	DI_PIN12 = 1,
+	DI_PIN13 = 2,
+	DI_PIN14 = 3,
+	DI_PIN15 = 4,
+	DI_PIN16 = 5,
+	DI_PIN17 = 6,
+	DI_PIN_CS = 7,
+
+	DI_PIN_SER_CLK = 0,
+	DI_PIN_SER_RS = 1,
+};
+
+enum di_sync_wave {
+	DI_SYNC_NONE = -1,
+	DI_SYNC_CLK = 0,
+	DI_SYNC_INT_HSYNC = 1,
+	DI_SYNC_HSYNC = 2,
+	DI_SYNC_VSYNC = 3,
+	DI_SYNC_DE = 5,
+};
+
+/* DC template opcodes */
+#define WROD(lf)		(0x18 | (lf << 1))
+
+#endif
-- 
1.6.5.2

