From 503635f3f4a1aad6c8cf0b726c2f02cab6597adb Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Wed, 29 Oct 2008 16:35:18 +0800
Subject: [PATCH] imx_drivers_mx3_pm

MX3 Power Managment driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Makefile                        |    2 +
 arch/arm/mach-mx3/clock.c                         |  200 ++++
 arch/arm/mach-mx3/dvfs.c                          | 1069 ++++++++++++++++++
 arch/arm/plat-mxc/include/mach/dptc.h             |  186 +++
 arch/arm/plat-mxc/include/mach/dvfs.h             |  157 +++
 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h |  171 +++
 arch/arm/plat-mxc/include/mach/pm_api.h           |  351 ++++++
 drivers/mxc/pm/Kconfig                            |   32 +
 drivers/mxc/pm/Makefile                           |   11 +
 drivers/mxc/pm/dptc.c                             |  924 +++++++++++++++
 drivers/mxc/pm/dvfs_dptc.c                        | 1245 +++++++++++++++++++++
 drivers/mxc/pm/dvfs_dptc.h                        |   76 ++
 drivers/mxc/pm/dvfs_dptc_table_mx31.h             |  157 +++
 drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h      |  152 +++
 14 files changed, 4733 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx3/dvfs.c
 create mode 100644 arch/arm/plat-mxc/include/mach/dptc.h
 create mode 100644 arch/arm/plat-mxc/include/mach/dvfs.h
 create mode 100644 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
 create mode 100644 arch/arm/plat-mxc/include/mach/pm_api.h
 create mode 100644 drivers/mxc/pm/Kconfig
 create mode 100644 drivers/mxc/pm/Makefile
 create mode 100644 drivers/mxc/pm/dptc.c
 create mode 100644 drivers/mxc/pm/dvfs_dptc.c
 create mode 100644 drivers/mxc/pm/dvfs_dptc.h
 create mode 100644 drivers/mxc/pm/dvfs_dptc_table_mx31.h
 create mode 100644 drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 1312f13..06066b5 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -9,3 +9,5 @@ obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o mx31_gpio.o
 obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
 obj-$(CONFIG_USB_EHCI_ARC)  += usb.o
+
+obj-$(CONFIG_MXC_DVFS)      += dvfs.o
diff --git a/arch/arm/mach-mx3/clock.c b/arch/arm/mach-mx3/clock.c
index 20b343a..b8c87d0 100644
--- a/arch/arm/mach-mx3/clock.c
+++ b/arch/arm/mach-mx3/clock.c
@@ -29,6 +29,15 @@
 #include "crm_regs.h"
 
 #define PRE_DIV_MIN_FREQ    10000000 /* Minimum Frequency after Predivider */
+#define PROPAGATE_RATE_DIS  2
+
+#ifdef CONFIG_MXC_DPTC
+static int cpu_clk_set_wp(int wp);
+
+static int cpu_curr_wp, cpu_wp_nr;
+static struct cpu_wp *cpu_wp_tbl;
+struct timer_list dptcen_timer;
+#endif
 
 static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
 {
@@ -155,6 +164,24 @@ static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
 	return 0;
 }
 
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int ahb_rate;
+
+	ahb_rate = ahb_clk.get_rate(&ahb_clk);
+
+	if ((rate < ahb_rate) || (rate % ahb_rate != 0)) {
+		printk(KERN_ERR "Wrong rate %lu in _clk_cpu_set_rate\n", rate);
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_MXC_DPTC
+	cpu_clk_set_wp(rate / ahb_rate - 1);
+#endif
+
+	return PROPAGATE_RATE_DIS;
+}
+
 static unsigned long _clk_pll_get_rate(struct clk *clk)
 {
 	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
@@ -207,6 +234,16 @@ static unsigned long _clk_pll_get_rate(struct clk *clk)
 	return temp;
 }
 
+static unsigned long _clk_cpu_get_rate(struct clk *clk)
+{
+	unsigned long mcu_pdf;
+
+	mcu_pdf = __raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_MCU_PODF_MASK >>
+			      MXC_CCM_PDR0_MCU_PODF_OFFSET;
+
+	return clk->parent->get_rate(clk->parent) / (mcu_pdf + 1);
+}
+
 static int _clk_usb_pll_enable(struct clk *clk)
 {
 	u32 reg;
@@ -581,6 +618,13 @@ static struct clk usb_pll_clk = {
 	.disable = _clk_usb_pll_disable,
 };
 
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mcu_main_clk,
+	.get_rate = _clk_cpu_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+};
+
 static struct clk ahb_clk = {
 	.name = "ahb_clk",
 	.parent = &mcu_main_clk,
@@ -1113,6 +1157,7 @@ static struct clk *mxc_clks[] = {
 	&usb_pll_clk,
 	&serial_pll_clk,
 	&mcu_main_clk,
+	&cpu_clk,
 	&ahb_clk,
 	&per_clk,
 	&perclk_clk,
@@ -1202,6 +1247,18 @@ int __init mxc_clocks_init(unsigned long fref)
 
 	clk_enable(&serial_pll_clk);
 
+#ifdef	CONFIG_MXC_DPTC
+	cpu_curr_wp =
+		cpu_clk.get_rate(&cpu_clk) / ahb_clk.get_rate(&ahb_clk) - 1;
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	if (mx31_revision() < CHIP_REV_2_0) {
+		/* replace 399MHz wp with 266MHz one */
+		memcpy(&cpu_wp_tbl[2], &cpu_wp_tbl[1],
+				sizeof(cpu_wp_tbl[0]));
+	}
+#endif
+
 	if (mx31_revision() >= CHIP_REV_2_0) {
 		reg = __raw_readl(MXC_CCM_PMCR1);
 		/* No PLL restart on DVFS switch; enable auto EMI handshake */
@@ -1212,3 +1269,146 @@ int __init mxc_clocks_init(unsigned long fref)
 	return 0;
 }
 
+#ifdef CONFIG_MXC_DPTC
+
+#define MXC_PMCR0_DVFS_MASK	(MXC_CCM_PMCR0_DVSUP_MASK | \
+				 MXC_CCM_PMCR0_UDSC_MASK | \
+				 MXC_CCM_PMCR0_VSCNT_MASK | \
+				 MXC_CCM_PMCR0_DPVCR)
+
+#define MXC_PDR0_MAX_MCU_MASK	(MXC_CCM_PDR0_MAX_PODF_MASK | \
+				 MXC_CCM_PDR0_MCU_PODF_MASK | \
+				 MXC_CCM_PDR0_HSP_PODF_MASK | \
+				 MXC_CCM_PDR0_IPG_PODF_MASK | \
+				 MXC_CCM_PDR0_NFC_PODF_MASK)
+
+static DEFINE_SPINLOCK(mxc_dfs_lock);
+
+static void dptcen_after_timeout(unsigned long ptr)
+{
+	unsigned long flags;
+	u32 pmcr0;
+	u32 dptc_active;
+
+	spin_lock_irqsave(&mxc_dfs_lock, flags);
+	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	dptc_active = pmcr0 & MXC_CCM_PMCR0_DPTEN;
+
+	/*
+	 * If DPTC is still active and core is running
+	 * in Turbo mode
+	 */
+	if ((dptcen_timer.data == cpu_wp_nr - 1) &&
+			dptc_active) {
+		pmcr0 |= (MXC_CCM_PMCR0_DPVCR | MXC_CCM_PMCR0_DPVV);
+		__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	}
+	spin_unlock_irqrestore(&mxc_dfs_lock, flags);
+}
+
+/*
+ * Setup cpu clock based on working point.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 dvsup;
+	u32 pmcr0;
+	u32 pdr0;
+	u32 vscnt = MXC_CCM_PMCR0_VSCNT_2;
+	u32 udsc = MXC_CCM_PMCR0_UDSC_DOWN;
+	void __iomem *ipu_base =
+		(void __iomem *)IO_ADDRESS(IPU_CTRL_BASE_ADDR);
+	u32 ipu_conf;
+
+	if (wp >= cpu_wp_nr || wp < 0) {
+		printk(KERN_ERR "Wrong wp: %d for"
+				"cpu_clk_set_wp\n", wp);
+		return -EINVAL;
+	}
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	pdr0 = __raw_readl(MXC_CCM_PDR0);
+
+	if (!(pmcr0 & MXC_CCM_PMCR0_UPDTEN))
+		return -EBUSY;
+
+	if (wp > cpu_curr_wp) {
+		/* going faster */
+		if (wp == (cpu_wp_nr - 1)) {
+			/* Only update vscnt going into Turbo */
+			vscnt = MXC_CCM_PMCR0_VSCNT_8;
+		}
+		udsc = MXC_CCM_PMCR0_UDSC_UP;
+	}
+
+	p = &cpu_wp_tbl[wp];
+
+	if (mcu_main_clk.get_rate(&mcu_main_clk) ==
+			p->pll_rate) {
+		/* No pll switching and relocking needed */
+		pmcr0 |= MXC_CCM_PMCR0_DFSUP0_PDR;
+	} else {
+		/* pll switching and relocking needed */
+		pmcr0 ^= MXC_CCM_PMCR0_DFSUP1;	/* flip MSB bit */
+		pmcr0 &= ~(MXC_CCM_PMCR0_DFSUP0);
+	}
+
+	dvsup =
+		(cpu_wp_nr - 1 - wp) << MXC_CCM_PMCR0_DVSUP_OFFSET;
+
+	pmcr0 =
+		(pmcr0 & ~MXC_PMCR0_DVFS_MASK) | dvsup | vscnt | udsc;
+
+	/* also enable DVFS hardware */
+	pmcr0 |= MXC_CCM_PMCR0_DVFEN;
+
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+	/* IPU and DI submodule must be on for PDR0
+	 * update to take effect */
+	if (!clk_get_usecount(&ipu_clk))
+		ipu_clk.enable(&ipu_clk);
+
+	ipu_conf = __raw_readl(ipu_base);
+	if (!(ipu_conf & 0x40))
+		__raw_writel(ipu_conf | 0x40, ipu_base);
+
+	__raw_writel((pdr0 & ~MXC_PDR0_MAX_MCU_MASK) | p->pdr0_reg,
+		     MXC_CCM_PDR0);
+
+	if ((pmcr0 & MXC_CCM_PMCR0_DFSUP0) ==
+			MXC_CCM_PMCR0_DFSUP0_PLL) {
+		/* PLL and post divider update */
+		if ((pmcr0 & MXC_CCM_PMCR0_DFSUP1) ==
+				MXC_CCM_PMCR0_DFSUP1_SPLL) {
+			__raw_writel(p->pll_reg, MXC_CCM_SRPCTL);
+			mcu_main_clk.parent = &serial_pll_clk;
+		} else {
+			__raw_writel(p->pll_reg, MXC_CCM_MPCTL);
+			mcu_main_clk.parent = &mcu_pll_clk;
+		}
+	}
+
+	cpu_curr_wp = wp;
+
+	/* Restore IPU_CONF setting */
+	__raw_writel(ipu_conf, ipu_base);
+	if (!clk_get_usecount(&ipu_clk))
+		ipu_clk.disable(&ipu_clk);
+
+	if (wp == cpu_wp_nr - 1) {
+		init_timer(&dptcen_timer);
+		dptcen_timer.expires = jiffies + 2;
+		dptcen_timer.function = dptcen_after_timeout;
+		dptcen_timer.data = wp;
+		add_timer(&dptcen_timer);
+	} else
+		dptc_suspend();
+
+	return 0;
+}
+#endif
diff --git a/arch/arm/mach-mx3/dvfs.c b/arch/arm/mach-mx3/dvfs.c
new file mode 100644
index 0000000..0c20242
--- /dev/null
+++ b/arch/arm/mach-mx3/dvfs.c
@@ -0,0 +1,1069 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * The DVFS driver
+ * driver is designed as a character driver which interacts with the
+ * MXC DVFS hardware. Upon initialization, the DVFS driver initializes
+ * the DVFS hardware sets up driver nodes attaches to the DVFS interrupt
+ * and initializes internal data structures. When the DVFS interrupt
+ * occurs the driver checks the cause of the interrupt (lower frequency,
+ * increase frequency or emergency) and changes the CPU voltage according
+ * to translation table that is loaded into the driver. The driver read
+ * method is used to read the log buffer. Driver ioctls are used to change
+ * driver parameters and enable/disable the
+ * DVFS operation.
+ *
+ * @ingroup PM
+ */
+
+/* Define to enable debug messages */
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/semaphore.h>
+#include <linux/uaccess.h>
+
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <mach/sdma.h>
+#include <mach/dvfs.h>
+#include <mach/iomux-mx3.h>
+
+#include "crm_regs.h"
+
+/*!
+ * Read the LBFL bits from the CCM
+ */
+#define GET_LBFL(pmcr0)	\
+	((pmcr0 & MXC_CCM_PMCR0_LBFL) >> MXC_CCM_PMCR0_LBFL_OFFSET)
+
+/*!
+ * Read the LBCF bits from the CCM
+ */
+#define GET_LBCF(pmcr0)	\
+	((pmcr0 & MXC_CCM_PMCR0_LBCF_MASK) >> \
+	MXC_CCM_PMCR0_LBCF_OFFSET)
+
+/*!
+ * Set DVSUP bits
+ */
+#define SET_DVSUP(pmcr0, x) \
+	pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DVSUP_MASK) | \
+			x << MXC_CCM_PMCR0_DVSUP_OFFSET)
+
+/*!
+ * Set DFSUP0 bits
+ */
+#define SET_DFSUP0(pmcr0, x) \
+	pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DFSUP0) | \
+			x << MXC_CCM_PMCR0_DFSUP0_OFFSET)
+
+/*!
+ * Set DFSUP1 bits
+ */
+#define SET_DFSUP1(pmcr0, x) \
+	pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DFSUP1) | \
+			x << MXC_CCM_PMCR0_DFSUP1_OFFSET)
+
+/*
+ * Set UDSC bit
+ */
+#define SET_UDSC(pmcr0) (pmcr0 |= MXC_CCM_PMCR0_UDSC)
+
+/*
+ * Clear UDSC bit
+ */
+#define CLEAR_UDSC(pmcr0) (pmcr0 &= ~MXC_CCM_PMCR0_UDSC)
+
+#define SET_VSCNT(pmcr0, x) \
+	pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_VSCNT_MASK) | \
+			x << MXC_CCM_PMCR0_VSCNT_OFFSET)
+
+/*
+ * Clear DPVCR bit
+ */
+#define CLEAR_DPVCR(pmcr0) (pmcr0 &= ~MXC_CCM_PMCR0_DPVCR)
+
+/*
+ * Set DPVCR bit
+ */
+#define SET_DPVCR(pmcr0) (pmcr0 |= MXC_CCM_PMCR0_DPVCR)
+
+/*
+ * Set DPVCR bit
+ */
+#define SET_DPVV(pmcr0) (pmcr0 |= MXC_CCM_PMCR0_DPVV)
+
+dvfs_states_table *dvfs_states_tbl;
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal
+ * DPTC driver parameters (current working point, current
+ * frequency, translation table and DPTC log buffer).
+ */
+static dvfs_dptc_params_s *dvfs_dptc_params;
+
+/*
+ * Clock structures
+ */
+static struct clk *cpu_clk;
+static struct clk *ckih_clk;
+
+/*!
+ * Set the div_3_clk clock to maximum.
+ * With the ARM clocked at 532, this setting yields
+ * a DIV_3_CLK of 2.03 kHz.
+ *
+ * @param val   div3ck value
+ */
+static void dvfs_set_div3ck(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0,
+			MXC_CCM_LTR0_DIV3CK_MASK,
+			val << MXC_CCM_LTR0_DIV3CK_OFFSET);
+}
+
+/*!
+ * Sets frequency decrease threshold. Decrease frequency
+ * change request will be sent if DVFS counter value will
+ * be less than this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_dnthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0,
+			MXC_CCM_LTR0_DNTHR_MASK,
+			val << MXC_CCM_LTR0_DNTHR_OFFSET);
+}
+
+/*!
+ * Set frequency increase threshold. Increase frequency
+ * change request will be sent if DVFS counter value will
+ * be more than this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_upthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0,
+			MXC_CCM_LTR0_UPTHR_MASK,
+			val << MXC_CCM_LTR0_UPTHR_OFFSET);
+}
+
+/*!
+ * Set panic threshold. Panic frequency change request
+ * will be sent if DVFS counter value will be more than
+ * this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_pncthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1,
+			MXC_CCM_LTR1_PNCTHR_MASK,
+			val << MXC_CCM_LTR1_PNCTHR_OFFSET);
+}
+
+/*!
+ * Set UPCNT value.
+ * UPCNT defines the amount of times the up threshold
+ * should be exceeded before DVFS will trigger frequency
+ * increase request.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_upcnt(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1,
+			MXC_CCM_LTR1_UPCNT_MASK,
+			val << MXC_CCM_LTR1_UPCNT_OFFSET);
+}
+
+/*!
+ * Set DNCNT value.
+ * DNCNT defines the amount of times the up threshold
+ * should be exceeded before DVFS will trigger frequency
+ * decrease request.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_dncnt(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1,
+			MXC_CCM_LTR1_DNCNT_MASK,
+			val << MXC_CCM_LTR1_DNCNT_OFFSET);
+}
+
+/*!
+ * Set load tracking buffer source to ld_add
+ */
+static void dvfs_set_ltbrsr(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1,
+			MXC_CCM_LTR1_LTBRSR,
+			MXC_CCM_LTR1_LTBRSR);
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Take the original MSB of ld_add - ld_add[5:2]
+ * for load tracking register
+ */
+static void dvfs_clear_ltbrsh(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1,
+			MXC_CCM_LTR1_LTBRSH, 0);
+}
+#endif
+
+/*!
+ * Set EMAC value.
+ * EMAC defines how many samples are included in
+ * EMA calculation
+ *
+ * @param val   EMAC value
+ */
+static void dvfs_set_emac(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR2,
+			MXC_CCM_LTR2_EMAC_MASK,
+			val << MXC_CCM_LTR2_EMAC_OFFSET);
+}
+
+/*!
+ * Set general purpose weights of LTR2 register
+ *
+ * @param x   general purpose bit number
+ * @param w   weight value
+ */
+static void dvfs_set_ltr2_wsw(unsigned long x, unsigned long w)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR2,
+			MXC_CCM_LTR2_WSW_MASK(x),
+			w << MXC_CCM_LTR2_WSW_OFFSET(x));
+}
+
+/*!
+ * Set general purpose weights of LTR3 register
+ *
+ * @param x   general purpose bit number
+ * @param w   weight value
+ */
+static void dvfs_set_ltr3_wsw(unsigned long x, unsigned long w)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR3,
+			MXC_CCM_LTR3_WSW_MASK(x),
+			w << MXC_CCM_LTR3_WSW_OFFSET(x));
+}
+
+/*!
+ * Unmask DVFS interrupt
+ */
+static void dvfs_unmask_dvfs_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_FSVAIM, 0);
+}
+
+/*!
+ * Mask DVFS interrupt
+ */
+static void dvfs_mask_dvfs_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_FSVAIM,
+			MXC_CCM_PMCR0_FSVAIM);
+}
+
+/*!
+ * Mask DVFS log buffer interrupt
+ */
+static void dvfs_mask_dvfs_lb_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_LBMI,
+			MXC_CCM_PMCR0_LBMI);
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Unmask DVFS log buffer interrupt
+ */
+static void dvfs_unmask_dvfs_lb_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_LBMI, 0);
+}
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Sets DVFIS bit. MCU will get DVFS interrupt
+ */
+static void dvfs_set_dvfis(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_DVFIS,
+			MXC_CCM_PMCR0_DVFIS);
+}
+#endif
+
+/*!
+ * Enable DVFS hardware
+ */
+static void dvfs_enable_dvfs(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_DVFEN,
+			MXC_CCM_PMCR0_DVFEN);
+}
+
+/*!
+ * Disable DVFS hardware
+ */
+static void dvfs_disable_dvfs(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+			MXC_CCM_PMCR0_DVFEN, 0);
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Read the FSVAI bits from the CCM.
+ *
+ * @return  FSVAI bits value
+ */
+static unsigned long dvfs_get_fsvai(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) &
+				MXC_CCM_PMCR0_FSVAI_MASK)
+			>> MXC_CCM_PMCR0_FSVAI_OFFSET;
+}
+#endif
+
+/*!
+ * Read the DFSUP0 bit from the CCM
+ *
+ * @return  DFSUP0 bit value
+ */
+static unsigned long dvfs_get_dfsup0(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) &
+				MXC_CCM_PMCR0_DFSUP0)
+			>> MXC_CCM_PMCR0_DFSUP0_OFFSET;
+}
+
+/*!
+ * Read the DFSUP1 bits from the CCM
+ *
+ * @return  DFSUP1 bit value
+ */
+static unsigned long dvfs_get_dfsup1(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) &
+				MXC_CCM_PMCR0_DFSUP1)
+			>> MXC_CCM_PMCR0_DFSUP1_OFFSET;
+}
+
+/*!
+ * Read the DVSUP bits from the CCM
+ *
+ * @return  DVFSUP bits value
+ */
+unsigned long dvfs_get_dvsup(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) &
+				MXC_CCM_PMCR0_DVSUP_MASK)
+			>> MXC_CCM_PMCR0_DVSUP_OFFSET;
+}
+
+/*!
+ * Set SW general purpose SW bits.
+ *
+ * @param x    status bits. Each of 4 LSB's corresponds to
+ *             1 SW general purpose bit status (on/off).
+ */
+void dvfs_set_dvgp(unsigned long x)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR1,
+			MXC_CCM_PMCR1_DVGP_MASK, x & 0xf);
+}
+
+/*!
+ * This function sets the weight of general purpose signals
+ * @param   gp_id   number of general purpose bit
+ * @param   weight  the weight of the general purpose bit
+ */
+static void set_gp_weight(int gp_id, unsigned char weight)
+{
+	if (gp_id < 9)
+		dvfs_set_ltr3_wsw(gp_id, weight & 0x7);
+	else if (gp_id < 16)
+		dvfs_set_ltr2_wsw(gp_id, weight & 0x7);
+}
+
+/*!
+ * This function returns the ARM clock value in Hz.
+ *
+ * @param       reg     pll value
+ * @param       pdr0     post-divider 0 value
+ *
+ * @return      clock value in Hz
+ */
+unsigned long dvfs_get_clock(unsigned long reg, unsigned long pdr0)
+{
+	unsigned long pll, ret_val = 0;
+	signed long mcu_pdf;
+	signed long pdf, mfd, mfi, mfn, ref_clk;
+	struct clk *pll_clk;
+	struct clk *parent_clk;
+
+	pll_clk = clk_get(NULL, "mcu_pll");
+	parent_clk = clk_get(NULL, "ckih");
+
+	if (parent_clk == clk_get_parent(pll_clk))
+		ref_clk = clk_get_rate(parent_clk);
+	else {		/* parent is ckil/fpm */
+		parent_clk = clk_get(NULL, "ckil");
+		ref_clk = clk_get_rate(parent_clk) * 1024;
+	}
+
+	pdf = (signed long)
+		((reg & MXC_CCM_PCTL_PD_MASK) >>
+		 MXC_CCM_PCTL_PD_OFFSET);
+	mfd = (signed long)
+		((reg & MXC_CCM_PCTL_MFD_MASK) >>
+		 MXC_CCM_PCTL_MFD_OFFSET);
+
+	mfi = (signed long)((reg & MXC_CCM_PCTL_MFI_MASK) >>
+			MXC_CCM_PCTL_MFI_OFFSET);
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = (signed long)(reg & MXC_CCM_PCTL_MFN_MASK);
+	mfn = (mfn < 0x200) ? mfn : (mfn - 0x400);
+
+	pll = (2 * ref_clk * mfi + ((2 * ref_clk /
+					(mfd + 1)) * mfn)) / (pdf + 1);
+
+	mcu_pdf = pdr0 & MXC_CCM_PDR0_MCU_PODF_MASK;
+	ret_val = pll / (mcu_pdf + 1);
+
+	return ret_val;
+}
+
+static ssize_t dvfs_enable_store(struct sys_device *dev,
+		struct sysdev_attribute *attr,
+		const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		if (start_dvfs(dvfs_dptc_params) != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL)
+		stop_dvfs(dvfs_dptc_params);
+
+	return size;
+}
+
+
+static ssize_t dvfs_status_show(struct sys_device *dev,
+		struct sysdev_attribute *attr, char *buf)
+{
+	int size = 0;
+
+	if (dvfs_dptc_params->dvfs_is_active)
+		size = sprintf(buf, "DVFS is enabled\n");
+	else
+		size = sprintf(buf, "DVFS is disabled\n");
+
+	return size;
+}
+
+static SYSDEV_ATTR(enable, 0200, NULL, dvfs_enable_store);
+static SYSDEV_ATTR(status, 0644, dvfs_status_show, NULL);
+
+static struct sysdev_class dvfs_sysclass = {
+	.name = "dvfs",
+};
+
+static struct sys_device dvfs_device = {
+	.id = 0,
+	.cls = &dvfs_sysclass,
+};
+
+static int dvfs_sysdev_ctrl_init(void)
+{
+	int err;
+
+	err = sysdev_class_register(&dvfs_sysclass);
+	if (!err)
+		err = sysdev_register(&dvfs_device);
+	if (!err) {
+		err = sysdev_create_file(&dvfs_device, &attr_enable);
+		err = sysdev_create_file(&dvfs_device, &attr_status);
+	}
+
+	return err;
+}
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures and sets up the
+ * DVFS hardware. It sets default values for DVFS thresholds
+ * and counters. The default values was chosen from a set of
+ * different reasonable values. They was tested and the default
+ * values in the driver gave the best results. More work should
+ * be done to find optimal values.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver
+ *					parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+int __init init_dvfs_controller(dvfs_dptc_params_s *params)
+{
+	int i;
+	int res = 0;
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ckih_clk = clk_get(NULL, "ckih");
+
+	/* Configure 2 MC13783 DVFS pins */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_DVFS0,
+				IOMUX_OCONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_DVFS1,
+				IOMUX_OCONFIG_FUNC));
+
+	/* Configure MC13783 voltage ready input pin */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_5,
+				IOMUX_OCONFIG_GPIO | IOMUX_ICONFIG_FUNC));
+
+	/* Mask DVFS interrupts */
+	dvfs_mask_dvfs_int();
+	dvfs_mask_dvfs_lb_int();
+
+	params->dvfs_log_buffer = (char *)
+		dma_alloc_coherent(NULL, DVFS_LB_SIZE *
+				DVFS_LB_SAMPLE_SIZE / 8,
+				&params->dvfs_log_buffer_phys, GFP_KERNEL);
+
+	if (params->dvfs_log_buffer <= 0) {
+		printk(KERN_ERR "DVFS failed allocating"
+				"log buffer\n");
+		res = -ENOMEM;
+	} else
+		memset(params->dvfs_log_buffer, 0,
+				DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8);
+
+	/* Set general purpose weights to 0 */
+	for (i = 0; i < 16; i++)
+		set_gp_weight(i, 0);
+
+	/*
+	 * Set the div_3_clk clock to maximum.
+	 * With the ARM clocked at 532, this setting yields
+	 * a DIV_3_CLK of 2.03 kHz.
+	 */
+	dvfs_set_div3ck(3);
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/*
+	 * ARM will get DVFS interrupt
+	 */
+	dvfs_set_dvfis();
+#endif
+
+	/*
+	 * UPCNT defines the amount of times the up threshold
+	 * should be exceeded before DVFS will trigger
+	 * frequency increase request.
+	 */
+	dvfs_set_upcnt(0x33);
+
+	/*
+	 * DNCNT defines the amount of times the up threshold
+	 * should be exceeded before DVFS will trigger
+	 * frequency decrease request.
+	 */
+	dvfs_set_dncnt(0x33);
+
+	/* EMAC defines how many samples are included in
+	 * EMA calculation */
+	dvfs_set_emac(0x20);
+
+	/* Initialize frequencies tables for DPM usage */
+	dvfs_states_tbl =
+		kmalloc(sizeof(dvfs_states_table), GFP_KERNEL);
+	memset(dvfs_states_tbl, 0, sizeof(dvfs_states_table));
+
+	params->dvfs_mode = DVFS_HW_MODE;
+
+	dvfs_dptc_params = params;
+
+	if (system_rev >= CHIP_REV_2_0) {
+		/* Rev2.0 changes */
+
+		/* Disable PLL restart on DVFS switch */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR1,
+				MXC_CCM_PMCR1_PLLRDIS,
+				MXC_CCM_PMCR1_PLLRDIS);
+
+		/* Enable automatic EMI handshake */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR1,
+				MXC_CCM_PMCR1_EMIRQ_EN,
+				MXC_CCM_PMCR1_EMIRQ_EN);
+
+		/* Init SR PLL for 399MHz */
+		mxc_ccm_modify_reg(MXC_CCM_SRPCTL,
+				0xffffffff, 0x00331c23);
+	}
+
+	if (res == 0) {
+		dvfs_sysdev_ctrl_init();
+		printk(KERN_INFO "DVFS controller initialized\n");
+	}
+
+	return res;
+}
+
+/*!
+ * Update tables of frequencies for DPM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *               DPTC translation table.
+ */
+void dvfs_update_freqs_table(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr)
+{
+	int freq;
+	dvfs_state *table;
+	unsigned long pll, pdr0;
+	int i;
+
+	if (dvfs_states_tbl->freqs != 0)
+		kfree(dvfs_states_tbl->freqs);
+
+	dvfs_states_tbl->freqs = kmalloc(sizeof(unsigned int) *
+			dvfs_dptc_tables_ptr->dvfs_state_num,
+			GFP_KERNEL);
+
+	dvfs_states_tbl->num_of_states =
+		dvfs_dptc_tables_ptr->dvfs_state_num;
+
+	table = dvfs_dptc_tables_ptr->table;
+
+	/* State 0 */
+	pll = table[0].pll_up;
+	pdr0 = table[0].pdr0_up;
+	freq = dvfs_get_clock(table[0].pll_up, table[0].pdr0_up);
+	dvfs_states_tbl->freqs[0] = freq;
+
+	for (i = 0; i < dvfs_dptc_tables_ptr->dvfs_state_num - 1;
+			i++) {
+
+		if (table[i].pll_sw_down == 1)
+			pll = table[i].pll_down;
+
+		pdr0 = table[i].pdr0_down;
+
+		freq = dvfs_get_clock(pll, pdr0);
+		dvfs_states_tbl->freqs[i + 1] = freq;
+	}
+}
+
+/*!
+ * This function enables the DVFS module. this function updates
+ * the DVFS thresholds, updates the MC13783, unmasks the DVFS
+ * interrupt and enables the DVFS module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver
+ *				parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ *
+ */
+int start_dvfs(dvfs_dptc_params_s *params)
+{
+	int i;
+	int dnthr, upthr, pncthr;
+
+	/* Check if DVFS module isn't already active */
+	if (params->dvfs_is_active == FALSE) {
+
+		for (i = 12; i <= 15; i++)
+			set_gp_weight(i, 7);
+
+		if (params->dvfs_mode == DVFS_HW_MODE) {
+			dnthr = DVFS_DNTHR;
+			upthr = DVFS_UPTHR;
+			pncthr = DVFS_PNCTHR;
+		} else {
+			dnthr = 0;
+			upthr = 63;
+			pncthr = 63;
+		}
+
+		/*
+		 * Frequency decrease threshold. Decrease frequency
+		 * change request will be sent if DVFS counter value
+		 * will be less than this value.
+		 */
+		dvfs_set_dnthr(dnthr);
+		/*
+		 * Frequency increase threshold. Increase frequency
+		 * change request will be sent if DVFS counter value
+		 * will be more than this value.
+		 */
+		dvfs_set_upthr(upthr);
+		/*
+		 * Panic threshold. Panic frequency change request
+		 * will be sent if DVFS counter value will be more
+		 * than this value.
+		 */
+		dvfs_set_pncthr(pncthr);
+
+		dvfs_unmask_dvfs_int();
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+		if (params->dvfs_mode == DVFS_PRED_MODE) {
+			params->chars_in_buffer = 0;
+			init_waitqueue_head(&params->dvfs_pred_wait);
+			params->read_ptr = params->dvfs_log_buffer;
+			dvfs_unmask_dvfs_lb_int();
+			dvfs_clear_ltbrsh();
+		}
+#endif
+
+		dvfs_set_ltbrsr();
+
+		dvfs_enable_dvfs();
+
+		params->dvfs_is_active = TRUE;
+
+		return 0;
+	}
+
+	/* DVFS module already active return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function sets frequency according to fsvai bits
+ *(increase/decrease).
+ * @param    params    pointer to the DVFS & DPTC driver
+ *				parameters structure.
+ * @param    fsvai     value of fsvai bits
+ *					(increase/decrease/emergency)
+ */
+void set_freq(dvfs_dptc_params_s *params, int fsvai)
+{
+	int dvsup;
+	unsigned long pdr0;
+	unsigned long pll;
+	int curr_freq_index;
+	int pll_switch;
+	int dfsup0, dfsup1;
+	dvfs_state *table;
+	unsigned long pmcr0;
+	int dptc_enable = 0;
+
+	pmcr0 = mxc_ccm_get_reg(MXC_CCM_PMCR0);
+	dptc_enable = pmcr0 & MXC_CCM_PMCR0_DPTEN;
+
+	/* Read DVSUP - current frequency index */
+	dvsup = dvfs_get_dvsup();
+	curr_freq_index = dvsup;
+
+	table = params->dvfs_dptc_tables_ptr->table;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	table = sdma_phys_to_virt((unsigned long)table);
+#endif
+
+	if (dptc_enable)
+		CLEAR_DPVCR(pmcr0);
+
+	if (fsvai == DVFS_DECREASE) {
+		/* On DVFS_DECREASE event the frequency will be
+		 * changed according to the next state setting
+		 */
+		CLEAR_UDSC(pmcr0);
+		dvsup++;
+		SET_VSCNT(pmcr0, 1);
+		pll_switch = table[curr_freq_index].pll_sw_down;
+		pdr0 = table[curr_freq_index].pdr0_down;
+		pll = table[curr_freq_index].pll_down;
+
+	} else {
+		/* On DVFS_INCREASE and on DVFS_PANIC event the
+		 * highest frequency will be set
+		 */
+		SET_UDSC(pmcr0);
+		dvsup = 0;
+		SET_VSCNT(pmcr0, table[curr_freq_index].vscnt);
+		pll_switch = table[curr_freq_index].pll_sw_up;
+		pdr0 = table[curr_freq_index].pdr0_up;
+		pll = table[curr_freq_index].pll_up;
+	}
+
+	/* DVSUP (new frequency index) setup */
+	SET_DVSUP(pmcr0, dvsup);
+
+	/* DFSUP defines if PLL switch is required and which
+	 * PLL source will be used after the switch.
+	 */
+	dfsup0 = dvfs_get_dfsup0();
+	dfsup1 = dvfs_get_dfsup1();
+
+	if (pll_switch == 0) {
+		/* Update only pdr0 */
+		dfsup0 = 1;
+	}
+
+	if (pll_switch == 1) {
+		/* Update pll and pdr0 */
+		dfsup1 = (~dfsup1) & 0x1;
+		dfsup0 = 0;
+	}
+
+	SET_DFSUP0(pmcr0, dfsup0);
+	SET_DFSUP1(pmcr0, dfsup1);
+
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, 0xffffffff, pmcr0);
+	/* software wait for voltage ramp-up */
+	udelay(100);
+	mxc_ccm_modify_reg(MXC_CCM_PDR0, 0xffffffff, pdr0);
+
+	if (pll_switch == 1) {
+		if (dfsup1 == 1) {
+			/* MPCTL will be updated */
+			mxc_ccm_modify_reg(MXC_CCM_MPCTL, 0xffffffff, pll);
+		} else {
+			/* SRPCTL will be updated */
+			mxc_ccm_modify_reg(MXC_CCM_SRPCTL, 0xffffffff, pll);
+		}
+	}
+
+	if (dptc_enable) {
+		pmcr0 = mxc_ccm_get_reg(MXC_CCM_PMCR0);
+		SET_DPVCR(pmcr0);
+		SET_DPVV(pmcr0);
+		mxc_ccm_modify_reg(MXC_CCM_PMCR0, 0xffffffff, pmcr0);
+	}
+
+	pr_debug(KERN_INFO "ARM frequency: %dMHz CKIH frequency:"
+			"%dMHz(%d)\n",
+			(int)clk_get_rate(cpu_clk) / 1000000,
+			(int)clk_get_rate(ckih_clk) / 1000000, (int)jiffies);
+}
+
+/*!
+ * This function disables the DVFS module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver
+ *				parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int stop_dvfs(dvfs_dptc_params_s *params)
+{
+	unsigned long dvsup;
+	unsigned long dfsup1;
+
+	/* Check if DPTC module isn't already disabled */
+	if (params->dvfs_is_active != FALSE) {
+		/* Mask interrupts */
+		dvfs_mask_dvfs_int();
+		dvfs_mask_dvfs_lb_int();
+
+		params->dvfs_is_active = FALSE;
+
+		/* Set maximal frequency */
+		dvsup = dvfs_get_dvsup();
+		if (dvsup != 0)
+			set_freq(params, DVFS_INCREASE);
+
+		/* If current PLL is SRPCTL, move to MPCTL */
+		dfsup1 = dvfs_get_dfsup1();
+		if (dfsup1 != 1)
+			set_freq(params, DVFS_INCREASE);
+
+		/* Disable DVFS */
+		dvfs_disable_dvfs();
+
+		return 0;
+	}
+
+	/* DVFS module already disabled return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function turns on/off SW general purpose bits.
+ * The argument's 4 LSBs represent the status of the bits.
+ *
+ * @param   arg  status of the SW general purpose bits
+ *
+ * @return 0 on success
+ */
+int set_sw_gp(unsigned char arg)
+{
+	/* Clear upper 4 bits */
+	arg &= 0xf;
+	dvfs_set_dvgp(arg);
+
+	return 0;
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DVFS Interrupt handler.
+ * @param    params    pointer to the DVFS & DPTC driver
+ *			parameters structure.
+ */
+void dvfs_irq(dvfs_dptc_params_s *params)
+{
+	int fsvai;
+	unsigned long pmcr0;
+
+	fsvai = dvfs_get_fsvai();
+	pmcr0 = mxc_ccm_get_reg(MXC_CCM_PMCR0);
+
+	if (pmcr0 & MXC_CCM_PMCR0_FSVAIM) {
+		/* Do nothing. DVFS interrupt is masked */
+		return;
+	}
+
+	if (fsvai == 0) {
+		/* Do nothing. Freq change is not required */
+		return;
+	}
+
+	if (!(pmcr0 & MXC_CCM_PMCR0_UPDTEN)) {
+		/* Do nothing. DVFS didn't finish previous
+		 * flow update */
+		return;
+	}
+
+	if (((dvfs_get_dvsup() == 3) &&
+				(fsvai == DVFS_DECREASE)) ||
+				((dvfs_get_dvsup() == 0) &&
+				 ((fsvai == DVFS_INCREASE) ||
+				(fsvai == DVFS_EMERG)))) {
+		/* Do nothing. DVFS is already at lowest
+		 * (highest) state */
+		return;
+	}
+
+	set_freq(params, fsvai);
+
+}
+#endif				/* CONFIG_MXC_DVFS_SDMA */
+
+/*!
+ * This function sets DVFS to monitor WFI signal
+ *
+ * @param   arg  0 - turn WFI off, 1 - turn WFI on
+ * @return  0 on success, error code on fail
+ */
+int set_wfi(unsigned char arg)
+{
+	int res;
+
+	if (arg == 0) {
+		/* Disable */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+				MXC_CCM_PMCR0_WFIM,
+				MXC_CCM_PMCR0_WFIM);
+		res = 0;
+	} else if (arg == 1) {
+		/* Enable */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+				MXC_CCM_PMCR0_WFIM, 0);
+		res = 0;
+	} else
+		res = -EINVAL;
+
+	return res;
+}
+
+/*!
+ * This function changes the frequency if DVFS HW is disabled.
+ * It gets id of the required state supported by DVFS table and
+ * updates CCM.
+ *
+ * @param    dvfs_state_id  id of the DVFS state.
+ * @return   0 on success, error code on fail
+ */
+int dvfs_set_state(int dvfs_state_id)
+{
+	int curr_freq_index;
+
+	if (dvfs_dptc_params->dvfs_is_active != FALSE &&
+			dvfs_dptc_params->dvfs_mode != DVFS_PRED_MODE) {
+		/* Frequency change is impossible when DVFS
+		 * HW is enabled */
+		return -EINVAL;
+	}
+
+	if (dvfs_state_id >= 0 &&
+			dvfs_state_id <
+			dvfs_dptc_params->dvfs_dptc_tables_ptr->dvfs_state_num) {
+		curr_freq_index = dvfs_get_dvsup();
+		if (curr_freq_index > dvfs_state_id) {
+
+			if (dvfs_dptc_params->dvfs_is_active == FALSE)
+				dvfs_enable_dvfs();
+
+			set_freq(dvfs_dptc_params, DVFS_INCREASE);
+			if (dvfs_dptc_params->dvfs_is_active == FALSE)
+				dvfs_disable_dvfs();
+
+			return dvfs_set_state(dvfs_state_id);
+		} else if (curr_freq_index < dvfs_state_id) {
+
+			if (dvfs_dptc_params->dvfs_is_active == FALSE)
+				dvfs_enable_dvfs();
+
+			set_freq(dvfs_dptc_params, DVFS_DECREASE);
+			if (dvfs_dptc_params->dvfs_is_active == FALSE)
+				dvfs_disable_dvfs();
+
+			return dvfs_set_state(dvfs_state_id);
+		} else
+			return 0;
+	}
+
+	return -EINVAL;
+}
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/include/mach/dptc.h b/arch/arm/plat-mxc/include/mach/dptc.h
new file mode 100644
index 0000000..239cfcc
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dptc.h
@@ -0,0 +1,186 @@
+
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_DPTC_H__
+#define __ASM_ARCH_MXC_DPTC_H__
+
+#include <mach/dvfs_dptc_struct.h>
+
+/*!
+ * DPTC proc file system entry name
+ */
+#define PROC_NODE_NAME	"dptc"
+
+int __init init_dptc_controller(dvfs_dptc_params_s *params);
+
+/*!
+ * This function enables the DPTC module. this function updates the DPTC
+ * thresholds, updates the PMIC, unmasks the DPTC interrupt and enables
+ * the DPTC module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was enabled else returns -EINVAL.
+ */
+int start_dptc(dvfs_dptc_params_s *params);
+/*!
+ * This function disables the DPTC module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was disabled else returns -EINVAL.
+ */
+int stop_dptc(dvfs_dptc_params_s *params);
+/*!
+ * This function updates the drivers current working point index. This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU working point measured by the DPTC hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    new_wp	New working point index value to be set.
+ *
+ */
+void set_dptc_wp(dvfs_dptc_params_s *params, int new_wp);
+/*!
+ * This function updates the DPTC threshold registers.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ * @param    freq_index		translation table index of the current CPU
+ *				frequency.
+ *
+ */
+void update_dptc_thresholds(dvfs_dptc_tables_s *dptc_tables_ptr,
+		int wp, int freq_index);
+/*!
+ * This function adds a new entry to the DPTC log buffer.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    dptc_log		pointer to the DPTC log buffer structure.
+ * @param    wp			value of the working point index written
+ *				to the log buffer.
+ * @param    freq_index		value of the frequency index written to
+ *				the log buffer.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+
+void add_dptc_log_entry(dvfs_dptc_params_s *params,
+		dptc_log_s *dptc_log, int wp, int freq_index);
+
+/*!
+ * This function updates the CPU voltage, produced by PMIC, by calling PMIC
+ * driver functions.
+ *
+ * @param    dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ */
+void set_pmic_voltage(dvfs_dptc_tables_s *dptc_tables_ptr, int wp);
+
+/*!
+ * This function enables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to enable.
+ * @return   0 on success, error code on failure
+ */
+int enable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state);
+
+/*!
+ * This function disables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to disable
+ * @return   0 on success, error code on failure
+ */
+int disable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state);
+
+/*!
+ * This function is the DPTC Interrupt handler.
+ * This function wakes-up the dptc_workqueue_handler function that handles the
+ * DPTC interrupt.
+ */
+void dptc_irq(void);
+
+/*!
+ * This function updates the drivers current frequency index.This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU frequency (each CPU frequency has a separate index number
+ * according to the loaded DPTC table).
+ *
+ * @param    params      pointer to the DVFS & DPTC driver parameters structure.
+ * @param    freq_index	 New frequency index value to be set.
+ *
+ * @return      0 if the frequency index was updated (the new index is a
+ *		valid index and the DPTC module isn't active) else returns
+ *              -EINVAL.
+ *
+ */
+int set_dptc_curr_freq(dvfs_dptc_params_s *params, unsigned int freq_index);
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * DPTC SDMA callback.
+ * Updates the PMIC voltage
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dptc_sdma_callback(dvfs_dptc_params_s *params);
+#endif
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state);
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_suspend(void);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_resume(struct platform_device *dev);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_resume(void);
+
+/*!
+ * This function initializes DPTC according to turbo mode status
+ *
+ * @param    status    Turbo mode disable, 1 - turbo mode enabled
+ *
+ */
+void dptc_set_turbo_mode(unsigned int status);
+
+#endif				/* __ASM_ARCH_MXC_DPTC_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/dvfs.h b/arch/arm/plat-mxc/include/mach/dvfs.h
new file mode 100644
index 0000000..b720170
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dvfs.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs.h
+ *
+ * @brief MXC dvfs header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_H__
+#define __ASM_ARCH_MXC_DVFS_H__
+
+#include "dvfs_dptc_struct.h"
+
+/*!
+ * If value equal to FSVAI bits indicates working point decrease
+ */
+#define DVFS_DECREASE		(unsigned long)0x2
+
+/*!
+ * If value equal to FSVAI bits indicates working point increase
+ */
+#define DVFS_INCREASE		(unsigned long)0x1
+
+/*!
+ * If value equal to FSVAI bits indicates working point increase to maximum
+ */
+#define DVFS_EMERG		(unsigned long)0x3
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures and sets up the DVFS hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+int __init init_dvfs_controller(dvfs_dptc_params_s *params);
+
+/*!
+ * This function enables the DVFS module. this function updates the DVFS
+ * thresholds, updates the PMIC, unmasks the DVFS interrupt and enables
+ * the DVFS module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int start_dvfs(dvfs_dptc_params_s *params);
+
+/*!
+ * This function disables the DVFS module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int stop_dvfs(dvfs_dptc_params_s *params);
+
+/*!
+ * This function turns on/off SW general purpose bits.
+ * The argument's 4 LSBs represent the status of the bits.
+ *
+ * @param   arg  status of the SW general purpose bits
+ *
+ * @return 0 on success
+ */
+int set_sw_gp(unsigned char arg);
+
+/*!
+ * This function sets DVFS to monitor WFI signal
+ *
+ * @param   arg  0 - turn WFI off, 1 - turn WFI on
+ * @return  0 on success, error code on fail
+ */
+int set_wfi(unsigned char arg);
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DVFS Interrupt handler.
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dvfs_irq(dvfs_dptc_params_s *params);
+#endif
+
+/*!
+ * This function changes the frequency if DVFS HW is disabled.
+ * It gets id of the required state supported by DVFS table and
+ * updates CCM.
+ *
+ * @param    dvfs_state_id  id of the DVFS state.
+ * @return   0 on success, error code on fail
+ */
+int dvfs_set_state(int dvfs_state_id);
+
+/*
+ * Update tables of frequencies for DPM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+void dvfs_update_freqs_table(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr);
+
+/*!
+ * Read the DVSUP bits from the CCM
+ */
+unsigned long dvfs_get_dvsup(void);
+
+/*!
+ * This contains the array with values of supported frequencies in Hz.
+ * The structure is used by DPM.
+ */
+extern dvfs_states_table *dvfs_states_tbl;
+
+/*!
+ * This define DVFS log buffer sample size (in bits)
+ */
+#define DVFS_LB_SAMPLE_SIZE 4
+
+/*!
+ * This define DVFS log buffer samples
+ */
+#define DVFS_LB_SIZE 1600
+
+/*!
+ * This define DVFS SDMA buffer descriptors number
+ */
+#define DVFS_LB_SDMA_BD 10
+
+/*!
+ * This defines default DVFS down threshold
+ */
+#define DVFS_DNTHR  18
+
+/*!
+ * This defines default DVFS up threshold
+ */
+#define DVFS_UPTHR  30
+
+/*!
+ * This defines default DVFS panic threshold
+ */
+#define DVFS_PNCTHR 63
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
new file mode 100644
index 0000000..f523d5d
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/dvfs_dptc_struct.h
+ *
+ * @brief MXC dvfs & dptc structure definitions file.
+ *
+ * @ingroup PM_MX27 PM_MX31 PM_MXC91321 PM_MXC91311
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+#define __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+
+#include <linux/semaphore.h>
+#include <mach/pm_api.h>
+
+/*!
+ * Number of entries in the DPTC log buffer
+ */
+#define LOG_ENTRIES 1024
+
+/*!
+ * Log buffer Structure.\n
+ * This structure records the DPTC changes. \n
+ * This structure can be read by the user using
+ * the proc file system DPTC read entry.
+ */
+typedef struct {
+	/*!
+	 * Index to the head of the log buffer
+	 */
+	int head;
+
+	/*!
+	 * Index to the tail of the log buffer
+	 */
+	int tail;
+
+	/*!
+	 * Mutex to allow access to the log buffer
+	 */
+	struct semaphore mutex;
+
+	/*!
+	 * Array of log buffer entries
+	 */
+	dptc_log_entry_s entries[LOG_ENTRIES];
+} dptc_log_s;
+
+/*!
+ * DPTC driver data structure.\n
+ * Holds all driver parameters and data structures.
+ */
+typedef struct {
+	/*!
+	 * This variable holds the current frequency index
+	 */
+	int current_freq_index;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dptc_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE turbo mode enable
+	 * if FALSE turbo mode disabled
+	 */
+	int turbo_mode_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DVFS module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dvfs_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is suspended
+	 */
+	int suspended;
+
+	unsigned char rc_state;
+
+	/*!
+	 * Pointer to the DVFS & DPTC translation table
+	 */
+	dvfs_dptc_tables_s *dvfs_dptc_tables_ptr;
+
+	/*!
+	 * The DPTC log buffer
+	 */
+	dptc_log_s dptc_log_buffer;
+
+	/*!
+	 * The DVFS log buffer
+	 */
+	unsigned char *dvfs_log_buffer;
+
+	/*!
+	 * The DVFS log buffer physical address (for SDMA)
+	 */
+	dma_addr_t dvfs_log_buffer_phys;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/*!
+	 * SDMA channel number
+	 */
+	int sdma_channel;
+
+	/*!
+	 * This holds the previous working point
+	 */
+	int prev_wp;
+
+	/*!
+	 * Wait entry for predictive DVFS
+	 */
+	wait_queue_head_t dvfs_pred_wait;
+#endif
+
+	/*!
+	 * This holds the current DVFS mode
+	 */
+	unsigned int dvfs_mode;
+
+	/*!
+	 * Log buffer read pointer
+	 */
+	unsigned char *read_ptr;
+
+	/*
+	 * Number of characters in log buffer
+	 */
+	int chars_in_buffer;
+} dvfs_dptc_params_s;
+
+/*!
+ * This struct contains the array with values of supported frequencies in Hz
+ */
+typedef struct {
+	/*
+	 * Number of supported states
+	 */
+	unsigned int num_of_states;
+	/*!
+	 * Array of frequencies
+	 */
+	unsigned int *freqs;
+} dvfs_states_table;
+
+/*
+ * if not defined define TREU and FALSE values.
+ */
+#ifndef TRUE
+#define TRUE  1
+#define FALSE 0
+#endif				/* TRUE */
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/pm_api.h b/arch/arm/plat-mxc/include/mach/pm_api.h
new file mode 100644
index 0000000..86a0acb
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/pm_api.h
@@ -0,0 +1,351 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup PM_MX27 Dynamic Process Temperature Compensation (DPTC) for i.MX27
+ */
+/*!
+ * @defgroup PM_MX31 Dynamic Process Temperature Compensation (DPTC) &
+ * Dynamic Voltage Frequency Scaling (DVFS) Drivers for i.MX31
+ */
+/*!
+ * @file arch-mxc/pm_api.h
+ *
+ * @brief MXC PM API header file.
+ *
+ */
+#ifndef __ASM_ARCH_MXC_PM_API_H__
+#define __ASM_ARCH_MXC_PM_API_H__
+
+#include <linux/ioctl.h>
+
+/*!
+ * PM IOCTL Magic Number
+ */
+#define PM_MAGIC  0xDC
+
+/*!
+ * PM IOCTL update PM translation table command.\n
+ * This command changes the current DPTC table used by the driver. \n
+ * The command receives a string pointer to a new DPTC table, parses
+ * it and swiches the table.
+ */
+#define PM_IOCSTABLE		         _IOW(PM_MAGIC, 0, char*)
+
+/*!
+ * PM IOCTL get DPTC table command.\n
+ * This command returns DPTC table used by the driver. \n
+ * The command receives a string pointer for DPTC table,
+ * and dumps the current working table.
+ */
+#define PM_IOCGTABLE		        _IOR(PM_MAGIC, 1, char*)
+
+/*!
+ * DPTC IOCTL enable command.\n
+ * This command enables the dptc module.
+ */
+#define DPTC_IOCTENABLE			_IO(PM_MAGIC, 2)
+
+/*!
+ * DPTC IOCTL disable command.\n
+ * This command disables the dptc module.
+ */
+#define DPTC_IOCTDISABLE		 _IO(PM_MAGIC, 3)
+
+/*!
+ * DPTC IOCTL enable reference circuit command.\n
+ * This command enables the dptc reference circuits.
+ */
+#define DPTC_IOCSENABLERC			_IOW(PM_MAGIC, 4, unsigned char)
+
+/*!
+ * DPTC IOCTL disable reference circuit command.\n
+ * This command disables the dptc reference circuits.
+ */
+#define DPTC_IOCSDISABLERC			_IOW(PM_MAGIC, 5, unsigned char)
+
+/*!
+ * DPTC IOCTL get current state command.\n
+ * This command returns the current dptc module state (Enabled/Disabled).
+ */
+#define DPTC_IOCGSTATE         		_IO(PM_MAGIC, 6)
+
+/*!
+ * DPTC IOCTL set working point command.\n
+ * This command sets working point according to parameter.
+ */
+#define DPTC_IOCSWP         		_IOW(PM_MAGIC, 7, unsigned int)
+
+/*!
+ * DVFS IOCTL enable command.\n
+ * This command enables the dvfs module.
+ */
+#define DVFS_IOCTENABLE			_IO(PM_MAGIC, 8)
+
+/*!
+ * DVFS IOCTL disable command.\n
+ * This command disables the dvfs module.
+ */
+#define DVFS_IOCTDISABLE		 _IO(PM_MAGIC, 9)
+
+/*!
+ * DVFS IOCTL get current state command.\n
+ * This command returns the current dvfs module state (Enabled/Disabled).
+ */
+#define DVFS_IOCGSTATE         		_IO(PM_MAGIC, 10)
+
+/*!
+ * DVFS IOCTL set SW general purpose bits
+ */
+#define DVFS_IOCSSWGP         		_IOW(PM_MAGIC, 11, unsigned char)
+
+/*!
+ * DVFS IOCTL set wait-for-interrupt state
+ */
+#define DVFS_IOCSWFI         		_IOW(PM_MAGIC, 12, unsigned char)
+
+/*!
+ * PM IOCTL get current frequency command.\n
+ * This command returns the current frequency in Hz
+ */
+#define PM_IOCGFREQ         		_IO(PM_MAGIC, 13)
+
+/*!
+ * DVFS IOCTL set frequency command.\n
+ * This command sets frequency according to parameter. The parameter
+ * is the index of required frequency in current table.
+ */
+#define DVFS_IOCSFREQ         		_IOW(PM_MAGIC, 14, unsigned int)
+
+/*!
+ * DVFS IOCTL set mode command.\n
+ * This command sets DVFS mode.
+ * 0 - HW mode, 1 - SW predictive mode
+ */
+#define DVFS_IOCSMODE         		_IOW(PM_MAGIC, 15, unsigned int)
+
+#ifdef CONFIG_ARCH_MXC91321
+/*!
+ * This defines refercence circuits default status
+ */
+#define DPTC_REF_CIRCUITS_STATUS  0xE
+
+/*!
+ * DCVR register structure
+ */
+typedef struct {
+	/*!
+	 * Emergency limit threshold
+	 */
+	unsigned long EmergencyLimit:10;
+
+	/*!
+	 * Lower limit threshold
+	 */
+	unsigned long LowerLimit:11;
+
+	/*!
+	 * Upper limit threshold
+	 */
+	unsigned long UpperLimit:11;
+} dcvr_reg_s;
+#else
+/*!
+ * This defines refercence circuits default status
+ */
+#define DPTC_REF_CIRCUITS_STATUS  0xA
+
+/*!
+ * DCVR register structure
+ */
+typedef struct {
+	/*!
+	 * Reserved bits
+	 */
+	unsigned long Reserved:2;
+
+	/*!
+	 * Emergency limit threshold
+	 */
+	unsigned long EmergencyLimit:10;
+
+	/*!
+	 * Lower limit threshold
+	 */
+	unsigned long LowerLimit:10;
+
+	/*!
+	 * Upper limit threshold
+	 */
+	unsigned long UpperLimit:10;
+} dcvr_reg_s;
+#endif
+
+/*!
+ * DCVR register represented as a union between a 32 bit word and a bit field
+ */
+typedef union {
+
+	/*!
+	 * DCVR register as a 32 bit word
+	 */
+	unsigned int AsInt;
+
+	/*!
+	 * DCVR register as a bit field
+	 */
+	dcvr_reg_s AsStruct;
+} dcvr_reg_u;
+
+/*!
+ * This struct represents DCVR registers state
+ */
+typedef struct {
+	/*!
+	 * dcvr registers values
+	 */
+	dcvr_reg_u dcvr_reg[4];
+} dcvr_state;
+
+/*!
+ * This struct defines DPTC working point
+ */
+typedef struct {
+	/*!
+	 * Working point index
+	 */
+	int wp_index;
+	/*!
+	 * PMIC regulators values
+	 */
+	unsigned long pmic_values[4];
+} dptc_wp;
+
+/*!
+ * This struct defines DVFS state
+ */
+typedef struct {
+	/*!
+	 * Flag for pll change when frequency should be decreased
+	 */
+	unsigned long pll_sw_down;
+	/*!
+	 * pdr0 register decrease value
+	 */
+	unsigned long pdr0_down;
+	/*!
+	 * pll register deccrease value
+	 */
+	unsigned long pll_down;
+	/*!
+	 * Flag for pll change when frequency should be increased
+	 */
+	unsigned long pll_sw_up;
+	/*!
+	 * pdr0 register increase value
+	 */
+	unsigned long pdr0_up;
+	/*!
+	 * pll register increase value
+	 */
+	unsigned long pll_up;
+	/*!
+	 * vscnt increase value
+	 */
+	unsigned long vscnt;
+} dvfs_state;
+
+/*!
+ * This structure holds the dptc translation table.\n
+ * This structure is used to translate a working point and frequency index to
+ * voltage value and DPTC thresholds.\n
+ * This structure is also used in the driver read and write operations.\n
+ * During read operation this structure is received from the dptc driver,
+ * and during write operation this structure should be sent to the driver.
+ */
+typedef struct {
+	/*!
+	 * Number of working points in dptc table
+	 */
+	int wp_num;
+
+	/*!
+	 * This variable holds the current working point
+	 */
+	int curr_wp;
+
+	/*!
+	 * DVFS translation table entries
+	 */
+	dvfs_state *table;
+
+	/*!
+	 * DCVR table
+	 */
+	dcvr_state **dcvr;
+
+	/*!
+	 * DPTC translation table entries
+	 */
+	dptc_wp *wp;
+
+	/*
+	 * Boolean flag. If it is 0 - uses 4 levels of frequency,
+	 * 1 - uses 2 levels of frequency
+	 */
+	int use_four_freq;
+
+	/*!
+	 * Number of frequencies for each working point
+	 */
+	int dvfs_state_num;
+} dvfs_dptc_tables_s;
+
+/*!
+ * DPTC log buffer entry structure
+ */
+typedef struct {
+
+	/*!
+	 * Log entry time in jiffies
+	 */
+	unsigned long jiffies;
+
+	/*!
+	 * Log entry working point value
+	 */
+	int wp;
+
+	/*!
+	 * Log entry voltage index
+	 */
+	int voltage;
+
+	/*!
+	 * Log entry frequency index
+	 */
+	int freq;
+} dptc_log_entry_s;
+
+/*!
+ * This defines DVFS HW mode
+ */
+#define DVFS_HW_MODE   0
+
+/*!
+ * This defines DVFS predictive mode
+ */
+#define DVFS_PRED_MODE 1
+
+#endif
diff --git a/drivers/mxc/pm/Kconfig b/drivers/mxc/pm/Kconfig
new file mode 100644
index 0000000..dde07bd
--- /dev/null
+++ b/drivers/mxc/pm/Kconfig
@@ -0,0 +1,32 @@
+#
+# Power Managment devices
+#
+
+menu "Advanced Power Management devices"
+
+config MXC_DPTC
+	bool "MXC DPTC driver"
+	depends on ARCH_MX3 && MXC_PMIC_MC13783
+	default y
+	help
+	   This selects the Freescale MXC Internal DPTC driver.
+	   If unsure, say N.
+
+config MXC_DVFS
+	bool "MXC DVFS driver"
+	depends on ARCH_MX3
+	default y
+	help
+	  This selects the Freescale MXC Internal DVFS driver.
+	  If unsure, say N.
+
+config MXC_DVFS_SDMA
+	bool "MXC DVFS SDMA support"
+	depends on MXC_DVFS
+	default n
+	help
+	  This selects the Freescale MXC Internal DVFS driver SDMA support.
+	  If unsure, say N.
+
+endmenu
+
diff --git a/drivers/mxc/pm/Makefile b/drivers/mxc/pm/Makefile
new file mode 100644
index 0000000..853f049
--- /dev/null
+++ b/drivers/mxc/pm/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for Power Managment devices.
+#
+
+# Module dependencies for the MXC driver
+obj-$(CONFIG_MXC_DPTC)		+= dptc.o
+
+obj-$(CONFIG_MXC_DPTC)		+= dvfs_dptc.o
+
+obj-$(CONFIG_MXC_DVFS)		+= dvfs_dptc.o
+
diff --git a/drivers/mxc/pm/dptc.c b/drivers/mxc/pm/dptc.c
new file mode 100644
index 0000000..0fe6345
--- /dev/null
+++ b/drivers/mxc/pm/dptc.c
@@ -0,0 +1,924 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DPTC module.
+ *
+ * The DPTC driver
+ * driver is designed as a character driver which interacts with the MXC DPTC
+ * hardware. Upon initialization, the DPTC driver initializes the DPTC hardware
+ * sets up driver nodes attaches to the DPTC interrupt and initializes internal
+ * data structures. When the DPTC interrupt occurs the driver checks the cause
+ * of the interrupt (lower voltage, increase voltage or emergency) and changes
+ * the CPU voltage according to translation table that is loaded into the driver
+ * (the voltage changes are done by calling some * routines in the mc13783
+ * driver). The driver read method is used to read the currently loaded DPTC
+ * translation table and the write method is used in-order to update the
+ * translation table. Driver ioctls are used to change driver parameters and
+ * enable/disable the DPTC operation.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/sdma.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/pmic_power.h>
+
+/*
+ * Module header file
+ */
+#include <mach/dptc.h>
+#include <mach/dvfs.h>
+
+/*
+ * CRM registers
+ */
+#ifdef CONFIG_ARCH_MX3
+#include "../../../arch/arm/mach-mx3/crm_regs.h"
+#endif
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
+ * (current working point, current frequency, translation table and DPTC
+ * log buffer).
+ */
+static dvfs_dptc_params_s *dvfs_dptc_params;
+
+static struct delayed_work dptc_work;
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+static unsigned long ptvai;
+#endif
+
+/*!
+ * Enable DPTC hardware
+ */
+static void dptc_enable_dptc(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPTEN,
+			   MXC_CCM_PMCR0_DPTEN);
+}
+
+/*!
+ * Disable DPTC hardware
+ */
+static void dptc_disable_dptc(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPTEN, 0);
+}
+
+/*!
+ * Mask DPTC interrupt
+ */
+static void dptc_mask_dptc_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVAIM,
+			   MXC_CCM_PMCR0_PTVAIM);
+}
+
+/*!
+ * Unmask DPTC interrupt
+ */
+static void dptc_unmask_dptc_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVAIM, 0);
+}
+
+/*!
+ * Read the PTVAI bits from the CCM
+ *
+ * @return  PTVAI bits value
+ */
+static unsigned long dptc_get_ptvai(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_PTVAI_MASK)
+	    >> MXC_CCM_PMCR0_PTVAI_OFFSET;
+}
+
+/*!
+ * Clear DCR bits of the CCM
+ */
+static void dptc_clear_dcr(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DCR, 0);
+}
+
+/*!
+ * If value equal to PTVAI bits indicates working point decrease
+ */
+#define DPTC_DECREASE		(unsigned long)0x1
+
+/*!
+ * If value equal to PTVAI bits indicates working point increase
+ */
+#define DPTC_INCREASE		(unsigned long)0x2
+
+/*!
+ * If value equal to PTVAI bits indicates working point increase to maximum
+ */
+#define DPTC_EMERG		(unsigned long)0x3
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*
+ * MCU will get DPTC interrupt
+ */
+static void dptc_set_ptvis(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVIS,
+			   MXC_CCM_PMCR0_PTVIS);
+}
+#endif
+#endif
+
+/*!
+ * This function enables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to enable
+ * @return   0 on success, error code on failure
+ */
+int enable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state)
+{
+	int ret_val;
+
+	if (params->dptc_is_active == FALSE) {
+		params->rc_state = rc_state;
+
+		if (rc_state & 0x1) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE0,
+					   MXC_CCM_PMCR0_DRCE0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 0 enabled\n");
+#endif
+		}
+		if (rc_state & 0x2) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE1,
+					   MXC_CCM_PMCR0_DRCE1);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 1 enabled\n");
+#endif
+		}
+		if (rc_state & 0x4) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE2,
+					   MXC_CCM_PMCR0_DRCE2);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 2 enabled\n");
+#endif
+		}
+		if (rc_state & 0x8) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE3,
+					   MXC_CCM_PMCR0_DRCE3);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 3 enabled\n");
+#endif
+		}
+
+		ret_val = 0;
+	} else
+		ret_val = -EINVAL;
+
+	return ret_val;
+}
+
+/*!
+ * This function disables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to disable
+ * @return   0 on success, error code on failure
+ */
+int disable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state)
+{
+	int ret_val;
+
+	if (params->dptc_is_active == FALSE) {
+		params->rc_state &= ~rc_state;
+
+		if (rc_state & 0x1) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE0, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 0 disabled\n");
+#endif
+		}
+		if (rc_state & 0x2) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE1, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 1 disabled\n");
+#endif
+		}
+		if (rc_state & 0x4) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE2, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 2 disabled\n");
+#endif
+		}
+		if (rc_state & 0x8) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE3, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 3 disabled\n");
+#endif
+		}
+
+		ret_val = 0;
+	} else {
+		ret_val = -EINVAL;
+	}
+
+	return ret_val;
+}
+
+static void dptc_workqueue_handler(struct work_struct *work)
+{
+	dvfs_dptc_params_s *params;
+
+	params = (dvfs_dptc_params_s *) dvfs_dptc_params;
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "In %s: PTVAI = %d\n", __func__, dptc_get_ptvai());
+	printk(KERN_INFO "DCVR0 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR0));
+	printk(KERN_INFO "DCVR1 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR1));
+	printk(KERN_INFO "DCVR2 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR2));
+	printk(KERN_INFO "DCVR3 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR3));
+	printk(KERN_INFO "PTVAI = 0x%x\n", ptvai);
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	switch (ptvai) {
+		/* Chip working point has decreased,
+		 * lower working point by one */
+	case DPTC_DECREASE:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp + 1);
+		break;
+
+		/* Chip working point has increased,
+		 * raise working point by one */
+	case DPTC_INCREASE:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp - 1);
+		break;
+
+		/*
+		 * Chip working point has increased dramatically,
+		 * raise working point to maximum */
+	case DPTC_EMERG:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp - 1);
+		break;
+
+		/* Unknown interrupt cause */
+	default:
+		break;
+	}
+#else
+	set_dptc_wp(params, params->dvfs_dptc_tables_ptr->curr_wp);
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPVV,
+			   MXC_CCM_PMCR0_DPVV);
+#endif
+
+	/*
+	 * If the DPTC module is still active, re-enable
+	 * the DPTC hardware
+	 */
+	if (params->dptc_is_active) {
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+	}
+}
+
+/*!
+ * This function is the DPTC Interrupt handler.
+ * This function wakes-up the dptc_workqueue_handler
+ * function that handles the
+ * DPTC interrupt.
+ */
+void dptc_irq(void)
+{
+#ifndef CONFIG_MXC_DVFS_SDMA
+	ptvai = dptc_get_ptvai();
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "Got DPTC interrupt on %d ", (int)jiffies);
+	printk(KERN_INFO "ptvai = 0x%x (0x%x)!!!!!!!\n", ptvai,
+	       mxc_ccm_get_reg(MXC_CCM_PMCR0));
+#endif
+
+	if (ptvai != 0) {
+		dptc_mask_dptc_int();
+		dptc_disable_dptc();
+
+		schedule_delayed_work(&dptc_work, 0);
+	}
+#else
+	schedule_delayed_work(&dptc_work, 0);
+#endif
+}
+
+/*!
+ * This function updates the CPU voltage,
+ * produced by mc13783, by calling mc13783
+ * driver functions.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ *				frequency.
+ *
+ */
+void set_pmic_voltage(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr, int wp)
+{
+	/* Call mc13783 functions */
+	t_regulator_voltage volt;
+
+	/* Normal mode setting */
+	volt.sw1a = dvfs_dptc_tables_ptr->wp[wp].pmic_values[0];
+	pmic_power_regulator_set_voltage(SW_SW1A, volt);
+
+#ifdef CONFIG_MXC_DVFS
+	volt.sw1a = dvfs_dptc_tables_ptr->wp[wp].pmic_values[1];
+	pmic_power_switcher_set_dvs(SW_SW1A, volt);
+
+	volt.sw1b = dvfs_dptc_tables_ptr->wp[wp].pmic_values[2];
+	pmic_power_switcher_set_dvs(SW_SW1B, volt);
+
+	volt.sw1b = dvfs_dptc_tables_ptr->wp[wp].pmic_values[3];
+	pmic_power_switcher_set_stby(SW_SW1B, volt);
+#endif
+
+#ifdef EVB_DEBUG
+	if (cpu_is_mx31()) {
+		printk(KERN_INFO "DPVV = 0x%x (0x%x)\n",
+		       mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_DPVV,
+		       mxc_ccm_get_reg(MXC_CCM_PMCR0));
+	}
+#endif				/* EVB_DEBUG */
+}
+
+/*!
+ * This function enables the DPTC module. this function updates the DPTC
+ * thresholds, updates the mc13783, unmasks the DPTC interrupt and enables
+ * the DPTC module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was enabled else returns -EINVAL.
+ */
+int start_dptc(dvfs_dptc_params_s *params)
+{
+	int freq_index = 0;
+
+	/* Check if DPTC module isn't already active */
+	if (params->dptc_is_active == FALSE) {
+
+		enable_ref_circuits(params, params->rc_state);
+		disable_ref_circuits(params, ~params->rc_state);
+
+		/*
+		 * Set the DPTC thresholds and mc13783 voltage to
+		 * correspond to the current working point and frequency.
+		 */
+		set_pmic_voltage(params->dvfs_dptc_tables_ptr,
+				 params->dvfs_dptc_tables_ptr->curr_wp);
+
+#ifdef CONFIG_MXC_DVFS
+		freq_index = dvfs_get_dvsup();
+#endif
+
+		update_dptc_thresholds(params->dvfs_dptc_tables_ptr,
+				       params->dvfs_dptc_tables_ptr->curr_wp,
+				       freq_index);
+
+		/* Mark DPCT module as active */
+		params->dptc_is_active = TRUE;
+
+		/* Enable the DPTC module and unmask the DPTC interrupt */
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+
+		return 0;
+	}
+
+	/* DPTC module already active return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function disables the DPTC module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was disabled else returns -EINVAL.
+ */
+int stop_dptc(dvfs_dptc_params_s *params)
+{
+	/* Check if DPTC module isn't already disabled */
+	if (params->dptc_is_active != FALSE) {
+
+		/* Disable the DPTC module and mask the DPTC interrupt */
+		dptc_disable_dptc();
+		dptc_mask_dptc_int();
+
+		/* Set working point 0 */
+		set_dptc_wp(params, 0);
+
+		/* Mark DPCT module as inactive */
+		params->dptc_is_active = FALSE;
+
+		return 0;
+	}
+
+	/* DPTC module already disabled, return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function updates the drivers current working point index. This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU working point measured by the DPTC hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    new_wp	New working point index value to be set.
+ *
+ */
+void set_dptc_wp(dvfs_dptc_params_s *params, int new_wp)
+{
+	int freq_index = 0;
+
+#ifdef CONFIG_MXC_DVFS
+	freq_index = dvfs_get_dvsup();
+#endif
+
+	/*
+	 * Check if new index is smaller than the maximal working point
+	 * index in the DPTC translation table and larger that 0.
+	 */
+	if ((new_wp < params->dvfs_dptc_tables_ptr->wp_num)
+	    && (new_wp >= 0))
+		/* Set current working point index to new index */
+		params->dvfs_dptc_tables_ptr->curr_wp = new_wp;
+
+	/*
+	 * Check if new index is larger than the maximal working point index in
+	 * the DPTC translation table.
+	 */
+	if (new_wp >= params->dvfs_dptc_tables_ptr->wp_num) {
+		/*
+		 * Set current working point index to maximal working point
+		 * index in the DPTC translation table.
+		 */
+		params->dvfs_dptc_tables_ptr->curr_wp =
+		    params->dvfs_dptc_tables_ptr->wp_num - 1;
+	}
+
+	/* Check if new index is smaller than 0. */
+	if (new_wp < 0)
+		/* Set current working point index to 0 (minimal value) */
+		params->dvfs_dptc_tables_ptr->curr_wp = 0;
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/* Update the DPTC hardware thresholds */
+	update_dptc_thresholds(params->dvfs_dptc_tables_ptr,
+			       params->dvfs_dptc_tables_ptr->curr_wp,
+			       freq_index);
+#else
+	params->prev_wp = params->dvfs_dptc_tables_ptr->curr_wp;
+#endif
+
+	/* Update the mc13783 voltage */
+	set_pmic_voltage(params->dvfs_dptc_tables_ptr,
+			 params->dvfs_dptc_tables_ptr->curr_wp);
+
+	/* Write DPTC changes in the DPTC log buffer */
+	add_dptc_log_entry(params, &params->dptc_log_buffer,
+			   params->dvfs_dptc_tables_ptr->curr_wp, freq_index);
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "Current wp: %d\n",
+			params->dvfs_dptc_tables_ptr->curr_wp);
+#endif
+}
+
+/*!
+ * This function updates the DPTC threshold registers.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ * @param    freq_index		translation table index of the current CPU
+ *				frequency.
+ *
+ */
+void update_dptc_thresholds(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr,
+			    int wp, int freq_index)
+{
+	dcvr_state *dcvr;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+
+	dcvr_state **dcvr_arr;
+	dcvr_state *curr_freq_dcvr;
+
+	dcvr_arr = dvfs_dptc_tables_ptr->dcvr;
+	dcvr_arr = sdma_phys_to_virt((unsigned long)dcvr_arr);
+	curr_freq_dcvr = dcvr_arr[freq_index];
+	curr_freq_dcvr = sdma_phys_to_virt((unsigned long)curr_freq_dcvr);
+	dcvr = &curr_freq_dcvr[wp];
+#else
+	/* Calculate current table entry offset in the DPTC translation table */
+	dcvr = &dvfs_dptc_tables_ptr->dcvr[freq_index][wp];
+#endif
+	/* Update DPTC threshold registers */
+	mxc_ccm_modify_reg(MXC_CCM_DCVR0,
+			0xffffffff, dcvr->dcvr_reg[0].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR1,
+			0xffffffff, dcvr->dcvr_reg[1].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR2,
+			0xffffffff, dcvr->dcvr_reg[2].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR3,
+			0xffffffff, dcvr->dcvr_reg[3].AsInt);
+}
+
+/*!
+ * This function increments a log buffer index (head or tail)
+ * by the value of val.
+ *
+ * @param    index	pointer to the DPTC log buffer index that
+ *			we wish to change.
+ * @param    val	the value in which the index should be incremented.
+ *
+ */
+static void inc_log_index(int *index, int val)
+{
+	*index = (*index + val) % LOG_ENTRIES;
+}
+
+/*!
+ * This function returns the number of entries in the DPTC log buffer.
+ *
+ * @param    dptc_log	pointer to the DPTC log buffer structure.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+static int get_entry_count(dptc_log_s *dptc_log)
+{
+	return (dptc_log->head - dptc_log->tail + LOG_ENTRIES) % LOG_ENTRIES;
+}
+
+/*!
+ * This function is used by the proc file system to read the DPTC log buffer.
+ * Each time the DPTC proc file system file is read this function is called
+ * and returns the data written in the log buffer.
+ *
+ * @param    buf	pointer to the buffer the data should be written to.
+ * @param    start	pointer to the pointer where the new data is
+ *                      written to.
+ *			procedure should update the start pointer to point to
+ *			where in the buffer the data was written.
+ * @param    offset	current offset in the DPTC proc file.
+ * @param    count	number of bytes to read.
+ * @param    eof	pointer to eof flag. should be set to 1 when
+ *                      reaching eof.
+ * @param    data	driver specific data pointer.
+ *
+ * @return   number byte read from the log buffer.
+ *
+ */
+static int read_log(char *buf, char **start, off_t offset, int count,
+		    int *eof, void *data)
+{
+	int ret;
+	int entries_to_read;
+	int num_of_entries;
+	int entries_to_end_of_buffer, entries_left;
+	void *entry_ptr;
+	char *buf_ptr;
+	dvfs_dptc_params_s *params;
+
+	params = (dvfs_dptc_params_s *) data;
+
+	/* Calculate number of log entries to read */
+	entries_to_read = count / sizeof(dptc_log_entry_s);
+	/* Get the number of current log buffer entries */
+	num_of_entries = get_entry_count(&params->dptc_log_buffer);
+
+	/*
+	 * If number of entries to read is larger that the number of entries
+	 * in the log buffer set number of entries to read to number of
+	 * entries in the log buffer and set eof flag to 1
+	 */
+	if (num_of_entries < entries_to_read) {
+		entries_to_read = num_of_entries;
+		*eof = 1;
+	}
+
+	/*
+	 * Down the log buffer mutex to exclude others from reading and
+	 * writing to the log buffer.
+	 */
+	if (down_interruptible(&params->dptc_log_buffer.mutex))
+		return -EAGAIN;
+
+	if (num_of_entries == 0 && offset == 0) {
+		inc_log_index(&params->dptc_log_buffer.tail, -1);
+		num_of_entries++;
+		entries_to_read++;
+	}
+
+	/* get the pointer of the last (oldest) entry in the log buffer */
+	entry_ptr = (void *)&params->dptc_log_buffer.
+	    entries[params->dptc_log_buffer.tail];
+
+	/* Check if tail index wraps during current read */
+	if ((params->dptc_log_buffer.tail + entries_to_read) < LOG_ENTRIES) {
+		/* No tail wrap around copy data from log buffer to buf */
+		memcpy(buf, entry_ptr,
+		       (entries_to_read * sizeof(dptc_log_entry_s)));
+	} else {
+		/*
+		 * Tail wrap around.
+		 * First copy data from current position until end of buffer,
+		 * after that copy the rest from start of the log buffer.
+		 */
+		entries_to_end_of_buffer = LOG_ENTRIES -
+		    params->dptc_log_buffer.tail;
+		memcpy(buf, entry_ptr,
+		       (entries_to_end_of_buffer * sizeof(dptc_log_entry_s)));
+
+		entry_ptr = (void *)&params->dptc_log_buffer.entries[0];
+		buf_ptr = buf +
+		    (entries_to_end_of_buffer * sizeof(dptc_log_entry_s));
+		entries_left = entries_to_read - entries_to_end_of_buffer;
+		memcpy(buf_ptr, entry_ptr,
+		       (entries_left * sizeof(dptc_log_entry_s)));
+	}
+
+	/* Increment the tail index by the number of entries read */
+	inc_log_index(&params->dptc_log_buffer.tail, entries_to_read);
+
+	/* Up the log buffer mutex to allow access to the log buffer */
+	up(&params->dptc_log_buffer.mutex);
+
+	/* set start of data to point to buf */
+	*start = buf;
+
+	ret = (entries_to_read * sizeof(dptc_log_entry_s));
+	return ret;
+}
+
+/*!
+ * This function initializes the DPTC log buffer.
+ *
+ * @param    params	pointer to \b dvfs_dptc_params_s.
+ * @param    dptc_log	pointer to the DPTC log buffer structure.
+ *
+ */
+void init_dptc_log(dvfs_dptc_params_s *params, dptc_log_s *dptc_log)
+{
+	dptc_log->tail = 0;
+	dptc_log->head = 0;
+
+	/* initialize log buffer mutex used for accessing the log buffer */
+	sema_init(&dptc_log->mutex, 1);
+
+	/* add the first log buffer entry */
+	add_dptc_log_entry(params, dptc_log,
+			   params->dvfs_dptc_tables_ptr->curr_wp,
+			   params->current_freq_index);
+}
+
+/*!
+ * This function adds a new entry to the DPTC log buffer.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    dptc_log		pointer to the DPTC log buffer structure.
+ * @param    wp			value of the working point index written
+ *				to the log buffer.
+ * @param    freq_index		value of the frequency index written to
+ *				the log buffer.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+void add_dptc_log_entry(dvfs_dptc_params_s *params,
+			dptc_log_s *dptc_log, int wp, int freq_index)
+{
+	/*
+	 * Down the log buffer mutex to exclude others from reading and
+	 * writing to the log buffer.
+	 */
+	if (down_interruptible(&dptc_log->mutex))
+		return;
+
+	/* Write values to log buffer */
+	dptc_log->entries[dptc_log->head].jiffies = jiffies;
+	dptc_log->entries[dptc_log->head].wp = wp;
+
+	dptc_log->entries[dptc_log->head].voltage = wp;
+
+#ifdef CONFIG_MXC_DVFS
+	freq_index = dptc_get_ptvai();
+#endif
+
+	dptc_log->entries[dptc_log->head].freq = freq_index;
+
+	/* Increment the head index by 1 */
+	inc_log_index(&dptc_log->head, 1);
+	/* If head index reaches the tail increment the tail by 1 */
+	if (dptc_log->head == dptc_log->tail)
+		inc_log_index(&dptc_log->tail, 1);
+
+	/* Up the log buffer mutex to allow access to the log buffer */
+	up(&dptc_log->mutex);
+}
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_suspend(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params->dptc_is_active) {
+		dptc_disable_dptc();
+		set_dptc_wp(dvfs_dptc_params,
+			    dvfs_dptc_params->
+			    dvfs_dptc_tables_ptr->curr_wp - 1);
+	}
+#endif
+}
+EXPORT_SYMBOL(dptc_suspend);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_resume(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params->dptc_is_active) {
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+	}
+#endif
+}
+EXPORT_SYMBOL(dptc_resume);
+
+/*!
+ * This function initializes the DPTC hardware
+ *
+ * @param    params    pointer to the DPTC driver parameters structure.
+ *
+ */
+int __init init_dptc_controller(dvfs_dptc_params_s *params)
+{
+	dvfs_dptc_params = params;
+
+	INIT_DELAYED_WORK(&dptc_work, dptc_workqueue_handler);
+
+	if (create_proc_read_entry(PROC_NODE_NAME, 0,
+				   NULL, read_log, params) == NULL) {
+		/*
+		 * Error creating proc file system entry.
+		 * Exit and return error code
+		 */
+		printk(KERN_ERR "DPTC: Unable create proc entry");
+		return -EFAULT;
+	}
+
+	/* Initialize the DPTC log buffer */
+	init_dptc_log(params, &params->dptc_log_buffer);
+
+	set_dptc_curr_freq(params, 0);
+	set_dptc_wp(params, 0);
+
+	/* By default all reference circuits are enabled */
+	params->rc_state = DPTC_REF_CIRCUITS_STATUS;
+	dptc_clear_dcr();
+
+	/* Disable DPTC hardware and mask DPTC interrupt */
+	dptc_disable_dptc();
+	dptc_mask_dptc_int();
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DVFS_SDMA
+	dptc_set_ptvis();
+#endif
+#endif
+	printk(KERN_INFO "DPTC controller initialized\n");
+
+	return 0;
+}
+
+/*!
+ * This function updates the drivers current frequency index.This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU frequency (each CPU frequency has a separate index number
+ * according to the loaded DPTC table).
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ * @param    freq_index	  New frequency index value to be set.
+ *
+ * @return      0 if the frequency index was updated (the new index is a
+ *		valid index and the DPTC module isn't active) else returns
+ *              -EINVAL.
+ *
+ */
+int set_dptc_curr_freq(dvfs_dptc_params_s *params, unsigned int freq_index)
+{
+	/*
+	 * Check if the new index value is a valid frequency index (smaller
+	 * than the maximal index in the DPTC table) and if the DPTC module
+	 * is disabled.
+	 */
+	if ((freq_index < params->dvfs_dptc_tables_ptr->dvfs_state_num)
+	    && (params->dptc_is_active == FALSE)) {
+		/*
+		 * Index is valid and DPTC module is
+		 * disabled -> change frequency index.
+		 */
+		params->current_freq_index = freq_index;
+		add_dptc_log_entry(params, &params->dptc_log_buffer,
+				   params->dvfs_dptc_tables_ptr->curr_wp,
+				   params->current_freq_index);
+
+		return 0;
+	}
+
+	/* Invalid index or DPTC module is active -> return error */
+	return -EINVAL;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * DPTC SDMA callback.
+ * Updates the mc13783 voltage
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dptc_sdma_callback(dvfs_dptc_params_s *params)
+{
+	printk(KERN_INFO "In %s: params->dvfs_dptc_tables_ptr->curr_wp = %d\n",
+	       __func__, params->dvfs_dptc_tables_ptr->curr_wp);
+}
+#endif
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dptc_suspend();
+	return 0;
+}
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_resume(struct platform_device *pdev)
+{
+	dptc_resume();
+	return 0;
+}
diff --git a/drivers/mxc/pm/dvfs_dptc.c b/drivers/mxc/pm/dvfs_dptc.c
new file mode 100644
index 0000000..eb48daa
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc.c
@@ -0,0 +1,1245 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_dptc.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DVFS & DPTC module.
+ *
+ * The DVFS & DPTC driver
+ * driver is designed as a character driver which interacts with the MXC
+ * DVFS & DPTC hardware. Upon initialization, the DVFS & DPTC driver initializes
+ * the DVFS & DPTC hardware sets up driver nodes attaches to the DVFS & DPTC
+ * interrupts and initializes internal data structures. When the DVFS or DPTC
+ * interrupt occurs the driver checks the cause of the interrupt
+ * (lower voltage/frequency, increase voltage/frequency or emergency)
+ * and changes the CPU voltage and/or frequency according to translation table
+ * that is loaded into the driver (the voltage changes are done by calling
+ * some routines of the mc13783 driver).
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/vmalloc.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*
+ * Module header files
+ */
+#include "dvfs_dptc.h"
+#include <mach/dptc.h>
+
+#ifdef CONFIG_MXC_DVFS
+#include <mach/dvfs.h>
+#endif
+
+/*
+ * Comment EVB_DEBUG to disable debug messages
+ */
+/* #define EVB_DEBUG 1 */
+
+/*
+ * Prototypes
+ */
+static int dvfs_dptc_open(struct inode *inode, struct file *filp);
+static int dvfs_dptc_release(struct inode *inode, struct file *filp);
+static int dvfs_dptc_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+#ifdef CONFIG_MXC_DVFS_SDMA
+static ssize_t dvfs_dptc_read(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos);
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+static irqreturn_t dvfs_dptc_irq(int irq, void *dev_id);
+#else
+static void dvfs_dptc_sdma_callback(dvfs_dptc_params_s *params);
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_dptc_driver = {
+	.driver = {
+		   .name = "mxc_dptc",
+		   },
+	.suspend = mxc_dptc_suspend,
+	.resume = mxc_dptc_resume,
+};
+
+/*!
+ * This is platform device structure for adding MU
+ */
+static struct platform_device mxc_dptc_device = {
+	.name = "mxc_dptc",
+	.id = 0,
+};
+#endif
+
+/*
+ * Global variables
+ */
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
+ * (current working point, current frequency, translation table and DPTC
+ * log buffer).
+ */
+static dvfs_dptc_params_s dvfs_dptc_params;
+
+/*!
+ * Holds the automatically selected DPTC driver major number.
+ */
+static int major;
+
+void mxc_dvfs_dptc_class_dev_release(struct device *dev);
+
+static struct class mxc_dvfs_dptc_class = {
+	.owner		=	THIS_MODULE,
+	.name		=	DEVICE_NAME,
+	.dev_release	= mxc_dvfs_dptc_class_dev_release,
+};
+
+/*
+ * This mutex makes the Read,Write and IOCTL command mutual exclusive.
+ */
+DECLARE_MUTEX(access_mutex);
+
+/*!
+ * This structure contains pointers for device driver entry point.
+ * The driver register function in init module will call this
+ * structure.
+ */
+static struct file_operations fops = {
+	.open = dvfs_dptc_open,
+	.release = dvfs_dptc_release,
+	.ioctl = dvfs_dptc_ioctl,
+#ifdef CONFIG_MXC_DVFS_SDMA
+	.read = dvfs_dptc_read,
+#endif
+};
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * Update pointers to physical addresses of DVFS & DPTC table
+ * for SDMA usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+static void dvfs_dptc_virt_2_phys(dvfs_dptc_tables_s *dvfs_dptc_table)
+{
+	int i;
+
+	/* Update DCVR pointers */
+	for (i = 0; i < dvfs_dptc_table->dvfs_state_num; i++) {
+		dvfs_dptc_table->dcvr[i] = (dcvr_state *)
+		    sdma_virt_to_phys(dvfs_dptc_table->dcvr[i]);
+	}
+	dvfs_dptc_table->dcvr = (dcvr_state **)
+	    sdma_virt_to_phys(dvfs_dptc_table->dcvr);
+	dvfs_dptc_table->table = (dvfs_state *)
+	    sdma_virt_to_phys(dvfs_dptc_table->table);
+}
+
+/*
+ * Update pointers to virtual addresses of DVFS & DPTC table
+ * for ARM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+static void dvfs_dptc_phys_2_virt(dvfs_dptc_tables_s *dvfs_dptc_table)
+{
+	int i;
+
+	dvfs_dptc_table->table = sdma_phys_to_virt
+	    ((unsigned long)dvfs_dptc_table->table);
+	dvfs_dptc_table->dcvr = sdma_phys_to_virt
+	    ((unsigned long)dvfs_dptc_table->dcvr);
+
+	/* Update DCVR pointers */
+	for (i = 0; i < dvfs_dptc_table->dvfs_state_num; i++) {
+		dvfs_dptc_table->dcvr[i] =
+		    sdma_phys_to_virt((unsigned long)dvfs_dptc_table->dcvr[i]);
+	}
+}
+#endif
+
+/*!
+ * This function frees power management table structures
+ */
+static void free_dvfs_dptc_table(void)
+{
+	int i;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	dvfs_dptc_phys_2_virt(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+#endif
+
+	for (i = 0;
+	     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num; i++) {
+		sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr[i]);
+	}
+
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr);
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->table);
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->wp);
+
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+
+	dvfs_dptc_params.dvfs_dptc_tables_ptr = 0;
+}
+
+/*
+ * DVFS & DPTC table parsing function
+ * reads the next line of the table in text format
+ *
+ * @param   str    pointer to the previous line
+ *
+ * @return  pointer to the next line
+ */
+static char *pm_table_get_next_line(char *str)
+{
+	char *line_ptr;
+	int flag = 0;
+
+	if (strlen(str) == 0)
+		return str;
+
+	line_ptr = strchr(str, '\n') + 1;
+
+	while (!flag) {
+		if (strlen(line_ptr) == 0)
+			flag = 1;
+		else if (line_ptr[0] == '\n')
+			line_ptr++;
+		else if (line_ptr[0] == '#')
+			line_ptr = pm_table_get_next_line(line_ptr);
+		else
+			flag = 1;
+	}
+
+	return line_ptr;
+}
+
+/*
+ * DVFS & DPTC table parsing function
+ * sets the values of DVFS & DPTC tables from
+ * table in text format
+ *
+ * @param   pm_table  pointer to the table in binary format
+ * @param   pm_str    pointer to the table in text format
+ *
+ * @return  0 on success, error code on failure
+ */
+static int dvfs_dptc_parse_table(dvfs_dptc_tables_s *pm_table, char *pm_str)
+{
+	char *pm_str_ptr;
+	int i, j, n;
+	dptc_wp *wp;
+	dvfs_state *table;
+
+	pm_str_ptr = pm_str;
+
+	n = sscanf(pm_str_ptr, "WORKING POINT %d\n", &pm_table->wp_num);
+
+	if (n != 1) {
+		printk(KERN_WARNING "Failed read WORKING POINT number\n");
+		return -1;
+	}
+
+	pm_table->curr_wp = 0;
+
+	pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+
+	if (cpu_is_mx31()) {
+		pm_table->dvfs_state_num = 4;
+		pm_table->use_four_freq = 1;
+	} else {
+		pm_table->dvfs_state_num = 1;
+	}
+
+	pm_table->wp =
+	    (dptc_wp *) sdma_malloc(sizeof(dptc_wp) * pm_table->wp_num);
+	if (!pm_table->wp) {
+		printk(KERN_ERR "Failed allocating memory\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pm_table->wp_num; i++) {
+
+		wp = &pm_table->wp[i];
+
+		wp->wp_index = i;
+
+		if (cpu_is_mx31()) {
+			n = sscanf(pm_str_ptr, "WP 0x%x 0x%x 0x%x 0x%x\n",
+				   (unsigned int *)&wp->pmic_values[0],
+				   (unsigned int *)&wp->pmic_values[1],
+				   (unsigned int *)&wp->pmic_values[2],
+				   (unsigned int *)&wp->pmic_values[3]);
+
+			if (n != 4) {
+				printk(KERN_WARNING "Failed read WP %d\n", i);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+		} else {
+			n = sscanf(pm_str_ptr, "WP 0x%x\n",
+				   (unsigned int *)&wp->pmic_values[0]);
+
+			if (n != 1) {
+				printk(KERN_WARNING "Failed read WP %d\n", i);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+		}
+
+		pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+
+	}
+
+	pm_table->table =
+	    (dvfs_state *) sdma_malloc(sizeof(dvfs_state) *
+				       pm_table->dvfs_state_num);
+
+	if (!pm_table->table) {
+		printk(KERN_WARNING "Failed allocating memory\n");
+		sdma_free(pm_table->wp);
+		return -ENOMEM;
+	}
+
+	if (cpu_is_mx31()) {
+		for (i = 0; i < pm_table->dvfs_state_num; i++) {
+			table = &pm_table->table[i];
+
+			n = sscanf(pm_str_ptr,
+				   "FREQ %d %d 0x%x 0x%x 0x%x 0x%x %d\n",
+				   (unsigned int *)&table->pll_sw_up,
+				   (unsigned int *)&table->pll_sw_down,
+				   (unsigned int *)&table->pdr0_up,
+				   (unsigned int *)&table->pdr0_down,
+				   (unsigned int *)&table->pll_up,
+				   (unsigned int *)&table->pll_down,
+				   (unsigned int *)&table->vscnt);
+
+			if (n != 7) {
+				printk(KERN_WARNING "Failed read FREQ %d\n", i);
+				sdma_free(pm_table->table);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+
+			pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+		}
+	}
+
+	pm_table->dcvr =
+	    (dcvr_state **) sdma_malloc(sizeof(dcvr_state *) *
+					pm_table->dvfs_state_num);
+
+	if (!pm_table->dcvr) {
+		printk(KERN_WARNING "Failed allocating memory\n");
+		sdma_free(pm_table->table);
+		sdma_free(pm_table->wp);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pm_table->dvfs_state_num; i++) {
+		pm_table->dcvr[i] =
+		    (dcvr_state *) sdma_malloc(sizeof(dcvr_state) *
+					       pm_table->wp_num);
+
+		if (!pm_table->dcvr[i]) {
+			printk(KERN_WARNING "Failed allocating memory\n");
+
+			for (j = i - 1; j >= 0; j--)
+				sdma_free(pm_table->dcvr[j]);
+
+			sdma_free(pm_table->dcvr);
+			return -ENOMEM;
+		}
+
+		for (j = 0; j < pm_table->wp_num; j++) {
+
+			n = sscanf(pm_str_ptr, "DCVR 0x%x 0x%x 0x%x 0x%x\n",
+				   &pm_table->dcvr[i][j].dcvr_reg[0].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[1].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[2].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[3].AsInt);
+
+			if (n != 4) {
+				printk(KERN_WARNING "Failed read FREQ %d\n", i);
+
+				for (j = i; j >= 0; j--)
+					sdma_free(pm_table->dcvr[j]);
+
+				sdma_free(pm_table->dcvr);
+				sdma_free(pm_table->table);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+
+			pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Initializes the default values of DVFS & DPTC table
+ *
+ * @return  0 on success, error code on failure
+ */
+static int __init dvfs_dptc_init_default_table(void)
+{
+	int res = 0;
+	char *table_str;
+	struct clk *clk = NULL;
+
+	dvfs_dptc_tables_s *default_table;
+
+	default_table = sdma_malloc(sizeof(dvfs_dptc_tables_s));
+
+	if (!default_table)
+		return -ENOMEM;
+
+	if (cpu_is_mx31()) {
+		if (mx31_revision() < CHIP_REV_2_0) {
+			clk = clk_get(NULL, "ckih");
+			if (clk_get_rate(clk) == 27000000) {
+				printk(KERN_INFO
+					"DVFS & DPTC: using"
+					"27MHz CKIH table\n");
+				table_str = default_table_str_27ckih;
+			} else
+				table_str = default_table_str;
+		} else
+			table_str = default_table_str;
+
+		clk_put(clk);
+	}
+
+	memset(default_table, 0, sizeof(dvfs_dptc_tables_s));
+	res = dvfs_dptc_parse_table(default_table, table_str);
+
+	if (res == 0)
+		dvfs_dptc_params.dvfs_dptc_tables_ptr = default_table;
+
+	return res;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is called for SDMA channel initialization.
+ *
+ * @param    params    pointer to the DPTC driver parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ */
+static int init_sdma_channel(dvfs_dptc_params_s *params)
+{
+	dma_channel_params sdma_params;
+	dma_request_t sdma_request;
+	int i;
+	int res = 0;
+
+	params->sdma_channel = 0;
+	res = mxc_request_dma(&params->sdma_channel, "DVFS_DPTC");
+	if (res < 0) {
+		printk(KERN_ERR "Failed allocate SDMA channel for DVFS_DPTC\n");
+		return res;
+	}
+
+	memset(&sdma_params, 0, sizeof(dma_channel_params));
+	sdma_params.peripheral_type = CCM;
+	sdma_params.transfer_type = per_2_emi;
+	sdma_params.event_id = DMA_REQ_CCM;
+	sdma_params.callback = (dma_callback_t) dvfs_dptc_sdma_callback;
+	sdma_params.arg = params;
+	sdma_params.per_address = CCM_BASE_ADDR;
+	sdma_params.watermark_level =
+	    sdma_virt_to_phys(params->dvfs_dptc_tables_ptr);
+	sdma_params.bd_number = 2;
+
+	res = mxc_dma_setup_channel(params->sdma_channel, &sdma_params);
+
+	if (res == 0) {
+		memset(&sdma_request, 0, sizeof(dma_request_t));
+
+		for (i = 0; i < DVFS_LB_SDMA_BD; i++) {
+			sdma_request.destAddr = (__u8 *)
+			    (params->dvfs_log_buffer_phys +
+			     i * (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) /
+			     DVFS_LB_SDMA_BD);
+			sdma_request.count = DVFS_LB_SIZE / DVFS_LB_SDMA_BD;
+			sdma_request.bd_cont = 1;
+
+			mxc_dma_set_config(params->sdma_channel, &sdma_request,
+					   i);
+		}
+
+		mxc_dma_start(params->sdma_channel);
+	}
+
+	return res;
+}
+#endif
+
+
+void mxc_dvfs_dptc_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures, sets up the DPTC hardware,
+ * registers the DPTC driver, creates a proc file system read entry and
+ * attaches the driver to the DPTC interrupt.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+static int __init dvfs_dptc_init(void)
+{
+	int res = 0;
+	struct device *temp_dev;
+
+	res = dvfs_dptc_init_default_table();
+
+	if (res < 0) {
+		printk(KERN_WARNING "Failed parsing default DPTC table\n");
+		return res;
+	}
+#ifdef CONFIG_MXC_DPTC
+	/* Initialize DPTC hardware */
+	res = init_dptc_controller(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+	/* Initialize DVFS hardware */
+	res = init_dvfs_controller(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+
+	/* Enable 4 mc13783 output voltages */
+	pmic_write_reg(REG_ARBITRATION_SWITCHERS, 1, (1 << 5));
+
+	/* Enable mc13783 voltage ready signal */
+	pmic_write_reg(REG_INTERRUPT_MASK_1, 0, (1 << 11));
+
+	/* Set mc13783 DVS speed 25mV each 4us */
+	pmic_write_reg(REG_SWITCHERS_4, 1, (1 << 6));
+	pmic_write_reg(REG_SWITCHERS_4, 0, (1 << 7));
+
+	dvfs_update_freqs_table(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+#endif
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/* Update addresses to physical */
+	if (res == 0)
+		dvfs_dptc_virt_2_phys(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+
+	res = init_sdma_channel(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+#endif
+
+	/* Initialize internal driver structures */
+	dvfs_dptc_params.dptc_is_active = FALSE;
+
+#ifdef CONFIG_MXC_DVFS
+	dvfs_dptc_params.dvfs_is_active = FALSE;
+#endif
+
+	/*
+	 * Register DPTC driver as a char driver with an automatically allocated
+	 * major number.
+	 */
+	major = register_chrdev(0, DEVICE_NAME, &fops);
+
+	/*
+	 * Return error if a negative major number is returned.
+	 */
+	if (major < 0) {
+		printk(KERN_ERR
+		       "DPTC: Registering driver failed with %d\n", major);
+		free_dvfs_dptc_table();
+		return major;
+	}
+
+	res = class_register(&mxc_dvfs_dptc_class);
+	if (res) {
+		printk(KERN_ERR "DPTC: Error creating class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&mxc_dvfs_dptc_class,
+			NULL, MKDEV(major, 0), NULL, DEVICE_NAME);
+	 if (IS_ERR(temp_dev)) {
+			printk(KERN_ERR "DPTC: Error creating class device.\n");
+			res = PTR_ERR(temp_dev);
+			goto err_out2;
+	 }
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/* request the DPTC interrupt */
+	res = request_irq(MXC_INT_CCM, dvfs_dptc_irq, 0, DEVICE_NAME, NULL);
+	/*
+	 * If res is not 0, then where was an error
+	 * during attaching to DPTC interrupt.
+	 * Exit and return error code.
+	 */
+	if (res) {
+		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt");
+		goto err_out3;
+	}
+	/* request the DVFS interrupt */
+	res = request_irq(MXC_INT_DVFS, dvfs_dptc_irq, 0, DEVICE_NAME, NULL);
+	if (res) {
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt");
+		goto err_out4;
+	}
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+	/* Register low power modes functions */
+	res = platform_driver_register(&mxc_dptc_driver);
+	if (res == 0) {
+		res = platform_device_register(&mxc_dptc_device);
+		if (res != 0)
+			goto err_out5;
+	}
+#endif
+	dvfs_dptc_params.suspended = FALSE;
+
+	return res;
+
+err_out5:
+	free_irq(MXC_INT_DVFS, NULL);
+#ifndef CONFIG_MXC_DVFS_SDMA
+err_out4:
+#endif
+	free_irq(MXC_INT_CCM, NULL);
+#ifndef CONFIG_MXC_DVFS_SDMA
+err_out3:
+#endif
+	device_unregister(temp_dev);
+err_out2:
+	class_unregister(&mxc_dvfs_dptc_class);
+err_out1:
+	unregister_chrdev(major, DEVICE_NAME);
+	free_dvfs_dptc_table();
+	printk(KERN_ERR "DVFS&DPTC driver was not initialized\n");
+	return res;
+}
+
+/*!
+ * This function is called whenever the module is removed from the kernel. It
+ * unregisters the DVFS & DPTC driver from kernel, frees the irq number
+ * and removes the proc file system entry.
+ */
+static void __exit dvfs_dptc_cleanup(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	/* Unregister low power modes functions */
+	platform_driver_unregister(&mxc_dptc_driver);
+	platform_device_unregister(&mxc_dptc_device);
+#endif
+
+	free_dvfs_dptc_table();
+
+	/* release the DPTC interrupt */
+	free_irq(MXC_INT_CCM, NULL);
+	/* release the DVFS interrupt */
+	free_irq(MXC_INT_DVFS, NULL);
+
+	/* remove the DPTC proc file system entry */
+	remove_proc_entry(PROC_NODE_NAME, NULL);
+}
+
+/*!
+ * This function is called when the driver is opened. This function
+ * checks if the user that open the device has root privileges.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ */
+static int dvfs_dptc_open(struct inode *inode, struct file *filp)
+{
+	/*
+	 * check if the program that opened the driver has root
+	 * privileges, if not return error.
+	 */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (dvfs_dptc_params.suspended)
+		return -EPERM;
+
+	return 0;
+}
+
+/*!
+ * This function is called when the driver is close.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ *
+ */
+static int dvfs_dptc_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/*!
+ * This function dumps dptc translation table into string pointer
+ *
+ * @param    str    string pointer
+ */
+static void dvfs_dptc_dump_table(char *str)
+{
+	int i, j;
+	dcvr_state **dcvr_arr;
+	dcvr_state *dcvr_row;
+	dvfs_state *table;
+
+	memset(str, 0, MAX_TABLE_SIZE);
+
+	sprintf(str, "WORKING POINT %d\n",
+		dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num);
+	str += strlen(str);
+
+	for (i = 0; i < dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num; i++) {
+		if (cpu_is_mx31()) {
+			sprintf(str, "WP 0x%x 0x%x 0x%x 0x%x\n", (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[0], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[1], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[2], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[3]);
+		} else {
+			sprintf(str, "WP 0x%x\n", (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[0]);
+		}
+
+		str += strlen(str);
+	}
+
+	if (cpu_is_mx31()) {
+		for (i = 0;
+		     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num;
+		     i++) {
+			table = dvfs_dptc_params.dvfs_dptc_tables_ptr->table;
+#ifdef CONFIG_MXC_DVFS_SDMA
+			table = sdma_phys_to_virt((unsigned long)table);
+#endif
+			sprintf(str,
+				"FREQ %d %d 0x%x 0x%x 0x%x 0x%x %d\n",
+				(unsigned int)table[i].pll_sw_up,
+				(unsigned int)table[i].pll_sw_down,
+				(unsigned int)table[i].pdr0_up,
+				(unsigned int)table[i].pdr0_down,
+				(unsigned int)table[i].pll_up,
+				(unsigned int)table[i].pll_down,
+				(unsigned int)table[i].vscnt);
+
+			str += strlen(str);
+		}
+	}
+
+	for (i = 0;
+	     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num; i++) {
+		dcvr_arr = dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr;
+#ifdef CONFIG_MXC_DVFS_SDMA
+		dcvr_arr = sdma_phys_to_virt((unsigned long)dcvr_arr);
+#endif
+		dcvr_row = dcvr_arr[i];
+#ifdef CONFIG_MXC_DVFS_SDMA
+		dcvr_row = sdma_phys_to_virt((unsigned long)dcvr_row);
+#endif
+
+		for (j = 0;
+		     j < dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num; j++) {
+			sprintf(str,
+				"DCVR 0x%x 0x%x 0x%x 0x%x\n",
+				dcvr_row[j].dcvr_reg[0].AsInt,
+				dcvr_row[j].dcvr_reg[1].AsInt,
+				dcvr_row[j].dcvr_reg[2].AsInt,
+				dcvr_row[j].dcvr_reg[3].AsInt);
+
+			str += strlen(str);
+		}
+	}
+}
+
+/*!
+ * This function reads DVFS & DPTC translation table from user
+ *
+ * @param    user_table    pointer to user table
+ * @return   0 on success, error code on failure
+ */
+int dvfs_dptc_set_table(char *user_table)
+{
+	int ret_val = -ENOIOCTLCMD;
+	char *tmp_str;
+	char *tmp_str_ptr;
+	dvfs_dptc_tables_s *dptc_table;
+
+	if (cpu_is_mx31() &&
+	    (dvfs_dptc_params.dptc_is_active == TRUE ||
+	     dvfs_dptc_params.dvfs_is_active == TRUE)) {
+		ret_val = -EINVAL;
+		return ret_val;
+	} else if (dvfs_dptc_params.dptc_is_active == TRUE) {
+		ret_val = -EINVAL;
+		return ret_val;
+	}
+
+	tmp_str = vmalloc(MAX_TABLE_SIZE);
+
+	if (tmp_str < 0) {
+		ret_val = (int)tmp_str;
+	} else {
+		memset(tmp_str, 0, MAX_TABLE_SIZE);
+		tmp_str_ptr = tmp_str;
+
+		/*
+		 * read num_of_wp and dvfs_state_num
+		 * parameters from new table
+		 */
+		while (tmp_str_ptr - tmp_str < MAX_TABLE_SIZE &&
+		       (!copy_from_user(tmp_str_ptr, user_table, 1)) &&
+		       tmp_str_ptr[0] != 0) {
+			tmp_str_ptr++;
+			user_table++;
+		}
+		if (tmp_str_ptr == tmp_str) {
+			/* error reading from table */
+			printk(KERN_ERR "Failed reading table from user,"
+					"didn't copy a character\n");
+			ret_val = -EFAULT;
+		} else if (tmp_str_ptr - tmp_str == MAX_TABLE_SIZE) {
+			/* error reading from table */
+			printk(KERN_ERR "Failed reading table from user,"
+					"read more than %d\n", MAX_TABLE_SIZE);
+			ret_val = -EFAULT;
+		} else {
+			/*
+			 * copy table from user and set it as
+			 * the current DPTC table
+			 */
+			dptc_table = sdma_malloc(sizeof(dvfs_dptc_tables_s));
+
+			if (!dptc_table) {
+				ret_val = -ENOMEM;
+			} else {
+				ret_val =
+				    dvfs_dptc_parse_table(dptc_table, tmp_str);
+
+				if (ret_val == 0) {
+					free_dvfs_dptc_table();
+					dvfs_dptc_params.dvfs_dptc_tables_ptr =
+					    dptc_table;
+
+#ifdef CONFIG_MXC_DVFS
+					dvfs_update_freqs_table
+					    (dvfs_dptc_params.
+					     dvfs_dptc_tables_ptr);
+#endif
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+					/* Update addresses to physical */
+					dvfs_dptc_virt_2_phys(dvfs_dptc_params.
+							dvfs_dptc_tables_ptr);
+					mxc_free_dma(dvfs_dptc_params.
+						     sdma_channel);
+					init_sdma_channel(&dvfs_dptc_params);
+#endif
+#ifdef CONFIG_MXC_DPTC
+					set_dptc_curr_freq(&dvfs_dptc_params,
+							   0);
+					set_dptc_wp(&dvfs_dptc_params, 0);
+#endif
+				}
+			}
+
+		}
+
+		vfree(tmp_str);
+	}
+
+	return ret_val;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+static ssize_t dvfs_dptc_read(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	size_t count0, count1;
+
+	while (dvfs_dptc_params.chars_in_buffer < count) {
+		waitqueue_active(&dvfs_dptc_params.dvfs_pred_wait);
+		wake_up(&dvfs_dptc_params.dvfs_pred_wait);
+		schedule();
+	}
+
+	if (dvfs_dptc_params.read_ptr + count <
+	    dvfs_dptc_params.dvfs_log_buffer +
+	    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) {
+		count0 = count;
+		count1 = 0;
+	} else {
+		count0 =
+		    dvfs_dptc_params.dvfs_log_buffer +
+		    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8 -
+		    dvfs_dptc_params.read_ptr;
+		count1 = count - count0;
+	}
+
+	copy_to_user(buf, dvfs_dptc_params.read_ptr, count0);
+	copy_to_user(buf + count0, dvfs_dptc_params.dvfs_log_buffer, count1);
+
+	if (count1 == 0)
+		dvfs_dptc_params.read_ptr += count;
+	else
+		dvfs_dptc_params.read_ptr =
+		    dvfs_dptc_params.dvfs_log_buffer + count1;
+
+	if (dvfs_dptc_params.read_ptr ==
+	    dvfs_dptc_params.dvfs_log_buffer +
+	    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) {
+		dvfs_dptc_params.read_ptr = dvfs_dptc_params.dvfs_log_buffer;
+	}
+
+	dvfs_dptc_params.chars_in_buffer -= count;
+
+	return count;
+}
+#endif
+
+/*!
+ * This function is called when a ioctl call is made from user space.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ * @param    cmd      Ioctl command
+ * @param    arg      Ioctl argument
+ *
+ *                    Following are the ioctl commands for user to use:\n
+ *                    DPTC_IOCTENABLE : Enables the DPTC module.\n
+ *                    DPTC_IOCTDISABLE : Disables the DPTC module.\n
+ *                    DPTC_IOCSENABLERC : Enables DPTC reference circuits.\n
+ *                    DPTC_IOCSDISABLERC : Disables DPTC reference circuits.\n
+ *                    DPTC_IOCGETSTATE :
+ *                    Returns 1 if the DPTC module is enabled,
+ *                    returns 0 if the DPTC module is disabled.\n
+ *                    DPTC_IOCSWP : Sets working point.\n
+ *                    PM_IOCSTABLE : Sets translation table.\n
+ *                    PM_IOCGTABLE : Gets translation table.\n
+ *                    DVFS_IOCTENABLE : Enables DVFS
+ *                    DVFS_IOCTDISABLE : Disables DVFS
+ *                    DVFS_IOCGSTATE : Returns 1 if the DVFS module is enabled,
+ *                    returns 0 if the DVFS module is disabled.\n
+ *                    DVFS_IOCSSWGP : Sets the value of DVFS SW general
+ *                    purpose bits.\n
+ *                    DVFS_IOCSWFI : Sets the status of WFI monitoring.\n
+ *                    PM_IOCGFREQ : Returns current CPU frequency in Hz
+ *                    DVFS_IOCSFREQ : Sets DVFS frequency when DVFS\n
+ *                    HW is disabled.\n
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ */
+static int dvfs_dptc_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg)
+{
+	unsigned int tmp;
+	int ret_val = -ENOIOCTLCMD;
+	char *tmp_str;
+	struct clk *clk = NULL;
+
+	tmp = arg;
+
+	if (dvfs_dptc_params.suspended)
+		return -EPERM;
+
+	down(&access_mutex);
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "DVFS_DPTC ioctl (%d)\n", cmd);
+#endif
+
+	switch (cmd) {
+#ifdef CONFIG_MXC_DPTC
+		/* Enable the DPTC module */
+	case DPTC_IOCTENABLE:
+		ret_val = start_dptc(&dvfs_dptc_params);
+		break;
+
+		/* Disable the DPTC module */
+	case DPTC_IOCTDISABLE:
+		ret_val = stop_dptc(&dvfs_dptc_params);
+		break;
+
+	case DPTC_IOCSENABLERC:
+		ret_val = enable_ref_circuits(&dvfs_dptc_params, tmp);
+		break;
+
+	case DPTC_IOCSDISABLERC:
+		ret_val = disable_ref_circuits(&dvfs_dptc_params, tmp);
+		break;
+		/*
+		 * Return the DPTC module current state.
+		 * Returns 1 if the DPTC module is enabled, else returns 0
+		 */
+	case DPTC_IOCGSTATE:
+		ret_val = dvfs_dptc_params.dptc_is_active;
+		break;
+	case DPTC_IOCSWP:
+		if (dvfs_dptc_params.dptc_is_active == FALSE) {
+			if (arg >= 0 &&
+			    arg <
+			    dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num) {
+				set_dptc_wp(&dvfs_dptc_params, arg);
+				ret_val = 0;
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+		break;
+
+#endif				/* CONFIG_MXC_DPTC */
+
+		/* Update DPTC table */
+	case PM_IOCSTABLE:
+		ret_val = dvfs_dptc_set_table((char *)arg);
+		break;
+
+	case PM_IOCGTABLE:
+		tmp_str = vmalloc(MAX_TABLE_SIZE);
+		if (tmp_str < 0)
+			ret_val = (int)tmp_str;
+		else {
+			dvfs_dptc_dump_table(tmp_str);
+			if (copy_to_user((char *)tmp,
+						tmp_str, strlen(tmp_str))) {
+				printk(KERN_ERR
+				       "Failed copy %d characters to 0x%x\n",
+				       strlen(tmp_str), tmp);
+				ret_val = -EFAULT;
+			} else
+				ret_val = 0;
+			vfree(tmp_str);
+		}
+		break;
+
+#ifdef CONFIG_MXC_DVFS
+		/* Enable the DVFS module */
+	case DVFS_IOCTENABLE:
+		ret_val = start_dvfs(&dvfs_dptc_params);
+		break;
+
+		/* Disable the DVFS module */
+	case DVFS_IOCTDISABLE:
+		ret_val = stop_dvfs(&dvfs_dptc_params);
+		break;
+		/*
+		 * Return the DVFS module current state.
+		 * Returns 1 if the DPTC module is enabled, else returns 0
+		 */
+	case DVFS_IOCGSTATE:
+		ret_val = dvfs_dptc_params.dvfs_is_active;
+		break;
+	case DVFS_IOCSSWGP:
+		ret_val = set_sw_gp((unsigned char)arg);
+		break;
+	case DVFS_IOCSWFI:
+		ret_val = set_wfi((unsigned char)arg);
+		break;
+	case DVFS_IOCSFREQ:
+		if (dvfs_dptc_params.dvfs_is_active == FALSE ||
+		    dvfs_dptc_params.dvfs_mode == DVFS_PRED_MODE) {
+			if (arg >= 0 &&
+			    arg <
+			    dvfs_dptc_params.dvfs_dptc_tables_ptr->
+			    dvfs_state_num) {
+				ret_val = dvfs_set_state(arg);
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+		break;
+	case DVFS_IOCSMODE:
+#ifdef CONFIG_MXC_DVFS_SDMA
+		if (dvfs_dptc_params.dvfs_is_active == FALSE) {
+			if ((unsigned int)arg == DVFS_HW_MODE ||
+			    (unsigned int)arg == DVFS_PRED_MODE) {
+				dvfs_dptc_params.dvfs_mode = (unsigned int)arg;
+				ret_val = 0;
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+#else
+		/* Predictive mode is supported only in SDMA mode */
+		ret_val = -EINVAL;
+#endif
+		break;
+#endif				/* CONFIG_MXC_DVFS */
+	case PM_IOCGFREQ:
+		clk = clk_get(NULL, "cpu_clk");
+		ret_val = clk_get_rate(clk);
+		clk_put(clk);
+		break;
+
+		/* Unknown ioctl command -> return error */
+	default:
+		printk(KERN_ERR "Unknown ioctl command 0x%x\n", cmd);
+		ret_val = -ENOIOCTLCMD;
+	}
+
+	up(&access_mutex);
+
+	return ret_val;
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DPTC & DVFS Interrupt handler.
+ * This function wakes-up the dvfs_dptc_workqueue_handler
+ * function that handles the
+ * DPTC interrupt.
+ *
+ * @param   irq      The Interrupt number
+ * @param   dev_id   Driver private data
+ *
+ * @result    The function returns \b IRQ_RETVAL(1) if interrupt was handled,
+ *            returns \b IRQ_RETVAL(0) if the interrupt was not handled.
+ *            \b IRQ_RETVAL is defined in include/linux/interrupt.h.
+ */
+static irqreturn_t dvfs_dptc_irq(int irq, void *dev_id)
+{
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "CCM interrupt (0x%x)!!!\n",
+	       (unsigned int)mxc_ccm_get_reg(MXC_CCM_PMCR0));
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params.dptc_is_active == TRUE)
+		dptc_irq();
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+	if (dvfs_dptc_params.dvfs_is_active == TRUE)
+		dvfs_irq(&dvfs_dptc_params);
+#endif
+
+	return IRQ_RETVAL(1);
+}
+#else
+/*!
+ * This function is the DPTC & DVFS SDMA callback.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ */
+static void dvfs_dptc_sdma_callback(dvfs_dptc_params_s *params)
+{
+	dma_request_t sdma_request_params;
+	int i;
+
+	for (i = 0; i < DVFS_LB_SDMA_BD; i++) {
+		mxc_dma_get_config(params->sdma_channel,
+				   &sdma_request_params, i);
+
+		if (sdma_request_params.bd_error == 1)
+			printk(KERN_WARNING
+			       "Error in DVFS-DPTC buffer descriptor\n");
+
+		if (sdma_request_params.bd_done == 0) {
+			params->chars_in_buffer +=
+			    (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) /
+			    DVFS_LB_SDMA_BD;
+
+			if (params->chars_in_buffer >
+			    (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8)) {
+				params->chars_in_buffer =
+				    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8;
+				params->read_ptr = params->dvfs_log_buffer;
+			}
+
+			sdma_request_params.destAddr =
+			    (__u8 *) (params->dvfs_log_buffer_phys +
+				      i * (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE /
+					   8) / DVFS_LB_SDMA_BD);
+			sdma_request_params.count =
+			    DVFS_LB_SIZE / DVFS_LB_SDMA_BD;
+			sdma_request_params.bd_cont = 1;
+			mxc_dma_set_config(params->sdma_channel,
+					   &sdma_request_params, i);
+
+			if (params->dvfs_mode == DVFS_PRED_MODE)
+				wake_up_interruptible(&params->dvfs_pred_wait);
+		}
+	}
+
+#ifdef CONFIG_MXC_DPTC
+	if (params->prev_wp != params->dvfs_dptc_tables_ptr->curr_wp)
+		dptc_irq();
+#endif
+}
+#endif
+
+module_init(dvfs_dptc_init);
+module_exit(dvfs_dptc_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS & DPTC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pm/dvfs_dptc.h b/drivers/mxc/pm/dvfs_dptc.h
new file mode 100644
index 0000000..9c6d0b5
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_dptc.h
+ *
+ * @brief MXC dvfs & dptc header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_H__
+#define __DVFS_DPTC_H__
+
+#include <mach/pm_api.h>
+#include <mach/hardware.h>
+#include <mach/dvfs_dptc_struct.h>
+
+#ifdef CONFIG_ARCH_MX27
+#include <mach/dma.h>
+#else
+#include <mach/sdma.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX3
+#include "dvfs_dptc_table_mx31.h"
+#include "dvfs_dptc_table_mx31_27ckih.h"
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DPTC
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dvfs"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dvfs"
+#endif				/* ifndef CONFIG_MXC_DPTC */
+#ifdef CONFIG_MXC_DPTC
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dvfs_dptc"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dvfs_dptc"
+#endif				/* ifdef CONFIG_MXC_DPTC */
+#else				/* ifdef CONFIG_MXC_DVFS */
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dptc"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dptc"
+#endif				/* ifdef CONFIG_MXC_DVFS */
+
+#define MAX_TABLE_SIZE 8192
+
+#endif				/* __DPTC_H__ */
diff --git a/drivers/mxc/pm/dvfs_dptc_table_mx31.h b/drivers/mxc/pm/dvfs_dptc_table_mx31.h
new file mode 100644
index 0000000..0d7c892
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc_table_mx31.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.h
+ *
+ * @brief MX31 dvfs & dptc table file for CKIH clock 26MHz.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_TABLE_MX31_H__
+#define __DVFS_DPTC_TABLE_MX31_H__
+
+#define NUM_OF_FREQS 4
+#define NUM_OF_WP    17
+
+/*!
+ * Default DPTC table definition.
+ * The table doesn't use PLL switch, because on DDR boards
+ * PLL switch is not possible due to HW issue.
+ * For SDR boards new table can be loaded.
+ *
+ * The table keeps the same voltage of 3.5V for frequencies lower than 399MHz.
+ * Theoretically we don't need DPTC for these frequencies,
+ * but we have to keep DPTC enabled for fluent DVFS switching
+ * back to high frequency.
+ */
+static char *default_table_str = "WORKING POINT 17\n\
+\n\
+# mc13783 switcher SW values for each working point\n\
+# The first line is for WP of highest voltage\n\
+# The first column is for highest frequency\n\
+#  SW1A      SW1A DVS   SW1B DVS   SW1B STANDBY\n\
+WP 0x1d      0x12        0x12        0x12\n\
+WP 0x1c      0x12        0x12        0x12\n\
+WP 0x1b      0x12        0x12        0x12\n\
+WP 0x1a      0x12        0x12        0x12\n\
+WP 0x19      0x12        0x12        0x12\n\
+WP 0x18      0x12        0x12        0x12\n\
+WP 0x17      0x12        0x12        0x12\n\
+WP 0x16      0x12        0x12        0x12\n\
+WP 0x15      0x12        0x12        0x12\n\
+WP 0x14      0x12        0x12        0x12\n\
+WP 0x13      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+\n\
+#    pll_sw_up pll_sw_down pdr_up     pdr_down    pll_up     pll_down   vscnt\n\
+# 532MHz\n\
+FREQ 0 0 0xff871e58 0xff871e59 0x33280c 0x33280c 7\n\
+# 266MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 532MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95e3e8e4 0xffc00000 0xe5b6fda0\n\
+DCVR 0xffc00000 0x95e3e8e4 0xffc00000 0xe5b6fda0\n\
+DCVR 0xffc00000 0x95e3e8e8 0xffc00000 0xe5f70da4\n\
+DCVR 0xffc00000 0x9623f8e8 0xffc00000 0xe6371da8\n\
+DCVR 0xffc00000 0x966408f0 0xffc00000 0xe6b73db0\n\
+DCVR 0xffc00000 0x96e428f4 0xffc00000 0xe7776dbc\n\
+DCVR 0xffc00000 0x976448fc 0xffc00000 0xe8379dc8\n\
+DCVR 0xffc00000 0x97e46904 0xffc00000 0xe977ddd8\n\
+DCVR 0xffc00000 0x98a48910 0xffc00000 0xeab81de8\n\
+DCVR 0xffc00000 0x9964b918 0xffc00000 0xebf86df8\n\
+DCVR 0xffc00000 0xffe4e924 0xffc00000 0xfff8ae08\n\
+DCVR 0xffc00000 0xffe5192c 0xffc00000 0xfff8fe1c\n\
+DCVR 0xffc00000 0xffe54938 0xffc00000 0xfff95e2c\n\
+DCVR 0xffc00000 0xffe57944 0xffc00000 0xfff9ae44\n\
+DCVR 0xffc00000 0xffe5b954 0xffc00000 0xfffa0e58\n\
+DCVR 0xffc00000 0xffe5e960 0xffc00000 0xfffa6e70\n\
+\n\
+# 266MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+";
+
+#endif
diff --git a/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h b/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h
new file mode 100644
index 0000000..2254a8c
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.h
+ *
+ * @brief MX31 dvfs & dptc table file for CKIH clock 27MHz.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_TABLE_MX31_27CKIH_H__
+#define __DVFS_DPTC_TABLE_MX31_27CKIH_H__
+
+#define NUM_OF_FREQS 4
+#define NUM_OF_WP    17
+
+/*!
+ * Default DPTC table definition.
+ * The table doesn't use PLL switch, because on DDR boards
+ * PLL switch is not possible due to HW issue.
+ * For SDR boards new table can be loaded.
+ *
+ * The table keeps the same voltage of 1.35V for frequencies lower than 399MHz.
+ * Theoretically we don't need DPTC for these frequencies,
+ * but we have to keep DPTC enabled for fluent DVFS switching
+ * back to high frequency.
+ */
+static char *default_table_str_27ckih = "WORKING POINT 17\n\
+WP 0x1d 0x12 0x12 0x12\n\
+WP 0x1c 0x12 0x12 0x12\n\
+WP 0x1b 0x12 0x12 0x12\n\
+WP 0x1a 0x12 0x12 0x12\n\
+WP 0x19 0x12 0x12 0x12\n\
+WP 0x18 0x12 0x12 0x12\n\
+WP 0x17 0x12 0x12 0x12\n\
+WP 0x16 0x12 0x12 0x12\n\
+WP 0x15 0x12 0x12 0x12\n\
+WP 0x14 0x12 0x12 0x12\n\
+WP 0x13 0x12 0x12 0x12\n\
+WP 0x12 0x12 0x12 0x12\n\
+WP 0x11 0x12 0x12 0x12\n\
+WP 0x10 0x12 0x12 0x12\n\
+WP 0xf 0x12 0x12 0x12\n\
+WP 0xe 0x12 0x12 0x12\n\
+WP 0xd 0x12 0x12 0x12\n\
+\n\
+#    pll_sw_up pll_sw_down pdr_up     pdr_down    pll_up     pll_down   vscnt\n\
+# 532MHz\n\
+FREQ 0 0 0xff871e58 0xff871e59 0xe240d 0xe240d 7\n\
+# 266MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 532MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x90629890 0xffc00000 0xdd34ed20\n\
+DCVR 0xffc00000 0x90629890 0xffc00000 0xdd34ed20\n\
+DCVR 0xffc00000 0x90629894 0xffc00000 0xdd74fd24\n\
+DCVR 0xffc00000 0x90a2a894 0xffc00000 0xddb50d28\n\
+DCVR 0xffc00000 0x90e2b89c 0xffc00000 0xde352d30\n\
+DCVR 0xffc00000 0x9162d8a0 0xffc00000 0xdef55d38\n\
+DCVR 0xffc00000 0x91e2f8a8 0xffc00000 0xdfb58d44\n\
+DCVR 0xffc00000 0x926308b0 0xffc00000 0xe0b5cd54\n\
+DCVR 0xffc00000 0x92e328bc 0xffc00000 0xe1f60d64\n\
+DCVR 0xffc00000 0x93a358c0 0xffc00000 0xe3365d74\n\
+DCVR 0xffc00000 0xf66388cc 0xffc00000 0xf6768d84\n\
+DCVR 0xffc00000 0xf663b8d4 0xffc00000 0xf676dd98\n\
+DCVR 0xffc00000 0xf663e8e0 0xffc00000 0xf6773da4\n\
+DCVR 0xffc00000 0xf66418ec 0xffc00000 0xf6778dbc\n\
+DCVR 0xffc00000 0xf66458fc 0xffc00000 0xf677edd0\n\
+DCVR 0xffc00000 0xf6648908 0xffc00000 0xf6783de8\n\
+\n\
+# 266MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+";
+
+#endif
-- 
1.5.5.1

