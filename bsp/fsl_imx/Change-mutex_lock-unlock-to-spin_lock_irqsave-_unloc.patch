From c12aa0a11be050184321c4ddd7d5506061d2953d Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 29 Apr 2011 12:44:47 +0800
Subject: [PATCH 02/11] Change mutex_lock/unlock to spin_lock_irqsave/_unlock_irqrestore

The clock API clk_enable() and clk_disable() will be called in
ISR context. So replace sleepable mutex lock by spinlock in
order to avoid dirty message.

BUG: scheduling while atomic: swapper/1/0x00000103
Modules linked in:

Pid: 1, comm:              swapper
CPU: 0    Not tainted  (2.6.34.8-WR4.1.0.0_standard #115)
PC is at __clk_enable+0x1c/0x64
LR is at __clk_enable+0x24/0x64
pc : [<c003c85c>]    lr : [<c003c864>]    psr: 20000013
sp : c3c25dd8  ip : 000023a2  fp : 00000000
r10: 00000002  r9 : 00000000  r8 : c3c25e80
r7 : c3c25e80  r6 : ffff8fb8  r5 : 00000000  r4 : c05dc65c
r3 : 00000000  r2 : 00000002  r1 : 00000001  r0 : 00000000
Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 0005317f  Table: 80004000  DAC: 00000017
INFO: task swapper:1 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
swapper       D c047e05c     0     1      0 0x00000000
[<c047e05c>] (schedule+0x348/0x3e8) from [<c047eda4>] (__mutex_lock_slowpath+0xd4/0x160)
[<c047eda4>] (__mutex_lock_slowpath+0xd4/0x160) from [<c003ca44>] (clk_disable+0x1c/0x34)
[<c003ca44>] (clk_disable+0x1c/0x34) from [<c038e8c8>] (sdhci_tasklet_finish+0x134/0x14c)
[<c038e8c8>] (sdhci_tasklet_finish+0x134/0x14c) from [<c0056fe0>] (tasklet_action+0xe4/0x1b0)
[<c0056fe0>] (tasklet_action+0xe4/0x1b0) from [<c00578dc>] (__do_softirq+0xf0/0x1f4)
[<c00578dc>] (__do_softirq+0xf0/0x1f4) from [<c0057a28>] (irq_exit+0x48/0x5c)
[<c0057a28>] (irq_exit+0x48/0x5c) from [<c002d06c>] (asm_do_IRQ+0x6c/0x88)
[<c002d06c>] (asm_do_IRQ+0x6c/0x88) from [<c002da8c>] (__irq_svc+0x4c/0x8c)
Exception stack(0xc3c25d90 to 0xc3c25dd8)
5d80:                                     00000000 00000001 00000002 00000000
5da0: c05dc65c 00000000 ffff8fb8 c3c25e80 c3c25e80 00000000 00000002 00000000
5dc0: 000023a2 c3c25dd8 c003c864 c003c85c 20000013 ffffffff
[<c002da8c>] (__irq_svc+0x4c/0x8c) from [<c003c85c>] (__clk_enable+0x1c/0x64)
INFO: task kmmcd:16 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
kmmcd         D c047e05c     0    16      2 0x00000000
[<c047e05c>] (schedule+0x348/0x3e8) from [<c047e6e8>] (schedule_timeout+0x18/0x2e8)
[<c047e6e8>] (schedule_timeout+0x18/0x2e8) from [<c047e570>] (wait_for_common+0xf0/0x1b8)
[<c047e570>] (wait_for_common+0xf0/0x1b8) from [<c0384ec4>] (mmc_wait_for_req+0x114/0x120)
[<c0384ec4>] (mmc_wait_for_req+0x114/0x120) from [<c0384f34>] (mmc_wait_for_cmd+0x64/0x74)
[<c0384f34>] (mmc_wait_for_cmd+0x64/0x74) from [<c0387a14>] (mmc_app_cmd+0x70/0xa0)
[<c0387a14>] (mmc_app_cmd+0x70/0xa0) from [<c0387bec>] (mmc_wait_for_app_cmd+0x5c/0xd4)
[<c0387bec>] (mmc_wait_for_app_cmd+0x5c/0xd4) from [<c0387e50>] (mmc_send_app_op_cond+0x6c/0xd8)
[<c0387e50>] (mmc_send_app_op_cond+0x6c/0xd8) from [<c0386d84>] (mmc_sd_init_card+0x68/0x85c)
[<c0386d84>] (mmc_sd_init_card+0x68/0x85c) from [<c0387680>] (mmc_attach_sd+0x108/0x184)
[<c0387680>] (mmc_attach_sd+0x108/0x184) from [<c0384d50>] (mmc_rescan+0x2f4/0x354)
[<c0384d50>] (mmc_rescan+0x2f4/0x354) from [<c0069570>] (worker_thread+0x1e8/0x2a8)
[<c0069570>] (worker_thread+0x1e8/0x2a8) from [<c006d024>] (kthread+0x78/0x80)
[<c006d024>] (kthread+0x78/0x80) from [<c002eef4>] (kernel_thread_exit+0x0/0x8)

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-mxc/clock.c |   55 +++++++++++++++++++++++++++-----------------
 1 files changed, 34 insertions(+), 21 deletions(-)

diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
index 21a46d5..3aa9760 100644
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -43,22 +43,23 @@
 
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
-
+static DEFINE_SPINLOCK(clockfw_lock);
 /*-------------------------------------------------------------------------
  * Standard clock functions defined in include/linux/clk.h
  *-------------------------------------------------------------------------*/
 
 static void __clk_disable(struct clk *clk)
 {
-	if (clk == NULL || IS_ERR(clk))
+	if (clk == NULL || IS_ERR(clk) || !clk->usecount)
 		return;
 
-	__clk_disable(clk->parent);
-	__clk_disable(clk->secondary);
+	if (!(--clk->usecount)) {
+		__clk_disable(clk->parent);
+		__clk_disable(clk->secondary);
 
-	WARN_ON(!clk->usecount);
-	if (!(--clk->usecount) && clk->disable)
-		clk->disable(clk);
+		if (clk->disable)
+			clk->disable(clk);
+	}
 }
 
 static int __clk_enable(struct clk *clk)
@@ -66,12 +67,13 @@ static int __clk_enable(struct clk *clk)
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
-	__clk_enable(clk->parent);
-	__clk_enable(clk->secondary);
-
-	if (clk->usecount++ == 0 && clk->enable)
-		clk->enable(clk);
+	if (clk->usecount++ == 0) {
+		__clk_enable(clk->parent);
+		__clk_enable(clk->secondary);
 
+		if (clk->enable)
+			clk->enable(clk);
+	}
 	return 0;
 }
 
@@ -80,15 +82,15 @@ static int __clk_enable(struct clk *clk)
  */
 int clk_enable(struct clk *clk)
 {
+	unsigned long flags;
 	int ret = 0;
 
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
-	mutex_lock(&clocks_mutex);
+	spin_lock_irqsave(&clockfw_lock, flags);
 	ret = __clk_enable(clk);
-	mutex_unlock(&clocks_mutex);
-
+	spin_unlock_irqrestore(&clockfw_lock, flags);
 	return ret;
 }
 EXPORT_SYMBOL(clk_enable);
@@ -99,12 +101,14 @@ EXPORT_SYMBOL(clk_enable);
  */
 void clk_disable(struct clk *clk)
 {
+	unsigned long flags;
+
 	if (clk == NULL || IS_ERR(clk))
 		return;
 
-	mutex_lock(&clocks_mutex);
+	spin_lock_irqsave(&clockfw_lock, flags);
 	__clk_disable(clk);
-	mutex_unlock(&clocks_mutex);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
 }
 EXPORT_SYMBOL(clk_disable);
 
@@ -161,14 +165,15 @@ EXPORT_SYMBOL(clk_round_rate);
  */
 int clk_set_rate(struct clk *clk, unsigned long rate)
 {
+	unsigned long flags;
 	int ret = -EINVAL;
 
 	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
 		return ret;
 
-	mutex_lock(&clocks_mutex);
+	spin_lock_irqsave(&clockfw_lock, flags);
 	ret = clk->set_rate(clk, rate);
-	mutex_unlock(&clocks_mutex);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
 
 	return ret;
 }
@@ -177,17 +182,25 @@ EXPORT_SYMBOL(clk_set_rate);
 /* Set the clock's parent to another clock source */
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
+	unsigned long flags;
 	int ret = -EINVAL;
+	struct clk *prev_parent = clk->parent;
 
 	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
 	    IS_ERR(parent) || clk->set_parent == NULL)
 		return ret;
 
-	mutex_lock(&clocks_mutex);
+	if (clk->usecount != 0)
+		clk_enable(parent);
+
+	spin_lock_irqsave(&clockfw_lock, flags);
 	ret = clk->set_parent(clk, parent);
 	if (ret == 0)
 		clk->parent = parent;
-	mutex_unlock(&clocks_mutex);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	if (clk->usecount != 0)
+		clk_disable(prev_parent);
 
 	return ret;
 }
-- 
1.7.0.4

