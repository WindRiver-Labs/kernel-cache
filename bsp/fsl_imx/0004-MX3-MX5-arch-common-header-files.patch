From f389bc676e3a80d999622beb42299764d6b06f63 Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@windriver.com>
Date: Thu, 20 Nov 2008 00:56:34 -0500
Subject: [PATCH] MX3/MX5 arch common header files.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Add imx51 specific header files.
Upgrade the existing platform header files to match an upgrade of the
hardware, like register definitions and base addresses.
Add or modify some platform device struct definitions to support imx51
BSP.

[make mxc_pg_* declarations general among mxc platforms]
Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>

---
 arch/arm/plat-mxc/include/mach/arc_otg.h           |  525 +++++
 arch/arm/plat-mxc/include/mach/board-mx51_3stack.h |  127 ++
 arch/arm/plat-mxc/include/mach/clock.h             |   28 +-
 arch/arm/plat-mxc/include/mach/common.h            |   79 +-
 arch/arm/plat-mxc/include/mach/debug-macro.S       |    3 +
 arch/arm/plat-mxc/include/mach/dma-mx3.h           |   81 +
 arch/arm/plat-mxc/include/mach/dma.h               |  255 +++
 arch/arm/plat-mxc/include/mach/entry-macro.S       |   31 +
 arch/arm/plat-mxc/include/mach/gpio.h              |  185 ++
 arch/arm/plat-mxc/include/mach/hardware.h          |  122 +-
 arch/arm/plat-mxc/include/mach/io.h                |   22 +-
 arch/arm/plat-mxc/include/mach/iomux-mx3.h         |  221 ++-
 arch/arm/plat-mxc/include/mach/irqs.h              |    8 +
 arch/arm/plat-mxc/include/mach/isp1504.h           |   39 +
 arch/arm/plat-mxc/include/mach/memory.h            |   22 +
 arch/arm/plat-mxc/include/mach/mx31.h              |   16 +-
 arch/arm/plat-mxc/include/mach/mx31_pins.h         |  438 ++++
 arch/arm/plat-mxc/include/mach/mx31_usb.h          |   33 +
 arch/arm/plat-mxc/include/mach/mx51.h              |  574 +++++
 arch/arm/plat-mxc/include/mach/mx51_usb.h          |   74 +
 arch/arm/plat-mxc/include/mach/mx5_regulator.h     |   53 +
 arch/arm/plat-mxc/include/mach/mxc.h               |  489 ++++-
 arch/arm/plat-mxc/include/mach/mxc_timer.h         |    4 +-
 arch/arm/plat-mxc/include/mach/sdma.h              |  517 +++++
 arch/arm/plat-mxc/include/mach/sdma_script_code.h  |  581 +++++
 .../plat-mxc/include/mach/sdma_script_code_pass2.h |  398 ++++
 arch/arm/plat-mxc/include/mach/serial.h            |  154 ++
 arch/arm/plat-mxc/include/mach/spba.h              |   66 +
 arch/arm/plat-mxc/include/mach/system.h            |   14 +
 arch/arm/plat-mxc/include/mach/vmalloc.h           |    4 +
 include/asm-arm/plat-mxc/mc13892/core.h            |   77 +
 include/asm-arm/plat-mxc/mxc_i2c.h                 |  178 ++
 include/asm-arm/plat-mxc/mxc_ide.h                 |  208 ++
 include/asm-arm/plat-mxc/mxc_mci.h                 |  275 +++
 include/asm-arm/plat-mxc/mxc_nd.h                  |  170 ++
 include/asm-arm/plat-mxc/mxc_pcmcia.h              |  250 +++
 include/asm-arm/plat-mxc/mxc_pm.h                  |  229 ++
 include/asm-arm/plat-mxc/mxc_rtc.h                 |  101 +
 include/asm-arm/plat-mxc/mxc_spi.h                 |  276 +++
 include/asm-arm/plat-mxc/mxc_timer.h               |  160 ++
 include/asm-arm/plat-mxc/mxc_wdt.h                 |   40 +
 include/asm-arm/plat-mxc/pmic_adc.h                |  454 ++++
 include/asm-arm/plat-mxc/pmic_audio.h              | 2329 ++++++++++++++++++++
 include/asm-arm/plat-mxc/pmic_battery.h            |  405 ++++
 include/asm-arm/plat-mxc/pmic_convity.h            |  875 ++++++++
 include/asm-arm/plat-mxc/pmic_external.h           | 1114 ++++++++++
 include/asm-arm/plat-mxc/pmic_light.h              | 1082 +++++++++
 include/asm-arm/plat-mxc/pmic_power.h              | 1358 ++++++++++++
 include/asm-arm/plat-mxc/pmic_rtc.h                |  153 ++
 include/asm-arm/plat-mxc/pmic_status.h             |   92 +
 50 files changed, 14925 insertions(+), 64 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/arc_otg.h
 create mode 100644 arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
 create mode 100644 arch/arm/plat-mxc/include/mach/dma-mx3.h
 create mode 100644 arch/arm/plat-mxc/include/mach/isp1504.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mx31_pins.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mx31_usb.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mx51.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mx51_usb.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mx5_regulator.h
 create mode 100644 arch/arm/plat-mxc/include/mach/sdma.h
 create mode 100644 arch/arm/plat-mxc/include/mach/sdma_script_code.h
 create mode 100644 arch/arm/plat-mxc/include/mach/sdma_script_code_pass2.h
 create mode 100644 arch/arm/plat-mxc/include/mach/serial.h
 create mode 100644 arch/arm/plat-mxc/include/mach/spba.h
 create mode 100644 include/asm-arm/plat-mxc/mc13892/core.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_i2c.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_ide.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_mci.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_nd.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_pcmcia.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_pm.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_rtc.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_spi.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_timer.h
 create mode 100644 include/asm-arm/plat-mxc/mxc_wdt.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_adc.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_audio.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_battery.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_convity.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_external.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_light.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_power.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_rtc.h
 create mode 100644 include/asm-arm/plat-mxc/pmic_status.h

diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
new file mode 100644
index 0000000..a08cd03
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -0,0 +1,525 @@
+
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+struct arc_usb_config {
+	char *name;		/* pretty print */
+	int (*platform_init) (void);	/* platform-specific init routine */
+	void (*platform_uninit) (void);	/* platform-specific uninit routine */
+	void (*set_vbus_power) (int);	/* turn on/off Vbus power */
+	u32 xcvr_type;		/* PORTSC_PTS_* */
+	u32 usbmode;		/* address of usbmode register */
+	u32 does_otg;		/* set IFF it's an OTG port */
+	unsigned power_budget;	/* for hcd->power_budget */
+};
+
+struct arc_xcvr_config {
+	char *name;		/* pretty print */
+	int (*platform_init) (void);	/* platform-specific init routine */
+	void (*platform_uninit) (void);	/* platform-specific uninit routine */
+	void *regs;		/* register base */
+};
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#ifdef CONFIG_ARCH_MX51
+#define USB_H3REGS_BASE		(OTG_BASE_ADDR + 0x600)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x800)
+#else
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+#endif
+
+#define USBOTG_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS \
+				(USB_OTGREGS_BASE + (offset)))))
+#define USBOTG_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS \
+				(USB_OTGREGS_BASE + (offset)))))
+
+#define USBH1_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS \
+				(USB_H1REGS_BASE + (offset)))))
+#define USBH1_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS \
+				(USB_H1REGS_BASE + (offset)))))
+
+#define USBH2_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS \
+				(USB_H2REGS_BASE + (offset)))))
+#define USBH2_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS \
+				(USB_H2REGS_BASE + (offset)))))
+
+#define USBOTHER_REG(offset)	(*((volatile u32 *)(IO_ADDRESS \
+				(USB_OTHERREGS_BASE + (offset)))))
+
+/*
+ * OTG registers
+ */
+#define UOG_ID			USBOTG_REG32(0x00)
+/* Host ID */
+#define UOG_HWGENERAL		USBOTG_REG32(0x04)
+/* Host General */
+#define UOG_HWHOST		USBOTG_REG32(0x08)
+/* Host h/w params */
+#define UOG_HWTXBUF		USBOTG_REG32(0x10)
+/* TX buffer h/w params */
+#define UOG_HWRXBUF		USBOTG_REG32(0x14)
+/* RX buffer */
+
+/* h/w params */
+#define UOG_CAPLENGTH		USBOTG_REG16(0x100)
+/* Capability */
+/* register length */
+#define UOG_HCIVERSION		USBOTG_REG16(0x102)
+/* Host Interface */
+/* version */
+#define UOG_HCSPARAMS		USBOTG_REG32(0x104)
+/* Host control */
+/* structural params */
+#define UOG_HCCPARAMS		USBOTG_REG32(0x108)
+/* control capability */
+/*params */
+#define UOG_DCIVERSION		USBOTG_REG32(0x120)
+/* device interface */
+/* version */
+/* start EHCI registers: */
+#define UOG_USBCMD		USBOTG_REG32(0x140)
+/* USB command */
+/* register */
+#define UOG_USBSTS		USBOTG_REG32(0x144)
+/* USB status */
+/* register */
+#define UOG_USBINTR		USBOTG_REG32(0x148)
+/* interrupt */
+/* enable register */
+#define UOG_FRINDEX		USBOTG_REG32(0x14c)
+/* USB frame index */
+/* segment (0x150) addr bits 63:32 if needed */
+/* host crtlr frame list base addr */
+#define UOG_PERIODICLISTBASE	USBOTG_REG32(0x154)
+/* device crtlr device address */
+#define UOG_DEVICEADDR		USBOTG_REG32(0x154)
+/* host ctrlr next async addr */
+#define UOG_ASYNCLISTADDR	USBOTG_REG32(0x158)
+/* device ctrlr endpoint list addr */
+#define UOG_EPLISTADDR		USBOTG_REG32(0x158)
+/* host ctrlr embedded TT async buf status */
+#define UOG_BURSTSIZE		USBOTG_REG32(0x160)
+/* TX FIFO fill tuning */
+#define UOG_TXFILLTUNING	USBOTG_REG32(0x164)
+/* ULPI viewport */
+#define UOG_ULPIVIEW		USBOTG_REG32(0x170)
+/* configflag (supports HS) */
+#define	UOG_CFGFLAG		USBOTG_REG32(0x180)
+/* port status and control */
+#define UOG_PORTSC1		USBOTG_REG32(0x184)
+
+/* end EHCI registers: */
+/* OTG status and control */
+#define UOG_OTGSC		USBOTG_REG32(0x1a4)
+/* USB device mode */
+#define UOG_USBMODE		USBOTG_REG32(0x1a8)
+/* endpoint setup status */
+#define UOG_ENDPTSETUPSTAT	USBOTG_REG32(0x1ac)
+/* endpoint initialization */
+#define UOG_ENDPTPRIME		USBOTG_REG32(0x1b0)
+/* endpoint de-initialize */
+#define UOG_ENDPTFLUSH		USBOTG_REG32(0x1b4)
+/* endpoint status */
+#define UOG_ENDPTSTAT		USBOTG_REG32(0x1b8)
+/* endpoint complete */
+#define UOG_ENDPTCOMPLETE	USBOTG_REG32(0x1bc)
+#define UOG_EPCTRL0		USBOTG_REG32(0x1c0)	/* endpoint control0 */
+#define UOG_EPCTRL1		USBOTG_REG32(0x1c4)	/* endpoint control1 */
+#define UOG_EPCTRL2		USBOTG_REG32(0x1c8)	/* endpoint control2 */
+#define UOG_EPCTRL3		USBOTG_REG32(0x1cc)	/* endpoint control3 */
+#define UOG_EPCTRL4		USBOTG_REG32(0x1d0)	/* endpoint control4 */
+#define UOG_EPCTRL5		USBOTG_REG32(0x1d4)	/* endpoint control5 */
+#define UOG_EPCTRL6		USBOTG_REG32(0x1d8)	/* endpoint control6 */
+#define UOG_EPCTRL7		USBOTG_REG32(0x1dc)	/* endpoint control7 */
+
+/*
+ * Host 1 registers
+ */
+#define UH1_ID			USBH1_REG32(0x00)	/* Host ID */
+#define UH1_HWGENERAL		USBH1_REG32(0x04)	/* Host General */
+#define UH1_HWHOST		USBH1_REG32(0x08)	/* Host h/w params */
+/* TX buffer h/w params */
+#define UH1_HWTXBUF		USBH1_REG32(0x10)
+/* RX buffer h/w params */
+#define UH1_HWRXBUF		USBH1_REG32(0x14)
+/* Capability register length */
+#define UH1_CAPLENGTH		USBH1_REG16(0x100)
+/* Host Interface version */
+#define UH1_HCIVERSION		USBH1_REG16(0x102)
+/* Host control structural params */
+#define UH1_HCSPARAMS		USBH1_REG32(0x104)
+/* control capability params */
+#define UH1_HCCPARAMS		USBH1_REG32(0x108)
+
+/* start EHCI registers: */
+/* USB command register */
+#define UH1_USBCMD		USBH1_REG32(0x140)
+/* USB status register */
+#define UH1_USBSTS		USBH1_REG32(0x144)
+/* interrupt enable register */
+#define UH1_USBINTR		USBH1_REG32(0x148)
+/* USB frame index */
+/*segment (0x150)      addr bits 63:32 if needed */
+#define UH1_FRINDEX		USBH1_REG32(0x14c)
+/* host crtlr frame list base addr */
+#define UH1_PERIODICLISTBASE	USBH1_REG32(0x154)
+/* host ctrlr nest async addr */
+#define UH1_ASYNCLISTADDR	USBH1_REG32(0x158)
+/* host ctrlr embedded TT async buf status */
+#define UH1_BURSTSIZE		USBH1_REG32(0x160)
+/* TX FIFO fill tuning */
+/* configured_flag (0x180) configflag (supports HS) */
+#define UH1_TXFILLTUNING	USBH1_REG32(0x164)
+/* port status and control */
+#define UH1_PORTSC1		USBH1_REG32(0x184)
+/* end EHCI registers: */
+
+#define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * Host 2 registers
+ */
+#define UH2_ID	USBH2_REG32(0x00)
+/* Host ID */
+#define UH2_HWGENERAL	USBH2_REG32(0x04)
+/* Host General */
+#define UH2_HWHOST	USBH2_REG32(0x08)
+/* Host h/w params */
+#define UH2_HWTXBUF	USBH2_REG32(0x10)
+/* TX buffer h/w params */
+#define UH2_HWRXBUF	USBH2_REG32(0x14)
+/* RX buffer h/w params */
+#define UH2_CAPLENGTH	USBH2_REG16(0x100)
+/* Capability register length */
+#define UH2_HCIVERSION	USBH2_REG16(0x102)
+/* Host Interface version */
+#define UH2_HCSPARAMS	USBH2_REG32(0x104)
+/* Host control structural params */
+#define UH2_HCCPARAMS	USBH2_REG32(0x108)
+/* control capability params */
+
+/* start EHCI registers: */
+#define UH2_USBCMD	USBH2_REG32(0x140)
+/* USB command register */
+#define UH2_USBSTS	USBH2_REG32(0x144)
+/* USB status register */
+#define UH2_USBINTR	USBH2_REG32(0x148)
+/* interrupt enable register */
+#define UH2_FRINDEX	USBH2_REG32(0x14c)
+/* USB frame index */
+/* segment (0x150) addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)
+/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)
+/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)
+/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)
+/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)
+/* ULPI viewport */
+/*configured_flag (0x180) configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)
+/* port status and control */
+/* end EHCI registers */
+
+#define UH2_USBMODE		USBH2_REG32(0x1a8)
+/* USB device mode */
+
+/*
+ * other regs (not part of ARC core)
+ */
+#define USBCTRL		USBOTHER_REG(0x00)
+/* USB Control register */
+#define USB_OTG_MIRROR	USBOTHER_REG(0x04)
+/* USB OTG mirror register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG	(0x08)      /* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG	(0x0c)      /* OTG UTMI PHY Function Control register */
+#define USB_CTRL_1		USBOTHER_REG	(0x10)/* USB Cotrol Register 1*/
+#define USBCTRL_HOST2		USBOTHER_REG	(0x14)/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG	(0x18)/* USB Cotrol Register 1*/
+
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK		(3 << 30)
+/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI		(0 << 30)
+/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS	(1 << 30)
+/* Philips classic */
+#define PORTSC_PTS_ULPI		(2 << 30)
+/* ULPI */
+#define PORTSC_PTS_SERIAL	(3 << 30)
+/* serial */
+#define PORTSC_STS		(1 << 29)
+/* serial xcvr select */
+#define PORTSC_PTW		(1 << 28)
+/* UTMI width */
+#define PORTSC_PORT_POWER		(1 << 12)
+/* port power */
+#define PORTSC_LS_MASK			(3 << 10)
+/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)
+/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)
+/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)
+/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)
+/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)
+/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)
+/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)
+/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)
+/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)
+/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)
+/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)
+/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)
+/* current connect status */
+
+#define PORTSC_W1C_BITS \
+	(PORTSC_CONNECT_STATUS_CHANGE | \
+	 PORTSC_PORT_EN_DIS_CHANGE    | \
+	 PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)
+/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)
+/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)
+/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#ifdef CONFIG_ARCH_MX51
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#else
+#define  OTGSC_IE_1ms_TIMER		(1 << 19)
+#endif
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1
+/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)
+/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)
+/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)
+/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)
+/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)
+/* device */
+#define USBMODE_CM_reserved	(1 << 0)
+/* reserved */
+
+/* USBCTRL */
+#define UCTRL_OWIR		(1 << 31)
+/* OTG wakeup intr request received */
+#define UCTRL_OSIC_MASK		(3 << 29)
+/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)
+/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)
+/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)
+/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)
+/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_OUIE		(1 << 28)
+/* OTG ULPI intr enable */
+#define UCTRL_OWIE		(1 << 27)
+/* OTG wakeup intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)
+/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)
+/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)
+/* OTG power mask */
+#define UCTRL_H2WIR		(1 << 23)
+/* HOST2 wakeup intr request received */
+#define UCTRL_H2SIC_MASK	(3 << 21)
+/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)
+/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)
+/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)
+/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)
+/* single-ended/bidirectional  3 wire */
+
+#ifdef CONFIG_ARCH_MX51
+#define UCTRL_H2UIE		(1 << 8)/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)/* HOST2 power mask */
+#else
+#define UCTRL_H2UIE		(1 << 20)
+/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 19)
+/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		(1 << 18)/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 16)
+/* HOST2 power mask */
+#endif
+
+#define UCTRL_H1WIR		(1 << 15)
+/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)
+/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)
+/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)
+/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)
+/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)
+/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)/* Host1 ULPI interrupt enable */
+
+#define UCTRL_H1WIE		(1 << 11)
+/* HOST1 wakeup intr enable */
+#define UCTRL_PP		(1 << 11)       /* power polarity bit */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)
+/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO		(1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)
+/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2		(1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)
+/* HOST1 power mask */
+#define UCTRL_IP_PULIDP		(1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP		(1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN	(1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)
+/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)
+/* HOST1 TLL disabled */
+#define UCTRL_USBTE		(1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL		(1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE		(1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS		(1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)
+/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)/* OTG TLL Disable */
+#define UCTRL_OOCS		(1 <<  0)       /* OTG OverCurrent State */
+
+/* USBCMD */
+#define UCMD_RUN_STOP		(1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)
+/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	(~(0xff << 16))/* Interrupt Threshold Control */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)
+/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)
+/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)
+/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)
+/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)
+/* OTG ID pin status */
+/* 1=high: Operate as B-device */
+/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE	0x01000000
+#define USB_UTMI_PHYCTRL_OC_POL		(1 << 9)/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS		(1 << 8)/* OTG Disable Overcurrent Event */
+
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK	0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT	0
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN		(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN		(1 << 26)
+
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)
+/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)
+/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)
+/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)
+/* SyncState */
+#define ULPIVW_PORT_MASK	0x07
+/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+#define HCSPARAMS_PPC		(0x1<<4)        /* Port Power Control */
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h b/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
new file mode 100644
index 0000000..ebd9736
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__
+
+/*!
+ * @defgroup BRDCFG_MX51 Board Configuration Options
+ * @ingroup MSL_MX51
+ */
+
+/*!
+ * @file mach-mx51/board-mx51_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX51 3Stack Platform.
+ *
+ * @ingroup BRDCFG_MX51
+ */
+
+
+/*!
+ * @name MXC UART board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV	0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV	0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE		MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR		NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED		1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE		MODE_DCE
+#define UART2_IR		NO_IRDA
+#define UART2_ENABLED		1
+/* UART 3 configuration */
+#define UART3_MODE		MODE_DTE
+#define UART3_IR		NO_IRDA
+#define UART3_ENABLED		1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define DEBUG_BOARD_BASE_ADDRESS(n)	(n)
+/* LAN9217 ethernet base address */
+#define LAN9217_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n))
+/* External UART */
+#define UARTA_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x8000)
+#define UARTB_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x10000)
+
+#define BOARD_IO_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x20000)
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG	0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+/* interrupts like external uart , external ethernet etc*/
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX51_PIN_GPIO1_6)
+
+#define EXPIO_INT_ENET		(MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_XUART_A 	(MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_XUART_B 	(MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_BUTTON_A 	(MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_BUTTON_B 	(MXC_EXP_IO_BASE + 4)
+
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ	EXPIO_INT_ENET
+
+#define CONSISTENT_DMA_SIZE	(64 * SZ_1M)
+
+#define I2C_NR			2
+#define I2C1_FRQ_DIV		0x17
+#define I2C_BASE_ADDR		I2C1_BASE_ADDR
+
+#define I2C2_FRQ_DIV		0x17
+#define MXC_INT_I2C		MXC_INT_I2C1
+#endif				/* __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/clock.h b/arch/arm/plat-mxc/include/mach/clock.h
index 24caa2b..a394c11 100644
--- a/arch/arm/plat-mxc/include/mach/clock.h
+++ b/arch/arm/plat-mxc/include/mach/clock.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -23,6 +23,8 @@
 #ifndef __ASSEMBLY__
 #include <linux/list.h>
 
+#define MAX_DRV_CLK_NAME 16
+
 struct module;
 
 struct clk {
@@ -34,13 +36,26 @@ struct clk {
 	struct clk *parent;
 	/* Secondary clock to enable/disable with this clock */
 	struct clk *secondary;
+#ifdef MXC_CLK_FRAME_2
+	/* Current clock rate */
+	unsigned long rate;
+#endif
 	/* Reference count of clock enable/disable */
 	__s8 usecount;
 	/* Register bit position for clock's enable/disable control. */
 	u8 enable_shift;
 	/* Register address for clock's enable/disable control. */
+#ifdef MXC_CLK_FRAME_2
+	void __iomem *enable_reg;
+#else
 	u32 enable_reg;
+#endif
 	u32 flags;
+#ifdef MXC_CLK_FRAME_2
+	/* Function ptr to recalculate the clock's rate based on parent
+	   clock's rate */
+	void (*recalc) (struct clk *);
+#endif
 	/* get the current clock rate (always a fresh value) */
 	unsigned long (*get_rate) (struct clk *);
 	/* Function ptr to set the clock to a new rate. The rate must match a
@@ -62,6 +77,17 @@ struct clk {
 
 int clk_register(struct clk *clk);
 void clk_unregister(struct clk *clk);
+int clk_get_usecount(struct clk *clk);
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+		unsigned int data);
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
+int clk_set_pll_dither(struct clk *clk, unsigned int pll_ppm);
+
+/* Clock flags */
+#define RATE_PROPAGATES		(1 << 0)        /* Program children too */
+#define ALWAYS_ENABLED		(1 << 1)        /* Clock cannot be disabled */
+#define RATE_FIXED		(1 << 2)        /* Fixed clock rate */
+#define CPU_FREQ_TRIG_UPDATE	(1 << 3)        /* CPUFREQ trig update */
 
 #endif /* __ASSEMBLY__ */
 #endif /* __ASM_ARCH_MXC_CLOCK_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index a6d2e24..cd7de16 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -1,5 +1,6 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
  */
 
 /*
@@ -11,10 +12,86 @@
 #ifndef __ASM_ARCH_MXC_COMMON_H__
 #define __ASM_ARCH_MXC_COMMON_H__
 
+#ifndef __ASSEMBLY__
+/*
+ * Create inline functions to test for cpu revision
+ * Function name is cpu_is_<cpu name>_rev(rev)
+ *
+ * Returns:
+ * 0 - not the cpu queried
+ * 1 - cpu and revision match
+ * 2 - cpu matches, but cpu revision is greater than queried rev
+ *-1 - cpu matches, but cpu revision is less than queried rev
+ */
+MXC_REV(cpu_is_mx25);
+MXC_REV(cpu_is_mx32);
+MXC_REV(cpu_is_mx35);
+MXC_REV(cpu_is_mx37);
+MXC_REV(cpu_is_mx51);
+#endif
+
 extern void mxc_map_io(void);
 extern void mxc_init_irq(void);
 extern void mxc_timer_init(const char *clk_timer);
+#ifdef CONFIG_ARCH_MX51
+extern int __init mxc_clocks_init(unsigned long ckil, unsigned long osc,
+				  unsigned long ckih1, unsigned long ckih2);
+extern int mxc_init_devices(void);
+#else
 extern int mxc_clocks_init(unsigned long fref);
+#endif
 extern int mxc_register_gpios(void);
+extern void mxc_cpu_init(void);
+extern void mxc_cpu_common_init(void);
+
+#if defined(CONFIG_RTC_DRV_MXC) || \
+	defined(CONFIG_RTC_DRV_MXC_MODULE)
+int mxc_init_rtc(void);
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || \
+	defined(CONFIG_MXC_WATCHDOG_MODULE)
+extern int mxc_init_wdt(void);
+#endif
+
+#if defined(CONFIG_MMC_MXC) || \
+	defined(CONFIG_MMC_MXC_MODULE)
+extern int mxc_init_mmc(void);
+#endif
+
+#if defined(CONFIG_SPI_MXC) || \
+	defined(CONFIG_SPI_MXC_MODULE)
+extern int mxc_init_spi(void);
+#endif
+
+#if defined(CONFIG_PCMCIA_MX3) || \
+	defined(CONFIG_PCMCIA_MX3_MODULE)
+extern int mxc_init_pcmcia(void);
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_MXC) || \
+	defined(CONFIG_BLK_DEV_IDE_MXC_MODULE)
+extern int mxc_init_ide(void);
+#endif
+
+#if defined(CONFIG_SND_MXC_PMIC) || \
+	defined(CONFIG_SND_MXC_PMIC_MODULE)
+extern void mxc_init_audio(void);
+#endif
+
+#if defined(CONFIG_MXC_SSI) || \
+	defined(CONFIG_MXC_SSI_MODULE)
+extern void mxc_init_ssi(void);
+#endif
+
+#if defined(CONFIG_MXC_IPU) || \
+	    defined(CONFIG_MXC_IPU_MODULE)
+extern void mxc_init_ipu(void);
+#endif
+
+#if defined(CONFIG_MXC_HMP4E) || \
+	    defined(CONFIG_MXC_HMP4E_MODULE)
+extern void mxc_init_hmp4e(void);
+#endif
 
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/debug-macro.S b/arch/arm/plat-mxc/include/mach/debug-macro.S
index b9907be..43f0bbb 100644
--- a/arch/arm/plat-mxc/include/mach/debug-macro.S
+++ b/arch/arm/plat-mxc/include/mach/debug-macro.S
@@ -28,6 +28,9 @@
 #ifdef CONFIG_MACH_PCM038
 #include <mach/board-pcm038.h>
 #endif
+#ifdef CONFIG_MACH_MX51_3DS
+#include <mach/board-mx51_3stack.h>
+#endif
 		.macro	addruart,rx
 		mrc	p15, 0, \rx, c1, c0
 		tst	\rx, #1			@ MMU enabled?
diff --git a/arch/arm/plat-mxc/include/mach/dma-mx3.h b/arch/arm/plat-mxc/include/mach/dma-mx3.h
new file mode 100644
index 0000000..dd3ca13
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dma-mx3.h
@@ -0,0 +1,81 @@
+#ifndef __ASM_ARCH_MXC_DMA_MX3_H__
+#define __ASM_ARCH_MXC_DMA_MX3_H__
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+
+/*!
+ * This option is used to set or clear
+ * the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_GPIO1_0    31
+#define DMA_REQ_NFC        30
+#define DMA_REQ_SSI1_TX1   29
+#define DMA_REQ_SSI1_RX1   28
+#define DMA_REQ_SSI1_TX2   27
+#define DMA_REQ_SSI1_RX2   26
+#define DMA_REQ_SSI2_TX1   25
+#define DMA_REQ_SSI2_RX1   24
+#define DMA_REQ_SSI2_TX2   23
+#define DMA_REQ_SSI2_RX2   22
+#define DMA_REQ_SDHC2      21
+#define DMA_REQ_SDHC1      20
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_FIRI_TX    17
+#define DMA_REQ_FIRI_RX    16
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_GPIO1_1    15
+#define DMA_REQ_GPIO1_2    14
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_UART5_TX   11
+#define DMA_REQ_UART5_RX   10
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_UART3_TX   9
+#define DMA_REQ_UART3_RX   8
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_SIM        5
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_CCM        1
+#define DMA_REQ_reserved   0
+
+#endif
+
diff --git a/arch/arm/plat-mxc/include/mach/dma.h b/arch/arm/plat-mxc/include/mach/dma.h
index c822d56..9a35f04 100644
--- a/arch/arm/plat-mxc/include/mach/dma.h
+++ b/arch/arm/plat-mxc/include/mach/dma.h
@@ -11,4 +11,259 @@
 #ifndef __ASM_ARCH_MXC_DMA_H__
 #define __ASM_ARCH_MXC_DMA_H__
 
+#ifdef CONFIG_ARCH_MX3
+#include <mach/dma-mx3.h>
+#endif
+
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE          0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum __mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+#ifdef CONFIG_ARCH_MX51
+	MXC_DMA_CSPI3_RX,
+	MXC_DMA_CSPI3_TX,
+#endif
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+#ifdef CONFIG_ARCH_MX51
+	MXC_DMA_CSI_RX,
+	MXC_DMA_SPDIF_16BIT_TX,
+	MXC_DMA_SPDIF_16BIT_RX,
+	MXC_DMA_SPDIF_32BIT_TX,
+	MXC_DMA_SPDIF_32BIT_RX,
+	MXC_DMA_ASRC_A_RX,
+	MXC_DMA_ASRC_A_TX,
+	MXC_DMA_ASRC_B_RX,
+	MXC_DMA_ASRC_B_TX,
+	MXC_DMA_ASRC_C_RX,
+	MXC_DMA_ASRC_C_TX,
+	MXC_DMA_ESAI_16BIT_RX,
+	MXC_DMA_ESAI_16BIT_TX,
+	MXC_DMA_ESAI_24BIT_RX,
+	MXC_DMA_ESAI_24BIT_TX,
+#endif
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+		unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum __mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct __mxc_dma_channel {
+	unsigned int active:1;  /*!< When there has */
+		/*  a active tranfer, */
+		/*  it is set to 1 */
+	unsigned int lock;  /*!< Defines the channel
+							is allocated or not */
+	int curr_buf;       /*!< Current buffer */
+	mxc_dma_mode_t mode;    /*!< Read or Write */
+	unsigned int channel;   /*!< Channel info */
+	unsigned int dynamic:1; /*!< Channel not */
+	/* statically allocated when 1 */
+	char *dev_name;     /*!< Device name */
+	void *private;      /*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;   /*!< The callback function */
+	void *cb_args;      /*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct __mxc_dma_requestbuf {
+	dma_addr_t src_addr;    /*!< source address */
+	dma_addr_t dst_addr;    /*!< destination address */
+	int num_of_bytes;   /*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+#include <mach/sdma.h>
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return returns a negative number on error if request for a DMA channel did not
+ *         succeed, returns the channel number to be used on success.
+ */
+extern int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t *dma_buf,
+		int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+		int num_buf, int num_of_bytes,
+		mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+		void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/entry-macro.S b/arch/arm/plat-mxc/include/mach/entry-macro.S
index b542433..105cfc2 100644
--- a/arch/arm/plat-mxc/include/mach/entry-macro.S
+++ b/arch/arm/plat-mxc/include/mach/entry-macro.S
@@ -23,7 +23,37 @@
 	@ and returns its number in irqnr
 	@ and returns if an interrupt occured in irqstat
 	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#ifdef CONFIG_MXC_TZIC
+	ldr	\base, =TZIC_IO_ADDRESS(TZIC_BASE_ADDR)
+#else
 	ldr	\base, =AVIC_IO_ADDRESS(AVIC_BASE_ADDR)
+#endif
+#ifdef CONFIG_MXC_TZIC
+	@ Load offset & priority of the highest priority
+	@ interrupt pending.
+        @ 0xD80 is HIPND0 register
+        ldr     \irqnr, =0
+        ldr     \irqstat, =0x0D80
+1000:
+        ldr     \tmp,   [\irqstat, \base]
+        cmp     \tmp, #0
+        bne     1001f
+        addeq   \irqnr, \irqnr, #32
+        addeq   \irqstat, \irqstat, #4
+        cmp     \irqnr, #128
+        blo     1000b
+        b       2001f
+1001:   ldr     \irqstat, =1
+1002:   tst     \tmp, \irqstat
+        bne     2002f
+        movs    \tmp, \tmp, lsr #1
+        addne   \irqnr, \irqnr, #1
+        bne     1002b
+2001:
+        ldr  \irqnr, =0
+2002:
+        movs \irqnr, \irqnr
+#else
 	@ Load offset & priority of the highest priority
 	@ interrupt pending from AVIC_NIVECSR
 	ldr	\irqstat, [\base, #0x40]
@@ -32,6 +62,7 @@
 	mov	\irqnr, \irqstat, asr #16
 	@ set zero flag if IRQ + 1 == 0
 	adds	\tmp, \irqnr, #1
+#endif
 	.endm
 
 	@ irq priority table (not used)
diff --git a/arch/arm/plat-mxc/include/mach/gpio.h b/arch/arm/plat-mxc/include/mach/gpio.h
index 65eedc0..6c13592 100644
--- a/arch/arm/plat-mxc/include/mach/gpio.h
+++ b/arch/arm/plat-mxc/include/mach/gpio.h
@@ -20,8 +20,10 @@
 #define __ASM_ARCH_MXC_GPIO_H__
 
 #include <mach/hardware.h>
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 #include <asm-generic/gpio.h>
 
+
 /* use gpiolib dispatchers */
 #define gpio_get_value		__gpio_get_value
 #define gpio_set_value		__gpio_set_value
@@ -32,11 +34,194 @@
 
 struct mxc_gpio_port {
 	void __iomem *base;
+#ifdef MXC_GPIO_SPLIT_IRQ_2
+	u16 irq_0_15;
+	u16 irq_16_31;
+#endif
 	int irq;
 	int virtual_irq_start;
 	struct gpio_chip chip;
 };
 
+typedef unsigned int iomux_pin_name_t;
+
 int mxc_gpio_init(struct mxc_gpio_port*, int);
+void mxc_set_gpio_dataout(iomux_pin_name_t pin, u32 data);
+void mxc_set_gpio_direction(iomux_pin_name_t pin, int is_input);
+int mxc_get_gpio_datain(iomux_pin_name_t pin);
+#else
+#include <linux/interrupt.h>
+#include <asm/sizes.h>
+
+struct mxc_gpio_port {
+	u32 num;                /*!< gpio port number */
+	u32 base;               /*!< gpio port base VA */
+	int irq;
+	int virtual_irq_start;
+};
+
+/*!
+ * There are two queues for registered GPIO ISRs. One is for high priority and
+ * the other is for low priority. The ISRs in the high priority queue will be
+ * called first before the low priority queue if more than one GPIO interrupt
+ * occurs at the same time.
+ */
+enum gpio_prio {
+	GPIO_HIGH_PRIO = 0, /*!< high priority queue */
+	GPIO_LOW_PRIO       /*!< low priority queue */
+};
+
+/*!
+ * This enumeration data type defines various different ways for interrupting
+ * the ARM core from GPIO signals. The way to interrupt the core is dictated
+ * by the external hardware.
+ */
+typedef enum gpio_int_cfg {
+	GPIO_INT_LOW_LEV = 0x0, /*!< low level sensitive */
+	GPIO_INT_HIGH_LEV = 0x1,    /*!< high level sensitive */
+	GPIO_INT_RISE_EDGE = 0x2,   /*!< rising edge sensitive */
+	GPIO_INT_FALL_EDGE = 0x3,   /*!< falling edge sensitive */
+	GPIO_INT_NONE = 0x4 /*!< No interrupt */
+} gpio_edge_t;
+
+typedef irqreturn_t(*gpio_irq_handler) (int, void *);
+
+/*!
+ * This function configures the GPIO signal to be either input or output. For
+ * input signals used for generating interrupts for the ARM core, how the
+ * interrupts being triggered is also passed in via \a icr. For output signals,
+ * the \a icr value doesn't matter.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  out          #true for output, #false for input
+ * @param  icr          value defined in \b #gpio_int_cfg
+ */
+void gpio_config(__u32 port, __u32 sig_no, bool out, enum gpio_int_cfg icr);
+
+/*!
+ * This function sets a GPIO signal value.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  data         value to be set (only 0 or 1 is valid)
+ */
+void gpio_set_data(__u32 port, __u32 sig_no, __u32 data);
+
+/*!
+ * This function returns the value of the GPIO signal.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ *
+ * @return Value of the GPIO signal
+ */
+__u32 gpio_get_data(__u32 port, __u32 sig_no);
+
+/*!
+ * This function is responsible for registering a GPIO signal's ISR.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ * @param  handler      GPIO ISR function pointer for the GPIO signal
+ * @param  irq_flags    irq flags (not used)
+ * @param  devname      device name associated with the interrupt
+ * @param  dev_id       some unique information for the ISR
+ *
+ * @return 0 if successful; non-zero otherwise.
+ */
+int gpio_request_irq(__u32 port, __u32 sig_no, enum gpio_prio prio,
+		gpio_irq_handler handler, __u32 irq_flags,
+		const char *devname, void *dev_id);
+
+/*!
+ * This function un-registers an ISR with the GPIO interrupt module.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ */
+void gpio_free_irq(__u32 port, __u32 sig_no, enum gpio_prio prio);
+
+/*!
+ * Request ownership for a GPIO pin. The caller has to check the return value
+ * of this function to make sure it returns 0 before make use of that pin.
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @return      0 if successful; Non-zero otherwise
+ */
+int mxc_request_gpio(iomux_pin_name_t pin);
+
+/*!
+ * Exported function to set a GPIO pin's direction
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @param is_input  1 (or non-zero) for input; 0 for output
+ */
+void mxc_set_gpio_direction(iomux_pin_name_t pin, int is_input);
+
+/*!
+ * Exported function to set a GPIO pin's data output
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @param data      value to be set (only 0 or 1 is valid)
+ */
+void mxc_set_gpio_dataout(iomux_pin_name_t pin, u32 data);
+
+/*!
+ * Return the data value of a GPIO signal.
+ * @param pin   a name defined by \b iomux_pin_name_t
+ *
+ * @return  value (0 or 1) of the GPIO signal; -1 if pass in invalid pin
+ */
+int mxc_get_gpio_datain(iomux_pin_name_t pin);
+
+/*!
+ * Release ownership for a GPIO pin
+ * @param pin       a name defined by \b iomux_pin_name_t
+ */
+void mxc_free_gpio(iomux_pin_name_t pin);
+
+int mxc_gpio_init(void);
+
+#endif /*ARCH_REQUIRE_GPIOLIB*/
+
+extern void mx31ads_gpio_init(void);
+extern void mx31lite_gpio_init(void);
+extern void gpio_nic_active(void);
+extern void gpio_nic_inactive(void);
+extern void gpio_uart_active(int port, int no_irda);
+extern void gpio_uart_inactive(int port, int no_irda);
+extern void config_uartdma_event(int port);
+extern void gpio_keypad_active(void);
+extern void gpio_keypad_inactive(void);
+extern void gpio_spi_active(int cspi_mod);
+extern void gpio_owire_active(void);
+extern void gpio_owire_inactive(void);
+extern void gpio_spi_inactive(int cspi_mod);
+extern void gpio_i2c_active(int i2c_num);
+extern void gpio_i2c_inactive(int i2c_num);
+extern void gpio_pmic_active(void);
+extern void gpio_activate_audio_ports(void);
+extern void gpio_sdhc_active(int module);
+extern void gpio_sdhc_inactive(int module);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+extern void gpio_lcd_active(void);
+extern void gpio_lcd_inactive(void);
+extern void slcd_gpio_config(void);
+extern void gpio_sensor_active(void);
+extern void gpio_sensor_reset(bool flag);
+extern void gpio_sensor_inactive(void);
+extern void gpio_ata_active(void);
+extern void gpio_ata_inactive(void);
+extern int gpio_usbh1_active(void);
+extern void gpio_usbh1_inactive(void);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern int gpio_usbotg_fs_active(void);
+extern void gpio_usbotg_fs_inactive(void);
+extern void gpio_pcmcia_active(void);
+extern void gpio_pcmcia_inactive(void);
 
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/hardware.h b/arch/arm/plat-mxc/include/mach/hardware.h
index 3caadee..aca5943 100644
--- a/arch/arm/plat-mxc/include/mach/hardware.h
+++ b/arch/arm/plat-mxc/include/mach/hardware.h
@@ -1,6 +1,7 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ * Copyright 2008-2009 WindRiver System, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,8 +23,60 @@
 
 #include <asm/sizes.h>
 
+/*!
+ *  * This macro is used to get certain bit field from a number
+ *   */
+#define MXC_GET_FIELD(val, len, sh) \
+			((val >> sh) & ((1 << len) - 1))
+
+/*!
+ *  * This macro is used to set certain bit field inside a number
+ *   */
+#define MXC_SET_FIELD(val, len, sh, nval) \
+			((val & ~(((1 << len) - 1) << sh)) | nval << sh)
+
+#ifndef __ASSEMBLY__
+extern unsigned int system_rev;
+#endif
+
+#define mxc_set_system_rev(part, rev) {	\
+	system_rev = (part << 12) | rev;	\
+}
+
+#define mxc_cpu()		(system_rev >> 12)
+#define mxc_is_cpu(part)	((mxc_cpu() == part) ? 1 : 0)
+#define mxc_cpu_rev()		(system_rev & 0xFF)
+#define mxc_cpu_rev_major()	((system_rev >> 4) & 0xF)
+#define mxc_cpu_rev_minor()	(system_rev & 0xF)
+#define mxc_cpu_is_rev(rev)	\
+	((mxc_cpu_rev() == rev) ? 1 : ((mxc_cpu_rev() < rev) ? -1 : 2))
+#define MXC_REV(type)	\
+static inline int type## _rev (int rev)	\
+{	\
+return (type() ? mxc_cpu_is_rev(rev) : 0);	\
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ * Board specific defines
+ * ---------------------------------------------------------------------------
+ */
+
 #ifdef CONFIG_ARCH_MX3
 # include <mach/mx31.h>
+#ifdef CONFIG_MACH_MX31ADS
+# include <mach/board-mx31ads.h>
+#endif
+#ifdef CONFIG_MACH_MX31LITE
+# include <mach/board-mx31lite.h>
+# include <mach/mx31_pins.h>
+#endif
+#ifdef CONFIG_MACH_MX31_3DS
+# include <mach/board-mx31pdk.h>
+#endif
+#define cpu_is_mx32()	(mxc_is_cpu(0x32))/*system_rev got from Redboot */
+#else
+#define cpu_is_mx32()	(0)
 #endif
 
 #ifdef CONFIG_ARCH_MX2
@@ -32,6 +85,73 @@
 # endif
 #endif
 
+#ifdef CONFIG_ARCH_MX35
+# include <mach/mx35.h>
+#define cpu_is_mx35()   (1)
+#define board_is_mx35(rev)   ((system_rev & rev) ? 1 : 0)
+#else
+#define cpu_is_mx35()   (0)
+#define board_is_mx35(rev) (0)
+#endif
+
+#ifdef CONFIG_ARCH_MX37
+# include <mach/mx37.h>
+#define cpu_is_mx37()   (1)
+#define board_is_mx37(rev)   ((system_rev & rev) ? 1 : 0)
+#else
+#define cpu_is_mx37()   (0)
+#define board_is_mx37(rev)   (0)
+#endif
+
+#ifdef CONFIG_ARCH_MX51
+# include <mach/mx51.h>
+#define cpu_is_mx51()   (1)
+#ifdef CONFIG_MACH_MX51_3DS
+#  include <mach/board-mx51_3stack.h>
+#endif
+#else
+#define cpu_is_mx51()   (0)
+#endif
+
+#ifdef CONFIG_ARCH_MX25
+# include <mach/mx25.h>
+#define cpu_is_mx25()(1)
+#else
+#define cpu_is_mx25()(0)
+#endif
+
 #include <mach/mxc.h>
 
+#define MXC_VIRTUAL_INTS_BASE	(MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES)
+#define MXC_SDIO1_CARD_IRQ	MXC_VIRTUAL_INTS_BASE
+#define MXC_SDIO2_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 1)
+#define MXC_SDIO3_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 2)
+
+/* This is used to turn on/off debugging */
+#undef MXC_TRACE
+#ifdef MXC_TRACE
+/*!
+ * This is used for error checking in debugging mode.
+ */
+#define MXC_ERR_CHK(a) \
+	do { \
+		if ((a)) { \
+			printk(KERN_ERR, "Error at line %d in "\
+					"function %s in file %s", \
+					__LINE__, __func__, __FILE__); \
+			BUG(); \
+		} \
+	} \
+while (0)
+#else
+#define MXC_ERR_CHK(a)
+#endif
+
+#define MXC_EXP_IO_BASE         (MXC_GPIO_BASE + MXC_MAX_GPIO_LINES)
+
+#define MXC_MAX_INTS            (MXC_MAX_INT_LINES + \
+		MXC_MAX_GPIO_LINES + \
+		MXC_MAX_EXP_IO_LINES + \
+		MXC_MAX_VIRTUAL_INTS)
+
 #endif /* __ASM_ARCH_MXC_HARDWARE_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/io.h b/arch/arm/plat-mxc/include/mach/io.h
index 65b6810..e1d39eb 100644
--- a/arch/arm/plat-mxc/include/mach/io.h
+++ b/arch/arm/plat-mxc/include/mach/io.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -14,6 +14,26 @@
 /* Allow IO space to be anywhere in the memory */
 #define IO_SPACE_LIMIT 0xffffffff
 
+#ifdef CONFIG_ARCH_MX3
+#define __arch_ioremap __mx3_ioremap
+#define __arch_iounmap __iounmap
+
+static inline void __iomem *
+__mx3_ioremap(unsigned long phys_addr, size_t size, unsigned int mtype)
+{
+	if (mtype == MT_DEVICE) {
+	/* Access all peripherals below 0x80000000 as nonshared device
+	* but leave l2cc alone.
+	*/
+		if ((phys_addr < 0x80000000) && ((phys_addr < L2CC_BASE_ADDR) ||
+			(phys_addr >= L2CC_BASE_ADDR + L2CC_SIZE)))
+			mtype = MT_DEVICE_NONSHARED;
+	}
+
+	return __arm_ioremap(phys_addr, size, mtype);
+}
+#endif
+
 /* io address mapping macro */
 #define __io(a)			((void __iomem *)(a))
 
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx3.h b/arch/arm/plat-mxc/include/mach/iomux-mx3.h
index 7509e76..5238be7 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx3.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx3.h
@@ -1,6 +1,7 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ * Copyright 2008-2009 WindRiver System, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,6 +23,7 @@
 
 #include <linux/types.h>
 
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 /*
  * various IOMUX output functions
  */
@@ -40,90 +42,193 @@
 #define	IOMUX_ICONFIG_ALT1  4		/* used as alternate function 1 */
 #define	IOMUX_ICONFIG_ALT2  8		/* used as alternate function 2 */
 
+#define IOMUX_CONFIG_NORMAL (IOMUX_OCONFIG_GPIO | IOMUX_ICONFIG_NONE)
 #define IOMUX_CONFIG_GPIO (IOMUX_OCONFIG_GPIO | IOMUX_ICONFIG_GPIO)
 #define IOMUX_CONFIG_FUNC (IOMUX_OCONFIG_FUNC | IOMUX_ICONFIG_FUNC)
 #define IOMUX_CONFIG_ALT1 (IOMUX_OCONFIG_ALT1 | IOMUX_ICONFIG_ALT1)
 #define IOMUX_CONFIG_ALT2 (IOMUX_OCONFIG_ALT2 | IOMUX_ICONFIG_ALT2)
 
+#else
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_output_config {
+	OUTPUTCONFIG_GPIO = 0,  /*!< used as GPIO */
+	OUTPUTCONFIG_FUNC,  /*!< used as function */
+	OUTPUTCONFIG_ALT1,  /*!< used as alternate function 1 */
+	OUTPUTCONFIG_ALT2,  /*!< used as alternate function 2 */
+	OUTPUTCONFIG_ALT3,  /*!< used as alternate function 3 */
+	OUTPUTCONFIG_ALT4,  /*!< used as alternate function 4 */
+	OUTPUTCONFIG_ALT5,  /*!< used as alternate function 5 */
+	OUTPUTCONFIG_ALT6   /*!< used as alternate function 6 */
+} iomux_pin_ocfg_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUTCONFIG_NONE = 0,   /*!< not configured for input */
+	INPUTCONFIG_GPIO = 1 << 0,  /*!< used as GPIO */
+	INPUTCONFIG_FUNC = 1 << 1,  /*!< used as function */
+	INPUTCONFIG_ALT1 = 1 << 2,  /*!< used as alternate function 1 */
+	INPUTCONFIG_ALT2 = 1 << 3   /*!< used as alternate function 2 */
+} iomux_pin_icfg_t;
+
+#endif /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
+
 /*
  * various IOMUX pad functions
  */
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 enum iomux_pad_config {
-	PAD_CTL_NOLOOPBACK	= 0x0 << 9,
-	PAD_CTL_LOOPBACK	= 0x1 << 9,
-	PAD_CTL_PKE_NONE	= 0x0 << 8,
-	PAD_CTL_PKE_ENABLE	= 0x1 << 8,
-	PAD_CTL_PUE_KEEPER	= 0x0 << 7,
-	PAD_CTL_PUE_PUD		= 0x1 << 7,
-	PAD_CTL_100K_PD		= 0x0 << 5,
-	PAD_CTL_100K_PU		= 0x1 << 5,
-	PAD_CTL_47K_PU		= 0x2 << 5,
-	PAD_CTL_22K_PU		= 0x3 << 5,
-	PAD_CTL_HYS_CMOS	= 0x0 << 4,
-	PAD_CTL_HYS_SCHMITZ	= 0x1 << 4,
-	PAD_CTL_ODE_CMOS	= 0x0 << 3,
-	PAD_CTL_ODE_OpenDrain	= 0x1 << 3,
-	PAD_CTL_DRV_NORMAL	= 0x0 << 1,
-	PAD_CTL_DRV_HIGH	= 0x1 << 1,
-	PAD_CTL_DRV_MAX		= 0x2 << 1,
-	PAD_CTL_SRE_SLOW	= 0x0 << 0,
-	PAD_CTL_SRE_FAST	= 0x1 << 0
-};
+#else
+	typedef enum __iomux_pad_config {
+#endif
+		PAD_CTL_NOLOOPBACK	= 0x0 << 9,
+		PAD_CTL_LOOPBACK	= 0x1 << 9,
+		PAD_CTL_PKE_NONE	= 0x0 << 8,
+		PAD_CTL_PKE_ENABLE	= 0x1 << 8,
+		PAD_CTL_PUE_KEEPER	= 0x0 << 7,
+		PAD_CTL_PUE_PUD		= 0x1 << 7,
+		PAD_CTL_100K_PD		= 0x0 << 5,
+		PAD_CTL_100K_PU		= 0x1 << 5,
+		PAD_CTL_47K_PU		= 0x2 << 5,
+		PAD_CTL_22K_PU		= 0x3 << 5,
+		PAD_CTL_HYS_CMOS	= 0x0 << 4,
+		PAD_CTL_HYS_SCHMITZ	= 0x1 << 4,
+		PAD_CTL_ODE_CMOS	= 0x0 << 3,
+		PAD_CTL_ODE_OpenDrain	= 0x1 << 3,
+		PAD_CTL_DRV_NORMAL	= 0x0 << 1,
+		PAD_CTL_DRV_HIGH	= 0x1 << 1,
+		PAD_CTL_DRV_MAX		= 0x2 << 1,
+		PAD_CTL_SRE_SLOW	= 0x0 << 0,
+		PAD_CTL_SRE_FAST	= 0x1 << 0
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
+	};
+#else
+} iomux_pad_config_t;
+#endif
 
 /*
  * various IOMUX general purpose functions
  */
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 enum iomux_gp_func {
-	MUX_PGP_FIRI			= 1 << 0,
-	MUX_DDR_MODE			= 1 << 1,
-	MUX_PGP_CSPI_BB			= 1 << 2,
-	MUX_PGP_ATA_1			= 1 << 3,
-	MUX_PGP_ATA_2			= 1 << 4,
-	MUX_PGP_ATA_3			= 1 << 5,
-	MUX_PGP_ATA_4			= 1 << 6,
-	MUX_PGP_ATA_5			= 1 << 7,
-	MUX_PGP_ATA_6			= 1 << 8,
-	MUX_PGP_ATA_7			= 1 << 9,
-	MUX_PGP_ATA_8			= 1 << 10,
-	MUX_PGP_UH2			= 1 << 11,
-	MUX_SDCTL_CSD0_SEL		= 1 << 12,
-	MUX_SDCTL_CSD1_SEL		= 1 << 13,
-	MUX_CSPI1_UART3			= 1 << 14,
-	MUX_EXTDMAREQ2_MBX_SEL		= 1 << 15,
-	MUX_TAMPER_DETECT_EN		= 1 << 16,
-	MUX_PGP_USB_4WIRE		= 1 << 17,
-	MUX_PGB_USB_COMMON		= 1 << 18,
-	MUX_SDHC_MEMSTICK1		= 1 << 19,
-	MUX_SDHC_MEMSTICK2		= 1 << 20,
-	MUX_PGP_SPLL_BYP		= 1 << 21,
-	MUX_PGP_UPLL_BYP		= 1 << 22,
-	MUX_PGP_MSHC1_CLK_SEL		= 1 << 23,
-	MUX_PGP_MSHC2_CLK_SEL		= 1 << 24,
-	MUX_CSPI3_UART5_SEL		= 1 << 25,
-	MUX_PGP_ATA_9			= 1 << 26,
-	MUX_PGP_USB_SUSPEND		= 1 << 27,
-	MUX_PGP_USB_OTG_LOOPBACK	= 1 << 28,
-	MUX_PGP_USB_HS1_LOOPBACK	= 1 << 29,
-	MUX_PGP_USB_HS2_LOOPBACK	= 1 << 30,
-	MUX_CLKO_DDR_MODE		= 1 << 31,
-};
+#else
+	typedef enum __iomux_gp_func {
+#endif
+		MUX_PGP_FIRI			= 1 << 0,
+		MUX_DDR_MODE			= 1 << 1,
+		MUX_PGP_CSPI_BB			= 1 << 2,
+		MUX_PGP_ATA_1			= 1 << 3,
+		MUX_PGP_ATA_2			= 1 << 4,
+		MUX_PGP_ATA_3			= 1 << 5,
+		MUX_PGP_ATA_4			= 1 << 6,
+		MUX_PGP_ATA_5			= 1 << 7,
+		MUX_PGP_ATA_6			= 1 << 8,
+		MUX_PGP_ATA_7			= 1 << 9,
+		MUX_PGP_ATA_8			= 1 << 10,
+		MUX_PGP_UH2			= 1 << 11,
+		MUX_SDCTL_CSD0_SEL		= 1 << 12,
+		MUX_SDCTL_CSD1_SEL		= 1 << 13,
+		MUX_CSPI1_UART3			= 1 << 14,
+		MUX_EXTDMAREQ2_MBX_SEL		= 1 << 15,
+		MUX_TAMPER_DETECT_EN		= 1 << 16,
+		MUX_PGP_USB_4WIRE		= 1 << 17,
+		MUX_PGB_USB_COMMON		= 1 << 18,
+		MUX_SDHC_MEMSTICK1		= 1 << 19,
+		MUX_SDHC_MEMSTICK2		= 1 << 20,
+		MUX_PGP_SPLL_BYP		= 1 << 21,
+		MUX_PGP_UPLL_BYP		= 1 << 22,
+		MUX_PGP_MSHC1_CLK_SEL		= 1 << 23,
+		MUX_PGP_MSHC2_CLK_SEL		= 1 << 24,
+		MUX_CSPI3_UART5_SEL		= 1 << 25,
+		MUX_PGP_ATA_9			= 1 << 26,
+		MUX_PGP_USB_SUSPEND		= 1 << 27,
+		MUX_PGP_USB_OTG_LOOPBACK	= 1 << 28,
+		MUX_PGP_USB_HS1_LOOPBACK	= 1 << 29,
+		MUX_PGP_USB_HS2_LOOPBACK	= 1 << 30,
+		MUX_CLKO_DDR_MODE		= 1 << 31,
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
+	};
+#else
+} iomux_gp_func_t;
+#endif
 
 /*
  * This function enables/disables the general purpose function for a particular
  * signal.
  */
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 void iomux_config_gpr(enum iomux_gp_func , bool);
+#else
+void iomux_config_gpr(iomux_gp_func_t , bool);
+#endif
 
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 /*
  * set the mode for a IOMUX pin.
  */
 int mxc_iomux_mode(unsigned int);
+#endif
+
+#ifndef CONFIG_ARCH_REQUIRE_GPIOLIB
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ *
+ * @param  pin      a pin number as defined in \b #iomux_pin_name_t
+ * @param  out      an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in       an input function as defined in \b #iomux_pin_icfg_t
+ * @return      0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		iomux_pin_icfg_t in);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pins
+ * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin      a name defined by \b iomux_pin_name_t
+ * @param  out      an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in       an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return      0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		iomux_pin_icfg_t in);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin      a name defined by \b iomux_pin_name_t
+ * @param  out      an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in       an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		iomux_pin_icfg_t in);
+#endif
 
 /*
  * This function enables/disables the general purpose function for a particular
  * signal.
  */
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 void mxc_iomux_set_gpr(enum iomux_gp_func, bool);
+#else
+void mxc_iomux_set_gpr(iomux_gp_func_t , bool);
+#endif
+
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 
 #define IOMUX_PADNUM_MASK	0x1ff
 #define IOMUX_GPIONUM_SHIFT	9
@@ -141,7 +246,7 @@ void mxc_iomux_set_gpr(enum iomux_gp_func, bool);
 	((iomux_pin & IOMUX_GPIONUM_MASK) >> IOMUX_GPIONUM_SHIFT)
 #define IOMUX_TO_IRQ(iomux_pin) \
 	(((iomux_pin & IOMUX_GPIONUM_MASK) >> IOMUX_GPIONUM_SHIFT) + \
-	MXC_GPIO_INT_BASE)
+	 MXC_GPIO_INT_BASE)
 
 /*
  * This enumeration is constructed based on the Section
@@ -492,10 +597,16 @@ enum iomux_pins {
 #define MX31_PIN_TXD1__TXD1		IOMUX_MODE(MX31_PIN_TXD1, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_RXD1__RXD1		IOMUX_MODE(MX31_PIN_RXD1, IOMUX_CONFIG_FUNC)
 
+#endif /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
+
 /*
  * This function configures the pad value for a IOMUX pin.
  */
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 void mxc_iomux_set_pad(enum iomux_pins, u32);
+#else
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+#endif
 
 #endif
 
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index 228c4f6..bd585a3 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -13,4 +13,12 @@
 
 #include <mach/hardware.h>
 
+#define MXC_IRQ_TO_EXPIO(irq)   ((irq) - MXC_EXP_IO_BASE)
+
+#define MXC_IRQ_TO_GPIO(irq)    ((irq) - MXC_GPIO_INT_BASE)
+#define MXC_GPIO_TO_IRQ(x)  (MXC_GPIO_INT_BASE + x)
+
+/* Number of fast interrupts */
+#define NR_FIQS     MXC_MAX_INTS
+
 #endif /* __ASM_ARCH_MXC_IRQS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/isp1504.h b/arch/arm/plat-mxc/include/mach/isp1504.h
new file mode 100644
index 0000000..e45589b
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/isp1504.h
@@ -0,0 +1,39 @@
+
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ISP1504_H__
+#define __ASM_ARCH_MXC_ISP1504_H__
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+u8 isp1504_read(int reg, u32 *view);
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index d7a8d3e..b4edf7c 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -11,8 +11,30 @@
 #ifndef __ASM_ARCH_MXC_MEMORY_H__
 #define __ASM_ARCH_MXC_MEMORY_H__
 
+#include <asm/page.h>
+#include <asm/sizes.h>
 #include <mach/hardware.h>
 
+#ifndef __ASSEMBLY__
+#define MXC_DMA_ZONE_SIZE   ((24 * SZ_1M) >> PAGE_SHIFT)
+
+static inline void __arch_adjust_zones(int node, unsigned long *zone_size,
+		unsigned long *zhole_size)
+{
+	if (node != 0)
+		return;
+
+	/* Create separate zone to reserve memory for DMA */
+	zone_size[1] = zone_size[0] - MXC_DMA_ZONE_SIZE;
+	zone_size[0] = MXC_DMA_ZONE_SIZE;
+	zhole_size[1] = zhole_size[0];
+	zhole_size[0] = 0;
+}
+
+#define arch_adjust_zones(node, size, holes) \
+	__arch_adjust_zones(node, size, holes)
+
+#endif
 /*
  * Virtual view <-> DMA view memory address translations
  * This macro is used to translate the virtual address to an address
diff --git a/arch/arm/plat-mxc/include/mach/mx31.h b/arch/arm/plat-mxc/include/mach/mx31.h
index a7373e4..ef55fbf 100644
--- a/arch/arm/plat-mxc/include/mach/mx31.h
+++ b/arch/arm/plat-mxc/include/mach/mx31.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -120,6 +120,15 @@
 #define MSHC2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
 #define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
 
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI2	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_SIM	0x18
+#define SPBA_IIM	0x1C
+#define SPBA_ATA	0x20
+
 /*
  * AIPS 2
  */
@@ -280,7 +289,7 @@
 #define MXC_INT_EPIT1		28
 #define MXC_INT_GPT		29
 #define MXC_INT_RESV30		30
-#define MXC_INT_RESV31		31
+#define MXC_INT_DVFS		31
 #define MXC_INT_UART2		32
 #define MXC_INT_NANDFC		33
 #define MXC_INT_SDMA		34
@@ -319,6 +328,7 @@
 #define MXC_GPIO_INT_BASE	MXC_MAX_INT_LINES
 #define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
 #define MXC_MAX_VIRTUAL_INTS	16
+#define MXC_GPIO_BASE           (MXC_MAX_INT_LINES)
 
 #define NR_IRQS (MXC_MAX_INT_LINES + MXC_MAX_GPIO_LINES + MXC_MAX_VIRTUAL_INTS)
 
@@ -349,6 +359,7 @@
 #define SYSTEM_REV_MIN		CHIP_REV_1_0
 #define SYSTEM_REV_NUM		3
 
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 /* gpio and gpio based interrupt handling */
 #define GPIO_DR		 	0x00
 #define GPIO_GDIR	 	0x04
@@ -362,6 +373,7 @@
 #define GPIO_INT_RISE_EDGE	0x2
 #define GPIO_INT_FALL_EDGE	0x3
 #define GPIO_INT_NONE		0x4
+#endif /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
 
 /* Mandatory defines used globally */
 
diff --git a/arch/arm/plat-mxc/include/mach/mx31_pins.h b/arch/arm/plat-mxc/include/mach/mx31_pins.h
new file mode 100644
index 0000000..0bc6baa
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx31_pins.h
@@ -0,0 +1,438 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX31_PINS_H__
+#define __ASM_ARCH_MXC_MX31_PINS_H__
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20  | 19 - 18 | 17 - 10| 9 - 8 | 7 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   |     RSVD    |  PAD_F  |  PAD_I | MUX_F | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base + 0xC) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Bit 8 to 9 is MUX_F which
+ * contains the offset value defined WITHIN the same register (each IOMUX
+ * control register contains four 8-bit fields for four different pins). The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX31_PIN_A0 is defined in the enumeration:
+ *    ( 73 << MUX_I) | (0 << MUX_F)|( 98 << PAD_I) | (0 << PAD_F)
+ * It means the mux control register is at register offset 73. So the absolute
+ * address is: 0xC+73*4=0x130   0 << MUX_F means the control bits are at the
+ * least significant bits within the register. The pad control register offset
+ * is: 0x154+98*4=0x2DC and also occupy the least significant bits within the
+ * register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	29
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	24
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register index (0-based)
+ */
+#define MUX_I		0
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within IOMUX control register for control bits
+ * (legal values are 0, 1, 2, 3)
+ */
+#define MUX_F		8
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register index (0-based)
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within PAD control register for control bits
+ * (legal values are 0, 1, 2)
+ */
+#define PAD_F		18
+
+#define _MXC_BUILD_PIN(gp, gi, mi, mf, pi, pf) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | ((mi) << MUX_I) | \
+	 ((mf) << MUX_F) | ((pi) << PAD_I) | ((pf) << PAD_F))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, mf, pi, pf) \
+	_MXC_BUILD_PIN(gp, gi, mi, mf, pi, pf)
+#define _MXC_BUILD_NON_GPIO_PIN(mi, mf, pi, pf) \
+	_MXC_BUILD_PIN(7, 0, mi, mf, pi, pf)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX31 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+typedef enum __iomux_pins {
+	MX31_PIN_CSPI3_MISO = _MXC_BUILD_NON_GPIO_PIN(0, 3, 1, 2),
+	MX31_PIN_CSPI3_SCLK = _MXC_BUILD_NON_GPIO_PIN(0, 2, 1, 1),
+	MX31_PIN_CSPI3_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(0, 1, 1, 0),
+	MX31_PIN_TTM_PAD = _MXC_BUILD_NON_GPIO_PIN(0, 0, 0, 2),
+	MX31_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(2, 31, 1, 3, 3, 0),
+	MX31_PIN_CE_CONTROL = _MXC_BUILD_NON_GPIO_PIN(1, 2, 2, 2),
+	MX31_PIN_CLKSS = _MXC_BUILD_NON_GPIO_PIN(1, 1, 2, 1),
+	MX31_PIN_CSPI3_MOSI = _MXC_BUILD_NON_GPIO_PIN(1, 0, 2, 0),
+	MX31_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(2, 27, 2, 3, 4, 1),
+	MX31_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(2, 28, 2, 2, 4, 0),
+	MX31_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(2, 29, 2, 1, 3, 2),
+	MX31_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(2, 30, 2, 0, 3, 1),
+	MX31_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 29, 3, 3, 5, 2),
+	MX31_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 30, 3, 2, 5, 1),
+	MX31_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 31, 3, 1, 5, 0),
+	MX31_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0, 4, 2),
+	MX31_PIN_D3_SPL = _MXC_BUILD_NON_GPIO_PIN(4, 3, 7, 0),
+	MX31_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 26, 4, 2, 6, 2),
+	MX31_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 27, 4, 1, 6, 1),
+	MX31_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 28, 4, 0, 6, 0),
+	MX31_PIN_VSYNC3 = _MXC_BUILD_NON_GPIO_PIN(5, 3, 8, 1),
+	MX31_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(5, 2, 8, 0),
+	MX31_PIN_D3_REV = _MXC_BUILD_NON_GPIO_PIN(5, 1, 7, 2),
+	MX31_PIN_D3_CLS = _MXC_BUILD_NON_GPIO_PIN(5, 0, 7, 1),
+	MX31_PIN_SER_RS = _MXC_BUILD_GPIO_PIN(2, 25, 6, 3, 9, 2),
+	MX31_PIN_PAR_RS = _MXC_BUILD_NON_GPIO_PIN(6, 2, 9, 1),
+	MX31_PIN_WRITE = _MXC_BUILD_NON_GPIO_PIN(6, 1, 9, 0),
+	MX31_PIN_READ = _MXC_BUILD_NON_GPIO_PIN(6, 0, 8, 2),
+	MX31_PIN_SD_D_IO = _MXC_BUILD_GPIO_PIN(2, 21, 7, 3, 11, 0),
+	MX31_PIN_SD_D_CLK = _MXC_BUILD_GPIO_PIN(2, 22, 7, 2, 10, 2),
+	MX31_PIN_LCS0 = _MXC_BUILD_GPIO_PIN(2, 23, 7, 1, 10, 1),
+	MX31_PIN_LCS1 = _MXC_BUILD_GPIO_PIN(2, 24, 7, 0, 10, 0),
+	MX31_PIN_HSYNC = _MXC_BUILD_NON_GPIO_PIN(8, 3, 12, 1),
+	MX31_PIN_FPSHIFT = _MXC_BUILD_NON_GPIO_PIN(8, 2, 12, 0),
+	MX31_PIN_DRDY0 = _MXC_BUILD_NON_GPIO_PIN(8, 1, 11, 2),
+	MX31_PIN_SD_D_I = _MXC_BUILD_GPIO_PIN(2, 20, 8, 0, 11, 1),
+	MX31_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(9, 3, 13, 2),
+	MX31_PIN_LD16 = _MXC_BUILD_NON_GPIO_PIN(9, 2, 13, 1),
+	MX31_PIN_LD17 = _MXC_BUILD_NON_GPIO_PIN(9, 1, 13, 0),
+	MX31_PIN_VSYNC0 = _MXC_BUILD_NON_GPIO_PIN(9, 0, 12, 2),
+	MX31_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(10, 3, 15, 0),
+	MX31_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(10, 2, 14, 2),
+	MX31_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(10, 1, 14, 1),
+	MX31_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(10, 0, 14, 0),
+	MX31_PIN_LD7 = _MXC_BUILD_NON_GPIO_PIN(11, 3, 16, 1),
+	MX31_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(11, 2, 16, 0),
+	MX31_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(11, 1, 15, 2),
+	MX31_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(11, 0, 15, 1),
+	MX31_PIN_LD3 = _MXC_BUILD_NON_GPIO_PIN(12, 3, 17, 2),
+	MX31_PIN_LD4 = _MXC_BUILD_NON_GPIO_PIN(12, 2, 17, 1),
+	MX31_PIN_LD5 = _MXC_BUILD_NON_GPIO_PIN(12, 1, 17, 0),
+	MX31_PIN_LD6 = _MXC_BUILD_NON_GPIO_PIN(12, 0, 16, 2),
+	MX31_PIN_USBH2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(13, 3, 19, 0),
+	MX31_PIN_LD0 = _MXC_BUILD_NON_GPIO_PIN(13, 2, 18, 2),
+	MX31_PIN_LD1 = _MXC_BUILD_NON_GPIO_PIN(13, 1, 18, 1),
+	MX31_PIN_LD2 = _MXC_BUILD_NON_GPIO_PIN(13, 0, 18, 0),
+	MX31_PIN_USBH2_DIR = _MXC_BUILD_NON_GPIO_PIN(14, 3, 20, 1),
+	MX31_PIN_USBH2_STP = _MXC_BUILD_NON_GPIO_PIN(14, 2, 20, 0),
+	MX31_PIN_USBH2_NXT = _MXC_BUILD_NON_GPIO_PIN(14, 1, 19, 2),
+	MX31_PIN_USBH2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(14, 0, 19, 1),
+	MX31_PIN_USBOTG_DATA5 = _MXC_BUILD_NON_GPIO_PIN(15, 3, 21, 2),
+	MX31_PIN_USBOTG_DATA6 = _MXC_BUILD_NON_GPIO_PIN(15, 2, 21, 1),
+	MX31_PIN_USBOTG_DATA7 = _MXC_BUILD_NON_GPIO_PIN(15, 1, 21, 0),
+	MX31_PIN_USBH2_CLK = _MXC_BUILD_NON_GPIO_PIN(15, 0, 20, 2),
+	MX31_PIN_USBOTG_DATA1 = _MXC_BUILD_NON_GPIO_PIN(16, 3, 23, 0),
+	MX31_PIN_USBOTG_DATA2 = _MXC_BUILD_NON_GPIO_PIN(16, 2, 22, 2),
+	MX31_PIN_USBOTG_DATA3 = _MXC_BUILD_NON_GPIO_PIN(16, 1, 22, 1),
+	MX31_PIN_USBOTG_DATA4 = _MXC_BUILD_NON_GPIO_PIN(16, 0, 22, 0),
+	MX31_PIN_USBOTG_DIR = _MXC_BUILD_NON_GPIO_PIN(17, 3, 24, 1),
+	MX31_PIN_USBOTG_STP = _MXC_BUILD_NON_GPIO_PIN(17, 2, 24, 0),
+	MX31_PIN_USBOTG_NXT = _MXC_BUILD_NON_GPIO_PIN(17, 1, 23, 2),
+	MX31_PIN_USBOTG_DATA0 = _MXC_BUILD_NON_GPIO_PIN(17, 0, 23, 1),
+	MX31_PIN_USB_PWR = _MXC_BUILD_GPIO_PIN(0, 29, 18, 3, 25, 2),
+	MX31_PIN_USB_OC = _MXC_BUILD_GPIO_PIN(0, 30, 18, 2, 25, 1),
+	MX31_PIN_USB_BYP = _MXC_BUILD_GPIO_PIN(0, 31, 18, 1, 25, 0),
+	MX31_PIN_USBOTG_CLK = _MXC_BUILD_NON_GPIO_PIN(18, 0, 24, 2),
+	MX31_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(19, 3, 27, 0),
+	MX31_PIN_TRSTB = _MXC_BUILD_NON_GPIO_PIN(19, 2, 26, 2),
+	MX31_PIN_DE_B = _MXC_BUILD_NON_GPIO_PIN(19, 1, 26, 1),
+	MX31_PIN_SJC_MOD = _MXC_BUILD_NON_GPIO_PIN(19, 0, 26, 0),
+	MX31_PIN_RTCK = _MXC_BUILD_NON_GPIO_PIN(20, 3, 28, 1),
+	MX31_PIN_TCK = _MXC_BUILD_NON_GPIO_PIN(20, 2, 28, 0),
+	MX31_PIN_TMS = _MXC_BUILD_NON_GPIO_PIN(20, 1, 27, 2),
+	MX31_PIN_TDI = _MXC_BUILD_NON_GPIO_PIN(20, 0, 27, 1),
+	MX31_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN(1, 22, 21, 3, 29, 2),
+	MX31_PIN_KEY_COL5 = _MXC_BUILD_GPIO_PIN(1, 23, 21, 2, 29, 1),
+	MX31_PIN_KEY_COL6 = _MXC_BUILD_GPIO_PIN(1, 24, 21, 1, 29, 0),
+	MX31_PIN_KEY_COL7 = _MXC_BUILD_GPIO_PIN(1, 25, 21, 0, 28, 2),
+	MX31_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(22, 3, 31, 0),
+	MX31_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(22, 2, 30, 2),
+	MX31_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(22, 1, 30, 1),
+	MX31_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(22, 0, 30, 0),
+	MX31_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN(1, 18, 23, 3, 32, 1),
+	MX31_PIN_KEY_ROW5 = _MXC_BUILD_GPIO_PIN(1, 19, 23, 2, 32, 0),
+	MX31_PIN_KEY_ROW6 = _MXC_BUILD_GPIO_PIN(1, 20, 23, 1, 31, 2),
+	MX31_PIN_KEY_ROW7 = _MXC_BUILD_GPIO_PIN(1, 21, 23, 0, 31, 1),
+	MX31_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(24, 3, 33, 2),
+	MX31_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(24, 2, 33, 1),
+	MX31_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(24, 1, 33, 0),
+	MX31_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(24, 0, 32, 2),
+	MX31_PIN_TXD2 = _MXC_BUILD_GPIO_PIN(0, 28, 25, 3, 35, 0),
+	MX31_PIN_RTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 2, 34, 2),
+	MX31_PIN_CTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 1, 34, 1),
+	MX31_PIN_BATT_LINE = _MXC_BUILD_GPIO_PIN(1, 17, 25, 0, 34, 0),
+	MX31_PIN_RI_DTE1 = _MXC_BUILD_GPIO_PIN(1, 14, 26, 3, 36, 1),
+	MX31_PIN_DCD_DTE1 = _MXC_BUILD_GPIO_PIN(1, 15, 26, 2, 36, 0),
+	MX31_PIN_DTR_DCE2 = _MXC_BUILD_GPIO_PIN(1, 16, 26, 1, 35, 2),
+	MX31_PIN_RXD2 = _MXC_BUILD_GPIO_PIN(0, 27, 26, 0, 35, 1),
+	MX31_PIN_RI_DCE1 = _MXC_BUILD_GPIO_PIN(1, 10, 27, 3, 37, 2),
+	MX31_PIN_DCD_DCE1 = _MXC_BUILD_GPIO_PIN(1, 11, 27, 2, 37, 1),
+	MX31_PIN_DTR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 12, 27, 1, 37, 0),
+	MX31_PIN_DSR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 13, 27, 0, 36, 2),
+	MX31_PIN_RTS1 = _MXC_BUILD_GPIO_PIN(1, 6, 28, 3, 39, 0),
+	MX31_PIN_CTS1 = _MXC_BUILD_GPIO_PIN(1, 7, 28, 2, 38, 2),
+	MX31_PIN_DTR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 8, 28, 1, 38, 1),
+	MX31_PIN_DSR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 9, 28, 0, 38, 0),
+	MX31_PIN_CSPI2_SCLK = _MXC_BUILD_NON_GPIO_PIN(29, 3, 40, 1),
+	MX31_PIN_CSPI2_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(29, 2, 40, 0),
+	MX31_PIN_RXD1 = _MXC_BUILD_GPIO_PIN(1, 4, 29, 1, 39, 2),
+	MX31_PIN_TXD1 = _MXC_BUILD_GPIO_PIN(1, 5, 29, 0, 39, 1),
+	MX31_PIN_CSPI2_MISO = _MXC_BUILD_NON_GPIO_PIN(30, 3, 41, 2),
+	MX31_PIN_CSPI2_SS0 = _MXC_BUILD_NON_GPIO_PIN(30, 2, 41, 1),
+	MX31_PIN_CSPI2_SS1 = _MXC_BUILD_NON_GPIO_PIN(30, 1, 41, 0),
+	MX31_PIN_CSPI2_SS2 = _MXC_BUILD_NON_GPIO_PIN(30, 0, 40, 2),
+	MX31_PIN_CSPI1_SS2 = _MXC_BUILD_NON_GPIO_PIN(31, 3, 43, 0),
+	MX31_PIN_CSPI1_SCLK = _MXC_BUILD_NON_GPIO_PIN(31, 2, 42, 2),
+	MX31_PIN_CSPI1_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(31, 1, 42, 1),
+	MX31_PIN_CSPI2_MOSI = _MXC_BUILD_NON_GPIO_PIN(31, 0, 42, 0),
+	MX31_PIN_CSPI1_MOSI = _MXC_BUILD_NON_GPIO_PIN(32, 3, 44, 1),
+	MX31_PIN_CSPI1_MISO = _MXC_BUILD_NON_GPIO_PIN(32, 2, 44, 0),
+	MX31_PIN_CSPI1_SS0 = _MXC_BUILD_NON_GPIO_PIN(32, 1, 43, 2),
+	MX31_PIN_CSPI1_SS1 = _MXC_BUILD_NON_GPIO_PIN(32, 0, 43, 1),
+	MX31_PIN_STXD6 = _MXC_BUILD_GPIO_PIN(0, 23, 33, 3, 45, 2),
+	MX31_PIN_SRXD6 = _MXC_BUILD_GPIO_PIN(0, 24, 33, 2, 45, 1),
+	MX31_PIN_SCK6 = _MXC_BUILD_GPIO_PIN(0, 25, 33, 1, 45, 0),
+	MX31_PIN_SFS6 = _MXC_BUILD_GPIO_PIN(0, 26, 33, 0, 44, 2),
+	MX31_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 21, 34, 3, 47, 0),
+	MX31_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 22, 34, 2, 46, 2),
+	MX31_PIN_SCK5 = _MXC_BUILD_NON_GPIO_PIN(34, 1, 46, 1),
+	MX31_PIN_SFS5 = _MXC_BUILD_NON_GPIO_PIN(34, 0, 46, 0),
+	MX31_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(0, 19, 35, 3, 48, 1),
+	MX31_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(0, 20, 35, 2, 48, 0),
+	MX31_PIN_SCK4 = _MXC_BUILD_NON_GPIO_PIN(35, 1, 47, 2),
+	MX31_PIN_SFS4 = _MXC_BUILD_NON_GPIO_PIN(35, 0, 47, 1),
+	MX31_PIN_STXD3 = _MXC_BUILD_GPIO_PIN(0, 17, 36, 3, 49, 2),
+	MX31_PIN_SRXD3 = _MXC_BUILD_GPIO_PIN(0, 18, 36, 2, 49, 1),
+	MX31_PIN_SCK3 = _MXC_BUILD_NON_GPIO_PIN(36, 1, 49, 0),
+	MX31_PIN_SFS3 = _MXC_BUILD_NON_GPIO_PIN(36, 0, 48, 2),
+	MX31_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(2, 18, 37, 3, 51, 0),
+	MX31_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(2, 19, 37, 2, 50, 2),
+	MX31_PIN_I2C_CLK = _MXC_BUILD_NON_GPIO_PIN(37, 1, 50, 1),
+	MX31_PIN_I2C_DAT = _MXC_BUILD_NON_GPIO_PIN(37, 0, 50, 0),
+	MX31_PIN_CSI_D14 = _MXC_BUILD_GPIO_PIN(2, 14, 38, 3, 52, 1),
+	MX31_PIN_CSI_D15 = _MXC_BUILD_GPIO_PIN(2, 15, 38, 2, 52, 0),
+	MX31_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(2, 16, 38, 1, 51, 2),
+	MX31_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(2, 17, 38, 0, 51, 1),
+	MX31_PIN_CSI_D10 = _MXC_BUILD_GPIO_PIN(2, 10, 39, 3, 53, 2),
+	MX31_PIN_CSI_D11 = _MXC_BUILD_GPIO_PIN(2, 11, 39, 2, 53, 1),
+	MX31_PIN_CSI_D12 = _MXC_BUILD_GPIO_PIN(2, 12, 39, 1, 53, 0),
+	MX31_PIN_CSI_D13 = _MXC_BUILD_GPIO_PIN(2, 13, 39, 0, 52, 2),
+	MX31_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(2, 6, 40, 3, 55, 0),
+	MX31_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(2, 7, 40, 2, 54, 2),
+	MX31_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(2, 8, 40, 1, 54, 1),
+	MX31_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(2, 9, 40, 0, 54, 0),
+	MX31_PIN_M_REQUEST = _MXC_BUILD_NON_GPIO_PIN(41, 3, 56, 1),
+	MX31_PIN_M_GRANT = _MXC_BUILD_NON_GPIO_PIN(41, 2, 56, 0),
+	MX31_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(2, 4, 41, 1, 55, 2),
+	MX31_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(2, 5, 41, 0, 55, 1),
+	MX31_PIN_PC_RST = _MXC_BUILD_NON_GPIO_PIN(42, 3, 57, 2),
+	MX31_PIN_IOIS16 = _MXC_BUILD_NON_GPIO_PIN(42, 2, 57, 1),
+	MX31_PIN_PC_RW_B = _MXC_BUILD_NON_GPIO_PIN(42, 1, 57, 0),
+	MX31_PIN_PC_POE = _MXC_BUILD_NON_GPIO_PIN(42, 0, 56, 2),
+	MX31_PIN_PC_VS1 = _MXC_BUILD_NON_GPIO_PIN(43, 3, 59, 0),
+	MX31_PIN_PC_VS2 = _MXC_BUILD_NON_GPIO_PIN(43, 2, 58, 2),
+	MX31_PIN_PC_BVD1 = _MXC_BUILD_NON_GPIO_PIN(43, 1, 58, 1),
+	MX31_PIN_PC_BVD2 = _MXC_BUILD_NON_GPIO_PIN(43, 0, 58, 0),
+	MX31_PIN_PC_CD2_B = _MXC_BUILD_NON_GPIO_PIN(44, 3, 60, 1),
+	MX31_PIN_PC_WAIT_B = _MXC_BUILD_NON_GPIO_PIN(44, 2, 60, 0),
+	MX31_PIN_PC_READY = _MXC_BUILD_NON_GPIO_PIN(44, 1, 59, 2),
+	MX31_PIN_PC_PWRON = _MXC_BUILD_NON_GPIO_PIN(44, 0, 59, 1),
+	MX31_PIN_D2 = _MXC_BUILD_NON_GPIO_PIN(45, 3, 61, 2),
+	MX31_PIN_D1 = _MXC_BUILD_NON_GPIO_PIN(45, 2, 61, 1),
+	MX31_PIN_D0 = _MXC_BUILD_NON_GPIO_PIN(45, 1, 61, 0),
+	MX31_PIN_PC_CD1_B = _MXC_BUILD_NON_GPIO_PIN(45, 0, 60, 2),
+	MX31_PIN_D6 = _MXC_BUILD_NON_GPIO_PIN(46, 3, 63, 0),
+	MX31_PIN_D5 = _MXC_BUILD_NON_GPIO_PIN(46, 2, 62, 2),
+	MX31_PIN_D4 = _MXC_BUILD_NON_GPIO_PIN(46, 1, 62, 1),
+	MX31_PIN_D3 = _MXC_BUILD_NON_GPIO_PIN(46, 0, 62, 0),
+	MX31_PIN_D10 = _MXC_BUILD_NON_GPIO_PIN(47, 3, 64, 1),
+	MX31_PIN_D9 = _MXC_BUILD_NON_GPIO_PIN(47, 2, 64, 0),
+	MX31_PIN_D8 = _MXC_BUILD_NON_GPIO_PIN(47, 1, 63, 2),
+	MX31_PIN_D7 = _MXC_BUILD_NON_GPIO_PIN(47, 0, 63, 1),
+	MX31_PIN_D14 = _MXC_BUILD_NON_GPIO_PIN(48, 3, 65, 2),
+	MX31_PIN_D13 = _MXC_BUILD_NON_GPIO_PIN(48, 2, 65, 1),
+	MX31_PIN_D12 = _MXC_BUILD_NON_GPIO_PIN(48, 1, 65, 0),
+	MX31_PIN_D11 = _MXC_BUILD_NON_GPIO_PIN(48, 0, 64, 2),
+	MX31_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(0, 14, 49, 3, 67, 0),
+	MX31_PIN_NFCE_B = _MXC_BUILD_GPIO_PIN(0, 15, 49, 2, 66, 2),
+	MX31_PIN_NFRB = _MXC_BUILD_GPIO_PIN(0, 16, 49, 1, 66, 1),
+	MX31_PIN_D15 = _MXC_BUILD_NON_GPIO_PIN(49, 0, 66, 0),
+	MX31_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(0, 10, 50, 3, 68, 1),
+	MX31_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(0, 11, 50, 2, 68, 0),
+	MX31_PIN_NFALE = _MXC_BUILD_GPIO_PIN(0, 12, 50, 1, 67, 2),
+	MX31_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(0, 13, 50, 0, 67, 1),
+	MX31_PIN_SDQS0 = _MXC_BUILD_NON_GPIO_PIN(51, 3, 69, 2),
+	MX31_PIN_SDQS1 = _MXC_BUILD_NON_GPIO_PIN(51, 2, 69, 1),
+	MX31_PIN_SDQS2 = _MXC_BUILD_NON_GPIO_PIN(51, 1, 69, 0),
+	MX31_PIN_SDQS3 = _MXC_BUILD_NON_GPIO_PIN(51, 0, 68, 2),
+	MX31_PIN_SDCKE0 = _MXC_BUILD_NON_GPIO_PIN(52, 3, 71, 0),
+	MX31_PIN_SDCKE1 = _MXC_BUILD_NON_GPIO_PIN(52, 2, 70, 2),
+	MX31_PIN_SDCLK = _MXC_BUILD_NON_GPIO_PIN(52, 1, 70, 1),
+	MX31_PIN_SDCLK_B = _MXC_BUILD_NON_GPIO_PIN(52, 0, 70, 0),
+	MX31_PIN_RW = _MXC_BUILD_NON_GPIO_PIN(53, 3, 72, 1),
+	MX31_PIN_RAS = _MXC_BUILD_NON_GPIO_PIN(53, 2, 72, 0),
+	MX31_PIN_CAS = _MXC_BUILD_NON_GPIO_PIN(53, 1, 71, 2),
+	MX31_PIN_SDWE = _MXC_BUILD_NON_GPIO_PIN(53, 0, 71, 1),
+	MX31_PIN_CS5 = _MXC_BUILD_NON_GPIO_PIN(54, 3, 73, 2),
+	MX31_PIN_ECB = _MXC_BUILD_NON_GPIO_PIN(54, 2, 73, 1),
+	MX31_PIN_LBA = _MXC_BUILD_NON_GPIO_PIN(54, 1, 73, 0),
+	MX31_PIN_BCLK = _MXC_BUILD_NON_GPIO_PIN(54, 0, 72, 2),
+	MX31_PIN_CS1 = _MXC_BUILD_NON_GPIO_PIN(55, 3, 75, 0),
+	MX31_PIN_CS2 = _MXC_BUILD_NON_GPIO_PIN(55, 2, 74, 2),
+	MX31_PIN_CS3 = _MXC_BUILD_NON_GPIO_PIN(55, 1, 74, 1),
+	MX31_PIN_CS4 = _MXC_BUILD_NON_GPIO_PIN(55, 0, 74, 0),
+	MX31_PIN_EB0 = _MXC_BUILD_NON_GPIO_PIN(56, 3, 76, 1),
+	MX31_PIN_EB1 = _MXC_BUILD_NON_GPIO_PIN(56, 2, 76, 0),
+	MX31_PIN_OE = _MXC_BUILD_NON_GPIO_PIN(56, 1, 75, 2),
+	MX31_PIN_CS0 = _MXC_BUILD_NON_GPIO_PIN(56, 0, 75, 1),
+	MX31_PIN_DQM0 = _MXC_BUILD_NON_GPIO_PIN(57, 3, 77, 2),
+	MX31_PIN_DQM1 = _MXC_BUILD_NON_GPIO_PIN(57, 2, 77, 1),
+	MX31_PIN_DQM2 = _MXC_BUILD_NON_GPIO_PIN(57, 1, 77, 0),
+	MX31_PIN_DQM3 = _MXC_BUILD_NON_GPIO_PIN(57, 0, 76, 2),
+	MX31_PIN_SD28 = _MXC_BUILD_NON_GPIO_PIN(58, 3, 79, 0),
+	MX31_PIN_SD29 = _MXC_BUILD_NON_GPIO_PIN(58, 2, 78, 2),
+	MX31_PIN_SD30 = _MXC_BUILD_NON_GPIO_PIN(58, 1, 78, 1),
+	MX31_PIN_SD31 = _MXC_BUILD_NON_GPIO_PIN(58, 0, 78, 0),
+	MX31_PIN_SD24 = _MXC_BUILD_NON_GPIO_PIN(59, 3, 80, 1),
+	MX31_PIN_SD25 = _MXC_BUILD_NON_GPIO_PIN(59, 2, 80, 0),
+	MX31_PIN_SD26 = _MXC_BUILD_NON_GPIO_PIN(59, 1, 79, 2),
+	MX31_PIN_SD27 = _MXC_BUILD_NON_GPIO_PIN(59, 0, 79, 1),
+	MX31_PIN_SD20 = _MXC_BUILD_NON_GPIO_PIN(60, 3, 81, 2),
+	MX31_PIN_SD21 = _MXC_BUILD_NON_GPIO_PIN(60, 2, 81, 1),
+	MX31_PIN_SD22 = _MXC_BUILD_NON_GPIO_PIN(60, 1, 81, 0),
+	MX31_PIN_SD23 = _MXC_BUILD_NON_GPIO_PIN(60, 0, 80, 2),
+	MX31_PIN_SD16 = _MXC_BUILD_NON_GPIO_PIN(61, 3, 83, 0),
+	MX31_PIN_SD17 = _MXC_BUILD_NON_GPIO_PIN(61, 2, 82, 2),
+	MX31_PIN_SD18 = _MXC_BUILD_NON_GPIO_PIN(61, 1, 82, 1),
+	MX31_PIN_SD19 = _MXC_BUILD_NON_GPIO_PIN(61, 0, 82, 0),
+	MX31_PIN_SD12 = _MXC_BUILD_NON_GPIO_PIN(62, 3, 84, 1),
+	MX31_PIN_SD13 = _MXC_BUILD_NON_GPIO_PIN(62, 2, 84, 0),
+	MX31_PIN_SD14 = _MXC_BUILD_NON_GPIO_PIN(62, 1, 83, 2),
+	MX31_PIN_SD15 = _MXC_BUILD_NON_GPIO_PIN(62, 0, 83, 1),
+	MX31_PIN_SD8 = _MXC_BUILD_NON_GPIO_PIN(63, 3, 85, 2),
+	MX31_PIN_SD9 = _MXC_BUILD_NON_GPIO_PIN(63, 2, 85, 1),
+	MX31_PIN_SD10 = _MXC_BUILD_NON_GPIO_PIN(63, 1, 85, 0),
+	MX31_PIN_SD11 = _MXC_BUILD_NON_GPIO_PIN(63, 0, 84, 2),
+	MX31_PIN_SD4 = _MXC_BUILD_NON_GPIO_PIN(64, 3, 87, 0),
+	MX31_PIN_SD5 = _MXC_BUILD_NON_GPIO_PIN(64, 2, 86, 2),
+	MX31_PIN_SD6 = _MXC_BUILD_NON_GPIO_PIN(64, 1, 86, 1),
+	MX31_PIN_SD7 = _MXC_BUILD_NON_GPIO_PIN(64, 0, 86, 0),
+	MX31_PIN_SD0 = _MXC_BUILD_NON_GPIO_PIN(65, 3, 88, 1),
+	MX31_PIN_SD1 = _MXC_BUILD_NON_GPIO_PIN(65, 2, 88, 0),
+	MX31_PIN_SD2 = _MXC_BUILD_NON_GPIO_PIN(65, 1, 87, 2),
+	MX31_PIN_SD3 = _MXC_BUILD_NON_GPIO_PIN(65, 0, 87, 1),
+	MX31_PIN_A24 = _MXC_BUILD_NON_GPIO_PIN(66, 3, 89, 2),
+	MX31_PIN_A25 = _MXC_BUILD_NON_GPIO_PIN(66, 2, 89, 1),
+	MX31_PIN_SDBA1 = _MXC_BUILD_NON_GPIO_PIN(66, 1, 89, 0),
+	MX31_PIN_SDBA0 = _MXC_BUILD_NON_GPIO_PIN(66, 0, 88, 2),
+	MX31_PIN_A20 = _MXC_BUILD_NON_GPIO_PIN(67, 3, 91, 0),
+	MX31_PIN_A21 = _MXC_BUILD_NON_GPIO_PIN(67, 2, 90, 2),
+	MX31_PIN_A22 = _MXC_BUILD_NON_GPIO_PIN(67, 1, 90, 1),
+	MX31_PIN_A23 = _MXC_BUILD_NON_GPIO_PIN(67, 0, 90, 0),
+	MX31_PIN_A16 = _MXC_BUILD_NON_GPIO_PIN(68, 3, 92, 1),
+	MX31_PIN_A17 = _MXC_BUILD_NON_GPIO_PIN(68, 2, 92, 0),
+	MX31_PIN_A18 = _MXC_BUILD_NON_GPIO_PIN(68, 1, 91, 2),
+	MX31_PIN_A19 = _MXC_BUILD_NON_GPIO_PIN(68, 0, 91, 1),
+	MX31_PIN_A12 = _MXC_BUILD_NON_GPIO_PIN(69, 3, 93, 2),
+	MX31_PIN_A13 = _MXC_BUILD_NON_GPIO_PIN(69, 2, 93, 1),
+	MX31_PIN_A14 = _MXC_BUILD_NON_GPIO_PIN(69, 1, 93, 0),
+	MX31_PIN_A15 = _MXC_BUILD_NON_GPIO_PIN(69, 0, 92, 2),
+	MX31_PIN_A9 = _MXC_BUILD_NON_GPIO_PIN(70, 3, 95, 0),
+	MX31_PIN_A10 = _MXC_BUILD_NON_GPIO_PIN(70, 2, 94, 2),
+	MX31_PIN_MA10 = _MXC_BUILD_NON_GPIO_PIN(70, 1, 94, 1),
+	MX31_PIN_A11 = _MXC_BUILD_NON_GPIO_PIN(70, 0, 94, 0),
+	MX31_PIN_A5 = _MXC_BUILD_NON_GPIO_PIN(71, 3, 96, 1),
+	MX31_PIN_A6 = _MXC_BUILD_NON_GPIO_PIN(71, 2, 96, 0),
+	MX31_PIN_A7 = _MXC_BUILD_NON_GPIO_PIN(71, 1, 95, 2),
+	MX31_PIN_A8 = _MXC_BUILD_NON_GPIO_PIN(71, 0, 95, 1),
+	MX31_PIN_A1 = _MXC_BUILD_NON_GPIO_PIN(72, 3, 97, 2),
+	MX31_PIN_A2 = _MXC_BUILD_NON_GPIO_PIN(72, 2, 97, 1),
+	MX31_PIN_A3 = _MXC_BUILD_NON_GPIO_PIN(72, 1, 97, 0),
+	MX31_PIN_A4 = _MXC_BUILD_NON_GPIO_PIN(72, 0, 96, 2),
+	MX31_PIN_DVFS1 = _MXC_BUILD_NON_GPIO_PIN(73, 3, 99, 0),
+	MX31_PIN_VPG0 = _MXC_BUILD_NON_GPIO_PIN(73, 2, 98, 2),
+	MX31_PIN_VPG1 = _MXC_BUILD_NON_GPIO_PIN(73, 1, 98, 1),
+	MX31_PIN_A0 = _MXC_BUILD_NON_GPIO_PIN(73, 0, 98, 0),
+	MX31_PIN_CKIL = _MXC_BUILD_NON_GPIO_PIN(74, 3, 100, 1),
+	MX31_PIN_POWER_FAIL = _MXC_BUILD_NON_GPIO_PIN(74, 2, 100, 0),
+	MX31_PIN_VSTBY = _MXC_BUILD_NON_GPIO_PIN(74, 1, 99, 2),
+	MX31_PIN_DVFS0 = _MXC_BUILD_NON_GPIO_PIN(74, 0, 99, 1),
+	MX31_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN(75, 3, 101, 2),
+	MX31_PIN_BOOT_MODE2 = _MXC_BUILD_NON_GPIO_PIN(75, 2, 101, 1),
+	MX31_PIN_BOOT_MODE3 = _MXC_BUILD_NON_GPIO_PIN(75, 1, 101, 0),
+	MX31_PIN_BOOT_MODE4 = _MXC_BUILD_NON_GPIO_PIN(75, 0, 100, 2),
+	MX31_PIN_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN(76, 3, 103, 0),
+	MX31_PIN_POR_B = _MXC_BUILD_NON_GPIO_PIN(76, 2, 102, 2),
+	MX31_PIN_CLKO = _MXC_BUILD_NON_GPIO_PIN(76, 1, 102, 1),
+	MX31_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN(76, 0, 102, 0),
+	MX31_PIN_STX0 = _MXC_BUILD_GPIO_PIN(1, 1, 77, 3, 104, 1),
+	MX31_PIN_SRX0 = _MXC_BUILD_GPIO_PIN(1, 2, 77, 2, 104, 0),
+	MX31_PIN_SIMPD0 = _MXC_BUILD_GPIO_PIN(1, 3, 77, 1, 103, 2),
+	MX31_PIN_CKIH = _MXC_BUILD_NON_GPIO_PIN(77, 0, 103, 1),
+	MX31_PIN_GPIO3_1 = _MXC_BUILD_GPIO_PIN(2, 1, 78, 3, 105, 2),
+	MX31_PIN_SCLK0 = _MXC_BUILD_GPIO_PIN(2, 2, 78, 2, 105, 1),
+	MX31_PIN_SRST0 = _MXC_BUILD_GPIO_PIN(2, 3, 78, 1, 105, 0),
+	MX31_PIN_SVEN0 = _MXC_BUILD_GPIO_PIN(1, 0, 78, 0, 104, 2),
+	MX31_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 79, 3, 107, 0),
+	MX31_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 79, 2, 106, 2),
+	MX31_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 79, 1, 106, 1),
+	MX31_PIN_GPIO3_0 = _MXC_BUILD_GPIO_PIN(2, 0, 79, 0, 106, 0),
+	MX31_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 80, 3, 108, 1),
+	MX31_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 80, 2, 108, 0),
+	MX31_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 80, 1, 107, 2),
+	MX31_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 80, 0, 107, 1),
+	MX31_PIN_CAPTURE = _MXC_BUILD_GPIO_PIN(0, 7, 81, 3, 109, 2),
+	MX31_PIN_COMPARE = _MXC_BUILD_GPIO_PIN(0, 8, 81, 2, 109, 1),
+	MX31_PIN_WATCHDOG_RST = _MXC_BUILD_NON_GPIO_PIN(81, 1, 109, 0),
+	MX31_PIN_PWMO = _MXC_BUILD_GPIO_PIN(0, 9, 81, 0, 108, 2),
+} iomux_pin_name_t;
+
+#endif
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mx31_usb.h b/arch/arm/plat-mxc/include/mach/mx31_usb.h
new file mode 100644
index 0000000..39173c6
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx31_usb.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_USB2)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
diff --git a/arch/arm/plat-mxc/include/mach/mx51.h b/arch/arm/plat-mxc/include/mach/mx51.h
new file mode 100644
index 0000000..59c26ca
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx51.h
@@ -0,0 +1,574 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX51_H__
+#define __ASM_ARCH_MXC_MX51_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#ifndef __ASSEMBLY__
+void mx51_arch_idle(void);
+void mx51_arch_reset(char mode);
+#endif
+
+/*!
+ * @file arch-mxc/mx51.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX51
+ */
+/*!
+ * defines the hardware clock tick rate
+ */
+#define CLOCK_TICK_RATE		8000000
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 3
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
+#define MXC_SDMA_V2
+
+ /*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR		0x1FFE0000	/* internal ram */
+#define IRAM_BASE_ADDR_VIRT	0xFA3E0000
+#define IRAM_PARTITIONS		16
+#define IRAM_PARTITIONS_TO1	12
+#define IRAM_SIZE		(IRAM_PARTITIONS*SZ_8K)	/* 128KB */
+
+#if defined(CONFIG_MXC_SECURITY_SCC2) \
+    || defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
+#define SCC_IRAM_SIZE  SZ_16K
+#else
+#define SCC_IRAM_SIZE  0
+#endif
+
+#ifdef CONFIG_SDMA_IRAM
+#define SDMA_IRAM_SIZE  CONFIG_SDMA_IRAM_SIZE
+#else
+#define SDMA_IRAM_SIZE  0
+#endif
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x6000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#ifdef CONFIG_MXC_VPU_IRAM
+#define VPU_IRAM_SIZE  0x7000
+#else
+#define VPU_IRAM_SIZE 0
+#endif
+
+#if (IRAM_SIZE < (SDMA_IRAM_SIZE + SND_RAM_SIZE + VPU_IRAM_SIZE + \
+	SCC_IRAM_SIZE))
+#error "IRAM size exceeded"
+#endif
+
+#define SCC_IRAM_BASE_ADDR	(IRAM_BASE_ADDR + IRAM_SIZE - SCC_IRAM_SIZE)
+#define VPU_IRAM_BASE_ADDR	(SCC_IRAM_BASE_ADDR - VPU_IRAM_SIZE)
+#define SND_RAM_BASE_ADDR	(VPU_IRAM_BASE_ADDR - SND_RAM_SIZE)
+#define SDMA_IRAM_BASE_ADDR	(SND_RAM_BASE_ADDR - SDMA_IRAM_SIZE)
+#define IDLE_IRAM_BASE_ADDR	(SDMA_IRAM_BASE_ADDR - SZ_4K)
+
+/*
+ * NFC
+ */
+#define NFC_BASE_ADDR_AXI		0xCFFF0000	/* NAND flash AXI */
+#define NFC_BASE_ADDR_AXI_VIRT	0xF9000000
+#define NFC_AXI_SIZE		SZ_64K
+
+/*
+ * Graphics Memory of GPU
+ */
+#define GPU_BASE_ADDR			0x20000000
+
+#define TZIC_BASE_ADDR		0x8FFFC000
+#define TZIC_BASE_ADDR_VIRT	0xFA100000
+#define TZIC_SIZE		SZ_16K
+
+#define DEBUG_BASE_ADDR	0x60000000
+#define DEBUG_BASE_ADDR_VIRT	0xFA200000
+#define DEBUG_SIZE		SZ_1M
+#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
+#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
+#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
+#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
+#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
+#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
+#define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
+#define CORTEX_DBG_BASE_ADDR	(DEBUG_BASE_ADDR + 0x00008000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0x70000000
+#define SPBA0_BASE_ADDR_VIRT	0xFB100000
+#define SPBA0_SIZE		SZ_1M
+
+#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
+#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI1_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define MMC_SDHC4_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00024000)
+#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00030000)
+#define SLIM_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
+#define HSI2C_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00038000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI1	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_SDHC3	0x20
+#define SPBA_SDHC4	0x24
+#define SPBA_SPDIF	0x28
+#define SPBA_ATA	0x30
+#define SPBA_SLIM	0x34
+#define SPBA_HSI2C	0x38
+#define SPBA_CTRL	0x3C
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0x73F00000
+#define AIPS1_BASE_ADDR_VIRT	0xFB000000
+#define AIPS1_SIZE		SZ_1M
+
+#define OTG_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00080000)
+#define GPIO1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00084000)
+#define GPIO2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00088000)
+#define GPIO3_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0008C000)
+#define GPIO4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00090000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
+#define WDOG1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00098000)
+#define WDOG_BASE_ADDR	WDOG1_BASE_ADDR
+#define WDOG2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0009C000)
+#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
+#define EPIT1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
+#define EPIT2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B0000)
+#define PWM1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B4000)
+#define PWM2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
+#define UART1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
+#define UART2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000C0000)
+#define SRC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
+#define CCM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D4000)
+#define GPC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_IRAM         30
+#define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX		MXC_DMA_DYNAMIC_CHANNEL
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
+#else				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_SSI2_TX		MXC_DMA_DYNAMIC_CHANNEL
+#endif				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_CSPI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY		MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR	0x83F00000
+#define AIPS2_BASE_ADDR_VIRT	0xFB200000
+#define AIPS2_SIZE		SZ_1M
+
+#define PLL1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define PLL2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
+#define PLL3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00088000)
+#define AHBMAX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00094000)
+#define IIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define CSU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
+#define ARM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
+#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
+#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
+#define CSPI2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000AC000)
+#define SDMA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B0000)
+#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B4000)
+#define ROMCP_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B8000)
+#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000BC000)
+#define CSPI3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
+#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
+#define I2C1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
+#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
+#define M4IF_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define ESDCTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D9000)
+#define WEIM_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DA000)
+#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
+#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DBF00)
+#define MIPI_HSC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DC000)
+#define ATA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000)
+#define SIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000)
+#define SSI3BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E8000)
+#define FEC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
+#define TVE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F0000)
+#define VPU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
+#define SAHARA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000F8000)
+
+/*
+ * Memory regions and CS
+ */
+#define GPU_CTRL_BASE_ADDR	0x30000000
+#define IPU_CTRL_BASE_ADDR	0x40000000
+#define CSD0_BASE_ADDR		0x90000000
+#define CSD1_BASE_ADDR		0xA0000000
+#define CS0_BASE_ADDR		0xB0000000
+#define CS1_BASE_ADDR		0xB8000000
+#define CS2_BASE_ADDR		0xC0000000
+#define CS3_BASE_ADDR		0xC8000000
+#define CS4_BASE_ADDR		0xCC000000
+#define CS5_BASE_ADDR		0xCE000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	((((x) >= (unsigned long)IRAM_BASE_ADDR) && \
+	    ((x) < (unsigned long)IRAM_BASE_ADDR + IRAM_SIZE)) ? \
+	     IRAM_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)TZIC_BASE_ADDR) && \
+	    ((x) < (unsigned long)TZIC_BASE_ADDR + TZIC_SIZE)) ? \
+	     TZIC_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)DEBUG_BASE_ADDR) && \
+	  ((x) < (unsigned long)DEBUG_BASE_ADDR + DEBUG_SIZE)) ? \
+	   DEBUG_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)SPBA0_BASE_ADDR) && \
+	  ((x) < (unsigned long)SPBA0_BASE_ADDR + SPBA0_SIZE)) ? \
+	   SPBA0_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS1_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS1_BASE_ADDR + AIPS1_SIZE)) ? \
+	   AIPS1_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS2_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS2_BASE_ADDR + AIPS2_SIZE)) ? \
+	   AIPS2_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)NFC_BASE_ADDR_AXI) && \
+	  ((x) < (unsigned long)NFC_BASE_ADDR_AXI + NFC_AXI_SIZE)) ? \
+	   NFC_BASE_ADDR_AXI_IO_ADDRESS(x) : \
+	0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+#define IRAM_IO_ADDRESS(x)  \
+	(((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
+
+#define TZIC_IO_ADDRESS(x)  \
+	(((x) - TZIC_BASE_ADDR) + TZIC_BASE_ADDR_VIRT)
+
+#define DEBUG_IO_ADDRESS(x)  \
+	(((x) - DEBUG_BASE_ADDR) + DEBUG_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define NFC_BASE_ADDR_AXI_IO_ADDRESS(x) \
+	(((x) - NFC_BASE_ADDR_AXI) + NFC_BASE_ADDR_AXI_VIRT)
+
+#define IS_MEM_DEVICE_NONSHARED(x)		0
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_SSI3_TX1	47
+#define DMA_REQ_SSI3_RX1	46
+#define DMA_REQ_SPDIF		45
+#define DMA_REQ_UART3_TX	44
+#define DMA_REQ_UART3_RX	43
+#define DMA_REQ_SLIM_B_TX	42
+#define DMA_REQ_SDHC4		41
+#define DMA_REQ_SDHC3		40
+#define DMA_REQ_CSPI_TX		39
+#define DMA_REQ_CSPI_RX		38
+#define DMA_REQ_SSI3_TX2	37
+#define DMA_REQ_IPU		36
+#define DMA_REQ_SSI3_RX2	35
+#define DMA_REQ_EPIT2		34
+#define DMA_REQ_CTI2_1		33
+#define DMA_REQ_EMI_WR		32
+#define DMA_REQ_CTI2_0		31
+#define DMA_REQ_EMI_RD		30
+#define DMA_REQ_SSI1_TX1	29
+#define DMA_REQ_SSI1_RX1	28
+#define DMA_REQ_SSI1_TX2	27
+#define DMA_REQ_SSI1_RX2	26
+#define DMA_REQ_SSI2_TX1	25
+#define DMA_REQ_SSI2_RX1	24
+#define DMA_REQ_SSI2_TX2	23
+#define DMA_REQ_SSI2_RX2	22
+#define DMA_REQ_SDHC2		21
+#define DMA_REQ_SDHC1		20
+#define DMA_REQ_UART1_TX	19
+#define DMA_REQ_UART1_RX	18
+#define DMA_REQ_UART2_TX	17
+#define DMA_REQ_UART2_RX	16
+#define DMA_REQ_GPU		15
+#define DMA_REQ_EXTREQ1		14
+#define DMA_REQ_FIRI_TX		13
+#define DMA_REQ_FIRI_RX		12
+#define DMA_REQ_HS_I2C_RX	11
+#define DMA_REQ_HS_I2C_TX	10
+#define DMA_REQ_CSPI2_TX	9
+#define DMA_REQ_CSPI2_RX	8
+#define DMA_REQ_CSPI1_TX	7
+#define DMA_REQ_CSPI1_RX	6
+#define DMA_REQ_SLIM_B		5
+#define DMA_REQ_ATA_TX_END	4
+#define DMA_REQ_ATA_TX		3
+#define DMA_REQ_ATA_RX		2
+#define DMA_REQ_GPC		1
+#define DMA_REQ_VPU		0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE		0
+#define MXC_INT_RESV0		0
+#define MXC_INT_MMC_SDHC1	1
+#define MXC_INT_MMC_SDHC2	2
+#define MXC_INT_MMC_SDHC3	3
+#define MXC_INT_MMC_SDHC4	4
+#define MXC_INT_RESV5		5
+#define MXC_INT_SDMA		6
+#define MXC_INT_IOMUX		7
+#define MXC_INT_NFC		8
+#define MXC_INT_VPU		9
+#define MXC_INT_IPU_ERR		10
+#define MXC_INT_IPU_SYN		11
+#define MXC_INT_GPU		12
+#define MXC_INT_RESV13		13
+#define MXC_INT_USB_H1		14
+#define MXC_INT_EMI		15
+#define MXC_INT_USB_H2		16
+#define MXC_INT_USB_H3		17
+#define MXC_INT_USB_OTG		18
+#define MXC_INT_SAHARA_H0	19
+#define MXC_INT_SAHARA_H1	20
+#define MXC_INT_SCC_SMN		21
+#define MXC_INT_SCC_STZ		22
+#define MXC_INT_SCC_SCM		23
+#define MXC_INT_SRTC_NTZ	24
+#define MXC_INT_SRTC_TZ		25
+#define MXC_INT_RTIC		26
+#define MXC_INT_CSU		27
+#define MXC_INT_SLIM_B		28
+#define MXC_INT_SSI1		29
+#define MXC_INT_SSI2		30
+#define MXC_INT_UART1		31
+#define MXC_INT_UART2		32
+#define MXC_INT_UART3		33
+#define MXC_INT_RESV34		34
+#define MXC_INT_RESV35		35
+#define MXC_INT_CSPI1		36
+#define MXC_INT_CSPI2		37
+#define MXC_INT_CSPI		38
+#define MXC_INT_GPT		39
+#define MXC_INT_EPIT1		40
+#define MXC_INT_EPIT2		41
+#define MXC_INT_GPIO1_INT7	42
+#define MXC_INT_GPIO1_INT6	43
+#define MXC_INT_GPIO1_INT5	44
+#define MXC_INT_GPIO1_INT4	45
+#define MXC_INT_GPIO1_INT3	46
+#define MXC_INT_GPIO1_INT2	47
+#define MXC_INT_GPIO1_INT1	48
+#define MXC_INT_GPIO1_INT0	49
+#define MXC_INT_GPIO1_LOW	50
+#define MXC_INT_GPIO1_HIGH	51
+#define MXC_INT_GPIO2_LOW	52
+#define MXC_INT_GPIO2_HIGH	53
+#define MXC_INT_GPIO3_LOW	54
+#define MXC_INT_GPIO3_HIGH	55
+#define MXC_INT_GPIO4_LOW	56
+#define MXC_INT_GPIO4_HIGH	57
+#define MXC_INT_WDOG1		58
+#define MXC_INT_WDOG2		59
+#define MXC_INT_KPP		60
+#define MXC_INT_PWM1		61
+#define MXC_INT_I2C1		62
+#define MXC_INT_I2C2		63
+#define MXC_INT_HS_I2C		64
+#define MXC_INT_RESV65		65
+#define MXC_INT_RESV66		66
+#define MXC_INT_SIM_IPB		67
+#define MXC_INT_SIM_DAT		68
+#define MXC_INT_IIM		69
+#define MXC_INT_ATA		70
+#define MXC_INT_CCM1		71
+#define MXC_INT_CCM2		72
+#define MXC_INT_GPC1		73
+#define MXC_INT_GPC2		74
+#define MXC_INT_SRC		75
+#define MXC_INT_NM		76
+#define MXC_INT_PMU		77
+#define MXC_INT_CTI_IRQ		78
+#define MXC_INT_CTI1_TG0	79
+#define MXC_INT_CTI1_TG1	80
+#define MXC_INT_MCG_ERR		81
+#define MXC_INT_MCG_TMR		82
+#define MXC_INT_MCG_FUNC	83
+#define MXC_INT_GPU2_IRQ	84
+#define MXC_INT_GPU2_BUSY	85
+#define MXC_INT_RESV86		86
+#define MXC_INT_FEC		87
+#define MXC_INT_OWIRE		88
+#define MXC_INT_CTI1_TG2	89
+#define MXC_INT_SJC		90
+#define MXC_INT_SPDIF		91
+#define MXC_INT_TVE		92
+#define MXC_INT_FIRI		93
+#define MXC_INT_PWM2		94
+#define MXC_INT_SLIM_EXP	95
+#define MXC_INT_SSI3		96
+#define MXC_INT_EMI_BOOT	97
+#define MXC_INT_CTI1_TG3	98
+#define MXC_INT_SMC_RX		99
+#define MXC_INT_VPU_IDLE	100
+#define MXC_INT_EMI_NFC		101
+#define MXC_INT_GPU_IDLE	102
+
+#define MXC_MAX_INT_LINES       128
+
+#define	MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
+
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
+/* gpio and gpio based interrupt handling */
+#define GPIO_DR		 	0x00
+#define GPIO_GDIR	 	0x04
+#define GPIO_PSR	 	0x08
+#define GPIO_ICR1	 	0x0C
+#define GPIO_ICR2	 	0x10
+#define GPIO_IMR	 	0x14
+#define GPIO_ISR	 	0x18
+#define GPIO_INT_LOW_LEV	0x0
+#define GPIO_INT_HIGH_LEV	0x1
+#define GPIO_INT_RISE_EDGE	0x2
+#define GPIO_INT_FALL_EDGE	0x3
+#define GPIO_INT_NONE		0x4
+#endif /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM		4
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+#define MUX_IO_P		29
+#define MUX_IO_I		24
+
+#define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
+#define	MXC_GPIO_BASE		(MXC_MAX_INT_LINES)
+#define MXC_MAX_EXP_IO_LINES	16
+#define MXC_MAX_VIRTUAL_INTS	0
+
+#define NR_IRQS			MXC_MAX_INTS
+
+#define MXC_GPIO_SPLIT_IRQ_2
+
+/* Start of RAM */
+#define PHYS_OFFSET		CSD0_BASE_ADDR
+
+#define CHIP_REV_1_0	0x10
+#define CHIP_REV_1_1	0x11
+#define CHIP_REV_1_2	0x12
+#define CHIP_REV_1_3	0x13
+#define CHIP_REV_2_0	0x20
+#define CHIP_REV_2_1	0x21
+#define CHIP_REV_2_2	0x22
+#define CHIP_REV_2_3	0x23
+#define CHIP_REV_3_0	0x30
+#define CHIP_REV_3_1	0x31
+#define CHIP_REV_3_2	0x32
+
+#define BOARD_REV_2	0x100
+
+#define MXC_CLK_FRAME_2
+
+#define MXC_GLB_GPIO_INTERFACE
+#define MXC_GPIO_SPLIT_IRQ_2
+
+#endif				/*  __ASM_ARCH_MXC_MX51_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mx51_usb.h b/arch/arm/plat-mxc/include/mach/mx51_usb.h
new file mode 100644
index 0000000..38d6f6b
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx51_usb.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+#include <mach/common.h>
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on);
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+	struct fsl_usb2_platform_data *pdata;
+	unsigned int temp;
+
+	pdata = hcd->self.controller->platform_data;
+	if (pdata->change_ahb_burst) {
+		temp = readl(hcd->regs + FSL_SOC_USB_SBUSCFG);
+		writel((temp & (~(0x7))) | pdata->ahb_burst_mode,
+			hcd->regs + FSL_SOC_USB_SBUSCFG);
+	}
+
+	/* Increase TX fifo threshold for USB+ATA for i.mx35 2.0 */
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x20 */
+		writel((temp & (~(0x3f << 16))) | (0x20 << 16),
+			hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+}
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
diff --git a/arch/arm/plat-mxc/include/mach/mx5_regulator.h b/arch/arm/plat-mxc/include/mach/mx5_regulator.h
new file mode 100644
index 0000000..662f9cc
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx5_regulator.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ * Copyright (C) 2008-2009 WindRiver System, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MX5_REGULATOR_H__
+#define __ASM_ARCH_MX5_REGULATOR_H__
+#include <linux/regulator/machine.h>
+
+/**
+ * struct regulator_consumer_supply - supply -> device mapping
+ *
+ * This maps a supply name to a device.
+ */
+struct regulator_consumer_supply {
+	struct device *dev;	/* consumer */
+	const char *supply;	/* consumer supply - e.g. "vcc" */
+};
+
+/**
+ * struct regulator_init_data - regulator platform initialisation data.
+ *
+ * Initialisation constraints, our supply and consumers supplies.
+ */
+struct regulator_init_data {
+	struct device *supply_regulator_dev; /* or NULL for LINE */
+
+	struct regulation_constraints constraints;
+
+	int num_consumer_supplies;
+	struct regulator_consumer_supply *consumer_supplies;
+
+	/* optional regulator machine specific init */
+	int (*regulator_init)(void *driver_data);
+	void *driver_data;	/* core does not touch this */
+};
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 332eda4..497e4a9 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -1,6 +1,7 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ * Copyright (C) 2008-2009 WindRiver System, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -24,6 +25,326 @@
 #error "Do not include directly."
 #endif
 
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+
+struct platform_device;
+/*!
+ * This structure is used to define the One wire platform data.
+ * It includes search rom accelerator.
+ */
+
+struct mxc_w1_config {
+	int search_rom_accelerator;
+};
+
+struct mxc_ir_platform_data {
+	int uart_ir_mux;
+	int ir_rx_invert;
+	int ir_tx_invert;
+	struct clk *uart_clk;
+};
+
+struct mxc_i2c_platform_data {
+	u32 i2c_clk;
+};
+
+struct mxc_spdif_platform_data {
+	int spdif_tx;
+	int spdif_rx;
+	int spdif_clk_44100;
+	int spdif_clk_48000;
+	int spdif_clkid;
+	struct clk *spdif_clk;
+	struct clk *spdif_core_clk;
+};
+
+struct mxc_asrc_platform_data {
+	struct clk *asrc_core_clk;
+	struct clk *asrc_audio_clk;
+	unsigned int channel_bits;
+};
+
+struct mxc_bt_platform_data {
+	char *bt_vdd;
+	char *bt_vdd_parent;
+	char *bt_vusb;
+	char *bt_vusb_parent;
+	void (*bt_reset) (void);
+};
+
+struct mxc_lightsensor_platform_data {
+	char *vdd_reg;
+	int rext;
+};
+
+struct mxc_fb_platform_data {
+	struct fb_videomode *mode;
+	char *mode_str;
+	u32 interface_pix_fmt;
+};
+
+struct mxc_dvfs_platform_data {
+	/** Supply voltage regulator name string */
+	char *reg_id;
+	/* CPU clock name string */
+	char *clk1_id;
+	/* DVFS clock name string */
+	char *clk2_id;
+	/* GPC control reg address */
+	unsigned int gpc_cntr_reg_addr;
+	/* GPC voltage counter reg address */
+	unsigned int gpc_vcr_reg_addr;
+	/* DVFS threshold reg address */
+	unsigned int dvfs_thrs_reg_addr;
+	/* DVFS counters reg address */
+	unsigned int dvfs_coun_reg_addr;
+	/* DVFS EMAC reg address */
+	unsigned int dvfs_emac_reg_addr;
+	/* DVFS control reg address */
+	unsigned int dvfs_cntr_reg_addr;
+	/* DIV3CK mask */
+	u32 div3ck_mask;
+	/* DIV3CK offset */
+	int div3ck_offset;
+	/* DIV3CK value */
+	int div3ck_val;
+	/* EMAC value */
+	int emac_val;
+	/* Frequency increase threshold. Increase frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int upthr_val;
+	/* Frequency decrease threshold. Decrease frequency change request
+	   will be sent if DVFS counter value will be less than this value */
+	int dnthr_val;
+	/* Panic threshold. Panic frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int pncthr_val;
+	/* The amount of times the up threshold should be exceeded
+	   before DVFS will trigger frequency increase request */
+	int upcnt_val;
+	/* The amount of times the down threshold should be exceeded
+	   before DVFS will trigger frequency decrease request */
+	int dncnt_val;
+	/* Delay time in us */
+	int delay_time;
+	/* Number of woking points supported */
+	int num_wp;
+};
+
+struct mxc_tsc_platform_data {
+	char *vdd_reg;
+	int penup_threshold;
+	void (*active) (void);
+	void (*inactive) (void);
+};
+
+struct mxc_tvin_platform_data {
+	char *dvddio_reg;
+	char *dvdd_reg;
+	char *avdd_reg;
+	char *pvdd_reg;
+	void (*pwdn) (int pwdn);
+	void (*reset) (void);
+};
+
+/*gpo1-3 is in fixed state by hardware design,
+ * only deal with reset pin and clock_enable pin
+ * only poll mode can be used to control the chip,
+ * interrupt mode is not supported by 3ds*/
+struct mxc_fm_platform_data {
+	char *reg_vio;
+	char *reg_vdd;
+	void (*gpio_get) (void);
+	void (*gpio_put) (void);
+	void (*reset) (void);
+	void (*clock_ctl) (int flag);
+	u8	sksnr; /*0,disable;1,most stop;0xf,fewest stop*/
+	u8	skcnt; /*0,disable;1,most stop;0xf,fewest stop*/
+	/*
+	00 = 87.5-108 MHz (USA,Europe) (Default).
+	01 = 76-108 MHz (Japan wide band).
+	10 = 76-90 MHz (Japan).
+	11 = Reserved.
+	*/
+	u8	band;
+	/*
+	00 = 200 kHz (USA, Australia) (default).
+	01 = 100 kHz (Europe, Japan).
+	10 = 50 kHz.
+	*/
+	u8	space;
+	u8	seekth;
+};
+
+struct mxc_mma7450_platform_data {
+	char *reg_dvdd_io;
+	char *reg_avdd;
+	void (*gpio_pin_get) (void);
+	void (*gpio_pin_put) (void);
+	int int1;
+	int int2;
+};
+
+struct mxc_keyp_platform_data {
+	u16 *matrix;
+	void (*active) (void);
+	void (*inactive) (void);
+	char *vdd_reg;
+};
+
+struct mxc_unifi_platform_data {
+	void (*hardreset) (int pin_level);
+	void (*enable) (int en);
+	/* power parameters */
+	char *reg_gpo1;
+	char *reg_gpo2;
+	char *reg_1v5_ana_bb;
+	char *reg_vdd_vpa;
+	char *reg_1v5_dd;
+
+	int host_id;
+
+	void *priv;
+};
+
+
+struct mxc_gps_platform_data {
+	char *core_reg;
+	char *analog_reg;
+};
+
+struct mxc_mlb_platform_data {
+	u32 buf_address;
+	u32 phy_address;
+	char *reg_nvcc;
+	char *mlb_clk;
+};
+
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	void (*xcvr_enable) (int id, int en);
+	void (*active) (int id);
+	void (*inactive) (int id);
+};
+
+struct mxc_srtc_platform_data {
+	u32 srtc_sec_mode_addr;
+};
+
+struct tve_platform_data {
+	char *dac_reg;
+	char *dig_reg;
+};
+
+struct mxc_sim_platform_data {
+	unsigned int clk_rate;
+	char *clock_sim;
+	char *power_sim;
+	int (*init)(struct platform_device *pdev);
+	void (*exit)(void);
+	unsigned int detect; /* 1 have detect pin, 0 not */
+};
+
+struct mxc_ipu_config {
+	int rev;
+	struct clk *di_clk[2];
+};
+
+/*This struct is to define the number of SSIs on a platform,
+DAM source port config, DAM external port config, and Regulator names*/
+struct mxc_audio_platform_data {
+	int ssi_num;
+	int src_port;
+	int ext_port;
+	int intr_id_hp;
+#ifdef CONFIG_ARCH_MX51
+	int ext_ram;
+#endif
+	struct clk *ssi_clk[2];
+	char *regulator1;
+	char *regulator2;
+#ifdef CONFIG_ARCH_MX51
+	int hp_irq;
+	int (*hp_status) (void);
+
+	char *vddio_reg;
+	char *vdda_reg;
+	char *vddd_reg;
+	int vddio;		/* voltage of VDDIO (uv) */
+	int vdda;		/* voltage of vdda (uv) */
+	int vddd;		/* voltage of vddd (uv), 0 if not connected */
+	int sysclk;
+
+	int (*init) (void);	/* board specific init */
+	int (*amp_enable) (int enable);
+	int (*finit) (void);	/* board specific finit */
+	void *priv;		/* used by board specific functions */
+#endif
+};
+
+struct mxc_lcd_platform_data {
+	char *io_reg;
+	char *core_reg;
+#ifdef CONFIG_ARCH_MX51
+	char *analog_reg;
+#endif
+	void (*reset) (void);
+};
+
+struct mxc_tvout_platform_data {
+	char *io_reg;
+	char *core_reg;
+	char *analog_reg;
+	u32 detect_line;
+};
+
+/*! Platform data for the IDE drive structure. */
+struct mxc_ide_platform_data {
+	char *power_drive;	/*!< The power pointer */
+	char *power_io;		/*!< The power pointer */
+};
+
+struct mxc_camera_platform_data {
+	char *core_regulator;
+	char *io_regulator;
+	char *analog_regulator;
+	char *gpo_regulator;
+	u32 mclk;
+	u32 csi;
+};
+
+struct mxc_keypad_platform_data {
+	u16 rowmax;
+	u16 colmax;
+	u32 irq;
+	u16 delay;
+	u16 learning;
+	u16 *matrix;
+};
+
+#ifdef CONFIG_ARCH_MX51
+enum mxc_cpu_pwr_mode {
+	WAIT_CLOCKED,		/* wfi only */
+	WAIT_UNCLOCKED,		/* WAIT */
+	WAIT_UNCLOCKED_POWER_OFF,	/* WAIT + SRPG */
+	STOP_POWER_ON,		/* just STOP */
+	STOP_POWER_OFF,		/* STOP + SRPG */
+};
+
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
+int tzic_enable_wake(int is_idle);
+void gpio_activate_audio_ports(void);
+void gpio_inactivate_audio_ports(void);
+
+#endif
+
+void mxc_pg_enable(struct platform_device *pdev);
+void mxc_pg_disable(struct platform_device *pdev);
+
+#endif
+
 /* clean up all things that are not used */
 #ifndef CONFIG_ARCH_MX3
 # define cpu_is_mx31() (0)
@@ -33,4 +354,170 @@
 # define cpu_is_mx27() (0)
 #endif
 
+#if !defined(CONFIG_ARCH_REQUIRE_GPIOLIB) || defined(CONFIG_ARCH_MX51)
+#define IOMUX_TO_GPIO(pin)      ((((unsigned int)pin >> MUX_IO_P) * \
+			GPIO_NUM_PIN) + ((pin >> MUX_IO_I) & \
+				((1 << (MUX_IO_P - MUX_IO_I)) - 1)))
+
+#define IOMUX_TO_IRQ(pin)       (MXC_GPIO_INT_BASE + IOMUX_TO_GPIO(pin))
+#endif
+
+#define GPIO_TO_PORT(n)         (n / GPIO_NUM_PIN)
+#define GPIO_TO_INDEX(n)        (n % GPIO_NUM_PIN)
+
+/*
+ *****************************************
+ * EPIT  Register definitions            *
+ *****************************************
+ */
+#ifndef EPIT1_AP_BASE_ADDR
+#define EPIT1_AP_BASE_ADDR      EPIT1_BASE_ADDR
+#endif
+
+#define MXC_EPIT_EPITCR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x00))
+#define MXC_EPIT_EPITSR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x04))
+#define MXC_EPIT_EPITLR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x08))
+#define MXC_EPIT_EPITCMPR       (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x0C))
+#define MXC_EPIT_EPITCNR        (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x10))
+
+/*
+ *****************************************
+ * GPT  Register definitions             *
+ *****************************************
+ */
+#define MXC_GPT_GPTCR       IO_ADDRESS(GPT1_BASE_ADDR + 0x00)
+#define MXC_GPT_GPTPR       IO_ADDRESS(GPT1_BASE_ADDR + 0x04)
+#define MXC_GPT_GPTSR       IO_ADDRESS(GPT1_BASE_ADDR + 0x08)
+#define MXC_GPT_GPTIR       IO_ADDRESS(GPT1_BASE_ADDR + 0x0C)
+#define MXC_GPT_GPTOCR1     IO_ADDRESS(GPT1_BASE_ADDR + 0x10)
+#define MXC_GPT_GPTOCR2     IO_ADDRESS(GPT1_BASE_ADDR + 0x14)
+#define MXC_GPT_GPTOCR3     IO_ADDRESS(GPT1_BASE_ADDR + 0x18)
+#define MXC_GPT_GPTICR1     IO_ADDRESS(GPT1_BASE_ADDR + 0x1C)
+#define MXC_GPT_GPTICR2     IO_ADDRESS(GPT1_BASE_ADDR + 0x20)
+#define MXC_GPT_GPTCNT      IO_ADDRESS(GPT1_BASE_ADDR + 0x24)
+
+/* GPT Control register bit definitions */
+#define GPTCR_FO3           (1 << 31)
+#define GPTCR_FO2           (1 << 30)
+#define GPTCR_FO1           (1 << 29)
+
+#define GPTCR_OM3_SHIFT         26
+#define GPTCR_OM3_MASK          (7 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_DISCONNECTED      (0 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_TOGGLE        (1 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_CLEAR         (2 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_SET           (3 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_GENERATE_LOW      (7 << GPTCR_OM3_SHIFT)
+
+#define GPTCR_OM2_SHIFT         23
+#define GPTCR_OM2_MASK          (7 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_DISCONNECTED      (0 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_TOGGLE        (1 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_CLEAR         (2 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_SET           (3 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_GENERATE_LOW      (7 << GPTCR_OM2_SHIFT)
+
+#define GPTCR_OM1_SHIFT         20
+#define GPTCR_OM1_MASK          (7 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_DISCONNECTED      (0 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_TOGGLE        (1 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_CLEAR         (2 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_SET           (3 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_GENERATE_LOW      (7 << GPTCR_OM1_SHIFT)
+
+#define GPTCR_IM2_SHIFT         18
+#define GPTCR_IM2_MASK          (3 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_DISABLE   (0 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_RISING    (1 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_FALLING   (2 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_BOTH      (3 << GPTCR_IM2_SHIFT)
+
+#define GPTCR_IM1_SHIFT         16
+#define GPTCR_IM1_MASK          (3 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_DISABLE   (0 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_RISING    (1 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_FALLING   (2 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_BOTH      (3 << GPTCR_IM1_SHIFT)
+
+#define GPTCR_SWR           (1 << 15)
+#define GPTCR_FRR           (1 << 9)
+
+#define GPTCR_CLKSRC_SHIFT      6
+#define GPTCR_CLKSRC_MASK       (7 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_NOCLOCK        (0 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_HIGHFREQ       (2 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLKIN      (3 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLK32K     (7 << GPTCR_CLKSRC_SHIFT)
+
+#define GPTCR_STOPEN            (1 << 5)
+#define GPTCR_DOZEN         (1 << 4)
+#define GPTCR_WAITEN            (1 << 3)
+#define GPTCR_DBGEN         (1 << 2)
+
+#define GPTCR_ENMOD         (1 << 1)
+#define GPTCR_ENABLE            (1 << 0)
+
+#define GPTSR_OF1           (1 << 0)
+#define GPTSR_OF2           (1 << 1)
+#define GPTSR_OF3           (1 << 2)
+#define GPTSR_IF1           (1 << 3)
+#define GPTSR_IF2           (1 << 4)
+#define GPTSR_ROV           (1 << 5)
+
+#define GPTIR_OF1IE         GPTSR_OF1
+#define GPTIR_OF2IE         GPTSR_OF2
+#define GPTIR_OF3IE         GPTSR_OF3
+#define GPTIR_IF1IE         GPTSR_IF1
+#define GPTIR_IF2IE         GPTSR_IF2
+#define GPTIR_ROVIE         GPTSR_ROV
+
+/* DMA driver defines */
+#define MXC_IDE_DMA_WATERMARK   32      /* DMA watermark level in bytes */
+#define MXC_IDE_DMA_BD_NR       (512/3/4)       /* Number of BDs per channel */
+
+/* Since AVIC vector registers are NOT used, we reserve some for various
+ * purposes. */
+#define AVIC_VEC_0      0x100   /* For WFI workaround. */
+#define AVIC_VECTOR     IO_ADDRESS(AVIC_BASE_ADDR + AVIC_VEC_0)
+#define MXC_WFI_ENABLE      0x00000008
+
+/*!
+ * Interrupt Number for ARM11 PMU
+ */
+#define ARM11_PMU_IRQ           INT_EVTMON
+
+#ifndef __ASSEMBLY__
+struct cpu_wp {
+	u32 pll_reg;
+	u32 pll_rate;
+	u32 cpu_rate;
+	u32 pdr0_reg;
+	u32 pdf;
+	u32 mfi;
+	u32 mfd;
+	u32 mfn;
+#ifdef CONFIG_ARCH_MX51
+	u32 cpu_voltage;
+	u32 cpu_podf;
+#endif
+};
+
+#ifndef CONFIG_ARCH_MX51
+struct cpu_wp *get_cpu_wp(int *wp);
+#endif
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_suspend(void);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_resume(void);
+
+
+#endif
 #endif /*  __ASM_ARCH_MXC_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_timer.h b/arch/arm/plat-mxc/include/mach/mxc_timer.h
index 130aebf..e93f53d 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_timer.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_timer.h
@@ -105,7 +105,7 @@ static void gpt_irq_acknowledge(void)
 }
 #endif /* CONFIG_ARCH_MX2 */
 
-#ifdef CONFIG_ARCH_MX3
+#if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX5)
 #define TIMER_BASE		IO_ADDRESS(GPT1_BASE_ADDR)
 #define TIMER_INTERRUPT		MXC_INT_GPT
 
@@ -144,7 +144,7 @@ static inline void gpt_irq_acknowledge(void)
 {
 	__raw_writel(TSTAT_OF1, TIMER_BASE + MXC_TSTAT);
 }
-#endif /* CONFIG_ARCH_MX3 */
+#endif /* CONFIG_ARCH_MX3 || CONFIG_ARCH_MX5 */
 
 #define TCTL_SWR		(1<<15)
 #define TCTL_CC			(1<<10)
diff --git a/arch/arm/plat-mxc/include/mach/sdma.h b/arch/arm/plat-mxc/include/mach/sdma.h
new file mode 100644
index 0000000..a1e7cd5
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdma.h
@@ -0,0 +1,517 @@
+
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SDMA_H__
+#define __ASM_ARCH_MXC_SDMA_H__
+
+/*!
+ * @defgroup SDMA Smart Direct Memory Access (SDMA) Driver
+ */
+
+/*!
+ * @file arch-mxc/sdma.h
+ *
+ * @brief This file contains the SDMA API declarations.
+ *
+ * SDMA is responsible on moving data
+ * between peripherals and memories (MCU, EMI and DSP).
+ *
+ * @ingroup SDMA
+ */
+
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#include <mach/hardware.h>
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+/*!
+ * This defines maximum number of DMA channels
+ */
+#ifdef CONFIG_MXC_SDMA_API
+#define MAX_DMA_CHANNELS 32
+#define MAX_BD_NUMBER    16
+#define MXC_SDMA_DEFAULT_PRIORITY 1
+#define MXC_SDMA_MIN_PRIORITY 1
+#define MXC_SDMA_MAX_PRIORITY 7
+#else
+#define MAX_DMA_CHANNELS 0
+#endif
+
+#define MXC_FIFO_MEM_DEST_FIXED   0x1
+#define MXC_FIFO_MEM_SRC_FIXED    0x2
+
+/*!
+ * This enumerates  transfer types
+ */
+typedef enum __sdma_transferT{
+	emi_2_per = 0,		/*!< EMI memory to peripheral */
+	emi_2_int,		/*!< EMI memory to internal RAM */
+	emi_2_emi,		/*!< EMI memory to EMI memory */
+	emi_2_dsp,		/*!< EMI memory to DSP memory */
+	per_2_int,		/*!< Peripheral to internal RAM */
+	per_2_emi,		/*!< Peripheral to internal EMI memory */
+	per_2_dsp,		/*!< Peripheral to DSP memory */
+#ifdef MXC_SDMA_V2
+	per_2_per,              /*!< Peripheral to Peripheral */
+#endif
+	int_2_per,		/*!< Internal RAM to peripheral */
+	int_2_int,		/*!< Internal RAM to Internal RAM */
+	int_2_emi,		/*!< Internal RAM to EMI memory */
+	int_2_dsp,		/*!< Internal RAM to DSP memory */
+	dsp_2_per,		/*!< DSP memory to peripheral */
+	dsp_2_int,		/*!< DSP memory to internal RAM */
+	dsp_2_emi,		/*!< DSP memory to EMI memory */
+	dsp_2_dsp,		/*!< DSP memory to DSP memory */
+	emi_2_dsp_loop,		/*!< EMI memory to DSP memory loopback */
+	dsp_2_emi_loop,		/*!< DSP memory to EMI memory loopback */
+	dvfs_pll,		/*!< DVFS script with PLL change       */
+	dvfs_pdr		/*!< DVFS script without PLL change    */
+} sdma_transferT;
+
+/*!
+ * This enumerates peripheral types
+ */
+typedef enum __sdma_periphT{
+	SSI,			/*!< MCU domain SSI */
+	SSI_SP,			/*!< Shared SSI */
+	MMC,			/*!< MMC */
+	SDHC,			/*!< SDHC */
+	UART,			/*!< MCU domain UART */
+	UART_SP,		/*!< Shared UART */
+	FIRI,			/*!< FIRI */
+	CSPI,			/*!< MCU domain CSPI */
+	CSPI_SP,		/*!< Shared CSPI */
+	SIM,			/*!< SIM */
+	ATA,			/*!< ATA */
+	CCM,			/*!< CCM */
+	EXT,			/*!< External peripheral */
+	MSHC,			/*!< Memory Stick Host Controller */
+#ifdef MXC_SDMA_V2
+	MSHC_SP,                /*!< Shared Memory Stick Host Controller */
+#endif
+	DSP,			/*!< DSP */
+	MEMORY,                 /*!< Memory */
+#ifdef MXC_SDMA_V2
+	FIFO_MEMORY,            /*!< FIFO type Memory */
+	SPDIF,                  /*!< SPDIF */
+	IPU_MEMORY,             /*!< IPU Memory */
+	ASRC,                   /*!< ASRC */
+	ESAI,                   /*!< ESAI */
+#endif
+} sdma_periphT;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines SDMA access data size
+ */
+#define TRANSFER_32BIT      0x00
+#define TRANSFER_8BIT       0x01
+#define TRANSFER_16BIT      0x02
+#define TRANSFER_24BIT      0x03
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+
+/*!
+ * This defines SDMA interrupt callback function prototype.
+ */
+typedef void (*dma_callback_t) (void *arg);
+
+/*!
+ * Structure containing sdma channel parameters.
+ */
+typedef struct __dma_channel_params{
+	__u32 watermark_level;	/*!< Lower/upper threshold that
+							 *   triggers SDMA event
+							 */
+	__u32 per_address;	/*!< Peripheral source/destination
+						 *   physical address
+						 */
+	sdma_periphT peripheral_type;	/*!< Peripheral type */
+	sdma_transferT transfer_type;	/*!< Transfer type   */
+	int event_id;		/*!< Event number,
+						 * needed by all channels
+						 * that started by peripherals
+						 * dma request (per_2_*,*_2_per)
+						 * Not used for memory and DSP
+						 * transfers.
+						 */
+	int event_id2;		/*!< Second event number,
+						 *   used in ATA scripts only.
+						 */
+	int bd_number;		/*!< Buffer descriptors number.
+						 *   If not set, single buffer
+						 *   descriptor will be used.
+						 */
+	dma_callback_t callback;	/*!   callback function            */
+	void *arg;		/*!   callback argument            */
+	unsigned long word_size:8;	/*!< SDMA data access word size    */
+} dma_channel_params;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct __dma_request{
+	/*!   physical source memory address        */
+	__u8 *sourceAddr;
+	/*!   physical destination memory address   */
+	__u8 *destAddr;
+	/*!   amount of data to transfer,
+	 * updated during mxc_dma_get_config
+	 */
+	__u16 count;
+	/*!< DONE bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config
+	 * 0 - means the BD is done and closed by SDMA
+	 * 1 - means the BD is still being processed by SDMA
+	 */
+	int bd_done;
+	/*!< CONT bit of the buffer descriptor,
+	 * set it if full multi-buffer descriptor mechanism
+	 * required.
+	 */
+	int bd_cont;
+	/*!< ERROR bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config.
+	 * If it is set - there was an error during BD processing.
+	 */
+	int bd_error;
+} dma_request_t;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct __sdma_script_start_addrs{
+	/*! address of ap_2_ap script */
+	int mxc_sdma_ap_2_ap_addr;
+	/*! address of ap_2_bp script */
+	int mxc_sdma_ap_2_bp_addr;
+#ifdef MXC_SDMA_V2
+	/*! address of ap_2_ap_fixed script */
+	int mxc_sdma_ap_2_ap_fixed_addr;
+#endif
+	/*! address of bp_2_ap script */
+	int mxc_sdma_bp_2_ap_addr;
+	/*! address of loopback_on_dsp_side script */
+	int mxc_sdma_loopback_on_dsp_side_addr;
+	/*! address of mcu_interrupt_only script */
+	int mxc_sdma_mcu_interrupt_only_addr;
+
+	/*! address of firi_2_per script */
+	int mxc_sdma_firi_2_per_addr;
+	/*! address of firi_2_mcu script */
+	int mxc_sdma_firi_2_mcu_addr;
+	/*! address of per_2_firi script */
+	int mxc_sdma_per_2_firi_addr;
+	/*! address of mcu_2_firi script */
+	int mxc_sdma_mcu_2_firi_addr;
+
+	/*! address of uart_2_per script */
+	int mxc_sdma_uart_2_per_addr;
+	/*! address of uart_2_mcu script */
+	int mxc_sdma_uart_2_mcu_addr;
+	/*! address of per_2_app script */
+	int mxc_sdma_per_2_app_addr;
+	/*! address of mcu_2_app script */
+	int mxc_sdma_mcu_2_app_addr;
+#ifdef MXC_SDMA_V2
+	/*! address of per_2_per script */
+	int mxc_sdma_per_2_per_addr;
+#endif
+	/*! address of uartsh_2_per script */
+	int mxc_sdma_uartsh_2_per_addr;
+	/*! address of uartsh_2_mcu script */
+	int mxc_sdma_uartsh_2_mcu_addr;
+	/*! address of per_2_shp script */
+	int mxc_sdma_per_2_shp_addr;
+	/*! address of mcu_2_shp script */
+	int mxc_sdma_mcu_2_shp_addr;
+
+	/*! address of ata_2_mcu script */
+	int mxc_sdma_ata_2_mcu_addr;
+	/*! address of mcu_2_ata script */
+	int mxc_sdma_mcu_2_ata_addr;
+
+	/*! address of app_2_per script */
+	int mxc_sdma_app_2_per_addr;
+	/*! address of app_2_mcu script */
+	int mxc_sdma_app_2_mcu_addr;
+	/*! address of shp_2_per script */
+	int mxc_sdma_shp_2_per_addr;
+	/*! address of shp_2_mcu script */
+	int mxc_sdma_shp_2_mcu_addr;
+
+	/*! address of mshc_2_mcu script */
+	int mxc_sdma_mshc_2_mcu_addr;
+	/*! address of mcu_2_mshc script */
+	int mxc_sdma_mcu_2_mshc_addr;
+#ifdef MXC_SDMA_V2
+	/*! address of spdif_2_mcu script */
+	int mxc_sdma_spdif_2_mcu_addr;
+	/*! address of mcu_2_spdif script */
+	int mxc_sdma_mcu_2_spdif_addr;
+	/*! address of asrc_2_mcu script */
+	int mxc_sdma_asrc_2_mcu_addr;
+	/*! address of ext_mem_2_ipu script */
+	int mxc_sdma_ext_mem_2_ipu_addr;
+	/*! address of descrambler script */
+	int mxc_sdma_descrambler_addr;
+#endif
+	/*! address of dptc_dvfs script */
+	int mxc_sdma_dptc_dvfs_addr;
+
+	int mxc_sdma_utra_addr;
+
+	/*! address where ram code starts */
+	int mxc_sdma_ram_code_start_addr;
+	/*! size of the ram code */
+	int mxc_sdma_ram_code_size;
+	/*! RAM image address */
+	unsigned short *mxc_sdma_start_addr;
+} sdma_script_start_addrs;
+
+/*! Structure to store the initialized dma_channel parameters */
+typedef struct __mxc_sdma_channel_params {
+	/*! Channel params */
+	dma_channel_params chnl_params;
+	/*! Channel type (static channel number or dynamic channel) */
+	unsigned int channel_num;
+	/*! Channel priority [0x1(lowest) - 0x7(highest)] */
+	unsigned int chnl_priority;
+} mxc_sdma_channel_params_t;
+
+/*! Private SDMA data structure */
+typedef struct __mxc_dma_channel_private {
+	/*! ID of the buffer that was processed */
+	unsigned int buf_tail;
+	/*! Tasklet for the channel */
+	struct tasklet_struct chnl_tasklet;
+	/*! Flag indicates if interrupt is required after every BD transfer */
+	int intr_after_every_bd;
+} mxc_dma_channel_private_t;
+
+#ifdef CONFIG_ARCH_MX51
+void mx51_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr);
+#endif
+/*!
+ * Setup channel according to parameters.
+ * Must be called once after mxc_request_dma()
+ *
+ * @param   channel           channel number
+ * @param   p                 channel parameters pointer
+ * @return  0 on success, error code on fail
+ */
+int mxc_dma_setup_channel(int channel, dma_channel_params *p);
+
+/*!
+ * Setup the channel priority. This can be used to change the default priority
+ * for the channel.
+ *
+ * @param   channel           channel number
+ * @param   priority          priority to be set for the channel
+ *
+ * @return  0 on success, error code on failure
+ */
+int mxc_dma_set_channel_priority(unsigned int channel, unsigned int priority);
+
+/*!
+ * Allocates dma channel.
+ * If channel's value is 0, then the function allocates a free channel
+ * dynamically and sets its value to channel.
+ * Else allocates requested channel if it is free.
+ * If the channel is busy or no free channels (in dynamic allocation)
+ * -EBUSY returned.
+ *
+ * @param   channel           pointer to channel number
+ * @param   devicename        device name
+ * @return  0 on success, error code on fail
+ */
+int mxc_request_dma(int *channel, const char *devicename);
+
+/*!
+ * Configures request parameters. Can be called multiple times after
+ * mxc_request_dma() and mxc_dma_setup_channel().
+ *
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to set
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index);
+
+/*!
+ * Returns request parameters.
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to get
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index);
+
+/*!
+ * This function is used by MXC IPC's write_ex2. It passes the a pointer to the
+ * data control structure to iapi_write_ipcv2()
+ *
+ * @param channel  SDMA channel number
+ * @param ctrl_ptr Data Control structure pointer
+ */
+int mxc_sdma_write_ipcv2(int channel, void *ctrl_ptr);
+
+/*!
+ * This function is used by MXC IPC's read_ex2. It passes the a pointer to the
+ * data control structure to iapi_read_ipcv2()
+ *
+ * @param channel   SDMA channel number
+ * @param ctrl_ptr  Data Control structure pointer
+ */
+int mxc_sdma_read_ipcv2(int channel, void *ctrl_ptr);
+
+/*!
+ * Starts dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_start(int channel);
+
+/*!
+ * Stops dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_stop(int channel);
+
+/*!
+ * Frees dma channel.
+ *
+ * @param   channel           channel number
+ */
+void mxc_free_dma(int channel);
+
+/*!
+ * Sets callback function. Used with standard dma api
+ *  for supporting interrupts
+ *
+ * @param   channel           channel number
+ * @param   callback          callback function pointer
+ * @param   arg               argument for callback function
+ */
+void mxc_dma_set_callback(int channel, dma_callback_t callback, void *arg);
+
+/*!
+ * Allocates uncachable buffer. Uses hash table.
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_malloc(size_t size);
+
+#ifdef CONFIG_SDMA_IRAM
+/*!
+ * Allocates uncachable buffer from IRAM..
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_iram_malloc(size_t size);
+#endif                         /*CONFIG_SDMA_IRAM */
+
+/*!
+ * Frees uncachable buffer. Uses hash table.
+ */
+void sdma_free(void *buf);
+
+/*!
+ * Converts virtual to physical address. Uses hash table.
+ *
+ * @param   buf  virtual address pointer
+ * @return  physical address value
+ */
+unsigned long sdma_virt_to_phys(void *buf);
+
+/*!
+ * Converts physical to virtual address. Uses hash table.
+ *
+ * @param   buf  physical address value
+ * @return  virtual address pointer
+ */
+void *sdma_phys_to_virt(unsigned long buf);
+
+/*!
+ * Configures the BD_INTR bit on a buffer descriptor parameters.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ * @param   bd_intr           flag to set or clear the BD_INTR bit
+ */
+void mxc_dma_set_bd_intr(int channel, int bd_index, int bd_intr);
+
+/*!
+ * Gets the BD_INTR bit on a buffer descriptor.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ *
+ * @return returns the BD_INTR bit status
+ */
+int mxc_dma_get_bd_intr(int channel, int bd_index);
+
+/*!
+ * Stop the current transfer
+ *
+ * @param   channel           channel number
+ * @param   buffer_number     number of buffers (beginning with 0),
+ *                            whose done bits should be reset to 0
+ */
+int mxc_dma_reset(int channel, int buffer_number);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+		channel_id);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl);
+
+/*!
+ * Initializes SDMA driver
+ */
+int __init sdma_init(void);
+
+#define DEFAULT_ERR     1
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/sdma_script_code.h b/arch/arm/plat-mxc/include/mach/sdma_script_code.h
new file mode 100644
index 0000000..49a2d46
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdma_script_code.h
@@ -0,0 +1,581 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+ * Following define start address of start script
+ */
+#define start_ADDR	0
+/*!
+ * Following define size of start script
+ */
+#define start_SIZE	21
+
+/*!
+ * Following define start address of core script
+ */
+#define core_ADDR	80
+/*!
+ * Following define size of core script
+ */
+#define core_SIZE	152
+
+/*!
+ * Following define start address of common script
+ */
+#define common_ADDR	232
+/*!
+ * Following define size of common script
+ */
+#define common_SIZE	191
+
+/*!
+ * Following define start address of burst_copy script
+ */
+#define burst_copy_ADDR	423
+/*!
+ * Following define size of burst_copy script
+ */
+#define burst_copy_SIZE	87
+
+/*!
+ * Following define start address of dsp_2_burst script
+ */
+#define dsp_2_burst_ADDR	510
+/*!
+ * Following define size of dsp_2_burst script
+ */
+#define dsp_2_burst_SIZE	24
+
+/*!
+ * Following define start address of burst_2_dsp script
+ */
+#define burst_2_dsp_ADDR	534
+/*!
+ * Following define size of burst_2_dsp script
+ */
+#define burst_2_dsp_SIZE	24
+
+/*!
+ * Following define start address of dsp_copy script
+ */
+#define dsp_copy_ADDR	558
+/*!
+ * Following define size of dsp_copy script
+ */
+#define dsp_copy_SIZE	86
+
+/*!
+ * Following define start address of mcu_2_mcu script
+ */
+#define mcu_2_mcu_ADDR	644
+/*!
+ * Following define size of mcu_2_mcu script
+ */
+#define mcu_2_mcu_SIZE	79
+
+/*!
+ * Following define start address of mcu_2_per script
+ */
+#define mcu_2_per_ADDR	723
+/*!
+ * Following define size of mcu_2_per script
+ */
+#define mcu_2_per_SIZE	88
+
+/*!
+ * Following define start address of test script
+ */
+#define test_ADDR	811
+/*!
+ * Following define size of test script
+ */
+#define test_SIZE	63
+
+/*!
+ * Following define start address of mcu_2_dsp script
+ */
+#define mcu_2_dsp_ADDR	874
+/*!
+ * Following define size of mcu_2_dsp script
+ */
+#define mcu_2_dsp_SIZE	30
+
+/*!
+ * Following define start address of mcu_2_dsp_2buf script
+ */
+#define mcu_2_dsp_2buf_ADDR	904
+/*!
+ * Following define size of mcu_2_dsp_2buf script
+ */
+#define mcu_2_dsp_2buf_SIZE	113
+
+/*!
+ * Following define start address of dsp_2_mcu script
+ */
+#define dsp_2_mcu_ADDR	1017
+/*!
+ * Following define size of dsp_2_mcu script
+ */
+#define dsp_2_mcu_SIZE	30
+
+/*!
+ * Following define start address of dsp_2_mcu_2buf script
+ */
+#define dsp_2_mcu_2buf_ADDR	1047
+/*!
+ * Following define size of dsp_2_mcu_2buf script
+ */
+#define dsp_2_mcu_2buf_SIZE	113
+
+/*!
+ * Following define start address of dsp_2_dsp script
+ */
+#define dsp_2_dsp_ADDR	1160
+/*!
+ * Following define size of dsp_2_dsp script
+ */
+#define dsp_2_dsp_SIZE	64
+
+/*!
+ * Following define start address of per_2_mcu script
+ */
+#define per_2_mcu_ADDR	1224
+/*!
+ * Following define size of per_2_mcu script
+ */
+#define per_2_mcu_SIZE	121
+
+/*!
+ * Following define start address of dsp_2_per_2buf script
+ */
+#define dsp_2_per_2buf_ADDR	1345
+/*!
+ * Following define size of dsp_2_per_2buf script
+ */
+#define dsp_2_per_2buf_SIZE	164
+
+/*!
+ * Following define start address of per_2_dsp_2buf script
+ */
+#define per_2_dsp_2buf_ADDR	1509
+/*!
+ * Following define size of per_2_dsp_2buf script
+ */
+#define per_2_dsp_2buf_SIZE	168
+
+/*!
+ * Following define start address of per_2_per script
+ */
+#define per_2_per_ADDR	1677
+/*!
+ * Following define size of per_2_per script
+ */
+#define per_2_per_SIZE	67
+
+/*!
+ * Following define start address of error_dsp script
+ */
+#define error_dsp_ADDR	1744
+/*!
+ * Following define size of error_dsp script
+ */
+#define error_dsp_SIZE	34
+
+/*!
+ * Following define start address of ap_2_ap script
+ */
+#define ap_2_ap_ADDR	6144
+/*!
+ * Following define size of ap_2_ap script
+ */
+#define ap_2_ap_SIZE	294
+
+/*!
+ * Following define start address of app_2_mcu script
+ */
+#define app_2_mcu_ADDR	6438
+/*!
+ * Following define size of app_2_mcu script
+ */
+#define app_2_mcu_SIZE	101
+
+/*!
+ * Following define start address of ata_2_mcu script
+ */
+#define ata_2_mcu_ADDR	6539
+/*!
+ * Following define size of ata_2_mcu script
+ */
+#define ata_2_mcu_SIZE	110
+
+/*!
+ * Following define start address of dptc_dvfs script
+ */
+#define dptc_dvfs_ADDR	6649
+/*!
+ * Following define size of dptc_dvfs script
+ */
+#define dptc_dvfs_SIZE	274
+
+/*!
+ * Following define start address of error script
+ */
+#define error_ADDR	6923
+/*!
+ * Following define size of error script
+ */
+#define error_SIZE	73
+
+/*!
+ * Following define start address of firi_2_mcu script
+ */
+#define firi_2_mcu_ADDR	6996
+/*!
+ * Following define size of firi_2_mcu script
+ */
+#define firi_2_mcu_SIZE	114
+
+/*!
+ * Following define start address of mcu_2_app script
+ */
+#define mcu_2_app_ADDR	7110
+/*!
+ * Following define size of mcu_2_app script
+ */
+#define mcu_2_app_SIZE	127
+
+/*!
+ * Following define start address of mcu_2_ata script
+ */
+#define mcu_2_ata_ADDR	7237
+/*!
+ * Following define size of mcu_2_ata script
+ */
+#define mcu_2_ata_SIZE	87
+
+/*!
+ * Following define start address of mcu_2_firi script
+ */
+#define mcu_2_firi_ADDR	7324
+/*!
+ * Following define size of mcu_2_firi script
+ */
+#define mcu_2_firi_SIZE	77
+
+/*!
+ * Following define start address of mcu_2_mshc script
+ */
+#define mcu_2_mshc_ADDR	7401
+/*!
+ * Following define size of mcu_2_mshc script
+ */
+#define mcu_2_mshc_SIZE	48
+
+/*!
+ * Following define start address of mcu_2_shp script
+ */
+#define mcu_2_shp_ADDR	7449
+/*!
+ * Following define size of mcu_2_shp script
+ */
+#define mcu_2_shp_SIZE	123
+
+/*!
+ * Following define start address of mshc_2_mcu script
+ */
+#define mshc_2_mcu_ADDR	7572
+/*!
+ * Following define size of mshc_2_mcu script
+ */
+#define mshc_2_mcu_SIZE	60
+
+/*!
+ * Following define start address of shp_2_mcu script
+ */
+#define shp_2_mcu_ADDR	7632
+/*!
+ * Following define size of shp_2_mcu script
+ */
+#define shp_2_mcu_SIZE	101
+
+/*!
+ * Following define start address of uart_2_mcu script
+ */
+#define uart_2_mcu_ADDR	7733
+/*!
+ * Following define size of uart_2_mcu script
+ */
+#define uart_2_mcu_SIZE	105
+
+/*!
+ * Following define start address of uartsh_2_mcu script
+ */
+#define uartsh_2_mcu_ADDR	7838
+/*!
+ * Following define size of uartsh_2_mcu script
+ */
+#define uartsh_2_mcu_SIZE	98
+
+/*!
+ * Following define the start address of sdma ram
+ */
+
+#define RAM_CODE_START_ADDR	6144
+/*!
+ * Following define the size of sdma ram
+ */
+#define RAM_CODE_SIZE	1792
+
+/*!
+ * This function returns buffer that holds the image of SDMA RAM.
+ * This is required to start on a 4-byte aligned boundary on some platforms
+ * for SDMA to work properly.
+ *
+ * @return pointer to buffer that holds the image of SDMA RAM
+ */
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+	const
+#endif
+	static short sdma_code[] = {
+		0xc0ec, 0x7d59, 0x0970, 0x0111, 0x5111, 0x5ad1, 0x5bd9, 0xc0fe,
+		0x5ce1, 0x7d02, 0x0200, 0x9806, 0x08ff, 0x0011, 0x28ff, 0x00bc,
+		0x05df, 0x7d4b, 0x06df, 0x7d2f, 0x6dc5, 0x6ed5, 0x5ef1, 0x0288,
+		0xd81a, 0x9854, 0x0b04, 0x00d3, 0x7d20, 0x06a5, 0x3e03, 0x3d03,
+		0x03a5, 0x3b03, 0x008b, 0x058b, 0x7802, 0x63d8, 0x0000, 0x7e72,
+		0x63ff, 0x7e70, 0x02a5, 0x008a, 0x4e00, 0x7d01, 0x983d, 0x6dcf,
+		0x6edf, 0x0015, 0x0015, 0x7802, 0x63d8, 0x0000, 0x7e63, 0x63ff,
+		0x7e61, 0x3a03, 0x008a, 0x6dcd, 0x6edd, 0x7801, 0x63d8, 0x7e5a,
+		0x63ff, 0x7e58, 0x0006, 0x6dc5, 0x6e07, 0x5ef1, 0x0288, 0xd8f7,
+		0x7e02, 0x7f04, 0x9854, 0x0007, 0x68cc, 0x6b28, 0x54e1, 0x0089,
+		0xdb13, 0x0188, 0x5ce1, 0x9854, 0x52d1, 0x53d9, 0x54e1, 0xc10d,
+		0x7dad, 0x0200, 0x9800, 0x0200, 0x9800, 0x06df, 0x7d06, 0x6d23,
+		0x6ed5, 0x5ef1, 0x0288, 0xd8cd, 0x9854, 0x5ef1, 0x6e07, 0x6d03,
+		0x0b04, 0x00d3, 0x7d59, 0x06a5, 0x3e03, 0x3d03, 0x4d00, 0x7d09,
+		0x03a5, 0x00a3, 0x0588, 0x008b, 0xd8c9, 0x7ed8, 0x620c, 0x7ed6,
+		0x008d, 0x4e00, 0x7c25, 0x0a20, 0x00da, 0x7c22, 0x6503, 0x3d1f,
+		0x02a5, 0x00a2, 0x0215, 0x0215, 0x6a18, 0x6a28, 0x7fc7, 0x0a20,
+		0x0b08, 0x00da, 0x7c06, 0x6b18, 0x6b28, 0x7fc0, 0x0000, 0x2020,
+		0x9889, 0x0688, 0x0015, 0x0015, 0x6818, 0x6828, 0x7fb7, 0x98c2,
+		0x0007, 0x6a0c, 0x54e1, 0x0089, 0xdb0f, 0x0188, 0x5ce1, 0x9854,
+		0x0b04, 0x00d3, 0x7d21, 0x0389, 0x1b12, 0x048b, 0x0688, 0x0015,
+		0x0015, 0x0588, 0x038c, 0x0a08, 0x05da, 0x008d, 0x7c01, 0x008a,
+		0x05a0, 0x7803, 0x620b, 0x5a03, 0x1b01, 0x7e98, 0x008b, 0x00a4,
+		0x038c, 0x7803, 0x5203, 0x6a0b, 0x1b01, 0x6a28, 0x7f8f, 0x0000,
+		0x4d00, 0x7ce8, 0x008e, 0x3803, 0xd8c9, 0x7e88, 0x620c, 0x7e86,
+		0x9854, 0x7802, 0x6209, 0x6a29, 0x0006, 0x3e03, 0x4e00, 0x7d11,
+		0x0b04, 0x03a6, 0x02db, 0x7d01, 0x038a, 0x02a3, 0x048a, 0x008b,
+		0x7802, 0x6329, 0x6bc8, 0x7ebc, 0x63c8, 0x7ebc, 0x008c, 0x4800,
+		0x7d15, 0x0488, 0x0015, 0x0015, 0x6edf, 0x7803, 0x632b, 0x6bc8,
+		0x0000, 0x7eae, 0x63c8, 0x7eae, 0x008c, 0x3803, 0x6edd, 0x7803,
+		0x6329, 0x6bc8, 0x0000, 0x7ea4, 0x63c8, 0x7ea4, 0x0006, 0x3d03,
+		0x4d00, 0x7d0e, 0x0b04, 0x03a5, 0x02db, 0x7d01, 0x038a, 0x02a3,
+		0x048a, 0x008b, 0x7802, 0x63c8, 0x6b09, 0x7e1e, 0x7f1e, 0x008c,
+		0x0488, 0x0015, 0x0015, 0x6dcf, 0x0288, 0x008a, 0x0d08, 0x02dd,
+		0x7c01, 0x008d, 0x7802, 0x63c8, 0x6b0b, 0x7e0e, 0x6b28, 0x7f0d,
+		0x0000, 0x02dd, 0x7c02, 0x2208, 0x990d, 0x008c, 0x3803, 0x65c0,
+		0x6dc5, 0x7802, 0x63c8, 0x6b09, 0x6b28, 0x0006, 0x0870, 0x0011,
+		0x5010, 0xc0ec, 0x7d5e, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+		0x7d02, 0x0200, 0x992c, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511,
+		0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0b70, 0x0311, 0x522b, 0x5313,
+		0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x993c, 0x008f,
+		0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210,
+		0x4a00, 0x7d1c, 0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311,
+		0x53eb, 0x62c8, 0x7e24, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09,
+		0x7f1e, 0x0212, 0x6a09, 0x7f1b, 0x0212, 0x6a09, 0x7f18, 0x2003,
+		0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313, 0x997d, 0x0015, 0x0015,
+		0x7802, 0x62c8, 0x6a0b, 0x997c, 0x0015, 0x7802, 0x62c8, 0x6a0a,
+		0x997c, 0x7802, 0x62c8, 0x6a09, 0x7c02, 0x0000, 0x993a, 0xdb13,
+		0x6a28, 0x7ffd, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7da5, 0x0200,
+		0x992c, 0x0200, 0x9929, 0xc19d, 0xc0ec, 0x7d69, 0x0c70, 0x0411,
+		0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02,
+		0x0200, 0x9994, 0x6d07, 0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff,
+		0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70, 0x0211, 0x552a,
+		0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9, 0x4d00, 0x7c13,
+		0x6928, 0x7f2d, 0x0400, 0x99a5, 0x008f, 0x0015, 0x04d8, 0x7d01,
+		0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e29, 0x6d28,
+		0x7f1e, 0x0000, 0x99a3, 0x1e20, 0x5506, 0x2620, 0x008d, 0x0560,
+		0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a, 0x7f10, 0x4c00,
+		0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0, 0x0015, 0x7802,
+		0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000, 0x99ec, 0x0007,
+		0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28, 0x0007, 0x680c,
+		0x0007, 0x54d2, 0x0454, 0x99ef, 0x6928, 0x7ff1, 0x54d2, 0x008a,
+		0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200, 0x9994, 0x0200,
+		0x998c, 0xc0ec, 0x7d72, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1,
+		0x5bc9, 0x028e, 0xc0fe, 0x068a, 0x7c6a, 0x5dd9, 0x5ce1, 0x0bff,
+		0x0311, 0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363,
+		0x7c05, 0x036f, 0x7d27, 0x0374, 0x7c7a, 0x9a71, 0xdb04, 0x3c06,
+		0x4c00, 0x7df7, 0x028f, 0x1a04, 0x6a23, 0x620b, 0x6f23, 0x301f,
+		0x00aa, 0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9a30, 0x048a,
+		0x620b, 0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa,
+		0x048f, 0x1c04, 0x6c07, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e,
+		0x1a5c, 0x9a11, 0x058f, 0x1d0c, 0x6d23, 0x650b, 0x007d, 0x7c01,
+		0x1d08, 0x007c, 0x7c01, 0x1d04, 0x6d23, 0x650b, 0x0488, 0x3c1f,
+		0x0417, 0x0417, 0x0417, 0x0417, 0x059c, 0x6d23, 0x028e, 0x1a34,
+		0x6ad7, 0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28,
+		0x6ad7, 0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065,
+		0x7c02, 0x0101, 0x0025, 0x0400, 0x9a0d, 0x52c1, 0x53c9, 0x54e1,
+		0x0453, 0xc10d, 0x7d95, 0x0200, 0x9a00, 0x0200, 0x99f9, 0x0200,
+		0x9a00, 0x55d9, 0x6d07, 0x54d1, 0x058a, 0x2508, 0x6dc7, 0x0373,
+		0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372, 0x7c04, 0x65c8, 0x6d0b,
+		0x2408, 0x9a86, 0x6cce, 0x65c8, 0x6d0a, 0x2404, 0x6d28, 0x6507,
+		0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8, 0x0334, 0x6bc8, 0x0370,
+		0x7ca9, 0x0c60, 0x0411, 0x04bb, 0x4c00, 0x7da4, 0x0410, 0x1c30,
+		0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d, 0x7c03, 0x047c, 0x7c01,
+		0x9a3a, 0x003b, 0x003a, 0x0039, 0x0058, 0x9ab5, 0x047d, 0x7d03,
+		0x047c, 0x7d01, 0x9a3a, 0x005b, 0xdaf9, 0x1d18, 0x6d23, 0x650b,
+		0x0510, 0x003a, 0x0039, 0x0038, 0x00ad, 0xdb04, 0x0c30, 0x0410,
+		0x04bb, 0x003c, 0x003d, 0x00ac, 0xdaf9, 0x007b, 0x7c04, 0x003d,
+		0x003c, 0x1d0c, 0x9ad6, 0x048f, 0x1c14, 0x6c23, 0x640b, 0x4401,
+		0x7d04, 0x005d, 0x005c, 0x1d0c, 0x9ad6, 0x0310, 0x3b30, 0x4b30,
+		0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c, 0x00ab, 0x6ad7, 0x63c8,
+		0x6d23, 0x650b, 0x0560, 0x7d03, 0x005e, 0xdaed, 0x9a3a, 0x003e,
+		0x0c80, 0x0410, 0x0394, 0xdaed, 0x640b, 0x037f, 0x7d02, 0x1a14,
+		0x9aea, 0x1a0c, 0x6ad7, 0x6cc8, 0x9a3a, 0x0c7f, 0x0410, 0x03b4,
+		0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e, 0x1a04, 0x6ad7, 0x6cc8,
+		0x0006, 0x058f, 0x1d08, 0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d38,
+		0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b, 0x042c, 0x0454, 0x042b,
+		0x6ad7, 0x6cc8, 0x0006, 0x0007, 0x684c, 0x6144, 0x9b1c, 0x0007,
+		0x68cc, 0x61d0, 0x9b1c, 0x0007, 0x680c, 0x680c, 0x6107, 0x6907,
+		0x692b, 0x6928, 0x0007, 0x680c, 0x0d70, 0x0511, 0x5515, 0x55f5,
+		0x01a5, 0x0dff, 0x0512, 0x1dff, 0x0512, 0x04bd, 0x0499, 0x0454,
+		0x0006, 0x08ff, 0x0011, 0x28ff, 0x0006, 0x038c, 0x0eff, 0x0611,
+		0x2eff, 0x03b6, 0x0006, 0x53d6, 0x0398, 0x5bd6, 0x53ee, 0x0398,
+		0x5bee, 0x0006, 0x52de, 0x53e6, 0x54ee, 0x0498, 0x0454, 0x0006,
+		0x50f6, 0x52c6, 0x53ce, 0x54d6, 0x0498, 0x0454, 0x0006, 0x6207,
+		0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff,
+		0x0312, 0x04bb, 0x049a, 0x0006, 0x1e10, 0x0870, 0x0011, 0x5010,
+		0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+		0x0200, 0x9b5b, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+		0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70,
+		0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9b6a, 0x0212,
+		0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8,
+		0xdba5, 0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xdbbd, 0x52c0,
+		0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x9b5b, 0x008f, 0x00d5, 0x7d01,
+		0x008d, 0xdba5, 0x9b68, 0x0200, 0x9b58, 0x0007, 0x68cc, 0x6a28,
+		0x7f01, 0x9ba3, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b,
+		0x6a28, 0x0007, 0x680c, 0x0454, 0x9b81, 0x05a0, 0x1e08, 0x6ec3,
+		0x0388, 0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5,
+		0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09,
+		0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5,
+		0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0870, 0x0011,
+		0x5010, 0xc0ec, 0x7d78, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+		0x7d02, 0x0200, 0x9bcc, 0x6d03, 0x6ed3, 0x0dff, 0x0511, 0x1dff,
+		0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b, 0x5313,
+		0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9bdc, 0x008f,
+		0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc,
+		0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a,
+		0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25, 0x620a,
+		0x7e23, 0x9c06, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512,
+		0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70, 0x0311,
+		0x5313, 0x9c21, 0x7802, 0x6209, 0x6ac8, 0x9c20, 0x0015, 0x7802,
+		0x620a, 0x6ac8, 0x9c20, 0x0015, 0x0015, 0x7802, 0x620b, 0x6ac8,
+		0x7c03, 0x0000, 0x55db, 0x9bda, 0x0007, 0x68cc, 0x680c, 0x55d3,
+		0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9c2f, 0x0017, 0x0017, 0x55db,
+		0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8,
+		0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x008b, 0x52c0, 0x53c8, 0xc10d,
+		0x7d8b, 0x0200, 0x9bcc, 0x0200, 0x9bc9, 0xc19d, 0xc0ec, 0x7d52,
+		0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+		0x56fa, 0x7d02, 0x0200, 0x9c4e, 0x6d03, 0x5bca, 0x5cd2, 0x0bff,
+		0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211, 0x4c00,
+		0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9c61, 0x4c01,
+		0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020, 0x04a0,
+		0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d, 0x9c5f,
+		0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f, 0x5d06,
+		0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0, 0x0454,
+		0x9c8b, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9, 0x4d00,
+		0x7c02, 0x0400, 0x9c8d, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7db6,
+		0x0200, 0x9c4e, 0x0200, 0x9c46, 0x0870, 0x0011, 0x5010, 0xc0ec,
+		0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+		0x9ca2, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511, 0x1dff,
+		0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62c8,
+		0x7e1f, 0x0400, 0x9cb3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+		0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16, 0x6ac8, 0x7f11, 0x0015,
+		0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e, 0x6ac8, 0x7f09, 0x6edf,
+		0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9cb1,
+		0x0007, 0x68cc, 0x9cdd, 0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8,
+		0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd, 0x0200, 0x9ca2, 0x0200,
+		0x9c9f, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0,
+		0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cf0, 0x0870, 0x0011,
+		0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228,
+		0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9cff, 0x620b, 0x7e06, 0x5a06,
+		0x7f06, 0x0000, 0x2504, 0x7d05, 0x9cff, 0x0007, 0x680c, 0x0007,
+		0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9cf0, 0x0200,
+		0x9cec, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d74, 0x5010, 0x5ac0,
+		0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d20, 0x6d03,
+		0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff,
+		0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70, 0x0211, 0x532a, 0x5212,
+		0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9d34, 0x008f, 0x05d8, 0x7d01,
+		0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d27, 0x4d02, 0x7d20,
+		0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea, 0x0260, 0x7d05, 0x6509,
+		0x7e25, 0x630a, 0x7e23, 0x9d58, 0x630a, 0x7e20, 0x6509, 0x7e1e,
+		0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19, 0x2003, 0x4800, 0x7ced,
+		0x0a70, 0x0211, 0x5212, 0x9d73, 0x7802, 0x6309, 0x5b06, 0x9d72,
+		0x0015, 0x7802, 0x630a, 0x5b06, 0x9d72, 0x0015, 0x0015, 0x7802,
+		0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000, 0x9d32, 0x0007, 0x680c,
+		0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9d80, 0x0017, 0x0017,
+		0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+		0x04b8, 0x04ad, 0x0454, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d90,
+		0x0200, 0x9d20, 0x0200, 0x9d1c, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+		0x7d35, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+		0x9d9b, 0x0870, 0x0011, 0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+		0x4d00, 0x7d1c, 0x5228, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b,
+		0x0400, 0x9daa, 0x5206, 0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000,
+		0x2504, 0x7d0c, 0x9daa, 0x0007, 0x680c, 0x680c, 0x6207, 0x6a07,
+		0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3,
+		0x5010, 0x52c0, 0xc10d, 0x7dcf, 0x0200, 0x9d9b, 0x0200, 0x9d97,
+		0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d5e, 0x5010, 0x5ac0, 0x5bc8,
+		0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dd7, 0x6d07, 0x5df0,
+		0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0a70, 0x0211,
+		0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04, 0x6a28, 0x7f3a, 0x0400,
+		0x9de6, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312,
+		0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02, 0x7d20, 0x4b01, 0x7d23,
+		0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e24, 0x0260, 0x7d02, 0x0310,
+		0x0312, 0x6b09, 0x7f1e, 0x0312, 0x6b09, 0x7f1b, 0x0312, 0x6b09,
+		0x7f18, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e27,
+		0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b, 0x9e26, 0x0015, 0x7802,
+		0x5306, 0x6b0a, 0x9e26, 0x7802, 0x5306, 0x6b09, 0x7c02, 0x0000,
+		0x9de4, 0xdb13, 0x6928, 0x7ffd, 0x008a, 0x52c0, 0x53c8, 0xc10d,
+		0x7da6, 0x0200, 0x9dd7, 0x0200, 0x9dd3, 0x0870, 0x0011, 0x5010,
+		0xc0ec, 0x7d5b, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+		0x0200, 0x9e3b, 0x0b70, 0x0311, 0x6ec3, 0x6d07, 0x5df0, 0x0dff,
+		0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3d, 0x522b, 0x02b9, 0x4a00,
+		0x7c04, 0x6a28, 0x7f33, 0x0400, 0x9e4d, 0x028e, 0x1a94, 0x6ac3,
+		0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3, 0x6ed3, 0x62c8, 0x0248,
+		0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e, 0x7d31, 0x6a09, 0x7f1e,
+		0x2501, 0x4d00, 0x7d1f, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3,
+		0x0260, 0x7df1, 0x6a28, 0x7f12, 0xdb47, 0x9e8c, 0x6ee3, 0x008f,
+		0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17,
+		0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e4b, 0x0289, 0xdb13,
+		0x018a, 0x9e9b, 0x6a28, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0,
+		0x53c8, 0xc10d, 0x7da8, 0x0200, 0x9e3b, 0x0200, 0x9e38, 0x6a28,
+		0x7fed, 0xdb47, 0x9e9b, 0x0458, 0x0454, 0x9e8c, 0xc19d, 0x0870,
+		0x0011, 0xc0ec, 0x7d54, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+		0x56f8, 0x7d02, 0x0200, 0x9ea5, 0x0b70, 0x0311, 0x6d07, 0x5df0,
+		0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d36, 0x522b, 0x02b9,
+		0x4a00, 0x7c04, 0x6928, 0x7f2c, 0x0400, 0x9eb6, 0x028e, 0x1a94,
+		0x5202, 0x0269, 0x7d16, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694,
+		0x5206, 0x026e, 0x7d2e, 0x6a09, 0x7f1b, 0x2501, 0x4d00, 0x7d1c,
+		0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6a28, 0x7f11, 0xdb47,
+		0x9eee, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+		0x026e, 0x7d17, 0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9eb4,
+		0x0289, 0xdb13, 0x018a, 0x9efd, 0x6928, 0x7ffa, 0x0b70, 0x0311,
+		0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7db0, 0x0200, 0x9ea5, 0x0200,
+		0x9ea1, 0x6a28, 0x7fed, 0xdb47, 0x9efd, 0x0458, 0x0454, 0x9eee,
+		0x9eee
+	};
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/sdma_script_code_pass2.h b/arch/arm/plat-mxc/include/mach/sdma_script_code_pass2.h
new file mode 100644
index 0000000..e546417
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdma_script_code_pass2.h
@@ -0,0 +1,398 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS15_MX31"
+
+*******************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_PASS2_H__
+#define __SDMA_SCRIPT_CODE_PASS2_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_2	0
+#define start_SIZE_2	20
+
+#define core_ADDR_2	80
+#define core_SIZE_2	152
+
+#define common_ADDR_2	232
+#define common_SIZE_2	191
+
+#define ap_2_ap_ADDR_2	423
+#define ap_2_ap_SIZE_2	294
+
+#define bp_2_bp_ADDR_2	717
+#define bp_2_bp_SIZE_2	112
+
+#define ap_2_bp_ADDR_2	829
+#define ap_2_bp_SIZE_2	200
+
+#define bp_2_ap_ADDR_2	1029
+#define bp_2_ap_SIZE_2	223
+
+#define error_ADDR_2	1907
+#define error_SIZE_2	73
+
+#define test_ADDR_2	1980
+#define test_SIZE_2	63
+
+#define signature_ADDR_2	1023
+#define signature_SIZE_2	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define ap_2_ap_fixed_addr_ADDR_2	6144
+#define ap_2_ap_fixed_addr_SIZE_2	68
+
+#define app_2_mcu_patched_ADDR_2	6212
+#define app_2_mcu_patched_SIZE_2	104
+
+/*mapping the app_2_mcu start address to the patched(RAM)script start address*/
+#define app_2_mcu_ADDR_2		app_2_mcu_patched_ADDR_2
+#define app_2_mcu_SIZE_2		app_2_mcu_patched_SIZE_2
+
+#define app_2_per_ADDR_2	6316
+#define app_2_per_SIZE_2	105
+
+#define ata_2_mcu_ADDR_2	6421
+#define ata_2_mcu_SIZE_2	110
+
+#define firi_2_mcu_ADDR_2	6531
+#define firi_2_mcu_SIZE_2	114
+
+#define loop_DMAs_fixed_addr_ADDR_2	6645
+#define loop_DMAs_fixed_addr_SIZE_2	90
+
+#define mcu_2_app_patched_ADDR_2	6735
+#define mcu_2_app_patched_SIZE_2	129
+
+/*mapping the mcu_2_app start address to the patched(RAM)script start address*/
+#define mcu_2_app_ADDR_2		mcu_2_app_patched_ADDR_2
+#define mcu_2_app_SIZE_2		mcu_2_app_patched_SIZE_2
+
+#define mcu_2_ata_ADDR_2	6864
+#define mcu_2_ata_SIZE_2	87
+
+#define mcu_2_firi_ADDR_2	6951
+#define mcu_2_firi_SIZE_2	77
+
+#define mcu_2_mshc_ADDR_2	7028
+#define mcu_2_mshc_SIZE_2	48
+
+#define mcu_2_shp_patched_ADDR_2	7076
+#define mcu_2_shp_patched_SIZE_2	125
+
+/*mapping the mcu_2_shp start address to the patched(RAM)script start address*/
+#define mcu_2_shp_ADDR_2		mcu_2_shp_patched_ADDR_2
+#define mcu_2_shp_SIZE_2		mcu_2_shp_patched_SIZE_2
+
+#define mshc_2_mcu_ADDR_2	7201
+#define mshc_2_mcu_SIZE_2	60
+
+#define per_2_app_ADDR_2	7261
+#define per_2_app_SIZE_2	131
+
+#define per_2_shp_ADDR_2	7392
+#define per_2_shp_SIZE_2	131
+
+#define shp_2_mcu_patched_ADDR_2	7523
+#define shp_2_mcu_patched_SIZE_2	104
+
+/*mapping the shp_2_mcu start address to the patched(RAM)script start address*/
+#define shp_2_mcu_ADDR_2		shp_2_mcu_patched_ADDR_2
+#define shp_2_mcu_SIZE_2		shp_2_mcu_patched_SIZE_2
+
+#define shp_2_per_ADDR_2	7627
+#define shp_2_per_SIZE_2	109
+
+#define uart_2_mcu_patched_ADDR_2	7736
+#define uart_2_mcu_patched_SIZE_2	106
+
+/*mapping the uart_2_mcu start address to the patched(RAM)script start address*/
+#define uart_2_mcu_ADDR_2		uart_2_mcu_patched_ADDR_2
+#define uart_2_mcu_SIZE_2		uart_2_mcu_patched_SIZE_2
+
+#define uartsh_2_mcu_patched_ADDR_2	7842
+#define uartsh_2_mcu_patched_SIZE_2	99
+
+/*
+ * mapping the uartsh_2_mcu start address to the patched(RAM)script
+ * start address
+ */
+#define uartsh_2_mcu_ADDR_2		uartsh_2_mcu_patched_ADDR_2
+#define uartsh_2_mcu_SIZE_2		uartsh_2_mcu_patched_SIZE_2
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_2		6144
+#define RAM_CODE_SIZE_2			1797
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code_2[] = {
+	0x0970, 0x0111, 0x5111, 0x5ef9, 0xc0ec, 0x7d23, 0x5ad1, 0x5bd9,
+	0xc0fe, 0x7c1f, 0x5ce1, 0x5de9, 0x5ef1, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x048e, 0x56f9, 0x0660, 0x7d05, 0x0661, 0x7c2b, 0x6c07,
+	0x6d13, 0x9821, 0x0661, 0x7d26, 0x6c17, 0x6d03, 0x028d, 0x058c,
+	0x048a, 0xd9f5, 0x7e08, 0x7f07, 0x54e1, 0x52d1, 0x53d9, 0xc10d,
+	0x7dde, 0x0200, 0x9804, 0x0660, 0x7d03, 0x6007, 0x52f1, 0x9832,
+	0x6003, 0x52e9, 0x00a2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x6a0c, 0x54e1, 0xc795, 0x048b, 0x0498,
+	0x0454, 0x9825, 0x0800, 0x983c, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d61, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x984a, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d45, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f3b, 0x0400, 0x985a, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d1c,
+	0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311, 0x53eb, 0x62c8,
+	0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09, 0x7f1f, 0x0212,
+	0x6a09, 0x7f1c, 0x0212, 0x6a09, 0x7f19, 0x2003, 0x4800, 0x7cef,
+	0x0b70, 0x0311, 0x5313, 0x989b, 0x0015, 0x0015, 0x7802, 0x62c8,
+	0x6a0b, 0x989a, 0x0015, 0x7802, 0x62c8, 0x6a0a, 0x989a, 0x7802,
+	0x62c8, 0x6a09, 0x7c03, 0x6a28, 0x0000, 0x9858, 0xc77b, 0x6a28,
+	0x7ffd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da2,
+	0x0200, 0x984a, 0x0200, 0x9847, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d62, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x98b2, 0x6ec3, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d46, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x62ff, 0x7e3c, 0x0400, 0x98c2, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d28,
+	0x4a02, 0x7d20, 0x4a01, 0x7d19, 0x6ddd, 0x0b70, 0x0311, 0x53eb,
+	0x62c8, 0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6ac8, 0x7f1f,
+	0x0212, 0x6ac8, 0x7f1c, 0x0212, 0x6ac8, 0x7f19, 0x2003, 0x4800,
+	0x7cef, 0x0b70, 0x0311, 0x5313, 0x9905, 0x6ddd, 0x7802, 0x62c8,
+	0x6ac8, 0x9904, 0x6dde, 0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9904,
+	0x0015, 0x0015, 0x7801, 0x62d8, 0x7c02, 0x0000, 0x98c0, 0xc777,
+	0x62ff, 0x7efd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d,
+	0x7da1, 0x0200, 0x98b2, 0x0200, 0x98af, 0xc19d, 0xc0ec, 0x7d69,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x991e, 0x6d07, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70,
+	0x0211, 0x552a, 0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9,
+	0x4d00, 0x7c13, 0x6928, 0x7f2d, 0x0400, 0x992f, 0x008f, 0x0015,
+	0x04d8, 0x7d01, 0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b,
+	0x7e29, 0x6d28, 0x7f1e, 0x0000, 0x992d, 0x1e20, 0x5506, 0x2620,
+	0x008d, 0x0560, 0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a,
+	0x7f10, 0x4c00, 0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000,
+	0x9976, 0x0007, 0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28,
+	0x0007, 0x680c, 0x0007, 0x54d2, 0x0454, 0x9979, 0x6928, 0x7ff1,
+	0x54d2, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200,
+	0x991e, 0x0200, 0x9916, 0x1e10, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x998a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70, 0x0311,
+	0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9999, 0x0212, 0x3aff,
+	0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8, 0xd9d4,
+	0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xd9ec, 0x52c0, 0x53c8,
+	0xc10d, 0x7dd0, 0x0200, 0x998a, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0xd9d4, 0x9997, 0x0200, 0x9987, 0x0007, 0x68cc, 0x6a28, 0x7f01,
+	0x99d2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b, 0x6a28,
+	0x0007, 0x680c, 0x0454, 0x99b0, 0x05a0, 0x1e08, 0x6ec3, 0x0388,
+	0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5, 0x6a28,
+	0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09, 0x7edc,
+	0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5, 0x0dff,
+	0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0388, 0x028d, 0x3a03,
+	0x4a00, 0x7c33, 0x028c, 0x3a03, 0x4a00, 0x7d0c, 0x0804, 0x00a2,
+	0x00db, 0x7d24, 0x03a0, 0x0498, 0x7802, 0x6209, 0x6a29, 0x7e24,
+	0x620c, 0x7e22, 0x0804, 0x03d0, 0x7d19, 0x0820, 0x028c, 0x3a1f,
+	0x00a2, 0x03d0, 0x7c02, 0x008b, 0x3003, 0x03a0, 0x0015, 0x0015,
+	0x6818, 0x7e12, 0x6828, 0x7f10, 0x0000, 0x0820, 0x03d8, 0x7df5,
+	0x0804, 0x03d0, 0x7d03, 0x008b, 0x3003, 0x9a15, 0x008b, 0x7802,
+	0x6209, 0x6a29, 0x7e01, 0x620c, 0x0006, 0x0804, 0x03d0, 0x7df6,
+	0x048b, 0x3403, 0x03a4, 0x0415, 0x0415, 0x0d0f, 0x0511, 0x1df0,
+	0x0808, 0x04d0, 0x7c01, 0x008c, 0x58c1, 0x04a0, 0x7803, 0x620b,
+	0x5a05, 0x1d01, 0x7ee9, 0x50c1, 0x05a0, 0x7803, 0x5205, 0x6a0b,
+	0x1d01, 0x6a28, 0x7fe1, 0x0000, 0x4c00, 0x7ce7, 0x9a26, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d7a, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9a55, 0x6d03, 0x6ed3, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b,
+	0x5313, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9a65,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512,
+	0x05bc, 0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01,
+	0x7d1a, 0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25,
+	0x620a, 0x7e23, 0x9a8f, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512,
+	0x0512, 0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70,
+	0x0311, 0x5313, 0x9aaa, 0x7802, 0x6209, 0x6ac8, 0x9aa9, 0x0015,
+	0x7802, 0x620a, 0x6ac8, 0x9aa9, 0x0015, 0x0015, 0x7802, 0x620b,
+	0x6ac8, 0x7c03, 0x0000, 0x55db, 0x9a63, 0x0007, 0x68cc, 0x680c,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9ab8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d89, 0x0200, 0x9a55, 0x0200, 0x9a52,
+	0xc19d, 0xc0ec, 0x7d52, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c,
+	0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9ad9, 0x6d03,
+	0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da,
+	0x0a70, 0x0211, 0x4c00, 0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02,
+	0x0400, 0x9aec, 0x4c01, 0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x0020, 0x04a0, 0x0015, 0x7802, 0x650b, 0x5d06, 0x0000,
+	0x7e0c, 0x7f0d, 0x9aea, 0x650a, 0x7e08, 0x008d, 0x0011, 0x0010,
+	0x05a8, 0x065f, 0x5d06, 0x063f, 0x7f02, 0x0007, 0x680c, 0x0007,
+	0x5012, 0x54d0, 0x0454, 0x9b16, 0x5012, 0x54d0, 0x0473, 0x7c06,
+	0x552a, 0x05b9, 0x4d00, 0x7c02, 0x0400, 0x9b18, 0x52c0, 0x53c8,
+	0xc10d, 0x0288, 0x7db6, 0x0200, 0x9ad9, 0x0200, 0x9ad1, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9b2d, 0x0b70, 0x0311, 0x6ed3, 0x6d03,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x62c8, 0x7e1f, 0x0400, 0x9b3e, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16,
+	0x6ac8, 0x7f11, 0x0015, 0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e,
+	0x6ac8, 0x7f09, 0x6edf, 0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000,
+	0x7e05, 0x7f01, 0x9b3c, 0x0007, 0x68cc, 0x9b68, 0x0007, 0x6a0c,
+	0x0454, 0x62c8, 0x7ef8, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd,
+	0x0200, 0x9b2d, 0x0200, 0x9b2a, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9b7b, 0x0870, 0x0011, 0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9b8a,
+	0x620b, 0x7e06, 0x5a06, 0x7f06, 0x0000, 0x2504, 0x7d05, 0x9b8a,
+	0x0007, 0x680c, 0x0007, 0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb,
+	0x0200, 0x9b7b, 0x0200, 0x9b77, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d76, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9bab, 0x6d03, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70,
+	0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9bbf,
+	0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00,
+	0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea,
+	0x0260, 0x7d05, 0x6509, 0x7e25, 0x630a, 0x7e23, 0x9be3, 0x630a,
+	0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19,
+	0x2003, 0x4800, 0x7ced, 0x0a70, 0x0211, 0x5212, 0x9bfe, 0x7802,
+	0x6309, 0x5b06, 0x9bfd, 0x0015, 0x7802, 0x630a, 0x5b06, 0x9bfd,
+	0x0015, 0x0015, 0x7802, 0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000,
+	0x9bbd, 0x0007, 0x680c, 0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02,
+	0x9c0b, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff,
+	0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454, 0x0870, 0x0011,
+	0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d8e, 0x0200, 0x9bab, 0x0200,
+	0x9ba7, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9c28, 0x0870, 0x0011,
+	0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c, 0x5228,
+	0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9c37, 0x5206,
+	0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9c37,
+	0x0007, 0x680c, 0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007,
+	0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0, 0xc10d,
+	0x7dcf, 0x0200, 0x9c28, 0x0200, 0x9c24, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d7c, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9c63, 0x6ed3, 0x6dc5, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d60, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9,
+	0x4a00, 0x7c02, 0x0400, 0x9c73, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd3, 0x4d00,
+	0x7d2c, 0x4d02, 0x7d24, 0x4d01, 0x7d1e, 0x59e3, 0x0b70, 0x0311,
+	0x53eb, 0x61c8, 0x7e2b, 0x62c8, 0x7e29, 0x65c8, 0x7e27, 0x0360,
+	0x7d03, 0x0112, 0x0112, 0x9c9e, 0x0512, 0x0512, 0x0211, 0x02a9,
+	0x02ad, 0x6ac8, 0x7f1b, 0x2003, 0x4800, 0x7ceb, 0x0b70, 0x0311,
+	0x5313, 0x51e3, 0x9cbb, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dce,
+	0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dcf, 0x0015, 0x0015,
+	0x7801, 0x62d8, 0x7c03, 0x0000, 0x55db, 0x9c71, 0x0007, 0x68ff,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9cc8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62c8, 0x7ee9, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d87, 0x0200, 0x9c63, 0x0200, 0x9c60,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d7c, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ce7, 0x6dc5, 0x0d03,
+	0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d5d, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9,
+	0x4b00, 0x7c02, 0x0400, 0x9cfb, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d2c, 0x4d02, 0x7d24, 0x4d01,
+	0x7d1e, 0x59e2, 0x0a70, 0x0211, 0x52ea, 0x61c8, 0x7e2c, 0x63c8,
+	0x7e2a, 0x65c8, 0x7e28, 0x0260, 0x7d03, 0x0112, 0x0112, 0x9d22,
+	0x0512, 0x0512, 0x0311, 0x03a9, 0x03ad, 0x5b06, 0x7f1c, 0x2003,
+	0x4800, 0x7ceb, 0x0a70, 0x0211, 0x5212, 0x51e2, 0x9d40, 0x7802,
+	0x63c8, 0x5b06, 0x9d3f, 0x6dce, 0x0015, 0x7802, 0x63c8, 0x5b06,
+	0x9d3f, 0x6dcf, 0x0015, 0x0015, 0x7802, 0x63c8, 0x5b06, 0x7c03,
+	0x55da, 0x0000, 0x9cf9, 0x0007, 0x68ff, 0x55d2, 0x4d00, 0x7d03,
+	0x4d02, 0x7d02, 0x9d4d, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa,
+	0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d88, 0x0200,
+	0x9ce7, 0x0200, 0x9ce3, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d61,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d6a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d45, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04,
+	0x6a28, 0x7f3b, 0x0400, 0x9d79, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x0b03, 0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02,
+	0x7d20, 0x4b01, 0x7d23, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e25,
+	0x0260, 0x7d02, 0x0310, 0x0312, 0x6b09, 0x7f1f, 0x0312, 0x6b09,
+	0x7f1c, 0x0312, 0x6b09, 0x7f19, 0x2003, 0x4800, 0x7cef, 0x0a70,
+	0x0211, 0x5212, 0x9dba, 0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b,
+	0x9db9, 0x0015, 0x7802, 0x5306, 0x6b0a, 0x9db9, 0x7802, 0x5306,
+	0x6b09, 0x7c03, 0x6b28, 0x0000, 0x9d77, 0xc77b, 0x6928, 0x7ffd,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da3, 0x0200,
+	0x9d6a, 0x0200, 0x9d66, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d60,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9dd2, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d46, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02,
+	0x0400, 0x9de1, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03,
+	0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d28, 0x4b02, 0x7d20, 0x4b01,
+	0x7d19, 0x6ddd, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e27, 0x0260,
+	0x7d02, 0x0310, 0x0312, 0x6bc8, 0x7f21, 0x0312, 0x6bc8, 0x7f1e,
+	0x0312, 0x6bc8, 0x7f1b, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211,
+	0x5212, 0x9e23, 0x6ddd, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x6dde,
+	0x0015, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x0015, 0x0015, 0x7802,
+	0x5306, 0x6bc8, 0x7c03, 0x0000, 0xde32, 0x9ddf, 0xc777, 0x0870,
+	0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da4, 0x0200, 0x9dd2,
+	0x0200, 0x9dce, 0x63ff, 0x0368, 0x7d02, 0x0369, 0x7def, 0x0006,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d5c, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9e3e, 0x0b70, 0x0311, 0x6ec3,
+	0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3e,
+	0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f34, 0x0400, 0x9e50,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3,
+	0x6ed3, 0x62c8, 0x0248, 0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e,
+	0x7d32, 0x6a09, 0x7f1f, 0x2501, 0x4d00, 0x7d20, 0x028e, 0x1a98,
+	0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x6a28, 0x7f13, 0xc7af,
+	0x9e90, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x62c8, 0x026e, 0x7d18, 0x6a09, 0x7f05, 0x2001, 0x7cf9, 0x6a28,
+	0x0000, 0x9e4e, 0x0289, 0xc77b, 0x018a, 0x9e9f, 0x6a28, 0x7ffa,
+	0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7da7, 0x0200,
+	0x9e3e, 0x0200, 0x9e3b, 0x6a28, 0x7fed, 0xc7af, 0x9e9f, 0x0458,
+	0x0454, 0x9e90, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d55, 0x5010,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ea9,
+	0x0b70, 0x0311, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d37, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f2d,
+	0x0400, 0x9eba, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d16, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d2f, 0x6a09,
+	0x7f1c, 0x2501, 0x4d00, 0x7d1d, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6a28, 0x7f12, 0xc7af, 0x9ef3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d18, 0x6a09, 0x7f05,
+	0x2001, 0x7cf9, 0x6a28, 0x0000, 0x9eb8, 0x0289, 0xc77b, 0x018a,
+	0x9f02, 0x6928, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7daf, 0x0200, 0x9ea9, 0x0200, 0x9ea5, 0x6a28, 0x7fed,
+	0xc7af, 0x9f02, 0x0458, 0x0454, 0x9ef3
+};
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/serial.h b/arch/arm/plat-mxc/include/mach/serial.h
new file mode 100644
index 0000000..23ea3d5
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/serial.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX3_SERIAL_H__
+#define __ARCH_ARM_MACH_MX3_SERIAL_H__
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#ifdef CONFIG_MACH_MX31LITE
+#define UART1_UFCR_RXTL         1
+#else
+#define UART1_UFCR_RXTL         16
+#endif
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        0
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        0
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              MXC_INT_UART4
+#define UART4_INT2              -1
+#define UART4_INT3              -1
+#define UART4_SHARED_PERI       -1
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              MXC_INT_UART5
+#define UART5_INT2              -1
+#define UART5_INT3              -1
+#define UART5_SHARED_PERI       -1
+
+#endif				/* __ARCH_ARM_MACH_MX3_SERIAL_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/spba.h b/arch/arm/plat-mxc/include/mach/spba.h
new file mode 100644
index 0000000..cff2cc4
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/spba.h
@@ -0,0 +1,66 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup SPBA Shared Peripheral Bus Arbiter (SPBA)
+ * @ingroup MSL
+ */
+
+/*!
+ * @file spba.h
+ * @brief This file contains the Shared Peripheral Bus Arbiter (spba) API.
+ *
+ * @ingroup SPBA
+ */
+
+#ifndef __ASM_ARCH_MXC_SPBA_H__
+#define __ASM_ARCH_MXC_SPBA_H__
+
+#ifdef __KERNEL__
+
+#define MXC_SPBA_RAR_MASK       0x7
+
+/*!
+ * Defines three SPBA masters: A - ARM, C - SDMA (no master B for MX31)
+ */
+enum spba_masters {
+	SPBA_MASTER_A = 1,
+	SPBA_MASTER_B = 2,
+	SPBA_MASTER_C = 4,
+};
+
+/*!
+ * This function allows the three masters (A, B, C) to take ownership of a
+ * shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_take_ownership(int mod, int master);
+
+/*!
+ * This function releases the ownership for a shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_rel_ownership(int mod, int master);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_SPBA_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
index bbfc374..40798ae 100644
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -20,6 +20,9 @@
 
 #ifndef __ASM_ARCH_MXC_SYSTEM_H__
 #define __ASM_ARCH_MXC_SYSTEM_H__
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
 
 static inline void arch_idle(void)
 {
@@ -28,7 +31,18 @@ static inline void arch_idle(void)
 
 static inline void arch_reset(char mode)
 {
+#ifdef CONFIG_ARCH_MX3
+	if ((__raw_readw(IO_ADDRESS(WDOG_BASE_ADDR)) & 0x4) != 0) {
+		/* If WDOG enabled, wait till it's timed out */
+		asm("cpsid iaf");
+		while (1)
+			nop();
+	} else
+		__raw_writew(__raw_readw(IO_ADDRESS(WDOG_BASE_ADDR)) | 0x4,
+				IO_ADDRESS(WDOG_BASE_ADDR));
+#elif defined (CONFIG_ARCH_MX2)
 	cpu_reset(0);
+#endif
 }
 
 #endif /* __ASM_ARCH_MXC_SYSTEM_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/vmalloc.h b/arch/arm/plat-mxc/include/mach/vmalloc.h
index 62d9762..81ad143 100644
--- a/arch/arm/plat-mxc/include/mach/vmalloc.h
+++ b/arch/arm/plat-mxc/include/mach/vmalloc.h
@@ -21,6 +21,10 @@
 #define __ASM_ARCH_MXC_VMALLOC_H__
 
 /* vmalloc ending address */
+#if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX5)
 #define VMALLOC_END       0xF4000000
+#else
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
+#endif
 
 #endif /* __ASM_ARCH_MXC_VMALLOC_H__ */
diff --git a/include/asm-arm/plat-mxc/mc13892/core.h b/include/asm-arm/plat-mxc/mc13892/core.h
new file mode 100644
index 0000000..6e4ef85
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mc13892/core.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13892_CORE_H_
+#define __LINUX_MFD_MC13892_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define MC13892_SW1 0
+#define MC13892_SW2 1
+#define MC13892_SW3 2
+#define MC13892_SW4 3
+#define MC13892_SWBST 4
+#define MC13892_VIOHI 5
+#define MC13892_VPLL 6
+#define MC13892_VDIG 7
+#define MC13892_VSD 8
+#define MC13892_VUSB2 9
+#define MC13892_VVIDEO 10
+#define MC13892_VAUDIO 11
+#define MC13892_VCAM 12
+#define MC13892_VGEN1 13
+#define MC13892_VGEN2 14
+#define MC13892_VGEN3 15
+#define MC13892_VUSB 16
+#define MC13892_GPO1 17
+#define MC13892_GPO2 18
+#define MC13892_GPO3 19
+#define MC13892_GPO4 20
+#define MC13892_PWGT1 21
+#define MC13892_PWGT2 22
+#define MC13892_REG_NUM 23
+
+struct mc13892;
+struct regulator_init_data;
+
+struct mc13892_platform_data {
+	int (*init)(struct mc13892 *);
+};
+
+struct mc13892_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC13892_REG_NUM];
+};
+
+struct mc13892 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc13892_pmic pmic;
+};
+
+int mc13892_register_regulator(struct mc13892 *mc13892, int reg,
+			      struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/asm-arm/plat-mxc/mxc_i2c.h b/include/asm-arm/plat-mxc/mxc_i2c.h
new file mode 100644
index 0000000..50c5ca6
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_i2c.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_I2C_H__
+#define __ASM_ARCH_MXC_I2C_H__
+
+/*!
+ * @defgroup MXCI2C Inter-IC (I2C) Driver
+ */
+
+/*!
+ * @file mxc_i2c.h
+ *
+ * @brief This file contains the I2C chip level configuration details.
+ *
+ * It also contains the API function that other drivers can use to read/write
+ * to the I2C device registers.
+ *
+ * @ingroup MXCI2C
+ */
+
+/*!
+ * This defines the string used to identify MXC I2C Bus drivers
+ */
+#define MXC_ADAPTER_NAME        "MXC I2C Adapter"
+
+#define MXC_I2C_FLAG_READ	0x01	/* if set, is read; */
+/*else is write */
+#define MXC_I2C_FLAG_POLLING	0x02 /* if set, is polling */
+/* mode; else is interrupt mode */
+
+/* Address offsets of the I2C registers */
+#define MXC_IADR                0x00    /* Address Register */
+#define MXC_IFDR                0x04    /* Freq div register */
+#define MXC_I2CR                0x08    /* Control regsiter */
+#define MXC_I2SR                0x0C    /* Status register */
+#define MXC_I2DR                0x10    /* Data I/O register */
+
+/* Bit definitions of I2CR */
+#define MXC_I2CR_IEN            0x0080
+#define MXC_I2CR_IIEN           0x0040
+#define MXC_I2CR_MSTA           0x0020
+#define MXC_I2CR_MTX            0x0010
+#define MXC_I2CR_TXAK           0x0008
+#define MXC_I2CR_RSTA           0x0004
+
+/* Bit definitions of I2SR */
+#define MXC_I2SR_ICF            0x0080
+#define MXC_I2SR_IAAS           0x0040
+#define MXC_I2SR_IBB            0x0020
+#define MXC_I2SR_IAL            0x0010
+#define MXC_I2SR_SRW            0x0004
+#define MXC_I2SR_IIF            0x0002
+#define MXC_I2SR_RXAK           0x0001
+
+/*!
+ * In case the MXC device has multiple I2C modules, this structure is used to
+ * store information specific to each I2C module.
+ */
+typedef struct __mxc_i2c_device{
+	/*!
+	 * This structure is used to identify the physical i2c bus along with
+	 * the access algorithms necessary to access it.
+	 */
+	struct i2c_adapter adap;
+
+	/*!
+	 * This waitqueue is used to wait for the data transfer to complete.
+	 */
+	wait_queue_head_t wq;
+
+	/*!
+	 * The base address of the I2C device.
+	 */
+	char *membase;
+
+	/*!
+	 * The interrupt number used by the I2C device.
+	 */
+	int irq;
+
+	/*!
+	 * The default clock divider value to be used.
+	 */
+	unsigned int clkdiv;
+
+	/*!
+	 * The current power state of the device
+	 */
+	bool low_power;
+
+	struct clk *clk;
+
+	char clock_id[MAX_DRV_CLK_NAME];
+} mxc_i2c_device;
+
+/*!
+ * Function used to read the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to read data from
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the device
+ *          or a negative number on failure
+ */
+int mxc_i2c_read(int bus_id, unsigned int addr, char *reg, int reg_len,
+		char *buf, int num);
+
+/*!
+ * Function used to write to the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to write data to
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the device
+ *          or a negative number on failure
+ */
+int mxc_i2c_write(int bus_id, unsigned int addr, char *reg, int reg_len,
+		char *buf, int num);
+
+/*!
+ * Function used to read the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to read data from
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the
+ *          device or a negative number on failure *
+ */
+int mxc_i2c_polling_read(int bus_id, unsigned int addr, char *reg, int reg_len,
+		char *buf, int num);
+
+/*!
+ * Function used to write to the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to write data to
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the
+ *          device or a negative number on failure
+ */
+int mxc_i2c_polling_write(int bus_id, unsigned int addr, char *reg, int reg_len,
+		char *buf, int num);
+
+#endif				/* __ASM_ARCH_MXC_I2C_H__ */
diff --git a/include/asm-arm/plat-mxc/mxc_ide.h b/include/asm-arm/plat-mxc/mxc_ide.h
new file mode 100644
index 0000000..d2183fe
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_ide.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_IDE_H_
+#define __ASM_ARCH_MXC_IDE_H_
+
+/*!
+ * @defgroup ATA ATA/IDE Driver
+ */
+
+/*!
+ * @file mxc_ide.h
+ *
+ * @brief MXC ATA/IDE hardware register and bit definitions.
+ *
+ * @ingroup ATA
+ */
+
+#define ATA_BASE_CLK	"ipg_clk"
+
+#define IDE_ARM_IO   0xA0
+#define IDE_ARM_CTL  0xD8
+#define IDE_ARM_IRQ  MXC_INT_ATA
+
+/*
+ * Interface control registers
+ */
+
+#define MXC_IDE_FIFO_DATA_32    0x18
+#define MXC_IDE_FIFO_DATA_16    0x1C
+#define MXC_IDE_FIFO_FILL       0x20
+#define MXC_IDE_ATA_CONTROL     0x24
+#define MXC_IDE_INTR_PENDING    0x28
+#define MXC_IDE_INTR_ENABLE     0x2C
+#define MXC_IDE_INTR_CLEAR      0x30
+#define MXC_IDE_FIFO_ALARM      0x34
+
+/*
+ * Control register bit definitions
+ */
+
+#define MXC_IDE_CTRL_FIFO_RST_B      0x80
+#define MXC_IDE_CTRL_ATA_RST_B       0x40
+#define MXC_IDE_CTRL_FIFO_TX_EN      0x20
+#define MXC_IDE_CTRL_FIFO_RCV_EN     0x10
+#define MXC_IDE_CTRL_DMA_PENDING     0x08
+#define MXC_IDE_CTRL_DMA_ULTRA       0x04
+#define MXC_IDE_CTRL_DMA_WRITE       0x02
+#define MXC_IDE_CTRL_IORDY_EN        0x01
+
+/*
+ * Interrupt registers bit definitions
+ */
+
+#define MXC_IDE_INTR_ATA_INTRQ1      0x80
+#define MXC_IDE_INTR_FIFO_UNDERFLOW  0x40
+#define MXC_IDE_INTR_FIFO_OVERFLOW   0x20
+#define MXC_IDE_INTR_CTRL_IDLE       0x10
+#define MXC_IDE_INTR_ATA_INTRQ2      0x08
+
+/*
+ * timing registers
+ */
+
+#define MXC_IDE_TIME_OFF         0x00
+#define MXC_IDE_TIME_ON          0x01
+#define MXC_IDE_TIME_1           0x02
+#define MXC_IDE_TIME_2w          0x03
+
+#define MXC_IDE_TIME_2r          0x04
+#define MXC_IDE_TIME_AX          0x05
+#define MXC_IDE_TIME_PIO_RDX     0x06
+#define MXC_IDE_TIME_4           0x07
+
+#define MXC_IDE_TIME_9           0x08
+#define MXC_IDE_TIME_M           0x09
+#define MXC_IDE_TIME_JN          0x0A
+#define MXC_IDE_TIME_D           0x0B
+
+#define MXC_IDE_TIME_K           0x0C
+#define MXC_IDE_TIME_ACK         0x0D
+#define MXC_IDE_TIME_ENV         0x0E
+#define MXC_IDE_TIME_RPX         0x0F
+
+#define MXC_IDE_TIME_ZAH         0x10
+#define MXC_IDE_TIME_MLIX        0x11
+#define MXC_IDE_TIME_DVH         0x12
+#define MXC_IDE_TIME_DZFS        0x13
+
+#define MXC_IDE_TIME_DVS         0x14
+#define MXC_IDE_TIME_CVH         0x15
+#define MXC_IDE_TIME_SS          0x16
+#define MXC_IDE_TIME_CYC         0x17
+
+/*
+ * other facts
+ */
+#define MXC_IDE_FIFO_SIZE	64	/* DMA FIFO size in halfwords */
+#define MXC_IDE_DMA_BD_SIZE_MAX 0xFC00	/* max size of scatterlist segment */
+
+/*! Private data for the drive structure. */
+typedef struct __mxc_ide_private{
+	struct device *dev;	/*!< The device */
+	struct resource *res;
+	struct clk *clk;
+	int dma_read_chan;	/*!< DMA channel sdma api gave us for reads */
+	int dma_write_chan;	/*!< DMA channel sdma api gave us for writes */
+	int ultra;		/*!< Remember when we're in ultra mode */
+	int dma_stat;		/*!< the state of DMA request */
+	void *base;
+	unsigned int irq;
+	u8 enable;		/*!< Current hardware interrupt mask */
+	struct regulator *regulator_drive;
+	struct regulator *regulator_io;
+} mxc_ide_private_t;
+
+/*! ATA transfer mode for set_ata_bus_timing() */
+enum ata_mode {
+	PIO,			/*!< Specifies PIO mode */
+	MDMA,			/*!< Specifies MDMA mode */
+	UDMA			/*!< Specifies UDMA mode */
+};
+
+/*!
+ * The struct defines the interrupt type which will issued by interrupt singal.
+ */
+typedef enum __intrq_which{
+	/*! Enable ATA_INTRQ on the CPU */
+	INTRQ_MCU,
+
+	/*! Enable ATA_INTRQ on the DMA engine */
+	INTRQ_DMA
+} intrq_which_t;
+
+/*! defines the structure for timing configurations */
+
+/*!
+ *  This structure defines the bits in the ATA TIME_CONFIGx
+ */
+typedef union __mxc_ide_time_cfg{
+	unsigned long config;	/* the 32bits fields in TIME_CONFIGx */
+	struct {
+		unsigned char field1;	/* the 8bits field */
+		/* for 8bits accessing */
+		unsigned char field2;	/* the 8bits field */
+		/* for 8bits accessing */
+		unsigned char field3;	/* the 8bits field */
+		/* for 8bits accessing */
+		unsigned char field4;	/* the 8bits field */
+		/* for 8bits accessing */
+	} bytes;		/* the 8bits fields in TIME_CONFIGx */
+} mxc_ide_time_cfg_t;
+
+#ifdef MXC_ATA_USE_8_BIT_ACCESS	/* use 8 bit access */
+
+/*!defines the macro for accessing the register */
+#define ATA_RAW_WRITE(v, addr)	__raw_writeb(v, addr)
+#define ATA_RAW_READ(addr)	__raw_readb(addr)
+
+/*! Get the configuration of TIME_CONFIG0 */
+#define GET_TIME_CFG(t, base)
+/*! Set the configuration of TIME_CONFIG0.
+ * And mask is the mask of valid fields.
+ * base is the start address of this cofniguration.
+ */
+#define SET_TIME_CFG(t, mask, base)	\
+{	\
+	if (((mask) & 1)) \
+	ATA_RAW_WRITE((t)->bytes.field1, (unsigned long)(base)); \
+	if (((mask) & 2)) \
+	ATA_RAW_WRITE((t)->bytes.field2, (unsigned long)(base) + 1); \
+	if (((mask) & 4)) \
+	ATA_RAW_WRITE((t)->bytes.field3, (unsigned long)(base) + 2); \
+	if (((mask) & 8)) \
+	ATA_RAW_WRITE((t)->bytes.field4, (unsigned long)(base) + 3); \
+}
+
+#else				/*MXC_ATA_USE_8_BIT_ACCESS */
+
+/*!defines the macro for accessing the register */
+#define ATA_RAW_WRITE(v, addr)	__raw_writel(v, addr)
+#define ATA_RAW_READ(addr)	__raw_readl(addr)
+/*! Get the configuration of TIME_CONFIG0 */
+#define GET_TIME_CFG(t, base)	\
+{	\
+	(t)->config = ATA_RAW_READ(base); \
+}
+
+/*! Set the configuration of TIME_CONFIG0.
+ * And mask is ignored. base is the start address of this configuration.
+ */
+#define SET_TIME_CFG(t, mask, base)	\
+{	\
+	ATA_RAW_WRITE((t)->config, base);	\
+}
+#endif				/*MXC_ATA_USE_8_BIT_ACCESS */
+
+#endif				/* !__ASM_ARCH_MXC_IDE_H_*/
diff --git a/include/asm-arm/plat-mxc/mxc_mci.h b/include/asm-arm/plat-mxc/mxc_mci.h
new file mode 100644
index 0000000..89ba706
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_mci.h
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup MMC Configurable MultiMedia card (MMC) Driver
+ */
+
+/*!
+ * @file mxc_mci.h
+ * @brief This header file contains MMC driver low level definition to access module registers.
+ *
+ * @defgroup MMC_SD MMC/SD Driver
+ */
+
+#ifndef __ASM_ARCH_MXC_MCI_H__
+#define __ASM_ARCH_MXC_MCI_H__
+
+#include <linux/spinlock.h>
+#include <linux/ioport.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <mach/hardware.h>
+
+/*!
+ * Number of SDHC modules
+ */
+
+#define SDHC_MMC_WML                    16
+#define SDHC_SD_WML                     64
+#define DRIVER_NAME                     "MXCMMC"
+#define SDHC_MEM_SIZE                   16384
+#define SDHC_REV_NO                     0x400
+#define READ_TO_VALUE                   0x2db4
+
+/* Address offsets of the SDHC registers */
+#define MMC_STR_STP_CLK                 0x00    /* Clock Control Reg */
+#define MMC_STATUS                      0x04    /* Status Reg */
+#define MMC_CLK_RATE                    0x08    /* Clock Rate Reg */
+#define MMC_CMD_DAT_CONT                0x0C    /* Command and Data */
+								/* Control Reg */
+#define MMC_RES_TO                      0x10    /* Response Time-out Reg */
+#define MMC_READ_TO                     0x14    /* Read Time-out Reg */
+#define MMC_BLK_LEN                     0x18    /* Block Length Reg */
+#define MMC_NOB                         0x1C    /* Number of Blocks Reg */
+#define MMC_REV_NO                      0x20    /* Revision Number Reg */
+#define MMC_INT_CNTR                    0x24    /* Interrupt Control Reg */
+#define MMC_CMD                         0x28    /* Command Number Reg */
+#define MMC_ARG                         0x2C    /* Command Argument Reg */
+#define MMC_RES_FIFO                    0x34    /* Command Response Reg */
+#define MMC_BUFFER_ACCESS               0x38    /* Data Buffer Access Reg */
+#define MMC_REM_NOB                     0x40    /* Remaining NOB Reg */
+#define MMC_REM_BLK_SIZE                0x44    /* Remaining Block Size Reg */
+
+/* Bit definitions for STR_STP_CLK */
+#define STR_STP_CLK_IPG_CLK_GATE_DIS    (1<<15)
+#define STR_STP_CLK_IPG_PERCLK_GATE_DIS (1<<14)
+#define STR_STP_CLK_RESET               (1<<3)
+#define STR_STP_CLK_START_CLK           (1<<1)
+#define STR_STP_CLK_STOP_CLK            (1<<0)
+
+/* Bit definitions for STATUS */
+#define STATUS_CARD_INSERTION           (1<<31)
+#define STATUS_CARD_REMOVAL             (1<<30)
+#define STATUS_YBUF_EMPTY               (1<<29)
+#define STATUS_XBUF_EMPTY               (1<<28)
+#define STATUS_YBUF_FULL                (1<<27)
+#define STATUS_XBUF_FULL                (1<<26)
+#define STATUS_BUF_UND_RUN              (1<<25)
+#define STATUS_BUF_OVFL                 (1<<24)
+#define STATUS_SDIO_INT_ACTIVE          (1<<14)
+#define STATUS_END_CMD_RESP             (1<<13)
+#define STATUS_WRITE_OP_DONE            (1<<12)
+#define STATUS_READ_OP_DONE             (1<<11)
+#define STATUS_WR_CRC_ERROR_CODE_MASK   (3<<10)
+#define STATUS_CARD_BUS_CLK_RUN         (1<<8)
+#define STATUS_BUF_READ_RDY             (1<<7)
+#define STATUS_BUF_WRITE_RDY            (1<<6)
+#define STATUS_RESP_CRC_ERR             (1<<5)
+#define STATUS_READ_CRC_ERR             (1<<3)
+#define STATUS_WRITE_CRC_ERR            (1<<2)
+#define STATUS_TIME_OUT_RESP            (1<<1)
+#define STATUS_TIME_OUT_READ            (1<<0)
+#define STATUS_ERR_MASK                 0x3f
+
+/* Clock rate definitions */
+#define CLK_RATE_PRESCALER(x)           ((x) & 0xF)
+#define CLK_RATE_CLK_DIVIDER(x)         (((x) & 0xF) << 4)
+
+/* Bit definitions for CMD_DAT_CONT */
+#define CMD_DAT_CONT_CMD_RESP_LONG_OFF  (1<<12)
+#define CMD_DAT_CONT_STOP_READWAIT      (1<<11)
+#define CMD_DAT_CONT_START_READWAIT     (1<<10)
+#define CMD_DAT_CONT_BUS_WIDTH_1        (0<<8)
+#define CMD_DAT_CONT_BUS_WIDTH_4        (2<<8)
+#define CMD_DAT_CONT_INIT               (1<<7)
+#define CMD_DAT_CONT_WRITE              (1<<4)
+#define CMD_DAT_CONT_DATA_ENABLE        (1<<3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R1 (1)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R2 (2)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R3 (3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R4 (4)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R5 (5)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R6 (6)
+
+/* Bit definitions for INT_CNTR */
+#define INT_CNTR_SDIO_INT_WKP_EN        (1<<18)
+#define INT_CNTR_CARD_INSERTION_WKP_EN  (1<<17)
+#define INT_CNTR_CARD_REMOVAL_WKP_EN    (1<<16)
+#define INT_CNTR_CARD_INSERTION_EN      (1<<15)
+#define INT_CNTR_CARD_REMOVAL_EN        (1<<14)
+#define INT_CNTR_SDIO_IRQ_EN            (1<<13)
+#define INT_CNTR_DAT0_EN                (1<<12)
+#define INT_CNTR_BUF_READ_EN            (1<<4)
+#define INT_CNTR_BUF_WRITE_EN           (1<<3)
+#define INT_CNTR_END_CMD_RES            (1<<2)
+#define INT_CNTR_WRITE_OP_DONE          (1<<1)
+#define INT_CNTR_READ_OP_DONE           (1<<0)
+
+
+struct mxc_mmc_platform_data {
+    unsigned int ocr_mask;  /* available voltages */
+    unsigned int min_clk;
+    unsigned int max_clk;
+    unsigned int reserved:16;
+    unsigned int card_fixed:1;
+    unsigned int card_inserted_state:1;
+    unsigned int (*status) (struct device *);
+    int (*wp_status) (struct device *);
+    char *power_mmc;
+};
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b mmc_host structure. This structure includes the core \b mmc_host
+ * structure that is provided by Linux MMC/SD Bus protocol driver as an
+ * element and has other elements that are specifically required by this
+ * low-level driver.
+ */
+struct mxcmci_host {
+    /*!
+     * The mmc structure holds all the information about the device
+     * structure, current SDHC io bus settings, the current OCR setting,
+     * devices attached to this host, and so on.
+     */
+    struct mmc_host *mmc;
+
+    /*!
+     * This variable is used for locking the host data structure from
+     * multiple access.
+     */
+    spinlock_t lock;
+
+    /*!
+     * Resource structure, which will maintain base addresses and IRQs.
+     */
+    struct resource *res;
+
+    /*!
+     * Base address of SDHC, used in readl and writel.
+     */
+    void *base;
+
+	/*!
+     * SDHC IRQ number.
+     */
+    int irq;
+
+    /*!
+     * Card Detect IRQ number.
+     */
+    int detect_irq;
+
+    /*!
+     * MMC mode.
+     */
+    int mode;
+
+    /*!
+     * DMA channel number.
+     */
+    int dma;
+
+    /*!
+     * Pointer to hold MMC/SD request.
+     */
+    struct mmc_request *req;
+
+	/*!
+     * Pointer to hold MMC/SD command.
+     */
+    struct mmc_command *cmd;
+
+    /*!
+     * Pointer to hold MMC/SD data.
+     */
+    struct mmc_data *data;
+
+    /*!
+     * Holds the number of bytes to transfer using DMA.
+     */
+    unsigned int dma_size;
+
+    /*!
+     * Value to store in Command and Data Control Register
+     * - currently unused
+     */
+    unsigned int cmdat;
+
+    /*!
+     * Regulator
+     */
+    struct regulator *regulator_mmc;
+
+    /*!
+     * Current vdd settting
+     */
+    int current_vdd;
+
+    /*!
+     * Power mode - currently unused
+     */
+    unsigned int power_mode;
+
+    /*!
+     * DMA address for scatter-gather transfers
+     */
+    dma_addr_t sg_dma;
+
+	/*!
+     * Length of the scatter-gather list
+     */
+    unsigned int dma_len;
+
+    /*!
+     * Holds the direction of data transfer.
+     */
+    unsigned int dma_dir;
+
+    /*!
+     * Id for MMC block.
+     */
+    unsigned int id;
+
+    /*!
+     * Note whether this driver has been suspended.
+     */
+    unsigned int mxc_mmc_suspend_flag;
+
+	/*!
+	 * sdio_irq enable/disable ref count
+	 */
+	int sdio_irq_cnt;
+
+    /*!
+     * Platform specific data
+     */
+    struct mxc_mmc_platform_data *plat_data;
+
+	struct clk *clk;
+};
+
+
+#endif /*__ASM_ARCH_MXC_MCI_H__*/
diff --git a/include/asm-arm/plat-mxc/mxc_nd.h b/include/asm-arm/plat-mxc/mxc_nd.h
new file mode 100644
index 0000000..d0a57a9
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_nd.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_nd.h
+ *
+ * @brief This file contains the NAND Flash Controller register information.
+ *
+ *
+ * @ingroup NAND_MTD
+ */
+
+#ifndef __MXC_ND_H__
+#define __MXC_ND_H__
+
+#include <mach/hardware.h>
+
+#define IS_2K_PAGE_NAND   (mtd->writesize == NAND_PAGESIZE_2KB)
+
+/*!
+ * NFMS bit in RCSR register for pagesize of nandflash
+ */
+#define	NFMS	(*((volatile u32 *)IO_ADDRESS(CCM_BASE_ADDR+0xc)))
+#define	NFMS_BIT	30
+
+/*
+ * Addresses for NFC registers
+ */
+#define NFC_BUF_SIZE            (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE00)))
+#define NFC_BUF_ADDR            (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE04)))
+#define NFC_FLASH_ADDR          (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE06)))
+#define NFC_FLASH_CMD           (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE08)))
+#define NFC_CONFIG              (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE0A)))
+#define NFC_ECC_STATUS_RESULT   (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE0C)))
+#define NFC_RSLTMAIN_AREA       (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE0E)))
+#define NFC_RSLTSPARE_AREA      (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE10)))
+#define NFC_WRPROT              (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE12)))
+#define NFC_UNLOCKSTART_BLKADDR (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE14)))
+#define NFC_UNLOCKEND_BLKADDR   (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE16)))
+#define NFC_NF_WRPRST           (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE18)))
+#define NFC_CONFIG1             (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE1A)))
+#define NFC_CONFIG2             (*((volatile u16 *)IO_ADDRESS \
+			(NFC_BASE_ADDR + 0xE1C)))
+
+/*!
+ * Addresses for NFC RAM BUFFER Main area 0
+ */
+#define MAIN_AREA0        (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x000)
+#define MAIN_AREA1        (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x200)
+#define MAIN_AREA2        (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x400)
+#define MAIN_AREA3        (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x600)
+
+/*!
+ * Addresses for NFC SPARE BUFFER Spare area 0
+ */
+#define SPARE_AREA0       (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x800)
+#define SPARE_AREA1       (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x810)
+#define SPARE_AREA2       (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x820)
+#define SPARE_AREA3       (volatile u16 *)IO_ADDRESS \
+	(NFC_BASE_ADDR + 0x830)
+
+/*!
+ * Set INT to 0, FCMD to 1, rest to 0 in NFC_CONFIG2 Register for Command
+ * operation
+ */
+#define NFC_CMD            0x1
+
+/*!
+ * Set INT to 0, FADD to 1, rest to 0 in NFC_CONFIG2 Register for Address
+ * operation
+ */
+#define NFC_ADDR           0x2
+
+/*!
+ * Set INT to 0, FDI to 1, rest to 0 in NFC_CONFIG2 Register for Input
+ * operation
+ */
+#define NFC_INPUT          0x4
+
+/*!
+ * Set INT to 0, FDO to 001, rest to 0 in NFC_CONFIG2 Register for Data Output
+ * operation
+ */
+#define NFC_OUTPUT         0x8
+
+/*!
+ * Set INT to 0, FD0 to 010, rest to 0 in NFC_CONFIG2 Register for Read ID
+ * operation
+ */
+#define NFC_ID             0x10
+
+/*!
+ * Set INT to 0, FDO to 100, rest to 0 in NFC_CONFIG2 Register for Read Status
+ * operation
+ */
+#define NFC_STATUS         0x20
+
+/*!
+ * Set INT to 1, rest to 0 in NFC_CONFIG2 Register for Read Status
+ * operation
+ */
+#define NFC_INT            0x8000
+
+#define NFC_SP_EN           (1 << 2)
+#define NFC_ECC_EN          (1 << 3)
+#define NFC_INT_MSK         (1 << 4)
+#define NFC_BIG             (1 << 5)
+#define NFC_RST             (1 << 6)
+#define NFC_CE              (1 << 7)
+#define NFC_ONE_CYCLE       (1 << 8)
+
+/*
+ * Define delays in microsec for NAND device operations
+ */
+#define TROP_US_DELAY   2000
+/*
+ * Macros to get byte and bit positions of ECC
+ */
+#define COLPOS(x)  ((x) >> 3)
+#define BITPOS(x) ((x) & 0xf)
+
+/* Define single bit Error positions in Main & Spare area */
+#define MAIN_SINGLEBIT_ERROR 0x4
+#define SPARE_SINGLEBIT_ERROR 0x1
+
+struct mxc_mtd_s {
+	struct mtd_info mtd;
+	struct nand_chip nand;
+	struct mtd_partition *parts;
+	struct device *dev;
+	struct clk *clk;
+};
+
+struct nand_info {
+	bool bSpareOnly;
+	bool bStatusRequest;
+	u16 colAddr;
+};
+
+#endif				/* MXCND_H */
diff --git a/include/asm-arm/plat-mxc/mxc_pcmcia.h b/include/asm-arm/plat-mxc/mxc_pcmcia.h
new file mode 100644
index 0000000..6a04ca8
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_pcmcia.h
@@ -0,0 +1,250 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PCMCIA_H__
+#define __ASM_ARCH_MXC_PCMCIA_H__
+
+#include <mach/hardware.h>
+
+#define	WINDOW_SIZE	0x1000000	/* The size of a window: 16M    */
+#define PCMCIA_WINDOWS  5	/* How many windows / socket    */
+#define SOCKET_NO	1	/* How many sockets             */
+
+#define ATTRIBUTE_MEMORY_WINDOW	0
+#define IO_WINDOW		1
+#define COMMON_MEMORY_WINDOW	2
+
+/*
+ * PCMCIA socket
+ */
+#define	PCMCIAPrtSp	WINDOW_SIZE	/* PCMCIA window size              */
+#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */
+
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */
+
+#define _PCMCIA(Nb)			/* PCMCIA [0..1]		   */ \
+	(PCMCIA_MEM_BASE_ADDR + (Nb) * PCMCIASp)
+
+#define _PCMCIAAttr(Nb)	_PCMCIA(Nb)	/* PCMCIA I/O [0..1]               */
+
+#define _PCMCIAIO(Nb)			/* PCMCIA Attribute [0..1]	   */ \
+	(_PCMCIA(Nb) + (IO_WINDOW) * PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)			/* PCMCIA Memory [0..1]		   */ \
+	(_PCMCIA(Nb) + (COMMON_MEMORY_WINDOW) * PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA(0)	/* PCMCIA 0                        */
+#define _PCMCIA0IO	_PCMCIAIO(0)	/* PCMCIA 0 I/O                    */
+#define _PCMCIA0Attr	_PCMCIAAttr(0)	/* PCMCIA 0 Attribute              */
+#define _PCMCIA0Mem	_PCMCIAMem(0)	/* PCMCIA 0 Memory                 */
+
+/*
+ * Module: PCMCIA, Addr Range: 0xB8004000 - 0xB8004FFF, Size: 4 Kbyte
+ */
+#define PCMCIA_BASE_ADDR	(PCMCIA_CTL_BASE_ADDR)	/* PCMCIA Base Address */
+#define PCMCIA_IO_ADDR(x)	(*(volatile u32 *) PCMCIA_IO_ADDRESS(x))
+
+#define _reg_PCMCIA_PIPR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x00)
+/* PCMCIA input pins register */
+#define _reg_PCMCIA_PSCR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x04)
+/* PCMCIA Status Changed Register */
+#define _reg_PCMCIA_PER		PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x08)
+/* PCMCIA Enable Register */
+
+/* win: 0-4 */
+#define _reg_PCMCIA_PBR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + \
+		0x0C + 4 * (win))	/* PCMCIA Base Register x */
+#define _reg_PCMCIA_POR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + \
+		0x28 + 4 * (win))	/* PCMCIA Option Register x */
+#define _reg_PCMCIA_POFR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + \
+		0x44 + 4 * (win))	/* PCMCIA Offset Register x */
+
+#define _reg_PCMCIA_PGCR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x60)
+/* PCMCIA General Control Register */
+#define _reg_PCMCIA_PGSR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x64)
+/* PCMCIA General Status Register */
+
+/* PCMCIA_PIPR - PCMCIA Input Pins Register - fields */
+#define PCMCIA_PIPR_POWERON	(1 <<  8)	/* card indicates "power on" */
+#define PCMCIA_PIPR_RDY		(1 <<  7)	/* card is ready */
+#define PCMCIA_PIPR_BVD2	(1 <<  6)	/* battery voltage 2/SPKR in */
+#define PCMCIA_PIPR_BVD1	(1 <<  5)	/* battery voltage 1/STSCHG */
+#define PCMCIA_PIPR_CD		(3 <<  3)	/* card detect 1 and 2 */
+#define PCMCIA_PIPR_WP		(1 <<  2)	/* write protect switch */
+									/* enabled */
+#define PCMCIA_PIPR_VS		(3 <<  0)	/* voltage sense bits */
+#define PCMCIA_PIPR_VS_5V	(1 <<  0)	/* 5v */
+
+/* PCMCIA_PSCR - PCMCIA Status Change Register - fields */
+#define PCMCIA_PSCR_POWC               (1 << 11)	/*  */
+#define PCMCIA_PSCR_RDYR               (1 << 10)	/*  */
+#define PCMCIA_PSCR_RDYF               (1 <<  9)	/*  */
+#define PCMCIA_PSCR_RDYH               (1 <<  8)	/*  */
+#define PCMCIA_PSCR_RDYL               (1 <<  7)	/*  */
+#define PCMCIA_PSCR_BVDC2              (1 <<  6)	/*  */
+#define PCMCIA_PSCR_BVDC1              (1 <<  5)	/*  */
+#define PCMCIA_PSCR_CDC2               (1 <<  4)	/*  */
+#define PCMCIA_PSCR_CDC1               (1 <<  3)	/*  */
+#define PCMCIA_PSCR_WPC                (1 <<  2)	/*  */
+#define PCMCIA_PSCR_VSC2               (1 <<  1)	/*  */
+#define PCMCIA_PSCR_VSC1               (1 <<  0)	/*  */
+
+/* PCMCIA_PER - PCMCIA Enable Register - fields */
+#define PCMCIA_PER_ERRINTEN		(1 << 12)
+/* error interrupt enable */
+#define PCMCIA_PER_POWERONEN	(1 << 11)
+/* power on interrupt enable */
+#define PCMCIA_PER_RDYRE		(1 << 10)
+/* RDY/nIREQ pin rising edge */
+#define PCMCIA_PER_RDYFE		(1 <<  9)
+/* RDY/nIREQ pin falling edge */
+#define PCMCIA_PER_RDYHE		(1 <<  8)
+/* RDY/nIREQ pin high */
+#define PCMCIA_PER_RDYLE        (1 <<  7)
+/* RDY/nIREQ pin low */
+#define PCMCIA_PER_BVDE2        (1 <<  6)
+/* battery voltage 2/SPKR in */
+#define PCMCIA_PER_BVDE1        (1 <<  5)
+/* battery voltage 1/STSCHG */
+#define PCMCIA_PER_CDE2         (1 <<  4)
+/* card detect 2  */
+#define PCMCIA_PER_CDE1         (1 <<  3)
+/* card detect 1 */
+#define PCMCIA_PER_WPE          (1 <<  2)
+/* write protect */
+#define PCMCIA_PER_VSE2         (1 <<  1)
+/* voltage sense 2 */
+#define PCMCIA_PER_VSE1         (1 <<  0)
+/* voltage sense 1 */
+
+/* PCMCIA_POR[0-4] - PCMCIA Option Registers 0-4 - fields */
+#define PCMCIA_POR_PV	(1 << 29)	/* set iff bank is valid */
+#define PCMCIA_POR_WPEN (1 << 28)	/* write protect (WP) input */
+/* signal is enabled */
+#define PCMCIA_POR_WP   (1 << 27)	/* write protected */
+
+#define PCMCIA_POR_PRS_SHIFT	(25)
+#define PCMCIA_POR_PRS(x)       (((x) & 0x3) << PCMCIA_POR_PRS_SHIFT)
+#define PCMCIA_POR_PRS_MASK     PCMCIA_POR_PRS(3)	/* PCMCIA region select */
+#define PCMCIA_POR_PRS_COMMON   (0)	/* values of POR_PRS field */
+#define PCMCIA_POR_PRS_TRUE_IDE (1)
+#define PCMCIA_POR_PRS_ATTRIBUTE (2)
+#define PCMCIA_POR_PRS_IO       (3)
+
+#define PCMCIA_POR_PPS_8	(1 << 24)	/* PCMCIA Port size =  8bits */
+#define PCMCIA_POR_PPS_16   (0 << 24)	/* PCMCIA Port size = 16bits */
+
+#define PCMCIA_POR_PSL_SHIFT	(17)	/* strobe length */
+#define PCMCIA_POR_PSL(x)       (((x) & 0x7F) << PCMCIA_POR_PSL_SHIFT)
+#define PCMCIA_POR_PSL_MASK     PCMCIA_POR_PSL(0x7f)
+
+#define PCMCIA_POR_PSST_SHIFT   (11)	/* strobe setup time */
+#define PCMCIA_POR_PSST(x)      (((x) & 0x3F) << PCMCIA_POR_PSST_SHIFT)
+#define PCMCIA_POR_PSST_MASK    PCMCIA_POR_PSST(0x3f)
+
+#define PCMCIA_POR_PSHT_SHIFT   (5)	/* strobe hold time  */
+#define PCMCIA_POR_PSHT(x)      (((x) & 0x3F) << PCMCIA_POR_PSHT_SHIFT)
+#define PCMCIA_POR_PSHT_MASK    PCMCIA_POR_PSHT(0x3f)
+
+#define PCMCIA_POR_BSIZE_SHIFT  (0)	/* bank size */
+#define PCMCIA_POR_BSIZE(x)     (((x) & 0x1F) << PCMCIA_POR_BSIZE_SHIFT)
+#define PCMCIA_POR_BSIZE_MASK   PCMCIA_POR_BSIZE(0x1F)
+
+/* some handy BSIZE values */
+#define POR_BSIZE_1		PCMCIA_POR_BSIZE(0x00)
+#define POR_BSIZE_2     PCMCIA_POR_BSIZE(0x01)
+#define POR_BSIZE_4     PCMCIA_POR_BSIZE(0x03)
+#define POR_BSIZE_8     PCMCIA_POR_BSIZE(0x02)
+#define POR_BSIZE_16    PCMCIA_POR_BSIZE(0x06)
+#define POR_BSIZE_32    PCMCIA_POR_BSIZE(0x07)
+#define POR_BSIZE_64    PCMCIA_POR_BSIZE(0x05)
+#define POR_BSIZE_128   PCMCIA_POR_BSIZE(0x04)
+#define POR_BSIZE_256   PCMCIA_POR_BSIZE(0x0C)
+#define POR_BSIZE_512   PCMCIA_POR_BSIZE(0x0D)
+#define POR_BSIZE_1K    PCMCIA_POR_BSIZE(0x0F)
+#define POR_BSIZE_2K    PCMCIA_POR_BSIZE(0x0E)
+
+#define POR_BSIZE_4K    PCMCIA_POR_BSIZE(0x0A)
+#define POR_BSIZE_8K    PCMCIA_POR_BSIZE(0x0B)
+#define POR_BSIZE_16K   PCMCIA_POR_BSIZE(0x09)
+#define POR_BSIZE_32K   PCMCIA_POR_BSIZE(0x08)
+#define POR_BSIZE_64K   PCMCIA_POR_BSIZE(0x18)
+#define POR_BSIZE_128K  PCMCIA_POR_BSIZE(0x19)
+#define POR_BSIZE_256K  PCMCIA_POR_BSIZE(0x1B)
+#define POR_BSIZE_512K  PCMCIA_POR_BSIZE(0x1A)
+#define POR_BSIZE_1M    PCMCIA_POR_BSIZE(0x1E)
+#define POR_BSIZE_2M    PCMCIA_POR_BSIZE(0x1F)
+#define POR_BSIZE_4M    PCMCIA_POR_BSIZE(0x1D)
+#define POR_BSIZE_8M    PCMCIA_POR_BSIZE(0x1C)
+#define POR_BSIZE_16M   PCMCIA_POR_BSIZE(0x14)
+#define POR_BSIZE_32M   PCMCIA_POR_BSIZE(0x15)
+#define POR_BSIZE_64M   PCMCIA_POR_BSIZE(0x17)
+
+/* Window size */
+#define POR_1		0x1
+#define POR_2		0x2
+#define POR_4		0x4
+#define POR_8		0x8
+#define POR_16		0x10
+#define POR_32		0x20
+#define POR_64		0x40
+#define POR_128		0x80
+#define POR_256		0x100
+#define POR_512		0x200
+
+#define POR_1K		0x400
+#define POR_2K		0x800
+#define POR_4K		0x1000
+#define POR_8K		0x2000
+#define POR_16K		0x4000
+#define POR_32K		0x8000
+#define POR_64K		0x10000
+#define POR_128K	0x20000
+#define POR_256K	0x40000
+#define POR_512K	0x80000
+
+#define POR_1M		0x100000
+#define POR_2M		0x200000
+#define POR_4M		0x400000
+#define POR_8M		0x800000
+#define POR_16M		0x1000000
+#define POR_32M		0x2000000
+#define POR_64M		0x4000000
+
+/* PCMCIA_PGCR - PCMCIA General Control Register - fields */
+#define PCMCIA_PGCR_LPMEN	(1 <<  3)
+/* Low power Mode Enable */
+#define PCMCIA_PGCR_SPKREN  (1 <<  2)
+/* SPKROUT routing enable */
+#define PCMCIA_PGCR_POE     (1 <<  1)
+/* Controller out enable */
+#define PCMCIA_PGCR_RESET   (1 <<  0)
+/* Card reset */
+
+/* PCMCIA_PGSR - PCMCIA General Status Register - fields */
+#define PCMCIA_PGSR_NWINE   (1 <<  4)
+/* No Window error */
+#define PCMCIA_PGSR_LPE     (1 <<  3)
+/* Low Power error */
+#define PCMCIA_PGSR_SE      (1 <<  2)
+/* Size error */
+#define PCMCIA_PGSR_CDE     (1 <<  1)
+/* Card Detect error */
+#define PCMCIA_PGSR_WPE     (1 <<  0)
+/* Write Protect error */
+
+#endif				/* __ASM_ARCH_MXC_PCMCIA_H__ */
diff --git a/include/asm-arm/plat-mxc/mxc_pm.h b/include/asm-arm/plat-mxc/mxc_pm.h
new file mode 100644
index 0000000..d431070
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_pm.h
@@ -0,0 +1,229 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup LPMD Low-Level Power Management Driver
+ */
+
+/*!
+ * @file mxc_pm.h
+ *
+ * @brief This file contains the  chip level configuration details and
+ * public API declarations for CRM_AP module
+ *
+ * @ingroup LPMD
+ */
+
+#ifndef __ASM_ARCH_MXC_PM_H__
+#define __ASM_ARCH_MXC_PM_H__
+
+#define WAIT_MODE               111
+#define DOZE_MODE               112
+#define STOP_MODE               113
+#define DSM_MODE                114
+
+#define GATE_STOP_WAIT          9
+#define GATE_STOP               10
+
+/*
+ * Used for MHz conversion
+ */
+#define MEGA_HERTZ              1000000
+
+/*
+ * If invalid frequency value other than the following
+ * CORE_133 - ARM desired to run @133MHz, LoV (1.2V)
+ * CORE_266 - ARM desired to run @266MHz, LoV (1.2V)
+ * CORE_399 - ARM desired to run @399MHz, LoV (1.2V)
+ * CORE_532 - ARM desired to run @133MHz, HiV (1.6V)
+ * are passed then this error is returned,
+ */
+#define ERR_FREQ_INVALID          1
+
+/*
+ * If PLL freq is less than desired ARM frequency during Integer
+ * DVFS, then return this error
+ */
+#define PLL_LESS_ARM_ERR        2
+
+/*
+ * Frequency change within the same-lo voltage is not approved.
+ * Inorder to do Integer DFS, move to the high voltage range and
+ * then set LFDF and move to the low voltage range
+ */
+#define INT_DFS_LOW_NOT_ALLOW   3
+
+/*
+ * If the desired AHB or IPG exceeds 133MHz or 66.5MHz respectively,
+ * then return this error
+ */
+#define AHB_IPG_EXCEED_LIMIT    4
+
+/*
+ * If the desired ARM frequency is too low to get by PLL scaling
+ * and the mxc_pm_pllscale API is called, return this error:
+ */
+#define PLL_DVFS_FREQ_TOO_LOW   5
+
+/*
+ * Invalid frequencies requested
+ */
+#define MXC_PM_INVALID_PARAM    6
+
+/*
+ * If AHB and/or IPG frequencies are greater than maximum allowed
+ */
+#define FREQ_OUT_OF_RANGE       2
+
+/*
+ * If AHB and/or IPG frequencies are other than 100 or 50Mhz
+ */
+#define BUS_FREQ_INVALID        2
+
+/*
+ * If MAX_PDF is greater than max value (8) then return this error
+ */
+#define AHB_MAX_DIV_ERR         3
+
+/*
+ * If IPG_PDF is greater than max value (2) then return this error
+ */
+#define IPG_MAX_DIV_ERR         4
+
+/*
+ * If ARM freq is out of range i.e., less than 133 or greater than
+ * 399 then return this error
+ */
+#define INVALID_ARM_FREQ        5
+
+/*
+ * This file includes all platform APIs. Some of the APIs are not
+ * appicable to some platforms. So, this error is used to indicate
+ * that a particular API is not available
+ */
+#define MXC_PM_API_NOT_SUPPORTED	6
+
+/*!
+ * Additional define for stop mode
+ */
+#define PM_SUSPEND_STOP         ((__force suspend_state_t) 2)
+
+/*!
+ * CKOH pins configuration
+ */
+#define CKOH_AP_SEL             1
+#define CKOH_AHB_SEL            2
+#define CKOH_IP_SEL             3
+
+/*!
+ * Defines for Stop and DSM mode acknowledgements
+ */
+#define MXC_PM_LOWPWR_ACK_SDMA  0x01
+#define MXC_PM_LOWPWR_ACK_IPU   0x02
+#define MXC_PM_LOWPWR_ACK_MAX   0x04
+#define MXC_PM_LOWPWR_ACK_MQSPI 0x08
+#define MXC_PM_LOWPWR_ACK_USB   0x10
+#define MXC_PM_LOWPWR_ACK_RTIC  0x20
+
+/*
+ * PMIC configuration
+ */
+#define MXC_PMIC_1_2_VOLT                      0xC
+#define MXC_PMIC_1_6_VOLT                      0x1C
+#define MXC_PMIC_1_0_VOLT                      0x4
+#define MXC_PMIC_DVS_SPEED                     0x3
+
+/*!
+ * Implementing Level 1 CRM Gate Control. Level 2 gate control
+ * is provided at module level using LPMD registers
+ *
+ * @param   group   The desired clock gate control register bits.
+ *                  Possible values are 0 through 6
+ * @param   opt     The desired option requesting clock to run during stop
+ *                  and wait modes or just during the stop mode. Possible
+ *                  values are GATE_STOP_WAIT and GATE_STOP.
+ *
+ */
+void mxc_pm_clockgate(int group, int opt);
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode);
+
+/*!
+ * Enables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to enable.
+ *
+ */
+void mxc_pm_lp_ack_enable(int ack);
+
+/*!
+ * Disables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to disable.
+ *
+ */
+void mxc_pm_lp_ack_disable(int ack);
+
+/*!
+ * Implementing steps required to set Integer Scaling
+ *
+ * @param   armfreq    The desired ARM frequency. AHB and IP
+ *                     frequency are changed depending on ARM
+ *                     frequency and the divider values.
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -PLL_LESS_ARM_ERR if pllfreq is less than
+ *                     desired core freq
+ */
+int mxc_pm_intscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To calculate MFI, MFN, MFD values. Using this the output frequency
+ * whose value is calculated using,
+ * 2 * REF_FREQ * (MF / PDF), where
+ * REF_FREQ is 26 Mhz
+ * MF = MFI + (MFN + MFD)
+ * PDF is assumed to be 1
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -1 on error
+ */
+int mxc_pm_pllscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To change AP core frequency and/or voltage suitably
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns -ERR_FREQ_INVALID on failure
+ *                     Returns 0 on success
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq);
+
+#endif
diff --git a/include/asm-arm/plat-mxc/mxc_rtc.h b/include/asm-arm/plat-mxc/mxc_rtc.h
new file mode 100644
index 0000000..800ad4b
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_rtc.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_RTC_H__
+#define __ASM_ARCH_MXC_RTC_H__
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#define RTC_INPUT_CLK_32768HZ
+
+#if defined(RTC_INPUT_CLK_32768HZ)
+#define RTC_INPUT_CLK   (0x00 << 5)
+#else
+#if defined(RTC_INPUT_CLK_32000HZ)
+#define RTC_INPUT_CLK   (0x01 << 5)
+#else				/* 38.4kHz */
+#define RTC_INPUT_CLK   (0x02 << 5)
+#endif
+#endif
+
+#define RTC_SW_BIT      (1 << 0)
+#define RTC_ALM_BIT     (1 << 2)
+#define RTC_1HZ_BIT     (1 << 4)
+#define RTC_2HZ_BIT     (1 << 7)
+#define RTC_SAM0_BIT    (1 << 8)
+#define RTC_SAM1_BIT    (1 << 9)
+#define RTC_SAM2_BIT    (1 << 10)
+#define RTC_SAM3_BIT    (1 << 11)
+#define RTC_SAM4_BIT    (1 << 12)
+#define RTC_SAM5_BIT    (1 << 13)
+#define RTC_SAM6_BIT    (1 << 14)
+#define RTC_SAM7_BIT    (1 << 15)
+#define PIT_ALL_ON      (RTC_2HZ_BIT | RTC_SAM0_BIT | RTC_SAM1_BIT | \
+		RTC_SAM2_BIT | RTC_SAM3_BIT | RTC_SAM4_BIT | \
+		RTC_SAM5_BIT | RTC_SAM6_BIT | RTC_SAM7_BIT)
+
+#define RTC_ENABLE_BIT	(1 << 7)
+
+#ifndef RTC_INPUT_CLK_32768HZ
+#error The PIE code has to be modified to support different input clock!
+#endif
+
+#define MAX_PIE_NUM     9
+#define MAX_PIE_FREQ	512
+const u32 PIE_BIT_DEF[MAX_PIE_NUM][2] = {
+	{2, RTC_2HZ_BIT},
+	{4, RTC_SAM0_BIT},
+	{8, RTC_SAM1_BIT},
+	{16, RTC_SAM2_BIT},
+	{32, RTC_SAM3_BIT},
+	{64, RTC_SAM4_BIT},
+	{128, RTC_SAM5_BIT},
+	{256, RTC_SAM6_BIT},
+	{MAX_PIE_FREQ, RTC_SAM7_BIT},
+};
+
+/* Those are the bits from a classic RTC we want to mimic */
+#define RTC_IRQF                0x80	/* any of the following 3 is active */
+#define RTC_PF                  0x40	/* Periodic interrupt */
+#define RTC_AF                  0x20	/* Alarm interrupt */
+#define RTC_UF                  0x10	/* Update interrupt for 1Hz RTC */
+
+#define MXC_RTC_TIME            0
+#define MXC_RTC_ALARM           1
+
+#define RTC_HOURMIN   0x00  /*  32bit rtc hour/min counter reg */
+#define RTC_SECOND    0x04	/*  32bit rtc seconds counter reg */
+#define RTC_ALRM_HM   0x08	/*  32bit rtc alarm hour/min reg */
+#define RTC_ALRM_SEC  0x0C	/*  32bit rtc alarm seconds reg */
+#define RTC_RTCCTL    0x10	/*  32bit rtc control reg */
+#define RTC_RTCISR    0x14	/*  32bit rtc interrupt status reg */
+#define RTC_RTCIENR   0x18	/*  32bit rtc interrupt enable reg */
+#define RTC_STPWCH    0x1C	/*  32bit rtc stopwatch min reg */
+#define RTC_DAYR      0x20	/*  32bit rtc days counter reg */
+#define RTC_DAYALARM  0x24	/*  32bit rtc day alarm reg */
+#define RTC_TEST1     0x28	/*  32bit rtc test reg 1 */
+#define RTC_TEST2     0x2C	/*  32bit rtc test reg 2 */
+#define RTC_TEST3     0x30	/*  32bit rtc test reg 3 */
+
+struct mxc_rtc_priv {
+	struct device *dev;
+	struct resource *res;
+	struct clk *clk;
+	void *base;
+	unsigned int irq;
+};
+
+#define RTC_RAW_WRITE(v, addr)  __raw_writel(v, addr)
+#define RTC_RAW_READ(addr)      __raw_readl(addr)
+
+
+#endif				/* __MXC_RTC_H__ */
diff --git a/include/asm-arm/plat-mxc/mxc_spi.h b/include/asm-arm/plat-mxc/mxc_spi.h
new file mode 100644
index 0000000..45c5637
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_spi.h
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup SPI Configurable Serial Peripheral Interface (CSPI) Driver
+ */
+
+/*!
+ * @file mxc_spi.h
+ * @brief This header file contains SPI driver low level definition to access module registers.
+ *
+ * @ingroup SPI
+ */
+
+#ifndef __ASM_ARCH_MXC_SPI_H__
+#define __ASM_ARCH_MXC_SPI_H__
+
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+/*!
+ * This structure is used to define the SPI master controller's platform
+ * data. It includes the SPI  bus number and the maximum number of
+ * slaves/chips it supports.
+ */
+struct mxc_spi_master {
+	/*!
+	 * SPI Master's bus number.
+	 */
+	unsigned int bus_num;
+	/*!
+	 * SPI Master's maximum number of chip selects.
+	 */
+	unsigned int maxchipselect;
+	/*!
+	 * CSPI Hardware Version.
+	 */
+	unsigned int spi_version;
+	/*!
+	 * CSPI Clock.
+	 */
+	char clock[MAX_DRV_CLK_NAME];
+};
+
+#define MXC_CSPIRXDATA      0x00
+#define MXC_CSPITXDATA      0x04
+#define MXC_CSPICTRL        0x08
+#define MXC_CSPIINT     0x0C
+#define MXC_CSPIDMA     0x10
+#define MXC_CSPISTAT        0x14
+#define MXC_CSPIPERIOD      0x18
+#define MXC_CSPITEST        0x1C
+#define MXC_CSPIRESET       0x00
+
+#define MXC_CSPICTRL_ENABLE 0x1
+#define MXC_CSPICTRL_DISABLE    0x0
+#define MXC_CSPICTRL_MASTER (1 << 1)
+#define MXC_CSPICTRL_SLAVE  0x0
+#define MXC_CSPICTRL_XCH    (1 << 2)
+#define MXC_CSPICTRL_SMC    (1 << 3)
+#define MXC_CSPICTRL_LOWPOL (1 << 4)
+#define MXC_CSPICTRL_HIGHPOL    0x0
+#define MXC_CSPICTRL_PHA    (1 << 5)
+#define MXC_CSPICTRL_NOPHA  0x0
+#define MXC_CSPICTRL_SSCTL  (1 << 6)
+#define MXC_CSPICTRL_HIGHSSPOL  (1 << 7)
+#define MXC_CSPICTRL_LOWSSPOL   0x0
+#define MXC_CSPICTRL_CSMASK 0x3
+#define MXC_CSPICTRL_MAXDATRATE 0x7
+#define MXC_CSPICTRL_DATAMASK   0x7
+#define MXC_CSPICTRL_DATASHIFT  16
+#define MXC_CSPICTRL_ADJUST_SHIFT(x) ((x) -= 2)
+
+#define MXC_CSPICTRL_CSSHIFT_0_7    12
+#define MXC_CSPICTRL_BCSHIFT_0_7    20
+#define MXC_CSPICTRL_BCMASK_0_7     0xFFF
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_7    8
+
+#define MXC_CSPICTRL_CSSHIFT_0_5    12
+#define MXC_CSPICTRL_BCSHIFT_0_5    20
+#define MXC_CSPICTRL_BCMASK_0_5     0xFFF
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_5    8
+
+#define MXC_CSPICTRL_CSSHIFT_0_4    24
+#define MXC_CSPICTRL_BCSHIFT_0_4    8
+#define MXC_CSPICTRL_BCMASK_0_4     0x1F
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_4    20
+
+#define MXC_CSPICTRL_CSSHIFT_0_0    19
+#define MXC_CSPICTRL_BCSHIFT_0_0    0
+#define MXC_CSPICTRL_BCMASK_0_0     0x1F
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_0    12
+
+#define MXC_CSPIINT_IRQSHIFT_0_7    8
+#define MXC_CSPIINT_IRQSHIFT_0_5    9
+#define MXC_CSPIINT_IRQSHIFT_0_4    9
+#define MXC_CSPIINT_IRQSHIFT_0_0    18
+#define MXC_CSPIINT_TEEN    (1 << 0)
+#define MXC_CSPIINT_THEN    (1 << 1)
+#define MXC_CSPIINT_TFEN    (1 << 2)
+#define MXC_CSPIINT_RREN    (1 << 3)
+#define MXC_CSPIINT_RHEN        (1 << 4)
+#define MXC_CSPIINT_RFEN        (1 << 5)
+#define MXC_CSPIINT_ROEN        (1 << 6)
+#define MXC_CSPIINT_TCEN_0_7    (1 << 7)
+#define MXC_CSPIINT_TCEN_0_5    (1 << 8)
+#define MXC_CSPIINT_TCEN_0_4    (1 << 8)
+#define MXC_CSPIINT_TCEN_0_0    (1 << 3)
+#define MXC_CSPIINT_BOEN_0_7    0
+#define MXC_CSPIINT_BOEN_0_5    (1 << 7)
+#define MXC_CSPIINT_BOEN_0_4    (1 << 7)
+#define MXC_CSPIINT_BOEN_0_0    (1 << 8)
+
+#define MXC_CSPISTAT_TE     (1 << 0)
+#define MXC_CSPISTAT_TH     (1 << 1)
+#define MXC_CSPISTAT_TF     (1 << 2)
+#define MXC_CSPISTAT_RR     (1 << 3)
+#define MXC_CSPISTAT_RH         (1 << 4)
+#define MXC_CSPISTAT_RF         (1 << 5)
+#define MXC_CSPISTAT_RO         (1 << 6)
+#define MXC_CSPISTAT_TC_0_7 (1 << 7)
+#define MXC_CSPISTAT_TC_0_5 (1 << 8)
+#define MXC_CSPISTAT_TC_0_4 (1 << 8)
+#define MXC_CSPISTAT_TC_0_0 (1 << 3)
+#define MXC_CSPISTAT_BO_0_7 0
+#define MXC_CSPISTAT_BO_0_5 (1 << 7)
+#define MXC_CSPISTAT_BO_0_4 (1 << 7)
+#define MXC_CSPISTAT_BO_0_0 (1 << 8)
+
+#define MXC_CSPIPERIOD_32KHZ    (1 << 15)
+
+#define MXC_CSPITEST_LBC    (1 << 14)
+
+/*!
+ * @struct mxc_spi_unique_def
+ * @brief This structure contains information that differs with
+ * SPI master controller hardware version
+ */
+struct mxc_spi_unique_def {
+	/*!
+	 * Width of valid bits in MXC_CSPIINT.
+	 */
+	unsigned int intr_bit_shift;
+	/*!
+	 * Chip Select shift.
+	 */
+	unsigned int cs_shift;
+	/*!
+	 * Bit count shift.
+	 */
+	unsigned int bc_shift;
+	/*!
+	 * Bit count mask.
+	 */
+	unsigned int bc_mask;
+	/*!
+	 * Data Control shift.
+	 */
+	unsigned int drctrl_shift;
+
+	/*!
+	 * Transfer Complete shift.
+	 */
+	unsigned int xfer_complete;
+	/*!
+	 * Bit counnter overflow shift.
+	 */
+	unsigned int bc_overflow;
+};
+
+struct mxc_spi;
+/*!
+ * Structure to group together all the data buffers and functions
+ * used in data transfers.
+ */
+struct mxc_spi_xfer {
+	/*!
+	 * Transmit buffer.
+	 */
+	const void *tx_buf;
+	/*!
+	 * Receive buffer.
+	 */
+	void *rx_buf;
+	/*!
+	 * Data transfered count.
+	 */
+	unsigned int count;
+
+	/*!
+	 * Function to read the FIFO data to rx_buf.
+	 */
+	void (*rx_get) (struct mxc_spi *, u32 val);
+	/*!
+	 * Function to get the data to be written to FIFO.
+	 */
+	u32(*tx_get) (struct mxc_spi *);
+};
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b spi_master structure. This structure includes the core \b spi_master
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and has other elements that are specifically required by this
+ * low-level driver.
+ */
+struct mxc_spi {
+	/*!
+	 * SPI Master and a simple I/O queue runner.
+	 */
+	struct spi_bitbang mxc_bitbang;
+	/*!
+	 * Completion flags used in data transfers.
+	 */
+	struct completion xfer_done;
+	/*!
+	 * Data transfer structure.
+	 */
+	struct mxc_spi_xfer transfer;
+	/*!
+	 * Resource structure, which will maintain base addresses and IRQs.
+	 */
+	struct resource *res;
+	/*!
+	 * Base address of CSPI, used in readl and writel.
+	 */
+	void *base;
+	/*!
+	 * CSPI IRQ number.
+	 */
+	int irq;
+	/*!
+	 * CSPI Clock id.
+	 */
+	struct clk *clk;
+	/*!
+	 * CSPI input clock SCLK.
+	 */
+	unsigned long spi_ipg_clk;
+	/*!
+	 * CSPI registers' bit pattern.
+	 */
+	struct mxc_spi_unique_def *spi_ver_def;
+};
+
+#define MXC_SPI_BUF_RX(type)    \
+	void mxc_spi_buf_rx_##type(struct mxc_spi *master_drv_data, u32 val)\
+{\
+	type *rx = master_drv_data->transfer.rx_buf;\
+	*rx++ = (type)val;\
+	master_drv_data->transfer.rx_buf = rx;\
+}
+
+#define MXC_SPI_BUF_TX(type)    \
+	u32 mxc_spi_buf_tx_##type(struct mxc_spi *master_drv_data)\
+{\
+	u32 val;\
+	const type *tx = master_drv_data->transfer.tx_buf;\
+	val = *tx++;\
+	master_drv_data->transfer.tx_buf = tx;\
+	return val;\
+}
+
+#endif
diff --git a/include/asm-arm/plat-mxc/mxc_timer.h b/include/asm-arm/plat-mxc/mxc_timer.h
new file mode 100644
index 0000000..6f696ae
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_timer.h
@@ -0,0 +1,160 @@
+/*
+ * mxc_timer.h
+ *
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * Platform independent (i.MX1, i.MX2, i.MX3) definition for timer handling.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_TIMER_H
+#define __ASM_ARCH_MXC_TIMER_H
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+
+#ifdef CONFIG_ARCH_IMX
+#define TIMER_BASE		IO_ADDRESS(TIM1_BASE_ADDR)
+#define TIMER_INTERRUPT		TIM1_INT
+
+#define TCTL_VAL		TCTL_CLK_PCLK1
+#define TCTL_IRQEN		(1<<4)
+#define TCTL_FRR		(1<<8)
+#define TCTL_CLK_PCLK1		(1<<1)
+#define TCTL_CLK_PCLK1_4	(2<<1)
+#define TCTL_CLK_TIN		(3<<1)
+#define TCTL_CLK_32		(4<<1)
+
+#define MXC_TCTL   0x00
+#define MXC_TPRER  0x04
+#define MXC_TCMP   0x08
+#define MXC_TCR    0x0c
+#define MXC_TCN    0x10
+#define MXC_TSTAT  0x14
+#define TSTAT_CAPT		(1<<1)
+#define TSTAT_COMP		(1<<0)
+
+static inline void gpt_irq_disable(void)
+{
+	unsigned int tmp;
+
+	tmp = __raw_readl(TIMER_BASE + MXC_TCTL);
+	__raw_writel(tmp & ~TCTL_IRQEN, TIMER_BASE + MXC_TCTL);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(__raw_readl(TIMER_BASE + MXC_TCTL) | TCTL_IRQEN,
+				TIMER_BASE + MXC_TCTL);
+}
+
+static void gpt_irq_acknowledge(void)
+{
+	__raw_writel(0, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_IMX */
+
+#ifdef CONFIG_ARCH_MX2
+#define TIMER_BASE		IO_ADDRESS(GPT1_BASE_ADDR)
+#define TIMER_INTERRUPT		MXC_INT_GPT1
+
+#define MXC_TCTL   0x00
+#define TCTL_VAL		TCTL_CLK_PCLK1
+#define TCTL_CLK_PCLK1		(1<<1)
+#define TCTL_CLK_PCLK1_4	(2<<1)
+#define TCTL_IRQEN		(1<<4)
+#define TCTL_FRR		(1<<8)
+#define MXC_TPRER  0x04
+#define MXC_TCMP   0x08
+#define MXC_TCR    0x0c
+#define MXC_TCN    0x10
+#define MXC_TSTAT  0x14
+#define TSTAT_CAPT		(1<<1)
+#define TSTAT_COMP		(1<<0)
+
+static inline void gpt_irq_disable(void)
+{
+	unsigned int tmp;
+
+	tmp = __raw_readl(TIMER_BASE + MXC_TCTL);
+	__raw_writel(tmp & ~TCTL_IRQEN, TIMER_BASE + MXC_TCTL);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(__raw_readl(TIMER_BASE + MXC_TCTL) | TCTL_IRQEN,
+				TIMER_BASE + MXC_TCTL);
+}
+
+static void gpt_irq_acknowledge(void)
+{
+	__raw_writel(TSTAT_CAPT | TSTAT_COMP, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_MX2 */
+
+#ifdef CONFIG_ARCH_MX3
+#define TIMER_BASE		IO_ADDRESS(GPT1_BASE_ADDR)
+#define TIMER_INTERRUPT		MXC_INT_GPT
+
+#define MXC_TCTL   0x00
+#define TCTL_VAL		(TCTL_CLK_IPG | TCTL_WAITEN)
+#define TCTL_CLK_IPG		(1<<6)
+#define TCTL_FRR		(1<<9)
+#define TCTL_WAITEN		(1<<3)
+
+#define MXC_TPRER  0x04
+#define MXC_TSTAT  0x08
+#define TSTAT_OF1		(1<<0)
+#define TSTAT_OF2		(1<<1)
+#define TSTAT_OF3		(1<<2)
+#define TSTAT_IF1		(1<<3)
+#define TSTAT_IF2		(1<<4)
+#define TSTAT_ROV		(1<<5)
+#define MXC_IR     0x0c
+#define MXC_TCMP   0x10
+#define MXC_TCMP2  0x14
+#define MXC_TCMP3  0x18
+#define MXC_TCR    0x1c
+#define MXC_TCN    0x24
+
+static inline void gpt_irq_disable(void)
+{
+	__raw_writel(0, TIMER_BASE + MXC_IR);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(1<<0, TIMER_BASE + MXC_IR);
+}
+
+static inline void gpt_irq_acknowledge(void)
+{
+	__raw_writel(TSTAT_OF1, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_MX3 */
+
+#define TCTL_SWR		(1<<15)
+#define TCTL_CC			(1<<10)
+#define TCTL_OM			(1<<9)
+#define TCTL_CAP_RIS		(1<<6)
+#define TCTL_CAP_FAL		(2<<6)
+#define TCTL_CAP_RIS_FAL	(3<<6)
+#define TCTL_CAP_ENA		(1<<5)
+#define TCTL_TEN		(1<<0)
+
+#endif
diff --git a/include/asm-arm/plat-mxc/mxc_wdt.h b/include/asm-arm/plat-mxc/mxc_wdt.h
new file mode 100644
index 0000000..a747182
--- /dev/null
+++ b/include/asm-arm/plat-mxc/mxc_wdt.h
@@ -0,0 +1,40 @@
+/*
+ *  linux/drivers/char/watchdog/mxc_wdt.h
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *      MXC Watchdog timer register definitions
+ *
+ * Author: MontaVista Software, Inc.
+ *       <AKuster@mvista.com> or <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc.
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __MXC_WDT_H__
+#define __MXC_WDT_H__
+
+#define MXC_WDT_WCR             IO_ADDRESS(WDOG_BASE_ADDR + 0x00)
+#define MXC_WDT_WSR             IO_ADDRESS(WDOG_BASE_ADDR + 0x02)
+#define MXC_WDT_WRSR            IO_ADDRESS(WDOG_BASE_ADDR + 0x04)
+#define WCR_WOE_BIT             (1 << 6)
+#define WCR_WDA_BIT             (1 << 5)
+#define WCR_SRS_BIT             (1 << 4)
+#define WCR_WRE_BIT             (1 << 3)
+#define WCR_WDE_BIT             (1 << 2)
+#define WCR_WDBG_BIT            (1 << 1)
+#define WCR_WDZST_BIT           (1 << 0)
+#define WDT_MAGIC_1             0x5555
+#define WDT_MAGIC_2             0xAAAA
+
+#define TIMER_MARGIN_MAX    	127
+#define TIMER_MARGIN_DEFAULT	60	/* 60 secs */
+#define TIMER_MARGIN_MIN	1
+
+#define WDOG_SEC_TO_COUNT(s)  ((s * 2) << 8)
+#define WDOG_COUNT_TO_SEC(c)  ((c >> 8) / 2)
+
+#endif				/* __MXC_WDT_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_adc.h b/include/asm-arm/plat-mxc/pmic_adc.h
new file mode 100644
index 0000000..67c4d9b
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_adc.h
@@ -0,0 +1,454 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D', 4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D', 5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum __t_channel{
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum __t_comp_exception{
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum __t_touch_mode{
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct __t_touch_screen{
+	/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum __t_conversion_mode{
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct __t_adc_convert_param{
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator.
+ */
+typedef struct __t_adc_comp_param{
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+		unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+		unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+		unsigned char high,
+		t_channel channel,
+		t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+
+int is_pmic_adc_ready(void);
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_audio.h b/include/asm-arm/plat-mxc/pmic_audio.h
new file mode 100644
index 0000000..48329c4
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_audio.h
@@ -0,0 +1,2329 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_AUDIO_H__
+#define __ASM_ARCH_MXC_PMIC_AUDIO_H__
+
+/*!
+ * @defgroup PMIC_AUDIO  PMIC Audio Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_audio.h
+ * @brief External definitions for the PMIC Audio Client driver.
+ *
+ * The PMIC Audio driver and this API were developed to support the
+ * audio playback, recording, and mixing capabilities of the power
+ * management ICs that are available from Freescale Semiconductor, Inc.
+ *
+ * The following table shows which audio-related capabilities are supported
+ * by each power management IC:
+ *
+ * @ingroup PMIC_AUDIO
+ */
+
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Audio Device Access Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to the
+ * PMIC Audio hardware.
+ */
+/*@{*/
+
+/*!
+ * @typedef PMIC_AUDIO_HANDLE
+ * @brief Define typedef for a handle to the PMIC Audio hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Audio hardware
+ * is opened. This handle grants exclusive access to the PMIC Audio
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Audio hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long *PMIC_AUDIO_HANDLE;
+
+/*!
+ * @enum PMIC_AUDIO_EVENTS
+ * @brief Identify the audio events that have been detected and should be
+ * handled.
+ *
+ * This enumeration defines all of the possible PMIC Audio events. Multiple
+ * events may be selected when defining a mask and multiple events may be
+ * signalled together.
+ *
+ * Note that the MICROPHONE_DETECT and MICROPHONE_REMOVED events may also be
+ * used to signal the operation of a serial or parallel microphone switch
+ * when used with a combined headset+microphone device. In that case the
+ * HEADSET_DETECT state must also be checked to determine if it's only the
+ * microphone switch being operated or whether the microphone has truly been
+ * inserted/removed (along with the headset).
+ */
+typedef enum _PMIC_AUDIO_EVENTS{
+	HEADSET_DETECTED = 1,	/*!< Detected headset insertion.      */
+	HEADSET_STEREO = 2,	/*!< Detected stereo headset device.  */
+	HEADSET_MONO = 4,	/*!< Detected mono headset device.    */
+	HEADSET_THERMAL_SHUTDOWN = 8,	/*!< Detected output amplifier */
+	/* shutdown due to thermal */
+	/*  limits . */
+	HEADSET_SHORT_CIRCUIT = 16,	/*!< Detected output amplifier */
+	/* short circuit condition */
+	HEADSET_REMOVED = 32,	/*!< Detected headset removal.        */
+	MICROPHONE_DETECTED = 64,	/*!< Detected microphone insertion.   */
+	MICROPHONE_REMOVED = 128,	/*!< Detected microphone removal.     */
+	PTT_BUTTON_PRESS = 256,	/*!< Detected PTT button down */
+	PTT_BUTTON_RANGE = 512,	/*!< Detected PTT button within */
+	/*  voltage range. */
+	PTT_SHORT_OR_INVALID = 1024	/*!< Detected PTT button outside */
+		/*  of voltage range or invalid*/
+		/*  device  . */
+} PMIC_AUDIO_EVENTS;
+
+/*!
+ * @typedef PMIC_AUDIO_CALLBACK
+ * @brief Typedef for PMIC Audio event notification callback function.
+ *
+ * Define a typedef for the PMIC Audio event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef PMIC_AUDIO_EVENTS(*PMIC_AUDIO_CALLBACK) (const PMIC_AUDIO_EVENTS event);
+
+/*!
+ * @enum PMIC_AUDIO_SOURCE
+ * @brief Select an audio signal processing component.
+ *
+ * This enumeration defines all of the possible PMIC audio signal handling
+ * components which can be acquired by calling pmic_audio_open().
+ *
+ * Note that the EXTERNAL_STEREO_IN selection is used to simply gain access
+ * to the stereo input pins. The stereo input signal can then be routed
+ * directly to the output amplifiers. In this case, no signal processing is
+ * done by either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum _PMIC_AUDIO_SOURCE{
+	STEREO_DAC,		/*!< Open connection to Stereo DAC. */
+	VOICE_CODEC,		/*!< Open connection to Voice CODEC. */
+	EXTERNAL_STEREO_IN	/*!< Open connection to external */
+		/* stereo inputs. */
+} PMIC_AUDIO_SOURCE;
+
+/*@}*/
+
+/*!
+ * @name Data Bus Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the data bus protocol in order to communicate with the Stereo DAC
+ * or the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_DATA_BUS
+ * @brief Select the data bus used to transfer data between the host and
+ *        Voice CODEC and/or the Stereo DAC.
+ *
+ * This enumeration defines all of the possible PMIC audio data buses that
+ * can be used to transfer data between the host and the Voice CODEC and/or
+ * the Stereo DAC on the PMIC.
+ *
+ * Note that the same data bus may be used to transfer audio data to/from
+ * the Voice CODEC and the Stereo DAC. However, in this case, the data bus
+ * must be configured for network mode with different timeslots assigned to
+ * the Voice CODEC and the Stereo DAC. Also, the sampling rates must be
+ * identical for both the Voice CODEC and the Stereo DAC in order to avoid
+ * a data bus timing conflict and audio signal distortion.
+ */
+typedef enum _PMIC_AUDIO_DATA_BUS{
+	AUDIO_DATA_BUS_1,	/*!< Use data bus 1 for audio data. */
+	AUDIO_DATA_BUS_2	/*!< Use data bus 2 for audio data. */
+} PMIC_AUDIO_DATA_BUS;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_PROTOCOL
+ * @brief Select the data bus protocol to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus protocols
+ * that may be selected.
+ */
+typedef enum _PMIC_AUDIO_BUS_PROTOCOL{
+	NORMAL_MSB_JUSTIFIED_MODE,	/*!< Transmit and receive audio data */
+	/*  in normal MSB-justified mode. */
+	NETWORK_MODE,		/*!< Transmit and receive audio data */
+	/*  in network mode. */
+	I2S_MODE,		/*!< Transmit and receive audio data */
+	/*  in I2S mode. */
+	SPD_IF_MODE		/*!< Transmit and receive audio data */
+		/* in SPD/IF mode. */
+} PMIC_AUDIO_BUS_PROTOCOL;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_MODE
+ * @brief Select the data bus mode to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus modes
+ * that may be selected. When configured in BUS_MASTER_MODE, the PMIC is
+ * responsible for supplying the data bus clock signals. Alternatively,
+ * when configured in BUS_SLAVE_MODE, the PMIC will use the data bus clock
+ * signals that are supplied by the bus master.
+ */
+typedef enum _PMIC_AUDIO_BUS_MODE{
+	BUS_MASTER_MODE = 0,	/*!< Operate as bus master.       */
+	BUS_SLAVE_MODE = 1	/*!< Operate as bus slave.        */
+} PMIC_AUDIO_BUS_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_IN_SOURCE
+ * @brief Select the clock signal source when in bus master mode.
+ *
+ * This enumeration defines all of the possible PMIC audio clock signal
+ * sources that may be selected. One of these clock signal sources must
+ * be selected in order to use either the Voice CODEC or the Stereo DAC.
+ *
+ * When configured in BUS_MASTER_MODE, the PMIC's onboard PLL circuits
+ * will also be driven by the selected clock input signal.
+ */
+typedef enum _PMIC_AUDIO_CLOCK_IN_SOURCE{
+	CLOCK_IN_DEFAULT,	/*!< Just use default */
+	/* (power-up) clock input.*/
+	CLOCK_IN_CLIA,		/*!< Use the CLIA clock */
+	/*  source (Stereo DAC default). */
+	CLOCK_IN_CLIB,		/*!< Use the CLIB clock source */
+	/*  (Voice CODEC default). */
+	CLOCK_IN_CLKIN,		/*!< Use the CLKIN clock source */
+	CLOCK_IN_MCLK,		/*!< Disable the internal PLL */
+	/* and use the MCLK clock */
+	/* source (Stereo DAC only) */
+	CLOCK_IN_FSYNC,		/*!< Internal PLL input from */
+	/* external framesync( Stereo DAC only). */
+	CLOCK_IN_BITCLK		/*!< Internal PLL input */
+		/* from external bitclock */
+		/* (Stereo DAC only) */
+} PMIC_AUDIO_CLOCK_IN_SOURCE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_INVERT
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration enables or disables the inversion of the incoming
+ * frame sync or bit clock signals.
+ */
+typedef enum _PMIC_AUDIO_CLOCK_INVERT{
+	NO_INVERT = 0,		/*!< Do not invert the clock signals.    */
+	INVERT_BITCLOCK = 1,	/*!< Invert the BCLK input signal.       */
+	INVERT_FRAMESYNC = 2	/*!< Invert the FSYNC input signal.      */
+} PMIC_AUDIO_CLOCK_INVERT;
+
+/*!
+ * @enum PMIC_AUDIO_NUMSLOTS
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration defines all of the possible number of timeslots that may
+ * be selected when the PMIC is configured as the data bus master. One of these
+ * options must be selected if the Stereo DAC is to provide the data bus
+ * clock signals.
+ *
+ * Note that the Voice CODEC currently only allows USE_4_TIMESLOTS when
+ * operating in data bus master mode.
+ */
+typedef enum _PMIC_AUDIO_NUMSLOTS{
+	USE_2_TIMESLOTS,	/*!< Configure for 2 timeslots. */
+	USE_4_TIMESLOTS,	/*!< Configure for 4 timeslots. */
+	USE_8_STAR_TIMESLOTS,	/*!< Configure for 8 */
+	/* (Left, Right, 6 other) timeslots. */
+	USE_8_TIMESLOTS		/*!< Configure for 8 timeslots. */
+} PMIC_AUDIO_NUMSLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Stereo DAC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Stereo DAC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum _PMIC_AUDIO_STDAC_SAMPLING_RATE{
+	STDAC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	STDAC_RATE_11_025_KHZ,	/*!< Use 11.025 kHz sampling rate. */
+	STDAC_RATE_12_KHZ,	/*!< Use 12 kHz sampling rate.     */
+	STDAC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+	STDAC_RATE_22_050_KHZ,	/*!< Use 22.050 kHz sampling rate. */
+	STDAC_RATE_24_KHZ,	/*!< Use 24 kHz sampling rate.     */
+	STDAC_RATE_32_KHZ,	/*!< Use 32 kHz sampling rate.     */
+	STDAC_RATE_44_1_KHZ,	/*!< Use 44.1 kHz sampling rate.   */
+	STDAC_RATE_48_KHZ,	/*!< Use 48 kHz sampling rate.     */
+	STDAC_RATE_64_KHZ,	/*!< Use 64 kHz sampling rate
+						  .          */
+	STDAC_RATE_96_KHZ	/*!< Use 96 kHz sampling rate.
+						  .          */
+} PMIC_AUDIO_STDAC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Voice CODEC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Voice CODEC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_SAMPLING_RATE{
+	VCODEC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	VCODEC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+} PMIC_AUDIO_VCODEC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+ * @brief Select the anti-pop circuitry's ramp up speed.
+ *
+ * This enumeration defines all of the possible ramp up speeds for the
+ * anti-pop circuitry. A slow ramp up speed may be required in order to
+ * avoid the popping noise that is typically generated during the insertion
+ * or removal of a headset or microphone.
+ */
+typedef enum _PMIC_AUDIO_ANTI_POP_RAMP_SPEED{
+	ANTI_POP_RAMP_FAST,	/*!< Select fast ramp up.          */
+	ANTI_POP_RAMP_SLOW	/*!< Select slow ramp up.          */
+} PMIC_AUDIO_ANTI_POP_RAMP_SPEED;
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+ * @brief Select the Voice CODEC input clock frequency.
+ *
+ * This enumeration defines all of the supported Voice CODEC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Voice CODEC to operate at the required sampling
+ * rate.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ{
+	VCODEC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.    */
+	VCODEC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz. */
+	VCODEC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+						  .         */
+	VCODEC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.    */
+	VCODEC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.  */
+} PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CONFIG
+ * @brief Select the Voice CODEC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Voice CODEC options.
+ * This includes the use of highpass digital filters and audio signal
+ * loopback modes.
+ *
+ * Note that resetting the digital filters is now handled by the
+ * pmic_audio_digital_filter_reset() API.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_CONFIG{
+	DITHERING = 1,		/*!< Enable/disable dithering.      */
+	INPUT_HIGHPASS_FILTER = 2,	/*!< Enable/disable the input high */
+	/* pass digital filter.*/
+	OUTPUT_HIGHPASS_FILTER = 4,	/*!< Enable/disable the output high */
+	/*  pass digital filter. */
+	ANALOG_LOOPBACK = 8,	/*!< Enable/disable the analog */
+	/* loopback path */
+	DIGITAL_LOOPBACK = 16,	/*!< Enable/disable the digital
+							  loopback path.                 */
+	VCODEC_MASTER_CLOCK_OUTPUTS = 32,	/*!< Enable/disable the */
+	/* bus master clock outputs. */
+	TRISTATE_TS = 64	/*!< Enable/disable FSYNC, BITCLK,*/
+		/* and TX tristate. */
+} PMIC_AUDIO_VCODEC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+ * @brief Select the Stereo DAC input clock frequency.
+ *
+ * This enumeration defines all of the supported Stereo DAC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Stereo DAC to operate at the required sampling
+ * rate.
+ */
+typedef enum _PMIC_AUDIO_STDAC_CLOCK_IN_FREQ{
+	STDAC_CLI_3_36864MHZ,	/*!< Clock frequency is 3.36864MHz
+							  .                */
+	STDAC_CLI_12MHZ,	/*!< Clock frequency is 12MHz.
+						  .                */
+	STDAC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.           */
+	STDAC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz.        */
+	STDAC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+						  .                */
+	STDAC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.           */
+	STDAC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.         */
+	STDAC_MCLK_PLL_DISABLED,	/*!< Use MCLK and */
+	/* disable internal PLL.  */
+	STDAC_FSYNC_IN_PLL,	/*!< Use FSYNC as internal PLL input.    */
+	STDAC_BCLK_IN_PLL	/*!< Use BCLK as internal PLL input.     */
+} PMIC_AUDIO_STDAC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CONFIG
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Stereo DAC options.
+ */
+typedef enum _PMIC_AUDIO_STDAC_CONFIG{
+	STDAC_MASTER_CLOCK_OUTPUTS = 1	/*!< Enable/disable the bus master clock */
+		/*  outputs.*/
+} PMIC_AUDIO_STDAC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name Voice CODEC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_TIMESLOT
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to select the timeslot for both the primary and
+ * secondary (for mc13783-only) audio channels to the Voice CODEC.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_TIMESLOT{
+	USE_TS0,		/*!< Use timeslot 0 for audio signal source
+					  .                    */
+	USE_TS1,		/*!< Use timeslot 1 for audio signal source
+					  .                    */
+	USE_TS2,		/*!< Use timeslot 2 for audio signal source
+					  .                    */
+	USE_TS3			/*!< Use timeslot 3 for audio signal source
+					  .                    */
+} PMIC_AUDIO_VCODEC_TIMESLOT;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the secondary channel input gain for the Voice
+ * CODEC mixer.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_MIX_IN_GAIN{
+	VCODEC_NO_MIX,		/*!< No audio mixing .  */
+	VCODEC_MIX_IN_0DB,	/*!< Mix with 0dB */
+	/* secondary channel gain
+	   .                  */
+	VCODEC_MIX_IN_MINUS_6DB,	/*!< Mix with -6dB */
+	/* secondary channel gain */
+	VCODEC_MIX_IN_MINUS_12DB,	/*!< Mix with -12dB */
+	/* secondary channel gain */
+} PMIC_AUDIO_VCODEC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the output gain for the Voice CODEC mixer.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_MIX_OUT_GAIN{
+	VCODEC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain
+						  .                  */
+	VCODEC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain */
+} PMIC_AUDIO_VCODEC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Stereo DAC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_TIMESLOTS
+ * @brief Select the timeslots used to transmit the left and right audio
+ *        channels to the Stereo DAC.
+ *
+ * This enumeration is used to select the timeslots used to transmit the
+ * data corresponding to the left and right audio channels to the Stereo
+ * DAC.
+ */
+typedef enum _PMIC_AUDIO_STDAC_TIMESLOTS{
+	USE_TS0_TS1,		/*!< Use timeslots 0 and 1 for left and */
+	/* right channels, respectively.      */
+	USE_TS2_TS3,		/*!< Use timeslots 2 and 3 for left and */
+	/*right channels, respectively */
+	USE_TS4_TS5,		/*!< Use timeslots 4 and 5 for left and */
+	/*  right channels, respectively */
+	USE_TS6_TS7		/*!< Use timeslots 6 and 7 for left and */
+		/*  right channels, respectively */
+} PMIC_AUDIO_STDAC_TIMESLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the secondary channel input gain for
+ * the Stereo DAC mixer.
+ */
+typedef enum _PMIC_AUDIO_STDAC_MIX_IN_GAIN{
+	STDAC_NO_MIX,		/*!< No mixing, keep separate left
+						  and right audio channels.         */
+	STDAC_MIX_IN_0DB,	/*!< Mix left and right audio channels
+						  together with 0dB secondary
+						  channel gain.                     */
+	STDAC_MIX_IN_MINUS_6DB,	/*!< Mix left and right audio channels
+							  together with -6dB secondary
+							  channel gain.                     */
+	STDAC_MIX_IN_MINUS_12DB	/*!< Mix left and right audio channels
+							  together with -12dB secondary
+							  channel gain . */
+} PMIC_AUDIO_STDAC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the output gain for the Stereo DAC
+ * mixer.
+ */
+typedef enum _PMIC_AUDIO_STDAC_MIX_OUT_GAIN{
+	STDAC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain.     */
+	STDAC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain
+								  .              */
+} PMIC_AUDIO_STDAC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Microphone Input Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or microphone inputs for recording.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_MIC_BIAS
+ * @brief Select the microphone bias circuit to be enabled/disabled.
+ *
+ * This enumeration lists all of the available microphone bias circuits that
+ * may be enabled or disabled.
+ */
+typedef enum _PMIC_AUDIO_MIC_BIAS{
+	NO_BIAS = 0,		/*!< No microphone
+						  bias circuit selected. */
+	MIC_BIAS1 = 1,		/*!< Enable/disable
+						  microphone bias 1 circuit. */
+	MIC_BIAS2 = 2,		/*!< Enable/disable
+						  microphone bias 2 circuit. */
+} PMIC_AUDIO_MIC_BIAS;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_PORT
+ * @brief Select an audio input port for recording.
+ *
+ * This enumeration lists all of the available audio input ports that may
+ * be selected for a recording operation.
+ */
+typedef enum _PMIC_AUDIO_INPUT_PORT{
+	NO_MIC,			/*!< No microphone
+					  input selected. */
+	MIC1_LEFT,		/*!< Enable left/mono
+					  channel microphone input. */
+	MIC1_RIGHT_MIC_MONO,	/*!< Enable right
+							  channel microphone input. */
+	MIC2_AUX,		/*!< Enable auxiliary
+					  microphone input. */
+	TXIN_EXT		/*!< Enable external
+					  mono input. */
+} PMIC_AUDIO_INPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_MIC_STATE
+ * @brief Control whether the input microphone is on/off.
+ *
+ * This enumeration allows the currently selected input microphone amplifier
+ * to be turned on/off.
+ */
+typedef enum _PMIC_AUDIO_INPUT_MIC_STATE{
+	MICROPHONE_ON,		/*!< Turn microphone input on for recording. */
+	MICROPHONE_OFF		/*!< Turn microphone input off (mute).       */
+} PMIC_AUDIO_INPUT_MIC_STATE;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_CONFIG
+ * @brief Enable/disable the audio input options.
+ *
+ * This enumeration allows for enabling/disabling any of the audio input
+ * section options.
+ */
+typedef enum _PMIC_AUDIO_INPUT_CONFIG{
+	MIC_AMP_AUTO_DISABLE = 1	/* !< Enable/disable
+								   automatic disabling of
+								   microphone input
+								   amplifiers following
+								   headset insertion/removal */
+} PMIC_AUDIO_INPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_AMP_MODE
+ * @brief Select the operating mode for the microphone amplifiers.
+ *
+ * This enumeration is used to select the operating mode for the microphone
+ * amplifier.
+ */
+typedef enum _PMIC_AUDIO_MIC_AMP_MODE{
+	AMP_OFF,		/*!< Disable input amplifier.   */
+	VOLTAGE_TO_VOLTAGE,	/*!< Operate input amplifier in
+						  voltage-to-voltage mode
+						  .       */
+	CURRENT_TO_VOLTAGE	/*!< Operate input amplifier in
+						  current-to-voltage mode    */
+} PMIC_AUDIO_MIC_AMP_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_GAIN
+ * @brief Select the microphone amplifier gain level.
+ *
+ * This enumeration lists all of the available microphone amplifier gain
+ * levels.
+ */
+typedef enum _PMIC_AUDIO_MIC_GAIN{
+	MIC_GAIN_MINUS_8DB,	/*!< Select -8dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_7DB,	/*!< Select -7dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_6DB,	/*!< Select -6dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_5DB,	/*!< Select -5dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_4DB,	/*!< Select -4dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_3DB,	/*!< Select -3dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_2DB,	/*!< Select -2dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_1DB,	/*!< Select -1dB
+						  microphone amplifier gain */
+	MIC_GAIN_0DB,		/*!< Select 0dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_1DB,	/*!< Select 1dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_2DB,	/*!< Select 2dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_3DB,	/*!< Select 3dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_4DB,	/*!< Select 4dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_5DB,	/*!< Select 5dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_6DB,	/*!< Select 6dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_7DB,	/*!< Select 7dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_8DB,	/*!< Select 8dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_9DB,	/*!< Select 9dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_10DB,	/*!< Select 10dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_11DB,	/*!< Select 11dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_12DB,	/*!< Select 12dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_13DB,	/*!< Select 13dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_14DB,	/*!< Select 14dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_15DB,	/*!< Select 15dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_16DB,	/*!< Select 16dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_17DB,	/*!< Select 17dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_18DB,	/*!< Select 18dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_19DB,	/*!< Select 19dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_20DB,	/*!< Select 20dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_21DB,	/*!< Select 21dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_22DB,	/*!< Select 22dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_23DB,	/*!< Select 23dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_24DB,	/*!< Select 24dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_25DB,	/*!< Select 25dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_26DB,	/*!< Select 26dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_27DB,	/*!< Select 27dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_28DB,	/*!< Select 28dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_29DB,	/*!< Select 29dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_30DB,	/*!< Select 30dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_31DB	/*!< Select 31dB microphone
+						  amplifier gain. */
+} PMIC_AUDIO_MIC_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or audio output ports for playback.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PORT
+ * @brief Select the audio output port.
+ *
+ * This enumeration lists all of the available audio output ports. One or
+ * more may be selected as desired to handle the output audio stream from
+ * either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_PORT{
+	MONO_SPEAKER = 1,	/*!< Select mono output speaker.            */
+	MONO_LOUDSPEAKER = 2,	/*!< Select mono loudspeaker
+							  .                   */
+	MONO_ALERT = 4,		/*!< Select mono alert output               */
+	MONO_EXTOUT = 8,	/*!< Select mono external output            */
+	MONO_CDCOUT = 16,	/*!< Select dedicated Voice CODEC output
+						  .                   */
+	STEREO_LEFT_LOW_POWER = 32,	/*!< Select stereo left channel low power
+								  output .            */
+	STEREO_HEADSET_LEFT = 64,	/*!< Select stereo headset left channel.    */
+	STEREO_HEADSET_RIGHT = 128,	/*!< Select stereo headset right channel.   */
+	STEREO_OUT_LEFT = 256,	/*!< Select stereo external left channel
+							  output .            */
+	STEREO_OUT_RIGHT = 512	/*!< Select stereo external right channel
+							  output .            */
+} PMIC_AUDIO_OUTPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_CONFIG
+ * @brief Enable/disable the audio output section options.
+ *
+ * This enumeration is used to enable/disable any of the audio output section
+ * options.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_CONFIG{
+	MONO_SPEAKER_INVERT_OUT_ONLY = 1,	/*!< Enable/disable the non-inverted
+										  mono speaker output          */
+	MONO_LOUDSPEAKER_COMMON_BIAS = 2,	/*!< Enable/disable the loudspeaker
+										  output amplifier common bias
+										  .            */
+	HEADSET_DETECT_ENABLE = 4,	/*!< Enable/disable headset
+								  insertion/removal detection
+								  .            */
+	STEREO_HEADSET_AMP_AUTO_DISABLE = 8	/*!< Enable/disable automatic
+										  disabling of the stereo headset
+										  output amplifiers following
+										  headset insertion/removal.      */
+} PMIC_AUDIO_OUTPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_STEREO_IN_GAIN
+ * @brief Select the amplifier gain for the external stereo inputs.
+ *
+ * This enumeration is used to select the amplifier gain level to be used for
+ * the external stereo inputs.
+ */
+typedef enum _PMIC_AUDIO_STEREO_IN_GAIN{
+	STEREO_IN_GAIN_0DB,	/*!< Select 0dB external stereo signal
+						  input gain.                        */
+	STEREO_IN_GAIN_PLUS_18DB	/*!< Select 18dB external stereo signal
+								  input gain .    */
+} PMIC_AUDIO_STEREO_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PGA_GAIN
+ * @brief Select the output PGA amplifier gain level.
+ *
+ * This enumeration is used to select the output PGA amplifier gain level.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_PGA_GAIN{
+	OUTPGA_GAIN_MINUS_33DB,	/*!< Select -33dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_30DB,	/*!< Select -30dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_27DB,	/*!< Select -27dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_24DB,	/*!< Select -24dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_21DB,	/*!< Select -21dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_18DB,	/*!< Select -18dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_15DB,	/*!< Select -15dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_12DB,	/*!< Select -12dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_9DB,	/*!< Select -9dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_6DB,	/*!< Select -6dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_3DB,	/*!< Select -3dB output PGA gain.  */
+	OUTPGA_GAIN_0DB,	/*!< Select 0dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_3DB,	/*!< Select 3dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_6DB,	/*!< Select 6dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_9DB,	/*!< Select 9dB output PGA gain.
+							  .     */
+	OUTPGA_GAIN_PLUS_12DB,	/*!< Select 12dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_15DB,	/*!< Select 15dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_18DB,	/*!< Select 18dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_21DB	/*!< Select 21dB output PGA gain
+							  .     */
+} PMIC_AUDIO_OUTPUT_PGA_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+ * @brief Select the left/right channel balance gain level.
+ *
+ * This enumeration is used to select the balance gain level that is to be
+ * separately applied to the left and right audio channels.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_BALANCE_GAIN{
+	BAL_GAIN_MINUS_21DB,	/*!< Select -21dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_18DB,	/*!< Select -18dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_15DB,	/*!< Select -15dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_12DB,	/*!< Select -12dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_9DB,	/*!< Select -9dB channel balance
+						  gain .        */
+	BAL_GAIN_MINUS_6DB,	/*!< Select -6dB channel balance
+						  gain .        */
+	BAL_GAIN_MINUS_3DB,	/*!< Select -3dB channel balance
+						  gain .        */
+	BAL_GAIN_0DB		/*!< Select 0dB channel balance gain. */
+} PMIC_AUDIO_OUTPUT_BALANCE_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_MODE
+ * @brief Select the output mono adder operating mode.
+ *
+ * This enumeration is used to select the operating mode for the mono adder
+ * in the audio output section.
+ */
+typedef enum _PMIC_AUDIO_MONO_ADDER_MODE{
+	MONO_ADDER_OFF,		/*!< Disable mono adder (keep separate
+						  left and right channels).         */
+	MONO_ADD_LEFT_RIGHT,	/*!< Add left and right channels.      */
+	MONO_ADD_OPPOSITE_PHASE,	/*!< Add left and right channels but
+								  with outputs in opposite phase
+								  .              */
+	STEREO_OPPOSITE_PHASE	/*!< Keep separate left and right
+							  channels but invert phase of
+							  left channel . */
+} PMIC_AUDIO_MONO_ADDER_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+ * @brief Select the mono adder output amplifier gain level.
+ *
+ * This enumeration is used to select the output amplifier gain level for
+ * the mono adder.
+ */
+typedef enum _PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN{
+	MONOADD_GAIN_MINUS_6DB,	/*!< Select -6dB mono adder output gain
+							  .          */
+	MONOADD_GAIN_MINUS_3DB,	/*!< Select -3dB mono adder output gain
+							  .          */
+	MONOADD_GAIN_0DB	/*!< Select 0dB mono adder output gain. */
+} PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN;
+
+/*@}*/
+
+/***************************************************************************
+ *                       PMIC-SPECIFIC DEFINITIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name Definition of PMIC-specific Capabilities
+ * Constants that are used to define PMIC-specific capabilities.
+ */
+/*@{*/
+
+/*!
+ * Define the minimum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MIN_STDAC_SAMPLING_RATE_HZ;
+/*!
+ * Define the maximum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MAX_STDAC_SAMPLING_RATE_HZ;
+
+/*@}*/
+
+#define DEBUG_AUDIO
+
+#ifdef __KERNEL__
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Audio
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * This function enables the Headset detection mechanism in hardware
+ */
+PMIC_STATUS pmic_audio_set_autodetect(int val);
+
+/*!
+ * @brief Request exclusive access to the PMIC Audio hardware.
+ *
+ * Attempt to open and gain exclusive access to a key PMIC audio hardware
+ * component (e.g., the Stereo DAC or the Voice CODEC). Depending upon the
+ * type of audio operation that is desired and the nature of the audio data
+ * stream, the Stereo DAC and/or the Voice CODEC will be a required hardware
+ * component and needs to be acquired by calling this function.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls to complete
+ * the configuration of either the Stereo DAC or the Voice CODEC and along
+ * with any other associated audio hardware components that will be needed.
+ *
+ * The same handle must also be used in the close call when use of the PMIC
+ * audio hardware is no longer required.
+ *
+ * The open request will fail if the requested audio hardware component has
+ * already been acquired by a previous open call but not yet closed.
+ *
+ * @param[out]  handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param[in]   device          The required PMIC audio hardware component.
+ *
+ * @retval      PMIC_SUCCESS         If the open request was successful
+ * @retval      PMIC_PARAMETER_ERROR If the handle argument is NULL.
+ * @retval      PMIC_ERROR           If the audio hardware component is
+ *                                   unavailable.
+ */
+PMIC_STATUS pmic_audio_open(PMIC_AUDIO_HANDLE * const handle,
+		const PMIC_AUDIO_SOURCE device);
+
+/*!
+ * @brief Terminate further access to the PMIC audio hardware.
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_close(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure the data bus protocol to be used.
+ *
+ * Provide the parameters needed to properly configure the audio data bus
+ * protocol so that data can be read/written to either the Stereo DAC or
+ * the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   busID           Select data bus to be used.
+ * @param[in]   protocol        Select the data bus protocol.
+ * @param[in]   masterSlave     Select the data bus timing mode.
+ * @param[in]   numSlots        Define the number of timeslots (only if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the protocol parameters
+ *                                   are invalid.
+ */
+PMIC_STATUS pmic_audio_set_protocol(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_DATA_BUS busID,
+		const PMIC_AUDIO_BUS_PROTOCOL protocol,
+		const PMIC_AUDIO_BUS_MODE masterSlave,
+		const PMIC_AUDIO_NUMSLOTS numSlots);
+
+/*!
+ * @brief Retrieve the current data bus protocol configuration.
+ *
+ * Retrieve the parameters that define the current audio data bus protocol.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  busID           The data bus being used.
+ * @param[out]  protocol        The data bus protocol being used.
+ * @param[out]  masterSlave     The data bus timing mode being used.
+ * @param[out]  numSlots        The number of timeslots being used (if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_protocol(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_DATA_BUS * const busID,
+		PMIC_AUDIO_BUS_PROTOCOL * const protocol,
+		PMIC_AUDIO_BUS_MODE * const masterSlave,
+		PMIC_AUDIO_NUMSLOTS * const numSlots);
+
+/*!
+ * @brief Enable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly enable the Stereo DAC or the Voice CODEC to begin audio
+ * playback or recording as required. This should only be done after
+ * successfully configuring all of the associated audio components (e.g.,
+ * microphones, amplifiers, etc.).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be enabled.
+ */
+PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly disable the Stereo DAC or the Voice CODEC to end audio
+ * playback or recording as required.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be disabled.
+ */
+PMIC_STATUS pmic_audio_disable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their power on state.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset all audio hardware control registers to their power on state.
+ *
+ * This resets all of the audio hardware control registers back to their
+ * power on states. Use this function with care since it also invalidates
+ * (i.e., automatically closes) all currently opened device handles.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset_all(void);
+
+/*!
+ * @brief Set the Audio callback function.
+ *
+ * Register a callback function that will be used to signal PMIC audio
+ * events. For example, the OSS audio driver should register a callback
+ * function in order to be notified of headset connect/disconnect events.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   func            A pointer to the callback function.
+ * @param[in]   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_audio_set_callback(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CALLBACK func,
+		const PMIC_AUDIO_EVENTS eventMask);
+
+/*!
+ * @brief Deregisters the existing audio callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_audio_set_callback().
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_clear_callback(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Get the current audio callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  func            The current callback function.
+ * @param[out]  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_callback(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CALLBACK * const func,
+		PMIC_AUDIO_EVENTS * const eventMask);
+
+/*!
+ * @brief Enable the anti-pop circuitry to avoid extra noise when inserting
+ *        or removing a external device (e.g., a headset).
+ *
+ * Enable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug. A slow ramp speed may be needed to avoid extra noise.
+ *
+ * @param[in]   rampSpeed       The desired anti-pop circuitry ramp speed.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   enabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_antipop_enable(const PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+		rampSpeed);
+
+/*!
+ * @brief Disable the anti-pop circuitry.
+ *
+ * Disable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   disabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_antipop_disable(void);
+
+/*!
+ * @brief Performs a reset of the Voice CODEC/Stereo DAC digital filter.
+ *
+ * This function performs a reset of the digital filter using the back-to-back
+ * SPI write procedure.
+ *
+ * @retval      PMIC_SUCCESS         If the digital filter was successfully
+ *                                   reset.
+ * @retval      PMIC_ERROR           If the digital filter could not be reset.
+ */
+PMIC_STATUS pmic_audio_digital_filter_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Get the most recent PTT button voltage reading.
+ *
+ * This function returns the most recent reading for the PTT button voltage.
+ * The value may be used during the processing of the PTT_BUTTON_RANGE event
+ * as part of the headset ID detection process.
+ *
+ * @retval      PMIC_SUCCESS         If the most recent PTT button voltage was
+ *                                   returned.
+ * @retval      PMIC_PARAMETER_ERROR If a NULL pointer argument was given.
+ */
+PMIC_STATUS pmic_audio_get_ptt_button_level(unsigned int *const level);
+
+#ifdef DEBUG_AUDIO
+
+/*!
+ * @brief Provide a hexadecimal dump of all PMIC audio registers (DEBUG only).
+ *
+ * This function is intended strictly for debugging purposes only (i.e.,
+ * the DEBUG macro must be defined) and will print the current values of the
+ * following PMIC registers:
+ *
+ * - AUD_CODEC (Voice CODEC state)
+ * - ST_DAC (Stereo DAC state)
+ * - RX_AUD_AMPS (audio input section state)
+ * - TX_AUD_AMPS (audio output section state)
+ *
+ * The register fields will also be decoded.
+ */
+void pmic_audio_dump_registers(void);
+
+#endif				/* DEBUG */
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice
+ * CODEC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Voice CODEC clock source and operating characteristics.
+ *
+ * Define the Voice CODEC clock source and operating characteristics. This
+ * must be done before the Voice CODEC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE
+		clockIn,
+		const PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_VCODEC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Voice CODEC clock source and operating characteristics.
+ *
+ * Get the current Voice CODEC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_VCODEC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Voice CODEC primary audio channel timeslot.
+ *
+ * Set the Voice CODEC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot);
+
+/*!
+ * @brief Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot);
+
+/*!
+ * @brief Set the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Set the Voice CODEC secondary audio channel timeslot. This function must be
+ * used if the default timeslot for the secondary audio channel is to be
+ * changed. The secondary audio channel timeslot is used to transmit the audio
+ * data that was recorded by the Voice CODEC from the secondary audio input
+ * channel.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		const
+		PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot);
+
+/*!
+ * @brief Get the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Get the Voice CODEC secondary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot);
+
+/*!
+ * @brief Set/Enable the Voice CODEC options.
+ *
+ * Set or enable various Voice CODEC options. The available options include
+ * the use of dithering, highpass digital filters, and loopback modes.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Voice CODEC options.
+ *
+ * Clear or disable various Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG
+		config);
+
+/*!
+ * @brief Get the current Voice CODEC options.
+ *
+ * Get the current Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Voice CODEC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_CONFIG *
+		const config);
+
+/*!
+ * @brief Enable the Voice CODEC bypass audio pathway.
+ *
+ * Enables the Voice CODEC bypass pathway for audio data. This allows direct
+ * output of the voltages on the TX data bus line to the output amplifiers
+ * (bypassing the digital-to-analog converters within the Voice CODEC).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Voice CODEC bypass audio pathway.
+ *
+ * Disables the Voice CODEC bypass pathway for audio data. This means that
+ * the TX data bus line will deliver digital data to the digital-to-analog
+ * converters within the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo
+ * DAC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Stereo DAC clock source and operating characteristics.
+ *
+ * Define the Stereo DAC clock source and operating characteristics. This
+ * must be done before the Stereo DAC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE clockIn,
+		const PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_STDAC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Stereo DAC clock source and operating characteristics.
+ *
+ * Get the current Stereo DAC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_STDAC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Stereo DAC primary audio channel timeslot.
+ *
+ * Set the Stereo DAC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		timeslot);
+
+/*!
+ * @brief Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_TIMESLOTS *
+		const timeslot);
+
+/*!
+ * @brief Set/Enable the Stereo DAC options.
+ *
+ * Set or enable various Stereo DAC options. The available options include
+ * enabling/disabling the bus master clock outputs.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Stereo DAC options.
+ *
+ * Clear or disable various Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Get the current Stereo DAC options.
+ *
+ * Get the current Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Stereo DAC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Input Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio
+ * input hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set/Enable the audio input section options.
+ *
+ * Set or enable various audio input section options. The only available
+ * option right now is to enable the automatic disabling of the microphone
+ * input amplifiers when a microphone/headset is inserted or removed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_input_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the audio input section options.
+ *
+ * Clear or disable various audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to be
+ *                              cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_input_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Get the current audio input section options.
+ *
+ * Get the current audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of audio input section options.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_input_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Recording Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio recording.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the microphone inputs to be used for Voice CODEC recording.
+ *
+ * Select left  and right microphone inputs for Voice CODEC
+ * recording. It is possible to disable or not use a particular microphone
+ * input channel by specifying NO_MIC as a parameter.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     Select the left microphone input channel.
+ * @param[in]   rightChannel    Select the right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input ports
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be successfully enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_PORT leftChannel,
+		const PMIC_AUDIO_INPUT_PORT rightChannel);
+
+/*!
+ * @brief Get the current microphone inputs being used for Voice CODEC
+ *        recording.
+ *
+ * Get the left  and right microphone inputs currently being
+ * used for Voice CODEC recording.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The left microphone input channel.
+ * @param[out]  rightChannel    The right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_PORT * const leftChannel,
+		PMIC_AUDIO_INPUT_PORT *
+		const rightChannel);
+
+/*!
+ * @brief Enable/disable the microphone input.
+ *
+ * This function enables/disables the current microphone input channel. The
+ * input amplifier is automatically turned off when the microphone input is
+ * disabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     The left microphone input channel state.
+ * @param[in]   rightChannel    the right microphone input channel state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input states
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		leftChannel,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		rightChannel);
+
+/*!
+ * @brief Return the current state of the microphone inputs.
+ *
+ * This function returns the current state (on/off) of the microphone
+ * input channels.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The current left microphone input channel
+ *                              state.
+ * @param[out]  rightChannel    the current right microphone input channel
+ *                              state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channel states
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channel states
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const leftChannel,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const rightChannel);
+
+/*!
+ * @brief Set the microphone input amplifier mode and gain level.
+ *
+ * This function sets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannelMode  The left microphone input amplifier mode.
+ * @param[in]   leftChannelGain  The left microphone input amplifier gain level.
+ * @param[in]   rightChannelMode The right microphone input amplifier mode.
+ * @param[in]   rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifiers were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input amplifier
+ *                                   modes or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifiers could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_record_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		leftChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		leftChannelGain,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		rightChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		rightChannelGain);
+
+/*!
+ * @brief Get the current microphone input amplifier mode and gain level.
+ *
+ * This function gets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannelMode  The left microphone input amplifier mode.
+ * @param[out]  leftChannelGain  The left microphone input amplifier gain level.
+ * @param[out]  rightChannelMode The right microphone input amplifier mode.
+ * @param[out]  rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifier modes
+ *                                   and gain levels were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifier modes
+ *                                   and gain levels could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_record_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const leftChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const leftChannelGain,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const rightChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const rightChannelGain);
+
+/*!
+ * @brief Enable a microphone bias circuit.
+ *
+ * This function enables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be enabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit);
+
+/*!
+ * @brief Disable a microphone bias circuit.
+ *
+ * This function disables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Voice CODEC mixer.
+ *
+ * This function configures and enables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+		gainOut);
+
+/*!
+ * @brief Disable the Voice CODEC mixer.
+ *
+ * This function disables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo DAC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Stereo DAC mixer.
+ *
+ * This function configures and enables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_STDAC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+		gainOut);
+
+/*!
+ * @brief Disable the Stereo DAC mixer.
+ *
+ * This function disables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio output
+ * section to support playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the audio output ports.
+ *
+ * This function selects the audio output ports to be used. This also enables
+ * the appropriate output amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   acquired.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   acquired.
+ */
+PMIC_STATUS pmic_audio_output_set_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Deselect/disable the audio output ports.
+ *
+ * This function disables the audio output ports that were previously enabled
+ * by calling pmic_audio_output_set_port().
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_output_clear_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Get the current audio output ports.
+ *
+ * This function retrieves the audio output ports that are currently being
+ * used.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  port                The audio output ports currently being used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_port(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PORT * const port);
+
+/*!
+ * @brief Set the gain level for the external stereo inputs.
+ *
+ * This function sets the gain levels for the external stereo inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The external stereo input gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STEREO_IN_GAIN
+		gain);
+
+/*!
+ * @brief Get the current gain level for the external stereo inputs.
+ *
+ * This function retrieves the current gain levels for the external stereo
+ * inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current external stereo input gain
+ *                                  level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STEREO_IN_GAIN *
+		const gain);
+
+/*!
+ * @brief Set the output PGA gain level.
+ *
+ * This function sets the audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PGA_GAIN
+		gain);
+
+/*!
+ * @brief Get the output PGA gain level.
+ *
+ * This function retrieves the current audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PGA_GAIN *
+		const gain);
+
+/*!
+ * @brief Enable the output mixer.
+ *
+ * This function enables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the output mixer.
+ *
+ * This function disables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure and enable the output balance amplifiers.
+ *
+ * This function configures and enables the output balance amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   leftGain            The desired left channel gain level.
+ * @param[in]   rightGain           The desired right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifiers were
+ *                                   successfully configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifiers could not
+ *                                   be reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_output_set_balance(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		leftGain,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		rightGain);
+
+/*!
+ * @brief Get the current output balance amplifier gain levels.
+ *
+ * This function retrieves the current output balance amplifier gain levels.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  leftGain            The current left channel gain level.
+ * @param[out]  rightGain           The current right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifier gain levels
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifier gain levels
+ *                                   could be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_balance(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const leftGain,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const rightGain);
+
+/*!
+ * @brief Configure and enable the output mono adder.
+ *
+ * This function configures and enables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   mode                The desired mono adder operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mono adder mode was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be reconfigured
+ *                                   or enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mono_adder(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_MODE
+		mode);
+
+/*!
+ * @brief Disable the output mono adder.
+ *
+ * This function disables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mono_adder(const PMIC_AUDIO_HANDLE
+		handle);
+
+/*!
+ * @brief Configure the mono adder output gain level.
+ *
+ * This function configures the mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The desired output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_output_set_mono_adder_gain(
+		const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN gain);
+
+/*!
+ * @brief Get the current mono adder output gain level.
+ *
+ * This function retrieves the current mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_mono_adder_gain(
+		const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN *gain);
+
+/*!
+ * @brief Set various audio output section options.
+ *
+ * This function sets one or more audio output section configuration
+ * options. The currently supported options include whether to disable
+ * the non-inverting mono speaker output, enabling the loudspeaker common
+ * bias circuit, enabling detection of headset insertion/removal, and
+ * whether to automatically disable the headset amplifiers when a headset
+ * insertion/removal has been detected.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be set.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG config);
+
+/*!
+ * @brief Clear various audio output section options.
+ *
+ * This function clears one or more audio output section configuration
+ * options.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be cleared.
+ */
+PMIC_STATUS pmic_audio_output_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG
+		config);
+
+/*!
+ * @brief Get the current audio output section options.
+ *
+ * This function retrieves the current audio output section configuration
+ * option settings.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  config              The current audio output section
+ *                                  configuration option settings.
+ *
+ * @retval      PMIC_SUCCESS         If the current configuration options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the current configuration options
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_CONFIG *
+		const config);
+
+/*!
+ * @brief Enable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function enables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_phantom_ground(const PMIC_AUDIO_HANDLE
+		handle);
+
+/*!
+ * @brief Disable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function disables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_phantom_ground(const PMIC_AUDIO_HANDLE
+		handle);
+
+/*@}*/
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_AUDIO_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_battery.h b/include/asm-arm/plat-mxc/pmic_battery.h
new file mode 100644
index 0000000..f0efd20
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_battery.h
@@ -0,0 +1,405 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+
+/*!
+ * Get the charger voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_VOLTAGE			_IOR('p', 0xca, int)
+
+/*!
+ * Get the battery voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_VOLTAGE			_IOR('p', 0xcb, int)
+
+/*!
+ * Get the battery current.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_CURRENT			_IOR('p', 0xcc, int)
+
+/*!
+ * Get the charger sensor.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_SENSOR			_IOR('p', 0xcd, int)
+
+/*!
+ * Get the battery temperature.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_TEMPERATURE		_IOR('p', 0xce, int)
+
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum _t_batt_charger{
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum _t_bp_threshold{
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum _t_control{
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum _t_batt_event{
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct _t_charger_setting{
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct _t_eol_setting{
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+		unsigned char c_voltage,
+		unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+		unsigned char c_voltage,
+		unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+		unsigned char *c_voltage,
+		unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+ BPDET   UVDET   LOBATL
+ ____    _____   ___________
+ 0       2.6     UVDET + 0.2
+ 1       2.6     UVDET + 0.3
+ 2       2.6     UVDET + 0.4
+ 3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_convity.h b/include/asm-arm/plat-mxc/pmic_convity.h
new file mode 100644
index 0000000..a09eb90
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_convity.h
@@ -0,0 +1,875 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_CONVITY_H__
+#define __ASM_ARCH_MXC_PMIC_CONVITY_H__
+
+/*!
+ * @defgroup PMIC_CONNECTIVITY PMIC Connectivity Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_convity.h
+ * @brief External definitions for the PMIC Connectivity Client driver.
+ *
+ * The PMIC Connectivity driver and this API were developed to support the
+ * external connectivity capabilities of several power management ICs that
+ * are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes, in terms of external connectivity, are
+ * supported:
+ *
+ *
+ *
+ * @ingroup PMIC_CONNECTIVITY
+ */
+
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to and
+ * configuration of the PMIC Connectivity hardware.
+ */
+/*@{*/
+
+#define DEBUG_CONVITY
+
+/*!
+ * @typedef PMIC_CONVITY_HANDLE
+ * @brief Define typedef for a handle to the PMIC Connectivity hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Connectivity hardware
+ * is opened. This handle grants exclusive access to the PMIC Connectivity
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Connectivity hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long PMIC_CONVITY_HANDLE;
+
+/*!
+ * @enum PMIC_CONVITY_MODE
+ * @brief Select the main Connectivity operating mode.
+ *
+ * Defines all possible PMIC Connectivity main operating modes. Only one of
+ * these modes can be active at a time.
+ */
+typedef enum _PMIC_CONVITY_MODE{
+	USB,			/*!< Select USB mode
+					  (this is also the
+					  Reset/Default mode). */
+	RS232,			/*!< Select RS-232 mode.*/
+	RS232_1,		/*!< Select RS-232_1 mode. */
+	RS232_2,		/*!< Select RS-232_2 mode. */
+	CEA936_MONO,		/*!< Select CE-936 Mono mode. */
+	CEA936_STEREO,		/*!< Select CE-936 Stereo mode. */
+	CEA936_TEST_RIGHT,	/*!< Select CE-936 Right
+						  Channel Test mode. */
+	CEA936_TEST_LEFT	/*!< Select CE-936 Left Channel
+						  Test mode. */
+} PMIC_CONVITY_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_EVENTS
+ * @brief Identify the connectivity events that have been detected and should
+ * be handled.
+ *
+ * Defines all possible PMIC Connectivity events. Multiple events may be
+ * selected when defining a mask.
+ */
+typedef enum _PMIC_CONVITY_EVENTS{
+	USB_DETECT_4V4_RISE = 1,	/*!< Detected 4.4V rising edge.      */
+	USB_DETECT_4V4_FALL = 2,	/*!< Detected 4.4V falling edge.     */
+	USB_DETECT_2V0_RISE = 4,	/*!< Detected 2.0V rising edge.      */
+	USB_DETECT_2V0_FALL = 8,	/*!< Detected 2.0V falling edge.     */
+	USB_DETECT_0V8_RISE = 16,	/*!< Detected 0.8V rising edge.      */
+	USB_DETECT_0V8_FALL = 32,	/*!< Detected 0.8V falling edge.     */
+	USB_DETECT_MINI_A = 64,	/*!< Detected USB mini A plug.       */
+	USB_DETECT_MINI_B = 128,	/*!< Detected USB mini B plug.       */
+	USB_DETECT_NON_USB_ACCESSORY = 256,	/*!< Detected a non-USB connection */
+	USB_DETECT_FACTORY_MODE = 512,	/*!< Detected a factory-mode connect */
+	USB_DP_HI = 1024,
+
+	USB_DM_HI = 2048
+} PMIC_CONVITY_EVENTS;
+
+/*!
+ * @typedef PMIC_CONVITY_CALLBACK
+ * @brief Typedef for PMIC Connectivity event notification callback function.
+ *
+ * Define a typedef for the PMIC Connectivity event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef void (*PMIC_CONVITY_CALLBACK) (const PMIC_CONVITY_EVENTS event);
+
+/*@}*/
+
+/*!
+ * @name USB and USB On-The-Go Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the USB and USB On-The-Go modes of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_USB_DEVICE_TYPE
+ * @brief Select the USB device type (either A or B).
+ *
+ * Defines all possible USB device types. This must match the physical
+ * connector being used.
+ */
+typedef enum _PMIC_CONVITY_USB_DEVICE_TYPE{
+	USB_A_DEVICE,
+	USB_B_DEVICE
+} PMIC_CONVITY_USB_DEVICE_TYPE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_SPEED
+ * @brief Select the USB transceiver operating speed.
+ *
+ * Defines all possible USB transceiver operating speeds. Only one
+ * speed setting may be used at a time.
+ */
+typedef enum _PMIC_CONVITY_USB_SPEED{
+	USB_LOW_SPEED,		/*!< Select 1.5 Mbps.              */
+	USB_FULL_SPEED,		/*!< Select 12 Mbps.               */
+	USB_HIGH_SPEED		/*!< Select 480 Mbps */
+} PMIC_CONVITY_USB_SPEED;
+
+/*!
+ * @enum PMIC_CONVITY_USB_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all possible USB transceiver operating modes. Only one
+ * mode may be used at a time. The selected mode, in combination with
+ * the USB bus speed, determines the selection of pull-up and pull-down
+ * resistors.
+ */
+typedef enum _PMIC_CONVITY_USB_MODE{
+	USB_HOST,
+	USB_PERIPHERAL
+} PMIC_CONVITY_USB_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_IN
+ * @brief Select the USB transceiver's power regulator input source.
+ *
+ * Defines all possible input power sources for the USB transceiver power
+ * regulator. Only one power supply source may be selected at a time.
+ */
+typedef enum _PMIC_CONVITY_USB_POWER_IN{
+
+	USB_POWER_INTERNAL_BOOST,	/*!< Select internal power source */
+								  /* with boost. */
+
+	USB_POWER_VBUS,		/*!< Select VBUS power source.    */
+
+	USB_POWER_INTERNAL	/*!< Select internal power source
+						  .         */
+} PMIC_CONVITY_USB_POWER_IN;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_OUT
+ * @brief Select the USB transceiver power regulator output voltage.
+ *
+ * Defines all possible output voltages for the USB transceiver power
+ * regulator. Only one power output voltage level may be selected at
+ * a time.
+ */
+typedef enum _PMIC_CONVITY_USB_POWER_OUT{
+	USB_POWER_2V775,	/*!< Select 2.775V output voltage
+						  .         */
+	USB_POWER_3V3		/*!< Select 3.3V output voltage.  */
+} PMIC_CONVITY_USB_POWER_OUT;
+
+/*!
+ * @enum PMIC_CONVITY_USB_TRANSCEIVER_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all valid USB transceiver operating modes. Only one of the
+ * following USB transceiver modes may be selected at a time.
+ */
+typedef enum _PMIC_CONVITY_USB_TRANSCEIVER_MODE{
+	USB_TRANSCEIVER_OFF,	/*!< USB transceiver currently off
+							  .            */
+	USB_SINGLE_ENDED_UNIDIR,	/*!< Select Single-ended */
+								/*  unidirectional transmit mode.*/
+	USB_SINGLE_ENDED_UNIDIR_TX,	/*!< Select Single-ended */
+								 /*  unidirectional transmit mode.   */
+	USB_SINGLE_ENDED_UNIDIR_RX,	/*!< Select Single-ended
+								  unidirectional receive mode.    */
+	USB_SINGLE_ENDED_BIDIR,	/*!< Select Single-ended */
+							 /* bidirectional transmit mode.    */
+	USB_SINGLE_ENDED_LOW,	/*!< Select USB SE0 mode. */
+	USB_DIFFERENTIAL_UNIDIR_TX,	/*!< Select Differential */
+								/*  unidirectional transmit mode */
+	USB_DIFFERENTIAL_UNIDIR,	/*!< Select Differential */
+								/* unidirectional transmit mode */
+
+	USB_DIFFERENTIAL_UNIDIR_RX,	/*!< Select Differential */
+								/*  unidirectional receive mode. */
+	USB_DIFFERENTIAL_BIDIR,	/*!< Select Differential */
+							/* bidirectional transmit mode */
+	USB_SUSPEND_ON,		/*!< Select Suspend mode.	*/
+	USB_SUSPEND_OFF,	/*!< Terminate Suspend mode. */
+	USB_OTG_SRP_DLP_START,	/*!< Start USB On-The-Go Session */
+							/*  Request Protocol using Data */
+							/*  Line Pulsing. */
+	USB_OTG_SRP_DLP_STOP	/*!< Terminate USB On-The-Go Session */
+							/*  Request Protocol using Data */
+							/*  Line Pulsing. */
+} PMIC_CONVITY_USB_TRANSCEIVER_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_OTG_CONFIG
+ * @brief Select the USB On-The-Go configuration options.
+ *
+ * Defines all possible USB On-The-Go configuration options. Multiple
+ * configuration options may be selected at the same time. However, only one
+ * VBUS current limit may be selected at a time. Selecting more than one
+ * VBUS current limit will result in undefined and implementation-dependent
+ * behavior.
+ */
+typedef enum _PMIC_CONVITY_USB_OTG_CONFIG{
+	USB_OTG_SE0CONN = 0x00001,	/*!< Enable automatic
+								  connection of a pull-up
+								  resistor to VUSB when the
+								  SE0 condition is detected. */
+	USB_OTG_DLP_SRP = 0x00002,	/*!< Enable use of the hardware
+								  timer to control the
+								  duration of the data line
+								  pulse during the session
+								  request protocol.          */
+	USB_PULL_OVERRIDE = 0x00004,	/*!< Enable automatic disconnect
+									  of pull-up and pull-down
+									  resistors when transmitter
+									  is enabled.                */
+
+	USB_DP150K_PU = 0x00008,
+
+	USB_VBUS_CURRENT_LIMIT_HIGH = 0x00010, /*!< Select current
+											 limit to 200mA	for
+											 VBUS regulator. */
+	USB_VBUS_CURRENT_LIMIT_LOW = 0x00020,	/*!< Select low current
+											  limit for VBUS
+											  regulator. */
+	USB_VBUS_CURRENT_LIMIT_LOW_10MS = 0x00040,	/*!< Select low
+												  current limit for
+												  VBUS regulator for
+												  10 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_20MS = 0x00080,	/*!< Select low
+												  current limit
+												  for VBUS regulator for
+												  20 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_30MS = 0x00100,	/*!< Select low
+												  current limit
+												  for VBUS regulator for
+												  30 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_40MS = 0x00200,	/*!< Select low
+												  current limit
+												  for VBUS regulator for
+												  40 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_50MS = 0x00400,	/*!< Select low
+												  current limit
+												  for VBUS regulator for
+												  50 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_60MS = 0x00800,	/*!< Select low
+												  current limit
+												  for VBUS regulator for
+												  60 ms . */
+
+	USB_VBUS_PULLDOWN = 0x01000,	/*!< Enable VBUS pull-down.     */
+
+	USB_USBCNTRL = 0x02000,
+
+	USB_UDP_PD = 0x04000,
+
+	USB_UDM_PD = 0x08000,
+
+	USB_PU = 0x10000,
+
+	USBXCVREN = 0x20000
+} PMIC_CONVITY_USB_OTG_CONFIG;
+/*@}*/
+
+/*!
+ * @name RS-232 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the RS-232 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_RS232_EXTERNAL
+ * @brief Select the RS-232 transceiver external connections.
+ *
+ * Defines all valid RS-232 transceiver external RX/TX connection options.
+ * Only one connection mode may be selected at a time.
+ */
+typedef enum _PMIC_CONVITY_RS232_EXTERNAL{
+	RS232_TX_UDM_RX_UDP,	/*!< Select RS-232 TX on UDM   */
+	RS232_TX_UDP_RX_UDM,	/*!< Select RS-232 TX on UDP
+							  . */
+	RS232_TX_RX_EXTERNAL_DEFAULT	/*!< Use power on default.        */
+} PMIC_CONVITY_RS232_EXTERNAL;
+
+/*!
+ * @enum PMIC_CONVITY_RS232_INTERNAL
+ * @brief Select the RS-232 transceiver internal connections.
+ *
+ * Defines all valid RS-232 transceiver internal RX/TX connection options.
+ * Only one connection mode can be selected at a time.
+ */
+typedef enum _PMIC_CONVITY_RS232_INTERNAL{
+	RS232_TX_USE0VM_RX_UDATVP,	/*!< Select RS-232 TX from USE0VM
+								  .         */
+	RS232_TX_UDATVP_RX_URXVM,	/*!< Select RS-232 TX from UDATVP
+								  .         */
+	RS232_TX_UTXDI_RX_URXDO,	/*!< Select RS-232 TX from UTXDI
+								  .    */
+	RS232_TX_RX_INTERNAL_DEFAULT	/*!< Use power on default.     */
+} PMIC_CONVITY_RS232_INTERNAL;
+
+/*@}*/
+
+/*!
+ * @name CEA-936 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the CEA-936 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_CEA936_EXIT_SIGNAL
+ * @brief Select the CEA-936 mode exit signal.
+ *
+ * Defines all valid CEA-936 connection termination signals. Only one
+ * termination signal can be selected at a time.
+ */
+typedef enum _PMIC_CONVITY_CEA936_EXIT_SIGNAL{
+	CEA936_UID_NO_PULLDOWN,	/*!< No UID pull-down . */
+	CEA936_UID_PULLDOWN_6MS,	/*!< UID pull-down for 6 ms (+/-2 ms) */
+	CEA936_UID_PULLDOWN,	/*!< UID pulled down .  */
+	CEA936_UDMPULSE		/*!< UDM pulsed .       */
+} PMIC_CONVITY_CEA936_EXIT_SIGNAL;
+
+/*@}*/
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Connectivity
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Request exclusive access to the PMIC Connectivity hardware.
+ *
+ * Attempt to open and gain exclusive access to the PMIC Connectivity
+ * hardware. An initial operating mode (e.g., USB or RS-232) must also
+ * be specified.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls. The
+ * same handle must also be used in the close call when use of the PMIC
+ * connectivity hardware is no longer required.
+ *
+ * The open request will fail if another thread has already obtained the
+ * device handle and has not yet called pmic_convity_close() with it.
+ *
+ * @param   handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param   mode            Initial connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the open request was successful
+ * @retval      PMIC_ERROR      If the connectivity hardware cannot be opened.
+ */
+PMIC_STATUS pmic_convity_open(PMIC_CONVITY_HANDLE * const handle,
+		const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Terminate further access to the PMIC Connectivity hardware.
+ *
+ * Terminate further access to the PMIC Connectivity hardware. This also
+ * allows another thread to successfully call pmic_convity_open() to gain
+ * access.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_close(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the PMIC Connectivity main operating mode.
+ *
+ * Change the current operating mode of the PMIC Connectivity hardware.
+ * The available connectivity operating modes are hardware-dependent and
+ * consists of one or more of the following: USB (including USB On-the-Go),
+ * RS-232, and CEA-936. Requesting an operating mode that is not supported
+ * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired operating mode.
+ */
+PMIC_STATUS pmic_convity_set_mode(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Get the current PMIC Connectivity main operating mode.
+ *
+ * Get the current operating mode for the PMIC Connectivity hardware.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            The current PMIC Connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_mode(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_MODE * const mode);
+
+/*!
+ * @brief Reset the Connectivity hardware to it's power on state.
+ *
+ * Restore all registers to the initial power-on/reset state.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_reset(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the Connectivity callback function.
+ *
+ * Register a callback function that will be used to signal PMIC Connectivity
+ * events. For example, the USB subsystem should register a callback function
+ * in order to be notified of device connect/disconnect events. Note, however,
+ * that non-USB events may also be signalled depending upon the PMIC hardware
+ * capabilities. Therefore, the callback function must be able to properly
+ * handle all of the possible events if support for non-USB peripherals is
+ * also to be included.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   func            A pointer to the callback function.
+ * @param   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_convity_set_callback(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_CALLBACK func,
+		const PMIC_CONVITY_EVENTS eventMask);
+
+/*!
+ * @brief Deregisters the existing Connectivity callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_convity_set_callback().
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_clear_callback(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Get the current Connectivity callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param  handle          Device handle from open() call.
+ * @param  func            The current callback function.
+ * @param  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_callback(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_CALLBACK * const func,
+		PMIC_CONVITY_EVENTS * const eventMask);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name USB and USB On-The-Go APIs
+ * USB Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the USB transceiver's operating speed.
+ *
+ * Set the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   speed           The desired USB transceiver speed.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the high speed (480 Mbps) mode is
+ *                                   requested.
+ */
+PMIC_STATUS pmic_convity_usb_set_speed(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_SPEED speed);
+
+/*!
+ * This function enables/disables VUSB and VBUS output.
+ * This API configures the VUSBEN and VBUSEN bits of USB register
+ *
+ * @param   handle          Device handle from open() call.
+ * @param        out_type true, for VUSB
+ *                        false, for VBUS
+ * @param        out 	if true, output is enabled
+ *                      if false, output is disabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_convity_set_output(const PMIC_CONVITY_HANDLE handle,
+		bool out_type, bool out);
+
+/*!
+ * @brief Get the USB transceiver's operating speed.
+ *
+ * Get the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  speed           The current USB transceiver speed.
+ * @param  mode            The current USB transceiver mode.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ *                                   obtained
+ */
+PMIC_STATUS pmic_convity_usb_get_speed(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_SPEED * const speed,
+		PMIC_CONVITY_USB_MODE * const mode);
+
+/*!
+ * @brief Set the USB transceiver's power supply configuration.
+ *
+ * Set the USB transceiver's power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   pwrin           USB transceiver regulator input power source.
+ * @param   pwrout          USB transceiver regulator output power level.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired configuration.
+ */
+PMIC_STATUS pmic_convity_usb_set_power_source(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_POWER_IN
+		pwrin,
+		const PMIC_CONVITY_USB_POWER_OUT
+		pwrout);
+
+/*!
+ * @brief Get the USB transceiver's power supply configuration.
+ *
+ * Get the USB transceiver's current power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  pwrin           USB transceiver regulator input power source
+ * @param  pwrout          USB transceiver regulator output power level
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_power_source(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_POWER_IN *
+		const pwrin,
+		PMIC_CONVITY_USB_POWER_OUT *
+		const pwrout);
+
+/*!
+ * @brief Set the current USB transceiver operating mode.
+ *
+ * Set the USB transceiver's operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the USB transceiver's operating mode
+ *                              was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB transceiver mode is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_set_xcvr(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_TRANSCEIVER_MODE
+		mode);
+
+/*!
+ * @brief Get the current USB transceiver operating mode.
+ *
+ * Get the USB transceiver's current operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  mode            Current operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's operating mode
+ *                                   was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_xcvr(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_TRANSCEIVER_MODE *
+		const mode);
+
+/*!
+ * @brief Set the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Set the Data Line Pulse duration (in milliseconds) for the USB OTG
+ * Session Request Protocol.
+ *
+ * Note that for mc13783 the duration is fixed at 7.5 ms and calling this
+ * function will simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the data line pulse
+ *                                   duration is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired data line pulse duration
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_dlp_duration(const PMIC_CONVITY_HANDLE
+		handle,
+		const unsigned int duration);
+
+/*!
+ * @brief Get the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Get the current Data Line Pulse duration (in milliseconds) for the USB
+ * OTG Session Request Protocol.
+ *
+ * Note that the Data Line Pulse duration is fixed at 7.5 ms for the mc13783
+ * PMIC. Therefore, calling this function while using the mc13783 PMIC will
+ * simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully
+ *                                   obtained.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If called using the mc13783 PMIC.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_dlp_duration(const PMIC_CONVITY_HANDLE
+		handle,
+		unsigned int *const duration);
+
+/*!
+ * @brief Start the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the start of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully started
+ */
+PMIC_STATUS pmic_convity_usb_otg_begin_hnp(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_DEVICE_TYPE
+		deviceType);
+
+/*!
+ * @brief Complete the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the end of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully ended
+ */
+PMIC_STATUS pmic_convity_usb_otg_end_hnp(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_DEVICE_TYPE
+		deviceType);
+
+/*!
+ * @brief Set the current USB On-The-Go configuration.
+ *
+ * Set the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             Desired USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_OTG_CONFIG
+		cfg);
+
+/*!
+ * @brief Clear the current USB On-The-Go configuration.
+ *
+ * Clears the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             USB OTG configuration settings to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_clear_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_USB_OTG_CONFIG
+		cfg);
+
+/*!
+ * @brief Get the current USB On-The-Go configuration.
+ *
+ * Get the current USB On-The-Go (OTG) configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             The current USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_config(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_USB_OTG_CONFIG *
+		const cfg);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name RS-232 APIs
+ * RS-232 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the current RS-232 operating configuration.
+ *
+ * Set the connectivity interface to the selected RS-232 operating mode.
+ * Note that the RS-232 operating mode will be automatically overridden
+ * if the USB_EN is asserted at any time (e.g., when a USB device is
+ * attached).
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfgInternal     RS-232 transceiver internal connections.
+ * @param   cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired RS-232 configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_rs232_set_config(const PMIC_CONVITY_HANDLE handle,
+		const PMIC_CONVITY_RS232_INTERNAL
+		cfgInternal,
+		const PMIC_CONVITY_RS232_EXTERNAL
+		cfgExternal);
+
+/*!
+ * @brief Get the current RS-232 operating configuration.
+ *
+ * Get the connectivity interface's current RS-232 operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  cfgInternal     RS-232 transceiver internal connections.
+ * @param  cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_rs232_get_config(const PMIC_CONVITY_HANDLE handle,
+		PMIC_CONVITY_RS232_INTERNAL *
+		const cfgInternal,
+		PMIC_CONVITY_RS232_EXTERNAL *
+		const cfgExternal);
+
+/***************************************************************************/
+
+/*@}*/
+
+/*!
+ * @name CE-936 APIs
+ * CE-936 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Send a signal to exit CEA-936 mode.
+ *
+ * Signal the attached device to exit the current CEA-936 operating mode.
+ * Returns an error if the current operating mode is not CEA-936.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   signal          Type of exit signal to be sent.
+ *
+ * @retval      PMIC_SUCCESS         If the CEA-936 exit mode signal was sent.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired CEA-936 exit mode signal
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_cea936_exit_signal(const PMIC_CONVITY_HANDLE handle,
+		const
+		PMIC_CONVITY_CEA936_EXIT_SIGNAL
+		signal);
+
+/*@}*/
+
+#endif				/* __ASM_ARCH_MXC_PMIC_CONVITY_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_external.h b/include/asm-arm/plat-mxc/pmic_external.h
new file mode 100644
index 0000000..c6a6f80
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_external.h
@@ -0,0 +1,1114 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum _pmic_id_t{
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3,
+	PMIC_MC34704 = 4
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct _pmic_version_t{
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its
+ * parameter to be used when un/registering and launching a callback
+ * for an event.
+ */
+typedef struct _pmic_event_callback_t{
+	/*!
+	 * call back function
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct _register_info{
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for pmic core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#ifdef CONFIG_MXC_PMIC_MC13783
+
+#define PMIC_ARBITRATION	"NULL"
+/*!
+ * This is the enumeration of register names of MC13783
+ */
+typedef enum _pmic_reg{
+	/*!
+	 * REG_INTERRUPT_STATUS_0
+	 */
+	REG_INTERRUPT_STATUS_0 = 0,
+	/*!
+	 * REG_INTERRUPT_MASK_0
+	 */
+	REG_INTERRUPT_MASK_0,
+	/*!
+	 * REG_INTERRUPT_SENSE_0
+	 */
+	REG_INTERRUPT_SENSE_0,
+	/*!
+	 * REG_INTERRUPT_STATUS_1
+	 */
+	REG_INTERRUPT_STATUS_1,
+	/*!
+	 * REG_INTERRUPT_MASK_1
+	 */
+	REG_INTERRUPT_MASK_1,
+	/*!
+	 * REG_INTERRUPT_SENSE_1
+	 */
+	REG_INTERRUPT_SENSE_1,
+	/*!
+	 * REG_POWER_UP_MODE_SENSE
+	 */
+	REG_POWER_UP_MODE_SENSE,
+	/*!
+	 * REG_REVISION
+	 */
+	REG_REVISION,
+	/*!
+	 * REG_SEMAPHORE
+	 */
+	REG_SEMAPHORE,
+	/*!
+	 * REG_ARBITRATION_PERIPHERAL_AUDIO
+	 */
+	REG_ARBITRATION_PERIPHERAL_AUDIO,
+	/*!
+	 * REG_ARBITRATION_SWITCHERS
+	 */
+	REG_ARBITRATION_SWITCHERS,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_0
+	 */
+	REG_ARBITRATION_REGULATORS_0,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_1
+	 */
+	REG_ARBITRATION_REGULATORS_1,
+	/*!
+	 * REG_POWER_CONTROL_0
+	 */
+	REG_POWER_CONTROL_0,
+	/*!
+	 * REG_POWER_CONTROL_1
+	 */
+	REG_POWER_CONTROL_1,
+	/*!
+	 * REG_POWER_CONTROL_2
+	 */
+	REG_POWER_CONTROL_2,
+	/*!
+	 * REG_REGEN_ASSIGNMENT
+	 */
+	REG_REGEN_ASSIGNMENT,
+	/*!
+	 * REG_CONTROL_SPARE
+	 */
+	REG_CONTROL_SPARE,
+	/*!
+	 * REG_MEMORY_A
+	 */
+	REG_MEMORY_A,
+	/*!
+	 * REG_MEMORY_B
+	 */
+	REG_MEMORY_B,
+	/*!
+	 * REG_RTC_TIME
+	 */
+	REG_RTC_TIME,
+	/*!
+	 * REG_RTC_ALARM
+	 */
+	REG_RTC_ALARM,
+	/*!
+	 * REG_RTC_DAY
+	 */
+	REG_RTC_DAY,
+	/*!
+	 * REG_RTC_DAY_ALARM
+	 */
+	REG_RTC_DAY_ALARM,
+	/*!
+	 * REG_SWITCHERS_0
+	 */
+	REG_SWITCHERS_0,
+	/*!
+	 * REG_SWITCHERS_1
+	 */
+	REG_SWITCHERS_1,
+	/*!
+	 * REG_SWITCHERS_2
+	 */
+	REG_SWITCHERS_2,
+	/*!
+	 * REG_SWITCHERS_3
+	 */
+	REG_SWITCHERS_3,
+	/*!
+	 * REG_SWITCHERS_4
+	 */
+	REG_SWITCHERS_4,
+	/*!
+	 * REG_SWITCHERS_5
+	 */
+	REG_SWITCHERS_5,
+	/*!
+	 * REG_REGULATOR_SETTING_0
+	 */
+	REG_REGULATOR_SETTING_0,
+	/*!
+	 * REG_REGULATOR_SETTING_1
+	 */
+	REG_REGULATOR_SETTING_1,
+	/*!
+	 * REG_REGULATOR_MODE_0
+	 */
+	REG_REGULATOR_MODE_0,
+	/*!
+	 * REG_REGULATOR_MODE_1
+	 */
+	REG_REGULATOR_MODE_1,
+	/*!
+	 * REG_POWER_MISCELLANEOUS
+	 */
+	REG_POWER_MISCELLANEOUS,
+	/*!
+	 * REG_POWER_SPARE
+	 */
+	REG_POWER_SPARE,
+	/*!
+	 * REG_AUDIO_RX_0
+	 */
+	REG_AUDIO_RX_0,
+	/*!
+	 * REG_AUDIO_RX_1
+	 */
+	REG_AUDIO_RX_1,
+	/*!
+	 * REG_AUDIO_TX
+	 */
+	REG_AUDIO_TX,
+	/*!
+	 * REG_AUDIO_SSI_NETWORK
+	 */
+	REG_AUDIO_SSI_NETWORK,
+	/*!
+	 * REG_AUDIO_CODEC
+	 */
+	REG_AUDIO_CODEC,
+	/*!
+	 * REG_AUDIO_STEREO_DAC
+	 */
+	REG_AUDIO_STEREO_DAC,
+	/*!
+	 * REG_AUDIO_SPARE
+	 */
+	REG_AUDIO_SPARE,
+	/*!
+	 * REG_ADC_0
+	 */
+	REG_ADC_0,
+	/*!
+	 * REG_ADC_1
+	 */
+	REG_ADC_1,
+	/*!
+	 * REG_ADC_2
+	 */
+	REG_ADC_2,
+	/*!
+	 * REG_ADC_3
+	 */
+	REG_ADC_3,
+	/*!
+	 * REG_ADC_4
+	 */
+	REG_ADC_4,
+	/*!
+	 * REG_CHARGER
+	 */
+	REG_CHARGER,
+	/*!
+	 * REG_USB
+	 */
+	REG_USB,
+	/*!
+	 * REG_CHARGE_USB_SPARE
+	 */
+	REG_CHARGE_USB_SPARE,
+	/*!
+	 * REG_LED_CONTROL_0
+	 */
+	REG_LED_CONTROL_0,
+	/*!
+	 * REG_LED_CONTROL_1
+	 */
+	REG_LED_CONTROL_1,
+	/*!
+	 * REG_LED_CONTROL_2
+	 */
+	REG_LED_CONTROL_2,
+	/*!
+	 * REG_LED_CONTROL_3
+	 */
+	REG_LED_CONTROL_3,
+	/*!
+	 * REG_LED_CONTROL_4
+	 */
+	REG_LED_CONTROL_4,
+	/*!
+	 * REG_LED_CONTROL_5
+	 */
+	REG_LED_CONTROL_5,
+	/*!
+	 * REG_SPARE
+	 */
+	REG_SPARE,
+	/*!
+	 * REG_TRIM_0
+	 */
+	REG_TRIM_0,
+	/*!
+	 * REG_TRIM_1
+	 */
+	REG_TRIM_1,
+	/*!
+	 * REG_TEST_0
+	 */
+	REG_TEST_0,
+	/*!
+	 * REG_TEST_1
+	 */
+	REG_TEST_1,
+	/*!
+	 * REG_TEST_2
+	 */
+	REG_TEST_2,
+	/*!
+	 * REG_TEST_3
+	 */
+	REG_TEST_3,
+	/*!
+	 * REG_NB
+	 */
+	REG_NB,
+} pmic_reg;
+
+/*!
+ * This is event list of mc13783 interrupt
+ */
+
+typedef enum _type_event{
+	/*!
+	 * ADC has finished requested conversions
+	 */
+	EVENT_ADCDONEI = 0,
+	/*!
+	 * ADCBIS has finished requested conversions
+	 */
+	EVENT_ADCBISDONEI = 1,
+	/*!
+	 * Touchscreen wakeup
+	 */
+	EVENT_TSI = 2,
+	/*!
+	 * ADC reading above high limit
+	 */
+	EVENT_WHIGHI = 3,
+	/*!
+	 * ADC reading below low limit
+	 */
+	EVENT_WLOWI = 4,
+	/*!
+	 * Charger attach and removal
+	 */
+	EVENT_CHGDETI = 6,
+	/*!
+	 * Charger over-voltage detection
+	 */
+	EVENT_CHGOVI = 7,
+	/*!
+	 * Charger path reverse current
+	 */
+	EVENT_CHGREVI = 8,
+	/*!
+	 * Charger path short circuit
+	 */
+	EVENT_CHGSHORTI = 9,
+	/*!
+	 * BP regulator current or voltage regulation
+	 */
+	EVENT_CCCVI = 10,
+	/*!
+	 * Charge current below threshold
+	 */
+	EVENT_CHRGCURRI = 11,
+	/*!
+	 * BP turn on threshold detection
+	 */
+	EVENT_BPONI = 12,
+	/*!
+	 * End of life / low battery detect
+	 */
+	EVENT_LOBATLI = 13,
+	/*!
+	 * Low battery warning
+	 */
+	EVENT_LOBATHI = 14,
+	/*!
+	 * USB detect
+	 */
+	EVENT_USBI = 16,
+	/*!
+	 * USB ID Line detect
+	 */
+	EVENT_IDI = 19,
+	/*!
+	 * Single ended 1 detect
+	 */
+	EVENT_SE1I = 21,
+	/*!
+	 * Car-kit detect
+	 */
+	EVENT_CKDETI = 22,
+	/*!
+	 * 1 Hz time-tick
+	 */
+	EVENT_E1HZI = 24,
+	/*!
+	 * Time of day alarm
+	 */
+	EVENT_TODAI = 25,
+	/*!
+	 * ON1B event
+	 */
+	EVENT_ONOFD1I = 27,
+	/*!
+	 * ON2B event
+	 */
+	EVENT_ONOFD2I = 28,
+	/*!
+	 * ON3B event
+	 */
+	EVENT_ONOFD3I = 29,
+	/*!
+	 * System reset
+	 */
+	EVENT_SYSRSTI = 30,
+	/*!
+	 * RTC reset occurred
+	 */
+	EVENT_RTCRSTI = 31,
+	/*!
+	 * Power cut event
+	 */
+	EVENT_PCI = 32,
+	/*!
+	 * Warm start event
+	 */
+	EVENT_WARMI = 33,
+	/*!
+	 * Memory hold event
+	 */
+	EVENT_MEMHLDI = 34,
+	/*!
+	 * Power ready
+	 */
+	EVENT_PWRRDYI = 35,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	EVENT_THWARNLI = 36,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	EVENT_THWARNHI = 37,
+	/*!
+	 * Clock source change
+	 */
+	EVENT_CLKI = 38,
+	/*!
+	 * Semaphore
+	 */
+	EVENT_SEMAFI = 39,
+	/*!
+	 * Microphone bias 2 detect
+	 */
+	EVENT_MC2BI = 41,
+	/*!
+	 * Headset attach
+	 */
+	EVENT_HSDETI = 42,
+	/*!
+	 * Stereo headset detect
+	 */
+	EVENT_HSLI = 43,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	EVENT_ALSPTHI = 44,
+	/*!
+	 * Short circuit on AHS outputs
+	 */
+	EVENT_AHSSHORTI = 45,
+	/*!
+	 * number of event
+	 */
+	EVENT_NB,
+} type_event;
+
+/*!
+ * This enumeration all senses of MC13783.
+ */
+typedef enum _t_sensor{
+	/*!
+	 * Charger attach sense
+	 */
+	SENSE_CHGDETS,
+	/*!
+	 * Charger over-voltage sense
+	 */
+	SENSE_CHGOVS,
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	SENSE_CHGREVS,
+	/*!
+	 * Charger short circuit
+	 */
+	SENSE_CHGSHORTS,
+	/*!
+	 * Charger regulator operating mode
+	 */
+	SENSE_CCCVS,
+	/*!
+	 * Charger current below threshold
+	 */
+	SENSE_CHGCURRS,
+	/*!
+	 * BP turn on
+	 */
+	SENSE_BPONS,
+	/*!
+	 * Low bat detect
+	 */
+	SENSE_LOBATLS,
+	/*!
+	 * Low bat warning
+	 */
+	SENSE_LOBATHS,
+	/*!
+	 * USB 4V4
+	 */
+	SENSE_USB4V4S,
+	/*!
+	 * USB 2V0
+	 */
+	SENSE_USB2V0S,
+	/*!
+	 * USB 0V8
+	 */
+	SENSE_USB0V8S,
+	/*!
+	 * ID Floats
+	 */
+	SENSE_ID_FLOATS,
+	/*!
+	 * ID Gnds
+	 */
+	SENSE_ID_GNDS,
+	/*!
+	 * Single ended
+	 */
+	SENSE_SE1S,
+	/*!
+	 * Car-kit detect
+	 */
+	SENSE_CKDETS,
+	/*!
+	 * mic bias detect
+	 */
+	SENSE_MC2BS,
+	/*!
+	 * headset attached
+	 */
+	SENSE_HSDETS,
+	/*!
+	 * ST headset attached
+	 */
+	SENSE_HSLS,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	SENSE_ALSPTHS,
+	/*!
+	 * short circuit on AHS
+	 */
+	SENSE_AHSSHORTS,
+	/*!
+	 * ON1B pin is hight
+	 */
+	SENSE_ONOFD1S,
+	/*!
+	 * ON2B pin is hight
+	 */
+	SENSE_ONOFD2S,
+	/*!
+	 * ON3B pin is hight
+	 */
+	SENSE_ONOFD3S,
+	/*!
+	 * System reset power ready
+	 */
+	SENSE_PWRRDYS,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	SENSE_THWARNHS,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	SENSE_THWARNLS,
+	/*!
+	 * Clock source is XTAL
+	 */
+	SENSE_CLKS,
+} t_sensor;
+
+/*!
+ * This structure is used to read all sense bits of MC13783.
+ */
+typedef struct _t_sensor_bits{
+	/*!
+	 * Charger attach sense
+	 */
+	bool sense_chgdets;
+	/*!
+	 * Charger over-voltage sense
+	 */
+	bool sense_chgovs;
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	bool sense_chgrevs;
+	/*!
+	 * Charger short circuit
+	 */
+	bool sense_chgshorts;
+	/*!
+	 * Charger regulator operating mode
+	 */
+	bool sense_cccvs;
+	/*!
+	 * Charger current below threshold
+	 */
+	bool sense_chgcurrs;
+	/*!
+	 * BP turn on
+	 */
+	bool sense_bpons;
+	/*!
+	 * Low bat detect
+	 */
+	bool sense_lobatls;
+	/*!
+	 * Low bat warning
+	 */
+	bool sense_lobaths;
+	/*!
+	 * USB 4V4
+	 */
+	bool sense_usb4v4s;
+	/*!
+	 * USB 2V0
+	 */
+	bool sense_usb2v0s;
+	/*!
+	 * USB 0V8
+	 */
+	bool sense_usb0v8s;
+	/*!
+	 * ID Floats
+	 */
+	bool sense_id_floats;
+	/*!
+	 * ID Gnds
+	 */
+	bool sense_id_gnds;
+	/*!
+	 * Single ended
+	 */
+	bool sense_se1s;
+	/*!
+	 * Car-kit detect
+	 */
+	bool sense_ckdets;
+	/*!
+	 * mic bias detect
+	 */
+	bool sense_mc2bs;
+	/*!
+	 * headset attached
+	 */
+	bool sense_hsdets;
+	/*!
+	 * ST headset attached
+	 */
+	bool sense_hsls;
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	bool sense_alspths;
+	/*!
+	 * short circuit on AHS
+	 */
+	bool sense_ahsshorts;
+	/*!
+	 * ON1B pin is hight
+	 */
+	bool sense_onofd1s;
+	/*!
+	 * ON2B pin is hight
+	 */
+	bool sense_onofd2s;
+	/*!
+	 * ON3B pin is hight
+	 */
+	bool sense_onofd3s;
+	/*!
+	 * System reset power ready
+	 */
+	bool sense_pwrrdys;
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	bool sense_thwarnhs;
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	bool sense_thwarnls;
+	/*!
+	 * Clock source is XTAL
+	 */
+	bool sense_clks;
+} t_sensor_bits;
+#endif
+
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+
+#define PMIC_ARBITRATION	"NULL"
+
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+};
+
+typedef enum {
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
+} t_sensor;
+
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+void mc13892_power_off(void);
+
+#endif  /* CONFIG_MXC_PMIC_MC13892 */
+
+#if defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
+
+typedef enum {
+	/* register names for mc34704 */
+	REG_MC34704_GENERAL1 = 0x01,
+	REG_MC34704_GENERAL2 = 0x02,
+	REG_MC34704_GENERAL3 = 0x03,
+	REG_MC34704_VGSET1 = 0x04,
+	REG_MC34704_VGSET2 = 0x05,
+	REG_MC34704_REG2SET1 = 0x06,
+	REG_MC34704_REG2SET2 = 0x07,
+	REG_MC34704_REG3SET1 = 0x08,
+	REG_MC34704_REG3SET2 = 0x09,
+	REG_MC34704_REG4SET1 = 0x0A,
+	REG_MC34704_REG4SET2 = 0x0B,
+	REG_MC34704_REG5SET1 = 0x0C,
+	REG_MC34704_REG5SET2 = 0x0D,
+	REG_MC34704_REG5SET3 = 0x0E,
+	REG_MC34704_REG6SET1 = 0x0F,
+	REG_MC34704_REG6SET2 = 0x10,
+	REG_MC34704_REG6SET3 = 0x11,
+	REG_MC34704_REG7SET1 = 0x12,
+	REG_MC34704_REG7SET2 = 0x13,
+	REG_MC34704_REG7SET3 = 0x14,
+	REG_MC34704_REG8SET1 = 0x15,
+	REG_MC34704_REG8SET2 = 0x16,
+	REG_MC34704_REG8SET3 = 0x17,
+	REG_MC34704_FAULTS = 0x18,
+	REG_MC34704_I2CSET1 = 0x19,
+	REG_MC34704_REG3DAC = 0x49,
+	REG_MC34704_REG7CR0 = 0x58,
+	REG_MC34704_REG7DAC = 0x59,
+	REG_NB = 0x60,
+} pmic_reg;
+
+typedef enum {
+	/* events for mc34704 */
+	EVENT_FLT1 = 0,
+	EVENT_FLT2,
+	EVENT_FLT3,
+	EVENT_FLT4,
+	EVENT_FLT5,
+	EVENT_FLT6,
+	EVENT_FLT7,
+	EVENT_FLT8,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	MCU_SENSOR_NOT_SUPPORT
+} t_sensor;
+
+typedef enum {
+	MCU_SENSOR_BIT_NOT_SUPPORT
+} t_sensor_bits;
+
+#endif			  /* MXC_PMIC_MC34704 */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+		unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+		unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+		pmic_event_callback_t callback);
+/*!
+ * This function is called by PMIC clients to un-subscribe on an event.
+ *
+ * @param        event_unsub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+		pmic_event_callback_t callback);
+/*!
+ * This function is called to read all sensor bits of PMIC.
+ *
+ * @param        sensor    Sensor to be checked.
+ *
+ * @return       This function returns true if the sensor bit is high;
+ *               or returns false if the sensor bit is low.
+ */
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+ * This function checks one sensor of PMIC.
+ *
+ * @param        sensor_bits  structure of all sensor bits.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits);
+
+#ifdef CONFIG_REGULATOR_MC13783
+/*!
+ * This function is used to initialize the regulator for MC13783.
+ *
+ * @return      Returns 0.
+ */
+int reg_mc13783_probe(void);
+#else
+static inline int reg_mc13783_probe(void)
+{
+	return 0;
+};
+#endif
+
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
+#endif				/* __KERNEL__ */
+
+#ifdef CONFIG_ARCH_MX51
+struct pmic_platform_data {
+	int (*init)(void *);
+	int power_key_irq;
+};
+#endif
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_light.h b/include/asm-arm/plat-mxc/pmic_light.h
new file mode 100644
index 0000000..47a05ff
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_light.h
@@ -0,0 +1,1082 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum _t_bklit_mode{
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum _t_bklit_channel{
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum _t_bklit_strobe_mode{
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct _t_bklit_setting_param{
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+						 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+						 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum _t_funlight_bank{
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum _t_tcled_mode{
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct _t_tcled_enable_param{
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum _t_ind_channel{
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum _t_funlight_channel{
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum _t_tcled_ind_blink_pattern{
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum _t_tcled_cur_level{
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum _t_tcled_fun_cycle_time{
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum _t_tcled_fun_speed{
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum _t_tcled_fun_strobe_speed{
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum _t_chaselight_pattern{
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum _t_fun_pattern{
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct _t_fun_param{
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum _t_led_channel{
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum _t_aud_path{
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum _t_aud_gain{
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct _t_tcled_ind_param{
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+enum curr_level {
+	LIT_CURR_0 = 0,
+	LIT_CURR_3,
+	LIT_CURR_6,
+	LIT_CURR_9,
+	LIT_CURR_12,
+	LIT_CURR_15,
+	LIT_CURR_18,
+	LIT_CURR_21,
+	/* below setting only used for main/aux/keypad */
+	LIT_CURR_HI_0,
+	LIT_CURR_HI_6,
+	LIT_CURR_HI_12,
+	LIT_CURR_HI_18,
+	LIT_CURR_HI_24,
+	LIT_CURR_HI_30,
+	LIT_CURR_HI_36,
+	LIT_CURR_HI_42,
+};
+
+enum lit_channel {
+	LIT_MAIN = 0,
+	LIT_AUX,
+	LIT_KEY,
+	LIT_RED,
+	LIT_GREEN,
+	LIT_BLUE,
+};
+
+#endif
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ level     current
+ ------    -----------
+ 0         0 mA
+ 1         12 mA
+ 2         24 mA
+ 3         36 mA
+ 4         48 mA
+ 5         60 mA
+ 6         72 mA
+ 7         84 mA
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+		unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+		unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ dc        Duty Cycle (% On-time over Cycle Time)
+ ------    ---------------------------------------
+ 0        0%
+ 1        6.7%
+ 2        13.3%
+ 3        20%
+ 4        26.7%
+ 5        33.3%
+ 6        40%
+ 7        46.7%
+ 8        53.3%
+ 9        60%
+ 10        66.7%
+ 11        73.3%
+ 12        80%
+ 13        86.7%
+ 14        93.3%
+ 15        100%
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+		unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ period      Cycle Time
+ --------    ------------
+ 0          0.01 seconds
+ 1          0.1 seconds
+ 2          0.5 seconds
+ 3          2 seconds
+ @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Istant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+		t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+		t_tcled_cur_level level,
+		t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED
+ * channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+		t_tcled_cur_level *level,
+		t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+		t_tcled_ind_blink_pattern pattern,
+		bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+		t_tcled_ind_blink_pattern *pattern,
+		bool *skip,	t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_cur_level *level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+		t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+		t_tcled_fun_cycle_time *ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+		t_funlight_channel channel,
+		unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+		t_funlight_channel channel,
+		unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+		t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+		t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+		t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+		t_chaselight_pattern pattern,
+		t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+		t_funlight_channel channel,
+		t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+		t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+		t_funlight_channel channel,
+		bool *rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+		t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+		t_funlight_channel channel,
+		bool *rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+		t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+		t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+		t_aud_path path,
+		t_aud_gain gain,
+		bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level);
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level);
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc);
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc);
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_power.h b/include/asm-arm/plat-mxc/pmic_power.h
new file mode 100644
index 0000000..7aefb92
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_power.h
@@ -0,0 +1,1358 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_POWER_H__
+#define __ASM_ARCH_MXC_PMIC_POWER_H__
+
+/*!
+ * @defgroup PMIC_POWER  PMIC Power Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_power.h
+ * @brief This is the header of PMIC power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+/*! @{ */
+
+/*!
+ * Turn on a regulator.
+ */
+#define PMIC_REGULATOR_ON			_IOWR('p', 0xf0, int)
+
+/*!
+ * Turn off a regulator.
+ */
+#define PMIC_REGULATOR_OFF        	 	_IOWR('p', 0xf1, int)
+
+/*!
+ * Set regulator configuration.
+ */
+#define PMIC_REGULATOR_SET_CONFIG         	_IOWR('p', 0xf2, int)
+
+/*!
+ * Get regulator configuration.
+ */
+#define PMIC_REGULATOR_GET_CONFIG         	_IOWR('p', 0xf3, int)
+
+/*!
+ * Miscellaneous Power Test.
+ */
+#define PMIC_POWER_CHECK_MISC			_IOWR('p', 0xf4, int)
+
+/*! @} */
+
+/*!
+ * This enumeration define all power interrupts
+ */
+typedef enum _t_pwr_int{
+	/*!
+	 * BP turn on threshold detection
+	 */
+	PWR_IT_BPONI = 0,
+	/*!
+	 * End of life / low battery detect
+	 */
+	PWR_IT_LOBATLI,
+	/*!
+	 * Low battery warning
+	 */
+	PWR_IT_LOBATHI,
+	/*!
+	 * ON1B event
+	 */
+	PWR_IT_ONOFD1I,
+	/*!
+	 * ON2B event
+	 */
+	PWR_IT_ONOFD2I,
+	/*!
+	 * ON3B event
+	 */
+	PWR_IT_ONOFD3I,
+	/*!
+	 * System reset
+	 */
+	PWR_IT_SYSRSTI,
+	/*!
+	 * Power ready
+	 */
+	PWR_IT_PWRRDYI,
+	/*!
+	 * Power cut event
+	 */
+	PWR_IT_PCI,
+	/*!
+	 * Warm start event
+	 */
+	PWR_IT_WARMI,
+	/*!
+	 * Memory hold event
+	 */
+} t_pwr_int;
+
+/*!
+ * VHOLD regulator output voltage setting.
+ */
+typedef enum _t_vhold_voltage{
+	VH_1_875V,		/*!< 1.875V */
+	VH_2_5V,		/*!< 2.5V */
+	VH_1_55V,		/*!< 1.55V */
+	VH_PASSTHROUGH,		/*!< Pass-through mode */
+} t_vhold_voltage;
+
+/*!
+ * PMIC power control configuration.
+ */
+
+typedef struct _t_pc_config{
+	bool pc_enable;		/*!< Power cut enable */
+	unsigned char pc_timer;	/*!< Power cut timer value */
+	bool pc_count_enable;	/*!< Power cut counter enable,*/
+	/*  If TURE, Power cuts are disabled */
+	/*  when pc_count > pc_max_count; */
+	/*  If FALSE, Power cuts are not */
+	/*  disabled when */
+	/*  pc_count > pc_max_count */
+	unsigned char pc_count;	/*!< Power cut count */
+	unsigned char pc_max_count;	/*!< Power cut maximum count */
+	bool warm_enable;	/*!< User Off state enable */
+	bool user_off_pc;	/*!< Automatic transition to user off
+						  during power cut */
+	bool clk_32k_enable;	/*!< 32 kHz output buffer enable
+							  during memory hold */
+	bool clk_32k_user_off;	/*!< Keeps the CLK32KMCU active during
+							  user off power cut modes */
+	bool en_vbkup1;		/*!< enable VBKUP1 regulator */
+	bool auto_en_vbkup1;	/*!< automatically enable VBKUP1
+							  regulator in the memory hold
+							  and user of modes */
+	t_vhold_voltage vhold_voltage;	/*!< output voltage for VBKUP1 */
+	bool en_vbkup2;		/*!< enable VBKUP2 regulator */
+	bool auto_en_vbkup2;	/*!< automatically enable VBKUP2
+							  regulator in the memory hold
+							  and user of modes */
+	t_vhold_voltage vhold_voltage2;	/*!< output voltage for VBKUP2 */
+	unsigned char mem_timer;	/*!< duration of the memory hold
+								  timer */
+	bool mem_allon;		/*!< memory hold timer infinity mode,
+						  If TRUE, the memory hold timer
+						  will be set to infinity and
+						  the mem_timer filed will be
+						  ignored */
+} t_pc_config;
+
+/*!
+ * brief PMIC regulators.
+ */
+
+typedef enum _t_pmic_regulator{
+	SW_SW1A = 0,		/*!< SW1A or SW1 */
+	SW_SW1B,		/*!< SW1B */
+	SW_SW2A,		/*!< SW2A or SW2 */
+	SW_SW2B,		/*!< SW2B */
+	SW_SW3,			/*!< SW3 */
+	SW_PLL,			/*!< PLL */
+	REGU_VAUDIO,		/*!< VAUDIO */
+	REGU_VIOHI,		/*!< VIOHI */
+	REGU_VIOLO,		/*!< VIOLO */
+	REGU_VDIG,		/*!< VDIG */
+	REGU_VGEN,		/*!< VGEN */
+	REGU_VRFDIG,		/*!< VRFDIG */
+	REGU_VRFREF,		/*!< VRFREF */
+	REGU_VRFCP,		/*!< VRFCP */
+	REGU_VSIM,		/*!< VSIM */
+	REGU_VESIM,		/*!< VESIM */
+	REGU_VCAM,		/*!< VCAM */
+	REGU_VRFBG,		/*!< VRFBG */
+	REGU_VVIB,		/*!< VVIB */
+	REGU_VRF1,		/*!< VRF1 */
+	REGU_VRF2,		/*!< VRF2 */
+	REGU_VMMC1,		/*!< VMMC1 or VMMC */
+	REGU_VMMC2,		/*!< VMMC2 */
+	REGU_GPO1,		/*!< GPIO1 */
+	REGU_GPO2,		/*!< GPO2 */
+	REGU_GPO3,		/*!< GPO3 */
+	REGU_GPO4,		/*!< GPO4 */
+	REGU_V1,		/*!< V1 */
+	REGU_V2,		/*!< V2 */
+	REGU_V3,		/*!< V3 */
+	REGU_V4,		/*!< V4 */
+} t_pmic_regulator;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1
+ * @brief PMIC Switch mode regulator SW1 output voltages.
+ */
+
+typedef enum _t_pmic_regulator_voltage_sw1{
+	SW1_1V = 0,		/*!< 1.0 V */
+	SW1_1_1V,		/*!< 1.1 V */
+	SW1_1_2V,		/*!< 1.2 V */
+	SW1_1_3V,		/*!< 1.3 V */
+	SW1_1_4V,		/*!< 1.4 V */
+	SW1_1_55V,		/*!< 1.55 V */
+	SW1_1_625V,		/*!< 1.625 V */
+	SW1_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1a
+ * @brief PMIC regulator SW1A output voltage.
+ */
+typedef enum {
+	SW1A_0_9V = 0,		/*!< 0.900 V */
+	SW1A_0_925V,		/*!< 0.925 V */
+	SW1A_0_95V,		/*!< 0.950 V */
+	SW1A_0_975V,		/*!< 0.975 V */
+	SW1A_1V,		/*!< 1.000 V */
+	SW1A_1_025V,		/*!< 1.025 V */
+	SW1A_1_05V,		/*!< 1.050 V */
+	SW1A_1_075V,		/*!< 1.075 V */
+	SW1A_1_1V,		/*!< 1.100 V */
+	SW1A_1_125V,		/*!< 1.125 V */
+	SW1A_1_15V,		/*!< 1.150 V */
+	SW1A_1_175V,		/*!< 1.175 V */
+	SW1A_1_2V,		/*!< 1.200 V */
+	SW1A_1_225V,		/*!< 1.225 V */
+	SW1A_1_25V,		/*!< 1.250 V */
+	SW1A_1_275V,		/*!< 1.275 V */
+	SW1A_1_3V,		/*!< 1.300 V */
+	SW1A_1_325V,		/*!< 1.325 V */
+	SW1A_1_35V,		/*!< 1.350 V */
+	SW1A_1_375V,		/*!< 1.375 V */
+	SW1A_1_4V,		/*!< 1.400 V */
+	SW1A_1_425V,		/*!< 1.425 V */
+	SW1A_1_45V,		/*!< 1.450 V */
+	SW1A_1_475V,		/*!< 1.475 V */
+	SW1A_1_5V,		/*!< 1.500 V */
+	SW1A_1_525V,		/*!< 1.525 V */
+	SW1A_1_55V,		/*!< 1.550 V */
+	SW1A_1_575V,		/*!< 1.575 V */
+	SW1A_1_6V,		/*!< 1.600 V */
+	SW1A_1_625V,		/*!< 1.625 V */
+	SW1A_1_65V,		/*!< 1.650 V */
+	SW1A_1_675V,		/*!< 1.675 V */
+	SW1A_1_7V,		/*!< 1.700 V */
+	SW1A_1_8V = 36,		/*!< 1.800 V */
+	SW1A_1_85V = 40,	/*!< 1.850 V */
+	SW1A_2V = 44,		/*!< 2_000 V */
+	SW1A_2_1V = 48,		/*!< 2_100 V */
+	SW1A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1b
+ * @brief PMIC regulator SW1B output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_sw1b{
+	SW1B_0_9V = 0,		/*!< 0.900 V */
+	SW1B_0_925V,		/*!< 0.925 V */
+	SW1B_0_95V,		/*!< 0.950 V */
+	SW1B_0_975V,		/*!< 0.975 V */
+	SW1B_1V,		/*!< 1.000 V */
+	SW1B_1_025V,		/*!< 1.025 V */
+	SW1B_1_05V,		/*!< 1.050 V */
+	SW1B_1_075V,		/*!< 1.075 V */
+	SW1B_1_1V,		/*!< 1.100 V */
+	SW1B_1_125V,		/*!< 1.125 V */
+	SW1B_1_15V,		/*!< 1.150 V */
+	SW1B_1_175V,		/*!< 1.175 V */
+	SW1B_1_2V,		/*!< 1.200 V */
+	SW1B_1_225V,		/*!< 1.225 V */
+	SW1B_1_25V,		/*!< 1.250 V */
+	SW1B_1_275V,		/*!< 1.275 V */
+	SW1B_1_3V,		/*!< 1.300 V */
+	SW1B_1_325V,		/*!< 1.325 V */
+	SW1B_1_35V,		/*!< 1.350 V */
+	SW1B_1_375V,		/*!< 1.375 V */
+	SW1B_1_4V,		/*!< 1.400 V */
+	SW1B_1_425V,		/*!< 1.425 V */
+	SW1B_1_45V,		/*!< 1.450 V */
+	SW1B_1_475V,		/*!< 1.475 V */
+	SW1B_1_5V,		/*!< 1.500 V */
+	SW1B_1_525V,		/*!< 1.525 V */
+	SW1B_1_55V,		/*!< 1.550 V */
+	SW1B_1_575V,		/*!< 1.575 V */
+	SW1B_1_6V,		/*!< 1.600 V */
+	SW1B_1_625V,		/*!< 1.625 V */
+	SW1B_1_65V,		/*!< 1.650 V */
+	SW1B_1_675V,		/*!< 1.675 V */
+	SW1B_1_7V,		/*!< 1.700 V */
+	SW1B_1_8V = 36,		/*!< 1.800 V */
+	SW1B_1_85V = 40,	/*!< 1.850 V */
+	SW1B_2V = 44,		/*!< 2_000 V */
+	SW1B_2_1V = 48,		/*!< 2_100 V */
+	SW1B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2
+ * @brief PMIC Switch mode regulator SW2 output voltages.
+ */
+typedef enum _t_pmic_regulator_voltage_sw2{
+	SW2_1V = 0,		/*!< 1.0 V */
+	SW2_1_1V,		/*!< 1.1 V */
+	SW2_1_2V,		/*!< 1.2 V */
+	SW2_1_3V,		/*!< 1.3 V */
+	SW2_1_4V,		/*!< 1.4 V */
+	SW2_1_55V,		/*!< 1.55 V */
+	SW2_1_625V,		/*!< 1.625 V */
+	SW2_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2a
+ * @brief PMIC regulator SW2A output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_sw2a{
+	SW2A_0_9V = 0,		/*!< 0.900 V */
+	SW2A_0_925V,		/*!< 0.925 V */
+	SW2A_0_95V,		/*!< 0.950 V */
+	SW2A_0_975V,		/*!< 0.975 V */
+	SW2A_1V,		/*!< 1.000 V */
+	SW2A_1_025V,		/*!< 1.025 V */
+	SW2A_1_05V,		/*!< 1.050 V */
+	SW2A_1_075V,		/*!< 1.075 V */
+	SW2A_1_1V,		/*!< 1.100 V */
+	SW2A_1_125V,		/*!< 1.125 V */
+	SW2A_1_15V,		/*!< 1.150 V */
+	SW2A_1_175V,		/*!< 1.175 V */
+	SW2A_1_2V,		/*!< 1.200 V */
+	SW2A_1_225V,		/*!< 1.225 V */
+	SW2A_1_25V,		/*!< 1.250 V */
+	SW2A_1_275V,		/*!< 1.275 V */
+	SW2A_1_3V,		/*!< 1.300 V */
+	SW2A_1_325V,		/*!< 1.325 V */
+	SW2A_1_35V,		/*!< 1.350 V */
+	SW2A_1_375V,		/*!< 1.375 V */
+	SW2A_1_4V,		/*!< 1.400 V */
+	SW2A_1_425V,		/*!< 1.425 V */
+	SW2A_1_45V,		/*!< 1.450 V */
+	SW2A_1_475V,		/*!< 1.475 V */
+	SW2A_1_5V,		/*!< 1.500 V */
+	SW2A_1_525V,		/*!< 1.525 V */
+	SW2A_1_55V,		/*!< 1.550 V */
+	SW2A_1_575V,		/*!< 1.575 V */
+	SW2A_1_6V,		/*!< 1.600 V */
+	SW2A_1_625V,		/*!< 1.625 V */
+	SW2A_1_65V,		/*!< 1.650 V */
+	SW2A_1_675V,		/*!< 1.675 V */
+	SW2A_1_7V,		/*!< 1.700 V */
+	SW2A_1_8V = 36,		/*!< 1.800 V */
+	SW2A_1_9V = 40,		/*!< 1.900 V */
+	SW2A_2V = 44,		/*!< 2_000 V */
+	SW2A_2_1V = 48,		/*!< 2_100 V */
+	SW2A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2b
+ * @brief PMIC regulator SW2B output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_sw2b{
+	SW2B_0_9V = 0,		/*!< 0.900 V */
+	SW2B_0_925V,		/*!< 0.925 V */
+	SW2B_0_95V,		/*!< 0.950 V */
+	SW2B_0_975V,		/*!< 0.975 V */
+	SW2B_1V,		/*!< 1.000 V */
+	SW2B_1_025V,		/*!< 1.025 V */
+	SW2B_1_05V,		/*!< 1.050 V */
+	SW2B_1_075V,		/*!< 1.075 V */
+	SW2B_1_1V,		/*!< 1.100 V */
+	SW2B_1_125V,		/*!< 1.125 V */
+	SW2B_1_15V,		/*!< 1.150 V */
+	SW2B_1_175V,		/*!< 1.175 V */
+	SW2B_1_2V,		/*!< 1.200 V */
+	SW2B_1_225V,		/*!< 1.225 V */
+	SW2B_1_25V,		/*!< 1.250 V */
+	SW2B_1_275V,		/*!< 1.275 V */
+	SW2B_1_3V,		/*!< 1.300 V */
+	SW2B_1_325V,		/*!< 1.325 V */
+	SW2B_1_35V,		/*!< 1.350 V */
+	SW2B_1_375V,		/*!< 1.375 V */
+	SW2B_1_4V,		/*!< 1.400 V */
+	SW2B_1_425V,		/*!< 1.425 V */
+	SW2B_1_45V,		/*!< 1.450 V */
+	SW2B_1_475V,		/*!< 1.475 V */
+	SW2B_1_5V,		/*!< 1.500 V */
+	SW2B_1_525V,		/*!< 1.525 V */
+	SW2B_1_55V,		/*!< 1.550 V */
+	SW2B_1_575V,		/*!< 1.575 V */
+	SW2B_1_6V,		/*!< 1.600 V */
+	SW2B_1_625V,		/*!< 1.625 V */
+	SW2B_1_65V,		/*!< 1.650 V */
+	SW2B_1_675V,		/*!< 1.675 V */
+	SW2B_1_7V,		/*!< 1.700 V */
+	SW2B_1_8V = 36,		/*!< 1.800 V */
+	SW2B_1_9V = 40,		/*!< 1.900 V */
+	SW2B_2V = 44,		/*!< 2_000 V */
+	SW2B_2_1V = 48,		/*!< 2_100 V */
+	SW2B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw3
+ * @brief PMIC Switch mode regulator SW3 output voltages.
+ */
+typedef enum _t_pmic_regulator_voltage_sw3{
+	SW3_5V = 0,		/*!< 5.0 V */
+	SW3_5_1V = 0,		/*!< 5.1 V */
+	SW3_5_6V,		/*!< 5.6 V */
+} t_pmic_regulator_voltage_sw3;
+
+/*!
+ * @enum t_switcher_factor
+ * @brief PLL multiplication factor
+ */
+typedef enum _t_switcher_factor{
+	FACTOR_28 = 0,		/*!< 917 504 kHz */
+	FACTOR_29,		/*!< 950 272 kHz */
+	FACTOR_30,		/*!< 983 040 kHz */
+	FACTOR_31,		/*!< 1 015 808 kHz */
+	FACTOR_32,		/*!< 1 048 576 kHz */
+	FACTOR_33,		/*!< 1 081 344 kHz */
+	FACTOR_34,		/*!< 1 114 112 kHz */
+	FACTOR_35,		/*!< 1 146 880 kHz */
+} t_switcher_factor;
+
+/*!
+ * @enum t_pmic_regulator_voltage_violo
+ * @brief PMIC regulator VIOLO output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_violo{
+	VIOLO_1_2V = 0,		/*!< 1.2 V */
+	VIOLO_1_3V,		/*!< 1.3 V */
+	VIOLO_1_5V,		/*!< 1.5 V */
+	VIOLO_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_violo;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vdig
+ * @brief PMIC regulator VDIG output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vdig{
+	VDIG_1_2V = 0,		/*!< 1.2 V */
+	VDIG_1_3V,		/*!< 1.3 V */
+	VDIG_1_5V,		/*!< 1.5 V */
+	VDIG_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_vdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vgen
+ * @brief PMIC regulator VGEN output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vgen{
+	VGEN_1_2V = 0,		/*!< 1.2 V */
+	VENG_1_3V,		/*!< 1.3 V */
+	VGEN_1_5V,		/*!< 1.5 V */
+	VGEN_1_8V,		/*!< 1.8 V */
+	VGEN_1_1V,		/*!< 1.1 V */
+	VGEN_2V,		/*!< 2 V */
+	VGEN_2_775V,		/*!< 2.775 V */
+	VGEN_2_4V,		/*!< 2.4 V */
+} t_pmic_regulator_voltage_vgen;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfdig
+ * @brief PMIC regulator VRFDIG output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vrfdig{
+	VRFDIG_1_2V = 0,	/*!< 1.2 V */
+	VRFDIG_1_5V,		/*!< 1.5 V */
+	VRFDIG_1_8V,		/*!< 1.8 V */
+	VRFDIG_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_vrfdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfref
+ * @brief PMIC regulator VRFREF output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vrfref{
+	VRFREF_2_475V = 0,	/*!< 2.475 V */
+	VRFREF_2_6V,		/*!< 2.600 V */
+	VRFREF_2_7V,		/*!< 2.700 V */
+	VRFREF_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfref;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfcp
+ * @brief PMIC regulator VRFCP output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vrfcp{
+	VRFCP_2_7V = 0,		/*!< 2.700 V */
+	VRFCP_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfcp;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vsim
+ * @brief PMIC linear regulator VSIM output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vsim{
+	VSIM_1_8V = 0,		/*!< 1.8 V */
+	VSIM_2_9V,		/*!< 2.90 V */
+	VSIM_3V = 1,		/*!< 3 V */
+} t_pmic_regulator_voltage_vsim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vesim
+ * @brief PMIC regulator VESIM output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vesim{
+	VESIM_1_8V = 0,		/*!< 1.80 V */
+	VESIM_2_9V,		/*!< 2.90 V */
+} t_pmic_regulator_voltage_vesim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vcam
+ * @brief PMIC regulator VCAM output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vcam{
+	VCAM_1_5V = 0,		/*!< 1.50 V */
+	VCAM_1_8V,		/*!< 1.80 V */
+	VCAM_2_5V,		/*!< 2.50 V */
+	VCAM_2_55V,		/*!< 2.55 V */
+	VCAM_2_6V,		/*!< 2.60 V */
+	VCAM_2_75V,		/*!< 2.75 V */
+	VCAM_2_8V,		/*!< 2.80 V */
+	VCAM_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vcam;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vvib
+ * @brief PMIC linear regulator V_VIB output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vvib{
+	VVIB_1_3V = 0,		/*!< 1.30 V */
+	VVIB_1_8V,		/*!< 1.80 V */
+	VVIB_2V,		/*!< 2 V */
+	VVIB_3V,		/*!< 3 V */
+} t_pmic_regulator_voltage_vvib;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf1
+ * @brief PMIC regulator VRF1 output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vrf1{
+	VRF1_1_5V = 0,		/*!< 1.500 V */
+	VRF1_1_875V,		/*!< 1.875 V */
+	VRF1_2_7V,		/*!< 2.700 V */
+	VRF1_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf2
+ * @brief PMIC regulator VRF2 output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vrf2{
+	VRF2_1_5V = 0,		/*!< 1.500 V */
+	VRF2_1_875V,		/*!< 1.875 V */
+	VRF2_2_7V,		/*!< 2.700 V */
+	VRF2_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc
+ * @brief PMIC linear regulator VMMC output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vmmc{
+	VMMC_OFF = 0,		/*!< Output off */
+	VMMC_1_6V,		/*!< 1.6 V */
+	VMMC_1_8V,		/*!< 1.8 V */
+	VMMC_2V,		/*!< 2 V */
+	VMMC_2_2V,		/*!< 2.2 V */
+	VMMC_2_4V,		/*!< 2.4 V */
+	VMMC_2_6V,		/*!< 2.6 V */
+	VMMC_2_8V,		/*!< 2.8 V */
+	VMMC_3V,		/*!< 3 V */
+	VMMC_3_2V,		/*!< 3.2 V */
+	VMMC_3_3V,		/*!< 3.3 V */
+	VMMC_3_4V,		/*!< 3.4 V */
+} t_pmic_regulator_voltage_vmmc;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc1
+ * @brief PMIC regulator VMMC1 output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vmmc1{
+	VMMC1_1_6V = 0,		/*!< 1.60 V */
+	VMMC1_1_8V,		/*!< 1.80 V */
+	VMMC1_2V,		/*!< 2.00 V */
+	VMMC1_2_6V,		/*!< 2.60 V */
+	VMMC1_2_7V,		/*!< 2.70 V */
+	VMMC1_2_8V,		/*!< 2.80 V */
+	VMMC1_2_9V,		/*!< 2.90 V */
+	VMMC1_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc2
+ * @brief PMIC regulator VMMC2 output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_vmmc2{
+	VMMC2_1_6V = 0,		/*!< 1.60 V */
+	VMMC2_1_8V,		/*!< 1.80 V */
+	VMMC2_2V,		/*!< 2.00 V */
+	VMMC2_2_6V,		/*!< 2.60 V */
+	VMMC2_2_7V,		/*!< 2.70 V */
+	VMMC2_2_8V,		/*!< 2.80 V */
+	VMMC2_2_9V,		/*!< 2.90 V */
+	VMMC2_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v1
+ * @brief PMIC linear regulator V1 output voltages.
+ */
+typedef enum _t_pmic_regulator_voltage_v1{
+	V1_2_775V = 0,		/*!< 2.775 V */
+	V1_1_2V,		/*!< 1.2 V */
+	V1_1_3V,		/*!< 1.3 V */
+	V1_1_4V,		/*!< 1.4 V */
+	V1_1_55V,		/*!< 1.55 V */
+	V1_1_75V,		/*!< 1.75 V */
+	V1_1_875V,		/*!< 1.875 V */
+	V1_2_475V,		/*!< 2.475 V */
+} t_pmic_regulator_voltage_v1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v2
+ * @brief PMIC linear regulator V2 output voltage, V2 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum _t_pmic_regulator_voltage_v2{
+	V2_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v3
+ * @brief PMIC linear regulator V3 output voltage.
+ */
+typedef enum _t_pmic_regulator_voltage_v3{
+	V3_1_875V = 0,		/*!< 1.875 V */
+	V3_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v3;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v4
+ * @brief PMIC linear regulator V4 output voltage, V4 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum _t_pmic_regulator_voltage_v4{
+	V4_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v4;
+
+/*!
+ * @union t_regulator_voltage
+ * @brief PMIC regulator output voltages.
+ */
+typedef union _t_regulator_voltage{
+	t_pmic_regulator_voltage_sw1 sw1;	/*!< SW1 voltage */
+	t_pmic_regulator_voltage_sw1a sw1a;	/*!< SW1A voltage */
+	t_pmic_regulator_voltage_sw1b sw1b;	/*!< SW1B voltage */
+	t_pmic_regulator_voltage_sw2 sw2;	/*!< SW2 voltage */
+	t_pmic_regulator_voltage_sw2a sw2a;	/*!< SW2A voltage */
+	t_pmic_regulator_voltage_sw2b sw2b;	/*!< SW2B voltage */
+	t_pmic_regulator_voltage_sw3 sw3;	/*!< SW3 voltage */
+	t_pmic_regulator_voltage_violo violo;	/*!< VIOLO voltage */
+	t_pmic_regulator_voltage_vdig vdig;	/*!< VDIG voltage */
+	t_pmic_regulator_voltage_vgen vgen;	/*!< VGEN voltage */
+	t_pmic_regulator_voltage_vrfdig vrfdig;	/*!< VRFDIG voltage */
+	t_pmic_regulator_voltage_vrfref vrfref;	/*!< VRFREF voltage */
+	t_pmic_regulator_voltage_vrfcp vrfcp;	/*!< VRFCP voltage */
+	t_pmic_regulator_voltage_vsim vsim;	/*!< VSIM voltage */
+	t_pmic_regulator_voltage_vesim vesim;	/*!< VESIM voltage */
+	t_pmic_regulator_voltage_vcam vcam;	/*!< VCAM voltage */
+	t_pmic_regulator_voltage_vvib vvib;	/*!< VVIB voltage */
+	t_pmic_regulator_voltage_vrf1 vrf1;	/*!< VRF1 voltage */
+	t_pmic_regulator_voltage_vrf2 vrf2;	/*!< VRF2 voltage */
+	t_pmic_regulator_voltage_vmmc vmmc;	/*!< VMMC voltage */
+	t_pmic_regulator_voltage_vmmc1 vmmc1;	/*!< VMMC1 voltage */
+	t_pmic_regulator_voltage_vmmc2 vmmc2;	/*!< VMMC2 voltage */
+	t_pmic_regulator_voltage_v1 v1;	/*!< V1 voltage */
+	t_pmic_regulator_voltage_v2 v2;	/*!< V2 voltage */
+	t_pmic_regulator_voltage_v3 v3;	/*!< V3 voltage */
+	t_pmic_regulator_voltage_v4 v4;	/*!< V4 voltage */
+} t_regulator_voltage;
+
+/*!
+ * @enum t_pmic_regulator_sw_mode
+ * @brief define switch mode regulator mode.
+ *
+ * The synchronous rectifier can be disabled (and pulse-skipping enabled)
+ * to improve low current efficiency. Software should disable synchronous
+ * rectifier / enable the pulse skipping for average loads less than
+ * approximately 30 mA, depending on the quiescent current penalty due to
+ * synchronous mode.
+ */
+typedef enum _t_pmic_regulator_sw_mode{
+	SYNC_RECT = 0,
+	NO_PULSE_SKIP,
+	PULSE_SKIP,
+	LOW_POWER,
+} t_pmic_regulator_sw_mode;
+
+/*!
+ * Generic PMIC switch mode regulator mode.
+ */
+typedef t_pmic_regulator_sw_mode t_regulator_sw_mode;
+typedef t_pmic_regulator_sw_mode t_regulator_stby_mode;
+
+/*!
+ * @enum t_regulator_lp_mode
+ * @brief Low power mode control modes.
+ */
+
+typedef enum _t_regulator_lp_mode{
+	/*!
+	 * Low Power Mode is disabled
+	 */
+	LOW_POWER_DISABLED = 0,
+	/*!
+	 * Low Power Mode is controlled by STANDBY pin and/or LVS pin
+	 */
+	LOW_POWER_CTRL_BY_PIN,
+	/*!
+	 * Set Low Power mode no matter of hardware pins
+	 */
+	LOW_POWER_EN,
+	/*!
+	 * Set Low Power mode and control by STANDBY
+	 */
+	LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN,
+} t_regulator_lp_mode;
+
+/*!
+ * @enum t_switcher_dvs_speed
+ * @brief DVS speed setting
+ */
+typedef enum _t_switcher_dvs_speed{
+	/*!
+	 * Transition speed is dictated by the current
+	 * limit and input -output conditions
+	 */
+	DICTATED = 0,
+	/*!
+	 * 25mV step each 4us
+	 */
+	DVS_4US,
+	/*!
+	 * 25mV step each 8us
+	 */
+	DVS_8US,
+	/*!
+	 * 25mV step each 16us
+	 */
+	DVS_16US,
+} t_switcher_dvs_speed;
+
+/*!
+ * @struct t_regulator_config
+ * @brief regulator configuration.
+ *
+ */
+
+typedef struct _t_regulator_config{
+	/*!
+	 * Switch mode regulator operation mode. This field only applies to
+	 * switch mode regulators.
+	 */
+	t_regulator_sw_mode mode;
+	/*!
+	 * Switch mode stby regulator operation mode. This field only applies
+	 * to switch mode regulators.
+	 */
+	t_regulator_stby_mode stby_mode;
+	/*!
+	 * Regulator output voltage.
+	 */
+	t_regulator_voltage voltage;
+	/*!
+	 * Regulator output voltage in LVS mode.
+	 */
+	t_regulator_voltage voltage_lvs;
+	/*!
+	 * Regulator output voltage in standby mode.
+	 */
+	t_regulator_voltage voltage_stby;
+	/*!
+	 * Regulator low power mode.
+	 */
+	t_regulator_lp_mode lp_mode;
+	/*!
+	 * Switcher dvs speed
+	 */
+	t_switcher_dvs_speed dvs_speed;
+	/*!
+	 * Switcher panic mode
+	 */
+	bool panic_mode;
+	/*!
+	 * Switcher softstart
+	 */
+	bool softstart;
+	/*!
+	 * PLL Multiplication factor
+	 */
+	t_switcher_factor factor;
+} t_regulator_config;
+
+/*!
+ * @struct t_regulator_cfg_param
+ * @brief regulator configuration structure for IOCTL.
+ *
+ */
+typedef struct _t_regulator_cfg_param{
+	/*!
+	 * Regulator.
+	 */
+	t_pmic_regulator regulator;
+	/*!
+	 * Regulator configuration.
+	 */
+	t_regulator_config cfg;
+} t_regulator_cfg_param;
+
+/*!
+ * This struct list all state reads in Power Up Sense
+ */
+struct t_p_up_sense {
+	/*!
+	 * power up sense ictest
+	 */
+	bool state_ictest;
+	/*!
+	 * power up sense clksel
+	 */
+	bool state_clksel;
+	/*!
+	 * power up mode supply 1
+	 */
+	bool state_pums1;
+	/*!
+	 * power up mode supply 2
+	 */
+	bool state_pums2;
+	/*!
+	 * power up mode supply 3
+	 */
+	bool state_pums3;
+	/*!
+	 * power up sense charge mode 0
+	 */
+	bool state_chrgmode0;
+	/*!
+	 * power up sense charge mode 1
+	 */
+	bool state_chrgmode1;
+	/*!
+	 * power up sense USB mode
+	 */
+	bool state_umod;
+	/*!
+	 * power up sense boot mode enable for USB/RS232
+	 */
+	bool state_usben;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_1a1b_joined;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_2a2b_joined;
+};
+
+/*!
+ * This enumeration define all On_OFF button
+ */
+typedef enum _t_button{
+	/*!
+	 * ON1B
+	 */
+	BT_ON1B = 0,
+	/*!
+	 * ON2B
+	 */
+	BT_ON2B,
+	/*!
+	 * ON3B
+	 */
+	BT_ON3B,
+} t_button;
+
+#ifdef __KERNEL__
+/* EXPORTED FUNCTIONS */
+
+/*!
+ * This function sets user power off in power control register and thus powers
+ * off the phone.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_off(void);
+
+/*!
+ * This function sets the power control configuration.
+ *
+ * @param        pc_config   power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_set_pc_config(t_pc_config *pc_config);
+
+/*!
+ * This function retrives the power control configuration.
+ *
+ * @param        pc_config   pointer to power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_pc_config(t_pc_config *pc_config);
+
+/*!
+ * This function turns on a regulator.
+ *
+ * @param        regulator    The regulator to be turned on.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator);
+
+/*!
+ * This function turns off a regulator.
+ *
+ * @param        regulator    The regulator to be turned off.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator);
+
+/*!
+ * This function sets the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      The regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
+		t_regulator_voltage voltage);
+
+/*!
+ * This function retrieves the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      Pointer to regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
+		t_regulator_voltage *voltage);
+
+/*!
+ * This function sets the DVS voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs(t_pmic_regulator regulator,
+		t_regulator_voltage dvs);
+
+/*!
+ * This function gets the DVS voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs(t_pmic_regulator regulator,
+		t_regulator_voltage *dvs);
+
+/*!
+ * This function sets the standby voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_stby(t_pmic_regulator regulator,
+		t_regulator_voltage stby);
+
+/*!
+ * This function gets the standby voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_stby(t_pmic_regulator regulator,
+		t_regulator_voltage *stby);
+
+/*!
+ * This function sets the switchers mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         The switcher mode
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_mode(t_pmic_regulator regulator,
+		t_regulator_sw_mode mode, bool stby);
+
+/*!
+ * This function gets the switchers mode.
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        mode         The switcher mode.
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_mode(t_pmic_regulator regulator,
+		t_regulator_sw_mode *mode, bool stby);
+
+/*!
+ * This function sets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs_speed(t_pmic_regulator regulator,
+		t_switcher_dvs_speed speed);
+
+/*!
+ * This function gets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs_speed(t_pmic_regulator regulator,
+		t_switcher_dvs_speed *speed);
+
+/*!
+ * This function sets the switch panic mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_panic_mode(t_pmic_regulator regulator,
+		bool panic_mode);
+
+/*!
+ * This function gets the switch panic mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_panic_mode(t_pmic_regulator regulator,
+		bool *panic_mode);
+
+/*!
+ * This function sets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_softstart(t_pmic_regulator regulator,
+		bool softstart);
+
+/*!
+ * This function gets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_softstart(t_pmic_regulator regulator,
+		bool *softstart);
+
+/*!
+ * This function sets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        factor              The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_factor(t_pmic_regulator regulator,
+		t_switcher_factor factor);
+
+/*!
+ * This function gets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_factor(t_pmic_regulator regulator,
+		t_switcher_factor *factor);
+
+/*!
+ * This function enables or disables low power mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_lp_mode(t_pmic_regulator regulator,
+		t_regulator_lp_mode lp_mode);
+
+/*!
+ * This function gets low power mode.
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_lp_mode(t_pmic_regulator regulator,
+		t_regulator_lp_mode *lp_mode);
+
+/*!
+ * This function sets the regulator configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       The regulator output configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_config(t_pmic_regulator regulator,
+		t_regulator_config *config);
+
+/*!
+ * This function retrieves the regulator output configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       Pointer to regulator configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_config(t_pmic_regulator regulator,
+		t_regulator_config *config);
+
+/*!
+ * This function enables automatically VBKUP2 in the memory hold modes.
+ *
+ * @param        en           if true, enable VBKUP2AUTOMH
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vbkup2_auto_en(bool en);
+
+/*!
+ * This function gets state of automatically VBKUP2.
+ *
+ * @param        en           if true, VBKUP2AUTOMH is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_vbkup2_auto_state(bool *en);
+
+/*!
+ * This function enables battery detect function.
+ *
+ * @param        en           if true, enable BATTDETEN
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_bat_det_en(bool en);
+
+/*!
+ * This function gets state of battery detect function.
+ *
+ * @param        en           if true, BATTDETEN is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_bat_det_state(bool *en);
+
+/*!
+ * This function enables control of VVIB by VIBEN pin.
+ *
+ * @param        en           if true, enable VIBPINCTRL
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vib_pin_en(bool en);
+
+/*!
+ * This function gets state of control of VVIB by VIBEN pin.
+ * @param        en           if true, VIBPINCTRL is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_gets_vib_pin_state(bool *en);
+
+/*!
+ * This function returns power up sense value
+ *
+ * @param        p_up_sense     value of power up sense
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_power_mode_sense(struct t_p_up_sense *p_up_sense);
+
+/*!
+ * This function configures the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         if true, the regulator is enabled by regen.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_assig(t_pmic_regulator regulator, bool en_dis);
+
+/*!
+ * This function gets the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         return value, if true :
+ *       		         the regulator is enabled by regen.
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_assig(t_pmic_regulator regu, bool *en_dis);
+
+/*!
+ * This function sets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_inv(bool en_dis);
+
+/*!
+ * This function gets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+
+PMIC_STATUS pmic_power_get_regen_inv(bool *en_dis);
+
+/*!
+ * This function enables esim control voltage.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_esim_v_en(bool vesim, bool vmmc1, bool vmmc2);
+
+/*!
+ * This function gets esim control voltage values.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_gets_esim_v_state(bool *vesim,
+		bool *vmmc1, bool *vmmc2);
+
+/*!
+ * This function enables auto reset after a system reset.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_auto_reset_en(bool en);
+
+/*!
+ * This function gets auto reset configuration.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_auto_reset_en(bool *en);
+
+/*!
+ * This function configures a system reset on a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, enable the system reset on this button
+ * @param       deb_time   sets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_conf_button(t_button bt, bool sys_rst, int deb_time);
+
+/*!
+ * This function gets configuration of a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, the system reset is enabled on this button
+ * @param       deb_time   gets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_conf_button(t_button bt,
+		bool *sys_rst, int *deb_time);
+
+/*!
+ * This function is used to subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_sub(t_pwr_int event, void *callback);
+
+/*!
+ * This function is used to un subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_unsub(t_pwr_int event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_POWER_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_rtc.h b/include/asm-arm/plat-mxc/pmic_rtc.h
new file mode 100644
index 0000000..d0f7502
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_rtc.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+#define	PMIC_RTC_SET_TIME            _IOWR('p', 0xd1, int)
+#define PMIC_RTC_GET_TIME            _IOWR('p', 0xd2, int)
+#define PMIC_RTC_SET_ALARM		     _IOWR('p', 0xd3, int)
+#define PMIC_RTC_GET_ALARM		     _IOWR('p', 0xd4, int)
+#define PMIC_RTC_WAIT_ALARM		     _IOWR('p', 0xd5, int)
+#define PMIC_RTC_ALARM_REGISTER      _IOWR('p', 0xd6, int)
+#define PMIC_RTC_ALARM_UNREGISTER    _IOWR('p', 0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum _t_rtc_int{
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ * 		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/asm-arm/plat-mxc/pmic_status.h b/include/asm-arm/plat-mxc/pmic_status.h
new file mode 100644
index 0000000..8d2b22a
--- /dev/null
+++ b/include/asm-arm/plat-mxc/pmic_status.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <linux/uaccess.h>
+#include <asm-generic/errno-base.h>
+/*!
+ * @file pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * Define bool type if it is not defined.
+ */
+#ifndef bool
+#define bool int
+#endif
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation
+						  was successfully completed. */
+	PMIC_ERROR = -1,	/*!< The requested operation */
+	/*  could not be completed due to an error. */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested */
+	/*  operation failed because one or */
+	/*  more of the parameters was invalid. */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could */
+	/* not be completed because the PMIC */
+	/* hardware does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation */
+	/*  could not be completed because */
+	/*  there are too many PMIC client */
+	/*  requests */
+} PMIC_STATUS;
+
+int pmic_read(unsigned int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)		\
+do {					\
+	int ret = (a);		\
+	if (ret != PMIC_SUCCESS)	\
+	return ret;			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs)	\
+do {					\
+	int ret = (func);	\
+	if (ret != PMIC_SUCCESS) {	\
+		freeptrs;	\
+		return ret;	\
+	}   \
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
-- 
1.6.0.4

