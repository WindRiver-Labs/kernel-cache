From 1afc91233ff05841c3588de433422c296568c4e2 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 19 May 2010 14:10:37 +0800
Subject: [PATCH 02/30] mxc/plat: add mxc platform common files

Add all mxc platform common files, include power management software
framework, usb transceiver management, gpio, irq and clock management.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/plat-mxc/Kconfig      |   93 ++++
 arch/arm/plat-mxc/Makefile     |   33 ++-
 arch/arm/plat-mxc/clock.c      |   18 +
 arch/arm/plat-mxc/cpu_common.c |   87 ++++
 arch/arm/plat-mxc/cpufreq.c    |  318 ++++++++++++++
 arch/arm/plat-mxc/dptc.c       |  624 +++++++++++++++++++++++++++
 arch/arm/plat-mxc/dvfs_core.c  |  914 ++++++++++++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/dvfs_per.c   |  894 +++++++++++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/entry-pm.S   |  315 ++++++++++++++
 arch/arm/plat-mxc/gpio.c       |   32 ++
 arch/arm/plat-mxc/irq.c        |  132 ++++++
 arch/arm/plat-mxc/isp1504xc.c  |  272 ++++++++++++
 arch/arm/plat-mxc/serialxc.c   |   60 +++
 arch/arm/plat-mxc/snoop.c      |  128 ++++++
 arch/arm/plat-mxc/spba.c       |  131 ++++++
 arch/arm/plat-mxc/system.c     |    4 +-
 arch/arm/plat-mxc/tzic.c       |    5 +-
 arch/arm/plat-mxc/usb_common.c |  876 ++++++++++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/utmixc.c     |  102 +++++
 19 files changed, 5034 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/plat-mxc/cpu_common.c
 create mode 100644 arch/arm/plat-mxc/cpufreq.c
 create mode 100644 arch/arm/plat-mxc/dptc.c
 create mode 100644 arch/arm/plat-mxc/dvfs_core.c
 create mode 100644 arch/arm/plat-mxc/dvfs_per.c
 create mode 100644 arch/arm/plat-mxc/entry-pm.S
 create mode 100644 arch/arm/plat-mxc/isp1504xc.c
 create mode 100644 arch/arm/plat-mxc/serialxc.c
 create mode 100644 arch/arm/plat-mxc/snoop.c
 create mode 100644 arch/arm/plat-mxc/spba.c
 create mode 100644 arch/arm/plat-mxc/usb_common.c
 create mode 100644 arch/arm/plat-mxc/utmixc.c

diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 7f7ad6f..45b1a4d 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -87,6 +87,9 @@ config MXC_ULPI
 config ARCH_HAS_RNGA
 	bool
 
+config ARCH_HAS_RNGC
+	bool
+
 config IMX_HAVE_IOMUX_V1
 	bool
 
@@ -99,4 +102,94 @@ config ARCH_MXC_AUDMUX_V1
 config ARCH_MXC_AUDMUX_V2
 	bool
 
+config MXC_DSP_BRINGUP
+	bool
+
+config ARCH_HAS_EVTMON
+	bool
+
+config MXC_EMMA
+	bool
+
+config MXC_FB_IRAM
+	bool
+
+config DMA_ZONE_SIZE
+	int "DMA memory zone size"
+	range 0 64
+	default 24
+	help
+	  This is the size in MB for the DMA zone. The DMA zone is used for
+	  dedicated memory for large contiguous video buffers
+
+# set if we need the 1504 transceiver code
+config ISP1504_MXC
+	bool
+	select ISP1504_MXC_OTG if USB_GADGET && USB_EHCI_HCD && USB_OTG
+	default y if USB_EHCI_FSL_1504 || USB_GADGET_FSL_1504
+
+config ISP1504_MXC_OTG
+	tristate
+	help
+	  Support for USB OTG pin detect using the ISP1504 transceiver on MXC platforms.
+
+# set if we need the UTMI transceiver code
+config UTMI_MXC
+	bool
+	default y if USB_EHCI_FSL_UTMI || USB_GADGET_FSL_UTMI
+	depends on ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51
+
+#config UTMI_MXC_OTG
+# 	tristate
+# 	help
+# 	  Support for USB OTG pin detect using the UTMI transceiver on MXC platforms.
+
+# set if we need the 1301 transceiver code
+config ISP1301_MXC
+	bool
+	default y if USB_EHCI_FSL_1301 || USB_GADGET_FSL_1301
+	select I2C_MXC
+
+# set if we need the mx13783 transceiver code
+config MC13783_MXC
+	bool
+	default y if USB_EHCI_FSL_MC13783 || USB_GADGET_FSL_MC13783
+	select SPI_MXC
+
+choice
+	prompt "Select serial USB transceiver mode"
+	depends on ISP1301_MXC || MC13783_MXC
+	default MXC_USB_SU6
+
+config MXC_USB_SU6
+	bool "Single Ended Unidirectional Mode"
+	help
+	  If you say yes to this option, the serial tranceiver operates in SU6 mode.
+	  This option will work for either the Freescale MC13783 or Philips ISP1301
+	  transceiver.
+
+config MXC_USB_SB3
+	bool "Single Ended Bidirectional Mode"
+	help
+	  If you say yes to this option, the serial tranceiver operates in SB3 mode.
+	  Not recommended for the Freescale MC13783.
+
+config MXC_USB_DU6
+	bool "Differential Unidirectional Mode"
+	help
+	  If you say yes to this option, the serial tranceiver operates in DU6 mode.
+
+config MXC_USB_DB4
+	bool "Differential Bidirectional Mode"
+	help
+	  If you say yes to this option, the serial tranceiver operates in DB4 mode.
+
+endchoice
+
+config MXC_DVFS_PER
+	bool "Enable DVFS Peripheral"
+	depends on ARCH_MX37 || ARCH_MX51
+	help
+	   Select this if you want to enable HW supported peripheral frequency scaling.
+
 endif
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 895bc3c..13ab7b6 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,8 @@
 #
 
 # Common support
-obj-y := irq.o clock.o gpio.o time.o devices.o cpu.o system.o
+obj-y := irq.o clock.o gpio.o time.o devices.o cpu.o system.o cpu_common.o \
+	 snoop.o
 
 # MX51 uses the TZIC interrupt controller, older platforms use AVIC (irq.o)
 obj-$(CONFIG_MXC_TZIC) += tzic.o
@@ -21,3 +22,33 @@ ifdef CONFIG_SND_IMX_SOC
 obj-y += ssi-fiq.o
 obj-y += ssi-fiq-ksym.o
 endif
+
+ifneq ($(CONFIG_ARCH_MX27),y)
+obj-y += spba.o
+endif
+
+obj-$(CONFIG_ARCH_MX3) += dptc.o usb_common.o entry-pm.o
+obj-$(CONFIG_ARCH_MX51) += usb_common.o utmixc.o dvfs_core.o
+
+# CPU FREQ support
+obj-$(CONFIG_CPU_FREQ_IMX)    += cpufreq.o
+
+# DVFS-PER support
+obj-$(CONFIG_MXC_DVFS_PER) 	+= dvfs_per.o
+
+# USB support
+obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
+obj-$(CONFIG_ISP1301_MXC) += isp1301xc.o
+obj-$(CONFIG_MC13783_MXC) += mc13783_xc.o
+
+ifneq ($(strip $(CONFIG_USB_EHCI_FSL_UTMI) $(CONFIG_USB_GADGET_FSL_UTMI)),)
+obj-y += utmixc.o
+endif
+
+ifneq ($(CONFIG_USB_EHCI_ARC_H1)$(CONFIG_USB_EHCI_ARC_H2),)
+ifneq ($(CONFIG_ARCH_MX51),y)
+obj-y += serialxc.o
+else
+obj-y += isp1504xc.o
+endif
+endif
diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
index 323ff8c..21a46d5 100644
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -108,6 +108,24 @@ void clk_disable(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_disable);
 
+/*!
+ * @brief Function to get the usage count for the requested clock.
+ *
+ * This function returns the reference count for the clock.
+ *
+ * @param clk	Handle to clock to disable.
+ *
+ * @return Returns the usage count for the requested clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+EXPORT_SYMBOL(clk_get_usecount);
+
 /* Retrieve the *current* clock rate. If the clock itself
  * does not provide a special calculation routine, ask
  * its parent and so on, until one is able to return
diff --git a/arch/arm/plat-mxc/cpu_common.c b/arch/arm/plat-mxc/cpu_common.c
new file mode 100644
index 0000000..ee7a21e
--- /dev/null
+++ b/arch/arm/plat-mxc/cpu_common.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/setup.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+
+/*!
+ * @file plat-mxc/cpu_common.c
+ *
+ * @brief This file contains the common CPU initialization code.
+ *
+ * @ingroup MSL_MX31 MSL_MXC91321
+ */
+
+static int __init system_rev_setup(char *p)
+{
+	strict_strtoul(p, 16, &system_rev);
+
+	return 0;
+}
+
+early_param("system_rev=", system_rev_setup);
+
+int mxc_jtag_enabled;		/* OFF: 0 (default), ON: 1 */
+
+/*
+ * Here are the JTAG options from the command line. By default JTAG
+ * is OFF which means JTAG is not connected and WFI is enabled
+ *
+ *       "on" --  JTAG is connected, so WFI is disabled
+ *       "off" -- JTAG is disconnected, so WFI is enabled
+ */
+
+static int __init jtag_wfi_setup(char *p)
+{
+	if (memcmp(p, "on", 2) == 0) {
+		mxc_jtag_enabled = 1;
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
+		mxc_jtag_enabled = 0;
+		p += 3;
+	}
+
+	return 0;
+}
+
+early_param("jtag=", jtag_wfi_setup);
+
+void __init mxc_cpu_common_init(void)
+{
+	mxc_set_cpu_type((((system_rev >> 20) & 0xF) * 10) \
+			+ ((system_rev >> 16) & 0xF));
+	pr_info("CPU is %s%x Revision %u.%u\n",
+		(mxc_cpu() < 0x100) ? "i.MX" : "MXC",
+		mxc_cpu(), mxc_cpu_rev_major(), mxc_cpu_rev_minor());
+}
+
+/**
+ * early_console_setup - setup debugging console
+ *
+ * Consoles started here require little enough setup that we can start using
+ * them very early in the boot process, either right after the machine
+ * vector initialization, or even before if the drivers can detect their hw.
+ *
+ * Returns non-zero if a console couldn't be setup.
+ * This function is developed based on
+ * early_console_setup function as defined in arch/ia64/kernel/setup.c
+ */
+void __init early_console_setup(char *cmdline)
+{
+#ifdef CONFIG_SERIAL_MXC_CONSOLE
+	mxc_early_serial_console_init(cmdline);
+#endif
+}
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
new file mode 100644
index 0000000..3330f46
--- /dev/null
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file cpufreq.c
+ *
+ * @brief A driver for the Freescale Semiconductor i.MXC CPUfreq module.
+ *
+ * The CPUFREQ driver is for controling CPU frequency. It allows you to change
+ * the CPU clock speed on the fly.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <asm/cacheflush.h>
+#include <linux/hrtimer.h>
+
+int cpu_freq_khz_min;
+int cpu_freq_khz_max;
+int arm_lpm_clk;
+int arm_normal_clk;
+int cpufreq_suspended;
+int cpufreq_trig_needed;
+
+static struct clk *cpu_clk;
+static struct regulator *gp_regulator;
+static struct cpu_wp *cpu_wp_tbl;
+static struct cpufreq_frequency_table imx_freq_table[4];
+
+int set_cpu_freq(int freq)
+{
+	int ret = 0;
+	int org_cpu_rate;
+	int gp_volt = 0;
+	int i;
+
+	org_cpu_rate = clk_get_rate(cpu_clk);
+	if (org_cpu_rate == freq)
+		return ret;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (freq == cpu_wp_tbl[i].cpu_rate)
+			gp_volt = cpu_wp_tbl[i].cpu_voltage;
+	}
+
+	if (gp_volt == 0)
+		return ret;
+
+	/*Set the voltage for the GP domain. */
+	if (freq > org_cpu_rate) {
+		ret = regulator_set_voltage(gp_regulator, gp_volt, gp_volt);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
+			return ret;
+		}
+	}
+
+	ret = clk_set_rate(cpu_clk, freq);
+	if (ret != 0) {
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+		return ret;
+	}
+
+	if (freq < org_cpu_rate) {
+		ret = regulator_set_voltage(gp_regulator, gp_volt, gp_volt);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int mxc_verify_speed(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	return cpufreq_frequency_table_verify(policy, imx_freq_table);
+}
+
+static unsigned int mxc_get_speed(unsigned int cpu)
+{
+	if (cpu)
+		return 0;
+
+	return clk_get_rate(cpu_clk) / 1000;
+}
+
+static int calc_frequency_khz(int target, unsigned int relation)
+{
+	int i;
+
+	if ((target * 1000) == clk_get_rate(cpu_clk))
+		return target;
+
+	if (relation == CPUFREQ_RELATION_H) {
+		for (i = cpu_wp_nr - 1; i >= 0; i--) {
+			if (imx_freq_table[i].frequency <= target)
+				return imx_freq_table[i].frequency;
+		}
+	} else if (relation == CPUFREQ_RELATION_L) {
+		for (i = 0; i < cpu_wp_nr; i++) {
+			if (imx_freq_table[i].frequency >= target)
+				return imx_freq_table[i].frequency;
+		}
+	}
+	printk(KERN_ERR "Error: No valid cpufreq relation\n");
+	return cpu_freq_khz_max;
+}
+
+static int mxc_set_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq, unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	int freq_Hz;
+	int low_freq_bus_ready = 0;
+	int ret = 0;
+
+	if (dvfs_core_is_active || cpufreq_suspended) {
+		target_freq = clk_get_rate(cpu_clk) / 1000;
+		freq_Hz = calc_frequency_khz(target_freq, relation) * 1000;
+		if (freq_Hz == arm_lpm_clk)
+			freqs.old = cpu_wp_tbl[cpu_wp_nr - 2].cpu_rate / 1000;
+		else
+			freqs.old = arm_lpm_clk / 1000;
+
+		freqs.new = freq_Hz / 1000;
+		freqs.cpu = 0;
+		freqs.flags = 0;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+		return ret;
+	}
+	/*
+	 * Some governors do not respects CPU and policy lower limits
+	 * which leads to bad things (division by zero etc), ensure
+	 * that such things do not happen.
+	 */
+	if (target_freq < policy->cpuinfo.min_freq)
+		target_freq = policy->cpuinfo.min_freq;
+
+	if (target_freq < policy->min)
+		target_freq = policy->min;
+
+	freq_Hz = calc_frequency_khz(target_freq, relation) * 1000;
+
+	freqs.old = clk_get_rate(cpu_clk) / 1000;
+	freqs.new = freq_Hz / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+	low_freq_bus_ready = low_freq_bus_used();
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	if (!dvfs_core_is_active) {
+		if ((freq_Hz == arm_lpm_clk) && (!low_bus_freq_mode)
+		    && (low_freq_bus_ready)) {
+			if (freqs.old != freqs.new)
+				ret = set_cpu_freq(freq_Hz);
+			set_low_bus_freq();
+
+		} else {
+			set_high_bus_freq(0);
+			ret = set_cpu_freq(freq_Hz);
+		}
+	}
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return ret;
+}
+
+static int __init mxc_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+	int ret;
+	int i;
+
+	printk(KERN_INFO "i.MXC CPU frequency driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_ERR "%s: failed to get cpu clock\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	gp_regulator = regulator_get(NULL, gp_reg_id);
+	if (IS_ERR(gp_regulator)) {
+		clk_put(cpu_clk);
+		printk(KERN_ERR "%s: failed to get gp regulator\n", __func__);
+		return PTR_ERR(gp_regulator);
+	}
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	cpu_freq_khz_min = cpu_wp_tbl[0].cpu_rate / 1000;
+	cpu_freq_khz_max = cpu_wp_tbl[0].cpu_rate / 1000;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		imx_freq_table[cpu_wp_nr - 1 - i].index = cpu_wp_nr - i;
+		imx_freq_table[cpu_wp_nr - 1 - i].frequency =
+		    cpu_wp_tbl[i].cpu_rate / 1000;
+
+		if ((cpu_wp_tbl[i].cpu_rate / 1000) < cpu_freq_khz_min)
+			cpu_freq_khz_min = cpu_wp_tbl[i].cpu_rate / 1000;
+
+		if ((cpu_wp_tbl[i].cpu_rate / 1000) > cpu_freq_khz_max)
+			cpu_freq_khz_max = cpu_wp_tbl[i].cpu_rate / 1000;
+	}
+
+	imx_freq_table[i].index = 0;
+	imx_freq_table[i].frequency = CPUFREQ_TABLE_END;
+
+	policy->cur = clk_get_rate(cpu_clk) / 1000;
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->min = policy->cpuinfo.min_freq = cpu_freq_khz_min;
+	policy->max = policy->cpuinfo.max_freq = cpu_freq_khz_max;
+
+	arm_lpm_clk = cpu_freq_khz_min * 1000;
+	arm_normal_clk = cpu_freq_khz_max * 1000;
+
+	/* Manual states, that PLL stabilizes in two CLK32 periods */
+	policy->cpuinfo.transition_latency = 10;
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, imx_freq_table);
+
+	if (ret < 0) {
+		clk_put(cpu_clk);
+		regulator_put(gp_regulator);
+		printk(KERN_ERR "%s: failed to register i.MXC CPUfreq\n",
+		       __func__);
+		return ret;
+	}
+
+	cpufreq_frequency_table_get_attr(imx_freq_table, policy->cpu);
+	return 0;
+}
+
+static int mxc_cpufreq_suspend(struct cpufreq_policy *policy,
+				     pm_message_t state)
+{
+	return 0;
+}
+
+static int mxc_cpufreq_resume(struct cpufreq_policy *policy)
+{
+	return 0;
+}
+
+static int mxc_cpufreq_driver_exit(struct cpufreq_policy *policy)
+{
+	cpufreq_frequency_table_put_attr(policy->cpu);
+
+	/* Reset CPU to 665MHz */
+	if (!dvfs_core_is_active)
+		set_cpu_freq(arm_normal_clk);
+	if (!high_bus_freq_mode)
+		set_high_bus_freq(1);
+
+	clk_put(cpu_clk);
+	regulator_put(gp_regulator);
+	return 0;
+}
+
+static struct cpufreq_driver mxc_driver = {
+	.flags = CPUFREQ_STICKY,
+	.verify = mxc_verify_speed,
+	.target = mxc_set_target,
+	.get = mxc_get_speed,
+	.init = mxc_cpufreq_driver_init,
+	.exit = mxc_cpufreq_driver_exit,
+	.suspend = mxc_cpufreq_suspend,
+	.resume = mxc_cpufreq_resume,
+	.name = "imx",
+};
+
+static int __devinit mxc_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&mxc_driver);
+}
+
+static void mxc_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&mxc_driver);
+}
+
+module_init(mxc_cpufreq_init);
+module_exit(mxc_cpufreq_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("CPUfreq driver for i.MX");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/dptc.c b/arch/arm/plat-mxc/dptc.c
new file mode 100644
index 0000000..d0b157e
--- /dev/null
+++ b/arch/arm/plat-mxc/dptc.c
@@ -0,0 +1,624 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DPTC module.
+ *
+ * The DPTC driver is designed to control the MXC DPTC hardware.
+ * hardware. Upon initialization, the DPTC driver initializes the DPTC hardware
+ * sets up driver nodes attaches to the DPTC interrupt and initializes internal
+ * data structures. When the DPTC interrupt occurs the driver checks the cause
+ * of the int(lower frequency, increase frequency or emergency) and changes
+ * the CPU volt according to translation table that is loaded into the driver.
+ * The driver read method is used to read the log buffer.
+ * Driver ioctls are used to change driver parameters and enable/disable the
+ * DVFS operation.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dptc.h>
+
+#include "../../../drivers/base/base.h"
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+enum {
+	DPTC_PTVAI_NOCHANGE = 0x0,
+	DPTC_PTVAI_DECREASE,
+	DPTC_PTVAI_INCREASE,
+	DPTC_PTVAI_EMERG,
+};
+
+struct device *dev_data0;
+struct device *dev_data1;
+
+/*!
+ * In case the MXC device has multiple DPTC modules, this structure is used to
+ * store information specific to each DPTC module.
+ */
+struct dptc_device {
+	/* DPTC delayed work */
+	struct delayed_work dptc_work;
+	/* DPTC spinlock */
+	spinlock_t lock;
+	/* DPTC regulator */
+	struct regulator *dptc_reg;
+	/* DPTC clock */
+	struct clk *dptc_clk;
+	/* DPTC is active flag */
+	int dptc_is_active;
+	/* turbo mode active flag */
+	int turbo_mode_active;
+	/* DPTC current working point */
+	int curr_wp;
+	/* DPTC vai bits */
+	u32 ptvai;
+	/* The interrupt number used by the DPTC device */
+	int irq;
+	/* DPTC platform data pointer */
+	struct mxc_dptc_data *dptc_platform_data;
+};
+
+static void update_dptc_wp(struct dptc_device *drv_data, u32 wp)
+{
+	struct mxc_dptc_data *dptc_data = drv_data->dptc_platform_data;
+	int voltage_uV;
+	int ret = 0;
+
+	voltage_uV = dptc_data->dptc_wp_allfreq[wp].voltage * 1000;
+
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr0,
+		     dptc_data->dcvr0_reg_addr);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr1,
+		     dptc_data->dcvr0_reg_addr + 0x4);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr2,
+		     dptc_data->dcvr0_reg_addr + 0x8);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr3,
+		     dptc_data->dcvr0_reg_addr + 0xC);
+
+	/* Set the voltage */
+	ret = regulator_set_voltage(drv_data->dptc_reg, voltage_uV, voltage_uV);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET VOLTAGE!!!!!\n");
+
+	pr_debug("dcvr0-3: 0x%x, 0x%x, 0x%x, 0x%x; vol: %d\n",
+		 dptc_data->dptc_wp_allfreq[wp].dcvr0,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr1,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr2,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr3,
+		 dptc_data->dptc_wp_allfreq[wp].voltage);
+}
+
+static irqreturn_t dptc_irq(int irq, void *dev_id)
+{
+	struct device *dev = dev_id;
+	struct dptc_device *drv_data = dev->p->driver_data;
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	u32 gpc_cntr = __raw_readl(dptc_data->gpc_cntr_reg_addr);
+
+	gpc_cntr = (gpc_cntr & dptc_data->dptccr);
+
+	if (gpc_cntr) {
+		drv_data->ptvai =
+		    (dptccr & dptc_data->vai_mask) >> dptc_data->vai_offset;
+		pr_debug("dptc_irq: vai = 0x%x (0x%x)!!!!!!!\n",
+			 drv_data->ptvai, dptccr);
+
+		/* disable DPTC and mask its interrupt */
+		dptccr = (dptccr & ~(dptc_data->dptc_enable_bit)) |
+		    (dptc_data->irq_mask);
+		dptccr = (dptccr & ~(dptc_data->dptc_nvcr_bit));
+		__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+
+		if (drv_data->turbo_mode_active == 1)
+			schedule_delayed_work(&drv_data->dptc_work, 0);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static void dptc_workqueue_handler(struct work_struct *work1)
+{
+	struct delayed_work *dptc_work_tmp =
+	    container_of(work1, struct delayed_work, work);
+	struct dptc_device *drv_data =
+	    container_of(dptc_work_tmp, struct dptc_device, dptc_work);
+	struct mxc_dptc_data *dptc_data = drv_data->dptc_platform_data;
+	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	switch (drv_data->ptvai) {
+	case DPTC_PTVAI_DECREASE:
+		drv_data->curr_wp++;
+		break;
+	case DPTC_PTVAI_INCREASE:
+	case DPTC_PTVAI_EMERG:
+		drv_data->curr_wp--;
+		if (drv_data->curr_wp < 0) {
+			/* already max voltage */
+			drv_data->curr_wp = 0;
+			printk(KERN_WARNING "dptc: already maximum voltage\n");
+		}
+		break;
+
+		/* Unknown interrupt cause */
+	default:
+		BUG();
+	}
+
+	if (drv_data->curr_wp > dptc_data->dptc_wp_supported
+	    || drv_data->curr_wp < 0) {
+		panic("Can't support this working point: %d\n",
+		      drv_data->curr_wp);
+	}
+	update_dptc_wp(drv_data, drv_data->curr_wp);
+
+	/* Enable DPTC and unmask its interrupt */
+	dptccr = (dptccr & ~(dptc_data->irq_mask)) |
+	    dptc_data->dptc_nvcr_bit | dptc_data->dptc_enable_bit;
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+}
+
+/* Start DPTC unconditionally */
+static int start_dptc(struct device *dev)
+{
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	struct dptc_device *drv_data = dev->p->driver_data;
+	u32 dptccr;
+	unsigned long flags;
+	unsigned long clk_rate;
+	int voltage_uV;
+
+	/* Get the voltage */
+	drv_data->dptc_reg = regulator_get(NULL, dptc_data->reg_id);
+	voltage_uV = regulator_get_voltage(drv_data->dptc_reg);
+	drv_data->curr_wp =
+	    (dptc_data->dptc_wp_allfreq[0].voltage - (voltage_uV / 1000)) / 25;
+
+	update_dptc_wp(drv_data, drv_data->curr_wp);
+
+	/* Set the voltage */
+	spin_lock_irqsave(&drv_data->lock, flags);
+
+	clk_rate = clk_get_rate(drv_data->dptc_clk);
+
+	if (clk_rate < dptc_data->clk_max_val)
+		goto err;
+
+	if (dptc_data->gpc_irq_bit != 0x0) {
+		/* Enable ARM domain frequency and/or voltage update needed
+		   and enable ARM IRQ */
+		__raw_writel(dptc_data->gpc_irq_bit | dptc_data->gpc_adu,
+			     dptc_data->gpc_cntr_reg_addr);
+	}
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	/* Enable DPTC and unmask its interrupt */
+	dptccr = ((dptccr & ~(dptc_data->irq_mask)) | dptc_data->enable_config);
+
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+
+	spin_unlock_irqrestore(&drv_data->lock, flags);
+
+	drv_data->dptc_is_active = 1;
+	drv_data->turbo_mode_active = 1;
+
+	pr_info("DPTC has been started\n");
+
+	return 0;
+
+err:
+	spin_unlock_irqrestore(&drv_data->lock, flags);
+	pr_info("DPTC is not enabled\n");
+	return -1;
+}
+
+/* Stop DPTC unconditionally */
+static void stop_dptc(struct device *dev)
+{
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	struct dptc_device *drv_data = dev->p->driver_data;
+	u32 dptccr;
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	/* disable DPTC and mask its interrupt */
+	dptccr = ((dptccr & ~(dptc_data->dptc_enable_bit)) |
+		  dptc_data->irq_mask) & (~dptc_data->dptc_nvcr_bit);
+
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+
+	/* Restore Turbo Mode voltage to highest wp */
+	update_dptc_wp(drv_data, 0);
+	drv_data->curr_wp = 0;
+
+	regulator_put(drv_data->dptc_reg);
+
+	pr_info("DPTC has been stopped\n");
+}
+
+/*
+  This function does not change the working point. It can be
+ called from an interrupt context.
+*/
+void dptc_suspend(int id)
+{
+	struct mxc_dptc_data *dptc_data;
+	struct dptc_device *drv_data;
+	u32 dptccr;
+
+	switch (id) {
+	case DPTC_GP_ID:
+		dptc_data = dev_data0->platform_data;
+		drv_data = dev_data0->p->driver_data;
+		break;
+	case DPTC_LP_ID:
+		if (dev_data1 == NULL)
+			return;
+
+		dptc_data = dev_data1->platform_data;
+		drv_data = dev_data0->p->driver_data;
+		break;
+		/* Unknown DPTC ID */
+	default:
+		return;
+	}
+
+	if (!drv_data->dptc_is_active)
+		return;
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	/* Disable DPTC and mask its interrupt */
+	dptccr = (dptccr & ~(dptc_data->dptc_enable_bit)) | dptc_data->irq_mask;
+
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+}
+EXPORT_SYMBOL(dptc_suspend);
+
+/*
+  This function does not change the working point. It can be
+ called from an interrupt context.
+*/
+void dptc_resume(int id)
+{
+	struct mxc_dptc_data *dptc_data;
+	struct dptc_device *drv_data;
+	u32 dptccr;
+
+	switch (id) {
+	case DPTC_GP_ID:
+		dptc_data = dev_data0->platform_data;
+		drv_data = dev_data0->p->driver_data;
+		break;
+	case DPTC_LP_ID:
+		if (dev_data1 == NULL)
+			return;
+
+		dptc_data = dev_data1->platform_data;
+		drv_data = dev_data0->p->driver_data;
+		break;
+		/* Unknown DPTC ID */
+	default:
+		return;
+	}
+
+	if (!drv_data->dptc_is_active)
+		return;
+
+	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr0,
+		     dptc_data->dcvr0_reg_addr);
+	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr1,
+		     dptc_data->dcvr0_reg_addr + 0x4);
+	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr2,
+		     dptc_data->dcvr0_reg_addr + 0x8);
+	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr3,
+		     dptc_data->dcvr0_reg_addr + 0xC);
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	/* Enable DPTC and unmask its interrupt */
+	dptccr = (dptccr & ~(dptc_data->irq_mask)) | dptc_data->dptc_enable_bit;
+
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+}
+EXPORT_SYMBOL(dptc_resume);
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_disable(struct device *dev)
+{
+	struct dptc_device *drv_data = dev->p->driver_data;
+
+	if (!(drv_data->dptc_is_active))
+		return;
+
+	stop_dptc(dev);
+	drv_data->dptc_is_active = 0;
+	drv_data->turbo_mode_active = 0;
+}
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+int dptc_enable(struct device *dev)
+{
+	struct dptc_device *drv_data = dev->p->driver_data;
+
+	if (drv_data->dptc_is_active)
+		return 0;
+
+	return start_dptc(dev);
+}
+
+static ssize_t dptc_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct dptc_device *drv_data = dev->p->driver_data;
+
+	if (drv_data->dptc_is_active)
+		return sprintf(buf, "DPTC is enabled\n");
+	else
+		return sprintf(buf, "DPTC is disabled\n");
+}
+
+static ssize_t dptc_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	if (strstr(buf, "0") != NULL)
+		dptc_disable(dev);
+	else if (strstr(buf, "1") != NULL)
+		dptc_enable(dev);
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, dptc_show, dptc_store);
+
+/*!
+ * This is the probe routine for the DPTC driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mxc_dptc_probe(struct platform_device *pdev)
+{
+	struct dptc_device *dptc_device_data;
+	int ret = 0;
+	struct resource *res;
+	u32 dptccr = 0;
+	struct clk *ckih_clk;
+	struct mxc_dptc_data *dptc_data = pdev->dev.platform_data;
+
+	if (dptc_data == NULL) {
+		printk(KERN_ERR "DPTC: Pointer to DPTC data is NULL\
+				not started\n");
+		return -1;
+	}
+
+	dptc_device_data = kzalloc(sizeof(struct dptc_device), GFP_KERNEL);
+	if (!dptc_device_data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	/*
+	 * Request the DPTC interrupt
+	 */
+	dptc_device_data->irq = platform_get_irq(pdev, 0);
+	if (dptc_device_data->irq < 0) {
+		ret = dptc_device_data->irq;
+		goto err1;
+	}
+
+	ret =
+	    request_irq(dptc_device_data->irq, dptc_irq, IRQF_SHARED,
+			pdev->name, &pdev->dev);
+	if (ret) {
+		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt\n");
+		goto err1;
+	}
+
+	dptc_device_data->curr_wp = 0;
+	dptc_device_data->dptc_is_active = 0;
+	dptc_device_data->turbo_mode_active = 0;
+	dptc_device_data->ptvai = 0;
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	printk(KERN_INFO "DPTC mxc_dptc_probe()\n");
+
+	spin_lock_init(&dptc_device_data->lock);
+
+	if (dptc_data->dptc_wp_allfreq == NULL) {
+		ckih_clk = clk_get(NULL, "ckih");
+		if (cpu_is_mx31() &
+		    (mxc_cpu_is_rev(CHIP_REV_2_0) < 0) &
+		    (clk_get_rate(ckih_clk) == 27000000))
+			printk(KERN_ERR "DPTC: DPTC not supported on TO1.x \
+					& ckih = 27M\n");
+		else
+			printk(KERN_ERR "DPTC: Pointer to DPTC table is NULL\
+					not started\n");
+		goto err1;
+	}
+
+	dptc_device_data->dptc_reg = regulator_get(NULL, dptc_data->reg_id);
+
+	if (IS_ERR(dptc_device_data->dptc_reg)) {
+		clk_put(dptc_device_data->dptc_clk);
+		printk(KERN_ERR "%s: failed to get regulator\n", __func__);
+		goto err1;
+	}
+
+	INIT_DELAYED_WORK(&dptc_device_data->dptc_work, dptc_workqueue_handler);
+
+	/* Enable Reference Circuits */
+	dptccr = (dptccr & ~(dptc_data->dcr_mask)) | dptc_data->init_config;
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_enable.attr);
+	if (ret) {
+		printk(KERN_ERR
+		       "DPTC: Unable to register sysdev entry for dptc");
+		goto err1;
+	}
+
+	if (ret != 0) {
+		printk(KERN_ERR "DPTC: Unable to start");
+		goto err1;
+	}
+
+	dptc_device_data->dptc_clk = clk_get(NULL, dptc_data->clk_id);
+
+	if (pdev->id == 0)
+		dev_data0 = &pdev->dev;
+	else
+		dev_data1 = &pdev->dev;
+
+	dptc_device_data->dptc_platform_data = pdev->dev.platform_data;
+
+	/* Set driver data */
+	platform_set_drvdata(pdev, dptc_device_data);
+
+	return 0;
+
+err1:
+	dev_err(&pdev->dev, "Failed to probe DPTC\n");
+	kfree(dptc_device_data);
+	return ret;
+}
+
+/*!
+ * This function is called to put DPTC in a low power state.
+ *
+ * @param   pdev  the device structure
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct dptc_device *drv_data = pdev->dev.p->driver_data;
+
+	if (drv_data->dptc_is_active)
+		stop_dptc(&pdev->dev);
+
+	return 0;
+}
+
+/*!
+ * This function is called to resume the MU from a low power state.
+ *
+ * @param   dev   the device structure
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dptc_resume(struct platform_device *pdev)
+{
+	struct dptc_device *drv_data = pdev->dev.p->driver_data;
+
+	if (drv_data->dptc_is_active)
+		return start_dptc(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver mxc_dptc_driver = {
+	.driver = {
+		   .name = "mxc_dptc",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_dptc_probe,
+	.suspend = mxc_dptc_suspend,
+	.resume = mxc_dptc_resume,
+};
+
+/*!
+ * This function is called to resume the MU from a low power state.
+ *
+ * @param   dev   the device structure used to give information on which MU
+ *                device (0 through 3 channels) to suspend
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init dptc_init(void)
+{
+	if (platform_driver_register(&mxc_dptc_driver) != 0) {
+		printk(KERN_ERR "mxc_dptc_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "DPTC driver module loaded\n");
+
+	return 0;
+}
+
+static void __exit dptc_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxc_dptc_driver);
+
+	printk(KERN_INFO "DPTC driver module unloaded\n");
+}
+
+module_init(dptc_init);
+module_exit(dptc_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DPTC driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/dvfs_core.c b/arch/arm/plat-mxc/dvfs_core.c
new file mode 100644
index 0000000..8fdbbaf
--- /dev/null
+++ b/arch/arm/plat-mxc/dvfs_core.c
@@ -0,0 +1,914 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_core.c
+ *
+ * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and
+ * changes the CPU voltage according to translation table that is loaded into
+ * the driver.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+
+#define MXC_DVFSTHRS_UPTHR_MASK               0x0FC00000
+#define MXC_DVFSTHRS_UPTHR_OFFSET             22
+#define MXC_DVFSTHRS_DNTHR_MASK               0x003F0000
+#define MXC_DVFSTHRS_DNTHR_OFFSET             16
+#define MXC_DVFSTHRS_PNCTHR_MASK              0x0000003F
+#define MXC_DVFSTHRS_PNCTHR_OFFSET            0
+
+#define MXC_DVFSCOUN_DNCNT_MASK               0x00FF0000
+#define MXC_DVFSCOUN_DNCNT_OFFSET             16
+#define MXC_DVFSCOUN_UPCNT_MASK              0x000000FF
+#define MXC_DVFSCOUN_UPCNT_OFFSET            0
+
+#define MXC_DVFSEMAC_EMAC_MASK               0x000001FF
+#define MXC_DVFSEMAC_EMAC_OFFSET             0
+
+#define MXC_DVFSCNTR_DVFEV                   0x10000000
+#define MXC_DVFSCNTR_LBMI                    0x08000000
+#define MXC_DVFSCNTR_LBFL                    0x06000000
+#define MXC_DVFSCNTR_DVFIS                   0x01000000
+#define MXC_DVFSCNTR_FSVAIM                  0x00400000
+#define MXC_DVFSCNTR_FSVAI_MASK              0x00300000
+#define MXC_DVFSCNTR_FSVAI_OFFSET            20
+#define MXC_DVFSCNTR_WFIM                    0x00080000
+#define MXC_DVFSCNTR_WFIM_OFFSET             19
+#define MXC_DVFSCNTR_MAXF_MASK               0x00040000
+#define MXC_DVFSCNTR_MAXF_OFFSET             18
+#define MXC_DVFSCNTR_MINF_MASK               0x00020000
+#define MXC_DVFSCNTR_MINF_OFFSET             17
+#define MXC_DVFSCNTR_LTBRSR_MASK             0x00000018
+#define MXC_DVFSCNTR_LTBRSR_OFFSET           3
+#define MXC_DVFSCNTR_DVFEN                   0x00000001
+
+static struct mxc_dvfs_platform_data *dvfs_data;
+static struct device *dvfs_dev;
+static struct cpu_wp *cpu_wp_tbl;
+int dvfs_core_resume;
+int curr_wp;
+int old_wp;
+
+struct timeval core_prev_intr;
+
+static struct delayed_work dvfs_core_handler;
+
+/*
+ * Clock structures
+ */
+static struct clk *pll1_sw_clk;
+static struct clk *cpu_clk;
+static struct clk *dvfs_clk;
+static struct regulator *core_regulator;
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+/*
+ * Load tracking buffer source: 1 for ld_add; 0 for pre_ld_add; 2 for after EMA
+ */
+#define DVFS_LTBRSR		(2 << MXC_DVFSCNTR_LTBRSR_OFFSET)
+
+
+DEFINE_SPINLOCK(mxc_dvfs_core_lock);
+
+static void dvfs_load_config(int set_point)
+{
+	u32 reg;
+	reg = 0;
+
+	reg |= dvfs_core_setpoint[set_point].upthr << MXC_DVFSTHRS_UPTHR_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].downthr <<
+	    MXC_DVFSTHRS_DNTHR_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].panicthr;
+	__raw_writel(reg, dvfs_data->dvfs_thrs_reg_addr);
+
+	reg = 0;
+	reg |= dvfs_core_setpoint[set_point].downcnt <<
+	    MXC_DVFSCOUN_DNCNT_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].upcnt << MXC_DVFSCOUN_UPCNT_OFFSET;
+	__raw_writel(reg, dvfs_data->dvfs_coun_reg_addr);
+
+	/* Set EMAC value */
+	__raw_writel((dvfs_core_setpoint[set_point].emac <<
+					MXC_DVFSEMAC_EMAC_OFFSET),
+					dvfs_data->dvfs_emac_reg_addr);
+
+
+}
+
+static int set_cpu_freq(int wp)
+{
+	int arm_podf;
+	int podf;
+	int vinc = 0;
+	int ret = 0;
+	int org_cpu_rate;
+	unsigned long rate = 0;
+	int gp_volt = 0;
+	u32 reg;
+	u32 reg1;
+	unsigned long flags;
+
+	if (cpu_wp_tbl[wp].pll_rate != cpu_wp_tbl[old_wp].pll_rate) {
+		org_cpu_rate = clk_get_rate(cpu_clk);
+		rate = cpu_wp_tbl[wp].cpu_rate;
+
+		if (org_cpu_rate == rate)
+			return ret;
+
+		gp_volt = cpu_wp_tbl[wp].cpu_voltage;
+		if (gp_volt == 0)
+			return ret;
+
+		/*Set the voltage for the GP domain. */
+		if (rate > org_cpu_rate) {
+			ret = regulator_set_voltage(core_regulator, gp_volt,
+						    gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+		/* PLL_RELOCK, set ARM_FREQ_SHIFT_DIVIDER */
+		reg = __raw_readl(dvfs_data->ccm_cdcr_reg_addr);
+		reg &= 0xFFFFFFFB;
+		__raw_writel(reg, dvfs_data->ccm_cdcr_reg_addr);
+
+		setup_pll();
+		/* START the GPC main control FSM */
+		/* set VINC */
+		reg = __raw_readl(dvfs_data->gpc_vcr_reg_addr);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+			 MXC_GPCVCR_VCNT_MASK);
+
+		if (rate > org_cpu_rate)
+			reg |= 1 << MXC_GPCVCR_VINC_OFFSET;
+
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+		    (1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, dvfs_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		reg |= MXC_GPCCNTR_ADU;
+		__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+		while (__raw_readl(dvfs_data->gpc_cntr_reg_addr) & 0x4000)
+			udelay(10);
+		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+		if (rate < org_cpu_rate) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+		clk_set_rate(cpu_clk, rate);
+	} else {
+		podf = cpu_wp_tbl[wp].cpu_podf;
+		gp_volt = cpu_wp_tbl[wp].cpu_voltage;
+
+		/* Change arm_podf only */
+		/* set ARM_FREQ_SHIFT_DIVIDER */
+		reg = __raw_readl(dvfs_data->ccm_cdcr_reg_addr);
+		reg &= 0xFFFFFFFB;
+		reg |= 1 << 2;
+		__raw_writel(reg, dvfs_data->ccm_cdcr_reg_addr);
+
+		/* Get ARM_PODF */
+		reg = __raw_readl(dvfs_data->ccm_cacrr_reg_addr);
+		arm_podf = reg & 0x07;
+		if (podf == arm_podf) {
+			printk(KERN_DEBUG
+			       "No need to change freq and voltage!!!!\n");
+			return 0;
+		}
+
+		/* Check if FSVAI indicate freq up */
+		if (podf < arm_podf) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return 0;
+			}
+			udelay(dvfs_data->delay_time);
+			vinc = 1;
+		} else {
+			vinc = 0;
+		}
+
+		arm_podf = podf;
+		/* Set ARM_PODF */
+		reg &= 0xFFFFFFF8;
+		reg |= arm_podf;
+
+		reg1 = __raw_readl(dvfs_data->ccm_cdhipr_reg_addr);
+		if ((reg1 & 0x00010000) == 0)
+			__raw_writel(reg, dvfs_data->ccm_cacrr_reg_addr);
+		else {
+			printk(KERN_DEBUG "ARM_PODF still in busy!!!!\n");
+			return 0;
+		}
+
+		/* START the GPC main control FSM */
+		reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+		reg |= MXC_GPCCNTR_FUPD;
+		/* ADU=1, select ARM domain */
+		reg |= MXC_GPCCNTR_ADU;
+		__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+		/* set VINC */
+		reg = __raw_readl(dvfs_data->gpc_vcr_reg_addr);
+		reg &=
+		    ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+		    (100 << MXC_GPCVCR_VCNT_OFFSET) |
+		    (vinc << MXC_GPCVCR_VINC_OFFSET);
+		__raw_writel(reg, dvfs_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+		reg &= (~(MXC_GPCCNTR_ADU | MXC_GPCCNTR_FUPD));
+		reg |= MXC_GPCCNTR_ADU | MXC_GPCCNTR_FUPD | MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+
+		/* Wait for arm podf Enable */
+		while ((__raw_readl(dvfs_data->gpc_cntr_reg_addr) &
+			MXC_GPCCNTR_STRT) == MXC_GPCCNTR_STRT) {
+			printk(KERN_DEBUG "Waiting arm_podf enabled!\n");
+			udelay(10);
+		}
+
+		if (vinc == 0) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+
+	}
+#if defined(CONFIG_CPU_FREQ)
+		cpufreq_trig_needed = 1;
+#endif
+	old_wp = wp;
+
+	return ret;
+}
+
+static int start_dvfs(void)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (dvfs_core_is_active)
+		return 0;
+
+	spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+
+	clk_enable(dvfs_clk);
+
+	dvfs_load_config(0);
+
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	/* GPCIRQ=1, select ARM IRQ */
+	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
+	/* ADU=1, select ARM domain */
+	reg |= MXC_GPCCNTR_ADU;
+	__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+
+	/* Set PREDIV bits */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = (reg & ~(dvfs_data->prediv_mask));
+	reg |= (dvfs_data->prediv_val) << (dvfs_data->prediv_offset);
+	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+	/* Enable DVFS interrupt */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	/* FSVAIM=0 */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	/* Set MAXF, MINF */
+	reg = (reg & ~(MXC_DVFSCNTR_MAXF_MASK | MXC_DVFSCNTR_MINF_MASK));
+	reg |= 1 << MXC_DVFSCNTR_MAXF_OFFSET;
+	/* Select ARM domain */
+	reg |= MXC_DVFSCNTR_DVFIS;
+	/* Enable DVFS frequency adjustment interrupt */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	/* Set load tracking buffer register source */
+	reg = (reg & ~MXC_DVFSCNTR_LTBRSR_MASK);
+	reg |= DVFS_LTBRSR;
+	/* Set DIV3CK */
+	reg = (reg & ~(dvfs_data->div3ck_mask));
+	reg |= (dvfs_data->div3ck_val) << (dvfs_data->div3ck_offset);
+	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+	/* Enable DVFS */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg |= MXC_DVFSCNTR_DVFEN;
+	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+	dvfs_core_is_active = 1;
+
+	spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+	printk(KERN_DEBUG "DVFS is started\n");
+
+	return 0;
+}
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_controller(void)
+{
+	/* DVFS loading config */
+	dvfs_load_config(0);
+
+	return 0;
+}
+
+static irqreturn_t dvfs_irq(int irq, void *dev_id)
+{
+	u32 reg;
+
+	/* Check if DVFS0 (ARM) id requesting for freqency/voltage update */
+	if ((__raw_readl(dvfs_data->gpc_cntr_reg_addr) & MXC_GPCCNTR_DVFS0CR) ==
+	    0)
+		return IRQ_NONE;
+
+	/* Mask DVFS irq */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	/* FSVAIM=1 */
+	reg |= MXC_DVFSCNTR_FSVAIM;
+	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+	/* Mask GPC1 irq */
+	reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+	reg |= MXC_GPCCNTR_GPCIRQM | 0x1000000;
+	__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+
+	schedule_delayed_work(&dvfs_core_handler, 0);
+	return IRQ_HANDLED;
+}
+
+static void dvfs_core_work_handler(struct work_struct *work)
+{
+	u32 fsvai;
+	u32 reg;
+	u32 curr_cpu;
+	int ret = 0;
+	int maxf = 0, minf = 0;
+	int low_freq_bus_ready = 0;
+	int bus_incr = 0, cpu_dcr = 0;
+
+	low_freq_bus_ready = low_freq_bus_used();
+
+	/* Check DVFS frequency adjustment interrupt status */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	fsvai = (reg & MXC_DVFSCNTR_FSVAI_MASK) >> MXC_DVFSCNTR_FSVAI_OFFSET;
+	/* Check FSVAI, FSVAI=0 is error */
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		goto END;
+	}
+	curr_cpu = clk_get_rate(cpu_clk);
+
+	/* If FSVAI indicate freq down,
+	   check arm-clk is not in lowest frequency 200 MHz */
+	if (fsvai == FSVAI_FREQ_DECREASE) {
+		if (curr_cpu == cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate) {
+			minf = 1;
+			if (low_bus_freq_mode)
+				goto END;
+		} else {
+			/* freq down */
+			curr_wp++;
+			if (curr_wp >= cpu_wp_nr) {
+				curr_wp = cpu_wp_nr - 1;
+				goto END;
+			}
+
+			if (curr_wp == cpu_wp_nr - 1 && !low_freq_bus_ready) {
+				minf = 1;
+				dvfs_load_config(1);
+			} else {
+				cpu_dcr = 1;
+			}
+		}
+	} else {
+		if (curr_cpu == cpu_wp_tbl[0].cpu_rate) {
+			maxf = 1;
+			goto END;
+		} else {
+			if (low_bus_freq_mode) {
+				/* bump up LP freq first. */
+				bus_incr = 1;
+				dvfs_load_config(2);
+			} else {
+				/* freq up */
+				curr_wp = 0;
+				maxf = 1;
+				dvfs_load_config(0);
+			}
+		}
+	}
+
+	low_freq_bus_ready = low_freq_bus_used();
+	if ((curr_wp == cpu_wp_nr - 1) && (!low_bus_freq_mode)
+	    && (low_freq_bus_ready) && !bus_incr) {
+		if (cpu_dcr)
+			ret = set_cpu_freq(curr_wp);
+		if (!cpu_dcr) {
+			set_low_bus_freq();
+			dvfs_load_config(3);
+		} else {
+			dvfs_load_config(2);
+			cpu_dcr = 0;
+		}
+	} else {
+		if (low_bus_freq_mode)
+			set_high_bus_freq(0);
+
+		if (!bus_incr)
+			ret = set_cpu_freq(curr_wp);
+		bus_incr = 0;
+	}
+
+
+END:	/* Set MAXF, MINF */
+	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = (reg & ~(MXC_DVFSCNTR_MAXF_MASK | MXC_DVFSCNTR_MINF_MASK));
+	reg |= maxf << MXC_DVFSCNTR_MAXF_OFFSET;
+	reg |= minf << MXC_DVFSCNTR_MINF_OFFSET;
+
+	/* Enable DVFS interrupt */
+	/* FSVAIM=0 */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	reg |= FSVAI_FREQ_NOCHANGE;
+	/* LBFL=1 */
+	reg = (reg & ~MXC_DVFSCNTR_LBFL);
+	reg |= MXC_DVFSCNTR_LBFL;
+	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	/*Unmask GPC1 IRQ */
+	reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
+
+#if defined(CONFIG_CPU_FREQ)
+	if (cpufreq_trig_needed == 1) {
+		cpufreq_trig_needed = 0;
+		cpufreq_update_policy(0);
+	}
+#endif
+}
+
+
+/*!
+ * This function disables the DVFS module.
+ */
+static void stop_dvfs(void)
+{
+	u32 reg = 0;
+	unsigned long flags;
+	u32 curr_cpu;
+
+	if (dvfs_core_is_active) {
+
+		/* Mask dvfs irq, disable DVFS */
+		reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+		/* FSVAIM=1 */
+		reg |= MXC_DVFSCNTR_FSVAIM;
+		__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+		curr_wp = 0;
+		if (!high_bus_freq_mode)
+			set_high_bus_freq(1);
+
+		curr_cpu = clk_get_rate(cpu_clk);
+		if (curr_cpu != cpu_wp_tbl[curr_wp].cpu_rate) {
+			set_cpu_freq(curr_wp);
+#if defined(CONFIG_CPU_FREQ)
+			if (cpufreq_trig_needed == 1) {
+				cpufreq_trig_needed = 0;
+				cpufreq_update_policy(0);
+			}
+#endif
+		}
+		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+
+		reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+		reg = (reg & ~MXC_DVFSCNTR_DVFEN);
+		__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+
+		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+		dvfs_core_is_active = 0;
+
+		clk_disable(dvfs_clk);
+	}
+
+	printk(KERN_DEBUG "DVFS is stopped\n");
+}
+
+void dump_dvfs_core_regs()
+{
+	struct timeval cur;
+	u32 diff = 0;
+	if (core_prev_intr.tv_sec == 0)
+		do_gettimeofday(&core_prev_intr);
+	else {
+		do_gettimeofday(&cur);
+		diff = (cur.tv_sec - core_prev_intr.tv_sec)*1000000
+			 + (cur.tv_usec - core_prev_intr.tv_usec);
+		core_prev_intr = cur;
+	}
+	if (diff < 90000)
+		printk(KERN_DEBUG "diff = %d\n", diff);
+
+	printk(KERN_INFO "THRS = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr));
+	printk(KERN_INFO "COUNT = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x04));
+	printk(KERN_INFO "SIG1 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x08));
+	printk(KERN_INFO "SIG0 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x0c));
+	printk(KERN_INFO "GPC0 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x10));
+	printk(KERN_INFO "GPC1 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x14));
+	printk(KERN_INFO "GPBT = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x18));
+	printk(KERN_INFO "EMAC = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x1c));
+	printk(KERN_INFO "CNTR = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x20));
+	printk(KERN_INFO "LTR0_0 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x24));
+	printk(KERN_INFO "LTR0_1 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x28));
+	printk(KERN_INFO "LTR1_0 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x2c));
+	printk(KERN_DEBUG "LTR1_1 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x30));
+	printk(KERN_INFO "PT0 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x34));
+	printk(KERN_INFO "PT1 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x38));
+	printk(KERN_INFO "PT2 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x3c));
+	printk(KERN_INFO "PT3 = 0x%08x\n",
+			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x40));
+}
+
+static ssize_t downthreshold_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downthr);
+}
+
+static ssize_t downthreshold_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int ret = 0;
+	int val;
+	ret = sscanf(buf, "%u", &val);
+	dvfs_core_setpoint[0].downthr = val;
+
+	return size;
+}
+
+static ssize_t downcount_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downcnt);
+}
+
+static ssize_t downcount_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int ret = 0;
+	int val;
+	ret = sscanf(buf, "%u", &val);
+	dvfs_core_setpoint[0].downcnt = val;
+
+	return size;
+}
+
+
+static ssize_t dvfs_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (dvfs_core_is_active)
+		return sprintf(buf, "DVFS is enabled\n");
+	else
+		return sprintf(buf, "DVFS is disabled\n");
+}
+
+static ssize_t dvfs_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		if (start_dvfs() != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL)
+		stop_dvfs();
+
+	return size;
+}
+
+static ssize_t dvfs_regs_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (dvfs_core_is_active)
+		dump_dvfs_core_regs();
+	return 0;
+}
+
+static ssize_t dvfs_regs_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (dvfs_core_is_active)
+		dump_dvfs_core_regs();
+	return 0;
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, dvfs_enable_show, dvfs_enable_store);
+static DEVICE_ATTR(show_regs, 0644, dvfs_regs_show, dvfs_regs_store);
+
+static DEVICE_ATTR(down_threshold, 0644, downthreshold_show,
+						downthreshold_store);
+static DEVICE_ATTR(down_count, 0644, downcount_show, downcount_store);
+
+/*!
+ * This is the probe routine for the DVFS driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ */
+static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct resource *res;
+	int irq;
+
+	printk(KERN_INFO "mxc_dvfs_core_probe\n");
+	dvfs_dev = &pdev->dev;
+	dvfs_data = pdev->dev.platform_data;
+
+	INIT_DELAYED_WORK(&dvfs_core_handler, dvfs_core_work_handler);
+
+	pll1_sw_clk = clk_get(NULL, "pll1_sw_clk");
+	if (IS_ERR(pll1_sw_clk)) {
+		printk(KERN_INFO "%s: failed to get pll1_sw_clk\n", __func__);
+		return PTR_ERR(pll1_sw_clk);
+	}
+
+	cpu_clk = clk_get(NULL, dvfs_data->clk1_id);
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_ERR "%s: failed to get cpu clock\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	dvfs_clk = clk_get(NULL, dvfs_data->clk2_id);
+	if (IS_ERR(dvfs_clk)) {
+		printk(KERN_ERR "%s: failed to get dvfs clock\n", __func__);
+		return PTR_ERR(dvfs_clk);
+	}
+
+	core_regulator = regulator_get(NULL, dvfs_data->reg_id);
+	if (IS_ERR(core_regulator)) {
+		clk_put(cpu_clk);
+		clk_put(dvfs_clk);
+		printk(KERN_ERR "%s: failed to get gp regulator\n", __func__);
+		return PTR_ERR(core_regulator);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENODEV;
+		goto err1;
+	}
+
+	/*
+	 * Request the DVFS interrupt
+	 */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		err = irq;
+		goto err1;
+	}
+
+	/* request the DVFS interrupt */
+	err = request_irq(irq, dvfs_irq, IRQF_SHARED, "dvfs", dvfs_dev);
+	if (err)
+		printk(KERN_ERR
+		       "DVFS: Unable to attach to DVFS interrupt,err = %d",
+		       err);
+
+	clk_enable(dvfs_clk);
+	err = init_dvfs_controller();
+	if (err) {
+		printk(KERN_ERR "DVFS: Unable to initialize DVFS");
+		return err;
+	}
+	clk_disable(dvfs_clk);
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		return err;
+	}
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_show_regs.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		return err;
+	}
+
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_down_threshold.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		return err;
+	}
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_down_count.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		return err;
+	}
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	old_wp = 0;
+	curr_wp = 0;
+	dvfs_core_resume = 0;
+	cpufreq_trig_needed = 0;
+
+	return err;
+
+err1:
+	dev_err(&pdev->dev, "Failed to probe DVFS CORE\n");
+	return err;
+}
+
+/*!
+ * This function is called to put DVFS in a low power state.
+ *
+ * @param   pdev  the device structure
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_core_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	if (dvfs_core_is_active) {
+		dvfs_core_resume = 1;
+		stop_dvfs();
+	}
+
+	return 0;
+}
+
+/*!
+ * This function is called to resume the MU from a low power state.
+ *
+ * @param   dev   the device structure
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_core_resume(struct platform_device *pdev)
+{
+	if (dvfs_core_resume) {
+		dvfs_core_resume = 0;
+		start_dvfs();
+	}
+
+	return 0;
+}
+
+static struct platform_driver mxc_dvfs_core_driver = {
+	.driver = {
+		   .name = "mxc_dvfs_core",
+		   },
+	.probe = mxc_dvfs_core_probe,
+	.suspend = mxc_dvfs_core_suspend,
+	.resume = mxc_dvfs_core_resume,
+};
+
+static int __init dvfs_init(void)
+{
+	if (platform_driver_register(&mxc_dvfs_core_driver) != 0) {
+		printk(KERN_ERR "mxc_dvfs_core_driver register failed\n");
+		return -ENODEV;
+	}
+
+	dvfs_core_is_active = 0;
+	printk(KERN_INFO "DVFS driver module loaded\n");
+	return 0;
+}
+
+static void __exit dvfs_cleanup(void)
+{
+	stop_dvfs();
+
+	/* release the DVFS interrupt */
+	free_irq(MXC_INT_GPC1, NULL);
+
+	sysfs_remove_file(&dvfs_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxc_dvfs_core_driver);
+
+	clk_put(cpu_clk);
+	clk_put(dvfs_clk);
+
+	dvfs_core_is_active = 0;
+	printk(KERN_INFO "DVFS driver module unloaded\n");
+
+}
+
+module_init(dvfs_init);
+module_exit(dvfs_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/dvfs_per.c b/arch/arm/plat-mxc/dvfs_per.c
new file mode 100644
index 0000000..3ef24a1
--- /dev/null
+++ b/arch/arm/plat-mxc/dvfs_per.c
@@ -0,0 +1,894 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_per.c
+ *
+ * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and
+ * changes the CPU voltage according to translation table that is loaded into
+ * the driver.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+#include <mach/clock.h>
+#if defined(CONFIG_ARCH_MX37)
+#include <mach/mxc_dptc.h>
+#endif
+
+#define DRIVER_NAME "DVFSPER"
+#define DVFS_PER_DEBUG 0
+
+static int dvfs_per_stop;
+static int dvfs_per_low_freq;
+static int dvfs_per_suspended;
+static volatile int freq_increased;
+static int cur_setpoint;
+static struct delayed_work dvfs_per_work;
+static struct clk *dvfs_clk;
+static struct clk *main_bus_clk;
+static struct clk *pll2;
+static struct clk *lpapm;
+static struct clk *cpu_clk;
+static struct clk *axi_b_clk;
+static struct clk *ahb_clk;
+static struct clk *ddr_hf_clk;
+static struct regulator *lp_regulator;
+
+/* Flag used to indicate if dvfs_per is active. */
+static int dvfs_per_is_active;
+static int dvfs_per_is_paused;
+static int ipu_freq_scaled;
+
+struct dvfsper_device *dvfsper_device_data;
+/* DVFS platform data pointer */
+struct mxc_dvfsper_data *dvfsper_plt_data;
+struct timeval prev_intr;
+
+/*!
+ * In case the MXC device has multiple DVFS modules, this structure is used to
+ * store information specific to each DVFS module.
+ */
+struct dvfsper_device {
+	/* DVFS delayed work */
+	struct delayed_work dvfs_work;
+	/* DVFS regulator */
+	struct regulator *dvfs_reg;
+	/* DVFS clock */
+	struct clk *dvfs_clk;
+	/* The interrupt number used by the DVFS device */
+	int irq;
+};
+struct dvfs_wp dvfs_per_setpoint[] = {{33, 7, 33, 20, 40, 0x10},
+				{18, 0, 33, 25, 10, 0x10},
+				/* When LP is at 24MHz */
+				{8, 0, 10, 5, 5, 0x2E},};
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+#define LOW_BUS_FREQ 24000000
+
+DEFINE_SPINLOCK(mxc_dvfs_per_lock);
+
+static void dvfs_per_load_config(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_DVFS_PER_LTR0);
+	reg &= ~MXC_DVFSLTR0_UPTHR_MASK;
+	reg &= ~MXC_DVFSLTR0_DNTHR_MASK;
+	reg |= dvfs_per_setpoint[cur_setpoint].upthr <<
+						MXC_DVFSLTR0_UPTHR_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].downthr <<
+						MXC_DVFSLTR0_DNTHR_OFFSET;
+	__raw_writel(reg, MXC_DVFS_PER_LTR0);
+
+	reg = __raw_readl(MXC_DVFS_PER_LTR1);
+	reg &= ~MXC_DVFSLTR1_PNCTHR_MASK;
+	reg &= ~MXC_DVFSLTR1_DNCNT_MASK;
+	reg &= ~MXC_DVFSLTR1_UPCNT_MASK;
+	reg |= dvfs_per_setpoint[cur_setpoint].downcnt <<
+				MXC_DVFSLTR1_DNCNT_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].upcnt <<
+				MXC_DVFSLTR1_UPCNT_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].panicthr <<
+				MXC_DVFSLTR1_PNCTHR_OFFSET;
+	__raw_writel(reg, MXC_DVFS_PER_LTR1);
+
+	reg = dvfs_per_setpoint[cur_setpoint].emac <<
+				MXC_DVFSLTR2_EMAC_OFFSET;
+	__raw_writel(reg, MXC_DVFS_PER_LTR2);
+}
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_per_controller(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_DVFS_PER_LTR0);
+	/* DIV3CLK */
+	reg &= ~dvfsper_plt_data->div3_mask;
+	reg |= (dvfsper_plt_data->div3_div <<
+		  dvfsper_plt_data->div3_offset);
+	__raw_writel(reg, MXC_DVFS_PER_LTR0);
+
+	reg = __raw_readl(MXC_DVFS_PER_LTR1);
+	/* Set load tracking buffer register source */
+	reg &= ~MXC_DVFSLTR1_LTBRSR;
+	reg |= MXC_DVFSLTR1_LTBRSR;
+	reg &= ~MXC_DVFSLTR1_LTBRSH;
+	__raw_writel(reg, MXC_DVFS_PER_LTR1);
+
+	/* Enable all the peripheral signals, but VPU and IPU panic*/
+	__raw_writel(0x30000, MXC_DVFS_PER_PMCR1);
+	/* Disable weighted load tracking signals */
+	__raw_writel(0, MXC_DVFS_PER_LTR3);
+
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg &= ~MXC_DVFSPMCR0_DVFEV;
+	reg |= MXC_DVFSPMCR0_LBMI;
+	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+	/* DVFS loading config */
+	dvfs_per_load_config();
+	return 0;
+}
+
+#if DVFS_PER_DEBUG
+static void dump_dvfs_per_regs(void)
+{
+	struct timeval cur;
+	u32 diff = 0;
+	if (prev_intr.tv_sec == 0)
+		do_gettimeofday(&prev_intr);
+	else {
+		do_gettimeofday(&cur);
+		diff = (cur.tv_sec - prev_intr.tv_sec)*1000000
+			 + (cur.tv_usec - prev_intr.tv_usec);
+		prev_intr = cur;
+	}
+	if (diff < 90000)
+		printk(KERN_INFO "diff = %d\n", diff);
+
+	printk(KERN_INFO "LTRO = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR0));
+	printk(KERN_INFO "LTR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR1));
+	printk(KERN_INFO "LTR2 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR2));
+	printk(KERN_INFO "LTR3 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR3));
+	printk(KERN_INFO "LBTR0 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTBR0));
+	printk(KERN_INFO "LBTR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTBR1));
+	printk(KERN_INFO "PMCR0 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_PMCR0));
+	printk(KERN_INFO "PMCR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_PMCR1));
+}
+#endif
+
+static irqreturn_t dvfs_per_irq(int irq, void *dev_id)
+{
+	u32 reg;
+
+	/* Check if DVFS1 (PER) id requesting for freqency/voltage update */
+	if ((__raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr) &
+						MXC_GPCCNTR_DVFS1CR) == 0)
+		return IRQ_NONE;
+	/* Mask DVFS irq */
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	/* FSVAIM=1 */
+	reg |= MXC_DVFSPMCR0_FSVAIM;
+	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	/* Mask GPC1 irq */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg |= MXC_GPCCNTR_GPCIRQM | 0x1000000;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	if (reg & MXC_DVFSPMCR0_LBFL) {
+		/* clear LBFL */
+		reg = (reg & ~MXC_DVFSPMCR0_LBFL);
+		reg |= MXC_DVFSPMCR0_LBFL;
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	}
+	schedule_delayed_work(&dvfs_per_work, 0);
+	return IRQ_HANDLED;
+}
+
+static void dvfs_per_handler(struct work_struct *work)
+{
+	u32 fsvai;
+	u32 reg;
+	u32 ret;
+	unsigned long flags;
+	int retry = 20;
+
+	/* Check DVFS frequency adjustment interrupt status */
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	fsvai = (reg & MXC_DVFSPMCR0_FSVAI_MASK) >> MXC_DVFSPMCR0_FSVAI_OFFSET;
+	/* Check FSVAI, FSVAI=0 is error */
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		goto END;
+	}
+
+#if DVFS_PER_DEBUG
+	dump_dvfs_per_regs();
+#endif
+	/* If FSVAI indicate freq down. */
+	if (fsvai == FSVAI_FREQ_DECREASE) {
+		if (cpu_is_mx51()) {
+			/*Change the DDR freq to 133Mhz. */
+			clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, 133000000));
+		}
+
+#ifndef DVFS_SW_WORKAROUND
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg &= ~MXC_DVFSPMCR0_UDCS;
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+		/* Set the peripheral divider */
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+			(1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		retry = 10;
+		while ((__raw_readl(
+			dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+			&& retry > 0) {
+			udelay(10);
+			retry--;
+		}
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+#else
+		/*Set the frequencies manually */
+		rate = clk_get_rate(axi_b_clk);
+		clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, rate/2));
+
+		rate = clk_get_rate(ahb_clk);
+		clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, rate/2));
+#endif
+		dvfs_per_low_freq = 1;
+		if (clk_get_rate(main_bus_clk) == LOW_BUS_FREQ) {
+			cur_setpoint = 2;
+		} else {
+#if defined(CONFIG_ARCH_MX37)
+			dptc_suspend(DPTC_LP_ID);
+#endif
+			cur_setpoint = 1;
+#ifndef DVFS_SW_WORKAROUND
+			clk_set_parent(main_bus_clk, clk_get(NULL, "pll2"));
+#endif
+		}
+#ifndef DVFS_SW_WORKAROUND
+		/* Drop the LP domain voltage */
+		ret = regulator_set_voltage(lp_regulator,
+					dvfsper_plt_data->lp_low,
+					dvfsper_plt_data->lp_low);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+		dvfs_per_load_config();
+	} else if ((fsvai == FSVAI_FREQ_INCREASE) ||
+			(fsvai == FSVAI_FREQ_EMERG)) {
+#ifndef DVFS_SW_WORKAROUND
+		/* Increase the LP domain voltage first. */
+		ret = regulator_set_voltage(lp_regulator,
+					dvfsper_plt_data->lp_high,
+					dvfsper_plt_data->lp_high);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+
+#ifndef DVFS_SW_WORKAROUND
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg |= MXC_DVFSPMCR0_UDCS;
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VINC_OFFSET |
+			1 << MXC_GPCVCR_VCNTU_OFFSET |
+			1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~MXC_GPCCNTR_ADU;
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+		retry = 10;
+		while ((__raw_readl(
+				dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+				&& retry > 0) {
+			udelay(10);
+			retry--;
+		}
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+
+	if (retry < 0)
+		printk(KERN_ERR "****ERROR- DVFS\n");
+#else
+		/*Set the frequencies manually */
+		rate = clk_get_rate(axi_b_clk);
+		clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, 130000000));
+		rate = clk_get_rate(ahb_clk);
+		clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, 130000000));
+#endif
+		if (cpu_is_mx51()) {
+			/*Change the DDR freq to 200Mhz. */
+			clk_set_rate(ddr_hf_clk, clk_round_rate(ddr_hf_clk,
+						200000000));
+		}
+		dvfs_per_low_freq = 0;
+		if (clk_get_rate(main_bus_clk) == LOW_BUS_FREQ) {
+			cur_setpoint = 2;
+		} else {
+			cur_setpoint = 0;
+#if defined(CONFIG_ARCH_MX37)
+			dptc_resume(DPTC_LP_ID);
+#endif
+#ifndef DVFS_SW_WORKAROUND
+			clk_set_parent(main_bus_clk, clk_get(NULL, "pll2"));
+#endif
+		}
+		dvfs_per_load_config();
+		freq_increased = 1;
+	}
+
+END:
+#if DVFS_PER_DEBUG
+	dump_dvfs_per_regs(void)();
+#endif
+	if (dvfs_per_is_active) {
+		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		/* Enable dVFS interrupt */
+		/* FSVAIM=0 */
+		reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
+		reg |= FSVAI_FREQ_NOCHANGE;
+		reg = (reg & ~MXC_DVFSPMCR0_FSVAIM);
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		/*Unmask GPC1 IRQ */
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~MXC_GPCCNTR_GPCIRQM;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	}
+}
+
+static void force_freq_change(void)
+{
+	u32 reg;
+	int retry = 50;
+
+	freq_increased = 0;
+
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg |= MXC_DVFSPMCR0_UDCS;
+	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+	if (cpu_is_mx51()) {
+		/*Change the DDR freq to 133Mhz. */
+		clk_set_rate(ddr_hf_clk, clk_round_rate(ddr_hf_clk, 200000000));
+	}
+
+#ifndef DVFS_SW_WORKAROUND
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg |= MXC_GPCCNTR_FUPD;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+	reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+	      MXC_GPCVCR_VCNT_MASK);
+	reg |= (1 << MXC_GPCVCR_VINC_OFFSET |
+		1 << MXC_GPCVCR_VCNTU_OFFSET |
+		20 << MXC_GPCVCR_VCNT_OFFSET);
+	__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg &= ~MXC_GPCCNTR_ADU;
+	reg |= MXC_GPCCNTR_STRT;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	while ((__raw_readl(
+			dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+			&& retry > 0) {
+		udelay(30);
+		retry--;
+	}
+	freq_increased = 1;
+	if (retry <= 0)
+		printk(KERN_ERR "Cannot stop DVFS-PER\n");
+#else
+	/* Set the frequencies manually */
+	rate = clk_get_rate(axi_b_clk);
+	clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, 130000000));
+	rate = clk_get_rate(ahb_clk);
+	clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, 130000000));
+#endif
+	dvfs_per_low_freq = 0;
+
+#ifndef DVFS_SW_WORKAROUND
+	clk_set_parent(main_bus_clk, pll2);
+#endif
+}
+
+static int start(void)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (dvfs_per_is_active || dvfs_per_stop)
+		return 0;
+
+	if (low_bus_freq_mode)
+		return 0;
+
+	if (bus_freq_scaling_is_active) {
+		dvfs_per_is_paused = 1;
+		printk(KERN_INFO "Cannot start DVFS-PER since bus_freq_scaling is active\n");
+		return 0;
+	}
+
+	if (!dvfs_per_pixel_clk_limit()) {
+		dvfs_per_is_paused = 1;
+		printk(KERN_INFO "Cannot start DVFS-PER since pixel clock is\
+			above 60MHz or divider is not even\n");
+		return 0;
+	}
+
+	stop_sdram_autogating();
+
+	spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+
+	clk_enable(dvfs_clk);
+
+	cur_setpoint = 0;
+	init_dvfs_per_controller();
+
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	/* ADU=0, select PER domain */
+	reg &= ~MXC_GPCCNTR_ADU;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	/* Select ARM domain */
+	reg |= MXC_DVFSPMCR0_DVFIS;
+	/* Set the UDCS bit */
+	reg |= MXC_DVFSPMCR0_UDCS;
+	/* Enable DVFS interrupt */
+	/* FSVAIM=0 */
+	reg &= ~MXC_DVFSPMCR0_FSVAIM;
+	/*Set the FSVAI to no_freq_change */
+	reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
+	reg |= FSVAI_FREQ_NOCHANGE << MXC_DVFSPMCR0_FSVAI_OFFSET;
+	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	/* GPCIRQ=1, select ARM IRQ */
+	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	/* Enable DVFS */
+	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg |= MXC_DVFSPMCR0_DVFEN;
+	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+	dvfs_per_is_active = 1;
+	spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+
+	printk(KERN_DEBUG "DVFS PER is started\n");
+
+	return 0;
+}
+
+/*!
+ * This function disables the DVFS module.
+ */
+static void stop(void)
+{
+	u32 reg = 0;
+	unsigned long flags;
+	u32 ret = 0;
+
+	if (dvfs_per_is_active) {
+		dvfs_per_is_active = 0;
+#ifndef DVFS_SW_WORKAROUND
+		/* Increase the LP domain voltage first. */
+		ret = regulator_set_voltage(
+				lp_regulator, dvfsper_plt_data->lp_high,
+				dvfsper_plt_data->lp_high);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+
+		/* Mask dvfs irq, disable DVFS */
+		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		/* FSVAIM=1 */
+		reg |= MXC_DVFSPMCR0_FSVAIM;
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+		if (cur_setpoint != 0)
+			force_freq_change();
+
+		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = (reg & ~MXC_DVFSPMCR0_DVFEN);
+		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+		clk_disable(dvfs_clk);
+
+		start_sdram_autogating();
+	}
+}
+
+
+int dvfs_per_active()
+{
+	return dvfs_per_is_active;
+}
+
+int dvfs_per_divider_active()
+{
+	return dvfs_per_low_freq;
+}
+
+int dvfs_per_pixel_clk_limit()
+{
+	struct clk *disp0_pixel_clk;
+	struct clk *disp1_pixel_clk;
+	int disp0_rate = 0;
+	int disp1_rate = 0;
+	int div1 = 0;
+	int div2 = 0;
+	int even_div1 = 1;
+	int even_div2  = 1;
+
+	disp0_pixel_clk = clk_get(NULL, "pixel_clk.0");
+	disp1_pixel_clk = clk_get(NULL, "pixel_clk.1");
+
+	if (disp0_pixel_clk != NULL)
+		disp0_rate = clk_get_rate(disp0_pixel_clk);
+
+	if (disp1_pixel_clk != NULL)
+		disp1_rate = clk_get_rate(disp1_pixel_clk);
+
+	/* DVFS-PER will not work if pixel clock divider is odd */
+	if (disp0_rate != 0)
+		div1  = (clk_get_rate(
+			clk_get_parent(disp0_pixel_clk)) * 10) / disp0_rate;
+
+	if ((div1 % 2) || ((div1 / 10) % 2))
+		even_div1 = 0;
+
+	if ((div2 % 2) || ((div2 / 10) % 2))
+		even_div2 = 0;
+
+	if (disp1_rate != 0)
+		div2  = (clk_get_rate(
+			clk_get_parent(disp1_pixel_clk)) * 10) / disp1_rate;
+
+	if (((disp0_rate < DVFS_MAX_PIX_CLK && even_div1) ||
+		!clk_get_usecount(disp0_pixel_clk)) &&
+		((disp1_rate < DVFS_MAX_PIX_CLK && even_div2) ||
+		!clk_get_usecount(disp1_pixel_clk)))
+		ipu_freq_scaled = 1;
+	else
+		ipu_freq_scaled = 0;
+
+	clk_put(disp0_pixel_clk);
+	clk_put(disp1_pixel_clk);
+
+	return ipu_freq_scaled;
+}
+
+int start_dvfs_per(void)
+{
+	if (dvfs_per_is_paused) {
+		dvfs_per_is_paused = 0;
+		return start();
+	}
+	return 0;
+}
+
+void stop_dvfs_per(void)
+{
+	if (dvfs_per_is_active) {
+		dvfs_per_is_paused = 1;
+		stop();
+	}
+}
+
+/*!
+ * Enable DVFS Peripheral
+ *
+ */
+int dvfs_enable(struct device *dev)
+{
+	if (dvfs_per_is_active)
+		return 0;
+	return start();
+}
+
+static ssize_t dvfsper_enable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		dvfs_per_stop = 0;
+		if (dvfs_enable(dev) != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL) {
+		dvfs_per_stop = 1;
+		stop();
+	}
+	return size;
+}
+
+static ssize_t dvfsper_status_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int size = 0;
+
+	if (dvfs_per_is_active)
+		size = sprintf(buf, "DVFS PER is enabled\n");
+	else
+		size = sprintf(buf, "DVFS PEr is disabled\n");
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, dvfsper_status_show, dvfsper_enable_store);
+
+/*!
+ * This is the probe routine for the DVFS PER driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mxc_dvfsper_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	struct mxc_dvfsper_data *dvfsper_data = pdev->dev.platform_data;
+
+	if (dvfsper_data == NULL) {
+		printk(KERN_ERR "DVFS: Pointer to DVFS data is NULL\
+				not started\n");
+		return -1;
+	}
+
+	/* Set driver data */
+	platform_set_drvdata(pdev, dvfsper_device_data);
+
+	dvfsper_plt_data = pdev->dev.platform_data;
+	dvfsper_device_data = kzalloc(sizeof(struct dvfsper_device),
+								GFP_KERNEL);
+	if (!dvfsper_device_data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	/*
+	 * Request the DVFSPER interrupt
+	 */
+	dvfsper_device_data->irq = platform_get_irq(pdev, 0);
+	if (dvfsper_device_data->irq < 0) {
+		ret = dvfsper_device_data->irq;
+		goto err1;
+	}
+
+	ret =
+	    request_irq(dvfsper_device_data->irq, dvfs_per_irq, IRQF_SHARED,
+			pdev->name, &pdev->dev);
+	if (ret) {
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt\n");
+		goto err1;
+	}
+
+	lp_regulator = regulator_get(NULL, dvfsper_data->reg_id);
+	if (IS_ERR(lp_regulator)) {
+		printk(KERN_ERR "%s: failed to get lp regulator\n", __func__);
+		return PTR_ERR(lp_regulator);
+	}
+
+	INIT_DELAYED_WORK(&dvfs_per_work, dvfs_per_handler);
+
+	main_bus_clk = clk_get(NULL, "main_bus_clk");
+	pll2 = clk_get(NULL, "pll2");
+	lpapm = clk_get(NULL, "lp_apm");
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	axi_b_clk = clk_get(NULL, "axi_b_clk");
+
+	if (cpu_is_mx51())
+		ddr_hf_clk = clk_get(NULL, "ddr_hf_clk");
+
+	dvfsper_device_data->dvfs_clk = clk_get(NULL, dvfsper_data->clk_id);
+	dvfs_clk = dvfsper_device_data->dvfs_clk;
+
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_enable.attr);
+
+	if (ret) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for dvfs");
+		goto err1;
+	}
+
+	return 0;
+err1:
+	dev_err(&pdev->dev, "Failed to probe DVFS\n");
+	kfree(dvfsper_device_data);
+
+	return ret;
+}
+
+/*!
+ * This function is called to put DVFS in a low power state.
+ *
+ * @param   pdev  the device structure
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	if (dvfs_per_is_active) {
+		stop_dvfs_per();
+		dvfs_per_suspended = 1;
+	}
+	return 0;
+}
+
+/*!
+ * This function is called to resume the DVFS from a low power state.
+ *
+ * @param   dev   the device structure
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_resume(struct platform_device *pdev)
+{
+	if (dvfs_per_suspended) {
+		dvfs_per_suspended = 0;
+		return start_dvfs_per();
+	}
+
+	return 0;
+}
+
+static struct platform_driver mxc_dvfsper_driver = {
+	.driver = {
+		   .name = "mxc_dvfsper",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_dvfsper_probe,
+	.suspend = mxc_dvfs_suspend,
+	.resume = mxc_dvfs_resume,
+};
+
+static int __init dvfs_per_init(void)
+{
+	int err = 0;
+
+	if (platform_driver_register(&mxc_dvfsper_driver) != 0) {
+		printk(KERN_ERR "mxc_dvfsper_driver register failed\n");
+		return -ENODEV;
+	}
+	printk(KERN_INFO "DVFS PER driver module loaded\n");
+
+	return err;
+}
+
+static void __exit dvfs_per_cleanup(void)
+{
+	stop_dvfs_per();
+
+	/* release the DVFS interrupt */
+	free_irq(dvfsper_device_data->irq, NULL);
+
+	clk_put(dvfs_clk);
+	clk_put(main_bus_clk);
+	clk_put(pll2);
+	clk_put(lpapm);
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+	clk_put(axi_b_clk);
+	if (cpu_is_mx51())
+		clk_put(ddr_hf_clk);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxc_dvfsper_driver);
+}
+
+module_init(dvfs_per_init);
+module_exit(dvfs_per_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS PERIPHERAL  driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/entry-pm.S b/arch/arm/plat-mxc/entry-pm.S
new file mode 100644
index 0000000..4a3af0e
--- /dev/null
+++ b/arch/arm/plat-mxc/entry-pm.S
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file plat-mxc/entry-pm.S
+ *
+ * @brief This file contains common pm entry .
+ *
+ * @ingroup MXC_PM
+ */
+
+#include <asm/assembler.h>
+#include <asm/ptrace.h>
+#include <asm/memory.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+#include <asm/proc-fns.h>
+#include <asm/vfpmacros.h>
+
+#define WAIT_MODE               111
+#define DOZE_MODE               112
+#define STOP_MODE               113
+#define DSM_MODE                114
+
+#define PM_XLOAD_SIZE		0x04
+#define PM_XLOAD_ENTRY		0x08
+#define PM_XLOAD_SUSPEND_MODE	0x0C
+#define PM_XLOAD_CORE_SP	0x10
+
+#define PROCINFO_PROC_FNS	36
+#define PROC_FIN_FN		12
+#define PROC_IDLE_FN		20
+
+#ifdef CONFIG_FIQ
+#define ARM_CONTEXT_SIZE 12
+#else
+#define ARM_CONTEXT_SIZE 8
+#endif
+
+#ifdef CONFIG_PM_VERBOSE
+resume_str:
+	.string "Resume from DSM..."
+	.size resume_str, . - resume_str
+
+.macro show_resume_str
+	ldr r0, =resume_str
+	bl printk
+.endm
+
+#else
+.macro show_resume_str
+.endm
+#endif
+
+	.data
+	.align 3
+arm_core_context:
+	.rept ARM_CONTEXT_SIZE
+	.long 0
+	.endr
+
+#ifdef CONFIG_VFP
+	.text
+	.align 5
+arm_vfp_save:
+	mov ip, sp
+	stmdb sp!, {r0-r8, fp, ip, lr, pc}
+	sub fp, ip, #4
+	mov r1, #THREAD_SIZE
+	sub r1, r1, #1
+	bic r0, sp, r1
+	ldr r8, [r0, #TI_CPU]
+	add r4, r0, #TI_VFPSTATE
+
+	ldr r3, =last_VFP_context
+	VFPFMRX	r2, FPEXC
+	tst r2, #FPEXC_EN
+	bne 1f
+
+	ldr r4, [r3, r8, lsl #2]
+	cmp r4, #0
+	beq dead_vfp
+1:
+	bic r1, r2, #FPEXC_EN
+	VFPFMXR FPEXC, r1
+	/*TODO: SMP */
+	VFPFSTMIA r4, r1
+	VFPFMRX	r5, FPSCR
+	tst r2, #FPEXC_EX
+	VFPFMRX r6, FPINST, NE
+	tstne r2, #FPEXC_FP2V
+	VFPFMRX r7, FPINST2, NE
+	stmia r4, {r2, r5, r6, r7}
+
+	mov r1, #0
+	str r1, [r3, r8, lsl #2]
+dead_vfp:
+	ldmia sp, {r0-r8, fp, sp, pc}
+#endif
+/*
+ * The function just be called in this file
+ * Current r0 ~r4 are not saved.
+ * Otherwise, the working registers should be saved
+ */
+	.text
+	.align 5
+arm_core_save:
+	mov ip, sp
+	stmdb sp!, {r8, r9, sl, fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =arm_core_context
+	mov r3, r0
+	/* SVC mode */
+	mrs r1, spsr	@Save spsr
+	mrs r2, cpsr	@Save cpsr
+	stmia r0!, {r1, r2}
+	/* Abort mode */
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | ABT_MODE
+	stmia r0!, {sp}		@Save stack pointer for abort mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | UND_MODE
+	stmia r0!, {sp}		@Save stack pointer for undefine mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | IRQ_MODE
+	stmia r0!, {sp}		@Save stack pointer for irq mode
+#ifdef CONFIG_FIQ
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | FIQ_MODE
+	/*Save general register and sp for fiq mode*/
+	stmia r0!, {r8-r9, sl, fp, ip, sp}
+#endif
+	ldr r0, [r3, #4]
+	msr cpsr_c, r0
+	ldmia sp, {r8-r9, sl, fp, sp, pc}
+
+/*
+ * The function just be called in this file
+ * Current r0 ~r4 are not saved.
+ * Otherwise, the working registers should be saved
+ */
+arm_core_restore:
+	mov ip, sp
+	stmdb sp!, {fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =arm_core_context
+	mov r3, r0
+	/* SVC mode */
+	add r0, r0, #8		@skip svc mode
+	/* Abort mode */
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | ABT_MODE
+	ldmia r0!, {sp}		@restore stack pointer for abort mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | UND_MODE
+	ldmia r0!, {sp}		@restore stack pointer for undefine mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | IRQ_MODE
+	ldmia r0!, {sp}		@restore stack pointer for irq mode
+#ifdef CONFIG_FIQ
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | FIQ_MODE
+	/*Save general register and sp for fiq mode*/
+	ldmia r0!, {r8-r9, sl, fp, ip, sp}
+#endif
+	ldmia r3!, {r1, r2}
+	msr cpsr, r2		@restore cpsr
+	msr spsr, r1		@restore spsr
+	ldmia sp, {fp, sp, pc}
+
+mxc_cp15_context:
+	.rept 16
+	.long 0
+	.endr
+
+	.align 5
+mxc_cp15_restore:
+	/* Physical address */
+	adr r0, mxc_cp15_context
+	ldmia r0, {r1-r9}
+#ifndef CONFIG_PM_DEBUG
+	@Add dynamic check to skip this block when debug
+	sub lr, lr, #PHYS_OFFSET
+	add lr, lr, #PAGE_OFFSET
+#endif
+	mcr p15, 0, r3, c1, c0, 2	@CP Access Register
+	mcr p15, 0, r2, c1, c0, 1	@Aux Control register
+
+#ifndef CONFIG_PM_DEBUG
+	mcr p15, 0, r0, c7, c5, 6	@flush BTAC/BTB
+	mcr p15, 0, r0, c7, c7, 0	@invalidate both caches
+	mcr p15, 0, r0, c8, c7, 0	@Inval TLBs
+#endif
+
+	mcr p15, 0, r4, c13, c0, 0	@PID
+	mcr p15, 0, r5, c13, c0, 1	@Context ID
+
+	mcr p15, 0, r6, c3, c0, 0	@Domain Access Register
+	mcr p15, 0, r7, c2, c0, 0	@TTB0
+	mcr p15, 0, r8, c2, c0, 1	@TTB1
+	mcr p15, 0, r9, c2, c0, 2	@TTBC
+
+	mcr p15, 0, r1, c1, c0, 0	@Control Register
+	/* mcu enabled */
+	mrc p15, 0, r0, c2, c0, 0
+
+	mov pc, lr
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+mxc_cp15_save:
+	mov ip, sp
+	stmdb sp!, {r8-r9, fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =mxc_cp15_context
+/* System Control Registers */
+	mrc p15, 0, r1, c1, c0, 0	@Control Register
+	mrc p15, 0, r2, c1, c0, 1	@Aux Control Register
+	mrc p15, 0, r3, c1, c0, 2	@CP access Register
+
+/* Memory management Registers */
+	mrc p15, 0, r4, c13, c0, 0	@PID
+	mrc p15, 0, r5, c13, c0, 1	@Context ID
+
+	mrc p15, 0, r6, c3, c0, 0	@Domain Access Register
+
+	mrc p15, 0, r7, c2, c0, 0	@TTB0
+	mrc p15, 0, r8, c2, c0, 1	@TTB1
+	mrc p15, 0, r9, c2, c0, 2	@TTBC
+	stmia r0, {r1-r9}
+	ldmia sp, {r8, r9, fp, sp, pc}
+
+/*
+ * int __mxc_pm_arch_entry(u32 entry, u32 size)
+ */
+	.align 5
+	.globl mxc_pm_arch_entry
+mxc_pm_arch_entry:
+	mov ip, sp
+	stmdb sp!, {r4-r9, sl, fp, ip, lr, pc}
+	sub fp, ip, #4
+	sub sp, sp, #4
+	mov r8, r0	@save entry
+	mov r9, r1	@save entry size
+#ifdef CONFIG_VFP
+	bl arm_vfp_save
+#endif
+	/* r0 ~r3, ip is dirty*/
+	bl arm_core_save	@save arm context
+	bl mxc_cp15_save
+	mov r0, sp
+	mov r1, r8	@restore entry
+	mov r2, r9	@restore entry size
+	bl __mxc_pm_xload_setup
+1:	bl cpu_v6_proc_fin
+	bl cpu_v6_do_idle
+	nop
+	nop
+	nop
+	nop
+__mxc_pm_arch_leave:
+	adr r0, __mxc_pm_xload_info
+	ldr sp, [r0, #PM_XLOAD_CORE_SP]
+
+#ifndef CONFIG_PM_DEBUG
+	sub sp, sp, #PAGE_OFFSET
+	add sp, sp, #PHYS_OFFSET
+#endif
+	bl mxc_cp15_restore
+#ifndef CONFIG_PM_DEBUG
+	sub sp, sp, #PHYS_OFFSET
+	add sp, sp, #PAGE_OFFSET
+#endif
+	show_resume_str
+	bl arm_core_restore
+	ldmib sp, {r4-r9, sl, fp, sp, pc}
+
+__mxc_pm_xload_info:
+	adr pc, __mxc_pm_xload_entry		@Jump instruction
+	.long	__mxc_pm_xload_end - __mxc_pm_xload_info	@loader size
+	.long 	(__mxc_pm_arch_leave - PAGE_OFFSET + PHYS_OFFSET) @resume entry
+	.long   0 		@suspend state
+	.long   0		@Core Stack pointer
+__mxc_pm_xload_entry:
+	adr r0, __mxc_pm_xload_info
+	ldr pc, [r0, #PM_XLOAD_ENTRY]
+__mxc_pm_xload_end:
+
+/*
+ * __mxc_pm_xload_setup(u32 sp, u32 entry, u32 size)
+ * r0~r6 is dirty
+ */
+__mxc_pm_xload_setup:
+	ldr r3, =__mxc_pm_xload_info
+	str r0, [r3, #PM_XLOAD_CORE_SP]
+	ldr r4, [r3, #PM_XLOAD_SIZE]
+	cmp r2, r4
+	blo 2f
+1:	ldr r5, [r3], #4
+	str r5, [r1], #4
+	subs r4, r4, #4
+	bhi 1b
+	b 3f
+2:	str r3, [r1]
+3:	mov pc, lr
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
index 70b2389..ea5295e 100644
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -171,6 +171,26 @@ static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)
 	}
 }
 
+/* one interrupt *per* gpio port */
+static void mx5_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 irq_stat;
+	u32 mask = 0xFFFFFFFF;
+	struct mxc_gpio_port *port = (struct mxc_gpio_port *)get_irq_data(irq);
+
+#ifdef MXC_GPIO_SPLIT_IRQ_2
+	if (irq == port->irq)
+		mask = 0x0000FFFF;
+	else
+		mask = 0xFFFF0000;
+#endif
+
+	irq_stat = __raw_readl(port->base + GPIO_ISR) &
+			(__raw_readl(port->base + GPIO_IMR) & mask);
+	mxc_gpio_irq_handler(port, irq_stat);
+}
+
+
 /* MX1 and MX3 has one interrupt *per* gpio port */
 static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)
 {
@@ -294,6 +314,18 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 			set_irq_chained_handler(port[i].irq, mx3_gpio_irq_handler);
 			set_irq_data(port[i].irq, &port[i]);
 		}
+
+		if (cpu_is_mx51()) {
+			set_irq_chained_handler(port[i].irq,
+						mx5_gpio_irq_handler);
+			set_irq_data(port[i].irq, &port[i]);
+			if (port[i].irq_high) {
+				set_irq_chained_handler(port[i].irq_high,
+							mx5_gpio_irq_handler);
+				set_irq_data(port[i].irq_high, &port[i]);
+			}
+
+		}
 	}
 
 	if (cpu_is_mx2()) {
diff --git a/arch/arm/plat-mxc/irq.c b/arch/arm/plat-mxc/irq.c
index 778ddfe..1764d1d 100644
--- a/arch/arm/plat-mxc/irq.c
+++ b/arch/arm/plat-mxc/irq.c
@@ -19,7 +19,9 @@
 
 #include <linux/module.h>
 #include <linux/irq.h>
+#include <linux/pm.h>
 #include <linux/io.h>
+#include <linux/sysdev.h>
 #include <mach/common.h>
 #include <asm/mach/irq.h>
 #include <mach/hardware.h>
@@ -46,6 +48,11 @@
 
 void __iomem *avic_base;
 
+#define IRQ_BIT(irq)  (1 << (irq))
+
+static uint32_t saved_wakeup_low, saved_wakeup_high;
+static uint32_t suspend_wakeup_low, suspend_wakeup_high;
+
 int imx_irq_set_priority(unsigned char irq, unsigned char prio)
 {
 #ifdef CONFIG_MXC_IRQ_PRIOR
@@ -102,12 +109,111 @@ static void mxc_unmask_irq(unsigned int irq)
 	__raw_writel(irq, avic_base + AVIC_INTENNUM);
 }
 
+static int mxc_set_wake_irq(unsigned int irq, unsigned int enable)
+{
+	uint32_t *wakeup_intr;
+	uint32_t irq_bit;
+
+	if (irq < 32) {
+		wakeup_intr = &suspend_wakeup_low;
+		irq_bit = IRQ_BIT(irq);
+	} else {
+		wakeup_intr = &suspend_wakeup_high;
+		irq_bit = IRQ_BIT(irq - 32);
+	}
+
+	if (enable)
+		*wakeup_intr |= irq_bit;
+	else
+		*wakeup_intr &= ~irq_bit;
+
+	return 0;
+}
+
 static struct irq_chip mxc_avic_chip = {
 	.ack = mxc_mask_irq,
 	.mask = mxc_mask_irq,
 	.unmask = mxc_unmask_irq,
+	.set_wake = mxc_set_wake_irq,
 };
 
+#ifdef CONFIG_PM
+/*!
+ * This function puts the AVIC in low-power mode/state.
+ * All the interrupts that are enabled are first saved.
+ * Only those interrupts which registers as a wake source by calling
+ * enable_irq_wake are enabled. All other interrupts are disabled.
+ *
+ * @param   dev  the system device structure used to give information
+ *                on AVIC to suspend
+ * @param   mesg the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_avic_suspend(struct sys_device *dev, pm_message_t mesg)
+{
+	saved_wakeup_high = __raw_readl(avic_base + AVIC_INTENABLEH);
+	saved_wakeup_low = __raw_readl(avic_base + AVIC_INTENABLEL);
+
+	__raw_writel(suspend_wakeup_high, avic_base + AVIC_INTENABLEH);
+	__raw_writel(suspend_wakeup_low, avic_base + AVIC_INTENABLEL);
+
+	return 0;
+}
+
+/*!
+ * This function brings the AVIC back from low-power state.
+ * All the interrupts enabled before suspension are re-enabled from
+ * the saved information.
+ *
+ * @param   dev  the system device structure used to give information
+ *                on AVIC to resume
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_avic_resume(struct sys_device *dev)
+{
+	__raw_writel(saved_wakeup_high, avic_base + AVIC_INTENABLEH);
+	__raw_writel(saved_wakeup_low, avic_base + AVIC_INTENABLEL);
+
+	return 0;
+}
+
+#else
+#define mxc_avic_suspend  NULL
+#define mxc_avic_resume   NULL
+#endif				/* CONFIG_PM */
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct sysdev_class mxc_avic_sysclass = {
+	.name = "mxc_irq",
+	.suspend = mxc_avic_suspend,
+	.resume = mxc_avic_resume,
+};
+
+/*!
+ * This structure represents AVIC as a system device.
+ * System devices follow a slightly different driver model.
+ * They don't need to do dynammic driver binding, can't be probed,
+ * and don't reside on any type of peripheral bus.
+ * So, it is represented and treated a little differently.
+ */
+static struct sys_device mxc_avic_device = {
+	.id = 0,
+	.cls = &mxc_avic_sysclass,
+};
+
+/*
+ * This function is used to get the AVIC Lo and Hi interrupts
+ * that are enabled as wake up sources to wake up the core from suspend
+ */
+void mxc_get_wake_irq(u32 *wake_src[])
+{
+	*wake_src[0] = __raw_readl(avic_base + AVIC_INTENABLEL);
+	*wake_src[1] = __raw_readl(avic_base + AVIC_INTENABLEH);
+}
+
 /*
  * This function initializes the AVIC hardware and disables all the
  * interrupts. It registers the interrupt enable and disable functions
@@ -142,6 +248,10 @@ void __init mxc_init_irq(void __iomem *irqbase)
 	for (i = 0; i < 8; i++)
 		__raw_writel(0, avic_base + AVIC_NIPRIORITY(i));
 
+	/* Set WDOG2's interrupt the highest priority level (bit 28-31) */
+	__raw_writel(__raw_readl(avic_base + AVIC_NIPRIORITY(6)) | \
+		     (0xF << 28), avic_base + AVIC_NIPRIORITY(6));
+
 	/* init architectures chained interrupt handler */
 	mxc_register_gpios();
 
@@ -153,3 +263,25 @@ void __init mxc_init_irq(void __iomem *irqbase)
 	printk(KERN_INFO "MXC IRQ initialized\n");
 }
 
+/*!
+ * This function registers AVIC hardware as a system device.
+ * System devices will only be suspended with interrupts disabled, and
+ * after all other devices have been suspended. On resume, they will be
+ * resumed before any other devices, and also with interrupts disabled.
+ *
+ * @return       This function returns 0 on success.
+ */
+static int __init mxc_avic_sysinit(void)
+{
+	int ret = 0;
+
+	ret = sysdev_class_register(&mxc_avic_sysclass);
+	if (ret == 0)
+		ret = sysdev_register(&mxc_avic_device);
+
+	return ret;
+}
+
+#ifndef CONFIG_MXC_TZIC
+arch_initcall(mxc_avic_sysinit);
+#endif
diff --git a/arch/arm/plat-mxc/isp1504xc.c b/arch/arm/plat-mxc/isp1504xc.c
new file mode 100644
index 0000000..fead4f6
--- /dev/null
+++ b/arch/arm/plat-mxc/isp1504xc.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/delay.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_FUNC		0x04	/* Function Control */
+#define ISP1504_ITFCTL		0x07	/* Interface Control */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+/* 1504 OTG Function Control Register bits */
+#define SUSPENDM		(1 << 6)	/* places the PHY into
+						   low-power mode      */
+#define DRV_RESET		(1 << 5)	/* Active HIGH transceiver
+						   reset                  */
+
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+static u8 isp1504_read(int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_set(u8 bits, int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_clear(u8 bits, int reg, volatile u32 *view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+static void isp1508_fix(u32 *view)
+{
+	if (!machine_is_mx31_3ds())
+		gpio_usbotg_hs_active();
+
+	/* Set bits IND_PASS_THRU and IND_COMPL */
+	isp1504_set(0x60, ISP1504_ITFCTL, view);
+
+	/* Set bit USE_EXT_VBUS_IND */
+	isp1504_set(USE_EXT_VBUS_IND, ISP1504_OTGCTL, view);
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void isp1504_set_vbus_power(struct fsl_xcvr_ops *this,
+				   struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 *view = pdata->regs + ULPIVW_OFF;
+
+	pr_debug("real %s(on=%d) view=0x%p\n", __func__, on, view);
+
+	pr_debug("ULPI Vendor ID 0x%x    Product ID 0x%x\n",
+		 (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_VID_LOW, view),
+		 (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_PID_LOW, view));
+
+	pr_debug("OTG Control before=0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1508_fix(view);
+
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	pr_debug("OTG Control after = 0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+}
+
+/*!
+ * set remote wakeup
+ *
+ * @param       view  viewport register
+ */
+static void isp1504_set_remote_wakeup(u32 *view)
+{
+	__raw_writel(~ULPIVW_WRITE & __raw_readl(view), view);
+	__raw_writel((1 << ULPIVW_PORT_SHIFT) | __raw_readl(view), view);
+	__raw_writel(ULPIVW_RUN | __raw_readl(view), view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+static void isp1504_init(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __func__);
+}
+
+static void isp1504_uninit(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __func__);
+}
+
+static void isp1504_suspend(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s\n", __func__);
+
+	/* send suspend command */
+	isp1504_clear(SUSPENDM, ISP1504_FUNC, &UOG_ULPIVIEW);
+	pr_debug("%s.\n", __func__);
+}
+
+/*!
+ * Set the 1504 transceiver to the proper mode for testing purposes.
+ *
+ * @param       view  the ULPI VIEWPORT register address
+ * @param       test_mode Set the 1504 transceiver to disable bit stuffing and NRZI
+ */
+ static void isp1504_set_test_mode(u32 *view, enum usb_test_mode test_mode)
+{
+	if (test_mode == USB_TEST_J || test_mode == USB_TEST_K) {
+		printk(KERN_INFO "udc: disable bit stuffing and NRZI\n");
+		/* Disable bit-stuffing and NRZI encoding. */
+		isp1504_set(0x10, 0x04, view);
+	}
+}
+
+static struct fsl_xcvr_ops isp1504_ops = {
+	.name = "isp1504",
+	.xcvr_type = PORTSC_PTS_ULPI,
+	.init = isp1504_init,
+	.uninit = isp1504_uninit,
+	.suspend = isp1504_suspend,
+	.set_vbus_power = isp1504_set_vbus_power,
+	.set_remote_wakeup = isp1504_set_remote_wakeup,
+	.set_test_mode = isp1504_set_test_mode,
+};
+
+static int __init isp1504xc_init(void)
+{
+	pr_debug("%s\n", __func__);
+
+	fsl_usb_xcvr_register(&isp1504_ops);
+
+	/* suspend isp1504 */
+	if (fsl_usb_xcvr_suspend(&isp1504_ops))
+		pr_debug("%s: failed to suspend isp1504\n", __func__);
+
+	return 0;
+}
+
+static void __exit isp1504xc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&isp1504_ops);
+}
+
+module_init(isp1504xc_init);
+module_exit(isp1504xc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1504 xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/serialxc.c b/arch/arm/plat-mxc/serialxc.c
new file mode 100644
index 0000000..6bf931f
--- /dev/null
+++ b/arch/arm/plat-mxc/serialxc.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+
+static void usb_serial_init(struct fsl_xcvr_ops *this)
+{
+}
+
+static void usb_serial_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+static struct fsl_xcvr_ops serial_ops = {
+	.name = "serial",
+	.xcvr_type = PORTSC_PTS_SERIAL,
+	.init = usb_serial_init,
+	.uninit = usb_serial_uninit,
+};
+
+static int __init serialxc_init(void)
+{
+	pr_debug("%s\n", __func__);
+
+	fsl_usb_xcvr_register(&serial_ops);
+
+	return 0;
+}
+
+static void __exit serialxc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&serial_ops);
+}
+
+module_init(serialxc_init);
+module_exit(serialxc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("serial xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/snoop.c b/arch/arm/plat-mxc/snoop.c
new file mode 100644
index 0000000..3ef7a75
--- /dev/null
+++ b/arch/arm/plat-mxc/snoop.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+
+#ifdef M4IF_BASE_ADDR
+#define SNOOP_V2
+#define MAX_SNOOP	2
+#define g_snoop_base	(IO_ADDRESS(M4IF_BASE_ADDR) + 0x4C)
+#elif defined(M3IF_BASE_ADDR)
+#define MAX_SNOOP	1
+#define g_snoop_base	(IO_ADDRESS(M3IF_BASE_ADDR) + 0x28)
+#else
+#define MAX_SNOOP	0
+#define g_snoop_base	0
+#endif
+
+/* M3IF Snooping Configuration Register 0 (M3IFSCFG0) READ/WRITE*/
+#define SBAR(x)		(x * 0x14)
+/* M3IF Snooping Configuration Register 1 (M3IFSCFG1) READ/WRITE*/
+#define SERL(x)		((x * 0x14) + 0x4)
+/* M3IF Snooping Configuration Register 2 (M3IFSCFG2) READ/WRITE*/
+#define SERH(x)		((x * 0x14) + 0x8)
+/* M3IF Snooping Status Register 0 (M3IFSSR0) READ/WRITE */
+#define SSRL(x)		((x * 0x14) + 0xC)
+/* M3IF Snooping Status Register 1 (M3IFSSR1) */
+#define SSRH(x)		((x * 0x14) + 0x10)
+
+#if MAX_SNOOP
+
+int mxc_snoop_set_config(u32 num, unsigned long base, int size)
+{
+	u32 reg;
+	uint32_t msb;
+	uint32_t seg_size;
+	uint32_t window_size = 0;
+	int i;
+
+	if (num >= MAX_SNOOP)
+		return -EINVAL;
+
+	/* Setup M3IF for snooping */
+	if (size) {
+
+		if (base == 0)
+			return -EINVAL;
+
+		msb = fls(size);
+		if (!(size & ((1UL << msb) - 1)))
+			msb--;	/* Already aligned to power 2 */
+		if (msb < 11)
+			msb = 11;
+
+		window_size = (1UL << msb);
+		seg_size = window_size / 64;
+
+		msb -= 11;
+
+		reg = base & ~((1UL << msb) - 1);
+		reg |= msb << 1;
+		reg |= 1;	/* enable snooping */
+		reg |= 0x80;	/* Set pulse width to default (M4IF only) */
+		__raw_writel(reg, g_snoop_base + SBAR(num));
+
+		reg = 0;
+		for (i = 0; i < 32; i++) {
+			if (i * seg_size >= size)
+				break;
+			reg |= 1UL << i;
+		}
+		__raw_writel(reg, g_snoop_base + SERL(num));
+
+		reg = 0;
+		for (i = 32; i < 64; i++) {
+			if (i * seg_size >= size)
+				break;
+			reg |= 1UL << (i - 32);
+		}
+		__raw_writel(reg, g_snoop_base + SERH(num));
+
+		pr_debug
+		    ("Snooping unit # %d enabled: window size = 0x%X,"
+		     "M3IFSCFG0=0x%08X, M3IFSCFG1=0x%08X, M3IFSCFG2=0x%08X\n",
+		     num, window_size, __raw_readl(g_snoop_base + SBAR(num)),
+		     __raw_readl(g_snoop_base + SERL(num)),
+		     __raw_readl(g_snoop_base + SERH(num)));
+	} else
+		__raw_writel(0, g_snoop_base + SBAR(num));
+
+	return window_size;
+}
+EXPORT_SYMBOL(mxc_snoop_set_config);
+
+int mxc_snoop_get_status(u32 num, u32 *statl, u32 *stath)
+{
+	if (num >= MAX_SNOOP)
+		return -EINVAL;
+
+	*statl = __raw_readl(g_snoop_base + SSRL(num));
+	*stath = __raw_readl(g_snoop_base + SSRH(num));
+	/* DPRINTK("status = 0x%08X%08X\n", stat[1], stat[0]); */
+
+#ifdef SNOOP_V2
+	__raw_writel(*statl, g_snoop_base + SSRL(num));
+	__raw_writel(*stath, g_snoop_base + SSRH(num));
+#else
+	__raw_writel(0x0, g_snoop_base + SSRL(num));
+	__raw_writel(0x0, g_snoop_base + SSRH(num));
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(mxc_snoop_get_status);
+
+#endif				/* MAX_SNOOP */
diff --git a/arch/arm/plat-mxc/spba.c b/arch/arm/plat-mxc/spba.c
new file mode 100644
index 0000000..af56393
--- /dev/null
+++ b/arch/arm/plat-mxc/spba.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/spba.h>
+
+/*!
+ * @file plat-mxc/spba.c
+ *
+ * @brief This file contains the SPBA API implementation details.
+ *
+ * @ingroup SPBA
+ */
+
+static DEFINE_SPINLOCK(spba_lock);
+
+#define SPBA_MASTER_MIN                 1
+#define SPBA_MASTER_MAX                 7
+
+/*!
+ * the base addresses for the SPBA modules
+ */
+static unsigned long spba_base = (unsigned long)IO_ADDRESS(SPBA_CTRL_BASE_ADDR);
+
+/*!
+ * SPBA clock
+ */
+static struct clk *spba_clk;
+/*!
+ * This function allows the three masters (A, B, C) to take ownership of a
+ * shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_take_ownership(int mod, int master)
+{
+	unsigned long spba_flags;
+	__u32 rtn_val = -1;
+
+	if (master < SPBA_MASTER_MIN || master > SPBA_MASTER_MAX) {
+		pr_info("spba_take_ownership() invalide master= %d\n", master);
+		BUG();		/* oops */
+	}
+
+	if (spba_clk == NULL)
+		spba_clk = clk_get(NULL, "spba_clk");
+
+	clk_enable(spba_clk);
+
+	spin_lock_irqsave(&spba_lock, spba_flags);
+	__raw_writel(master, spba_base + mod);
+
+	if ((__raw_readl(spba_base + mod) & MXC_SPBA_RAR_MASK) == master)
+		rtn_val = 0;
+
+	spin_unlock_irqrestore(&spba_lock, spba_flags);
+
+	clk_disable(spba_clk);
+	return rtn_val;
+}
+EXPORT_SYMBOL(spba_take_ownership);
+
+/*!
+ * This function releases the ownership for a shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_rel_ownership(int mod, int master)
+{
+	unsigned long spba_flags;
+	volatile unsigned long rar;
+
+	if (master < SPBA_MASTER_MIN || master > SPBA_MASTER_MAX) {
+		pr_err("spba_take_ownership() invalide master= %d\n", master);
+		BUG();		/* oops */
+	}
+
+	if (spba_clk == NULL)
+		spba_clk = clk_get(NULL, "spba_clk");
+
+	clk_enable(spba_clk);
+
+	if ((__raw_readl(spba_base + mod) & master) == 0) {
+		clk_disable(spba_clk);
+		return 0;	/* does not own it */
+	}
+
+	spin_lock_irqsave(&spba_lock, spba_flags);
+
+	/* Since only the last 3 bits are writeable, doesn't need to mask off
+	   bits 31-3 */
+	rar = __raw_readl(spba_base + mod) & (~master);
+	__raw_writel(rar, spba_base + mod);
+
+	if ((__raw_readl(spba_base + mod) & master) != 0) {
+		spin_unlock_irqrestore(&spba_lock, spba_flags);
+		clk_disable(spba_clk);
+		return -1;
+	}
+
+	spin_unlock_irqrestore(&spba_lock, spba_flags);
+
+	clk_disable(spba_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(spba_rel_ownership);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SPBA");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/system.c b/arch/arm/plat-mxc/system.c
index 97f4279..ac67d86 100644
--- a/arch/arm/plat-mxc/system.c
+++ b/arch/arm/plat-mxc/system.c
@@ -56,7 +56,9 @@ void arch_reset(char mode, const char *cmd)
 			clk_enable(clk);
 		wcr_enable = (1 << 2);
 	}
-
+#ifdef CONFIG_ARCH_MX51
+	mx51_reset_fixup();
+#endif
 	/* Assert SRS signal */
 	__raw_writew(wcr_enable, wdog_base);
 
diff --git a/arch/arm/plat-mxc/tzic.c b/arch/arm/plat-mxc/tzic.c
index afa6709..c884ad4 100644
--- a/arch/arm/plat-mxc/tzic.c
+++ b/arch/arm/plat-mxc/tzic.c
@@ -164,8 +164,9 @@ int tzic_enable_wake(int is_idle)
 		return -EAGAIN;
 
 	for (i = 0; i < 4; i++) {
-		v = is_idle ? __raw_readl(TZIC_ENSET0(i)) : wakeup_intr[i];
-		__raw_writel(v, TZIC_WAKEUP0(i));
+		v = is_idle ? __raw_readl(tzic_base + TZIC_ENSET0(i)) : \
+				wakeup_intr[i];
+		__raw_writel(v, tzic_base + TZIC_WAKEUP0(i));
 	}
 
 	return 0;
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
new file mode 100644
index 0000000..00bf24e
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -0,0 +1,876 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata)
+{
+	enum fsl_usb2_modes mode;
+	mode = FSL_USB_UNKNOWN;
+
+	if (!strcmp("DR", pdata->name)) {
+		if ((UOG_USBMODE & 0x3) == 0x2)
+			mode = FSL_USB_DR_DEVICE;
+		else if ((UOG_USBMODE & 0x3) == 0x3)
+			mode = FSL_USB_DR_HOST;
+	} else if (!strcmp("Host 1", pdata->name))
+		mode = FSL_USB_MPH_HOST1;
+	else if (!strcmp("Host 2", pdata->name))
+		mode = FSL_USB_MPH_HOST2;
+
+	if (mode == FSL_USB_UNKNOWN)
+		printk(KERN_ERR "unknow usb mode,name is %s\n", pdata->name);
+	return mode;
+}
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int fsl_check_usbclk(void)
+{
+	unsigned long freq;
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	if (clk_enable(usb_ahb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
+	clk_put(usb_ahb_clk);
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
+		return -1;
+	}
+
+	return 0;
+}
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_platform_set_test_mode(struct fsl_usb2_platform_data *pdata,
+				enum usb_test_mode mode)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_test_mode)
+		pdata->xcvr_ops->set_test_mode((u32 *)(pdata->regs + \
+						       ULPIVW_OFF), mode);
+}
+EXPORT_SYMBOL(fsl_platform_set_test_mode);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	if (name == NULL) {
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0)
+			return g_xc_ops[i];
+	}
+	pr_debug("Failed %s\n", __func__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id;
+struct platform_device *host_pdev_register(struct resource *res, int n_res,
+				   struct fsl_usb2_platform_data *config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	instance_id++;
+
+	return pdev;
+}
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	pr_debug("%s xceiv=0x%p\n", __func__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	pr_debug("%s xceiv=0x%p  x=0x%p\n", __func__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+static struct resource *otg_resources;
+
+struct resource *otg_get_resources(void)
+{
+	return otg_resources;
+}
+EXPORT_SYMBOL(otg_get_resources);
+
+int otg_set_resources(struct resource *resources)
+{
+	otg_resources = resources;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_resources);
+#endif
+
+static void usbh1_set_serial_xcvr(void)
+{
+	pr_debug("%s:\n", __func__);
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE); /* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |		/* single-ended / unidir. */
+		   UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		   UCTRL_H1PM;			/* power mask */
+}
+
+static void usbh1_set_ulpi_xcvr(void)
+{
+	pr_debug("%s:\n", __func__);
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while (UH1_USBCMD & UCMD_RESET)
+		;
+
+	/* Select the clock from external PHY */
+	USB_CTRL_1 |= USB_CTRL_UH1_EXT_CLK_EN;
+
+	/* select ULPI PHY PTS=2 */
+	UH1_PORTSC1 = (UH1_PORTSC1 & ~PORTSC_PTS_MASK) | PORTSC_PTS_ULPI;
+
+	USBCTRL &= ~UCTRL_H1WIE; /* HOST1 wakeup intr disable */
+	USBCTRL &= ~UCTRL_H1UIE; /* Host1 ULPI interrupt disable */
+	USBCTRL |= UCTRL_H1PM; /* HOST1 power mask */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* OC is not used */
+
+	/* Interrupt Threshold Control:Immediate (no threshold) */
+	UH1_USBCMD &= UCMD_ITC_NO_THRESHOLD;
+
+	UH1_USBCMD |= UCMD_RESET;       /* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	* the ULPI transceiver to reset too.
+	*/
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+static void usbh2_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
+	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
+		   UCTRL_H2UIE |	/* ULPI intr enable */
+		   UCTRL_H2DT |		/* disable H2 TLL */
+		   UCTRL_H2PM;		/* power mask */
+
+	/* must set ULPI phy before turning off clock */
+	tmp = UH2_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UH2_PORTSC1 = tmp;
+
+	UH2_USBCMD |= UCMD_RESET;	/* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh2_set_serial_xcvr(void)
+{
+	pr_debug("%s:\n", __func__);
+
+	/* Stop then Reset */
+	UH2_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH2_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	USBCTRL &= ~(UCTRL_H2SIC_MASK);	/* Disable bypass mode */
+	USBCTRL &= ~(UCTRL_H2PM);	/* Power Mask */
+	USBCTRL &= ~UCTRL_H2OCPOL;	/* OverCurrent Polarity is Low Active */
+	USBCTRL &= ~UCTRL_H2WIE;	/* Wakeup intr disable */
+	USBCTRL |= UCTRL_IP_PUE_DOWN |	/* ipp_pue_pulldwn_dpdm */
+	    UCTRL_USBTE |	/* USBT is enabled */
+	    UCTRL_H2DT;		/* Disable H2 TLL */
+
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 0) {
+		/* Disable Host2 bus Lock for i.MX35 1.0 */
+		USBCTRL |= UCTRL_H2LOCKD;
+		/* USBOTG_PWR low active */
+		USBCTRL &= ~UCTRL_PP;
+		/* OverCurrent Polarity is Low Active */
+		USBCTRL &= ~UCTRL_OCPOL;
+	} else if (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1) {
+		/* i.MX35 2.0 OTG and Host2 have seperate OC/PWR polarity */
+		USBCTRL &= ~UCTRL_H2PP;
+		USBCTRL &= ~UCTRL_H2OCPOL;
+	} else if (cpu_is_mx25()) {
+		/*
+		 * USBH2_PWR and USBH2_OC are active high.
+		 * Must force xcvr clock to "internal" so that
+		 * we can write to PTS field after it's been
+		 * cleared by ehci_turn_off_all_ports().
+		 */
+		USBCTRL |= UCTRL_H2PP | UCTRL_H2OCPOL | UCTRL_XCSH2;
+		/* Disable Host2 bus Lock */
+		USBCTRL |= UCTRL_H2LOCKD;
+	}
+
+	USBCTRL &= ~(UCTRL_PP);
+	UH2_PORTSC1 = (UH2_PORTSC1 & (~PORTSC_PTS_MASK)) | PORTSC_PTS_SERIAL;
+
+	if (UH2_HCSPARAMS & HCSPARAMS_PPC)
+		UH2_PORTSC1 |= PORTSC_PORT_POWER;
+
+	/* Reset controller before set host mode */
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	msleep(100);
+}
+
+/*!
+ * Register remote wakeup by this usb controller
+ *
+ * @param pdev: platform_device for this usb controller
+ *
+ * @return 0 or negative error code in case not supportted.
+ */
+static int usb_register_remote_wakeup(struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+
+	pr_debug("%s: pdev=0x%p\n", __func__, pdev);
+	if (!cpu_is_mx51() && !cpu_is_mx25())
+		return -ECANCELED;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+		"Found HC with no IRQ. Check %s setup!\n",
+		dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+	pdev->dev.power.can_wakeup = 1;
+	enable_irq_wake(irq);
+
+	return 0;
+}
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+
+	pr_debug("%s: grab pins\n", __func__);
+	if (pdata->gpio_usb_active())
+		return -EINVAL;
+
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+		return -EINVAL;
+	}
+
+	if (cpu_is_mx51()) {
+		struct clk *usboh3_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usboh3_clk);
+		clk_put(usboh3_clk);
+	}
+
+	/* enable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_enable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_enable(pdata->xcvr_pwr->regu2);
+	}
+
+	if (xops->init)
+		xops->init(xops);
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("%s port is not a wakeup source.\n", pdata->name);
+
+	if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+		if (cpu_is_mx35()) {
+			usbh2_set_serial_xcvr();
+			/* Close the internal 60Mhz */
+			USBCTRL &= ~UCTRL_XCSH2;
+		} else if (cpu_is_mx25())
+			usbh2_set_serial_xcvr();
+		else
+			usbh1_set_serial_xcvr();
+	} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+		if (!strcmp("Host 1", pdata->name)) {
+			usbh1_set_ulpi_xcvr();
+			if (cpu_is_mx51()) {
+#ifdef CONFIG_USB_EHCI_ARC_H1
+				gpio_usbh1_setback_stp();
+				/* disable remote wakeup irq */
+				USBCTRL &= ~UCTRL_H1WIE;
+#endif
+			}
+		}
+		if (!strcmp("Host 2", pdata->name)) {
+			usbh2_set_ulpi_xcvr();
+			if (cpu_is_mx51()) {
+#ifdef CONFIG_USB_EHCI_ARC_H2
+				gpio_usbh2_setback_stp();
+#endif
+			}
+		}
+	}
+
+	pr_debug("%s: %s success\n", __func__, pdata->name);
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+
+	pdata->gpio_usb_inactive();
+	if (pdata->xcvr_type == PORTSC_PTS_SERIAL) {
+		/* Workaround an IC issue for ehci driver.
+		 * when turn off root hub port power, EHCI set
+		 * PORTSC reserved bits to be 0, but PTS with 0
+		 * means UTMI interface, so here force the Host2
+		 * port use the internal 60Mhz.
+		 */
+		if (cpu_is_mx35())
+			USBCTRL |= UCTRL_XCSH2;
+		clk_disable(usb_clk);
+	}
+
+	/* disable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_disable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_disable(pdata->xcvr_pwr->regu2);
+	}
+
+	if (cpu_is_mx51()) {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+	clk_disable(usb_ahb_clk);
+}
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+static void otg_set_serial_xcvr(void)
+{
+	pr_debug("%s\n", __func__);
+}
+
+void otg_set_serial_host(void)
+{
+	pr_debug("%s\n", __func__);
+	/* set USBCTRL for host operation
+	 * disable: bypass mode,
+	 * set: single-ended/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_ASESVLD;	/* 0xa */
+}
+EXPORT_SYMBOL(otg_set_serial_host);
+
+void otg_set_serial_peripheral(void)
+{
+	/* set USBCTRL for device operation
+	 * disable: bypass mode
+	 * set: differential/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_BSESVLD | OTGM_IDIDG; /* oxd */
+}
+EXPORT_SYMBOL(otg_set_serial_peripheral);
+
+static void otg_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+	USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* must set ULPI phy before turning off clock */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	if (clk_get_usecount(usb_clk) > 0)
+		clk_disable(usb_clk);
+}
+
+int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops)
+{
+	if (!machine_is_mx31_3ds())
+		return -ECANCELED;
+
+	if (xcvr_ops->xcvr_type == PORTSC_PTS_ULPI) {
+		if (fsl_check_usbclk() != 0)
+			return -EINVAL;
+		if (gpio_usbotg_hs_active())
+			return -EINVAL;
+		clk_enable(usb_clk);
+
+		otg_set_ulpi_xcvr();
+
+		if (xcvr_ops->suspend)
+			/* suspend transceiver */
+			xcvr_ops->suspend(xcvr_ops);
+
+		gpio_usbotg_hs_inactive();
+
+		if (clk_get_usecount(usb_clk) > 0)
+			clk_disable(usb_clk);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_suspend);
+
+static void otg_set_utmi_xcvr(void)
+{
+	u32 tmp;
+
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	if (cpu_is_mx51()) {
+		if (machine_is_mx51_3ds()) {
+			/* OTG Polarity of Overcurrent is Low active */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_POL;
+			/* Enable OTG Overcurrent Event */
+			USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_OC_DIS;
+		} else {
+			/* BBG is not using OC */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+		}
+	} else if (cpu_is_mx25()) {
+		USBCTRL |= UCTRL_OCPOL;
+		USBCTRL &= ~UCTRL_PP;
+	} else {
+		/* USBOTG_PWR low active */
+		USBCTRL &= ~UCTRL_PP;
+		/* OverCurrent Polarity is Low Active */
+		USBCTRL &= ~UCTRL_OCPOL;
+
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 0)
+			/* OTG Lock Disable */
+			USBCTRL |= UCTRL_OLOCKD;
+	}
+
+	USBCTRL &= ~UCTRL_OPM;	/* OTG Power Mask */
+	USBCTRL &= ~UCTRL_OWIE;	/* OTG Wakeup Intr Disable */
+
+	/* set UTMI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_UTMI;
+	UOG_PORTSC1 = tmp;
+
+	if (cpu_is_mx51()) {
+		/* Set the PHY clock to 19.2MHz */
+		USB_PHY_CTR_FUNC2 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
+		USB_PHY_CTR_FUNC2 |= 0x01;
+	} else if (machine_is_mx37_3ds()) {
+		/* Reference voltage for HS disconnect envelope detector */
+		/* adjust the Squelch level */
+		USB_PHY_CTR_FUNC2 &= ~(USB_UTMI_PHYCTRL2_HSDEVSEL_MASK <<
+			USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT);
+	}
+
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	UOG_PORTSC1 |= PORTSC_PTW;
+
+	if (cpu_is_mx35() || cpu_is_mx25()) {
+		/* Enable UTMI interface in PHY control Reg */
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_UTMI_ENABLE;
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_UTMI_ENABLE;
+	}
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	if (cpu_is_mx37()) {
+		/* fix USB PHY Power Gating leakage issue for i.MX37 */
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CHGRDETON;
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CHGRDETEN;
+	}
+
+	/* Turn off the usbpll for UTMI tranceivers */
+	clk_disable(usb_clk);
+}
+
+static int otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "DR transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (!otg_used) {
+		if (fsl_check_usbclk() != 0)
+			return -EINVAL;
+
+		pr_debug("%s: grab pins\n", __func__);
+		if (pdata->gpio_usb_active())
+			return -EINVAL;
+
+		if (clk_enable(usb_clk)) {
+			printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+			return -EINVAL;
+		}
+
+		if (xops->init)
+			xops->init(xops);
+
+		UOG_PORTSC1 = UOG_PORTSC1 & ~PORTSC_PHCD;
+		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+			if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+				otg_set_serial_host();
+				/* need reset */
+				UOG_USBCMD |= UCMD_RESET;
+				msleep(100);
+			} else if (pdata->operating_mode == FSL_USB2_DR_DEVICE)
+				otg_set_serial_peripheral();
+			otg_set_serial_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+			otg_set_ulpi_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
+			otg_set_utmi_xcvr();
+		}
+	}
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("DR is not a wakeup source.\n");
+
+	otg_used++;
+	pr_debug("%s: success\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	otg_used--;
+	if (!otg_used) {
+		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+			pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+		pdata->regs = NULL;
+
+		if (machine_is_mx31_3ds()) {
+			if (pdata->xcvr_ops && pdata->xcvr_ops->suspend)
+				pdata->xcvr_ops->suspend(pdata->xcvr_ops);
+			clk_disable(usb_clk);
+		}
+		msleep(1);
+		UOG_PORTSC1 = UOG_PORTSC1 | PORTSC_PHCD;
+		pdata->gpio_usb_inactive();
+		if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
+			clk_disable(usb_clk);
+		clk_disable(usb_ahb_clk);
+	}
+}
+EXPORT_SYMBOL(usbotg_uninit);
+
+int usb_host_wakeup_irq(struct device *wkup_dev)
+{
+	int wakeup_req = 0;
+	struct fsl_usb2_platform_data *pdata = wkup_dev->platform_data;
+
+	if (!strcmp("Host 1", pdata->name)) {
+		wakeup_req = USBCTRL & UCTRL_H1WIR;
+	} else if (!strcmp("DR", pdata->name)) {
+		wakeup_req = USBCTRL & UCTRL_OWIR;
+		/* If DR is in device mode, let udc handle it */
+		if (wakeup_req && ((UOG_USBMODE & 0x3) == 0x2))
+			wakeup_req = 0;
+	}
+
+	return wakeup_req;
+}
+EXPORT_SYMBOL(usb_host_wakeup_irq);
+
+void usb_host_set_wakeup(struct device *wkup_dev, bool para)
+{
+	struct fsl_usb2_platform_data *pdata = wkup_dev->platform_data;
+	if (pdata->wake_up_enable)
+		pdata->wake_up_enable(pdata, para);
+}
+EXPORT_SYMBOL(usb_host_set_wakeup);
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
new file mode 100644
index 0000000..aef540f
--- /dev/null
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/pmic_external.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+static struct regulator *usbotg_regux;
+
+static void usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+	if (machine_is_mx51_3ds()) {
+		unsigned int value;
+
+		/* VUSBIN */
+		pmic_read_reg(REG_USB1, &value, 0xffffff);
+		value |= 0x1;
+		value |= (0x1 << 3);
+		pmic_write_reg(REG_USB1, value, 0xffffff);
+	}
+#endif
+}
+
+static void usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void set_power(struct fsl_xcvr_ops *this,
+		      struct fsl_usb2_platform_data *pdata, int on)
+{
+	struct device *dev = &pdata->pdev->dev;
+
+	pr_debug("real %s(on=%d) pdata=0x%p\n", __func__, on, pdata);
+	if (machine_is_mx37_3ds()) {
+		if (on) {
+			if (!board_is_rev(BOARD_REV_2))
+				usbotg_regux = regulator_get(dev, "DCDC2");
+			else
+				usbotg_regux = regulator_get(dev, "SWBST");
+
+			regulator_enable(usbotg_regux);
+		} else {
+			regulator_disable(usbotg_regux);
+			regulator_put(usbotg_regux);
+		}
+	}
+}
+
+static struct fsl_xcvr_ops utmi_ops = {
+	.name = "utmi",
+	.xcvr_type = PORTSC_PTS_UTMI,
+	.init = usb_utmi_init,
+	.uninit = usb_utmi_uninit,
+	.set_vbus_power = set_power,
+};
+
+static int __init utmixc_init(void)
+{
+	fsl_usb_xcvr_register(&utmi_ops);
+	return 0;
+}
+
+static void __exit utmixc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&utmi_ops);
+}
+
+module_init(utmixc_init);
+module_exit(utmixc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("utmi xcvr driver");
+MODULE_LICENSE("GPL");
-- 
1.6.5.2

