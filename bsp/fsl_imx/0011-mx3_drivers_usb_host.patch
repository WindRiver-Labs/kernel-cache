From 6092a529bce4df4e7823e82901c915d745ab18c3 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Tue, 28 Oct 2008 10:44:30 +0800
Subject: [PATCH] mx3_drivers_usb_host

MX3 usb host controller driver.
Add kernel clk  interface manipulation.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Makefile  |    1 +
 arch/arm/mach-mx3/usb.c     |  937 +++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/Kconfig         |    1 +
 drivers/usb/host/Kconfig    |   28 ++
 drivers/usb/host/ehci-arc.c |  398 ++++++++++++++++++
 drivers/usb/host/ehci-hcd.c |    5 +
 6 files changed, 1370 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx3/usb.c
 create mode 100644 drivers/usb/host/ehci-arc.c

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 07d46da..93d6c68 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -8,3 +8,4 @@ obj-y			:= mm.o clock.o devices.o iomux.o cpu.o dma.o mx31_gpio.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o
 obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
+obj-$(CONFIG_USB_EHCI_ARC)  += usb.o
diff --git a/arch/arm/mach-mx3/usb.c b/arch/arm/mach-mx3/usb.c
new file mode 100644
index 0000000..4450d56
--- /dev/null
+++ b/arch/arm/mach-mx3/usb.c
@@ -0,0 +1,937 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/cacheflush.h>
+#include <asm/mach-types.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <mach/gpio.h>
+#include <mach/clock.h>
+#include <mach/isp1504.h>
+#include <asm/plat-mxc/mxc_timer.h>
+
+#include "crm_regs.h"
+
+#define PBC3_CLEAR	(PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR)
+#define PBC3_SET	(PBC_BASE_ADDRESS + PBC_BCTRL3_SET)
+
+#undef VERBOSE
+
+#ifdef DEBUG
+#define dbg(fmt, args...)	printk(KERN_DEBUG "%s: " fmt "\n", \
+		__func__, ## args)
+#else
+#define dbg(fmt, args...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define vdbg	dbg
+#else
+#define vdbg(fmt, args...)	do {} while (0)
+#endif
+
+static void usbh2_set_vbus_power(int on);
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+static unsigned int usb_clk_cnt;
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int check_usbclk(void)
+{
+	unsigned long clk;
+
+	if (IS_ERR(usb_clk)) {
+		pr_debug("no usb_clk?\n");
+		return -1;
+	}
+
+	clk = clk_get_rate(usb_clk);
+	if ((clk < 59999000) ||
+			(clk > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", clk);
+		return -1;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_ISP1504_MXC) || defined(CONFIG_ISP1504_MXC_MODULE)
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+u8 isp1504_read(int reg, u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+EXPORT_SYMBOL(isp1504_read);
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_set(u8 bits, int reg, u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+			cpu_relax();
+			barrier();
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+				((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+				((bits & ULPIVW_WDATA_MASK)
+				 << ULPIVW_WDATA_SHIFT)),
+			view);
+
+	while (__raw_readl(view) & ULPIVW_RUN) { /* wait for completion */
+		cpu_relax();
+		barrier();
+	}
+}
+EXPORT_SYMBOL(isp1504_set);
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_clear(u8 bits, int reg, u32 *view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+				((reg + ISP1504_REG_CLEAR)
+				 << ULPIVW_ADDR_SHIFT) |
+				((bits & ULPIVW_WDATA_MASK)
+				 << ULPIVW_WDATA_SHIFT)),
+			view);
+
+	while (__raw_readl(view) & ULPIVW_RUN) {
+		cpu_relax();
+		barrier();
+	}
+}
+EXPORT_SYMBOL(isp1504_clear);
+
+/*!
+ * set vbus power
+ *
+ * @param       on    power on or off
+ * @param       view  the ULPI view register address
+ */
+static void ulpi_set_vbus_power(int on, u32 *view)
+{
+	dbg("on=%d  view=0x%p", on, view);
+
+	vdbg("ULPI Vendor ID 0x%x    Product ID 0x%x",
+			(isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+			isp1504_read(ISP1504_VID_LOW, view),
+			(isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+			isp1504_read(ISP1504_PID_LOW, view));
+
+	vdbg("OTG Control before = 0x%x", isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+				DRV_VBUS |	/* enable internal Vbus */
+				USE_EXT_VBUS_IND |
+				CHRG_VBUS,	/* charge Vbus */
+				ISP1504_OTGCTL, view);
+
+	} else {
+		isp1504_clear(DRV_VBUS_EXT |
+				DRV_VBUS,	/* disable internal Vbus */
+				ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |
+				DISCHRG_VBUS,	/* discharge Vbus */
+				ISP1504_OTGCTL, view);
+	}
+
+	vdbg("OTG Control after = 0x%x\n", isp1504_read(ISP1504_OTGCTL, view));
+}
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || defined(CONFIG_USB_GADGET_ARC_OTGHS)
+static int otg_used;	/* OTG use-count */
+
+static void otg_hs_set_xcvr(void)
+{
+	u32 tmp;
+
+	/* set ULPI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(10);
+}
+
+static int otg_hs_init(void)
+{
+	if (!otg_used) {
+		if (check_usbclk() != 0)
+			return -EINVAL;
+
+		dbg("grab OTG-HS pins");
+		if (gpio_usbotg_hs_active())	/* grab our pins */
+			return -EINVAL;
+
+		if (machine_is_mx31ads()) {
+			/* enable OTG/HS */
+			__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
+
+			/* disable OTG/FS */
+			__raw_writew(PBC_BCTRL3_OTG_FS_EN, PBC3_SET);
+		}
+
+		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+			UCTRL_OWIE |	/* OTG wakeup intr enable */
+			UCTRL_OPM;	/* power mask */
+
+		otg_hs_set_xcvr();	/* set transciever type */
+	}
+
+	otg_used++;
+	usb_clk_cnt++;
+	return 0;
+}
+
+static void otg_hs_uninit(void)
+{
+	dbg();
+
+	otg_used--;
+	if (!otg_used) {
+		/* disable  OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_SET);
+
+		dbg("free OTG-HS pins");
+		gpio_usbotg_hs_inactive();	/* release our pins */
+	}
+
+	if (!(--usb_clk_cnt)) {
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+		usb_clk = NULL;
+	}
+}
+
+static void otg_hs_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, (u32 *)&UOG_ULPIVIEW);
+}
+
+/*!
+ * OTG HS host config
+ */
+#ifdef CONFIG_USB_EHCI_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_hs_host_config = {
+	.name            = "OTG HS Host",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_hs_host_device;
+#endif	/* CONFIG_USB_EHCI_ARC_OTGHS */
+#endif	/* CONFIG_USB_EHCI_ARC_OTGHS || CONFIG_USB_GADGET_ARC_OTGHS */
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || defined(CONFIG_USB_EHCI_ARC_OTGFS)
+/* *INDENT-OFF* */
+static struct resource otg_resources[] = {
+	{
+		.start = (u32) (USB_OTGREGS_BASE),
+		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+#endif
+
+/* *INDENT-ON* */
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGFS) || defined(CONFIG_USB_GADGET_ARC_OTGFS)
+static void otg_fs_set_xcvr(void)
+{
+	u32 tmp;
+
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_SERIAL;
+	UOG_PORTSC1 = tmp;
+}
+#endif /* CONFIG_USB_EHCI_ARC_OTGFS || CONFIG_USB_GADGET_ARC_OTGFS */
+
+#ifdef CONFIG_USB_EHCI_ARC_OTGFS
+static int otg_fs_host_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_host();
+	if (gpio_usbotg_fs_active())	/* grab our pins */
+		return -EINVAL;
+	mdelay(1);
+
+	/* enable OTG VBUS */
+	clk_disable(usb_ahb_clk);
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
+	clk_enable(usb_ahb_clk);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	/* disable bypass mode */
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);
+	USBCTRL |= UCTRL_OSIC_SU6 |	/* single-ended, unidir, 6 wire */
+		UCTRL_OWIE |	/* OTG wakeup intr enable */
+		UCTRL_OPM;		/* power mask */
+
+	/* need reset */
+	UOG_USBCMD |= UCMD_RESET;
+	mdelay(10);
+
+	usb_clk_cnt++;
+
+	return 0;
+}
+
+static void otg_fs_host_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);	/* disable OTG VBUS */
+
+	isp1301_uninit();
+
+	if (!(--usb_clk_cnt)) {
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+		usb_clk = NULL;
+	}
+
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/*!
+ * OTG FS host config
+ */
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_fs_host_config = {
+	.name            = "OTG FS Host",
+	.platform_init   = otg_fs_host_init,
+	.platform_uninit = otg_fs_host_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_fs_host_device;
+#endif				/* CONFIG_USB_EHCI_ARC_OTGFS */
+
+/* Host 1 */
+#ifdef CONFIG_USB_EHCI_ARC_H1
+static void usbh1_set_xcvr(void)
+{
+	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
+	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
+}
+
+static int usbh1_init(void)
+{
+	dbg("grab H1 pins");
+
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	if (gpio_usbh1_active())
+		return -EINVAL;
+
+	if (machine_is_mx31ads()) {
+		__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_CLEAR);	/* enable FSH */
+		__raw_writew(PBC_BCTRL3_FSH_SEL, PBC3_SET);	/* Group B */
+		/* single ended */
+		__raw_writew(PBC_BCTRL3_FSH_MOD, PBC3_CLEAR);
+		/* enable FSH VBUS */
+		__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);
+	}
+	/* disable bypass mode */
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);
+	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
+		UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		UCTRL_H1PM;		/* power mask */
+
+	usbh1_set_xcvr();
+
+	usb_clk_cnt++;
+
+	return 0;
+}
+
+static void usbh1_uninit(void)
+{
+	dbg();
+
+	if (machine_is_mx31ads()) {
+		/* disable FSH */
+		__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_SET);
+		/* disable FSH VBUS */
+		__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_SET);
+	}
+
+	if (!(--usb_clk_cnt)) {
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+		usb_clk = NULL;
+	}
+
+	gpio_usbh1_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh1_config = {
+	.name            = "Host 1",
+	.platform_init   = usbh1_init,
+	.platform_uninit = usbh1_uninit,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UH1_USBMODE,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+
+static struct resource usbh1_resources[] = {
+	{
+		.start = (u32) (USB_H1REGS_BASE),
+		.end   = (u32) (USB_H1REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh1_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H1 */
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+static void usbh2_set_xcvr(void)
+{
+	UH2_PORTSC1 &= ~PORTSC_PTS_MASK;	/* set ULPI xcvr */
+	UH2_PORTSC1 |= PORTSC_PTS_ULPI;
+	UH2_USBCMD |= UCMD_RESET;
+	mdelay(10);
+}
+
+static int usbh2_init(void)
+{
+	dbg("grab H2 pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	if (machine_is_mx31ads()) {
+		/* abort the init if NAND card is present */
+		if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT1) &
+					PBC_BSTAT1_NF_DET) == 0) {
+			printk(KERN_ERR "USBH2 port not configured: "
+					"pin conflict with NAND flash.\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * If the ATA interface is enabled, turning on
+		 * PBC_BCTRL3_HSH_SEL will make it unusable.
+		 * To avoid that, abort now if ATA is enabled.
+		 */
+		if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BCTRL2_SET) &
+					PBC_BCTRL2_ATA_EN) == 0) {
+			printk(KERN_ERR "USBH2 port not configured: "
+					"pin conflict with ATA.\n");
+			return -EINVAL;
+		}
+	}
+
+	if (gpio_usbh2_active())	/* grab our pins */
+		return -EINVAL;
+
+	if (machine_is_mx31ads()) {
+		/* enable HSH select */
+		__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_SET);
+		/* enable HSH */
+		__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);
+	}
+
+	usbh2_set_xcvr();	/* set transceiver type */
+
+	if (machine_is_mx31lite()) {
+		usbh2_set_vbus_power(true);
+		barrier();
+	}
+
+	/* disable bypass mode */
+	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
+	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
+		UCTRL_H2UIE |	/* ULPI intr enable */
+		UCTRL_H2DT |	/* disable H2 TLL */
+		UCTRL_H2PM;		/* power mask */
+
+	usb_clk_cnt++;
+
+	dbg("success");
+	return 0;
+}
+
+static void usbh2_uninit(void)
+{
+	dbg();
+
+	if (!machine_is_mx31lite()) {
+		/* disable HSH select */
+		__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_CLEAR);
+		/* disable HSH */
+		__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_SET);
+	}
+
+	if (!(--usb_clk_cnt)) {
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+		usb_clk = NULL;
+	}
+
+	gpio_usbh2_inactive();	/* release our pins */
+}
+
+static void usbh2_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, (u32 *)&UH2_ULPIVIEW);
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh2_config = {
+	.name            = "Host 2",
+	.platform_init   = usbh2_init,
+	.platform_uninit = usbh2_uninit,
+	.set_vbus_power  = usbh2_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH2_USBMODE,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+
+static struct resource usbh2_resources[] = {
+	{
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh2_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H2 */
+
+#ifdef CONFIG_USB_GADGET_ARC
+#ifdef CONFIG_USB_GADGET_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_hs_config = {
+	.name            = "OTG HS Gadget",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC_OTGFS
+int otg_fs_dev_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_dev();
+	gpio_usbotg_fs_active();	/* grab our pins */
+	mdelay(1);
+
+	/* disable OTG VBUS */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass */
+	USBCTRL |= UCTRL_OSIC_DU6 |	/* differential, unidir, 6 wire */
+		UCTRL_OWIE |	/* OTG wakeup intr enable */
+		UCTRL_OPM;		/* power mask */
+
+	USB_OTG_MIRROR = 0xd;
+
+	usb_clk_cnt++;
+
+	return 0;
+}
+
+static void otg_fs_dev_uninit(void)
+{
+	dbg();
+
+	/* disable OTG VBUS */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+
+	isp1301_uninit();
+
+	if (!(--usb_clk_cnt)) {
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+		usb_clk = NULL;
+	}
+
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_fs_config = {
+	.name            = "OTG FS Gadget",
+	.platform_init   = otg_fs_dev_init,
+	.platform_uninit = otg_fs_dev_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC_OTGFS */
+
+/*!
+ * OTG HS/FS gadget device
+ */
+
+static void usb_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+static u64 udc_dmamask = ~(u32)0;
+/* *INDENT-OFF* */
+static struct platform_device udc_device = {
+	.name = "arc_udc",
+	.id   = -1,
+	.dev  = {
+		.release           = usb_release,
+		.dma_mask          = &udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+#if   defined CONFIG_USB_GADGET_ARC_OTGHS
+		.platform_data     = &udc_hs_config,
+#elif defined CONFIG_USB_GADGET_ARC_OTGFS
+		.platform_data     = &udc_fs_config,
+#else
+#error "No OTG port configured."
+#endif
+	},
+	.num_resources = ARRAY_SIZE(otg_resources),
+	.resource      = otg_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC */
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	dbg("%s xceiv=0x%p\n", __func__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	dbg("%s xceiv=0x%p  x=0x%p\n", __func__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+static void isp1504_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+/* *INDENT-OFF* */
+static struct arc_xcvr_config isp1504_config = {
+	.name            = "isp1504",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.regs            = (void *)&UOG_ID,
+};
+
+static struct resource isp1504_resources[] = {
+	{
+		.start = INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*!
+ * ISP1504 device
+ */
+static u64 isp1504_dmamask = ~(u32) 0;
+static struct platform_device isp1504_device = {
+	.name = "isp1504_arc",
+	.id   = -1,
+	.dev  = {
+		.release           = isp1504_release,
+		.dma_mask          = &isp1504_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &isp1504_config,
+	},
+	.num_resources = ARRAY_SIZE(isp1504_resources),
+	.resource      = isp1504_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_OTG */
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id;
+static struct platform_device *host_pdev_register(struct resource *res,
+		int n_res,
+		struct arc_usb_config *config)
+{
+	int rc;
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("fsl-ehci",
+			instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+				config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+	rc = platform_device_add_data(pdev, config,
+			sizeof(struct arc_usb_config));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s registered\n", config->name);
+	dbg("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p",
+			pdev, &pdev->dev,
+			pdev->resource, pdev->dev.platform_data);
+	instance_id++;
+
+	return pdev;
+}
+
+static inline void fixup_usb_pll(void)
+{
+	/* set USB PLL frequency */
+	u32 pll_val = ((1 << MXC_CCM_PCTL_PD_OFFSET) |
+			(9 << MXC_CCM_PCTL_MFI_OFFSET) |
+			(12 << MXC_CCM_PCTL_MFD_OFFSET) |
+			3);
+	__raw_writel(pll_val, MXC_CCM_UPCTL);
+	udelay(700);
+	pll_val = __raw_readl(MXC_CCM_PDR1);
+	pll_val &= ~(MXC_CCM_PDR1_USB_PRDF_MASK | MXC_CCM_PDR1_USB_PODF_MASK);
+	pll_val |= ((1 << MXC_CCM_PDR1_USB_PRDF_OFFSET) |
+			(1 << MXC_CCM_PDR1_USB_PODF_OFFSET));
+	__raw_writel(pll_val, MXC_CCM_PDR1);
+	udelay(700);
+}
+
+
+static int __init mx3_usb_init(void)
+{
+#if defined(CONFIG_USB_OTG)
+	int rc;
+#endif
+
+	dbg();
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	clk_enable(usb_ahb_clk);
+
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	if (IS_ERR(usb_clk)) {
+		pr_debug("no usb_clk?\n");
+		return -ENODEV;
+	}
+	clk_enable(usb_clk);
+
+	fixup_usb_pll();
+#if defined(CONFIG_USB_OTG)
+	rc = platform_device_register(&isp1504_device);
+	if (rc)
+		pr_debug("can't register isp1504 dvc, %d\n", rc);
+	else {
+		printk(KERN_INFO "usb: isp1504 registered\n");
+		dbg("isp1504: platform_device_register succeeded.");
+		dbg("isp1504_device=0x%p  resources=0x%p.",
+				&isp1504_device, isp1504_device.resource);
+	}
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H1
+	usbh1_device = host_pdev_register(usbh1_resources,
+			ARRAY_SIZE(usbh1_resources),
+			&usbh1_config);
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+	usbh2_device = host_pdev_register(usbh2_resources,
+			ARRAY_SIZE(usbh2_resources),
+			&usbh2_config);
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS)
+	otg_hs_host_device = host_pdev_register(otg_resources,
+			ARRAY_SIZE(otg_resources),
+			&otg_hs_host_config);
+#elif defined(CONFIG_USB_EHCI_ARC_OTGFS)
+	otg_fs_host_device = host_pdev_register(otg_resources,
+			ARRAY_SIZE(otg_resources),
+			&otg_fs_host_config);
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+	rc = platform_device_register(&udc_device);
+	if (rc)
+		pr_debug("can't register OTG Gadget, %d\n", rc);
+	else
+		printk(KERN_INFO "usb: %s registered\n",
+				((struct arc_usb_config *)
+				 udc_device.dev.platform_data)->name);
+#endif
+	return 0;
+}
+
+subsys_initcall(mx3_usb_init);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 3265afe..3d65b1a 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -56,6 +56,7 @@ config USB_ARCH_HAS_EHCI
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
 	default y if ARCH_OMAP34XX
+	default y if ARCH_MX3
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 1839db1..94f9bc9 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -107,6 +107,34 @@ config USB_EHCI_FSL
 	---help---
 	  Variation of ARC USB block used in some Freescale chips.
 
+config USB_EHCI_ARC
+    bool "Support for ARC controller"
+    depends on USB_EHCI_HCD && ARCH_MX3
+    select USB_EHCI_ROOT_HUB_TT
+	select ISP1504_MXC if MACH_MX31LITE
+    ---help---
+       Some Freescale processors have an ARC High Speed
+       USBOTG controller, which supports EHCI host mode.
+
+       This driver supports the controller in the i.MX27 or i.MX31,
+       and should work with controllers in other Freescale
+       processors too, given minor tweaks.
+
+       Say "y" here to add support for this controller
+       to the EHCI HCD driver.
+
+config USB_EHCI_ARC_H1
+    bool "Support for Host1 port on ARC controller"
+    depends on USB_EHCI_ARC
+    ---help---
+      Enable support for the USB Host1 port.
+
+config USB_EHCI_ARC_H2
+    bool "Support for Host2 port on ARC controller"
+    depends on USB_EHCI_ARC
+    ---help---
+      Enable support for the USB Host2 port.
+
 config USB_EHCI_HCD_PPC_OF
 	bool "EHCI support for PPC USB controller on OF platform bus"
 	depends on USB_EHCI_HCD && PPC_OF
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
new file mode 100644
index 0000000..0c843c4
--- /dev/null
+++ b/drivers/usb/host/ehci-arc.c
@@ -0,0 +1,398 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ehci-arc.c
+ * @brief platform related part of usb host driver.
+ * @ingroup USB
+ */
+
+/* Note: this file is #included by ehci-hcd.c */
+
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <mach/arc_otg.h>
+#include <mach/isp1504.h>
+
+#ifdef CONFIG_ARCH_MX3
+#include <mach/mx31_usb.h>
+#endif
+
+static struct otg_transceiver *transceiver;
+
+/* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_fsl_probe - initialize FSL-based HCDs
+ * @drvier: Driver to be used for this HCD
+ * @pdev: USB Host Controller being probed
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller.
+ *
+ */
+static int usb_hcd_fsl_probe(const struct hc_driver *driver,
+		struct platform_device *pdev)
+{
+	struct arc_usb_config *pdata;
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	pr_debug("initializing FSL-SOC USB Controller\n");
+	/* Need platform data for setup */
+	pdata = (struct arc_usb_config *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+				"No platform data for %s.\n", pdev->dev.bus_id);
+		return -ENODEV;
+	}
+
+	retval = fsl_platform_verify(pdev);
+	if (retval)
+		return retval;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init()) {
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+				"Found HC with no IRQ. Check %s setup!\n",
+				pdev->dev.bus_id);
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	if (pdata->set_vbus_power)
+		pdata->set_vbus_power(1);
+
+	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+				"Found HC with no register addr."
+				"Check %s setup!\n",
+				pdev->dev.bus_id);
+		retval = -ENODEV;
+		goto err2;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	vdbg("start=0x%x   end=0x%x    rsrc_start=0x%llx  rsrc_len=0x%llx\n",
+			res->start, res->end, hcd->rsrc_start, hcd->rsrc_len);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&pdev->dev, "request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err2;
+	}
+
+	hcd->regs = (void __iomem *)IO_ADDRESS(hcd->rsrc_start);
+
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err3;
+	}
+
+	hcd->power_budget = pdata->power_budget;
+
+	/* DDD
+	 * the following must be done by this point, otherwise the OTG
+	 * host port doesn't make it thru initializtion.
+	 * ehci_halt(), called by ehci_fsl_setup() returns -ETIMEDOUT
+	 */
+	fsl_platform_set_host_mode(hcd);
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval != 0)
+		goto err3;
+
+#if defined(CONFIG_USB_OTG)
+	if (pdata->does_otg) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
+
+		transceiver = otg_get_transceiver()
+			dbg("ehci->transceiver=0x%p\n", transceiver);
+
+		if (transceiver) {
+			retval = otg_set_host(transceiver,
+					&ehci_to_hcd(ehci)->self);
+			dev_dbg(transceiver->dev,
+					"init %s transceiver, retval %d\n",
+					transceiver->label, retval);
+			if (retval) {
+				if (transceiver) {
+					put_device(transceiver->dev);
+					transceiver = NULL;
+				}
+				goto err3;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto err3;
+		}
+
+	}
+#endif
+
+	return retval;
+
+err3:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err2:
+	usb_put_hcd(hcd);
+err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit();
+	return retval;
+}
+
+static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
+		struct platform_device *pdev)
+{
+	struct arc_usb_config *pdata;
+	pdata = (struct arc_usb_config *)pdev->dev.platform_data;
+
+	dbg("%s  hcd=0x%p\n", __func__, hcd);
+
+	usb_remove_hcd(hcd);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	if (transceiver) {
+		(void)otg_set_host(transceiver, 0);
+		put_device(transceiver->dev);
+		transceiver = NULL;
+	}
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit();
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_fsl_reinit(struct ehci_hcd *ehci)
+{
+	fsl_platform_usb_setup(ehci_to_hcd(ehci));
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+/* called during probe() after chip reset completes */
+static int ehci_fsl_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* EHCI registers start at offset 0x00 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+		HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+	vdbg("%s(): ehci->caps=0x%p  ehci->regs=0x%p\n", __func__,
+			ehci->caps, ehci->regs);
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	retval = ehci_fsl_reinit(ehci);
+	return retval;
+}
+
+/* *INDENT-OFF* */
+static const struct hc_driver ehci_arc_hc_driver = {
+	.description	= hcd_name,
+	.product_desc	= "Freescale On-Chip EHCI Host Controller",
+	.hcd_priv_size	= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq		= ehci_irq,
+	.flags		= HCD_USB2 ,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset		= ehci_fsl_setup,
+	.start		= ehci_run,
+	.stop		= ehci_stop,
+	.shutdown   = ehci_shutdown,
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+};
+
+/* *INDENT-ON* */
+
+static struct ehci_regs usb_ehci_regs;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int ehci_arc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct arc_usb_config *config =
+		(struct arc_usb_config *)pdev->dev.platform_data;
+	u32 cmd;
+
+	dbg("%s pdev=0x%p  config=0x%p  ehci=0x%p  hcd=0x%p\n",
+			__func__, pdev, config, ehci, hcd);
+	dbg("%s ehci->regs=0x%p  hcd->regs=0x%p  hcd->state=%d\n",
+			__func__, ehci->regs, hcd->regs, hcd->state);
+	dbg("%s config->usbmode=0x%x  config->set_vbus_power=0x%p\n",
+			__func__, config->usbmode, config->set_vbus_power);
+
+#ifdef CONFIG_USB_OTG
+	hcd->state = HC_STATE_HALT;	/* ignore non-host interrupts */
+#endif
+
+	cmd = readl(&ehci->regs->command);
+	cmd &= ~CMD_RUN;
+	writel(cmd, &ehci->regs->command);
+
+	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
+	usb_ehci_regs.port_status[0] &=
+		cpu_to_le32(~(PORT_PEC | PORT_OCC | PORT_CSC));
+
+	if (config->set_vbus_power)
+		config->set_vbus_power(0);
+
+	return 0;
+}
+
+static int ehci_arc_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 cmd;
+	struct arc_usb_config *config =
+		(struct arc_usb_config *)pdev->dev.platform_data;
+
+	dbg("%s pdev=0x%p  config=0x%p  ehci=0x%p  hcd=0x%p\n",
+			__func__, pdev, config, ehci, hcd);
+	vdbg("%s ehci->regs=0x%p  hcd->regs=0x%p  usbmode=0x%x\n",
+			__func__, ehci->regs, hcd->regs, config->usbmode);
+
+	if (config->set_vbus_power)
+		config->set_vbus_power(1);
+
+	writel(USBMODE_CM_HOST, config->usbmode);
+	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
+
+	cmd = readl(&ehci->regs->command);
+	cmd |= CMD_RUN;
+	writel(cmd, &ehci->regs->command);
+
+#ifdef CONFIG_USB_OTG
+	hcd->state = HC_STATE_RUNNING;
+#endif
+
+	return 0;
+}
+
+static int ehci_hcd_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_hcd_fsl_probe(&ehci_arc_hc_driver, pdev);
+}
+
+static int __init_or_module ehci_hcd_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_fsl_remove(hcd, pdev);
+
+	return 0;
+}
+
+/* *INDENT-OFF* */
+static struct platform_driver ehci_fsl_driver = {
+	.probe   = ehci_hcd_drv_probe,
+	.remove  = ehci_hcd_drv_remove,
+	.suspend = ehci_arc_suspend,
+	.resume  = ehci_arc_resume,
+	.driver  = {
+		.name = "fsl-ehci",
+	},
+};
+/* *INDENT-ON* */
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f7c83e8..03f1ae7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1009,6 +1009,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_ARC
+#include "ehci-arc.c"
+#define PLATFORM_DRIVER     ehci_fsl_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
-- 
1.6.0.3

