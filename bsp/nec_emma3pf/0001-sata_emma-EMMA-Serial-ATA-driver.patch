From eef6a72c14d609b81c185ab36df4a2d53a41786e Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Tue, 28 Apr 2009 14:30:06 +0900
Subject: [PATCH] sata_emma: EMMA Serial ATA driver

Features:
* Serial ATA
  - 1ch, master only
  - 1.5Gbps transfer (150MByte/Sec)
  - 3.0Gbps transfer (300MByte/Sec)
* Compliant to Serial ATA (High Speed Serialized AT Attachment, Rev. 2.5)
* Power management support
* ATAPI support
* The followings are not supported
  - NCQ
  - PIO to DMA feature

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Chunbo Luo <chunbo.luo@windriver.com>
Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/ata/sata_emma.c |  519 +++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 519 insertions(+), 0 deletions(-)
 create mode 100644 drivers/ata/sata_emma.c

diff --git a/drivers/ata/sata_emma.c b/drivers/ata/sata_emma.c
new file mode 100644
index 0000000..f1411ce
--- /dev/null
+++ b/drivers/ata/sata_emma.c
@@ -0,0 +1,519 @@
+/*
+ * SATA driver for EMMA.
+ *
+ * Copyright (C) NEC Electronics Corporation 2007
+ *
+ * 2005-2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * This file was developed based on the following files:
+ * linux/drivers/scsi/sata_svw.c
+ * linux/drivers/scsi/libata-core.c
+ *
+ * History:
+ * Version 0.02	   Support DMA mode
+ * Version 0.01	   Support only PIO mode0.
+ *
+ * Changes:
+ * Wind River Systems, Inc.
+ * Ported to Linux 2.6.21 by Jack Tan <jack.tan@windriver.com>
+ * Ported to Linux 2.6.27 by Chunbo Luo <chunbo.luo@windriver.com>
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+#include <linux/platform_device.h>
+
+#define DRV_NAME	"sata_emma"
+#define DRV_VERSION	"0.02"
+
+/* Taskfile registers offsets */
+#define EMMA_SATA_TF_CMD_OFFSET		0x00
+#define EMMA_SATA_TF_DATA_OFFSET	0x02
+#define EMMA_SATA_TF_ERROR_OFFSET	0x07
+#define EMMA_SATA_TF_NSECT_OFFSET	0x0b
+#define EMMA_SATA_TF_LBAL_OFFSET	0x0f
+#define EMMA_SATA_TF_LBAM_OFFSET	0x13
+#define EMMA_SATA_TF_LBAH_OFFSET	0x17
+#define EMMA_SATA_TF_DEVICE_OFFSET	0x1b
+#define EMMA_SATA_TF_CMDSTAT_OFFSET    	0x1f
+#define EMMA_SATA_IF_CTL_ALT_OFFSET	0x28
+#define EMMA_SATA_TF_CTL_OFFSET		0x2b
+
+/* DMA offsets */
+#define EMMA_SATA_DMA_CMD_OFFSET	0x42
+#define EMMA_SATA_DMA_STATUS_OFFSET	0x40
+#define EMMA_SATA_DMA_TABLE_OFFSET	0x44
+
+/* SCRs offsets */
+#define EMMA_SATA_SCR_STATUS_OFFSET	0x80
+#define EMMA_SATA_SCR_ERROR_OFFSET	0x84
+#define EMMA_SATA_SCR_CONTROL_OFFSET	0x88
+#define EMMA_SATA_SCR_ERRCNT_OFFSET	0xd0
+
+/* sata INT control registers */
+#define EMMA_SATA_INT_OFFSET		0xb0
+#define EMMA_SATA_INT_EN_OFFSET		0xb4
+
+/* emma specific registers */
+#define	EMMA_SATA_BM_CTL_OFFSET		0x48
+#define EMMA_SATA_SCR_MISC_OFFSET	0xe0
+
+/* sata common register */
+#define EMMA_SATA_COMMON_OFFSET		0xf0
+
+static int emma_sata_get_scr_offset(unsigned int sc_reg)
+{
+	return 	(sc_reg == SCR_STATUS) 	? 0:
+		(sc_reg == SCR_ERROR) 	? 4:
+		(sc_reg == SCR_CONTROL)	? 8:-1;
+}
+
+static int emma_sata_scr_read (struct ata_port *ap, unsigned int sc_reg,
+			       u32 *val)
+{
+	int	offset = emma_sata_get_scr_offset(sc_reg);
+
+	if (offset < 0)
+		return -EINVAL;
+
+	*val = readl(ap->ioaddr.scr_addr + offset);
+
+	DPRINTK("0x%x 0x%x\n",
+		(unsigned int)(ap->ioaddr.scr_addr + offset), *val);
+	return 0;
+}
+
+static int emma_sata_scr_write (struct ata_port *ap, unsigned int sc_reg,
+			        u32 val)
+{
+	int	offset = emma_sata_get_scr_offset(sc_reg);
+
+	if (offset < 0)
+		return -EINVAL;
+
+	DPRINTK("0x%x 0x%x\n",
+		(unsigned int)(ap->ioaddr.scr_addr + offset), val);
+	writel(val, ap->ioaddr.scr_addr + offset);
+	return 0;
+}
+
+/**
+ *	emma_bmdma_setup_mmio - Set up PCI IDE BMDMA transaction (MMIO)
+ *	@qc: Info associated with this ATA transaction.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+static void emma_bmdma_setup_mmio (struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);
+	u16 dmactl;
+	void __iomem *mmio = ap->ioaddr.bmdma_addr;
+
+	DPRINTK(" ENTER \n");
+	/* load PRD table addr. */
+	mb();	/* make sure PRD table writes are visible to controller */
+	writel(ap->prd_dma, mmio + EMMA_SATA_DMA_TABLE_OFFSET);
+
+	/* specify data direction, triple-check start bit is clear */
+	dmactl = readw(mmio + EMMA_SATA_DMA_CMD_OFFSET);
+	/* clear PRD_INEX */
+	dmactl &= 0xf;
+
+	dmactl &= ~(ATA_DMA_WR | ATA_DMA_START);
+	if (!rw)
+		dmactl |= ATA_DMA_WR;
+	writew(dmactl, mmio + EMMA_SATA_DMA_CMD_OFFSET);
+
+	ap->ops->sff_exec_command(ap, &qc->tf);
+
+	DPRINTK("EXIT \n");
+}
+
+/**
+ *	emma_bmdma_start_mmio - Start a PCI IDE BMDMA transaction (MMIO)
+ *	@qc: Info associated with this ATA transaction.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+static void emma_bmdma_start_mmio (struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *mmio = ap->ioaddr.bmdma_addr;
+	u16 dmactl;
+
+	/* start host DMA transaction */
+	dmactl = readw(mmio + EMMA_SATA_DMA_CMD_OFFSET);
+	writew(dmactl | ATA_DMA_START, mmio + EMMA_SATA_DMA_CMD_OFFSET);
+	DPRINTK("0x%x, 0x%x\n",	dmactl | ATA_DMA_START,
+		(unsigned int)(mmio + EMMA_SATA_DMA_CMD_OFFSET));
+	/* There is a race condition in certain SATA controllers that can
+	   be seen when the r/w command is given to the controller before
+	   the host DMA is started. On a Read command, the controller would
+	   initiate the command to the drive even before it sees the DMA start.
+	   When there are very fast drives connected to the controller,or when
+	   the data request hits in the drive cache, there is the possibility
+	   that the drive returns a part or all of the requested data to the
+	   controller before the DMA start is issued. In this case, the
+	   controller would become confused as to what to do with the data.
+	   In the worst case  when all the data is returned back to the
+	   controller, the controller could hang. In other cases it could
+	   return partial data returning in data corruption. This problem
+	   has been seen in PPC systems and can also appear on an system
+	   with very fast disks, where the SATA controller is sitting
+	   behind a number of bridges, and hence there is significant
+	   latency between the r/w command and the start command. */
+}
+
+static inline u8 emma_sata_bmdma_status(struct ata_port *ap)
+{
+	u16 host_stat;
+	void __iomem *mmio = ap->ioaddr.bmdma_addr;
+	host_stat = (u8)readw(mmio + EMMA_SATA_DMA_STATUS_OFFSET);
+
+	DPRINTK("0x%x, 0x%x\n",
+		(unsigned int)(mmio + EMMA_SATA_DMA_STATUS_OFFSET), host_stat);
+	return host_stat;
+}
+
+static inline void emma_sata_bmdma_stop(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->ioaddr.bmdma_addr;
+
+	/* clear start/stop bit */
+	writew(readw(mmio + EMMA_SATA_DMA_CMD_OFFSET) & ~ATA_DMA_START,
+			mmio + EMMA_SATA_DMA_CMD_OFFSET);
+}
+
+static inline void emma_sata_bmdma_ack_irq(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->ioaddr.bmdma_addr + EMMA_SATA_DMA_STATUS_OFFSET;
+	writew(readw(mmio), mmio);
+}
+
+unsigned int emma_sata_host_intr (struct ata_port *ap,
+				  struct ata_queued_cmd *qc)
+{
+	u8 status, host_stat;
+
+	switch (qc->tf.protocol) {
+
+	case ATA_PROT_DMA:
+	case ATAPI_PROT_DMA:
+	case ATAPI_PROT_PIO:
+		/* check status of DMA engine */
+		host_stat = emma_sata_bmdma_status(ap);
+		DPRINTK("ata%u: host_stat 0x%x\n", ap->print_id, host_stat);
+
+		/* if it's not our irq... */
+		if (!(host_stat & ATA_DMA_INTR))
+			goto idle_irq;
+
+		/* before we do anything else, clear DMA-Start bit */
+		emma_sata_bmdma_stop(ap);
+
+		/* fall through */
+
+	case ATAPI_PROT_NODATA:
+	case ATA_PROT_NODATA:
+		/* check altstatus */
+		if(ap->ops->sff_check_altstatus)
+			status = ap->ops->sff_check_altstatus(ap);
+		else if(ap->ioaddr.altstatus_addr)
+			status = ioread8(ap->ioaddr.altstatus_addr);
+		else
+			status = 0;
+
+		if (status & ATA_BUSY)
+			goto idle_irq;
+
+		/* check main status, clearing INTRQ */
+		status = ap->ops->sff_check_status(ap);
+		if (unlikely(status & ATA_BUSY))
+			goto idle_irq;
+		DPRINTK("ata%u: protocol %d (dev_stat 0x%x)\n",
+			ap->print_id, qc->tf.protocol, status);
+
+		/* ack bmdma irq events */
+		emma_sata_bmdma_ack_irq(ap);
+
+		/* complete taskfile transaction */
+		ata_qc_complete(qc);
+		break;
+
+	default:
+		goto idle_irq;
+	}
+
+	return 1;	/* irq handled */
+
+idle_irq:
+	ap->stats.idle_irq++;
+
+#ifdef ATA_IRQ_TRAP
+	if ((ap->stats.idle_irq % 1000) == 0) {
+		handled = 1;
+		ata_irq_ack(ap, 0); /* debug trap */
+		printk(KERN_WARNING "ata%d: irq trap\n", ap->id);
+	}
+#endif
+	return 0;	/* irq not handled */
+}
+
+irqreturn_t emma_sata_interrupt (int irq, void *dev_instance)
+{
+	struct ata_host *host_set = dev_instance;
+	unsigned int i;
+	unsigned int handled = 0;
+	unsigned long flags;
+
+	/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */
+	spin_lock_irqsave(&host_set->lock, flags);
+
+	for (i = 0; i < host_set->n_ports; i++) {
+		struct ata_port *ap;
+
+		ap = host_set->ports[i];
+		if (ap && (!(ap->flags & ATA_FLAG_DISABLED))) {
+			struct ata_queued_cmd *qc;
+			qc = ata_qc_from_tag(ap, ap->link.active_tag);
+			if (qc && (!(qc->tf.ctl & ATA_TFLAG_POLLING)))
+				handled |= emma_sata_host_intr(ap, qc);
+		}
+	}
+
+	spin_unlock_irqrestore(&host_set->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static void emma_bmdma_irq_clear(struct ata_port *ap)
+{
+	u16	dmasts;
+	void __iomem *mmio = ap->ioaddr.bmdma_addr + EMMA_SATA_DMA_STATUS_OFFSET;
+
+	dmasts = readw(mmio);
+	dmasts |= 0x4;
+	writew(dmasts, mmio);
+	DPRINTK("0x%x, 0x%x\n", dmasts, (unsigned int)(mmio));
+}
+
+static unsigned int emma_mmio_data_xfer(struct ata_device *adev,
+					unsigned char *buf,unsigned int buflen,
+				       	int write_data)
+{
+	struct ata_port *ap = adev->link->ap;
+	unsigned int i;
+	unsigned int words = buflen >> 1;
+	u16 *buf16 = (u16 *) buf;
+	void __iomem *mmio = (void __iomem *)ap->ioaddr.bmdma_addr;
+
+	DPRINTK("ENTER\n");
+
+	/* Transfer multiple of 2 bytes */
+	if (write_data) {
+		for (i = 0; i < words; i++)
+			writew(le16_to_cpu(buf16[i]),
+			       mmio + EMMA_SATA_TF_DATA_OFFSET);
+	} else {
+		for (i = 0; i < words; i++)
+			buf16[i] = cpu_to_le16(readw(mmio +
+						EMMA_SATA_TF_DATA_OFFSET));
+	}
+
+	/* Transfer trailing 1 byte, if any. */
+	if (unlikely(buflen & 0x01)) {
+		u16 align_buf[1] = { 0 };
+		unsigned char *trailing_buf = buf + buflen - 1;
+
+		if (write_data) {
+			memcpy(align_buf, trailing_buf, 1);
+			writew(le16_to_cpu(align_buf[0]),
+			       mmio + EMMA_SATA_TF_DATA_OFFSET);
+		} else {
+			align_buf[0] = cpu_to_le16(readw(mmio +
+						EMMA_SATA_TF_DATA_OFFSET));
+			memcpy(trailing_buf, align_buf, 1);
+		}
+		words++;
+	}
+
+	DPRINTK("EXIT\n");
+	return words << 1;
+
+}
+
+static struct scsi_host_template emma_sata_sht = {
+	ATA_BMDMA_SHT(DRV_NAME),
+};
+
+static struct ata_port_operations emma_sata_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+	.scr_read		= emma_sata_scr_read,
+	.scr_write		= emma_sata_scr_write,
+	.bmdma_setup		= emma_bmdma_setup_mmio,
+	.bmdma_start		= emma_bmdma_start_mmio,
+	.sff_irq_clear		= emma_bmdma_irq_clear,
+	.sff_data_xfer		= emma_mmio_data_xfer,
+};
+
+static void emma_sata_setup_port(struct ata_ioports *port, void __iomem *base)
+{
+	port->cmd_addr		= base + EMMA_SATA_TF_CMD_OFFSET;
+	port->data_addr		= base + EMMA_SATA_TF_DATA_OFFSET;
+	port->feature_addr	=
+	port->error_addr	= base + EMMA_SATA_TF_ERROR_OFFSET;
+	port->nsect_addr	= base + EMMA_SATA_TF_NSECT_OFFSET;
+	port->lbal_addr		= base + EMMA_SATA_TF_LBAL_OFFSET;
+	port->lbam_addr		= base + EMMA_SATA_TF_LBAM_OFFSET;
+	port->lbah_addr		= base + EMMA_SATA_TF_LBAH_OFFSET;
+	port->device_addr	= base + EMMA_SATA_TF_DEVICE_OFFSET;
+	port->command_addr	=
+	port->status_addr	= base + EMMA_SATA_TF_CMDSTAT_OFFSET;
+	port->altstatus_addr	=
+	port->ctl_addr		= base + EMMA_SATA_TF_CTL_OFFSET;
+	port->bmdma_addr	= base;
+	port->scr_addr		= base + EMMA_SATA_SCR_STATUS_OFFSET;
+}
+
+static const struct ata_port_info emma_sata_port_info = {
+	.flags		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY
+			| ATA_FLAG_MMIO | ATA_FLAG_PIO_POLLING
+			| ATA_FLAG_SATA_RESET,
+	.pio_mask	= 0x1f,
+	.mwdma_mask	= 0x07,
+	.udma_mask	= 0x7f,
+	.port_ops	= &emma_sata_ops,
+};
+
+static void emma_sata_deactivate_device(unsigned long base)
+{
+	u32 scr;
+
+	/* Disable the Serial ATA interface and put Phy in offline mode. */
+	scr = readl((void __iomem *)(base + EMMA_SATA_SCR_CONTROL_OFFSET));
+	scr &= ~0x0000000fUL;
+	scr |=  0x00000004UL;
+	writel(scr, (void __iomem *)(base + EMMA_SATA_SCR_CONTROL_OFFSET));
+}
+
+static void emma_sata_clear_serr(unsigned long base)
+{
+	u32 serror;
+
+	serror = readl((void __iomem *)(base + EMMA_SATA_SCR_ERROR_OFFSET));
+	writel(serror, (void __iomem *)(base + EMMA_SATA_SCR_ERROR_OFFSET));
+	writel(0x0000ffffUL,(void __iomem *)base + EMMA_SATA_SCR_ERRCNT_OFFSET);
+}
+
+static int emma_sata_init_one(struct platform_device *pdev)
+{
+	static int printed_version;
+	const struct ata_port_info *ppi[] =
+		{ &emma_sata_port_info,NULL };
+	struct ata_host *host;
+	unsigned long base;
+	void __iomem *mmio_base;
+	struct resource *r;
+
+	DPRINTK("emma_sata_init_one start\n");
+
+	if (!printed_version++)
+		printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	r = platform_get_resource(pdev, 0, /*IORESOURCE_MEM,*/ 0);
+	if (!r)
+	{
+		DPRINTK(KERN_ERR ":%d\n", __LINE__);
+		return -EINVAL;
+	}
+
+	mmio_base = (void*)r->start;
+	base = (unsigned long)mmio_base;
+
+	DPRINTK("mmio_base = 0x%x\n", base);
+
+	/* allocate host */
+	host = ata_host_alloc_pinfo(&pdev->dev,ppi,1);
+
+	if (!host)
+		return -ENOMEM;
+
+	host->iomap = mmio_base;
+
+	DPRINTK("emma initialize start\n");
+
+	/* endian/swap ctl */
+	writel(0x2, (void *)(base + EMMA_SATA_BM_CTL_OFFSET));
+
+	/* staggered spin up for channel1-2 */
+	writel(0x10000, (void *)(base + EMMA_SATA_SCR_MISC_OFFSET));
+
+	emma_sata_setup_port(&host->ports[0]->ioaddr, mmio_base);
+
+	/* deactivate port */
+	emma_sata_deactivate_device(base);
+
+	/* clear sata error */
+	emma_sata_clear_serr(base);
+
+	/* interrupt enable */
+	writel(0x2, (void *)(base + EMMA_SATA_IF_CTL_ALT_OFFSET));
+	writel(0x1, (void *)(base + EMMA_SATA_INT_EN_OFFSET));
+
+	return ata_host_activate(host, platform_get_irq(pdev,0),
+				 emma_sata_interrupt,IRQF_SHARED,
+				 &emma_sata_sht);
+}
+
+static int __devexit emma_sata_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_detach(host);
+	return 0;
+}
+
+static struct platform_driver emma_sata_driver = {
+	.probe		= emma_sata_init_one,
+	.remove		= __devexit_p(emma_sata_remove),
+	.driver		= {
+			   .name = DRV_NAME,
+			   .owner = THIS_MODULE,
+			  },
+};
+
+static int __init emma_sata_init (void)
+{
+	int	rc;
+
+	rc = platform_driver_register(&emma_sata_driver);
+	return rc;
+}
+
+static void __exit emma_sata_exit (void)
+{
+	platform_driver_unregister(&emma_sata_driver);
+}
+
+MODULE_AUTHOR("NEC Electronics Corporation <www.necel.com>");
+MODULE_DESCRIPTION("low-level driver for emma SATA controller");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(emma_sata_init);
+module_exit(emma_sata_exit);
-- 
1.6.0.4

