From add6f508a4127d20f684baff91edb33419a0d577 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Tue, 28 Apr 2009 14:33:08 +0900
Subject: [PATCH] USB: EMMA3PF USB EHCI/OHCI driver

EMMA3PF has the USB host controllers which complies with the USB spec rev.
2.0 and OHCI spec rev. 1.0a for full-/low- signaling, and Intel' EHCI spec
rev. 1.0 for high-speed signaling.  The host core consists of 2 host
controllers with PCI interface and USB 2.0 transceivers.  This core is
connected to flip bus bridge internally, and acts as if it's a PCI device.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/usb/host/ehci-emma.c |  265 +++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/ehci-hcd.c  |    5 +
 drivers/usb/host/ohci-emma.c |  281 ++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/ohci-hcd.c  |    5 +
 4 files changed, 556 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/host/ehci-emma.c
 create mode 100644 drivers/usb/host/ohci-emma.c

diff --git a/drivers/usb/host/ehci-emma.c b/drivers/usb/host/ehci-emma.c
new file mode 100644
index 0000000..62e896f
--- /dev/null
+++ b/drivers/usb/host/ehci-emma.c
@@ -0,0 +1,265 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ * Bus Glue for NEC EMMA3PF
+ * Based on "ehci-au1xxx.c"
+ *
+ * Author: NEC Electronics Corporation
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <asm/emma/emmaxxx.h>
+
+/* ftop registers */
+#define EMMA_FLIP_REGBASE	(0xb0200100)
+#define EMMA_FLIP_M0_CTR	(0x0)
+#define EMMA_FLIP_USB_CTR	(0x20)
+
+#define FLIP_OCI1_EN		(0x00100000UL)
+#define FLIP_OCI2_EN		(0x00200000UL)
+#define FLIP_PPON1_EN		(0x00400000UL)
+#define FLIP_PPON2_EN		(0x00800000UL)
+#define FLIP_OCI1_ACT		(0x00010000UL)
+#define FLIP_OCI2_ACT		(0x00020000UL)
+#define FLIP_PPON1_ACT		(0x00040000UL)
+#define FLIP_PPON2_ACT		(0x00080000UL)
+#define FLIP_ENDIAN_SWAP	(0x00000002UL)
+
+/* ftop pseudo pci */
+#define EHCI_CONFBASE		(0xb0200500UL)
+#define OHCI_CONFBASE		(0xb0200200UL)
+#define PCI_CONFIG		EHCI_CONFBASE
+#define	PCI_CMD_MEM_ENABLE	(0x0002)
+#define	PCI_CMD_MASTER_ENABLE	(0x0004)
+
+static int emma_flip_init(void)
+{
+	u32	d;
+
+	writel(0x00ff0900, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_USB_CTR));
+
+	d = readl((void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+	d |= FLIP_ENDIAN_SWAP;
+	writel(d, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+
+	return 0;
+}
+
+static void emma_pseudo_pci_init(struct platform_device *dev)
+{
+	struct resource *res;
+	int		irq;
+	u32		d;
+
+	res = platform_get_resource_byname(dev, IORESOURCE_MEM, "ehci_mem");
+	irq = platform_get_irq_byname(dev, "ehci_irq");
+
+	/* PCI BAR */
+	writel(CPHYSADDR(res->start), (void *)(PCI_CONFIG + 0x10));
+
+	/* PCI interrupt line */
+	d = readl((void *)(PCI_CONFIG + 0x3c));
+	d &= ~0xff;
+	d |= irq;
+	writel(d, (void *)(PCI_CONFIG + 0x3c));
+
+	/* PCI command status */
+	writel(PCI_CMD_MASTER_ENABLE|PCI_CMD_MEM_ENABLE,
+	       (void *)(PCI_CONFIG + 0x4));
+}
+
+static void emma_start_ehc(struct platform_device *dev)
+{
+	pr_debug(__FILE__ ": starting EMMA EHCI USB Controller\n");
+
+	emma_flip_init();
+	emma_pseudo_pci_init(dev);
+
+	pr_debug(__FILE__ ": Clock to USB host has been enabled\n");
+}
+
+static void emma_stop_ehc(struct platform_device *dev)
+{
+	pr_debug(__FILE__ ": stopping EMMA EHCI USB Controller\n");
+}
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_ehci_emma_probe - initialize EMMA-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_ehci_emma_probe(const struct hc_driver *driver,
+			struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd	*hcd;
+	struct ehci_hcd *ehci;
+	struct resource *res;
+	int		irq;
+
+	res = platform_get_resource_byname(dev, IORESOURCE_MEM, "ehci_mem");
+	if (!res) {
+		pr_debug("Found EMMA_HC with no MEM. Check %s setup!\n",
+			 dev->dev.bus_id);
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	irq = platform_get_irq_byname(dev, "ehci_irq");
+	if (irq == -ENXIO) {
+		pr_debug("Found EMMA_HC with no IRQ. Check %s setup!\n",
+			 dev->dev.bus_id);
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	hcd = usb_create_hcd(driver, &dev->dev, "emma-ehci");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = (u64)res->start;
+	hcd->rsrc_len = (u64)(res->end - res->start + 1);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = (void __iomem *)((u32)hcd->rsrc_start);
+
+	emma_start_ehc(dev);
+
+	/* fix  some ehci registers */
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+	/* !!!!!!! cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_SHARED);
+	if (retval == 0)
+		return retval;
+
+	emma_stop_ehc(dev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_ehci_emma_remove - shutdown processing for EMMA-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_emma_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_ehci_emma_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	emma_stop_ehc(dev);
+}
+
+static const struct hc_driver ehci_emma_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "EMMA EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+};
+
+static int ehci_hcd_emma_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	pr_debug("In ehci_hcd_emma_drv_probe\n");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_ehci_emma_probe(&ehci_emma_hc_driver, pdev);
+	return ret;
+}
+
+static int ehci_hcd_emma_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ehci_emma_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ehci_hcd_emma_driver = {
+	.probe		= ehci_hcd_emma_drv_probe,
+	.remove		= ehci_hcd_emma_drv_remove,
+	.driver = {
+		.name	= "emma-ehci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:emma-ehci");
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fd666ce..115a29d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1011,6 +1011,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
+#ifdef CONFIG_EMMA_HAS_USB_EHCI
+#include "ehci-emma.c"
+#define PLATFORM_DRIVER		ehci_hcd_emma_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
diff --git a/drivers/usb/host/ohci-emma.c b/drivers/usb/host/ohci-emma.c
new file mode 100644
index 0000000..6160e8d
--- /dev/null
+++ b/drivers/usb/host/ohci-emma.c
@@ -0,0 +1,281 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ * Bus Glue for NEC EMMA3PF
+ * Based on "ohci-lh7a404.c"
+ *
+ * Author: NEC Electronics Corporation
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <asm/emma/emmaxxx.h>
+
+/* ftop registers */
+#define EMMA_FLIP_REGBASE	(0xb0200100)
+#define EMMA_FLIP_M0_CTR	(0x0)
+#define EMMA_FLIP_USB_CTR	(0x20)
+
+#define FLIP_OCI1_EN		(0x00100000UL)
+#define FLIP_OCI2_EN		(0x00200000UL)
+#define FLIP_PPON1_EN		(0x00400000UL)
+#define FLIP_PPON2_EN		(0x00800000UL)
+#define FLIP_OCI1_ACT		(0x00010000UL)
+#define FLIP_OCI2_ACT		(0x00020000UL)
+#define FLIP_PPON1_ACT		(0x00040000UL)
+#define FLIP_PPON2_ACT		(0x00080000UL)
+#define FLIP_ENDIAN_SWAP	(0x00000002UL)
+
+/* ftop pseudo pci */
+#define EHCI_CONFBASE		(0xb0200500UL)
+#define OHCI_CONFBASE		(0xb0200200UL)
+#define PCI_CONFIG		OHCI_CONFBASE
+#define	PCI_CMD_MEM_ENABLE	(0x0002)
+#define	PCI_CMD_MASTER_ENABLE	(0x0004)
+
+static int emma_flip_init(void)
+{
+	u32	d;
+
+	writel(0x00ff0900, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_USB_CTR));
+
+	d = readl((void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+	d |= FLIP_ENDIAN_SWAP;
+	writel(d, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+
+	return 0;
+}
+
+static void emma_pseudo_pci_init(struct platform_device *dev)
+{
+	struct resource *res;
+	int		irq;
+	u32		d;
+
+	res = platform_get_resource_byname(dev, IORESOURCE_MEM, "ohci_mem");
+	irq = platform_get_irq_byname(dev, "ohci_irq");
+
+	/* PCI BAR */
+	writel(CPHYSADDR(res->start), (void *)(PCI_CONFIG + 0x10));
+
+	/* PCI interrupt line */
+	d = readl((void *)(PCI_CONFIG + 0x3c));
+	d &= ~0xff;
+	d |= irq;
+	writel(d, (void *)(PCI_CONFIG + 0x3c));
+
+	/* PCI command status */
+	writel(PCI_CMD_MASTER_ENABLE|PCI_CMD_MEM_ENABLE,
+	       (void *)(PCI_CONFIG + 0x4));
+}
+
+static void emma_start_hc(struct platform_device *dev)
+{
+	pr_debug(__FILE__ ": starting EMMA OHCI USB Controller\n");
+
+	emma_flip_init();
+	emma_pseudo_pci_init(dev);
+
+	pr_debug(__FILE__ ": Clock to USB host has been enabled\n");
+}
+
+static void emma_stop_hc(struct platform_device *dev)
+{
+	pr_debug(__FILE__ ": stopping EMMA OHCI USB Controller\n");
+}
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_emma_probe - initialize EMMA-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_hcd_emma_probe(const struct hc_driver *driver,
+		       struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd	*hcd;
+	struct resource *res;
+	int		irq;
+
+	res = platform_get_resource_byname(dev, IORESOURCE_MEM, "ohci_mem");
+	if (!res) {
+		pr_debug("Found EMMA_HC with no MEM. Check %s setup!\n",
+			 dev->dev.bus_id);
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	irq = platform_get_irq_byname(dev, "ohci_irq");
+	if (irq == -ENXIO) {
+		pr_debug("Found EMMA_HC with no IRQ. Check %s setup!\n",
+			 dev->dev.bus_id);
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	hcd = usb_create_hcd(driver, &dev->dev, "emma-ohci");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = (u64)res->start;
+	hcd->rsrc_len = (u64)(res->end - res->start + 1);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = (void __iomem *)((u32)hcd->rsrc_start);
+
+	emma_start_hc(dev);
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_SHARED);
+	if (retval == 0)
+		return retval;
+
+	emma_stop_hc(dev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_emma_remove - shutdown processing for EMMA-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_emma_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_emma_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	emma_stop_hc(dev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static int __devinit ohci_emma_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int		ret;
+
+	ohci_dbg(ohci, "ohci_emma_start, ohci:%p", ohci);
+	ret = ohci_init(ohci);
+	if (ret  < 0)
+		return ret;
+
+	ret = ohci_run(ohci);
+	if (ret < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+	return 0;
+}
+
+static const struct hc_driver ohci_emma_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "EMMA OHCI",
+	.hcd_priv_size		= sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ohci_irq,
+	.flags			= HCD_MEMORY | HCD_USB11,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start			= ohci_emma_start,
+#ifdef	CONFIG_PM
+	/* suspend:		ohci_lh7a404_suspend,  -- tbd */
+	/* resume:		ohci_lh7a404_resume,   -- tbd */
+#endif /*CONFIG_PM*/
+	.stop			= ohci_stop,
+	.shutdown		= ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ohci_bus_suspend,
+	.bus_resume		= ohci_bus_resume,
+#endif
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static int ohci_hcd_emma_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	pr_debug("In ohci_hcd_emma_drv_probe\n");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_emma_probe(&ohci_emma_hc_driver, pdev);
+	return ret;
+}
+
+static int ohci_hcd_emma_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_emma_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_emma_driver = {
+	.probe		= ohci_hcd_emma_drv_probe,
+	.remove		= ohci_hcd_emma_drv_remove,
+	.driver = {
+		.name	= "emma-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:emma-ohci");
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8bec02c..be1b2cc 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1063,6 +1063,11 @@ MODULE_LICENSE ("GPL");
 #define OF_PLATFORM_DRIVER	ohci_hcd_ppc_of_driver
 #endif
 
+#ifdef CONFIG_EMMA_HAS_USB_OHCI
+#include "ohci-emma.c"
+#define PLATFORM_DRIVER		ohci_hcd_emma_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ohci-ps3.c"
 #define PS3_SYSTEM_BUS_DRIVER	ps3_ohci_driver
-- 
1.6.0.4

