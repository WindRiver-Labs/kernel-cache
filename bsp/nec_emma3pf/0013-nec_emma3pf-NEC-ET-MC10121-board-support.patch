From 9f3805d838b1e0f0985295f74b2b61cd4ea108a2 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Tue, 28 Apr 2009 14:35:30 +0900
Subject: [PATCH] nec_emma3pf: NEC ET-MC10121 board support

ET-MC10121 is EMMA3PF evaluation board manufactured by NEC Electronics.
This patch adds support for a few of the system peripherals, I2C, SATA,
UART, USB HCs, and ethernet MAC.  On-board NOR flash and LED devices are
available as well.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 arch/mips/Kconfig                 |    6 +
 arch/mips/Makefile                |    6 +
 arch/mips/emma/et10121/Makefile   |   13 ++
 arch/mips/emma/et10121/init.c     |   28 +++++
 arch/mips/emma/et10121/irq.c      |  138 ++++++++++++++++++++++
 arch/mips/emma/et10121/led.c      |  188 +++++++++++++++++++++++++++++
 arch/mips/emma/et10121/platform.c |  235 +++++++++++++++++++++++++++++++++++++
 arch/mips/emma/et10121/setup.c    |  151 ++++++++++++++++++++++++
 8 files changed, 765 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/emma/et10121/Makefile
 create mode 100644 arch/mips/emma/et10121/init.c
 create mode 100644 arch/mips/emma/et10121/irq.c
 create mode 100644 arch/mips/emma/et10121/led.c
 create mode 100644 arch/mips/emma/et10121/platform.c
 create mode 100644 arch/mips/emma/et10121/setup.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 8b5c2be..1f12744 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -257,6 +257,12 @@ config MARKEINS
 	  This enables support for the R5432-based NEC Mark-eins
 	  boards with R5500 CPU.
 
+config NEC_ET10121
+	bool "NEC EMMA3PF ET-MC10121 board"
+	select SOC_EMMA3PF
+	help
+	  This enables support for the NEC Electroncis ET-MC10121 board.
+
 config MACH_VR41XX
 	bool "NEC VR4100 series based machines"
 	select CEVT_R4K
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 3690634..f763ee1 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -419,6 +419,12 @@ core-$(CONFIG_SOC_EMMA)		+= arch/mips/emma/common/
 cflags-$(CONFIG_SOC_EMMA3PF)	+= -Iinclude/asm-mips/mach-emma3pf
 
 #
+# NEC EMMA3PF ET-MC10121
+#
+core-$(CONFIG_NEC_ET10121)	+= arch/mips/emma/et10121/
+load-$(CONFIG_NEC_ET10121)	+= 0xffffffff80040000
+
+#
 # SGI IP22 (Indy/Indigo2)
 #
 # Set the load address to >= 0xffffffff88069000 if you want to leave space for
diff --git a/arch/mips/emma/et10121/Makefile b/arch/mips/emma/et10121/Makefile
new file mode 100644
index 0000000..cfbe256
--- /dev/null
+++ b/arch/mips/emma/et10121/Makefile
@@ -0,0 +1,13 @@
+#
+#  arch/mips/emma/et10121/Makefile
+#       Makefile for the common code of NEC EMMA3PF based board.
+#
+#  Copyright (C) NEC Electronics Corporation 2005-2009
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+
+obj-y		:= init.o irq.o led.o platform.o setup.o
diff --git a/arch/mips/emma/et10121/init.c b/arch/mips/emma/et10121/init.c
new file mode 100644
index 0000000..47f46e9
--- /dev/null
+++ b/arch/mips/emma/et10121/init.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/init.h>
+
+#include <asm/bootinfo.h>
+#include <asm/emma/prom.h>
+
+const char *get_system_type(void)
+{
+	return "NEC EMMA3PF ET-MC10121";
+}
+
+void __init prom_init(void)
+{
+	prom_init_cmdline();
+
+	/*
+	 * 256MB + 128MB
+	 */
+	add_memory_region(0, 0x10000000, BOOT_MEM_RAM);
+	add_memory_region(0x10000000, 0x08000000, BOOT_MEM_RAM);
+}
diff --git a/arch/mips/emma/et10121/irq.c b/arch/mips/emma/et10121/irq.c
new file mode 100644
index 0000000..6818593
--- /dev/null
+++ b/arch/mips/emma/et10121/irq.c
@@ -0,0 +1,138 @@
+/*
+ *  arch/mips/emma/et10121/irq.c
+ *      This file defines the irq handler for ET10121.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2009
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/irq.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/mipsregs.h>
+#include <asm/irq_cpu.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/irq.h>
+#include <asm/emma/bhif.h>
+#include <asm/emma/gpio.h>
+
+/*
+ * IRQ mapping
+ *
+ *  0-7: 8 CPU interrupts
+ *	0 -	software interrupt 0
+ *	1 - 	software interrupt 1
+ *	2 - 	most Vrc5477 interrupts are routed to this pin
+ *	3 - 	(optional) some other interrupts routed to this pin for debugg
+ *	4 - 	not used
+ *	5 - 	not used
+ *	6 - 	not used
+ *	7 - 	cpu timer (used by default)
+ *
+ */
+
+void emma_irq_dispatch(void)
+{
+	u32 status;
+	u32 bitmask;
+	u32 i;
+
+	status = emma_in32(EMMA_BHIF_INT_ST_0) &
+		 emma_in32(EMMA_BHIF_INT_EN_0);
+
+#ifdef EMMA_SW_CASCADE
+	if (status & (1UL << ((EMMA_SW_CASCADE - EMMA_IRQ_BASE) % 32))) {
+		u32 sw_int_status;
+
+		sw_int_status = emma_in32(EMMA_BHIF_SW_INT) &
+				emma_in32(EMMA_BHIF_SW_INT_EN);
+		for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+			if (sw_int_status & bitmask) {
+				do_IRQ(EMMA_SW_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+#endif
+
+	for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	status = emma_in32(EMMA_BHIF_INT_ST_1) &
+		 emma_in32(EMMA_BHIF_INT_EN_1);
+
+#ifdef CONFIG_HW_HAS_PCI
+	if (status & (1UL << ((EMMA_GPIO_CASCADE - EMMA_IRQ_BASE) % 32))) {
+		u32 gpio_int_status;
+
+		gpio_int_status = emma_in32(EMMA_GPIO0_INT) &
+				  emma_in32(EMMA_GPIO0_INT_CPUMEN);
+		for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+			if (gpio_int_status & bitmask) {
+				do_IRQ(EMMA_GPIO_IRQ_BASE + i);
+				return;
+			}
+		}
+
+		gpio_int_status = emma_in32(EMMA_GPIO1_INT) &
+				  emma_in32(EMMA_GPIO1_INT_CPUMEN);
+		for (i = 32, bitmask = 1UL; i < 64; i++, bitmask <<= 1) {
+			if (gpio_int_status & bitmask) {
+				do_IRQ(EMMA_GPIO_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+#endif
+
+	for (i = 32, bitmask = 1UL; i < 64; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+}
+
+void __init arch_init_irq(void)
+{
+	/* by default, interrupts are disabled. */
+	emma_out32(EMMA_BHIF_INT_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT_EN_2, 0);
+	emma_out32(EMMA_BHIF_SW_INT_EN, 0);
+
+	clear_c0_status(0xff00);
+	set_c0_status(0x0400);
+
+	/* init all controllers */
+	mips_cpu_irq_init();
+	bhif_irq_init();
+	bhif_sw_irq_init();
+#ifdef CONFIG_HW_HAS_PCI
+	gpio_irq_init();
+#endif
+
+	/* setup cascade interrupts */
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(EMMA_SW_CASCADE, &irq_cascade);
+	setup_irq(EMMA_GPIO_CASCADE, &irq_cascade);
+}
diff --git a/arch/mips/emma/et10121/led.c b/arch/mips/emma/et10121/led.c
new file mode 100644
index 0000000..b596533
--- /dev/null
+++ b/arch/mips/emma/et10121/led.c
@@ -0,0 +1,188 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc.
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <asm/timex.h>
+#include <asm/emma/emmaxxx.h>
+
+#define	LED_BASE	(EMMA_GPIO0_BASE + 0x3c)
+#define	GPIO_LED	0x003f8000
+
+#ifdef TEST_LED_WHEN_INIT
+
+static inline void emma_udelay(unsigned long usecs)
+{
+	cycles_t cycles = get_cycles();
+	cycles_t end_cycles = cycles + usecs * mips_hpt_frequency * 2 / 100000;
+	do {
+		cycles = get_cycles();
+	} while (cycles < end_cycles);
+}
+
+static inline void emma_mdelay(unsigned long msecs)
+{
+	do {
+		emma_udelay(1000);
+	} while (msecs--);
+}
+#endif
+
+void et10121_led_init(void)
+{
+	u32 reg;
+	reg = emma_in32(EMMA_GPIO0_DIR);
+	emma_out32(EMMA_GPIO0_DIR, reg | GPIO_LED);
+}
+
+static inline void et10121_led_clear(void)
+{
+	emma_out32(LED_BASE, 0);
+	emma_out32(LED_BASE + 0x4, 0);
+	emma_out32(LED_BASE + 0x8, 0);
+	emma_out32(LED_BASE + 0xc, 0);
+	emma_out32(LED_BASE + 0x10, 0);
+	emma_out32(LED_BASE + 0x14, 0);
+	emma_out32(LED_BASE + 0x18, 0);
+}
+
+/*show all */
+static inline void et10121_led_all(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+	emma_out32(LED_BASE + 0xc, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+}
+
+/* show S */
+static inline void et10121_led_start(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+	emma_out32(LED_BASE + 0xc, 1);
+}
+
+/* show R */
+static inline void et10121_led_restart(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+}
+
+/* show P */
+static inline void et10121_led_poweroff(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+}
+
+/* show H */
+static inline void et10121_led_halted(void)
+{
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+}
+
+void show_default(int c)
+{
+	int i;
+	for (i = 0; i < c; i++) {
+		et10121_led_all();
+#ifdef TEST_LED_WHEN_INIT
+		emma_mdelay(500);
+#else
+		mdelay(500);
+#endif
+		et10121_led_clear();
+#ifdef TEST_LED_WHEN_INIT
+		emma_mdelay(300);
+#else
+		mdelay(300);
+#endif
+	}
+}
+
+static void show_restart(int c)
+{
+	int i;
+	for (i = 0; i < c; i++) {
+		et10121_led_restart();
+		mdelay(500);
+		et10121_led_clear();
+		mdelay(300);
+	}
+}
+
+static void show_poweroff(int c)
+{
+	int i;
+	for (i = 0; i < c; i++) {
+		et10121_led_poweroff();
+		mdelay(500);
+		et10121_led_clear();
+		mdelay(300);
+	}
+}
+
+static void show_halted(int c)
+{
+	int i;
+	for (i = 0; i < c; i++) {
+		et10121_led_halted();
+		mdelay(500);
+		et10121_led_clear();
+		mdelay(300);
+	}
+}
+
+void et10121_led(const char *str)
+{
+	switch (str[0]) {
+	case 'r':
+		show_restart(5);
+		break;
+	case 'p':
+		show_poweroff(5);
+		break;
+	case 'h':
+		show_halted(5);
+		break;
+	default:
+		show_default(5);
+		break;
+	}
+}
diff --git a/arch/mips/emma/et10121/platform.c b/arch/mips/emma/et10121/platform.c
new file mode 100644
index 0000000..e6b3aef
--- /dev/null
+++ b/arch/mips/emma/et10121/platform.c
@@ -0,0 +1,235 @@
+/*
+ *  arch/mips/emma/et10121/platform.c
+ *      This file sets up platform devices for EMMA3PF ET10121.
+ *
+ *  Copyright(C) MontaVista Software Inc, 2006
+ *
+ *  Author: dmitry pervushin <dpervushin@ru.mvista.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/addrspace.h>
+#include <asm/emma/emmaxxx.h>
+#include <linux/nec_candy_pd.h>
+
+#define I2C_EMMA "emma-iic" /* must be in sync with IIC driver */
+#define SERIAL_EMMA "serial8250"
+#define NAND_ET10121 "et10121-nand"
+#define SATA_EMMA "sata_emma" /* must be in sync with sata_emma.c DRV_NAME */
+
+static struct resource i2c_emma_resources_0[] = {
+	{
+		.name	= NULL,
+		.start	= EMMA_IRQ_PIIC0,
+		.end	= EMMA_IRQ_PIIC0,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.name	= NULL,
+		.start	= KSEG1ADDR(EMMA_PIIC0_BASE),
+		.end	= KSEG1ADDR(EMMA_PIIC0_BASE + 0x1000),
+	}, {
+		.name	= "pbrd",
+		.start	= KSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= KSEG1ADDR(EMMA_PBRD_BASE + 0x1000),
+	}
+};
+
+struct resource i2c_emma_resources_1[] = {
+	{
+		.name	= NULL,
+		.start	= EMMA_IRQ_PIIC1,
+		.end	= EMMA_IRQ_PIIC1,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.name	= NULL,
+		.start	= KSEG1ADDR(EMMA_PIIC1_BASE),
+		.end	= KSEG1ADDR(EMMA_PIIC1_BASE + 0x1000),
+	}, {
+		.name	= "pbrd",
+		.start	= KSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= KSEG1ADDR(EMMA_PBRD_BASE + 0x1000),
+	}
+};
+
+struct platform_device i2c_emma_devices[] = {
+	[0] = {
+		.name		= I2C_EMMA,
+		.id		= 0,
+		.resource	= i2c_emma_resources_0,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_0),
+	},
+};
+
+#define EMMA_SATA_PORT_OFFSET	0x0100
+
+static struct resource sata_emma_resources0[] = {
+	{
+		.name	= NULL,
+		.start	= EMMA_IRQ_KSATA0,
+		.end	= EMMA_IRQ_KSATA0,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.name	= NULL,
+		.start	= KSEG1ADDR(EMMA_SATA_PORT_BASE + EMMA_SATA_PORT_OFFSET * 0),
+		.end	= KSEG1ADDR(EMMA_SATA_PORT_BASE + EMMA_SATA_PORT_OFFSET * 1),
+		.flags	= 0 /*IORESOURCE_MEM*/
+	}
+};
+
+struct platform_device sata_emma_devices[] = {
+	[0] = {
+		.name		= SATA_EMMA,
+		.id		= 0,
+		.resource	= sata_emma_resources0,
+		.num_resources	= ARRAY_SIZE(sata_emma_resources0),
+	}
+};
+
+#define EMMA3P_MAC_FLASH	0xbfe20000
+
+static struct nec_candy_platform_data nec_candy_pdata = {
+	.pmd_addr	= 0x1f,
+	.rmii		= 1,
+	.clks		= MIIC_CLKS166,
+};
+
+static struct platform_device nec_candy_device = {
+	.name			= "nec_candy",
+	.id			= 0,
+	.dev.platform_data	= &nec_candy_pdata,
+	.num_resources		= 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start	= CPHYSADDR(EMMA_ETHER_BASE),
+			.end	= CPHYSADDR(EMMA_ETHER_BASE + 0x400),
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start	= EMMA_IRQ_ETHER,
+			.end	= EMMA_IRQ_ETHER,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static u64 ohci_dmamask = ~(u32)0;
+static struct platform_device emma_ohci = {
+	.name = "emma-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "ohci_mem",
+			.start	= KSEG1ADDR(EMMA_OHCI_BASE),
+			.end	= KSEG1ADDR(EMMA_OHCI_BASE + 0xff),
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "ohci_irq",
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+static struct platform_device emma_ehci = {
+	.name = "emma-ehci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "ehci_mem",
+			.start	= KSEG1ADDR(EMMA_EHCI_BASE),
+			.end	= KSEG1ADDR(EMMA_EHCI_BASE + 0xff),
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "ehci_irq",
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static struct platform_device *devices[] = {
+	&i2c_emma_devices[0],
+	&emma_ohci,
+	&emma_ehci,
+	&sata_emma_devices[0],
+	&nec_candy_device,
+};
+
+#ifdef CONFIG_MTD
+static struct mtd_partition et10121_parts[] = {
+	[0] = {
+		.name	= "Root FS",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x01500000,
+	},
+	[1] = {
+		.name	= "kernel image",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00700000,
+	},
+	[2] = {
+		.name	= "boot code area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00200000,
+	},
+	[3] = {
+		.name	= "boot env area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00040000,
+		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	[4] = {
+		.name	= "Free Area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x001C0000,
+	},
+};
+#endif
+
+static int __init platform_devices_setup(void)
+{
+#ifdef CONFIG_MTD
+	physmap_set_partitions(et10121_parts, ARRAY_SIZE(et10121_parts));
+#endif
+	memcpy(nec_candy_pdata.mac_addr, (void *) EMMA3P_MAC_FLASH, 6);
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+arch_initcall(platform_devices_setup);
diff --git a/arch/mips/emma/et10121/setup.c b/arch/mips/emma/et10121/setup.c
new file mode 100644
index 0000000..09ba7b9
--- /dev/null
+++ b/arch/mips/emma/et10121/setup.c
@@ -0,0 +1,151 @@
+/*
+ *  arch/mips/emma/et10121/setup.c
+ *      This file is setup for EMMA3PF ET10121.
+ *
+ *  Changes:
+ *	Wind River Systems, Inc.
+ *	- Make kgdb 8250 work properly. Jack Tan <jack.tan@windriver.com>
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2009
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/setup.c.
+ *
+ *  Copyright 2001 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+#include <linux/kgdb.h>
+
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <asm/emma/emmaxxx.h>
+
+extern void et10121_led(const char *);
+static int bus_frequency;
+
+static void et10121_machine_restart(char *command)
+{
+	static void (*back_to_prom) (void) = (void (*)(void))0xbfc00000;
+
+	printk(KERN_INFO "EMMA3PF ET10121 restart.\n");
+	et10121_led("restart");
+	back_to_prom();
+}
+
+static void et10121_machine_halt(void)
+{
+	printk(KERN_INFO "EMMA3PF ET10121 halted.\n");
+	et10121_led("halted");
+	while (1)
+		;
+}
+
+static void et10121_machine_power_off(void)
+{
+	printk(KERN_INFO "EMMA3PF ET10121 halted. Please turn off the power.\n");
+	et10121_led("poweroff");
+	while (1)
+		;
+}
+
+#ifdef CONFIG_EMMA_SUBCPU
+static unsigned long emma_clock[4] = { 109333000, 164000000, 218667000, 328000000 };
+#else
+static unsigned long emma_clock[4] = { 328000000, 262400000, 0, 0 };
+#endif
+
+static unsigned int __init detect_bus_frequency(unsigned long rtc_base)
+{
+	u32 reg;
+
+	/* detect from boot strap */
+	reg = emma_in32(EMMA_BHIF_CLKSEL);
+#ifdef CONFIG_EMMA_SUBCPU
+	reg = (reg >> 4) & 0x3;
+#else
+	reg = reg & 0x1;
+#endif
+	return emma_clock[reg];
+}
+
+void __init plat_time_init(void)
+{
+	if (bus_frequency == 0)
+		bus_frequency = detect_bus_frequency(0);
+
+	mips_hpt_frequency = bus_frequency / 2;
+}
+
+static inline void __init et10121_sio_setup(void)
+{
+	struct uart_port emma_port;
+#ifdef CONFIG_KGDB
+	int emma_uart;
+#endif
+
+	memset(&emma_port, 0, sizeof(emma_port));
+
+	emma_port.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	emma_port.iotype = UPIO_DWAPB;
+	emma_port.regshift = 2;	/* I/O addresses are every 8 bytes */
+	emma_port.uartclk = 24000000;	/* Clock rate of the chip */
+
+	emma_port.line = 0;
+	emma_port.mapbase = KSEG1ADDR(EMMA_PUART0_BASE + 3);
+	emma_port.membase = (u8 *)emma_port.mapbase;
+	emma_port.private_data = (void *)(emma_port.membase + 0x7c);
+	emma_port.irq = EMMA_IRQ_PUART0;
+	early_serial_setup(&emma_port);
+
+#ifdef CONFIG_KGDB
+#ifdef CONFIG_KGDB_SIMPLE_SERIAL
+	emma_uart = CONFIG_KGDB_PORT_NUM;
+#else
+	emma_uart = 1;
+#endif
+	emma_port.line = emma_uart;
+	emma_port.mapbase = KSEG1ADDR(EMMA_PUART0_BASE + 0x1000 * emma_uart + 3);
+	emma_port.membase = (u8 *)emma_port.mapbase;
+	emma_port.private_data = (void *)(emma_port.membase + 0x7c);
+	emma_port.irq = EMMA_IRQ_PUART0 + emma_uart;
+	early_serial_setup(&emma_port);
+#ifdef CONFIG_KGDB_8250_NOMODULE
+	kgdb8250_add_port(emma_uart, &emma_port);
+#endif
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(KSEG1);
+
+	_machine_restart = et10121_machine_restart;
+	_machine_halt = et10121_machine_halt;
+	pm_power_off = et10121_machine_power_off;
+
+	/* setup resource limits */
+	ioport_resource.end = ~0;
+
+	/* Reboot on panic */
+	panic_timeout = 50;
+
+	et10121_sio_setup();
+}
-- 
1.6.0.4

