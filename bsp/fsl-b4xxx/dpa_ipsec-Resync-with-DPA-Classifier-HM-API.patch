From aa516479b069e2a59ef43b5b1fdc41e575df976a Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:58:51 +0000
Subject: [PATCH 244/518] dpa_ipsec: Resync with DPA Classifier HM API

DPA Classifier HM API was updated. The DPA IPSec component is using
the header manipulation for the configuration of IP fragmentation
and special offloading features, hence it required some re-sync effort.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  134 +++++++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   12 +-
 2 files changed, 83 insertions(+), 63 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index dfa2cc3..84ddc88 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -35,6 +35,7 @@
 
 #include "dpa_ipsec.h"
 #include "dpa_ipsec_desc.h"
+#include "dpa_classifier.h"
 
 #include "fm_common.h"
 #include "fm_pcd.h"
@@ -1116,7 +1117,7 @@ static int fill_policy_key(int td,
  */
 static inline void fill_cls_action_enq(struct dpa_cls_tbl_action *action_prm,
 				       int en_stats, uint32_t new_fqid,
-				       struct dpa_cls_tbl_header_manip *hmanip)
+				       int hmd)
 {
 	action_prm->type = DPA_CLS_TBL_ACTION_ENQ;
 	action_prm->enable_statistics = en_stats;
@@ -1126,7 +1127,7 @@ static inline void fill_cls_action_enq(struct dpa_cls_tbl_action *action_prm,
 	} else
 		action_prm->enq_params.override_fqid = FALSE;
 	action_prm->enq_params.policer_params = NULL;
-	action_prm->enq_params.hm = hmanip;
+	action_prm->enq_params.hmd = hmd;
 }
 
 static inline void fill_cls_action_drop(struct dpa_cls_tbl_action *action,
@@ -1139,13 +1140,15 @@ static inline void fill_cls_action_drop(struct dpa_cls_tbl_action *action,
 
 static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 			     struct dpa_ipsec_pol_frag_params *out_frag,
-			     struct dpa_cls_tbl_header_manip **hm)
+			     int *frag_hmd)
 {
 	t_FmPcdManipFragParams *frag_param;
+	int err;
+	t_Handle hm;
 
 	BUG_ON(!dpa_ipsec);
 	BUG_ON(!out_frag);
-	BUG_ON(!hm);
+	BUG_ON(!frag_hmd);
 
 	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
 	frag_param = &pcd_manip_params.u.frag;
@@ -1155,28 +1158,34 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	frag_param->u.ipFrag.scratchBpid = dpa_ipsec->config.ipf_bpid;
 	frag_param->u.ipFrag.dontFragAction =
 					pcd_df_action[out_frag->df_action];
-	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
-	if (!*hm) {
+	hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
+	if (!hm) {
 		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
 		return -EBUSY;
 	}
 
-	return 0;
+	err = dpa_classif_import_static_hm(hm, DPA_OFFLD_DESC_NONE, frag_hmd);
+	if (err < 0)
+		pr_err("%s: Failed to import IP fragmentation into DPA "
+			"Classifier.\n", __func__);
+
+	return err;
 }
 
-static int create_ipsec_manip(struct dpa_ipsec_sa *sa, void *next_manip,
-			      void **manip)
+static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd,
+	int *hmd)
 {
-	t_FmPcdManipParams			pcd_manip_params;
-	t_FmPcdManipSpecialOffloadParams	*offld_params;
-	void					*ipsec_manip = NULL;
+	t_FmPcdManipParams pcd_manip_params;
+	t_FmPcdManipSpecialOffloadParams *offld_params;
+	t_Handle hm;
+	int err;
 
 	BUG_ON(!sa);
-	BUG_ON(!manip);
+	BUG_ON(!hmd);
 
 	if (!sa->use_var_iphdr_len && !sa->dscp_copy && !sa->ecn_copy) {
 		/* no need to create a manipulation object */
-		*manip = NULL;
+		*hmd = DPA_OFFLD_DESC_NONE;
 		return 0;
 	}
 
@@ -1189,28 +1198,33 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa, void *next_manip,
 	offld_params->u.ipsec.variableIpHdrLen = sa->use_var_iphdr_len;
 	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
 	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
-	pcd_manip_params.h_NextManip = next_manip;
-	ipsec_manip = FM_PCD_ManipNodeSet(sa->dpa_ipsec->config.fm_pcd,
+	pcd_manip_params.h_NextManip =
+				dpa_classif_get_static_hm_handle(next_hmd);
+	hm = FM_PCD_ManipNodeSet(sa->dpa_ipsec->config.fm_pcd,
 				     &pcd_manip_params);
-	if (!ipsec_manip) {
+	if (!hm) {
 		pr_err("%s: FM_PCD_ManipSetNode failed!\n", __func__);
 		return -EBUSY;
 	}
-	*manip = ipsec_manip;
 
-	return 0;
+	err = dpa_classif_import_static_hm(hm, next_hmd, hmd);
+	if (err < 0)
+		pr_err("%s: Failed to import header manipulation into DPA "
+			"Classifier.\n", __func__);
+
+	return err;
 }
 
-static int destroy_manip(void *hm)
+static int destroy_manip(int hmd)
 {
-	t_Error fmd_err;
+	int err = 0;
 
-	BUG_ON(!hm);
+	BUG_ON(hmd == DPA_OFFLD_DESC_NONE);
 
-	fmd_err = FM_PCD_ManipNodeDelete((t_Handle)hm);
-	if (fmd_err != E_OK) {
-		pr_err("%s: FM_PCD_ManipNodeDelete failed!\n", __func__);
-		return -EBUSY;
+	err = dpa_classif_free_hm(hmd);
+	if (err < 0) {
+		pr_err("%s: Failed to remove header manip!\n", __func__);
+		return err;
 	}
 
 	return 0;
@@ -1299,9 +1313,9 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	uint8_t key_len, table_idx, key_fields;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
-	struct dpa_cls_tbl_header_manip *hm = NULL;
 	struct dpa_cls_tbl_entry_mod_params params;
 	int table, err;
+	int hmd;
 
 	BUG_ON(!sa);
 	BUG_ON(!policy_entry);
@@ -1348,28 +1362,29 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 						DPA_IPSEC_POL_DIR_PARAMS_FRAG) {
 			err = create_frag_manip(dpa_ipsec,
 					       &pol_params->dir_params.out_frag,
-					       &hm);
+					       &policy_entry->hmd);
 			if (err < 0) {
 				pr_err("Could not create Manip node for fragmentation!\n");
 				return -EAGAIN;
 			}
 		}
 
-		/* Store the header manipulation into the policy entry */
-		policy_entry->hm = hm;
-
 		/* Init IPSec Manip. object (if required) for outbound policy */
-		err = create_ipsec_manip(sa, hm, &policy_entry->ipsec_manip);
+		err = create_ipsec_manip(sa,
+					policy_entry->hmd,
+					&policy_entry->ipsec_hmd);
 		if (err < 0) {
 			xx_pr_err("Could not create Manip obj for policy!\n");
 			return err;
 		}
-		if (policy_entry->ipsec_manip)
-			hm = policy_entry->ipsec_manip;
+		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE)
+			hmd = policy_entry->ipsec_hmd;
+		else
+			hmd = policy_entry->hmd;
 
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-				    qman_fq_fqid((sa->to_sec_fq)), hm);
+				    qman_fq_fqid((sa->to_sec_fq)), hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 					      policy_entry->pol_params.priority,
@@ -1387,34 +1402,34 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			return err;
 		}
 
-		if (policy_entry->ipsec_manip) {
-			err = destroy_manip(policy_entry->ipsec_manip);
+		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
+			err = destroy_manip(policy_entry->ipsec_hmd);
 			if (err < 0) {
 				xx_pr_err("Couldn't delete ipsec manip\n");
 				return err;
 			}
-			policy_entry->ipsec_manip = NULL;
+			policy_entry->ipsec_hmd = DPA_OFFLD_DESC_NONE;
 		}
 
-		if (policy_entry->hm) {
-			err = destroy_manip(policy_entry->hm);
+		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE) {
+			err = destroy_manip(policy_entry->hmd);
 			if (err < 0) {
 				pr_err("Couldn't delete frag manip\n");
 				return err;
 			}
-			policy_entry->hm = NULL;
+			policy_entry->hmd = DPA_OFFLD_DESC_NONE;
 		}
 		break;
 	case MNG_OP_MODIFY:
-		if (policy_entry->ipsec_manip)
-			hm = policy_entry->ipsec_manip;
+		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE)
+			hmd = policy_entry->ipsec_hmd;
 		else
-			hm = policy_entry->hm;
+			hmd = policy_entry->hmd;
 
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
 				    qman_fq_fqid((sa->to_sec_fq)),
-				    policy_entry->hm);
+				    policy_entry->hmd);
 
 		memset(&params, 0, sizeof(params));
 		params.type = DPA_CLS_TBL_MODIFY_ACTION;
@@ -1528,7 +1543,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		/* Complete the parameters for table insert function */
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-			qman_fq_fqid((sa->to_sec_fq)), sa->ipsec_manip);
+			qman_fq_fqid((sa->to_sec_fq)), sa->ipsec_hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
@@ -2622,13 +2637,14 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 	}
 	sa->inbound_hash_entry = -1;
 
-	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
-		err_rb = destroy_manip(sa->ipsec_manip);
+	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
+			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
+		err_rb = destroy_manip(sa->ipsec_hmd);
 		if (err_rb < 0) {
 			xx_pr_err("Could not delete manip object!\n");
 			return err_rb;
 		}
-		sa->ipsec_manip = NULL;
+		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
 	}
 
 
@@ -2679,13 +2695,14 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 	}
 	sa->inbound_hash_entry = -1;
 
-	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
-		err_rb = destroy_manip(sa->ipsec_manip);
+	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
+			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
+		err_rb = destroy_manip(sa->ipsec_hmd);
 		if (err_rb < 0) {
 			xx_pr_err("Could not delete manip object!\n");
 			return err_rb;
 		}
-		sa->ipsec_manip = NULL;
+		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
 	}
 
 	err_rb = remove_sa_fq_pair(sa);
@@ -2837,7 +2854,8 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
-		err = create_ipsec_manip(sa, NULL, &sa->ipsec_manip);
+		err = create_ipsec_manip(sa, DPA_OFFLD_DESC_NONE,
+			&sa->ipsec_hmd);
 		if (err < 0) {
 			xx_pr_err("Could not create Manip object for in SA!\n");
 			goto create_sa_err;
@@ -2985,13 +3003,14 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 				return err;
 		}
 
-		if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
-			err = destroy_manip(sa->ipsec_manip);
+		if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
+				(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
+			err = destroy_manip(sa->ipsec_hmd);
 			if (err < 0) {
 				xx_pr_err("Could not delete manip object!\n");
 				return err;
 			}
-			sa->ipsec_manip = NULL;
+			sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
 		}
 
 		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
@@ -3519,7 +3538,8 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
 	if (new_sa->sa_dir == DPA_IPSEC_INBOUND) {
-		err = create_ipsec_manip(new_sa, NULL, &new_sa->ipsec_manip);
+		err = create_ipsec_manip(new_sa, DPA_OFFLD_DESC_NONE,
+			&new_sa->ipsec_hmd);
 		if (err < 0) {
 			xx_pr_err("Could not create Manip object for in SA!\n");
 			goto rekey_sa_err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 127a293..1b106d4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -58,11 +58,11 @@
 /* MACRO declaration */
 #define PCD_DF_ACTION	{				\
 	/* DPA_IPSEC_DF_ACTION_DISCARD */		\
-	e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET,	\
+	DPA_CLS_HM_DF_ACTION_DROP,			\
 	/* DPA_IPSEC_DF_ACTION_OVERRIDE */		\
-	e_FM_PCD_MANIP_FRAGMENT_PACKET,		\
+	DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY,		\
 	/* DPA_IPSEC_DF_ACTION_CONTINUE */		\
-	e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG		\
+	DPA_CLS_HM_DF_ACTION_DONT_FRAG			\
 }
 
 #define OP_PCL_IPSEC_INVALID_ALG_ID	0xFFFF
@@ -287,7 +287,7 @@ struct dpa_ipsec_sa {
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
 	bool use_var_iphdr_len; /* Enable variable IP header length support   */
-	void *ipsec_manip; /* Manip object for special IPSec functions     */
+	int ipsec_hmd;		/* Manip object for special IPSec functions   */
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 	uint8_t l2_hdr_size; /* Size of the Ethernet header, including any
 			      * VLAN information.			      */
@@ -345,8 +345,8 @@ struct dpa_ipsec {
 struct dpa_ipsec_policy_entry {
 	struct dpa_ipsec_policy_params pol_params; /* Policy parameters       */
 	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
-	struct dpa_cls_tbl_header_manip *hm;	/* Header manip for frag      */
-	void *ipsec_manip; /* Manip obj used for special IPSec functions      */
+	int hmd;		/* Header manip for frag      */
+	int ipsec_hmd; /* Manip obj used for special IPSec functions      */
 	struct list_head node;	/* Node in linked list			      */
 };
 
-- 
1.7.5.4

