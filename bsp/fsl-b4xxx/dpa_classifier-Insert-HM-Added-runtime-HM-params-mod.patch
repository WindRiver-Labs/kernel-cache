From 9a4b0672febd271144f2bca57da32f7de8308dbe Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 20:03:13 +0000
Subject: [PATCH 304/518] dpa_classifier: Insert HM - Added runtime HM params
 modification option

Implemented runtime modification feature for the insert header
manipulation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  138 +++++++++++++++++++++-
 1 files changed, 135 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 45e1818..76b66cf 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3832,9 +3832,141 @@ int dpa_classif_modify_insert_hm(int hmd,
 	const struct dpa_cls_hm_insert_params *new_insert_params,
 	int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Insert HM runtime modification not "
-		"supported yet.\n", __FILE__, __func__, __LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm *pinsert_hm;
+	unsigned int size = 0;
+	uint8_t offset = 0;
+	uint8_t *pdata = NULL;
+	struct dpa_cls_hm_node *hm_node;
+	bool update = false;
+	int mask;
+	t_Error error;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	xx_sanity_check_return_value(new_insert_params, "new_insert_params",
+		-EINVAL);
+	xx_sanity_check_return_value(((hmd >= 0) &&
+		(hmd < hm_array.num_descriptors)), "hmd", -EINVAL);
+	xx_sanity_check_return_value(hm_array.object[hmd], "hmd", -EINVAL);
+
+	pinsert_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pinsert_hm->type != DPA_CLS_HM_TYPE_INSERT) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an INSERT type header manip.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	BUG_ON(pinsert_hm->num_nodes < 1);
+	BUG_ON(!pinsert_hm->hm_node[0]);
+
+	hm_node = pinsert_hm->hm_node[0];
+
+	switch (pinsert_hm->insert_params.type) {
+	case DPA_CLS_HM_INSERT_ETHERNET:
+		mask = DPA_CLS_HM_INS_MOD_ETH_HEADER |
+			DPA_CLS_HM_INS_MOD_NUM_QTAGS |
+			DPA_CLS_HM_INS_MOD_QTAGS_ARRAY |
+			DPA_CLS_HM_INS_MOD_PPPoE_HEADER;
+		if ((modify_flags & mask) == 0)
+			break;
+		if (modify_flags & DPA_CLS_HM_INS_MOD_NUM_QTAGS) {
+			if (new_insert_params->eth.num_tags >
+				pinsert_hm->insert_params.eth.num_tags) {
+				size = sizeof(struct ethhdr) +
+					(new_insert_params->eth.num_tags *
+					sizeof(struct vlan_header));
+				kfree(hm_node->params.u.hdr.insrtParams.u.
+							generic.p_Data);
+				pdata = kzalloc(size, GFP_KERNEL);
+				if (!pdata) {
+					pr_err("ERROR: %s, %s (%d): Not enough "
+						"memory for insert HM.\n",
+						__FILE__, __func__, __LINE__);
+					return -ENOMEM;
+				}
+				hm_node->params.u.hdr.insrtParams.u.generic.
+								p_Data = pdata;
+			}
+
+			pinsert_hm->insert_params.eth.num_tags =
+						new_insert_params->eth.num_tags;
+		} else
+			pdata = hm_node->params.u.hdr.insrtParams.u.generic.
+									p_Data;
+
+		if (pinsert_hm->insert_params.eth.num_tags) {
+			/* Copy Ethernet header data except the EtherType */
+			memcpy(pdata,
+				&pinsert_hm->insert_params.eth.eth_header,
+				sizeof(struct ethhdr) - ETHERTYPE_SIZE);
+			offset += (uint8_t)(sizeof(struct ethhdr) -
+								ETHERTYPE_SIZE);
+			/* Copy the VLAN tags */
+			memcpy(&pdata[offset],
+				&pinsert_hm->insert_params.eth.qtag,
+				pinsert_hm->insert_params.eth.num_tags *
+				sizeof(struct vlan_header));
+			offset += (uint8_t) (pinsert_hm->insert_params.eth.
+				num_tags * sizeof(struct vlan_header));
+			/* Copy the EtherType */
+			memcpy(&pdata[offset],
+		&pinsert_hm->insert_params.eth.eth_header.h_proto,
+				ETHERTYPE_SIZE);
+			offset = 0;
+		} else
+			/* Copy the entire Ethernet header */
+			memcpy(pdata,
+				&pinsert_hm->insert_params.eth.eth_header,
+				sizeof(struct ethhdr));
+		update = true;
+		break;
+	case DPA_CLS_HM_INSERT_PPP:
+		if ((modify_flags & DPA_CLS_HM_INS_MOD_PPP_PID) == 0)
+			break;
+
+		/* Copy the PPP PID */
+		memcpy(pdata, &pinsert_hm->insert_params.ppp_pid,
+			PPP_HEADER_SIZE);
+		update = true;
+		break;
+	case DPA_CLS_HM_INSERT_CUSTOM:
+		if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_OFFSET) {
+			hm_node->params.u.hdr.insrtParams.u.generic.offset =
+				new_insert_params->custom.offset;
+			update = true;
+		}
+		if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_SIZE) {
+			hm_node->params.u.hdr.insrtParams.u.generic.size =
+				new_insert_params->custom.size;
+			update = true;
+		}
+		if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_DATA) {
+			hm_node->params.u.hdr.insrtParams.u.generic.p_Data =
+				new_insert_params->custom.data;
+			update = true;
+		}
+		break;
+	default:
+		/* Should never get here */
+		BUG_ON(false);
+	}
+
+	if (update) {
+		error = FM_PCD_ManipNodeReplace(hm_node->node,
+						&hm_node->params);
+		if (error != E_OK) {
+			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeReplace "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_modify_insert_hm);
 
-- 
1.7.5.4

