From 70a8f048dfc2a32275fb6d4b98b1ea6915a068df Mon Sep 17 00:00:00 2001
From: alexandru Badicioiu <Alexandru.Badicioiu@freescale.com>
Date: Mon, 13 Feb 2012 17:24:12 +0000
Subject: [PATCH 097/518] DPA offloading driver use case

The use case shows ip acceleration offloading (IPsec, IP framentation,
IP reassembly) functions usage integrated with standard Linux IPsec
manual keying configuration tools.
It works together with USDPAA offload_demo application to implement
mixed kernel/user space data flows.

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Kconfig            |    7 +-
 drivers/staging/fsl_dpa_offload/usecases/Kconfig   |   15 +
 drivers/staging/fsl_dpa_offload/usecases/Makefile  |   18 +
 .../staging/fsl_dpa_offload/usecases/dip_init.c    |  182 +++
 .../staging/fsl_dpa_offload/usecases/dip_init.h    |   64 +
 .../usecases/dts/p3041ds-usdpaa.dts                |  241 ++++
 .../usecases/dts/p4080ds-usdpaa.dts                |  281 ++++
 .../usecases/dts/p5020ds-usdpaa.dts                |  227 ++++
 .../staging/fsl_dpa_offload/usecases/eth_utils.c   |  219 ++++
 .../staging/fsl_dpa_offload/usecases/fm_utils.c    |  282 ++++
 .../fsl_dpa_offload/usecases/fmc/fmc_config.xml    |   11 +
 .../fsl_dpa_offload/usecases/fmc/fmc_policy.xml    |  147 +++
 .../staging/fsl_dpa_offload/usecases/fmc_config.c  | 1362 ++++++++++++++++++++
 .../fsl_dpa_offload/usecases/fmc_config_ipsec.c    |  138 ++
 drivers/staging/fsl_dpa_offload/usecases/main.c    |  207 +++
 .../fsl_dpa_offload/usecases/platform_defs.h       |  127 ++
 drivers/staging/fsl_dpa_offload/usecases/pools.h   |   37 +
 .../staging/fsl_dpa_offload/usecases/ports_conf.h  |   59 +
 drivers/staging/fsl_dpa_offload/usecases/queues.c  |  187 +++
 .../staging/fsl_dpa_offload/usecases/queues_conf.h |   85 ++
 .../staging/fsl_dpa_offload/usecases/softparse.h   |  299 +++++
 drivers/staging/fsl_dpa_offload/usecases/utils.h   |  107 ++
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |  672 ++++++++++
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.h |   50 +
 .../staging/fsl_dpa_offload/usecases/xfrm_utils.c  |  231 ++++
 25 files changed, 5254 insertions(+), 1 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/Kconfig
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/Makefile
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dip_init.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dip_init.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p3041ds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/eth_utils.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_config.xml
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_policy.xml
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc_config_ipsec.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/main.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/pools.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/queues.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/queues_conf.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/softparse.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/utils.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c

diff --git a/drivers/staging/fsl_dpa_offload/Kconfig b/drivers/staging/fsl_dpa_offload/Kconfig
index 022848e..ae7be42 100644
--- a/drivers/staging/fsl_dpa_offload/Kconfig
+++ b/drivers/staging/fsl_dpa_offload/Kconfig
@@ -13,4 +13,9 @@ config FSL_DPA_OFFLOAD
 		      SEC 4.x.
 
 		To compile this driver as a module, choose M here. The module
-		will be called dpa_offload.
\ No newline at end of file
+		will be called dpa_offload.
+
+menu "IP acceleration usecases "
+depends on FSL_DPA_OFFLOAD
+source drivers/staging/fsl_dpa_offload/usecases/Kconfig
+endmenu
diff --git a/drivers/staging/fsl_dpa_offload/usecases/Kconfig b/drivers/staging/fsl_dpa_offload/usecases/Kconfig
new file mode 100644
index 0000000..9002d46
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/Kconfig
@@ -0,0 +1,15 @@
+config FSL_IPACC_USECASES
+tristate "DPA offloading usecases"
+depends on FSL_DPA_OFFLOAD
+default m
+
+menu "Plaform options"
+depends on FSL_IPACC_USECASES
+config P4080_BUILD
+	bool "P4080DS platform"
+	default y
+
+config P5020_BUILD
+	bool "P5020DS platform"
+
+endmenu
diff --git a/drivers/staging/fsl_dpa_offload/usecases/Makefile b/drivers/staging/fsl_dpa_offload/usecases/Makefile
new file mode 100644
index 0000000..def7c9d
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/Makefile
@@ -0,0 +1,18 @@
+
+#Include NetComm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += \
+	-I$(NCSW)/src/wrapper \
+	-Idrivers/crypto/caam
+
+obj-$(CONFIG_FSL_IPACC_USECASES) = fsl_ipacc_usecase.o
+fsl_ipacc_usecase-objs += 	main.o \
+				queues.o \
+				fm_utils.o \
+				eth_utils.o \
+				fmc_config.o \
+				fmc_config_ipsec.o \
+				dip_init.o \
+				xfrm_km.o \
+				xfrm_utils.o
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dip_init.c b/drivers/staging/fsl_dpa_offload/usecases/dip_init.c
new file mode 100644
index 0000000..ff9ff29
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dip_init.c
@@ -0,0 +1,182 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "platform_defs.h"
+#include "utils.h"
+#include "dip_init.h"
+#include "ports_conf.h"
+
+
+static unsigned int start_fqid;
+module_param(start_fqid, int, 0);
+MODULE_PARM_DESC(start_fqid, "\tFqid range for inbound and outbound SAs");
+
+t_Error DipInit(void)
+{
+	int i, cls_td, dpa_ipsec_id;
+	struct dpa_cls_tbl_params	cls_tbl_params;
+	struct dpa_ipsec_params dipParams;
+	struct qman_fqid_pool *fqid_pool = NULL;
+	int error = E_OK;
+	t_LnxWrpFmDev *fm;
+	uint32_t scratchBpid;
+
+	memset(&dipParams, 0, sizeof(struct dpa_ipsec_params));
+	fm = get_fm(FM);
+	if (!fm) {
+		pr_info("%s : cannot get FM %d\n", __func__, FM);
+		error = E_NOT_AVAILABLE;
+		goto out;
+	}
+
+	dipParams.fm_pcd = fm->h_PcdDev;
+	/*FIXME - intended usage */
+	dipParams.max_sa_pairs = 32;
+	scratchBpid = create_scratch_pool();
+	if (scratchBpid <= 0) {
+		error = E_INVALID_VALUE;
+		goto out;
+	}
+
+	dipParams.ipf_bpid		= scratchBpid;
+	dipParams.qm_sec_ch		= qm_channel_caam;
+
+	/* return required PCD handles to DIP initialization */
+	do_fmc_config(&dipParams);
+
+	/* create required classifier tables */
+	/* INB/DL pre SEC params */
+	/* FIXME - intended usage */
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+	cls_tbl_params.fm_pcd = fm->h_PcdDev;
+	cls_tbl_params.cc_node = h_CcNodeInRx;
+	cls_tbl_params.type = DPA_CLS_TBL_HASH;
+	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+	cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
+	cls_tbl_params.hash_params.max_ways = CCNODE_MAX_NUM_OF_KEYS;
+	cls_tbl_params.hash_params.num_sets = IN_SA_PCD_HASH_SETS;
+	cls_tbl_params.hash_params.key_size = MAX_SIZE_IP_UDP_SPI_KEY_IPV4;
+	error = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+	if (error < 0) {
+		pr_err("%s:%d: error creating in sa lookup classif table\n",
+				__func__, __LINE__);
+		goto out;
+	}
+
+	dipParams.pre_sec_in_params.dpa_cls_td = cls_td;
+
+	/* INB/DL  post SEC params */
+	 /* data_off - SEC preheader burst size in bytes */
+	dipParams.post_sec_in_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
+	dipParams.post_sec_in_params.use_ipv6_pol = FALSE;
+	dipParams.post_sec_in_params.qm_tx_ch =
+			OH_PORT_CHANNEL(FM, DL_POST_IPSEC_OH);
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+	cls_tbl_params.fm_pcd = fm->h_PcdDev;
+	cls_tbl_params.cc_node = h_CcNodeFlowId;
+	cls_tbl_params.type = DPA_CLS_TBL_INDEXED;
+	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+	cls_tbl_params.indexed_params.entries_cnt = dipParams.max_sa_pairs;
+	error = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+	if (error < 0) {
+		pr_err("%s:%d: error creating in sa lookup classif table\n",
+				__func__, __LINE__);
+		goto out;
+	}
+
+	/* INB policy verification */
+	dipParams.post_sec_in_params.dpa_cls_td = cls_td;
+	dipParams.post_sec_in_params.do_pol_check = TRUE;
+	dipParams.post_sec_in_params.key_fields = DPA_IPSEC_KEY_FIELD_DPORT;
+
+	/* OUTB/UL post SEC params */
+	/* data_off - SEC preheader burst size in bytes */
+	dipParams.post_sec_out_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
+	dipParams.post_sec_out_params.qm_tx_ch =
+			OH_PORT_CHANNEL(FM, UL_POST_IPSEC_OH);
+
+	/* OUTB/UL pre SEC params */
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
+		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+		cls_tbl_params.fm_pcd = fm->h_PcdDev;
+		cls_tbl_params.cc_node = h_CcNodeOutPreEnc[i];
+		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+		cls_tbl_params.exact_match_params.entries_cnt =
+				dipParams.max_sa_pairs;
+		cls_tbl_params.exact_match_params.key_size =
+				MAX_SIZE_POLICY_KEY_IPV4;
+		error = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+		if (error < 0) {
+			pr_err("%s:%d: error creating out sa lookup classif table\n",
+					__func__, __LINE__);
+			goto out;
+		}
+
+		dipParams.pre_sec_out_params.dpa_cls_td[i] = cls_td;
+	}
+	dipParams.pre_sec_out_params.key_fields = DPA_IPSEC_KEY_FIELD_SIP |
+						  DPA_IPSEC_KEY_FIELD_DIP |
+						  DPA_IPSEC_KEY_FIELD_PROTO |
+						  DPA_IPSEC_KEY_FIELD_SPORT |
+						  DPA_IPSEC_KEY_FIELD_DPORT;
+
+	/* create a FQID pool for DPA IPSec */
+	if (start_fqid > 0) {
+		fqid_pool = qman_fqid_pool_create(start_fqid,
+				dipParams.max_sa_pairs * 4);
+		if (!fqid_pool) {
+			pr_err("Error creating fqid pool\n");
+			error = E_INVALID_VALUE;
+			goto out;
+		}
+	}
+
+	dipParams.fqid_pool = fqid_pool;
+	error = dpa_ipsec_init(&dipParams, &dpa_ipsec_id);
+	if (error < 0) {
+		pr_err("%s:%d cannot initialize DPA IPsec\n",
+				__func__, __LINE__);
+		goto out;
+	}
+
+out:
+	return error;
+}
+
+t_Error DipCleanup(void)
+{
+	return dpa_ipsec_free(0);
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dip_init.h b/drivers/staging/fsl_dpa_offload/usecases/dip_init.h
new file mode 100644
index 0000000..e40719d
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dip_init.h
@@ -0,0 +1,64 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _DIP_INIT_H_
+#define _DIP_INIT_H_
+
+#include <linux/fsl_dpa_ipsec.h>
+
+extern t_Handle p_Dip;
+
+extern t_Error DipInit(void);
+extern t_Error DipCleanup(void);
+extern t_Handle h_CcNodeInRx;
+extern t_Handle h_CcNodeOutPreEnc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
+extern t_Handle h_CcNodeFlowId;
+extern t_Handle h_CcNodeInPostDec;
+
+enum e_PortId {
+	e_IN_RX = 0,	/**< Inbound, FMAN RX port */
+	e_IN_POST_DEC,	/**< Inbound post-decryption OH port */
+	e_OUT_PRE_ENC,	/**< Outbound pre-encryption OH port */
+	e_OUT_POST_ENC,	/**< Outbound post-encryption OH port*/
+	e_PORT_MAX	/**< Dummy val, for SW usage */
+};
+
+#define IN_SA_PCD_HASH_OFF	0
+#define IN_SA_PCD_HASH_SETS	2
+#define CCNODE_MAX_NUM_OF_KEYS	16
+
+
+
+
+void InitIpsecPortPcd(t_Handle *h_CcNodes, int *NumCcNodes,
+		enum e_PortId PortId, struct dpa_ipsec_params *dipParams);
+int do_fmc_config(struct dpa_ipsec_params *dipParams);
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p3041ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p3041ds-usdpaa.dts
new file mode 100644
index 0000000..d3a0ea9
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dts/p3041ds-usdpaa.dts
@@ -0,0 +1,241 @@
+/*
+ * P3041DS Device Tree Source
+ *
+ * Copyright 2010-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p3041ds.dts"
+
+/ {
+	bman-portals@ff4000000 {
+		bman-portal@0 {
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@4000 {
+			cpu-handle = <&cpu1>;
+		};
+		bman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+		};
+		bman-portal@10000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu2>;
+		};
+		bman-portal@14000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu3>;
+		};
+		bman-portal@18000 {
+		};
+		bman-portal@1c000 {
+		};
+		bman-portal@20000 {
+		};
+		bman-portal@24000 {
+		};
+
+		buffer-pool@0 {
+			compatible = "fsl,p3041-bpool", "fsl,bpool";
+			fsl,bpid = <0>;
+			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
+		};
+		/* NB: the bpool-cfg is set for no seeding (count==0), because
+		 * apps seed these pools buffers which are determined only at
+		 * run-time.
+		 * HOWEVER, the kernel driver requires the buffer-size and also
+		 * mis-interprets things if the base-address is zero (hence the
+		 * bogus values).
+		 */
+		bp7: buffer-pool@7 {
+			compatible = "fsl,p3041-bpool", "fsl,bpool";
+			fsl,bpid = <7>;
+			fsl,bpool-cfg = <0 0 0 192 0 0xdeadbeef>;
+			fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		};
+		bp8: buffer-pool@8 {
+			compatible = "fsl,p3041-bpool", "fsl,bpool";
+			fsl,bpid = <8>;
+			fsl,bpool-cfg = <0 0 0 576 0 0xabbaf00d>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+		bp9: buffer-pool@9 {
+			compatible = "fsl,p3041-bpool", "fsl,bpool";
+			fsl,bpid = <9>;
+			fsl,bpool-cfg = <0 0 0 1600 0 0xfeedabba>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+	};
+
+	qman-portals@ff4200000 {
+		qportal0: qman-portal@0 {
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal1: qman-portal@4000 {
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal2: qman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal3: qman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal4: qman-portal@10000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu2>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal5: qman-portal@14000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu3>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal6: qman-portal@18000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal7: qman-portal@1c000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal8: qman-portal@20000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal9: qman-portal@24000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+		ethernet@1 {
+			compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+		ethernet@2 {
+			compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+        ethernet@4 {
+            compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+            fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+            fsl,qman-channel = <&qpool4>;
+            fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+            fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+        };
+		ethernet@5 {
+			compatible = "fsl,p3041-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+        ethernet@6 {
+            compatible = "fsl,p3041-dpa-ethernet", "fsl,dpa-ethernet";
+            fsl,qman-channel = <&qpool1>;
+            fsl,qman-frame-queues-rx = <0x0 1 0x0 1>;
+            fsl,qman-frame-queues-tx = <0x0 1 0x0 1>;
+            local-mac-address = [000000000001];
+            fsl,fman-oh-tx = <&dpa_fman0_oh2>;
+        };
+       dpa_fman0_oh1: dpa-fman0-oh@1 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,fman-oh-port = <&fman0_oh1>;
+		};
+        dpa_fman0_oh2: dpa-fman0-oh@2 {
+            compatible = "fsl,dpa-oh";
+	    fsl,bman-buffer-pools = <&bp9>;
+            /* Define frame queues for the OH port*/
+            /* <OH Rx error, OH Rx default> */
+            fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+            fsl,fman-oh-port = <&fman0_oh2>;
+        };
+        dpa_fman0_oh3: dpa-fman0-oh@3 {
+            compatible = "fsl,dpa-oh";
+	    fsl,bman-buffer-pools = <&bp9>;
+            /* Define frame queues for the OH port*/
+            /* <OH Rx error, OH Rx default> */
+            fsl,qman-frame-queues-oh = <0x72 1 0x73 1>;
+            fsl,fman-oh-port = <&fman0_oh3>;
+        };
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
new file mode 100644
index 0000000..b74de95
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
@@ -0,0 +1,281 @@
+/*
+ * P4080DS Device Tree Source
+ *
+ * Copyright 2009-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p4080ds.dts"
+
+/ {
+	bman-portals@ff4000000 {
+		bman-portal@0 {
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@4000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+		};
+		bman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu2>;
+		};
+		bman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu3>;
+		};
+		bman-portal@10000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu4>;
+		};
+		bman-portal@14000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu5>;
+		};
+		bman-portal@18000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu6>;
+		};
+		bman-portal@1c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu7>;
+		};
+		bman-portal@20000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@24000 {
+			cpu-handle = <&cpu1>;
+		};
+		/* BPID 0 is used a dynamic FQID allocator */
+		buffer-pool@0 {
+			compatible = "fsl,p4080-bpool", "fsl,bpool";
+			fsl,bpid = <0>;
+			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
+		};
+		/* NB: the bpool-ethernet-seeds is not set to avoid buffer seeding,
+		 * because apps seed these pools buffers which are determined only
+		 * at run-time.
+		 * HOWEVER, the kernel driver requires the buffer-size and also
+		 * mis-interprets things if the base-address is zero (hence the bogus
+		 * values).
+		 */
+		bp7: buffer-pool@7 {
+			compatible = "fsl,p4080-bpool", "fsl,bpool";
+			fsl,bpid = <7>;
+			fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+			fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		};
+		bp8: buffer-pool@8 {
+			compatible = "fsl,p4080-bpool", "fsl,bpool";
+			fsl,bpid = <8>;
+			fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+		bp9: buffer-pool@9 {
+			compatible = "fsl,p4080-bpool", "fsl,bpool";
+			fsl,bpid = <9>;
+			fsl,bpool-ethernet-cfg = <0 0 0 1600 0 0xfeedabba>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+	};
+
+	qman-portals@ff4200000 {
+		qportal0: qman-portal@0 {
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal1: qman-portal@4000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal2: qman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu2>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal3: qman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu3>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal4: qman-portal@10000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu4>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal5: qman-portal@14000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu5>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal6: qman-portal@18000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu6>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal7: qman-portal@1c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu7>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal8: qman-portal@20000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal9: qman-portal@24000 {
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+
+		/* ethernet@1 will be used as a normal Linux ethernet that
+		 * interfaces to the kernel network stack. All others will be
+		 * dedicated for use by usdpaa */
+
+		ethernet@2 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+		ethernet@4 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+		ethernet@6 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
+		};
+		ethernet@7 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
+			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
+		};
+		ethernet@8 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
+			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
+		};
+		ethernet@9 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x66 1 0x67 1>;
+			fsl,qman-frame-queues-tx = <0x86 1 0x87 1>;
+		};
+		dpa_fman1_oh1: dpa-fman1-oh@1 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
+			fsl,fman-oh-port = <&fman1_oh1>;
+		};
+		dpa_fman1_oh2: dpa-fman1-oh@2 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman1_oh2>;
+		};
+		dpa_fman1_oh3: dpa-fman1-oh@3 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman1_oh3>;
+		};
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
new file mode 100644
index 0000000..8e84aa0
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
@@ -0,0 +1,227 @@
+/*
+ * P5020DS Device Tree Source
+ *
+ * Copyright 2010-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p5020ds.dts"
+
+/ {
+	bman-portals@ff4000000 {
+		bman-portal@0 {
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@4000 {
+			cpu-handle = <&cpu1>;
+		};
+		bman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+		};
+		bman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+		};
+		bman-portal@10000 {
+		};
+		bman-portal@14000 {
+		};
+		bman-portal@18000 {
+		};
+		bman-portal@1c000 {
+		};
+		bman-portal@20000 {
+		};
+		bman-portal@24000 {
+		};
+
+		buffer-pool@0 {
+			compatible = "fsl,p5020-bpool", "fsl,bpool";
+			fsl,bpid = <0>;
+			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
+		};
+		/* NB: the bpool-cfg is set for no seeding (count==0), because
+		 * apps seed these pools buffers which are determined only at
+		 * run-time.
+		 * HOWEVER, the kernel driver requires the buffer-size and also
+		 * mis-interprets things if the base-address is zero (hence the
+		 * bogus values).
+		 */
+		bp7: buffer-pool@7 {
+			compatible = "fsl,p5020-bpool", "fsl,bpool";
+			fsl,bpid = <7>;
+			fsl,bpool-cfg = <0 0 0 192 0 0xdeadbeef>;
+			fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		};
+		bp8: buffer-pool@8 {
+			compatible = "fsl,p5020-bpool", "fsl,bpool";
+			fsl,bpid = <8>;
+			fsl,bpool-cfg = <0 0 0 576 0 0xabbaf00d>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+		bp9: buffer-pool@9 {
+			compatible = "fsl,p5020-bpool", "fsl,bpool";
+			fsl,bpid = <9>;
+			fsl,bpool-cfg = <0 0 0 1600 0 0xfeedabba>;
+			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		};
+	};
+
+	qman-portals@ff4200000 {
+		qportal0: qman-portal@0 {
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal1: qman-portal@4000 {
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal2: qman-portal@8000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu0>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal3: qman-portal@c000 {
+			fsl,usdpaa-portal;
+			cpu-handle = <&cpu1>;
+			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+		};
+
+		qportal4: qman-portal@10000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal5: qman-portal@14000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal6: qman-portal@18000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal7: qman-portal@1c000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal8: qman-portal@20000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+
+		qportal9: qman-portal@24000 {
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
+		};
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+		ethernet@1 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+		ethernet@2 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+		ethernet@4 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-channel = <&qpool4>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+        ethernet@6 {
+            compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
+            fsl,qman-channel = <&qpool1>;
+            fsl,qman-frame-queues-rx = <0x0 1 0x0 1>;
+            fsl,qman-frame-queues-tx = <0x0 1 0x0 1>;
+            local-mac-address = [000000000001];
+            fsl,fman-oh-tx = <&dpa_fman0_oh2>;
+        };
+       dpa_fman0_oh1: dpa-fman0-oh@1 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,fman-oh-port = <&fman0_oh1>;
+		};
+        dpa_fman0_oh2: dpa-fman0-oh@2 {
+            compatible = "fsl,dpa-oh";
+	    fsl,bman-buffer-pools = <&bp9>;
+            /* Define frame queues for the OH port*/
+            /* <OH Rx error, OH Rx default> */
+            fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+            fsl,fman-oh-port = <&fman0_oh2>;
+        };
+        dpa_fman0_oh3: dpa-fman0-oh@3 {
+            compatible = "fsl,dpa-oh";
+	    fsl,bman-buffer-pools = <&bp9>;
+            /* Define frame queues for the OH port*/
+            /* <OH Rx error, OH Rx default> */
+            fsl,qman-frame-queues-oh = <0x72 1 0x73 1>;
+            fsl,fman-oh-port = <&fman0_oh3>;
+        };
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/eth_utils.c b/drivers/staging/fsl_dpa_offload/usecases/eth_utils.c
new file mode 100644
index 0000000..94ccfa6
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/eth_utils.c
@@ -0,0 +1,219 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fsl_bman.h>
+#include <linux/fsl_qman.h>
+#include <linux/etherdevice.h>
+#include "dpaa_eth.h"
+#include "lnxwrp_fm.h"
+#include "platform_defs.h"
+#include "utils.h"
+
+/* USDPAA DMA mem ptov offset */
+static long ptov_off = 0x10000000;
+module_param(ptov_off, long, 0);
+MODULE_PARM_DESC(ptov_off, "\tUSDPAA DMA mem phys to virt offset");
+
+/*
+ *  Returns a reference to a buffer pool configured for interface if
+ *  We assume that the pool is the default kernel pool
+ */
+struct bman_pool *get_if_pool(const char *_if)
+{
+	struct net_device *ndev;
+	struct dpa_priv_s *priv;
+	ndev = dev_get_by_name(&init_net, _if);
+	if (!ndev) {
+		pr_err("%s : net device %s doesn't exist\n", __func__, _if);
+		return NULL;
+	}
+	priv = netdev_priv(ndev);
+	dev_put(ndev);
+	if (priv->bp_count != 1)
+		pr_warning("%s : interface %s has %d pools configured\n",
+			   __func__, _if, priv->bp_count);
+	return priv->dpa_bp->pool;
+}
+
+/*
+ *  Returns a reference to an interface Linux Rx queue
+ *  Assumes that sw_portal_0 is always used by Linux
+ */
+struct qman_fq *get_if_ingress_queue(const char *_if, int fqid)
+{
+	struct net_device *ndev;
+	struct dpa_priv_s *priv;
+	struct dpa_fq *fq;
+	ndev = dev_get_by_name(&init_net, _if);
+	if (!ndev) {
+		pr_err("%s : net device %s doesn't exist\n", __func__, _if);
+		return NULL;
+	}
+	priv = netdev_priv(ndev);
+	dev_put(ndev);
+
+	list_for_each_entry(fq, &priv->dpa_fq_list, list) {
+		if (fq->fqid == fqid) {
+			if (fq->channel != SW_PORTAL_CHANNEL(0))
+				pr_warning("%s : fqid %d is not on SWP 0 channel - %x\n",
+				     __func__, fqid, fq->channel);
+			return &fq->fq_base;
+		}
+	}
+	return NULL;
+}
+
+/*
+ Copies an USDPAA frame (buffer) into an skb and pushes it
+ to kernel stack as received from a tap device
+*/
+void tap_receive(const struct qm_dqrr_entry *dqrr, struct net_device *ndev)
+{
+	dma_addr_t phys = qm_fd_addr(&dqrr->fd);
+	u32 len = dqrr->fd.length20;
+	struct bm_buffer bm_usr_buf;
+	void *virt;
+	int ret = -1;
+	struct sk_buff *skb;
+
+	if (!ndev)
+		goto free_usr_buf;
+
+	/* dma_mem ptov translation */
+	virt = (void *)((unsigned long)(phys + ptov_off)) + dqrr->fd.offset;
+
+	/* get an skb */
+	skb = dev_alloc_skb(len);
+	if (!skb) {
+		pr_warning("%s: skb allocation failed\n", __func__);
+		goto free_usr_buf;
+	}
+
+	/* copy user buffer into the skb */
+	ret = __copy_from_user_inatomic(skb_put(skb, len), virt, len);
+	if (ret) {
+		pr_err("%s : cannot copy user frame, ret %d\n", __func__, ret);
+		goto free_usr_buf;
+	}
+	skb->dev = ndev;
+	skb->protocol = eth_type_trans(skb, ndev);
+	netif_rx(skb);
+
+free_usr_buf:
+	/* return user buffer to its pool */
+	bm_usr_buf.bpid = dqrr->fd.bpid;
+	bm_usr_buf.lo = dqrr->fd.addr_lo;
+	bm_usr_buf.hi = dqrr->fd.addr_hi;
+
+	/* TODO - this may fail and we cannot wait here to return the buffer*/
+	ret =
+	    bman_release(usdpaa_pools[bm_usr_buf.bpid], &bm_usr_buf, 1,
+			 BMAN_RELEASE_FLAG_NOW);
+	if (ret == -EBUSY)
+		pr_warning("%s : buffer %x was not freed\n", __func__,
+			dqrr->fd.addr_lo);
+}
+
+/* Enqueues an USDPAA frame (buffer) to a DPAA tap/tun interface */
+void if_enqueue(const struct qm_dqrr_entry *dqrr, struct qman_fq *rx_fq)
+{
+	dma_addr_t phys = qm_fd_addr(&dqrr->fd);
+	dma_addr_t bm_phys;
+	u32 len = dqrr->fd.length20;
+	struct bm_buffer bm_usr_buf, bm_buf;
+	struct qm_fd fd;
+	struct ethhdr *prot_eth;
+	struct iphdr *iphdr;
+	void *virt;
+	u8 *buf;
+	int ret = -1;
+
+	if (!rx_fq)
+		goto free_usr_buf;
+
+	/* dma_mem ptov translation */
+	virt = (void *)((unsigned long)(phys + ptov_off)) + dqrr->fd.offset;
+
+	/* get a buffer from default kernel pool */
+	ret = bman_acquire(default_pool, &bm_buf, 1, 0);
+	if (ret != 1) {
+		pr_err
+		    ("%s : cannot aquire buffer from default pool, ret = %d\n",
+		     __func__, ret);
+		goto free_usr_buf;
+	}
+
+	/* copy user buffer - assume the same offset */
+	bm_phys = bm_buf_addr(&bm_buf);
+	buf = phys_to_virt(bm_phys);
+	ret = __copy_from_user_inatomic(buf + dqrr->fd.offset, virt, len);
+	if (ret) {
+		pr_err("%s : cannot copy user frame , ret %d\n", __func__, ret);
+		goto free_usr_buf;
+	}
+
+	prot_eth = (struct ethhdr *)(buf + dqrr->fd.offset);
+
+	/* set-up a frame descriptor and enqueue it to interface Rx queue */
+	fd.format = qm_fd_contig;
+	qm_fd_addr_set64(&fd, bm_phys);
+	/* IP frame may contain ESP padding after decryption */
+	if (prot_eth->h_proto == ETH_P_IP) {
+		iphdr = (typeof(iphdr)) (prot_eth + 1);
+		fd.length20 = sizeof(*prot_eth) + iphdr->tot_len;
+	} else	/* TODO - handle other protocols : 8021Q,IPv6 */
+		fd.length20 = dqrr->fd.length20;
+	fd.offset = dqrr->fd.offset;
+	fd.status = 0;
+	fd.bpid = bm_buf.bpid;
+
+	ret = qman_enqueue(rx_fq, &fd, 0);
+	if (ret)
+		pr_err("%s : cannot enqueue fd to fqid %d, ret = %d\n",
+		       __func__, qman_fq_fqid(rx_fq), ret);
+
+free_usr_buf:
+	/* return user buffer to its pool */
+	bm_usr_buf.bpid = dqrr->fd.bpid;
+	bm_usr_buf.lo = dqrr->fd.addr_lo;
+	bm_usr_buf.hi = dqrr->fd.addr_hi;
+
+	/* TODO - this may fail and we cannot wait here to return the buffer,
+	 * so it would be better to move buffer release in a work queue
+	 */
+	ret = bman_release(usdpaa_pools[bm_usr_buf.bpid],
+			   &bm_usr_buf, 1, BMAN_RELEASE_FLAG_NOW);
+	if (ret == -EBUSY)
+		pr_warning("%s : buffer %x was not freed\n",
+			   __func__, dqrr->fd.addr_lo);
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
new file mode 100644
index 0000000..fe251fc
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
@@ -0,0 +1,282 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fsl_bman.h>
+#include <linux/fsl_qman.h>
+#include <linux/of.h>
+#include <linux/version.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include "lnxwrp_fm.h"
+#include "ports_conf.h"
+#include "platform_defs.h"
+
+static struct of_device_id fman_1g_rx_port[] = {
+	{ .compatible = "fsl,fman-port-1g-rx", },
+	{}
+};
+static struct of_device_id fman_1g_tx_port[] = {
+	{ .compatible = "fsl,fman-port-1g-tx", },
+	{}
+};
+
+static struct of_device_id fman_10g_rx_port[] = {
+	{ .compatible = "fsl,fman-port-10g-rx", },
+	{}
+};
+
+static struct of_device_id fman_10g_tx_port[] = {
+	{ .compatible = "fsl,fman-port-10g-tx", },
+	{}
+};
+
+static struct of_device_id fman_oh_port[] = {
+	{ .compatible = "fsl,fman-port-oh", },
+	 {}
+};
+
+static struct of_device_id fman[] = {
+	{ .compatible = "fsl,fman", },
+	{}
+};
+
+/*
+	 Create scratch buffer pool for IP fragmentation
+*/
+int create_scratch_pool(void)
+{
+	struct bman_pool_params buffer_pool_params;
+	const struct bman_pool_params *buf_pool_params;
+	struct bman_pool *buf_pool = NULL;
+
+	memset(&buffer_pool_params, 0, sizeof(struct bman_pool_params));
+	buffer_pool_params.flags = BMAN_POOL_FLAG_DYNAMIC_BPID ;
+	buf_pool = bman_new_pool(&buffer_pool_params);
+	if (buf_pool == NULL)
+		return -ENODEV;
+
+	buf_pool_params = bman_get_params(buf_pool);
+	return buf_pool_params->bpid;
+}
+
+/*
+	Find the base address of dTSEC device
+	@fm_idx : FMAN index (0/1)
+	@port_idx : port index
+	*/
+uint64_t get_mac_dev(int fm_id, int port_id)
+{
+	struct device_node *eth_dev_temp = NULL, *eth_dev = NULL,
+	*mac_node = NULL, *fman_node = NULL;
+	const phandle *mac_phandle, *fm_cell_idx, *mac_cell_idx;
+	size_t lenp;
+	const uint32_t *regs_addr;
+	uint64_t regs_size;
+	uint64_t phys_addr;
+
+	eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+			"fsl,dpa-ethernet-init");
+	while (eth_dev != NULL) {
+		mac_phandle = of_get_property(eth_dev, "fsl,fman-mac", &lenp);
+		if (unlikely(mac_phandle == NULL))
+			goto err;
+
+		mac_node = of_find_node_by_phandle(*mac_phandle);
+		if (unlikely(mac_node == NULL))
+			goto err;
+
+		regs_addr = of_get_address(mac_node, 0, &regs_size, NULL);
+		if (unlikely(regs_addr == NULL))
+			goto err;
+
+		phys_addr = of_translate_address(mac_node, regs_addr);
+		if (unlikely(phys_addr == 0))
+			goto err;
+
+		fman_node = of_get_parent(mac_node);
+		if (!fman_node)
+			goto err;
+
+		fm_cell_idx = of_get_property(fman_node, "cell-index", &lenp);
+		if (!fm_cell_idx)
+			goto err;
+
+		mac_cell_idx = of_get_property(mac_node, "cell-index", &lenp);
+		if (!mac_cell_idx)
+			goto err;
+
+		if ((*mac_cell_idx == port_id) && (*fm_cell_idx == fm_id))
+			return phys_addr;
+
+		eth_dev_temp = eth_dev;
+		eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+				"fsl,dpa-ethernet-init");
+	}
+
+err:
+	return -1;
+}
+
+/*
+	Configure a dTEC to operate in loopback mode
+	fm_idx : FMAN index (0/1)
+	@port_idx : port index
+*/
+int config_loopback(int fm_id, int port_id)
+{
+	u64 addr;
+	uint64_t mac_phys_addr = 0;
+	u32 val;
+
+	mac_phys_addr = get_mac_dev(fm_id, port_id);
+	if (mac_phys_addr <= 0)
+		return -1;
+
+	addr = (uintptr_t)ioremap((mac_phys_addr), 0x1000);
+	if (!addr) {
+		pr_err("%s : cannot remap mac_phys_addr=%llx\n",
+			__func__, mac_phys_addr);
+	return -1;
+	}
+
+	val = in_be32((u32 *)((void *)(uintptr_t)
+			((addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET))));
+
+	val = val | MACCFG1_LOOPBACK;
+
+	out_be32((u32 *)((void *)(uintptr_t)
+			((addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET))), val);
+
+	iounmap((u32 *)((void *)(uintptr_t)
+			((addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET))));
+
+	printk(KERN_INFO "Loopback was set on mac device\n");
+
+	return 0;
+
+}
+
+
+/*
+	Returns fmd wrapper structure associated to a given FMAN
+*/
+t_LnxWrpFmDev *get_fm(int fm_idx)
+{
+	struct device_node *np = NULL;
+	struct device_node *fman_np = NULL;
+	struct platform_device *of_dev = NULL;
+	struct device *dev;
+	t_LnxWrpFmDev *fm_dev = NULL;
+
+	for_each_matching_node(np, fman) {
+		if (*((unsigned int *)of_get_property(np,
+				"cell-index", NULL)) == fm_idx) {
+			fman_np = np;
+			break;
+		}
+	}
+
+	if (!fman_np)
+		return NULL;
+
+	of_dev = of_find_device_by_node(fman_np);
+	of_node_put(fman_np);
+	if (unlikely(of_dev == NULL))
+		return NULL;
+
+	dev = &of_dev->dev;
+	fm_dev = dev_get_drvdata(dev);
+	return fm_dev;
+}
+
+/*
+	Returns fmd wrapper structure associated to a given FMAN port
+	@fm_idx : FMAN index (0/1)
+	@port_idx : port index
+	@port_type : type of port (RX/TX/1G/10G , OH)
+*/
+t_LnxWrpFmPortDev *get_fm_port(int fm_idx, int port_idx, e_FmPortType port_type)
+{
+	struct of_device_id *port_dev_id;
+	struct device_node *np = NULL;
+	struct device_node *fman_np = NULL;
+	struct platform_device *of_dev = NULL;
+	struct device *dev;
+	t_LnxWrpFmPortDev *port_dev = NULL;
+
+	switch (port_type) {
+	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
+		port_dev_id = fman_oh_port;
+		break;
+	case e_FM_PORT_TYPE_RX:
+		port_dev_id = fman_1g_rx_port;
+		break;
+	case e_FM_PORT_TYPE_RX_10G:
+		port_dev_id = fman_10g_rx_port;
+		break;
+	case e_FM_PORT_TYPE_TX:
+		port_dev_id = fman_1g_tx_port;
+		break;
+	case e_FM_PORT_TYPE_TX_10G:
+		port_dev_id = fman_10g_tx_port;
+		break;
+	default:
+		return NULL;
+	}
+
+	for_each_matching_node(np, fman) {
+		if (*((unsigned int *)of_get_property(np,
+					"cell-index", NULL)) == fm_idx) {
+			fman_np = np;
+			break;
+		}
+	}
+	if (!fman_np)
+		return NULL;
+
+	for (np = of_find_matching_node(fman_np, port_dev_id); np;
+		np = of_find_matching_node(np, port_dev_id)) {
+		if (*((unsigned int *)of_get_property(np,
+					"cell-index", NULL)) == port_idx) {
+			of_dev = of_find_device_by_node(np);
+			of_node_put(np);
+			if (unlikely(of_dev == NULL))
+				break
+;
+		dev = &of_dev->dev;
+		port_dev = dev_get_drvdata(dev);
+			break;
+		}
+	}
+return port_dev;
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_config.xml b/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_config.xml
new file mode 100644
index 0000000..16f3a12
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_config.xml
@@ -0,0 +1,11 @@
+<cfgdata>
+    <config>
+    <engine name="fm1">
+		<port type="1G" number="3" policy="dl_rx_port_policy"/>
+		<port type="1G" number="2" policy="ul_rx_port_policy"/>
+		<port type="OFFLINE" number="1" policy="dl_oh_post_ipsec_policy"/>
+		<port type="OFFLINE" number="2" policy="ul_oh_pre_ipsec_policy"/>
+		<port type="OFFLINE" number="3" policy="ul_oh_post_ipsec_policy"/>
+	</engine>
+    </config>
+</cfgdata>
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_policy.xml b/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_policy.xml
new file mode 100644
index 0000000..15b8d0a
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc/fmc_policy.xml
@@ -0,0 +1,147 @@
+<netpcd xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:noNamespaceSchemaLocation="xmlProject/pcd.xsd" name="example"
+    description="Bridging configuration">
+
+<!-- DL input port PCD -->
+<!-- UDP traffic goes to coarse classification -->
+<!-- Inbound IPsec distribution/classification hooks in here -->
+    <distribution name="dl_rx_dist">
+        <queue count="1" base="0x2e00"/> <!-- DL HOST -->
+        <protocols>
+        <protocolref name="udp"/>
+        </protocols>
+        <action type="classification" name="dl_rx_udp_classf"/>
+    </distribution>
+
+	<distribution name="dl_rx_ipsec_dist">
+		<queue count="1" base="0x2e00"/> <!-- DL HOST -->
+		<protocols>
+		<protocolref name="ipv4"/>
+		<protocolref name="ipsec_esp"/>
+		</protocols>
+		<action type="classification" name="dl_rx_ipsec_classf"/>
+	</distribution>
+
+<!-- Non-UDP traffic goes to Linux -->
+    <distribution name="dl_default_dist">
+        <queue count="1" base="0x2e00"/>    <!-- DL HOST -->
+    </distribution>
+
+<!-- UDP dports 2152 and 1025 go to post IPsec OH -->
+    <classification name="dl_rx_udp_classf">
+        <key>
+            <fieldref name="udp.dport"/>
+        </key>
+        <!-- GTP UP app -->
+        <entry>
+            <data>0x0868</data> <!-- 2152 -->
+            <queue count="1" base="0x2e01"/>    <!-- DL UDP -->
+        </entry>
+        <!-- UDP OAM -->
+        <entry>
+            <data>0x0401</data> <!-- 1025 -->
+            <queue count="1" base="0x2e01"/>    <!-- DL UDP -->
+        </entry>
+    </classification>
+
+	<classification name="dl_rx_ipsec_classf">
+		<key>
+			<fieldref name="ipsec_esp.spi"/>
+		</key>
+		<entry>
+			<data>0x00000000</data>
+			<mask>0x00000000</mask>
+			<queue count="1" base="0x2e05"/>
+		</entry>
+	</classification>
+
+    <policy name="dl_rx_port_policy">
+        <dist_order>
+            <distributionref name="dl_rx_dist"/>
+			<distributionref name="dl_rx_ipsec_dist"/>
+            <distributionref name="dl_default_dist"/>
+        </dist_order>
+    </policy>
+
+<!-- DL post IPsec OH port PCD -->
+<!-- UDP traffic is classified based on dport -->
+	<distribution name="dl_oh_dist">
+		<queue count="1" base="0x2e02"/> <!-- DL UDP HOST -->
+		<key>
+			<fieldref name="udp.dport"/>
+		</key>
+		<action type="classification" name="dl_oh_udp_classf"/>
+	</distribution>
+
+<!-- NON UDP host goes to Linux -->
+    <distribution name="dl_oh_default_dist">
+        <queue count="1" base="0x2e03"/>          <!-- DL NON UDP host -->
+    </distribution>
+
+<!-- UDP dport 2152 goes to USDPAA app
+	 UDP dport 1025 goes to Linux -->
+	<classification name="dl_oh_udp_classf">
+		<key>
+            <fieldref name="udp.dport"/>
+        </key>
+
+		<!-- UDP OAM -->
+		<entry>
+			<data>0x0401</data> <!-- 1025 -->
+            <queue count="1" base="0x2e02"/>    <!-- DL UDP HOST -->
+		</entry>
+
+		<!-- GTP UP app -->
+        <entry>
+            <data>0x0868</data> <!-- 2152 -->
+            <queue count="1" base="0x2e04"/>    <!-- UPLANE APP  -->
+        </entry>
+	</classification>
+
+    <policy name="dl_oh_post_ipsec_policy">
+        <dist_order>
+            <distributionref name="dl_oh_dist"/>
+            <distributionref name="dl_oh_default_dist"/>
+        </dist_order>
+    </policy>
+
+<!-- UL input port PCD -->
+<!-- all traffic is received on USDPAA Rx FQ -->
+
+    <distribution name="ul_rx_port_hash_dist">
+        <queue count="1" base="0x3e00"/>				<!-- UL input Rx queues -->
+    </distribution>
+
+    <policy name="ul_rx_port_policy">
+        <dist_order>
+            <distributionref name="ul_rx_port_hash_dist"/>
+        </dist_order>
+    </policy>
+
+<!-- UL pre IPsec OH port PCD -->
+<!-- non IPsec traffic goes directly to Tx port -->
+<!-- outbound IPsec classification hooks in here -->
+
+	<distribution name="ul_oh_pre_ipsec_dist">
+		<queue count="2" base="0x3e01"/>			<!-- UL non IPSEC = USDPAA fm2-gb3 Tx -->
+	</distribution>
+
+	<policy name="ul_oh_pre_ipsec_policy">
+		<dist_order>
+			<distributionref name="ul_oh_pre_ipsec_dist"/>
+		</dist_order>
+	</policy>
+
+<!-- UL post IPsec OH port PCD -->
+
+    <distribution name="ul_oh_post_ipsec_default_dist">
+        <queue count="1" base="0x3e01"/>          <!-- USDPAA fm2-gb3 Tx  -->
+    </distribution>
+
+	<policy name="ul_oh_post_ipsec_policy">
+		<dist_order>
+			<distributionref name="ul_oh_post_ipsec_default_dist"/>
+		</dist_order>
+	</policy>
+
+</netpcd>
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c b/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
new file mode 100644
index 0000000..f288841
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
@@ -0,0 +1,1362 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Based on fmc tool generated code
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "utils.h"
+#include "net_ext.h"
+#include "types_ext.h"
+#include "Peripherals/fm_pcd_ext.h"
+#include "Peripherals/fm_port_ext.h"
+
+#include "ports_conf.h"
+#include "queues_conf.h"
+#include "dip_init.h"
+#include <linux/fsl_dpa_compat.h>
+#include "softparse.h"
+
+static t_Handle pcds[2];
+static t_Handle *ports[10];
+static t_Handle env_ids[10];
+static t_Handle schemes[32];
+static t_Handle ccnodes[512];
+static t_Handle cctrees[10];
+static t_Handle manips[10];
+
+static t_FmPcdNetEnvParams		distinctionUnits;
+static t_FmPcdKgSchemeParams		scheme;
+static t_FmPortPcdParams		pcdParam;
+static t_FmPortPcdPrsParams		prsParam;
+static t_FmPortPcdKgParams		kgParam;
+static t_FmPortPcdCcParams		ccParam;
+static t_FmPcdCcNodeParams		ccNodeParam;
+static t_FmPcdCcTreeParams		ccTreeParams;
+static t_FmPcdManipParams		manipParam;
+
+/* MTU for outbound OH post sec */
+static uint16_t mtu_post_enc;
+module_param(mtu_post_enc, ushort, 0);
+MODULE_PARM_DESC(mtu_post_enc, "\tMTU for OH port post encryption");
+
+/* Loopback operation mode */
+static int enable_loopback;
+module_param(enable_loopback, int, 0);
+MODULE_PARM_DESC(enable_loopback,
+			"\tEnable loopback for DownLink Interface\n");
+
+t_Handle h_CcNodeInRx;
+t_Handle h_CcNodeOutPreEnc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
+t_Handle h_CcNodeInPostDec;
+t_Handle h_CcNodeFlowId;
+
+/* FIXME */
+#define UDP_SRC_AND_DEST_PORT_SIZE	4
+#define UDP_SRC_AND_DEST_PORT_DEF_VAL	0xAAAAAAAA
+
+e_ErrorType fmc_config(struct dpa_ipsec_params *dipParams)
+{
+	uint8_t scheme_idx = 0;
+	uint8_t relativeSchemeId = 0;
+	uint8_t manipId = 0;
+	t_FmPcdPrsSwParams	    swPrs = SOFT_PARSE_UDP_ESP;
+	int i = 0;
+	t_Error err;
+	int NumCcNodes = 0;
+	t_LnxWrpFmPortDev *oh_port = NULL, *rx_port = NULL;
+	/*FM_PCD_MAX_NUM_OF_KEYS*/ /*FM_PCD_MAX_SIZE_OF_KEY*/
+	unsigned char keydata[][2] = {
+		{0x08, 0x68} /* GTP */
+	};
+	unsigned char mask[][2] = {
+		{0xff, 0xff}
+	};
+
+	/* Initialize SW Parser for UDP encapsulated ESP */
+	FM_PCD_Disable(pcds[0]);
+	err = FM_PCD_PrsLoadSw(pcds[0], &swPrs);
+	if (err != E_OK) {
+		pr_err("Cannot load Soft Parser!");
+		return err;
+	}
+
+	FM_PCD_Enable(pcds[0]);
+
+	/***************************************************************/
+	/************************* UL_POST_IPSEC_OH ********************/
+
+	memset(&distinctionUnits, 0, sizeof(distinctionUnits));
+	distinctionUnits.numOfDistinctionUnits = 0;
+	env_ids[4] = FM_PCD_SetNetEnvCharacteristics(pcds[0],
+					&distinctionUnits);
+	if (0 == env_ids[4])
+		return E_INVALID_HANDLE;
+
+	/* IP Fragmentation Manipulation */
+	oh_port = container_of(ports[4], t_LnxWrpFmPortDev, h_Dev);
+	if (oh_port->settings.frag_enabled == FALSE) {
+		/* fragmentation is not enabled */
+		/* set mtu to 0, to prevent setting the manip node */
+		mtu_post_enc = 0;
+		printk(KERN_INFO "%s : Fragmentation not"
+			"applied on OH post enc.\n", __func__);
+	}
+
+	if (mtu_post_enc) {
+		memset(&manipParam, 0, sizeof(manipParam));
+		manipParam.fragOrReasm = TRUE;
+		manipParam.fragOrReasmParams.frag = TRUE;
+		manipParam.fragOrReasmParams.hdr = HEADER_TYPE_IPv4;
+		manipParam.fragOrReasmParams.ipFragParams.
+				sizeForFragmentation = mtu_post_enc;
+		manipParam.fragOrReasmParams.ipFragParams.
+				scratchBpid = dipParams->ipf_bpid;
+		manips[0] = FM_PCD_ManipSetNode(pcds[0], &manipParam);
+		if (manips[0] == NULL) {
+			pr_err("Could not set Manip handler for Fragmentation!");
+			return E_INVALID_HANDLE;
+		}
+	}
+
+	memset(&ccNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
+	ccNodeParam.extractCcParams.type  = e_FM_PCD_EXTRACT_NON_HDR;
+	ccNodeParam.extractCcParams.extractNonHdr.src =
+			e_FM_PCD_EXTRACT_FROM_FLOW_ID;
+	ccNodeParam.extractCcParams.extractNonHdr.action =
+			e_FM_PCD_ACTION_INDEXED_LOOKUP;
+	ccNodeParam.extractCcParams.extractNonHdr.offset = 0;
+	ccNodeParam.extractCcParams.extractNonHdr.size = 2;
+
+	/*FIXME -  Maximum number of entries (256) are not
+			permited for indexed lookup. */
+	ccNodeParam.keysParams.numOfKeys = dipParams->max_sa_pairs;
+
+	ccNodeParam.extractCcParams.extractNonHdr.icIndxMask =
+			(uint16_t)((ccNodeParam.keysParams.numOfKeys - 1) << 4);
+	ccNodeParam.keysParams.keySize = 2;
+
+	for (i = 0; i < ccNodeParam.keysParams.numOfKeys; i++) {
+		ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+				nextEngine = e_FM_PCD_DONE;
+		ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+				params.enqueueParams.overrideFqid = TRUE;
+		ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+				params.enqueueParams.newFqid = UL_TX_QUEUE;
+
+	if (mtu_post_enc)
+		ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+				h_Manip = manips[0];
+	}
+
+	ccnodes[2] = FM_PCD_CcSetNode(pcds[0], &ccNodeParam);
+	if (ccnodes[2] == 0)
+		return E_INVALID_HANDLE;
+
+	memset(&ccTreeParams, 0, sizeof(ccTreeParams));
+	ccTreeParams.numOfGrps = 1;
+	ccTreeParams.ccGrpParams[0].numOfDistinctionUnits = 0;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				params.ccParams.h_CcNode = ccnodes[2];
+
+	cctrees[4] = FM_PCD_CcBuildTree(pcds[0], &ccTreeParams);
+	if (cctrees[4] == NULL) {
+		pr_err("Could not create CC Tree!");
+		return E_INVALID_STATE;
+	}
+
+	/* Initialize PCD parameters */
+	memset(&pcdParam, 0, sizeof(pcdParam));
+	pcdParam.h_NetEnv = env_ids[4];
+	pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_CC;
+	pcdParam.p_PrsParams = &prsParam;
+	pcdParam.p_CcParams = &ccParam;
+
+	/* initialize coarse classification port parameters */
+	memset(&ccParam, 0, sizeof(ccParam));
+	ccParam.h_CcTree = cctrees[4];
+
+	/* Initialize parser parameters */
+	memset(&prsParam, 0, sizeof(prsParam));
+	prsParam.parsingOffset = 0;
+	prsParam.prsResultPrivateInfo = 0;
+	prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+
+
+
+	/* Apply the configuration */
+	FM_PORT_Disable(*(ports[4]));
+	FM_PORT_SetPCD(*(ports[4]), &pcdParam);
+	FM_PORT_Enable(*(ports[4]));
+
+	/******************************************************************/
+	/********************** UL_PRE_IPSEC_OH	 **************************/
+
+	memset(&distinctionUnits, 0, sizeof(distinctionUnits));
+	distinctionUnits.numOfDistinctionUnits = 4;
+	distinctionUnits.units[0].hdrs[0].hdr = HEADER_TYPE_IPv4;
+	distinctionUnits.units[1].hdrs[0].hdr = HEADER_TYPE_UDP;
+	distinctionUnits.units[2].hdrs[0].hdr = HEADER_TYPE_TCP;
+	distinctionUnits.units[3].hdrs[0].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
+
+	env_ids[3] = FM_PCD_SetNetEnvCharacteristics(pcds[0],
+			&distinctionUnits);
+	if (env_ids[3] == 0)
+		return E_INVALID_HANDLE;
+
+	/* ->ipsec port */
+	InitIpsecPortPcd(h_CcNodeOutPreEnc, &NumCcNodes,
+			e_OUT_PRE_ENC, dipParams);
+	/* ipsec port <-*/
+
+	/* CC Tree for the current port */
+	memset(&ccTreeParams, 0, sizeof(ccTreeParams));
+	ccTreeParams.numOfGrps = 3;
+	ccTreeParams.h_NetEnv = env_ids[3];
+
+	/* TCP Group */
+	ccTreeParams.ccGrpParams[0].numOfDistinctionUnits = 1;
+	ccTreeParams.ccGrpParams[0].unitIds[0] = 0; /* IPv4 */
+	/* IPv6 not yet supported */
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_DONE;/* unit NOT found */
+	/* IPv4 */
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[1].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[1].
+				params.ccParams.h_CcNode = h_CcNodeOutPreEnc[0];
+
+	/* UDP Group */
+	ccTreeParams.ccGrpParams[1].numOfDistinctionUnits = 1;
+	ccTreeParams.ccGrpParams[1].unitIds[0] = 0; /* IPv4 */
+	/* IPv6 not yet supported */
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_DONE;/* unit NOT found */
+	/* IPv4 */
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[1].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[1].
+				params.ccParams.h_CcNode = h_CcNodeOutPreEnc[1];
+
+	/* ICMP Group */
+	ccTreeParams.ccGrpParams[2].numOfDistinctionUnits = 1;
+	ccTreeParams.ccGrpParams[2].unitIds[0] = 0;/* IPv4 */
+	/* IPv6 not yet supported */
+	ccTreeParams.ccGrpParams[2].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_DONE;/* unit NOT found */
+	/* IPv4 */
+	ccTreeParams.ccGrpParams[2].nextEnginePerEntriesInGrp[1].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[2].nextEnginePerEntriesInGrp[1].
+				params.ccParams.h_CcNode = h_CcNodeOutPreEnc[2];
+
+	cctrees[3] = FM_PCD_CcBuildTree(pcds[0], &ccTreeParams);
+	if (cctrees[3] == NULL) {
+		pr_err("Could not create CC Tree!");
+		return E_INVALID_STATE;
+	}
+
+	/* Distribution: 5_tuple_distribution TCP */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[3];
+	scheme.netEnvParams.numOfDistinctionUnits = 2;
+	scheme.netEnvParams.unitIds[0] = 0;
+	scheme.netEnvParams.unitIds[1] = 2;
+	scheme.useHash = TRUE;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 5;
+	/* Extract field:ipv4.src */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+	/* Extract field:ipv4.dst */
+	scheme.keyExtractAndHashParams.extractArray[1].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+	/* Extract field:ipv4.nextp */
+	scheme.keyExtractAndHashParams.extractArray[2].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+	/* Extract field:tcp.sport */
+	scheme.keyExtractAndHashParams.extractArray[3].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.hdr = HEADER_TYPE_TCP;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.extractByHdrType.
+				fullField.tcp = NET_HEADER_FIELD_TCP_PORT_SRC;
+	/* Extract field:tcp.dport */
+	scheme.keyExtractAndHashParams.extractArray[4].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.hdr = HEADER_TYPE_TCP;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.extractByHdrType.
+				fullField.tcp = NET_HEADER_FIELD_TCP_PORT_DST;
+	scheme.baseFqid = UL_POST_IPSEC_OH_TX_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[3];
+	scheme.kgNextEngineParams.cc.grpId = 0;
+	scheme.schemeCounter.update = TRUE;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == NULL) {
+		pr_err("Could not create KG Scheme!");
+		return E_INVALID_STATE;
+	}
+	scheme_idx++;
+
+	/* Distribution: 5_tuple_distribution UDP */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[3];
+	scheme.netEnvParams.numOfDistinctionUnits = 2;
+	scheme.netEnvParams.unitIds[0] = 0;
+	scheme.netEnvParams.unitIds[1] = 1;
+	scheme.useHash = TRUE;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 5;
+	/* Extract field:ipv4.src */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+	/* Extract field:ipv4.dst */
+	scheme.keyExtractAndHashParams.extractArray[1].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+	/* Extract field:ipv4.nextp */
+	scheme.keyExtractAndHashParams.extractArray[2].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+	/* Extract field:udp.sport */
+	scheme.keyExtractAndHashParams.extractArray[3].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.hdr = HEADER_TYPE_UDP;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.extractByHdrType.
+				fullField.udp = NET_HEADER_FIELD_UDP_PORT_SRC;
+	/* Extract field:udp.dport */
+	scheme.keyExtractAndHashParams.extractArray[4].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.hdr = HEADER_TYPE_UDP;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.extractByHdrType.
+				fullField.udp = NET_HEADER_FIELD_UDP_PORT_DST;
+	scheme.baseFqid = UL_POST_IPSEC_OH_TX_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[3];
+	scheme.kgNextEngineParams.cc.grpId = 1;
+	scheme.schemeCounter.update = TRUE;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == NULL) {
+		pr_err("Could not create KG Scheme!");
+		return E_INVALID_STATE;
+	}
+	scheme_idx++;
+
+	/* Distribution: ICMP distribution */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[3];
+	scheme.netEnvParams.numOfDistinctionUnits = 2;
+	scheme.netEnvParams.unitIds[0] = 0;
+	scheme.netEnvParams.unitIds[1] = 3;
+	scheme.useHash = TRUE;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 4;
+	/* Extract field:ipv4.src */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+	/* Extract field:ipv4.dst */
+	scheme.keyExtractAndHashParams.extractArray[1].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+	/* Extract field:ipv4.nextp */
+	scheme.keyExtractAndHashParams.extractArray[2].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+	/* Extract field:dflt value */
+	scheme.keyExtractAndHashParams.extractArray[3].
+				type = e_FM_PCD_EXTRACT_NON_HDR;
+	scheme.keyExtractAndHashParams.extractArray[3].
+			extractNonHdr.src = e_FM_PCD_EXTRACT_FROM_DFLT_VALUE;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractNonHdr.offset = 0;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractNonHdr.size = UDP_SRC_AND_DEST_PORT_SIZE;
+
+	/* Default values */
+	scheme.keyExtractAndHashParams.
+				privateDflt0 = UDP_SRC_AND_DEST_PORT_DEF_VAL;
+	scheme.keyExtractAndHashParams.
+			numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+	for (i = 0; i < FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; i++) {
+		scheme.keyExtractAndHashParams.dflts[i].
+				type = (e_FmPcdKgKnownFieldsDfltTypes)i;
+		scheme.keyExtractAndHashParams.dflts[i].
+				dfltSelect = e_FM_PCD_KG_DFLT_PRIVATE_0;
+	}
+
+	scheme.baseFqid = UL_POST_IPSEC_OH_TX_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[3];
+	scheme.kgNextEngineParams.cc.grpId = 2;
+	scheme.schemeCounter.update = TRUE;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == NULL) {
+		pr_err("Could not create KG Scheme!");
+		return E_INVALID_STATE;
+	}
+	scheme_idx++;
+
+	/* Distribution: ul_oh_pre_ipsec_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[3];
+	scheme.netEnvParams.numOfDistinctionUnits = 0;
+	scheme.useHash = 0;
+	scheme.baseFqid = UL_POST_IPSEC_OH_TX_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_DONE;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 2;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Initialize PCD parameters */
+	memset(&pcdParam, 0, sizeof(pcdParam));
+	pcdParam.h_NetEnv = env_ids[3];
+	pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+	pcdParam.p_PrsParams = &prsParam;
+	pcdParam.p_KgParams = &kgParam;
+	pcdParam.p_CcParams = &ccParam;
+
+	/* Initialize parser parameters */
+	memset(&prsParam, 0, sizeof(prsParam));
+	prsParam.parsingOffset = 0;
+	prsParam.prsResultPrivateInfo = 0;
+	prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+	prsParam.numOfHdrsWithAdditionalParams = 2;
+	prsParam.additionalParams[0].hdr = HEADER_TYPE_UDP;
+	prsParam.additionalParams[0].errDisable = FALSE;
+	prsParam.additionalParams[0].swPrsEnable = TRUE;
+	prsParam.additionalParams[0].usePrsOpts = FALSE;
+	prsParam.additionalParams[0].indexPerHdr = 0;
+	prsParam.additionalParams[0].usePrsOpts = FALSE;
+	prsParam.additionalParams[1].hdr = HEADER_TYPE_IPv4;
+	prsParam.additionalParams[1].errDisable = FALSE;
+	prsParam.additionalParams[1].swPrsEnable = TRUE;
+	prsParam.additionalParams[1].usePrsOpts = FALSE;
+	prsParam.additionalParams[1].indexPerHdr = 0;
+	prsParam.additionalParams[1].usePrsOpts = FALSE;
+
+	/* Initialize KeyGen parameters */
+	memset(&kgParam, 0, sizeof(kgParam));
+
+	kgParam.numOfSchemes = 4;
+	kgParam.h_Schemes[0] = schemes[scheme_idx-3];
+	kgParam.h_Schemes[1] = schemes[scheme_idx-2];
+	kgParam.h_Schemes[2] = schemes[scheme_idx-1];
+	kgParam.h_Schemes[3] = schemes[scheme_idx];
+
+	scheme_idx++;
+
+	/* initialize coarse classification port parameters */
+	memset(&ccParam, 0, sizeof(ccParam));
+	ccParam.h_CcTree = cctrees[3];
+
+	/* Apply the configuration */
+	FM_PORT_Disable(*(ports[3]));
+	FM_PORT_SetPCD(*(ports[3]), &pcdParam);
+	FM_PORT_Enable(*(ports[3]));
+
+	/*******************************************************/
+	/************************ DL_POST_IPSEC_OH  ************/
+
+	memset(&distinctionUnits, 0, sizeof(distinctionUnits));
+	distinctionUnits.numOfDistinctionUnits = 2;
+	distinctionUnits.units[0].hdrs[0].hdr = HEADER_TYPE_UDP;
+	distinctionUnits.units[1].hdrs[0].hdr = HEADER_TYPE_IPv4;
+	distinctionUnits.units[1].hdrs[0].opt.ipv4Opt = IPV4_FRAG_1;
+
+	env_ids[2] = FM_PCD_SetNetEnvCharacteristics(pcds[0],
+				&distinctionUnits);
+	if (env_ids[2] == 0)
+		return E_INVALID_HANDLE;
+
+	/* IP Reassembly Manips */
+	memset(&manipParam, 0, sizeof(manipParam));
+	manipParam.fragOrReasm = TRUE;
+	manipParam.fragOrReasmParams.frag = FALSE;
+	manipParam.fragOrReasmParams.hdr = HEADER_TYPE_IPv4;
+	manipParam.fragOrReasmParams.extBufPoolIndx = 9;
+	manipParam.fragOrReasmParams.ipReasmParams.
+				maxNumFramesInProcess = 1024;
+	manipParam.fragOrReasmParams.
+				ipReasmParams.
+		timeOutMode = e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG;
+	manipParam.fragOrReasmParams.
+		ipReasmParams.fqidForTimeOutFrames = 473;
+	manipParam.fragOrReasmParams.
+		ipReasmParams.
+		numOfFramesPerHashEntry =  e_FM_PCD_MANIP_EIGHT_WAYS_HASH;
+	manipParam.fragOrReasmParams.
+		ipReasmParams.timeoutThresholdForReassmProcess = 100000;
+	manipParam.fragOrReasmParams.
+		ipReasmParams.relativeSchemeId[0] = relativeSchemeId++;
+	manipParam.fragOrReasmParams.ipReasmParams.minFragSize[0] = 0;
+
+	manips[manipId] = FM_PCD_ManipSetNode(pcds[0], &manipParam);
+	if (manips[manipId] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Coarse classification node: dl_oh_udp_classf */
+	memset(&ccNodeParam, 0, sizeof(ccNodeParam));
+
+	ccNodeParam.extractCcParams.type = e_FM_PCD_EXTRACT_BY_HDR;
+	ccNodeParam.extractCcParams.extractByHdr.hdr = HEADER_TYPE_UDP;
+	ccNodeParam.extractCcParams.extractByHdr.
+				hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	ccNodeParam.extractCcParams.extractByHdr.
+				type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	ccNodeParam.extractCcParams.extractByHdr.
+				extractByHdrType.
+				fullField.udp = NET_HEADER_FIELD_UDP_PORT_DST;
+	ccNodeParam.keysParams.numOfKeys = 1;
+	ccNodeParam.keysParams.keySize = 2;
+	ccNodeParam.keysParams.keyParams[0].p_Key = keydata[0];
+	ccNodeParam.keysParams.keyParams[0].p_Mask = mask[0];
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.nextEngine = e_FM_PCD_DONE;
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.params.enqueueParams.
+				overrideFqid = 1;
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.params.enqueueParams.
+				newFqid = DL_GTP_QUEUE;
+	ccNodeParam.keysParams.ccNextEngineParamsForMiss.
+				nextEngine = e_FM_PCD_DONE;
+	ccNodeParam.keysParams.ccNextEngineParamsForMiss.
+				params.enqueueParams.overrideFqid = 0;
+	ccnodes[1] = FM_PCD_CcSetNode(pcds[0], &ccNodeParam);
+	if (ccnodes[1] == 0)
+		return E_INVALID_HANDLE;
+
+	InitIpsecPortPcd(&h_CcNodeFlowId, &NumCcNodes,
+		e_IN_POST_DEC, dipParams);
+
+	/* CC Tree for the current port */
+	memset(&ccTreeParams, 0, sizeof(ccTreeParams));
+	ccTreeParams.numOfGrps = 2;
+	ccTreeParams.h_NetEnv = env_ids[2];
+	ccTreeParams.ccGrpParams[0].numOfDistinctionUnits = 0;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				params.ccParams.h_CcNode = ccnodes[1];
+	h_CcNodeInPostDec = ccnodes[1];
+
+	ccTreeParams.ccGrpParams[1].numOfDistinctionUnits = 0;
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[0].
+				params.ccParams.h_CcNode = h_CcNodeFlowId;
+
+	/* Reassembly manip is given as a parameter to the tree */
+	ccTreeParams.h_IpReassemblyManip = manips[manipId];
+	manipId++;
+
+	cctrees[2] = FM_PCD_CcBuildTree(pcds[0], &ccTreeParams);
+	if (cctrees[2] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Distribution: dl_oh_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[2];
+	scheme.netEnvParams.numOfDistinctionUnits = 1;
+	scheme.netEnvParams.unitIds[0] = 0;
+	scheme.useHash = 1;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 1;
+	/* Extract field:udp.dport */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_UDP;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = 0;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.udp = NET_HEADER_FIELD_UDP_PORT_DST;
+	scheme.baseFqid = DL_UDP_UPLANE_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[2];
+	scheme.kgNextEngineParams.cc.grpId = 1;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	scheme_idx++;
+
+	/* Distribution: dl_oh_default_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[2];
+	scheme.netEnvParams.numOfDistinctionUnits = 0;
+	scheme.useHash = 0;
+	scheme.baseFqid = DL_NON_UDP_UPLANE_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_DONE;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Initialize PCD parameters */
+	memset(&pcdParam, 0, sizeof(pcdParam));
+	pcdParam.h_NetEnv = env_ids[2];
+	pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+	pcdParam.p_PrsParams = &prsParam;
+	pcdParam.p_KgParams = &kgParam;
+	pcdParam.p_CcParams = &ccParam;
+
+	/* Initialize parser parameters */
+	memset(&prsParam, 0, sizeof(prsParam));
+	prsParam.parsingOffset = 0;
+	prsParam.prsResultPrivateInfo = 0;
+	prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+
+	/* Initialize KeyGen parameters */
+	memset(&kgParam, 0, sizeof(kgParam));
+	kgParam.numOfSchemes = 2;
+	kgParam.h_Schemes[0] = schemes[scheme_idx-1];
+	kgParam.h_Schemes[1] = schemes[scheme_idx];
+	scheme_idx++;
+
+	/* initialize coarse classification port parameters */
+	memset(&ccParam, 0, sizeof(ccParam));
+	ccParam.h_CcTree = cctrees[2];
+
+	/* Apply the configuration */
+	FM_PORT_Disable(*(ports[2]));
+	FM_PORT_SetPCD(*(ports[2]), &pcdParam);
+	FM_PORT_Enable(*(ports[2]));
+
+	/****************************************************************/
+	/******************************* UL_RX **************************/
+
+	memset(&distinctionUnits, 0, sizeof(distinctionUnits));
+	distinctionUnits.numOfDistinctionUnits = 0;
+	env_ids[1] = FM_PCD_SetNetEnvCharacteristics(pcds[0],
+			&distinctionUnits);
+	if (env_ids[1] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Distribution: dl_rx_port_hash_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[1];
+	scheme.netEnvParams.numOfDistinctionUnits = 0;
+	scheme.useHash = 0;
+	scheme.baseFqid = UL_RX_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_DONE;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Initialize PCD parameters */
+	memset(&pcdParam, 0, sizeof(pcdParam));
+	pcdParam.h_NetEnv = env_ids[1];
+	pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG;
+	pcdParam.p_PrsParams = &prsParam;
+	pcdParam.p_KgParams = &kgParam;
+
+	/* Initialize parser parameters */
+	memset(&prsParam, 0, sizeof(prsParam));
+	prsParam.parsingOffset = 0;
+	prsParam.prsResultPrivateInfo = 0;
+	prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+
+	/* Initialize KeyGen parameters */
+	memset(&kgParam, 0, sizeof(kgParam));
+	kgParam.numOfSchemes = 1;
+	kgParam.h_Schemes[0] = schemes[scheme_idx];
+	scheme_idx++;
+
+	/* Apply the configuration */
+	FM_PORT_Disable(*(ports[1]));
+	FM_PORT_SetPCD(*(ports[1]), &pcdParam);
+	FM_PORT_Enable(*(ports[1]));
+
+
+	/******************************************************************/
+	/**************************** DL_RX *******************************/
+	rx_port = container_of(ports[0], t_LnxWrpFmPortDev, h_Dev);
+	memset(&distinctionUnits, 0, sizeof(distinctionUnits));
+	distinctionUnits.numOfDistinctionUnits = 5;
+	distinctionUnits.units[0].hdrs[0].hdr = HEADER_TYPE_IPv4;
+	distinctionUnits.units[1].hdrs[0].hdr = HEADER_TYPE_UDP;
+	distinctionUnits.units[2].hdrs[0].hdr = HEADER_TYPE_IPSEC_ESP;
+	distinctionUnits.units[3].hdrs[0].hdr = HEADER_TYPE_UDP_ENCAP_ESP;
+	distinctionUnits.units[4].hdrs[0].hdr = HEADER_TYPE_IPv4;
+	distinctionUnits.units[4].hdrs[0].opt.ipv4Opt = IPV4_FRAG_1;
+
+	env_ids[0] = FM_PCD_SetNetEnvCharacteristics(pcds[0],
+			&distinctionUnits);
+	if (env_ids[0] == 0)
+		return E_INVALID_HANDLE;
+
+	/* IP Reassembly Manips */
+	memset(&manipParam, 0, sizeof(manipParam));
+	manipParam.fragOrReasm = TRUE;
+	manipParam.fragOrReasmParams.frag = FALSE;
+	manipParam.fragOrReasmParams.hdr = HEADER_TYPE_IPv4;
+	manipParam.fragOrReasmParams.extBufPoolIndx = 9;
+	manipParam.fragOrReasmParams.ipReasmParams.maxNumFramesInProcess = 1024;
+	manipParam.fragOrReasmParams.ipReasmParams.
+			timeOutMode = e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG;
+	manipParam.fragOrReasmParams.ipReasmParams.
+				fqidForTimeOutFrames = 472;
+	manipParam.fragOrReasmParams.ipReasmParams.
+		numOfFramesPerHashEntry =  e_FM_PCD_MANIP_EIGHT_WAYS_HASH;
+	manipParam.fragOrReasmParams.ipReasmParams.
+			timeoutThresholdForReassmProcess = 100000;
+	manipParam.fragOrReasmParams.ipReasmParams.
+			relativeSchemeId[0] = relativeSchemeId++;
+	manipParam.fragOrReasmParams.ipReasmParams.minFragSize[0] = 0;
+	manipParam.fragOrReasmParams.ipReasmParams.
+			liodnOffset = rx_port->settings.param.
+					specificParams.rxParams.liodnOffset;
+
+	manips[manipId] = FM_PCD_ManipSetNode(pcds[0], &manipParam);
+	if (manips[manipId] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Coarse classification node: dl_rx_udp_classf */
+	memset(&ccNodeParam, 0, sizeof(ccNodeParam));
+
+	ccNodeParam.extractCcParams.type = e_FM_PCD_EXTRACT_BY_HDR;
+	ccNodeParam.extractCcParams.extractByHdr.hdr = HEADER_TYPE_UDP;
+	ccNodeParam.extractCcParams.extractByHdr.
+				hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	ccNodeParam.extractCcParams.extractByHdr.
+				type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	ccNodeParam.extractCcParams.extractByHdr.
+				extractByHdrType.
+				fullField.udp = NET_HEADER_FIELD_UDP_PORT_DST;
+	ccNodeParam.keysParams.numOfKeys = 1;
+	ccNodeParam.keysParams.keySize = 2;
+	ccNodeParam.keysParams.keyParams[0].p_Key = keydata[0];
+	ccNodeParam.keysParams.keyParams[0].p_Mask = mask[0];
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.nextEngine = e_FM_PCD_DONE;
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.params.
+				enqueueParams.overrideFqid = 1;
+	ccNodeParam.keysParams.keyParams[0].
+				ccNextEngineParams.params.
+				enqueueParams.newFqid = DL_GTP_QUEUE;
+	ccNodeParam.keysParams.ccNextEngineParamsForMiss.
+				nextEngine = e_FM_PCD_DONE;
+	ccNodeParam.keysParams.ccNextEngineParamsForMiss.
+				params.enqueueParams.overrideFqid = 0;
+
+	ccnodes[0] = FM_PCD_CcSetNode(pcds[0], &ccNodeParam);
+	if (ccnodes[0] == 0)
+		return E_INVALID_HANDLE;
+
+	/* ->ipsec port */
+	InitIpsecPortPcd(&h_CcNodeInRx, &NumCcNodes, e_IN_RX, dipParams);
+	/* ipsec port <-*/
+
+	/* CC Tree for the current port */
+	memset(&ccTreeParams, 0, sizeof(ccTreeParams));
+	ccTreeParams.numOfGrps = 2;
+	ccTreeParams.h_NetEnv = env_ids[0];
+	ccTreeParams.ccGrpParams[0].numOfDistinctionUnits = 0;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.
+				ccParams.h_CcNode = ccnodes[0];
+
+	/* ->ipsec port */
+	ccTreeParams.ccGrpParams[1].numOfDistinctionUnits = 0;
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[0].
+				nextEngine = e_FM_PCD_CC;
+	ccTreeParams.ccGrpParams[1].nextEnginePerEntriesInGrp[0].
+				params.ccParams.h_CcNode = h_CcNodeInRx;
+	/* ipsec port <-*/
+
+	/* Reassembly manip is given as a parameter to the tree */
+	ccTreeParams.h_IpReassemblyManip = manips[manipId];
+	manipId++;
+
+	cctrees[0] = FM_PCD_CcBuildTree(pcds[0], &ccTreeParams);
+	if (cctrees[0] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Distribution: UDP ESP distribution */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[0];
+	scheme.netEnvParams.numOfDistinctionUnits = 2;
+	scheme.netEnvParams.unitIds[0] = 0;
+	scheme.netEnvParams.unitIds[1] = 3;
+	scheme.useHash = 1;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 5;
+	/* Extract field:ipv4.src */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+	/* Extract field:ipv4.proto */
+	scheme.keyExtractAndHashParams.extractArray[1].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+	/* Extract field:udp_ipsec_esp.sport */
+	scheme.keyExtractAndHashParams.extractArray[2].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdr = HEADER_TYPE_UDP_ENCAP_ESP;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.extractByHdrType.fullField.
+			udpEncapEsp = NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC;
+	/* Extract field:udp_ipsec_esp.dport */
+	scheme.keyExtractAndHashParams.extractArray[3].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.hdr = HEADER_TYPE_UDP_ENCAP_ESP;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[3].
+				extractByHdr.extractByHdrType.
+				fullField.
+			udpEncapEsp = NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST;
+	/* Extract field:udp_ipsec_esp.spi */
+	scheme.keyExtractAndHashParams.extractArray[4].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.hdr = HEADER_TYPE_UDP_ENCAP_ESP;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[4].
+				extractByHdr.extractByHdrType.
+		fullField.udpEncapEsp = NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI;
+	/* Default values */
+	scheme.keyExtractAndHashParams.
+				privateDflt0 = UDP_SRC_AND_DEST_PORT_DEF_VAL;
+	scheme.keyExtractAndHashParams.
+			numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+
+	for (i = 0; i < FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; i++) {
+		scheme.keyExtractAndHashParams.dflts[i].
+				type = (e_FmPcdKgKnownFieldsDfltTypes)i;
+		scheme.keyExtractAndHashParams.dflts[i].
+				dfltSelect = e_FM_PCD_KG_DFLT_PRIVATE_0;
+	}
+
+	scheme.baseFqid =  DL_IPSEC_HOST_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[0];
+	scheme.kgNextEngineParams.cc.grpId = 1;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == NULL) {
+		pr_err("Could not create KG Scheme!");
+		return E_INVALID_STATE;
+	}
+
+	scheme_idx++;
+
+	/* Distribution: ESP distribution */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[0];
+	scheme.netEnvParams.numOfDistinctionUnits = 2;
+	scheme.netEnvParams.unitIds[0] = 0;		/*ipv4 unit id*/
+	scheme.netEnvParams.unitIds[1] = 2;		/*esp unit id*/
+	scheme.useHash = 1;
+	scheme.keyExtractAndHashParams.numOfUsedExtracts = 4;
+	/* Extract field:ipv4.dst */
+	scheme.keyExtractAndHashParams.extractArray[0].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[0].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+	/* Extract field:ipv4.proto */
+	scheme.keyExtractAndHashParams.extractArray[1].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdr = HEADER_TYPE_IPv4;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[1].
+				extractByHdr.extractByHdrType.
+				fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+	/* Extract field:ipsec_esp.spi */
+	scheme.keyExtractAndHashParams.extractArray[2].
+				type = e_FM_PCD_EXTRACT_BY_HDR;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdr = HEADER_TYPE_IPSEC_ESP;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.hdrIndex = e_FM_PCD_HDR_INDEX_NONE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.ignoreProtocolValidation = FALSE;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+	scheme.keyExtractAndHashParams.extractArray[2].
+				extractByHdr.extractByHdrType.
+			fullField.ipsecEsp = NET_HEADER_FIELD_IPSEC_ESP_SPI;
+	/* Extract field:dflt value - to replace udp sport and udp dport*/
+	scheme.keyExtractAndHashParams.extractArray[3].
+				type = e_FM_PCD_EXTRACT_NON_HDR;
+	scheme.keyExtractAndHashParams.extractArray[3].
+			extractNonHdr.src = e_FM_PCD_EXTRACT_FROM_DFLT_VALUE;
+	scheme.keyExtractAndHashParams.extractArray[3].extractNonHdr.offset = 0;
+	scheme.keyExtractAndHashParams.extractArray[3].
+			extractNonHdr.size = UDP_SRC_AND_DEST_PORT_SIZE;
+	/* Default values */
+	scheme.keyExtractAndHashParams.
+				privateDflt0 = UDP_SRC_AND_DEST_PORT_DEF_VAL;
+	scheme.keyExtractAndHashParams.
+			numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+	for (i = 0; i < FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; i++) {
+		scheme.keyExtractAndHashParams.dflts[i].
+				type = (e_FmPcdKgKnownFieldsDfltTypes)i;
+		scheme.keyExtractAndHashParams.dflts[i].
+				dfltSelect = e_FM_PCD_KG_DFLT_PRIVATE_0;
+	}
+	scheme.baseFqid = DL_IPSEC_HOST_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[0];
+	scheme.kgNextEngineParams.cc.grpId = 1;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == NULL) {
+		pr_err("Could not create KG Scheme!");
+		return E_INVALID_STATE;
+	}
+	scheme_idx++;
+
+	/* Distribution: dl_rx_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId  = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[0];
+	scheme.netEnvParams.numOfDistinctionUnits = 1;
+	scheme.netEnvParams.unitIds[0] = 1;
+	scheme.useHash = 0;
+	scheme.baseFqid = DL_UDP_UPLANE_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_CC;
+	scheme.kgNextEngineParams.cc.h_CcTree = cctrees[0];
+	scheme.kgNextEngineParams.cc.grpId = 0;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	scheme_idx++;
+
+	/* Distribution: dl_default_dist */
+	memset(&scheme, 0, sizeof(scheme));
+	scheme.modify = 0;
+	scheme.id.relativeSchemeId = relativeSchemeId++;
+	scheme.alwaysDirect = 0;
+	scheme.netEnvParams.h_NetEnv = env_ids[0];
+	scheme.netEnvParams.numOfDistinctionUnits = 0;
+	scheme.useHash = 0;
+	scheme.baseFqid = DL_HOST_QUEUE;
+	scheme.numOfUsedExtractedOrs = 0;
+	scheme.nextEngine = e_FM_PCD_DONE;
+	scheme.schemeCounter.update = 1;
+	scheme.schemeCounter.value = 0;
+	scheme.keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+	scheme.keyExtractAndHashParams.numOfUsedMasks = 0;
+	scheme.keyExtractAndHashParams.hashShift = 0;
+	scheme.keyExtractAndHashParams.symmetricHash = 0;
+	schemes[scheme_idx] = FM_PCD_KgSetScheme(pcds[0], &scheme);
+	if (schemes[scheme_idx] == 0)
+		return E_INVALID_HANDLE;
+
+	/* Initialize PCD parameters */
+	memset(&pcdParam, 0, sizeof(pcdParam));
+	pcdParam.h_NetEnv = env_ids[0];
+	pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+	pcdParam.p_PrsParams = &prsParam;
+	pcdParam.p_KgParams = &kgParam;
+	pcdParam.p_CcParams = &ccParam;
+
+	/* Initialize parser parameters */
+	memset(&prsParam, 0, sizeof(prsParam));
+	prsParam.parsingOffset = 0;
+	prsParam.prsResultPrivateInfo = 0;
+	prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+
+	/* Initialize KeyGen parameters */
+	memset(&kgParam, 0, sizeof(kgParam));
+	kgParam.numOfSchemes = 4;
+	kgParam.h_Schemes[0] = schemes[scheme_idx-3];
+	kgParam.h_Schemes[1] = schemes[scheme_idx-2];
+	kgParam.h_Schemes[2] = schemes[scheme_idx-1];
+	kgParam.h_Schemes[3] = schemes[scheme_idx];
+
+	/* initialize coarse classification port parameters */
+	memset(&ccParam, 0, sizeof(ccParam));
+	ccParam.h_CcTree = cctrees[0];
+
+	/* Apply the configuration */
+	FM_PORT_Disable(*(ports[0]));
+	FM_PORT_SetPCD(*(ports[0]), &pcdParam);
+	FM_PORT_Enable(*(ports[0]));
+
+	return E_OK;
+}
+
+/* fmc_config wrapper function */
+int do_fmc_config(struct dpa_ipsec_params *dipParams)
+{
+	t_LnxWrpFmDev *fm;
+	t_LnxWrpFmPortDev *port;
+	int error = E_OK;
+
+	fm = get_fm(FM);
+	if (!fm)
+		return E_NOT_AVAILABLE;
+	pcds[0] = fm->h_PcdDev;
+
+	pr_info("Using ports :");
+
+	port = get_fm_port(FM, UL_POST_IPSEC_OH,
+		e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return E_NOT_AVAILABLE;
+
+	pr_info("%s UL_POST_IPSEC_OH ", port->name);
+	ports[4] = &port->h_Dev;
+	error = FM_PORT_SetOpWorkarounds(*ports[4],
+					FM_OP_PORT_WA_SEC_ERR |
+					FM_OP_PORT_WA_ETH_TYPE |
+					FM_OP_PORT_WA_COPY_CTXB |
+					FM_OP_PORT_WA_DISABLE_UDP_CKSM |
+					FM_OP_PORT_WA_UPDATE_UDP_LEN);
+	if (error != E_OK) {
+		printk("Cannot Activate FlowID WA!");
+		return -EINVAL;
+	}
+
+	port = get_fm_port(FM, UL_PRE_IPSEC_OH,
+		e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return E_NOT_AVAILABLE;
+
+	pr_info("%s UL_PRE_IPSEC_OH", port->name);
+	ports[3] = &port->h_Dev;
+
+	port = get_fm_port(FM, DL_POST_IPSEC_OH,
+		e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return E_NOT_AVAILABLE;
+
+	pr_info("%s DL_POST_IPSEC_OH", port->name);
+	ports[2] = &port->h_Dev;
+	error = FM_PORT_SetOpWorkarounds(*ports[2],
+					FM_OP_PORT_WA_SEC_ERR |
+					FM_OP_PORT_WA_ETH_TYPE |
+					FM_OP_PORT_WA_COPY_CTXB |
+					FM_OP_PORT_WA_DISABLE_UDP_CKSM);
+	if (error != E_OK) {
+		printk("Cannot Activate FlowID WA!");
+		return -EINVAL;
+	}
+
+	port = get_fm_port(FM, UL_RX, e_FM_PORT_TYPE_RX);
+	if (!port || !port->pcd_owner_params.dev)
+		return E_NOT_AVAILABLE;
+
+	pr_info("%s UL_RX", port->name);
+	ports[1] = &port->h_Dev;
+
+	port = get_fm_port(FM, DL_RX, e_FM_PORT_TYPE_RX);
+	if (!port || !port->pcd_owner_params.dev)
+		return E_NOT_AVAILABLE;
+
+	if (enable_loopback) {
+		error = config_loopback(FM, DL_RX);
+		if (error != E_OK) {
+			pr_err("%s : Cannot set loopback on interface!\n",
+				__func__);
+			return error;
+		}
+	}
+
+
+	pr_info("%s DL_RX\n", port->name);
+	ports[0] = &port->h_Dev;
+
+	pr_info("Applying PCD\n");
+
+	return fmc_config(dipParams);
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc_config_ipsec.c b/drivers/staging/fsl_dpa_offload/usecases/fmc_config_ipsec.c
new file mode 100644
index 0000000..132609e
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc_config_ipsec.c
@@ -0,0 +1,138 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ Generates all PCD structures required by DPA IPsec domain
+ */
+#include "std_ext.h"
+#include "types_ext.h"
+#include <linux/fsl_dpa_ipsec.h>
+#include "queues_conf.h"
+#include "dip_init.h"
+#include "fm_pcd_ext.h"
+
+static t_FmPcdCcNodeParams ccNodeParam;
+
+/*
+  Creates CC nodes required by IPsec for each port
+  Returns pointers to CCnodes and the number of created CCnodes for each port
+ */
+void InitIpsecPortPcd(t_Handle *h_CcNodes, int *NumCcNodes,
+		      enum e_PortId PortId, struct dpa_ipsec_params *dipParams)
+{
+	int i;
+	switch (PortId) {
+	case e_IN_RX:
+		memset(&ccNodeParam, 0, sizeof(ccNodeParam));
+		ccNodeParam.extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+		ccNodeParam.extractCcParams.extractNonHdr.src =
+		    e_FM_PCD_EXTRACT_FROM_HASH;
+		ccNodeParam.extractCcParams.extractNonHdr.action =
+		    e_FM_PCD_ACTION_INDEXED_LOOKUP;
+		ccNodeParam.extractCcParams.extractNonHdr.offset =
+		    IN_SA_PCD_HASH_OFF;
+		ccNodeParam.extractCcParams.extractNonHdr.size = 2;
+		ccNodeParam.extractCcParams.extractNonHdr.icIndxMask =
+		    (IN_SA_PCD_HASH_SETS - 1) << 4;
+		ccNodeParam.keysParams.numOfKeys = IN_SA_PCD_HASH_SETS;
+		ccNodeParam.keysParams.keySize = 2;
+		for (i = 0; i < IN_SA_PCD_HASH_SETS; i++) {
+			ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+			    nextEngine = e_FM_PCD_DONE;
+		}
+		h_CcNodes[0] =
+		    FM_PCD_CcSetNode(dipParams->fm_pcd, &ccNodeParam);
+		*NumCcNodes = 1;
+		break;
+
+	case e_IN_POST_DEC:
+		memset(&ccNodeParam, 0, sizeof(ccNodeParam));
+		ccNodeParam.extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+		ccNodeParam.extractCcParams.extractNonHdr.src =
+		    e_FM_PCD_EXTRACT_FROM_FLOW_ID;
+		ccNodeParam.extractCcParams.extractNonHdr.action =
+		    e_FM_PCD_ACTION_INDEXED_LOOKUP;
+		ccNodeParam.extractCcParams.extractNonHdr.offset = 0;
+		ccNodeParam.extractCcParams.extractNonHdr.size = 2;
+
+		ccNodeParam.keysParams.numOfKeys = dipParams->max_sa_pairs;
+
+		ccNodeParam.extractCcParams.extractNonHdr.icIndxMask =
+		    (uint16_t) ((ccNodeParam.keysParams.numOfKeys - 1) << 4);
+		ccNodeParam.keysParams.keySize = 2;
+		for (i = 0; i < ccNodeParam.keysParams.numOfKeys; i++) {
+			ccNodeParam.keysParams.keyParams[i].ccNextEngineParams.
+			    nextEngine = e_FM_PCD_DONE;
+		}
+		h_CcNodes[0] =
+		    FM_PCD_CcSetNode(dipParams->fm_pcd, &ccNodeParam);
+		*NumCcNodes = 1;
+		break;
+
+	case e_OUT_PRE_ENC:
+		for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
+			memset(&ccNodeParam, 0, sizeof(ccNodeParam));
+			ccNodeParam.extractCcParams.type =
+			    e_FM_PCD_EXTRACT_NON_HDR;
+			ccNodeParam.extractCcParams.extractNonHdr.src =
+			    e_FM_PCD_EXTRACT_FROM_KEY;
+			ccNodeParam.extractCcParams.extractNonHdr.action =
+			    e_FM_PCD_ACTION_EXACT_MATCH;
+			ccNodeParam.extractCcParams.extractNonHdr.offset = 0;
+			ccNodeParam.extractCcParams.extractNonHdr.size =
+			    MAX_SIZE_POLICY_KEY_IPV4;
+
+			ccNodeParam.keysParams.numOfKeys = 0;
+			ccNodeParam.keysParams.keySize =
+			    MAX_SIZE_POLICY_KEY_IPV4;
+
+			ccNodeParam.keysParams.ccNextEngineParamsForMiss.
+			    nextEngine = e_FM_PCD_DONE;
+			ccNodeParam.keysParams.ccNextEngineParamsForMiss.params.
+			    enqueueParams.overrideFqid = TRUE;
+			ccNodeParam.keysParams.ccNextEngineParamsForMiss.params.
+			    enqueueParams.newFqid = UL_POST_IPSEC_OH_TX_QUEUE;
+
+			h_CcNodes[i] =
+			    FM_PCD_CcSetNode(dipParams->fm_pcd, &ccNodeParam);
+		}
+		*NumCcNodes = DPA_IPSEC_MAX_SUPPORTED_PROTOS;
+
+		break;
+
+	case e_OUT_POST_ENC:
+		*NumCcNodes = 0;
+		break;
+
+	default:
+		break;
+	};
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
new file mode 100644
index 0000000..d0250ab
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/main.c
@@ -0,0 +1,207 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fsl_bman.h>
+#include <linux/fsl_qman.h>
+
+#include "platform_defs.h"
+#include "utils.h"
+#include "queues_conf.h"
+#include "ports_conf.h"
+#include "pools.h"
+#include "dip_init.h"
+#include "xfrm_km.h"
+
+/* Kernel default pool reference */
+struct bman_pool *default_pool;
+
+struct net_device *eth_dev;
+
+/* Frame queues */
+/* Downlink static frame queues */
+static struct qman_fq dl_host_fq,
+		dl_ipsec_host_fq,
+		ul_tx_fq,
+		ul_post_ipsec_oh_tx_fq;
+
+/************** Module parameters **********************************/
+/* CPU where USDPAA application thread runs */
+int usdpaa_cpu = 1;
+module_param(usdpaa_cpu, int, 0);
+MODULE_PARM_DESC(usdpaa_cpu, "\tCPU where USDPAA app thread runs");
+
+/* DPAA tap interface name */
+static char *eth_if;
+module_param(eth_if, charp, 0);
+MODULE_PARM_DESC(eth_if, "\tEthernet tap interface name");
+
+/* DPAA tap  Rx queue FQID */
+static int eth_rx_fqid;
+module_param(eth_rx_fqid, int, 0);
+struct qman_fq *eth_rx_fq;
+MODULE_PARM_DESC(eth_rx_fqid, "\tEthernet tap interface Rx FQID to use");
+
+/* USDPAA buffer pools ids and references */
+/* BMAN has maximum 64 pools - USDPAA bpid is an index in this array */
+struct bman_pool *usdpaa_pools[64];
+int bpids[64] = {7, 8, 9};
+static int bpids_argc = 3;
+module_param_array(bpids, int, &bpids_argc, 0);
+MODULE_PARM_DESC(bpids, "\tBuffer pools ids used by USDPAA app");
+
+/*******************************************************************/
+
+int __init usecase_init(void)
+{
+	int ret = 0, i;
+	struct bman_pool_params bp_params;
+
+	const u32 sqdcr_channels_map =
+		QM_SDQCR_CHANNELS_POOL(qm_channel_swportal0);
+
+	qman_static_dequeue_add(sqdcr_channels_map);
+
+
+	/* get references to USDPAA pools */
+	pr_info("USDPAA buffer pools ids : ");
+	for (i = 0; i < bpids_argc; i++) {
+		pr_cont("%d ", bpids[i]);
+		bp_params.bpid = bpids[i];
+		usdpaa_pools[bp_params.bpid] = bman_new_pool(&bp_params);
+		BUG_ON(!usdpaa_pools[bp_params.bpid]);
+		pr_cont("(%p) ", usdpaa_pools[bp_params.bpid]);
+	}
+	pr_cont("\n");
+
+	if (eth_if) {
+		eth_dev = dev_get_by_name(&init_net, eth_if);
+		if (!eth_dev)
+			pr_warning("Interface %s doesn't exist\n", eth_if);
+		else
+			pr_info("Using ethernet interface %s\n", eth_if);
+	}
+
+	if (eth_if && eth_rx_fqid) {
+		/* get a reference to kernel default pool */
+		/* we assume that the interface was configured to use the
+		 * default pool */
+		eth_rx_fq = get_if_ingress_queue(eth_if, eth_rx_fqid);
+		BUG_ON(!eth_rx_fq);
+		pr_info("Using ethernet interface %s Rx queue %d\n",
+			eth_if, qman_fq_fqid(eth_rx_fq));
+
+		default_pool = get_if_pool(eth_if);
+		BUG_ON(!default_pool);
+		pr_info("Got buffer pool default at %p\n",
+				default_pool);
+	}
+
+	/* Downlink static queues  */
+	ret = create_fq(ETH_RX, &dl_host_fq, DL_HOST_QUEUE,
+					SW_PORTAL_CHANNEL(0), 0, &host_cb);
+	BUG_ON(ret);
+	pr_info("Created DL HOST queue fqid %d\n",
+			qman_fq_fqid(&dl_host_fq));
+
+
+	ret = create_fq(ETH_RX, &dl_ipsec_host_fq, DL_IPSEC_HOST_QUEUE,
+					SW_PORTAL_CHANNEL(0), 0, &host_cb);
+	BUG_ON(ret);
+	pr_info("Created DL IPSEC HOST queue fqid %d\n",
+	    qman_fq_fqid(&dl_ipsec_host_fq));
+
+
+	ret = create_fq(
+			OH_TX,
+			&ul_post_ipsec_oh_tx_fq,
+			UL_POST_IPSEC_OH_TX_QUEUE,
+			OH_PORT_CHANNEL(FM, UL_POST_IPSEC_OH),
+			0,
+			&host_cb);
+
+	BUG_ON(ret);
+
+	pr_info("Created UL POST IPSEC OH TX QUEUE queue fqid %d\n",
+		qman_fq_fqid(&ul_post_ipsec_oh_tx_fq));
+
+	ret = create_fq(ETH_TX, &ul_tx_fq, UL_TX_QUEUE,
+			ETH_PORT_CHANNEL(FM, DL_RX), 0, &host_cb);
+
+	BUG_ON(ret);
+	pr_info("Created UL TX QUEUE queue fqid %d\n",
+		qman_fq_fqid(&ul_tx_fq));
+
+
+	if (E_OK != DipInit()) {
+		pr_err("Cannot initialize DPA IPsec\n");
+		return 0;
+	}
+	pr_info("Initialized DPA IPsec\n");
+
+	xfrm_km_init();
+	pr_info("Registered for XFRM key notifications\n");
+
+	return 0;
+}
+
+
+void __exit usecase_exit(void)
+{
+	int i;
+
+	xfrm_km_exit();
+
+	DipCleanup();
+
+	pr_info("Releasing USDPAA buffer pools ids : ");
+	for (i = 0; i < bpids_argc; i++) {
+		pr_cont("%d ", bpids[i]);
+		bman_free_pool(usdpaa_pools[bpids[i]]);
+	}
+
+	pr_cont("\n");
+
+	pr_info("Releasing DL HOST queue fqid %d\n",
+			qman_fq_fqid(&dl_host_fq));
+	teardown_fq(&dl_host_fq);
+
+	pr_info("Releasing DL IPSEC HOST queue fqid %d\n",
+			qman_fq_fqid(&dl_ipsec_host_fq));
+	teardown_fq(&dl_ipsec_host_fq);
+}
+
+
+module_init(usecase_init);
+module_exit(usecase_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h b/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
new file mode 100644
index 0000000..143ff5a
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
@@ -0,0 +1,127 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PLATFORM_H_
+#define _PLATFORM_H_
+
+/* P4080 refman dTDEC */
+#define MACCFG1_LOOPBACK            0x00000100
+#define FM_1GMAC_CMD_CONF_CTRL_OFFSET   0x100
+
+#ifdef CONFIG_P4080_BUILD
+#define SOC_BASE		0xffe000000
+/* P4080 refman MPIC section */
+#define IIDR_BASE		0x50210
+#define JR0_INT_NUM		72
+#define JR_INT_NUM(n)		(JR0_INT_NUM + n)
+#define IIDR(n)			(IIDR_BASE + n*0x20)
+#define QM_CHANNEL_FM0_SP_OH	qm_channel_fman0_sp5
+#define QM_CHANNEL_FM1_SP_OH	qm_channel_fman1_sp5
+#define QM_CHANNEL_FM0_SP_ETH	qm_channel_fman0_sp1
+#define QM_CHANNEL_FM1_SP_ETH	qm_channel_fman1_sp1
+
+#elif defined CONFIG_P3041_BUILD
+#define QM_CHANNEL_FM0_SP_OH	qm_channel_fman0_sp6
+#define QM_CHANNEL_FM1_SP_OH	qm_channel_fman1_sp6
+
+#elif defined CONFIG_P5020_BUILD
+#define QM_CHANNEL_FM0_SP_OH	qm_channel_fman0_sp6
+#define QM_CHANNEL_FM1_SP_OH	qm_channel_fman1_sp6
+#else
+	#error "Build not defined : P4080_BUILD P5020_BUILD P3041_BUILD"
+#endif
+
+
+/*
+ * Return the channel dedicated to a specific 1GB port of the first FMan
+ *
+ * @eth_port_index : index of the ethernet port to use. Valid values: [0..3]
+ */
+#ifndef ETH_PORT_CHANNEL_FM0
+#define ETH_PORT_CHANNEL_FM0(eth_port_index) \
+	(QM_CHANNEL_FM0_SP_ETH + (eth_port_index))
+#endif
+
+/*
+ * Return the channel dedicated to a specific 1GB port of the first FMan
+ *
+ * @eth_port_index : index of the ethernet to use. Valid values: [0..3]
+ */
+#ifndef ETH_PORT_CHANNEL_FM1
+#define ETH_PORT_CHANNEL_FM1(eth_port_index) \
+	(QM_CHANNEL_FM1_SP_ETH + (eth_port_index))
+#endif
+
+/*
+ * Return the channel dedicated to a specific OH port of the first FMan
+ *
+ * @oh_port_index : index of the offline port to use. Valid values: [1..6]
+ * (OH port 0 is reserved by FMD for Host commands)
+ */
+#ifndef OH_PORT_CHANNEL_FM0
+#define OH_PORT_CHANNEL_FM0(oh_port_index) \
+	(QM_CHANNEL_FM0_SP_OH + (oh_port_index))
+#endif
+/**
+ * Return the channel dedicated to a specific OH port of the second FMan
+ *
+ * @oh_port_index : index of the offline port to use. Valid values: [1..6]
+ * (port 0 is reserved by FMD for Host commands)
+ */
+#ifndef OH_PORT_CHANNEL_FM1
+#define OH_PORT_CHANNEL_FM1(oh_port_index) \
+	(QM_CHANNEL_FM1_SP_OH + (oh_port_index))
+#endif
+
+
+#ifndef OH_PORT_CHANNEL
+#define OH_PORT_CHANNEL(fm, oh_port_index) \
+	((fm == 1) ? OH_PORT_CHANNEL_FM1(oh_port_index) : \
+		OH_PORT_CHANNEL_FM0(oh_port_index))
+#endif
+
+#ifndef ETH_PORT_CHANNEL
+#define ETH_PORT_CHANNEL(fm, eth_port_index) \
+	((fm == 1) ? ETH_PORT_CHANNEL_FM1(eth_port_index) : \
+		ETH_PORT_CHANNEL_FM0(eth_port_index))
+#endif
+
+/**
+ * Return the channel dedicated to a software portal.
+ *
+ * @sw_portal_index Valid values: [0..7]
+ */
+#ifndef SW_PORTAL_CHANNEL
+#define SW_PORTAL_CHANNEL(sw_portal_index) \
+	(qm_channel_swportal0 + (sw_portal_index))
+#endif
+
+#endif /*_PLATFORM_H_*/
diff --git a/drivers/staging/fsl_dpa_offload/usecases/pools.h b/drivers/staging/fsl_dpa_offload/usecases/pools.h
new file mode 100644
index 0000000..5b0b13c
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/pools.h
@@ -0,0 +1,37 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _POOLS_H_
+#define _POOLS_H_
+
+/* USDPAA buffer pools ids */
+extern int bpids[];
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h b/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
new file mode 100644
index 0000000..7500d0b
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
@@ -0,0 +1,59 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PORTS_H_
+#define _PORTS_H_
+
+/* In this usecase all ports are on the same FM */
+#if defined CONFIG_P4080_BUILD
+#define FM						1
+#define BACKHAUL_NETWORK		1
+#define BACKPLANE_NETWORK		0
+#define DL_RX				BACKHAUL_NETWORK
+#define UL_RX				BACKPLANE_NETWORK
+#elif defined CONFIG_P3041_BUILD
+#define FM			0
+#define BACKHAUL_NETWORK	3
+#define BACKPLANE_NETWORK	4
+#define DL_RX		    BACKHAUL_NETWORK
+#define UL_RX		    BACKPLANE_NETWORK
+#elif defined CONFIG_P5020_BUILD
+#define FM			0
+#define BACKHAUL_NETWORK	3
+#define BACKPLANE_NETWORK	4
+#define DL_RX		    BACKHAUL_NETWORK
+#define UL_RX		    BACKPLANE_NETWORK
+#endif
+#define DL_POST_IPSEC_OH		1
+#define UL_PRE_IPSEC_OH			2
+#define UL_POST_IPSEC_OH		3
+
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/queues.c b/drivers/staging/fsl_dpa_offload/usecases/queues.c
new file mode 100644
index 0000000..3909fa4
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/queues.c
@@ -0,0 +1,187 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/fsl_qman.h>
+#include <linux/fsl_bman.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include "utils.h"
+
+/*
+    Utility to create queues
+    @type - type of the queue : OH input (OH_TX), OH default (OH_DEFAULT),
+	    OH/ETH PCD (OH_RX, ETH_RX) and OH error (OH_ERR)
+    @fq	  - frame queue descriptor address
+    @fqid - frame queue id
+    @channel - channel : who will dequeue from us
+    @wq_id - work queue where the FQ will be placed
+    @cb - queue callbacks
+*/
+
+int create_fq(enum queue_type type, struct qman_fq *fq,
+	      u32 fq_id, u16 channel, u16 wq_id, const struct qman_fq_cb *cb)
+{
+	struct qm_mcc_initfq fq_opts;
+	u32 create_flags = 0, init_flags = 0;
+	u32 ret = -1;
+
+	create_flags = QMAN_FQ_FLAG_LOCKED;
+	init_flags = QMAN_INITFQ_FLAG_SCHED;
+
+	switch (type) {
+	case OH_TX:
+	case ETH_TX:
+		create_flags |=
+		    QMAN_FQ_FLAG_TO_DCPORTAL;
+		create_flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+		break;
+
+	case OH_RX:
+	case OH_DEFAULT:
+	case OH_ERR:
+	case ETH_RX:
+		create_flags |= QMAN_FQ_FLAG_NO_ENQUEUE;
+		create_flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+		break;
+
+	default:
+		pr_err("%s : invalid queue type %d\n", __func__,
+		       type);
+		goto out;
+	}
+
+	fq->cb = *cb;
+
+	ret = qman_create_fq(fq_id, create_flags, fq);
+	if (ret) {
+		pr_err("%s : cannot create frame queue, ret %d\n",
+		       __func__, ret);
+		goto out;
+	}
+
+	fq_opts.we_mask = QM_INITFQ_WE_DESTWQ;
+	fq_opts.fqd.dest.wq = wq_id;
+	fq_opts.fqd.dest.channel = channel;
+
+	/* Initialize frame queue */
+	ret = qman_init_fq(fq, init_flags, &fq_opts);
+	if (ret)
+		pr_err("%s : cannot create frame queue, ret %d\n",
+		       __func__, ret);
+ out:
+	return ret;
+}
+
+/* Tears down a frame queue */
+void teardown_fq(struct qman_fq *fq)
+{
+	u32 flags;
+	int s = qman_retire_fq(fq, &flags);
+	if (s == 1) {
+		/* Retire is non-blocking, poll for completion */
+		enum qman_fq_state state;
+		do {
+			qman_poll();
+			qman_fq_state(fq, &state, &flags);
+		} while (state != qman_fq_state_retired);
+		if (flags & QMAN_FQ_STATE_NE) {
+			/* FQ isn't empty, drain it */
+			s = qman_volatile_dequeue(fq, 0,
+						  QM_VDQCR_NUMFRAMES_TILLEMPTY);
+			BUG_ON(s);
+			/* Poll for completion */
+			do {
+				qman_poll();
+				qman_fq_state(fq, &state, &flags);
+			} while (flags & QMAN_FQ_STATE_VDQCR);
+		}
+	}
+	s = qman_oos_fq(fq);
+	BUG_ON(s);
+	qman_destroy_fq(fq, 0);
+}
+
+struct tsk_data {
+	struct tasklet_struct tsk;
+	const struct qm_dqrr_entry *dqrr;
+};
+
+static inline void enqueue_to_host(void *info)
+{
+	struct tsk_data *tsk = ((struct tsk_data *)info);
+	const struct qm_dqrr_entry *dqrr = tsk->dqrr;
+	tap_receive(dqrr, eth_dev);
+	kfree(tsk);
+}
+
+static void tsk_func(unsigned long data)
+{
+	/* this assumes that USDPAA application runs
+	 * to completion isolated on usdpaa_cpu core */
+	smp_call_function_single(usdpaa_cpu, enqueue_to_host, (void *)data, 0);
+}
+
+/* Runs in SW_PORTAL 0 portal interrupt context */
+static enum qman_cb_dqrr_result host_dqrr_callback(struct qman_portal *qm,
+				struct qman_fq *fq,
+				const struct qm_dqrr_entry *dqrr)
+{
+	struct tsk_data *tsk = kmalloc(sizeof(*tsk), GFP_ATOMIC);
+	BUG_ON(!tsk);
+	tasklet_init(&tsk->tsk, tsk_func, (unsigned long)tsk);
+	tsk->dqrr = dqrr;
+	if (dqrr->fd.status)
+		pr_warning("%s : fqid 0x%x fd status 0x%x\n",
+		       __func__, dqrr->fqid, dqrr->fd.status);
+	/* tsk_func needs to run with interrupts enabled */
+	tasklet_schedule(&tsk->tsk);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void ern_callback(struct qman_portal *portal,
+			 struct qman_fq *fq, const struct qm_mr_entry *msg)
+{
+}
+
+static void fqs_callback(struct qman_portal *portal,
+			 struct qman_fq *fq, const struct qm_mr_entry *msg)
+{
+}
+
+struct qman_fq_cb host_cb = {
+	.dqrr = host_dqrr_callback,
+	.ern = ern_callback,
+	.fqs = fqs_callback,
+};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/queues_conf.h b/drivers/staging/fsl_dpa_offload/usecases/queues_conf.h
new file mode 100644
index 0000000..7a4020c
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/queues_conf.h
@@ -0,0 +1,85 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _QUEUES_CONF_H_
+#define _QUEUES_CONF_H_
+
+/**************** Inbound (DL) queues ***********************/
+/* non IPsec + non UDP */
+/* ENQ : DL_RX port
+   DEQ : Core 0 (Linux)
+*/
+#define DL_HOST_QUEUE				0x2e00
+
+/* GTP - dl_oh_post_ipsec_udp_dist base */
+/* ENQ : DL_POST_IPSEC_OH port
+   DEQ : USDPAA core
+ */
+#define DL_GTP_QUEUE				0x2e01
+
+/* Non GTP UDP traffic */
+/* ENQ : DL_POST_IPSEC_OH port
+   DEQ : USDPAA core
+*/
+#define DL_UDP_UPLANE_QUEUE			0x2e02
+
+/* tunneled non-UDP */
+/* ENQ : DL_POST_IPSEC_OH port
+   DEQ : USDPAA core
+ */
+#define DL_NON_UDP_UPLANE_QUEUE		0x2e03
+
+/* IPsec miss queue */
+/* ENQ : DL_RX port, DL_POST_IPSEC_OH port
+   DEQ : Core 0 (Linux)
+ */
+#define DL_IPSEC_HOST_QUEUE			0x2f00
+
+
+/************* Outbound (UL) queues ************************/
+/* USDPAA - ul_rx_port_hash_dist base */
+/* ENQ : UL_RX port
+   DEQ : USDPAA core
+ */
+#define UL_RX_QUEUE					0x3e00
+
+/* All outbound - dl_rx_port_policy txfqid base */
+/* ENQ : UL_POST_IPSEC_OH port
+   DEQ : UL_TX port
+*/
+#define UL_TX_QUEUE					0x3e01
+
+/* non IPsec - ul_oh_post_ipsec_policy txfqid base */
+/* ENQ : UL_PRE_IPSEC_OH port
+   DEQ : UL_POST_IPSEC_OH port
+ */
+#define UL_POST_IPSEC_OH_TX_QUEUE	0x3e03
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/softparse.h b/drivers/staging/fsl_dpa_offload/usecases/softparse.h
new file mode 100644
index 0000000..19acd5d
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/softparse.h
@@ -0,0 +1,299 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *	 * Redistributions of source code must retain the above copyright
+ *	   notice, this list of conditions and the following disclaimer.
+ *	 * Redistributions in binary form must reproduce the above copyright
+ *	   notice, this list of conditions and the following disclaimer in the
+ *	   documentation and/or other materials provided with the distribution.
+ *	 * Neither the name of Freescale Semiconductor nor the
+ *	   names of its contributors may be used to endorse or promote products
+ *	   derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * softparse.h
+ */
+
+#ifndef SOFTPARSE_H_
+#define SOFTPARSE_H_
+
+#include "fm_pcd_ext.h"
+
+/******************************************************************************/
+t_FmPcdPrsSwParams SOFT_PARSE_ICMP_UDP_ESP = \
+{		                                              \
+	TRUE,	                       /*Override*/       \
+	1860,	                       /*Size*/           \
+	0x5C,	                       /*Base*/           \
+	(uint8_t *)&(uint8_t[]){	    /*Code*/           \
+	0x00,0x00,0x97,0x9E,0x70,0x6A,0x00,0x0C,0x00,0x00, \
+	0x87,0x9E,0x40,0x69,0x11,0x94,0x00,0x00,0x8F,0x9E, \
+	0x40,0x69,0x11,0x94,0x18,0x6A,0x18,0x6C,0x00,0x01, \
+	0x1B,0xFE,0x32,0xE1,0x32,0xF0,0x00,0x4A,0x00,0x80, \
+	0x00,0x02,0x00,0x00,0x8F,0xBE,0x40,0x85,0x00,0x00, \
+	0x32,0xE1,0x00,0x55,0x00,0x08,0x28,0x41,0x32,0xE1, \
+	0x00,0x55,0x00,0x10,0x28,0x5F,0x00,0x03,0x00,0x01, \
+	0x00,0x00,0x00,0x01,0x02,0x1F,0x00,0x08,0x00,0x81, \
+	0x1F,0xFF,0x00,0x01,0x1B,0xFF,0x00,0x00,0xA7,0x8E, \
+	0x40,0x8E,0x00,0x01,0x00,0x01,0x1B,0xFE,0x18,0x8E, \
+	0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+	0x00,0x02,0x35,0x73,0x28,0x1B,0x00,0x05,0x29,0x1F, \
+	0x30,0xD0,0x60,0xB0,0x00,0x07,0x00,0x05,0x00,0x00, \
+	0xC3,0x8F,0x00,0x52,0x00,0x01,0x07,0x01,0x60,0x9C, \
+	0x00,0x00,0x30,0xD0,0x00,0xDA,0x00,0x01,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x40,0xAD,0x00,0x00,0x02,0x8F, \
+	0x00,0x00,0x30,0xF2,0x00,0x06,0x18,0xBE,0x00,0x00, \
+	0x9F,0xFF,0x30,0xF2,0x00,0x06,0x29,0x1E,0x07,0x08, \
+	0x30,0xD0,0x00,0x52,0x00,0x08,0x28,0x1A,0x60,0x98, \
+	0x00,0x00,0x30,0xF2,0x18,0xBE,0x06,0x00,0x29,0x1E, \
+	0x30,0xF2,0x40,0xC7,0xFF,0xFF,0x08,0x11,0x00,0x23, \
+	0x1B,0xFF,0x18,0xD1,0x32,0xF1,0x28,0x41,0x32,0x01, \
+	0x35,0x72,0x00,0x4D,0x28,0x5F,0x00,0x03,0x00,0x01, \
+	0x00,0x00,0x1B,0xFF,0x1B,0xFF,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+	},	                                             \
+	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  /*swPrsParams*/    \
+	2,	                          /*numOfLabels*/    \
+	{	                                              \
+	{	                                              \
+		0x5C,                       /*offset*/         \
+		HEADER_TYPE_UDP,           /*prevProto*/      \
+		0,                           /*index*/          \
+	},	                                             \
+	{	                                              \
+		0x87,                       /*offset*/         \
+		HEADER_TYPE_IPv4,           /*prevProto*/      \
+		0,                           /*index*/          \
+	},	                                             \
+	},	                                             \
+};
+
+/*****************************************************************************/
+#define SOFT_PARSE_UDP_ESP		                     \
+{		                                              \
+	FALSE,	                       /*Override*/       \
+	200,	                       /*Size*/           \
+	0x5C,	                       /*Base*/           \
+	(uint8_t *)&(uint8_t[]){	    /*Code*/           \
+	0x00,0x00,0x97,0x9E,0x70,0x6A,0x00,0x0C,0x00,0x00, \
+	0x87,0x9E,0x40,0x69,0x11,0x94,0x00,0x00,0x8F,0x9E, \
+	0x40,0x69,0x11,0x94,0x18,0x6A,0x18,0x6C,0x00,0x01, \
+	0x1B,0xFE,0x32,0xF1,0x32,0xE0,0x00,0x4F,0x00,0x81, \
+	0x00,0x02,0x00,0x00,0x8F,0xBE,0x40,0x85,0x00,0x00, \
+	0x32,0xE1,0x00,0x55,0x00,0x08,0x28,0x41,0x32,0xE1, \
+	0x00,0x55,0x00,0x18,0x28,0x5F,0x00,0x03,0x00,0x01, \
+	0x00,0x00,0x00,0x01,0x02,0x1F,0x00,0x08,0x00,0x81, \
+	0x1F,0xFF,0x00,0x01,0x1B,0xFF,0x31,0x52,0x00,0xDA, \
+	0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x91, \
+	0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00, \
+	0x50,0x9A,0x00,0x00,0x00,0x00,0x9F,0x98,0x50,0x9A, \
+	0x00,0x00,0x18,0x9F,0x00,0x03,0x00,0x02,0x00,0x00, \
+	0x00,0x01,0x1B,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+	0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
+	0x40,0xAB,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0xC0, \
+	0x50,0xB2,0x00,0x00,0x31,0xD2,0x50,0xB2,0x00,0x00, \
+	0x18,0xB7,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+	0x1B,0xFF,0x00,0x01,0x1B,0xFE,0x00,0x00,0x00,0x00, \
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},\
+	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  /*swPrsParams*/    \
+	3,	                          /*numOfLabels*/    \
+	{	                                              \
+	{	                                              \
+		0x5C,                       /*offset*/         \
+		HEADER_TYPE_UDP,            /*prevProto*/      \
+		0,                          /*index*/          \
+	},	                                             \
+	{	                                              \
+		0x87,                       /*offset*/         \
+		HEADER_TYPE_IPv4,           /*prevProto*/      \
+		0,                          /*index*/          \
+	},	                                             \
+	{	                                              \
+		0xA1,                       /*offset*/         \
+		HEADER_TYPE_IPv6,           /*prevProto*/      \
+		0,                          /*index*/          \
+	},	                                             \
+	},	                                             \
+}
+
+#endif /* SOFTPARSE_H_ */
diff --git a/drivers/staging/fsl_dpa_offload/usecases/utils.h b/drivers/staging/fsl_dpa_offload/usecases/utils.h
new file mode 100644
index 0000000..8be1f7b
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/utils.h
@@ -0,0 +1,107 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ETH_UTILS__
+#define __ETH_UTILS__
+
+#include <net/xfrm.h>
+#include "lnxwrp_fm.h"
+#include <linux/fsl_dpa_ipsec.h>
+
+/* dequeues are perfomed by the host (Linux SW portal) */
+enum queue_type {
+	OH_TX,	/* enqueue to OH port */
+	OH_RX,	/* dequeues from OH port */
+	OH_DEFAULT, /* OH port default queue */
+	OH_ERR,	/* OH port error queue */
+	ETH_RX,	/* dequeues from ETH port */
+	ETH_TX
+};
+
+/* dpaa_eth driver frame queue wrapper struct */
+struct dpa_fq {
+	struct qman_fq		fq_base;
+	struct list_head	list;
+	struct net_device	*net_dev;
+	bool			init;
+	uint32_t		fqid;
+	uint32_t		flags;
+	uint16_t		channel;
+	uint8_t			wq;
+};
+
+
+/* CPU number for an USDPAA isolated core */
+extern int usdpaa_cpu;
+
+extern struct qman_fq_cb host_cb;
+
+extern struct qman_fq *eth_rx_fq;
+
+extern struct net_device *eth_dev;
+
+extern struct bman_pool *usdpaa_pools[64];
+
+extern struct bman_pool *default_pool;
+
+struct bman_pool *get_if_pool(const char *_if);
+
+int create_fq(enum queue_type type, struct qman_fq *fq,
+		u32 fq_id, u16 channel,
+		u16 wq_id, const struct qman_fq_cb *cb);
+
+void teardown_fq(struct qman_fq *fq);
+
+struct qman_fq *get_if_ingress_queue(const char *_if, int fqid);
+
+void if_enqueue(const struct qm_dqrr_entry *dqrr, struct qman_fq *rx_fq);
+void tap_receive(const struct qm_dqrr_entry *dqrr, struct net_device *ndev);
+
+t_LnxWrpFmPortDev *get_fm_port(int fm_idx, int port_idx,
+				e_FmPortType port_type);
+
+uint64_t get_mac_dev(int fm_id, int port_id);
+
+int config_loopback(int fm_id, int port_id);
+
+int create_scratch_pool(void);
+
+t_LnxWrpFmDev *get_fm(int fm_idx);
+
+void dump_xfrm_sa(struct xfrm_state *x);
+
+void dump_xfrm_selector(struct xfrm_selector *sel);
+
+void dump_xfrm_template(struct xfrm_tmpl *tmpl);
+
+int get_offld_work_cpu(void);
+
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
new file mode 100644
index 0000000..014a026
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -0,0 +1,672 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/crypto.h>
+#include <linux/in.h>		/* for IP protocols, IPPROTO_ESP */
+#include <net/xfrm.h>
+
+#include <linux/fsl_dpa_ipsec.h>
+#include "desc.h"
+
+#include "pools.h"
+#include "utils.h"
+#include "dip_init.h"
+#include "queues_conf.h"
+#include "dip_init.h"
+#include "ports_conf.h"
+
+#include "xfrm_km.h"
+#include "platform_defs.h"
+#define HASH_SIZE 256
+
+/* DPA IPsec domain SA hash table */
+static struct hlist_head sa_htable[HASH_SIZE];
+static const u32 jhash_initval = 0xdeadbeef;
+
+/* MTU for outbound OH pre sec */
+int mtu_pre_enc;
+module_param(mtu_pre_enc, int, 0);
+MODULE_PARM_DESC(mtu_pre_enc, "\tMTU for OH port pre encryption");
+
+/* This should be the core interrupted by the jr used for
+   split key generation .*/
+static int offld_work_cpu;
+module_param(offld_work_cpu, int, 0);
+MODULE_PARM_DESC(offld_work_cpu, "\tCPU to run the offloading code");
+
+struct work_arg {
+	struct xfrm_state *x;
+	struct xfrm_policy_walk walk;
+	struct work_struct work;
+};
+
+/*
+  Returns core number where CAAM job ring 0 interrupt is routed
+*/
+#ifdef CONFIG_P4080_BUILD
+int get_offld_work_cpu(void)
+{
+	u32 *addr, iidr;
+	int i;
+	addr = ioremap(SOC_BASE + IIDR(JR0_INT_NUM), sizeof(u32));
+	if (!addr) {
+		pr_err("%s : Cannot remap IIDR%d\n", __func__, JR0_INT_NUM);
+		return -1;
+	}
+	iidr = in_be32(addr);
+	iounmap(addr);
+
+	for (i = 0; iidr != 1; iidr = (iidr >> 1), i++)
+	;
+	return i;
+}
+#else
+int get_offld_work_cpu(void)
+{
+	return -1;
+}
+#endif
+
+static void work_func(struct work_struct *work);
+
+/*
+ Stores a pair of xfrm_state and DIP SA on a hash table
+ Hash is computed on concatenated auth and crypto keys
+ */
+static struct sa *hash_sa(struct hlist_head *htable, struct xfrm_state *x,
+			  enum dpa_ipsec_direction dir, int *sa_id)
+{
+	struct sa *psa;
+	unsigned int hash_val = 0;
+	unsigned char *hash_key;
+	unsigned int hash_key_size;
+	unsigned char _dir = 0;
+
+	if ((*sa_id == -1) || (x == NULL))
+		return NULL;
+
+	psa = kzalloc(sizeof(*psa), GFP_ATOMIC);
+	if (!psa) {
+		pr_err("%s: Cannot allocate memory for SA\n", __func__);
+		return NULL;
+	}
+
+	INIT_HLIST_NODE(&psa->h);
+
+	/* 1 byte for direction */
+	hash_key_size = x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8 + 1;
+	hash_key = kzalloc(hash_key_size, GFP_ATOMIC);
+	if (!hash_key) {
+		pr_err("%s: Cannot allocate memory for hash key\n", __func__);
+		kfree(psa);
+		return NULL;
+	}
+
+	memcpy(hash_key, x->aalg->alg_key, x->aalg->alg_key_len / 8);
+	memcpy(hash_key + x->aalg->alg_key_len / 8, x->ealg->alg_key,
+	       x->ealg->alg_key_len / 8);
+	(dir == DPA_IPSEC_OUTBOUND) ? _dir = 1 : 0;
+	memcpy(hash_key + x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8,
+	       &_dir, 1);
+
+	hash_val =
+	    jhash((u32 *) hash_key, hash_key_size, jhash_initval) % HASH_SIZE;
+	hlist_add_head(&psa->h, sa_htable + hash_val);
+	psa->sa_id = *sa_id;
+	psa->state = x;
+	psa->dir = dir;
+
+	kfree(hash_key);
+	return psa;
+}
+
+/*
+ Retrieves a pair of xfrm_state and DIP SA
+*/
+static struct sa *find_sa(struct hlist_head *htable, struct xfrm_state *x,
+			  enum dpa_ipsec_direction dir)
+{
+	unsigned int hash_val = 0;
+	unsigned char *hash_key;
+	unsigned int hash_key_size = 0;
+	struct hlist_node *entry;
+	int sa_found = 0;
+	unsigned char _dir = 0;
+	struct sa *psa;
+
+	/* 1 byte for direction */
+	hash_key_size = x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8 + 1;
+	hash_key = kzalloc(hash_key_size, GFP_ATOMIC);
+	if (!hash_key) {
+		pr_err("%s: Cannot allocate memory for hash key\n", __func__);
+		return NULL;
+	}
+
+	memcpy(hash_key, x->aalg->alg_key, x->aalg->alg_key_len / 8);
+	memcpy(hash_key + x->aalg->alg_key_len / 8, x->ealg->alg_key,
+	       x->ealg->alg_key_len / 8);
+	(dir == DPA_IPSEC_OUTBOUND) ? _dir = 1 : 0;
+	memcpy(hash_key + x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8,
+	       &_dir, 1);
+
+	hash_val =
+	    jhash((u32 *) hash_key, hash_key_size, jhash_initval) % HASH_SIZE;
+	hlist_for_each_entry(psa, entry, sa_htable + hash_val, h) {
+		if (psa->state == x && psa->dir == dir) {
+			sa_found = 1;
+			break;
+		}
+	}
+
+	if (!sa_found)
+		psa = NULL;
+	kfree(hash_key);
+	return psa;
+}
+
+/* Converts auth algos names into SEC descriptors constants
+   Assumes 0 is not a valid value.
+*/
+static inline u16 aalg_type(struct xfrm_state *x)
+{
+	struct xfrm_algo_desc *aalg_desc;
+	aalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);
+
+	if (!strcmp(x->aalg->alg_name, "hmac(sha1)") &&
+	    aalg_desc->uinfo.auth.icv_truncbits == 96)
+		return OP_PCL_IPSEC_HMAC_SHA1_96;
+
+	return 0;
+}
+
+/* Converts crypto algos names into SEC descriptors constants
+   Assumes 0 is not a valid value.
+*/
+static inline u16 ealg_type(struct xfrm_state *x)
+{
+	if (!strcmp(x->ealg->alg_name, "cbc(des3_ede)"))
+		return OP_PCL_IPSEC_3DES;
+
+	return 0;
+}
+
+static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
+			    void *ptr);
+
+/*
+  XFRM state notifications
+ */
+static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
+{
+	int ret = 0;
+	unsigned int hash_val;
+	struct hlist_node *entry;
+	struct sa *psa;
+	struct work_arg *work;
+
+	/* Only ESP 3DES-CBC HMAC-SHA1 96 is supported for now */
+	if (!(x && (x->id.proto == IPPROTO_ESP) &&
+	      !strcmp(x->aalg->alg_name, "hmac(sha1)") &&
+	      !strcmp(x->ealg->alg_name, "cbc(des3_ede)"))
+	    )
+		return 0;
+
+	switch (c->event) {
+	case XFRM_MSG_EXPIRE:
+		break;
+
+	case XFRM_MSG_NEWAE:
+	/*
+	 * This changes some internal members of the xfrm_state structure,
+	 * such as: replay, preplay, replay_maxage, replay_maxdiff, curlft.
+	 * We don't have any action to take for this message.
+	 */
+		break;
+
+	case XFRM_MSG_DELSA:
+		pr_info("%s: XFRM_MSG_DELSA event, SPI %x\n",
+			__func__, x->id.spi);
+		dump_xfrm_sa(x);
+		psa = find_sa(sa_htable, x, DPA_IPSEC_OUTBOUND);
+		if (psa) {
+			ret = dpa_ipsec_remove_sa(psa->sa_id);
+			if (ret < 0)
+				pr_info("%s: Error removing out SA\n",
+					__func__);
+			kfree(psa);
+		}
+		psa = find_sa(sa_htable, x, DPA_IPSEC_INBOUND);
+		if (psa) {
+			ret = dpa_ipsec_remove_sa(psa->sa_id);
+			if (ret < 0)
+				pr_info("%s: error removing in SA\n", __func__);
+			kfree(psa);
+		}
+		break;
+
+	case XFRM_MSG_NEWSA:
+		pr_info("%s: XFRM_MSG_NEWSA event, SPI %x\n",
+			__func__, x->id.spi);
+		dump_xfrm_sa(x);
+		work = kzalloc(sizeof(*work), GFP_KERNEL);
+		if (!work) {
+			pr_err(
+			       "%s: Cannot allocate memory for offload work\n",
+			       __func__);
+			break;
+		}
+		work->x = x;
+		INIT_WORK(&work->work, work_func);
+		schedule_work_on(offld_work_cpu, &work->work);
+		break;
+
+	case XFRM_MSG_UPDSA:
+		break;
+
+	case XFRM_MSG_FLUSHSA:
+		pr_info("%s: XFRM_MSG_FLUSHSA event\n", __func__);
+		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
+			hlist_for_each_entry(psa, entry, sa_htable + hash_val,
+					     h) {
+				ret = dpa_ipsec_remove_sa(psa->sa_id);
+				if (ret < 0) {
+					pr_info("%s: Error removing SA\n",
+						__func__);
+				}
+				kfree(psa);
+			}
+		}
+		break;
+
+	default:
+		pr_err("%s: Unknown SA event %d\n", __func__, c->event);
+		break;
+	}
+
+	return ret;
+}
+
+/* Policy walking */
+static void work_func(struct work_struct *work)
+{
+	struct work_arg *this_work = container_of(work, struct work_arg, work);
+	xfrm_policy_walk_init(&this_work->walk, XFRM_POLICY_TYPE_ANY);
+	xfrm_policy_walk(&init_net, &this_work->walk, policy_walk_func,
+			 this_work->x);
+	xfrm_policy_walk_done(&this_work->walk);
+	kfree(this_work);
+}
+
+/*
+ Loops over all XFRM policies and matches the template with the given SA.
+ Creates DIP policies/SAs based on XFRM counterparts.
+ */
+static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
+			    void *ptr)
+{
+	int i = 0;
+	int err = 0;
+	struct iphdr outer_iphdr;
+	t_LnxWrpFmPortDev *oh_port;
+	int cls_td;
+	int sa_id = -1;
+	struct sa *sa;
+	t_LnxWrpFmDev *fm;
+	struct xfrm_state *x = (struct xfrm_state *)ptr;
+	struct dpa_ipsec_sa_params saParams;
+	struct dpa_ipsec_policy_params polParams;
+	struct dpa_cls_tbl_action def_sa_action;
+	struct dpa_cls_tbl_params cls_tbl_params;
+
+	for (i = 0; i < pol->xfrm_nr; i++) {
+		if (!((x->id.daddr.a4 == pol->xfrm_vec[i].id.daddr.a4) &&
+		      (x->props.saddr.a4 == pol->xfrm_vec[i].saddr.a4) &&
+		      (x->id.proto == pol->xfrm_vec[i].id.proto)))
+			continue;
+
+		if (dir == XFRM_POLICY_OUT) {
+			pr_info("%s: found policy %d dir OUT (%d) for SA spi %x\n",
+			     __func__, pol->index, dir, x->id.spi);
+			sa = find_sa(sa_htable, x, DPA_IPSEC_OUTBOUND);
+			if (sa)
+				sa_id = sa->sa_id;
+			if (sa_id < 0) {
+				memset(&saParams, 0, sizeof(saParams));
+				saParams.spi = x->id.spi;
+				saParams.start_seq_num = 1;
+				saParams.l2_hdr_size = ETH_HLEN;
+				saParams.sa_wqid = 7;
+				saParams.sa_bpid = bpids[2];
+				/* FIXME - support other algorithms too */
+				saParams.crypto_params.alg_suite =
+				    DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_SHA_160;
+				saParams.crypto_params.auth_key =
+				    x->aalg->alg_key;
+				saParams.crypto_params.auth_key_len =
+				    x->aalg->alg_key_len / 8;
+				saParams.crypto_params.cipher_key =
+				    x->ealg->alg_key;
+				saParams.crypto_params.cipher_key_len =
+				    x->ealg->alg_key_len / 8;
+				saParams.sa_dir = DPA_IPSEC_OUTBOUND;
+				/*use internal gen */
+				saParams.sa_out_params.init_vector = NULL;
+				saParams.sa_out_params.addr_type =
+				    DPA_IPSEC_ADDR_T_IPv4;
+				memset(&outer_iphdr, 0, sizeof(outer_iphdr));
+				outer_iphdr.version = IPVERSION;
+				outer_iphdr.ihl =
+				    sizeof(outer_iphdr) / sizeof(u32);
+				outer_iphdr.tot_len = sizeof(outer_iphdr);
+				outer_iphdr.ttl = IPDEFTTL;
+				outer_iphdr.saddr = x->props.saddr.a4;
+				outer_iphdr.daddr = x->id.daddr.a4;
+				outer_iphdr.protocol = IPPROTO_ESP;
+				saParams.sa_out_params.outer_ip_header =
+				    &outer_iphdr;
+				saParams.sa_out_params.ip_hdr_size =
+				    sizeof(outer_iphdr);
+				saParams.sa_out_params.outer_udp_header = NULL;
+				saParams.sa_out_params.post_sec_flow_id = 0;
+				saParams.sa_out_params.init_vector = NULL;
+				/* create DIP OUT SA */
+				err = dpa_ipsec_create_sa(0, &saParams, &sa_id);
+				if (err < 0) {
+					pr_err("%s: Error creating outbound SA\n",
+					     __func__);
+					return err;
+				}
+
+				/* store h_Sa for later retrieval */
+				hash_sa(sa_htable, x, saParams.sa_dir, &sa_id);
+			}
+
+			/* create outbound  policy */
+			oh_port =
+			    get_fm_port(FM, UL_PRE_IPSEC_OH,
+					e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+			BUG_ON(oh_port == NULL);
+			if (oh_port->settings.frag_enabled == FALSE) {
+				/* set mtu to 0, to prevent setting
+				the manip node */
+				mtu_pre_enc = 0;
+				pr_info("%s : Fragmentation not applied on OH pre enc\n",
+				     __func__);
+			}
+			polParams.mtu = mtu_pre_enc;
+			polParams.src_addr.addr_type = DPA_IPSEC_ADDR_T_IPv4;
+			polParams.src_addr.ipv4.word = pol->selector.saddr.a4;
+			polParams.src_prefix_len = pol->selector.prefixlen_s;
+
+			polParams.dest_addr.addr_type = DPA_IPSEC_ADDR_T_IPv4;
+			polParams.dest_addr.ipv4.word = pol->selector.daddr.a4;
+			polParams.dest_prefix_len = pol->selector.prefixlen_d;
+
+			polParams.protocol = pol->selector.proto;
+			polParams.src_port = pol->selector.sport;
+			polParams.src_port_mask = pol->selector.sport_mask;
+			polParams.dest_port = pol->selector.dport;
+			polParams.dest_port_mask = pol->selector.dport_mask;
+
+			if (sa_id >= 0) {
+				err =
+				    dpa_ipsec_sa_add_policy(sa_id, &polParams);
+				if (err < 0) {
+					pr_warning("%s: Error creating outbound policy\n",
+					     __func__);
+					return err;
+				}
+
+			} else
+				pr_warning("%s: Cannot add policy for a non existent SA!\n",
+				     __func__);
+
+		}
+		if (dir == XFRM_POLICY_IN) {
+			/* create one DIP IN SA for x */
+			pr_info("%s: found policy %d dir IN (%d) for SA spi %x\n",
+			     __func__, pol->index, dir, x->id.spi);
+			sa = find_sa(sa_htable, x, DPA_IPSEC_INBOUND);
+			if (sa)
+				sa_id = sa->sa_id;
+			if (sa_id < 0) {
+				memset(&saParams, 0, sizeof(saParams));
+				saParams.spi = x->id.spi;
+				saParams.crypto_params.alg_suite =
+				    DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_SHA_160;
+				saParams.crypto_params.auth_key =
+				    x->aalg->alg_key;
+				saParams.crypto_params.auth_key_len =
+					x->aalg->alg_key_len / 8; /*bits */
+				saParams.crypto_params.cipher_key =
+				    x->ealg->alg_key;
+				saParams.crypto_params.cipher_key_len =
+				    x->ealg->alg_key_len / 8;
+				saParams.sa_dir = DPA_IPSEC_INBOUND;
+				saParams.sa_in_params.use_udp_encap = FALSE;
+				saParams.sa_in_params.src_addr.addr_type =
+				    DPA_IPSEC_ADDR_T_IPv4;
+				saParams.sa_in_params.src_addr.ipv4.word =
+				    x->props.saddr.a4;
+				saParams.sa_in_params.dest_addr.addr_type =
+				    DPA_IPSEC_ADDR_T_IPv4;
+				saParams.sa_in_params.dest_addr.ipv4.word =
+				    x->id.daddr.a4;
+				saParams.sa_bpid = bpids[2];
+
+				fm = get_fm(FM);
+				if (!fm) {
+					pr_info("%s: Cannot get FM %d\n",
+						__func__, FM);
+					err = E_NOT_AVAILABLE;
+					return err;
+				}
+
+				/* DL POST SEC */
+				memset(&cls_tbl_params, 0,
+				       sizeof(cls_tbl_params));
+				cls_tbl_params.fm_pcd = fm->h_PcdDev;
+				cls_tbl_params.cc_node = h_CcNodeInPostDec;
+				cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+				cls_tbl_params.entry_mgmt =
+				    DPA_CLS_TBL_MANAGE_BY_REF;
+				/* FIXME: DL POST SEC
+				classification keys number */
+				cls_tbl_params.exact_match_params.entries_cnt =
+				    1;
+				/* FIXME: DL POST SEC
+				classification keys size */
+				cls_tbl_params.exact_match_params.key_size = 2;
+				err =
+				    dpa_classif_table_create
+				    (&cls_tbl_params, &cls_td);
+				if (err < 0) {
+					pr_info("%s: Error creating out SA lookup classif table\n",
+					     __func__);
+					return err;
+				}
+
+				memset(&def_sa_action, 0,
+				       sizeof(def_sa_action));
+				def_sa_action.type =
+				    DPA_CLS_TBL_ACTION_NEXT_TABLE;
+				def_sa_action.enable_statistics = FALSE;
+				def_sa_action.next_table_params.next_td =
+				    cls_td;
+				saParams.sa_in_params.post_ipsec_action =
+				    def_sa_action;
+				saParams.sa_in_params.policy_miss_fqid =
+				    DL_IPSEC_HOST_QUEUE;
+				saParams.sa_in_params.arw = DPA_IPSEC_ARSNONE;
+				err = dpa_ipsec_create_sa(0, &saParams, &sa_id);
+				if (err < 0) {
+					pr_info("%s: Error creating inbound SA\n",
+					     __func__);
+					return 0;
+				}
+
+				/* store h_Sa for later retrieval */
+				hash_sa(sa_htable, x, saParams.sa_dir, &sa_id);
+			}
+
+			/* create inbound policy */
+			memset(&polParams, 0, sizeof(polParams));
+			polParams.src_addr.addr_type = DPA_IPSEC_ADDR_T_IPv4;
+			polParams.src_addr.ipv4.word = pol->selector.saddr.a4;
+			polParams.src_prefix_len = pol->selector.prefixlen_s;
+			polParams.dest_addr.addr_type = DPA_IPSEC_ADDR_T_IPv4;
+			polParams.dest_addr.ipv4.word = pol->selector.daddr.a4;
+			polParams.dest_prefix_len = pol->selector.prefixlen_d;
+
+			polParams.protocol = pol->selector.proto;
+			polParams.src_port = pol->selector.sport;
+			polParams.src_port_mask = pol->selector.sport_mask;
+			polParams.dest_port = pol->selector.dport;
+			polParams.dest_port_mask = pol->selector.dport_mask;
+
+			if (sa_id >= 0) {
+				err =
+				    dpa_ipsec_sa_add_policy(sa_id, &polParams);
+				if (err < 0) {
+					pr_warning("%s: Error creating inbound policy\n",
+					     __func__);
+					return err;
+				}
+			} else
+				pr_warning("%s: Cannot add policy for a non existent SA!\n",
+				     __func__);
+
+		}
+	}
+
+	return 0;
+}
+
+/*
+ XFRM policy notifications
+ */
+static int xfrm_km_policy_notify(struct xfrm_policy *x, int dir,
+				 const struct km_event *c)
+{
+	int ret = 0, i = 0;
+	struct xfrm_state *state;
+	struct work_arg *work;
+
+	switch (c->event) {
+	case XFRM_MSG_NEWPOLICY:
+		pr_info("%s: XFRM_MSG_NEWPOLICY event, policy index %d\n",
+			__func__, x->index);
+		dump_xfrm_selector(&x->selector);
+		for (i = 0; i < x->xfrm_nr; i++) {
+			dump_xfrm_template(&x->xfrm_vec[i]);
+
+			/* find a xfrm_state for this policy */
+			state =
+			    xfrm_state_lookup_byaddr(&init_net, 0,
+						     &x->xfrm_vec[i].id.daddr,
+						     &x->xfrm_vec[i].saddr,
+						     x->xfrm_vec[i].id.proto,
+						     x->family);
+
+			if (state
+			    && (dir == XFRM_POLICY_IN
+				|| dir == XFRM_POLICY_OUT)) {
+				work = kzalloc(sizeof(*work), GFP_KERNEL);
+				if (!work) {
+					pr_err("%s: Cannot allocate memory for offload work\n",
+					       __func__);
+					break;
+				}
+				work->x = state;
+				INIT_WORK(&work->work, work_func);
+				schedule_work_on(offld_work_cpu, &work->work);
+			}
+		}
+
+		break;
+	case XFRM_MSG_DELPOLICY:
+		break;
+	case XFRM_MSG_GETPOLICY:
+		break;
+	case XFRM_MSG_POLEXPIRE:
+		break;
+	case XFRM_MSG_FLUSHPOLICY:
+		break;
+	}
+
+	return ret;
+
+}
+
+int xfrm_km_acquire(struct xfrm_state *x, struct xfrm_tmpl *tmpl,
+		    struct xfrm_policy *xp, int dir)
+{
+	pr_info("%s:\n", __func__);
+	return 0;
+}
+
+/* XFRM key manager interface */
+static struct xfrm_mgr xfrm_mgr = {
+	.id = "xfrm",
+	.notify = xfrm_km_state_notify,
+	.notify_policy = xfrm_km_policy_notify,
+	.acquire = xfrm_km_acquire,
+};
+
+int xfrm_km_init(void)
+{
+	int err = 0;
+	int core;
+
+	/* register ourselves as a key manager */
+	err = xfrm_register_km(&xfrm_mgr);
+	if (unlikely(err < 0)) {
+		pr_err("%s: returned %d\n", __func__, err);
+		return err;
+	}
+	core = get_offld_work_cpu();
+	if (core != -1)
+		offld_work_cpu = core;
+
+	pr_info("Using core %d to run offloading code\n", offld_work_cpu);
+
+	return err;
+}
+
+void xfrm_km_exit(void)
+{
+	/* unregister the key manager first so we don't learn any new SA */
+	xfrm_unregister_km(&xfrm_mgr);
+	return;
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.h b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.h
new file mode 100644
index 0000000..f9e3a6d
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.h
@@ -0,0 +1,50 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _XFRM_KM_H_
+#define _XFRM_KM_H_
+
+#include <linux/kernel.h>
+#include "std_ext.h"
+#include <linux/fsl_dpa_ipsec.h>
+
+/* maps XFRM SA to DIP SA*/
+struct sa {
+	struct hlist_node h;
+	struct xfrm_state *state;
+	enum dpa_ipsec_direction dir;
+	int sa_id;
+};
+
+int  xfrm_km_init(void);
+void xfrm_km_exit(void);
+
+#endif /* __DPA_XFRM_KM_H__ */
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c
new file mode 100644
index 0000000..773373f
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c
@@ -0,0 +1,231 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/crypto.h>
+#include <linux/in.h>		/* for IP protocols, IPPROTO_ESP */
+#include <net/xfrm.h>
+
+
+#if (defined DEBUG_XFRM)
+void dump_xfrm_sa(struct xfrm_state *x)
+{
+	char authenc_name[CRYPTO_MAX_ALG_NAME];
+	int len;
+	char *xfrm_km_states[] = {
+		[XFRM_STATE_VOID] = "void",
+		[XFRM_STATE_ACQ] = "acq",
+		[XFRM_STATE_VALID] = "valid",
+		[XFRM_STATE_ERROR] = "error",
+		[XFRM_STATE_EXPIRED] = "expired",
+		[XFRM_STATE_DEAD] = "dead",
+	};
+
+	/* SA general info */
+	pr_info("\tx = %p\n", x);
+	/* SPI */
+	pr_info("\tx->id.spi = 0x%x\n", htonl(x->id.spi));
+	/* ESP/AH */
+	pr_info("\tx->id.proto = 0x%x\n", htonl(x->id.proto));
+	/* tunnel destination */
+	pr_info("\tx->id.daddr.a4 = %pI4\n", &x->id.daddr.a4);
+	pr_info("\tx->props.saddr.a4 = %pI4\n", &x->props.saddr.a4);
+	pr_info("\tx->km.state = %s\n", xfrm_km_states[x->km.state]);
+	pr_info("\tx->km.dying = %d\n", x->km.dying);
+	pr_info("\tx->data = %p\n", x->data);
+
+	/* NAT-T: x->encap is non-NULL only with UDP Encapsulation */
+	if (x->encap) {
+		struct xfrm_encap_tmpl *encap = x->encap;
+		pr_info("\tNAT-T is enabled\n");
+		pr_info("\t\tx->encap->encap_type: %s\n",
+		       encap->encap_type ==
+		       UDP_ENCAP_ESPINUDP ? "UDP_ENCAP_ESPINUDP" :
+			(encap->encap_type == UDP_ENCAP_ESPINUDP_NON_IKE ?
+				"UDP_ENCAP_ESPINUDP_NON_IKE" : "Unsupported"));
+		pr_info("\t\tx->encap->encap_sport = %d\n",
+		       ntohs(encap->encap_sport));
+		pr_info("\t\tx->encap->encap_dport = %d\n",
+		       ntohs(encap->encap_dport));
+	}
+
+	pr_info("\tx->props.mode = %d\n", x->props.mode);
+	if (x->props.mode == XFRM_MODE_TUNNEL)
+		pr_info("\tSA is TUNNEL mode!\n");
+	else if (x->props.mode == XFRM_MODE_TRANSPORT)
+		pr_info("\tSA is TRANSPORT mode!\n");
+	else
+		pr_err("\tSA has unsupported mode!\n");
+
+	/* Authentication algorithm */
+	if (x->aalg) {
+		struct xfrm_algo_desc *aalg_desc;
+		int i;
+		pr_info("\tx->aalg->alg_name = %s\n",
+		       x->aalg->alg_name);
+		pr_info("\tx->aalg->alg_key_len = %d\n",
+		       x->aalg->alg_key_len);
+		pr_info("\tx->aalg->alg_key:");
+		for (i = 0; i < x->aalg->alg_key_len / 8; i++) {
+			if (i % 16 == 0)
+				pr_cont("\n\t\t");
+			pr_cont("%02x ",
+			       (unsigned char)x->aalg->alg_key[i]);
+		}
+		pr_cont("\n");
+		aalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);
+		BUG_ON(!aalg_desc);
+		pr_info(
+		       "\taalg_desc->uinfo.auth.icv_fullbits = %d, "
+		       "aalg_desc->uinfo.auth.icv_truncbits = %d\n",
+		       aalg_desc->uinfo.auth.icv_fullbits,
+		       aalg_desc->uinfo.auth.icv_truncbits);
+		pr_info(
+		       "\taalg_desc->uinfo.auth.icv_fullbits/8 = %d, "
+		       "aalg_desc->uinfo.auth.icv_truncbits/8 = %d\n",
+		       aalg_desc->uinfo.auth.icv_fullbits / 8,
+		       aalg_desc->uinfo.auth.icv_truncbits / 8);
+	}
+	/* Encryption algorithm */
+	if (x->ealg) {
+		int i;
+		pr_info("\tx->ealg->alg_name = %s\n",
+		       x->ealg->alg_name);
+		pr_info("\tx->ealg->alg_key_len = %d\n",
+		       x->ealg->alg_key_len);
+		pr_info("\tx->ealg->alg_key:");
+		for (i = 0; i < x->ealg->alg_key_len / 8; i++) {
+			if (i % 16 == 0)
+				pr_cont("\n\t\t");
+			pr_cont("%02x ",
+			       (unsigned char)x->ealg->alg_key[i]);
+		}
+		pr_cont("\n");
+	}
+
+	if (x->aead) {
+		int i;
+		pr_info("\tx->aead->alg_name = %s\n",
+		       x->aead->alg_name);
+		pr_info("\tx->aead->alg_key_len = %d\n",
+		       x->aead->alg_key_len);
+		pr_info("\tx->aead->alg_icv_len = %d\n",
+		       x->aead->alg_icv_len);
+		pr_info("\tx->aead->alg_key:");
+		for (i = 0; i < x->aead->alg_key_len / 8; i++) {
+			if (i % 16 == 0)
+				pr_cont("\n\t\t");
+			pr_cont("%02x ",
+			       (unsigned char)x->aead->alg_key[i]);
+		}
+	}
+
+	len = snprintf(authenc_name, CRYPTO_MAX_ALG_NAME, "authenc(%s,%s)",
+		       x->aalg ? x->aalg->alg_name : "digest_null",
+		       x->ealg->alg_name);
+	BUG_ON(len > CRYPTO_MAX_ALG_NAME);
+
+	/*
+	   if (!in_atomic()) {
+	   aead = crypto_alloc_aead(authenc_name, 0, 0);
+	   BUG_ON(!aead);
+	   pr_info(
+		"\tcrypto_aead_ivsize() = %d\n", crypto_aead_ivsize(aead));
+	   crypto_free_aead(aead);
+	   }
+	 */
+	if (x->aead) {
+		pr_info("\tx->aead->alg_name = %s\n",
+		       x->aead->alg_name);
+		pr_info("\tx->aead->alg_key_len = %d\n",
+		       x->aead->alg_key_len);
+		pr_info("\tx->aead->alg_icv_len = %d\n",
+		       x->aead->alg_icv_len);
+	}
+	if (x->type) {
+		pr_info("\tx->type->description = %s\n",
+		       x->type->description);
+		pr_info("\tx->type->flags = 0x%x\n", x->type->flags);
+	}
+	/* Lifetime parameters */
+	pr_info("\tx->lft.soft_byte_limit = %lld\n",
+	       x->lft.soft_byte_limit);
+	pr_info("\tx->lft.hard_byte_limit = %lld\n",
+	       x->lft.hard_byte_limit);
+	pr_info("\tx->lft.soft_packet_limit = %lld\n",
+	       x->lft.soft_packet_limit);
+	pr_info("\tx->lft.hard_packet_limit = %lld\n",
+	       x->lft.hard_packet_limit);
+	pr_info("\tx->lft.soft_add_expires_seconds = %lld\n",
+	       x->lft.soft_add_expires_seconds);
+	pr_info("\tx->lft.hard_add_expires_seconds = %lld\n",
+	       x->lft.hard_add_expires_seconds);
+	pr_info("\tx->lft.soft_use_expires_seconds = %lld\n",
+	       x->lft.soft_use_expires_seconds);
+	pr_info("\tx->lft.hard_use_expires_seconds = %lld\n",
+	       x->lft.hard_use_expires_seconds);
+	pr_info("\n\n");
+}
+
+void dump_xfrm_selector(struct xfrm_selector *sel)
+{
+	pr_info("\tsaddr %pI4 daddr %pI4\n", &sel->saddr.a4,
+	       &sel->daddr.a4);
+	pr_info("\tprefixlen_s %d prefixlen_d %d\n", sel->prefixlen_s,
+	       sel->prefixlen_d);
+	pr_info("\tproto %d\n", sel->proto);
+	pr_info("\tsport %d dport %d\n", sel->sport, sel->dport);
+	pr_info("\tsport mask %04x dport mask %04x\n", sel->sport_mask,
+	       sel->dport_mask);
+}
+
+void dump_xfrm_template(struct xfrm_tmpl *tmpl)
+{
+	pr_info("\ttemplates:\n");
+	pr_info("\t\tdaddr %pI4 spi %x proto %d saddr %pI4 mode %d\n",
+	       &tmpl->id.daddr.a4, tmpl->id.spi, tmpl->id.proto,
+	       &tmpl->saddr.a4, tmpl->mode);
+}
+#else
+void dump_xfrm_sa(struct xfrm_state *x)
+{
+}
+
+void dump_xfrm_selector(struct xfrm_selector *sel)
+{
+}
+
+void dump_xfrm_template(struct xfrm_tmpl *tmpl)
+{
+}
+#endif
-- 
1.7.5.4

