From 6cbd57ce66f04222cf024434958c963fc73269be Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Thu, 9 Aug 2012 16:11:57 +0000
Subject: [PATCH 276/518] dpa_classifier: Use anonymous unions

Simplified the DPA Classifier header manipulation API by using
anonymous unions instead of named unions.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  184 +++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   16 +-
 include/linux/fsl_dpa_classifier.h               |    8 +-
 3 files changed, 103 insertions(+), 105 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index b08aa79..e8389fa 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -2350,7 +2350,7 @@ static int insert_hm_check_params(const struct dpa_cls_hm_insert_params
 		return -ENOSYS;
 		break;
 	case DPA_CLS_HM_INSERT_ETHERNET:
-		if (insert_params->param.eth.num_tags >
+		if (insert_params->eth.num_tags >
 			DPA_CLS_HM_MAX_VLANs) {
 			pr_err("ERROR: %s, %s (%d): Insert HM: Can only insert "
 				"a maximum of %d VLANs.\n", __FILE__, __func__,
@@ -2453,7 +2453,7 @@ static int
 	xx_assert(vlan_params);
 
 	if ((vlan_params->type != DPA_CLS_HM_VLAN_EGRESS) &&
-		(vlan_params->params.egress.update_op !=
+		(vlan_params->egress.update_op !=
 		DPA_CLS_HM_VLAN_UPDATE_VPri)) {
 		pr_err("ERROR: %s, %s (%d): Unsupported VLAN specific header "
 			"manipulation.\n", __FILE__, __func__, __LINE__);
@@ -2462,7 +2462,7 @@ static int
 
 	switch (vlan_params->type) {
 	case DPA_CLS_HM_VLAN_INGRESS:
-		if (vlan_params->params.ingress.num_tags !=
+		if (vlan_params->ingress.num_tags !=
 			DPA_CLS_HM_VLAN_CNT_ALL_QTAGS) {
 			pr_err("ERROR: %s, %s (%d): Ingress VLAN QTags remove "
 				"HM: Only \"remove all QTags\" is currenly "
@@ -2471,7 +2471,7 @@ static int
 		}
 		break;
 	case DPA_CLS_HM_VLAN_EGRESS:
-		if (vlan_params->params.egress.num_tags >
+		if (vlan_params->egress.num_tags >
 						DPA_CLS_HM_MAX_VLANs) {
 			pr_err("ERROR: %s, %s (%d): Egress VLAN HM: Can only "
 				"insert a maximum of %d VLANs.\n", __FILE__,
@@ -2826,7 +2826,7 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	pnat_hm->chain_head	= chain_head;
 
 	/* Copy the NAT parameters locally */
-	memcpy(&pnat_hm->params.nat, nat_params, sizeof(*nat_params));
+	memcpy(&pnat_hm->nat_params, nat_params, sizeof(*nat_params));
 
 	if (res)
 		/* Need to import */
@@ -2842,7 +2842,7 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pnat_hm->params.nat.fm_pcd,
+			err = init_hm_chain(pnat_hm->nat_params.fm_pcd,
 				pnat_hm->hm_chain, pnat_hm->hm_chain);
 	}
 
@@ -3013,7 +3013,7 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	pfwd_hm->chain_head	= chain_head;
 
 	/* Copy the NAT parameters locally */
-	memcpy(&pfwd_hm->params.fwd, fwd_params, sizeof(*fwd_params));
+	memcpy(&pfwd_hm->fwd_params, fwd_params, sizeof(*fwd_params));
 
 	if (res)
 		/* Need to import */
@@ -3029,7 +3029,7 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pfwd_hm->params.fwd.fm_pcd,
+			err = init_hm_chain(pfwd_hm->fwd_params.fm_pcd,
 				pfwd_hm->hm_chain, pfwd_hm->hm_chain);
 	}
 
@@ -3075,7 +3075,7 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 
 	xx_assert(pfwd_hm->params.fwd.out_if_type != DPA_CLS_HM_IF_TYPE_PPPoE);
 
-	switch (pfwd_hm->params.fwd.out_if_type) {
+	switch (pfwd_hm->fwd_params.out_if_type) {
 	case DPA_CLS_HM_IF_TYPE_ETHERNET:
 		/* Update Ethernet MACS */
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
@@ -3094,8 +3094,8 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 			return -ENOMEM;
 		}
 
-		memcpy(pdata, pfwd_hm->params.fwd.param.eth.macda, ETH_ALEN);
-		memcpy(&pdata[ETH_ALEN], pfwd_hm->params.fwd.param.eth.macsa,
+		memcpy(pdata, pfwd_hm->fwd_params.eth.macda, ETH_ALEN);
+		memcpy(&pdata[ETH_ALEN], pfwd_hm->fwd_params.eth.macsa,
 			ETH_ALEN);
 
 		hm_node->params.u.hdr.insrtParams.u.generic.offset = 0;
@@ -3130,7 +3130,7 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 			return -ENOMEM;
 		}
 
-		memcpy(pdata, &pfwd_hm->params.fwd.param.ppp.ppp_pid,
+		memcpy(pdata, &pfwd_hm->fwd_params.ppp.ppp_pid,
 			PPP_HEADER_SIZE);
 
 		hm_node->params.u.hdr.insrtParams.u.generic.offset = 0;
@@ -3140,7 +3140,7 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 	default:
 		pr_err("ERROR: %s, %s (%d): Forwarding HM: Unknown output port "
 			"type (%d).\n", __FILE__, __func__, __LINE__,
-			pfwd_hm->params.fwd.out_if_type);
+			pfwd_hm->fwd_params.out_if_type);
 		kfree(hm_node);
 		return -EINVAL;
 	}
@@ -3194,7 +3194,7 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	premove_hm->chain_head	= chain_head;
 
 	/* Copy the remove HM parameters locally */
-	memcpy(&premove_hm->params.remove, remove_params,
+	memcpy(&premove_hm->remove_params, remove_params,
 						sizeof(*remove_params));
 
 	if (res)
@@ -3209,7 +3209,7 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(premove_hm->params.remove.fm_pcd,
+			err = init_hm_chain(premove_hm->remove_params.fm_pcd,
 				premove_hm->hm_chain, premove_hm->hm_chain);
 	}
 
@@ -3255,7 +3255,7 @@ static int init_remove_hm(struct dpa_cls_hm *premove_hm)
 	hm_node->params.u.hdr.rmv		= TRUE;
 	hm_node->params.u.hdr.rmvParams.type	= e_FM_PCD_MANIP_RMV_GENERIC;
 
-	switch (premove_hm->params.remove.type) {
+	switch (premove_hm->remove_params.type) {
 	case DPA_CLS_HM_REMOVE_PPP:
 		hm_node->params.u.hdr.rmvParams.u.generic.offset =
 							PPP_HEADER_OFFSET;
@@ -3264,9 +3264,9 @@ static int init_remove_hm(struct dpa_cls_hm *premove_hm)
 		break;
 	case DPA_CLS_HM_REMOVE_CUSTOM:
 		hm_node->params.u.hdr.rmvParams.u.generic.offset =
-					premove_hm->params.remove.custom.offset;
+					premove_hm->remove_params.custom.offset;
 		hm_node->params.u.hdr.rmvParams.u.generic.size =
-					premove_hm->params.remove.custom.size;
+					premove_hm->remove_params.custom.size;
 		break;
 	default:
 		break;
@@ -3322,7 +3322,7 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	pinsert_hm->chain_head	= chain_head;
 
 	/* Copy the insert HM parameters locally */
-	memcpy(&pinsert_hm->params.insert, insert_params,
+	memcpy(&pinsert_hm->insert_params, insert_params,
 						sizeof(*insert_params));
 
 	if (res)
@@ -3337,7 +3337,7 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pinsert_hm->params.insert.fm_pcd,
+			err = init_hm_chain(pinsert_hm->insert_params.fm_pcd,
 				pinsert_hm->hm_chain, pinsert_hm->hm_chain);
 	}
 
@@ -3386,10 +3386,10 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 	hm_node->params.u.hdr.insrt		= TRUE;
 	hm_node->params.u.hdr.insrtParams.type	= e_FM_PCD_MANIP_INSRT_GENERIC;
 
-	switch (pinsert_hm->params.insert.type) {
+	switch (pinsert_hm->insert_params.type) {
 	case DPA_CLS_HM_INSERT_ETHERNET:
 		size = sizeof(struct ethhdr) +
-			(pinsert_hm->params.insert.param.eth.num_tags *
+			(pinsert_hm->insert_params.eth.num_tags *
 			sizeof(struct vlan_header));
 		pdata = kzalloc(size, GFP_KERNEL);
 		if (!pdata) {
@@ -3399,27 +3399,27 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 			return -ENOMEM;
 		}
 
-		if (pinsert_hm->params.insert.param.eth.num_tags) {
+		if (pinsert_hm->insert_params.eth.num_tags) {
 			/* Copy Ethernet header data except the EtherType */
 			memcpy(pdata,
-				&pinsert_hm->params.insert.param.eth.eth_header,
+				&pinsert_hm->insert_params.eth.eth_header,
 				sizeof(struct ethhdr) - ETHERTYPE_SIZE);
 			offset += (uint8_t)(sizeof(struct ethhdr) -
 								ETHERTYPE_SIZE);
 			/* Copy the VLAN tags */
 			memcpy(&pdata[offset],
-				&pinsert_hm->params.insert.param.eth.qtag,
-				pinsert_hm->params.insert.param.eth.num_tags *
+				&pinsert_hm->insert_params.eth.qtag,
+				pinsert_hm->insert_params.eth.num_tags *
 				sizeof(struct vlan_header));
-			offset += (uint8_t) (pinsert_hm->params.insert.param.
-				eth.num_tags * sizeof(struct vlan_header));
+			offset += (uint8_t) (pinsert_hm->insert_params.eth.
+				num_tags * sizeof(struct vlan_header));
 			/* Copy the EtherType */
 			memcpy(&pdata[offset],
-		&pinsert_hm->params.insert.param.eth.eth_header.h_proto,
+		&pinsert_hm->insert_params.eth.eth_header.h_proto,
 				ETHERTYPE_SIZE);
 		} else
 			memcpy(pdata,
-				&pinsert_hm->params.insert.param.eth.eth_header,
+				&pinsert_hm->insert_params.eth.eth_header,
 				sizeof(struct ethhdr));
 
 		offset = 0;
@@ -3434,13 +3434,13 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 			return -ENOMEM;
 		}
 
-		memcpy(pdata, &pinsert_hm->params.insert.param.ppp_pid,
+		memcpy(pdata, &pinsert_hm->insert_params.ppp_pid,
 			PPP_HEADER_SIZE);
 		break;
 	case DPA_CLS_HM_INSERT_CUSTOM:
-		size	= pinsert_hm->params.insert.param.custom.size;
-		pdata	= pinsert_hm->params.insert.param.custom.data;
-		offset	= pinsert_hm->params.insert.param.custom.offset;
+		size	= pinsert_hm->insert_params.custom.size;
+		pdata	= pinsert_hm->insert_params.custom.data;
+		offset	= pinsert_hm->insert_params.custom.offset;
 		break;
 	default:
 		/* Will never get here */
@@ -3503,7 +3503,7 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	pupdate_hm->chain_head	= chain_head;
 
 	/* Copy the update HM parameters locally */
-	memcpy(&pupdate_hm->params.update, update_params,
+	memcpy(&pupdate_hm->update_params, update_params,
 						sizeof(*update_params));
 
 	if (res)
@@ -3518,7 +3518,7 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pupdate_hm->params.update.fm_pcd,
+			err = init_hm_chain(pupdate_hm->update_params.fm_pcd,
 				pupdate_hm->hm_chain, pupdate_hm->hm_chain);
 	}
 
@@ -3561,7 +3561,7 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 				struct dpa_cls_hm,
 				list_node);
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 			DPA_CLS_HM_UPDATE_IPv4_UPDATE)
 			/*
 			 * See if there is any other IPv4 update node in this
@@ -3571,7 +3571,7 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 				DPA_CLS_HM_NODE_IPv4_HDR_UPDATE,
 				pnext_hm->hm_chain);
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 			DPA_CLS_HM_UPDATE_IPv6_UPDATE)
 			/*
 			 * See if there is any other IPv6 update node in this
@@ -3581,7 +3581,7 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 				DPA_CLS_HM_NODE_IPv6_HDR_UPDATE,
 				pnext_hm->hm_chain);
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 			DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE)
 			/*
 			 * See if there is any other TCP/UDP header update node
@@ -3613,139 +3613,139 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 	replace_ops = DPA_CLS_HM_REPLACE_IPv4_BY_IPv6 |
 			DPA_CLS_HM_REPLACE_IPv6_BY_IPv4;
 
-	if (pupdate_hm->params.update.op_flags & update_ops) {
+	if (pupdate_hm->update_params.op_flags & update_ops) {
 
 		hm_node->params.u.hdr.fieldUpdate = TRUE;
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_IPv4_UPDATE) {
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4;
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_IPSA) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV4_SRC;
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					src =
-					pupdate_hm->params.update.update.l3.
+					pupdate_hm->update_params.update.l3.
 					ipsa.addr.ipv4.word;
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_IPDA) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV4_DST;
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					dst =
-					pupdate_hm->params.update.update.l3.
+					pupdate_hm->update_params.update.l3.
 					ipda.addr.ipv4.word;
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_TOS_TC) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV4_TOS;
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					tos =
-					pupdate_hm->params.update.update.l3.
+					pupdate_hm->update_params.update.l3.
 					tos_tc;
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_ID) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV4_ID;
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					id =
-					pupdate_hm->params.update.update.l3.
+					pupdate_hm->update_params.update.l3.
 					initial_id;
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_TTL_HOPL_DECREMENT)
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV4_TTL;
 		}
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_IPv6_UPDATE) {
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6;
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_IPSA) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv6.
 					validUpdates |=
 					HDR_MANIP_IPV6_SRC;
 				memcpy(hm_node->params.u.hdr.fieldUpdateParams.
-					u.ipv6.src, pupdate_hm->params.update.
+					u.ipv6.src, pupdate_hm->update_params.
 					update.l3.ipsa.addr.ipv6.byte,
 					DPA_OFFLD_IPv6_ADDR_LEN_BYTES);
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_IPDA) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv4.
 					validUpdates |=
 					HDR_MANIP_IPV6_DST;
 				memcpy(hm_node->params.u.hdr.fieldUpdateParams.
-					u.ipv6.dst, pupdate_hm->params.update.
+					u.ipv6.dst, pupdate_hm->update_params.
 					update.l3.ipda.addr.ipv6.byte,
 					DPA_OFFLD_IPv6_ADDR_LEN_BYTES);
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_TOS_TC) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv6.
 					validUpdates |=
 					HDR_MANIP_IPV6_TC;
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv6.
 					trafficClass =
-					pupdate_hm->params.update.update.l3.
+					pupdate_hm->update_params.update.l3.
 					tos_tc;
 			}
 
-			if (pupdate_hm->params.update.update.l3.field_flags &
+			if (pupdate_hm->update_params.update.l3.field_flags &
 				DPA_CLS_HM_IP_UPDATE_TTL_HOPL_DECREMENT)
 				hm_node->params.u.hdr.fieldUpdateParams.u.ipv6.
 					validUpdates |=
 					HDR_MANIP_IPV6_HL;
 		}
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE) {
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP;
 
-			if (pupdate_hm->params.update.update.l4.field_flags &
+			if (pupdate_hm->update_params.update.l4.field_flags &
 				DPA_CLS_HM_L4_UPDATE_SPORT) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.
 					tcpUdp.validUpdates |=
 					HDR_MANIP_TCP_UDP_SRC;
 				hm_node->params.u.hdr.fieldUpdateParams.u.
 					tcpUdp.src =
-					pupdate_hm->params.update.update.l4.
+					pupdate_hm->update_params.update.l4.
 					sport;
 			}
 
-			if (pupdate_hm->params.update.update.l4.field_flags &
+			if (pupdate_hm->update_params.update.l4.field_flags &
 				DPA_CLS_HM_L4_UPDATE_DPORT) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.
 					tcpUdp.validUpdates |=
 					HDR_MANIP_TCP_UDP_DST;
 				hm_node->params.u.hdr.fieldUpdateParams.u.
 					tcpUdp.dst =
-					pupdate_hm->params.update.update.l4.
+					pupdate_hm->update_params.update.l4.
 					dport;
 			}
 
-			if (pupdate_hm->params.update.update.l4.field_flags &
+			if (pupdate_hm->update_params.update.l4.field_flags &
 				DPA_CLS_HM_L4_UPDATE_CALCULATE_CKSUM) {
 				hm_node->params.u.hdr.fieldUpdateParams.u.
 					tcpUdp.validUpdates |=
@@ -3754,13 +3754,13 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 		}
 	}
 
-	if (pupdate_hm->params.update.op_flags & replace_ops) {
+	if (pupdate_hm->update_params.op_flags & replace_ops) {
 
 		hm_node->params.u.hdr.custom = TRUE;
 		hm_node->params.u.hdr.customParams.type =
 				e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE;
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_REPLACE_IPv4_BY_IPv6) {
 
 			hm_node->params.u.hdr.customParams.u.ipHdrReplace.
@@ -3771,11 +3771,11 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 
 			memcpy(hm_node->params.u.hdr.customParams.u.
 				ipHdrReplace.hdr,
-				&pupdate_hm->params.update.replace.ipv6_hdr,
+				&pupdate_hm->update_params.replace.ipv6_hdr,
 				sizeof(struct ipv6_header));
 		}
 
-		if (pupdate_hm->params.update.op_flags &
+		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_REPLACE_IPv6_BY_IPv4) {
 
 			hm_node->params.u.hdr.customParams.u.ipHdrReplace.
@@ -3785,7 +3785,7 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 				hdrSize = sizeof(struct iphdr);
 			memcpy(hm_node->params.u.hdr.customParams.u.
 				ipHdrReplace.hdr,
-				&pupdate_hm->params.update.replace.ipv4_hdr,
+				&pupdate_hm->update_params.replace.ipv4_hdr,
 				sizeof(struct iphdr));
 		}
 	}
@@ -3796,7 +3796,7 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 	if (size)
 		INIT_LIST_HEAD(&pupdate_hm->hm_node[0]->list_node);
 
-	if (pupdate_hm->params.update.ip_frag_params.mtu) {
+	if (pupdate_hm->update_params.ip_frag_params.mtu) {
 		/* IP fragmentation option is enabled */
 		/* Create a header manip node: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
@@ -3809,11 +3809,11 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 		hm_node->params.type = e_FM_PCD_MANIP_FRAG;
 		hm_node->params.u.frag.hdr = HEADER_TYPE_IPv4;
 		hm_node->params.u.frag.u.ipFrag.sizeForFragmentation =
-				pupdate_hm->params.update.ip_frag_params.mtu;
+				pupdate_hm->update_params.ip_frag_params.mtu;
 		hm_node->params.u.frag.u.ipFrag.scratchBpid =
-				pupdate_hm->params.update.ip_frag_params.
+				pupdate_hm->update_params.ip_frag_params.
 					scratch_bpid;
-		switch (pupdate_hm->params.update.ip_frag_params.df_action) {
+		switch (pupdate_hm->update_params.ip_frag_params.df_action) {
 		case DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY:
 			hm_node->params.u.frag.u.ipFrag.dontFragAction =
 					e_FM_PCD_MANIP_FRAGMENT_PACKET;
@@ -3882,7 +3882,7 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 	pvlan_hm->chain_head	= chain_head;
 
 	/* Copy the VLAN specific HM parameters locally */
-	memcpy(&pvlan_hm->params.vlan, vlan_params, sizeof(*vlan_params));
+	memcpy(&pvlan_hm->vlan_params, vlan_params, sizeof(*vlan_params));
 
 	if (res)
 		err = import_vlan_hm(pvlan_hm, res);
@@ -3896,7 +3896,7 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pvlan_hm->params.vlan.fm_pcd,
+			err = init_hm_chain(pvlan_hm->vlan_params.fm_pcd,
 				pvlan_hm->hm_chain, pvlan_hm->hm_chain);
 	}
 
@@ -3942,7 +3942,7 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
 
-	switch (pvlan_hm->params.vlan.type) {
+	switch (pvlan_hm->vlan_params.type) {
 	case DPA_CLS_HM_VLAN_INGRESS:
 		hm_node->params.u.hdr.rmv = TRUE;
 		hm_node->params.u.hdr.rmvParams.type	=
@@ -3954,7 +3954,7 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 
 		break;
 	case DPA_CLS_HM_VLAN_EGRESS:
-		if (pvlan_hm->params.vlan.params.egress.num_tags) {
+		if (pvlan_hm->vlan_params.egress.num_tags) {
 
 			hm_node->params.u.hdr.insrt = TRUE;
 			hm_node->params.u.hdr.insrtParams.type =
@@ -3962,7 +3962,7 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 			hm_node->params.u.hdr.insrtParams.u.generic.offset =
 							ETHERTYPE_OFFSET;
 
-			size = (uint8_t) (pvlan_hm->params.vlan.params.egress.
+			size = (uint8_t) (pvlan_hm->vlan_params.egress.
 				num_tags * sizeof(struct vlan_header));
 			pdata = kzalloc(size, GFP_KERNEL);
 			if (!pdata) {
@@ -3973,7 +3973,7 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 				return -ENOMEM;
 			}
 
-			memcpy(pdata, pvlan_hm->params.vlan.params.egress.qtag,
+			memcpy(pdata, pvlan_hm->vlan_params.egress.qtag,
 				size);
 
 			hm_node->params.u.hdr.insrtParams.u.generic.size =
@@ -3984,23 +3984,21 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 									FALSE;
 		}
 
-		if (pvlan_hm->params.vlan.params.egress.update_op !=
+		if (pvlan_hm->vlan_params.egress.update_op !=
 					DPA_CLS_HM_VLAN_UPDATE_NONE) {
 
 			hm_node->params.u.hdr.fieldUpdate = TRUE;
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN;
 
-			switch (pvlan_hm->params.vlan.params.egress.
-								update_op) {
+			switch (pvlan_hm->vlan_params.egress.update_op) {
 			case DPA_CLS_HM_VLAN_UPDATE_VPri:
 				hm_node->params.u.hdr.fieldUpdateParams.u.vlan.
 					updateType =
 				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI;
 				hm_node->params.u.hdr.fieldUpdateParams.u.vlan.
-					u.vpri =
-					pvlan_hm->params.vlan.params.egress.
-					update_params.vpri;
+					u.vpri = pvlan_hm->vlan_params.egress.
+					update.vpri;
 				break;
 			case DPA_CLS_HM_VLAN_UPDATE_VPri_BY_DSCP:
 				hm_node->params.u.hdr.fieldUpdateParams.u.vlan.
@@ -4008,8 +4006,8 @@ static int init_vlan_hm(struct dpa_cls_hm *pvlan_hm)
 				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN;
 				memcpy(hm_node->params.u.hdr.fieldUpdateParams.
 					u.vlan.u.dscpToVpri.dscpToVpriTable,
-					pvlan_hm->params.vlan.params.egress.
-					update_params.dscp_to_vpri,
+					pvlan_hm->vlan_params.egress.update.
+					dscp_to_vpri,
 					FM_PCD_MANIP_DSCP_TO_VLAN_TRANS);
 				break;
 			default:
@@ -4076,7 +4074,7 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 	pmpls_hm->chain_head	= chain_head;
 
 	/* Copy the VLAN specific HM parameters locally */
-	memcpy(&pmpls_hm->params.mpls, mpls_params, sizeof(*mpls_params));
+	memcpy(&pmpls_hm->mpls_params, mpls_params, sizeof(*mpls_params));
 
 	if (res)
 		err = import_mpls_hm(pmpls_hm, res);
@@ -4090,7 +4088,7 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 
 		if (chain_head)
 			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pmpls_hm->params.mpls.fm_pcd,
+			err = init_hm_chain(pmpls_hm->mpls_params.fm_pcd,
 				pmpls_hm->hm_chain, pmpls_hm->hm_chain);
 	}
 
@@ -4136,7 +4134,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
 
-	switch (pmpls_hm->params.mpls.type) {
+	switch (pmpls_hm->mpls_params.type) {
 	case DPA_CLS_HM_MPLS_REMOVE_ALL_LABELS:
 		hm_node->params.u.hdr.rmv = TRUE;
 		hm_node->params.u.hdr.rmvParams.type =
@@ -4157,7 +4155,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 					specificL2 =
 					e_FM_PCD_MANIP_HDR_INSRT_MPLS;
 
-		size = (uint8_t) (pmpls_hm->params.mpls.num_labels *
+		size = (uint8_t) (pmpls_hm->mpls_params.num_labels *
 						sizeof(struct mpls_header));
 		pdata = kzalloc(size, GFP_KERNEL);
 		if (!pdata) {
@@ -4167,7 +4165,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 			return -ENOMEM;
 		}
 
-		memcpy(pdata, pmpls_hm->params.mpls.mpls_hdr, size);
+		memcpy(pdata, pmpls_hm->mpls_params.mpls_hdr, size);
 
 		hm_node->params.u.hdr.insrtParams.u.byHdr.u.specificL2Params.
 			size = size;
@@ -4179,7 +4177,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 		kfree(hm_node);
 		pr_err("ERROR: %s, %s (%d): Unknown MPLS header manipulation "
 			"(%d).\n", __FILE__, __func__, __LINE__,
-			pmpls_hm->params.mpls.type);
+			pmpls_hm->mpls_params.type);
 		return -EINVAL;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 4d465a1..cfd1039 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -240,14 +240,14 @@ struct dpa_cls_hm {
 	bool						chain_head;
 
 	union {
-		struct dpa_cls_hm_nat_params		nat;
-		struct dpa_cls_hm_fwd_params		fwd;
-		struct dpa_cls_hm_remove_params		remove;
-		struct dpa_cls_hm_insert_params		insert;
-		struct dpa_cls_hm_update_params		update;
-		struct dpa_cls_hm_vlan_params		vlan;
-		struct dpa_cls_hm_mpls_params		mpls;
-	} params;
+		struct dpa_cls_hm_nat_params		nat_params;
+		struct dpa_cls_hm_fwd_params		fwd_params;
+		struct dpa_cls_hm_remove_params		remove_params;
+		struct dpa_cls_hm_insert_params		insert_params;
+		struct dpa_cls_hm_update_params		update_params;
+		struct dpa_cls_hm_vlan_params		vlan_params;
+		struct dpa_cls_hm_mpls_params		mpls_params;
+	};
 
 	struct dpa_cls_hm_node		*hm_node[DPA_CLS_HM_MAX_NODES_PER_OP];
 
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index fb545c9..16c9657 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -687,7 +687,7 @@ struct dpa_cls_hm_fwd_params {
 
 		/* Necessary parameters for a PPP output interface */
 		struct dpa_cls_hm_fwd_ppp_param		ppp;
-	} param;
+	};
 
 	/* Parameters related to optional IP fragmentation */
 	struct dpa_cls_hm_ip_frag_params		ip_frag_params;
@@ -879,7 +879,7 @@ struct dpa_cls_hm_insert_params {
 		 * manipulation operation is selected.
 		 */
 		struct dpa_cls_hm_custom_ins_params	custom;
-	} param;
+	};
 
 	/*
 	 * Handle to the low level driver PCD to use when creating the header
@@ -1123,7 +1123,7 @@ struct dpa_cls_hm_egress_vlan_params {
 		 */
 		uint8_t dscp_to_vpri[DPA_CLS_HM_DSCP_TO_VPRI_TABLE_SIZE];
 
-	} update_params;
+	} update;
 };
 
 /* VLAN specific header manipulation low level resources */
@@ -1157,7 +1157,7 @@ struct dpa_cls_hm_vlan_params {
 
 		/* Parameters for egress VLAN header manipulations */
 		struct dpa_cls_hm_egress_vlan_params	egress;
-	} params;
+	};
 
 	/*
 	 * Handle to the low level driver PCD to use when creating the header
-- 
1.7.5.4

