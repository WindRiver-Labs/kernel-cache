From 8964cb8ff451f0cd4c02fc4145c041d629575038 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:16:39 +0000
Subject: [PATCH 219/518] Updated DPA Classifier code to use standard Linux
 alloc/free functions

replaced xx_malloc/xx_zalloc/xx_free with Linux kmalloc/kzalloc/kfree
functions.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  118 +++++++++-------------
 1 files changed, 49 insertions(+), 69 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 611665c..e757b97 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -88,8 +88,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 		get_new_table_descriptor(td);
 	}
 
-	ptable = (struct dpa_cls_table *)
-			xx_zalloc(sizeof(struct dpa_cls_table));
+	ptable = kzalloc(sizeof(*ptable), GFP_KERNEL);
 	if (!ptable) {
 		pr_err("No more memory for DPA classifier table.");
 		err = -ENOMEM;
@@ -101,8 +100,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 
 	if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY) {
 		ptable->shadow_table =
-			(struct dpa_cls_tbl_shadow_table *)
-			xx_zalloc(sizeof(*ptable->shadow_table));
+			kzalloc(sizeof(*ptable->shadow_table), GFP_KERNEL);
 		if (!ptable->shadow_table) {
 			pr_err("No more memory for DPA classifier shadow table.");
 			err = -ENOMEM;
@@ -158,9 +156,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	/* Init shadow table if necessary */
 	if (ptable->shadow_table) {
 		/* Allocate entries in the shadow table */
-		ptable->shadow_table->shadow_entry = (struct list_head *)
-			xx_malloc(ptable->shadow_table->size *
-					sizeof(struct list_head));
+		ptable->shadow_table->shadow_entry =
+			kmalloc(ptable->shadow_table->size *
+				sizeof(struct list_head), GFP_KERNEL);
 		if (!ptable->shadow_table->shadow_entry) {
 			pr_err("No more memory for DPA Classifier shadow tables.");
 			err = -ENOMEM;
@@ -188,21 +186,18 @@ dpa_classif_table_create_error:
 	/* Something went wrong. Release allocated memory and exit */
 	if (ptable) {
 		if (ptable->shadow_table) {
-			if (ptable->shadow_table->shadow_entry)
-				xx_free(ptable->shadow_table->shadow_entry);
-			xx_free(ptable->shadow_table);
+			kfree(ptable->shadow_table->shadow_entry);
+			kfree(ptable->shadow_table);
 		}
 
 		free_table_management(ptable);
 
 		/* Free entry index management */
-		if (ptable->entry) {
-			xx_free(ptable->entry);
-			ptable->entry		= NULL;
-			ptable->entries_cnt	= 0;
-		}
+		kfree(ptable->entry);
+		ptable->entry = NULL;
+		ptable->entries_cnt = 0;
 
-		xx_free(ptable);
+		kfree(ptable);
 		put_table_descriptor(*td);
 	}
 
@@ -228,11 +223,9 @@ int dpa_classif_table_free(int td)
 
 	/* Check shadow table if it exists */
 	if (ptable->shadow_table) {
-
 		/* Release shadow table */
-		if (ptable->shadow_table->shadow_entry)
-			xx_free(ptable->shadow_table->shadow_entry);
-		xx_free(ptable->shadow_table);
+		kfree(ptable->shadow_table->shadow_entry);
+		kfree(ptable->shadow_table);
 	}
 
 	switch (ptable->params.type) {
@@ -248,15 +241,13 @@ int dpa_classif_table_free(int td)
 	}
 
 	/* Free entry index management */
-	if (ptable->entry) {
-		xx_free(ptable->entry);
-		ptable->entry		= NULL;
-		ptable->entries_cnt	= 0;
-	}
+	kfree(ptable->entry);
+	ptable->entry		= NULL;
+	ptable->entries_cnt	= 0;
 
 	free_table_management(ptable);
 
-	xx_free(table[td]);
+	kfree(table[td]);
 
 	put_table_descriptor(td);
 
@@ -724,7 +715,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 
 			list_del(&shadow_entry_indexed->list_node);
 
-			xx_free(shadow_entry_indexed);
+			kfree(shadow_entry_indexed);
 		} else {
 			shadow_list_entry =
 					ptable->entry[entry_id].shadow_entry;
@@ -734,7 +725,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 
 			list_del(&shadow_entry->list_node);
 
-			xx_free(shadow_entry);
+			kfree(shadow_entry);
 		}
 
 	}
@@ -882,7 +873,7 @@ int dpa_classif_table_flush(int td)
 				list_node);
 
 				list_del(&shadow_entry_indexed->list_node);
-				xx_free(shadow_entry_indexed);
+				kfree(shadow_entry_indexed);
 			}
 		}
 		INIT_LIST_HEAD(&ptable->entry_list);
@@ -904,7 +895,7 @@ int dpa_classif_table_flush(int td)
 
 				list_del(&shadow_entry->list_node);
 
-				xx_free(shadow_entry);
+				kfree(shadow_entry);
 			}
 
 			cc_node_index = index_entry->int_cc_node_index;
@@ -1073,9 +1064,9 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 	xx_assert(cls_table);
 
 	/* Allocate the necessary table management tools */
-	cls_table->int_cc_node = (struct dpa_cls_tbl_cc_node_info *)
-		xx_zalloc(cls_table->int_cc_nodes_count *
-			sizeof(struct dpa_cls_tbl_cc_node_info));
+	cls_table->int_cc_node =
+		kzalloc(cls_table->int_cc_nodes_count *
+			sizeof(*cls_table->int_cc_node), GFP_KERNEL);
 	if (!cls_table->int_cc_node) {
 		pr_err("No more memory for DPA Classifier table management.");
 		err = -ENOMEM;
@@ -1094,8 +1085,7 @@ static void free_table_management(struct dpa_cls_table *cls_table)
 {
 	xx_assert(cls_table);
 
-	if (cls_table->int_cc_node)
-		xx_free(cls_table->int_cc_node);
+	kfree(cls_table->int_cc_node);
 
 	cls_table->int_cc_nodes_count = 0;
 }
@@ -1141,9 +1131,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 
 	/* Allocate the index management array */
 	cls_table->entries_cnt = cls_table->params.indexed_params.entries_cnt;
-	cls_table->entry = (struct dpa_cls_tbl_entry *)
-		xx_zalloc(cls_table->entries_cnt *
-			sizeof(struct dpa_cls_tbl_entry));
+	cls_table->entry =
+		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
+			GFP_KERNEL);
 	if (!cls_table->entry) {
 		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt = 0;
@@ -1170,8 +1160,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	if (err < 0)
 		return err;
 
-	hash_set_params = (t_FmPcdCcNodeParams *)
-		xx_zalloc(sizeof(struct t_FmPcdCcNodeParams));
+	hash_set_params = kzalloc(sizeof(*hash_set_params), GFP_KERNEL);
 	if (!hash_set_params) {
 		pr_err("No more memory for DPA Classifier hash table.");
 		err = -ENOMEM;
@@ -1236,9 +1225,9 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	/* Allocate the index management array */
 	cls_table->entries_cnt = cls_table->params.hash_params.num_sets *
 		cls_table->params.hash_params.max_ways;
-	cls_table->entry = (struct dpa_cls_tbl_entry *)
-		xx_zalloc(cls_table->entries_cnt *
-			sizeof(struct dpa_cls_tbl_entry));
+	cls_table->entry =
+		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
+			GFP_KERNEL);
 	if (!cls_table->entry) {
 		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt	= 0;
@@ -1251,13 +1240,12 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		(uint64_t)(cls_table->params.hash_params.num_sets - 1) <<
 		(8 * (6 - cls_table->params.hash_params.hash_offs) + 4) ;
 
-	xx_free(hash_set_params);
+	kfree(hash_set_params);
 
 	return err;
 
 table_init_hash_error:
-	if (hash_set_params)
-		xx_free(hash_set_params);
+	kfree(hash_set_params);
 
 	table_cleanup_hash(cls_table);
 
@@ -1284,8 +1272,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	cls_table->int_cc_node[0].cc_node = cls_table->params.cc_node;
 
 	/* Create additional Cc nodes if necessary */
-	cc_node_params = (t_FmPcdCcNodeParams *)
-		xx_zalloc(sizeof(t_FmPcdCcNodeParams));
+	cc_node_params = kzalloc(sizeof(*cc_node_params), GFP_KERNEL);
 	if (!cc_node_params) {
 		pr_err("No more memory for DPA Classifier exact match table.");
 		err = -ENOMEM;
@@ -1347,9 +1334,9 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	/* Allocate the index management array */
 	cls_table->entries_cnt =
 		cls_table->params.exact_match_params.entries_cnt;
-	cls_table->entry = (struct dpa_cls_tbl_entry *)
-		xx_zalloc(cls_table->entries_cnt *
-			sizeof(struct dpa_cls_tbl_entry));
+	cls_table->entry =
+		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
+			GFP_KERNEL);
 	if (!cls_table->entry) {
 		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt	= 0;
@@ -1358,13 +1345,12 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	}
 	INIT_LIST_HEAD(&cls_table->entry_list);
 
-	xx_free(cc_node_params);
+	kfree(cc_node_params);
 
 	return err;
 
 table_init_exact_match_error:
-	if (cc_node_params)
-		xx_free(cc_node_params);
+	kfree(cc_node_params);
 
 	table_cleanup_exact_match(cls_table);
 
@@ -1662,8 +1648,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 
 	/* If a shadow table exists, add the action to it */
 	if (cls_table->shadow_table) {
-		shadow_entry = (struct dpa_cls_tbl_shadow_entry_indexed *)
-			xx_zalloc(sizeof(*shadow_entry));
+		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
 			pr_err("No more memory for a new DPA Classifier table entry.");
 			errno = -ENOMEM;
@@ -1698,8 +1683,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	return errno;
 
 table_insert_entry_indexed_error:
-	if (shadow_entry)
-		xx_free(shadow_entry);
+	kfree(shadow_entry);
 
 	return errno;
 }
@@ -1905,8 +1889,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	/* If shadow table exists, add the entry to it */
 	if (cls_table->shadow_table) {
-		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
-			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
+		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
 			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
@@ -1938,8 +1921,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	return errno;
 
 table_insert_entry_exact_match_error:
-	if (shadow_entry)
-		xx_free(shadow_entry);
+	kfree(shadow_entry);
 
 	return errno;
 }
@@ -2052,8 +2034,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 	/* If shadow tables exist, add the entry to them */
 	if (cls_table->shadow_table) {
-		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
-			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
+		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
 			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
@@ -2083,8 +2064,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	return errno;
 
 table_insert_entry_hash_error:
-	if (shadow_entry)
-		xx_free(shadow_entry);
+	kfree(shadow_entry);
 
 	return errno;
 }
@@ -2190,8 +2170,8 @@ static int extend_table_array(void)
 
 	new_table_size += DPA_CLS_TBL_ARRAYSIZEGRANULARITY;
 
-	new_table_array = (struct dpa_cls_table **)
-		xx_zalloc(new_table_size * sizeof(struct dpa_cls_table *));
+	new_table_array = kzalloc(new_table_size * sizeof(*new_table_array),
+				  GFP_KERNEL);
 	if (!new_table_array) {
 		pr_err("No more memory for DPA Classifier table management.");
 		return -ENOMEM;
@@ -2233,7 +2213,7 @@ static inline void put_table_descriptor(int td)
 {
 	if (table[td] != NULL) {
 		if (--table_entries_in_use == 0) {
-			xx_free(table);
+			kfree(table);
 			table = NULL;
 			num_tables = 0;
 		} else
-- 
1.7.5.4

