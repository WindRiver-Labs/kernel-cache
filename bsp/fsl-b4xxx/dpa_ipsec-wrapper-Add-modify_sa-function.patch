From 1a165b910a3fb23211a4ab27d22a392c075cbe1f Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Mon, 18 Feb 2013 20:50:47 +0000
Subject: [PATCH 485/518] dpa_ipsec wrapper: Add modify_sa function

New ioctl for runtime SA modification functionality.
Update wrapper code to call the modify_sa when ioctl is
received.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |   30 +++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |  131 +++++++++++++++++++++
 2 files changed, 161 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index b7956dd..2054da2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -205,6 +205,28 @@ struct ioc_dpa_ipsec_sa_get_stats {
 	struct dpa_ipsec_sa_stats sa_stats;
 };
 
+struct ioc_dpa_ipsec_sa_modify_prm {
+	int sa_id;		/* security association id */
+	struct dpa_ipsec_sa_modify_prm modify_prm;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_dpa_ipsec_sa_modify_prm {
+	enum dpa_ipsec_sa_modify_type type;
+	union {
+		enum dpa_ipsec_arw arw;
+		uint32_t seq;
+		uint64_t ext_seq;
+		struct ioc_compat_sa_crypto_params crypto_params;
+	};
+};
+
+struct ioc_compat_dpa_ipsec_sa_modify_prm {
+	int sa_id;		/* security association id */
+	struct compat_dpa_ipsec_sa_modify_prm modify_prm;
+};
+#endif
+
 #define DPA_IPSEC_IOC_MAGIC	0xee
 
 #define DPA_IPSEC_IOC_INIT \
@@ -269,4 +291,12 @@ struct ioc_dpa_ipsec_sa_get_stats {
 #define DPA_IPSEC_IOC_GET_SA_STATS \
 	_IOWR(DPA_IPSEC_IOC_MAGIC, 11, struct ioc_dpa_ipsec_sa_get_stats)
 
+#define DPA_IPSEC_IOC_SA_MODIFY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 12, struct ioc_dpa_ipsec_sa_modify_prm)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_SA_MODIFY_COMPAT \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 12, \
+	     struct ioc_compat_dpa_ipsec_sa_modify_prm)
+#endif
+
 #endif	/* __DPA_IPSEC_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 1f79719..542b7d2 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -953,6 +953,110 @@ err_pol_cleanup:
 	return err;
 }
 
+/* Set mprm - no compat case */
+static int do_sa_modify_ioctl(unsigned long args, int *sa_id,
+			      struct dpa_ipsec_sa_modify_prm *mprm)
+{
+	struct ioc_dpa_ipsec_sa_modify_prm prm;
+
+	if (copy_from_user(&prm,
+			   (struct ioc_dpa_ipsec_sa_modify_prm *)args,
+			   sizeof(prm))) {
+		pr_err("Could not copy from user modify parameters\n");
+		return -EINVAL;
+	}
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	*sa_id = prm.sa_id;
+
+	if (prm.modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+		struct dpa_ipsec_sa_crypto_params *crypto_prm;
+		crypto_prm = &prm.modify_prm.crypto_params;
+		mprm->crypto_params.cipher_key =
+			kmalloc(crypto_prm->cipher_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.cipher_key) {
+			pr_err("Allocation failed for cipher key\n");
+			return -ENOMEM;
+		}
+
+		mprm->crypto_params.auth_key =
+			kmalloc(crypto_prm->auth_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.auth_key) {
+			pr_err("Allocation failed for authentication key\n");
+			return -ENOMEM;
+		}
+
+		mprm->type = prm.modify_prm.type;
+		memcpy(mprm->crypto_params.cipher_key,
+		       crypto_prm->cipher_key,
+		       crypto_prm->cipher_key_len);
+		memcpy(mprm->crypto_params.auth_key,
+		       crypto_prm->auth_key,
+		       crypto_prm->auth_key_len);
+	} else {
+		memcpy(mprm, &prm.modify_prm, sizeof(prm.modify_prm));
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+/* Set mprm - compat case */
+static int do_sa_modify_ioctl_compat(unsigned long args, int *sa_id,
+				     struct dpa_ipsec_sa_modify_prm *mprm)
+{
+	struct ioc_compat_dpa_ipsec_sa_modify_prm prm;
+
+	if (copy_from_user(&prm,
+			   (struct ioc_compat_dpa_ipsec_sa_modify_prm *)args,
+			   sizeof(prm))) {
+		pr_err("Could not copy from user modify parameters\n");
+		return -EINVAL;
+	}
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	*sa_id = prm.sa_id;
+
+	if (prm.modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+		struct ioc_compat_sa_crypto_params *crypto_prm;
+		crypto_prm = &prm.modify_prm.crypto_params;
+		mprm->crypto_params.cipher_key =
+			kmalloc(crypto_prm->cipher_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.cipher_key) {
+			pr_err("Allocation failed for cipher key\n");
+			return -ENOMEM;
+		}
+
+		mprm->crypto_params.auth_key =
+			kmalloc(crypto_prm->auth_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.auth_key) {
+			pr_err("Allocation failed for authentication key\n");
+			return -ENOMEM;
+		}
+
+		mprm->type = prm.modify_prm.type;
+		memcpy(mprm->crypto_params.cipher_key,
+		       compat_ptr(crypto_prm->cipher_key),
+		       crypto_prm->cipher_key_len);
+		memcpy(mprm->crypto_params.auth_key,
+		       compat_ptr(crypto_prm->auth_key),
+		       crypto_prm->auth_key_len);
+	} else {
+		memcpy(mprm, &prm.modify_prm, sizeof(prm.modify_prm));
+	}
+
+	return 0;
+}
+#endif
+
 int wrp_dpa_ipsec_init(void)
 {
 	/* Cannot initialize the wrapper twice */
@@ -1158,10 +1262,37 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+	case DPA_IPSEC_IOC_SA_MODIFY: {
+		struct dpa_ipsec_sa_modify_prm modify_prm;
+		int sa_id, ret;
+
+#ifdef CONFIG_COMPAT
+		if (compat)
+			ret = do_sa_modify_ioctl_compat(args, &sa_id,
+							&modify_prm);
+		else
+#endif /* CONFIG_COMPAT */
+		ret = do_sa_modify_ioctl(args, &sa_id, &modify_prm);
+
+		if (IS_ERR_VALUE(ret))
+			goto free;
+
+		ret = dpa_ipsec_sa_modify(sa_id, &modify_prm);
+		if (IS_ERR_VALUE(ret))
+			pr_err("Modifying SA %d failed\n", sa_id);
+free:
+		if (modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+			kfree(modify_prm.crypto_params.cipher_key);
+			kfree(modify_prm.crypto_params.auth_key);
+		}
+
+		break;
+	}
 	default:
 		pr_err("Invalid DPA IPsec ioctl\n");
 		break;
 	}
+
 	return ret;
 }
 
-- 
1.7.5.4

