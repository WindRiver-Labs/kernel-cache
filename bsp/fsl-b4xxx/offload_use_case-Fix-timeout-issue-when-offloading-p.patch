From c8572bac49530427fef5778ed9b3ff71d2f1f31e Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Thu, 27 Sep 2012 21:22:55 +0000
Subject: [PATCH 330/518] offload_use_case: Fix timeout issue when offloading
 policies and security associations

This patch fixes the timeout issue when offloading policies and SAs
through XFRM policy walk mechanism, introducing a delay for each scheduled
work.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   23 +++++++++++++-------
 1 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index cca654d..9b1c66e 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -52,7 +52,9 @@
 #define DPA_IPSEC_ADDR_T_IPv6 6
 #define GTP_PORT 0x0868
 
-DEFINE_SPINLOCK(xfrm_lock);
+
+struct workqueue_struct *xfrm_wq;
+
 
 static const u32 jhash_initval = 0xdeadbeef;
 /* offloaded SA hash entry */
@@ -96,7 +98,7 @@ static struct xfrm_km_uparms usr_params;
 struct work_arg {
 	struct xfrm_state *x;
 	struct xfrm_policy_walk walk;
-	struct work_struct work;
+	struct delayed_work work;
 	int from_pol;
 };
 static void work_func(struct work_struct *work);
@@ -348,8 +350,9 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 			return -ENOMEM;
 		}
 		work->x = x;
-		INIT_WORK(&work->work, work_func);
-		schedule_work_on(offld_work_cpu, &work->work);
+		INIT_DELAYED_WORK(&work->work, work_func);
+		schedule_delayed_work_on(offld_work_cpu, &work->work,
+					HZ);
 		break;
 
 	case XFRM_MSG_FLUSHSA:
@@ -417,7 +420,8 @@ remove_sa:
 */
 static void work_func(struct work_struct *work)
 {
-	struct work_arg *this_work = container_of(work, struct work_arg, work);
+	struct work_arg *this_work = container_of((struct delayed_work *)work,
+						struct work_arg, work);
 	xfrm_policy_walk_init(&this_work->walk, XFRM_POLICY_TYPE_ANY);
 	xfrm_policy_walk(&init_net, &this_work->walk, policy_walk_func,
 			 this_work);
@@ -678,7 +682,6 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 		err = offload_sa(dpa_ipsec_id, &sa_params, x,
 				def_sa_fqid, usr_params.pol_miss_fqid,
 				dir, &sa_id);
-
 		if (err < 0) {
 			pr_err("%s(%d) : Error offloading out SA SPI %d (%d)\n",
 			       __func__, __LINE__, x->id.spi, err);
@@ -763,8 +766,9 @@ static int xfrm_km_policy_notify(struct xfrm_policy *x, int dir,
 			}
 			work->x = state;
 			work->from_pol = 1;
-			INIT_WORK(&work->work, work_func);
-			schedule_work_on(offld_work_cpu, &work->work);
+			INIT_DELAYED_WORK(&work->work, work_func);
+			schedule_delayed_work_on(offld_work_cpu, &work->work,
+						HZ);
 		}
 
 		break;
@@ -826,6 +830,8 @@ int init_xfrm_km(struct xfrm_km_uparms *params)
 	if (core != -1)
 		offld_work_cpu = core;
 
+	xfrm_wq = create_singlethread_workqueue("xfrm_wq");
+
 	xfrm_km_initialized = 1;
 	return err;
 }
@@ -844,6 +850,7 @@ void cleanup_xfrm_km(void)
 	if (!xfrm_km_initialized)
 		return;
 
+	destroy_workqueue(xfrm_wq);
 	key.byte = key_data;
 	key.mask = NULL;
 	for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
-- 
1.7.5.4

