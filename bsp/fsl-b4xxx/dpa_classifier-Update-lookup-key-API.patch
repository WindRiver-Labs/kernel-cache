From ddffe20ef06f726f3809398d52e865367c510ac5 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:59:06 +0000
Subject: [PATCH 245/518] dpa_classifier: Update lookup key API

The DPA Classifier lookup key description requires the user to enter
always the KEY as well as the MASK. The FMan low level driver however,
offers also the option to create tables with entries without mask,
thus saving MURAM.

The lookup key API was updated in order to support the definition of
keys w/o mask.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  295 +++++--
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |   31 +-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   97 ++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  888 ++++++++++++--------
 include/linux/fsl_dpa_classifier.h                 |   47 +-
 include/linux/fsl_dpa_offload.h                    |   25 +
 6 files changed, 878 insertions(+), 505 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 0e38b83..ffb6019 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -381,10 +381,10 @@ int dpa_classif_table_modify_miss_action(int			td,
 EXPORT_SYMBOL(dpa_classif_table_modify_miss_action);
 
 int dpa_classif_table_insert_entry(int				td,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action *action,
-				int				priority,
-				int				*entry_id)
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					priority,
+			int					*entry_id)
 {
 	int err = 0;
 	struct dpa_cls_table *ptable;
@@ -393,6 +393,9 @@ int dpa_classif_table_insert_entry(int				td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	/*
@@ -443,7 +446,7 @@ int dpa_classif_table_insert_entry(int				td,
 EXPORT_SYMBOL(dpa_classif_table_insert_entry);
 
 int dpa_classif_table_modify_entry_by_key(int			td,
-		const struct dpa_cls_tbl_key			*key,
+		const struct dpa_offload_lookup_key		*key,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
 	int entry_id;
@@ -453,6 +456,9 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
 	/* Check for unsupported modifications */
@@ -484,12 +490,12 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct dpa_cls_tbl_action *action;
-	struct dpa_cls_tbl_key *key;
+	struct dpa_offload_lookup_key *key;
 	t_FmPcdCcNextEngineParams next_engine_params;
 	t_FmPcdCcKeyParams key_params;
-	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-	uint8_t masked_key[DPA_CLS_TBL_MAXENTRYKEYSIZE];
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t masked_key[DPA_OFFLD_MAXENTRYKEYSIZE];
 	uint8_t entry_index, shadow_table_index;
 	unsigned int cc_node_index, key_size;
 	int errno;
@@ -545,23 +551,38 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		break;
 	case DPA_CLS_TBL_MODIFY_KEY:
 		/* Only exact match tables support this type of modification. */
+
+		if (mod_params->key->size !=
+			ptable->params.exact_match_params.key_size) {
+			pr_err("ERROR: %s, %s (%d): New key size (%d) doesn't "
+				"match the table key size (%d).\n", __FILE__,
+				__func__, __LINE__, mod_params->key->size,
+				ptable->params.exact_match_params.key_size);
+			return -EINVAL;
+		}
+
 		/*
 		 * Have to copy the data from the key and mask because the FMD
 		 * is not using const pointers and we cannot provide it the
 		 * const pointers that the user provided.
 		 */
+		memset(&key_params, 0, sizeof(key_params));
 		memcpy(key_data,
 			mod_params->key->byte,
-			ptable->params.exact_match_params.key_size);
-		memcpy(mask_data,
-			mod_params->key->mask,
-			ptable->params.exact_match_params.key_size);
+			mod_params->key->size);
+		key_params.p_Key = key_data;
+		if (mod_params->key->mask) {
+			memcpy(mask_data,
+				mod_params->key->mask,
+				mod_params->key->size);
+			key_params.p_Mask = mask_data;
+		}
 
 		err = FM_PCD_MatchTableModifyKey(cc_node,
 				entry_index,
 				ptable->params.exact_match_params.key_size,
-				key_data,
-				mask_data);
+				key_params.p_Key,
+				key_params.p_Mask);
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): "
 				"FM_PCD_MatchTableModifyKey failed.\n",
@@ -574,6 +595,16 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		break;
 	case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
 		/* Only exact match tables support this type of modification. */
+
+		if (mod_params->key->size !=
+			ptable->params.exact_match_params.key_size) {
+			pr_err("ERROR: %s, %s (%d): New key size (%d) doesn't "
+				"match the table key size (%d).\n", __FILE__,
+				__func__, __LINE__, mod_params->key->size,
+				ptable->params.exact_match_params.key_size);
+			return -EINVAL;
+		}
+
 		errno = action_to_next_engine_params(mod_params->action,
 						&key_params.ccNextEngineParams);
 		if (errno < 0)
@@ -584,15 +615,17 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		 * is not using const pointers and we cannot provide it the
 		 * const pointers that the user provided.
 		 */
+		memset(&key_params, 0, sizeof(key_params));
 		memcpy(key_data,
 			mod_params->key->byte,
-			ptable->params.exact_match_params.key_size);
-		memcpy(mask_data,
-			mod_params->key->mask,
-			ptable->params.exact_match_params.key_size);
-
-		key_params.p_Key	= key_data;
-		key_params.p_Mask	= mask_data;
+			mod_params->key->size);
+		key_params.p_Key = key_data;
+		if (mod_params->key->mask) {
+			memcpy(mask_data,
+				mod_params->key->mask,
+				mod_params->key->size);
+			key_params.p_Mask = mask_data;
+		}
 
 		err = FM_PCD_MatchTableModifyKeyAndNextEngine(cc_node,
 				entry_index,
@@ -643,8 +676,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				 */
 			key_size = ptable->params.exact_match_params.key_size;
 				key_apply_mask(mod_params->key,
-						masked_key,
-						key_size);
+						masked_key);
 				shadow_table_index = crc8(masked_key, key_size);
 
 				new_bucket_list =
@@ -656,10 +688,16 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		}
 
 		if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
-			(mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION))
+			(mod_params->type ==
+				DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) {
 			memcpy(key->byte,
 				mod_params->key->byte,
-				ptable->params.exact_match_params.key_size);
+				key->size);
+			if (key->mask)
+				memcpy(key->mask,
+					mod_params->key->mask,
+					key->size);
+		}
 
 		if ((mod_params->type == DPA_CLS_TBL_MODIFY_ACTION) ||
 			(mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION))
@@ -673,7 +711,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_ref);
 
 int dpa_classif_table_delete_entry_by_key(int				td,
-					const struct dpa_cls_tbl_key	*key)
+				const struct dpa_offload_lookup_key	*key)
 {
 	int entry_id;
 
@@ -681,6 +719,9 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 			table_array.object[td], key);
@@ -805,6 +846,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 
 			list_del(&shadow_entry->list_node);
 
+			kfree(shadow_entry->key.byte);
+			kfree(shadow_entry->key.mask);
 			kfree(shadow_entry);
 		}
 
@@ -815,8 +858,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 EXPORT_SYMBOL(dpa_classif_table_delete_entry_by_ref);
 
 int dpa_classif_table_lookup_by_key(int				td,
-				const struct dpa_cls_tbl_key	*key,
-				struct dpa_cls_tbl_action	*action)
+			const struct dpa_offload_lookup_key	*key,
+			struct dpa_cls_tbl_action		*action)
 {
 	struct list_head *pos;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
@@ -827,6 +870,9 @@ int dpa_classif_table_lookup_by_key(int				td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	ptable = (struct dpa_cls_table *) table_array.object[td];
@@ -990,6 +1036,8 @@ int dpa_classif_table_flush(int td)
 
 				list_del(&shadow_entry->list_node);
 
+				kfree(shadow_entry->key.byte);
+				kfree(shadow_entry->key.mask);
 				kfree(shadow_entry);
 			}
 
@@ -1013,7 +1061,7 @@ int dpa_classif_table_flush(int td)
 
 			int_cc_node->used--;
 			index_entry->valid = 0;
-			tmp	= list_current;
+			tmp		= list_current;
 			list_current	= list_current->prev;
 			list_del(tmp);
 		}
@@ -1024,9 +1072,9 @@ int dpa_classif_table_flush(int td)
 EXPORT_SYMBOL(dpa_classif_table_flush);
 
 int dpa_classif_table_get_entry_stats_by_key(int			td,
-					const struct dpa_cls_tbl_key	*key,
-					struct dpa_cls_tbl_entry_stats	*stats,
-					int				reset)
+				const struct dpa_offload_lookup_key	*key,
+				struct dpa_cls_tbl_entry_stats		*stats,
+				int					reset)
 {
 	int entry_id;
 
@@ -1034,6 +1082,9 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
@@ -1101,7 +1152,7 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_ref);
 
 int dpa_classif_table_reset_entry_stats_by_key(int			td,
-					const struct dpa_cls_tbl_key	*key)
+				const struct dpa_offload_lookup_key	*key)
 {
 	int entry_id;
 
@@ -1109,6 +1160,9 @@ int dpa_classif_table_reset_entry_stats_by_key(int			td,
 		(td < table_array.num_descriptors)), "td", -EINVAL);
 	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
+	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
+	xx_sanity_check_return_value(((key->size > 0) &&
+		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 					table_array.object[td], key);
@@ -1482,18 +1536,20 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 }
 
 static struct list_head *find_shadow_entry(const struct dpa_cls_table
-				*cls_table, const struct dpa_cls_tbl_key *key)
+			*cls_table, const struct dpa_offload_lookup_key *key)
 {
-	uint8_t shadow_table_index, key_size;
+	uint8_t shadow_table_index;
 	struct dpa_cls_tbl_shadow_entry *entry;
 	bool found = false;
 	struct list_head *pos, *bucket_list;
-	unsigned int i;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
-	uint8_t masked_key[DPA_CLS_TBL_MAXENTRYKEYSIZE];
+	uint8_t masked_key[DPA_OFFLD_MAXENTRYKEYSIZE];
 
 	BUG_ON(!cls_table);
 	BUG_ON(!key);
+	BUG_ON(!key->byte);
+	BUG_ON((key->size <= 0) ||
+		(key->size > DPA_OFFLD_MAXENTRYKEYSIZE));
 	BUG_ON(!cls_table->shadow_table);
 
 	shadow_table = cls_table->shadow_table;
@@ -1503,14 +1559,8 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 		else
 			return shadow_table->shadow_entry[key->byte[0]].next;
 	} else {
-		if (cls_table->params.type == DPA_CLS_TBL_HASH)
-			key_size = cls_table->params.hash_params.key_size;
-		else
-			key_size =
-				cls_table->params.exact_match_params.key_size;
-
-		key_apply_mask(key, masked_key, key_size);
-		shadow_table_index = crc8(masked_key, key_size);
+		key_apply_mask(key, masked_key);
+		shadow_table_index = crc8(masked_key, key->size);
 
 		bucket_list =
 			&shadow_table->shadow_entry[shadow_table_index];
@@ -1525,14 +1575,21 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 	list_for_each(pos, bucket_list) {
 		entry = list_entry(pos, struct dpa_cls_tbl_shadow_entry,
 				list_node);
-		found = true;
+		found = false;
+
+		if (entry->key.size != key->size)
+			break;
+
 		/* Verify if the key and mask are identical */
-		for (i = 0; i < DPA_CLS_TBL_MAXENTRYKEYSIZE; i++) {
-			if ((entry->key.byte[i] != key->byte[i]) ||
-					(entry->key.mask[i] != key->mask[i])) {
-				found = false;
-				break;
-			}
+		if (memcmp(entry->key.byte, key->byte, key->size) == 0) {
+			if (entry->key.mask) {
+				if ((key->mask) &&
+					(memcmp(entry->key.mask, key->mask,
+							key->size) == 0))
+					found = true;
+			} else
+				if (!key->mask)
+					found = true;
 		}
 
 		if (found)
@@ -1547,9 +1604,9 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 }
 
 static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action	*action,
-				int				*entry_id)
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					*entry_id)
 {
 	t_Error err;
 	int errno = 0;
@@ -1562,6 +1619,12 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	BUG_ON(!action);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
 
+	if (key->size != 1) {
+		pr_err("ERROR: %s, %s (%d): Bad key format for index table. "
+			"Key size must be 1.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
 	/* Check the index management array if the entry is already used */
 	if (cls_table->entry[key->byte[0]].valid)
 		return -EEXIST;
@@ -1626,10 +1689,10 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 }
 
 static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action	*action,
-				int				priority,
-				int				*entry_id)
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					priority,
+			int					*entry_id)
 {
 	t_Error err;
 	int errno = 0;
@@ -1637,8 +1700,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	t_FmPcdCcKeyParams key_params;
 	int i = 0, k;
 	uint8_t shadow_table_index;
-	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 	struct dpa_cls_tbl_entry *index_entry;
 	struct list_head *list_current;
@@ -1648,6 +1711,14 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	BUG_ON(!action);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
 
+	if (key->size != cls_table->params.exact_match_params.key_size) {
+		pr_err("ERROR: %s, %s (%d): Key size (%d) doesn't match table "
+			"key size (%d).\n", __FILE__, __func__, __LINE__,
+			key->size,
+			cls_table->params.exact_match_params.key_size);
+		return -EINVAL;
+	}
+
 	memset(&key_params, 0, sizeof(t_FmPcdCcKeyParams));
 
 	/*
@@ -1655,12 +1726,12 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	 * using const pointers and we cannot provide it the const pointers that
 	 * the user provided.
 	 */
-	memcpy(key_data, key->byte,
-		cls_table->params.exact_match_params.key_size);
-	memcpy(mask_data, key->mask,
-		cls_table->params.exact_match_params.key_size);
-	key_params.p_Key	= key_data;
-	key_params.p_Mask	= mask_data;
+	memcpy(key_data, key->byte, key->size);
+	key_params.p_Key = key_data;
+	if (key->mask) {
+		memcpy(mask_data, key->mask, key->size);
+		key_params.p_Mask = mask_data;
+	}
 
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams);
@@ -1779,16 +1850,36 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 		memcpy(&shadow_entry->action, action,
 			sizeof(struct dpa_cls_tbl_action));
-		memcpy(&shadow_entry->key, key,
-			sizeof(struct dpa_cls_tbl_key));
+		shadow_entry->key.byte = kzalloc(key->size, GFP_KERNEL);
+		if (!shadow_entry->key.byte) {
+			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
+				"new DPA Classifier shadow table entry.\n",
+				__FILE__, __func__, __LINE__);
+			kfree(shadow_entry);
+			return -ENOMEM;
+		}
+		memcpy(shadow_entry->key.byte, key->byte, key->size);
+		if (key->mask) {
+			shadow_entry->key.mask = kzalloc(key->size, GFP_KERNEL);
+			if (!shadow_entry->key.mask) {
+				pr_err("ERROR: %s, %s (%d): No more RAM to "
+					"add a new DPA Classifier shadow table "
+					"entry.\n",
+					__FILE__, __func__, __LINE__);
+				kfree(shadow_entry->key.byte);
+				kfree(shadow_entry);
+				return -ENOMEM;
+			}
+			memcpy(shadow_entry->key.mask, key->mask, key->size);
+		}
+		shadow_entry->key.size = key->size;
 
 		/* Connect index management entry with the shadow table entry */
 		shadow_entry->entry_id = k;
 		cls_table->entry[k].shadow_entry = &shadow_entry->list_node;
 
 		/* Add entry to the proper shadow table. */
-		key_apply_mask(key, key_data,
-			cls_table->params.exact_match_params.key_size);
+		key_apply_mask(key, key_data);
 		shadow_table_index = crc8(key_data,
 				cls_table->params.exact_match_params.key_size);
 		shadow_table = cls_table->shadow_table;
@@ -1803,9 +1894,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 }
 
 static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
-			const struct dpa_cls_tbl_key		*key,
-			const struct dpa_cls_tbl_action		*action,
-			int					*entry_id)
+		const struct dpa_offload_lookup_key		*key,
+		const struct dpa_cls_tbl_action			*action,
+		int						*entry_id)
 {
 	t_Error err;
 	int errno = 0;
@@ -1813,7 +1904,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	t_FmPcdCcKeyParams key_params;
 	uint8_t shadow_table_index;
 	uint64_t hash_set_index;
-	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	int j;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 	struct list_head *list_current;
@@ -1824,15 +1915,29 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	BUG_ON(!action);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
 
+	if (key->size != cls_table->params.hash_params.key_size) {
+		pr_err("ERROR: %s, %s (%d): Key size (%d) doesn't match table "
+			"key size (%d).\n", __FILE__, __func__, __LINE__,
+			key->size,
+			cls_table->params.hash_params.key_size);
+		return -EINVAL;
+	}
+
+	if (key->mask) {
+		pr_err("ERROR: %s, %s (%d): Key masks are not supported by "
+			"HASH tables.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
 	memset(&key_params, 0, sizeof(t_FmPcdCcKeyParams));
 
 	/*
-	 * Have to copy the data from the key and mask because the FMD is not
+	 * Have to copy the data from the key because the FMD is not
 	 * using const pointers and we cannot provide it the const pointers that
 	 * the user provided.
 	 */
-	memcpy(key_data, key->byte, cls_table->params.hash_params.key_size);
-	key_params.p_Key	= key_data;
+	memcpy(key_data, key->byte, key->size);
+	key_params.p_Key = key_data;
 
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams);
@@ -1921,8 +2026,16 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 		memcpy(&shadow_entry->action, action,
 			sizeof(struct dpa_cls_tbl_action));
-		memcpy(&shadow_entry->key, key,
-			sizeof(struct dpa_cls_tbl_key));
+		shadow_entry->key.byte = kzalloc(key->size, GFP_KERNEL);
+		if (!shadow_entry->key.byte) {
+			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
+				"new DPA Classifier shadow table entry.\n",
+				__FILE__, __func__, __LINE__);
+			kfree(shadow_entry);
+			return -ENOMEM;
+		}
+		memcpy(shadow_entry->key.byte, key->byte, key->size);
+		shadow_entry->key.size = key->size;
 
 		/* Connect index management entry with the shadow table entry */
 		shadow_entry->entry_id = j;
@@ -2055,7 +2168,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 }
 
 static int key_to_entry_id(const struct dpa_cls_table *cls_table,
-	const struct dpa_cls_tbl_key *key)
+	const struct dpa_offload_lookup_key *key)
 {
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct list_head *shadow_list_entry;
@@ -2171,14 +2284,22 @@ static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
 	}
 }
 
-static inline void key_apply_mask(const struct dpa_cls_tbl_key	*key,
-				uint8_t				*new_key,
-				unsigned int			key_size)
+static inline void key_apply_mask(const struct dpa_offload_lookup_key *key,
+	uint8_t *new_key)
 {
 	int i;
 
-	memset(new_key, 0, key_size);
-	for (i = 0; i < key_size; i++)
+	BUG_ON(!new_key);
+	BUG_ON(!key);
+	BUG_ON(!key->byte);
+
+	if (key->mask == NULL) {
+		memcpy(new_key, key->byte, key->size);
+		return;
+	}
+
+	memset(new_key, 0, key->size);
+	for (i = 0; i < key->size; i++)
 		new_key[i] = key->byte[i] & key->mask[i];
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index f037a37..4d465a1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -103,7 +103,7 @@ struct dpa_cls_tbl_entry {
  */
 struct dpa_cls_tbl_shadow_entry {
 
-	struct dpa_cls_tbl_key		key;		/* Lookup key info */
+	struct dpa_offload_lookup_key	key;		/* Lookup key info */
 	struct dpa_cls_tbl_action	action;		/* Action info */
 	int				entry_id;	/* Id of this entry
 							 * (helps find
@@ -294,26 +294,26 @@ static int	verify_table_params(const struct dpa_cls_tbl_params *params);
  * identified by its lookup key.
  */
 static struct list_head *find_shadow_entry(const struct dpa_cls_table
-				*cls_table, const struct dpa_cls_tbl_key *key);
+			*cls_table, const struct dpa_offload_lookup_key *key);
 
 /* Add a new entry in an indexed table. */
 static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action	*action,
-				int				*entry_id);
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					*entry_id);
 
 /* Add a new entry in an exact match table. */
 static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action	*action,
-				int				priority,
-				int				*entry_id);
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					priority,
+			int					*entry_id);
 
 /* Add a new entry in a hash table. */
 static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action	*action,
-				int				*entry_id);
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					*entry_id);
 
 /*
  * Translates action parameters into next engine
@@ -327,7 +327,7 @@ static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
  * by key. This works only on tables managed by key.
  */
 static int	key_to_entry_id(const struct dpa_cls_table *cls_table,
-	const struct dpa_cls_tbl_key *key);
+	const struct dpa_offload_lookup_key *key);
 
 /*
  * Extends with one more step an existing descriptor table. The array is
@@ -363,9 +363,8 @@ static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
  * Applies the key mask on the key and provides the updated key
  * in a new buffer.
  */
-static inline void key_apply_mask(const struct dpa_cls_tbl_key	*key,
-				uint8_t				*new_key,
-				unsigned int			key_size);
+static inline void key_apply_mask(const struct dpa_offload_lookup_key *key,
+	uint8_t *new_key);
 
 #endif /*__DPA_CLASSIFIER_C */
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index e02b3a6..8bb2630 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -58,7 +58,7 @@ struct ioc_dpa_cls_tbl_miss_action {
 
 struct ioc_dpa_cls_tbl_entry_params {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key key;
 	struct dpa_cls_tbl_action action;
 	int priority;
 	int entry_id;
@@ -66,7 +66,7 @@ struct ioc_dpa_cls_tbl_entry_params {
 
 struct ioc_dpa_cls_tbl_entry_mod_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key key;
 	struct dpa_cls_tbl_entry_mod_params mod_params;
 };
 
@@ -78,7 +78,7 @@ struct ioc_dpa_cls_tbl_entry_mod_by_ref {
 
 struct ioc_dpa_cls_tbl_entry_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key key;
 };
 
 struct ioc_dpa_cls_tbl_entry_by_ref {
@@ -88,7 +88,7 @@ struct ioc_dpa_cls_tbl_entry_by_ref {
 
 struct ioc_dpa_cls_tbl_lookup_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key key;
 	struct dpa_cls_tbl_action action;
 };
 
@@ -100,7 +100,7 @@ struct ioc_dpa_cls_tbl_lookup_by_ref {
 
 struct ioc_dpa_cls_tbl_entry_stats_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key key;
 	struct dpa_cls_tbl_entry_stats stats;
 	int reset;
 };
@@ -201,9 +201,27 @@ struct compat_ioc_dpa_cls_tbl_miss_action {
 	struct dpa_cls_compat_tbl_action miss_action;
 };
 
+struct compat_ioc_dpa_offld_lookup_key {
+	compat_uptr_t byte;
+	compat_uptr_t mask;
+	uint8_t size;
+};
+
+struct compat_ioc_dpa_cls_tbl_entry_by_key {
+	int td;
+	struct compat_ioc_dpa_offld_lookup_key key;
+};
+
+struct compat_ioc_dpa_cls_tbl_entry_stats_by_key {
+	int td;
+	struct compat_ioc_dpa_offld_lookup_key key;
+	struct dpa_cls_tbl_entry_stats stats;
+	int reset;
+};
+
 struct compat_ioc_dpa_cls_tbl_entry_params {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct compat_ioc_dpa_offld_lookup_key key;
 	struct dpa_cls_compat_tbl_action action;
 	int priority;
 	int entry_id;
@@ -217,7 +235,7 @@ struct dpa_cls_compat_tbl_entry_mod_params {
 
 struct compat_ioc_dpa_cls_tbl_entry_mod_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct compat_ioc_dpa_offld_lookup_key key;
 	struct dpa_cls_compat_tbl_entry_mod_params mod_params;
 };
 
@@ -229,7 +247,7 @@ struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref {
 
 struct compat_ioc_dpa_cls_tbl_lookup_by_key {
 	int td;
-	struct dpa_cls_tbl_key key;
+	struct compat_ioc_dpa_offld_lookup_key key;
 	struct dpa_cls_compat_tbl_action action;
 };
 
@@ -240,46 +258,58 @@ struct compat_ioc_dpa_cls_tbl_lookup_by_ref {
 };
 
 
-void dpa_cls_tbl_entry_params_compatcpy(
-		struct ioc_dpa_cls_tbl_entry_params *kparam,
-		const struct compat_ioc_dpa_cls_tbl_entry_params *uparam);
+int dpa_cls_tbl_entry_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_params			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_params	*uparam);
 
-void dpa_cls_tbl_params_compatcpy(
+int dpa_cls_tbl_params_compatcpy(
 		struct ioc_dpa_cls_tbl_params *kparam,
 		const struct compat_ioc_dpa_cls_tbl_params *uparam);
 
-void dpa_cls_tbl_miss_action_params_compatcpy(
+int dpa_cls_tbl_miss_action_params_compatcpy(
 		struct ioc_dpa_cls_tbl_miss_action *kparam,
 		const struct compat_ioc_dpa_cls_tbl_miss_action *uparam);
 
-void dpa_cls_tbl_action_params_compatcpy(
+int dpa_cls_tbl_action_params_compatcpy(
 		struct dpa_cls_tbl_action *kparam,
 		const struct dpa_cls_compat_tbl_action *uparam);
 
-void dpa_cls_tbl_action_params_rcompatcpy(
+int dpa_cls_tbl_action_params_rcompatcpy(
 		struct dpa_cls_compat_tbl_action *uparam,
 		const struct dpa_cls_tbl_action *kparam);
 
-void dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
-		struct ioc_dpa_cls_tbl_entry_mod_by_key *kparam,
-		const struct compat_ioc_dpa_cls_tbl_entry_mod_by_key *uparam);
+int dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_mod_by_key			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_mod_by_key	*uparam);
 
-void dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
+int dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
 		struct ioc_dpa_cls_tbl_entry_mod_by_ref *kparam,
 		const struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref *uparam);
 
-void dpa_cls_tbl_entry_mod_params_compatcpy(
+int dpa_cls_tbl_entry_mod_params_compatcpy(
 		struct dpa_cls_tbl_entry_mod_params *kparam,
 		const struct dpa_cls_compat_tbl_entry_mod_params *uparam);
 
-void dpa_cls_tbl_lookup_by_key_params_compatcpy(
+int dpa_cls_tbl_entry_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_by_key			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_by_key	*uparam);
+
+int dpa_cls_tbl_lookup_by_key_params_compatcpy(
 		struct ioc_dpa_cls_tbl_lookup_by_key *kparam,
 		const struct compat_ioc_dpa_cls_tbl_lookup_by_key *uparam);
 
-void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
+int dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 		struct ioc_dpa_cls_tbl_lookup_by_ref *kparam,
 		const struct compat_ioc_dpa_cls_tbl_lookup_by_ref *uparam);
 
+int dpa_cls_tbl_entry_stats_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_stats_by_key		*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_stats_by_key	*uparam);
+
+int dpa_lookup_key_params_compatcpy(
+		struct dpa_offload_lookup_key			*kparam,
+		const struct compat_ioc_dpa_offld_lookup_key	*uparam);
+
 #endif /* CONFIG_COMPAT */
 
 
@@ -331,9 +361,21 @@ void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 #define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY		\
 	_IOW(DPA_CLS_IOC_MAGIC, 6, struct ioc_dpa_cls_tbl_entry_by_key)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_DELETE_ENTRY_BY_KEY	\
+	_IOW(DPA_CLS_IOC_MAGIC, 6,			\
+		struct compat_ioc_dpa_cls_tbl_entry_by_key)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF		\
 	_IOW(DPA_CLS_IOC_MAGIC, 7, struct ioc_dpa_cls_tbl_entry_by_ref)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_DELETE_ENTRY_BY_REF	\
+	_IOW(DPA_CLS_IOC_MAGIC, 7,			\
+		struct compat_ioc_dpa_cls_tbl_entry_by_ref)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_LOOKUP_BY_KEY			\
 	_IOR(DPA_CLS_IOC_MAGIC, 8, struct ioc_dpa_cls_tbl_lookup_by_key)
 
@@ -356,12 +398,23 @@ void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 #define DPA_CLS_IOC_TBL_GET_STATS_BY_KEY		\
 	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_stats_by_key)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_GET_STATS_BY_KEY		\
+	_IOR(DPA_CLS_IOC_MAGIC, 11,			\
+		struct compat_ioc_dpa_cls_tbl_entry_stats_by_key)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_GET_STATS_BY_REF		\
 	_IOR(DPA_CLS_IOC_MAGIC, 12, struct ioc_dpa_cls_tbl_entry_stats_by_ref)
 
 #define DPA_CLS_IOC_TBL_RESET_STATS_BY_KEY		\
 	_IOR(DPA_CLS_IOC_MAGIC, 13, struct ioc_dpa_cls_tbl_entry_by_key)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_RESET_STATS_BY_KEY	\
+	_IOR(DPA_CLS_IOC_MAGIC, 13, struct compat_ioc_dpa_cls_tbl_entry_by_key)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_RESET_STATS_BY_REF		\
 	_IOR(DPA_CLS_IOC_MAGIC, 14, struct ioc_dpa_cls_tbl_entry_by_ref)
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index c206286..d967887 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -51,23 +51,111 @@
 #endif /* CONFIG_COMPAT */
 
 
+#define COPY_KEY_PARAMS							\
+do {									\
+	if ((kparam.key.size <= 0) ||					\
+			(kparam.key.size > DPA_OFFLD_MAXENTRYKEYSIZE)) { \
+		pr_err("ERROR: %s, %s (%d): Invalid lookup key size "	\
+			"(%d bytes).\n", __FILE__, __func__, __LINE__,	\
+			kparam.key.size);				\
+		return -EINVAL;						\
+	}								\
+									\
+	if (copy_from_user(key_buf, kparam.key.byte,			\
+						kparam.key.size)) {	\
+		pr_err("ERROR: %s, %s (%d): Lookup key.\n", __FILE__,	\
+			__func__, __LINE__);				\
+		return -EBUSY;						\
+	}								\
+	kparam.key.byte = key_buf;					\
+									\
+	if (kparam.key.mask) {						\
+		if (copy_from_user(mask_buf, kparam.key.mask,		\
+						kparam.key.size)) {	\
+			pr_err("ERROR: %s, %s (%d): Read failed: "	\
+				"key mask.\n", __FILE__, __func__,	\
+				__LINE__);				\
+			return -EBUSY;					\
+		}							\
+									\
+		kparam.key.mask = mask_buf;				\
+	}								\
+} while (0)
+
+#define COPY_NEW_KEY_PARAMS						\
+do {									\
+	if (kparam.mod_params.key) {					\
+		if (copy_from_user(&new_key,				\
+				kparam.mod_params.key,			\
+			sizeof(struct dpa_offload_lookup_key))) {	\
+			pr_err("ERROR: %s, %s (%d): Read failed: "	\
+				"new lookup key.\n", __FILE__,		\
+				__func__, __LINE__);			\
+			return -EBUSY;					\
+		}							\
+		kparam.mod_params.key = &new_key;			\
+									\
+		if ((kparam.mod_params.key->size <= 0) ||		\
+			(kparam.mod_params.key->size >			\
+				DPA_OFFLD_MAXENTRYKEYSIZE)) {		\
+			pr_err("ERROR: %s, %s (%d): Invalid new lookup " \
+				"key size (%d bytes).\n", __FILE__,	\
+				__func__, __LINE__,			\
+				kparam.mod_params.key->size);		\
+			return -EINVAL;					\
+		}							\
+									\
+		if (kparam.mod_params.key->byte) {			\
+			if (copy_from_user(new_key_buf,			\
+				kparam.mod_params.key->byte,		\
+				kparam.mod_params.key->size)) {	\
+				pr_err("ERROR: %s, %s (%d): Read "	\
+					"failed: new lookup key data.\n", \
+					__FILE__, __func__, __LINE__);	\
+				return -EBUSY;				\
+			}						\
+			kparam.mod_params.key->byte = new_key_buf;	\
+		}							\
+		if (kparam.mod_params.key->mask) {			\
+			if (copy_from_user(new_mask_buf,		\
+				kparam.mod_params.key->mask,		\
+				kparam.mod_params.key->size)) {		\
+				pr_err("ERROR: %s, %s (%d): Read "	\
+					"failed: new key mask.\n",	\
+					__FILE__, __func__, __LINE__);	\
+				return -EBUSY;				\
+			}						\
+			kparam.mod_params.key->mask = new_mask_buf;	\
+		}							\
+	}								\
+} while (0)
+
 static long do_ioctl_table_create(unsigned long args, bool compat_mode);
 
 static long do_ioctl_table_modify_miss_action(unsigned long	args,
-				bool			compat_mode);
+						bool		compat_mode);
 
 static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode);
 
 static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
-				bool			compat_mode);
+						bool		compat_mode);
 
 static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
-				bool			compat_mode);
+						bool		compat_mode);
 
 static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode);
 
 static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode);
 
+static long do_ioctl_table_delete_entry_by_key(unsigned long	args,
+						bool		compat_mode);
+
+static long do_ioctl_table_get_stats_by_key(unsigned long	args,
+						bool		compat_mode);
+
+static long do_ioctl_table_reset_stats_by_key(unsigned long	args,
+						bool		compat_mode);
+
 static long do_ioctl_set_remove_hm(unsigned long	args,
 				bool			compat_mode);
 
@@ -82,6 +170,8 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode);
 
 static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode);
 
+void *translate_fm_pcd_handle(void *fm_pcd);
+
 static const struct file_operations dpa_classif_fops = {
 	.owner			= THIS_MODULE,
 	.open			= wrp_dpa_classif_open,
@@ -231,24 +321,12 @@ long wrp_dpa_classif_do_ioctl(
 		ret = do_ioctl_table_modify_entry_by_ref(args, compat_mode);
 		break;
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_DELETE_ENTRY_BY_KEY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY:
-	{
-		struct ioc_dpa_cls_tbl_entry_by_key param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
-				"dpa_classif_table_delete_entry_by_key user "
-				"space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_delete_entry_by_key(param.td,
-							    &param.key);
-
+		ret = do_ioctl_table_delete_entry_by_key(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF:
 	{
@@ -287,36 +365,12 @@ long wrp_dpa_classif_do_ioctl(
 		ret = dpa_classif_table_flush((int)args);
 		break;
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_GET_STATS_BY_KEY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_GET_STATS_BY_KEY:
-	{
-		struct ioc_dpa_cls_tbl_entry_stats_by_key param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
-				"dpa_classif_table_get_entry_stats_by_key user "
-				"space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_get_entry_stats_by_key(param.td,
-							       &param.key,
-							       &param.stats,
-							       param.reset);
-		if (ret < 0)
-			return ret;
-
-		/* Return results to user space */
-		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			pr_err("Could not write "
-				"dpa_classif_table_get_entry_stats_by_key "
-				"result");
-			return -EBUSY;
-		}
-
+		ret = do_ioctl_table_get_stats_by_key(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_GET_STATS_BY_REF:
 	{
@@ -349,24 +403,12 @@ long wrp_dpa_classif_do_ioctl(
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_RESET_STATS_BY_KEY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_RESET_STATS_BY_KEY:
-	{
-		struct ioc_dpa_cls_tbl_entry_by_key param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
-				"dpa_classif_table_reset_entry_stats_by_key "
-				"user space args");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_reset_entry_stats_by_key(param.td,
-							    &param.key);
-
+		ret = do_ioctl_table_reset_stats_by_key(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_RESET_STATS_BY_REF:
 	{
@@ -428,33 +470,32 @@ long wrp_dpa_classif_do_ioctl(
 	case DPA_CLS_IOC_COMPAT_SET_INSERT_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_INSERT_HM:
-			ret = do_ioctl_set_insert_hm(args, compat_mode);
-			break;
+		ret = do_ioctl_set_insert_hm(args, compat_mode);
+		break;
 #ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_VLAN_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_VLAN_HM:
-			ret = do_ioctl_set_vlan_hm(args, compat_mode);
-			break;
+		ret = do_ioctl_set_vlan_hm(args, compat_mode);
+		break;
 #ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_NAT_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_NAT_HM:
-			ret = do_ioctl_set_nat_hm(args, compat_mode);
-			break;
+		ret = do_ioctl_set_nat_hm(args, compat_mode);
+		break;
 #ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_UPDATE_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_UPDATE_HM:
-			ret = do_ioctl_set_update_hm(args, compat_mode);
-			break;
+		ret = do_ioctl_set_update_hm(args, compat_mode);
+		break;
 #ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_FWD_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_FWD_HM:
-			ret = do_ioctl_set_fwd_hm(args, compat_mode);
-			break;
-
+		ret = do_ioctl_set_fwd_hm(args, compat_mode);
+		break;
 
 	default:
 		pr_err("ERROR: %s, %s (%d): DPA Classifier ioctl command "
@@ -470,8 +511,6 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_tbl_params kparam;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_tbl_params uparam;
 
@@ -485,7 +524,9 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 		}
 
 		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_params_compatcpy(&kparam, &uparam);
+		ret = dpa_cls_tbl_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
@@ -496,13 +537,10 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 		}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.table_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.table_params.fm_pcd = translate_fm_pcd_handle(kparam.
+							table_params.fm_pcd);
+	if (!kparam.table_params.fm_pcd)
 		return -EINVAL;
-	}
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.table_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	/* Call function */
 	ret = dpa_classif_table_create(&kparam.table_params,
@@ -532,15 +570,11 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	return ret;
 }
 
-static long do_ioctl_set_remove_hm(unsigned long args,
-					bool			compat_mode)
+static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_remove_params kparam;
 	struct dpa_cls_hm_remove_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
-
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
@@ -550,15 +584,10 @@ static long do_ioctl_set_remove_hm(unsigned long args,
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.rm_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.rm_params.fm_pcd = translate_fm_pcd_handle(kparam.rm_params.
+								fm_pcd);
+	if (!kparam.rm_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.rm_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
-
 
 	if (kparam.res.remove_node)
 		p_res = &kparam.res;
@@ -581,14 +610,11 @@ static long do_ioctl_set_remove_hm(unsigned long args,
 	return ret;
 }
 
-static long do_ioctl_set_insert_hm(unsigned long args,
-					bool			compat_mode)
+static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_insert_params kparam;
 	struct dpa_cls_hm_insert_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
@@ -598,14 +624,10 @@ static long do_ioctl_set_insert_hm(unsigned long args,
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.ins_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.ins_params.fm_pcd = translate_fm_pcd_handle(kparam.ins_params.
+								fm_pcd);
+	if (!kparam.ins_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.ins_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	if (kparam.res.insert_node)
 		p_res = &kparam.res;
@@ -628,13 +650,11 @@ static long do_ioctl_set_insert_hm(unsigned long args,
 
 }
 
-static long  do_ioctl_set_vlan_hm(unsigned long args, bool	compat_mode)
+static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_vlan_params kparam;
 	struct dpa_cls_hm_vlan_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
@@ -644,14 +664,10 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool	compat_mode)
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.vlan_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.vlan_params.fm_pcd = translate_fm_pcd_handle(kparam.vlan_params.
+								fm_pcd);
+	if (!kparam.vlan_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.vlan_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	if (kparam.res.vlan_node)
 			p_res = &kparam.res;
@@ -674,13 +690,11 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool	compat_mode)
 
 }
 
-static long do_ioctl_set_nat_hm(unsigned long args, bool	compat_mode)
+static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_nat_params kparam;
 	struct dpa_cls_hm_nat_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
@@ -690,14 +704,10 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool	compat_mode)
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.nat_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.nat_params.fm_pcd = translate_fm_pcd_handle(kparam.nat_params.
+								fm_pcd);
+	if (!kparam.nat_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.nat_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
 		p_res = &kparam.res;
@@ -719,13 +729,11 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool	compat_mode)
 	return ret;
 }
 
-static long do_ioctl_set_update_hm(unsigned long args, bool	compat_mode)
+static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_update_params kparam;
 	struct dpa_cls_hm_update_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
@@ -735,14 +743,10 @@ static long do_ioctl_set_update_hm(unsigned long args, bool	compat_mode)
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.update_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.update_params.fm_pcd = translate_fm_pcd_handle(kparam.
+						update_params.fm_pcd);
+	if (!kparam.update_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.update_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	if (kparam.res.ip_frag_node || kparam.res.update_node)
 		p_res = &kparam.res;
@@ -765,13 +769,11 @@ static long do_ioctl_set_update_hm(unsigned long args, bool	compat_mode)
 	return ret;
 }
 
-static long do_ioctl_set_fwd_hm(unsigned long args, bool	compat_mode)
+static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_fwd_params kparam;
 	struct dpa_cls_hm_fwd_resources *p_res = NULL;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmDev *fm_wrapper_dev;
 
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: dpa_classif_set_fwd_hm"
@@ -780,14 +782,10 @@ static long do_ioctl_set_fwd_hm(unsigned long args, bool	compat_mode)
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned int)kparam.fwd_params.fm_pcd);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+	kparam.fwd_params.fm_pcd = translate_fm_pcd_handle(kparam.fwd_params.
+								fm_pcd);
+	if (!kparam.fwd_params.fm_pcd)
 		return -EINVAL;
-	}
-
-	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	kparam.fwd_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
 	    kparam.res.pppoe_node)
@@ -816,6 +814,7 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 {
 	struct ioc_dpa_cls_tbl_miss_action kparam;
 #ifdef CONFIG_COMPAT
+	long ret = 0;
 	struct compat_ioc_dpa_cls_tbl_miss_action uparam;
 
 	/* Prepare arguments */
@@ -828,8 +827,10 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 		}
 
 		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_miss_action_params_compatcpy(&kparam,
-			&uparam);
+		ret = dpa_cls_tbl_miss_action_params_compatcpy(&kparam,
+								&uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
@@ -844,12 +845,13 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 						&kparam.miss_action);
 }
 
-
 static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_tbl_entry_params kparam;
 	struct dpa_cls_tbl_policer_params policer_params;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_tbl_entry_params uparam;
 
@@ -862,22 +864,16 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 			return -EBUSY;
 		}
 
-		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_entry_params_compatcpy(&kparam, &uparam);
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
 
-		/* Check if we need to copy also the policer params */
-		if ((uparam.action.type == DPA_CLS_TBL_ACTION_ENQ) &&
-			(uparam.action.enq_params.policer_params != 0)) {
-			if (copy_from_user(&policer_params,
-			compat_ptr(uparam.action.enq_params.policer_params),
-				sizeof(policer_params))) {
-				pr_err("Could not read "
-					"dpa_classif_table_insert_entry user "
-					"space args (#2)");
-				return -EBUSY;
-			}
 		kparam.action.enq_params.policer_params = &policer_params;
-		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 	{
@@ -888,6 +884,8 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 			return -EBUSY;
 		}
 
+		COPY_KEY_PARAMS;
+
 		/* Check if we need to copy also the policer params */
 		if ((kparam.action.type == DPA_CLS_TBL_ACTION_ENQ) &&
 				(kparam.action.enq_params.policer_params)) {
@@ -939,12 +937,16 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 					bool			compat_mode)
 {
 	struct ioc_dpa_cls_tbl_entry_mod_by_key kparam;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key new_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_policer_params policer_params;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t new_key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t new_mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
 #ifdef CONFIG_COMPAT
+	long ret = 0;
 	struct compat_ioc_dpa_cls_tbl_entry_mod_by_key uparam;
-	struct dpa_cls_compat_tbl_action compat_action;
 
 	/* Prepare arguments */
 	if (compat_mode) {
@@ -955,57 +957,23 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			return -EBUSY;
 		}
 
-		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_entry_mod_by_key_params_compatcpy(&kparam,
-			&uparam);
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
 
-		/* Check if we need to copy the new key and action */
-		if (uparam.mod_params.key) {
-			if (copy_from_user(&key,
-				compat_ptr(uparam.mod_params.key),
-				sizeof(struct dpa_cls_tbl_key))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_key "
-					"user space args (#2)");
-				return -EBUSY;
-			}
-			kparam.mod_params.key = &key;
-		}
-
-		if (uparam.mod_params.action) {
-			if (copy_from_user(&compat_action,
-				compat_ptr(uparam.mod_params.action),
-				sizeof(struct dpa_cls_compat_tbl_action))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_key "
-					"user space args (#3)");
-				return -EBUSY;
-			}
+		new_key.byte = new_key_buf;
+		new_key.mask = new_mask_buf;
+		new_key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
 
-			dpa_cls_tbl_action_params_compatcpy(&action,
-				&compat_action);
+		kparam.mod_params.key = &new_key;
 
-			kparam.mod_params.action = &action;
+		kparam.mod_params.action = &action;
 
-			/* Check if we need to copy policer params */
-			if ((compat_action.type ==
-				DPA_CLS_TBL_ACTION_ENQ) &&
-				(compat_action.enq_params.
-					policer_params)) {
-				if (copy_from_user(&policer_params,
-					compat_ptr(compat_action.
-					enq_params.policer_params),
-					sizeof(policer_params))) {
-					pr_err("Could not read "
-				"dpa_classif_table_modify_entry_by_key user "
-				"space args (#4)");
-					return -EBUSY;
-				}
-				kparam.mod_params.action->enq_params.
-					policer_params =
-					&policer_params;
-			}
-		}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_mod_by_key_params_compatcpy(&kparam,
+								&uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 	{
@@ -1016,18 +984,10 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			return -EBUSY;
 		}
 
-		/* Check if we need to copy the new key and action */
-		if (kparam.mod_params.key) {
-			if (copy_from_user(&key,
-				kparam.mod_params.key,
-				sizeof(struct dpa_cls_tbl_key))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_key "
-					"user space args (#2)");
-				return -EBUSY;
-			}
-			kparam.mod_params.key = &key;
-		}
+		COPY_KEY_PARAMS;
+
+		/* Check if we need to copy the new key */
+		COPY_NEW_KEY_PARAMS;
 
 		if (kparam.mod_params.action) {
 			if (copy_from_user(&action,
@@ -1073,12 +1033,14 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 					bool			compat_mode)
 {
 	struct ioc_dpa_cls_tbl_entry_mod_by_ref kparam;
-	struct dpa_cls_tbl_key key;
+	struct dpa_offload_lookup_key new_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_policer_params policer_params;
+	uint8_t new_key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t new_mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
 #ifdef CONFIG_COMPAT
+	long ret = 0;
 	struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref uparam;
-	struct dpa_cls_compat_tbl_action compat_action;
 
 	/* Prepare arguments */
 	if (compat_mode) {
@@ -1089,57 +1051,17 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			return -EBUSY;
 		}
 
-		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(&kparam,
-			&uparam);
+		new_key.byte = new_key_buf;
+		new_key.mask = new_mask_buf;
+		new_key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
 
-		/* Check if we need to copy the new key and action */
-		if (uparam.mod_params.key) {
-			if (copy_from_user(&key,
-				compat_ptr(uparam.mod_params.key),
-				sizeof(struct dpa_cls_tbl_key))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_ref "
-					"user space args (#2)");
-				return -EBUSY;
-			}
-			kparam.mod_params.key = &key;
-		}
+		kparam.mod_params.key = &new_key;
 
-		if (uparam.mod_params.action) {
-			if (copy_from_user(&compat_action,
-				compat_ptr(uparam.mod_params.action),
-				sizeof(struct dpa_cls_compat_tbl_action))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_ref "
-					"user space args (#3)");
-				return -EBUSY;
-			}
-
-			dpa_cls_tbl_action_params_compatcpy(&action,
-				&compat_action);
-
-			kparam.mod_params.action = &action;
-
-			/* Check if we need to copy policer params */
-			if ((compat_action.type ==
-				DPA_CLS_TBL_ACTION_ENQ) &&
-				(compat_action.enq_params.
-					policer_params)) {
-				if (copy_from_user(&policer_params,
-					compat_ptr(compat_action.
-					enq_params.policer_params),
-					sizeof(policer_params))) {
-					pr_err("Could not read "
-				"dpa_classif_table_modify_entry_by_ref user "
-				"space args (#4)");
-					return -EBUSY;
-				}
-				kparam.mod_params.action->enq_params.
-					policer_params =
-					&policer_params;
-			}
-		}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(&kparam,
+			&uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 	{
@@ -1150,18 +1072,8 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			return -EBUSY;
 		}
 
-		/* Check if we need to copy the new key and action */
-		if (kparam.mod_params.key) {
-			if (copy_from_user(&key,
-				kparam.mod_params.key,
-				sizeof(struct dpa_cls_tbl_key))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_ref "
-					"user space args (#2)");
-				return -EBUSY;
-			}
-			kparam.mod_params.key = &key;
-		}
+		/* Check if we need to copy the new key */
+		COPY_NEW_KEY_PARAMS;
 
 		if (kparam.mod_params.action) {
 			if (copy_from_user(&action,
@@ -1206,6 +1118,8 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_tbl_lookup_by_key kparam;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_tbl_lookup_by_key uparam;
 
@@ -1218,11 +1132,18 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 			return -EBUSY;
 		}
 
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
+
 		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_lookup_by_key_params_compatcpy(&kparam,
+		ret = dpa_cls_tbl_lookup_by_key_params_compatcpy(&kparam,
 			&uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
+	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_lookup_by_key user space "
@@ -1230,6 +1151,9 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 			return -EBUSY;
 		}
 
+		COPY_KEY_PARAMS;
+	}
+
 	/* Call function */
 	ret = dpa_classif_table_lookup_by_key(kparam.td,
 					      &kparam.key,
@@ -1237,18 +1161,13 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 	if (ret < 0)
 		return ret;
 
-	if (kparam.action.type == DPA_CLS_TBL_ACTION_ENQ)
-		/*
-		 * Reset policer params pointer as it has no meaning in user
-		 * space
-		 */
-		kparam.action.enq_params.policer_params = NULL;
-
 	/* Return results to user space */
 #ifdef CONFIG_COMPAT
 	if (compat_mode) {
-		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
+		ret = dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
 			&kparam.action);
+		if (ret < 0)
+			return ret;
 
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
 			pr_err("ERROR: %s, %s (%d): Write failed: "
@@ -1285,8 +1204,10 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 		}
 
 		/* Transfer the data into the kernel space params: */
-		dpa_cls_tbl_lookup_by_ref_params_compatcpy(&kparam,
+		ret = dpa_cls_tbl_lookup_by_ref_params_compatcpy(&kparam,
 			&uparam);
+		if (ret < 0)
+			return ret;
 	} else
 #endif /* CONFIG_COMPAT */
 		/* Prepare arguments */
@@ -1304,18 +1225,13 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 	if (ret < 0)
 		return ret;
 
-	if (kparam.action.type == DPA_CLS_TBL_ACTION_ENQ)
-		/*
-		 * Reset policer params pointer as it has no meaning in user
-		 * space
-		 */
-		kparam.action.enq_params.policer_params = NULL;
-
 	/* Return results to user space */
 #ifdef CONFIG_COMPAT
 	if (compat_mode) {
-		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
+		ret = dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
 			&kparam.action);
+		if (ret < 0)
+			return ret;
 
 		if (copy_to_user((void *)args, &uparam, sizeof(uparam))) {
 			pr_err("ERROR: %s, %s (%d): Write failed: "
@@ -1335,22 +1251,271 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 	return ret;
 }
 
+static long do_ioctl_table_delete_entry_by_key(unsigned long	args,
+					bool			compat_mode)
+{
+	struct ioc_dpa_cls_tbl_entry_by_key kparam;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+#ifdef CONFIG_COMPAT
+	long ret = 0;
+	struct compat_ioc_dpa_cls_tbl_entry_by_key uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_delete_entry_by_key user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_by_key_params_compatcpy(&kparam,
+								&uparam);
+		if (ret < 0)
+			return ret;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		/* Prepare arguments */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_delete_entry_by_key user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		COPY_KEY_PARAMS;
+	}
+
+	/* Call function */
+	return dpa_classif_table_delete_entry_by_key(kparam.td,
+						    &kparam.key);
+}
+
+static long do_ioctl_table_get_stats_by_key(unsigned long	args,
+					bool			compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_tbl_entry_stats_by_key kparam;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_entry_stats_by_key uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_get_entry_stats_by_key user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_stats_by_key_params_compatcpy(&kparam,
+			&uparam);
+		if (ret < 0)
+			return ret;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		/* Prepare arguments */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_get_entry_stats_by_key user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		COPY_KEY_PARAMS;
+	}
+
+	/* Call function */
+	ret = dpa_classif_table_get_entry_stats_by_key(kparam.td,
+						       &kparam.key,
+						       &kparam.stats,
+						       kparam.reset);
+	if (ret < 0)
+		return ret;
+
+	/* Return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		memcpy(&uparam.stats, &kparam.stats,
+				sizeof(struct dpa_cls_tbl_entry_stats));
+
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_get_entry_stats_by_key "
+				"result.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_get_entry_stats_by_key "
+				"result.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_table_reset_stats_by_key(unsigned long	args,
+					bool			compat_mode)
+{
+	struct ioc_dpa_cls_tbl_entry_by_key kparam;
+	uint8_t key_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_buf[DPA_OFFLD_MAXENTRYKEYSIZE];
+#ifdef CONFIG_COMPAT
+	long ret = 0;
+	struct compat_ioc_dpa_cls_tbl_entry_by_key uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_reset_entry_stats_by_key "
+				"user space args.\n", __FILE__, __func__,
+				__LINE__);
+			return -EBUSY;
+		}
+
+		kparam.key.byte = key_buf;
+		kparam.key.mask = mask_buf;
+		kparam.key.size = DPA_OFFLD_MAXENTRYKEYSIZE;
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_tbl_entry_by_key_params_compatcpy(&kparam,
+			&uparam);
+		if (ret < 0)
+			return ret;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		/* Prepare arguments */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_reset_entry_stats_by_key user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		COPY_KEY_PARAMS;
+	}
+
+	/* Call function */
+	return dpa_classif_table_reset_entry_stats_by_key(kparam.td,
+							&kparam.key);
+}
+
+void *translate_fm_pcd_handle(void *fm_pcd)
+{
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	fm_pcd_file = fcheck((unsigned int)fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("ERROR: %s, %s (%d): Could not translate PCD handle.\n",
+			__FILE__, __func__, __LINE__);
+		return NULL;
+	}
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+
+	return (void *)fm_wrapper_dev->h_PcdDev;
+}
+
 #ifdef CONFIG_COMPAT
 
-void dpa_cls_tbl_entry_params_compatcpy(
-		struct ioc_dpa_cls_tbl_entry_params			*kparam,
-		const struct compat_ioc_dpa_cls_tbl_entry_params	*uparam)
+int dpa_cls_tbl_entry_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_by_key			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_by_key	*uparam)
+{
+	kparam->td = uparam->td;
+	return dpa_lookup_key_params_compatcpy(&kparam->key, &uparam->key);
+}
+
+int dpa_cls_tbl_entry_stats_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_stats_by_key		*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_stats_by_key	*uparam)
 {
+	int err = 0;
+
+	kparam->td	= uparam->td;
+	kparam->reset	= uparam->reset;
+
+	err = dpa_lookup_key_params_compatcpy(&kparam->key, &uparam->key);
+	if (err < 0)
+		return err;
+
+	memcpy(&kparam->stats,
+		&uparam->stats,
+		sizeof(struct dpa_cls_tbl_entry_stats));
+
+	return 0;
+}
+
+int dpa_lookup_key_params_compatcpy(
+		struct dpa_offload_lookup_key			*kparam,
+		const struct compat_ioc_dpa_offld_lookup_key	*uparam)
+{
+	BUG_ON(!uparam->byte);
+	BUG_ON(!kparam->byte);
+	BUG_ON(kparam->size < uparam->size);
+	BUG_ON(uparam->size <= 0);
+
+	kparam->size = uparam->size;
+	if (copy_from_user(kparam->byte, compat_ptr(uparam->byte),
+		uparam->size)) {
+		pr_err("ERROR: %s, %s (%d): Read failed: lookup key.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	if (compat_ptr(uparam->mask)) {
+		BUG_ON(!kparam->mask);
+		if (copy_from_user(kparam->mask, compat_ptr(uparam->mask),
+			uparam->size)) {
+			pr_err("ERROR: %s, %s (%d): Read failed: key mask.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+		kparam->mask = NULL;
+
+	return 0;
+}
+
+int dpa_cls_tbl_entry_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_params			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_params	*uparam)
+{
+	int err;
+
 	kparam->td		= uparam->td;
 	kparam->priority	= uparam->priority;
 	kparam->entry_id	= uparam->entry_id;
 
-	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+	err = dpa_lookup_key_params_compatcpy(&kparam->key, &uparam->key);
+	if (err < 0)
+		return err;
 
-	dpa_cls_tbl_action_params_compatcpy(&kparam->action, &uparam->action);
+	return dpa_cls_tbl_action_params_compatcpy(&kparam->action,
+							&uparam->action);
 }
 
-void dpa_cls_tbl_action_params_compatcpy(
+int dpa_cls_tbl_action_params_compatcpy(
 		struct dpa_cls_tbl_action			*kparam,
 		const struct dpa_cls_compat_tbl_action		*uparam)
 {
@@ -1363,17 +1528,20 @@ void dpa_cls_tbl_action_params_compatcpy(
 				uparam->enq_params.override_fqid;
 		kparam->enq_params.new_fqid =
 				uparam->enq_params.new_fqid;
+		kparam->enq_params.hmd = uparam->enq_params.hmd;
 
-		if (uparam->enq_params.hm != 0) {
-			kparam->enq_params.hm = compat_get_id2ptr(
-				uparam->enq_params.hm, FM_MAP_TYPE_PCD_NODE);
+		if (uparam->enq_params.policer_params) {
+			BUG_ON(!kparam->enq_params.policer_params);
+			if (copy_from_user(kparam->enq_params.policer_params,
+				compat_ptr(uparam->enq_params.policer_params),
+				sizeof(struct dpa_cls_tbl_policer_params))) {
+				pr_err("ERROR: %s, %s (%d): Read failed: "
+					"policer params.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
 		} else
-			kparam->enq_params.hm = NULL;
-
-		/* Policer params are a separate data structure which is
-		 * managed by the caller */
-		kparam->enq_params.policer_params = NULL;
-
+			kparam->enq_params.policer_params = NULL;
 		break;
 	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
 		kparam->next_table_params.next_td =
@@ -1382,9 +1550,11 @@ void dpa_cls_tbl_action_params_compatcpy(
 	default:
 		break;
 	}
+
+	return 0;
 }
 
-void dpa_cls_tbl_action_params_rcompatcpy(
+int dpa_cls_tbl_action_params_rcompatcpy(
 		struct dpa_cls_compat_tbl_action	*uparam,
 		const struct dpa_cls_tbl_action		*kparam)
 {
@@ -1397,15 +1567,12 @@ void dpa_cls_tbl_action_params_rcompatcpy(
 				kparam->enq_params.override_fqid;
 		uparam->enq_params.new_fqid =
 				kparam->enq_params.new_fqid;
+		uparam->enq_params.hmd = kparam->enq_params.hmd;
 
-		if (kparam->enq_params.hm != NULL) {
-			uparam->enq_params.hm = compat_get_ptr2id(
-				kparam->enq_params.hm, FM_MAP_TYPE_PCD_NODE);
-		} else
-			uparam->enq_params.hm = 0;
-
-		/* Policer params are a separate data structure which is
-		 * managed by the caller */
+		/*
+		 * Policer params structure address has no meaning in user
+		 * space
+		 */
 		uparam->enq_params.policer_params = 0;
 
 		break;
@@ -1416,16 +1583,18 @@ void dpa_cls_tbl_action_params_rcompatcpy(
 	default:
 		break;
 	}
+
+	return 0;
 }
 
-void dpa_cls_tbl_params_compatcpy(
+int dpa_cls_tbl_params_compatcpy(
 		struct ioc_dpa_cls_tbl_params			*kparam,
 		const struct compat_ioc_dpa_cls_tbl_params	*uparam)
 {
 	kparam->table_params.fm_pcd = compat_ptr(uparam->table_params.fm_pcd);
 	kparam->table_params.cc_node = compat_get_id2ptr(
 					uparam->table_params.cc_node,
-					FM_MAP_TYPE_PCD_NODE);
+					PCD_NODE);
 
 	kparam->table_params.type	= uparam->table_params.type;
 	kparam->table_params.entry_mgmt	= uparam->table_params.entry_mgmt;
@@ -1449,67 +1618,92 @@ void dpa_cls_tbl_params_compatcpy(
 
 		break;
 	}
+
+	return 0;
 }
 
-void dpa_cls_tbl_miss_action_params_compatcpy(
+int dpa_cls_tbl_miss_action_params_compatcpy(
 		struct ioc_dpa_cls_tbl_miss_action		*kparam,
 		const struct compat_ioc_dpa_cls_tbl_miss_action	*uparam)
 {
 	kparam->td = uparam->td;
 
-	dpa_cls_tbl_action_params_compatcpy(&kparam->miss_action,
+	return dpa_cls_tbl_action_params_compatcpy(&kparam->miss_action,
 			&uparam->miss_action);
 }
 
-void dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
+int dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
 	struct ioc_dpa_cls_tbl_entry_mod_by_key			*kparam,
 	const struct compat_ioc_dpa_cls_tbl_entry_mod_by_key	*uparam)
 {
+	int err;
+
 	kparam->td = uparam->td;
 
-	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+	err = dpa_lookup_key_params_compatcpy(&kparam->key, &uparam->key);
+	if (err < 0)
+		return err;
 
-	dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
+	return dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
 		&uparam->mod_params);
 }
 
-void dpa_cls_tbl_entry_mod_params_compatcpy(
+int dpa_cls_tbl_entry_mod_params_compatcpy(
 	struct dpa_cls_tbl_entry_mod_params			*kparam,
 	const struct dpa_cls_compat_tbl_entry_mod_params	*uparam)
 {
+	int err = 0;
+
 	kparam->type = uparam->type;
 
-	/* Key params and action params are separate data structures which are
-	 * managed by the caller */
-	kparam->key	= NULL;
-	kparam->action	= NULL;
+	if (compat_ptr(uparam->key)) {
+		BUG_ON(!kparam->key);
+		err = dpa_lookup_key_params_compatcpy(kparam->key,
+				compat_ptr(uparam->key));
+	} else
+		kparam->key = NULL;
+
+	if (err < 0)
+		return err;
+
+	if (uparam->action) {
+		BUG_ON(!kparam->action);
+		err = dpa_cls_tbl_action_params_compatcpy(kparam->action,
+						compat_ptr(uparam->action));
+	} else
+		kparam->action = NULL;
+
+	return err;
 }
 
-void dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
+int dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
 	struct ioc_dpa_cls_tbl_entry_mod_by_ref			*kparam,
 	const struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref	*uparam)
 {
 	kparam->td		= uparam->td;
 	kparam->entry_id	= uparam->entry_id;
 
-	dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
+	return dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
 		&uparam->mod_params);
 }
 
-void dpa_cls_tbl_lookup_by_key_params_compatcpy(
+int dpa_cls_tbl_lookup_by_key_params_compatcpy(
 	struct ioc_dpa_cls_tbl_lookup_by_key			*kparam,
 	const struct compat_ioc_dpa_cls_tbl_lookup_by_key	*uparam)
 {
 	kparam->td = uparam->td;
-	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+
+	return dpa_lookup_key_params_compatcpy(&kparam->key, &uparam->key);
 }
 
-void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
+int dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 	struct ioc_dpa_cls_tbl_lookup_by_ref			*kparam,
 	const struct compat_ioc_dpa_cls_tbl_lookup_by_ref	*uparam)
 {
 	kparam->td		= uparam->td;
 	kparam->entry_id	= uparam->entry_id;
+
+	return 0;
 }
 
 #endif /* CONFIG_COMPAT */
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 7516822..fb545c9 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -53,17 +53,14 @@
 #define DPA_CLS_HM_MAX_MPLS_LABELS				6
 /* Standard size of the DSCP-to-VPri mapping table */
 #define DPA_CLS_HM_DSCP_TO_VLAN_TABLE_SIZE			32
-/* DPA Classifier maximum size of a lookup key, in bytes */
-#define DPA_CLS_TBL_MAXENTRYKEYSIZE				56
 /* Number of entries in the DSCP-to-VPri mapping table */
 #define DPA_CLS_HM_DSCP_TO_VPRI_TABLE_SIZE			64
 
-/* API functions, definitions and enums */
 
+/* API functions, definitions and enums */
 
 /* Table API */
 
-
 /* DPA Classifier Table Types */
 enum dpa_cls_tbl_type {
 	DPA_CLS_TBL_HASH = 0,		/* HASH table */
@@ -227,22 +224,6 @@ struct dpa_cls_tbl_next_table_desc {
 				 * table to continue classification with */
 };
 
-/* Entry key descriptor */
-struct dpa_cls_tbl_key {
-
-	/*
-	 * The data (bytes) of the key. For indexed tables the index is
-	 * the first byte of this array
-	 */
-	uint8_t		byte[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-
-	/*
-	 * The mask of the key. The the bits corresponding to zeros in
-	 * the mask are ignored
-	 */
-	uint8_t		mask[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-};
-
 /* DPA Classifier action descriptor */
 struct dpa_cls_tbl_action {
 
@@ -279,7 +260,7 @@ struct dpa_cls_tbl_entry_mod_params {
 	 * parameters of the entry. Ignored for modify types which
 	 * do not refer to the key.
 	 */
-	struct dpa_cls_tbl_key			*key;
+	struct dpa_offload_lookup_key		*key;
 
 	/*
 	 * The new action parameters to replace the existing action
@@ -336,10 +317,10 @@ int dpa_classif_table_modify_miss_action(int			td,
  * first one will always be returned by the hardware lookup.
  */
 int dpa_classif_table_insert_entry(int				td,
-				const struct dpa_cls_tbl_key	*key,
-				const struct dpa_cls_tbl_action *action,
-				int				priority,
-				int				*entry_id);
+			const struct dpa_offload_lookup_key	*key,
+			const struct dpa_cls_tbl_action		*action,
+			int					priority,
+			int					*entry_id);
 
 /*
  * Modifies an entry in the specified DPA Classifier table. The
@@ -347,7 +328,7 @@ int dpa_classif_table_insert_entry(int				td,
  * allocates new MURAM space.
  */
 int dpa_classif_table_modify_entry_by_key(int			td,
-		const struct dpa_cls_tbl_key			*key,
+		const struct dpa_offload_lookup_key		*key,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params);
 
 /*
@@ -366,7 +347,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
  * MURAM space.
  */
 int dpa_classif_table_delete_entry_by_key(int				td,
-					const struct dpa_cls_tbl_key	*key);
+				const struct dpa_offload_lookup_key	*key);
 
 /*
  * Removes an entry in the specified DPA Classifier table. The
@@ -389,8 +370,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id);
  * It is recommended to use this function with consideration.
  */
 int dpa_classif_table_lookup_by_key(int				td,
-				const struct dpa_cls_tbl_key	*key,
-				struct dpa_cls_tbl_action	*action);
+			const struct dpa_offload_lookup_key	*key,
+			struct dpa_cls_tbl_action		*action);
 
 /*
  * Performs a lookup in the specified table for an entry specified
@@ -415,9 +396,9 @@ int dpa_classif_table_flush(int td);
  * table. The entry is identified by the lookup key.
  */
 int dpa_classif_table_get_entry_stats_by_key(int			td,
-					const struct dpa_cls_tbl_key	*key,
-					struct dpa_cls_tbl_entry_stats	*stats,
-					int				reset);
+				const struct dpa_offload_lookup_key	*key,
+				struct dpa_cls_tbl_entry_stats		*stats,
+				int					reset);
 
 /*
  * Returns the statistics for a specified entry in a specified
@@ -433,7 +414,7 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
  * table. The entry is identified by its lookup key.
  */
 int dpa_classif_table_reset_entry_stats_by_key(int			td,
-					const struct dpa_cls_tbl_key	*key);
+				const struct dpa_offload_lookup_key	*key);
 
 /*
  * Resets the statistics for a specified entry in a specified
diff --git a/include/linux/fsl_dpa_offload.h b/include/linux/fsl_dpa_offload.h
index abeacbb..dde5499 100644
--- a/include/linux/fsl_dpa_offload.h
+++ b/include/linux/fsl_dpa_offload.h
@@ -49,9 +49,34 @@
 #define DPA_OFFLD_IPv6_ADDR_LEN_WORDS				8
 #define DPA_OFFLD_IPv6_ADDR_LEN_LONG				4
 
+/* Maximum size of a lookup key, in bytes */
+#define DPA_OFFLD_MAXENTRYKEYSIZE				56
+
 #define DPA_OFFLD_DESC_NONE					-1
 
 
+/* Description of lookup key */
+struct dpa_offload_lookup_key {
+
+	/*
+	 * The data (bytes) of the key. For indexed tables the index is the
+	 * first byte of this array
+	 */
+	uint8_t		*byte;
+
+	/*
+	 * The mask of the key. The bits corresponding to zeros in the mask are
+	 * ignored. NULL is the table doesn't have the mask support enabled.
+	 */
+	uint8_t		*mask;
+
+	/*
+	 * The size of the key in bytes. Must not exceed
+	 * DPA_OFFLD_MAXENTRYKEYSIZE
+	 */
+	uint8_t		size;
+};
+
 /* Description of the IPv4 address */
 union dpa_offload_ipv4_address {
 	/* Address as 32bit word */
-- 
1.7.5.4

