From 92877bba9152601a184a0878d86a16686d867c8f Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 15 Feb 2013 22:15:23 +0000
Subject: [PATCH 483/518] dpa_ipsec: Add modify_sa function

New feature for dpa ipsec component - created the API
and implementation for modifying an SA at runtime.

The API update is adding the capability of changing the
shared descriptor for an SA enabling the following
capabilities: enable ARS, change ARS window size,
set/reset the sequence number for an SA, replacing the
keys for encryption/decription and updating SPI/SEQ (rekeying the
SA)

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   96 +++++++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    3 +
 include/linux/fsl_dpa_ipsec.h               |   23 ++++++-
 3 files changed, 120 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 4acf76b..f9926c1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -889,6 +889,19 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		    sa[i].sec_desc_extra_cmds)
 			sa[i].sec_desc_extra_cmds += L1_CACHE_BYTES;
 
+		/*
+		 * Allocate space for the SEC replacement job descriptor
+		 * Required 64 byte alignment
+		 */
+		sa[i].rjob_desc_unaligned =
+			kzalloc(MAX_CAAM_DESCSIZE * sizeof(uint32_t) + 64,
+				GFP_KERNEL);
+		if (!sa[i].rjob_desc_unaligned) {
+			pr_err("No memory for replacement job descriptor\n");
+			return -ENOMEM;
+		}
+		sa[i].rjob_desc = PTR_ALIGN(sa[i].rjob_desc_unaligned, 64);
+
 		/* Initialize the policy parameter list which will hold all
 		 * inbound or outbound policy parameters which were use to
 		 * generate PCD entries */
@@ -1060,6 +1073,9 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 
 			kfree(sa_mng->sa[i].sec_desc_extra_cmds_unaligned);
 			sa_mng->sa[i].sec_desc_extra_cmds_unaligned = NULL;
+
+			kfree(sa_mng->sa[i].rjob_desc_unaligned);
+			sa_mng->sa[i].rjob_desc_unaligned = NULL;
 		}
 		kfree(sa_mng->sa);
 		sa_mng->sa = NULL;
@@ -4608,3 +4624,83 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 	return 0;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_get_stats);
+
+int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
+{
+	struct dpa_ipsec_sa *sa;
+	dma_addr_t dma_rjobd;
+	uint32_t *rjobd;
+	struct qm_fd fd;
+	int ret;
+
+	if (!modify_prm) {
+		pr_err("Invalid modify SA parameter\n");
+		return -EINVAL;
+	}
+
+	sa = get_sa_from_sa_id(sa_id);
+	if (!sa) {
+		pr_err("Invalid SA id provided\n");
+		return -EINVAL;
+	}
+
+	ret = mutex_trylock(&sa->lock);
+	if (ret == 0) {
+		pr_err("SA %d is being used\n", sa->id);
+		return -EBUSY;
+	}
+
+	BUG_ON(!sa->dpa_ipsec);
+
+	switch (modify_prm->type) {
+	case DPA_IPSEC_SA_MODIFY_ARS:
+		ret = build_rjob_desc_ars_update(sa, modify_prm->arw);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_IPSEC_SA_MODIFY_SEQ_NUM:
+		pr_err("Modifying SEQ number is unsupported\n");
+		return -EOPNOTSUPP;
+	case DPA_IPSEC_SA_MODIFY_EXT_SEQ_NUM:
+		pr_err("Modifying extended SEQ number is unsupported\n");
+		return -EOPNOTSUPP;
+	case DPA_IPSEC_SA_MODIFY_CRYPTO:
+		pr_err("Modifying cryptographic parameters is unsupported\n");
+		return -EOPNOTSUPP;
+	default:
+		pr_err("Invalid type for modify parameters\n");
+		mutex_unlock(&sa->lock);
+		return -EINVAL;
+	}
+
+	rjobd = sa->rjob_desc;
+	dma_rjobd = dma_map_single(sa->dpa_ipsec->jrdev, rjobd,
+				   desc_len(rjobd) * CAAM_CMD_SZ,
+				   DMA_BIDIRECTIONAL);
+	if (!dma_rjobd) {
+		pr_err("Failed DMA mapping the RJD for SA %d\n", sa->id);
+		return -ENXIO;
+	}
+
+	memset(&fd, 0x00, sizeof(struct qm_fd));
+	/* fill frame descriptor parameters */
+	fd.format = qm_fd_contig;
+	qm_fd_addr_set64(&fd, dma_rjobd);
+	fd.length20 = desc_len(rjobd) * sizeof(uint32_t);
+	fd.offset = 0;
+	fd.bpid = 0;
+	fd.cmd = FD_CMD_REPLACE_JOB_DESC;
+	ret = qman_enqueue(sa->to_sec_fq, &fd, 0);
+	if (ret != 0) {
+		pr_err("Could not enqueue frame with RJAD for SA %d\n", sa->id);
+		ret = -ETXTBSY;
+	}
+
+	dma_unmap_single(sa->dpa_ipsec->jrdev, dma_rjobd,
+			 desc_len(rjobd) * CAAM_CMD_SZ, DMA_BIDIRECTIONAL);
+
+	mutex_unlock(&sa->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dpa_ipsec_sa_modify);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 9555c58..7e79654 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -33,6 +33,7 @@
 #define __DPA_IPSEC_H__
 
 #include <linux/fsl_qman.h>
+#include <linux/fsl_bman.h>
 #include <linux/fsl_dpa_ipsec.h>
 
 /* From Linux for Shared Descriptor auxiliary structures */
@@ -249,6 +250,8 @@ struct dpa_ipsec_sa {
 	uint32_t *sec_desc_extra_cmds_unaligned;
 	uint32_t *sec_desc_extra_cmds; /* aligned to CORE cache line size     */
 	bool	 sec_desc_extended; /* true if SEC descriptor is extended     */
+	uint32_t *rjob_desc_unaligned;
+	uint32_t *rjob_desc; /* replacement job descriptor address	      */
 	uint32_t stats_offset; /* Offset of the statistics (in bytes)	      */
 	uint32_t stats_indx; /* Index of the lifetime counter in descriptor   */
 	uint32_t next_cmd_indx; /* Next command index after SHD header	      */
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index f3854bf..e5ac6aa 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -261,8 +261,8 @@ struct dpa_ipsec_init_vector {
 /* DPA IPSEC Anti Replay Window Size */
 enum dpa_ipsec_arw {
 	DPA_IPSEC_ARSNONE = 0,	/* No Anti Replay Protection		      */
-	DPA_IPSEC_ARS32,	/* 32 bit Anti Replay Window size	      */
-	DPA_IPSEC_ARS64,	/* 64 bit Anti Replay Window size	      */
+	DPA_IPSEC_ARS32   = 1,	/* 32 bit Anti Replay Window size	      */
+	DPA_IPSEC_ARS64   = 3,	/* 64 bit Anti Replay Window size	      */
 };
 
 /* DPA-IPSec Security Association Cryptographic Parameters */
@@ -494,4 +494,23 @@ struct dpa_ipsec_sa_stats {
 /* This function will populate sa_stats with SEC statistics for SA with sa_id */
 int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats);
 
+enum dpa_ipsec_sa_modify_type {
+	DPA_IPSEC_SA_MODIFY_ARS = 0, /* Set the anti replay window size	      */
+	DPA_IPSEC_SA_MODIFY_SEQ_NUM, /* Set the sequence number for this SA   */
+	DPA_IPSEC_SA_MODIFY_EXT_SEQ_NUM, /* Set the extended sequence number  */
+	DPA_IPSEC_SA_MODIFY_CRYPTO /* Reset the crypto algorithms for this SA */
+};
+
+struct dpa_ipsec_sa_modify_prm {
+	enum dpa_ipsec_sa_modify_type type;
+	union {
+		enum dpa_ipsec_arw arw;
+		uint32_t seq;
+		uint64_t ext_seq;
+		struct dpa_ipsec_sa_crypto_params crypto_params;
+	};
+};
+
+int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm);
+
 #endif	/* __FSL_DPA_IPSEC_H */
-- 
1.7.5.4

