From b60f5f5ab325b69968c83354cf78651138908ba7 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 12 Nov 2012 21:55:01 +0000
Subject: [PATCH 405/518] dpa_classifier: Bug fix. Update use of linked lists
 for header manipulation chains

The low level header manipulation chain from data structure "dpa_cls_hm"
was incorrectly using a linked list without a special head node. This was
corrected and now the head of the manip node list is allocated by the
"create_new_hm_op" function and shared by all high level header manip ops
in the chain.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  229 +++++++---------------
 1 files changed, 76 insertions(+), 153 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 31baa96..999affb 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3469,11 +3469,9 @@ static int
 static int import_hm_nodes_to_chain(void * const *node_array,
 	unsigned int num_nodes, struct dpa_cls_hm *hm)
 {
-	struct dpa_cls_hm *pnext_hm = NULL;
-	struct list_head *chain = NULL;
 	struct dpa_cls_hm_node *hm_node;
 	int i;
-	int j = 0;
+	bool found;
 
 	if (!num_nodes)
 		/* Nothing to do */
@@ -3482,101 +3480,44 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 	BUG_ON(!node_array);
 	BUG_ON(!hm);
 
-	if (!list_empty(&hm->list_node)) {
-		pnext_hm = list_entry(hm->list_node.next,
-				struct dpa_cls_hm,
-				list_node);
-
-		chain = pnext_hm->hm_chain;
-	}
-
-	if (pnext_hm) {
-		bool found;
-		struct dpa_cls_hm *pcurrent;
-
-		/* This HM operation is linked to another HM op */
-		for (i = 0; i < num_nodes; i++) {
-			/*
-			 * If the node is empty, save an empty space and skip
-			 * to the next
-			 */
-			if (!node_array[i]) {
-				hm->hm_node[j++] = NULL;
-				continue;
-			}
+	/* This HM operation is linked to another HM op */
+	for (i = num_nodes - 1; i >= 0; i--) {
+		/*
+		 * If the node is empty, save an empty space and skip
+		 * to the next
+		 */
+		if (!node_array[i]) {
+			hm->hm_node[i] = NULL;
+			continue;
+		}
 
-			/* Check if this node is already in the chain */
-			found = false;
-			list_for_each_entry(hm_node, pnext_hm->hm_chain,
-				list_node) {
+		/* Check if this node is already in the chain */
+		found = false;
+		if (!list_empty(&hm->list_node)) {
+			list_for_each_entry(hm_node, hm->hm_chain, list_node) {
 				if ((unsigned long)hm_node->node ==
 					(unsigned long)node_array[i]) {
 					/*
-					 * This node already exists in the
-					 * chain
+					 * This node already exists in the chain
 					 */
 					found = true;
 					break;
 				}
 			}
-
-			if (found)
-				/*
-				 * This node already exists in the chain hence
-				 * point to the existing node
-				 */
-				hm->hm_node[j++] = hm_node;
-			else {
-				/* Node does not exist, we need to create it */
-				hm->hm_node[j] = (struct dpa_cls_hm_node *)
-					kzalloc(sizeof(struct dpa_cls_hm_node),
-						GFP_KERNEL);
-				if (!hm->hm_node[j]) {
-					pr_err("ERROR: %s, %s (%d): Not enough "
-						"memory for HM node "
-						"management.\n", __FILE__,
-						__func__, __LINE__);
-					return -ENOMEM;
-				}
-
-				/* Fill in the node */
-				hm->hm_node[j]->node = node_array[i];
-				INIT_LIST_HEAD(&hm->hm_node[j]->list_node);
-
-			/* Add this new node to the HM chain: */
-			if (chain)
-				list_add_tail(&hm->hm_node[j]->list_node,
-					chain);
-			chain = &hm->hm_node[j++]->list_node;
-			}
 		}
 
-		/*
-		 * Update the low level ops chain head on all the other
-		 * high level ops in the high level ops chain:
-		 */
-		if (pnext_hm->hm_chain != chain) {
-			list_for_each_entry(pcurrent,
-				&hm->list_node, list_node) {
-				pcurrent->hm_chain = chain;
-			}
-		}
-	} else {
-		/* This is an isolated HM operation */
-		for (i = 0; i < num_nodes; i++) {
+		if (found)
 			/*
-			 * If the node is empty, save an empty space and skip
-			 * to the next
+			 * This node already exists in the chain hence
+			 * point to the existing node
 			 */
-			if (!node_array[i]) {
-				hm->hm_node[j++] = NULL;
-				continue;
-			}
-
-			hm->hm_node[j] = (struct dpa_cls_hm_node *)
+			hm->hm_node[i] = hm_node;
+		else {
+			/* Node does not exist, we need to create it */
+			hm->hm_node[i] = (struct dpa_cls_hm_node *)
 				kzalloc(sizeof(struct dpa_cls_hm_node),
 					GFP_KERNEL);
-			if (!hm->hm_node[j]) {
+			if (!hm->hm_node[i]) {
 				pr_err("ERROR: %s, %s (%d): Not enough memory "
 					"for HM node management.\n", __FILE__,
 					__func__, __LINE__);
@@ -3584,62 +3525,32 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			}
 
 			/* Fill in the node */
-			hm->hm_node[j]->node = node_array[i];
-			INIT_LIST_HEAD(&hm->hm_node[j]->list_node);
+			hm->hm_node[i]->node = node_array[i];
+			INIT_LIST_HEAD(&hm->hm_node[i]->list_node);
 
-			if (chain)
-				list_add_tail(&hm->hm_node[j]->list_node,
-						chain);
-			else
-				chain = &hm->hm_node[j]->list_node;
-
-			j++;
+			/* Add this new node to the HM chain: */
+			list_add(&hm->hm_node[i]->list_node,
+				hm->hm_chain);
 		}
 	}
 
-	hm->hm_chain = chain;
-
 	return 0;
 }
 
 static int add_local_hm_nodes_to_chain(struct dpa_cls_hm *phm)
 {
-	struct dpa_cls_hm *pnext_hm = NULL;
-	struct dpa_cls_hm *pcurrent;
 	int i;
 
 	BUG_ON(!phm);
 
-	if (!list_empty(&phm->list_node)) {
-		pnext_hm = list_entry(phm->list_node.next,
-				struct dpa_cls_hm,
-				list_node);
-		phm->hm_chain = pnext_hm->hm_chain;
-	} else
-		phm->hm_chain = NULL;
-
-	for (i = 0; i < phm->num_nodes; i++)
+	for (i = phm->num_nodes - 1; i >= 0; i--)
 		/*
 		 * If the node exists and it is not already integrated in a HM
 		 * chain...
 		 */
 		if ((phm->hm_node[i]) &&
-				(list_empty(&phm->hm_node[i]->list_node))) {
-			if (phm->hm_chain)
-				list_add_tail(&phm->hm_node[i]->list_node,
-								phm->hm_chain);
-			else
-				phm->hm_chain = &phm->hm_node[i]->list_node;
-		}
-
-	if (pnext_hm)
-		/*
-		 * Update the low level ops chain head for all the other
-		 * high level ops in the high level ops chain:
-		 */
-		list_for_each_entry(pcurrent, &phm->list_node, list_node) {
-			pcurrent->hm_chain = phm->hm_chain;
-		}
+				(list_empty(&phm->hm_node[i]->list_node)))
+			list_add(&phm->hm_node[i]->list_node, phm->hm_chain);
 
 	return 0;
 }
@@ -3842,12 +3753,25 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 			pr_err("ERROR: %s, %s (%d): Link to an invalid HM "
 				"(next_hmd=%d).\n", __FILE__, __func__,
 				__LINE__, next_hmd);
-			dpa_classif_free_hm(*hmd);
+			remove_hm_op(*hmd);
 			*hmd = DPA_OFFLD_DESC_NONE;
 			return -EINVAL;
 		}
 
 		list_add_tail(&hm->list_node, &next_hm->list_node);
+
+		hm->hm_chain = next_hm->hm_chain;
+	} else {
+		hm->hm_chain = kmalloc(sizeof(struct list_head), GFP_KERNEL);
+		if (!hm->hm_chain) {
+			pr_err("ERROR: %s, %s (%d): No more memory for header "
+				"manip ops.\n", __FILE__, __func__, __LINE__);
+			remove_hm_op(*hmd);
+			*hmd = DPA_OFFLD_DESC_NONE;
+			return -ENOMEM;
+		}
+
+		INIT_LIST_HEAD(hm->hm_chain);
 	}
 
 	return err;
@@ -3865,8 +3789,10 @@ static void remove_hm_op(int hmd)
 		/* Descriptor already free. Nothing to do */
 		return;
 
-	/* If this op is attached to others, detach it first from the list */
-	if (!list_empty(&phm->list_node))
+	if (list_empty(&phm->list_node))
+		kfree(phm->hm_chain);
+	else
+		/* If this op is attached to others, detach it from the list */
 		list_del(&phm->list_node);
 
 	put_descriptor(&hm_array, hmd);
@@ -3937,7 +3863,7 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	if (chain_head) {
 		err = init_hm_chain(pnat_hm->nat_params.fm_pcd,
 				pnat_hm->hm_chain,
-				pnat_hm->hm_chain);
+				pnat_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -4280,7 +4206,7 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	if (chain_head) {
 		err = init_hm_chain(pfwd_hm->fwd_params.fm_pcd,
 				pfwd_hm->hm_chain,
-				pfwd_hm->hm_chain);
+				pfwd_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -4534,7 +4460,7 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	if (chain_head) {
 		err = init_hm_chain(premove_hm->remove_params.fm_pcd,
 				premove_hm->hm_chain,
-				premove_hm->hm_chain);
+				premove_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -4712,7 +4638,7 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	if (chain_head) {
 		err = init_hm_chain(pinsert_hm->insert_params.fm_pcd,
 				pinsert_hm->hm_chain,
-				pinsert_hm->hm_chain);
+				pinsert_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -5088,7 +5014,7 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	if (chain_head) {
 		err = init_hm_chain(pupdate_hm->update_params.fm_pcd,
 				pupdate_hm->hm_chain,
-				pupdate_hm->hm_chain);
+				pupdate_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -5527,7 +5453,7 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 	if (chain_head) {
 		err = init_hm_chain(pvlan_hm->vlan_params.fm_pcd,
 				pvlan_hm->hm_chain,
-				pvlan_hm->hm_chain);
+				pvlan_hm->hm_chain->next);
 		if (err < 0)
 			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
 				"level HM chain.\n", __FILE__, __func__,
@@ -5757,7 +5683,7 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 		if (chain_head) {
 			/* Initialize low level HM ops chain */
 			err = init_hm_chain(pmpls_hm->mpls_params.fm_pcd,
-				pmpls_hm->hm_chain, pmpls_hm->hm_chain);
+				pmpls_hm->hm_chain, pmpls_hm->hm_chain->next);
 			if (err < 0)
 				pr_err("ERROR: %s, %s (%d): Failed to "
 					"initialize low level HM chain.\n",
@@ -5990,7 +5916,9 @@ void *dpa_classif_hm_lock_chain(int hmd)
 	 * Acquire the hm_node structure that is head of the header manipulation
 	 * chain
 	 */
-	hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node, list_node);
+	hm_node = list_entry(hm->hm_chain->next,
+				struct dpa_cls_hm_node,
+				list_node);
 
 	return hm_node->node;
 }
@@ -6027,7 +5955,6 @@ void *dpa_classif_get_frag_hm_handle(int hmd)
 	struct dpa_cls_hm *hm;
 	struct dpa_cls_hm_node *pcurrent;
 	void *frag_hm_handle = NULL;
-	struct list_head *hm_list_node;
 
 	if (hmd == DPA_OFFLD_DESC_NONE)
 		/* Nothing to do */
@@ -6045,20 +5972,12 @@ void *dpa_classif_get_frag_hm_handle(int hmd)
 
 	hm = hm_array.object[hmd];
 
-	if (hm->hm_chain) {
-		hm_list_node = hm->hm_chain;
-		do {
-			pcurrent = list_entry(hm_list_node,
-					struct dpa_cls_hm_node,
-					list_node);
-			if ((pcurrent->node) && (pcurrent->params.type ==
+	list_for_each_entry(pcurrent, hm->hm_chain, list_node)
+		if ((pcurrent->node) && (pcurrent->params.type ==
 							e_FM_PCD_MANIP_FRAG)) {
-				frag_hm_handle = pcurrent->node;
-				break;
-			}
-			hm_list_node = hm_list_node->next;
-		} while (hm_list_node != hm->hm_chain);
-	}
+			frag_hm_handle = pcurrent->node;
+			break;
+		}
 
 	return frag_hm_handle;
 }
@@ -6067,6 +5986,7 @@ int dpa_classif_free_hm(int hmd)
 {
 	struct dpa_cls_hm *phm;
 	struct dpa_cls_hm_node *hm_node;
+	int i = 1;
 
 	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
 		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
@@ -6082,12 +6002,15 @@ int dpa_classif_free_hm(int hmd)
 		return 0;
 
 	/* Verify whether this header manipulation chain is in use */
-	hm_node = list_entry(phm->hm_chain, struct dpa_cls_hm_node, list_node);
-	if (hm_node->ref) {
-		pr_err("ERROR: %s, %s (%d): Unable to remove HM chain hmd=%d. "
-			"Chain is still used by %d entity(ies).\n", __FILE__,
-			__func__, __LINE__, hmd, hm_node->ref);
-		return -EBUSY;
+	list_for_each_entry(hm_node, phm->hm_chain, list_node) {
+		if (hm_node->ref) {
+			pr_err("ERROR: %s, %s (%d): Unable to remove HM chain "
+				"hmd=%d. Manip node #%d (0x%p) is still in use "
+				"by %d entity(ies).\n", __FILE__, __func__,
+				__LINE__, hmd, i, hm_node->node, hm_node->ref);
+			return -EBUSY;
+		}
+		i++;
 	}
 
 	if (phm->chain_head) {
@@ -6095,7 +6018,7 @@ int dpa_classif_free_hm(int hmd)
 		 * This is a header manip chain head, hence remove the entire
 		 * chain of low level ops
 		 */
-		if (remove_hm_chain(phm->hm_chain, phm->hm_chain) < 0)
+		if (remove_hm_chain(phm->hm_chain, phm->hm_chain->next) < 0)
 			pr_warn("WARNING: Not all low level HM nodes could be "
 				"removed for chain hmd=%d.\n", hmd);
 	}
-- 
1.7.5.4

