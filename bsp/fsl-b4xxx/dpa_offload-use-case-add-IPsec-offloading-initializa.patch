From 5ed8fe1d68cbc778a9ed1fa53c0cccc1d7cadce6 Mon Sep 17 00:00:00 2001
From: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
Date: Thu, 17 May 2012 15:56:04 +0000
Subject: [PATCH 187/518] dpa_offload use case : add IPsec offloading
 initialization

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |  182 ++++++++++++++++++++
 1 files changed, 182 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c

diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
new file mode 100644
index 0000000..325e5c9
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -0,0 +1,182 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fsl_dpa_ipsec.h>
+#include <linux/fsl_dpa_classifier.h>
+
+#include "platform_defs.h"
+#include "ports_conf.h"
+#include "genl_ctl.h"
+#include "common.h"
+
+#define IN_SA_PCD_HASH_OFF      0
+#define IN_SA_PCD_HASH_SETS     2
+#define CCNODE_MAX_NUM_OF_KEYS  16
+
+static struct dpa_ipsec_params ipsec_params;
+static int ipsec_initialized = 0;
+
+int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
+{
+	int i, j, cls_td;
+	struct dpa_cls_tbl_params cls_tbl_params;
+	int ret;
+	t_LnxWrpFmDev *fm_dev;
+	t_FmPcdParams pcd_params;
+
+	memset(&ipsec_params, 0, sizeof(ipsec_params));
+	memset(&pcd_params, 0, sizeof(pcd_params));
+
+	fm_dev = get_fm(FM);
+	if (!fm_dev) {
+		pr_err("%s(%d): Cannot get FM %d\n", __func__, __LINE__, FM);
+		return -EINVAL;
+	}
+
+	ipsec_params.max_sa_pairs = params->max_sa;
+
+	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
+	ipsec_params.ipf_bpid = params->ipf_bpid;
+	ipsec_params.qm_sec_ch = qm_channel_caam;
+
+	/* INB/DL pre SEC params */
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+	cls_tbl_params.cc_node = cc_in_rx;
+	cls_tbl_params.type = DPA_CLS_TBL_HASH;
+	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+	cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
+	cls_tbl_params.hash_params.max_ways = CCNODE_MAX_NUM_OF_KEYS;
+	cls_tbl_params.hash_params.num_sets = IN_SA_PCD_HASH_SETS;
+	cls_tbl_params.hash_params.key_size = MAX_SIZE_IP_UDP_SPI_KEY;
+	ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+	if (ret < 0) {
+		pr_err("%s:%d: error creating in sa lookup classif table\n",
+				__func__, __LINE__);
+		return ret;
+	}
+
+	ipsec_params.pre_sec_in_params.dpa_cls_td = cls_td;
+
+	/* INB/DL  post SEC params */
+	 /* data_off - SEC preheader burst size in bytes */
+	ipsec_params.post_sec_in_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
+	ipsec_params.post_sec_in_params.use_ipv6_pol = FALSE;
+	ipsec_params.post_sec_in_params.qm_tx_ch =
+			OH_PORT_CHANNEL(FM, DL_POST_IPSEC_OH);
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+	cls_tbl_params.cc_node = cc_flow_id;
+	cls_tbl_params.type = DPA_CLS_TBL_INDEXED;
+	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+	cls_tbl_params.indexed_params.entries_cnt = ipsec_params.max_sa_pairs;
+	ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+	if (ret < 0) {
+		pr_err("%s:%d: error creating in sa lookup classif table\n",
+				__func__, __LINE__);
+		goto out_inb_post_sec;
+	}
+
+	/* INB policy verification */
+	ipsec_params.post_sec_in_params.dpa_cls_td = cls_td;
+	ipsec_params.post_sec_in_params.do_pol_check = TRUE;
+	ipsec_params.post_sec_in_params.key_fields = DPA_IPSEC_KEY_FIELD_DPORT;
+
+	/* OUTB/UL post SEC params */
+	/* data_off - SEC preheader burst size in bytes */
+	ipsec_params.post_sec_out_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
+	ipsec_params.post_sec_out_params.qm_tx_ch =
+			OH_PORT_CHANNEL(FM, UL_POST_IPSEC_OH);
+
+	/* OUTB/UL pre SEC params */
+	for (i = 0; i < ARRAY_SIZE(cc_out_pre_enc); i++) {
+		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+		cls_tbl_params.cc_node = cc_out_pre_enc[i];
+		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+		cls_tbl_params.exact_match_params.entries_cnt =
+				ipsec_params.max_sa_pairs;
+		cls_tbl_params.exact_match_params.key_size =
+			MAX_SIZE_POLICY_KEY;
+		ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+		if (ret < 0) {
+			pr_err("%s:%d: error creating out sa lookup classif table\n",
+					__func__, __LINE__);
+			goto out_outb_pre_sec;
+		}
+
+		ipsec_params.pre_sec_out_params.dpa_cls_td[i] = cls_td;
+	}
+	ipsec_params.pre_sec_out_params.key_fields = DPA_IPSEC_KEY_FIELD_SIP |
+						  DPA_IPSEC_KEY_FIELD_DIP |
+						  DPA_IPSEC_KEY_FIELD_PROTO |
+						  DPA_IPSEC_KEY_FIELD_SPORT |
+						  DPA_IPSEC_KEY_FIELD_DPORT;
+	ret = dpa_ipsec_init(&ipsec_params, dpa_ipsec_id);
+	if (ret < 0) {
+		pr_err("%s:%d cannot initialize DPA IPsec\n",
+				__func__, __LINE__);
+		goto out_outb_pre_sec;
+	}
+	ipsec_initialized = 1;
+	return ret;
+
+out_outb_pre_sec:
+	for (j = 0; j < i; j++)
+		dpa_classif_table_free(ipsec_params.
+					pre_sec_out_params.dpa_cls_td[j]);
+
+out_inb_post_sec:
+		dpa_classif_table_free(ipsec_params.
+					pre_sec_in_params.dpa_cls_td);
+
+	return ret;
+}
+
+int cleanup_ipsec_offload(int dpa_ipsec_id)
+{
+
+	int i;
+	if (!ipsec_initialized)
+		return 0;
+	dpa_classif_table_free(ipsec_params.
+				pre_sec_in_params.dpa_cls_td);
+
+	for (i = 0; i < ARRAY_SIZE(cc_out_pre_enc); i++)
+		dpa_classif_table_free(ipsec_params.
+				pre_sec_out_params.dpa_cls_td[i]);
+	dpa_ipsec_free(dpa_ipsec_id);
+
+	return 0;
+}
-- 
1.7.5.4

