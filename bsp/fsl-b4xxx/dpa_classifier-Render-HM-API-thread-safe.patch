From 36039f50db6a0dbf18eed4c8e9b54c4d5ce8dbf7 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 12 Apr 2013 15:25:46 +0300
Subject: [PATCH 33/36] dpa_classifier: Render HM API thread safe

Added resource locks so that the HM API is now thread safe.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.3.0_ALPHA, of
https://git.freescale.com/git-private/cgit.cgi/ppc/dpaa-offload/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  486 ++++++++++------------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   14 +-
 2 files changed, 228 insertions(+), 272 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index bdaf666..ef54298 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -63,12 +63,43 @@
 #define dpa_cls_dbg(message)
 #endif /* DPA_CLASSIFIER_DEBUG */
 
+#define LOCK_OBJECT(desc_table, desc, object) \
+		lock_desc_table(&(desc_table)); \
+		(object) = desc_to_object(&(desc_table), (desc)); \
+		if (!(object)) { \
+			release_desc_table(&(desc_table)); \
+			pr_err("ERROR: %s, %s (%d): Invalid descriptor (%d).\n", \
+				__FILE__, __func__, __LINE__, (desc)); \
+			return -EINVAL; \
+		} \
+		mutex_lock(&(object)->access); \
+		release_desc_table(&(desc_table))
+
+#define RELEASE_OBJECT(object) \
+		mutex_unlock(&(object)->access)
+
+#define LOCK_HM_OP_CHAIN(hm) \
+	list_for_each_entry(pcurrent, \
+		&(hm)->list_node, \
+		list_node) { \
+			mutex_lock(&pcurrent->access); \
+	} \
+	mutex_lock(&(hm)->access)
+
+#define RELEASE_HM_OP_CHAIN(hm) \
+	list_for_each_entry(pcurrent, \
+		&(hm)->list_node, \
+		list_node) { \
+			mutex_unlock(&pcurrent->access); \
+	} \
+	mutex_unlock(&(hm)->access)
 
 DEFINE_MUTEX(table_array_lock);
 DEFINE_MUTEX(hm_array_lock);
 #if (DPAA_VERSION >= 11)
 DEFINE_MUTEX(mcast_array_lock);
 #endif
+
 /* DPA Classifier table descriptor table */
 struct dpa_cls_descriptor_table		table_array = {
 	.num_descriptors	= 0,
@@ -391,19 +422,10 @@ int dpa_classif_table_modify_miss_action(int			td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Miss Action for DPA Classifier "
 			"Indexed Tables (td=%d) is not supported.\n", __FILE__,
 			__func__, __LINE__, td);
@@ -414,7 +436,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 	errno = action_to_next_engine_params(miss_action, &miss_engine_params,
 		NULL, NULL, NULL);
 	if (errno < 0) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Failed verification of miss action "
 			"params for table td=%d.\n", __FILE__, __func__,
 			__LINE__, td);
@@ -425,7 +447,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 		err = FM_PCD_HashTableModifyMissNextEngine(ptable->params.
 			cc_node, &miss_engine_params);
 		if (err != E_OK) {
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_HashTableModifyMissNextEngine "
 				"(td=%d, Cc node handle=0x%p).\n", __FILE__,
@@ -437,7 +459,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 		err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 			int_cc_node[0].cc_node, &miss_engine_params);
 		if (err != E_OK) {
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableModifyMissNextEngine (td=%d, "
 				"Cc node handle=0x%p).\n", __FILE__, __func__,
@@ -446,7 +468,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 			return -EBUSY;
 		}
 	}
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
@@ -490,19 +512,10 @@ int dpa_classif_table_insert_entry(int				td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Insert entry in an indexed table "
 			"(td=%d) makes no sense. Please use modify_entry "
 			"instead.\n", __FILE__, __func__, __LINE__, td);
@@ -516,7 +529,7 @@ int dpa_classif_table_insert_entry(int				td,
 	 */
 	if ((ptable->shadow_table) &&
 			(find_shadow_entry(ptable, key) != NULL)) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry already "
 			"exists in table td=%d. Attempted to add twice the "
 			"following key (hex) (%d byte(s)):", __FILE__, __func__,
@@ -544,7 +557,7 @@ int dpa_classif_table_insert_entry(int				td,
 		BUG_ON(1);
 	}
 
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0) {
 		pr_err("ERROR: %s, %s (%d): Failed to insert entry in table "
 			"td=%d. Table type=%d. Lookup key was (hex) (%d "
@@ -603,21 +616,12 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 		(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
 			"on exact match tables. ", __FILE__, __func__,
 			__LINE__);
@@ -656,7 +660,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 					(t_Handle)ptable->params.
 							classification);
 				if (ret < 0) {
-					mutex_unlock(&ptable->access);
+					RELEASE_OBJECT(ptable);
 					pr_err("ERROR: %s, %s (%d): Failed "
 						"verification of new action "
 						"params while modifying entry "
@@ -684,7 +688,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				mask,
 				&key_params.ccNextEngineParams);
 			if (err != E_OK) {
-				mutex_unlock(&ptable->access);
+				RELEASE_OBJECT(ptable);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNModifyNextEngine"
@@ -704,7 +708,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				key_data,
 				&key_params.ccNextEngineParams);
 			if (err != E_OK) {
-				mutex_unlock(&ptable->access);
+				RELEASE_OBJECT(ptable);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_HashTableModifyNextEngine. "
@@ -744,7 +748,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 					(t_Handle)ptable->params.
 						classification);
 				if (ret < 0) {
-					mutex_unlock(&ptable->access);
+					RELEASE_OBJECT(ptable);
 					pr_err("ERROR: %s, %s (%d): Failed "
 						"verification of new action "
 						"params while modifying entry "
@@ -800,7 +804,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				new_key_data,
 				new_mask);
 			if (err != E_OK) {
-				mutex_unlock(&ptable->access);
+				RELEASE_OBJECT(ptable);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNModifyKey. "
@@ -824,7 +828,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				mask,
 				&key_params);
 			if (err != E_OK) {
-				mutex_unlock(&ptable->access);
+				RELEASE_OBJECT(ptable);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 		"FM_PCD_MatchTableFindNModifyKeyAndNextEngine. td=%d, Cc node "
 				"handle=0x%p, trying to modify entry w/ key "
@@ -840,10 +844,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				break;
 			}
 
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			return ret;
 		} else {
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			pr_err("ERROR: %s, %s (%d): Unable to determine "
 				"entry_id associated with this lookup key for "
 				"table td=%d. ", __FILE__, __func__, __LINE__,
@@ -856,7 +860,7 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 	}
 
 	ret = table_modify_entry_by_ref(ptable, entry_id, mod_params);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (ret < 0) {
 		pr_err("ERROR: %s, %s (%d): Failed to MODIFY entry by KEY in "
 			"table td=%d. Translated entry ref=%d. Lookup key was "
@@ -907,16 +911,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
@@ -930,7 +925,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	}
 
 	err = table_modify_entry_by_ref(ptable, entry_id, mod_params);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0)
 		pr_err("ERROR: %s, %s (%d): Failed to MODIFY entry by REF in "
 			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
@@ -1256,16 +1251,7 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 			ptable, key);
@@ -1294,7 +1280,7 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 				key_data,
 				mask);
 			if (error != E_OK) {
-				mutex_unlock(&ptable->access);
+				RELEASE_OBJECT(ptable);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNRemoveKey. "
@@ -1326,7 +1312,7 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 					key->size,
 					key_data);
 				if (error != E_OK) {
-					mutex_unlock(&ptable->access);
+					RELEASE_OBJECT(ptable);
 					pr_err("ERROR: %s, %s (%d): FMan "
 						"driver call failed - "
 						"FM_PCD_HashTableRemoveKey. "
@@ -1350,10 +1336,10 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 				break;
 			}
 
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			return err;
 		} else {
-			mutex_unlock(&ptable->access);
+			RELEASE_OBJECT(ptable);
 			pr_err("ERROR: %s, %s (%d): Unable to determine "
 				"entry_id associated with this lookup key (hex) "
 				"(%d bytes):", __FILE__, __func__, __LINE__,
@@ -1365,7 +1351,7 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 	}
 
 	err = table_delete_entry_by_ref(ptable, entry_id);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0) {
 		pr_err("ERROR: %s, %s (%d): Failed to DELETE entry by KEY in "
 			"table td=%d. Translated entry ref=%d. Lookup key was "
@@ -1390,19 +1376,10 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	err = table_delete_entry_by_ref(ptable, entry_id);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0)
 		pr_err("ERROR: %s, %s (%d): Failed to DELETE entry by REF in "
 			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
@@ -1559,19 +1536,10 @@ int dpa_classif_table_lookup_by_key(int				td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	if (!ptable->shadow_table) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup by key in a "
 			"DPA_CLS_TBL_MANAGE_BY_REF table (td=%d).\n", __FILE__,
 			__func__, __LINE__, td);
@@ -1580,7 +1548,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 
 	pos = find_shadow_entry(ptable, key);
 	if (!pos) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		return -ENODEV;
 	}
 
@@ -1598,7 +1566,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 			sizeof(struct dpa_cls_tbl_action));
 	}
 
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
@@ -1626,16 +1594,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	/* Parameters sanity checks: */
 	if ((entry_id < 0) || (entry_id >= ptable->entries_cnt)) {
@@ -1651,7 +1610,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	}
 
 	if (!ptable->shadow_table) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
 			"DPA_CLS_TBL_MANAGE_BY_REF table (td=%d).\n", __FILE__,
 			__func__, __LINE__, td);
@@ -1677,7 +1636,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 			sizeof(struct dpa_cls_tbl_action));
 	}
 
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
@@ -1694,19 +1653,10 @@ int dpa_classif_table_flush(int td)
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	err = flush_table(ptable);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0)
 		pr_err("ERROR: %s, %s (%d): Failed to flush table td=%d. Table "
 			"type=%d.\n", __FILE__, __func__, __LINE__, td,
@@ -1856,20 +1806,11 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	if ((ptable->params.type == DPA_CLS_TBL_HASH) &&
 			(ptable->params.prefilled_entries)) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		/* get_entry_stats not supported on prefilled HASH tables */
 		pr_err("ERROR: %s, %s (%d): get_entry_stats_by_key is not "
 			"supported on prefilled HASH tables (td=%d).\n",
@@ -1878,7 +1819,7 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	}
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
-		mutex_unlock(&ptable->access);
+		RELEASE_OBJECT(ptable);
 		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
 			"associated with this lookup key (hex) (%d byte(s)):",
 			__FILE__, __func__, __LINE__, key->size);
@@ -1888,7 +1829,7 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	}
 
 	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0) {
 		pr_err("ERROR: %s, %s (%d): Failed to get entry STATS by KEY "
 			"in table td=%d. Translated entry ref=%d. Lookup key "
@@ -1915,19 +1856,10 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 	if (err < 0)
 		pr_err("ERROR: %s, %s (%d): Failed to get entry STATS by REF in "
 			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
@@ -2000,20 +1932,11 @@ int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
 		return -EINVAL;
 	}
 
-	lock_desc_table(&table_array);
-	ptable = desc_to_object(&table_array, td);
-	if (!ptable) {
-		release_desc_table(&table_array);
-		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
-			__func__, __LINE__, td);
-		return -EINVAL;
-	}
-	mutex_lock(&ptable->access);
-	release_desc_table(&table_array);
+	LOCK_OBJECT(table_array, td, ptable);
 
 	memcpy(params, &ptable->params, sizeof(struct dpa_cls_tbl_params));
 
-	mutex_unlock(&ptable->access);
+	RELEASE_OBJECT(ptable);
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
@@ -4014,22 +3937,12 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 {
 	int err;
 	struct dpa_cls_hm *hm;
-	struct dpa_cls_hm *next_hm;
+	struct dpa_cls_hm *next_hm, *pcurrent;
 
 	BUG_ON(!hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	if (next_hmd != DPA_OFFLD_DESC_NONE)
-		/* Check whether [next_hmd] is a valid descriptor */
-		if ((next_hmd < 0) || (next_hmd >= hm_array.num_descriptors)) {
-			pr_err("ERROR: %s, %s (%d): Invalid next HM descriptor "
-				"(next_hmd=%d). Should be between %d and %d.\n",
-				__FILE__, __func__, __LINE__, next_hmd, 0,
-				hm_array.num_descriptors-1);
-			return -EINVAL;
-		}
-
 	/* Allocate header manipulation object */
 	hm = kzalloc(sizeof(struct dpa_cls_hm), GFP_KERNEL);
 	if (!hm) {
@@ -4038,32 +3951,49 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 		return -ENOMEM;
 	}
 
+	lock_desc_table(&hm_array);
 	err = acquire_descriptor(&hm_array, hm, hmd);
 	if (err < 0)
 		return err;
 
 	INIT_LIST_HEAD(&hm->list_node);
 
+	mutex_init(&hm->access);
+	mutex_lock(&hm->access);
+
 	if (next_hmd != DPA_OFFLD_DESC_NONE) {
-		/*
-		 * In case this high level op is chained with another high
-		 * level op, add it to the list.
-		 */
+		/* Check whether [next_hmd] is a valid descriptor */
+		if ((next_hmd < 0) || (next_hmd >= hm_array.num_descriptors)) {
+			release_desc_table(&hm_array);
+			pr_err("ERROR: %s, %s (%d): Invalid next HM descriptor "
+				"(next_hmd=%d). Should be between %d and %d.\n",
+				__FILE__, __func__, __LINE__, next_hmd, 0,
+				hm_array.num_descriptors-1);
+			return -EINVAL;
+		}
 		next_hm = (struct dpa_cls_hm *)hm_array.object[next_hmd];
-
 		if (!next_hm) {
+			release_desc_table(&hm_array);
 			pr_err("ERROR: %s, %s (%d): Link to an invalid HM "
 				"(next_hmd=%d).\n", __FILE__, __func__,
 				__LINE__, next_hmd);
-			remove_hm_op(*hmd);
-			*hmd = DPA_OFFLD_DESC_NONE;
 			return -EINVAL;
 		}
 
+		/* Lock entire high level HM op chain */
+		LOCK_HM_OP_CHAIN(next_hm);
+		release_desc_table(&hm_array);
+
+		/*
+		 * In case this high level op is chained with another high
+		 * level op, add it to the list.
+		 */
+
 		list_add_tail(&hm->list_node, &next_hm->list_node);
 
 		hm->hm_chain = next_hm->hm_chain;
-	} else {
+	} else { /* Isolated header manip op, or first in chain. */
+		release_desc_table(&hm_array);
 		hm->hm_chain = kmalloc(sizeof(struct list_head), GFP_KERNEL);
 		if (!hm->hm_chain) {
 			pr_err("ERROR: %s, %s (%d): No more memory for header "
@@ -4081,23 +4011,35 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 
 static void remove_hm_op(int hmd)
 {
-	struct dpa_cls_hm *phm;
+	struct dpa_cls_hm *phm, *pcurrent, *pnext;
 
+	lock_desc_table(&hm_array);
 	BUG_ON((hmd < 0) || (hmd >= hm_array.num_descriptors));
 
 	phm = (struct dpa_cls_hm *) hm_array.object[hmd];
 
-	if (!phm)
+	if (!phm) {
 		/* Descriptor already free. Nothing to do */
+		release_desc_table(&hm_array);
 		return;
+	}
 
 	if (list_empty(&phm->list_node))
 		kfree(phm->hm_chain);
-	else
+	else {
+		LOCK_HM_OP_CHAIN(phm);
+
+		pnext = list_entry(phm->list_node.next,
+					struct dpa_cls_hm,
+					list_node);
 		/* If this op is attached to others, detach it from the list */
 		list_del(&phm->list_node);
 
+		RELEASE_HM_OP_CHAIN(pnext);
+	}
+
 	put_descriptor(&hm_array, hmd);
+	release_desc_table(&hm_array);
 
 	kfree(phm);
 }
@@ -4109,7 +4051,7 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 			const struct dpa_cls_hm_nat_resources	*res)
 {
 	int err;
-	struct dpa_cls_hm *pnat_hm;
+	struct dpa_cls_hm *pnat_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -4175,6 +4117,9 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pnat_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -4182,6 +4127,9 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 
 nat_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pnat_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -4479,21 +4427,11 @@ int dpa_classif_modify_nat_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pnat_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pnat_hm);
 
 	if (pnat_hm->type != DPA_CLS_HM_TYPE_NAT) {
+		RELEASE_OBJECT(pnat_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an NAT type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -4503,6 +4441,7 @@ int dpa_classif_modify_nat_hm(int hmd,
 		if (modify_flags & DPA_CLS_HM_NAT_MOD_SIP) {
 			if (new_nat_params->nat.sip.version !=
 					pnat_hm->nat_params.nat.sip.version) {
+				RELEASE_OBJECT(pnat_hm);
 				pr_err("ERROR: %s, %s (%d): New SIP adress "
 					"version (%d) in NAT header "
 					"manipulation hmd=%d cannot be "
@@ -4521,6 +4460,7 @@ int dpa_classif_modify_nat_hm(int hmd,
 		if (modify_flags & DPA_CLS_HM_NAT_MOD_DIP) {
 			if (new_nat_params->nat.dip.version !=
 					pnat_hm->nat_params.nat.dip.version) {
+				RELEASE_OBJECT(pnat_hm);
 				pr_err("ERROR: %s, %s (%d): New DIP adress "
 					"version (%d) in NAT header "
 					"manipulation hmd=%d cannot be "
@@ -4558,6 +4498,7 @@ int dpa_classif_modify_nat_hm(int hmd,
 						pnat_hm->nat_params.nat_pt.
 							new_header.ipv4.
 							options_size = 0;
+						RELEASE_OBJECT(pnat_hm);
 						pr_err("ERROR: %s, %s (%d): "
 							"Out of memory while "
 							"modifying IPv6 header "
@@ -4624,6 +4565,7 @@ int dpa_classif_modify_nat_hm(int hmd,
 				error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 				if (error != E_OK) {
+					RELEASE_OBJECT(pnat_hm);
 					pr_err("ERROR: %s, %s (%d): FMan "
 						"driver call failed - "
 						"FM_PCD_ManipNodeReplace, "
@@ -4638,6 +4580,8 @@ int dpa_classif_modify_nat_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(pnat_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -4652,7 +4596,7 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 			const struct dpa_cls_hm_fwd_resources	*res)
 {
 	int err;
-	struct dpa_cls_hm *pfwd_hm;
+	struct dpa_cls_hm *pfwd_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -4718,6 +4662,9 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pfwd_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -4725,6 +4672,9 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 
 fwd_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pfwd_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -4933,21 +4883,11 @@ int dpa_classif_modify_fwd_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pfwd_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pfwd_hm);
 
 	if (pfwd_hm->type != DPA_CLS_HM_TYPE_FORWARDING) {
+		RELEASE_OBJECT(pfwd_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an FORWARDING type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -5052,6 +4992,7 @@ int dpa_classif_modify_fwd_hm(int hmd,
 				error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 				if (error != E_OK) {
+					RELEASE_OBJECT(pfwd_hm);
 					pr_err("ERROR: %s, %s (%d): FMan "
 						"driver call failed - "
 						"FM_PCD_ManipNodeReplace, "
@@ -5066,6 +5007,8 @@ int dpa_classif_modify_fwd_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(pfwd_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5078,7 +5021,7 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	const struct dpa_cls_hm_remove_resources *res)
 {
 	int err;
-	struct dpa_cls_hm *premove_hm;
+	struct dpa_cls_hm *premove_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -5145,6 +5088,9 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(premove_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5152,6 +5098,9 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 
 remove_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(premove_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -5278,21 +5227,11 @@ int dpa_classif_modify_remove_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	premove_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, premove_hm);
 
 	if (premove_hm->type != DPA_CLS_HM_TYPE_REMOVE) {
+		RELEASE_OBJECT(premove_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an REMOVE type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -5337,6 +5276,7 @@ int dpa_classif_modify_remove_hm(int hmd,
 			error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 			if (error != E_OK) {
+				RELEASE_OBJECT(premove_hm);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_ManipNodeReplace, "
 					"while trying to modify hmd=%d, manip "
@@ -5347,6 +5287,8 @@ int dpa_classif_modify_remove_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(premove_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5359,7 +5301,7 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	const struct dpa_cls_hm_insert_resources *res)
 {
 	int err;
-	struct dpa_cls_hm *pinsert_hm;
+	struct dpa_cls_hm *pinsert_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -5426,6 +5368,9 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pinsert_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5433,6 +5378,9 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 
 insert_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pinsert_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -5608,21 +5556,11 @@ int dpa_classif_modify_insert_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pinsert_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pinsert_hm);
 
 	if (pinsert_hm->type != DPA_CLS_HM_TYPE_INSERT) {
+		RELEASE_OBJECT(pinsert_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an INSERT type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -5633,6 +5571,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 		DPA_CLS_HM_INS_MOD_PPPoE_HEADER;
 	if ((modify_flags & mask) && (pinsert_hm->insert_params.type !=
 			DPA_CLS_HM_INSERT_ETHERNET)) {
+		RELEASE_OBJECT(pinsert_hm);
 		pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't work on "
 			"hmd=%d. It only works on INSERT ETHERNET header "
 			"manipulations.\n", __FILE__, __func__, __LINE__,
@@ -5644,6 +5583,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 		DPA_CLS_HM_INS_MOD_CUSTOM_DATA;
 	if ((modify_flags & mask) && (pinsert_hm->insert_params.type !=
 			DPA_CLS_HM_INSERT_CUSTOM)) {
+		RELEASE_OBJECT(pinsert_hm);
 		pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't work on "
 			"hmd=%d. It only works on CUSTOM INSERT header "
 			"manipulations.\n", __FILE__, __func__, __LINE__,
@@ -5656,6 +5596,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 					new_insert_params->ppp_pid)) {
 		if (pinsert_hm->insert_params.type !=
 						DPA_CLS_HM_INSERT_PPP) {
+			RELEASE_OBJECT(pinsert_hm);
 			pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't "
 				"work on hmd=%d. It only works on INSERT PPP "
 				"header manipulations.\n", __FILE__, __func__,
@@ -5687,6 +5628,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 		update = true;
 		pdata = kzalloc(new_insert_params->custom.size, GFP_KERNEL);
 		if (!pdata) {
+			RELEASE_OBJECT(pinsert_hm);
 			pr_err("ERROR: %s, %s (%d): Not enough memory to "
 				"adjust custom insert header manipulation.\n",
 				__FILE__, __func__, __LINE__);
@@ -5736,6 +5678,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 			error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 			if (error != E_OK) {
+				RELEASE_OBJECT(pinsert_hm);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_ManipNodeReplace, "
 					"while trying to modify hmd=%d, manip "
@@ -5746,6 +5689,8 @@ int dpa_classif_modify_insert_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(pinsert_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5758,7 +5703,7 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	const struct dpa_cls_hm_update_resources *res)
 {
 	int err;
-	struct dpa_cls_hm *pupdate_hm;
+	struct dpa_cls_hm *pupdate_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -5825,6 +5770,9 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pupdate_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -5832,6 +5780,9 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 
 update_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pupdate_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -6221,21 +6172,11 @@ int dpa_classif_modify_update_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pupdate_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pupdate_hm);
 
 	if (pupdate_hm->type != DPA_CLS_HM_TYPE_UPDATE) {
+		RELEASE_OBJECT(pupdate_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an UPDATE type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -6265,6 +6206,7 @@ int dpa_classif_modify_update_hm(int hmd,
 					new_ipv4_hdr.options) {
 					pupdate_hm->update_params.replace.
 						new_ipv4_hdr.options_size = 0;
+					RELEASE_OBJECT(pupdate_hm);
 					pr_err("ERROR: %s, %s (%d): Out of "
 						"memory while modifying IPv6 "
 						"header replace header "
@@ -6280,6 +6222,7 @@ int dpa_classif_modify_update_hm(int hmd,
 				options_size = new_update_params->replace.
 				new_ipv4_hdr.options_size;
 		} else {
+			RELEASE_OBJECT(pupdate_hm);
 			pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't "
 				"work on hmd=%d. It only works on REPLACE "
 				"header manipulations.\n", __FILE__, __func__,
@@ -6296,6 +6239,7 @@ int dpa_classif_modify_update_hm(int hmd,
 			if (new_update_params->update.l3.ipsa.version !=
 				pupdate_hm->update_params.update.l3.ipsa.
 				version) {
+				RELEASE_OBJECT(pupdate_hm);
 				pr_err("ERROR: %s, %s (%d): New SIP adress "
 					"version (%d) in UPDATE header "
 					"manipulation hmd=%d cannot be "
@@ -6316,6 +6260,7 @@ int dpa_classif_modify_update_hm(int hmd,
 			if (new_update_params->update.l3.ipda.version !=
 				pupdate_hm->update_params.update.l3.ipda.
 				version) {
+				RELEASE_OBJECT(pupdate_hm);
 				pr_err("ERROR: %s, %s (%d): New DIP adress "
 					"version (%d) in UPDATE header "
 					"manipulation hmd=%d cannot be "
@@ -6401,6 +6346,7 @@ int dpa_classif_modify_update_hm(int hmd,
 			error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 			if (error != E_OK) {
+				RELEASE_OBJECT(pupdate_hm);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_ManipNodeReplace, "
 					"while trying to modify hmd=%d, manip "
@@ -6413,6 +6359,8 @@ int dpa_classif_modify_update_hm(int hmd,
 
 	/* update[1] not supported at this time */
 
+	RELEASE_OBJECT(pupdate_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -6427,7 +6375,7 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 			const struct dpa_cls_hm_vlan_resources	*res)
 {
 	int err;
-	struct dpa_cls_hm *pvlan_hm;
+	struct dpa_cls_hm *pvlan_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -6493,6 +6441,9 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pvlan_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -6500,6 +6451,9 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 
 vlan_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pvlan_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -6692,21 +6646,11 @@ int dpa_classif_modify_vlan_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pvlan_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pvlan_hm);
 
 	if (pvlan_hm->type != DPA_CLS_HM_TYPE_VLAN) {
+		RELEASE_OBJECT(pvlan_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an VLAN type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -6714,6 +6658,7 @@ int dpa_classif_modify_vlan_hm(int hmd,
 
 	if (modify_flags == DPA_CLS_HM_VLAN_MOD_INGRESS_NUM_QTAGS) {
 		if (pvlan_hm->vlan_params.type != DPA_CLS_HM_VLAN_INGRESS) {
+			RELEASE_OBJECT(pvlan_hm);
 			pr_err("ERROR: %s, %s (%d): hmd=%d is not an INGRESS "
 				"VLAN type header manipulation.\n", __FILE__,
 				__func__, __LINE__, hmd);
@@ -6728,6 +6673,7 @@ int dpa_classif_modify_vlan_hm(int hmd,
 		}
 	} else {
 		if (pvlan_hm->vlan_params.type != DPA_CLS_HM_VLAN_EGRESS) {
+			RELEASE_OBJECT(pvlan_hm);
 			pr_err("ERROR: %s, %s (%d): hmd=%d is not an EGRESS "
 				"VLAN type header manipulation.\n", __FILE__,
 				__func__, __LINE__, hmd);
@@ -6788,6 +6734,7 @@ int dpa_classif_modify_vlan_hm(int hmd,
 			error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 			if (error != E_OK) {
+				RELEASE_OBJECT(pvlan_hm);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_ManipNodeReplace, "
 					"while trying to modify hmd=%d, manip "
@@ -6798,6 +6745,8 @@ int dpa_classif_modify_vlan_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(pvlan_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -6812,7 +6761,7 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 			const struct dpa_cls_hm_mpls_resources	*res)
 {
 	int err;
-	struct dpa_cls_hm *pmpls_hm;
+	struct dpa_cls_hm *pmpls_hm, *pcurrent;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -6878,6 +6827,9 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 				__LINE__);
 	}
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pmpls_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
@@ -6885,6 +6837,9 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 
 mpls_hm_error:
 
+	/* Release the high level HM op chain */
+	RELEASE_HM_OP_CHAIN(pmpls_hm);
+
 	remove_hm_op(*hmd);
 
 	*hmd = DPA_OFFLD_DESC_NONE;
@@ -7027,21 +6982,11 @@ int dpa_classif_modify_mpls_hm(int hmd,
 			"NULL.\n", __FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
-	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
-			"Should be between %d and %d.\n", __FILE__, __func__,
-			__LINE__, hmd, 0, hm_array.num_descriptors-1);
-		return -EINVAL;
-	}
-	if (!hm_array.object[hmd]) {
-		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
-			__FILE__, __func__, __LINE__, hmd);
-		return -EINVAL;
-	}
 
-	pmpls_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+	LOCK_OBJECT(hm_array, hmd, pmpls_hm);
 
 	if (pmpls_hm->type != DPA_CLS_HM_TYPE_MPLS) {
+		RELEASE_OBJECT(pmpls_hm);
 		pr_err("ERROR: %s, %s (%d): hmd=%d is not an MPLS type "
 			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
@@ -7080,6 +7025,7 @@ int dpa_classif_modify_mpls_hm(int hmd,
 			error = FM_PCD_ManipNodeReplace(hm_node->node,
 							&new_hm_node_params);
 			if (error != E_OK) {
+				RELEASE_OBJECT(pmpls_hm);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_ManipNodeReplace, "
 					"while trying to modify hmd=%d, manip "
@@ -7090,6 +7036,8 @@ int dpa_classif_modify_mpls_hm(int hmd,
 		}
 	}
 
+	RELEASE_OBJECT(pmpls_hm);
+
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 30805c0..c988f17 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -142,10 +142,10 @@ struct dpa_cls_tbl_shadow_entry_indexed {
 struct dpa_cls_tbl_shadow_table {
 
 	/* Shadow table sets (buckets) */
-	struct list_head	*shadow_entry;
+	struct list_head		*shadow_entry;
 
 	/* The size of the shadow table in number of sets (buckets) */
-	unsigned int		size;
+	unsigned int			size;
 };
 
 /* Internal FMan Cc Node Management Info */
@@ -322,7 +322,14 @@ struct dpa_cls_hm {
 	 * chain
 	 */
 	struct list_head		list_node;
+
+	/*
+	 * Access control object for this header manipulation op to avoid race
+	 * conditions.
+	 */
+	struct mutex			access;
 };
+
 #if (DPAA_VERSION >= 11)
 struct dpa_cls_mcast_group {
 	/*
@@ -363,7 +370,8 @@ struct dpa_cls_mcast_group {
 	/* Access control object for the group to avoid race conditions. */
 	struct mutex				access;
 };
-#endif
+#endif /* (DPAA_VERSION >= 11) */
+
 #ifdef __DPA_CLASSIFIER_C
 /*
  * Allocates the array of internally managed Cc nodes based on
-- 
1.7.5.4

