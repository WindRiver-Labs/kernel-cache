From 1a94d0be3540da6266efe5a2a5f648ef0e6c7f4a Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:10:25 +0000
Subject: [PATCH 2/7] dpa_classifier: Add support for runtime modification of Forwarding type header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  163 ++++++++++++++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    6 -
 2 files changed, 154 insertions(+), 15 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 81a5ae0..5a825af 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -4542,13 +4542,9 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 	uint8_t *pdata;
 
 	BUG_ON(!pfwd_hm);
+	BUG_ON(pfwd_hm->num_nodes < 1);
+	BUG_ON(!pfwd_hm->hm_node[0]);
 
-	if ((pfwd_hm->num_nodes < 1) || (!pfwd_hm->hm_node[0])) {
-		pr_err("ERROR: %s, %s (%d): Inconsistency between resources "
-			"and provided parameters.\n", __FILE__, __func__,
-			__LINE__);
-		return -EINVAL;
-	}
 	hm_node = pfwd_hm->hm_node[0];
 
 	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
@@ -4620,6 +4616,7 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 	}
 
 	hm_node = pfwd_hm->hm_node[1];
+
 	if (pfwd_hm->fwd_params.ip_frag_params.mtu) {
 		/* IP fragmentation option is enabled */
 		BUG_ON(!hm_node);
@@ -4655,9 +4652,157 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 int dpa_classif_modify_fwd_hm(int hmd,
 	const struct dpa_cls_hm_fwd_params *new_fwd_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
-		__LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pfwd_hm;
+	bool update[3] = { false, false, false };
+	t_Error error;
+	int ret = 0;
+	int i;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	/* Parameters sanity checks: */
+	if (!new_fwd_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_fwd_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	pfwd_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pfwd_hm->type != DPA_CLS_HM_TYPE_FORWARDING) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an FORWARDING type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	if (modify_flags & DPA_CLS_HM_FWD_MOD_ETH_MACSA) {
+		if (pfwd_hm->fwd_params.out_if_type ==
+						DPA_CLS_HM_IF_TYPE_PPPoE) {
+			memcpy(pfwd_hm->fwd_params.pppoe.l2.macsa,
+				new_fwd_params->pppoe.l2.macsa,
+				ETH_ALEN);
+			update[0] = true;
+		}
+
+		if (pfwd_hm->fwd_params.out_if_type ==
+						DPA_CLS_HM_IF_TYPE_ETHERNET) {
+			memcpy(pfwd_hm->fwd_params.eth.macsa,
+				new_fwd_params->eth.macsa,
+				ETH_ALEN);
+			update[0] = true;
+		}
+	}
+
+	if (modify_flags & DPA_CLS_HM_FWD_MOD_ETH_MACDA) {
+		if (pfwd_hm->fwd_params.out_if_type ==
+						DPA_CLS_HM_IF_TYPE_PPPoE) {
+			memcpy(pfwd_hm->fwd_params.pppoe.l2.macda,
+				new_fwd_params->pppoe.l2.macda,
+				ETH_ALEN);
+			update[0] = true;
+		}
+
+		if (pfwd_hm->fwd_params.out_if_type ==
+						DPA_CLS_HM_IF_TYPE_ETHERNET) {
+			memcpy(pfwd_hm->fwd_params.eth.macda,
+				new_fwd_params->eth.macda,
+				ETH_ALEN);
+			update[0] = true;
+		}
+	}
+
+	if ((modify_flags & DPA_CLS_HM_FWD_MOD_PPPoE_HEADER) &&
+		(pfwd_hm->fwd_params.out_if_type == DPA_CLS_HM_IF_TYPE_PPPoE)) {
+		update[1] = true;
+		memcpy(&pfwd_hm->fwd_params.pppoe.pppoe_header,
+			&new_fwd_params->pppoe.pppoe_header,
+			sizeof(struct pppoe_header));
+	}
+
+	if ((modify_flags & DPA_CLS_HM_FWD_MOD_PPP_PID) &&
+		(pfwd_hm->fwd_params.out_if_type == DPA_CLS_HM_IF_TYPE_PPP) &&
+		(pfwd_hm->fwd_params.ppp.ppp_pid !=
+						new_fwd_params->ppp.ppp_pid)) {
+		update[0] = true;
+		pfwd_hm->fwd_params.ppp.ppp_pid = new_fwd_params->ppp.ppp_pid;
+	}
+
+	if (pfwd_hm->fwd_params.ip_frag_params.mtu) {
+		if ((modify_flags & DPA_CLS_HM_FWD_MOD_IP_FRAG_MTU) &&
+			(pfwd_hm->fwd_params.ip_frag_params.mtu !=
+					new_fwd_params->ip_frag_params.mtu)) {
+			pfwd_hm->fwd_params.ip_frag_params.mtu =
+					new_fwd_params->ip_frag_params.mtu;
+			update[2] = true;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_FWD_MOD_IP_FRAG_SCRATCH_BPID) &&
+			(pfwd_hm->fwd_params.ip_frag_params.scratch_bpid !=
+				new_fwd_params->ip_frag_params.scratch_bpid)) {
+			pfwd_hm->fwd_params.ip_frag_params.scratch_bpid =
+				new_fwd_params->ip_frag_params.scratch_bpid;
+			update[2] = true;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_FWD_MOD_IP_FRAG_DF_ACTION) &&
+			(pfwd_hm->fwd_params.ip_frag_params.df_action !=
+				new_fwd_params->ip_frag_params.df_action)) {
+			pfwd_hm->fwd_params.ip_frag_params.df_action =
+				new_fwd_params->ip_frag_params.df_action;
+			update[2] = true;
+		}
+	}
+
+	if (update[0] || update[1] || update[2]) {
+		ret = fwd_hm_update_params(pfwd_hm);
+		if (ret == 0) {
+			t_FmPcdManipParams new_hm_node_params;
+
+			for (i = 0; i < 3; i++) {
+				if (!update[i])
+					continue;
+
+				hm_node = pfwd_hm->hm_node[i];
+				memcpy(&new_hm_node_params,
+					&hm_node->params,
+					sizeof(t_FmPcdManipParams));
+				/*
+				 * Must make sure that h_NextManip is NULL
+				 * before calling FM_PCD_ManipNodeReplace
+				 */
+				new_hm_node_params.h_NextManip = NULL;
+				error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&new_hm_node_params);
+				if (error != E_OK) {
+					pr_err("ERROR: %s, %s (%d): FMan "
+						"driver call failed - "
+						"FM_PCD_ManipNodeReplace, "
+						"while trying to modify "
+						"hmd=%d, manip node "
+						"handle=0x%p (node #%d).\n",
+						__FILE__, __func__, __LINE__,
+						hmd, hm_node->node, i);
+					return -EBUSY;
+				}
+			}
+		}
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_fwd_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index fc96d30..9ae9440 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1408,12 +1408,6 @@ static long do_ioctl_modify_fwd_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d)\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.fwd_params.fm_pcd = translate_fm_pcd_handle(kparam.fwd_params.
-								fm_pcd);
-	if (!kparam.fwd_params.fm_pcd)
-		return -EINVAL;
-
 	return dpa_classif_modify_fwd_hm(kparam.hmd, &kparam.fwd_params,
 					kparam.modify_flags);
 }
-- 
1.7.0.2

