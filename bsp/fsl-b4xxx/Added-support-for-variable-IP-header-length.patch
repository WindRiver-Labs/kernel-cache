From e8e21107a95d00e326caa2aff763221a88e4d0a2 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Thu, 17 May 2012 20:55:22 +0000
Subject: [PATCH 148/518] Added support for variable IP header length

Added support for variable IP header length:
frames belonging to one IPSec SA may have different IP header length

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   70 +++++++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    2 +
 include/linux/fsl_dpa_ipsec.h               |    1 +
 3 files changed, 70 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 037c79e..f387b81 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1130,7 +1130,48 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	return 0;
 }
 
-static int destroy_frag_manip(struct dpa_ipsec *dpa_ipsec,
+static int create_ipsec_manip(struct dpa_ipsec *dpa_ipsec,
+			     struct dpa_ipsec_sa *sa,
+			     struct dpa_cls_tbl_header_manip **hm)
+{
+	t_FmPcdManipParams	pcd_manip_params;
+
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
+		return -EFAULT;
+	}
+
+	if (!sa) {
+		xx_pr_err("Invalid argument: NULL sa handle\n");
+		return -EFAULT;
+	}
+
+	if (!hm) {
+		xx_pr_err("Invalid argument: NULL manip holder\n");
+		return -EFAULT;
+	}
+
+	memset(&pcd_manip_params, 0, sizeof(struct t_FmPcdManipParams));
+	pcd_manip_params.type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD;
+	pcd_manip_params.u.specialOffload.type =
+					e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC;
+	pcd_manip_params.u.specialOffload.u.ipsec.decryption = TRUE;
+	pcd_manip_params.u.specialOffload.u.ipsec.variableIpHdrLen =
+							sa->use_var_iphdr_len;
+	pcd_manip_params.u.specialOffload.u.ipsec.ecnCopy = FALSE;
+	pcd_manip_params.u.specialOffload.u.ipsec.dscpCopy = FALSE;
+
+	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
+	if (!*hm) {
+		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_ManipSetNode");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int destroy_manip(struct dpa_ipsec *dpa_ipsec,
 			      struct dpa_cls_tbl_header_manip *hm)
 {
 	t_Error fmd_err;
@@ -1329,7 +1370,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		}
 
 		if (policy_entry->hm) {
-			err = destroy_frag_manip(dpa_ipsec, policy_entry->hm);
+			err = destroy_manip(dpa_ipsec, policy_entry->hm);
 			if (err < 0) {
 				xx_pr_err("Couldn't delete frag manip\n");
 				return err;
@@ -1370,6 +1411,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_params tbl_params;
 	struct dpa_cls_tbl_entry_mod_params mod_params;
 	int offset, err = 0, tbl_key_size = 0, i;
+	struct dpa_cls_tbl_header_manip *hm = NULL;
 	uint8_t *key, *mask;
 
 	/* sanity checks */
@@ -1444,10 +1486,22 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		 */
 		memset(mask, 0xFF, offset);
 
+		/* Configure support for variable IP header length */
+		if (sa->use_var_iphdr_len) {
+			err = create_ipsec_manip(dpa_ipsec, sa, &hm);
+			if (err < 0) {
+				xx_pr_err("Could not create Manip node !\n");
+				return -EAGAIN;
+			}
+		}
+
+		/* Store the header manipulation into the SA */
+		sa->hm = hm;
+
 		/* Complete the parameters for table insert function */
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-			qman_fq_fqid((sa->to_sec_fq)), NULL);
+			qman_fq_fqid((sa->to_sec_fq)), sa->hm);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
@@ -1465,6 +1519,15 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 			xx_pr_err("Could not remove key for inbound SA!\n");
 			return err;
 		}
+
+		if (sa->hm) {
+			err = destroy_manip(dpa_ipsec, sa->hm);
+			if (err < 0) {
+				xx_pr_err("Couldn't delete ipsec manip\n");
+				return err;
+			}
+		}
+
 		sa->inbound_hash_entry = -1;
 		break;
 
@@ -1984,6 +2047,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	sa->use_udp_encap = sa_params->sa_in_params.use_udp_encap;
 	sa->udp_src_port  = sa_params->sa_in_params.src_port;
 	sa->udp_dest_port = sa_params->sa_in_params.dest_port;
+	sa->use_var_iphdr_len = sa_params->sa_in_params.use_var_iphdr_len;
 
 	memcpy(&sa->def_sa_action,
 	       &sa_params->sa_in_params.post_ipsec_action,
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index c98cc1a..0b6e20c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -254,6 +254,8 @@ struct dpa_ipsec_sa {
 	struct list_head sa_rekeying_node; /* Only used for inbound rekeying  */
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
+	int use_var_iphdr_len; /* Enable variable IP header length support    */
+	struct dpa_cls_tbl_header_manip *hm;	/* Header manipulation        */
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 };
 
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 6851ab7..89ed38b 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -298,6 +298,7 @@ struct dpa_ipsec_sa_out_params {
 /* DPA-IPSec Security Association In Parameters */
 struct dpa_ipsec_sa_in_params {
 	enum dpa_ipsec_arw arw;	/* Anti replay window			      */
+	int use_var_iphdr_len; /* Enable variable IP header length support    */
 	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
 	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
 	int use_udp_encap;	/* NAT-T is activated (UDP encapsulated ESP)  */
-- 
1.7.5.4

