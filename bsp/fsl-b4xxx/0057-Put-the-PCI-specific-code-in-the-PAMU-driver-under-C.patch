From ef6a3fffb5955fa74e454e9eeaa37738b141b5b8 Mon Sep 17 00:00:00 2001
From: Varun Sethi <Varun.Sethi@freescale.com>
Date: Fri, 12 Jul 2013 18:38:24 +0530
Subject: [PATCH 057/130] Put the PCI specific code in the PAMU driver under
 CONFIG_PCI.

This fixes the problem where the kernel build breaks, when PCI
support is disabled.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: I698626ec0a40ba81ef132890bc339c6be10d8673
Reviewed-on: http://git.am.freescale.net:8181/3282
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Fetch from http://git.freescale.com/git/cgit.cgi/ppc/sdk/linux.git/,
 Tag: fsl-sdk-v1.4.5
 rebase on current context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/iommu/fsl_pamu_domain.c |   28 ++++++++++++++++++++--------
 1 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 781d1ca..99c182d 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -697,6 +697,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 	const u32 *liodn;
 	u32 liodn_cnt;
 	int len, ret = 0;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = NULL;
 	struct pci_controller *pci_ctl;
 
@@ -714,6 +715,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	liodn = of_get_property(dev->of_node, "fsl,liodn", &len);
 	if (liodn) {
@@ -735,6 +737,7 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 	struct fsl_dma_domain *dma_domain = domain->priv;
 	const u32 *prop;
 	int len;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = NULL;
 	struct pci_controller *pci_ctl;
 
@@ -752,6 +755,7 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	prop = of_get_property(dev->of_node, "fsl,liodn", &len);
 	if (prop)
@@ -995,12 +999,6 @@ static int fsl_pamu_get_domain_attr(struct iommu_domain *domain,
 	return ret;
 }
 
-static void swap_pci_ref(struct pci_dev **from, struct pci_dev *to)
-{
-	pci_dev_put(*from);
-	*from = to;
-}
-
 static struct iommu_group *get_device_iommu_group(struct device *dev)
 {
 	struct iommu_group *group;
@@ -1012,6 +1010,13 @@ static struct iommu_group *get_device_iommu_group(struct device *dev)
 	return group;
 }
 
+#ifdef CONFIG_PCI
+static void swap_pci_ref(struct pci_dev **from, struct pci_dev *to)
+{
+	pci_dev_put(*from);
+	*from = to;
+}
+
 static  bool check_pci_ctl_endpt_part(struct pci_controller *pci_ctl)
 {
 	u32 version;
@@ -1108,12 +1113,14 @@ static struct iommu_group *get_pci_device_group(struct pci_dev *pdev)
 
 	return group;
 }
+#endif
 
 static int fsl_pamu_add_device(struct device *dev)
 {
 	struct iommu_group *group = NULL;
-	struct pci_dev *pdev;
 	int ret;
+#ifdef CONFIG_PCI
+	struct pci_dev *pdev;
 
 	/*
 	 * For platform devices we allocate a separate group for
@@ -1128,6 +1135,7 @@ static int fsl_pamu_add_device(struct device *dev)
 		group = get_pci_device_group(pdev);
 
 	} else
+#endif
 		group = get_device_iommu_group(dev);
 
 	if (!group || IS_ERR(group))
@@ -1213,8 +1221,9 @@ static u32 fsl_pamu_get_windows(struct iommu_domain *domain)
 
 static struct iommu_domain *fsl_get_dev_domain(struct device *dev)
 {
-	struct pci_controller *pci_ctl;
 	struct device_domain_info *info;
+#ifdef CONFIG_PCI
+	struct pci_controller *pci_ctl;
 	struct pci_dev *pdev;
 
 	/*
@@ -1232,6 +1241,7 @@ static struct iommu_domain *fsl_get_dev_domain(struct device *dev)
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	info = dev->archdata.iommu_domain;
 	if (info && info->domain)
@@ -1267,7 +1277,9 @@ int pamu_domain_init()
 		return ret;
 
 	bus_set_iommu(&platform_bus_type, &fsl_pamu_ops);
+#ifdef CONFIG_PCI
 	bus_set_iommu(&pci_bus_type, &fsl_pamu_ops);
+#endif
 
 	return ret;
 }
-- 
1.7.5.4

