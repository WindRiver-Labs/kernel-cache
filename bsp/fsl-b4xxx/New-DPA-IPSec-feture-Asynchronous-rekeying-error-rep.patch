From 8fd004c47f636eac62406769667a4679a8b13b03 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 16 Mar 2012 15:38:28 +0000
Subject: [PATCH 120/518] New DPA IPSec feture: Asynchronous rekeying error
 reporting + autoremove on/off inbound rekeying

Implemented two features for DPA IPSec component:
    Add support for asynchronous rekeying error reporting [ClearQuest id ENGR174668]
    Modify default behaviour of rekeying function for inbound SAs [ClearQuest id ENGR174670]

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  598 +++++++++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    9 +-
 include/linux/fsl_dpa_ipsec.h               |   29 +-
 3 files changed, 463 insertions(+), 173 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 1fc1461..d37db89 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1082,6 +1082,14 @@ static inline void fill_cls_action_enq(struct dpa_cls_tbl_action *action_prm,
 	action_prm->enq_params.hm = hmanip;
 }
 
+static inline void fill_cls_action_drop(struct dpa_cls_tbl_action *action,
+					int en_stats)
+{
+	memset(action, 0, sizeof(struct dpa_cls_tbl_action));
+	action->type = DPA_CLS_TBL_ACTION_DROP;
+	action->enable_statistics = en_stats;
+}
+
 static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 			     struct dpa_ipsec_policy_entry *policy_entry,
 			     struct dpa_cls_tbl_header_manip **hm)
@@ -1362,6 +1370,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
+	struct dpa_cls_tbl_entry_mod_params mod_params;
 	int offset, err = 0, tbl_key_size = 0, i;
 	uint8_t *key, *mask;
 
@@ -1462,13 +1471,45 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		break;
 
 	case MNG_OP_MODIFY:
-		xx_pr_err("Modify operation not supported for IN SA PCD!\n");
-		return -EINVAL;
+		fill_cls_action_drop(&action, FALSE);
+
+		memset(&mod_params, 0, sizeof(mod_params));
+		mod_params.type = DPA_CLS_TBL_MODIFY_ACTION;
+		mod_params.key = NULL;
+		mod_params.action = &action;
+
+		entry_id = sa->inbound_hash_entry;
+		err = dpa_classif_table_modify_entry_by_ref(table, entry_id,
+							    &mod_params);
+		if (err < 0) {
+			xx_pr_err("Failed set drop action for inbound SA %d\n",
+				  sa->id);
+			return err;
+		}
+		sa->inbound_hash_entry = -1;
+		break;
 	}
 
 	return err;
 }
 
+static int inbound_error_recovery(struct dpa_ipsec_sa *sa)
+{
+	int err = -ENOTRECOVERABLE;
+
+	xx_pr_info("Bases on classifier feature, currently not supported.\n");
+
+	/* AV's note: TODO - use here the classifier feature when this is ready.
+	 * if no error occurs set inbound_hash_entry to -1 to mark that
+	 * PCD entry update was done successfully. */
+	if (err == 0) {
+		sa->inbound_hash_entry = -1;
+		return 0;
+	}
+
+	return -ENOTRECOVERABLE;
+}
+
 static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 {
 	int err = 0;
@@ -1550,7 +1591,7 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 
 static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 {
-	int err, flags, timeout = 10000;
+	int err, flags, timeout = WAIT4_FQ_EMPTY_TIMEOUT;
 
 	/* sanity checks */
 	if (!sec_fq) {
@@ -1588,9 +1629,7 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 {
 	struct qman_fq *to_sec_fq, *from_sec_fq;
-	enum qman_fq_state state;
 	int err;
-	u32 flags;
 
 	/* sanity checks */
 	if (!sa) {
@@ -1601,14 +1640,13 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 	to_sec_fq = sa->to_sec_fq;
 	from_sec_fq = sa->from_sec_fq;
 
-	qman_fq_state(to_sec_fq, &state, &flags);
 	if (qman_fq_fqid(to_sec_fq) != 0) {
 		err = remove_sa_sec_fq(to_sec_fq);
 		if (err < 0)
 			return err;
 	}
 
-	if (state != qman_fq_state_parked && qman_fq_fqid(from_sec_fq) != 0) {
+	if (!sa->parent_sa && !sa->child_sa) {
 		err = remove_sa_sec_fq(from_sec_fq);
 		if (err < 0)
 			return err;
@@ -1815,7 +1853,6 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	}
 
 	sa->sa_dir = DPA_IPSEC_OUTBOUND;
-	sa->parent_sa = NULL;
 	sa->sa_bpid = sa_params->sa_bpid;
 	sa->sa_wqid = sa_params->sa_wqid;
 
@@ -2393,20 +2430,45 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_sa_mng *sa_mng;
+	struct dpa_ipsec_sa *parent_sa, *child_sa;
 	int err;
 
 	dpa_ipsec = sa->dpa_ipsec;
 	sa_mng = &dpa_ipsec->sa_mng;
 
-	/* Mark as free index in used SA IDs vector of this DPA IPSEC instance*/
-	dpa_ipsec->used_sa_ids[sa->used_sa_index] = DPA_IPSEC_INVALID_SA_ID;
-	dpa_ipsec->num_used_sas--;
+	if (sa->used_sa_index < 0) {
+		xx_pr_crit("Invalid used_sa_index for SA with id %d\n", sa->id);
+		return -EFAULT;
+	}
+
+	/* Update successor to have no parent because its parent died */
+	if (sa->child_sa) {
+		child_sa  = sa->child_sa;
+		/* AV's note TODO: acquire lock for child SA */
+		child_sa->parent_sa = NULL;
+		sa->child_sa  = NULL;
+	}
+
+	/* Update parent to have no child because its child died */
+	if (sa->parent_sa) {
+		parent_sa =  sa->parent_sa;
+		/* AV's note TODO: acquire lock for parent SA */
+		parent_sa->child_sa = NULL;
+		sa->parent_sa = NULL;
+	}
+
+	/* Release the SA id in the SA IDs circular queue */
 	err = cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
 	if (err < 0) {
 		xx_pr_err("Could not release the sa id %d\n", sa->id);
 		return -EDOM;
 	}
+
+	/* Mark as free index in used SA IDs vector of this DPA IPSEC instance*/
+	dpa_ipsec->used_sa_ids[sa->used_sa_index] = DPA_IPSEC_INVALID_SA_ID;
+	dpa_ipsec->num_used_sas--;
 	sa->used_sa_index = -1;
+
 	return 0;
 }
 
@@ -2577,15 +2639,14 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	/* Update internal SA structure */
 	sa->sa_dir = sa_params->sa_dir;
 	sa->dpa_ipsec = dpa_ipsec;
+	sa->parent_sa = NULL;
+	sa->child_sa = NULL;
 
 	/* Copy SA params into the internal SA structure */
-	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		sa->parent_sa = NULL;
+	if (sa->sa_dir == DPA_IPSEC_OUTBOUND)
 		err = copy_sa_params_to_out_sa(sa, sa_params);
-	} else { /* DPA_IPSEC_INBOUND */
-		sa->parent_sa = NULL;
+	else /* DPA_IPSEC_INBOUND */
 		err = copy_sa_params_to_in_sa(sa, sa_params, FALSE);
-	}
 
 	if (err < 0) {
 		xx_pr_err("Could not copy SA parameters into SA\n");
@@ -2705,6 +2766,13 @@ EXPORT_SYMBOL(dpa_ipsec_create_sa);
  *		- flush all policies
  *		- detach the Exact Match Table from the Index Table
  * 7. Free all memory used for this SA i.e recycle this SA
+ *
+ * AV's note: TODO - Check if the SA id is refering to a SA
+ *	parent that has a child SA not scheduled. If so schedule this child SA
+ *	TO SEC FQ even if no frames arrived encrypted with its key (SPI, ...)
+ *	and remove it from the rekeying SA list.
+ *	This feature depends on proper locking mechanism for SA. Cleverly add
+ *	the synchronization mechanism.
  */
 int dpa_ipsec_remove_sa(int sa_id)
 {
@@ -2832,7 +2900,7 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	 * to know what to remove when SA expires.
 	 */
 	err = store_policy_param_to_sa_pol_list(sa, policy_params,
-				&policy_entry);
+						&policy_entry);
 	if (err < 0) {
 		xx_pr_err("Could not store the policy in the SA\n");
 		return err;
@@ -2892,21 +2960,32 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_remove_policy);
 
+static inline int sa_currently_in_rekeying(struct dpa_ipsec_sa *sa)
+{
+	if (sa->parent_sa || sa->child_sa)
+		return TRUE;
+	return FALSE;
+}
+
+/*
+ * Returned error code: -EUSERS
+ *	- if both parent SA and child SA are in invalid state, some or none of
+ *	  the old's policies were safely transfered to the child SA but some
+ *	  policies remained offloaded through parent SA.
+ *
+ */
 int dpa_ipsec_sa_rekeying(int sa_id,
 			  struct dpa_ipsec_sa_params *sa_params,
-			  dpa_ipsec_rekey_event_cb *rekey_event_cb,
+			  dpa_ipsec_rekey_event_cb rekey_event_cb,
 			  int auto_rmv_old_sa,
 			  int *new_sa_id)
 {
-	struct dpa_ipsec *dpa_ipsec;
-	struct dpa_ipsec_sa_mng *sa_mng;
+	struct dpa_ipsec *dpa_ipsec = NULL;
+	struct dpa_ipsec_sa_mng *sa_mng = NULL;
 	struct dpa_ipsec_sa *old_sa, *new_sa;
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	uint32_t id;
-	int err = 0, timeout = 10000;
-
-	unused(rekey_event_cb);
-	unused(auto_rmv_old_sa);
+	int err = 0;
 
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err("There is no dpa_ipsec instance initialized\n");
@@ -2930,11 +3009,23 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		return -EINVAL;
 	}
 
-	sa_mng = &dpa_ipsec->sa_mng;
+	/* Check if SA is currently in rekeying process */
+	if (sa_currently_in_rekeying(old_sa)) {
+		xx_pr_err("SA with id %d is already in rekeying process\n",
+			  old_sa->id);
+		return -EEXIST;
+	}
+
+	/* Check if new SA parameters are matching the rekeyed SA */
+	if (old_sa->sa_dir != sa_params->sa_dir) {
+		xx_pr_err("New SA parameters don't match the parent SA %d\n",
+			  old_sa->sa_dir);
+		return -EINVAL;
+	}
 
 	err = get_new_sa(dpa_ipsec, &new_sa, &id);
 	if (err < 0) {
-		xx_pr_err("Failed retrieveing a preallocated SA\n");
+		xx_pr_err("Failed retrieving a preallocated SA\n");
 		return err;
 	}
 
@@ -2942,15 +3033,20 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	new_sa->dpa_ipsec = old_sa->dpa_ipsec;
 	new_sa->inbound_flowid = old_sa->inbound_flowid;
 	new_sa->inbound_indx_entry = -1;
+	new_sa->rekey_event_cb = rekey_event_cb;
+
+	/* Set its parent */
+	new_sa->parent_sa = old_sa;
+	new_sa->child_sa  = NULL;
+	/* AV's note TODO: acquire lock for old SA */
+	old_sa->child_sa  = new_sa;
+	/* release lock */
 
 	/* Copy SA params into the internal SA structure */
-	if (old_sa->sa_dir == DPA_IPSEC_OUTBOUND) {
+	if (old_sa->sa_dir == DPA_IPSEC_OUTBOUND)
 		err = copy_sa_params_to_out_sa(new_sa, sa_params);
-		new_sa->parent_sa = old_sa;
-	} else {  /* DPA_IPSEC_INBOUND */
+	else
 		err = copy_sa_params_to_in_sa(new_sa, sa_params, TRUE);
-		new_sa->parent_sa = old_sa;
-	}
 
 	if (err < 0) {
 		xx_pr_err("Could not copy SA parameters into SA\n");
@@ -2981,15 +3077,11 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	/* AV's note: Since we have reused the FROM SEC FQ it is not needed to
 	 * make another entry in the PCD node of the post encryption OH PORT. */
 	if (new_sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		/* Link the entries of the policy list to the policy
-		 * list on the new SA.
-		 * The policy list from the old SA becomes void.
-		 */
-		list_splice_init(&old_sa->policy_headlist,
-				 &new_sa->policy_headlist);
-		/* Need to update the outbound policy if we have policies */
+		INIT_LIST_HEAD(&new_sa->policy_headlist);
+
+		/* Update child's SA policies if its parent SA has policies */
 		list_for_each_entry_safe(policy_entry, tmp_policy_entry,
-					 &new_sa->policy_headlist,
+					 &old_sa->policy_headlist,
 					 node) {
 			err = update_outbound_policy(new_sa,
 						     policy_entry,
@@ -2997,32 +3089,21 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 			if (err < 0) {
 				/* Keep both SAs. Both must be removed
 				 * using remove_sa */
-				*new_sa_id = id;
-				xx_pr_err("Could't modify outbound policy");
-				goto rekey_sa_err;
+				*new_sa_id = new_sa->id;
+				xx_pr_err("Could't modify outbound policy\n");
+				return -EUSERS;
 			}
+			list_del(&policy_entry->node);
+			list_add(&policy_entry->node, &new_sa->policy_headlist);
 		}
-		/* AV's note: Wait until all the frames from the old TO SEC FQ
-		 * are consumed and then schedule the new TO SEC FQ */
-		wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 
-		qman_schedule_fq(new_sa->to_sec_fq);
-
-		/* Free the old SA structure and all its resources */
-		err = remove_sa_sec_fq(old_sa->to_sec_fq);
-		if (err < 0) {
-			/* Mark SA as rekeyed */
-			/* AV's note: TODO Add this SA to the SA garbage
-			 * collector list because we can't remove it until
-			 * it's to SEC FQ is empty. */
-		} else {
-			/* Mark as free index in used sa ids vector of this
-			 * dpa ipsec instance */
-			dpa_ipsec->used_sa_ids[old_sa->used_sa_index] =
-			    DPA_IPSEC_INVALID_SA_ID;
-			dpa_ipsec->num_used_sas--;
-			cq_put_4bytes(sa_mng->sa_id_cq, old_sa->id);
-		}
+		/* Need to destroy the old SA. Have to wail until its TO SEC
+		 * FQ is empty. This is done in work queue, schedule it. */
+		sa_mng = &dpa_ipsec->sa_mng;
+		list_add(&new_sa->sa_rekeying_node,
+			 &sa_mng->sa_rekeying_headlist);
+		queue_delayed_work(sa_mng->sa_rekeying_wq,
+				   &sa_mng->sa_rekeying_work, 1);
 	} else {		/* DPA_IPSEC_INBOUND */
 		/* Need to update the IN SA PCD entry */
 		err = update_pre_sec_inbound_table(new_sa, MNG_OP_ADD);
@@ -3031,126 +3112,319 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 			goto rekey_sa_err;
 		}
 
-		/* Add new SA into the sa_rekeying_headlist */
-		list_add(&new_sa->sa_rekeying_node,
-			 &sa_mng->sa_rekeying_headlist);
+		if (auto_rmv_old_sa) {
+			sa_mng = &dpa_ipsec->sa_mng;
+			/* Add new SA into the sa_rekeying_headlist */
+			list_add(&new_sa->sa_rekeying_node,
+				 &sa_mng->sa_rekeying_headlist);
 
-		/* schedule inbound SA's rekeying */
-		queue_delayed_work(sa_mng->sa_rekeying_wq,
-				   &sa_mng->sa_rekeying_work, 1);
+			/* schedule inbound SA's rekeying */
+			queue_delayed_work(sa_mng->sa_rekeying_wq,
+					   &sa_mng->sa_rekeying_work, 1);
+		} else {
+			/* The old SA has to be removed using the
+			 * dpa_ipsec_remove_sa function when the hard SA
+			 * expiration time limit is reached.
+			 *
+			 * Since the difference between soft and hard limit
+			 * can be several seconds it is required to schedule the
+			 * TO SEC FQ of the new SA. */
+			err = qman_schedule_fq(new_sa->to_sec_fq);
+			if (err < 0)
+				return err;
+		}
 	}
 
+	/* Rekeying done ok. */
 	*new_sa_id = new_sa->id;
 
 	return 0;
 
-	/* Something went wrong. Begin rollback */
- rekey_sa_err:
-	if (*new_sa_id == DPA_IPSEC_INVALID_SA_ID) {
-		remove_sa_fq_pair(new_sa);
-		if (new_sa->used_sa_index != -1) {
-			new_sa->dpa_ipsec->used_sa_ids[new_sa->used_sa_index] =
-					DPA_IPSEC_INVALID_SA_ID;
-			new_sa->used_sa_index = -1;
-			new_sa->dpa_ipsec->num_used_sas--;
-		}
-		cq_put_4bytes(sa_mng->sa_id_cq, new_sa->id);
-	}
+/* Rekeying failed before updating/adding any table entry.
+ * It is safe to remove new SA */
+rekey_sa_err:
+	remove_sa_fq_pair(new_sa);
+	put_sa(new_sa);
 
 	return err;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_rekeying);
 
+static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
+				int dpa_ipsec_id, uint32_t sa_id, int err)
+{
+	if (rekey_event_cb)
+		rekey_event_cb(dpa_ipsec_id, sa_id, err);
+}
+
+/*
+ * Rekeying process successful if the returned error was: 0, -EUCLEAN, -EDQUOT
+ *	- error code 0 for perfect rekeying
+ *	- error code -EUCLEAN if during rekeying process the removal of the
+ *	  TO SEC FQ of old SA failed. Upper layer has to call the
+ *	  dpa_ipsec_remove_sa at a later time (not from callback) to try again
+ *	  freeing old SA resources. New SA is working perfectly.
+ *	- error code -EDQUOT if failed to recycle old SA memory. Upper layer
+ *	  has to call the dpa_ipsec_remove_sa at a later time (not from
+ *	  callback)to try again recycling old SA.
+ *
+ * Rekeying process in progress if the returned error is: -ETIME or -EIO.
+ *	- error code -ETIME if timeout occurred when waiting for old SA TO SEC
+ *	  FQ to get empty. Upper layer has nothing to do since the old SA TO
+ *	  SEC FQ will get empty eventually.
+ *	- error code -EIO if rekeying failed to schedule the new SA. Upper layer
+ *	  has nothing to do since the new SA TO SEC FQ will get scheduled
+ *	  eventually.
+ *
+ * Rekeying process failed: -EFAULT
+ *	- If somehow a new SA was linked to the rekeying list but has no parent
+ *	  set. This is an internal error for DPA IPSec component. Should never
+ *	  happen. The upper layer will get noticed of this error and the
+ *	  DPA IPSec will automatically remove the new SA from the rekeying list.
+ *	  Upper layer should call again the dpa_ipsec_sa_rekeying for old SA.
+ */
+static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
+{
+	struct dpa_ipsec_sa *old_sa;
+	int err, timeout = WAIT4_FQ_EMPTY_TIMEOUT; /* microseconds */
+
+	/* sanity check */
+	old_sa = new_sa->parent_sa;
+	if (!old_sa) {
+		xx_pr_err("Invalid parent SA for child SA id %d\n", new_sa->id);
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EFAULT);
+		/* Remove the new SA from rekeying list */
+		list_del(&new_sa->sa_rekeying_node);
+		return -EFAULT;
+	}
+
+	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
+	if (err < 0) {
+		xx_pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
+		return -ETIME;
+	}
+
+	/* Schedule the new SA */
+	err = qman_schedule_fq(new_sa->to_sec_fq);
+	if (unlikely(err < 0)) {
+		xx_pr_err("Scheduling the new SA %d failed\n", new_sa->id);
+		return -EIO;
+	}
+
+	/* Remove the new SA from rekeying list */
+	list_del(&new_sa->sa_rekeying_node);
+
+	/* Now free the old SA structure and all its resources */
+	err = remove_sa_sec_fq(old_sa->to_sec_fq);
+	if (err < 0) {
+		xx_pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EUCLEAN);
+		return -EUCLEAN;
+	}
+
+	/* Recycle SA memory */
+	err = put_sa(old_sa);
+	if (unlikely(err < 0)) {
+		xx_pr_err("Could not recycle parent SA.\n");
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EDQUOT);
+		return -EDQUOT;
+	}
+
+	return 0;
+}
+
+/*
+ * Rekeying process successful if the returned error was: 0, -EUCLEAN, -EDQUOT
+ *	- error code 0 for perfect rekeying
+ *	- error code -EUCLEAN if during rekeying process the removal of the
+ *	  TO SEC FQ of old SA failed. Upper layer has to call the
+ *	  dpa_ipsec_remove_sa at a later time (not from callback) to try again
+ *	  freeing old SA resources. New SA is working perfectly.
+ *	- error code -EDQUOT if failed to recycle old SA memory. Upper layer
+ *	  has to call the dpa_ipsec_remove_sa at a later time (not from
+ *	  callback)to try again recycling old SA.
+ *
+ * Rekeying process in progress if the returned error is: -EINPROGRESS, -ETIME
+ *	  or -EIO.
+ *	- error code -EINPROGRESS if no frame arrived on the new SA TO SEC FQ.
+ *	  If HARD expiration event occurs on the old SA and rekeying is still
+ *	  in progress the upper layer should call the dpa_ipsec_remove_sa with
+ *	  old SA id which will remove old SA and will automatically schedule
+ *	  new SA even if no frames have arrived on the new SA TO SEC FQ.
+ *	- error code -ETIME if timeout occurred when waiting for old SA TO SEC
+ *	  FQ to get empty. Upper layer has nothing to do since the old SA TO
+ *	  SEC FQ will get empty eventually.
+ *	- error code -EIO if rekeying failed to schedule the new SA. Upper layer
+ *	  has nothing to do since the old SA TO SEC FQ will get scheduled
+ *	  eventually.
+ *
+ * Rekeying process lost MURAM equivalent with 1 PCD entry: -EADV
+ *	- Failed to delete the hash entry formed by old SA (SPI, ...)
+ *	- If the above action failed than to avoid any possible attacks, the DPA
+ *	  IPSec component tries to modify the action of the hash entry formed by
+ *	  old SA (SPI, ...) to drop that traffic. If this attempt is successful
+ *	  than the system is in a safe state, rekeying might continue, the only
+ *	  inconvenient would be losing MURAM equivalent with 1 PCD entry.
+ *
+ * Rekeying process lost MURAM equivalent with 2 PCD entry: -EL2HLT
+ *	- Failed to delete the hash entry formed by old SA (SPI, ...)
+ *	- Failed to modify action (to DROP) for the hash entry formed by
+ *	  old SA (SPI, ...)
+ *	- If all above actions fail, the DPA IPSec component tries to create
+ *	  another PCD entry having the same lookup key of the old SA (SPI, ...)
+ *	  but with action DROP and greater priority. If this attempt is
+ *	  successful the system is in a safe state, rekeying might continue,
+ *	  the only inconvenient would be losing MURAM equivalent with 2 PCD
+ *	  entries.
+ *
+ * Rekeying in critical state: -ENOTRECOVERABLE
+ *	- Failed to delete the hash entry formed by old SA (SPI, ...)
+ *	- Failed to modify action (to DROP) for the hash entry formed by
+ *	  old SA (SPI, ...)
+ *	- Failed to create another hash entry formed by old SA (SPI, ...) with
+ *	  action DROP and having higher priority then the existing one.
+ *	- If all above actions failed than the system is in critical state,
+ *	  since it is still offloading the old SA. If an attacker would sent
+ *	  frames matching the old SA (SPI, ...) than FMAN will direct those
+ *	  frames to old SA FQ. In this case the wait until old SA FQ is empty
+ *	  is not valid, since being attacked this FQ might not get empty.
+ *	  There is a tiny probability that above scenario to happen, but if it
+ *	  does the recommended action would be to reboot the system.
+ *
+ * Rekeying process failed: -EFAULT
+ *	- If somehow a new SA was linked to the rekeying list but has no parent
+ *	  set. This is an internal error for DPA IPSec component. Should never
+ *	  happen. The upper layer will get noticed of this error and the
+ *	  DPA IPSec will automatically remove the new SA from the rekeying list.
+ *	  Upper layer should call again the dpa_ipsec_sa_rekeying for old SA.
+ */
+static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
+{
+	struct dpa_ipsec_sa *old_sa;
+	struct qm_mcr_queryfq_np queryfq_np;
+	int err = 0, timeout = WAIT4_FQ_EMPTY_TIMEOUT; /* microseconds */
+
+	/* sanity check */
+	old_sa = new_sa->parent_sa;
+	if (!old_sa) {
+		xx_pr_err("Invalid parent SA for child SA id %d\n", new_sa->id);
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EFAULT);
+		/* Remove the new SA from rekeying list */
+		list_del(&new_sa->sa_rekeying_node);
+		return -EFAULT;
+	}
+
+	/* Check if the new SA TO SEC FQ has frame descriptors enqueued in it */
+	qman_query_fq_np(new_sa->to_sec_fq, &queryfq_np);
+	if (queryfq_np.frm_cnt == 0)
+		return -EINPROGRESS;
+
+	/* Received at least one packet encrypted with the new SA,
+	 * check if the hash table of old SA was updated properly.*/
+	if (old_sa->inbound_hash_entry == -1)
+		goto resume_rekeying;
+
+	err = update_pre_sec_inbound_table(old_sa, MNG_OP_REMOVE);
+	if (unlikely(err < 0)) {
+		err = update_pre_sec_inbound_table(old_sa, MNG_OP_MODIFY);
+		if (err == 0) {
+			/* report error to upper layer - 1 MURAM entry lost */
+			xx_pr_err("MURAM lost equivalent to one PCD entry\n");
+			rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+					 -EADV);
+			goto resume_rekeying;
+		}
+
+		err = inbound_error_recovery(old_sa);
+		if (err == 0) {
+			/* report error to upper layer - 2 MURAM entry lost */
+			xx_pr_err("MURAM lost equivalent to two PCD entries\n");
+			rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+					 -EL2HLT);
+			goto resume_rekeying;
+		}
+
+		/* Mark hash table entry of old SA as updated, even if a
+		 * critical error occurred. Required so that a later call to
+		 * dpa_ipsec_remove_sa with old SA id, would not try again the
+		 * removal of this entry, consequently failing again. */
+		old_sa->inbound_hash_entry = -1;
+
+		/* Remove the new SA from rekeying list */
+		list_del(&new_sa->sa_rekeying_node);
+
+		/* report critical error */
+		xx_pr_crit("Error recovery failed for SA %d\n", old_sa->id);
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -ENOTRECOVERABLE);
+		return err;
+	}
+
+resume_rekeying:
+	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
+	if (err < 0) {
+		xx_pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
+		return -ETIME;
+	}
+
+	/* schedule new inbound SA */
+	err = qman_schedule_fq(new_sa->to_sec_fq);
+	if (unlikely(err < 0)) {
+		xx_pr_err("Scheduling the new SA %d failed\n", new_sa->id);
+		return -EIO;
+	}
+
+	/* Update the new SA with old SA's inbound indx entry */
+	new_sa->inbound_indx_entry = old_sa->inbound_indx_entry;
+
+	/* Inherit old SA policy list and then set it empty */
+	if (old_sa->dpa_ipsec->config.post_sec_in_params.do_pol_check)
+		list_splice_init(&old_sa->policy_headlist,
+				 &new_sa->policy_headlist);
+
+	/* Remove the new SA from rekeying list */
+	list_del(&new_sa->sa_rekeying_node);
+
+	/* Now free the old SA structure and all its resources */
+	err = remove_sa_sec_fq(old_sa->to_sec_fq);
+	if (err < 0) {
+		xx_pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EUCLEAN);
+		return -EUCLEAN;
+	}
+
+	/* Recycle SA memory */
+	err = put_sa(old_sa);
+	if (unlikely(err < 0)) {
+		xx_pr_err("Could not recycle parent SA.\n");
+		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
+				 -EDQUOT);
+		return -EDQUOT;
+	}
+
+	return 0;
+}
+
 void sa_rekeying_work_func(struct work_struct *work)
 {
 	struct dpa_ipsec_sa_mng *sa_mng;
-	struct dpa_ipsec_sa *new_sa, *old_sa, *tmp_sa;
-	struct dpa_ipsec *dpa_ipsec;
+	struct dpa_ipsec_sa *new_sa, *tmp_sa;
 	struct list_head *head_list;
-	struct qm_mcr_queryfq_np queryfq_np;
-	int err;
 
 	sa_mng = container_of((struct delayed_work *)work,
 			      struct dpa_ipsec_sa_mng, sa_rekeying_work);
 	head_list = &sa_mng->sa_rekeying_headlist;
 
 	list_for_each_entry_safe(new_sa, tmp_sa, head_list, sa_rekeying_node) {
-		/* Verify if the new SA TO SEC FQ has something enqueued in it*/
-		qman_query_fq_np(new_sa->to_sec_fq, &queryfq_np);
-		if (queryfq_np.frm_cnt > 0) {
-			/* timeout in microseconds */
-			uint32_t timeout = 10000;
-
-			old_sa = new_sa->parent_sa;
-			BUG_ON(!old_sa);
-
-			dpa_ipsec = old_sa->dpa_ipsec;
-			if (old_sa->inbound_hash_entry != -1) {
-				err = update_pre_sec_inbound_table(old_sa,
-								 MNG_OP_REMOVE);
-				if (err < 0) {
-					xx_pr_err("Could not remove PCD entry for SA\n");
-					/*Remove the new SA from rekeying list*/
-					list_del(&new_sa->sa_rekeying_node);
-					err = dpa_ipsec_remove_sa(new_sa->id);
-					if (err < 0)
-						xx_pr_err("Could not remove new sa\n");
-					continue;
-				}
-			}
-
-			/* AV's note: Wait until all the frames from the old
-			 * TO SEC FQ are consumed and then schedule the new TO
-			 * SEC FQ */
-			wait_until_fq_empty(old_sa->to_sec_fq, timeout);
-
-			/* If timeout has reached 0 it means that there are
-			 * still frames inside OLD SA TO SEC Frame Queue,
-			 * therefore we continue with other SA in progress of
-			 * rekeying and let the current one for a later time
-			 * when the work will be rescheduled. Do not remove
-			 * this new SA from rekeying list.
-			 * We can not receive on inbound old SA because the
-			 * old SA was removed from the PCD Entry which is
-			 * perfect */
-			if (timeout == 0)
-				continue;
-
-			/* schedule new inbound SA */
-			qman_schedule_fq(new_sa->to_sec_fq);
-
-			/* Free the old SA structure and all its resources */
-			err = remove_sa_sec_fq(old_sa->to_sec_fq);
-			if (err < 0) {
-				xx_pr_err("Could not remove SA FQ pair during rekeying!\n");
-				/* TODO: add this SA to garbage collector */
-				/*Remove the new SA from rekeying list*/
-				list_del(&new_sa->sa_rekeying_node);
-				continue;
-			}
-			/* Mark as free index in used sa ids vector of this
-			 * dpa ipsec instance */
-			dpa_ipsec->used_sa_ids[old_sa->used_sa_index] =
-				DPA_IPSEC_INVALID_SA_ID;
-			dpa_ipsec->num_used_sas--;
-			/* Update the new SA with old SA's inbound indx entry */
-			if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
-				new_sa->inbound_indx_entry =
-					old_sa->inbound_indx_entry;
-			/* Link the entries of the policy list to the policy
-			 * list on the new SA.
-			 * The policy list from the old SA becomes void.
-			 */
-				list_splice_init(&old_sa->policy_headlist,
-						 &new_sa->policy_headlist);
-			}
-			cq_put_4bytes(sa_mng->sa_id_cq, old_sa->id);
-
-			/*Remove the new SA from rekeying list*/
-			list_del(&new_sa->sa_rekeying_node);
-		} else {
-			continue;
-		}
+		if (new_sa->sa_dir == DPA_IPSEC_OUTBOUND)
+			sa_rekeying_outbound(new_sa);
+		else /* DPA_IPSEC_INBOUND */
+			sa_rekeying_inbound(new_sa);
 	}
 
 	if (!list_empty(head_list)) {
@@ -3158,12 +3432,12 @@ void sa_rekeying_work_func(struct work_struct *work)
 		unsigned long jiffies_to_wait;
 
 		timeval.tv_sec = 0;
-		timeval.tv_usec = 100;
+		timeval.tv_usec = REKEY_SCHED_DELAY;
 		jiffies_to_wait = timeval_to_jiffies(&timeval);
 
 		queue_delayed_work(sa_mng->sa_rekeying_wq,
 				   &sa_mng->sa_rekeying_work,
-				   jiffies_to_wait);	/* 100 microseconds. */
+				   jiffies_to_wait);
 	}
 
 	return;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index ad6a577..d4292d0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -169,6 +169,9 @@
 #define UDP_HEADER_LEN		8
 #define NEXT_HEADER_IS_IPv4	0x04
 
+#define WAIT4_FQ_EMPTY_TIMEOUT	10000 /* Time in microseconds */
+#define REKEY_SCHED_DELAY	100   /* Time in microseconds */
+
 /* DPA IPSec Encryption & authentication algorithm identifiers */
 struct ipsec_alg_suite {
 	uint16_t	enc_alg;
@@ -244,12 +247,12 @@ struct dpa_ipsec_sa {
 				      verification should be enqueued	      */
 	int em_inpol_td; /* Exact match table descriptor for inbound policy
 			    check					      */
-	struct dpa_ipsec_sa *parent_sa;	/* Address of the parent SA or NULL
-			if this is an SA created with DPA_IPSEC_CreateSA.
-			Used only when rekeying an inbound SA		      */
+	struct dpa_ipsec_sa *parent_sa;	/* Address of the parent SA or NULL   */
+	struct dpa_ipsec_sa *child_sa;	/* Address of the child SA or NULL    */
 	struct list_head sa_rekeying_node; /* Only used for inbound rekeying  */
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
+	dpa_ipsec_rekey_event_cb rekey_event_cb;
 };
 
 /* Parameters for inbound policy verification tables */
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 2fbbcae..6851ab7 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -344,20 +344,33 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 /* This function will be used when rekeying a SA.
  *	- The new SA will inherit the old SA's policies.
  *	- To SEC FQ of the new SA will be created in parked mode and
- *	  will be scheduled after the to SEC FQ of the old SA is empty.
- *	  This will ensure the preservation of the frame order
+ *	  will be scheduled after the to SEC FQ of the old SA is empty,
+ *	  exception only when auto_rmv_old_sa if false.
+ *	  This will ensure the preservation of the frame order.
  *	- To SEC FQ of the old SA will be retired and destroyed when it
  *	  has no purpose.
- *	- Memory allocated for old SA will be returned to the SA memory
- *	  pool
- *	- Currently the OLD SA is removed when encrypted traffic starts
- *	  flowing on the new SA regardless of the value auto_rmv_old_sa
- *	- auto_rmv_old_sa (UNUSED parameter)
+ *	- Memory allocated for old SA will be returned to the SA memory pool
+ *	- auto_rmv_old_sa
+ *		- relevant only for an inbound SA.
+ *		- if true:
+ *			- the old SA will be removed automatically when
+ *			  encrypted traffic starts flowing on the new SA
+ *			- the new SA is not scheduled until traffic arrives on
+ *			  its TO SEC FQ.
+ *		- if false:
+ *			- the old and new SA will be active in the same time.
+ *			- the old SA has to be removed using the
+ *			  dpa_ipsec_remove_sa function when the hard SA
+ *			  expiration time limit is reached
+ *			- Since the difference between soft and hard limit
+ *			  can be several seconds it is required to schedule the
+ *			  TO SEC FQ of the new SA.
+ *
  *	- rekey_event_cb (UNUSED parameter)
  */
 int dpa_ipsec_sa_rekeying(int sa_id,
 			  struct dpa_ipsec_sa_params *sa_params,
-			  dpa_ipsec_rekey_event_cb *rekey_event_cb,
+			  dpa_ipsec_rekey_event_cb rekey_event_cb,
 			  int auto_rmv_old_sa, int *new_sa_id);
 
 /*
-- 
1.7.5.4

