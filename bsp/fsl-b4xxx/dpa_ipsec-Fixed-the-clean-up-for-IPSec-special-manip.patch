From 3b0a9f149997a66d4f9241ea7c372cdd813175d9 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 9 Nov 2012 14:52:41 +0000
Subject: [PATCH 397/518] dpa_ipsec: Fixed the clean up for IPSec special
 manip operations

1. When preallocation was not used (runtime allocation)
the DPA IPSec manip nodes should have been deleted.
2. When preallocation is used, just recycle the DPA IPSec manip.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   36 +++++++++++++++++++++------
 1 files changed, 28 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 66e15ee..862078a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1512,18 +1512,38 @@ static int update_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
 	return ret;
 }
 
-static int destroy_manip(int hmd)
+static int destroy_recycle_manip(struct dpa_ipsec_sa *sa, int hmd)
 {
+	t_Handle hm;
 	int err = 0;
 
 	BUG_ON(hmd == DPA_OFFLD_DESC_NONE);
 
+	hm = dpa_classif_get_static_hm_handle(hmd);
+	BUG_ON(!hm);
+
+	/* Removed from classifier but not from memory. HM is still usable */
 	err = dpa_classif_free_hm(hmd);
 	if (err < 0) {
 		pr_err("%s: Failed to remove header manip!\n", __func__);
 		return err;
 	}
 
+	/* Destroy the DPA IPSec Special header manip or put it in the pool */
+	if (sa->dpa_ipsec->config.max_sa_manip_ops > 0) {
+		/* return to pool */
+		put_free_ipsec_manip_node(sa->dpa_ipsec, hm);
+		return 0;
+	}
+
+	/* Destroy hm */
+	err = FM_PCD_ManipNodeDelete(hm);
+	if (err != E_OK) {
+		pr_err("%s: FM_PCD_ManipNodeDelete failed for SA %d!\n",
+			__func__, sa->id);
+		return -EBUSY;
+	}
+
 	return 0;
 }
 
@@ -1727,7 +1747,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		}
 
 		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_manip(policy_entry->hmd);
+			err = destroy_recycle_manip(sa, policy_entry->hmd);
 			if (err < 0) {
 				pr_err("Couldn't delete frag & ipsec manip\n");
 				return err;
@@ -2963,7 +2983,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
-		err_rb = destroy_manip(sa->ipsec_hmd);
+		err_rb = destroy_recycle_manip(sa, sa->ipsec_hmd);
 		if (err_rb < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err_rb;
@@ -3018,7 +3038,7 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
-		err_rb = destroy_manip(sa->ipsec_hmd);
+		err_rb = destroy_recycle_manip(sa, sa->ipsec_hmd);
 		if (err_rb < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err_rb;
@@ -3324,7 +3344,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 
 		/* destroy SA manip */
 		if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_manip(sa->ipsec_hmd);
+			err = destroy_recycle_manip(sa, sa->ipsec_hmd);
 			if (err < 0) {
 				pr_err("Could not delete manip object!\n");
 				return err;
@@ -3404,7 +3424,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 
 	/* destroy SA manip */
 	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-		err = destroy_manip(sa->ipsec_hmd);
+		err = destroy_recycle_manip(sa, sa->ipsec_hmd);
 		if (err < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err;
@@ -3531,7 +3551,7 @@ static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
 
 	/* destroy SA manip, if one was initialized */
 	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-		err = destroy_manip(sa->ipsec_hmd);
+		err = destroy_recycle_manip(sa, sa->ipsec_hmd);
 		if (err < 0) {
 			pr_err("Couldn't delete SA manip\n");
 			return err;
@@ -4164,7 +4184,7 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 
 		/* destroy SA manip */
 		if (old_sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_manip(old_sa->ipsec_hmd);
+			err = destroy_recycle_manip(old_sa, old_sa->ipsec_hmd);
 			if (err < 0) {
 				pr_err("Could not delete manip object!\n");
 				return err;
-- 
1.7.5.4

