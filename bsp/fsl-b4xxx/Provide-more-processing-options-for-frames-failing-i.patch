From fb125692ad59895df03eeb78e3c9de066f2a0fe7 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:10 +0000
Subject: [PATCH 232/518] Provide more processing options for frames failing
 inbound policy verification

Provide the possibility to configure for the frames that failed
inbound policy verification more processing options, as supported
by the DPA Classifier.

Before these changes the frames were simply enqueued into a frame
queue configured by the upper layer. Now, the upper layer can
configure for these frames more complex actions, like sending them
to another classification or enabling specific header manipulation
operations.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c       |   10 +--
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h       |    5 +-
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |    2 +-
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |   80 +++++++++++++++------
 include/linux/fsl_dpa_ipsec.h                     |    5 +-
 5 files changed, 68 insertions(+), 34 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index a7229df..63330fc 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2186,7 +2186,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	       &sa_params->sa_in_params.dest_addr,
 	       sizeof(struct dpa_ipsec_ip_address));
 
-	sa->policy_miss_fqid = sa_params->sa_in_params.policy_miss_fqid;
+	sa->policy_miss_action = sa_params->sa_in_params.policy_miss_action;
 	sa->l2_hdr_size = sa_params->l2_hdr_size;
 	sa->enable_stats = sa_params->enable_stats;
 #ifdef DEBUG_PARAM
@@ -2853,7 +2853,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		if (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) {
 			int inbpol_td;
 			int inbindx_td;
-			struct dpa_cls_tbl_action miss_action, action;
+			struct dpa_cls_tbl_action action;
 			struct dpa_cls_tbl_key inbindx_key;
 
 			err = get_free_inbpol_tbl(dpa_ipsec, &inbpol_td);
@@ -2883,12 +2883,8 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 				goto create_sa_err;
 			}
 
-			memset(&miss_action, 0, sizeof(miss_action));
-			fill_cls_action_enq(&miss_action, FALSE,
-				sa->policy_miss_fqid, NULL);
-
 			err = dpa_classif_table_modify_miss_action(inbpol_td,
-								 &miss_action);
+						       &sa->policy_miss_action);
 			if (err < 0) {
 				pr_err("Can't set policy miss action\n");
 				goto create_sa_err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 5b76fbc..1c13831 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -265,8 +265,9 @@ struct dpa_ipsec_sa {
 	struct list_head policy_headlist; /* Head of the policy param list
 			 used to store all the in/out policy parameters in order
 			 to know how to remove the corresponding PCD entries  */
-	uint32_t policy_miss_fqid; /* FQID where frames that fail inbound policy
-				      verification should be enqueued	      */
+	struct dpa_cls_tbl_action policy_miss_action; /* Action for frames that
+						       * fail inbound policy
+						       * verification	      */
 	int em_inpol_td; /* Exact match table descriptor for inbound policy
 			    check					      */
 	struct dpa_ipsec_sa *parent_sa;	/* Address of the parent SA or NULL   */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index ab6a089..046e9b2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -104,7 +104,7 @@ struct ioc_compat_sa_in_params {
 	int use_udp_encap;
 	uint16_t src_port;
 	uint16_t dest_port;
-	uint32_t policy_miss_fqid;
+	struct dpa_cls_compat_tbl_action policy_miss_action;
 	struct dpa_cls_compat_tbl_action post_ipsec_action;
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index dad5b03..481a9a5 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -115,7 +115,10 @@ static void compat_copy_sa_in_params(struct dpa_ipsec_sa_in_params *prm,
 		prm->use_udp_encap = compat_prm->use_udp_encap;
 		prm->src_port = compat_prm->src_port;
 		prm->dest_port = compat_prm->dest_port;
-		prm->policy_miss_fqid = compat_prm->policy_miss_fqid;
+		memset(&prm->policy_miss_action, 0,
+		       sizeof(prm->policy_miss_action));
+		dpa_cls_tbl_action_params_compatcpy(&prm->policy_miss_action,
+					&compat_prm->policy_miss_action);
 		memset(&prm->post_ipsec_action, 0,
 		       sizeof(prm->post_ipsec_action));
 		dpa_cls_tbl_action_params_compatcpy(&prm->post_ipsec_action,
@@ -280,6 +283,30 @@ static void compat_copy_dpa_ipsec_get_pols(
 
 #endif
 
+static int copy_policer_params(struct dpa_cls_tbl_action *cls_action,
+			       struct dpa_cls_tbl_policer_params **policer_prm)
+{
+	struct dpa_cls_tbl_policer_params *policer_params;
+
+	if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
+	    cls_action->enq_params.policer_params != NULL) {
+		policer_params = kmalloc(sizeof(*policer_params), GFP_KERNEL);
+		if (!policer_params) {
+			pr_err("Error alloc CLS POL param");
+			return -ENOMEM;
+		}
+		*policer_prm = policer_params;
+		if (copy_from_user(policer_params,
+				  cls_action->enq_params.policer_params,
+				  sizeof(*policer_params))) {
+			pr_err("Error - copy CLS POL param");
+			return -EINVAL;
+		}
+		cls_action->enq_params.policer_params = policer_params;
+	}
+	return 0;
+}
+
 /* free memory allocated for copying SA params from US */
 static void free_sa_params(struct dpa_ipsec_sa_params *prm)
 {
@@ -296,11 +323,15 @@ static void free_sa_params(struct dpa_ipsec_sa_params *prm)
 		kfree(sa_out_prm->outer_ip_header);
 		kfree(sa_out_prm->outer_udp_header);
 	} else {
-		struct dpa_cls_tbl_action *sa_in_act;
+		struct dpa_cls_tbl_action *cls_action;
+
+		cls_action = &prm->sa_in_params.policy_miss_action;
+		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ)
+			kfree(cls_action->enq_params.policer_params);
 
-		sa_in_act = &prm->sa_in_params.post_ipsec_action;
-		if (sa_in_act->type == DPA_CLS_TBL_ACTION_ENQ)
-			kfree(sa_in_act->enq_params.policer_params);
+		cls_action = &prm->sa_in_params.post_ipsec_action;
+		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ)
+			kfree(cls_action->enq_params.policer_params);
 	}
 
 	crypto_params = &prm->crypto_params;
@@ -322,7 +353,8 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 	struct dpa_ipsec_init_vector *sa_out_iv = NULL;
 	uint8_t *auth_key =  NULL, *cipher_key = NULL, *iv_array = NULL;
 	void *out_ip_hdr = NULL, *out_udp_hdr = NULL;
-	struct dpa_cls_tbl_policer_params *policer_prm = NULL;
+	struct dpa_cls_tbl_policer_params *policer_prm_hit = NULL;
+	struct dpa_cls_tbl_policer_params *policer_prm_miss = NULL;
 	int err = 0;
 
 	/* allocate memory and copy SA out params (if required)*/
@@ -409,22 +441,24 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		/* handle any required memory transfer from US to K */
 		struct dpa_cls_tbl_action *cls_action;
 
+		/* copy policer params for policy miss action -  if any */
+		cls_action = &prm->sa_in_params.policy_miss_action;
+		err = copy_policer_params(cls_action, &policer_prm_miss);
+		if (err < 0) {
+			if (!policer_prm_miss)
+				return err;
+			else
+				goto free_create_copied_sa_mem;
+		}
+
+		/* copy policer params for post decryption action -  if any */
 		cls_action = &prm->sa_in_params.post_ipsec_action;
-		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
-		    cls_action->enq_params.policer_params != NULL) {
-			policer_prm = kmalloc(sizeof(*policer_prm), GFP_KERNEL);
-			if (!policer_prm) {
-				pr_err("Error alloc CLS POL param");
-				return -ENOMEM;
-			}
-			if (copy_from_user(policer_prm,
-					  cls_action->enq_params.policer_params,
-					  sizeof(*policer_prm))) {
-				pr_err("Error - copy CLS POL param");
-				err = -EINVAL;
+		err = copy_policer_params(cls_action, &policer_prm_hit);
+		if (err < 0) {
+			if (!policer_prm_hit)
+				return err;
+			else
 				goto free_create_copied_sa_mem;
-			}
-			cls_action->enq_params.policer_params = policer_prm;
 		}
 	}
 
@@ -478,8 +512,10 @@ free_create_copied_sa_mem:
 		kfree(sa_out_iv);
 		kfree(out_ip_hdr);
 		kfree(out_udp_hdr);
-	} else
-		kfree(policer_prm);
+	} else {
+		kfree(policer_prm_miss);
+		kfree(policer_prm_hit);
+	}
 
 	return err;
 }
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index e5046b7..de722bd 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -335,8 +335,9 @@ struct dpa_ipsec_sa_in_params {
 	int use_udp_encap;	/* NAT-T is activated (UDP encapsulated ESP)  */
 	uint16_t src_port;	/* Source UDP port (UDP encapsulated ESP)     */
 	uint16_t dest_port;	/* Destination UDP port (UDP encapsulated ESP)*/
-	uint32_t policy_miss_fqid; /* FQID where frames that fail inbound
-				    * policy verification should be enqueued  */
+	struct dpa_cls_tbl_action policy_miss_action; /* Action for frames that
+						       * fail inbound policy
+						       * verification         */
 	struct dpa_cls_tbl_action post_ipsec_action; /* Action to be performed
 						      * on the frames after
 						      * inbound IPSec processing
-- 
1.7.5.4

