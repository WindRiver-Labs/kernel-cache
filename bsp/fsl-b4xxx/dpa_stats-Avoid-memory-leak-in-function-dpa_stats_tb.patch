From dda56bb9130069e0182318bf046f2f97de3703ce Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 9 Nov 2012 19:12:15 +0000
Subject: [PATCH 390/518] dpa_stats: Avoid memory leak in function
 "dpa_stats_tbl_cls_compatcpy"

The kernel allocated memory for "keys" and "pairs" is now released in
case of error or before function returns.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   28 ++++++++++++++++++++--
 1 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index ad2e31c..b4540e7 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -921,9 +921,26 @@ static int do_ioctl_stats_compat_create_class_counter(void *args)
 	case DPA_STATS_CNT_CLASSIF_TBL:
 		ret = dpa_stats_tbl_cls_compatcpy(&kprm_cls->classif_tbl_params,
 			&uprm_cls->classif_tbl_params, kprm_cls->class_members);
-		if (ret < 0)
-			return ret;
-		break;
+		if (!ret)
+			break;
+
+		for (i = 0; i < kprm_cls->class_members; i++) {
+			struct dpa_stats_cls_cnt_classif_tbl *tbl =
+						&kprm_cls->classif_tbl_params;
+
+			if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+				kfree(tbl->keys[i].byte);
+				kfree(tbl->keys[i].mask);
+			}
+
+			if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+				kfree(tbl->pairs[i].first_key.byte);
+				kfree(tbl->pairs[i].first_key.mask);
+				kfree(tbl->pairs[i].second_key.byte);
+				kfree(tbl->pairs[i].second_key.mask);
+			}
+		}
+		return ret;
 	case DPA_STATS_CNT_CLASSIF_NODE:
 		ret = dpa_stats_ccnode_cls_compatcpy(
 			&kprm_cls->classif_node_params,
@@ -1925,9 +1942,11 @@ static long dpa_stats_tbl_cls_compatcpy(
 					&keys[i]);
 			if (ret != 0) {
 				pr_err("Couldn't copy the key descriptor\n");
+				kfree(keys);
 				return -EINVAL;
 			}
 		}
+		kfree(keys);
 	} else if (kprm->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
 		size = sizeof(struct dpa_offload_lookup_key_pair) * cls_members;
 		kprm->pairs = kzalloc(size, GFP_KERNEL);
@@ -1959,6 +1978,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 					&pairs[i].first_key);
 			if (ret != 0) {
 				pr_err("Couldn't copy the key descriptor\n");
+				kfree(pairs);
 				return -EINVAL;
 			}
 
@@ -1967,9 +1987,11 @@ static long dpa_stats_tbl_cls_compatcpy(
 					&pairs[i].second_key);
 			if (ret != 0) {
 				pr_err("Couldn't copy the key descriptor\n");
+				kfree(pairs);
 				return -EINVAL;
 			}
 		}
+		kfree(pairs);
 	}
 	return ret;
 }
-- 
1.7.5.4

