From 01100b317f07f6fcfe5b2c347b45f2ce924f962c Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:12 +0000
Subject: [PATCH 234/518] Add ICMP specific fields to the policy keys

Add support for enabling classification of policies of type ICMP
to be performed also on the basis of the protocol specific fields.
ICMP specific fields are added to the policy parameters structure
and the policy key calculation mechanism is modified to also
include these fields in the key.

Before these changes ICMP policies keys could contain only a
combination of the IP source, IP destination and IP protocol fields.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   51 +++++++++++++++------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   18 +++++-----
 include/linux/fsl_dpa_ipsec.h               |   25 +++++++++++--
 3 files changed, 58 insertions(+), 36 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index d744ece..337ed31 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1034,38 +1034,44 @@ static int fill_policy_key(int td,
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_PROTO:
-			SET_IP_PROTO_IN_KEY(key, offset, pol_sel->protocol);
+			SET_BYTE_VAL_IN_ARRAY(key, offset, pol_sel->protocol);
 			SET_IP_PROTO_MASK(mask, offset, pol_sel->masked_proto);
 			offset += IP_PROTO_FIELD_LEN;
 			break;
 
+		/* case DPA_IPSEC_KEY_FIELD_ICMP_TYPE: */
 		case DPA_IPSEC_KEY_FIELD_SPORT:
-			switch (pol_sel->protocol) {
-			case IPPROTO_TCP:
-			case IPPROTO_UDP:
-			case IPPROTO_SCTP:
+			if (pol_sel->protocol == IPPROTO_ICMP) {
+				SET_BYTE_VAL_IN_ARRAY(key, offset,
+						      pol_sel->icmp.icmp_type);
+				SET_BYTE_VAL_IN_ARRAY(mask, offset,
+						  pol_sel->icmp.icmp_type_mask);
+				offset += ICMP_HDR_FIELD_LEN;
+			} else {
 				memcpy(key + offset,
-				       (uint8_t *) &(pol_sel->src_port),
+				       (uint8_t *) &(pol_sel->l4.src_port),
 				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-						 pol_sel->src_port_mask);
+						 pol_sel->l4.src_port_mask);
 				offset += PORT_FIELD_LEN;
-				break;
 			}
 			break;
 
+		/* case DPA_IPSEC_KEY_FIELD_ICMP_CODE: */
 		case DPA_IPSEC_KEY_FIELD_DPORT:
-			switch (pol_sel->protocol) {
-			case IPPROTO_TCP:
-			case IPPROTO_UDP:
-			case IPPROTO_SCTP:
+			if (pol_sel->protocol == IPPROTO_ICMP) {
+				SET_BYTE_VAL_IN_ARRAY(key, offset,
+						      pol_sel->icmp.icmp_code);
+				SET_BYTE_VAL_IN_ARRAY(mask, offset,
+						  pol_sel->icmp.icmp_code_mask);
+				offset += ICMP_HDR_FIELD_LEN;
+			} else {
 				memcpy(key + offset,
-				       (uint8_t *) &(pol_sel->dest_port),
+				       (uint8_t *) &(pol_sel->l4.dest_port),
 				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-						 pol_sel->dest_port_mask);
+						 pol_sel->l4.dest_port_mask);
 				offset += PORT_FIELD_LEN;
-				break;
 			}
 			break;
 		}
@@ -1473,7 +1479,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 		offset = IP_ADDR_LEN(sa->dest_addr);
 		if (sa->use_udp_encap) {
-			SET_IP_PROTO_IN_KEY(key, offset, IPPROTO_UDP);
+			SET_BYTE_VAL_IN_ARRAY(key, offset, IPPROTO_UDP);
 			offset += IP_PROTO_FIELD_LEN;
 			memcpy(key + offset, (uint8_t *) &(sa->udp_src_port),
 			       PORT_FIELD_LEN);
@@ -1482,7 +1488,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 			       PORT_FIELD_LEN);
 			offset += PORT_FIELD_LEN;
 		} else {
-			SET_IP_PROTO_IN_KEY(key, offset, IPPROTO_ESP);
+			SET_BYTE_VAL_IN_ARRAY(key, offset, IPPROTO_ESP);
 			offset += IP_PROTO_FIELD_LEN;
 		}
 
@@ -2199,12 +2205,11 @@ static void copy_policy_selectors(struct dpa_ipsec_policy_params *policy_params,
 	policy_selectors->dest_prefix_len = policy_params->dest_prefix_len;
 	policy_selectors->protocol = policy_params->protocol;
 	policy_selectors->masked_proto = policy_params->masked_proto;
-	policy_selectors->src_port = policy_params->src_port;
-	policy_selectors->src_port_mask = policy_params->src_port_mask;
-	policy_selectors->dest_port = policy_params->dest_port;
-	policy_selectors->dest_port_mask = policy_params->dest_port_mask;
-
-	return;
+	/*
+	 * copy the bigger structure in the union to ensure that all memory is
+	 * initialized
+	 */
+	policy_selectors->l4 = policy_params->l4;
 }
 
 static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 3bc7b21..c2a367f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -151,7 +151,7 @@
 	(IP_ADDR_TYPE_IPV4(_ipAddr) ? \
 	(IPv4_ADDR_SIZE_IN_BYTES) : (IPv6_ADDR_SIZE_IN_BYTES))
 
-#define SET_IP_PROTO_IN_KEY(_key, _off, _val) (_key[_off] = _val)
+#define SET_BYTE_VAL_IN_ARRAY(_key, _off, _val) (_key[_off] = _val)
 #define SET_IP_PROTO_MASK(_mask, _off, _is_masked) \
 		(_mask[_off] = _is_masked ? 0x00 : 0xFF)
 #define SET_L4_PORT_MASK(_mask, _off, _val) \
@@ -333,16 +333,16 @@ struct dpa_ipsec {
 
 /* DPA IPSEC - Security Policy Selectors */
 struct dpa_ipsec_policy_selectors {
-	struct dpa_ipsec_ip_address src_addr;	/* Source IP address          */
+	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
 	uint8_t src_prefix_len;	/* Source network prefix		      */
-	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
-	uint8_t dest_prefix_len;	/* Destination network prefix	      */
+	struct dpa_ipsec_ip_address dest_addr;	/**< Destination IP address   */
+	uint8_t dest_prefix_len; /* Destination network prefix		      */
 	uint8_t protocol;	/* Protocol				      */
-	bool	masked_proto;	/* Mask the entire protocol field	      */
-	uint16_t dest_port;	/* Destination port			      */
-	uint16_t dest_port_mask;	/* Destination port mask	      */
-	uint16_t src_port;	/* Source port				      */
-	uint16_t src_port_mask;	/* Source port mask			      */
+	bool masked_proto;	/* Mask the entire protocol field	      */
+	union {
+		struct dpa_ipsec_l4_params	l4;	/* L4 protos params   */
+		struct dpa_ipsec_icmp_params	icmp;	/* ICMP proto params  */
+	};
 };
 
 /* DPA IPSEC - Security Policy Parameter Entry */
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index e2459e5..ddc1ce9 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -47,6 +47,7 @@
 #define IP_PROTO_FIELD_LEN		1
 #define ESP_SPI_FIELD_LEN		4
 #define PORT_FIELD_LEN			2
+#define ICMP_HDR_FIELD_LEN		1
 
 #define MAX_SIZE_IP_UDP_SPI_KEY	\
 		(1 * IPv6_ADDR_SIZE_IN_BYTES + \
@@ -93,7 +94,9 @@
 #define DPA_IPSEC_KEY_FIELD_DIP		0x02 /* Use destination IP in key     */
 #define	DPA_IPSEC_KEY_FIELD_PROTO	0x04 /* Use IP protocol field in key  */
 #define DPA_IPSEC_KEY_FIELD_SPORT	0x08 /* Use source port in key        */
+#define DPA_IPSEC_KEY_FIELD_ICMP_TYPE	0x08 /* Use ICMP type field in key    */
 #define DPA_IPSEC_KEY_FIELD_DPORT	0x10 /* Use destination port in key   */
+#define DPA_IPSEC_KEY_FIELD_ICMP_CODE	0x10 /* Use ICMP code field in key    */
 #define	DPA_IPSEC_MAX_KEY_FIELDS	5    /* Maximum key components        */
 
 #define DPA_IPSEC_DEF_PAD_VAL		0xAA /* Value to be used as padding in
@@ -431,6 +434,20 @@ enum dpa_ipsec_df_action {
 						 * performing IP Fragmentation*/
 };
 
+struct dpa_ipsec_l4_params {
+	uint16_t src_port;	/* Source port				      */
+	uint16_t src_port_mask;	/* Source port mask			      */
+	uint16_t dest_port;	/* Destination port			      */
+	uint16_t dest_port_mask;/* Destination port mask		      */
+};
+
+struct dpa_ipsec_icmp_params {
+	uint8_t	icmp_type;	/* Type of ICMP message			      */
+	uint8_t	icmp_type_mask; /* Mask for ICMP type field		      */
+	uint8_t	icmp_code;	/* ICMP message code			      */
+	uint8_t	icmp_code_mask; /* Mask for ICMP code field		      */
+};
+
 /* DPA-IPSec Security Policy Parameters */
 struct dpa_ipsec_policy_params {
 	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
@@ -439,10 +456,10 @@ struct dpa_ipsec_policy_params {
 	uint8_t dest_prefix_len; /* Destination network prefix		      */
 	uint8_t protocol;	/* Protocol				      */
 	bool masked_proto;	/* Mask the entire protocol field	      */
-	uint16_t dest_port;	/* Destination port			      */
-	uint16_t dest_port_mask;/* Destination port mask		      */
-	uint16_t src_port;	/* Source port				      */
-	uint16_t src_port_mask;	/* Source port mask			      */
+	union {
+		struct dpa_ipsec_l4_params	l4;	/* L4 protos params   */
+		struct dpa_ipsec_icmp_params	icmp;	/* ICMP proto params  */
+	};
 	uint16_t mtu;		/* Maximum size of unencrypted fragments.
 				 * Packets with a bigger size will be
 				 * automatically fragmented. 0 = disabled     */
-- 
1.7.5.4

