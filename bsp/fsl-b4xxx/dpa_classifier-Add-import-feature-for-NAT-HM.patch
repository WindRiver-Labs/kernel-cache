From b2cdecf428aa0965d74885e822749114ae2800b1 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 12 Sep 2012 16:01:32 +0000
Subject: [PATCH 302/518] dpa_classifier: Add import feature for NAT HM

Implemented the import feature for the NAT header manipulation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  159 ++++++++++++----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   12 +--
 2 files changed, 91 insertions(+), 80 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index eecdeb4..a000cf5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3009,12 +3009,6 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	if (res) {
-		pr_err("ERROR: %s, %s (%d): Header manipulation import is not "
-			"yet supported.\n", __FILE__, __func__, __LINE__);
-		return -ENOSYS;
-	}
-
 	err = nat_hm_check_params(nat_params);
 	if (err < 0)
 		return err;
@@ -3031,63 +3025,62 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	/* Copy the NAT parameters locally */
 	memcpy(&pnat_hm->nat_params, nat_params, sizeof(*nat_params));
 
-	if (res)
-		/* Need to import */
-		err = import_nat_hm(pnat_hm, res);
-	else {
-		/* Need to create */
-		err = init_nat_hm(pnat_hm);
-		if (err) {
-			dpa_classif_free_hm(*hmd);
-			*hmd = DPA_OFFLD_DESC_NONE;
-			return err;
-		}
-
-		if (chain_head)
-			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pnat_hm->nat_params.fm_pcd,
-				pnat_hm->hm_chain, pnat_hm->hm_chain);
+	err = nat_hm_prepare_nodes(pnat_hm, res);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to acquire necessary HM "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		goto nat_hm_error;
 	}
 
-	if (err) {
-		dpa_classif_free_hm(*hmd);
-		*hmd = DPA_OFFLD_DESC_NONE;
+	err = nat_hm_update_params(pnat_hm);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to update low level header "
+			"manipulation parameters.\n", __FILE__, __func__,
+			__LINE__);
+		goto nat_hm_error;
 	}
 
-	return err;
-}
-EXPORT_SYMBOL(dpa_classif_set_nat_hm);
-
-static int import_nat_hm(struct dpa_cls_hm *pnat_hm,
-				const struct dpa_cls_hm_nat_resources *res)
-{
-	void * const *phm_nodes;
-	int err;
+	if (chain_head)
+		err = init_hm_chain(pnat_hm->nat_params.fm_pcd,
+				pnat_hm->hm_chain,
+				pnat_hm->hm_chain);
 
-	BUG_ON(!pnat_hm);
-	BUG_ON(!res);
+	return err;
 
-	phm_nodes = &res->l3_update_node;
+nat_hm_error:
 
-	err = import_hm_nodes_to_chain(phm_nodes, 2, pnat_hm);
+	remove_hm_op(*hmd);
 
-	/* Update here the HM nodes parameters */
+	*hmd = DPA_OFFLD_DESC_NONE;
 
 	return err;
 }
+EXPORT_SYMBOL(dpa_classif_set_nat_hm);
 
-static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
+static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
+				const struct dpa_cls_hm_nat_resources *res)
 {
 	struct dpa_cls_hm_node *hm_node = NULL;
 	struct dpa_cls_hm *pnext_hm = NULL;
-	unsigned int ip_ver = 0;
+	void * const *phm_nodes;
+	int err = 0;
 	enum dpa_cls_hm_node_type l3_update_node = DPA_CLS_HM_NODE_LAST_ENTRY;
 	enum dpa_cls_hm_node_type l4_update_node = DPA_CLS_HM_NODE_LAST_ENTRY;
+	unsigned int ip_ver = 0;
 
 	BUG_ON(!pnat_hm);
 
-	pnat_hm->num_nodes = 0;
+	pnat_hm->num_nodes = 2;
+
+	if (res) { /* Import HM nodes */
+		phm_nodes = &res->l3_update_node;
+
+		return import_hm_nodes_to_chain(phm_nodes,
+					pnat_hm->num_nodes,
+					pnat_hm);
+	}
 
+	/* Create HM nodes */
 	if (pnat_hm->nat_params.type == DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
 		if (pnat_hm->nat_params.flags &
 			DPA_CLS_HM_NAT_UPDATE_SIP)
@@ -3129,8 +3122,28 @@ static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
 		if (pnext_hm)
 			hm_node = find_compatible_hm_node(l3_update_node,
 							pnext_hm->hm_chain);
+		/* If not, create an L3 update node: */
+		if (!hm_node) {
+			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+			if (!hm_node) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"header manip nodes.\n", __FILE__,
+					__func__, __LINE__);
+				return -ENOMEM;
+			}
+			INIT_LIST_HEAD(&hm_node->list_node);
+			pnat_hm->hm_node[0] = hm_node;
+		}
+	}
+
+	hm_node = NULL;
+	if (l4_update_node != DPA_CLS_HM_NODE_LAST_ENTRY) {
+		/* Check if we can attach to an existing L4 update node */
+		if (pnext_hm)
+			hm_node = find_compatible_hm_node(l4_update_node,
+							pnext_hm->hm_chain);
+		/* If not create an L4 update node: */
 		if (!hm_node) {
-			/* Create an L3 update node: */
 			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
 			if (!hm_node) {
 				pr_err("ERROR: %s, %s (%d): No more memory for "
@@ -3139,13 +3152,39 @@ static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
 				return -ENOMEM;
 			}
 			INIT_LIST_HEAD(&hm_node->list_node);
+			pnat_hm->hm_node[1] = hm_node;
 		}
+	}
+
+	add_local_hm_nodes_to_chain(pnat_hm);
+
+	return err;
+}
+
+static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
+{
+	struct dpa_cls_hm_node *hm_node;
+	unsigned int ip_ver = 0;
+
+	BUG_ON(!pnat_hm);
+
+	if (pnat_hm->hm_node[0]) {
+		hm_node = pnat_hm->hm_node[0];
 
 		hm_node->params.type = e_FM_PCD_MANIP_HDR;
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pnat_hm->nat_params.type ==
 					DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
 			hm_node->params.u.hdr.fieldUpdate = TRUE;
+
+			if (pnat_hm->nat_params.flags &
+				DPA_CLS_HM_NAT_UPDATE_SIP)
+				ip_ver = pnat_hm->nat_params.nat.sip.version;
+			if (pnat_hm->nat_params.flags &
+				DPA_CLS_HM_NAT_UPDATE_DIP)
+				ip_ver = pnat_hm->nat_params.nat.dip.version;
+
 			if (ip_ver == 4) {
 				hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4;
@@ -3233,30 +3272,14 @@ static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
 					ipv6, sizeof(struct ipv6_header));
 			}
 		}
-
-		pnat_hm->hm_node[pnat_hm->num_nodes++] = hm_node;
-		hm_node = NULL;
 	}
 
-	if (l4_update_node != DPA_CLS_HM_NODE_LAST_ENTRY) {
-		/* Check if we can attach to an existing L4 update node */
-		if (pnext_hm)
-			hm_node = find_compatible_hm_node(l4_update_node,
-							pnext_hm->hm_chain);
-		if (!hm_node) {
-			/* Create an L3 update node: */
-			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-			if (!hm_node) {
-				pr_err("ERROR: %s, %s (%d): No more memory for "
-					"header manip nodes.\n", __FILE__,
-					__func__, __LINE__);
-				return -ENOMEM;
-			}
-			INIT_LIST_HEAD(&hm_node->list_node);
-		}
+	if (pnat_hm->hm_node[1]) {
+		hm_node = pnat_hm->hm_node[1];
 
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 		hm_node->params.u.hdr.fieldUpdateParams.type =
 				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP;
 
@@ -3273,20 +3296,16 @@ static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
 			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.dst =
 				pnat_hm->nat_params.dport;
 		}
-
-		pnat_hm->hm_node[pnat_hm->num_nodes++] = hm_node;
 	}
 
-	add_local_hm_nodes_to_chain(pnat_hm);
-
 	return 0;
 }
 
 int dpa_classif_modify_nat_hm(int hmd,
 	const struct dpa_cls_hm_nat_params *new_nat_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): NAT HM runtime modification not supported "
-		"yet.\n", __FILE__, __func__, __LINE__);
+	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
+		__LINE__);
 	return -ENOSYS;
 }
 EXPORT_SYMBOL(dpa_classif_modify_nat_hm);
@@ -3470,8 +3489,8 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 int dpa_classif_modify_fwd_hm(int hmd,
 	const struct dpa_cls_hm_fwd_params *new_fwd_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Forwarding HM runtime modification not "
-		"supported yet.\n", __FILE__, __func__, __LINE__);
+	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
+		__LINE__);
 	return -ENOSYS;
 }
 EXPORT_SYMBOL(dpa_classif_modify_fwd_hm);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 946ba90..c0792c7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -414,18 +414,10 @@ static void remove_hm_op(int hmd);
  */
 static int nat_hm_check_params(const struct dpa_cls_hm_nat_params *nat_params);
 
-/*
- * Imports the low level header manipulation nodes for a NAT classifier header
- * manipulation op.
- */
-static int import_nat_hm(struct dpa_cls_hm *pnat_hm,
+static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 				const struct dpa_cls_hm_nat_resources *res);
 
-/*
- * Creates the low level header manipulation nodes for a NAT classifier header
- * manipulation op.
- */
-static int init_nat_hm(struct dpa_cls_hm *pnat_hm);
+static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm);
 
 /*
  * Verifies that the parameters provided for a Forwarding type header
-- 
1.7.5.4

