From 56022bc46912f7704e377bb82fc1cf5299dbe140 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 12 Nov 2012 21:55:51 +0000
Subject: [PATCH 409/518] dpa_classifier_wrapper: Ignore "fm_pcd" parameter
 when header manipulations are imported

The dpa_classifier HM API states that the pointer to the PCD is mandatory
only when the header manipulation operations are created at runtime. When
the operations are imported (i.e. were created externally, by means other
than the dpa_classifier API) this pointer is not needed. In these cases
providing garbage in this pointer should not impact the driver in any way.

The dpa_classifier_wrapper, however, was always attempting to translate this
pointer and when garbage was provided, it would incorrectly issue an error.
This was fixed and the "fm_pcd" handle is translated only when the header
manipulations are supposed to be created at runtime. Otherwise it is ignored.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   69 +++++++++-----------
 1 files changed, 31 insertions(+), 38 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 45818e9..68a35de 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -728,17 +728,17 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.remove_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.rm_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.rm_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.rm_params.fm_pcd);
 		if (!kparam.rm_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.remove_node)
-		p_res = &kparam.res;
-
 	ret = dpa_classif_set_remove_hm(&kparam.rm_params, kparam.next_hmd,
 					&kparam.hmd, kparam.chain_head,
 					p_res);
@@ -841,17 +841,17 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.insert_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.ins_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.ins_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.ins_params.fm_pcd);
 		if (!kparam.ins_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.insert_node)
-		p_res = &kparam.res;
-
 	if (kparam.ins_params.type == DPA_CLS_HM_INSERT_CUSTOM) {
 		sz = kparam.ins_params.custom.size;
 		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
@@ -990,21 +990,20 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.vlan_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.vlan_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.vlan_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.vlan_params.fm_pcd);
 		if (!kparam.vlan_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.vlan_node)
-			p_res = &kparam.res;
-
 	ret = dpa_classif_set_vlan_hm(&kparam.vlan_params, kparam.next_hmd,
 				      &kparam.hmd, kparam.chain_head,
 				      p_res);
-
 	if (ret < 0)
 			return ret;
 
@@ -1102,21 +1101,20 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.nat_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.nat_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.nat_params.fm_pcd);
 		if (!kparam.nat_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
-		p_res = &kparam.res;
-
 	ret =  dpa_classif_set_nat_hm(&kparam.nat_params, kparam.next_hmd,
 				      &kparam.hmd, kparam.chain_head,
 				      p_res);
-
 	if (ret < 0)
 			return ret;
 
@@ -1213,22 +1211,20 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.ip_frag_node || kparam.res.update_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.update_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.update_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.update_params.fm_pcd);
 		if (!kparam.update_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.ip_frag_node || kparam.res.update_node)
-		p_res = &kparam.res;
-
 	ret =  dpa_classif_set_update_hm(&kparam.update_params, kparam.next_hmd,
 					&kparam.hmd, kparam.chain_head,
 					p_res);
-
-
 	if (ret < 0)
 			return ret;
 
@@ -1325,23 +1321,21 @@ static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
+	    kparam.res.pppoe_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.fwd_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.fwd_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.fwd_params.fm_pcd);
 		if (!kparam.fwd_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
-	    kparam.res.pppoe_node)
-		p_res = &kparam.res;
-
 	ret = dpa_classif_set_fwd_hm(&kparam.fwd_params, kparam.next_hmd,
 				&kparam.hmd, kparam.chain_head,
 				p_res);
-
-
 	if (ret < 0)
 			return ret;
 
@@ -1437,21 +1431,20 @@ static long  do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
+	if (kparam.res.ins_rm_node)
+		p_res = &kparam.res;
+
 	/* Translate FM_PCD file descriptor */
-	if ((long)kparam.mpls_params.fm_pcd >= 0) {
+	if (!p_res) {
 		kparam.mpls_params.fm_pcd =
 			translate_fm_pcd_handle(kparam.mpls_params.fm_pcd);
 		if (!kparam.mpls_params.fm_pcd)
 			return -EINVAL;
 	}
 
-	if (kparam.res.ins_rm_node)
-		p_res = &kparam.res;
-
 	ret = dpa_classif_set_mpls_hm(&kparam.mpls_params, kparam.next_hmd,
 				&kparam.hmd, kparam.chain_head,
 				p_res);
-
 	if (ret < 0)
 		return ret;
 
@@ -2325,8 +2318,8 @@ void *translate_fm_pcd_handle(void *fm_pcd)
 
 	fm_pcd_file = fcheck((unsigned long)fm_pcd);
 	if (!fm_pcd_file) {
-		pr_err("ERROR: %s, %s (%d): Could not translate PCD handle.\n",
-			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): Could not translate PCD handle "
+			"fm_pcd=0x%p.\n", __FILE__, __func__, __LINE__, fm_pcd);
 		return NULL;
 	}
 	fm_wrapper_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-- 
1.7.5.4

