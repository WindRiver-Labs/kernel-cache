From 5cc706ab919a51aded27d791a42a4e7124a49927 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 29 Oct 2012 21:35:02 +0000
Subject: [PATCH 345/518] dpa_classifier: Add support for inserting IP headers
 w/ options in HM API

The "update" header manipulation and also the NAT-PT header manipulation
allows the user to configure a replacement of IPv4 with IPv6 and
vice-versa. When configuring the replacement of IPv6 with IPv4 however,
the user could only provide a standard IPv4 header (struct iphdr) which
does not include IPv4 options. The FMD however is using a buffer where
the user can place any kind of IPv4 header (with or w/o options). The DPA
Classifier API was updated to remove this limitation and now the user can
provide an IPv4 header in an iphdr data structure as well as a buffer
eventually storing IPv4 options:

struct ipv4_header {
	/* IPv4 header */
	struct iphdr			header;

	/* IPv4 options buffer. NULL for no options. */
	uint8_t				*options;

	/* Size of IPv4 options buffer. Zero for no options. */
	unsigned int			options_size;
};

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   21 ++++++++++++++++++---
 include/linux/fsl_dpa_classifier.h               |   14 +++++++-------
 include/linux/fsl_dpa_offload.h                  |   13 +++++++++++++
 3 files changed, 38 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index c62b9e7..119535f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3762,11 +3762,19 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 			e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4;
 				hm_node->params.u.hdr.customParams.u.
 					ipHdrReplace.hdrSize =
-						sizeof(struct iphdr);
+						sizeof(struct iphdr) +
+			pnat_hm->nat_params.nat_pt.new_header.ipv4.options_size;
 				memcpy(hm_node->params.u.hdr.customParams.u.
 					ipHdrReplace.hdr,
 					&pnat_hm->nat_params.nat_pt.new_header.
-					ipv4, sizeof(struct iphdr));
+					ipv4.header, sizeof(struct iphdr));
+	if ((pnat_hm->nat_params.nat_pt.new_header.ipv4.options_size)
+		&& (pnat_hm->nat_params.nat_pt.new_header.ipv4.options)) {
+		memcpy(&hm_node->params.u.hdr.customParams.u.ipHdrReplace.
+				hdr[sizeof(struct iphdr)],
+			&pnat_hm->nat_params.nat_pt.new_header.ipv4.options,
+		pnat_hm->nat_params.nat_pt.new_header.ipv4.options_size);
+	}
 			} else {
 				hm_node->params.u.hdr.customParams.u.
 					ipHdrReplace.replaceType =
@@ -4891,8 +4899,15 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 				hdrSize = (uint8_t)sizeof(struct iphdr);
 			memcpy(hm_node->params.u.hdr.customParams.u.
 				ipHdrReplace.hdr,
-				&pupdate_hm->update_params.replace.new_ipv4_hdr,
+			&pupdate_hm->update_params.replace.new_ipv4_hdr.header,
 				sizeof(struct iphdr));
+	if ((pupdate_hm->update_params.replace.new_ipv4_hdr.options_size)
+		&& (pupdate_hm->update_params.replace.new_ipv4_hdr.options)) {
+		memcpy(&hm_node->params.u.hdr.customParams.u.ipHdrReplace.
+				hdr[sizeof(struct iphdr)],
+			&pupdate_hm->update_params.replace.new_ipv4_hdr.options,
+		pupdate_hm->update_params.replace.new_ipv4_hdr.options_size);
+	}
 		}
 	}
 
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 4bb1008..9b85610 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -38,8 +38,6 @@
 #define __FSL_DPA_CLASSIFIER_H
 
 
-#include <linux/ip.h>
-
 /* DPA offloading layer includes */
 #include "fsl_dpa_compat.h"
 #include "fsl_dpa_offload.h"
@@ -511,7 +509,7 @@ struct dpa_cls_hm_nat_pt_params {
 
 	union {
 		/* New IPv4 header data to replace IPv6 with */
-		struct iphdr			ipv4;
+		struct ipv4_header		ipv4;
 
 		/* New IPv6 header data to replace IPv4 with */
 		struct ipv6_header		ipv6;
@@ -585,7 +583,8 @@ enum dpa_cls_hm_fwd_modify_flags {
 	DPA_CLS_HM_FWD_MOD_PPPoE_HEADER		= 0x04,
 	DPA_CLS_HM_FWD_MOD_PPP_PID		= 0x08,
 	DPA_CLS_HM_FWD_MOD_IP_FRAG_MTU		= 0x10,
-	DPA_CLS_HM_FWD_MOD_IP_FRAG_SCRATCH_BPID	= 0x20
+	DPA_CLS_HM_FWD_MOD_IP_FRAG_SCRATCH_BPID	= 0x20,
+	DPA_CLS_HM_FWD_MOD_IP_FRAG_DF_ACTION	= 0x40
 };
 
 enum dpa_cls_hm_frag_df_action {
@@ -934,7 +933,8 @@ enum dpa_cls_hm_update_modify_flags {
 	DPA_CLS_HM_UPDATE_MOD_L4_FLAGS		= 0x0100,
 
 	DPA_CLS_HM_UPDATE_MOD_IP_FRAG_MTU	= 0x0200,
-	DPA_CLS_HM_UPDATE_MOD_IP_FRAG_SCRATCH_BPID = 0x0400
+	DPA_CLS_HM_UPDATE_MOD_IP_FRAG_SCRATCH_BPID = 0x0400,
+	DPA_CLS_HM_UPDATE_MOD_IP_FRAG_DF_ACTION = 0x0800
 };
 
 /* L3 protocols field update parameters */
@@ -1004,10 +1004,10 @@ struct dpa_cls_hm_update_params {
 
 	union {
 		/*
-		 * IPv4 header data. This header is used IPv6 to IPv4 header
+		 * IPv4 header data. This header is used for IPv6 to IPv4 header
 		 * replace.
 		 */
-		struct iphdr				new_ipv4_hdr;
+		struct ipv4_header			new_ipv4_hdr;
 
 		/*
 		 * IPv6 header data. This header is used for IPv4 to IPv6
diff --git a/include/linux/fsl_dpa_offload.h b/include/linux/fsl_dpa_offload.h
index 804b7e2..8791341 100644
--- a/include/linux/fsl_dpa_offload.h
+++ b/include/linux/fsl_dpa_offload.h
@@ -39,7 +39,9 @@
 
 
 #include "fsl_dpa_compat.h"
+
 #include <linux/if_ether.h>
+#include <linux/ip.h>
 
 
 /* General definitions */
@@ -139,6 +141,17 @@ struct ipv6_header {
 	union dpa_offload_ipv6_address	ipda;		/* Destination addr */
 };
 
+struct ipv4_header {
+	/* IPv4 header */
+	struct iphdr			header;
+
+	/* IPv4 options buffer. NULL for no options. */
+	uint8_t				*options;
+
+	/* Size of IPv4 options buffer. Zero for no options. */
+	unsigned int			options_size;
+};
+
 /* Description of the VLAN header */
 struct vlan_header {
 	uint16_t			tpid;
-- 
1.7.5.4

