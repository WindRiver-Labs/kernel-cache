From 2446fcda7ba7df15f09799e99f586bd3a07ac751 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 7 Sep 2012 20:20:16 +0000
Subject: [PATCH 312/518] dpa_stats: Fix class counter of type Reassembly or
 Policer

Copy the user-space array of reassembly/policer handles into a
kernel allocated array.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   47 ++++++++++++++++++++++-
 1 files changed, 46 insertions(+), 1 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 1713d7e..2baba1e 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -77,6 +77,8 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		struct dpa_offload_lookup_key *dst);
 
+static int copy_class_members(void *objs, unsigned int size, void *dst);
+
 int wrp_dpa_stats_init(void)
 {
 	/* Cannot initialize the wrapper twice */
@@ -381,6 +383,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 	struct dpa_offload_lookup_key key;
 	struct dpa_stats_cnt_eth_src *eth_src = NULL;
 	uint32_t i = 0, eth_src_size = 0;
+	void *cls_objs = NULL;
 	int *sa_ids = NULL;
 	long ret = 0;
 
@@ -409,9 +412,28 @@ static int do_ioctl_stats_create_class_counter(void *args)
 			kfree(eth_src);
 			return -EBUSY;
 		}
-
 		prm.cnt_params.eth_params.src = eth_src;
 		break;
+	case DPA_STATS_CNT_REASS:
+		ret = copy_class_members(cls_objs,
+				prm.cnt_params.class_members,
+				prm.cnt_params.reass_params.reass);
+		if (ret < 0) {
+			pr_err("Could not copy array of reass objects\n");
+			kfree(cls_objs);
+			return -EBUSY;
+		}
+		break;
+	case DPA_STATS_CNT_POLICER:
+		ret = copy_class_members(cls_objs,
+				prm.cnt_params.class_members,
+				prm.cnt_params.plcr_params.plcr);
+		if (ret < 0) {
+			pr_err("Could not copy array of policer objects\n");
+			kfree(cls_objs);
+			return -EBUSY;
+		}
+		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
 		tbl = &prm.cnt_params.classif_tbl_params;
 
@@ -498,6 +520,10 @@ static int do_ioctl_stats_create_class_counter(void *args)
 	case DPA_STATS_CNT_ETH:
 		kfree(eth_src);
 		break;
+	case DPA_STATS_CNT_REASS:
+	case DPA_STATS_CNT_POLICER:
+		kfree(cls_objs);
+		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
 		tbl = &prm.cnt_params.classif_tbl_params;
 
@@ -768,3 +794,22 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 
 	return 0;
 }
+
+static int copy_class_members(void *objs, unsigned int size, void *dst)
+{
+	/* Allocate memory to store the array of reass objects */
+	objs = kmalloc(size, GFP_KERNEL);
+	if (!objs) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(objs, dst, (size * sizeof(void *)))) {
+		pr_err("Could not copy array of objects\n");
+		kfree(objs);
+		return -EBUSY;
+	}
+	dst = objs;
+
+	return 0;
+}
-- 
1.7.5.4

