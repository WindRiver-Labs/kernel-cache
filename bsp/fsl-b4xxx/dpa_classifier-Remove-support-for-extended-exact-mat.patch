From 022392f5458d426b33d27f3322974d399526590d Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 3 Aug 2012 23:32:26 +0000
Subject: [PATCH 223/518] dpa_classifier: Remove support for extended exact
 match tables

The support for extended exact match tables (where Cc nodes are created
internally by the DPA Classifier and cascaded with the initial Cc node
to get a number of exact match entries which is greater than what a
single Cc node can support) is proving to create more challenges than
benefits.

With the introduction of per Cc node statistics types in FMan driver
(FMD), the extended exact match tables need an additional parameter
to survive. As this feature of the exact match table was not used by
any customer yet, we see no reason to add complexity to the API just
to keep it. The support for extended exact match tables was removed.
Henceforth, the exact match tables will map only on the capabilities
of the FMan low level driver (FMD).

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  267 ++++------------------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |    6 -
 2 files changed, 39 insertions(+), 234 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 254a8f2..5aac8d6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -124,9 +124,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 		break;
 
 	case DPA_CLS_TBL_EXACT_MATCH:
-		ptable->int_cc_nodes_count = (unsigned int)
-			ptable->params.exact_match_params.entries_cnt /
-			DPA_CLS_TBL_MAXSHADOWTABLESIZE + 1;
+		ptable->int_cc_nodes_count = 1;
 		if (ptable->params.entry_mgmt ==
 				DPA_CLS_TBL_MANAGE_BY_KEY)
 			/* Set shadow table size */
@@ -170,13 +168,6 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			INIT_LIST_HEAD(&ptable->shadow_table->shadow_entry[i]);
 	}
 
-	/* Miss action is drop by default */
-	ptable->miss_next_engine_params.nextEngine = e_FM_PCD_DONE;
-	ptable->miss_next_engine_params.params.enqueueParams.action =
-		e_FM_PCD_DROP_FRAME;
-	ptable->miss_next_engine_params.statisticsEn =
-		TRUE;
-
 	table[*td] = ptable;
 	init_crc8_table(CRC8_WCDMA_POLY);
 
@@ -297,24 +288,8 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 	}
 }
 	} else {
-		/*
-		 * For exact match tables, the miss action is updated on the
-		 * last USED Cc node in the chain
-		 */
-		for (i = 0; i < ptable->int_cc_nodes_count; i++) {
-			if (!ptable->int_cc_node[i].used)
-				break;
-		}
-
-		/*
-		 * If none of the Cc nodes are used, adjust the index so that
-		 * the miss action is configured on the first table.
-		 */
-		if (i == 0)
-			i = 1;
-
-	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
-			int_cc_node[i-1].cc_node, &miss_engine_params);
+		err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
+			int_cc_node[0].cc_node, &miss_engine_params);
 		if (err != E_OK) {
 			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
 				__func__);
@@ -323,10 +298,6 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 		}
 	}
 
-	/* Store the miss next engine params */
-	memcpy(&ptable->miss_next_engine_params, &miss_engine_params,
-		sizeof(t_FmPcdCcNextEngineParams));
-
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_table_modify_miss_action);
@@ -1257,9 +1228,6 @@ table_init_hash_error:
 static int table_init_exact_match(struct dpa_cls_table *cls_table)
 {
 	int err = 0;
-	t_FmPcdCcNodeParams *cc_node_params = NULL;
-	unsigned int i;
-	t_Handle fm_pcd;
 
 	BUG_ON(!cls_table);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
@@ -1270,66 +1238,8 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 
 	/* First Cc node is the one that the user provided */
 	cls_table->int_cc_node[0].cc_node = cls_table->params.cc_node;
-
-	/* Create additional Cc nodes if necessary */
-	cc_node_params = kzalloc(sizeof(*cc_node_params), GFP_KERNEL);
-	if (!cc_node_params) {
-		pr_err("No more memory for DPA Classifier exact match table.");
-		err = -ENOMEM;
-		goto table_init_exact_match_error;
-	}
-	cc_node_params->keysParams.numOfKeys = 0;
-	cc_node_params->keysParams.keySize =
-		cls_table->params.exact_match_params.key_size;
-	cc_node_params->keysParams.maskSupport = TRUE;
-	cc_node_params->keysParams.ccNextEngineParamsForMiss.nextEngine =
-		e_FM_PCD_DONE;
-	cc_node_params->keysParams.ccNextEngineParamsForMiss.params.
-		enqueueParams.action = e_FM_PCD_DROP_FRAME;
-
-	cc_node_params->extractCcParams.type =
-		e_FM_PCD_EXTRACT_NON_HDR;
-	cc_node_params->extractCcParams.extractNonHdr.src =
-		e_FM_PCD_EXTRACT_FROM_KEY;
-	cc_node_params->extractCcParams.extractNonHdr.action =
-		e_FM_PCD_ACTION_EXACT_MATCH;
-	cc_node_params->extractCcParams.extractNonHdr.offset = 0;
-	cc_node_params->extractCcParams.extractNonHdr.size =
-		cls_table->params.exact_match_params.key_size;
-
-	fm_pcd = (t_Handle)cls_table->params.fm_pcd;
-	for (i = 0; i < cls_table->int_cc_nodes_count; i++) {
-		if (i > 0) { /* First node provided by user. Doesn't need to be
-				* created */
-
-			cc_node_params->keysParams.maxNumOfKeys = (uint16_t)
-		(cls_table->params.exact_match_params.entries_cnt -
-		(i * DPA_CLS_TBL_MAXSHADOWTABLESIZE));
-			if (cc_node_params->keysParams.maxNumOfKeys >
-				DPA_CLS_TBL_MAXSHADOWTABLESIZE)
-				cc_node_params->keysParams.maxNumOfKeys =
-					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
-			/* Dynamically create Cc node */
-			cls_table->int_cc_node[i].cc_node =
-				(void *)FM_PCD_MatchTableSet(fm_pcd,
-					cc_node_params);
-			if (!cls_table->int_cc_node[i].cc_node) {
-				pr_err("%s: FM_PCD_MatchTableSet\n", __func__);
-				pr_err("FMan driver call failed.");
-				err = -EBUSY;
-				goto table_init_exact_match_error;
-			}
-		}
-
-		/* Set the table size */
-		if (i < (cls_table->int_cc_nodes_count - 1))
-			cls_table->int_cc_node[i].table_size =
-				FM_PCD_MAX_NUM_OF_KEYS;
-		else
-			cls_table->int_cc_node[i].table_size =
-			cls_table->params.exact_match_params.entries_cnt -
-			(i * FM_PCD_MAX_NUM_OF_KEYS);
-	}
+	cls_table->int_cc_node[0].table_size =
+		cls_table->params.exact_match_params.entries_cnt;
 
 	/* Allocate the index management array */
 	cls_table->entries_cnt =
@@ -1345,13 +1255,9 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	}
 	INIT_LIST_HEAD(&cls_table->entry_list);
 
-	kfree(cc_node_params);
-
 	return err;
 
 table_init_exact_match_error:
-	kfree(cc_node_params);
-
 	table_cleanup_exact_match(cls_table);
 
 	free_table_management(cls_table);
@@ -1408,39 +1314,8 @@ static void table_cleanup_indexed(struct dpa_cls_table *cls_table)
 
 static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 {
-	t_FmPcdCcNextEngineParams cc_miss_engine_params;
-	unsigned int i;
-	t_Error err;
-	t_Handle cc_node;
-
-	BUG_ON(!cls_table);
-	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
-
-	/* Uncouple the first Cc node from the initial one */
-	memset(&cc_miss_engine_params, 0, sizeof(cc_miss_engine_params));
-	cc_miss_engine_params.nextEngine = e_FM_PCD_DONE;
-	cc_miss_engine_params.params.enqueueParams.action = e_FM_PCD_DROP_FRAME;
-
-	if (cls_table->int_cc_nodes_count > 1) {
-		cc_node = (t_Handle)cls_table->int_cc_node[0].cc_node;
-		/*
-		 * We can only delete nodes if the miss action of the initial
-		 * node doesn't point to the dynamic Cc node chain
-		 */
-		err = FM_PCD_MatchTableModifyMissNextEngine(cc_node,
-				&cc_miss_engine_params);
-		if (err == E_OK) {
-			for (i = 1; (i < cls_table->int_cc_nodes_count) &&
-				(cls_table->int_cc_node[i].cc_node); i++)
-				FM_PCD_MatchTableDelete((t_Handle)cls_table->
-					int_cc_node[i].cc_node);
-		} else {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
-			pr_warn("Classifier failed to clean exact match table");
-		}
-	}
+	/* Nothing special to do */
+	return;
 }
 
 static int verify_table_params(const struct dpa_cls_tbl_params *params)
@@ -1452,13 +1327,15 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 
 	switch (params->type) {
 	case DPA_CLS_TBL_EXACT_MATCH:
-		/*
-		 * Warning of performance penalties if the exact match table is
-		 * implemented with more than 3 nested Cc nodes.
-		 */
 		if (params->exact_match_params.entries_cnt >
-				3 * FM_PCD_MAX_NUM_OF_KEYS) {
-			pr_warn("Large exact match tables might cause performance penalties.");
+				FM_PCD_MAX_NUM_OF_KEYS) {
+			pr_err("ERROR: %s, %s (%d): Specified number of entries"
+				"(%d) for exact match table exceeds the maximum"
+				"capacity of this type of table (%d).\n",
+				__FILE__, __func__, __LINE__,
+				params->exact_match_params.entries_cnt,
+				FM_PCD_MAX_NUM_OF_KEYS);
+			err = -EINVAL;
 			break;
 		}
 
@@ -1470,15 +1347,6 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 			err = -EINVAL;
 			break;
 		}
-
-		if ((params->exact_match_params.use_priorities) &&
-				(params->exact_match_params.entries_cnt >
-				FM_PCD_MAX_NUM_OF_KEYS)) {
-			pr_err("Entry priorities for exact match tables are supported only for small tables (<= %d entries).",
-				FM_PCD_MAX_NUM_OF_KEYS);
-			err = -ENOSYS;
-			break;
-		}
 		break;
 	case DPA_CLS_TBL_HASH:
 		if (params->hash_params.num_sets > FM_PCD_MAX_NUM_OF_KEYS) {
@@ -1698,8 +1566,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	int errno = 0;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry = NULL;
 	t_FmPcdCcKeyParams key_params;
-	t_FmPcdCcNextEngineParams cc_miss_engine_params;
-	int i = 0, j, k;
+	int i = 0, k;
 	uint8_t shadow_table_index;
 	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
@@ -1731,16 +1598,12 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	if (errno < 0)
 		goto table_insert_entry_exact_match_error;
 
-	/* Find an empty spot for this entry, at the end of an existing Cc
-	 * node */
-	while ((i < cls_table->int_cc_nodes_count) &&
-			(cls_table->int_cc_node[i].used >=
-			cls_table->int_cc_node[i].table_size)) {
-		i++;
-	}
-	if (i >= cls_table->int_cc_nodes_count) {
+	if (cls_table->int_cc_node[0].used >=
+		cls_table->int_cc_node[0].table_size) {
 		/* No more space to add a new entry */
-		pr_err("DPA Classifier exact match table is full. Unable to add a new entry.");
+		pr_err("ERROR: %s, %s (%d): DPA Classifier exact match table "
+			"is full. Unable to add a new entry.\n",
+			__FILE__, __func__, __LINE__);
 		errno = -ENOSPC;
 		goto table_insert_entry_exact_match_error;
 	}
@@ -1755,10 +1618,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	/* Clean up and prepare the index entry */
 	memset(&cls_table->entry[k], 0,
 		sizeof(struct dpa_cls_tbl_entry));
-	cls_table->entry[k].int_cc_node_index	= (unsigned)i;
-	cls_table->entry[k].priority		= priority;
+	cls_table->entry[k].priority = priority;
 	cls_table->entry[k].entry_index =
-				(uint8_t)cls_table->int_cc_node[i].used;
+				(uint8_t)cls_table->int_cc_node[0].used;
 
 	/* Calculate the position in the index management list where this entry
 	 * should go */
@@ -1767,8 +1629,6 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		list_current = &cls_table->entry_list;
 	else {
 		if (cls_table->params.exact_match_params.use_priorities) {
-			BUG_ON(cls_table->entry[k].int_cc_node_index != 0);
-
 			/*
 			 * Have to recalculate the position of this entry based
 			 * on its priority.
@@ -1777,85 +1637,36 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			 * Find the first entry with a priority value which is
 			 * higher than or equal to the one to add
 			 */
-			list_for_each(list_current, &cls_table->entry_list) {
-				index_entry = list_entry(list_current,
-						struct dpa_cls_tbl_entry,
-						list_node);
+			list_for_each_entry(index_entry,
+						&cls_table->entry_list,
+						list_node) {
 				if (index_entry->priority >= priority)
 					break;
 			}
 			/* If there are such entries in the list */
-			if (list_current != &cls_table->entry_list) {
+			if (&index_entry->list_node != &cls_table->entry_list) {
 				/* Shall add this entry in the position of
 				 * the [current] one */
 				cls_table->entry[k].entry_index =
 					index_entry->entry_index;
-			}
-			/* Otherwise let the entry be added at the end of the
-			 * table */
-		} else
-			/* If priorities are not used, sort the index
-			 * management list based on [cc_node_index] and
-			 * [entry_index]. In other words, add the current entry
-			 * before the first entry of the next cc node */
-			if (i < cls_table->int_cc_nodes_count - 1)
-				list_for_each(list_current,
-					      &cls_table->entry_list) {
-					index_entry = list_entry(list_current,
-						struct dpa_cls_tbl_entry,
-						list_node);
-					if (index_entry->int_cc_node_index > i)
-						break;
-				}
-			else
+				list_current = &index_entry->list_node;
+			} else
+				/*
+				 * Otherwise let the entry be added at the end
+				 * of the table
+				 */
 				list_current = &cls_table->entry_list;
-	}
-
-	if ((i > 0) && (!cls_table->int_cc_node[i].used)) {
-		/* Check whether this is the last used node */
-		for (j = i; j < cls_table->int_cc_nodes_count; j++) {
-			if (cls_table->int_cc_node[j].used)
-				break;
-		}
-
-		if (j >= cls_table->int_cc_nodes_count) {
-			/* Last used node */
+		} else
 			/*
-			 * Make sure this node is properly connected on the
-			 * miss relationship with the previous node
+			 * If priorities are not used add the entry at the end
+			 * of the table
 			 */
-			memset(&cc_miss_engine_params, 0,
-				sizeof(t_FmPcdCcNextEngineParams));
-			cc_miss_engine_params.nextEngine = e_FM_PCD_CC;
-			cc_miss_engine_params.params.ccParams.h_CcNode =
-				(t_Handle)cls_table->int_cc_node[i].cc_node;
-
-	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
-		int_cc_node[i-1].cc_node, &cc_miss_engine_params);
-		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
-			errno = -EBUSY;
-			goto table_insert_entry_exact_match_error;
-		}
-
-	/* Set the table miss action on this node */
-	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
-		int_cc_node[i].cc_node, &cls_table->miss_next_engine_params);
-		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
-			errno = -EBUSY;
-			goto table_insert_entry_exact_match_error;
-		}
-		}
+			list_current = &cls_table->entry_list;
 	}
 
 	/* Add the key to the selected Cc node */
 	err = FM_PCD_MatchTableAddKey((t_Handle)cls_table->
-			int_cc_node[i].cc_node,
+			int_cc_node[0].cc_node,
 		cls_table->entry[k].entry_index,
 		cls_table->params.exact_match_params.key_size,
 		&key_params);
@@ -1885,7 +1696,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		list_current = list_current->next;
 	}
 
-	cls_table->int_cc_node[i].used++;
+	cls_table->int_cc_node[0].used++;
 
 	/* If shadow table exists, add the entry to it */
 	if (cls_table->shadow_table) {
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index df91d3f..d2ba7c3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -191,12 +191,6 @@ struct dpa_cls_table {
 
 	/* (Initial) parameters of the DPA Classifier table. */
 	struct dpa_cls_tbl_params		params;
-
-	/*
-	 * The current miss next engine paramas for this table (for
-	 * exact match and HASH tables).
-	 */
-	t_FmPcdCcNextEngineParams		miss_next_engine_params;
 };
 
 
-- 
1.7.5.4

