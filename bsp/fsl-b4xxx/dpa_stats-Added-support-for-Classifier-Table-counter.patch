From 9538a1d919b0f67bebef9194c96ae937c050e6d3 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:56:37 +0000
Subject: [PATCH 256/518] dpa_stats: Added support for Classifier Table
 counter

Added support for Classifier Table single and class counter.
Application can use this counter to retrieve statistics for
one or multiple entries of a Classifier Table.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  375 +++++++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_stats.h |   18 ++
 include/linux/fsl_dpa_stats.h               |  109 ++++++++
 3 files changed, 502 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 3433d20..b699877 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -41,7 +41,11 @@
 #include "dpa_compat.h"
 #include "dpa_stats.h"
 
+/* FMD includes */
+#include "fm_pcd_ext.h"
+
 #define STATS_VAL_SIZE 4
+#define CLASSIF_STATS_SHIFT 4
 
 /* Global dpa_stats component */
 struct dpa_stats *gbl_dpa_stats;
@@ -416,6 +420,91 @@ static void create_cnt_plcr_stats(struct dpa_stats *dpa_stats)
 		e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER;
 }
 
+static void create_classif_stats(struct dpa_stats *dpa_stats)
+{
+	t_FmPcdCcKeyStatistics   stats;
+
+	/* DPA_STATS_CNT_CLASSIF_BYTES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][0] =
+			(void *)&stats.byteCount - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_PACKETS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][1] = (void *)
+			&stats.frameLengthRangeCount[0] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE1 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][2] = (void *)
+			&stats.frameLengthRangeCount[0] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE2 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][3] = (void *)
+			&stats.frameLengthRangeCount[1] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE3 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][4] = (void *)
+			&stats.frameLengthRangeCount[2] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE4 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][5] = (void *)
+			&stats.frameLengthRangeCount[3] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE5 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][6] = (void *)
+			&stats.frameLengthRangeCount[4] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE6 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][7] = (void *)
+			&stats.frameLengthRangeCount[5] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE7 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][8] = (void *)
+			&stats.frameLengthRangeCount[6] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE8 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][9] = (void *)
+			&stats.frameLengthRangeCount[7] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE9 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][10] = (void *)
+			&stats.frameLengthRangeCount[8] - (void *)&stats;
+	/* DPA_STATS_CNT_CLASSIF_RANGE10 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][11] = (void *)
+			&stats.frameLengthRangeCount[9] - (void *)&stats;
+}
+
+static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
+		struct dpa_offload_lookup_key *dst)
+{
+	/* Check that key byte pointer is valid */
+	if (!src->byte) {
+		pr_err("Key byte pointer can't be NULL\n");
+		return -EINVAL;
+	}
+
+	/* Check that key mask pointer is valid */
+	if (!src->mask) {
+		pr_err("Key mask pointer can't be NULL\n");
+		return -EINVAL;
+	}
+
+	/* Check that key size is not zero */
+	if (!src->size) {
+		pr_err("Key size can't be zero\n");
+		return -EINVAL;
+	}
+
+	/* Allocate memory to store the key byte array */
+	dst->byte = kmalloc(src->size, GFP_KERNEL);
+	if (!dst->byte) {
+		pr_err("No more memory for key byte\n");
+		return -ENOMEM;
+	}
+	memcpy(dst->byte, src->byte, src->size);
+
+	/* Allocate memory to store the key mask array */
+	dst->mask = kmalloc(src->size, GFP_KERNEL);
+	if (!dst->mask) {
+		pr_err("No more memory for key mask\n");
+		return -ENOMEM;
+	}
+	memcpy(dst->mask, src->mask, src->size);
+
+	/* Store the key size */
+	dst->size = src->size;
+
+	return 0;
+}
+
 static t_Handle get_fman_ethernet_dev_node(
 		struct device_node *parent_dev_node, int port_id)
 {
@@ -692,6 +781,68 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_classif_tbl_cb *cnt_tbl_cb = &cnt_cb->tbl_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_stats_cnt_classif_tbl prm = params->classif_tbl_params;
+	struct dpa_cls_tbl_params cls_tbl;
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t cnt_sel = prm.cnt_sel;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Classifier Table counter selection */
+	if (!((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
+			(cnt_sel <= DPA_STATS_CNT_CLASSIF_RANGE10))) {
+		pr_err("Invalid Classifier Table counter selection");
+		return -EINVAL;
+	}
+
+	err = dpa_classif_table_get_params(prm.td, &cls_tbl);
+	if (err != 0) {
+		pr_err("Invalid Classifier Table descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Copy the key descriptor */
+	err = copy_key_descriptor(&prm.key, &cnt_tbl_cb->keys[0].key);
+	if (err != 0) {
+		pr_err("Unable to copy key descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Store CcNode handle and set number of keys to one */
+	cnt_tbl_cb->keys[0].cc_node = cls_tbl.cc_node;
+	cnt_tbl_cb->keys_num = 1;
+
+	/* Check the Classifier Table counter */
+	err = FM_PCD_MatchTableFindNGetKeyStatistics(
+			cnt_cb->tbl_cb.keys[0].cc_node,
+			cnt_cb->tbl_cb.keys[0].key.size,
+			cnt_cb->tbl_cb.keys[0].key.byte,
+			cnt_cb->tbl_cb.keys[0].key.mask, &stats);
+	if (err != 0) {
+		pr_err("Invalid Classifier Table counter parameters\n");
+		return -EINVAL;
+	}
+
+	/* Map Classifier Table counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_tbl_cb->info,
+		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+		(cnt_sel >> CLASSIF_STATS_SHIFT));
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_tbl_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -892,6 +1043,175 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_classif_tbl_pair(int td,
+		const struct dpa_offload_lookup_key_pair *pair,
+		struct dpa_stats_lookup_key *lookup_key)
+{
+	struct dpa_cls_tbl_params cls_tbl;
+	struct dpa_offload_lookup_key tbl_key;
+	struct dpa_cls_tbl_action action;
+	int err = 0;
+
+	/* Check that key byte is not NULL */
+	if (!pair->first_key.byte) {
+		pr_err("Invalid argument: NULL key byte pointer\n");
+		return -EFAULT;
+	}
+
+	/* Check that key mask is not NULL */
+	if (!pair->first_key.mask) {
+		pr_err("Invalid argument: NULL key mask pointer\n");
+		return -EFAULT;
+	}
+
+	/* Copy first key descriptor parameters*/
+	err = copy_key_descriptor(&pair->first_key, &tbl_key);
+	if (err != 0) {
+		pr_err("Unable to copy key descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Use the first key of the pair to lookup in the classifier
+	 * table the next table connected on a "next-action" */
+	err = dpa_classif_table_lookup_by_key(td, &tbl_key, &action);
+	if (err != 0) {
+		pr_err("Unable to retrieve next action parameters\n");
+		return -EINVAL;
+	}
+
+	if (action.type != DPA_CLS_TBL_ACTION_NEXT_TABLE) {
+		pr_err("Double key is supported only if "
+				"two tables are connected\n");
+		return -EINVAL;
+	}
+
+	/* Get CcNode from new table descriptor */
+	err = dpa_classif_table_get_params(
+			action.next_table_params.next_td, &cls_tbl);
+	if (err != 0) {
+		pr_err("Unable to retrieve next table parameters\n");
+		return -EINVAL;
+	}
+
+	/* Store CcNode handle */
+	lookup_key->cc_node = cls_tbl.cc_node;
+
+	/* Set as lookup key the second key descriptor from the pair */
+	err = copy_key_descriptor(&pair->second_key, &lookup_key->key);
+	if (err != 0) {
+		pr_err("Unable to copy key descriptor\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_classif_tbl_cb *cnt_tbl_cb = &cnt_cb->tbl_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_stats_cls_cnt_classif_tbl prm = params->classif_tbl_params;
+	struct dpa_cls_tbl_params cls_tbl;
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0, cnt_sel = prm.cnt_sel;
+	int err = 0;
+
+	/* Check Classifier Table counter selection */
+	if (!((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
+			(cnt_sel <= DPA_STATS_CNT_CLASSIF_RANGE10))) {
+		pr_err("Invalid Classifier Table counter selection");
+		return -EINVAL;
+	}
+
+	cnt_tbl_cb->keys_num = params->class_members;
+
+	if (prm.key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+		/* Get CcNode from table descriptor */
+		err = dpa_classif_table_get_params(prm.td, &cls_tbl);
+		if (err != 0) {
+			pr_err("Invalid argument: Table descriptor\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < params->class_members; i++) {
+			/* Store CcNode handle */
+			cnt_tbl_cb->keys[i].cc_node = cls_tbl.cc_node;
+
+			if ((!prm.keys[i].byte) && (!prm.keys[i].mask)) {
+				/* Key is not valid for now */
+				cnt_tbl_cb->keys[i].valid = FALSE;
+				continue;
+			}
+
+			/* Copy the key descriptor */
+			err = copy_key_descriptor(&prm.keys[i],
+					&cnt_tbl_cb->keys[i].key);
+			if (err != 0) {
+				pr_err("Unable to copy key descriptor\n");
+				return -EINVAL;
+			}
+
+			/* Check the Classifier Table counter */
+			err = FM_PCD_MatchTableFindNGetKeyStatistics(
+					cnt_cb->tbl_cb.keys[i].cc_node,
+					cnt_cb->tbl_cb.keys[i].key.size,
+					cnt_cb->tbl_cb.keys[i].key.byte,
+					cnt_cb->tbl_cb.keys[i].key.mask,
+					&stats);
+			if (err != 0) {
+				pr_err("Invalid Classif Table parameters\n");
+				return -EINVAL;
+			}
+
+			cnt_tbl_cb->keys[i].valid = TRUE;
+		}
+
+	} else if (prm.key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+		for (i = 0; i < params->class_members; i++) {
+			if ((!prm.pairs[i].first_key.byte) &&
+				(!prm.pairs[i].first_key.mask)) {
+				/* Key is not valid for now */
+				cnt_tbl_cb->keys[i].valid = FALSE;
+				continue;
+			}
+
+			err = set_cls_cnt_classif_tbl_pair(prm.td,
+					&prm.pairs[i], &cnt_tbl_cb->keys[i]);
+			if (err != 0) {
+				pr_err("Unable to set the key pair\n");
+				return -EINVAL;
+			}
+
+			/* Check the Classifier Table counter */
+			err = FM_PCD_MatchTableFindNGetKeyStatistics(
+					cnt_cb->tbl_cb.keys[i].cc_node,
+					cnt_cb->tbl_cb.keys[i].key.size,
+					cnt_cb->tbl_cb.keys[i].key.byte,
+					cnt_cb->tbl_cb.keys[i].key.mask,
+					&stats);
+			if (err != 0) {
+				pr_err("Invalid Classif Table parameters\n");
+				return -EINVAL;
+			}
+			cnt_tbl_cb->keys[i].valid = TRUE;
+		}
+	} else {
+		pr_err("Invalid argument: key type\n");
+		return -EINVAL;
+	}
+
+	/* Map Classif Node counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_tbl_cb->info,
+		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+		(cnt_sel >> CLASSIF_STATS_SHIFT));
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_tbl_cb->keys_num *
+			STATS_VAL_SIZE * cnt_tbl_cb->info.stats_num;
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -1063,6 +1383,40 @@ static int get_cnt_plcr_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->tbl_cb.keys_num; i++) {
+		if (!cnt_cb->tbl_cb.keys[i].valid) {
+			/* Write the memory location */
+			*(uint32_t *)(req_cb->request_area) = 0;
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE;
+
+			continue;
+		}
+
+		err = FM_PCD_MatchTableFindNGetKeyStatistics(
+				cnt_cb->tbl_cb.keys[i].cc_node,
+				cnt_cb->tbl_cb.keys[i].key.size,
+				cnt_cb->tbl_cb.keys[i].key.byte,
+				cnt_cb->tbl_cb.keys[i].key.mask, &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Table statistics\n");
+			return -EIO;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->tbl_cb.info, &stats, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -1112,6 +1466,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map Policer counters to FMAN Policer statistics */
 	create_cnt_plcr_stats(dpa_stats);
 
+	/* Map Classifier counters to FMAN Classifier statistics */
+	create_classif_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -1186,6 +1543,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_POLICER;
 		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
 		break;
+	case DPA_STATS_CNT_CLASSIF_TBL:
+		err = set_cnt_classif_tbl_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Classif Table counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -1283,6 +1649,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_POLICER;
 		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
 		break;
+	case DPA_STATS_CNT_CLASSIF_TBL:
+		err = set_cls_cnt_classif_tbl_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Classif Table counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index 4c8f635..0d05627 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -39,6 +39,7 @@
 
 /* DPA offloading layer includes */
 #include "linux/fsl_dpa_stats.h"
+#include "linux/fsl_dpa_ipsec.h"
 #include "dpa_compat.h"
 #include "cq.h"
 
@@ -91,6 +92,22 @@ struct dpa_stats_cnt_gen_cb {
 				/* Counter's statistics information */
 };
 
+/* DPA Stats Classifier Table key descriptor */
+struct dpa_stats_lookup_key {
+	void *cc_node;  /* Handle of Cc Node the lookup key belongs to */
+	struct dpa_offload_lookup_key key; /* Key descriptor */
+	bool valid; /* Lookup key is valid */
+};
+
+/* DPA Stats Classif Table control block */
+struct dpa_stats_cnt_classif_tbl_cb {
+	int td; /* Table descriptor */
+	struct dpa_stats_lookup_key keys[MAX_NUM_OF_MEMBERS]; /* Array of
+			 key descriptors for which to provide statistics */
+	unsigned int keys_num; /* Number of keys descriptors */
+	struct stats_info info; /* Counter's statistics information */
+};
+
 typedef int get_cnt_stats(struct dpa_stats_req_cb *req_cb,
 					struct dpa_stats_cnt_cb *cnt_cb);
 
@@ -103,6 +120,7 @@ struct dpa_stats_cnt_cb {
 	enum dpa_stats_cnt_type type; /* Counter type */
 	union {
 		struct dpa_stats_cnt_gen_cb gen_cb;
+		struct dpa_stats_cnt_classif_tbl_cb tbl_cb;
 	};
 	get_cnt_stats *f_get_cnt_stats; /* Function used to retrieve the
 				statistics for a specific counter */
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 4fe61aa..470f538 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -302,6 +302,51 @@ struct dpa_stats_cnt_plcr {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Classification counters */
+enum dpa_stats_cnt_classif_sel {
+	/* Number of bytes processed by classification entry */
+	DPA_STATS_CNT_CLASSIF_BYTES   = 0x00000010,
+	/* Number of frames processed by classification entry */
+	DPA_STATS_CNT_CLASSIF_PACKETS = 0x00000020,
+	/* Number of frames for frame length range 1 */
+	DPA_STATS_CNT_CLASSIF_RANGE1  = 0x00000040,
+	/* Number of frames for frame length range 2 */
+	DPA_STATS_CNT_CLASSIF_RANGE2  = 0x00000080,
+	/* Number of frames for frame length range 3 */
+	DPA_STATS_CNT_CLASSIF_RANGE3  = 0x00000100,
+	/* Number of frames for frame length range 4 */
+	DPA_STATS_CNT_CLASSIF_RANGE4  = 0x00000200,
+	/* Number of frames for frame length range 5 */
+	DPA_STATS_CNT_CLASSIF_RANGE5  = 0x00000400,
+	/* Number of frames for frame length range 6 */
+	DPA_STATS_CNT_CLASSIF_RANGE6  = 0x00000800,
+	/* Number of frames for frame length range 7 */
+	DPA_STATS_CNT_CLASSIF_RANGE7  = 0x00001000,
+	/* Number of frames for frame length range 8 */
+	DPA_STATS_CNT_CLASSIF_RANGE8  = 0x00002000,
+	/* Number of frames for frame length range 9 */
+	DPA_STATS_CNT_CLASSIF_RANGE9  = 0x00004000,
+	/* Number of frames for frame length range 10 */
+	DPA_STATS_CNT_CLASSIF_RANGE10  = 0x00008000
+};
+
+/* DPA Stats Classifier Table counter parameters */
+struct dpa_stats_cnt_classif_tbl {
+
+	/* Table descriptor */
+	int td;
+
+	/* Key to identify a specific entry */
+	struct dpa_offload_lookup_key key;
+
+	/*
+	 * Single or multiple selection of Classifier Table counters
+	 * from one of the enums: dpa_stats_cnt_classif_sel or
+	 * dpa_stats_cnt_frag_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -320,6 +365,9 @@ struct dpa_stats_cnt_params {
 
 		/* Parameters for Policer counter */
 		struct dpa_stats_cnt_plcr plcr_params;
+
+		/* Parameters for Classification Table counter */
+		struct dpa_stats_cnt_classif_tbl classif_tbl_params;
 	};
 };
 
@@ -369,6 +417,64 @@ struct dpa_stats_cls_cnt_plcr {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Classification key type */
+enum dpa_stats_classif_key_type {
+
+	/* Entry identified through a single key */
+	DPA_STATS_CLASSIF_SINGLE_KEY = 0,
+
+	/*
+	 * Entry identified through a pair of keys: the first key
+	 * uniquely identifies the first entry, while the second key
+	 * identifies the entry connected to the first entry
+	 */
+	DPA_STATS_CLASSIF_PAIR_KEY
+};
+
+/* DPA Stats Classification counter - pair of keys */
+struct dpa_offload_lookup_key_pair {
+
+	/* Key to identify the first entry */
+	struct dpa_offload_lookup_key first_key;
+
+	/* Key to identify the entry connected to the first entry */
+	struct dpa_offload_lookup_key second_key;
+};
+
+/* DPA Stats Classifier Table class counter parameters */
+struct dpa_stats_cls_cnt_classif_tbl {
+
+	/* Table descriptor */
+	int td;
+
+	/* Mechanism used to identify an entry */
+	enum dpa_stats_classif_key_type   key_type;
+
+	union {
+		/* Invalid keys can be provided during class counter creation
+		 * and the statistics values for such keys will be 0. Function
+		 * 'dpa_stats_modify_class_counter' can be further used to
+		 * modify a specific key. */
+
+		/* Array of keys to identify specific entries. A key can be
+		 * 'invalidated' by providing the 'byte' and 'mask' pointers
+		 * set to NULL. */
+		struct dpa_offload_lookup_key *keys;
+
+		/* Array of 'pair-keys' to identify specific entries. A key pair
+		 * can be 'invalidated' by providing the 'byte' and 'mask'
+		 * pointers of the first key set to NULL */
+		struct dpa_offload_lookup_key_pair *pairs;
+	};
+
+	/*
+	 * Single or multiple selection of Classifier Table counters
+	 * from one of the enums: dpa_stats_cnt_classif_sel or
+	 * dpa_stats_cnt_frag_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -390,6 +496,9 @@ struct dpa_stats_cls_cnt_params {
 
 		/* Parameters for Policer class counter */
 		struct dpa_stats_cls_cnt_plcr plcr_params;
+
+		/* Parameters for Classifier Table class counter */
+		struct dpa_stats_cls_cnt_classif_tbl classif_tbl_params;
 	};
 };
 
-- 
1.7.5.4

