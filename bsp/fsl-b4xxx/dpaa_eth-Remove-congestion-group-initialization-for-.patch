From f01baf31c9e4419f56d7ce682bb7d69f07e0a63d Mon Sep 17 00:00:00 2001
From: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Date: Thu, 21 Feb 2013 18:59:13 +0000
Subject: [PATCH 497/518] dpaa_eth: Remove congestion group initialization for
 mac-less interfaces

MAC-less devices initialize their own RX frame queues, assuming that
the TX queues will be initialized by the other partition.

We cannot rely on the second partition to place the TX queues of
the first partition into congestion groups because the congestion
interrupt will then be received by the second partition instead
of the partition enqueueing the frames (in this case the first
partition).

Supporting congestion on MAC-less devices would involve too much
code and device tree changes so we simply use taildrop mechanism
for now.

Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   17 ++++++++---------
 1 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index f763174..a7c6484 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -97,8 +97,6 @@
  *	- running out of memory if the CS threshold is set too high.
  */
 #define DPA_CS_THRESHOLD_1G	0x06000000
-/* Set a congestion threshold for MAC-less devices, too. */
-#define DPA_CS_THRESHOLD_MACLESS	0x10000000
 
 /* S/G table requires at least 256 bytes */
 #define SGT_BUFFER_SIZE		DPA_BP_SIZE(256)
@@ -3809,9 +3807,7 @@ static int dpaa_eth_cgr_init(struct dpa_priv_s *priv)
 	 * lower than its max, e.g. if a dTSEC later negotiates a 100Mbps link.
 	 * In such cases, we ought to reconfigure the threshold, too.
 	 */
-	if (!priv->mac_dev)
-		cs_th = DPA_CS_THRESHOLD_MACLESS;
-	else if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
+	if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
 		cs_th = DPA_CS_THRESHOLD_10G;
 	else
 		cs_th = DPA_CS_THRESHOLD_1G;
@@ -3999,11 +3995,14 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		 * dynamically-allocated CGR ID.
 		 * Must be executed after probing the MAC, but before
 		 * assigning the egress FQs to the CGRs.
+		 * Don't create a congestion group for MAC-less interfaces.
 		 */
-		err = dpaa_eth_cgr_init(priv);
-		if (err < 0) {
-			dpaa_eth_err(dev, "Error initializing CGR\n");
-			goto cgr_init_failed;
+		if (priv->mac_dev) {
+			err = dpaa_eth_cgr_init(priv);
+			if (err < 0) {
+				dpaa_eth_err(dev, "Error initializing CGR\n");
+				goto cgr_init_failed;
+			}
 		}
 
 		/* Add the FQs to the interface, and make them active */
-- 
1.7.5.4

