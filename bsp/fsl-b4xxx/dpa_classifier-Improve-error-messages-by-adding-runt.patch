From 44e211cd57690a1d6fba4461bdad9b2ceea8b774 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 29 Oct 2012 21:34:50 +0000
Subject: [PATCH 344/518] dpa_classifier: Improve error messages by adding
 runtime information

Added runtime context information when displaying errors. When available
information like table descriptor, lookup keys, current entry reference
and FMan driver object handles are displayed.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  674 +++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |    3 +
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  254 +++-----
 3 files changed, 545 insertions(+), 386 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index de0a98a..c62b9e7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -114,7 +114,8 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	ptable = kzalloc(sizeof(*ptable), GFP_KERNEL);
 	if (!ptable) {
 		pr_err("ERROR: %s, %s (%d): No more memory for DPA classifier "
-			"table.\n", __FILE__, __func__, __LINE__);
+			"table. Requested table type=%d.\n", __FILE__, __func__,
+			__LINE__, params->type);
 		err = -ENOMEM;
 		goto dpa_classif_table_create_error;
 	}
@@ -133,8 +134,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 					GFP_KERNEL);
 			if (!ptable->shadow_table) {
 				pr_err("ERROR: %s, %s (%d): No more memory for "
-					"DPA classifier shadow table.\n",
-					__FILE__, __func__, __LINE__);
+					"classifier shadow table while creating"
+					"INDEXED table.\n", __FILE__, __func__,
+					__LINE__);
 				err = -ENOMEM;
 				goto dpa_classif_table_create_error;
 			}
@@ -157,8 +159,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 					GFP_KERNEL);
 			if (!ptable->shadow_table) {
 				pr_err("ERROR: %s, %s (%d): No more memory for "
-					"DPA classifier shadow table.\n",
-					__FILE__, __func__, __LINE__);
+					"classifier shadow table while creating"
+					"EXACT MATCH table.\n", __FILE__,
+					__func__, __LINE__);
 				err = -ENOMEM;
 				goto dpa_classif_table_create_error;
 			}
@@ -181,9 +184,10 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 						GFP_KERNEL);
 				if (!ptable->shadow_table) {
 					pr_err("ERROR: %s, %s (%d): No more "
-						"memory for DPA classifier "
-						"shadow table.\n", __FILE__,
-						__func__, __LINE__);
+						"memory for classifier shadow "
+						"table while creating HASH "
+						"table.\n", __FILE__, __func__,
+						__LINE__);
 					err = -ENOMEM;
 					goto dpa_classif_table_create_error;
 				}
@@ -212,8 +216,10 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				sizeof(struct list_head), GFP_KERNEL);
 		if (!ptable->shadow_table->shadow_entry) {
 			pr_err("ERROR: %s, %s (%d): No more memory for DPA "
-				"Classifier shadow tables.\n", __FILE__,
-				__func__, __LINE__);
+				"Classifier shadow table buckets (%d buckets). "
+				"Requested table type=%d.\n", __FILE__,
+				__func__, __LINE__, ptable->shadow_table->size,
+				ptable->params.type);
 			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
 		}
@@ -226,12 +232,21 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	switch (ptable->params.type) {
 	case DPA_CLS_TBL_INDEXED:
 		err = table_init_indexed(ptable);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to create INDEXED "
+				"table.\n", __FILE__, __func__, __LINE__);
 		break;
 	case DPA_CLS_TBL_EXACT_MATCH:
 		err = table_init_exact_match(ptable);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to create EXACT "
+				"MATCH table.\n", __FILE__, __func__, __LINE__);
 		break;
 	case DPA_CLS_TBL_HASH:
 		err = table_init_hash(ptable);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to create HASH "
+				"table.\n", __FILE__, __func__, __LINE__);
 		break;
 	}
 	if (err < 0)
@@ -347,8 +362,8 @@ int dpa_classif_table_modify_miss_action(int			td,
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Miss Action for DPA Classifier "
-			"Indexed Tables is not supported.\n", __FILE__,
-			__func__, __LINE__);
+			"Indexed Tables (td=%d) is not supported.\n", __FILE__,
+			__func__, __LINE__, td);
 		return -ENOSYS;
 	}
 
@@ -356,6 +371,9 @@ int dpa_classif_table_modify_miss_action(int			td,
 	errno = action_to_next_engine_params(miss_action, &miss_engine_params);
 	if (errno < 0) {
 		mutex_unlock(&ptable->access);
+		pr_err("ERROR: %s, %s (%d): Failed verification of miss action "
+			"params for table td=%d.\n", __FILE__, __func__,
+			__LINE__, td);
 		return errno;
 	}
 
@@ -364,11 +382,11 @@ int dpa_classif_table_modify_miss_action(int			td,
 			cc_node, &miss_engine_params);
 		if (err != E_OK) {
 			mutex_unlock(&ptable->access);
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_HashTableModifyMissNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_HashTableModifyMissNextEngine "
+				"(td=%d, Cc node handle=0x%x).\n", __FILE__,
+				__func__, __LINE__, td,
+				(unsigned)ptable->params.cc_node);
 			return -EBUSY;
 		}
 	} else {
@@ -376,11 +394,11 @@ int dpa_classif_table_modify_miss_action(int			td,
 			int_cc_node[0].cc_node, &miss_engine_params);
 		if (err != E_OK) {
 			mutex_unlock(&ptable->access);
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyMissNextEngine "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_MatchTableModifyMissNextEngine (td=%d, "
+				"Cc node handle=0x%x).\n", __FILE__, __func__,
+				__LINE__, td,
+				(unsigned)ptable->int_cc_node[0].cc_node);
 			return -EBUSY;
 		}
 	}
@@ -419,8 +437,8 @@ int dpa_classif_table_insert_entry(int				td,
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Insert entry in an indexed table "
-			"makes no sense. Please use modify_entry instead.\n",
-			__FILE__, __func__, __LINE__);
+			"(td=%d) makes no sense. Please use modify_entry "
+			"instead.\n", __FILE__, __func__, __LINE__, td);
 		return -EINVAL;
 	}
 
@@ -433,7 +451,11 @@ int dpa_classif_table_insert_entry(int				td,
 			(find_shadow_entry(ptable, key) != NULL)) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry already "
-			"exists.\n", __FILE__, __func__, __LINE__);
+			"exists in table td=%d. Attempted to add twice the "
+			"following key (hex) (%d byte(s)):", __FILE__, __func__,
+			__LINE__, td, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
 		return -EEXIST;
 	}
 
@@ -456,6 +478,15 @@ int dpa_classif_table_insert_entry(int				td,
 	}
 
 	mutex_unlock(&ptable->access);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to insert entry in table "
+			"td=%d. Table type=%d. Lookup key was (hex) (%d "
+			"byte(s)):", __FILE__, __func__, __LINE__, td,
+			ptable->params.type, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
+	}
+
 	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_insert_entry);
@@ -498,8 +529,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
-			"on exact match tables.\n", __FILE__, __func__,
+			"on exact match tables. ", __FILE__, __func__,
 			__LINE__);
+		pr_err("You attempted to use it on table td=%d which is of "
+			"type=%d.\n", td, ptable->params.type);
 		return -ENOSYS;
 	}
 
@@ -523,6 +556,15 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 						&key_params.ccNextEngineParams);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
+					pr_err("ERROR: %s, %s (%d): Failed "
+						"verification of new action "
+						"params while modifying entry "
+						"by KEY in table td=%d. Lookup "
+						"key (hex) (%d byte(s)):",
+						__FILE__, __func__, __LINE__,
+						td, key->size);
+					dump_lookup_key(key);
+					pr_err("\n");
 					return ret;
 				}
 
@@ -542,13 +584,16 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				&key_params.ccNextEngineParams);
 			if (err != E_OK) {
 				mutex_unlock(&ptable->access);
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableFindNModifyNextEngine"
-					" failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_MatchTableFindNModifyNextEngine"
+					". td=%d, Cc node handle=0x%x, entry "
+					"key (hex) (%d byte(s)):", __FILE__,
+					__func__, __LINE__, td,
+				(unsigned)ptable->int_cc_node[0].cc_node,
+					key->size);
+				dump_lookup_key(key);
+				pr_err("\n");
 				return -EBUSY;
 			}
 		} else { /* Table is HASH */
@@ -559,13 +604,16 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				&key_params.ccNextEngineParams);
 			if (err != E_OK) {
 				mutex_unlock(&ptable->access);
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_HashTableModifyNextEngine "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_HashTableModifyNextEngine. "
+					"td=%d, Cc node handle=0x%x, entry key "
+					"(hex) (%d byte(s)):", __FILE__,
+					__func__, __LINE__, td,
+					(unsigned)ptable->params.cc_node,
+					key->size);
+				dump_lookup_key(key);
+				pr_err("\n");
 				return -EBUSY;
 			}
 		}
@@ -584,6 +632,15 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 						&key_params.ccNextEngineParams);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
+					pr_err("ERROR: %s, %s (%d): Failed "
+						"verification of new action "
+						"params while modifying entry "
+						"by KEY in table td=%d. Lookup "
+						"key (hex) (%d byte(s)):",
+						__FILE__, __func__, __LINE__,
+						td, key->size);
+					dump_lookup_key(key);
+					pr_err("\n");
 					return ret;
 				}
 
@@ -623,13 +680,17 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				new_mask);
 			if (err != E_OK) {
 				mutex_unlock(&ptable->access);
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableFindNModifyKey "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_MatchTableFindNModifyKey. "
+					"td=%d, Cc node handle=0x%x, trying to "
+					"modify entry w/ key (hex) (%d "
+					"byte(s)):", __FILE__, __func__,
+					__LINE__, td,
+				(unsigned)ptable->int_cc_node[0].cc_node,
+					key->size);
+				dump_lookup_key(key);
+				pr_err("\n");
 				return -EBUSY;
 			}
 		} else {
@@ -643,11 +704,15 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				&key_params);
 			if (err != E_OK) {
 				mutex_unlock(&ptable->access);
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableFindNModifyKeyAndNextEngine "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+		"FM_PCD_MatchTableFindNModifyKeyAndNextEngine. td=%d, Cc node "
+				"handle=0x%x, trying to modify entry w/ key "
+				"(hex) (%d byte(s)):", __FILE__, __func__,
+				__LINE__, td,
+				(unsigned)ptable->int_cc_node[0].cc_node,
+				key->size);
+				dump_lookup_key(key);
+				pr_err("\n");
 				return -EBUSY;
 			}
 		}
@@ -660,19 +725,45 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		} else {
 			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): Unable to determine "
-				"entry_id associated with this lookup key.\n",
-				__FILE__, __func__, __LINE__);
+				"entry_id associated with this lookup key for "
+				"table td=%d. ", __FILE__, __func__, __LINE__,
+				td);
+			pr_err("Lookup key was (hex) (%d byte(s)):", key->size);
+			dump_lookup_key(key);
+			pr_err("\n");
 			return entry_id;
 		}
 	}
 
 	ret = table_modify_entry_by_ref(ptable, entry_id, mod_params);
 	mutex_unlock(&ptable->access);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to MODIFY entry by KEY in "
+			"table td=%d. Translated entry ref=%d. Lookup key was "
+			"(hex) (%d byte(s)):", __FILE__, __func__, __LINE__,
+			td, entry_id, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
+	}
 
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_key);
 
+static void dump_lookup_key(const struct dpa_offload_lookup_key *key)
+{
+	int i;
+
+	for (i = 0; i < key->size; i++)
+		pr_err(" %02x", key->byte[i]);
+	pr_err(". Mask was (hex):");
+	if (key->mask) {
+		for (i = 0; i < key->size; i++)
+			pr_err(" %02x", key->mask[i]);
+	} else
+		pr_err("n/a");
+}
+
 int dpa_classif_table_modify_entry_by_ref(int			td,
 		int						entry_id,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
@@ -691,8 +782,23 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	mutex_lock(&ptable->access);
 	release_desc_table(&table_array);
 
+	/* Check for unsupported modifications */
+	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
+			(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
+		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
+			"on exact match tables. ", __FILE__, __func__,
+			__LINE__);
+		pr_err("You attempted to use it on table td=%d which is of "
+			"type=%d.\n", td, ptable->params.type);
+		return -ENOSYS;
+	}
+
 	err = table_modify_entry_by_ref(ptable, entry_id, mod_params);
 	mutex_unlock(&ptable->access);
+	if (err < 0)
+		pr_err("ERROR: %s, %s (%d): Failed to MODIFY entry by REF in "
+			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
+			__LINE__, td, entry_id);
 
 	return err;
 }
@@ -726,15 +832,6 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
-	/* Check for unsupported modifications */
-	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
-			(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
-			"on exact match tables.\n", __FILE__, __func__,
-			__LINE__);
-		return -ENOSYS;
-	}
-
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		cc_node_index	= 0;
 		entry_index	= entry_id;
@@ -757,25 +854,27 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_MatchTableModifyNextEngine. Entry "
+				"ref=%d, Cc node handle=0x%x, entry index=%d.\n",
+				__FILE__, __func__, __LINE__, entry_id,
+				(unsigned)cc_node, entry_index);
 			return -EBUSY;
 		}
 
 		break;
 	case DPA_CLS_TBL_MODIFY_KEY:
 		/* Only exact match tables support this type of modification. */
+		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
 		xx_sanity_check_return_value(mod_params->key,
 			"mod_params.key", -EINVAL);
 
 		if (mod_params->key->size !=
 			ptable->params.exact_match_params.key_size) {
-			pr_err("ERROR: %s, %s (%d): New key size (%d) doesn't "
-				"match the table key size (%d).\n", __FILE__,
-				__func__, __LINE__, mod_params->key->size,
+			pr_err("ERROR: %s, %s (%d): New key size (%d bytes) "
+				"doesn't match the table key size (%d bytes)"
+				".\n", __FILE__, __func__, __LINE__,
+				mod_params->key->size,
 				ptable->params.exact_match_params.key_size);
 			return -EINVAL;
 		}
@@ -803,17 +902,18 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 				key_params.p_Key,
 				key_params.p_Mask);
 		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyKey failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_MatchTableModifyKey. Entry ref=%d, Cc "
+				"node handle=0x%x, entry index=%d.\n",
+				__FILE__, __func__, __LINE__, entry_id,
+				(unsigned)cc_node, entry_index);
 			return -EBUSY;
 		}
 
 		break;
 	case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
 		/* Only exact match tables support this type of modification. */
+		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
 		xx_sanity_check_return_value(mod_params->key,
 			"mod_params.key", -EINVAL);
 		xx_sanity_check_return_value(mod_params->action,
@@ -821,9 +921,10 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 
 		if (mod_params->key->size !=
 			ptable->params.exact_match_params.key_size) {
-			pr_err("ERROR: %s, %s (%d): New key size (%d) doesn't "
-				"match the table key size (%d).\n", __FILE__,
-				__func__, __LINE__, mod_params->key->size,
+			pr_err("ERROR: %s, %s (%d): New key size (%d bytes) "
+				"doesn't match the table key size (%d bytes)."
+				"\n", __FILE__, __func__, __LINE__,
+				mod_params->key->size,
 				ptable->params.exact_match_params.key_size);
 			return -EINVAL;
 		}
@@ -856,11 +957,11 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 				ptable->params.exact_match_params.key_size,
 				&key_params);
 		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyKeyAndNextEngine "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_MatchTableModifyKeyAndNextEngine. "
+				"Entry ref=%d, Cc node handle=0x%x, entry "
+				"index=%d.\n", __FILE__, __func__, __LINE__,
+				entry_id, (unsigned)cc_node, entry_index);
 			return -EBUSY;
 		}
 
@@ -988,13 +1089,16 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 				mask);
 			if (error != E_OK) {
 				mutex_unlock(&ptable->access);
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableFindNRemoveKey"
-					" failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_MatchTableFindNRemoveKey. "
+					"td=%d, Cc node handle=0x%x, trying to "
+					"remove entry w/ key (hex) (%d byte(s)):",
+					__FILE__, __func__, __LINE__, td,
+				(unsigned)ptable->int_cc_node[0].cc_node,
+					key->size);
+				dump_lookup_key(key);
+				pr_err("\n");
 				return -EBUSY;
 			}
 
@@ -1017,13 +1121,18 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 					key_data);
 				if (error != E_OK) {
 					mutex_unlock(&ptable->access);
-					pr_err("ERROR: %s, %s (%d): "
-						"FM_PCD_HashTableRemoveKey"
-						" failed.\n", __FILE__,
-						__func__, __LINE__);
 					pr_err("ERROR: %s, %s (%d): FMan "
-						"driver call failed.\n",
-						__FILE__, __func__, __LINE__);
+						"driver call failed - "
+						"FM_PCD_HashTableRemoveKey. "
+						"td=%d, Cc node handle=0x%x, "
+						"trying to remove entry w/ key "
+						"(hex) (%d byte(s)):",
+						__FILE__, __func__, __LINE__,
+						td,
+					(unsigned)ptable->params.cc_node,
+						key->size);
+					dump_lookup_key(key);
+					pr_err("\n");
 					return -EBUSY;
 				}
 
@@ -1040,14 +1149,25 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 		} else {
 			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): Unable to determine "
-				"entry_id associated with this lookup key.\n",
-				__FILE__, __func__, __LINE__);
+				"entry_id associated with this lookup key (hex) "
+				"(%d bytes):", __FILE__, __func__, __LINE__,
+				key->size);
+			dump_lookup_key(key);
+			pr_err("\n");
 			return entry_id;
 		}
 	}
 
 	err = table_delete_entry_by_ref(ptable, entry_id);
 	mutex_unlock(&ptable->access);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to DELETE entry by KEY in "
+			"table td=%d. Translated entry ref=%d. Lookup key was "
+			"(hex) (%d byte(s)):", __FILE__, __func__, __LINE__,
+			td, entry_id, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
+	}
 
 	return err;
 }
@@ -1071,6 +1191,10 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 
 	err = table_delete_entry_by_ref(ptable, entry_id);
 	mutex_unlock(&ptable->access);
+	if (err < 0)
+		pr_err("ERROR: %s, %s (%d): Failed to DELETE entry by REF in "
+			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
+			__LINE__, td, entry_id);
 
 	return err;
 }
@@ -1109,11 +1233,11 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 		err = FM_PCD_MatchTableRemoveKey(cc_node,
 					entry_index);
 		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableRemoveKey failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_MatchTableRemoveKey. Entry ref=%d, Cc "
+				"node handle=0x%x, entry index=%d.\n", __FILE__,
+				__func__, __LINE__, entry_id, (unsigned)cc_node,
+				entry_index);
 			return -EBUSY;
 		}
 
@@ -1199,8 +1323,8 @@ int dpa_classif_table_lookup_by_key(int				td,
 	if (!ptable->shadow_table) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup by key in a "
-			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
-			__func__, __LINE__);
+			"DPA_CLS_TBL_MANAGE_BY_REF table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
 		return -ENOSYS;
 	}
 
@@ -1259,8 +1383,8 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	if (!ptable->shadow_table) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
-			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
-			__func__, __LINE__);
+			"DPA_CLS_TBL_MANAGE_BY_REF table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
 		return -ENOSYS;
 	}
 
@@ -1305,8 +1429,11 @@ int dpa_classif_table_flush(int td)
 	release_desc_table(&table_array);
 
 	err = flush_table(ptable);
-
 	mutex_unlock(&ptable->access);
+	if (err < 0)
+		pr_err("ERROR: %s, %s (%d): Failed to flush table td=%d. Table "
+			"type=%d.\n", __FILE__, __func__, __LINE__, td,
+			ptable->params.type);
 
 	return err;
 }
@@ -1376,13 +1503,12 @@ static int flush_table(struct dpa_cls_table *ptable)
 			err = FM_PCD_MatchTableRemoveKey(cc_node,
 						index_entry->entry_index);
 			if (err != E_OK) {
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableRemoveKey "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - FM_PCD_MatchTableRemoveKey. "
+					"Cc node handle=0x%x, entry index=%d.\n",
+					__FILE__, __func__, __LINE__,
+					(unsigned)cc_node,
+					index_entry->entry_index);
 				return -EBUSY;
 			}
 
@@ -1427,21 +1553,31 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 		mutex_unlock(&ptable->access);
 		/* get_entry_stats not supported on prefilled HASH tables */
 		pr_err("ERROR: %s, %s (%d): get_entry_stats_by_key is not "
-			"supported on prefilled HASH tables.\n", __FILE__,
-			__func__, __LINE__);
+			"supported on prefilled HASH tables (td=%d).\n",
+			__FILE__, __func__, __LINE__, td);
 		return -ENOSYS;
 	}
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
-			"associated with this lookup key.\n", __FILE__,
-			__func__, __LINE__);
+			"associated with this lookup key (hex) (%d byte(s)):",
+			__FILE__, __func__, __LINE__, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
 		return entry_id;
 	}
 
 	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
 	mutex_unlock(&ptable->access);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to get entry STATS by KEY "
+			"in table td=%d. Translated entry ref=%d. Lookup key "
+			"was (hex) (%d byte(s)):", __FILE__, __func__, __LINE__,
+			td, entry_id, key->size);
+		dump_lookup_key(key);
+		pr_err("\n");
+	}
 
 	return err;
 }
@@ -1467,6 +1603,10 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 
 	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
 	mutex_unlock(&ptable->access);
+	if (err < 0)
+		pr_err("ERROR: %s, %s (%d): Failed to get entry STATS by REF in "
+			"table td=%d. Entry ref=%d.\n", __FILE__, __func__,
+			__LINE__, td, entry_id);
 
 	return err;
 }
@@ -1621,23 +1761,21 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 							i,
 							&next_engine_params);
 			if (err != E_OK) {
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableGetNextEngine "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_MatchTableGetNextEngine. Cc "
+					"node handle=0x%x, entry index=%d.\n",
+					__FILE__, __func__, __LINE__,
+					(unsigned)cc_node, i);
 				return -EBUSY;
 			}
 
 			shadow_entry = kzalloc(sizeof(*shadow_entry),
 								GFP_KERNEL);
 			if (!shadow_entry) {
-				pr_err("ERROR: %s, %s (%d): No more memory for "
-					"importing indexed entries into DPA "
-					"Classifier.\n", __FILE__, __func__,
-					__LINE__);
+				pr_err("ERROR: %s, %s (%d): Out of memory "
+					"while populating shadow table.\n",
+					__FILE__, __func__, __LINE__);
 				return -ENOMEM;
 			}
 
@@ -1677,13 +1815,12 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 			if (FM_PCD_MatchTableGetNextEngine(cc_node,
 						i,
 						&next_engine_params) != E_OK) {
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableGetNextEngine "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
+					"failed - "
+					"FM_PCD_MatchTableGetNextEngine. Cc "
+					"node handle=0x%x, entry index=%d.\n",
+					__FILE__, __func__, __LINE__,
+					(unsigned)cc_node, i);
 				err = -EBUSY;
 				goto table_init_hash_error;
 			}
@@ -2065,10 +2202,12 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		cls_table->params.exact_match_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		pr_err("ERROR: %s, %s (%d): FM_PCD_MatchTableAddKey failed.\n",
-			__FILE__, __func__, __LINE__);
-		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+			"FM_PCD_MatchTableAddKey. Entry ref=%d, Cc node "
+			"handle=0x%x, entry index=%d.\n", __FILE__, __func__,
+			__LINE__, k,
+			(unsigned)cls_table->int_cc_node[0].cc_node,
+			cls_table->entry[k].entry_index);
 		return -EBUSY;
 	}
 
@@ -2097,9 +2236,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	if (cls_table->shadow_table) {
 		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
-			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
-				"new DPA Classifier shadow table entry.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Out of memory while "
+				"populating shadow table.\n", __FILE__,
+				__func__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -2107,9 +2246,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			sizeof(struct dpa_cls_tbl_action));
 		shadow_entry->key.byte = kzalloc(key->size, GFP_KERNEL);
 		if (!shadow_entry->key.byte) {
-			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
-				"new DPA Classifier shadow table entry.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Out of memory while "
+				"populating shadow table.\n", __FILE__,
+				__func__, __LINE__);
 			kfree(shadow_entry);
 			return -ENOMEM;
 		}
@@ -2117,9 +2256,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		if (key->mask) {
 			shadow_entry->key.mask = kzalloc(key->size, GFP_KERNEL);
 			if (!shadow_entry->key.mask) {
-				pr_err("ERROR: %s, %s (%d): No more RAM to "
-					"add a new DPA Classifier shadow table "
-					"entry.\n",
+				pr_err("ERROR: %s, %s (%d): Out of memory "
+					"while populating shadow table.\n",
 					__FILE__, __func__, __LINE__);
 				kfree(shadow_entry->key.byte);
 				kfree(shadow_entry);
@@ -2171,9 +2309,9 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
 
 	if (key->size != cls_table->params.hash_params.key_size) {
-		pr_err("ERROR: %s, %s (%d): Key size (%d) doesn't match table "
-			"key size (%d).\n", __FILE__, __func__, __LINE__,
-			key->size,
+		pr_err("ERROR: %s, %s (%d): Key size (%d bytes) doesn't match "
+			"table key size (%d bytes).\n", __FILE__, __func__,
+			__LINE__, key->size,
 			cls_table->params.hash_params.key_size);
 		return -EINVAL;
 	}
@@ -2209,10 +2347,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 				cls_table->params.hash_params.key_size,
 				&key_params);
 		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): FM_PCD_HashTableAddKey "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_HashTableAddKey. HASH table "
+				"handle=0x%x.\n", __FILE__, __func__, __LINE__,
+				(unsigned)cls_table->params.cc_node);
 			return -EBUSY;
 		}
 
@@ -2231,8 +2369,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	/* Check if there are entries still available in the selected set */
 	if (cls_table->int_cc_node[hash_set_index].used >=
 			cls_table->int_cc_node[hash_set_index].table_size) {
-		pr_err("ERROR: %s, %s (%d): Hash set is full. Unable to add "
-			"this entry.\n", __FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): Hash set #%llu is full (%d "
+			"entries). Unable to add this entry.\n", __FILE__,
+			__func__, __LINE__, hash_set_index,
+			cls_table->int_cc_node[hash_set_index].table_size);
 		return -ENOSPC;
 	}
 
@@ -2277,10 +2417,12 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		cls_table->params.hash_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		pr_err("ERROR: %s, %s (%d): FM_PCD_MatchTableAddKey failed.\n",
-			__FILE__, __func__, __LINE__);
-		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+			"FM_PCD_MatchTableAddKey. Entry ref=%d, HASH set=%llu,"
+			" Cc node handle=0x%x, entry index=%d.\n", __FILE__,
+			__func__, __LINE__, j, hash_set_index,
+		(unsigned)cls_table->int_cc_node[hash_set_index].cc_node,
+			cls_table->entry[j].entry_index);
 		return -EBUSY;
 	}
 
@@ -2293,9 +2435,9 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if (cls_table->shadow_table) {
 		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
-			pr_err("ERROR: %s, %s (%d): No more memory to add a "
-				"new DPA Classifier shadow table entry.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Out of memory while "
+				"populating shadow table.\n", __FILE__,
+				__func__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -2303,9 +2445,9 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 			sizeof(struct dpa_cls_tbl_action));
 		shadow_entry->key.byte = kzalloc(key->size, GFP_KERNEL);
 		if (!shadow_entry->key.byte) {
-			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
-				"new DPA Classifier shadow table entry.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Out of memory while "
+				"populating shadow table entry.\n", __FILE__,
+				__func__, __LINE__);
 			kfree(shadow_entry);
 			return -ENOMEM;
 		}
@@ -2419,8 +2561,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 			(!table_array.object[action->next_table_params.
 								next_td])) {
 			pr_err("ERROR: %s, %s (%d): Invalid next table "
-				"descriptor (%d).\n", __FILE__, __func__,
-				__LINE__,
+				"descriptor (next_td=%d).\n", __FILE__,
+				__func__, __LINE__,
 				(unsigned)action->next_table_params.next_td);
 			return -EINVAL;
 		}
@@ -2534,9 +2676,8 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 		return -ENODEV;
 
 	if (!cls_table->shadow_table) {
-		pr_err("ERROR: %s, %s (%d): Cannot use runtime functions based "
-			"on key in a DPA_CLS_TBL_MANAGE_BY_REF table.\n",
-			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): No shadow table.\n", __FILE__,
+			__func__, __LINE__);
 		return -ENOSYS;
 	}
 
@@ -2685,11 +2826,8 @@ static void	*desc_to_object(struct dpa_cls_descriptor_table *desc_table,
 
 	if ((desc >= 0) && (desc < desc_table->num_descriptors))
 		return table_array.object[desc];
-	else {
-		pr_err("ERROR: %s, %s (%d): No such object (desc=%d).\n",
-			__FILE__, __func__, __LINE__, desc);
+	else
 		return NULL;
-	}
 }
 
 static inline void key_apply_mask(const struct dpa_offload_lookup_key *key,
@@ -2735,8 +2873,8 @@ static int nat_hm_check_params(const struct dpa_cls_hm_nat_params *nat_params)
 
 		if ((ip_ver) && (ip_ver != 4) && (ip_ver != 6)) {
 			pr_err("ERROR: %s, %s (%d): Unsupported IP version "
-				"(%d).\n", __FILE__, __func__, __LINE__,
-				ip_ver);
+				"(%d). Only IPv4 and IPv6 are supported\n",
+				__FILE__, __func__, __LINE__, ip_ver);
 			return -EINVAL;
 		}
 	}
@@ -2925,8 +3063,9 @@ static int
 		}
 		break;
 	default:
-		pr_err("ERROR: %s, %s (%d): Invalid VLAN specific HM type.\n",
-			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): Invalid VLAN specific HM type "
+			"(%d).\n", __FILE__, __func__, __LINE__,
+			vlan_params->type);
 		return -EINVAL;
 		break;
 	}
@@ -3133,10 +3272,12 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	t_Error error;
 	struct dpa_cls_hm_node *pcurrent, *pnext;
 	t_FmPcdManipParams params;
+	static int index;
 
 	BUG_ON(!chain_head);
 	BUG_ON(!item);
 
+	index++;
 	if (item->next != chain_head) {
 		/* Initialize the rest of the HM chain */
 		err = init_hm_chain(fm_pcd, chain_head, item->next);
@@ -3157,10 +3298,10 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 							(t_Handle) fm_pcd,
 							&pcurrent->params);
 		if (!pcurrent->node) {
-			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeSet "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_ManipNodeSet. Failed to initialize low "
+				"level HM #%d from this chain.\n", __FILE__,
+				__func__, __LINE__, index);
 			err = -EINVAL;
 		}
 
@@ -3171,14 +3312,15 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 		params.h_NextManip = NULL;
 		error = FM_PCD_ManipNodeReplace(pcurrent->node, &params);
 		if (error != E_OK) {
-			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeReplace "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_ManipNodeReplace. Failed to initialize "
+				"low level HM #%d from this chain.\n", __FILE__,
+				__func__, __LINE__, index);
 			err = -EBUSY;
 		}
 	}
 
+	index--;
 	return err;
 }
 
@@ -3187,18 +3329,24 @@ int remove_hm_chain(struct list_head *chain_head, struct list_head *item)
 	int err = 0;
 	struct dpa_cls_hm_node *pcurrent;
 	t_Error error;
+	static int index;
 
 	BUG_ON(!chain_head);
 	BUG_ON(!item);
 
+	index++;
 	/* Remove the current node: */
 	pcurrent = list_entry(item, struct dpa_cls_hm_node, list_node);
 
 	if ((pcurrent->created) && (pcurrent->node)) {
 		error = FM_PCD_ManipNodeDelete((t_Handle) pcurrent->node);
 		if (error != E_OK) {
-			pr_warn("WARNING: Failed to remove low level HM.\n");
-			pr_warn("WARNING: FMan driver call failed.\n");
+			pr_warn("WARNING: Memory leak: failed to remove low "
+				"level HM #%d from this chain. Manip node "
+				"handle=0x%x.\n", index,
+				(unsigned)pcurrent->node);
+			pr_warn("WARNING: FMan driver call failed - "
+				"FM_PCD_ManipNodeDelete.\n");
 		}
 	}
 
@@ -3310,8 +3458,8 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 
 		if (!next_hm) {
 			pr_err("ERROR: %s, %s (%d): Link to an invalid HM "
-				"(hmd=%d).\n", __FILE__, __func__, __LINE__,
-				next_hmd);
+				"(next_hmd=%d).\n", __FILE__, __func__,
+				__LINE__, next_hmd);
 			dpa_classif_free_hm(*hmd);
 			*hmd = DPA_OFFLD_DESC_NONE;
 			return -EINVAL;
@@ -3359,12 +3507,18 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	*hmd = DPA_OFFLD_DESC_NONE;
 
 	err = nat_hm_check_params(nat_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid NAT HM parameters.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create NAT HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pnat_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -3389,10 +3543,15 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 		goto nat_hm_error;
 	}
 
-	if (chain_head)
+	if (chain_head) {
 		err = init_hm_chain(pnat_hm->nat_params.fm_pcd,
 				pnat_hm->hm_chain,
 				pnat_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
+	}
 
 	return err;
 
@@ -3678,12 +3837,18 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	return -ENOSYS;
 
 	err = fwd_hm_check_params(fwd_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid forwarding HM parameters.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create forwarding HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pfwd_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -3705,10 +3870,15 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 			return err;
 		}
 
-		if (chain_head)
+		if (chain_head) {
 			/* Initialize low level HM ops chain */
 			err = init_hm_chain(pfwd_hm->fwd_params.fm_pcd,
 				pfwd_hm->hm_chain, pfwd_hm->hm_chain);
+			if (err < 0)
+				pr_err("ERROR: %s, %s (%d): Failed to "
+					"initialize low level HM chain.\n",
+					__FILE__, __func__, __LINE__);
+		}
 	}
 
 	if (err) {
@@ -3857,12 +4027,18 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	*hmd = DPA_OFFLD_DESC_NONE;
 
 	err = remove_hm_check_params(remove_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid remove HM parameters.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create remove HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	premove_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -3888,10 +4064,15 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 		goto remove_hm_error;
 	}
 
-	if (chain_head)
+	if (chain_head) {
 		err = init_hm_chain(premove_hm->remove_params.fm_pcd,
 				premove_hm->hm_chain,
 				premove_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
+	}
 
 	return err;
 
@@ -4004,12 +4185,18 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	*hmd = DPA_OFFLD_DESC_NONE;
 
 	err = insert_hm_check_params(insert_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid insert HM parameters.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create insert HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pinsert_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -4035,10 +4222,15 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 		goto insert_hm_error;
 	}
 
-	if (chain_head)
+	if (chain_head) {
 		err = init_hm_chain(pinsert_hm->insert_params.fm_pcd,
 				pinsert_hm->hm_chain,
 				pinsert_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
+	}
 
 	return err;
 
@@ -4209,8 +4401,8 @@ int dpa_classif_modify_insert_hm(int hmd,
 	pinsert_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
 
 	if (pinsert_hm->type != DPA_CLS_HM_TYPE_INSERT) {
-		pr_err("ERROR: %s, %s (%d): hmd=%d is not an INSERT type header manip.\n",
-			__FILE__, __func__, __LINE__, hmd);
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an INSERT type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
 		return -EINVAL;
 	}
 
@@ -4312,10 +4504,11 @@ int dpa_classif_modify_insert_hm(int hmd,
 		error = FM_PCD_ManipNodeReplace(hm_node->node,
 						&hm_node->params);
 		if (error != E_OK) {
-			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeReplace "
-				"failed.\n", __FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
+				"FM_PCD_ManipNodeReplace, while trying to modify"
+				" hmd=%d, manip node handle=0x%x.\n", __FILE__,
+				__func__, __LINE__, hmd,
+				(unsigned)hm_node->node);
 			return -EBUSY;
 		}
 	}
@@ -4337,12 +4530,18 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	*hmd = DPA_OFFLD_DESC_NONE;
 
 	err = update_hm_check_params(update_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid update HM parameters.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create update HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pupdate_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -4368,10 +4567,15 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 		goto update_hm_error;
 	}
 
-	if (chain_head)
+	if (chain_head) {
 		err = init_hm_chain(pupdate_hm->update_params.fm_pcd,
 				pupdate_hm->hm_chain,
 				pupdate_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
+	}
 
 	return err;
 
@@ -4748,12 +4952,18 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 	*hmd = DPA_OFFLD_DESC_NONE;
 
 	err = vlan_hm_check_params(vlan_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid VLAN specific HM "
+			"parameters.\n", __FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create VLAN specific HM "
+			"op.\n", __FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pvlan_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -4778,10 +4988,15 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 		goto vlan_hm_error;
 	}
 
-	if (chain_head)
+	if (chain_head) {
 		err = init_hm_chain(pvlan_hm->vlan_params.fm_pcd,
 				pvlan_hm->hm_chain,
 				pvlan_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
+	}
 
 	return err;
 
@@ -4873,8 +5088,8 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 			pdata = kzalloc(size, GFP_KERNEL);
 			if (!pdata) {
 				pr_err("ERROR: %s, %s (%d): Not enough memory "
-					"for VLAN specific HM.\n", __FILE__,
-					__func__, __LINE__);
+					"for VLAN specific egress HM.\n",
+					__FILE__, __func__, __LINE__);
 				kfree(hm_node);
 				return -ENOMEM;
 			}
@@ -4918,8 +5133,8 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 					FM_PCD_MANIP_DSCP_TO_VLAN_TRANS);
 				break;
 			default:
-				pr_err("ERROR: %s, %s (%d): Unknown VLAN update "
-					"type.\n", __FILE__, __func__,
+				pr_err("ERROR: %s, %s (%d): Unknown VLAN "
+					"update type.\n", __FILE__, __func__,
 					__LINE__);
 				kfree(hm_node);
 				return -EINVAL;
@@ -4963,12 +5178,18 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 	return -ENOSYS;
 
 	err = mpls_hm_check_params(mpls_params);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Invalid MPLS specific HM "
+			"parameters.\n", __FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create MPLS specific HM "
+			"op.\n", __FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pmpls_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -4988,10 +5209,15 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 			return err;
 		}
 
-		if (chain_head)
+		if (chain_head) {
 			/* Initialize low level HM ops chain */
 			err = init_hm_chain(pmpls_hm->mpls_params.fm_pcd,
 				pmpls_hm->hm_chain, pmpls_hm->hm_chain);
+			if (err < 0)
+				pr_err("ERROR: %s, %s (%d): Failed to "
+					"initialize low level HM chain.\n",
+					__FILE__, __func__, __LINE__);
+		}
 	}
 
 	if (err) {
@@ -5030,7 +5256,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 	/* Create a header manip node for MPLS: */
 	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
 	if (!hm_node) {
-		pr_err("ERROR: %s, %s (%d): No more RAM for header manip "
+		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
 			"nodes.\n", __FILE__, __func__, __LINE__);
 		return -ENOMEM;
 	}
@@ -5079,7 +5305,7 @@ static int init_mpls_hm(struct dpa_cls_hm *pmpls_hm)
 	default:
 		kfree(hm_node);
 		pr_err("ERROR: %s, %s (%d): Unknown MPLS header manipulation "
-			"(%d).\n", __FILE__, __func__, __LINE__,
+			"type (%d).\n", __FILE__, __func__, __LINE__,
 			pmpls_hm->mpls_params.type);
 		return -EINVAL;
 	}
@@ -5122,7 +5348,7 @@ int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd)
 	/* Create a header manip node: */
 	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
 	if (!hm_node) {
-		pr_err("ERROR: %s, %s (%d): No more RAM for header manip "
+		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
 			"nodes.\n", __FILE__, __func__, __LINE__);
 		return -ENOMEM;
 	}
@@ -5229,8 +5455,8 @@ int dpa_classif_free_hm(int hmd)
 		 * chain of low level ops
 		 */
 		if (remove_hm_chain(phm->hm_chain, phm->hm_chain) < 0)
-			pr_warn("WARNING: Failed to remove HM nodes for chain "
-				"hmd=%d.\n", hmd);
+			pr_warn("WARNING: Not all low level HM nodes could be "
+				"removed for chain hmd=%d.\n", hmd);
 	}
 
 	remove_hm_op(hmd);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 441ef24..7419dad 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -403,6 +403,9 @@ static int remove_hm_chain(struct list_head	*chain_head,
 /* Removes a low level (FMD) header manipulation node */
 static void remove_hm_node(struct dpa_cls_hm_node *node);
 
+/* Display a lookup key and its mask */
+static void dump_lookup_key(const struct dpa_offload_lookup_key *key);
+
 /*
  * Creates a new classifier header manipulation object and links it to an
  * existing object if needed.
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 3d104a4..f26b238 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -63,8 +63,8 @@ do {									\
 									\
 	if (copy_from_user(key_buf, kparam.key.byte,			\
 						kparam.key.size)) {	\
-		pr_err("ERROR: %s, %s (%d): Lookup key.\n", __FILE__,	\
-			__func__, __LINE__);				\
+		pr_err("ERROR: %s, %s (%d): Read failed: lookup "	\
+			"key.\n", __FILE__, __func__, __LINE__);	\
 		return -EBUSY;						\
 	}								\
 	kparam.key.byte = key_buf;					\
@@ -556,9 +556,8 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_create user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -569,9 +568,8 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_create user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -592,17 +590,15 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.td = kparam.td;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_create result.\n", __FILE__,
-				__func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_create result.\n", __FILE__,
-				__func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -619,9 +615,8 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_remove_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -633,8 +628,7 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_remove_hm user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -661,16 +655,14 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_remove_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_remove_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -687,8 +679,7 @@ static long do_ioctl_modify_remove_hm(unsigned long args, bool compat_mode)
 
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_remove_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -701,8 +692,7 @@ static long do_ioctl_modify_remove_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_remove_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -730,8 +720,7 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_insert_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_insert_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -744,8 +733,7 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_insert_hm user space args.\n",
+			pr_err("ERROR: %s, %s (%d): Read failed: space args.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -765,8 +753,8 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 		sz = kparam.ins_params.custom.size;
 		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
 		if (!data) {
-			pr_err("ERROR: %s, %s (%d): Could not allocate memory "
-				"for  data param  for DPA_CLS_HM_INSERT_CUSTOM"
+			pr_err("ERROR: %s, %s (%d): Failed to allocate memory "
+				"for  data param for DPA_CLS_HM_INSERT_CUSTOM"
 				" parameter type.\n",
 				__FILE__, __func__, __LINE__);
 			return -ENOMEM;
@@ -787,16 +775,14 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_insert_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_insert_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -815,8 +801,7 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_insert_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_insert_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -829,9 +814,8 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-			      "dpa_classif_modify_insert_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -845,7 +829,7 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 		sz = kparam.ins_params.custom.size;
 		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
 		if (!data) {
-			pr_err("ERROR: %s, %s (%d): Could not allocate memory "
+			pr_err("ERROR: %s, %s (%d): Failed to allocate memory "
 				"for data param for DPA_CLS_HM_INSERT_CUSTOM "
 				"parameter type.\n",
 				__FILE__, __func__, __LINE__);
@@ -872,8 +856,7 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_vlan_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_vlan_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -886,9 +869,8 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_vlan_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -914,16 +896,14 @@ static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_vlan_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_vlan_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -940,8 +920,7 @@ static long do_ioctl_modify_vlan_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_vlan_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_vlan_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -954,8 +933,7 @@ static long do_ioctl_modify_vlan_hm(unsigned long args, bool compat_mode)
 	} else
 #endif
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"dpa_classif_modify_vlan_hm user space args.\n",
+		pr_err("ERROR: %s, %s (%d): Read failed: user space args.\n",
 			__FILE__, __func__, __LINE__);
 		return -EBUSY;
 	}
@@ -981,8 +959,7 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_nat_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_nat_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -995,9 +972,8 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_nat_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1023,16 +999,14 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_nat_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_nat_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1048,8 +1022,7 @@ static long do_ioctl_modify_nat_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_nat_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_nat_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1062,9 +1035,8 @@ static long do_ioctl_modify_nat_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_nat_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1089,8 +1061,7 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_update_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_update_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1103,9 +1074,8 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"do_ioctl_set_update_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1132,17 +1102,15 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_update_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_update_hm result.\n", __FILE__,
-				__func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1157,8 +1125,7 @@ static long do_ioctl_modify_update_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_update_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_update_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1171,8 +1138,7 @@ static long do_ioctl_modify_update_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-			       "dpa_classif_modify_update_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 			       "space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1198,8 +1164,7 @@ static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_fwd_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_fwd_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1212,9 +1177,8 @@ static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_fwd_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1242,16 +1206,14 @@ static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_update_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_fwd_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1267,8 +1229,7 @@ static long do_ioctl_modify_fwd_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_fwd_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_fwd_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1281,9 +1242,8 @@ static long do_ioctl_modify_fwd_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_modify_fwd_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1308,8 +1268,7 @@ static long  do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_mpls_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_set_mpls_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1322,9 +1281,8 @@ static long  do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed:"
-				"dpa_classif_set_mpls_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1350,16 +1308,14 @@ static long  do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.hmd = kparam.hmd;
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_mpls_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_set_mpls_hm result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1375,8 +1331,7 @@ static long  do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode)
 	struct compat_ioc_dpa_cls_hm_mpls_params uparam;
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"do_ioctl_modify_mpls_hm user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1389,9 +1344,8 @@ static long  do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed:"
-				"dpa_classif_modify_mpls_hm user space args.\n",
-				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -1418,8 +1372,7 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_miss_action user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1432,8 +1385,7 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_miss_action user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1456,8 +1408,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_insert_entry user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1476,8 +1427,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_insert_entry user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1514,16 +1464,14 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 		uparam.entry_id = kparam.entry_id;
 
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_insert_entry result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_insert_entry result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1549,8 +1497,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_entry_by_key user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1576,8 +1523,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_entry_by_key user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1643,8 +1589,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_entry_by_ref user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1664,8 +1609,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_modify_entry_by_ref user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1724,8 +1668,7 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_lookup_by_key user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1743,8 +1686,7 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_lookup_by_key user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1768,16 +1710,14 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 			return ret;
 
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_lookup_by_key result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_lookup_by_key result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1795,8 +1735,7 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_lookup_by_ref user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1810,8 +1749,7 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 #endif /* CONFIG_COMPAT */
 		/* Prepare arguments */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_lookup_by_ref user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1832,16 +1770,14 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 			return ret;
 
 		if (copy_to_user((void *)args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_lookup_by_ref result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_lookup_by_ref result.\n",
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
 				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1862,8 +1798,7 @@ static long do_ioctl_table_delete_entry_by_key(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_delete_entry_by_key user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1882,8 +1817,7 @@ static long do_ioctl_table_delete_entry_by_key(unsigned long	args,
 	{
 		/* Prepare arguments */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_delete_entry_by_key user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1909,8 +1843,7 @@ static long do_ioctl_table_get_stats_by_key(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_get_entry_stats_by_key user "
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
 				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1929,8 +1862,7 @@ static long do_ioctl_table_get_stats_by_key(unsigned long	args,
 	{
 		/* Prepare arguments */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: "
-				"dpa_classif_table_get_entry_stats_by_key user space "
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
 				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
@@ -1952,17 +1884,15 @@ static long do_ioctl_table_get_stats_by_key(unsigned long	args,
 				sizeof(struct dpa_cls_tbl_entry_stats));
 
 		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_get_entry_stats_by_key "
-				"result.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: "
-				"dpa_classif_table_get_entry_stats_by_key "
-				"result.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
-- 
1.7.5.4

