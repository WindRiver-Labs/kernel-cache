From f5d4c15e2341710ff3962946bb0259068463ec81 Mon Sep 17 00:00:00 2001
From: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
Date: Thu, 17 May 2012 15:55:55 +0000
Subject: [PATCH 185/518] dpa_offload use case : add Generic Netlink command
 interface

The commands perform PCD model execution, IPsec initialization,
XFRM events notifications registration and SA/SP associations
required by dpa_offload IPsec API when offloading is performed
in user space.

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |  499 ++++++++++++++++++++
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |   98 ++++
 2 files changed, 597 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h

diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
new file mode 100644
index 0000000..95ddff0
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -0,0 +1,499 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <net/genetlink.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <net/xfrm.h>
+#include <net/ipv6.h>
+#include "fmc.h"
+
+#include "genl_ctl.h"
+
+struct fmc_model_t cmodel;
+int dpa_ipsec_id;
+
+int fmc_config(void);
+int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params);
+int init_xfrm_km(struct xfrm_km_uparms *params);
+
+void dump_xfrm_sa(struct xfrm_state *x);
+void dump_xfrm_selector(struct xfrm_selector *sel);
+void dump_xfrm_template(struct xfrm_tmpl *tmpl);
+
+/* family definition */
+static struct genl_family dpa_ipacc_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "DPA_IPACC",
+	.version = VERSION_NR,
+	.maxattr = A_MAX,
+};
+
+/* Fills the reply to XFRM_NEW_SA user request with policy id information
+ for each matching policy. The reply contains one A_POL_INFO attribute for
+ each policy. Policy template is matched against the xfrm_state.
+*/
+static int policy_walk_func_fromsa(struct xfrm_policy *pol, int dir, int count,
+				   void *ptr)
+{
+	struct pol_walk_arg_fromsa *arg = (struct pol_walk_arg_fromsa *)ptr;
+	struct xfrm_state *x = arg->x;
+	struct sk_buff *skb = arg->skb;
+	struct xfrm_userpolicy_id pol_id;
+	int ret;
+
+	/* we support only one template per policy so only the
+	first transform is checked */
+	if (x->props.family == AF_INET) {
+		if (!((x->id.daddr.a4 == pol->xfrm_vec[0].id.daddr.a4) &&
+			(x->props.saddr.a4 == pol->xfrm_vec[0].saddr.a4) &&
+			(x->id.proto == pol->xfrm_vec[0].id.proto)))
+			/* continue walking */
+				return 0;
+	} else if (x->props.family == AF_INET6) {
+		if ((ipv6_addr_cmp((struct in6_addr *)x->id.daddr.a6,
+			(struct in6_addr *)pol->xfrm_vec[0].id.daddr.a6) ||
+			ipv6_addr_cmp((struct in6_addr *)x->props.saddr.a6,
+			(struct in6_addr *)pol->xfrm_vec[0].saddr.a6) ||
+			(x->id.proto != pol->xfrm_vec[0].id.proto)))
+			return 0;
+	}
+
+	if (dir == XFRM_POLICY_OUT || dir == XFRM_POLICY_IN) {
+		memset(&pol_id, 0, sizeof(pol_id));
+		pol_id.sel = pol->selector;
+		pol_id.dir = dir;
+		pol_id.index = pol->index;
+		ret = nla_put(skb, XFRMA_POLICY, sizeof(pol_id), &pol_id);
+		if (ret) {
+			pr_err("%s(%d): error constructing policy reply\n",
+			       __func__, __LINE__);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/* Returns xfrm_policy structure needed for state lookup
+ */
+static int policy_walk_func_frompol(struct xfrm_policy *pol, int dir, int count,
+				    void *ptr)
+{
+	struct pol_walk_arg_frompol *arg = (struct pol_walk_arg_frompol *)ptr;
+	struct xfrm_userpolicy_info *pol_info = arg->pol_info;
+
+	/* match xfrm_policy selector against user policy info */
+	if (pol_info->sel.family == AF_INET) {
+		if (pol_info->sel.saddr.a4 == pol->selector.saddr.a4 &&
+		pol_info->sel.daddr.a4 == pol->selector.daddr.a4 &&
+		pol_info->sel.proto == pol->selector.proto &&
+		pol_info->sel.family == pol->selector.family) {
+			arg->x = pol;
+			return 1;
+		}
+	} else if (pol_info->sel.family == AF_INET6) {
+		if (!ipv6_addr_cmp((struct in6_addr *)pol_info->sel.saddr.a6,
+		(struct in6_addr *)pol->selector.saddr.a6) &&
+		!ipv6_addr_cmp((struct in6_addr *)pol_info->sel.daddr.a6,
+		(struct in6_addr *)pol->selector.daddr.a6) &&
+		(pol_info->sel.proto == pol->selector.proto) &&
+		pol_info->sel.family == pol->selector.family)
+			arg->x = pol;
+			return 1;
+	}
+	/* continue walking */
+	return 0;
+}
+
+/* Command handler for C_GET_OFFLD_DATA_FROMSA */
+static int get_ipsec_offld_data_fromsa(struct sk_buff *skb_2,
+					struct genl_info *info)
+{
+	struct nlattr *na;
+	struct sk_buff *skb;
+	int rc = 0;
+	void *msg_head;
+	struct new_sa_req sa_req;
+	struct xfrm_state *x;
+	struct xfrm_policy_walk walk;
+	struct pol_walk_arg_fromsa arg;
+	struct xfrm_algo *ealg = NULL;
+	struct xfrm_algo_auth *aalg = NULL;
+
+	/* check user info */
+	na = info->attrs[A_SA_INFO];
+	if (!na) {
+		pr_err("%s(%d) : no A_SA_INFO (%d) attr in user info\n",
+			__func__, __LINE__, A_SA_INFO);
+		return -EINVAL;
+	}
+
+	sa_req = *((typeof(&sa_req)) nla_data(na));
+
+	/* get xfrm_state from user info */
+	x = xfrm_state_lookup(&init_net, 0, &sa_req.sa_info.id.daddr,
+			      sa_req.sa_info.id.spi, sa_req.sa_info.id.proto,
+			      sa_req.sa_info.family);
+
+	/* allocate reply */
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
+			       0, C_GET_OFFLD_DATA_FROMSA);
+	if (msg_head == NULL)
+		goto out;
+
+	aalg = kzalloc(sizeof(*aalg) + x->aalg->alg_key_len / 8, GFP_ATOMIC);
+	if (!aalg) {
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	ealg = kzalloc(sizeof(*ealg) + x->ealg->alg_key_len / 8, GFP_ATOMIC);
+	if (!ealg) {
+		kfree_skb(skb);
+		kfree(aalg);
+		return -ENOMEM;
+	}
+
+	memcpy(aalg, x->aalg,
+	       sizeof(struct xfrm_algo_auth) + x->aalg->alg_key_len / 8);
+	rc = nla_put(skb, XFRMA_ALG_AUTH,
+		     sizeof(*aalg) + x->aalg->alg_key_len / 8, aalg);
+	kfree(aalg);
+	if (rc < 0)
+		goto out;
+
+	memcpy(ealg, x->ealg,
+	       sizeof(struct xfrm_algo) + x->ealg->alg_key_len / 8);
+	rc = nla_put(skb, XFRMA_ALG_CRYPT,
+		     sizeof(*ealg) + x->ealg->alg_key_len / 8, ealg);
+	kfree(ealg);
+	if (rc < 0)
+		goto out;
+
+	/* run policy walking and fill skb with policy information */
+	if (x) {
+		arg.x = x;
+		arg.skb = skb;
+		xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
+		xfrm_policy_walk(&init_net, &walk, policy_walk_func_fromsa,
+				 &arg);
+		xfrm_policy_walk_done(&walk);
+	}
+
+	/* send reply to user */
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+	return rc;
+out:
+	kfree_skb(skb);
+	return rc;
+}
+
+/* Command handler for C_GET_OFFLD_DATA_FROMPOL */
+static int get_ipsec_offld_data_frompol(struct sk_buff *skb_2,
+					struct genl_info *info)
+{
+	struct new_pol_req pol_req;
+	struct nlattr *na;
+	struct xfrm_state *state = NULL;
+	struct xfrm_usersa_info sa_info;
+	struct sk_buff *skb;
+	void *msg_head;
+	struct xfrm_policy_walk walk;
+	struct pol_walk_arg_frompol arg;
+	struct xfrm_algo *ealg = NULL;
+	struct xfrm_algo_auth *aalg = NULL;
+	int rc = 0;
+
+	/* check user info */
+	na = info->attrs[A_POL_INFO];
+	if (!na) {
+		pr_err("%s(%d) : no A_POL_INFO (%d) attr in user info\n",
+			 __func__, __LINE__, A_POL_INFO);
+		return -EINVAL;
+	}
+
+	pol_req = *((typeof(&pol_req)) nla_data(na));
+
+	/* get xfrm policy for user policy info */
+	arg.pol_info = &pol_req.pol_info;
+	arg.x = NULL;
+	xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
+	xfrm_policy_walk(&init_net, &walk, policy_walk_func_frompol, &arg);
+	xfrm_policy_walk_done(&walk);
+	if (!arg.x)
+		return -ENOENT;
+
+	/* state lookup on xfrm_policy tmpl */
+	state = xfrm_state_lookup_byaddr(&init_net, 0,
+					 &arg.x->xfrm_vec[0].id.daddr,
+					 &arg.x->xfrm_vec[0].saddr,
+					 arg.x->xfrm_vec[0].id.proto,
+					 pol_req.pol_info.sel.family);
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
+				0, C_GET_OFFLD_DATA_FROMPOL);
+	if (!msg_head) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	/* fill an A_SA_INFO attribute if a xfrm state is found */
+	if (state && ((pol_req.pol_info.dir == XFRM_POLICY_IN) ||
+		      (pol_req.pol_info.dir == XFRM_POLICY_OUT))) {
+		aalg =
+		    kzalloc(sizeof(*aalg) + state->aalg->alg_key_len / 8,
+			    GFP_ATOMIC);
+		if (!aalg) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		ealg =
+		    kzalloc(sizeof(*ealg) + state->ealg->alg_key_len / 8,
+			    GFP_ATOMIC);
+		if (!ealg) {
+			kfree(aalg);
+			rc = -ENOMEM;
+			goto out;
+		}
+
+		memcpy(aalg, state->aalg,
+		       sizeof(struct xfrm_algo_auth) +
+		       state->aalg->alg_key_len / 8);
+		rc = nla_put(skb, XFRMA_ALG_AUTH,
+			     sizeof(*aalg) + state->aalg->alg_key_len / 8,
+			     aalg);
+		kfree(aalg);
+		if (rc < 0)
+			goto out;
+
+		memcpy(ealg, state->ealg,
+		       sizeof(struct xfrm_algo) + state->ealg->alg_key_len / 8);
+		rc = nla_put(skb, XFRMA_ALG_CRYPT,
+			     sizeof(*ealg) + state->ealg->alg_key_len / 8,
+			     ealg);
+		kfree(ealg);
+		if (rc < 0)
+			goto out;
+
+		memset(&sa_info, 0, sizeof(sa_info));
+		sa_info.saddr = state->props.saddr;
+		sa_info.id.daddr = state->id.daddr;
+		sa_info.id.spi = state->id.spi;
+		sa_info.id.proto = state->id.proto;
+		sa_info.family = state->props.family;
+		rc = nla_put(skb, XFRMA_SA, sizeof(sa_info), &sa_info);
+	}
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+	return rc;
+out:
+	kfree_skb(skb);
+	return rc;
+}
+
+static int put_fmc_model(struct sk_buff *skb_2, struct genl_info *info)
+{
+	int rc = 0;
+	struct nlattr *na;
+	struct sk_buff *skb;
+	void *msg_head;
+	static u8 *buff = (u8 *)&cmodel;
+
+	na = info->attrs[A_FMC_MODEL_PART];
+	if (na) {
+		memcpy(buff, (typeof(buff))nla_data(na),
+			na->nla_len - NLA_HDRLEN);
+		buff += na->nla_len - NLA_HDRLEN;
+	} else {
+		na = info->attrs[A_FMC_MODEL_LAST];
+		if (na) {
+			memcpy(buff, (typeof(buff))nla_data(na),
+				na->nla_len - NLA_HDRLEN);
+			buff += na->nla_len - NLA_HDRLEN;
+
+			rc = fmc_config();
+			if (rc) {
+				pr_err("%s(%d) : Error applying PCD\n",
+					__func__, __LINE__);
+				return rc;
+			}
+
+		} else {
+			pr_err("%s(%d) : no A_FMC_MODEL_PART or "
+				" A_FMC_MODEL_LAST attr in user info",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+	}
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
+				0, C_PUT_FMC_MODEL);
+	if (!msg_head) {
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+	return rc;
+}
+
+static int __init_ipsec_offld(struct sk_buff *skb_2, struct genl_info *info)
+{
+	int rc = 0;
+	struct nlattr *na;
+	struct sk_buff *skb;
+	void *msg_head;
+	struct ipsec_uparms params;
+
+	na  = info->attrs[A_INIT_IPSEC_INFO];
+	if (!na) {
+		pr_err("%s(%d) : no A_INIT_IPSEC_INFO (%d) attr in user info\n",
+			__func__, __LINE__, A_INIT_IPSEC_INFO);
+		return -EINVAL;
+	}
+	params = *(typeof(&params))nla_data(na);
+	rc = init_ipsec_offload(&dpa_ipsec_id, &params);
+	if (rc) {
+		pr_err("%s(%d) : Error initalizing IPsec offloading , ret %d\n",
+			__func__, __LINE__, rc);
+		return rc;
+	}
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
+				0, C_INIT_IPSEC_OFFLD);
+	if (!msg_head) {
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+	return rc;
+}
+
+static int __init_xfrm_km(struct sk_buff *skb_2, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct sk_buff *skb;
+	void *msg_head;
+	struct xfrm_km_uparms params;
+	int rc = 0;
+
+	na  = info->attrs[A_XFRM_KM_INFO];
+	if (!na) {
+		pr_err("%s(%d) : no A_XFRM_KM_INFO (%d) attr in user info\n",
+			__func__, __LINE__, A_XFRM_KM_INFO);
+		return -EINVAL;
+	}
+	params = *(typeof(&params))nla_data(na);
+	rc = init_xfrm_km(&params);
+	if (rc) {
+		pr_err("%s(%d) : Error initalizing XFRM key manager , ret %d\n",
+			__func__, __LINE__, rc);
+		return rc;
+	}
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
+			0, C_INIT_XFRM_KM);
+	if (!msg_head) {
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+	return rc;
+}
+
+struct genl_ops dpa_ipacc_ops[] = {
+	{
+		.cmd = C_GET_OFFLD_DATA_FROMSA,
+		.flags = 0,
+		.policy = NULL,
+		.doit = get_ipsec_offld_data_fromsa,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = C_GET_OFFLD_DATA_FROMPOL,
+		.flags = 0,
+		.policy = NULL,
+		.doit = get_ipsec_offld_data_frompol,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = C_PUT_FMC_MODEL,
+		.flags = 0,
+		.policy = NULL,
+		.doit = put_fmc_model,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = C_INIT_IPSEC_OFFLD,
+		.flags = 0,
+		.policy = NULL,
+		.doit = __init_ipsec_offld,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = C_INIT_XFRM_KM,
+		.flags = 0,
+		.policy = NULL,
+		.doit = __init_xfrm_km,
+		.dumpit = NULL,
+	}
+};
+
+int genl_ctl_init(void)
+{
+	int ret;
+	ret = genl_register_family_with_ops(&dpa_ipacc_family,
+		dpa_ipacc_ops, ARRAY_SIZE(dpa_ipacc_ops));
+	return ret;
+}
+
+int genl_ctl_exit(void)
+{
+	int ret;
+	ret = genl_unregister_family(&dpa_ipacc_family);
+	return ret;
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
new file mode 100644
index 0000000..ba989df
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -0,0 +1,98 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _GENL_CTL_H
+#define _GENL_CTL_H
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <net/xfrm.h>
+
+/* Attributes
+ */
+enum genl_attr {
+	A_UNSPEC,
+	A_SA_INFO,
+	A_POL_INFO,
+	A_FMC_MODEL_PART,
+	A_FMC_MODEL_LAST,
+	A_INIT_IPSEC_INFO,
+	A_XFRM_KM_INFO,
+	_A_MAX,
+};
+#define A_MAX (_A_MAX - 1)
+
+#define VERSION_NR 1
+
+/* Commands
+ */
+enum genl_cmd {
+	C_UNSPEC,
+	C_GET_OFFLD_DATA_FROMSA,
+	C_GET_OFFLD_DATA_FROMPOL,
+	C_PUT_FMC_MODEL,
+	C_INIT_IPSEC_OFFLD,
+	C_INIT_XFRM_KM,
+	_C_MAX,
+};
+#define C_MAX (_C_MAX - 1)
+
+/* XFRM_NEW_SA event user request
+ */
+struct new_sa_req {
+	struct xfrm_usersa_info sa_info;
+};
+
+struct new_pol_req {
+	struct xfrm_userpolicy_info pol_info;
+};
+
+struct pol_walk_arg_fromsa {
+	struct xfrm_state *x;
+	struct sk_buff *skb;
+};
+
+struct pol_walk_arg_frompol {
+	struct xfrm_userpolicy_info *pol_info;
+	struct xfrm_policy *x;
+};
+
+struct ipsec_uparms {
+	__u8 ipf_bpid;
+	__u16 max_sa;
+};
+
+struct xfrm_km_uparms {
+	__u8 sa_bpid;
+	__u8 sa_wqid;
+	unsigned int mtu_pre_enc;
+	__u32 def_sa_fqid;
+	__u32 pol_miss_fqid;
+};
+#endif
-- 
1.7.5.4

