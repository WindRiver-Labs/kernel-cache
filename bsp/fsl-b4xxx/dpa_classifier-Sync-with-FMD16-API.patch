From 28680055f3058deaef7cf54c8cb308c18d16c7d2 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Thu, 17 May 2012 13:48:20 +0000
Subject: [PATCH 146/518] dpa_classifier: Sync with FMD16 API

Updates to integrate FMD16 include FMD function name changes,
data structures updates and updates to accomodate FMD function
signature changes.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  212 ++++++++++------------
 1 files changed, 94 insertions(+), 118 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 48c9e40..c7ad427 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -176,7 +176,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	ptable->miss_next_engine_params.nextEngine = e_FM_PCD_DONE;
 	ptable->miss_next_engine_params.params.enqueueParams.action =
 		e_FM_PCD_DROP_FRAME;
-	ptable->miss_next_engine_params.params.enqueueParams.statisticsEn =
+	ptable->miss_next_engine_params.statisticsEn =
 		TRUE;
 
 	table[*td] = ptable;
@@ -261,7 +261,6 @@ int dpa_classif_table_modify_miss_action(int			td,
 	t_FmPcdCcNextEngineParams miss_engine_params;
 	unsigned int i;
 	struct dpa_cls_table *ptable;
-	t_Handle fm_pcd;
 
 	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
 		-EINVAL);
@@ -280,23 +279,22 @@ int dpa_classif_table_modify_miss_action(int			td,
 	if (errno < 0)
 		return errno;
 
-	fm_pcd = (t_Handle)ptable->params.fm_pcd;
 	if (ptable->params.type == DPA_CLS_TBL_HASH) {
 		/*
 		 * Set the next engine params for all the sets of the HASH
 		 * table
 		 */
-		for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
-			err = FM_PCD_CcNodeModifyMissNextEngine(fm_pcd,
-				(t_Handle)ptable->int_cc_node[i].cc_node,
-				&miss_engine_params);
-			if (err != E_OK) {
-				xx_pr_fmd_err(err,
-					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err("FMan driver call failed.");
-				return -EBUSY;
-			}
-		}
+for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
+
+	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
+		int_cc_node[i].cc_node,	&miss_engine_params);
+	if (err != E_OK) {
+		xx_pr_fmd_err(err,
+			"FM_PCD_MatchTableModifyMissNextEngine");
+		xx_pr_err("FMan driver call failed.");
+		return -EBUSY;
+	}
+}
 	} else {
 		/*
 		 * For exact match tables, the miss action is updated on the
@@ -314,11 +312,11 @@ int dpa_classif_table_modify_miss_action(int			td,
 		if (i == 0)
 			i = 1;
 
-		err = FM_PCD_CcNodeModifyMissNextEngine(fm_pcd,
-			(t_Handle)ptable->int_cc_node[i-1].cc_node,
-			&miss_engine_params);
+	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
+			int_cc_node[i-1].cc_node, &miss_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyMissNextEngine");
+			xx_pr_fmd_err(err,
+				"FM_PCD_MatchTableModifyMissNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -437,7 +435,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	int errno;
 	t_Error err;
 	struct dpa_cls_table *ptable;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 	struct list_head *shadow_list_entry, *new_bucket_list;
 
 	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
@@ -460,7 +458,6 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	entry_index	= ptable->entry[entry_id].entry_index;
 
-	fm_pcd	= (t_Handle)ptable->params.fm_pcd;
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	switch (mod_params->type) {
 	case DPA_CLS_TBL_MODIFY_ACTION:
@@ -469,12 +466,11 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		if (errno < 0)
 			return errno;
 
-		err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-						cc_node,
+		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -494,14 +490,13 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 			mod_params->key->mask,
 			ptable->params.exact_match_params.key_size);
 
-		err = FM_PCD_CcNodeModifyKey(fm_pcd,
-				cc_node,
+		err = FM_PCD_MatchTableModifyKey(cc_node,
 				entry_index,
 				ptable->params.exact_match_params.key_size,
 				key_data,
 				mask_data);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyKey");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -529,14 +524,13 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		key_params.p_Key	= key_data;
 		key_params.p_Mask	= mask_data;
 
-		err = FM_PCD_CcNodeModifyKeyAndNextEngine(fm_pcd,
-				cc_node,
+		err = FM_PCD_MatchTableModifyKeyAndNextEngine(cc_node,
 				entry_index,
 				ptable->params.exact_match_params.key_size,
 				&key_params);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err,
-				"FM_PCD_CcNodeModifyKeyAndNextEngine");
+				"FM_PCD_MatchTableModifyKeyAndNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -635,7 +629,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	uint8_t entry_index;
 	unsigned int cc_node_index;
 	struct dpa_cls_table *ptable;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 	struct list_head *shadow_list_entry, *list_current;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
@@ -652,7 +646,6 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	entry_index	= ptable->entry[entry_id].entry_index;
 
-	fm_pcd	= (t_Handle)ptable->params.fm_pcd;
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	int_cc_node = &ptable->int_cc_node[cc_node_index];
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
@@ -665,13 +658,12 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 		next_engine_params.nextEngine = e_FM_PCD_DONE;
 		next_engine_params.params.enqueueParams.action =
 			e_FM_PCD_DROP_FRAME;
-		next_engine_params.params.enqueueParams.statisticsEn = FALSE;
-		err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-						cc_node,
+		next_engine_params.statisticsEn = FALSE;
+		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -679,11 +671,10 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 		/* No indexes updates are necessary for the indexed table */
 	} else {
 		/* For all the other tables types we can remove the key */
-		err = FM_PCD_CcNodeRemoveKey(fm_pcd,
-					cc_node,
+		err = FM_PCD_MatchTableRemoveKey(cc_node,
 					entry_index);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeRemoveKey");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableRemoveKey");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -834,7 +825,7 @@ int dpa_classif_table_flush(int td)
 	unsigned int cc_node_index;
 	t_Error err;
 	struct dpa_cls_table *ptable;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 	struct list_head *list_current, *tmp;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
@@ -848,26 +839,24 @@ int dpa_classif_table_flush(int td)
 		return 0;
 
 	ptable = table[td];
-	fm_pcd = (t_Handle)ptable->params.fm_pcd;
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		memset(&next_engine_params, 0,
 			sizeof(t_FmPcdCcNextEngineParams));
 		next_engine_params.nextEngine = e_FM_PCD_DONE;
 		next_engine_params.params.enqueueParams.action =
 			e_FM_PCD_DROP_FRAME;
-		next_engine_params.params.enqueueParams.statisticsEn = FALSE;
+		next_engine_params.statisticsEn = FALSE;
 
 		cc_node = (t_Handle)ptable->int_cc_node[0].cc_node;
 		list_for_each_entry(index_entry,
 				&ptable->entry_list,
 				list_node) {
-			err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-						cc_node,
+			err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 						index_entry->entry_index,
 						&next_engine_params);
 			if (err != E_OK) {
 				xx_pr_fmd_err(err,
-					"FM_PCD_CcNodeModifyNextEngine");
+					"FM_PCD_MatchTableModifyNextEngine");
 				xx_pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
@@ -911,19 +900,19 @@ int dpa_classif_table_flush(int td)
 								cc_node;
 			int_cc_node = &ptable->int_cc_node[cc_node_index];
 
-			err = FM_PCD_CcNodeRemoveKey(fm_pcd,
-						cc_node,
+			err = FM_PCD_MatchTableRemoveKey(cc_node,
 						index_entry->entry_index);
 			if (err != E_OK) {
-				xx_pr_fmd_err(err, "FM_PCD_CcNodeRemoveKey");
+				xx_pr_fmd_err(err,
+					"FM_PCD_MatchTableRemoveKey");
 				xx_pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
 
 			int_cc_node->used--;
 			index_entry->valid = 0;
-			tmp = list_current;
-			list_current = list_current->prev;
+			tmp	= list_current;
+			list_current	= list_current->prev;
 			list_del(tmp);
 		}
 	}
@@ -965,7 +954,7 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 {
 	unsigned int cc_node_index;
 	uint8_t entry_index;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 	struct dpa_cls_table *ptable;
 	struct dpa_cls_tbl_entry *index_entry;
 
@@ -983,11 +972,9 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 	index_entry	= &ptable->entry[entry_id];
 	entry_index	= index_entry->entry_index;
 
-	fm_pcd = (t_Handle)ptable->params.fm_pcd;
 	cc_node = (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
-	stats->total_pkts = (unsigned long) FM_PCD_CcNodeGetKeyCounter(fm_pcd,
-						cc_node,
-						entry_index);
+	stats->total_pkts = (unsigned long)
+		FM_PCD_MatchTableGetKeyCounter(cc_node,	entry_index);
 
 	if (stats->total_pkts < index_entry->last_stats.total_pkts)
 		/* Roll over */
@@ -1031,7 +1018,7 @@ int dpa_classif_table_reset_entry_stats_by_ref(int		td,
 {
 	unsigned int cc_node_index;
 	struct dpa_cls_tbl_entry *index_entry;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 
 	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
 		-EINVAL);
@@ -1044,11 +1031,9 @@ int dpa_classif_table_reset_entry_stats_by_ref(int		td,
 	cc_node_index	= table[td]->entry[entry_id].int_cc_node_index;
 	index_entry	= &table[td]->entry[entry_id];
 
-	fm_pcd = (t_Handle)table[td]->params.fm_pcd;
 	cc_node = (t_Handle)table[td]->int_cc_node[cc_node_index].cc_node;
 	index_entry->last_stats.total_pkts =
-		(unsigned long) FM_PCD_CcNodeGetKeyCounter(fm_pcd,
-						cc_node,
+		(unsigned long) FM_PCD_MatchTableGetKeyCounter(cc_node,
 						index_entry->entry_index);
 	index_entry->stats.total_pkts = 0;
 
@@ -1109,7 +1094,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	int errno;
 	uint8_t i;
 	t_FmPcdCcNextEngineParams next_engine_params;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 
 	xx_assert(cls_table);
 	xx_assert(cls_table->params.type == DPA_CLS_TBL_INDEXED);
@@ -1129,15 +1114,13 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	next_engine_params.nextEngine = e_FM_PCD_DONE;
 	next_engine_params.params.enqueueParams.action = e_FM_PCD_DROP_FRAME;
 
-	fm_pcd	= (t_Handle)cls_table->params.fm_pcd;
 	cc_node	= (t_Handle)cls_table->params.cc_node;
 	for (i = 0; i < cls_table->params.indexed_params.entries_cnt; i++) {
-		err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-						cc_node,
+		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 						i,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
@@ -1208,10 +1191,10 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	for (i = 0; i < cls_table->params.hash_params.num_sets; i++) {
 		/* Create the HASH set */
 		cls_table->int_cc_node[i].cc_node =
-			(void *)FM_PCD_CcSetNode(fm_pcd,
+			(void *)FM_PCD_MatchTableSet(fm_pcd,
 					hash_set_params);
 		if (cls_table->int_cc_node[i].cc_node == NULL) {
-			xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_CcSetNode");
+			xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_MatchTableSet");
 			xx_pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
@@ -1222,13 +1205,12 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		/* Link the HASH set into the initial Cc node */
 		next_engine_params.params.ccParams.h_CcNode =
 			(t_Handle)cls_table->int_cc_node[i].cc_node;
-		err_code = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-						cc_node,
+		err_code = FM_PCD_MatchTableModifyNextEngine(cc_node,
 						(uint8_t)i,
 						&next_engine_params);
 		if (err_code != E_OK) {
 			xx_pr_fmd_err(err_code,
-				"FM_PCD_CcNodeModifyNextEngine");
+				"FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
@@ -1317,11 +1299,11 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 				* created */
 			/* Dynamically create Cc node */
 			cls_table->int_cc_node[i].cc_node =
-				(void *)FM_PCD_CcSetNode(fm_pcd,
+				(void *)FM_PCD_MatchTableSet(fm_pcd,
 					cc_node_params);
 			if (!cls_table->int_cc_node[i].cc_node) {
 				xx_pr_fmd_err(E_NOT_AVAILABLE,
-					"FM_PCD_CcSetNode");
+					"FM_PCD_MatchTableSet");
 				xx_pr_err("FMan driver call failed.");
 				err = -EBUSY;
 				goto table_init_exact_match_error;
@@ -1372,12 +1354,12 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 	t_FmPcdCcNextEngineParams next_engine_params;
 	unsigned int i;
 	t_Error err;
-	t_Handle fm_pcd;
+	t_Handle cc_node;
 
 	xx_assert(cls_table);
 	xx_assert(cls_table->params.type == DPA_CLS_TBL_HASH);
 
-	fm_pcd = (t_Handle)cls_table->params.fm_pcd;
+	cc_node = (t_Handle)cls_table->params.cc_node;
 	for (i = 0; (i < cls_table->int_cc_nodes_count) &&
 			(cls_table->int_cc_node[i].cc_node); i++) {
 		/*
@@ -1393,15 +1375,14 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 		 * We can only delete nodes if the miss action of the initial
 		 * node doesn't point to the dynamic Cc node chain
 		 */
-		err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-				(t_Handle)cls_table->params.cc_node,
+		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 				(uint8_t)i,
 				&next_engine_params);
 		if (err == E_OK)
-			FM_PCD_CcDeleteNode(fm_pcd,
-				(t_Handle)cls_table->int_cc_node[i].cc_node);
+			FM_PCD_MatchTableDelete((t_Handle)cls_table->
+				int_cc_node[i].cc_node);
 		else {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			xx_pr_warn("DPA Classifier failed to clean up hash table.");
 		}
@@ -1419,7 +1400,7 @@ static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 	t_FmPcdCcNextEngineParams cc_miss_engine_params;
 	unsigned int i;
 	t_Error err;
-	t_Handle fm_pcd;
+	t_Handle cc_node;
 
 	xx_assert(cls_table);
 	xx_assert(cls_table->params.type == DPA_CLS_TBL_EXACT_MATCH);
@@ -1430,21 +1411,20 @@ static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 	cc_miss_engine_params.params.enqueueParams.action = e_FM_PCD_DROP_FRAME;
 
 	if (cls_table->int_cc_nodes_count > 1) {
-		fm_pcd = (t_Handle)cls_table->params.fm_pcd;
+		cc_node = (t_Handle)cls_table->int_cc_node[0].cc_node;
 		/*
 		 * We can only delete nodes if the miss action of the initial
 		 * node doesn't point to the dynamic Cc node chain
 		 */
-		err = FM_PCD_CcNodeModifyMissNextEngine(fm_pcd,
-				(t_Handle)cls_table->int_cc_node[0].cc_node,
+		err = FM_PCD_MatchTableModifyMissNextEngine(cc_node,
 				&cc_miss_engine_params);
 		if (err == E_OK) {
 			for (i = 1; (i < cls_table->int_cc_nodes_count) &&
 				(cls_table->int_cc_node[i].cc_node); i++)
-				FM_PCD_CcDeleteNode(fm_pcd,
-				(t_Handle)cls_table->int_cc_node[i].cc_node);
+				FM_PCD_MatchTableDelete((t_Handle)cls_table->
+					int_cc_node[i].cc_node);
 		} else {
-			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 			xx_pr_err("FMan driver call failed.");
 			xx_pr_warn("DPA Classifier failed to clean up exact match table.");
 		}
@@ -1624,7 +1604,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	int errno = 0;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry = NULL;
 	t_FmPcdCcNextEngineParams next_engine_params;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 
 	xx_assert(cls_table);
 	xx_assert(key);
@@ -1640,15 +1620,13 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	if (errno < 0)
 		goto table_insert_entry_indexed_error;
 
-	fm_pcd	= (t_Handle)cls_table->params.fm_pcd;
 	cc_node	= (t_Handle)cls_table->int_cc_node[0].cc_node;
 	/* Considering the index as the first byte in the key... */
-	err = FM_PCD_CcNodeModifyNextEngine(fm_pcd,
-					cc_node,
+	err = FM_PCD_MatchTableModifyNextEngine(cc_node,
 					key->byte[0],
 					&next_engine_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
+		xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
 		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_indexed_error;
@@ -1843,39 +1821,37 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			cc_miss_engine_params.params.ccParams.h_CcNode =
 				(t_Handle)cls_table->int_cc_node[i].cc_node;
 
-			err = FM_PCD_CcNodeModifyMissNextEngine(fm_pcd,
-				(t_Handle)cls_table->int_cc_node[i-1].cc_node,
-				&cc_miss_engine_params);
-			if (err != E_OK) {
-				xx_pr_fmd_err(err,
-					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err("FMan driver call failed.");
-				errno = -EBUSY;
-				goto table_insert_entry_exact_match_error;
-			}
+	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
+		int_cc_node[i-1].cc_node, &cc_miss_engine_params);
+		if (err != E_OK) {
+			xx_pr_fmd_err(err,
+				"FM_PCD_MatchTableModifyMissNextEngine");
+			xx_pr_err("FMan driver call failed.");
+			errno = -EBUSY;
+			goto table_insert_entry_exact_match_error;
+		}
 
-			/* Set the table miss action on this node */
-			err = FM_PCD_CcNodeModifyMissNextEngine(fm_pcd,
-				(t_Handle)cls_table->int_cc_node[i].cc_node,
-				&cls_table->miss_next_engine_params);
-			if (err != E_OK) {
-				xx_pr_fmd_err(err,
-					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err("FMan driver call failed.");
-				errno = -EBUSY;
-				goto table_insert_entry_exact_match_error;
-			}
+	/* Set the table miss action on this node */
+	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
+		int_cc_node[i].cc_node, &cls_table->miss_next_engine_params);
+		if (err != E_OK) {
+			xx_pr_fmd_err(err,
+				"FM_PCD_MatchTableModifyMissNextEngine");
+			xx_pr_err("FMan driver call failed.");
+			errno = -EBUSY;
+			goto table_insert_entry_exact_match_error;
+		}
 		}
 	}
 
 	/* Add the key to the selected Cc node */
-	err = FM_PCD_CcNodeAddKey(fm_pcd,
-		(t_Handle)cls_table->int_cc_node[i].cc_node,
+	err = FM_PCD_MatchTableAddKey((t_Handle)cls_table->
+			int_cc_node[i].cc_node,
 		cls_table->entry[k].entry_index,
 		cls_table->params.exact_match_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_CcNodeAddKey");
+		xx_pr_fmd_err(err, "FM_PCD_MatchTableAddKey");
 		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_exact_match_error;
@@ -2035,13 +2011,13 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	}
 
 	/* Add the key to the selected Cc node */
-	err = FM_PCD_CcNodeAddKey((t_Handle)cls_table->params.fm_pcd,
-		(t_Handle)cls_table->int_cc_node[hash_set_index].cc_node,
+	err = FM_PCD_MatchTableAddKey((t_Handle)cls_table->
+			int_cc_node[hash_set_index].cc_node,
 		cls_table->entry[j].entry_index,
 		cls_table->params.hash_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_CcNodeAddKey");
+		xx_pr_fmd_err(err, "FM_PCD_MatchTableAddKey");
 		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_hash_error;
@@ -2109,7 +2085,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		next_engine_params->params.enqueueParams.action =
 			e_FM_PCD_DROP_FRAME;
 		if (action->enable_statistics)
-			next_engine_params->params.enqueueParams.statisticsEn =
+			next_engine_params->statisticsEn =
 				TRUE;
 
 		break;
@@ -2129,7 +2105,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 			next_engine_params->params.enqueueParams.overrideFqid =
 				TRUE;
 		if (action->enable_statistics)
-			next_engine_params->params.enqueueParams.statisticsEn =
+			next_engine_params->statisticsEn =
 				TRUE;
 
 		break;
-- 
1.7.5.4

