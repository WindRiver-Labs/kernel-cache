From 122b1187198bd427732eba43e3e59bd6a2a839f2 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:58:06 +0000
Subject: [PATCH 242/518] dpa_classifier: Add header manipulation support in
 driver wrapper

Add header manipulation commands access from user space via ioctl.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |  114 +++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  328 ++++++++++++++++++++
 2 files changed, 435 insertions(+), 7 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 84243f2..e02b3a6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -42,6 +42,10 @@
 #include "linux/ioctl.h"
 #include <linux/compat.h>
 
+
+#define DPA_CLS_IOC_MAGIC				0xbe
+
+
 struct ioc_dpa_cls_tbl_params {
 	struct dpa_cls_tbl_params table_params;
 	int td;
@@ -108,6 +112,54 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 	int reset;
 };
 
+struct ioc_dpa_cls_hm_remove_params {
+	struct dpa_cls_hm_remove_params rm_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_remove_resources res;
+	bool chain_head;
+};
+
+struct ioc_dpa_cls_hm_insert_params {
+	struct dpa_cls_hm_insert_params ins_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_insert_resources res;
+	bool chain_head;
+};
+
+struct ioc_dpa_cls_hm_vlan_params {
+	struct dpa_cls_hm_vlan_params vlan_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_vlan_resources res;
+	bool chain_head;
+};
+
+struct ioc_dpa_cls_hm_nat_params {
+	struct dpa_cls_hm_nat_params nat_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_nat_resources res;
+	bool chain_head;
+};
+
+struct ioc_dpa_cls_hm_update_params {
+	struct dpa_cls_hm_update_params update_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_update_resources res;
+	bool chain_head;
+};
+
+struct ioc_dpa_cls_hm_fwd_params {
+	struct dpa_cls_hm_fwd_params fwd_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_fwd_resources res;
+	bool chain_head;
+};
+
 
 #ifdef CONFIG_COMPAT
 
@@ -132,7 +184,7 @@ struct dpa_cls_compat_tbl_enq_action_desc {
 	int		override_fqid;
 	uint32_t	new_fqid;
 	compat_uptr_t	policer_params;
-	compat_uptr_t	hm;
+	int		hmd;
 };
 
 struct dpa_cls_compat_tbl_action {
@@ -231,8 +283,6 @@ void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 #endif /* CONFIG_COMPAT */
 
 
-#define DPA_CLS_IOC_MAGIC				0xbe
-
 #define DPA_CLS_IOC_TBL_CREATE				\
 	_IOWR(DPA_CLS_IOC_MAGIC, 0, struct ioc_dpa_cls_tbl_params)
 
@@ -310,17 +360,67 @@ void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 	_IOR(DPA_CLS_IOC_MAGIC, 12, struct ioc_dpa_cls_tbl_entry_stats_by_ref)
 
 #define DPA_CLS_IOC_TBL_RESET_STATS_BY_KEY		\
-	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_by_key)
+	_IOR(DPA_CLS_IOC_MAGIC, 13, struct ioc_dpa_cls_tbl_entry_by_key)
 
 #define DPA_CLS_IOC_TBL_RESET_STATS_BY_REF		\
-	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_by_ref)
+	_IOR(DPA_CLS_IOC_MAGIC, 14, struct ioc_dpa_cls_tbl_entry_by_ref)
 
 #define DPA_CLS_IOC_TBL_GET_PARAMS			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 13, struct ioc_dpa_cls_tbl_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 15, struct ioc_dpa_cls_tbl_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_TBL_GET_PARAMS			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 13, struct dpa_cls_compat_tbl_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 15, struct dpa_cls_compat_tbl_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_REMOVE_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 16, struct ioc_dpa_cls_hm_remove_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_REMOVE_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 16,			\
+		struct compat_ioc_dpa_cls_hm_ingress_rm_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_INSERT_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 17, struct ioc_dpa_cls_hm_insert_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_INSERT_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 17,			\
+		struct compat_ioc_dpa_cls_hm_egress_ins_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_VLAN_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 18, struct ioc_dpa_cls_hm_vlan_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_VLAN_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 18, struct compat_ioc_dpa_cls_hm_vlan_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_NAT_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 19, struct ioc_dpa_cls_hm_nat_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_NAT_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 19, struct compat_ioc_dpa_cls_hm_nat_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_UPDATE_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct ioc_dpa_cls_hm_update_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_UPDATE_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct compat_ioc_dpa_cls_hm_update_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_FWD_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct ioc_dpa_cls_hm_fwd_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_FWD_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct compat_ioc_dpa_cls_hm_fwd_params)
 #endif /* CONFIG_COMPAT */
 
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 08aa808..c206286 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -68,7 +68,19 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode);
 
 static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode);
 
+static long do_ioctl_set_remove_hm(unsigned long	args,
+				bool			compat_mode);
+
+static long do_ioctl_set_insert_hm(unsigned long	args,
+				bool			compat_mode);
+
+static long do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode);
+
+static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode);
+
+static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode);
 
 static const struct file_operations dpa_classif_fops = {
 	.owner			= THIS_MODULE,
@@ -406,6 +418,43 @@ long wrp_dpa_classif_do_ioctl(
 
 		break;
 	}
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_REMOVE_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_REMOVE_HM:
+		ret = do_ioctl_set_remove_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_INSERT_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_INSERT_HM:
+			ret = do_ioctl_set_insert_hm(args, compat_mode);
+			break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_VLAN_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_VLAN_HM:
+			ret = do_ioctl_set_vlan_hm(args, compat_mode);
+			break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_NAT_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_NAT_HM:
+			ret = do_ioctl_set_nat_hm(args, compat_mode);
+			break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_UPDATE_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_UPDATE_HM:
+			ret = do_ioctl_set_update_hm(args, compat_mode);
+			break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_FWD_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_FWD_HM:
+			ret = do_ioctl_set_fwd_hm(args, compat_mode);
+			break;
+
 
 	default:
 		pr_err("ERROR: %s, %s (%d): DPA Classifier ioctl command "
@@ -483,6 +532,285 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	return ret;
 }
 
+static long do_ioctl_set_remove_hm(unsigned long args,
+					bool			compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_remove_params kparam;
+	struct dpa_cls_hm_remove_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: "
+			"dpa_classif_set_ingress_remove_hm user space args.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.rm_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.rm_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+
+	if (kparam.res.remove_node)
+		p_res = &kparam.res;
+
+	ret = dpa_classif_set_remove_hm(&kparam.rm_params, kparam.next_hmd,
+					&kparam.hmd, kparam.chain_head,
+					p_res);
+
+
+	if (ret < 0)
+		return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_ingress_remove_hm result.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+}
+
+static long do_ioctl_set_insert_hm(unsigned long args,
+					bool			compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_insert_params kparam;
+	struct dpa_cls_hm_insert_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: "
+			"dpa_classif_set_egress_insert_hm user space args.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.ins_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.ins_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	if (kparam.res.insert_node)
+		p_res = &kparam.res;
+
+	ret = dpa_classif_set_insert_hm(&kparam.ins_params, kparam.next_hmd,
+					&kparam.hmd, kparam.chain_head,
+					p_res);
+
+	if (ret < 0)
+			return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_egress_insert_hm result.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+
+}
+
+static long  do_ioctl_set_vlan_hm(unsigned long args, bool	compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_vlan_params kparam;
+	struct dpa_cls_hm_vlan_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: "
+			"dpa_classif_set_vlan_hm user space args.\n", __FILE__,
+			__func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.vlan_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.vlan_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	if (kparam.res.vlan_node)
+			p_res = &kparam.res;
+
+	ret = dpa_classif_set_vlan_hm(&kparam.vlan_params, kparam.next_hmd,
+				      &kparam.hmd, kparam.chain_head,
+				      p_res);
+
+	if (ret < 0)
+			return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_vlan_hm result.\n", __FILE__, __func__,
+			__LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+
+}
+
+static long do_ioctl_set_nat_hm(unsigned long args, bool	compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_nat_params kparam;
+	struct dpa_cls_hm_nat_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: "
+			"dpa_classif_set_nat_hm user space args.\n", __FILE__,
+			__func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.nat_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.nat_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
+		p_res = &kparam.res;
+
+	ret =  dpa_classif_set_nat_hm(&kparam.nat_params, kparam.next_hmd,
+				      &kparam.hmd, kparam.chain_head,
+				      p_res);
+
+	if (ret < 0)
+			return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_nat_hm result.\n", __FILE__, __func__,
+			__LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+}
+
+static long do_ioctl_set_update_hm(unsigned long args, bool	compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_update_params kparam;
+	struct dpa_cls_hm_update_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: "
+			"do_ioctl_set_update_hm user space args.\n", __FILE__,
+			__func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.update_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.update_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	if (kparam.res.ip_frag_node || kparam.res.update_node)
+		p_res = &kparam.res;
+
+	ret =  dpa_classif_set_update_hm(&kparam.update_params, kparam.next_hmd,
+					&kparam.hmd, kparam.chain_head,
+					p_res);
+
+
+	if (ret < 0)
+			return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_update_hm result.\n", __FILE__,
+			__func__, __LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+}
+
+static long do_ioctl_set_fwd_hm(unsigned long args, bool	compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_fwd_params kparam;
+	struct dpa_cls_hm_fwd_resources *p_res = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Read failed: dpa_classif_set_fwd_hm"
+			" user space args.\n", __FILE__, __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.fwd_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.fwd_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
+	    kparam.res.pppoe_node)
+		p_res = &kparam.res;
+
+	ret = dpa_classif_set_fwd_hm(&kparam.fwd_params, kparam.next_hmd,
+				&kparam.hmd, kparam.chain_head,
+				p_res);
+
+
+	if (ret < 0)
+			return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("ERROR: %s, %s (%d): Write failed: "
+			"dpa_classif_set_fwd_hm result.\n", __FILE__, __func__,
+			__LINE__);
+		return -EBUSY;
+	}
+
+	return ret;
+}
+
 static long do_ioctl_table_modify_miss_action(unsigned long	args,
 					bool			compat_mode)
 {
-- 
1.7.5.4

