From 9df79cd31e9442d3886d16008f6c1058d0b7d772 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:14:03 +0000
Subject: [PATCH 212/518] Updated DPA IPSec sanity checks mechanism, used
 BUG_ON macro.

replaced all sanity checks done with if condition with the
Linux macro BUG_ON.

removed the return value -EFAULT and where this was the
only error value returned I have modified also the returning
type of that function to void.

cosmetics and in some places I have added internal bug detection

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  514 +++++++--------------------
 1 files changed, 120 insertions(+), 394 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index fefb613..e6f8b7b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -64,10 +64,7 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
 
-	if (!sa) {
-		xx_pr_err("Invalid argument: null SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
 
 	xx_pr_info("\n Printing SA SEC PARAM for sa %p\n", sa);
 	xx_pr_info("\n sa_dir = %d\n", sa->sa_dir);
@@ -290,26 +287,17 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	return 0;
 }
 
-static int calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
+static void calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 {
 	uint8_t key_fields, field_mask = 0;
 	int i;
 
-	/* sanity checks */
-	if (!key_size) {
-		xx_pr_err("Invalid argument: NULL key_size parameter\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!key_size);
 
 	/* default value for key_size (set now in case a failure occurs later)*/
 	*key_size = 0;
 
-	/* more sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
 	key_fields = dpa_ipsec->config.post_sec_in_params.key_fields;
 
 	for (i = 0; i < DPA_IPSEC_MAX_KEY_FIELDS; i++) {
@@ -342,29 +330,18 @@ static int calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 			break;
 		}
 	}
-
-	return 0;
 }
 
 static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 {
 	t_FmPcdCcNextEngineParams *next_engine_miss_action;
 
-	/* sanity checks */
-	if (!cc_node) {
-		xx_pr_err("Invalid argument: NULL CC Node handle holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!cc_node);
 
 	/* default value for cc_node (set now in case a failure occurs later) */
 	*cc_node = NULL;
 
-	/* more sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
 	if (dpa_ipsec->sa_mng.inpol_key_size == 0) {
 		xx_pr_err("Invalid argument: in policy table key size\n");
 		return -EFAULT;
@@ -416,25 +393,12 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 	struct dpa_cls_tbl_params params;
 	int err;
 
-	/* sanity checks */
-	if (!td) {
-		xx_pr_err("Invalid argument: NULL table descriptor holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!cc_node);
+	BUG_ON(!td);
 
 	*td = DPA_CLS_INVALID_TABLE_DESC;
 
-	/* more sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!cc_node) {
-		xx_pr_err("Invalid argument: NULL CC Node handle\n");
-		return -EFAULT;
-	}
-
 	memset(&params, 0, sizeof(params));
 	params.fm_pcd = dpa_ipsec->config.fm_pcd;
 	params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
@@ -465,21 +429,9 @@ static inline void destroy_inpol_cls_tbl(int td)
 
 static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t *flowid)
 {
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err("Invalid argument: NULL in policy flow ID CQ\n");
-		return -EFAULT;
-	}
-
-	if (!flowid) {
-		xx_pr_err("Invalid argument: NULL flow ID parameter\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!dpa_ipsec->sa_mng.inbound_flowid_cq);
+	BUG_ON(!flowid);
 
 	if (cq_get_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
 		xx_pr_err("Could not retrieve a valid inbound flow ID\n");
@@ -491,16 +443,8 @@ static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t *flowid)
 
 static int put_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t flowid)
 {
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err("Invalid argument: NULL in policy flow ID CQ\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!dpa_ipsec->sa_mng.inbound_flowid_cq);
 
 	if (cq_put_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
 		xx_pr_err("Could not release inbound flow id\n");
@@ -515,11 +459,7 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	void *cq;
 	int i, err;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
 
 	cq = cq_new(dpa_ipsec->sa_mng.max_num_sa / 2, sizeof(uint16_t));
 	if (!cq) {
@@ -554,17 +494,10 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 {
 	struct inpol_tbl *inpol_tbl;
 	struct list_head *head;
+	int ret = 0;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!table_desc) {
-		xx_pr_err("Invalid argument: in policy table desc holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!table_desc);
 
 	/* Lock inbound policy list */
 	mutex_lock(&dpa_ipsec->sa_mng.inpol_tables_lock);
@@ -572,47 +505,31 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 	head = &dpa_ipsec->sa_mng.inpol_tables;
 
 	list_for_each_entry(inpol_tbl, head, table_list)
-		if (inpol_tbl->used == FALSE)
+		if (!inpol_tbl->used)
 			break;
 
-	if (inpol_tbl->used == FALSE)
+	if (!inpol_tbl->used) {
+		BUG_ON(inpol_tbl->td < 0);
 		inpol_tbl->used = TRUE;
-	else {
+		*table_desc = inpol_tbl->td;
+	} else {
 		xx_pr_err("No more free EM tables for inbound policy verification\n");
-		/* Unlock inbound policy list */
-		mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
-		return -ENOMEM;
+		ret = -ENOMEM;
 	}
 
-	if (inpol_tbl->td < 0) {
-		xx_pr_err("Invalid table reference\n");
-		/* Unlock inbound policy list */
-		mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
-		return -EFAULT;
-	}
-
-	*table_desc = inpol_tbl->td;
 	/* Unlock inbound policy list */
 	mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
 
-	return 0;
+	return ret;
 }
 
-static int put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
+static void put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 {
 	struct inpol_tbl *inpol_tbl;
 	struct list_head *head;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (table_desc == DPA_CLS_INVALID_TABLE_DESC) {
-		xx_pr_err("Invalid argument: in policy table desc holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(table_desc < 0);
 
 	/* Lock inbound policy list */
 	mutex_lock(&dpa_ipsec->sa_mng.inpol_tables_lock);
@@ -623,18 +540,13 @@ static int put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 	    if (inpol_tbl->td == table_desc)
 		break;
 
-	if (inpol_tbl->used == FALSE) {
-		xx_pr_warn("Exact match table %d is not used\n", table_desc);
-		/* Unlock inbound policy list */
-		mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
-		return 0;
-	} else
+	if (inpol_tbl->used)
 		inpol_tbl->used = FALSE;
+	else
+		xx_pr_warn("Exact match table %d is not used\n", table_desc);
 
 	/* Unlock inbound policy list */
 	mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
-
-	return 0;
 }
 
 /*
@@ -649,11 +561,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	struct dpa_ipsec_sa_mng *sa_mng;
 	int i = 0, err;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
 
 	sa_mng = &dpa_ipsec->sa_mng;
 	sa_mng->max_num_sa = dpa_ipsec->config.max_sa_pairs * 2;
@@ -744,10 +652,8 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		void *cc_node;
 
 		/* calculate key size for policy verification tables */
-		err = calc_in_pol_key_size(dpa_ipsec,
-					   &dpa_ipsec->sa_mng.inpol_key_size);
-		if (err < 0)
-			return err;
+		calc_in_pol_key_size(dpa_ipsec,
+				     &dpa_ipsec->sa_mng.inpol_key_size);
 
 		INIT_LIST_HEAD(&sa_mng->inpol_tables);
 		mutex_init(&sa_mng->inpol_tables_lock);
@@ -913,11 +819,7 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 					    0xfc, 0xfe, 0xff};
 	uint8_t bit, off;
 
-	/* sanity checks */
-	if (!mask) {
-		xx_pr_err("Invalid argument: NULL mask parameter\n");
-		return -EFAULT;
-	}
+	BUG_ON(!mask);
 
 	off = prefix_len / 8;
 	bit = prefix_len % 8;
@@ -932,18 +834,15 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	int table;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action *action;
-	int err;
+	int table, err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
+
 	/* AV's note: TODO - case when inbound_flowid is greater than 255 */
 	memset(&tbl_key, 0, sizeof(tbl_key));
 	tbl_key.byte[0] = (uint8_t) sa->inbound_flowid;
@@ -969,26 +868,10 @@ static int fill_policy_key(int td,
 	uint8_t offset = 0, field_mask = 0, tbl_key_size = 0;
 	int err = 0, i;
 
-	/* sanity checks */
-	if (!pol_sel) {
-		xx_pr_err("Invalid argument: NULL policy selectors\n");
-		return -EFAULT;
-	}
-
-	if (!key) {
-		xx_pr_err("Invalid argument: NULL key container\n");
-		return -EFAULT;
-	}
-
-	if (!mask) {
-		xx_pr_err("Invalid argument: NULL mask container\n");
-		return -EFAULT;
-	}
-
-	if (!key_len) {
-		xx_pr_err("Invalid argument: NULL key_len container\n");
-		return -EFAULT;
-	}
+	BUG_ON(!pol_sel);
+	BUG_ON(!key);
+	BUG_ON(!mask);
+	BUG_ON(!key_len);
 
 	/* Fill in the key components */
 	for (i = 0; i < DPA_IPSEC_MAX_KEY_FIELDS; i++) {
@@ -1130,21 +1013,9 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 {
 	t_FmPcdManipFragParams *frag_param;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy handle\n");
-		return -EFAULT;
-	}
-
-	if (!hm) {
-		xx_pr_err("Invalid argument: NULL manip holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!policy_entry);
+	BUG_ON(!hm);
 
 	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
 	frag_param = &pcd_manip_params.u.frag;
@@ -1163,27 +1034,17 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	return 0;
 }
 
-static int create_ipsec_manip(struct dpa_ipsec *dpa_ipsec,
-			     struct dpa_ipsec_sa *sa,
-			     struct dpa_cls_tbl_header_manip **hm)
+static int create_ipsec_manip(struct dpa_ipsec_sa *sa,
+			      struct dpa_cls_tbl_header_manip **hm)
 {
-	t_FmPcdManipParams	pcd_manip_params;
-
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	t_FmPcdManipParams pcd_manip_params;
+	struct dpa_ipsec *dpa_ipsec;
 
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL sa handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!hm);
 
-	if (!hm) {
-		xx_pr_err("Invalid argument: NULL manip holder\n");
-		return -EFAULT;
-	}
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
 	memset(&pcd_manip_params, 0, sizeof(struct t_FmPcdManipParams));
 	pcd_manip_params.type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD;
@@ -1205,20 +1066,12 @@ static int create_ipsec_manip(struct dpa_ipsec *dpa_ipsec,
 }
 
 static int destroy_manip(struct dpa_ipsec *dpa_ipsec,
-			      struct dpa_cls_tbl_header_manip *hm)
+			 struct dpa_cls_tbl_header_manip *hm)
 {
 	t_Error fmd_err;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!hm) {
-		xx_pr_err("Invalid argument: NULL header manip handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!hm);
 
 	fmd_err = FM_PCD_ManipNodeDelete((t_Handle)hm);
 	if (fmd_err != E_OK) {
@@ -1238,27 +1091,19 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 	uint8_t key_len;
 	struct dpa_cls_tbl_action *action;
 	struct dpa_cls_tbl_key tbl_key;
-	int entry_id;
-	int err;
-
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	int entry_id, err;
 
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_entry);
 
 	if (sa->em_inpol_td < 0) {
 		xx_pr_err("Invalid exact match table for SA %d.\n", sa->id);
 		return -EINVAL;
 	}
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
-	policy_selectors = &(policy_entry->policy_selectors);
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
+	policy_selectors = &policy_entry->policy_selectors;
 
 	switch (op_type) {
 	case MNG_OP_ADD:
@@ -1314,26 +1159,19 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
 	uint8_t key_len, table_idx;
-	int table;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_header_manip *hm = NULL;
 	struct dpa_cls_tbl_entry_mod_params params;
-	int err;
+	int table, err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_entry);
 
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy handle\n");
-		return -EFAULT;
-	}
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
-	policy_selectors = &(policy_entry->policy_selectors);
+	policy_selectors = &policy_entry->policy_selectors;
 
 	table_idx = GET_POL_CC_NODE_INDX(policy_selectors->protocol);
 	table = dpa_ipsec->config.pre_sec_out_params.dpa_cls_td[table_idx];
@@ -1438,22 +1276,18 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 					enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	int table, entry_id;
+	int table, entry_id, offset, err = 0, tbl_key_size = 0, i;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
 	struct dpa_cls_tbl_entry_mod_params mod_params;
-	int offset, err = 0, tbl_key_size = 0, i;
 	struct dpa_cls_tbl_header_manip *hm = NULL;
 	uint8_t *key, *mask;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 	table = dpa_ipsec->config.pre_sec_in_params.dpa_cls_td;
 
 	switch (op_type) {
@@ -1521,7 +1355,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 		/* Configure support for variable IP header length */
 		if (sa->use_var_iphdr_len) {
-			err = create_ipsec_manip(dpa_ipsec, sa, &hm);
+			err = create_ipsec_manip(sa, &hm);
 			if (err < 0) {
 				xx_pr_err("Could not create Manip node !\n");
 				return -EAGAIN;
@@ -1619,11 +1453,8 @@ static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 	}
 
 	if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
-		/* AV's note: TODO - add BUG_ON in put_free_inbpol_tbl
-		 * and make this function void */
 		put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
 
-	/* AV's note: TODO - add BUG_ON in put_inbound_flowid */
 	err = put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
 	if (err < 0)
 		return err;
@@ -1637,16 +1468,8 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 {
 	int err = 0;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
-
-	if (!fqid) {
-		xx_pr_err("Invalid argument: NULL fqid holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!fqid);
 
 	if (dpa_ipsec->config.fqid_pool != NULL) {
 		err = qman_fqid_pool_alloc(dpa_ipsec->config.fqid_pool, fqid);
@@ -1670,7 +1493,6 @@ static void put_free_fqid(uint32_t fqid)
 {
 	struct dpa_ipsec *dpa_ipsec;
 
-	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err("There is no DPA IPSec instance initialized\n");
 		return;
@@ -1688,10 +1510,7 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 {
 	struct qm_mcr_queryfq_np queryfq_np;
 
-	if (!fq) {
-		xx_pr_err("Invalid argument: NULL fq handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!fq);
 
 	do {
 		qman_query_fq_np(fq, &queryfq_np);
@@ -1712,11 +1531,7 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 {
 	int err, flags, timeout = WAIT4_FQ_EMPTY_TIMEOUT;
 
-	/* sanity checks */
-	if (!sec_fq) {
-		xx_pr_err("Invalid argument: NULL fq handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sec_fq);
 
 	/* Check if already removed, and return success if so. */
 	if (qman_fq_fqid(sec_fq) == 0)
@@ -1753,15 +1568,11 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 {
 	int err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
 
 	err = remove_sa_sec_fq(sa->to_sec_fq);
-		if (err < 0)
-			return err;
+	if (err < 0)
+		return err;
 
 	if (sa_is_single(sa) && qman_fq_fqid(sa->from_sec_fq)) {
 		err = remove_sa_sec_fq(sa->from_sec_fq);
@@ -1782,11 +1593,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 	uint32_t flags;
 	int err = 0;
 
-	/* sanity checks */
-	if (!fq) {
-		xx_pr_err("Invalid argument: NULL fq handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!fq);
 
 	memset(fq, 0, sizeof(struct qman_fq));
 
@@ -1869,17 +1676,10 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	uint32_t fqid_from_sec = 0, fqid_to_sec = 0;
 	int err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
 	err = create_sec_descriptor(sa);
 	if (err < 0) {
@@ -1983,16 +1783,8 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	enum dpa_ipsec_ip_addr_type ip_addr_type;
 	int err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!sa_params) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!sa_params);
 
 	sa->sa_dir = DPA_IPSEC_OUTBOUND;
 	sa->sa_bpid = sa_params->sa_bpid;
@@ -2122,18 +1914,11 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec *dpa_ipsec;
 	int err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!sa_params) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!sa_params);
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
 	/* reserve a FlowID for this SA only if we are not rekeying */
 	if (!rekeying) {
@@ -2273,21 +2058,9 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 {
 	struct dpa_ipsec_policy_entry *pol_entry;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_params) {
-		xx_pr_err("Invalid argument: NULL policy params handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy entry holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_params);
+	BUG_ON(!policy_entry);
 
 	pol_entry = xx_zalloc(sizeof(struct dpa_ipsec_policy_entry));
 	if (!pol_entry) {
@@ -2312,21 +2085,9 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 	struct dpa_ipsec_policy_entry *pol_entry, *tmp_policy_entry;
 	struct dpa_ipsec_policy_selectors pol_sel;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_params) {
-		xx_pr_err("Invalid argument: NULL policy params handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy entry holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_params);
+	BUG_ON(!policy_entry);
 
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err("Policy parameter list is empty\n");
@@ -2373,16 +2134,8 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	int pol_count = 0;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_params) {
-		xx_pr_err("Invalid argument: NULL policy params handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_params);
 
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err("Policy parameter list is empty\n");
@@ -2418,16 +2171,8 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 					     struct dpa_ipsec_policy_entry
 					     *policy_entry)
 {
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy params handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_entry);
 
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err("Policy parameter list is empty\n");
@@ -2445,16 +2190,8 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 {
 	int err;
 
-	/* sanity checks */
-	if (!sa) {
-		xx_pr_err("Invalid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
-
-	if (!policy_entry) {
-		xx_pr_err("Invalid argument: NULL policy entry handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+	BUG_ON(!policy_entry);
 
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		err = update_inbound_policy(sa, policy_entry, MNG_OP_REMOVE);
@@ -2462,6 +2199,7 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 			xx_pr_err("Could not remove the inbound policy\n");
 			return err;
 		}
+
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
 			xx_pr_err("Couldn't remove inbound policy from SA policy list\n");
@@ -2473,6 +2211,7 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 			xx_pr_err("Could not remove the outbound policy\n");
 			return err;
 		}
+
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
 			xx_pr_err("Could not remove outbound policy from SA policy list\n");
@@ -2489,7 +2228,6 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *sa = NULL;
 
-	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err("There is no dpa_ipsec component initialized\n");
 		return NULL;
@@ -2498,7 +2236,7 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	dpa_ipsec = gbl_dpa_ipsec;
 	sa_mng = &dpa_ipsec->sa_mng;
 
-	if ((sa_id < 0) || (sa_id > sa_mng->max_num_sa)) {
+	if (sa_id < 0 || sa_id > sa_mng->max_num_sa) {
 		xx_pr_err("Invalid SA id %d provided\n", sa_id);
 		return NULL;
 	}
@@ -2593,22 +2331,12 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 	uint32_t id;
 	int i;
 
-	/* sanity checks */
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
 
-	if (!new_sa) {
-		xx_pr_err("Invalid argument: NULL SA holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!new_sa);
 	*new_sa = NULL;
 
-	if (!sa_id) {
-		xx_pr_err("Invalid argument: NULL ID holder\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa_id);
 
 	/* Acquire DPA IPSec instance lock */
 	mutex_lock(&dpa_ipsec->lock);
@@ -2659,11 +2387,10 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	struct dpa_ipsec_sa_mng *sa_mng;
 	int err;
 
+	BUG_ON(!sa);
+
 	dpa_ipsec = sa->dpa_ipsec;
-	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
-		return -EFAULT;
-	}
+	BUG_ON(!dpa_ipsec);
 
 	if (sa->used_sa_index < 0) {
 		xx_pr_crit("Invalid used_sa_index for SA with id %d\n", sa->id);
@@ -2699,11 +2426,10 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 	int err_rb;
 	struct dpa_ipsec *dpa_ipsec;
 
-	if (!sa) {
-		xx_pr_err("Inavlid argument: NULL SA handle\n");
-		return -EFAULT;
-	}
+	BUG_ON(!sa);
+
 	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 	    (sa->inbound_hash_entry != -1)) {
@@ -3488,7 +3214,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err("There is no dpa_ipsec instance initialized\n");
-		return -EINVAL;
+		return -EPERM;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
@@ -3672,9 +3398,9 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 				mutex_unlock(&new_sa->lock);
 				mutex_unlock(&old_sa->lock);
 				return err;
+			}
 		}
 	}
-	}
 
 	/* Rekeying done ok. */
 	*new_sa_id = new_sa->id;
@@ -3840,7 +3566,7 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 			if (err == -ENOTRECOVERABLE)
 				return err;
 		}
-		}
+	}
 
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 	if (err < 0) {
@@ -3957,7 +3683,7 @@ void sa_rekeying_work_func(struct work_struct *work)
 			parent_sa->child_sa = NULL;
 			child_sa->parent_sa = NULL;
 			list_del(&child_sa->sa_rekeying_node);
-	}
+		}
 
 		/* Release the list lock so other threads may use it */
 		mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
@@ -4163,7 +3889,7 @@ int dpa_ipsec_sa_flush_policies(int sa_id)
 	if (ret == 0) {
 		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
-		}
+	}
 
 	ret = sa_flush_policies(sa);
 
-- 
1.7.5.4

