From 519b374442dfa612533511ccd5fd600cc053b5d6 Mon Sep 17 00:00:00 2001
From: Roy Pledge <roy.pledge@freescale.com>
Date: Wed, 6 Mar 2013 15:18:00 +0200
Subject: [PATCH 496/518] Fix issues with passing pointers to kernel space

[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |   10 ++++++----
 include/linux/fsl_usdpaa.h             |   11 ++++++-----
 2 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index c4cbcc7..a48efa7 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -889,7 +889,7 @@ out:
 		if (longret & ~PAGE_MASK)
 			ret = (int)longret;
 		else
-			i.ptr = (void *)longret;
+			i.ptr = longret;
 	}
 	if (!ret)
 		ret = copy_to_user(arg, &i, sizeof(i));
@@ -1020,9 +1020,10 @@ map_match:
 	return ret;
 }
 
-static int portal_mmap(struct file *fp, struct resource *res, void **ptr)
+static int portal_mmap(struct file *fp, struct resource *res, compat_uptr_t *ptr)
 {
 	unsigned long longret = 0;
+
 	down_write(&current->mm->mmap_sem);
 	do {
 		longret = do_mmap_pgoff(fp, 0, resource_size(res),
@@ -1032,11 +1033,12 @@ static int portal_mmap(struct file *fp, struct resource *res, void **ptr)
 	up_write(&current->mm->mmap_sem);
 	if (longret & ~PAGE_MASK)
 		return (int)longret;
-	*ptr = (void *)longret;
+
+	*ptr = ptr_to_compat((void*) longret);
 	return 0;
 }
 
-static void portal_munmap(struct resource *res, void *ptr)
+static void portal_munmap(struct resource *res, compat_uptr_t ptr)
 {
 	down_write(&current->mm->mmap_sem);
 	do_munmap(current->mm, (unsigned long)ptr, resource_size(res));
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index 6b3c0d4..b2d713a 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -15,6 +15,7 @@ extern "C" {
 #include <linux/uaccess.h>
 #include <linux/ioctl.h>
 #include <linux/fsl_qman.h> /* For "enum qm_channel" */
+#include <asm/compat.h>
 
 #ifdef CONFIG_FSL_USDPAA
 
@@ -90,7 +91,7 @@ struct usdpaa_ioctl_id_reserve {
 #define USDPAA_DMA_FLAG_RDONLY   0x08
 struct usdpaa_ioctl_dma_map {
 	/* Output parameters - virtual and physical addresses */
-	void *ptr;
+	compat_uptr_t ptr;
 	uint64_t phys_addr;
 	/* Input parameter, the length of the region to be created (or if
 	 * mapping an existing region, this must match it). Must be a power-of-4
@@ -140,13 +141,13 @@ struct usdpaa_ioctl_portal_map {
 	/* Return value if the map succeeds, this gives the mapped
 	 * cache-inhibited (cinh) and cache-enabled (cena) addresses. */
 	struct usdpaa_portal_map {
-		void *cinh;
-		void *cena;
+		compat_uptr_t cinh;
+		compat_uptr_t cena;
 	} addr;
 	/* Qman-specific return values */
 	uint16_t channel;
 	uint32_t pools;
-	int irq;
+	uint32_t irq;
 };
 
 
@@ -156,7 +157,7 @@ struct usdpaa_ioctl_portal_map {
 #define USDPAA_IOCTL_PORTAL_UNMAP \
 	_IOW(USDPAA_IOCTL_MAGIC, 0x08, struct usdpaa_portal_map)
 #define USDPAA_IOCTL_PORTAL_IRQ_MAP \
-	_IOW(USDPAA_IOCTL_MAGIC, 0x09, int)
+	_IOW(USDPAA_IOCTL_MAGIC, 0x09, uint32_t)
 
 /* ioctl to query the amount of DMA memory used in the system */
 struct usdpaa_ioctl_dma_used {
-- 
1.7.5.4

