From 67cb20f9b818373ecc6e3f7d5a7414471ef81f78 Mon Sep 17 00:00:00 2001
From: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
Date: Fri, 9 Nov 2012 19:36:48 +0000
Subject: [PATCH 402/518] offload_use_case: Update offload usecase to create
 manipulation descriptor for fragmentation

Fragmentation manip object was removed from ipsec API. Instead a fragmentation
descriptor (a header manip descriptor) is received from the user.

This patch changes the usecase to create a manip fragmentation descriptor
when a mtu value greater than 0 is received through gen netlink from
userspace. This descriptor is then transmitted to ipsec during policy
offloading.

Signed-off-by: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/common.h  |    1 +
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |    2 +-
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |   24 +++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |    9 +++++--
 4 files changed, 31 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/common.h b/drivers/staging/fsl_dpa_offload/usecases/common.h
index 1a2b80e..db436b8 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/common.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/common.h
@@ -71,5 +71,6 @@ extern int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
 extern int outb_post_tx_fqid;
 extern int outb_update_hmd;
 extern bool inb_pol_check;
+extern int manip_desc;
 
 #endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
index 1369698..19eeacd 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -99,6 +99,7 @@ struct ipsec_uparms {
 	__u32 udp_dport_ob_nat;
 	bool inb_pol_check;
 	u8 vlan_priority;
+	unsigned int mtu_pre_enc;
 };
 
 /* Inbound post IPSEC OH queue types*/
@@ -112,7 +113,6 @@ enum inb_queue_types {
 struct xfrm_km_uparms {
 	__u8 sa_bpid;
 	__u8 sa_wqid;
-	unsigned int mtu_pre_enc;
 	__u32 policy_act_fqid[INB_MAX_NUM_QUEUES];
 	__u32 pol_miss_fqid;
 };
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index 6463fbe..e0b74a9 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -139,6 +139,7 @@ int outb_pre_ipsec_nat_td;
 int outb_post_tx_fqid;
 int outb_update_hmd;
 bool inb_pol_check;
+int manip_desc;
 
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 {
@@ -151,7 +152,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	t_LnxWrpFmPortDev *ib_oh_post, *ob_oh_post;
 
 	outb_update_hmd = DPA_OFFLD_DESC_NONE;
-
+	manip_desc	= DPA_OFFLD_DESC_NONE;
 	memset(&ipsec_params, 0, sizeof(ipsec_params));
 	memset(&pcd_params, 0, sizeof(pcd_params));
 
@@ -186,6 +187,24 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
 	ipsec_params.ipf_bpid = params->ipf_bpid;
 	ipsec_params.qm_sec_ch = qm_channel_caam;
+	if (params->mtu_pre_enc > 0) {
+		struct dpa_cls_hm_update_params update_params;
+		memset(&update_params, 0,
+		       sizeof(struct dpa_cls_hm_update_params));
+		update_params.fm_pcd = fm_dev->h_PcdDev;
+		update_params.ip_frag_params.df_action =
+					DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY;
+		update_params.ip_frag_params.mtu = params->mtu_pre_enc;
+		update_params.ip_frag_params.scratch_bpid = params->ipf_bpid;
+		ret = dpa_classif_set_update_hm(&update_params,
+						DPA_OFFLD_DESC_NONE,
+						&manip_desc, true,  NULL);
+		if (ret < 0) {
+			pr_err("%s:%dCould not create fragmentation manip "
+				"handle %d\n", __func__, __LINE__, ret);
+			return ret;
+		}
+	}
 
 	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
 		/* INB/DL pre SEC classifier */
@@ -700,6 +719,9 @@ int cleanup_ipsec_offload(int dpa_ipsec_id)
 	if (hmd_fwd != DPA_OFFLD_DESC_NONE)
 		dpa_classif_free_hm(hmd_fwd);
 
+	if (manip_desc != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(manip_desc);
+
 	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
 		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
 				dpa_cls_td[i]);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 332881a..4542d0d 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -589,10 +589,13 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 
 	memset(pol_params, 0, sizeof(*pol_params));
 	if (dir == XFRM_POLICY_OUT) {
-		pol_params->dir_params.type = DPA_IPSEC_POL_DIR_PARAMS_FRAG;
-		pol_params->dir_params.out_frag.mtu =
-					(uint16_t)usr_params.mtu_pre_enc;
+		if (manip_desc != DPA_OFFLD_DESC_NONE) {
+			pol_params->dir_params.type =
+					DPA_IPSEC_POL_DIR_PARAMS_MANIP;
+			pol_params->dir_params.manip_desc = manip_desc;
+		}
 	}
+
 	if (sel->family == AF_INET) {
 		pol_params->src_addr.version = DPA_IPSEC_ADDR_T_IPv4;
 		pol_params->src_addr.addr.ipv4.word = sel->saddr.a4;
-- 
1.7.5.4

