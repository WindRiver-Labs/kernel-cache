From d2c6d0b1ba2396563e32ae1e6ebd4f45d80bc7ea Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Thu, 25 Oct 2012 23:12:56 +0000
Subject: [PATCH 333/518] dpa_stats: Changed asynchronous request
 implementation

Changed the asynchronous request implementation
so that a work_struct is used every time a
request is received.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  112 +++++++++------------------
 drivers/staging/fsl_dpa_offload/dpa_stats.h |    6 +-
 2 files changed, 38 insertions(+), 80 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 6e67e88..df4bc1b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -54,6 +54,8 @@ struct dpa_stats *gbl_dpa_stats;
 static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb);
 
+static void async_req_work_func(struct work_struct *work);
+
 /* check that the provided params are valid */
 static int check_dpa_stats_params(const struct dpa_stats_params *params)
 {
@@ -354,6 +356,15 @@ static int init_reqs_cb(struct dpa_stats *dpa_stats)
 {
 	int i;
 
+	/* Create work queue to defer work when asynchronous
+	 * counters requests are received  */
+	dpa_stats->async_req_workqueue = alloc_workqueue(
+			"async_req_workqueue", WQ_UNBOUND | WQ_MEM_RECLAIM, 3);
+	if (!dpa_stats->async_req_workqueue) {
+		pr_err("Creating async request work queue failed\n");
+		return -ENOSPC;
+	}
+
 	/* Create circular queue that holds free counter request IDs */
 	dpa_stats->req_id_cq = cq_new(
 			DPA_STATS_MAX_NUM_OF_REQUESTS, sizeof(int));
@@ -397,6 +408,10 @@ static int init_reqs_cb(struct dpa_stats *dpa_stats)
 			pr_err("No more memory for array of counter ids\n");
 			return -ENOMEM;
 		}
+
+		/* Initialize work to be done for each request */
+		INIT_WORK(&dpa_stats->reqs_cb[i].async_req_work,
+						async_req_work_func);
 	}
 
 	return 0;
@@ -423,6 +438,8 @@ static int free_reqs_cb(struct dpa_stats *dpa_stats)
 				return err;
 			}
 
+			flush_work(&req_cb->async_req_work);
+
 			/* Release the array of counter ids */
 			kfree(req_cb->config.cnts_ids);
 			req_cb->config.cnts_ids = NULL;
@@ -464,8 +481,6 @@ static void free_resources(void)
 	/* free requests control blocks related stuff */
 	free_reqs_cb(dpa_stats);
 
-	flush_work(&dpa_stats->req_async_work);
-
 	/* destroy asynchronous requests workqueue */
 	if (dpa_stats->async_req_workqueue) {
 		destroy_workqueue(dpa_stats->async_req_workqueue);
@@ -2255,67 +2270,33 @@ static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
-void async_req_work_func(struct work_struct *work)
+static void async_req_work_func(struct work_struct *work)
 {
+	struct dpa_stats_req_cb *req_cb = NULL;
 	struct dpa_stats *dpa_stats = NULL;
-	struct dpa_stats_req_cb *req_cb = NULL, *pos = NULL, *new_rq_cb = NULL;
-	struct list_head *head;
 	int err = 0;
 
-	dpa_stats = container_of((struct work_struct *)work,
-			      struct dpa_stats, req_async_work);
-
-	/* Acquire protective lock for the asynchronous request list */
-	mutex_lock(&dpa_stats->async_req_hlist_lock);
-	head = &dpa_stats->async_req_hlist;
-	pos = container_of(head, struct dpa_stats_req_cb, async_req_node);
-
-	if (pos->async_req_node.next != head) {
-		req_cb = list_entry(pos->async_req_node.next,
-				struct dpa_stats_req_cb,
-				async_req_node);
-	} else {
-		req_cb = NULL;
-	}
-
-	/* Release the list lock so other threads may use it */
-	mutex_unlock(&dpa_stats->async_req_hlist_lock);
-
-	while (req_cb) {
-
-		err = treat_cnts_request(dpa_stats, req_cb);
-		if (err < 0) {
-			pr_err("Failed to retrieve counter values\n");
-			req_cb->bytes_num = err;
-		}
-
-		/* Notify the application */
-		req_cb->request_done(0, req_cb->config.storage_area_offset,
-				req_cb->cnts_num, req_cb->bytes_num);
-
-		/* Acquire protective lock for the asynchronous request list */
-		mutex_lock(&dpa_stats->async_req_hlist_lock);
+	dpa_stats = gbl_dpa_stats;
 
-		if (req_cb->async_req_node.next != head) {
-			new_rq_cb = list_entry(req_cb->async_req_node.next,
-					struct dpa_stats_req_cb,
-					async_req_node);
-		} else {
-			new_rq_cb = NULL;
-		}
+	req_cb = container_of((struct work_struct *)work,
+			      struct dpa_stats_req_cb, async_req_work);
 
-		list_del(&req_cb->async_req_node);
+	BUG_ON(!req_cb);
 
-		/* Release the request control block */
-		err = put_req(dpa_stats, req_cb);
-		if (err < 0)
-			pr_err("Failed to release request control block\n");
+	err = treat_cnts_request(dpa_stats, req_cb);
+	if (err < 0) {
+		pr_err("Failed to retrieve counter values\n");
+		req_cb->bytes_num = err;
+	}
 
-		/* Release the list lock so other threads may use it */
-		mutex_unlock(&dpa_stats->async_req_hlist_lock);
+	/* Notify the application */
+	req_cb->request_done(0, req_cb->config.storage_area_offset,
+			req_cb->cnts_num, req_cb->bytes_num);
 
-		req_cb = new_rq_cb;
-	}
+	/* Release the request control block */
+	err = put_req(dpa_stats, req_cb);
+	if (err < 0)
+		pr_err("Failed to release request control block\n");
 
 	return;
 }
@@ -2386,22 +2367,6 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map IPSec counters  */
 	create_cnt_ipsec_stats(dpa_stats);
 
-	/* Initialize the asynchronous requests list and its protective lock */
-	INIT_LIST_HEAD(&dpa_stats->async_req_hlist);
-	mutex_init(&dpa_stats->async_req_hlist_lock);
-
-	/* Create a single thread work queue used to defer work when
-	 * asynchronous counters requests are received  */
-	dpa_stats->async_req_workqueue =
-		create_singlethread_workqueue("async_req_workqueue");
-	if (!dpa_stats->async_req_workqueue) {
-		pr_err("Creating async request work queue failed\n");
-		return -ENOSPC;
-	}
-
-	/* Initialize the work needed to be done in asynchronous request */
-	INIT_WORK(&dpa_stats->req_async_work, async_req_work_func);
-
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -2945,15 +2910,12 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 			pr_err("Failed to retrieve counter values\n");
 
 		err = put_req(dpa_stats, req_cb);
+
 		return err;
 	} else {
 		/* Call is asynchronous */
-		mutex_lock(&dpa_stats->async_req_hlist_lock);
-		list_add_tail(&req_cb->async_req_node,
-				&dpa_stats->async_req_hlist);
-		mutex_unlock(&dpa_stats->async_req_hlist_lock);
 		queue_work(dpa_stats->async_req_workqueue,
-				&dpa_stats->req_async_work);
+					&req_cb->async_req_work);
 	}
 
 	return 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index b741abe..b467000 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -62,13 +62,9 @@ struct dpa_stats {
 	int stats_sel[NUM_OF_CNT_TYPES][MAX_NUM_OF_STATS]; /* Array that stores
 					the mapping between counter selection
 					and statistics values */
-	struct work_struct req_async_work; /* Asynchronous request work */
 	struct workqueue_struct *async_req_workqueue; /* Single threaded work
 				queue used to defer the work to be done when
 				an asynchronous counters request is received */
-	struct list_head async_req_hlist;  /* Head list with asynchronous
-				 counters requests currently being processed */
-	struct mutex async_req_hlist_lock; /* Lock for async requests list */
 	struct mutex lock; /* Lock for this dpa_stats instance */
 	bool sched_cnt_ids[DPA_STATS_MAX_NUM_OF_COUNTERS]; /* Counters that are
 				scheduled for a retrieve operation */
@@ -77,6 +73,7 @@ struct dpa_stats {
 
 /* DPA Stats  request control block */
 struct dpa_stats_req_cb {
+	struct work_struct async_req_work; /* Asynchronous request work */
 	struct dpa_stats_cnt_request_params config;
 				/* Parameters provided to the request */
 	uint32_t req_id; /* Request id */
@@ -86,7 +83,6 @@ struct dpa_stats_req_cb {
 	uint32_t bytes_num; /* Number of bytes written by this request */
 	uint32_t cnts_num; /* Number of counters written by this request */
 	dpa_stats_request_cb request_done; /* Callback to notify upper layer */
-	struct list_head async_req_node; /* For linking async req list */
 };
 
 /* DPA Stats - statistics information */
-- 
1.7.5.4

