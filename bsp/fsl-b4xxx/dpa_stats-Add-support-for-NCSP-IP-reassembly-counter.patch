From 3ac60b2b56d5443e69b17a695d8d2cab6de9a8aa Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <aurelian.zanoschi@freescale.com>
Date: Tue, 16 Apr 2013 20:14:31 +0000
Subject: [PATCH 2/2] dpa_stats: Add support for NCSP IP reassembly counter

Added support for non consistent storage profile reassembly counter
for FMANv3 capable platforms. For non FMANv3 platforms the driver will
accept the stat selection, but will always return 0.

Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
[Grabbed from the branch, LINUX_IR5.3.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/dpaa-offload/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |   46 ++++++++++++++++--------
 include/linux/fsl_dpa_stats.h               |   53 +++++++++++++++------------
 2 files changed, 60 insertions(+), 39 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index ac63a0c..e79c39f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -734,62 +734,68 @@ static void create_cnt_reass_stats(struct dpa_stats *dpa_stats)
 	/* DPA_STATS_CNT_REASS_DMA_SEM */
 	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][5] =
 			(void *)&stats.dmaSemaphoreDepletion - (void *)&stats;
-
+#if (DPAA_VERSION >= 11)
+	/* DPA_STATS_CNT_REASS_NON_CONSISTENT_SP */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] =
+			(void *)&stats.nonConsistentSp - (void *)&stats;
+#else
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] = 0;
+#endif /* (DPAA_VERSION >= 11) */
 	/* DPA_STATS_CNT_REASS_IPv4_FRAMES */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][7] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = (void *)
 			&stats.specificHdrStatistics[0].successfullyReassembled
 			- (void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][9] = (void *)
 			&stats.specificHdrStatistics[0].validFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][9] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][10] = (void *)
 			&stats.specificHdrStatistics[0].processedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][10] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][11] = (void *)
 			&stats.specificHdrStatistics[0].malformedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][11] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][12] = (void *)
 			&stats.specificHdrStatistics[0].discardedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][12] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][13] = (void *)
 			&stats.specificHdrStatistics[0].autoLearnBusy -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][13] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][14] = (void *)
 			&stats.specificHdrStatistics[0].moreThan16Fragments -
 			(void *)&stats;
 
 	/* DPA_STATS_CNT_REASS_IPv6_FRAMES */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][15] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][16] = (void *)
 			&stats.specificHdrStatistics[1].successfullyReassembled
 			- (void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][16] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][17] = (void *)
 			&stats.specificHdrStatistics[1].validFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][17] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][18] = (void *)
 			&stats.specificHdrStatistics[1].processedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][18] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][19] = (void *)
 			&stats.specificHdrStatistics[1].malformedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][19] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][20] = (void *)
 			&stats.specificHdrStatistics[1].discardedFragments -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][20] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][21] = (void *)
 			&stats.specificHdrStatistics[1].autoLearnBusy -
 			(void *)&stats;
 	/* DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][21] = (void *)
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][22] = (void *)
 			&stats.specificHdrStatistics[1].moreThan16Fragments -
 			(void *)&stats;
 }
@@ -2054,6 +2060,16 @@ static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 	uint64_t stats_val;
 
 	for (j = 0; j < stats_info->stats_num; j++) {
+
+		if (!stats_info->stats_off[j]) {
+			/* Write the memory location */
+			memset(req_cb->request_area, 0, STATS_VAL_SIZE);
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE ;
+			continue;
+		}
+
 		/* Get statistics value */
 		stats_val = (uint64_t)(*((uint32_t *)
 				(stats + stats_info->stats_off[j])));
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index e3087fa..2aaf5fa 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -220,19 +220,24 @@ struct dpa_stats_cnt_eth {
  */
 enum dpa_stats_cnt_reass_gen_sel {
 	/* Number of timeout occurrences */
-	DPA_STATS_CNT_REASS_TIMEOUT		= 0x00000001,
+	DPA_STATS_CNT_REASS_TIMEOUT			= 0x00000001,
 	/* Number of failed attempts to allocate a Reassembly Frame Descriptor*/
-	DPA_STATS_CNT_REASS_RFD_POOL_BUSY	= 0x00000002,
+	DPA_STATS_CNT_REASS_RFD_POOL_BUSY		= 0x00000002,
 	/* Number of internal buffer busy occurrences */
-	DPA_STATS_CNT_REASS_INT_BUFF_BUSY	= 0x00000004,
+	DPA_STATS_CNT_REASS_INT_BUFF_BUSY		= 0x00000004,
 	/* Number of external buffer busy occurrences */
-	DPA_STATS_CNT_REASS_EXT_BUFF_BUSY	= 0x00000008,
+	DPA_STATS_CNT_REASS_EXT_BUFF_BUSY		= 0x00000008,
 	/* Number of Scatter/Gather fragments */
-	DPA_STATS_CNT_REASS_SG_FRAGS		= 0x00000010,
+	DPA_STATS_CNT_REASS_SG_FRAGS			= 0x00000010,
 	/* Number of failed attempts to allocate a DMA semaphore */
-	DPA_STATS_CNT_REASS_DMA_SEM		= 0x00000020,
-	/* Select all counters from dpa_stats_cnt_reass_common_sel */
-	DPA_STATS_CNT_REASS_GEN_ALL		= 0x00000040
+	DPA_STATS_CNT_REASS_DMA_SEM			= 0x00000020,
+	/*
+	 * Number of Non Consistent Storage Profile occurrences for successfully
+	 * reassembled frames
+	 */
+	DPA_STATS_CNT_REASS_NON_CONSISTENT_SP		= 0x00000040,
+	/* Select all counters from dpa_stats_cnt_reass_gen_sel */
+	DPA_STATS_CNT_REASS_GEN_ALL			= 0x00000080
 };
 
 /*
@@ -241,24 +246,24 @@ enum dpa_stats_cnt_reass_gen_sel {
  */
 enum dpa_stats_cnt_reass_ipv4_sel {
 	/* Number of successfully reassembled IPv4 frames */
-	DPA_STATS_CNT_REASS_IPv4_FRAMES		= 0x00000080,
+	DPA_STATS_CNT_REASS_IPv4_FRAMES		= 0x00000100,
 	/* Number of valid IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID	 = 0x00000100,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID	 = 0x00000200,
 	/* Number of processed IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL	 = 0x00000200,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL	 = 0x00000400,
 	/* Number of malformed IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED = 0x00000400,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED = 0x00000800,
 	/* Number of discarded IPv4 fragments except Timeout condition */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED = 0x00000800,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED = 0x00001000,
 	/* Number of busy conditions due to Automatic Learning Hash access */
-	DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY	 = 0x00001000,
+	DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY	 = 0x00002000,
 	/*
 	 * Number of IPv4 fragments occurrences when the number of
 	 * fragments-per-frame exceeds 16
 	 */
-	DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS  = 0x00002000,
+	DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS  = 0x00004000,
 	/* Select all counters from dpa_stats_cnt_reass_ipv4_sel */
-	DPA_STATS_CNT_REASS_IPv4_ALL		 = 0x00004000
+	DPA_STATS_CNT_REASS_IPv4_ALL		 = 0x00008000
 };
 
 /*
@@ -267,24 +272,24 @@ enum dpa_stats_cnt_reass_ipv4_sel {
  */
 enum dpa_stats_cnt_reass_ipv6_sel {
 	/* Number of successfully reassembled IPv6 frames*/
-	DPA_STATS_CNT_REASS_IPv6_FRAMES		= 0x00008000,
+	DPA_STATS_CNT_REASS_IPv6_FRAMES		= 0x00010000,
 	/* Number of valid IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID	 = 0x00010000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID	 = 0x00020000,
 	/* Number of processed IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL	 = 0x00020000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL	 = 0x00040000,
 	/* Number of malformed IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED = 0x00040000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED = 0x00080000,
 	/* Number of discarded IPv6 fragments except Timeout condition */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED = 0x00080000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED = 0x00100000,
 	/* Number of busy conditions due to Automatic Learning Hash access */
-	DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY  = 0x00100000,
+	DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY  = 0x00200000,
 	/*
 	 * Number of IPv6 fragments occurrences when the number of
 	 * fragments-per-frame exceeds 16
 	 */
-	DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS  = 0x00200000,
+	DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS  = 0x00400000,
 	/* Select all counters from dpa_stats_cnt_reass_ipv6_sel */
-	DPA_STATS_CNT_REASS_IPv6_ALL		 = 0x00400000
+	DPA_STATS_CNT_REASS_IPv6_ALL		 = 0x00800000
 };
 
 /* DPA Stats IP Reassembly counter parameters */
-- 
1.7.5.4

