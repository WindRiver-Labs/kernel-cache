From 2782c794c9ed0f1f62f4b43f257ecf48c6b95d97 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Sat, 26 Jan 2013 01:46:16 +0200
Subject: [PATCH 041/518] dpaa_eth: Add overhead accounting control to CGRs

QMan can account for a fixed overhead when comparing the current byte
counts against the CGR notification threshold. We can use it to better
memory management in those cases when the fixed overhead from skb shells
and the netdev's needed_headroom is significant compared to the outgoing
frame size.
Unfortunately, with the current hardware the maximum value of
the overhead accounting limit (OAL) is 127, which is not enough for our
needs; but even so, it is better than no OAL at all.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   16 +++++++++++++++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h |    7 +++++++
 2 files changed, 22 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index ca6a704..2730e7f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -617,10 +617,24 @@ _dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
 		initfq.fqd.dest.wq = dpa_fq->wq;
 
 		/* Put all egress queues in a congestion group of their own */
-		initfq.we_mask |= QM_INITFQ_WE_CGID;
 		if (dpa_fq->fq_type == FQ_TYPE_TX) {
+			initfq.we_mask |= QM_INITFQ_WE_CGID;
 			initfq.fqd.fq_ctrl |= QM_FQCTRL_CGE;
 			initfq.fqd.cgid = priv->cgr_data.cgr.cgrid;
+			/*
+			 * Set a fixed overhead accounting, in an attempt to
+			 * reduce the impact of fixed-size skb shells and the
+			 * driver's needed headroom on system memory. This is
+			 * especially the case when the egress traffic is
+			 * composed of small datagrams.
+			 * Unfortunately, QMan's OAL value is capped to an
+			 * insufficient value, but even that is better than
+			 * no overhead accounting at all.
+			 */
+			initfq.we_mask |= QM_INITFQ_WE_OAC;
+			initfq.fqd.oac_init.oac = QM_OAC_CG;
+			initfq.fqd.oac_init.oal = min(sizeof(struct sk_buff) +
+				DPA_BP_HEAD, (size_t)FSL_QMAN_MAX_OAL);
 
 			/* Configure per-cpu Tx confirmation queue */
 			confq = _dpa_get_tx_conf_queue(priv, &dpa_fq->fq_base);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index f60626a..c1917b3 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -174,6 +174,13 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 #endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
 
 /*
+ * Largest value that the FQD's OAL field can hold.
+ * This is DPAA-1.x specific.
+ * TODO: This rather belongs in fsl_qman.h
+ */
+#define FSL_QMAN_MAX_OAL	127
+
+/*
  * Values for the L3R field of the FM Parse Results
  */
 /* L3 Type field: First IP Present IPv4 */
-- 
1.7.5.4

