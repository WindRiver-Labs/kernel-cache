From bd9d7a764d98ad332408fdcbf9957565c38b547b Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Nov 2012 19:06:22 +0000
Subject: [PATCH 381/518] dpa_classifier: Replace boolean "valid" indication
 for index management entry w/ flags

The data structure which is used for table entry index management
(dpa_cls_tbl_entry) had a boolean attribute which was indicating whether
the entry was valid or not. This was replaced with an integer "flags"
attribute which can hold more states or properties (32 boolean states) of
the index management entry for future use. The VALID state is now indicated
by a single bit from these flags:

#define DPA_CLS_TBL_ENTRY_VALID 0x1

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   22 +++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |    8 ++++++--
 2 files changed, 17 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 52574a7..713a351 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -948,7 +948,7 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
 		return -EINVAL;
 	}
-	if (!ptable->entry[entry_id].valid) {
+	if (!(ptable->entry[entry_id].flags & DPA_CLS_TBL_ENTRY_VALID)) {
 		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
 			__FILE__, __func__, __LINE__, entry_id);
 		return -EINVAL;
@@ -1404,7 +1404,7 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
 		return -EINVAL;
 	}
-	if (!ptable->entry[entry_id].valid) {
+	if (!(ptable->entry[entry_id].flags & DPA_CLS_TBL_ENTRY_VALID)) {
 		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
 			__FILE__, __func__, __LINE__, entry_id);
 		return -EINVAL;
@@ -1451,7 +1451,7 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 		list_del(&ptable->entry[entry_id].list_node);
 	}
 
-	ptable->entry[entry_id].valid = 0;
+	ptable->entry[entry_id].flags &= (~DPA_CLS_TBL_ENTRY_VALID);
 	dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 
 	int_cc_node->used--;
@@ -1609,7 +1609,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
 		return -EINVAL;
 	}
-	if (!ptable->entry[entry_id].valid) {
+	if (!(ptable->entry[entry_id].flags & DPA_CLS_TBL_ENTRY_VALID)) {
 		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
 			__FILE__, __func__, __LINE__, entry_id);
 		return -EINVAL;
@@ -1760,7 +1760,7 @@ static int flush_table(struct dpa_cls_table *ptable)
 			}
 
 			int_cc_node->used--;
-			index_entry->valid = 0;
+			index_entry->flags &= (~DPA_CLS_TBL_ENTRY_VALID);
 			tmp		= list_current;
 			list_current	= list_current->prev;
 			list_del(tmp);
@@ -1912,7 +1912,7 @@ static int table_get_entry_stats_by_ref(struct dpa_cls_table	*ptable,
 			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
 		return -EINVAL;
 	}
-	if (!ptable->entry[entry_id].valid) {
+	if (!(ptable->entry[entry_id].flags & DPA_CLS_TBL_ENTRY_VALID)) {
 		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
 			__FILE__, __func__, __LINE__, entry_id);
 		return -EINVAL;
@@ -2057,7 +2057,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 		/* Clean up and prepare the index entry */
 		memset(&cls_table->entry[i], 0,
 			sizeof(struct dpa_cls_tbl_entry));
-		cls_table->entry[i].valid	= 1;
+		cls_table->entry[i].flags	|= DPA_CLS_TBL_ENTRY_VALID;
 		cls_table->entry[i].entry_index	= i;
 	}
 
@@ -2485,7 +2485,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	/* Find an empty index management entry */
 	for (k = 0; k < cls_table->entries_cnt; k++)
-		if (!cls_table->entry[k].valid)
+		if (!(cls_table->entry[k].flags & DPA_CLS_TBL_ENTRY_VALID))
 			break;
 
 	BUG_ON(k == cls_table->entries_cnt);
@@ -2558,7 +2558,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	/* Add the index entry to the index management list */
 	list_add_tail(&cls_table->entry[k].list_node, list_current);
 
-	cls_table->entry[k].valid = 1;
+	cls_table->entry[k].flags |= DPA_CLS_TBL_ENTRY_VALID;
 
 	/* Increment all entry indexes in the current cc node starting from
 	 * [current] on */
@@ -2729,7 +2729,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 	/* Find an empty index entry */
 	for (j = 0; j < cls_table->entries_cnt; j++)
-		if (!cls_table->entry[j].valid)
+		if (!(cls_table->entry[j].flags & DPA_CLS_TBL_ENTRY_VALID))
 			break;
 
 	BUG_ON(j == cls_table->entries_cnt);
@@ -2737,7 +2737,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	/* Clean up and prepare the index entry */
 	memset(&cls_table->entry[j], 0,
 		sizeof(struct dpa_cls_tbl_entry));
-	cls_table->entry[j].valid = 1;
+	cls_table->entry[j].flags |= DPA_CLS_TBL_ENTRY_VALID;
 	cls_table->entry[j].int_cc_node_index = (unsigned int)hash_set_index;
 	cls_table->entry[j].entry_index =
 			(uint8_t)cls_table->int_cc_node[hash_set_index].used;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 8829f0e..d99c45d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -59,6 +59,10 @@
 
 #define DPA_CLS_HM_MAX_NODES_PER_OP				3
 
+/* Available flags for an index management entry: */
+
+/* Indication that the entry is valid */
+#define DPA_CLS_TBL_ENTRY_VALID					0x1
 
 #define unused(x)						(x = x)
 
@@ -66,8 +70,8 @@
 /* Index management entry */
 struct dpa_cls_tbl_entry {
 
-	/* Nonzero if this entry is valid */
-	int				valid;
+	/* Entry flags */
+	unsigned			flags;
 
 	/* Internal Cc node index where this entry resides */
 	unsigned int			int_cc_node_index;
-- 
1.7.5.4

