From 754de72ee14b5a9fa5edab3baedf503b8992c8a0 Mon Sep 17 00:00:00 2001
From: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
Date: Mon, 26 Mar 2012 12:47:09 +0000
Subject: [PATCH 136/518] Add GENL commands for XFRM policy/state associations
 required by USDPAA offload_demo application.

C_GET_OFFLD_DATA_FROMSA - receives SA information from user space
returns a list of policies that selects the SA and auth/crypt
algorithms used by the SA.
C_GET_OFFLD_DATA_FROMPOL - receives policy information from user space
returns the SA that this policy selects and auth/crypt algorithms
used by the SA.

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/Makefile  |    3 +-
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |  415 ++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/usecases/main.c    |    9 +
 drivers/staging/fsl_dpa_offload/usecases/utils.h   |    4 +
 4 files changed, 430 insertions(+), 1 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c

diff --git a/drivers/staging/fsl_dpa_offload/usecases/Makefile b/drivers/staging/fsl_dpa_offload/usecases/Makefile
index def7c9d..0b098db 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/Makefile
+++ b/drivers/staging/fsl_dpa_offload/usecases/Makefile
@@ -15,4 +15,5 @@ fsl_ipacc_usecase-objs += 	main.o \
 				fmc_config_ipsec.o \
 				dip_init.o \
 				xfrm_km.o \
-				xfrm_utils.o
+				xfrm_utils.o \
+				genl_ctl.o
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
new file mode 100644
index 0000000..8b255b6
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -0,0 +1,415 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <net/genetlink.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <net/xfrm.h>
+
+#include "utils.h"
+
+/* Attributes
+ */
+enum genl_attr {
+	A_UNSPEC,
+	A_SA_INFO,
+	A_POL_INFO,
+	_A_MAX,
+};
+#define A_MAX (_A_MAX - 1)
+
+#define VERSION_NR 1
+
+/* family definition */
+static struct genl_family dpa_ipacc_gnl_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "DPA_IPACC",
+	.version = VERSION_NR,
+	.maxattr = A_MAX,
+};
+
+/* Commands
+ */
+enum genl_cmd {
+	C_UNSPEC,
+	C_GET_OFFLD_DATA_FROMSA,
+	C_GET_OFFLD_DATA_FROMPOL,
+	_C_MAX,
+};
+#define C_MAX (_C_MAX - 1)
+
+/* XFRM_NEW_SA event user request
+ */
+struct new_sa_req {
+	struct xfrm_usersa_info sa_info;
+};
+
+struct new_pol_req {
+	struct xfrm_userpolicy_info pol_info;
+};
+
+struct pol_walk_arg_fromsa {
+	struct xfrm_state *x;
+	struct sk_buff *skb;
+};
+
+struct pol_walk_arg_frompol {
+	struct xfrm_userpolicy_info *pol_info;
+	struct xfrm_policy *x;
+};
+/* Fills the reply to XFRM_NEW_SA user request with policy id information
+ for each matching policy. The reply contains one A_POL_INFO attribute for
+ each policy. Policy template is matched against the xfrm_state.
+*/
+static int policy_walk_func_fromsa(struct xfrm_policy *pol, int dir, int count,
+				   void *ptr)
+{
+	struct pol_walk_arg_fromsa *arg = (struct pol_walk_arg_fromsa *)ptr;
+	struct xfrm_state *x = arg->x;
+	struct sk_buff *skb = arg->skb;
+	struct xfrm_userpolicy_id pol_id;
+	int ret;
+
+	/* we support only one template per policy */
+	if (!((x->id.daddr.a4 == pol->xfrm_vec[0].id.daddr.a4) &&
+	      (x->props.saddr.a4 == pol->xfrm_vec[0].saddr.a4) &&
+	      (x->id.proto == pol->xfrm_vec[0].id.proto))) {
+		return 0;
+	}
+
+	if (dir == XFRM_POLICY_OUT || dir == XFRM_POLICY_IN) {
+		memset(&pol_id, 0, sizeof(pol_id));
+		pol_id.sel = pol->selector;
+		pol_id.dir = dir;
+		pol_id.index = pol->index;
+		ret = nla_put(skb, XFRMA_POLICY, sizeof(pol_id), &pol_id);
+		if (ret) {
+			pr_err("%s(%d) error constructing policy reply\n",
+			       __func__, __LINE__);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/* Returns xfrm_policy structure needed for state lookup
+ */
+static int policy_walk_func_frompol(struct xfrm_policy *pol, int dir, int count,
+				    void *ptr)
+{
+	struct pol_walk_arg_frompol *arg = (struct pol_walk_arg_frompol *)ptr;
+	struct xfrm_userpolicy_info *pol_info = arg->pol_info;
+
+	/* match xfrm_policy selector against user policy info */
+	if (pol_info->sel.saddr.a4 == pol->selector.saddr.a4 &&
+	    pol_info->sel.daddr.a4 == pol->selector.daddr.a4 &&
+	    pol_info->sel.proto == pol->selector.proto &&
+	    pol_info->sel.family == pol->selector.family) {
+		arg->x = pol;
+		return 0;
+	}
+	return 0;
+}
+
+/* Command handler for C_GET_OFFLD_DATA_FROMSA */
+int get_ipsec_offld_data_fromsa(struct sk_buff *skb_2, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct sk_buff *skb;
+	int rc = 0;
+	void *msg_head;
+	struct new_sa_req sa_req;
+	struct xfrm_state *x;
+	struct xfrm_policy_walk walk;
+	struct pol_walk_arg_fromsa arg;
+	struct xfrm_algo *ealg = NULL;
+	struct xfrm_algo_auth *aalg = NULL;
+
+	if (info == NULL)
+		goto out;
+	/* check user info */
+	na = info->attrs[A_SA_INFO];
+	if (na) {
+		if (!nla_data(na)) {
+			pr_err("%s(%d) : error while receiving user info\n",
+			       __func__, __LINE__);
+			return -1;
+		}
+		sa_req = *((typeof(&sa_req)) nla_data(na));
+	} else {
+		pr_err("%s(%d) : no A_SA_INFO (%d) attr in user info\n",
+		       __func__, __LINE__, A_SA_INFO);
+		return -1;
+	}
+
+	/* get xfrm_state from user info */
+	x = xfrm_state_lookup(&init_net, 0, &sa_req.sa_info.id.daddr,
+			      sa_req.sa_info.id.spi, sa_req.sa_info.id.proto,
+			      sa_req.sa_info.family);
+
+	/* allocate reply */
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (skb == NULL) {
+		rc = -ENOMEM;
+		return rc;
+	}
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_gnl_family,
+			       0, C_GET_OFFLD_DATA_FROMSA);
+	if (msg_head == NULL) {
+		rc = -ENOMEM;
+		return rc;
+	}
+
+	aalg = kzalloc(sizeof(*aalg) + x->aalg->alg_key_len / 8, GFP_ATOMIC);
+	BUG_ON(!aalg);
+	ealg = kzalloc(sizeof(*ealg) + x->ealg->alg_key_len / 8, GFP_ATOMIC);
+	BUG_ON(!ealg);
+
+	memcpy(aalg, x->aalg,
+	       sizeof(struct xfrm_algo_auth) + x->aalg->alg_key_len / 8);
+	rc = nla_put(skb, XFRMA_ALG_AUTH,
+		     sizeof(*aalg) + x->aalg->alg_key_len / 8, aalg);
+	if (rc < 0)
+		goto out;
+	memcpy(ealg, x->ealg,
+	       sizeof(struct xfrm_algo) + x->ealg->alg_key_len / 8);
+	rc = nla_put(skb, XFRMA_ALG_CRYPT,
+		     sizeof(*ealg) + x->ealg->alg_key_len / 8, ealg);
+	if (rc < 0)
+		goto out;
+
+	/* run policy walking and fill skb with policy information */
+	if (x) {
+		arg.x = x;
+		arg.skb = skb;
+		xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
+		xfrm_policy_walk(&init_net, &walk, policy_walk_func_fromsa,
+				 &arg);
+		xfrm_policy_walk_done(&walk);
+	}
+
+	/* send reply to user */
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+out:
+	kfree(aalg);
+	kfree(ealg);
+	return rc;
+}
+
+/* Command handler for C_GET_OFFLD_DATA_FROMPOL */
+int get_ipsec_offld_data_frompol(struct sk_buff *skb_2, struct genl_info *info)
+{
+	struct new_pol_req pol_req;
+	struct nlattr *na;
+	struct xfrm_state *state = NULL;
+	struct xfrm_usersa_info sa_info;
+	struct sk_buff *skb;
+	void *msg_head;
+	struct xfrm_policy_walk walk;
+	struct pol_walk_arg_frompol arg;
+	struct xfrm_algo *ealg = NULL;
+	struct xfrm_algo_auth *aalg = NULL;
+
+	int rc = 0;
+
+	if (info == NULL)
+		goto out;
+	/* check user info */
+	na = info->attrs[A_POL_INFO];
+	if (na) {
+		if (!nla_data(na)) {
+			pr_err("%s(%d) : error while receiving user info\n",
+			       __func__, __LINE__);
+			return -1;
+		}
+		pol_req = *((typeof(&pol_req)) nla_data(na));
+	} else {
+		pr_err("%s(%d) : no A_POL_INFO (%d) attr in user info\n",
+		       __func__, __LINE__, A_POL_INFO);
+	}
+
+	/* get xfrm policy for user policy info */
+	arg.pol_info = &pol_req.pol_info;
+	arg.x = NULL;
+	xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
+	xfrm_policy_walk(&init_net, &walk, policy_walk_func_frompol, &arg);
+	xfrm_policy_walk_done(&walk);
+
+	if (arg.x) {
+		/* state lookup on xfrm_policy tmpl */
+		state = xfrm_state_lookup_byaddr(&init_net, 0,
+						 &arg.x->xfrm_vec[0].id.daddr,
+						 &arg.x->xfrm_vec[0].saddr,
+						 arg.x->xfrm_vec[0].id.proto,
+						 pol_req.pol_info.sel.family);
+	}
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (skb == NULL) {
+		rc = -ENOMEM;
+		return rc;
+	}
+	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_gnl_family,
+			       0, C_GET_OFFLD_DATA_FROMPOL);
+	/* fill an A_SA_INFO attribute if a xfrm state is found */
+	if (state && (pol_req.pol_info.dir == XFRM_POLICY_IN ||
+		      pol_req.pol_info.dir == XFRM_POLICY_OUT)) {
+		aalg =
+		    kzalloc(sizeof(*aalg) + state->aalg->alg_key_len / 8,
+			    GFP_ATOMIC);
+		BUG_ON(!aalg);
+		ealg =
+		    kzalloc(sizeof(*ealg) + state->ealg->alg_key_len / 8,
+			    GFP_ATOMIC);
+		BUG_ON(!ealg);
+
+		memcpy(aalg, state->aalg,
+		       sizeof(struct xfrm_algo_auth) +
+		       state->aalg->alg_key_len / 8);
+		rc = nla_put(skb, XFRMA_ALG_AUTH,
+			     sizeof(*aalg) + state->aalg->alg_key_len / 8,
+			     aalg);
+		if (rc < 0)
+			goto out;
+		memcpy(ealg, state->ealg,
+		       sizeof(struct xfrm_algo) + state->ealg->alg_key_len / 8);
+		rc = nla_put(skb, XFRMA_ALG_CRYPT,
+			     sizeof(*ealg) + state->ealg->alg_key_len / 8,
+			     ealg);
+		if (rc < 0)
+			goto out;
+
+		memset(&sa_info, 0, sizeof(sa_info));
+		sa_info.saddr = state->props.saddr;
+		sa_info.id.daddr = state->id.daddr;
+		sa_info.id.spi = state->id.spi;
+		sa_info.id.proto = state->id.proto;
+		sa_info.family = state->props.family;
+		rc = nla_put(skb, XFRMA_SA, sizeof(sa_info), &sa_info);
+	}
+	genlmsg_end(skb, msg_head);
+	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
+out:
+	kfree(aalg);
+	kfree(ealg);
+	return rc;
+}
+
+/* C_GET_OFFLD_DATA_FROMSA command ops */
+struct genl_ops dpa_ipacc_gnl_ops_fromsa = {
+	.cmd = C_GET_OFFLD_DATA_FROMSA,
+	.flags = 0,
+	.policy = NULL,
+	.doit = get_ipsec_offld_data_fromsa,
+	.dumpit = NULL,
+};
+
+/* C_GET_OFFLD_DATA_FROMPOL command ops */
+struct genl_ops dpa_ipacc_gnl_ops_frompol = {
+	.cmd = C_GET_OFFLD_DATA_FROMPOL,
+	.flags = 0,
+	.policy = NULL,
+	.doit = get_ipsec_offld_data_frompol,
+	.dumpit = NULL,
+};
+
+int genl_ctl_init(void)
+{
+	int ret;
+	/*register new family */
+	ret = genl_register_family(&dpa_ipacc_gnl_family);
+	if (ret != 0) {
+		pr_err("%s(%d): register %s GENL family ops error %i\n",
+		       __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+		goto err;
+	}
+
+	/* register commands */
+	/*C_GET_OFFLD_DATA_FROMSA */
+	ret =
+	    genl_register_ops(&dpa_ipacc_gnl_family, &dpa_ipacc_gnl_ops_fromsa);
+	if (ret != 0) {
+		pr_err
+		("%s(%d): register %s C_GET_OFFLD_DATA_FROMSA, ret %i\n",
+		     __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+		goto err;
+	}
+	/*C_GET_OFFLD_DATA_FROMPOL */
+	ret =
+	    genl_register_ops(&dpa_ipacc_gnl_family,
+			      &dpa_ipacc_gnl_ops_frompol);
+	if (ret != 0) {
+		pr_err
+		("%s(%d): register %s C_GET_OFFLD_DATA_FROMPOL, ret %i\n",
+		     __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+		goto err;
+	}
+
+	return 0;
+err:
+	genl_unregister_family(&dpa_ipacc_gnl_family);
+	return -1;
+
+}
+
+void genl_ctl_exit(void)
+{
+	int ret;
+	/* unregister the commands */
+	/*C_GET_OFFLD_DATA_FROMPOL */
+	ret =
+	    genl_unregister_ops(&dpa_ipacc_gnl_family,
+				&dpa_ipacc_gnl_ops_frompol);
+	if (ret != 0) {
+		pr_err
+		("%s(%d): unregister %s C_GET_OFFLD_DATA_FROMPOL, ret %i\n",
+		     __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+		return;
+	}
+	/*C_GET_OFFLD_DATA_FROMSA */
+	ret =
+	    genl_unregister_ops(&dpa_ipacc_gnl_family,
+				&dpa_ipacc_gnl_ops_fromsa);
+	if (ret != 0) {
+		pr_err
+		("%s(%d): unregister %s C_GET_OFFLD_DATA_FROMSA, ret %i\n",
+		     __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+	}
+
+	/*unregister the family */
+	ret = genl_unregister_family(&dpa_ipacc_gnl_family);
+	if (ret != 0) {
+		pr_err("%s(%d): unregister %s GENL family error %i\n",
+		       __func__, __LINE__, dpa_ipacc_gnl_family.name, ret);
+	}
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
index e610f75..f81de47 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/main.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/main.c
@@ -198,6 +198,12 @@ int __init usecase_init(void)
 		xfrm_km_init();
 		pr_info("Registered for XFRM key notifications\n");
 	}
+	ret = genl_ctl_init();
+	if (ret < 0) {
+		pr_err("Failed to register DPA_IPACC genl family\n");
+		return 0;
+	}
+	pr_info("Registered DPA_IPACC genl family\n");
 
 	return 0;
 }
@@ -206,6 +212,9 @@ int __init usecase_init(void)
 void __exit usecase_exit(void)
 {
 	int i;
+
+	genl_ctl_exit();
+
 	if (xfrm_km)
 		xfrm_km_exit();
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/utils.h b/drivers/staging/fsl_dpa_offload/usecases/utils.h
index cca2731..7805a67 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/utils.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/utils.h
@@ -106,4 +106,8 @@ void dump_xfrm_template(struct xfrm_tmpl *tmpl);
 
 int get_offld_work_cpu(void);
 
+int genl_ctl_init(void);
+
+void genl_ctl_exit(void);
+
 #endif
-- 
1.7.5.4

