From 876b6c74016f3f45a00131a722ad6133a8d5ca22 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Wed, 8 Aug 2012 17:24:14 +0000
Subject: [PATCH 263/518] dpa_ipsec: Synchronize API with common header
 definitions

Update API header and implementation to use the structures defined
in the common fsl_dpa_offload.h header and thus eliminate
redefinition of the same structures in multiple component headers.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c       |   56 ++++++++++----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h       |   16 ++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |   10 ++--
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |    2 +-
 include/linux/fsl_dpa_ipsec.h                     |   58 +++-----------------
 5 files changed, 53 insertions(+), 89 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 976410c..7d3c9e8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -93,12 +93,12 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	pr_info(" sa_wqid = %d\n", sa->sa_wqid);
 	pr_info(" outbound_flowid = %d\n", sa->outbound_flowid);
 
-	pr_info("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type);
+	pr_info("dest_addr.version = %d\n", sa->dest_addr.version);
 	pr_info("dest_addr = %x.%x.%x.%x\n",
 		sa->dest_addr.ipv4.byte[0],
 		sa->dest_addr.ipv4.byte[1],
 		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]);
-	pr_info("src_addr.addr_type = %d\n", sa->src_addr.addr_type);
+	pr_info("src_addr.version = %d\n", sa->src_addr.version);
 	pr_info("src_addr = %x.%x.%x.%x\n",
 		sa->src_addr.ipv4.byte[0],
 		sa->src_addr.ipv4.byte[1],
@@ -137,15 +137,15 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
 		policy_selectors = &policy_entry->policy_selectors;
-		pr_info("policy_selectors src_addr.addr_type = %d\n",
-			policy_selectors->src_addr.addr_type);
+		pr_info("policy_selectors src_addr.version = %d\n",
+			policy_selectors->src_addr.version);
 		pr_info("policy_selectors src_addr = %x.%x.%x.%x\n",
 			policy_selectors->src_addr.ipv4.byte[0],
 			policy_selectors->src_addr.ipv4.byte[1],
 			policy_selectors->src_addr.ipv4.byte[2],
 			policy_selectors->src_addr.ipv4.byte[3]);
-		pr_info("\n policy_selectors dest_addr.addr_type = %d\n",
-			policy_selectors->dest_addr.addr_type);
+		pr_info("\n policy_selectors dest_addr.version = %d\n",
+			policy_selectors->dest_addr.version);
 		pr_info("policy_selectors dest_addr = %x.%x.%x.%x\n",
 			policy_selectors->dest_addr.ipv4.byte[0],
 			policy_selectors->dest_addr.ipv4.byte[1],
@@ -379,16 +379,16 @@ static void calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 		switch (key_fields & field_mask) {
 		case DPA_IPSEC_KEY_FIELD_SIP:
 			if (dpa_ipsec->config.post_sec_in_params.use_ipv6_pol)
-				*key_size += IPv6_ADDR_SIZE_IN_BYTES;
+				*key_size += DPA_OFFLD_IPv6_ADDR_LEN_BYTES;
 			else
-				*key_size += IPv4_ADDR_SIZE_IN_BYTES;
+				*key_size += DPA_OFFLD_IPv4_ADDR_LEN_BYTES;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DIP:
 			if (dpa_ipsec->config.post_sec_in_params.use_ipv6_pol)
-				*key_size += IPv6_ADDR_SIZE_IN_BYTES;
+				*key_size += DPA_OFFLD_IPv6_ADDR_LEN_BYTES;
 			else
-				*key_size += IPv4_ADDR_SIZE_IN_BYTES;
+				*key_size += DPA_OFFLD_IPv4_ADDR_LEN_BYTES;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_PROTO:
@@ -1972,7 +1972,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 				    struct dpa_ipsec_sa_params *sa_params)
 {
 	struct iphdr *outer_ip_hdr;
-	enum dpa_ipsec_ip_addr_type ip_addr_type;
+	unsigned int ip_addr_type;
 	int err;
 
 	BUG_ON(!sa);
@@ -1981,7 +1981,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->sa_dir = DPA_IPSEC_OUTBOUND;
 	sa->sa_bpid = sa_params->sa_bpid;
 	sa->sa_wqid = sa_params->sa_wqid;
-	ip_addr_type = sa_params->sa_out_params.addr_type;
+	ip_addr_type = sa_params->sa_out_params.ip_ver;
 
 	err = set_cipher_auth_alg(sa_params->crypto_params.alg_suite,
 				  &sa->cipher_data.cipher_type,
@@ -2169,7 +2169,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ESN;
 	}
 
-	if (sa_params->sa_in_params.dest_addr.addr_type ==
+	if (sa_params->sa_in_params.dest_addr.version ==
 							DPA_IPSEC_ADDR_T_IPv6)
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_IPVSN;
 	else
@@ -2192,7 +2192,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	/* Updated the offset to the point in frame were the encrypted
 	 * stuff starts.*/
-	if (sa_params->sa_in_params.dest_addr.addr_type ==
+	if (sa_params->sa_in_params.dest_addr.version ==
 							DPA_IPSEC_ADDR_T_IPv6)
 		sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
 					(uint16_t) sizeof(struct ipv6hdr);
@@ -2220,11 +2220,11 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	memcpy(&sa->src_addr,
 	       &sa_params->sa_in_params.src_addr,
-	       sizeof(struct dpa_ipsec_ip_address));
+	       sizeof(struct dpa_offload_ip_address));
 
 	memcpy(&sa->dest_addr,
 	       &sa_params->sa_in_params.dest_addr,
-	       sizeof(struct dpa_ipsec_ip_address));
+	       sizeof(struct dpa_offload_ip_address));
 
 	sa->policy_miss_action = sa_params->sa_in_params.policy_miss_action;
 	sa->l2_hdr_size = sa_params->l2_hdr_size;
@@ -2244,7 +2244,7 @@ static int check_policy_params(struct dpa_ipsec_sa *sa,
 	BUG_ON(!pol_params);
 
 	/* check if both IP address are of the same type */
-	if (pol_params->src_addr.addr_type != pol_params->dest_addr.addr_type) {
+	if (pol_params->src_addr.version != pol_params->dest_addr.version) {
 		pr_err("Src and dest IP address types must be the same!\n");
 		return -EINVAL;
 	}
@@ -2269,7 +2269,7 @@ static int check_policy_params(struct dpa_ipsec_sa *sa,
 	/* check if DF bit was set and an IPv6 policy is being offloaded */
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND &&
 	    sa->sec_desc->pdb_en.hmo_rsvd == PDBHMO_ESP_DFBIT &&
-	    pol_params->src_addr.addr_type == DPA_IPSEC_ADDR_T_IPv6) {
+	    pol_params->src_addr.version == DPA_IPSEC_ADDR_T_IPv6) {
 		pr_err("Can't add IPv6 policy to IPv4 SA w/ DF bit copy set\n");
 		return -EINVAL;
 	}
@@ -2513,21 +2513,21 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 		}
 
 		if (sa_params->sa_out_params.outer_udp_header &&
-			sa_params->sa_out_params.addr_type ==
+			sa_params->sa_out_params.ip_ver ==
 				DPA_IPSEC_ADDR_T_IPv6) {
 			pr_err("NAT-T is not supported for IPV6 SAs\n");
 			return -EINVAL;
 		}
 	} else {
 		/* Inbound SA */
-		if (sa_params->sa_in_params.src_addr.addr_type !=
-		    sa_params->sa_in_params.dest_addr.addr_type) {
+		if (sa_params->sa_in_params.src_addr.version !=
+		    sa_params->sa_in_params.dest_addr.version) {
 			pr_err("Source and destination IP address must be of same type\n");
 			return -EINVAL;
 		}
 
 		if (sa_params->sa_in_params.use_udp_encap &&
-			sa_params->sa_in_params.src_addr.addr_type ==
+			sa_params->sa_in_params.src_addr.version ==
 				DPA_IPSEC_ADDR_T_IPv6) {
 			pr_err("NAT-T is not supported for IPV6 SAs\n");
 			return -EINVAL;
@@ -2570,7 +2570,7 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 	}
 
 	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa; i++)
-		if (dpa_ipsec->used_sa_ids[i] == DPA_IPSEC_INVALID_SA_ID)
+		if (dpa_ipsec->used_sa_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID)
 			break;
 	if (i == dpa_ipsec->sa_mng.max_num_sa) {
 		pr_err("No more used SAs ID holders");
@@ -2631,7 +2631,7 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	}
 
 	/* Mark as free index in used SA IDs vector of this DPA IPSEC instance*/
-	dpa_ipsec->used_sa_ids[sa->used_sa_index] = DPA_IPSEC_INVALID_SA_ID;
+	dpa_ipsec->used_sa_ids[sa->used_sa_index] = DPA_OFFLD_INVALID_OBJECT_ID;
 	dpa_ipsec->num_used_sas--;
 	sa->used_sa_index = -1;
 
@@ -2789,7 +2789,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 		free_resources();
 		return -ENOMEM;
 	}
-	memset(dpa_ipsec->used_sa_ids, DPA_IPSEC_INVALID_SA_ID,
+	memset(dpa_ipsec->used_sa_ids, DPA_OFFLD_INVALID_OBJECT_ID,
 	       max_num_sa * sizeof(uint32_t));
 	dpa_ipsec->num_used_sas = 0;
 
@@ -2842,7 +2842,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
-	*sa_id = DPA_IPSEC_INVALID_SA_ID;
+	*sa_id = DPA_OFFLD_INVALID_OBJECT_ID;
 
 	err = check_sa_params(sa_params);
 	if (err < 0)
@@ -3514,7 +3514,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
-	*new_sa_id = DPA_IPSEC_INVALID_SA_ID;
+	*new_sa_id = DPA_OFFLD_INVALID_OBJECT_ID;
 
 	err = check_sa_params(sa_params);
 	if (err < 0)
@@ -4111,7 +4111,7 @@ int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 		sa_id = dpa_ipsec->used_sa_ids[i];
 		mutex_unlock(&dpa_ipsec->lock);
 
-		if (sa_id != DPA_IPSEC_INVALID_SA_ID) {
+		if (sa_id != DPA_OFFLD_INVALID_OBJECT_ID) {
 			ret = dpa_ipsec_remove_sa(sa_id);
 			if (ret < 0)
 				err = -EAGAIN;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 6d04279..abe45cf 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -144,12 +144,16 @@
 	 (_proto == IPPROTO_SCTP) ? DPA_IPSEC_PROTO_SCTP_##_ip_ver : \
 	  DPA_IPSEC_PROTO_ANY_##_ip_ver)
 
-#define IP_ADDR_TYPE_IPV4(_ipAddr) (_ipAddr.addr_type == DPA_IPSEC_ADDR_T_IPv4)
+#define DPA_IPSEC_ADDR_T_IPv4	4
+#define DPA_IPSEC_ADDR_T_IPv6	6
+
+#define IP_ADDR_TYPE_IPV4(_ipAddr) (_ipAddr.version == DPA_IPSEC_ADDR_T_IPv4)
 #define IP_ADDR(_ipAddr) \
-	(IP_ADDR_TYPE_IPV4(_ipAddr) ? (_ipAddr.ipv4.byte) : (_ipAddr.ipv6.byte))
+	(IP_ADDR_TYPE_IPV4(_ipAddr) ? \
+	(_ipAddr.addr.ipv4.byte) : (_ipAddr.addr.ipv6.byte))
 #define IP_ADDR_LEN(_ipAddr) \
 	(IP_ADDR_TYPE_IPV4(_ipAddr) ? \
-	(IPv4_ADDR_SIZE_IN_BYTES) : (IPv6_ADDR_SIZE_IN_BYTES))
+	(DPA_OFFLD_IPv4_ADDR_LEN_BYTES) : (DPA_OFFLD_IPv6_ADDR_LEN_BYTES))
 
 #define SET_BYTE_VAL_IN_ARRAY(_key, _off, _val) (_key[_off] = _val)
 #define SET_IP_PROTO_MASK(_mask, _off, _is_masked) \
@@ -256,8 +260,8 @@ struct dpa_ipsec_sa {
 	uint8_t sa_bpid;  /* Buffer pool id used by SEC for acquiring buffers,
 			     comes from user. Default buffer pool 63	      */
 	uint32_t spi;	/* IPsec Security parameter index		      */
-	struct dpa_ipsec_ip_address src_addr;  /* Source IP address           */
-	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
+	struct dpa_offload_ip_address src_addr;  /* Source IP address	      */
+	struct dpa_offload_ip_address dest_addr; /* Destination IP address    */
 	uint16_t outbound_flowid; /* Value used to classify frames encrypted
 				 with this SA				      */
 	bool use_udp_encap;   /* NAT-T is activated for this SA.	      */
@@ -335,7 +339,7 @@ struct dpa_ipsec {
 	struct dpa_ipsec_params config;	/* Configuration parameters as
 					provided in dap_ipsec_config_and_init */
 	struct dpa_ipsec_sa_mng sa_mng;	/* Internal DPA IPsec SA manager      */
-	uint32_t *used_sa_ids;	/* Sa ids used by this dpa ipsec instance     */
+	int *used_sa_ids;	/* Sa ids used by this dpa ipsec instance     */
 	int num_used_sas;  /* The current number of sa's used by this instance*/
 	int sec_era; /* SEC ERA information */
 	struct mutex lock; /* Lock for this dpa_ipsec instance */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index 0412894..51bd226 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -89,7 +89,7 @@ struct ioc_compat_sa_crypto_params {
 
 struct ioc_compat_sa_out_params {
 	compat_uptr_t init_vector;
-	enum dpa_ipsec_ip_addr_type addr_type;
+	unsigned int ip_ver;
 	uint16_t ip_hdr_size;
 	compat_uptr_t outer_ip_header;
 	compat_uptr_t outer_udp_header;
@@ -99,8 +99,8 @@ struct ioc_compat_sa_out_params {
 struct ioc_compat_sa_in_params {
 	enum dpa_ipsec_arw arw;
 	int use_var_iphdr_len;
-	struct dpa_ipsec_ip_address src_addr;
-	struct dpa_ipsec_ip_address dest_addr;
+	struct dpa_offload_ip_address src_addr;
+	struct dpa_offload_ip_address dest_addr;
 	int use_udp_encap;
 	uint16_t src_port;
 	uint16_t dest_port;
@@ -149,9 +149,9 @@ struct ioc_compat_pol_dir_params {
 };
 
 struct ioc_compat_policy_params {
-	struct dpa_ipsec_ip_address src_addr;
+	struct dpa_offload_ip_address src_addr;
 	uint8_t src_prefix_len;
-	struct dpa_ipsec_ip_address dest_addr;
+	struct dpa_offload_ip_address dest_addr;
 	uint8_t dest_prefix_len;
 	uint8_t protocol;
 	bool masked_proto;
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 43fe02c..36d10b8 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -136,7 +136,7 @@ static void compat_copy_sa_out_params(struct dpa_ipsec_sa_out_params *prm,
 	if (compat == COMPAT_US_TO_K) {
 		prm->init_vector = (struct dpa_ipsec_init_vector *)
 					compat_ptr(compat_prm->init_vector);
-		prm->addr_type = compat_prm->addr_type;
+		prm->ip_ver = compat_prm->ip_ver;
 		prm->ip_hdr_size = compat_prm->ip_hdr_size;
 		prm->outer_ip_header = (void *)
 					compat_ptr(compat_prm->outer_ip_header);
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 592b5c9..785ac8e 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -39,43 +39,36 @@
 #include "fsl_dpa_classifier.h"
 
 /* General DPA-IPSec defines */
-#define IPv4_ADDR_SIZE_IN_BYTES		4
-#define IPv6_ADDR_SIZE_IN_BYTES		16
-#define IPv6_ADDR_SIZE_IN_WORDS		4
-#define IPv6_ADDR_SIZE_IN_LONG		2
-
 #define IP_PROTO_FIELD_LEN		1
 #define ESP_SPI_FIELD_LEN		4
 #define PORT_FIELD_LEN			2
 #define ICMP_HDR_FIELD_LEN		1
 
 #define MAX_SIZE_IP_UDP_SPI_KEY	\
-		(1 * IPv6_ADDR_SIZE_IN_BYTES + \
+		(1 * DPA_OFFLD_IPv6_ADDR_LEN_BYTES + \
 		IP_PROTO_FIELD_LEN + \
 		2 * PORT_FIELD_LEN + \
 		ESP_SPI_FIELD_LEN)
 
 #define MAX_SIZE_IP_UDP_SPI_KEY_IPV4 \
-		(1 * IPv4_ADDR_SIZE_IN_BYTES + \
+		(1 * DPA_OFFLD_IPv4_ADDR_LEN_BYTES + \
 		IP_PROTO_FIELD_LEN + \
 		2 * PORT_FIELD_LEN + \
 		ESP_SPI_FIELD_LEN)
 
 #define MAX_SIZE_POLICY_KEY \
-		(2 * IPv6_ADDR_SIZE_IN_BYTES + \
+		(2 * DPA_OFFLD_IPv6_ADDR_LEN_BYTES + \
 		IP_PROTO_FIELD_LEN + \
 		2 * PORT_FIELD_LEN)
 
 #define MAX_SIZE_POLICY_KEY_IPV4 \
-		(2 * IPv4_ADDR_SIZE_IN_BYTES + \
+		(2 * DPA_OFFLD_IPv4_ADDR_LEN_BYTES + \
 		IP_PROTO_FIELD_LEN + \
 		2 * PORT_FIELD_LEN)
 
 #define DPA_IPSEC_MAX_IN_POL_PER_SA  255  /* Maximum supported number of
 					   * inbound policies per SA	      */
 
-#define DPA_IPSEC_INVALID_SA_ID	-1
-
 #define DPA_IPSEC_HDR_COPY_TOS		0x01 /* Copy TOS / DiffServ byte from
 					      * inner / outer header to outer /
 					      * inner header		      */
@@ -204,45 +197,12 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id);
 /* Free a DPA-IPSec instance */
 int dpa_ipsec_free(int dpa_ipsec_id);
 
-/* DPA-IPSec IP Address Type */
-enum dpa_ipsec_ip_addr_type {
-	DPA_IPSEC_ADDR_T_IPv4 = 0,	/* IPv4 addresses		      */
-	DPA_IPSEC_ADDR_T_IPv6		/* IPv6 addresses		      */
-};
-
 /* DPA-IPSec data flow source specification */
 enum dpa_ipsec_direction {
 	DPA_IPSEC_INBOUND = 0,	/* Inbound				      */
 	DPA_IPSEC_OUTBOUND	/* Outbound				      */
 };
 
-/* DPA-IPSec IPv4 Address Descriptor */
-struct dpa_ipsec_ipv4_address {
-	union {
-		uint32_t word;	/* Address as 32bit word		      */
-		uint8_t byte[IPv4_ADDR_SIZE_IN_BYTES];/* Address as byte array*/
-	};
-};
-
-/* DPA-IPSec IPv6 Address Descriptor */
-struct dpa_ipsec_ipv6_address {
-	union {
-		uint8_t byte[IPv6_ADDR_SIZE_IN_BYTES];/* Address as byte array*/
-		uint32_t word[IPv6_ADDR_SIZE_IN_WORDS];/*Address as word array*/
-		uint64_t lword[IPv6_ADDR_SIZE_IN_LONG];/* Address as long word
-							* array		      */
-	};
-};
-
-/* DPA IPSEC IP Address Descriptor */
-struct dpa_ipsec_ip_address {
-	enum dpa_ipsec_ip_addr_type addr_type;
-	union {
-		struct dpa_ipsec_ipv4_address ipv4;  /* IPv4 address format   */
-		struct dpa_ipsec_ipv6_address ipv6;  /* IPv6 address format   */
-	};
-};
-
 /* DPA-IPSec Supported Cipher Suites */
 enum dpa_ipsec_cipher_alg {
 	DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_MD5_128,
@@ -320,7 +280,7 @@ struct dpa_ipsec_sa_out_params {
 						    * (IV). Null for using the
 						    * internal random number
 						    * generator               */
-	enum dpa_ipsec_ip_addr_type addr_type;	/* IPv4 or IPv6 address type  */
+	unsigned int ip_ver;	/* IPv4 or IPv6 address type		      */
 	uint16_t ip_hdr_size;	/* IP header size including any IP options    */
 	void *outer_ip_header;	/* IP encapsulation header		      */
 	void *outer_udp_header;	/* UDP encapsulation header
@@ -333,8 +293,8 @@ struct dpa_ipsec_sa_out_params {
 struct dpa_ipsec_sa_in_params {
 	enum dpa_ipsec_arw arw;	/* Anti replay window			      */
 	bool use_var_iphdr_len; /* Enable variable IP header length support   */
-	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
-	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
+	struct dpa_offload_ip_address src_addr;	/* Source IP address	      */
+	struct dpa_offload_ip_address dest_addr; /* Destination IP address    */
 	bool use_udp_encap;	/* NAT-T is activated (UDP encapsulated ESP)  */
 	uint16_t src_port;	/* Source UDP port (UDP encapsulated ESP)     */
 	uint16_t dest_port;	/* Destination UDP port (UDP encapsulated ESP)*/
@@ -479,9 +439,9 @@ struct dpa_ipsec_pol_dir_params {
 
 /* DPA-IPSec Security Policy Parameters */
 struct dpa_ipsec_policy_params {
-	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
+	struct dpa_offload_ip_address src_addr;	/* Source IP address	      */
 	uint8_t src_prefix_len;	/* Source network prefix		      */
-	struct dpa_ipsec_ip_address dest_addr;	/**< Destination IP address   */
+	struct dpa_offload_ip_address dest_addr; /**< Destination IP address  */
 	uint8_t dest_prefix_len; /* Destination network prefix		      */
 	uint8_t protocol;	/* Protocol				      */
 	bool masked_proto;	/* Mask the entire protocol field	      */
-- 
1.7.5.4

