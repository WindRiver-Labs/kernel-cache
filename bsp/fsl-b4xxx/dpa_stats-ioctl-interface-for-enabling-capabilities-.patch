From e6073e90b37dc8d0925c6e8469f23a7f401007ae Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 23:35:52 +0000
Subject: [PATCH 261/518] dpa_stats: ioctl interface for enabling capabilities
 in user space

Added ioctl support (wrappers) for dpa_stats component which
allows calling the functions from user space

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Makefile           |    2 +-
 .../staging/fsl_dpa_offload/dpa_offload_module.c   |   15 +
 drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h  |   96 +++
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c    |  712 ++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h    |   83 +++
 5 files changed, 907 insertions(+), 1 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h

diff --git a/drivers/staging/fsl_dpa_offload/Makefile b/drivers/staging/fsl_dpa_offload/Makefile
index 4e419d1..1527ccb 100644
--- a/drivers/staging/fsl_dpa_offload/Makefile
+++ b/drivers/staging/fsl_dpa_offload/Makefile
@@ -50,4 +50,4 @@ obj-$(CONFIG_FSL_DPA_OFFLOAD) += dpa_offload.o
 
 dpa_offload-objs :=  crc8.o dpa_classifier.o dpa_compat.o dpa_ipsec.o \
 		     dpa_ipsec_desc.o cq.o dpa_stats.o wrp_dpa_classifier.o \
-		     wrp_dpa_ipsec.o dpa_offload_module.o
+		     wrp_dpa_ipsec.o wrp_dpa_stats.o dpa_offload_module.o
diff --git a/drivers/staging/fsl_dpa_offload/dpa_offload_module.c b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
index 754b46e..8130c1b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
@@ -39,6 +39,7 @@
 #include "dpa_offload_module.h"
 #include "wrp_dpa_classifier.h"
 #include "wrp_dpa_ipsec.h"
+#include "wrp_dpa_stats.h"
 
 static int __init dpa_offload_drv_init(void)
 {
@@ -62,6 +63,14 @@ static int __init dpa_offload_drv_init(void)
 		return err;
 	}
 
+	/* Initialize DPA Stats wrapper to listen to [ioctl] calls */
+	err = wrp_dpa_stats_init();
+	if (err == 0)
+		printk(KERN_INFO"DPA Stats Driver initialized.\n");
+	else {
+		printk(KERN_ERR"DPA Stats Driver failed to initialize.\n");
+		return err;
+	}
 	return err;
 }
 module_init(dpa_offload_drv_init);
@@ -79,6 +88,12 @@ static void __exit dpa_offload_drv_exit(void)
 		printk(KERN_ERR"DPA IPSec Driver failed to unload.\n");
 	else
 		printk(KERN_INFO"INFO: DPA IPSec Driver unloaded.\n");
+
+	/* Shut down DPA Stats wrapper */
+	if (wrp_dpa_stats_exit() < 0)
+		printk(KERN_ERR"DPA Stats Driver failed to unload.\n");
+	else
+		printk(KERN_INFO"INFO: DPA Stats Driver unloaded.\n");
 }
 module_exit(dpa_offload_drv_exit);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
new file mode 100644
index 0000000..f77cc80
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
@@ -0,0 +1,96 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Stats Wrapper Application Programming Interface
+ */
+
+#ifndef __DPA_STATS_IOCTL_H
+#define __DPA_STATS_IOCTL_H
+
+/* Other includes */
+#include "linux/ioctl.h"
+#include <linux/compat.h>
+
+struct ioc_dpa_stats_params {
+	struct dpa_stats_params stats_params;
+	int dpa_stats_id;
+};
+
+struct ioc_dpa_stats_cnt_params {
+	int stats_id;
+	struct dpa_stats_cnt_params cnt_params;
+	int cnt_id;
+};
+
+struct ioc_dpa_stats_cls_cnt_params {
+	int stats_id;
+	struct dpa_stats_cls_cnt_params cnt_params;
+	int cnt_id;
+};
+
+struct ioc_dpa_stats_cls_member_params {
+	int cnt_id;
+	struct dpa_stats_cls_member_params params;
+	int member_index;
+};
+
+struct ioc_dpa_stats_cnt_request_params {
+	struct dpa_stats_cnt_request_params req_params;
+	int cnts_len;
+	dpa_stats_request_cb request_done;
+};
+
+#define DPA_STATS_IOC_MAGIC				0xde
+
+#define DPA_STATS_IOC_INIT				\
+	_IOWR(DPA_STATS_IOC_MAGIC, 0, struct ioc_dpa_stats_params)
+
+#define DPA_STATS_IOC_FREE				\
+	_IOW(DPA_STATS_IOC_MAGIC, 1, int)
+
+#define DPA_STATS_IOC_CREATE_COUNTER			\
+	_IOWR(DPA_STATS_IOC_MAGIC, 2, struct ioc_dpa_stats_cnt_params)
+
+#define DPA_STATS_IOC_CREATE_CLASS_COUNTER		\
+	_IOWR(DPA_STATS_IOC_MAGIC, 3, struct ioc_dpa_stats_cls_cnt_params)
+
+#define DPA_STATS_IOC_MODIFY_CLASS_COUNTER		\
+	_IOWR(DPA_STATS_IOC_MAGIC, 4, struct ioc_dpa_stats_cls_member_params)
+
+#define DPA_STATS_IOC_REMOVE_COUNTER			\
+	_IOW(DPA_STATS_IOC_MAGIC, 5, int)
+
+#define DPA_STATS_IOC_GET_COUNTERS			 \
+	_IOWR(DPA_STATS_IOC_MAGIC, 6, struct ioc_dpa_stats_cnt_request_params)
+
+#endif /* __DPA_STATS_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
new file mode 100644
index 0000000..ee1970c
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -0,0 +1,712 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Stats Wrapper implementation.
+ */
+#include <linux/fsl_dpa_stats.h>
+#include "wrp_dpa_stats.h"
+#include "dpa_stats_ioctl.h"
+
+/* Other includes */
+#include <linux/kernel.h>
+#include <linux/uaccess.h>
+#include <linux/fdtable.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+
+#include "dpa_compat.h"
+
+static const struct file_operations dpa_stats_fops = {
+	.owner = THIS_MODULE,
+	.open = wrp_dpa_stats_open,
+	.read = wrp_dpa_stats_read,
+	.write = NULL,
+	.unlocked_ioctl = wrp_dpa_stats_ioctl,
+	.release = wrp_dpa_stats_release
+};
+
+static int dpa_stats_cdev_major = -1;
+
+struct wrp_dpa_stats_cb wrp_dpa_stats;
+
+static void wrp_dpa_stats_event_queue_init(
+		struct dpa_stats_event_queue *eventQueue);
+
+static void wrp_dpa_stats_event_queue_free(
+		struct dpa_stats_event_queue *eventQueue);
+
+static int wrp_dpa_stats_queue_event(struct dpa_stats_event_queue *eventQueue,
+		struct dpa_stats_event *event);
+
+static struct dpa_stats_event  *wrp_dpa_stats_dequeue_event(
+		struct dpa_stats_event_queue *eventQueue, unsigned int block);
+
+static long wrp_dpa_stats_do_ioctl(struct file *filp,
+		unsigned int cmd, unsigned long args);
+
+static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
+		struct dpa_offload_lookup_key *dst);
+
+int wrp_dpa_stats_init(void)
+{
+	/* Cannot initialize the wrapper twice */
+	if (dpa_stats_cdev_major >= 0)
+		return -EBUSY;
+
+	dpa_stats_cdev_major =
+	    register_chrdev(0, DPA_STATS_CDEV, &dpa_stats_fops);
+	if (dpa_stats_cdev_major < 0) {
+		pr_err("Could not register DPA Stats character device");
+		return dpa_stats_cdev_major;
+	}
+
+	/* Initialize the event queue */
+	wrp_dpa_stats_event_queue_init(&wrp_dpa_stats.ev_queue);
+
+	return 0;
+}
+
+int wrp_dpa_stats_exit(void)
+{
+	if (dpa_stats_cdev_major < 0)
+		return 0;
+	unregister_chrdev(dpa_stats_cdev_major, DPA_STATS_CDEV);
+	dpa_stats_cdev_major = -1;
+
+	/* Destroy the event queue */
+	wrp_dpa_stats_event_queue_free(&wrp_dpa_stats.ev_queue);
+
+	return 0;
+}
+
+int wrp_dpa_stats_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+int wrp_dpa_stats_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+long wrp_dpa_stats_ioctl(struct file *filp, unsigned int cmd,
+			    unsigned long args)
+{
+	return wrp_dpa_stats_do_ioctl(filp, cmd, args);
+}
+
+ssize_t wrp_dpa_stats_read(struct file *file,
+				char *buf, size_t count, loff_t *off)
+{
+	struct dpa_stats_event  *event;
+	size_t      c = 0;
+
+	/* Make sure that the size of the buffer requested by the user is
+	 * at least the size of an event  */
+	if (count < sizeof(struct dpa_stats_event_params))
+		return -EINVAL;
+
+	/* Dequeue first event by using a blocking call */
+	event = wrp_dpa_stats_dequeue_event(&wrp_dpa_stats.ev_queue, 0);
+	while (event != NULL) {
+		if (event->params.bytes_written > 0) {
+			if (copy_to_user((wrp_dpa_stats.us_mem +
+					event->params.storage_area_offset),
+					(wrp_dpa_stats.k_mem +
+					event->params.storage_area_offset),
+					event->params.bytes_written)) {
+				pr_err("Couldn't copy counters values to storage area\n");
+				return -EFAULT;
+			}
+		}
+
+		if (copy_to_user(buf+c,
+				&event->params,
+				sizeof(struct dpa_stats_event_params)) != 0) {
+			kfree(event);
+			return -EFAULT;
+		}
+
+		kfree(event);
+
+		count   -= sizeof(struct dpa_stats_event_params);
+		c       += sizeof(struct dpa_stats_event_params);
+
+		if (count < sizeof(struct dpa_stats_event_params))
+			break;
+
+		/* For subsequent events, don't block */
+		event = wrp_dpa_stats_dequeue_event(
+				&wrp_dpa_stats.ev_queue, O_NONBLOCK);
+	}
+
+	return c;
+}
+
+static void wrp_dpa_stats_event_queue_init(
+		struct dpa_stats_event_queue *event_queue)
+{
+	INIT_LIST_HEAD(&event_queue->lh);
+	spin_lock_init(&event_queue->lock);
+	atomic_set(&event_queue->count, 0);
+	init_waitqueue_head(&event_queue->wq);
+}
+
+static void wrp_dpa_stats_event_queue_free(
+		struct dpa_stats_event_queue *event_queue)
+{
+	struct dpa_stats_event   *entry, *tmp;
+	unsigned long		 irqFlags;
+
+	/* Remove remaining events from the event queue */
+	spin_lock_irqsave(&event_queue->lock, irqFlags);
+	list_for_each_entry_safe(entry, tmp, &event_queue->lh, lh)
+	{
+		list_del(&entry->lh);
+		atomic_dec(&event_queue->count);
+		kfree(entry);
+	}
+	spin_unlock_irqrestore(&event_queue->lock, irqFlags);
+}
+
+static int wrp_dpa_stats_queue_event(struct dpa_stats_event_queue *event_queue,
+		struct dpa_stats_event *event)
+{
+	unsigned long    irqFlags;
+
+	/* If the event queue is already full, abort: */
+	if (atomic_read(&event_queue->count) >= QUEUE_MAX_EVENTS) {
+		pr_err("Event queue is full!\n");
+		return -EBUSY;
+	}
+
+	/* Add the event to the event queue */
+	spin_lock_irqsave(&event_queue->lock, irqFlags);
+	list_add_tail(&event->lh, &event_queue->lh);
+	atomic_inc(&event_queue->count);
+	spin_unlock_irqrestore(&event_queue->lock, irqFlags);
+
+	/* Wake up consumers */
+	wake_up_interruptible(&event_queue->wq);
+
+	/* Success. */
+	return 0;
+}
+
+static struct dpa_stats_event *wrp_dpa_stats_dequeue_event(
+		struct dpa_stats_event_queue *event_queue, unsigned int block)
+{
+	struct dpa_stats_event	*event;
+	unsigned long	irqFlags;
+
+	/* If the event queue is empty we perform an interruptible sleep
+	 * until an event is inserted into the queue. We use the event queue
+	 * spinlock to protect ourselves from race conditions. */
+	spin_lock_irqsave(&event_queue->lock, irqFlags);
+
+	while (list_empty(&event_queue->lh)) {
+		spin_unlock_irqrestore(&event_queue->lock, irqFlags);
+
+		/* If a non blocking action was requested, return failure: */
+		if (block & O_NONBLOCK)
+			return NULL;
+
+		if (wait_event_interruptible(event_queue->wq,
+			!list_empty(&event_queue->lh)))
+			/* Woken up by some signal... */
+			return NULL;
+
+		spin_lock_irqsave(&event_queue->lock, irqFlags);
+	}
+
+	/* Consume one event */
+	event = list_entry((&event_queue->lh)->next,
+			struct dpa_stats_event, lh);
+	list_del(&event->lh);
+	atomic_dec(&event_queue->count);
+	spin_unlock_irqrestore(&event_queue->lock, irqFlags);
+
+	return event;
+}
+
+void do_ioctl_req_done_cb(int dpa_stats_id,
+		unsigned int storage_area_offset, unsigned int cnts_written,
+		int bytes_written)
+{
+	struct dpa_stats_event *event = NULL;
+
+	/* Generate new event description: */
+	event = (struct dpa_stats_event *)
+			kmalloc(sizeof(struct dpa_stats_event), GFP_KERNEL);
+	if (!event) {
+		pr_err("No more memory for events !\n");
+		return;
+	}
+
+	/* Fill up the event parameters data structure: */
+	event->params.dpa_stats_id = dpa_stats_id;
+	event->params.storage_area_offset = storage_area_offset;
+	event->params.cnts_written = cnts_written;
+	event->params.bytes_written = bytes_written;
+
+	/* Queue this event */
+	if (wrp_dpa_stats_queue_event(&wrp_dpa_stats.ev_queue, event) != 0) {
+		pr_err("Failed to queue event.\n");
+		kfree(event);
+		return;
+	}
+
+	return;
+}
+
+static long do_ioctl_stats_init(void *args)
+{
+	struct ioc_dpa_stats_params kparam;
+	long ret = 0;
+
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		pr_err("Could not read dpa_stats_init user space args");
+		return -EBUSY;
+	}
+
+	/* Save user-space memory area pointer */
+	wrp_dpa_stats.us_mem = kparam.stats_params.storage_area;
+
+	/* Allocate kernel-space memory area to use for storing the statistics*/
+	kparam.stats_params.storage_area = kzalloc(
+			kparam.stats_params.storage_area_len, GFP_KERNEL);
+	if (!kparam.stats_params.storage_area) {
+		pr_err("Could not allocate kernel storage area");
+		return -ENOMEM;
+	}
+
+	/* Save kernel-space memory area pointer */
+	wrp_dpa_stats.k_mem = kparam.stats_params.storage_area;
+
+	/* Call init function */
+	ret = dpa_stats_init(&kparam.stats_params, &kparam.dpa_stats_id);
+	if (ret < 0)
+		return ret;
+
+	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+		pr_err("Could not write dpa_stats_init result");
+		return -EBUSY;
+	}
+
+	return ret;
+}
+
+static int do_ioctl_stats_create_counter(void *args)
+{
+	struct ioc_dpa_stats_cnt_params prm;
+	struct dpa_offload_lookup_key key;
+	long ret = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_NODE) {
+		ret = copy_key_descriptor(
+				&prm.cnt_params.classif_node_params.key, &key);
+		if (ret != 0) {
+			pr_err("Could not copy the key descriptor\n");
+			return -EINVAL;
+		}
+	} else if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_TBL) {
+		ret = copy_key_descriptor(
+				&prm.cnt_params.classif_tbl_params.key, &key);
+		if (ret != 0) {
+			pr_err("Could not copy the key descriptor\n");
+			return -EINVAL;
+		}
+	}
+
+	ret = dpa_stats_create_counter(prm.stats_id,
+			&prm.cnt_params, &prm.cnt_id);
+	if (ret < 0)
+		return ret;
+
+	if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+		pr_err("Could not copy to user the Counter ID");
+		ret = -EINVAL;
+	}
+
+	if ((prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_NODE) ||
+		(prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_TBL)) {
+		kfree(key.byte);
+		kfree(key.mask);
+	}
+
+	return ret;
+}
+
+static int do_ioctl_stats_create_class_counter(void *args)
+{
+	struct ioc_dpa_stats_cls_cnt_params prm;
+	struct dpa_stats_cls_cnt_classif_node *cnode;
+	struct dpa_stats_cls_cnt_classif_tbl  *tbl;
+	struct dpa_offload_lookup_key key;
+	long ret = 0;
+	uint32_t i = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_NODE) {
+		cnode = &prm.cnt_params.classif_node_params;
+
+		for (i = 0; i < prm.cnt_params.class_members; i++) {
+			ret = copy_key_descriptor(&cnode->keys[i], &key);
+			if (ret != 0) {
+				pr_err("Could not copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+
+	} else if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_TBL) {
+		tbl = &prm.cnt_params.classif_tbl_params;
+
+		if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+			for (i = 0; i < prm.cnt_params.class_members; i++) {
+
+				if ((!tbl->keys[i].byte) &&
+						(!tbl->keys[i].mask))
+					continue;
+
+				ret = copy_key_descriptor(&tbl->keys[i], &key);
+				if (ret != 0) {
+					pr_err("Couldn't copy the key descriptor\n");
+					return -EINVAL;
+				}
+			}
+
+		} else if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+			for (i = 0; i < prm.cnt_params.class_members; i++) {
+				if ((!tbl->pairs[i].first_key.byte) &&
+					(!tbl->pairs[i].first_key.mask))
+					continue;
+
+				ret = copy_key_descriptor(
+						&tbl->pairs[i].first_key, &key);
+				if (ret != 0) {
+					pr_err("Could not copy the key descriptor\n");
+					return -EINVAL;
+				}
+
+				ret = copy_key_descriptor(
+					&tbl->pairs[i].second_key, &key);
+				if (ret != 0) {
+					pr_err("Could not copy the key descriptor\n");
+					return -EINVAL;
+				}
+			}
+		}
+	}
+
+	ret = dpa_stats_create_class_counter(prm.stats_id,
+			&prm.cnt_params, &prm.cnt_id);
+	if (ret < 0)
+		return ret;
+
+	if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+		pr_err("Could not copy to user the Counter ID");
+		ret = -EINVAL;
+	}
+
+	if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_NODE) {
+		cnode = &prm.cnt_params.classif_node_params;
+
+		for (i = 0; i < prm.cnt_params.class_members; i++) {
+			kfree(cnode->keys[i].byte);
+			kfree(cnode->keys[i].mask);
+		}
+	}
+
+	if (prm.cnt_params.type == DPA_STATS_CNT_CLASSIF_TBL) {
+		tbl = &prm.cnt_params.classif_tbl_params;
+
+		for (i = 0; i < prm.cnt_params.class_members; i++) {
+			if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+				kfree(tbl->keys[i].byte);
+				kfree(tbl->keys[i].mask);
+			}
+
+			if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+				kfree(tbl->pairs[i].first_key.byte);
+				kfree(tbl->pairs[i].first_key.mask);
+				kfree(tbl->pairs[i].second_key.byte);
+				kfree(tbl->pairs[i].second_key.mask);
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int do_ioctl_stats_modify_class_counter(void *args)
+{
+	struct ioc_dpa_stats_cls_member_params prm;
+	struct dpa_offload_lookup_key key;
+	int ret;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	switch (prm.params.type) {
+	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
+		if ((prm.params.key.byte) && (prm.params.key.mask)) {
+			ret = copy_key_descriptor(&prm.params.key, &key);
+			if (ret != 0) {
+				pr_err("Couldn't copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+		break;
+	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
+		if ((prm.params.pair.first_key.byte) &&
+				(prm.params.pair.first_key.mask)) {
+			ret = copy_key_descriptor(
+					&prm.params.pair.first_key, &key);
+			if (ret != 0) {
+				pr_err("Could not copy the key descriptor\n");
+				return -EINVAL;
+			}
+
+			ret = copy_key_descriptor(
+					&prm.params.pair.second_key, &key);
+			if (ret != 0) {
+				pr_err("Could not copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+		break;
+	case DPA_STATS_CLS_MEMBER_SA_ID:
+		break;
+	default:
+		pr_err("invalid class member type\n");
+		break;
+	}
+
+	ret = dpa_stats_modify_class_counter(prm.cnt_id,
+			&prm.params, prm.member_index);
+	if (ret < 0)
+		return ret;
+
+	if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		pr_err("Could not write dpa_stats_init result");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int do_ioctl_stats_get_counters(void *args)
+{
+	struct ioc_dpa_stats_cnt_request_params prm;
+	int *req_cnts = NULL;
+	long ret = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy Request parameters");
+		return -EINVAL;
+	}
+
+	/* Allocate kernel-space memory area to copy the counters ids */
+	req_cnts = kzalloc(prm.req_params.cnts_ids_len *
+			sizeof(int), GFP_KERNEL);
+	if (!req_cnts) {
+		pr_err("Could not allocate requested counters array");
+		return -ENOMEM;
+	}
+
+	/* Copy the user provided counter ids */
+	if (copy_from_user(req_cnts,
+			prm.req_params.cnts_ids,
+			(prm.req_params.cnts_ids_len * sizeof(int)))) {
+		pr_err("Could not copy requested counters ids");
+		kfree(req_cnts);
+		return -EINVAL;
+	}
+
+	prm.req_params.cnts_ids = req_cnts;
+
+	/* If counters request is asynchronous, replace the application
+	 * callback with wrapper function */
+	if (prm.request_done)
+		prm.request_done = do_ioctl_req_done_cb;
+
+	ret = dpa_stats_get_counters(prm.req_params,
+			&prm.cnts_len,
+			prm.request_done);
+	if (ret < 0) {
+		kfree(req_cnts);
+		return -EINVAL;
+	}
+
+	/* If request is synchronous copy counters values to user space */
+	if (!prm.request_done) {
+		if (copy_to_user((wrp_dpa_stats.us_mem +
+				prm.req_params.storage_area_offset),
+				(wrp_dpa_stats.k_mem +
+				prm.req_params.storage_area_offset),
+				prm.cnts_len)) {
+			pr_err("Couldn't copy counters values to storage area\n");
+			kfree(req_cnts);
+			return -EINVAL;
+		}
+	}
+
+	kfree(req_cnts);
+
+	return ret;
+}
+
+long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args)
+{
+	long ret = 0;
+
+	switch (cmd) {
+	case DPA_STATS_IOC_INIT:
+		/* Call function */
+		ret = do_ioctl_stats_init((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_FREE: {
+		int dpa_stats_id;
+		if (copy_from_user(&dpa_stats_id, (int *)args,
+				    sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+
+		/* Release kernel allocated memory */
+		kfree(wrp_dpa_stats.k_mem);
+
+		ret = dpa_stats_free(dpa_stats_id);
+		if (ret < 0)
+			return ret;
+		break;
+	}
+	case DPA_STATS_IOC_CREATE_COUNTER:
+		ret = do_ioctl_stats_create_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_CREATE_CLASS_COUNTER:
+		ret = do_ioctl_stats_create_class_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_MODIFY_CLASS_COUNTER:
+		ret = do_ioctl_stats_modify_class_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_REMOVE_COUNTER:{
+		int dpa_stats_cnt_id;
+		if (copy_from_user(&dpa_stats_cnt_id, (int *)args,
+				    sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+
+		ret = dpa_stats_remove_counter(dpa_stats_cnt_id);
+		if (ret < 0)
+			return ret;
+
+		break;
+	}
+	case DPA_STATS_IOC_GET_COUNTERS:
+		ret = do_ioctl_stats_get_counters((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
+				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
+		break;
+	}
+	return ret;
+}
+
+static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
+		struct dpa_offload_lookup_key *dst)
+{
+	if (!src->byte) {
+		pr_err("Key byte pointer can't be NULL\n");
+		return -EINVAL;
+	}
+
+	if (!src->mask) {
+		pr_err("Key mask pointer can't be NULL\n");
+		return -EINVAL;
+	}
+
+	/* Allocate memory to store the key byte array */
+	dst->byte = kmalloc(src->size, GFP_KERNEL);
+	if (!dst->byte) {
+		pr_err("No more memory for key pointer\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(dst->byte, src->byte, src->size)) {
+		pr_err("Could not copy key byte");
+		return -EBUSY;
+	}
+
+	/* Allocate memory to store the key mask array */
+	dst->mask = kmalloc(src->size, GFP_KERNEL);
+	if (!dst->mask) {
+		pr_err("No more memory for mask pointer\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(dst->mask, src->mask, src->size)) {
+		pr_err("Could not copy key mask");
+		return -EBUSY;
+	}
+
+	src->byte = dst->byte;
+	src->mask = dst->mask;
+
+	return 0;
+}
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h
new file mode 100644
index 0000000..f67d154
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h
@@ -0,0 +1,83 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WRP_DPA_STATS_H_
+#define WRP_DPA_STATS_H_
+
+/* Other includes */
+#include "linux/fs.h"
+
+#define DPA_STATS_CDEV				"dpa_stats"
+
+int	wrp_dpa_stats_init(void);
+
+int	wrp_dpa_stats_exit(void);
+
+int	wrp_dpa_stats_open(struct inode *inode, struct file *filp);
+
+int	wrp_dpa_stats_release(struct inode *inode, struct file *filp);
+
+ssize_t wrp_dpa_stats_read(struct file *file,
+		char *buf, size_t count, loff_t *off);
+
+long	wrp_dpa_stats_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args);
+
+#define QUEUE_MAX_EVENTS 2048
+
+struct dpa_stats_event_params {
+	int		dpa_stats_id;
+	unsigned int	storage_area_offset;
+	unsigned int	cnts_written;
+	int		bytes_written;
+};
+
+struct dpa_stats_event_queue {
+	struct list_head    lh;     /**< Double linked list of events */
+	spinlock_t          lock;   /**< Spinlock protecting the queue
+					from concurrent access */
+	wait_queue_head_t   wq;     /**< Waitqueue for reader processes */
+	atomic_t            count;  /**< Number of events in the event queue */
+};
+
+struct dpa_stats_event {
+	struct dpa_stats_event_params  params;     /**< Event data */
+	struct list_head    lh;         /**< Event queue list head */
+};
+
+struct wrp_dpa_stats_cb {
+	void  *us_mem; /* Pointer to user-space storage area memory */
+	void  *k_mem;  /* Pointer to kernel-space storage area memory */
+	struct dpa_stats_event_queue ev_queue; /* Event queue */
+};
+
+#endif	/* WRP_DPA_STATS_H_ */
-- 
1.7.5.4

