From 094365a70c6327b171d136883b2934aae706992d Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Sun, 14 Apr 2013 17:19:20 +0300
Subject: [PATCH 26/36] fmd: Fix vsp-init not checking null pointer

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
[Grabbed from the branch, LINUX_IR5.3.0_ALPHA, of
https://git.freescale.com/git-private/cgit.cgi/ppc/dpaa-offload/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |   31 ++++++++++++++------
 .../dpa/NetCommSw/Peripherals/FM/SP/fman_sp.c      |    6 ++--
 .../freescale/dpa/NetCommSw/inc/flib/fsl_fman.h    |    1 +
 3 files changed, 26 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
index 8ddc326..6f0eb2d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -511,15 +511,28 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     fm_vsp_params.liodn_offset               = p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset;
     fm_vsp_params.no_scather_gather          = p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather;
 
-    fm_vsp_params.buf_pool_depletion.pools_grp_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsGrpModeEnable;
-    fm_vsp_params.buf_pool_depletion.num_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->numOfPools;
-    fm_vsp_params.buf_pool_depletion.pools_to_consider = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsider;
-    fm_vsp_params.buf_pool_depletion.single_pool_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->singlePoolModeEnable;
-    fm_vsp_params.buf_pool_depletion.pools_to_consider_for_single_mode = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsiderForSingleMode;
-    fm_vsp_params.buf_pool_depletion.has_pfc_priorities = TRUE;
-    fm_vsp_params.buf_pool_depletion.pfc_priorities_en = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->pfcPrioritiesEn;
-    fm_vsp_params.backup_pools.num_backup_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->numOfBackupPools;
-    fm_vsp_params.backup_pools.pool_ids = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->poolIds;
+    if (p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)
+    {
+        fm_vsp_params.buf_pool_depletion.buf_pool_depletion_enabled = TRUE;
+        fm_vsp_params.buf_pool_depletion.pools_grp_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsGrpModeEnable;
+        fm_vsp_params.buf_pool_depletion.num_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->numOfPools;
+        fm_vsp_params.buf_pool_depletion.pools_to_consider = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsider;
+        fm_vsp_params.buf_pool_depletion.single_pool_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->singlePoolModeEnable;
+        fm_vsp_params.buf_pool_depletion.pools_to_consider_for_single_mode = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsiderForSingleMode;
+        fm_vsp_params.buf_pool_depletion.has_pfc_priorities = TRUE;
+        fm_vsp_params.buf_pool_depletion.pfc_priorities_en = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->pfcPrioritiesEn;
+    }
+    else
+        fm_vsp_params.buf_pool_depletion.buf_pool_depletion_enabled = FALSE;
+    
+    if (p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
+    {
+        fm_vsp_params.backup_pools.num_backup_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->numOfBackupPools;
+        fm_vsp_params.backup_pools.pool_ids = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->poolIds;
+    }
+    else
+        fm_vsp_params.backup_pools.num_backup_pools = 0;
+
     fm_vsp_params.fm_ext_pools.num_pools_used = p_FmVspEntry->extBufPools.numOfPoolsUsed;
     fm_vsp_params.fm_ext_pools.ext_buf_pool = (struct fman_ext_pool_params*)&p_FmVspEntry->extBufPools.extBufPool;
     fm_vsp_params.buf_margins = (struct fman_sp_buf_margins*)&p_FmVspEntry->bufMargins;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fman_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fman_sp.c
index 42b6a5c..9ca525e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fman_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fman_sp.c
@@ -128,7 +128,7 @@ void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
 
 	/* fill pool depletion register*/
 	tmp_reg = 0;
-	if (buf_pool_depletion && buf_pool_depletion->pools_grp_mode_enable) {
+	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->pools_grp_mode_enable) {
 		/* calculate vector for number of pools depletion */
 		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
 				pools_to_consider, ext_buf_pools, 0x80000000);
@@ -139,7 +139,7 @@ void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
 		tmp_reg |= vector;
 	}
 
-	if (buf_pool_depletion && buf_pool_depletion->single_pool_mode_enable) {
+	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->single_pool_mode_enable) {
 		/* calculate vector for number of pools depletion */
 		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
 				pools_to_consider_for_single_mode,
@@ -150,7 +150,7 @@ void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
 	}
 
 	/* fill QbbPEV */
-	if (buf_pool_depletion) {
+	if (buf_pool_depletion->buf_pool_depletion_enabled) {
 		vector = 0;
 		for (i = 0; i < max_num_of_pfc_priorities; i++)
 			if (buf_pool_depletion->pfc_priorities_en[i] == TRUE)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman.h
index 8ad89ca..795f6b2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman.h
@@ -63,6 +63,7 @@ struct fman_backup_bm_pools {
  @Description   A structure for defining BM pool depletion criteria
 *//***************************************************************************/
 struct fman_buf_pool_depletion {
+	bool buf_pool_depletion_enabled;
 	bool pools_grp_mode_enable;    /**< select mode in which pause frames
 					will be sent after a number of pools
 					(all together!) are depleted */
-- 
1.7.5.4

