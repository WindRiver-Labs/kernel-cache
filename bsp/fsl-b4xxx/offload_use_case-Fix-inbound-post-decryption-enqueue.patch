From 6594330b1d37bffb86c428368c094c2124b2fead Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Wed, 12 Sep 2012 21:25:40 +0000
Subject: [PATCH 320/518] offload_use_case: Fix inbound post decryption
 enqueue action

For inbound post decryption frames are enqueued to different queues
according to the decrypted flow type(UDP-GTP, UDP-non GTP, non UDP)
Before this fix all decrypted traffic was enqueued to UDP-GTP queue.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |   10 +++++-
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   36 +++++++++++++++++--
 2 files changed, 41 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
index 4873fda..dd7a8c1 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -91,11 +91,19 @@ struct ipsec_uparms {
 	__u16 max_sa;
 };
 
+/* Inbound post IPSEC OH queue types*/
+enum inb_queue_types {
+	DL_GTP_QUEUE = 0,
+	DL_UDP_UPLANE_QUEUE,
+	DL_NON_UDP_UPLANE_QUEUE,
+	INB_MAX_NUM_QUEUES
+};
+
 struct xfrm_km_uparms {
 	__u8 sa_bpid;
 	__u8 sa_wqid;
 	unsigned int mtu_pre_enc;
-	__u32 def_sa_fqid;
+	__u32 policy_act_fqid[INB_MAX_NUM_QUEUES];
 	__u32 pol_miss_fqid;
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 23b4840..768cae8 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -50,6 +50,7 @@
 #define HASH_SIZE 256
 #define DPA_IPSEC_ADDR_T_IPv4 4
 #define DPA_IPSEC_ADDR_T_IPv6 6
+#define GTP_PORT 0x0868
 
 static const u32 jhash_initval = 0xdeadbeef;
 /* offloaded SA hash entry */
@@ -457,9 +458,11 @@ static int offload_sa(int dpa_ipsec_id,
 }
 
 static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
-				 struct xfrm_selector *sel, int sa_id, int dir)
+				 struct xfrm_selector *sel, int sa_id, int dir,
+				 int policy_act_fqid)
 {
 	int ret = 0;
+	struct dpa_cls_tbl_action policy_action;
 
 	memset(pol_params, 0, sizeof(*pol_params));
 	if (dir == XFRM_POLICY_OUT) {
@@ -487,6 +490,17 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 	pol_params->l4.dest_port = sel->dport;
 	pol_params->l4.dest_port_mask = sel->dport_mask;
 
+	memset(&policy_action, 0, sizeof(policy_action));
+	if (dir == XFRM_POLICY_IN) {
+		policy_action.type = DPA_CLS_TBL_ACTION_ENQ;
+		policy_action.enable_statistics = false;
+		policy_action.enq_params.new_fqid = policy_act_fqid;
+		policy_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
+		policy_action.enq_params.override_fqid = true;
+		pol_params->dir_params.type = DPA_IPSEC_POL_DIR_PARAMS_ACT;
+		pol_params->dir_params.in_action = policy_action;
+	}
+
 	ret = dpa_ipsec_sa_add_policy(sa_id, pol_params);
 	return ret;
 }
@@ -505,6 +519,7 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 	int from_pol = ((struct work_arg *)ptr)->from_pol;
 	struct dpa_ipsec_sa_params sa_params;
 	struct dpa_ipsec_policy_params pol_params;
+	int def_sa_fqid, policy_fqid;
 
 	/* we support only one template per policy so only the
 	   first transform is checked */
@@ -531,11 +546,23 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 	else
 		return 0;	/* continue walking */
 
+	if (pol->selector.proto == IPPROTO_UDP)
+		if (pol->selector.dport == GTP_PORT)
+				policy_fqid = usr_params.
+					policy_act_fqid[DL_GTP_QUEUE];
+			else
+				policy_fqid = usr_params.
+					policy_act_fqid[DL_UDP_UPLANE_QUEUE];
+	else
+		policy_fqid = usr_params.
+				policy_act_fqid[DL_NON_UDP_UPLANE_QUEUE];
+
 	if (!sa) {
+		def_sa_fqid = policy_fqid;
 		memset(&sa_params, 0, sizeof(sa_params));
 		err = offload_sa(dpa_ipsec_id, &sa_params, x,
-				 usr_params.def_sa_fqid,
-				 usr_params.pol_miss_fqid, dir, &sa_id);
+				def_sa_fqid, usr_params.pol_miss_fqid,
+				dir, &sa_id);
 
 		if (err < 0) {
 			pr_err("%s(%d) : Error offloading out SA SPI %d (%d)\n",
@@ -562,7 +589,8 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 		}
 
 	}
-	err = offload_policy(&pol_params, &pol->selector, sa->sa_id, dir);
+	err = offload_policy(&pol_params, &pol->selector, sa->sa_id, dir,
+				policy_fqid);
 	if (err < 0) {
 		pr_err("%s(%d): Error offloading policy index %d (%d)\n",
 		       __func__, __LINE__, pol->index, err);
-- 
1.7.5.4

