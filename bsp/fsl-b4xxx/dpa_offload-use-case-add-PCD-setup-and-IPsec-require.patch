From 8f2c7ce7f7daff985dec12982944fce6f52c7afd Mon Sep 17 00:00:00 2001
From: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
Date: Thu, 17 May 2012 15:56:13 +0000
Subject: [PATCH 186/518] dpa_offload use case : add PCD setup and IPsec
 required handle retrieval

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/pcd_init.c    |  127 ++++++++++++++++++++
 1 files changed, 127 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/pcd_init.c

diff --git a/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c b/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c
new file mode 100644
index 0000000..fbf6c4e
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c
@@ -0,0 +1,127 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "fmc.h"
+#include "ports_conf.h"
+
+#include "common.h"
+
+/* cc nodes required by DPA IPsec offloading */
+t_Handle cc_in_rx, cc_flow_id, cc_out_pre_enc[2];
+static int pcd_initialized;
+
+int fmc_config(void)
+{
+	int ret;
+	char ccnode_path[64];
+	/* execute fmc model */
+	ret = fmc_execute(&cmodel);
+	if (ret != E_OK) {
+		pr_err("%s(%d) : Failed to execute the fmc model\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* get cc nodes handles */
+	memset(ccnode_path, 0, sizeof(ccnode_path));
+	sprintf(ccnode_path, "fm%d/port/1G/%d/ccnode/dl_rx_e_IN_RX_ccnode",
+		FM, DL_RX);
+	cc_in_rx = fmc_get_handle(&cmodel, FM, e_FM_PORT_TYPE_RX, DL_RX,
+				/*"dl_rx_e_IN_RX_ccnode"*/
+				ccnode_path);
+	if (!cc_in_rx) {
+		pr_err("%s(%d): Error getting cc_in_rx handle\n",
+			__func__, __LINE__);
+		goto out;
+	}
+
+	memset(ccnode_path, 0, sizeof(ccnode_path));
+	sprintf(ccnode_path,
+		"fm%d/port/OFFLINE/%d/ccnode/flow_id_e_IN_POST_DEC_ccnode",
+		FM, DL_POST_IPSEC_OH);
+	cc_flow_id = fmc_get_handle(&cmodel, FM,
+			e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
+			DL_POST_IPSEC_OH,
+			/*"flow_id_e_IN_POST_DEC_ccnode"*/
+			ccnode_path);
+	if (!cc_flow_id) {
+		pr_err("%s(%d) : error getting cc_flow_id handle\n",
+			__func__, __LINE__);
+		goto out;
+	}
+
+	memset(ccnode_path, 0, sizeof(ccnode_path));
+	sprintf(ccnode_path,
+		"fm%d/port/OFFLINE/%d/ccnode/e_OUT_PRE_ENC_ccnode0",
+		FM, UL_PRE_IPSEC_OH);
+	cc_out_pre_enc[0] = fmc_get_handle(&cmodel, FM,
+				e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
+				UL_PRE_IPSEC_OH,
+				/*"e_OUT_PRE_ENC_ccnode0"*/
+				ccnode_path);
+	if (!cc_out_pre_enc[0]) {
+		pr_err("%s(%d) : Error getting cc_out_pre_enc[0] handle\n",
+			__func__, __LINE__);
+		goto out;
+	}
+
+	memset(ccnode_path, 0, sizeof(ccnode_path));
+	sprintf(ccnode_path,
+		"fm%d/port/OFFLINE/%d/ccnode/e_OUT_PRE_ENC_ccnode1",
+		FM, UL_PRE_IPSEC_OH);
+	cc_out_pre_enc[1] = fmc_get_handle(&cmodel, FM,
+				e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
+				UL_PRE_IPSEC_OH,
+				/*"e_OUT_PRE_ENC_ccnode1"*/
+				ccnode_path);
+	if (!cc_out_pre_enc[1]) {
+		pr_err("%s(%d) : Error getting cc_out_pre_enc[1]\n",
+			__func__, __LINE__);
+		goto out;
+	}
+
+	pcd_initialized = 1;
+	return 0;
+
+out:
+	fmc_clean(&cmodel);
+	return -EINVAL;
+
+	return 0;
+}
+
+void fmc_cleanup(void)
+{
+	if (!pcd_initialized)
+		return;
+	fmc_clean(&cmodel);
+}
-- 
1.7.5.4

