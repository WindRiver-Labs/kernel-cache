From 45901583916cddc31f8066347f1da0741d1d1f5a Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Fri, 7 Dec 2012 23:10:57 +0000
Subject: [PATCH 437/518] dpa_classifier: Remove import function from
 multicast component

This patch removes the import function from DPA Classif multicast component.
The import is now done using the create function, specifying the external group handle
and the number of prefilled members(members that exist in the imported group).

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  257 +++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |    2 +-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   24 +--
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   76 +-----
 include/linux/fsl_dpa_classifier.h                 |   21 +-
 5 files changed, 145 insertions(+), 235 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index a78e5ec..57d17807 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -6083,26 +6083,20 @@ int dpa_classif_mcast_create_group(
 
 	t_Error err = 0;
 	struct dpa_cls_mcast_group *pgroup;
-	struct dpa_cls_hm_node *hm_node;
-	struct dpa_cls_hm *hm;
 	uint8_t max_members;
 	struct dpa_cls_tbl_enq_action_desc	*member_params;
-	t_FmPcdFrmReplicGroupParams		grp_params;
+	t_FmPcdFrmReplicGroupParams		*replic_grp_params = NULL;
 	t_FmPcdCcNextEngineParams		*next_engine_params;
 
-
-	memset(&grp_params, 0, sizeof(t_FmPcdFrmReplicGroupParams));
-
-
 	if (!group_params) {
-		pr_err("\nERROR: %s, %s (%d): Invalid value for group "
-			"params.\n", __FILE__, __func__, __LINE__);
+		pr_err("\nERROR: %s, %s (%d): Group params is NULL.\n",
+			__FILE__, __func__, __LINE__);
 		err = -EINVAL;
 		return err;
 	}
 
 	if (!grpd) {
-		pr_err("\nERROR: %s, %s (%d): Invalid group desc\n",
+		pr_err("\nERROR: %s, %s (%d): Group desc is NULL\n",
 			__FILE__, __func__, __LINE__);
 		err = -EINVAL;
 		return err;
@@ -6133,6 +6127,16 @@ int dpa_classif_mcast_create_group(
 		goto dpa_classif_mcast_create_group_error;
 	}
 
+	if (group_params->prefilled_members > group_params->max_members) {
+		pr_err("\nERROR: %s, %s (%d): Number of prefilled members is "
+			"greater than the maximum number of members in group."
+			"%d > %d", __FILE__, __func__, __LINE__,
+			group_params->prefilled_members,
+			group_params->max_members);
+		err = -EINVAL;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
 	max_members = group_params->max_members;
 	*grpd = DPA_OFFLD_DESC_NONE;
 
@@ -6156,76 +6160,79 @@ int dpa_classif_mcast_create_group(
 		goto dpa_classif_mcast_create_group_error;
 	}
 
-	/*
-	 * set parameters for the first member
-	 */
-	member_params = &pgroup->group_params.member_params;
-
-	if (member_params->policer_params != NULL) {
-		pr_err("ERROR: %s, %s (%d): Policing for DPA Classifier flows "
-			"is not yet supported.\n", __FILE__, __func__,
-			__LINE__);
-		err = -ENOSYS;
-		goto dpa_classif_mcast_create_group_error;
-	}
-
-
-	grp_params.maxNumOfEntries = max_members;
-	grp_params.numOfEntries = pgroup->num_members + 1;
-	next_engine_params = &grp_params.nextEngineParams[0];
-
-	next_engine_params->nextEngine = e_FM_PCD_DONE;
-	next_engine_params->params.enqueueParams.action = e_FM_PCD_ENQ_FRAME;
-	next_engine_params->params.enqueueParams.overrideFqid =
-						member_params->override_fqid;
-	next_engine_params->params.enqueueParams.newFqid =
-						member_params->new_fqid;
+	/* Group is not imported */
+	if (group_params->group == NULL) {
+		/*
+		 * set parameters for the first member
+		 */
+		member_params = &pgroup->group_params.member_params;
 
-	if (member_params->hmd != DPA_OFFLD_DESC_NONE) {
-		hm = desc_to_object(&mcast_grp_array, member_params->hmd);
-		if (!hm) {
-			pr_err("ERROR: %s, %s (%d): Invalid hm descriptor "
-				"(hmd=%d).\n", __FILE__, __func__, __LINE__,
-				member_params->hmd);
-			err = -EINVAL;
+		if (member_params->policer_params != NULL) {
+			pr_err("ERROR: %s, %s (%d): Policing for DPA "
+				"Classifier flows is not yet supported.\n",
+				__FILE__, __func__, __LINE__);
+			err = -ENOSYS;
 			goto dpa_classif_mcast_create_group_error;
 		}
 
-		/*
-		 * Verify that the header manipulation op is a
-		 * chain head
-		 */
-		if (!hm->chain_head) {
-			pr_err("ERROR %s, %s (%d): Only a HM chain head can be "
-				"attached to a classifier table entry. hmd=%d "
-				"is not a chain head.\n", __FILE__, __func__,
-				__LINE__, member_params->hmd);
-			err = -EINVAL;
+		replic_grp_params = kzalloc(sizeof(t_FmPcdFrmReplicGroupParams),
+					    GFP_KERNEL);
+		if (!replic_grp_params) {
+			pr_err("\nERROR: %s, %s (%d): No more memory for DPA "
+				"multicast group params.", __FILE__, __func__,
+				__LINE__);
+			err = -ENOMEM;
 			goto dpa_classif_mcast_create_group_error;
 		}
 
-		/*
-		 * Acquire the hm_node structure that is head of
-		 * the header manipulation chain
-		 */
-		hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node,
-					list_node);
+		replic_grp_params->maxNumOfEntries = max_members;
+		replic_grp_params->numOfEntries = pgroup->num_members + 1;
+		next_engine_params = &replic_grp_params->nextEngineParams[0];
 
-		next_engine_params->h_Manip = (t_Handle)hm_node->node;
-	} else
-		next_engine_params->h_Manip = NULL;
+		next_engine_params->nextEngine = e_FM_PCD_DONE;
+		next_engine_params->params.enqueueParams.action =
+						e_FM_PCD_ENQ_FRAME;
+		next_engine_params->params.enqueueParams.overrideFqid =
+						member_params->override_fqid;
+		next_engine_params->params.enqueueParams.newFqid =
+						member_params->new_fqid;
+		if (member_params->hmd != DPA_OFFLD_DESC_NONE) {
+			next_engine_params->h_Manip = (t_Handle)
+				dpa_classif_hm_lock_chain(member_params->hmd);
+			if (!next_engine_params->h_Manip) {
+				pr_err("ERROR: %s, %s (%d): Failed to attach "
+					"HM op hmd=%d to multicast entry.",
+					__FILE__, __func__, __LINE__,
+					member_params->hmd);
+				err = -EINVAL;
+				goto dpa_classif_mcast_create_group_error;
+			}
+		} else
+			next_engine_params->h_Manip = NULL;
+
+		pgroup->group = FM_PCD_FrmReplicSetGroup(group_params->fm_pcd,
+							replic_grp_params);
+		pgroup->member_used[pgroup->num_members] = true;
+		pgroup->num_members++;
+	} else {
+		pgroup->group = group_params->group;
+		/* mark prefilled members in index array member */
+		memset(pgroup->member_used, 1,
+			group_params->prefilled_members * sizeof(bool));
+		pgroup->num_members = group_params->prefilled_members;
+	}
 
-	pgroup->group = FM_PCD_FrmReplicSetGroup(group_params->fm_pcd,
-						&grp_params);
 	if (!pgroup->group) {
-		pr_err("\nERROR: %s: Could not create group %d",
-			__func__, *grpd);
+		pr_err("\nERROR: %s, %s (%d): Could not create %s group %d",
+			__FILE__, __func__, __LINE__,
+			(group_params->prefilled_members > 0) ? "imported" :
+			"", *grpd);
 		err = -EINVAL;
 		goto dpa_classif_mcast_create_group_error;
 	}
 
-	pgroup->member_used[pgroup->num_members] = true;
-	pgroup->num_members++;
+
+	kfree(replic_grp_params);
 
 	return 0;
 
@@ -6237,61 +6244,24 @@ dpa_classif_mcast_create_group_error:
 	}
 
 	*grpd = DPA_OFFLD_DESC_NONE;
-	return err;
-}
-EXPORT_SYMBOL(dpa_classif_mcast_create_group);
-
-int dpa_classif_mcast_import_group(void *group, int *grpd)
-{
-	struct dpa_cls_mcast_group *pgroup;
-	t_Error err = 0;
-
-	if (!group) {
-		pr_err("\nERROR: %s, %s (%d): Invalid group handle.\n",
-			__FILE__, __func__, __LINE__);
-		return -EINVAL;
-	}
-
-	if (!grpd) {
-		pr_err("\nERROR: %s, %s (%d): Invalid group desc.\n",
-			__FILE__, __func__, __LINE__);
-		return -EINVAL;
-	}
-
-	*grpd = DPA_OFFLD_DESC_NONE;
-	pgroup = (typeof(pgroup))kzalloc(sizeof(struct dpa_cls_mcast_group),
-					  GFP_KERNEL);
-	if (!pgroup) {
-		pr_err("\nERROR: %s, %s (%d): No more memory for DPA multicast "
-			"groups.", __FILE__, __func__, __LINE__);
-		err = -ENOMEM;
-		return err;
-	}
-
-	err = acquire_descriptor(&mcast_grp_array, pgroup, grpd);
-	if (err < 0)
-		return err;
-
-	pgroup->group = group;
+	kfree(replic_grp_params);
 
 	return err;
 }
-EXPORT_SYMBOL(dpa_classif_mcast_import_group);
+EXPORT_SYMBOL(dpa_classif_mcast_create_group);
 
 int dpa_classif_mcast_add_member(int grpd,
 		const struct dpa_cls_tbl_enq_action_desc *member_params,
 		int *membrd)
 {
 	struct dpa_cls_mcast_group *pgroup;
-	struct dpa_cls_hm_node *hm_node;
 	int member_id;
-	struct dpa_cls_hm *hm;
+	unsigned int prefill_start;
 	uint8_t max_members;
 	t_Error err = 0;
-	t_FmPcdFrmReplicGroupParams	grp_params;
+	t_FmPcdFrmReplicGroupParams	*replic_grp_params = NULL;
 	t_FmPcdCcNextEngineParams	*next_engine_params;
 
-	memset(&grp_params, 0, sizeof(t_FmPcdFrmReplicGroupParams));
 	pgroup = desc_to_object(&mcast_grp_array, grpd);
 	if (!pgroup) {
 		pr_err("ERROR: %s, %s (%d): Invalid group descriptor "
@@ -6300,13 +6270,13 @@ int dpa_classif_mcast_add_member(int grpd,
 	}
 
 	if (!member_params) {
-		pr_err("\nERROR: %s, %s (%d): Invalid value for member "
-			"params.\n", __FILE__, __func__, __LINE__);
+		pr_err("\nERROR: %s, %s (%d): Member params is NULL.\n",
+			__FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
 
 	if (!membrd) {
-		pr_err("\nERROR: %s, %s (%d): Invalid member desc.\n",
+		pr_err("\nERROR: %s, %s (%d): Member desc is NULL.\n",
 			__FILE__, __func__, __LINE__);
 		return -EINVAL;
 	}
@@ -6320,7 +6290,8 @@ int dpa_classif_mcast_add_member(int grpd,
 	}
 
 	max_members = pgroup->group_params.max_members;
-	for (member_id = 0; member_id < max_members; member_id++)
+	prefill_start = pgroup->group_params.prefilled_members;
+	for (member_id = prefill_start; member_id < max_members; member_id++)
 		if (pgroup->member_used[member_id] == false) {
 			*membrd = member_id;
 			break;
@@ -6337,10 +6308,18 @@ int dpa_classif_mcast_add_member(int grpd,
 		goto dpa_classif_mcast_add_member_error;
 	}
 
+	replic_grp_params = kzalloc(sizeof(t_FmPcdFrmReplicGroupParams),
+				    GFP_KERNEL);
+	if (!replic_grp_params) {
+		pr_err("\nERROR: %s, %s (%d): No more memory for DPA multicast "
+			"group params.", __FILE__, __func__, __LINE__);
+		err = -ENOMEM;
+		goto dpa_classif_mcast_add_member_error;
+	}
 
-	grp_params.maxNumOfEntries = max_members;
-	grp_params.numOfEntries = pgroup->num_members;
-	next_engine_params = &grp_params.nextEngineParams[0];
+	replic_grp_params->maxNumOfEntries = max_members;
+	replic_grp_params->numOfEntries = pgroup->num_members;
+	next_engine_params = &replic_grp_params->nextEngineParams[0];
 	next_engine_params->nextEngine = e_FM_PCD_DONE;
 	next_engine_params->params.enqueueParams.action = e_FM_PCD_ENQ_FRAME;
 	next_engine_params->params.enqueueParams.overrideFqid =
@@ -6349,36 +6328,16 @@ int dpa_classif_mcast_add_member(int grpd,
 						member_params->new_fqid;
 
 	if (member_params->hmd != DPA_OFFLD_DESC_NONE) {
-		hm = desc_to_object(&mcast_grp_array, member_params->hmd);
-		if (!hm) {
-			pr_err("ERROR: %s, %s (%d): Invalid hm descriptor "
-				"(hmd=%d).\n", __FILE__, __func__, __LINE__,
+		next_engine_params->h_Manip = (t_Handle)
+				dpa_classif_hm_lock_chain(member_params->hmd);
+		if (!next_engine_params->h_Manip) {
+			pr_err("ERROR: %s, %s (%d): Failed to attach "
+				"HM op hmd=%d to multicast entry.",
+				__FILE__, __func__, __LINE__,
 				member_params->hmd);
 			err = -EINVAL;
 			goto dpa_classif_mcast_add_member_error;
 		}
-
-		/*
-		 * Verify that the header manipulation op is a
-		 * chain head
-		 */
-		if (!hm->chain_head) {
-			pr_err("ERROR %s, %s (%d): Only a HM chain head can be "
-				"attached to a classifier table entry. hmd=%d "
-				"is not a chain head.\n", __FILE__, __func__,
-				__LINE__, member_params->hmd);
-			err = -EINVAL;
-			goto dpa_classif_mcast_add_member_error;
-		}
-
-		/*
-		 * Acquire the hm_node structure that is head of
-		 * the header manipulation chain
-		 */
-		hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node,
-				     list_node);
-
-		next_engine_params->h_Manip = (t_Handle)hm_node->node;
 	} else
 		next_engine_params->h_Manip = NULL;
 
@@ -6392,6 +6351,7 @@ int dpa_classif_mcast_add_member(int grpd,
 		goto dpa_classif_mcast_add_member_error;
 	}
 
+	kfree(replic_grp_params);
 	return 0;
 
 dpa_classif_mcast_add_member_error:
@@ -6399,6 +6359,7 @@ dpa_classif_mcast_add_member_error:
 	pgroup->member_used[*membrd] = false;
 	pgroup->num_members--;
 	*membrd = DPA_OFFLD_DESC_NONE;
+	kfree(replic_grp_params);
 
 	return err;
 }
@@ -6450,15 +6411,19 @@ int dpa_classif_mcast_free_group(int grpd)
 		return -EINVAL;
 	}
 
-	err = FM_PCD_FrmReplicDeleteGroup(pgroup->group);
-	if (err != E_OK) {
-		pr_err("\nERROR: %s, %s (%d): Could not delete group (%d)\n",
-			__FILE__, __func__, __LINE__, grpd);
-		return -EINVAL;
+	/* If no prefilled members are present, the group was not imported*/
+	if (!pgroup->group_params.prefilled_members) {
+		err = FM_PCD_FrmReplicDeleteGroup(pgroup->group);
+		if (err != E_OK) {
+			pr_err("\nERROR: %s, %s (%d): Could not delete group "
+				"(%d)\n", __FILE__, __func__, __LINE__, grpd);
+			return -EINVAL;
+		}
 	}
 
-
 	kfree(pgroup->member_used);
+
+
 	put_descriptor(&mcast_grp_array, grpd);
 	kfree(pgroup);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 11826bc..9d6ba65 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -346,7 +346,7 @@ struct dpa_cls_mcast_group {
 	bool		*member_used;
 
 	/*
-	 * External group handle
+	 * Group handle
 	 */
 	void		*group;
 };
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index a14b276..53ca557 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -470,6 +470,8 @@ struct dpa_cls_compat_mcast_group_params {
 	uint8_t	max_members;
 	compat_uptr_t	fm_pcd;
 	struct	dpa_cls_compat_tbl_enq_action_desc member_params;
+	unsigned int prefilled_members;
+	compat_uptr_t group;
 };
 
 struct compat_ioc_dpa_cls_mcast_group_params {
@@ -477,11 +479,6 @@ struct compat_ioc_dpa_cls_mcast_group_params {
 	int grpd;
 };
 
-struct compat_ioc_dpa_cls_mcast_import_params {
-	compat_uptr_t group;
-	int grpd;
-};
-
 struct compat_ioc_dpa_cls_mcast_member_params {
 	int grpd;
 	struct dpa_cls_compat_tbl_enq_action_desc member_params;
@@ -809,29 +806,20 @@ int dpa_cls_mcast_member_params_compatcpy(
 	      struct compat_ioc_dpa_cls_mcast_group_params)
 #endif
 
-#define DPA_CLS_IOC_MCAST_IMPORT_GROUP				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 32, struct ioc_dpa_cls_mcast_import_params)
-
-#ifdef CONFIG_COMPAT
-#define DPA_CLS_IOC_COMPAT_MCAST_IMPORT_GROUP			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 32,				\
-	      struct compat_ioc_dpa_cls_mcast_import_params)
-#endif
-
 #define DPA_CLS_IOC_MCAST_ADD_MEMBER				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 33, struct ioc_dpa_cls_mcast_member_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 32, struct ioc_dpa_cls_mcast_member_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_MCAST_ADD_MEMBER			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 33,				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 32,				\
 	      struct compat_ioc_dpa_cls_mcast_member_params)
 #endif
 
 #define DPA_CLS_IOC_MCAST_REMOVE_MEMBER				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 34, struct ioc_dpa_cls_mcast_remove_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 33, struct ioc_dpa_cls_mcast_remove_params)
 
 #define DPA_CLS_IOC_MCAST_FREE_GROUP				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 35, struct ioc_dpa_cls_hm_mpls_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 34, int)
 
 
 #endif /* __DPA_CLASSIFIER_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index ea11ff9..58ef003 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -193,8 +193,6 @@ static long do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode);
 
 static long do_ioctl_mcast_create_group(unsigned long args, bool compat_mode);
 
-static long do_ioctl_mcast_import_group(unsigned long args, bool compat_mode);
-
 static long do_ioctl_mcast_add_member(unsigned long args, bool compat_mode);
 
 void *translate_fm_pcd_handle(void *fm_pcd);
@@ -566,12 +564,6 @@ long wrp_dpa_classif_do_ioctl(
 		ret = do_ioctl_mcast_create_group(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
-	case	DPA_CLS_IOC_COMPAT_MCAST_IMPORT_GROUP:
-#endif /* CONFIG_COMPAT */
-	case	DPA_CLS_IOC_MCAST_IMPORT_GROUP:
-		ret = do_ioctl_mcast_import_group(args, compat_mode);
-		break;
-#ifdef CONFIG_COMPAT
 	case	DPA_CLS_IOC_COMPAT_MCAST_ADD_MEMBER:
 #endif /* CONFIG_COMPAT */
 	case	DPA_CLS_IOC_MCAST_ADD_MEMBER:
@@ -1567,67 +1559,15 @@ static long do_ioctl_mcast_create_group(unsigned long args, bool compat_mode)
 #if (DPAA_VERSION >= 11)
 	ret = dpa_classif_mcast_create_group(&kparam.mcast_grp_params,
 					     &kparam.grpd);
-	if (ret < 0)
-		return ret;
 #else
 	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
 	       "platform.\n", __FILE__, __func__, __LINE__);
-	return -EINVAL;
-#endif
-
-#ifdef CONFIG_COMPAT
-	if (compat_mode) {
-		uparam.grpd = kparam.grpd;
-		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
-				__FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-	} else
-#endif /* CONFIG_COMPAT */
-		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
-				__FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-
-	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) <--\n", __func__,
-		__LINE__));
-
+	ret = -EINVAL;
 	return ret;
-}
+#endif
 
-static long do_ioctl_mcast_import_group(unsigned long args, bool compat_mode)
-{
-	long ret = 0;
-	struct ioc_dpa_cls_mcast_import_params kparam;
-#ifdef CONFIG_COMPAT
-	struct compat_ioc_dpa_cls_mcast_import_params uparam;
-	if (compat_mode) {
-		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: user "
-				"space args.\n", __FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-		kparam.group = compat_get_id2ptr(uparam.group,
-						FM_MAP_TYPE_PCD_NODE);
-	} else
-#endif /* CONFIG_COMPAT */
-		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("ERROR: %s, %s (%d): Read failed: user space "
-				"args.\n", __FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-#if (DPAA_VERSION >= 11)
-	ret = dpa_classif_mcast_import_group(kparam.group,
-					     &kparam.grpd);
 	if (ret < 0)
 		return ret;
-#else
-	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
-	       "platform.\n", __FILE__, __func__, __LINE__);
-	return -EINVAL;
-#endif
 
 #ifdef CONFIG_COMPAT
 	if (compat_mode) {
@@ -1701,7 +1641,8 @@ static long do_ioctl_mcast_add_member(unsigned long args, bool compat_mode)
 #else
 	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
 	       "platform.\n", __FILE__, __func__, __LINE__);
-	return -EINVAL;
+	ret = -EINVAL;
+	return ret;
 #endif
 
 #ifdef CONFIG_COMPAT
@@ -2917,6 +2858,15 @@ int dpa_cls_mcast_group_params_compatcpy(
 
 	kparam->mcast_grp_params.member_params.hmd =
 				uparam->mcast_grp_params.member_params.hmd;
+	kparam->mcast_grp_params.prefilled_members =
+				uparam->mcast_grp_params.prefilled_members;
+
+	if (uparam->mcast_grp_params.group)
+		kparam->mcast_grp_params.group = compat_get_id2ptr(
+						uparam->mcast_grp_params.group,
+						FM_MAP_TYPE_PCD_NODE);
+	else
+		kparam->mcast_grp_params.group = NULL;
 
 	return 0;
 }
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index f6d35b7..8854445 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -80,7 +80,9 @@ enum dpa_cls_tbl_action_type {
 	/* Go to another table and re-classify the packet */
 	DPA_CLS_TBL_ACTION_NEXT_TABLE,
 
-	/* Send frames to a multicast group */
+	/*
+	 * Send frames to a multicast group
+	 */
 	DPA_CLS_TBL_ACTION_MCAST
 
 };
@@ -1497,6 +1499,17 @@ struct dpa_cls_mcast_group_params {
 	 * one member
 	 */
 	struct		dpa_cls_tbl_enq_action_desc member_params;
+
+	/*
+	 * Number of members that already exist in the imported group
+	 */
+	unsigned int prefilled_members;
+
+	/*
+	 * External group handle given as input parameter for an import
+	 * operation
+	 */
+	void *group;
 };
 
 /*
@@ -1507,12 +1520,6 @@ int dpa_classif_mcast_create_group(
 		int *grpd);
 
 /*
- * Creates a multicast group based on an existing replicator returned by
- * the fmc tool
- */
-int dpa_classif_mcast_import_group(void *group, int *grpd);
-
-/*
  * Adds a new member to a multicast group
  */
 int dpa_classif_mcast_add_member(int grpd,
-- 
1.7.5.4

