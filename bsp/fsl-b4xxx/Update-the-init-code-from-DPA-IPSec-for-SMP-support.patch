From 93a6c5038e0b6264eafae95d80b8ce7d2d0bd294 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:48:05 +0000
Subject: [PATCH 161/518] Update the init code from DPA IPSec for SMP support

- added mutex for SA instance, SA structure, inbound policy
table and SA rekeying list
- initialized all mutexes

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   23 ++++++++++++++++++++---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   10 +++++++++-
 2 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index a044695..b51f2b6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -662,6 +662,8 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 	/* alloc cipher/auth stuff */
 	for (i = 0; i < sa_mng->max_num_sa; i++) {
+		mutex_init(&sa_mng->sa[i].lock);
+
 		sa_mng->sa[i].cipher_data.cipher_key =
 						 xx_zalloc(MAX_CIPHER_KEY_LEN);
 		if (!sa_mng->sa[i].cipher_data.cipher_key) {
@@ -728,10 +730,14 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			return err;
 
 		INIT_LIST_HEAD(&sa_mng->inpol_tables);
+		mutex_init(&sa_mng->inpol_tables_lock);
+
+		mutex_lock(&sa_mng->inpol_tables_lock);
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
 			pol_table = xx_zalloc(sizeof(*pol_table));
 			if (!pol_table) {
 				xx_pr_err("Could not allocate memory for policy table");
+				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return -ENOMEM;
 			}
 
@@ -740,6 +746,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			if (err < 0) {
 				xx_pr_err("Could not create cc node for EM table\n");
 				xx_free(pol_table);
+				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return err;
 			}
 			pol_table->cc_node = cc_node;
@@ -751,16 +758,19 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 				xx_pr_err("Failed create in policy table\n");
 				destroy_inpol_node(dpa_ipsec, cc_node);
 				xx_free(pol_table);
+				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return err;
 			}
 
 			list_add(&pol_table->table_list,
 				 &dpa_ipsec->sa_mng.inpol_tables);
 		}
+		mutex_unlock(&sa_mng->inpol_tables_lock);
 	}
 
-	/* Initialize the sa rekeying list of inboud SA's in rekeying process */
+	/* Initialize the SA rekeying list and its protective lock */
 	INIT_LIST_HEAD(&dpa_ipsec->sa_mng.sa_rekeying_headlist);
+	mutex_init(&sa_mng->sa_rekeying_headlist_lock);
 
 	/* Creating a single thread work queue used to defer work when there are
 	 * inbound SA's in rekeying process */
@@ -844,10 +854,13 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 
 	/* release inbound flow ID management CQ */
 	destroy_inbound_flowid_cq(dpa_ipsec->sa_mng.inbound_flowid_cq);
+	dpa_ipsec->sa_mng.inbound_flowid_cq = NULL;
 
 	/* destroy rekeying workqueue */
-	if (sa_mng->sa_rekeying_wq)
+	if (sa_mng->sa_rekeying_wq) {
 		destroy_workqueue(sa_mng->sa_rekeying_wq);
+		sa_mng->sa_rekeying_wq = NULL;
+	}
 }
 
 /* cleanup Ipsec */
@@ -2704,7 +2717,9 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 		xx_pr_err("Could not allocate memory for control block.\n");
 		return -ENOMEM;
 	}
-	gbl_dpa_ipsec = dpa_ipsec;
+
+	/* Initialize DPA IPSec instance lock */
+	mutex_init(&dpa_ipsec->lock);
 
 	/* store parameters */
 	store_ipsec_params(dpa_ipsec, params);
@@ -2728,6 +2743,8 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	       max_num_sa * sizeof(uint32_t));
 	dpa_ipsec->num_used_sas = 0;
 
+	gbl_dpa_ipsec = dpa_ipsec;
+
 	return 0;
 }
 EXPORT_SYMBOL(dpa_ipsec_init);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 008b037..f708747 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -264,9 +264,13 @@ struct dpa_ipsec_sa {
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 	uint8_t l2_hdr_size; /* Size of the Ethernet header, including any
 			      * VLAN information.			      */
+	struct mutex lock; /* Lock for this SA structure */
 };
 
-/* Parameters for inbound policy verification tables */
+/*
+ * Parameters for inbound policy verification tables
+ * Global list lock - inpol_tables_lock from SA manager
+ */
 struct inpol_tbl {
 	void *cc_node; /* Cc node handle on top of which the table is created */
 	int td;	 /* Exact match table used for inbound policy verification    */
@@ -286,6 +290,8 @@ struct dpa_ipsec_sa_mng {
 	struct list_head inpol_tables;	/* Head list of tables used for inbound
 		policy verification. List of inpol_tbl structures.
 		Populated only if inbound policy verification is enabled      */
+	struct mutex inpol_tables_lock; /* Lock for the inbound policy table
+					   list */
 	struct delayed_work sa_rekeying_work;
 	struct workqueue_struct *sa_rekeying_wq; /* Single threaded work
 				queue used to defer the work to be done in the
@@ -293,6 +299,7 @@ struct dpa_ipsec_sa_mng {
 	struct list_head sa_rekeying_headlist;	/* Head list with inbound SA's
 						   currently in the rekeying
 						   process                    */
+	struct mutex sa_rekeying_headlist_lock; /* Lock for the rekeying list */
 };
 
 /* DPA IPSEC - Control Block */
@@ -302,6 +309,7 @@ struct dpa_ipsec {
 	struct dpa_ipsec_sa_mng sa_mng;	/* Internal DPA IPsec SA manager      */
 	uint32_t *used_sa_ids;	/* Sa ids used by this dpa ipsec instance     */
 	int num_used_sas;  /* The current number of sa's used by this instance*/
+	struct mutex lock; /* Lock for this dpa_ipsec instance */
 };
 
 /* DPA IPSEC - Security Policy Selectors */
-- 
1.7.5.4

