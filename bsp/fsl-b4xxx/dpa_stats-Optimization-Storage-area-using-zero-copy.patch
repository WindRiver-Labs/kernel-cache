From 9f7a72e4e246a6cce2e2f6fba057f146d62f9670 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Mon, 25 Feb 2013 22:29:27 +0000
Subject: [PATCH 489/518] dpa_stats: Optimization: Storage area using "zero
 copy"

In the current implementation the transfer between the
user-application allocated storage area and the kernel
component retrieve operation is performed using
"copy_to_user"/"copy_from_user". This patch improves the performance
by using a "zero copy" approach in which the user application
allocates a DMA memory from fsl,shmem, memory that is mapped
in kernel address space. The user application can decide which method
to use for data transfer.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h |   10 ++-
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c   |   94 +++++++++++++--------
 2 files changed, 65 insertions(+), 39 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
index 5dd741c..9cf7301 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
@@ -42,7 +42,11 @@
 #include <linux/compat.h>
 
 struct ioc_dpa_stats_params {
-	struct dpa_stats_params stats_params;
+	unsigned int max_counters;
+	void *virt_stg_area;
+	uint64_t phys_stg_area;
+	bool stg_area_mapped;
+	unsigned int storage_area_len;
 	int dpa_stats_id;
 };
 
@@ -78,7 +82,9 @@ struct ioc_dpa_stats_cnts_reset_params {
 #ifdef CONFIG_COMPAT
 struct dpa_stats_compat_params {
 	unsigned int max_counters;
-	compat_uptr_t storage_area;
+	compat_uptr_t virt_stg_area;
+	uint64_t phys_stg_area;
+	bool stg_area_mapped;
 	unsigned int storage_area_len;
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 5926a34..5fcb4a4 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -228,7 +228,7 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 		memset(&ev_prm, 0,
 				sizeof(struct compat_dpa_stats_event_params));
 
-		if (event->params.bytes_written > 0) {
+		if (event->params.bytes_written > 0 && wrp_dpa_stats.k_mem) {
 			if (copy_to_user((wrp_dpa_stats.us_mem +
 					event->params.storage_area_offset),
 					(wrp_dpa_stats.k_mem +
@@ -280,7 +280,7 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 	/* Dequeue first event by using a blocking call */
 	event = wrp_dpa_stats_dequeue_event(&wrp_dpa_stats.ev_queue, 0);
 	while (event != NULL) {
-		if (event->params.bytes_written > 0) {
+		if (event->params.bytes_written > 0 && wrp_dpa_stats.k_mem) {
 			if (copy_to_user((wrp_dpa_stats.us_mem +
 					event->params.storage_area_offset),
 					(wrp_dpa_stats.k_mem +
@@ -464,25 +464,41 @@ void do_ioctl_req_done_cb(int dpa_stats_id,
 static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 {
 	struct dpa_stats_async_req_ev *async_req_ev;
+	struct dpa_stats_params params;
 	long ret = 0;
 	uint16_t i;
 
-	/* Save user-space memory area pointer */
-	wrp_dpa_stats.us_mem = prm->stats_params.storage_area;
+	/* Save user-provided parameters */
+	params.max_counters = prm->max_counters;
+	params.storage_area_len = prm->storage_area_len;
 
-	/* Allocate kernel-space memory area to use for storing the statistics*/
-	prm->stats_params.storage_area = kzalloc(
-			prm->stats_params.storage_area_len, GFP_KERNEL);
-	if (!prm->stats_params.storage_area) {
-		pr_err("Could not allocate kernel storage area\n");
-		return -ENOMEM;
-	}
+	if (prm->stg_area_mapped) {
+		/* Storage area is mapped, obtain the kernel-space memory area
+		 * pointer from the physical address */
+		params.storage_area = phys_to_virt(prm->phys_stg_area);
+		if (!params.storage_area) {
+			pr_err("Invalid physical memory address\n");
+			return -EINVAL;
+		}
+		wrp_dpa_stats.k_mem = NULL;
+	} else {
+		/* Save user-space memory area pointer */
+		wrp_dpa_stats.us_mem = prm->virt_stg_area;
+
+		/* Allocate kernel-space memory to store the statistics */
+		params.storage_area = kzalloc(
+				prm->storage_area_len, GFP_KERNEL);
+		if (!params.storage_area) {
+			pr_err("Could not allocate kernel storage area\n");
+			return -ENOMEM;
+		}
 
-	/* Save kernel-space memory area pointer */
-	wrp_dpa_stats.k_mem = prm->stats_params.storage_area;
+		/* Save kernel-space memory area pointer */
+		wrp_dpa_stats.k_mem = params.storage_area;
+	}
 
 	/* Call init function */
-	ret = dpa_stats_init(&prm->stats_params, &prm->dpa_stats_id);
+	ret = dpa_stats_init(&params, &prm->dpa_stats_id);
 	if (ret < 0)
 		return ret;
 
@@ -1245,19 +1261,21 @@ static int do_ioctl_stats_get_counters(void *args)
 	/* Request was sent, release the array of counter ids */
 	kfree(prm.req_params.cnts_ids);
 
-	/* If request is synchronous copy counters values to user space */
+	/* If request is synchronous copy counters length to user space */
 	if (!prm.request_done) {
-		if (copy_to_user((wrp_dpa_stats.us_mem +
-				prm.req_params.storage_area_offset),
-				(wrp_dpa_stats.k_mem +
-				prm.req_params.storage_area_offset),
-				prm.cnts_len)) {
-			pr_err("Couldn't copy counters values to storage area\n");
-			return -EINVAL;
+		if (wrp_dpa_stats.k_mem) {
+			if (copy_to_user((wrp_dpa_stats.us_mem +
+					prm.req_params.storage_area_offset),
+					(wrp_dpa_stats.k_mem +
+					prm.req_params.storage_area_offset),
+					prm.cnts_len)) {
+				pr_err("Couldn't copy counters values to storage area\n");
+				return -EINVAL;
+			}
 		}
 
 		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			pr_err("Could not copy to user the Counter ID\n");
+			pr_err("Could not copy to user the counters length\n");
 			ret = -EINVAL;
 		}
 	}
@@ -1321,21 +1339,23 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	/* Request was sent, release the array of counter ids */
 	kfree(kprm.req_params.cnts_ids);
 
-	/* If request is synchronous copy counters values to user space */
+	/* If request is synchronous copy counters length to user space */
 	if (!kprm.request_done) {
-		if (copy_to_user((wrp_dpa_stats.us_mem +
-				kprm.req_params.storage_area_offset),
-				(wrp_dpa_stats.k_mem +
-				kprm.req_params.storage_area_offset),
-				kprm.cnts_len)) {
-			pr_err("Couldn't copy counters values to storage area\n");
-			return -EINVAL;
+		if (wrp_dpa_stats.k_mem) {
+			if (copy_to_user((wrp_dpa_stats.us_mem +
+					kprm.req_params.storage_area_offset),
+					(wrp_dpa_stats.k_mem +
+					kprm.req_params.storage_area_offset),
+					kprm.cnts_len)) {
+				pr_err("Couldn't copy counters values to storage area\n");
+				return -EINVAL;
+			}
 		}
 
 		uprm.cnts_len = kprm.cnts_len;
 
 		if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
-			pr_err("Could not copy to user the Counter ID\n");
+			pr_err("Could not copy to user the counters length\n");
 			ret = -EINVAL;
 		}
 	}
@@ -1745,11 +1765,11 @@ static void dpa_stats_init_compatcpy(struct ioc_dpa_stats_params *kparam,
 		struct compat_ioc_dpa_stats_params *uparam)
 {
 	kparam->dpa_stats_id = uparam->dpa_stats_id;
-	kparam->stats_params.max_counters = uparam->stats_params.max_counters;
-	kparam->stats_params.storage_area_len =
-				uparam->stats_params.storage_area_len;
-	kparam->stats_params.storage_area =
-				compat_ptr(uparam->stats_params.storage_area);
+	kparam->max_counters = uparam->stats_params.max_counters;
+	kparam->storage_area_len = uparam->stats_params.storage_area_len;
+	kparam->virt_stg_area = compat_ptr(uparam->stats_params.virt_stg_area);
+	kparam->phys_stg_area = uparam->stats_params.phys_stg_area;
+	kparam->stg_area_mapped = uparam->stats_params.stg_area_mapped;
 }
 
 static void dpa_stats_reass_cnt_compatcpy(struct dpa_stats_cnt_reass *kprm,
-- 
1.7.5.4

