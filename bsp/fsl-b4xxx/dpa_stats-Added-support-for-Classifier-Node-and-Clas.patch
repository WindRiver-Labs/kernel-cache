From 2959778cabb8c739aebcdfb0eb002bc79eb9e85a Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Thu, 25 Oct 2012 23:14:40 +0000
Subject: [PATCH 337/518] dpa_stats: Added support for Classifier Node and
 Classifier Table of type Hash and type Index

In the current implementation the user could only create a
Classifier Node and a Classifier Table of type Exact Match.
Support was extended also for Hash and Index types.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  301 ++++++++++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_stats.h |    1 +
 include/linux/fsl_dpa_stats.h               |   16 ++
 3 files changed, 267 insertions(+), 51 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index c939e23..3f3dcae 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -54,6 +54,24 @@ struct dpa_stats *gbl_dpa_stats;
 static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb);
 
+static int get_cnt_cls_tbl_match_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
+static int get_cnt_cls_tbl_hash_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
+static int get_cnt_cls_tbl_index_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
+static int get_cnt_ccnode_match_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
+static int get_cnt_ccnode_hash_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
+static int get_cnt_ccnode_index_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
 static void async_req_work_func(struct work_struct *work);
 
 /* check that the provided params are valid */
@@ -85,6 +103,93 @@ static int check_dpa_stats_params(const struct dpa_stats_params *params)
 	return 0;
 }
 
+static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
+		struct dpa_stats_lookup_key *entry)
+{
+	t_FmPcdCcKeyStatistics stats;
+	int err;
+
+	switch (cnt_cb->tbl_cb.type) {
+	case DPA_CLS_TBL_HASH:
+		err = FM_PCD_HashTableFindNGetKeyStatistics(entry->cc_node,
+				entry->key.size, entry->key.byte, &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Table statistics\n");
+			return -EIO;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_hash_stats;
+		break;
+	case DPA_CLS_TBL_INDEXED:
+		err = FM_PCD_MatchTableGetKeyStatistics(
+				entry->cc_node, entry->key.byte[0], &stats);
+		if (err != 0) {
+			pr_err("Invalid Classifier Table counter parameters\n");
+			return -EIO;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_index_stats;
+		break;
+	case DPA_CLS_TBL_EXACT_MATCH:
+		err = FM_PCD_MatchTableFindNGetKeyStatistics(entry->cc_node,
+				entry->key.size, entry->key.byte,
+				entry->key.mask, &stats);
+		if (err != 0) {
+			pr_err("Invalid Classifier Table counter parameters\n");
+			return -EINVAL;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_match_stats;
+		break;
+	default:
+		pr_err("Invalid table type\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
+		enum dpa_stats_classif_node_type ccnode_type,
+		struct dpa_offload_lookup_key *key)
+{
+	t_FmPcdCcKeyStatistics stats;
+	int err;
+
+	switch (ccnode_type) {
+	case DPA_STATS_CLASSIF_NODE_HASH:
+		err = FM_PCD_HashTableFindNGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node,
+				key->size, key->byte, &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Table statistics\n");
+			return -EIO;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_hash_stats;
+		break;
+	case DPA_STATS_CLASSIF_NODE_INDEXED:
+		err = FM_PCD_MatchTableGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node,
+				key->byte[0], &stats);
+		if (err != 0) {
+			pr_err("Invalid Classifier Table counter parameters\n");
+			return -EIO;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_index_stats;
+		break;
+	case DPA_STATS_CLASSIF_NODE_EXACT_MATCH:
+		err = FM_PCD_MatchTableFindNGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node, key->size, key->byte,
+				key->mask, &stats);
+		if (err != 0) {
+			pr_err("Invalid Classifier Table counter parameters\n");
+			return -EINVAL;
+		}
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_match_stats;
+		break;
+	default:
+		pr_err("Invalid table type\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
 static int get_new_cnt(struct dpa_stats *dpa_stats,
 		int *dpa_stats_cnt_id, struct dpa_stats_cnt_cb **cnt_cb)
 {
@@ -1126,7 +1231,6 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cnt_classif_tbl prm = params->classif_tbl_params;
 	struct dpa_cls_tbl_params cls_tbl;
-	t_FmPcdCcKeyStatistics stats;
 	uint32_t cnt_sel = prm.cnt_sel;
 	int err = 0, frag_stats = -1;
 
@@ -1175,16 +1279,13 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_tbl_cb->keys[0].valid = TRUE;
 	cnt_cb->members_num = 1;
 
+	/* Store DPA Classifier Table type */
+	cnt_tbl_cb->type = cls_tbl.type;
+
 	/* Check the Classifier Table counter */
-	err = FM_PCD_MatchTableFindNGetKeyStatistics(
-			cnt_tbl_cb->keys[0].cc_node,
-			cnt_tbl_cb->keys[0].key.size,
-			cnt_tbl_cb->keys[0].key.byte,
-			cnt_tbl_cb->keys[0].key.mask, &stats);
-	if (err != 0) {
-		pr_err("Invalid Classifier Table counter parameters\n");
+	err = check_tbl_cls_counter(cnt_cb, &cnt_tbl_cb->keys[0]);
+	if (err != 0)
 		return -EINVAL;
-	}
 
 	if (frag_stats) {
 		err = set_frag_manip(prm.td, &cnt_tbl_cb->keys[0]);
@@ -1215,7 +1316,6 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cnt_classif_node prm = params->classif_node_params;
-	t_FmPcdCcKeyStatistics stats;
 	int err = 0;
 
 	if (!dpa_stats) {
@@ -1241,11 +1341,8 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->members_num = 1;
 
 	/* Check the Classifier Node counter parameters */
-	err = FM_PCD_MatchTableFindNGetKeyStatistics(
-			cnt_cb->ccnode_cb.cc_node,
-			cnt_cb->ccnode_cb.keys[0].size,
-			cnt_cb->ccnode_cb.keys[0].byte,
-			cnt_cb->ccnode_cb.keys[0].mask, &stats);
+	err = check_ccnode_counter(cnt_cb,
+			prm.ccnode_type, &cnt_cb->ccnode_cb.keys[0]);
 	if (err != 0) {
 		pr_err("Invalid Classif Node counter parameters\n");
 		return -EINVAL;
@@ -1505,7 +1602,8 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
-static int set_cls_cnt_classif_tbl_pair(int td,
+static int set_cls_cnt_classif_tbl_pair(
+		struct dpa_stats_cnt_classif_tbl_cb *cnt_tbl_cb, int td,
 		const struct dpa_offload_lookup_key_pair *pair,
 		struct dpa_stats_lookup_key *lookup_key)
 {
@@ -1555,6 +1653,9 @@ static int set_cls_cnt_classif_tbl_pair(int td,
 		return -EINVAL;
 	}
 
+	/* Store DPA Classifier Table type */
+	cnt_tbl_cb->type = cls_tbl.type;
+
 	/* Store CcNode handle */
 	lookup_key->cc_node = cls_tbl.cc_node;
 
@@ -1575,7 +1676,6 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	struct dpa_stats_cls_cnt_classif_tbl prm = params->classif_tbl_params;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_cls_tbl_params cls_tbl;
-	t_FmPcdCcKeyStatistics stats;
 	uint32_t i = 0, cnt_sel = prm.cnt_sel;
 	int err = 0, frag_stats = -1;
 
@@ -1618,6 +1718,9 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			return -EINVAL;
 		}
 
+		/* Store DPA Classifier Table type */
+		cnt_tbl_cb->type = cls_tbl.type;
+
 		for (i = 0; i < params->class_members; i++) {
 			/* Store CcNode handle */
 			cnt_tbl_cb->keys[i].cc_node = cls_tbl.cc_node;
@@ -1637,16 +1740,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			}
 
 			/* Check the Classifier Table counter */
-			err = FM_PCD_MatchTableFindNGetKeyStatistics(
-					cnt_tbl_cb->keys[i].cc_node,
-					cnt_tbl_cb->keys[i].key.size,
-					cnt_tbl_cb->keys[i].key.byte,
-					cnt_tbl_cb->keys[i].key.mask,
-					&stats);
-			if (err != 0) {
-				pr_err("Invalid Classif Table parameters\n");
+			err = check_tbl_cls_counter(cnt_cb,
+					&cnt_tbl_cb->keys[i]);
+			if (err != 0)
 				return -EINVAL;
-			}
 
 			cnt_tbl_cb->keys[i].valid = TRUE;
 		}
@@ -1660,7 +1757,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				continue;
 			}
 
-			err = set_cls_cnt_classif_tbl_pair(prm.td,
+			err = set_cls_cnt_classif_tbl_pair(cnt_tbl_cb, prm.td,
 					&prm.pairs[i], &cnt_tbl_cb->keys[i]);
 			if (err != 0) {
 				pr_err("Unable to set the key pair\n");
@@ -1668,16 +1765,11 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			}
 
 			/* Check the Classifier Table counter */
-			err = FM_PCD_MatchTableFindNGetKeyStatistics(
-					cnt_tbl_cb->keys[i].cc_node,
-					cnt_tbl_cb->keys[i].key.size,
-					cnt_tbl_cb->keys[i].key.byte,
-					cnt_tbl_cb->keys[i].key.mask,
-					&stats);
-			if (err != 0) {
-				pr_err("Invalid Classif Table parameters\n");
+			err = check_tbl_cls_counter(cnt_cb,
+					&cnt_tbl_cb->keys[i]);
+			if (err != 0)
 				return -EINVAL;
-			}
+
 			cnt_tbl_cb->keys[i].valid = TRUE;
 		}
 	} else {
@@ -1721,7 +1813,6 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cls_cnt_classif_node prm = params->classif_node_params;
-	t_FmPcdCcKeyStatistics stats;
 	uint32_t i = 0;
 	int err = 0;
 
@@ -1749,11 +1840,8 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 
 		/* Check the Classifier Node counter parameters */
-		err = FM_PCD_MatchTableFindNGetKeyStatistics(
-				cnt_cb->ccnode_cb.cc_node,
-				cnt_cb->ccnode_cb.keys[i].size,
-				cnt_cb->ccnode_cb.keys[i].byte,
-				cnt_cb->ccnode_cb.keys[i].mask, &stats);
+		err = check_ccnode_counter(cnt_cb,
+				prm.ccnode_type, &cnt_cb->ccnode_cb.keys[i]);
 		if (err != 0) {
 			pr_err("Invalid Classif Node counter parameters\n");
 			return -EINVAL;
@@ -1877,6 +1965,10 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
 				pr_err("Unable to copy key descriptor\n");
 				return -EINVAL;
 			}
+			err = check_tbl_cls_counter(cnt_cb,
+					&tbl_cb->keys[member_index]);
+			if (err != 0)
+				return -EINVAL;
 		}
 	} else {
 		if (!params->pair.first_key.byte) {
@@ -1885,13 +1977,18 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
 			return 0;
 		} else {
 			tbl_cb->keys[member_index].valid = TRUE;
-			err = set_cls_cnt_classif_tbl_pair(tbl_cb->td,
+			err = set_cls_cnt_classif_tbl_pair(tbl_cb, tbl_cb->td,
 					&params->pair,
 					&tbl_cb->keys[member_index]);
 			if (err != 0) {
 				pr_err("Unable to configure the key pair\n");
 				return -EINVAL;
 			}
+
+			err = check_tbl_cls_counter(cnt_cb,
+					&tbl_cb->keys[member_index]);
+			if (err != 0)
+				return -EINVAL;
 		}
 	}
 
@@ -2114,7 +2211,7 @@ static int get_cnt_plcr_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
-static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
+static int get_cnt_cls_tbl_match_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb)
 {
 	t_FmPcdCcKeyStatistics stats;
@@ -2147,6 +2244,71 @@ static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_cls_tbl_hash_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->members_num; i++) {
+		if (!cnt_cb->tbl_cb.keys[i].valid) {
+			/* Write the memory location */
+			memset(req_cb->request_area, 0,
+				cnt_cb->info.stats_num * STATS_VAL_SIZE);
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE *
+					cnt_cb->info.stats_num;
+			continue;
+		}
+		err = FM_PCD_HashTableFindNGetKeyStatistics(
+				cnt_cb->tbl_cb.keys[i].cc_node,
+				cnt_cb->tbl_cb.keys[i].key.size,
+				cnt_cb->tbl_cb.keys[i].key.byte,
+				&stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Table statistics\n");
+			return -EIO;
+		}
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
+	}
+
+	return 0;
+}
+
+static int get_cnt_cls_tbl_index_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->members_num; i++) {
+		if (!cnt_cb->tbl_cb.keys[i].valid) {
+			/* Write the memory location */
+			memset(req_cb->request_area, 0,
+				cnt_cb->info.stats_num * STATS_VAL_SIZE);
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE *
+					cnt_cb->info.stats_num;
+			continue;
+		}
+		err = FM_PCD_MatchTableGetKeyStatistics(
+				cnt_cb->tbl_cb.keys[i].cc_node,
+				cnt_cb->tbl_cb.keys[i].key.byte[0],
+				&stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Table statistics\n");
+			return -EIO;
+		}
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
+	}
+
+	return 0;
+}
+
 static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb)
 {
@@ -2180,7 +2342,7 @@ static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
-static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
+static int get_cnt_ccnode_match_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb)
 {
 	t_FmPcdCcKeyStatistics stats;
@@ -2198,10 +2360,51 @@ static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
 			return -ENXIO;
 		}
 
-		get_cnt_32bit_stats(req_cb,
-				&cnt_cb->info, (void *)&stats, i);
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, (void *)&stats, i);
 	}
+	return 0;
+}
 
+static int get_cnt_ccnode_hash_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->members_num; i++) {
+		err = FM_PCD_HashTableFindNGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node,
+				cnt_cb->ccnode_cb.keys[i].size,
+				cnt_cb->ccnode_cb.keys[i].byte, &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Node statistics\n");
+			return -ENXIO;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, (void *)&stats, i);
+	}
+	return 0;
+}
+
+static int get_cnt_ccnode_index_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->members_num; i++) {
+		err = FM_PCD_MatchTableGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node,
+				cnt_cb->ccnode_cb.keys[i].byte[0], &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Node statistics\n");
+			return -ENXIO;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, (void *)&stats, i);
+	}
 	return 0;
 }
 
@@ -2417,7 +2620,6 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
-		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 
 		err = set_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
@@ -2427,7 +2629,6 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
-		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 
 		err = set_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
@@ -2562,7 +2763,6 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
-		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 
 		err = set_cls_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
@@ -2572,7 +2772,6 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
-		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 
 		err = set_cls_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index e7de776..c03c27b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -114,6 +114,7 @@ struct dpa_stats_lookup_key {
 /* DPA Stats Classif Table control block */
 struct dpa_stats_cnt_classif_tbl_cb {
 	int td; /* Table descriptor */
+	enum dpa_cls_tbl_type type; /* The type of the DPA Classifier table */
 	struct dpa_stats_lookup_key keys[MAX_NUM_OF_MEMBERS]; /* Array of
 			 key descriptors for which to provide statistics */
 };
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 943c4f9..d2b5ab1 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -396,6 +396,16 @@ struct dpa_stats_cnt_classif_tbl {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Classification Node Type */
+enum dpa_stats_classif_node_type {
+	/* Classification Node type HASH */
+	DPA_STATS_CLASSIF_NODE_HASH = 0,
+	/* Classification Node type Indexed */
+	DPA_STATS_CLASSIF_NODE_INDEXED,
+	/* Classification Node type Exact match */
+	DPA_STATS_CLASSIF_NODE_EXACT_MATCH
+};
+
 /* DPA Stats Classification Node parameters */
 struct dpa_stats_cnt_classif_node {
 	/*
@@ -405,6 +415,9 @@ struct dpa_stats_cnt_classif_node {
 	 */
 	void *cc_node;
 
+	/* The type of FMAN Classification Node */
+	enum dpa_stats_classif_node_type ccnode_type;
+
 	/* Key to identify a specific entry */
 	struct dpa_offload_lookup_key key;
 
@@ -600,6 +613,9 @@ struct dpa_stats_cls_cnt_classif_node {
 	 */
 	void *cc_node;
 
+	/* The type of FMAN Classification Node */
+	enum dpa_stats_classif_node_type ccnode_type;
+
 	/* Array of keys to identify specific entries */
 	struct dpa_offload_lookup_key *keys;
 
-- 
1.7.5.4

