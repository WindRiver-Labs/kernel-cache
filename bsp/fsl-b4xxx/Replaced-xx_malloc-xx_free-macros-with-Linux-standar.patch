From 366c13901d56975269de13e6421f7f54a30b030d Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:15:12 +0000
Subject: [PATCH 214/518] Replaced xx_malloc/xx_free macros with Linux
 standard functions

replaced in the DPA IPSec code the allocation macros with
standard Linux functions.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   93 +++++++++++++--------------
 1 files changed, 46 insertions(+), 47 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index f21b846..8b43bc0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -562,6 +562,7 @@ static void put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 {
 	struct dpa_ipsec_sa_mng *sa_mng;
+	struct dpa_ipsec_sa *sa;
 	int i = 0, err;
 
 	BUG_ON(!dpa_ipsec);
@@ -585,43 +586,46 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	}
 
 	/* alloc SA array */
-	sa_mng->sa = xx_zalloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
-	if (!sa_mng->sa) {
+	sa = kzalloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa), GFP_KERNEL);
+	if (!sa) {
 		pr_err("Could not allocate memory for SAs\n");
 		return -ENOMEM;
 	}
+	sa_mng->sa = sa;
 
 	/* alloc cipher/auth stuff */
 	for (i = 0; i < sa_mng->max_num_sa; i++) {
 		mutex_init(&sa_mng->sa[i].lock);
 
-		sa_mng->sa[i].cipher_data.cipher_key =
-						 xx_zalloc(MAX_CIPHER_KEY_LEN);
-		if (!sa_mng->sa[i].cipher_data.cipher_key) {
+		sa[i].cipher_data.cipher_key =
+					kzalloc(MAX_CIPHER_KEY_LEN, GFP_KERNEL);
+		if (!sa[i].cipher_data.cipher_key) {
 			pr_err("Could not allocate memory for cipher key\n");
 			return -ENOMEM;
 		}
 
-		sa_mng->sa[i].auth_data.auth_key = xx_zalloc(MAX_AUTH_KEY_LEN);
-		if (!sa_mng->sa[i].auth_data.auth_key) {
+		sa[i].auth_data.auth_key =
+					kzalloc(MAX_AUTH_KEY_LEN, GFP_KERNEL);
+		if (!sa[i].auth_data.auth_key) {
 			pr_err("Could not allocate memory for authentication key\n");
 			return -ENOMEM;
 		}
 
-		sa_mng->sa[i].auth_data.split_key = xx_zalloc(MAX_AUTH_KEY_LEN);
-		if (!sa_mng->sa[i].auth_data.split_key) {
+		sa[i].auth_data.split_key =
+					kzalloc(MAX_AUTH_KEY_LEN, GFP_KERNEL);
+		if (!sa[i].auth_data.split_key) {
 			pr_err("Could not allocate memory for authentication split key\n");
 			return -ENOMEM;
 		}
 
-		sa_mng->sa[i].from_sec_fq = xx_zalloc(sizeof(struct qman_fq));
-		if (!sa_mng->sa[i].from_sec_fq) {
+		sa[i].from_sec_fq = kzalloc(sizeof(struct qman_fq), GFP_KERNEL);
+		if (!sa[i].from_sec_fq) {
 			pr_err("Can't allocate space for 'from SEC FQ'\n");
 			return -ENOMEM;
 		}
 
-		sa_mng->sa[i].to_sec_fq = xx_zalloc(sizeof(struct qman_fq));
-		if (!sa_mng->sa[i].to_sec_fq) {
+		sa[i].to_sec_fq = kzalloc(sizeof(struct qman_fq), GFP_KERNEL);
+		if (!sa[i].to_sec_fq) {
 			pr_err("Can't allocate space for 'to SEC FQ'\n");
 			return -ENOMEM;
 		}
@@ -639,7 +643,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		/* Initialize the policy parameter list which will hold all
 		 * inbound or outbound policy parameters which were use to
 		 * generate PCD entries */
-		INIT_LIST_HEAD(&sa_mng->sa[i].policy_headlist);
+		INIT_LIST_HEAD(&sa[i].policy_headlist);
 	}
 
 	err = create_inbound_flowid_cq(dpa_ipsec);
@@ -663,7 +667,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 		mutex_lock(&sa_mng->inpol_tables_lock);
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
-			pol_table = xx_zalloc(sizeof(*pol_table));
+			pol_table = kzalloc(sizeof(*pol_table), GFP_KERNEL);
 			if (!pol_table) {
 				pr_err("Could not allocate memory for policy table");
 				mutex_unlock(&sa_mng->inpol_tables_lock);
@@ -674,7 +678,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			err = create_inpol_node(dpa_ipsec, &cc_node);
 			if (err < 0) {
 				pr_err("Could not create cc node for EM table\n");
-				xx_free(pol_table);
+				kfree(pol_table);
 				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return err;
 			}
@@ -686,7 +690,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			if (err < 0) {
 				pr_err("Failed create in policy table\n");
 				destroy_inpol_node(dpa_ipsec, cc_node);
-				xx_free(pol_table);
+				kfree(pol_table);
 				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return err;
 			}
@@ -739,39 +743,34 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 			destroy_inpol_cls_tbl(pol_tbl->td);
 			list_del(&pol_tbl->table_list);
 			destroy_inpol_node(dpa_ipsec, pol_tbl->cc_node);
-			xx_free(pol_tbl);
+			kfree(pol_tbl);
 		}
 	}
 
 	/* dealloc cipher/auth stuff */
 	if (sa_mng->sa) {
 		for (i = 0; i < sa_mng->max_num_sa; i++) {
-			if (sa_mng->sa[i].cipher_data.cipher_key) {
-				xx_free(sa_mng->sa[i].cipher_data.cipher_key);
-				sa_mng->sa[i].cipher_data.cipher_key = NULL;
-			}
-			if (sa_mng->sa[i].auth_data.auth_key) {
-				xx_free(sa_mng->sa[i].auth_data.auth_key);
-				sa_mng->sa[i].auth_data.auth_key = NULL;
-			}
-			if (sa_mng->sa[i].auth_data.split_key) {
-				xx_free(sa_mng->sa[i].auth_data.split_key);
-				sa_mng->sa[i].auth_data.split_key = NULL;
-			}
-			if (sa_mng->sa[i].from_sec_fq) {
-				xx_free(sa_mng->sa[i].from_sec_fq);
-				sa_mng->sa[i].from_sec_fq = NULL;
-			}
-			if (sa_mng->sa[i].to_sec_fq) {
-				xx_free(sa_mng->sa[i].to_sec_fq);
-				sa_mng->sa[i].to_sec_fq = NULL;
-			}
+			kfree(sa_mng->sa[i].cipher_data.cipher_key);
+			sa_mng->sa[i].cipher_data.cipher_key = NULL;
+
+			kfree(sa_mng->sa[i].auth_data.auth_key);
+			sa_mng->sa[i].auth_data.auth_key = NULL;
+
+			kfree(sa_mng->sa[i].auth_data.split_key);
+			sa_mng->sa[i].auth_data.split_key = NULL;
+
+			kfree(sa_mng->sa[i].from_sec_fq);
+			sa_mng->sa[i].from_sec_fq = NULL;
+
+			kfree(sa_mng->sa[i].to_sec_fq);
+			sa_mng->sa[i].to_sec_fq = NULL;
+
 			if (sa_mng->sa[i].sec_desc) {
 				xx_free_smart(sa_mng->sa[i].sec_desc);
 				sa_mng->sa[i].sec_desc = NULL;
 			}
 		}
-		xx_free(sa_mng->sa);
+		kfree(sa_mng->sa);
 		sa_mng->sa = NULL;
 	}
 
@@ -807,8 +806,8 @@ static void free_resources(void)
 	/* free all SA related stuff */
 	free_sa_mng(dpa_ipsec);
 
-	xx_free(dpa_ipsec->used_sa_ids);
-	xx_free(dpa_ipsec);
+	kfree(dpa_ipsec->used_sa_ids);
+	kfree(dpa_ipsec);
 	gbl_dpa_ipsec = NULL;
 }
 
@@ -2064,7 +2063,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 	BUG_ON(!policy_params);
 	BUG_ON(!policy_entry);
 
-	pol_entry = xx_zalloc(sizeof(struct dpa_ipsec_policy_entry));
+	pol_entry = kzalloc(sizeof(*pol_entry), GFP_KERNEL);
 	if (!pol_entry) {
 		pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
@@ -2182,7 +2181,7 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 	}
 
 	list_del(&policy_entry->node);
-	xx_free(policy_entry);
+	kfree(policy_entry);
 
 	return 0;
 }
@@ -2523,7 +2522,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 		return err;
 
 	/* alloc control block */
-	dpa_ipsec = (struct dpa_ipsec *)xx_zalloc(sizeof(struct dpa_ipsec));
+	dpa_ipsec = kzalloc(sizeof(*dpa_ipsec), GFP_KERNEL);
 	if (!dpa_ipsec) {
 		pr_err("Could not allocate memory for control block.\n");
 		return -ENOMEM;
@@ -2544,7 +2543,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 
 	/* Init used sa vector */
 	max_num_sa = dpa_ipsec->sa_mng.max_num_sa;
-	dpa_ipsec->used_sa_ids = xx_malloc(max_num_sa * sizeof(uint32_t));
+	dpa_ipsec->used_sa_ids = kmalloc(max_num_sa * sizeof(u32), GFP_KERNEL);
 	if (!dpa_ipsec->used_sa_ids) {
 		pr_err("No more memory for used sa id's vector ");
 		free_resources();
@@ -3121,14 +3120,14 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			pr_err("Could not add the inbound policy\n");
-			xx_free(policy_entry);
+			kfree(policy_entry);
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		ret = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			pr_err("Could not add the outbound policy\n");
-			xx_free(policy_entry);
+			kfree(policy_entry);
 		}
 	}
 
-- 
1.7.5.4

