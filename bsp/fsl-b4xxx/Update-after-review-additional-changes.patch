From 1060770f1998f0a87a7b46a3d2f85ab95a64b751 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Thu, 1 Mar 2012 16:38:03 +0000
Subject: [PATCH 101/518] Update after review + additional changes

General code optimization and cleanup in fsl_dpa_offload/dpa_ipsec.c
    - minor cosmetics and bug fixing
    - refactor dpa_ipsec_remove_sa "to tell a story"
    - implemented dpa_ipsec_sa_flush_policies used by dpa_ipsec_remove_sa
    - created homologous function for get_new_sa (put_sa) used to recycle SAs
    - removed unnecessary list_empty checks.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  317 +++++++++++++--------------
 1 files changed, 156 insertions(+), 161 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 536ab96..21db189 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -727,7 +727,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 		/* calculate key size for policy verification tables */
 		err = calc_in_pol_key_size(dpa_ipsec,
-				&dpa_ipsec->sa_mng.inpol_key_size);
+					   &dpa_ipsec->sa_mng.inpol_key_size);
 		if (err < 0)
 			return err;
 
@@ -754,6 +754,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 						   &pol_table->td);
 			if (err < 0) {
 				xx_pr_err(("Failed create in policy table\n"));
+				destroy_inpol_node(dpa_ipsec, cc_node);
 				xx_free(pol_table);
 				return err;
 			}
@@ -935,7 +936,7 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 }
 
 static int fill_policy_key(int td,
-			   struct dpa_ipsec_policy_selectors *policy_selectors,
+			   struct dpa_ipsec_policy_selectors *pol_sel,
 			   uint8_t key_fields,
 			   uint8_t *key, uint8_t *mask, uint8_t *key_len)
 {
@@ -944,7 +945,7 @@ static int fill_policy_key(int td,
 	int err = 0, i;
 
 	/* sanity checks */
-	if (!policy_selectors) {
+	if (!pol_sel) {
 		xx_pr_err(("Invalid argument: NULL policy selectors\n"));
 		return -EFAULT;
 	}
@@ -970,32 +971,32 @@ static int fill_policy_key(int td,
 		switch (key_fields & field_mask) {
 		case DPA_IPSEC_KEY_FIELD_SIP:
 			memcpy(key + offset,
-			       IP_ADDR(policy_selectors->src_addr),
-			       IP_ADDR_LEN(policy_selectors->src_addr));
+			       IP_ADDR(pol_sel->src_addr),
+			       IP_ADDR_LEN(pol_sel->src_addr));
 			err = set_ip_addr_mask(mask + offset,
-				policy_selectors->src_prefix_len,
-				IP_ADDR_LEN(policy_selectors->src_addr));
+					       pol_sel->src_prefix_len,
+					       IP_ADDR_LEN(pol_sel->src_addr));
 			if (err < 0)
 				return err;
-			offset += IP_ADDR_LEN(policy_selectors->src_addr);
+			offset += IP_ADDR_LEN(pol_sel->src_addr);
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DIP:
 			memcpy(key + offset,
-			       IP_ADDR(policy_selectors->dest_addr),
-			       IP_ADDR_LEN(policy_selectors->dest_addr));
+			       IP_ADDR(pol_sel->dest_addr),
+			       IP_ADDR_LEN(pol_sel->dest_addr));
 			err = set_ip_addr_mask(mask + offset,
-				policy_selectors->dest_prefix_len,
-				IP_ADDR_LEN(policy_selectors->dest_addr));
+					       pol_sel->dest_prefix_len,
+					       IP_ADDR_LEN(pol_sel->dest_addr));
 			if (err < 0)
 				return err;
-			offset += IP_ADDR_LEN(policy_selectors->dest_addr);
+			offset += IP_ADDR_LEN(pol_sel->dest_addr);
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_PROTO:
-			if (policy_selectors->protocol) {
+			if (pol_sel->protocol) {
 				SET_IP_PROTO_IN_KEY(key, offset,
-						    policy_selectors->protocol);
+						    pol_sel->protocol);
 				SET_IP_PROTO_MASK(mask, offset, 0xFF);
 			} else {
 				/* ignore protocol field */
@@ -1007,30 +1008,30 @@ static int fill_policy_key(int td,
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_SPORT:
-			switch (policy_selectors->protocol) {
+			switch (pol_sel->protocol) {
 			case IPPROTO_TCP:
 			case IPPROTO_UDP:
 			case IPPROTO_SCTP:
 				memcpy(key + offset,
-				      (uint8_t *) &(policy_selectors->src_port),
+				       (uint8_t *) &(pol_sel->src_port),
 				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-					       policy_selectors->src_port_mask);
+						 pol_sel->src_port_mask);
 				offset += PORT_FIELD_LEN;
 				break;
 			}
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DPORT:
-			switch (policy_selectors->protocol) {
+			switch (pol_sel->protocol) {
 			case IPPROTO_TCP:
 			case IPPROTO_UDP:
 			case IPPROTO_SCTP:
 				memcpy(key + offset,
-				     (uint8_t *) &(policy_selectors->dest_port),
-				      PORT_FIELD_LEN);
+				       (uint8_t *) &(pol_sel->dest_port),
+				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-					      policy_selectors->dest_port_mask);
+						 pol_sel->dest_port_mask);
 				offset += PORT_FIELD_LEN;
 				break;
 			}
@@ -1117,10 +1118,8 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	pcd_manip_params.fragOrReasm = TRUE;
 	frag_param->frag = TRUE;
 	frag_param->hdr  = HEADER_TYPE_IPv4;
-	frag_param->ipFragParams.sizeForFragmentation =
-					policy_entry->mtu;
-	frag_param->ipFragParams.scratchBpid =
-				dpa_ipsec->config.ipf_bpid;
+	frag_param->ipFragParams.sizeForFragmentation = policy_entry->mtu;
+	frag_param->ipFragParams.scratchBpid = dpa_ipsec->config.ipf_bpid;
 	frag_param->ipFragParams.dontFragAction =
 			pcd_df_action[policy_entry->df_action];
 	*hm = FM_PCD_ManipSetNode(dpa_ipsec->config.fm_pcd,
@@ -1134,7 +1133,7 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 }
 
 static int destroy_frag_manip(struct dpa_ipsec *dpa_ipsec,
-				      struct dpa_cls_tbl_header_manip *hm)
+			      struct dpa_cls_tbl_header_manip *hm)
 {
 	t_Error fmd_err;
 
@@ -1150,7 +1149,7 @@ static int destroy_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	}
 
 	fmd_err = FM_PCD_ManipDeleteNode(dpa_ipsec->config.fm_pcd,
-			(t_Handle)hm);
+					 (t_Handle)hm);
 	if (fmd_err != E_OK) {
 		xx_pr_fmd_err(fmd_err, "FM_PCD_ManipDeleteNode");
 		return -EBUSY;
@@ -1309,7 +1308,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-			qman_fq_fqid((sa->to_sec_fq)), hm);
+				    qman_fq_fqid((sa->to_sec_fq)), hm);
 
 		/* Store the header manipulation into the policy entry */
 		policy_entry->hm = hm;
@@ -1335,14 +1334,13 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 				xx_pr_err(("Couldn't delete frag manip\n"));
 				return err;
 			}
-
 		}
-
 		break;
 	case MNG_OP_MODIFY:
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-			qman_fq_fqid((sa->to_sec_fq)), policy_entry->hm);
+				    qman_fq_fqid((sa->to_sec_fq)),
+				    policy_entry->hm);
 
 		memset(&params, 0, sizeof(params));
 		params.type = DPA_CLS_TBL_MODIFY_ACTION;
@@ -1704,7 +1702,6 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	phys_addr_t addr;
 	struct dpa_ipsec *dpa_ipsec;
 	uint32_t fqid_from_sec = 0, fqid_to_sec = 0;
-	uint16_t qm_tx_ch, flow_id;
 	int err;
 
 	/* sanity checks */
@@ -1730,31 +1727,30 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	ctxtA_hi = (uint32_t) (addr >> 32);
 	ctxtA_lo = (uint32_t) (addr);
 
-	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		qm_tx_ch = dpa_ipsec->config.post_sec_out_params.qm_tx_ch;
-		flow_id = sa->outbound_flowid;
-	} else {
-		qm_tx_ch = dpa_ipsec->config.post_sec_in_params.qm_tx_ch;
-		flow_id = sa->inbound_flowid;
-	}
-
-
 	/* If reuse FROM SEC FQ is false than create other FROM SEC FQ
 	 * and set it as output frame queue for this SA. Otherwise
 	 * profit that you poses a valid FROM SEC FQ from the OLD SA
 	 * and use it accordingly.
 	 */
 	if (!reuse_from_secfq) {
+		uint16_t chan, flow_id;
 		/* acquire fqid for 'FROM SEC' fq */
 		err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
 		if (err < 0)
 			return err;
 
+		if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
+			chan = dpa_ipsec->config.post_sec_out_params.qm_tx_ch;
+			flow_id = sa->outbound_flowid;
+		} else {
+			chan = dpa_ipsec->config.post_sec_in_params.qm_tx_ch;
+			flow_id = sa->inbound_flowid;
+		}
+
 		err = create_sec_frame_queue(fqid_from_sec,
-				qm_tx_ch,
-				sa->sa_wqid, 0, 0, /* ctxA */
-				flow_id, /*ctxB forwarding info*/
-				FALSE, sa->from_sec_fq);
+					     chan, sa->sa_wqid, 0, 0, /* ctxA */
+					     flow_id, /*ctxB forwarding info*/
+					     FALSE, sa->from_sec_fq);
 		if (err < 0) {
 			xx_pr_err(("From SEC FQ couldn't be created\n"));
 			goto create_fq_pair_err;
@@ -2067,7 +2063,7 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 				struct dpa_ipsec_policy_entry **policy_entry)
 {
 	struct dpa_ipsec_policy_entry *pol_entry, *tmp_policy_entry;
-	struct dpa_ipsec_policy_selectors policy_selectors;
+	struct dpa_ipsec_policy_selectors pol_sel;
 
 	/* sanity checks */
 	if (!sa) {
@@ -2090,14 +2086,12 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 		return -EDOM;
 	}
 
+	copy_policy_selectors(policy_params, &pol_sel);
 	list_for_each_entry_safe(pol_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
-		copy_policy_selectors(policy_params, &policy_selectors);
-		if (!memcmp(&pol_entry->policy_selectors,
-			    &policy_selectors,
-			    sizeof(struct dpa_ipsec_policy_selectors))) {
-			/* found the entry that matches the input policy
-			 * parameters */
+		if (!memcmp(&pol_entry->policy_selectors, &pol_sel,
+			    sizeof(pol_sel))) {
+			/* found entry matching the input policy parameters */
 			*policy_entry = pol_entry;
 			return 0;
 		}
@@ -2113,7 +2107,7 @@ static inline int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
 	int pol_count = 0;
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err(("Policy parameter list is empty\n"));
+		xx_pr_debug(("Policy parameter list is empty\n"));
 		return 0;
 	}
 
@@ -2369,7 +2363,7 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 	 * and call here that function */
 	sa->id = id;
 	sa->used_sa_index = i;
-	dpa_ipsec->used_sa_ids[i] = sa->id;
+	dpa_ipsec->used_sa_ids[sa->used_sa_index] = sa->id;
 	dpa_ipsec->num_used_sas++;
 
 	*sa_id = id;
@@ -2378,6 +2372,27 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 	return 0;
 }
 
+static int put_sa(struct dpa_ipsec_sa *sa)
+{
+	struct dpa_ipsec *dpa_ipsec;
+	struct dpa_ipsec_sa_mng *sa_mng;
+	int err;
+
+	dpa_ipsec = sa->dpa_ipsec;
+	sa_mng = &dpa_ipsec->sa_mng;
+
+	/* Mark as free index in used SA IDs vector of this DPA IPSEC instance*/
+	dpa_ipsec->used_sa_ids[sa->used_sa_index] = DPA_IPSEC_INVALID_SA_ID;
+	dpa_ipsec->num_used_sas--;
+	err = cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
+	if (err < 0) {
+		xx_pr_err(("Could not release the sa id %d\n", sa->id));
+		return -EDOM;
+	}
+	sa->used_sa_index = -1;
+	return 0;
+}
+
 static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 {
 	int err_rb;
@@ -2419,7 +2434,8 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 	}
 
 	/* Free the SA id and FlowID (for inbound SAs only).*/
-	put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->inbound_flowid >= 0)
+		put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
 	if (sa->used_sa_index != -1) {
 		sa->dpa_ipsec->used_sa_ids[sa->used_sa_index] =
 					DPA_IPSEC_INVALID_SA_ID;
@@ -2428,7 +2444,6 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 	}
 	cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
 
-
 	return 0;
 }
 
@@ -2613,7 +2628,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			err = dpa_classif_table_insert_entry(inbindx_td,
 						&inbindx_key,
 						&action, 0,
-						       &sa->inbound_indx_entry);
+						&sa->inbound_indx_entry);
 			if (err < 0) {
 				xx_pr_err(("Can't link EM table with index table\n"));
 				goto create_sa_err;
@@ -2662,20 +2677,25 @@ EXPORT_SYMBOL_GPL(dpa_ipsec_create_sa);
 /*
  * The steps implemented here are:
  * 1. Remove the PCD entries that make traffic to go to SEC
- * 2. Wait in order to consume all frames in
- *    the TO_SEC queue and to be correctly distributed by the PCD entries
- *    that reside in the offline port post SEC.
- * 3. Remove all the PCD entries from the offline port post SEC
- * 4. Destroy the TO_SEC and FROM_SEC queues
- * 5. Free all memory used for this SA
+ * 2. Wait until SEC consumes the frames in the TO_SEC queue of this SA
+ * 3. Wait until FROM_SEC queue gets empty, frames are distributed by the post
+ *    SEC offline port according to its PCD entries
+ * 4. Remove the TO_SEC queue
+ * 5. Remove the FROM_SEC queue if:
+ *	this SA is not a rekeyed SA
+ *	the rekeying process has been completed i.e TO_SEC queue is scheduled
+ * 6. Remove all the PCD entries from the post SEC offline port
+ *	special case for inbound SA with policy check enabled:
+ *		- flush all policies
+ *		- detach the Exact Match Table from the Index Table
+ * 7. Free all memory used for this SA i.e recycle this SA
  */
 int dpa_ipsec_remove_sa(int sa_id)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *sa;
-	struct dpa_ipsec_policy_entry *pol_entr, *tmp_pol_entr;
-	int timeout = 10000, err = 0;
+	int err = 0;
 
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
@@ -2687,12 +2707,11 @@ int dpa_ipsec_remove_sa(int sa_id)
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err(("Invalid SA handle\n"));
+		xx_pr_err(("Invalid SA handle for sa id %d\n", sa_id));
 		return -EINVAL;
 	}
 
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
-		int td;
 		/* Remove the PCD entry that makes traffic to go to SEC
 		 * First check that we have a valid entry reference.
 		 * In case previous add/remove operations failed, this entry
@@ -2706,27 +2725,6 @@ int dpa_ipsec_remove_sa(int sa_id)
 			}
 		}
 
-		/* AV's note: Wait until all the frames from the TO_SEC FQ are
-		 * consumed */
-		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
-		if (err < 0) {
-			/* AV's note: TODO Add this SA to the SA garbage
-			 * collector list because we can't remove it until
-			 *  it's to SEC FQ is empty. */
-			return err;
-		}
-
-		/* AV's note: Wait until all the frames from the FROM_SEC FQ are
-		 * consumed */
-		timeout = 10000;
-		err = wait_until_fq_empty(sa->from_sec_fq, timeout);
-		if (err < 0) {
-			/* AV's note: TODO Add this SA to the SA garbage
-			 * collector list because we can't remove it until it's
-			 * to SEC FQ is empty. */
-			return err;
-		}
-
 		/* Destroy the TO_SEC and FROM_SEC queues */
 		err = remove_sa_fq_pair(sa);
 		if (err != 0) {
@@ -2734,62 +2732,45 @@ int dpa_ipsec_remove_sa(int sa_id)
 			return err;
 		}
 
-		/* Free all memory used for this SA */
-		td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
-		if ((dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE)
-		    && (sa->inbound_indx_entry != -1)) {
-			/* Remove all the PCD entries from the offline port
-			 * post SEC */
-			if (!list_empty(&sa->policy_headlist)) {
-				list_for_each_entry_safe(pol_entr, tmp_pol_entr,
-						&sa->policy_headlist, node) {
-					err = remove_policy(sa, pol_entr);
-					if (err < 0) {
-						xx_pr_err(("Couldn't remove policy entry"));
-						return err;
-					}
-				}
+		/* Flush policy if policy check is enabled */
+		if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+			err = dpa_ipsec_sa_flush_policies(sa->id);
+			if (err < 0) {
+				xx_pr_err(("Couldn't flush inbound policies"));
+				return err;
 			}
+		}
+
+		/* Remove the flow id classification after decrypt */
+		if (sa->inbound_indx_entry != -1) {
+			int td;
+			td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
 			err = dpa_classif_table_delete_entry_by_ref(td,
 							sa->inbound_indx_entry);
 			if (err < 0) {
 				xx_pr_err(("Could not remove SA entry in indexed table\n"));
 				return err;
 			}
-			put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
-		} else {
-			if (sa->inbound_indx_entry != -1) {
-				err = dpa_classif_table_delete_entry_by_ref(td,
-							sa->inbound_indx_entry);
-				if (err < 0) {
-					xx_pr_err(("Could not remove SA entry in indexed table\n"));
-					return err;
-				}
-			}
-		}
-
-		if (sa->inbound_indx_entry != -1)
+			if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
+				put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
 			put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
-		sa->inbound_indx_entry = -1;
+			sa->inbound_indx_entry = -1;
+		}
 
-		/* Mark as free index in used sa ids vector of this dpa ipsec
-		 * instance */
-		dpa_ipsec->used_sa_ids[sa->used_sa_index] =
-						DPA_IPSEC_INVALID_SA_ID;
-		dpa_ipsec->num_used_sas--;
-		cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
+		/* Mark SA as free */
+		err = put_sa(sa);
+		if (err < 0) {
+			xx_pr_err(("Could not recycle the sa with id %d\n",
+				  sa->id));
+			return err;
+		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
-		/* Remove the PCD entries that make traffic to go to SEC */
-		if (!list_empty(&sa->policy_headlist)) {
-			list_for_each_entry_safe(pol_entr,
-						 tmp_pol_entr,
-						 &sa->policy_headlist, node) {
-				err = remove_policy(sa, pol_entr);
-				if (err < 0) {
-					xx_pr_err(("Could not remove policy PCD entry\n"));
-					return err;
-				}
-			}
+		/* Flush policies in order to remove the PCD entries that direct
+		 * traffic to SEC */
+		err = dpa_ipsec_sa_flush_policies(sa->id);
+		if (err < 0) {
+			xx_pr_err(("Could not flush outbound policies\n"));
+			return err;
 		}
 
 		/* Destroy the TO_SEC and FROM_SEC queues */
@@ -2799,13 +2780,13 @@ int dpa_ipsec_remove_sa(int sa_id)
 			return err;
 		}
 
-		/* Mark as free index in used sa ids vector of this dpa ipsec
-		 * instance */
-		dpa_ipsec->used_sa_ids[sa->used_sa_index] =
-						DPA_IPSEC_INVALID_SA_ID;
-		dpa_ipsec->num_used_sas--;
-		/* Free all memory used for this SA */
-		cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
+		/* Mark SA as free */
+		err = put_sa(sa);
+		if (err < 0) {
+			xx_pr_err(("Could not recycle the sa with id %d\n",
+				  sa->id));
+			return err;
+		}
 	}
 
 	return 0;
@@ -2870,7 +2851,7 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 	int err = 0;
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid policy params handle\n"));
+		xx_pr_err(("Invalid policy parameters handle\n"));
 		return -EINVAL;
 	}
 
@@ -2880,8 +2861,7 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 		return -EINVAL;
 	}
 
-	err = find_policy_in_sa_policy_list(sa, policy_params,
-				&policy_entry);
+	err = find_policy_in_sa_policy_list(sa, policy_params, &policy_entry);
 	if (err < 0) {
 		xx_pr_err(("Could not find policy entry in SA policy list\n"));
 		return err;
@@ -2992,20 +2972,18 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		list_splice_init(&old_sa->policy_headlist,
 				 &new_sa->policy_headlist);
 		/* Need to update the outbound policy if we have policies */
-		if (!list_empty(&new_sa->policy_headlist)) {
-			list_for_each_entry_safe(policy_entry, tmp_policy_entry,
-						 &new_sa->policy_headlist,
-						 node) {
-				err = update_outbound_policy(new_sa,
-							     policy_entry,
-							     MNG_OP_MODIFY);
-				if (err < 0) {
-					/* Keep both SAs. Both must be removed
-					 * using remove_sa */
-					*new_sa_id = id;
-					xx_pr_err(("Could't modify outbound policy"));
-					goto rekey_sa_err;
-				}
+		list_for_each_entry_safe(policy_entry, tmp_policy_entry,
+					 &new_sa->policy_headlist,
+					 node) {
+			err = update_outbound_policy(new_sa,
+						     policy_entry,
+						     MNG_OP_MODIFY);
+			if (err < 0) {
+				/* Keep both SAs. Both must be removed
+				 * using remove_sa */
+				*new_sa_id = id;
+				xx_pr_err(("Could't modify outbound policy"));
+				goto rekey_sa_err;
 			}
 		}
 		/* AV's note: Wait until all the frames from the old TO SEC FQ
@@ -3257,7 +3235,24 @@ EXPORT_SYMBOL_GPL(dpa_ipsec_sa_get_policies);
 
 int dpa_ipsec_sa_flush_policies(int sa_id)
 {
-	xx_pr_err(("This function is currently not supported\n"));
-	return -EINVAL;
+	struct dpa_ipsec_policy_entry *pol_entr, *tmp_pol_entr;
+	struct dpa_ipsec_sa *sa;
+	int err = 0;
+
+	sa = get_sa_from_sa_id(sa_id);
+	if (!sa) {
+		xx_pr_err(("Invalid SA handle for sa id %d\n", sa_id));
+		return -EINVAL;
+	}
+
+	list_for_each_entry_safe(pol_entr, tmp_pol_entr, &sa->policy_headlist,
+				 node) {
+		err = remove_policy(sa, pol_entr);
+		if (err < 0) {
+			xx_pr_err(("Couldn't remove policy entry"));
+			return err;
+		}
+	}
+	return 0;
 }
 EXPORT_SYMBOL_GPL(dpa_ipsec_sa_flush_policies);
-- 
1.7.5.4

