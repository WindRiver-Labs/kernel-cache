From abca85bf5f46367ff77970fb7a108db63df090f3 Mon Sep 17 00:00:00 2001
From: Alexandru Badicioiu <b15898@freescale.com>
Date: Mon, 11 Mar 2013 18:19:59 +0000
Subject: [PATCH 506/518] fsl_dpa_offload : Remove obsolete use cases

Signed-off-by: Alexandru Badicioiu <b15898@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Kconfig            |    4 -
 drivers/staging/fsl_dpa_offload/Makefile           |    2 -
 .../dts/b4860qds-usdpaa-shared-interfaces.dts      |  149 +++
 .../fsl_dpa_offload/dts/b4860qds-usdpaa.dts        |  127 +++
 .../dts/p4080ds-usdpaa-shared-interfaces.dts       |  171 ++++
 .../staging/fsl_dpa_offload/dts/p4080ds-usdpaa.dts |  143 +++
 .../staging/fsl_dpa_offload/dts/p5020ds-usdpaa.dts |  129 +++
 .../staging/fsl_dpa_offload/dts/p5020si-post.dtsi  |  437 ++++++++
 drivers/staging/fsl_dpa_offload/usecases/Kconfig   |   18 -
 drivers/staging/fsl_dpa_offload/usecases/Makefile  |   18 -
 drivers/staging/fsl_dpa_offload/usecases/common.h  |   78 --
 .../staging/fsl_dpa_offload/usecases/dbgfs_ctl.c   |  164 ---
 .../staging/fsl_dpa_offload/usecases/dbgfs_ctl.h   |   57 --
 .../dts/b4860qds-usdpaa-shared-interfaces.dts      |  149 ---
 .../usecases/dts/b4860qds-usdpaa.dts               |  127 ---
 .../dts/p4080ds-usdpaa-shared-interfaces.dts       |  171 ----
 .../usecases/dts/p4080ds-usdpaa.dts                |  143 ---
 .../usecases/dts/p5020ds-usdpaa.dts                |  129 ---
 .../fsl_dpa_offload/usecases/dts/p5020si-post.dtsi |  437 --------
 .../staging/fsl_dpa_offload/usecases/fm_utils.c    |  318 ------
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |  586 -----------
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |  171 ----
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |  724 --------------
 drivers/staging/fsl_dpa_offload/usecases/main.c    |  109 --
 .../fsl_dpa_offload/usecases/platform_defs.h       |   47 -
 .../staging/fsl_dpa_offload/usecases/ports_conf.h  |   65 --
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c | 1038 --------------------
 .../staging/fsl_dpa_offload/usecases/xfrm_utils.c  |  231 -----
 28 files changed, 1156 insertions(+), 4786 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa-shared-interfaces.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa-shared-interfaces.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/p5020ds-usdpaa.dts
 create mode 100644 drivers/staging/fsl_dpa_offload/dts/p5020si-post.dtsi
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/Kconfig
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/Makefile
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/common.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa-shared-interfaces.dts
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa.dts
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa-shared-interfaces.dts
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/dts/p5020si-post.dtsi
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/main.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c

diff --git a/drivers/staging/fsl_dpa_offload/Kconfig b/drivers/staging/fsl_dpa_offload/Kconfig
index ae7be42..3b529ef 100644
--- a/drivers/staging/fsl_dpa_offload/Kconfig
+++ b/drivers/staging/fsl_dpa_offload/Kconfig
@@ -15,7 +15,3 @@ config FSL_DPA_OFFLOAD
 		To compile this driver as a module, choose M here. The module
 		will be called dpa_offload.
 
-menu "IP acceleration usecases "
-depends on FSL_DPA_OFFLOAD
-source drivers/staging/fsl_dpa_offload/usecases/Kconfig
-endmenu
diff --git a/drivers/staging/fsl_dpa_offload/Makefile b/drivers/staging/fsl_dpa_offload/Makefile
index a9da7cc..0018e9b 100644
--- a/drivers/staging/fsl_dpa_offload/Makefile
+++ b/drivers/staging/fsl_dpa_offload/Makefile
@@ -43,8 +43,6 @@ EXTRA_CFLAGS += \
 	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd \
 	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc
 
-obj-$(CONFIG_FSL_IPACC_USECASES)   += usecases/
-
 obj-$(CONFIG_FSL_DPA_OFFLOAD) += dpa_offload.o
 
 dpa_offload-objs :=  crc8.o dpa_classifier.o dpa_ipsec.o dpa_ipsec_desc.o \
diff --git a/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa-shared-interfaces.dts b/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa-shared-interfaces.dts
new file mode 100644
index 0000000..f109b76
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa-shared-interfaces.dts
@@ -0,0 +1,149 @@
+/*
+ * B4860QDS Device Tree Source
+ *
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "b4860qds.dts"
+
+/ {
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+	};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	bp10: buffer-pool@10 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <10>;
+		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
+	};
+	bp11: buffer-pool@11 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <11>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp12: buffer-pool@12 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <12>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	bp16: buffer-pool@16 {
+                        compatible = "fsl,b4860-bpool", "fsl,bpool";
+                        fsl,bpid = <16>;
+			fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
+                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+       };
+
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+		ethernet@1 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+		ethernet@2 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp16>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+
+                /* ethernet@16 declared as MAC-less interface with no "fsl,fman-mac" property.
+                 * USDPAA will seed buffers to this buffer pool and initialize 8 TX Frame
+                 * queues. The ethernet driver will initialize 8 RX default Frame queues.
+                 * On receiving frame at this interface, the ethernet driver will do
+                 * kmap_atomic/kunmap_atomic for that frame. */
+               ethernet@16 {
+                        compatible = "fsl,b4860-dpa-ethernet", "fsl,dpa-ethernet";
+                        fsl,bman-buffer-pools = <&bp16>;
+                        fsl,qman-frame-queues-rx = <4000 8>;
+                        fsl,qman-frame-queues-tx = <4008 8>;
+                        local-mac-address = [00 11 22 33 44 55];
+                };
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x6e 1 0x6f 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+                dpa_fman0_oh3: dpa-fman0-oh@3 {
+                        compatible = "fsl,dpa-oh";
+                        fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+                        fsl,bman-buffer-pools = <&bp9>;
+                        fsl,fman-oh-port = <&fman0_oh3>;
+                };
+                dpa_fman0_oh4: dpa-fman0-oh@4 {
+                        compatible = "fsl,dpa-oh";
+                        fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+                        fsl,bman-buffer-pools = <&bp9>;
+                        fsl,fman-oh-port = <&fman0_oh4>;
+                };
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa.dts
new file mode 100644
index 0000000..91c4bcb
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/b4860qds-usdpaa.dts
@@ -0,0 +1,127 @@
+/*
+ * B4860QDS Device Tree Source
+ *
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "b4860qds.dts"
+
+/ {
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+	};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	bp10: buffer-pool@10 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <10>;
+		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
+	};
+	bp11: buffer-pool@11 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <11>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp12: buffer-pool@12 {
+		compatible = "fsl,b4860-bpool", "fsl,bpool";
+		fsl,bpid = <12>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+		ethernet@1 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+		ethernet@2 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x6e 1 0x6f 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+                dpa_fman0_oh3: dpa-fman0-oh@3 {
+                        compatible = "fsl,dpa-oh";
+                        fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+                        fsl,bman-buffer-pools = <&bp9>;
+                        fsl,fman-oh-port = <&fman0_oh3>;
+                };
+                dpa_fman0_oh4: dpa-fman0-oh@4 {
+                        compatible = "fsl,dpa-oh";
+                        fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+                        fsl,bman-buffer-pools = <&bp9>;
+                        fsl,fman-oh-port = <&fman0_oh4>;
+                };
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa-shared-interfaces.dts b/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa-shared-interfaces.dts
new file mode 100644
index 0000000..038e055
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa-shared-interfaces.dts
@@ -0,0 +1,171 @@
+/*
+ * P4080DS Device Tree Source
+ *
+ * Copyright 2009-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p4080ds.dts"
+
+/ {
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+	};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp16: buffer-pool@16 {
+                        compatible = "fsl,p4080-bpool", "fsl,bpool";
+                        fsl,bpid = <16>;
+                        fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
+                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+       };
+	bp17: buffer-pool@17 {
+                        compatible = "fsl,p4080-bpool", "fsl,bpool";
+                        fsl,bpid = <17>;
+                        fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
+                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+       };
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+
+		/* ethernet@1 will be used as a normal Linux ethernet that
+		 * interfaces to the kernel network stack. All others will be
+		 * dedicated for use by usdpaa */
+
+		ethernet@2 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+		ethernet@4 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+		ethernet@6 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
+		};
+		ethernet@7 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
+			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
+		};
+		ethernet@8 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
+			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
+		};
+		/* ethernet@9 declared as shared MAC. USDPAA will seed buffers to
+		 * this buffer pool. The ethernet driver will initialize the RX default,
+		 * RX error, TX error, TX confirm and 8 TX Frame queues. On receiving frame
+		 * at this interface, the ethernet driver will do kmap_atomic/kunmap_atomic
+		 * for that frame. */
+		ethernet@9 {
+			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
+			fsl,bman-buffer-pools = <&bp17>;
+			fsl,qman-frame-queues-rx = <0x66 1 0x67 1 0x2000 3>;
+			fsl,qman-frame-queues-tx = <0 1 0 1 0x3000 8>;
+		};
+		/* ethernet@16 declared as MAC-less interface with no "fsl,fman-mac" property.
+		 * USDPAA will seed buffers to this buffer pool and initialize 8 TX Frame
+		 * queues. The ethernet driver will initialize 8 RX default Frame queues.
+		 * On receiving frame at this interface, the ethernet driver will do
+		 * kmap_atomic/kunmap_atomic for that frame. */
+		ethernet@16 {
+			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
+			fsl,bman-buffer-pools = <&bp16>;
+			fsl,qman-frame-queues-rx = <4000 8>;
+			fsl,qman-frame-queues-tx = <4008 8>;
+			local-mac-address = [00 11 22 33 44 55];
+		};
+		dpa_fman1_oh1: dpa-fman1-oh@1 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
+			fsl,fman-oh-port = <&fman1_oh1>;
+		};
+		dpa_fman1_oh2: dpa-fman1-oh@2 { /* Define frame queues for the OH port*/
+			compatible = "fsl,dpa-oh"; /* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,bman-buffer-pools = <&bp8>;
+			fsl,fman-oh-port = <&fman1_oh2>;
+		};
+		dpa_fman1_oh3: dpa-fman1-oh@3 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman1_oh3>;
+		};
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa.dts
new file mode 100644
index 0000000..da0ca0f
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/p4080ds-usdpaa.dts
@@ -0,0 +1,143 @@
+/*
+ * P4080DS Device Tree Source
+ *
+ * Copyright 2009-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p4080ds.dts"
+
+/ {
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+	};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+
+		/* ethernet@1 will be used as a normal Linux ethernet that
+		 * interfaces to the kernel network stack. All others will be
+		 * dedicated for use by usdpaa */
+
+		ethernet@2 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+		ethernet@4 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+		ethernet@5 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+		ethernet@6 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
+		};
+		ethernet@7 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
+			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
+		};
+		ethernet@8 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
+			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
+		};
+		ethernet@9 {
+			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x66 1 0x67 1>;
+			fsl,qman-frame-queues-tx = <0x86 1 0x87 1>;
+		};
+		dpa_fman1_oh1: dpa-fman1-oh@1 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
+			fsl,fman-oh-port = <&fman1_oh1>;
+		};
+		dpa_fman1_oh2: dpa-fman1-oh@2 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman1_oh2>;
+		};
+		dpa_fman1_oh3: dpa-fman1-oh@3 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman1_oh3>;
+		};
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/dts/p5020ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/dts/p5020ds-usdpaa.dts
new file mode 100644
index 0000000..eaa4657
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/p5020ds-usdpaa.dts
@@ -0,0 +1,129 @@
+/*
+ * P5020DS Device Tree Source
+ *
+ * Copyright 2010-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/include/ "p5020ds.dts"
+
+/ {
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+	};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1600 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp10: buffer-pool@10 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <10>;
+		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
+	};
+	bp11: buffer-pool@11 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <11>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp12: buffer-pool@12 {
+		compatible = "fsl,p5020-bpool", "fsl,bpool";
+		fsl,bpid = <12>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+
+	fsl,dpaa {
+		ethernet@0 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+		ethernet@1 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+		ethernet@2 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+		ethernet@3 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+		ethernet@4 {
+			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+		};
+		dpa_fman0_oh1: dpa-fman0-oh@1 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
+			fsl,fman-oh-port = <&fman0_oh1>;
+		};
+		dpa_fman0_oh2: dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+		dpa_fman0_oh3: dpa-fman0-oh@3 {
+			compatible = "fsl,dpa-oh";
+			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
+			fsl,bman-buffer-pools = <&bp9>;
+			fsl,fman-oh-port = <&fman0_oh3>;
+		};
+	};
+};
diff --git a/drivers/staging/fsl_dpa_offload/dts/p5020si-post.dtsi b/drivers/staging/fsl_dpa_offload/dts/p5020si-post.dtsi
new file mode 100644
index 0000000..4772553
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dts/p5020si-post.dtsi
@@ -0,0 +1,437 @@
+/*
+ * P5020/5010 Silicon/SoC Device Tree Source (post include)
+ *
+ * Copyright 2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&lbc {
+	compatible = "fsl,p5020-rev1.0-elbc", "simple-bus";
+	interrupts = <
+		25 2 0 0
+		16 2 1 19
+		>;
+	#address-cells = <2>;
+	#size-cells = <1>;
+};
+
+/* controller at 0x200000 */
+&pci0 {
+	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
+	device_type = "pci";
+	#size-cells = <2>;
+	#address-cells = <3>;
+	bus-range = <0x0 0xff>;
+	clock-frequency = <33333333>;
+	interrupts = <16 2 1 15>;
+	pcie@0 {
+		reg = <0 0 0 0 0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		device_type = "pci";
+		interrupts = <16 2 1 15>;
+		interrupt-map-mask = <0xf800 0 0 7>;
+		interrupt-map = <
+			/* IDSEL 0x0 */
+			0000 0 0 1 &mpic 40 1 0 0
+			0000 0 0 2 &mpic 1 1 0 0
+			0000 0 0 3 &mpic 2 1 0 0
+			0000 0 0 4 &mpic 3 1 0 0
+			>;
+	};
+};
+
+/* controller at 0x201000 */
+&pci1 {
+	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
+	device_type = "pci";
+	#size-cells = <2>;
+	#address-cells = <3>;
+	bus-range = <0 0xff>;
+	clock-frequency = <33333333>;
+	interrupts = <16 2 1 14>;
+	pcie@0 {
+		reg = <0 0 0 0 0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		device_type = "pci";
+		interrupts = <16 2 1 14>;
+		interrupt-map-mask = <0xf800 0 0 7>;
+		interrupt-map = <
+			/* IDSEL 0x0 */
+			0000 0 0 1 &mpic 41 1 0 0
+			0000 0 0 2 &mpic 5 1 0 0
+			0000 0 0 3 &mpic 6 1 0 0
+			0000 0 0 4 &mpic 7 1 0 0
+			>;
+	};
+};
+
+/* controller at 0x202000 */
+&pci2 {
+	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
+	device_type = "pci";
+	#size-cells = <2>;
+	#address-cells = <3>;
+	bus-range = <0x0 0xff>;
+	clock-frequency = <33333333>;
+	interrupts = <16 2 1 13>;
+	pcie@0 {
+		reg = <0 0 0 0 0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		device_type = "pci";
+		interrupts = <16 2 1 13>;
+		interrupt-map-mask = <0xf800 0 0 7>;
+		interrupt-map = <
+			/* IDSEL 0x0 */
+			0000 0 0 1 &mpic 42 1 0 0
+			0000 0 0 2 &mpic 9 1 0 0
+			0000 0 0 3 &mpic 10 1 0 0
+			0000 0 0 4 &mpic 11 1 0 0
+			>;
+	};
+};
+
+/* controller at 0x203000 */
+&pci3 {
+	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
+	device_type = "pci";
+	#size-cells = <2>;
+	#address-cells = <3>;
+	bus-range = <0x0 0xff>;
+	clock-frequency = <33333333>;
+	interrupts = <16 2 1 12>;
+	pcie@0 {
+		reg = <0 0 0 0 0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		device_type = "pci";
+		interrupts = <16 2 1 12>;
+		interrupt-map-mask = <0xf800 0 0 7>;
+		interrupt-map = <
+			/* IDSEL 0x0 */
+			0000 0 0 1 &mpic 43 1 0 0
+			0000 0 0 2 &mpic 0 1 0 0
+			0000 0 0 3 &mpic 4 1 0 0
+			0000 0 0 4 &mpic 8 1 0 0
+			>;
+	};
+};
+
+&rio {
+	compatible = "fsl,srio";
+	interrupts = <16 2 1 11>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+
+	port1 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		cell-index = <1>;
+	};
+
+	port2 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		cell-index = <2>;
+	};
+};
+
+&dcsr {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "fsl,dcsr", "simple-bus";
+
+	dcsr-epu@0 {
+		compatible = "fsl,dcsr-epu";
+		interrupts = <52 2 0 0
+			      84 2 0 0
+			      85 2 0 0>;
+		reg = <0x0 0x1000>;
+	};
+	dcsr-npc {
+		compatible = "fsl,dcsr-npc";
+		reg = <0x1000 0x1000 0x1000000 0x8000>;
+	};
+	dcsr-nxc@2000 {
+		compatible = "fsl,dcsr-nxc";
+		reg = <0x2000 0x1000>;
+	};
+	dcsr-corenet {
+		compatible = "fsl,dcsr-corenet";
+		reg = <0x8000 0x1000 0xB0000 0x1000>;
+	};
+	dcsr-dpaa@9000 {
+		compatible = "fsl,p5020-dcsr-dpaa", "fsl,dcsr-dpaa";
+		reg = <0x9000 0x1000>;
+	};
+	dcsr-ocn@11000 {
+		compatible = "fsl,p5020-dcsr-ocn", "fsl,dcsr-ocn";
+		reg = <0x11000 0x1000>;
+	};
+	dcsr-ddr@12000 {
+		compatible = "fsl,dcsr-ddr";
+		dev-handle = <&ddr1>;
+		reg = <0x12000 0x1000>;
+	};
+	dcsr-ddr@13000 {
+		compatible = "fsl,dcsr-ddr";
+		dev-handle = <&ddr2>;
+		reg = <0x13000 0x1000>;
+	};
+	dcsr-nal@18000 {
+		compatible = "fsl,p5020-dcsr-nal", "fsl,dcsr-nal";
+		reg = <0x18000 0x1000>;
+	};
+	dcsr-rcpm@22000 {
+		compatible = "fsl,p5020-dcsr-rcpm", "fsl,dcsr-rcpm";
+		reg = <0x22000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@40000 {
+		compatible = "fsl,dcsr-e5500-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu0>;
+		reg = <0x40000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@41000 {
+		compatible = "fsl,dcsr-e5500-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu1>;
+		reg = <0x41000 0x1000>;
+	};
+};
+
+&bportals {
+/include/ "qoriq-bman1-portals.dtsi"
+};
+
+&qportals {
+/include/ "qoriq-qman1-portals.dtsi"
+};
+
+&soc {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	device_type = "soc";
+	compatible = "simple-bus";
+
+	soc-sram-error {
+		compatible = "fsl,soc-sram-error";
+		interrupts = <16 2 1 29>;
+	};
+
+	corenet-law@0 {
+		compatible = "fsl,corenet-law";
+		reg = <0x0 0x1000>;
+		fsl,num-laws = <32>;
+	};
+
+	ddr1: memory-controller@8000 {
+		compatible = "fsl,qoriq-memory-controller-v4.5", "fsl,qoriq-memory-controller";
+		reg = <0x8000 0x1000>;
+		interrupts = <16 2 1 23>;
+	};
+
+	ddr2: memory-controller@9000 {
+		compatible = "fsl,qoriq-memory-controller-v4.5","fsl,qoriq-memory-controller";
+		reg = <0x9000 0x1000>;
+		interrupts = <16 2 1 22>;
+	};
+
+	cpc: l3-cache-controller@10000 {
+		compatible = "fsl,p5020-l3-cache-controller", "fsl,p4080-l3-cache-controller", "cache";
+		reg = <0x10000 0x1000
+		       0x11000 0x1000>;
+		interrupts = <16 2 1 27
+			      16 2 1 26>;
+	};
+
+	corenet-cf@18000 {
+		compatible = "fsl,corenet-cf";
+		reg = <0x18000 0x1000>;
+		interrupts = <16 2 1 31>;
+		fsl,ccf-num-csdids = <32>;
+		fsl,ccf-num-snoopids = <32>;
+	};
+
+	iommu@20000 {
+		compatible = "fsl,pamu-v1.0", "fsl,pamu";
+		reg = <0x20000 0x4000>;
+		interrupts = <
+			24 2 0 0
+			16 2 1 30>;
+	};
+
+/include/ "qoriq-mpic.dtsi"
+
+	guts: global-utilities@e0000 {
+		compatible = "fsl,qoriq-device-config-1.0";
+		reg = <0xe0000 0xe00>;
+		fsl,has-rstcr;
+		#sleep-cells = <1>;
+		fsl,liodn-bits = <12>;
+	};
+
+	pins: global-utilities@e0e00 {
+		compatible = "fsl,qoriq-pin-control-1.0";
+		reg = <0xe0e00 0x200>;
+		#sleep-cells = <2>;
+	};
+
+	clockgen: global-utilities@e1000 {
+		compatible = "fsl,p5020-clockgen", "fsl,qoriq-clockgen-1.0";
+		reg = <0xe1000 0x1000>;
+		clock-frequency = <0>;
+	};
+
+	rcpm: global-utilities@e2000 {
+		compatible = "fsl,qoriq-rcpm-1.0";
+		reg = <0xe2000 0x1000>;
+		#sleep-cells = <1>;
+	};
+
+	sfp: sfp@e8000 {
+		compatible = "fsl,p5020-sfp", "fsl,qoriq-sfp-1.0";
+		reg	   = <0xe8000 0x1000>;
+	};
+
+	serdes: serdes@ea000 {
+		compatible = "fsl,p5020-serdes";
+		reg	   = <0xea000 0x1000>;
+	};
+
+/include/ "qoriq-dma-0.dtsi"
+/include/ "qoriq-dma-1.dtsi"
+/include/ "qoriq-espi-0.dtsi"
+	spi@110000 {
+		fsl,espi-num-chipselects = <4>;
+	};
+
+/include/ "qoriq-esdhc-0.dtsi"
+	sdhc@114000 {
+		sdhci,auto-cmd12;
+	};
+
+/include/ "qoriq-i2c-0.dtsi"
+/include/ "qoriq-i2c-1.dtsi"
+/include/ "qoriq-duart-0.dtsi"
+/include/ "qoriq-duart-1.dtsi"
+/include/ "qoriq-gpio-0.dtsi"
+/include/ "qoriq-usb2-mph-0.dtsi"
+		usb0: usb@210000 {
+			compatible = "fsl-usb2-mph-v1.6", "fsl,mpc85xx-usb2-mph", "fsl-usb2-mph";
+			phy_type = "utmi";
+			port0;
+		};
+
+/include/ "qoriq-usb2-dr-0.dtsi"
+		usb1: usb@211000 {
+			compatible = "fsl-usb2-dr-v1.6", "fsl,mpc85xx-usb2-dr", "fsl-usb2-dr";
+			dr_mode = "host";
+			phy_type = "utmi";
+		};
+
+/include/ "qoriq-sata2-0.dtsi"
+	sata@220000 {
+		compatible = "fsl,p5020-sata", "fsl,pq-sata-v2";
+	};
+/include/ "qoriq-sata2-1.dtsi"
+	sata@221000 {
+		compatible = "fsl,p5020-sata", "fsl,pq-sata-v2";
+	};
+/include/ "qoriq-sec4.2-0.dtsi"
+/include/ "qoriq-pme-0.dtsi"
+/include/ "qoriq-rman-0.dtsi"
+/include/ "qoriq-qman1.dtsi"
+/include/ "qoriq-bman1.dtsi"
+
+/include/ "qoriq-fman-0.dtsi"
+/include/ "qoriq-fman-0-1g-0.dtsi"
+/include/ "qoriq-fman-0-1g-1.dtsi"
+/include/ "qoriq-fman-0-1g-2.dtsi"
+/include/ "qoriq-fman-0-1g-3.dtsi"
+/include/ "qoriq-fman-0-1g-4.dtsi"
+	fman0: fman@400000 {
+		/* tx - 1g - 0 */
+		port@a8000 {
+			fsl,qman-channel-id = <0x41>;
+		};
+		/* tx - 1g - 1 */
+		port@a9000 {
+			fsl,qman-channel-id = <0x42>;
+		};
+		/* tx - 1g - 2 */
+		port@aa000 {
+			fsl,qman-channel-id = <0x43>;
+		};
+		/* tx - 1g - 3 */
+		port@ab000 {
+			fsl,qman-channel-id = <0x44>;
+		};
+		/* tx - 1g - 4 */
+		port@ac000 {
+			fsl,qman-channel-id = <0x45>;
+		};
+		/* tx - 10g - 0 */
+		port@b0000 {
+			fsl,qman-channel-id = <0x40>;
+		};
+		/* offline 0 */
+		port@81000 {
+			fsl,qman-channel-id = <0x46>;
+		};
+		/* offline 1 */
+		port@82000 {
+			fsl,qman-channel-id = <0x47>;
+		};
+		/* offline 2 */
+		port@83000 {
+			fsl,qman-channel-id = <0x48>;
+		};
+		/* offline 3 */
+		port@84000 {
+			fsl,qman-channel-id = <0x49>;
+		};
+		/* offline 4 */
+		port@85000 {
+			fsl,qman-channel-id = <0x4a>;
+		};
+		/* offline 5 */
+		port@86000 {
+			fsl,qman-channel-id = <0x4b>;
+		};
+	};
+
+/include/ "qoriq-raid1.0-0.dtsi"
+};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/Kconfig b/drivers/staging/fsl_dpa_offload/usecases/Kconfig
deleted file mode 100644
index 4217c2e..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/Kconfig
+++ /dev/null
@@ -1,18 +0,0 @@
-config FSL_IPACC_USECASES
-tristate "DPA offloading usecases"
-depends on FSL_DPA_OFFLOAD && m
-default m
-
-choice
-	prompt "Select platform"
-depends on FSL_IPACC_USECASES
-config P4080_BUILD
-	bool "P4080DS"
-
-config P5020_BUILD
-	bool "P5020DS"
-
-config B4860_BUILD
-	bool "B4860QDS"
-
-endchoice
diff --git a/drivers/staging/fsl_dpa_offload/usecases/Makefile b/drivers/staging/fsl_dpa_offload/usecases/Makefile
deleted file mode 100644
index ac461cc..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/Makefile
+++ /dev/null
@@ -1,18 +0,0 @@
-
-#Include NetComm SW specific definitions
-include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
-
-EXTRA_CFLAGS += \
-	-DNETCOMM_SW \
-	-I$(NCSW)/src/wrapper \
-	-Idrivers/crypto/caam \
-	-DDEBUG_XFRM
-
-obj-$(CONFIG_FSL_IPACC_USECASES) = fsl_ipacc_uc.o
-fsl_ipacc_uc-objs += 		main.o \
-				fm_utils.o \
-				genl_ctl.o \
-				ipsec_init.o \
-				xfrm_km.o \
-				xfrm_utils.o \
-				dbgfs_ctl.o
diff --git a/drivers/staging/fsl_dpa_offload/usecases/common.h b/drivers/staging/fsl_dpa_offload/usecases/common.h
deleted file mode 100644
index 03b70cb..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/common.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _COMMON_H_
-#define _COMMON_H_
-
-#include <linux/kernel.h>
-#include "lnxwrp_fm.h"
-
-enum outb_post_enc_proto {
-	OUTB_POST_ENC_IPv4 = 0,
-	OUTB_POST_ENC_IPv6,
-	MAX_POST_ENC_PROTOS
-};
-
-#define NAT_KEY_SIZE 6
-#define IPv4_KEY_SIZE 8
-#define IPv6_KEY_SIZE 32
-#define OUTB_POST_SEC_MAX_NUM_KEYS 16
-#define OUTB_NAT_MAX_NUM_KEYS 2
-
-struct outb_nat_keys {
-	u8	key[NAT_KEY_SIZE];
-};
-
-struct outb_ipv4_keys {
-	u8	key[IPv4_KEY_SIZE];
-};
-
-struct outb_ipv6_keys {
-	u8	key[IPv6_KEY_SIZE];
-};
-
-t_LnxWrpFmDev *get_fm(int fm_idx);
-t_LnxWrpFmPortDev *get_fm_port(int fm_idx,
-				int port_idx,
-				e_FmPortType port_type);
-
-
-
-extern int dpa_ipsec_id;
-extern int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
-extern int outb_post_tx_fqid;
-extern int outb_update_hmd;
-extern bool inb_pol_check;
-extern int manip_desc[OUTB_POST_SEC_MAX_NUM_KEYS];
-extern int mtu_pre_enc;
-extern int fr_bpid;
-extern t_Handle pcd_dev;
-#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
deleted file mode 100644
index c90cc59..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/* Copyright (c) 2011 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/module.h>
-#include <linux/debugfs.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-
-#include <linux/fsl_dpa_ipsec.h>
-#include "dbgfs_ctl.h"
-
-LIST_HEAD(dbgfs_headlist);
-
-struct dentry *root_dir, *stats_dir;
-
-static ssize_t dbgfs_statistics_read(struct file *file, char __user *user_buf,
-				 size_t count, loff_t *ppos)
-{
-
-	char buf[50];
-	struct dpa_ipsec_sa_stats sa_stats;
-	struct priv_data *priv = file->private_data;
-
-	memset(&sa_stats, 0, sizeof(struct dpa_ipsec_sa_stats));
-	memset(buf, 0, sizeof(buf));
-	dpa_ipsec_sa_get_stats(priv->sa_id, &sa_stats);
-
-	switch (priv->type) {
-	case BYTES:
-		scnprintf(buf, sizeof(buf), "%u\n", sa_stats.bytes_count);
-		break;
-	case PACKETS:
-		scnprintf(buf, sizeof(buf), "%u\n", sa_stats.packets_count);
-		break;
-	default:
-		break;
-	}
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
-}
-
-static int dbgfs_open_file_generic(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static const struct file_operations default_file_operations = {
-	.read =		dbgfs_statistics_read,
-	.open =		dbgfs_open_file_generic,
-};
-
-int dbgfs_init_stats(void)
-{
-
-	root_dir = debugfs_create_dir("dpa_offload", NULL);
-	stats_dir = debugfs_create_dir("sa_id", root_dir);
-	INIT_LIST_HEAD(&dbgfs_headlist);
-
-	return 0;
-}
-
-static int dbgfs_create_stats_file(char *file_name, enum count_type c_type,
-				int sa_id, struct dbgfs_sa_entry *node)
-{
-	node->priv[c_type].type = c_type;
-	node->priv[c_type].sa_id = sa_id;
-	node->priv[c_type].file = debugfs_create_file(file_name, 0444,
-						node->dir,
-						&node->priv[c_type],
-						&default_file_operations);
-
-	return 0;
-}
-
-int dbgfs_create_entry(int sa_id)
-{
-	char node_name[32];
-	struct dentry *dir;
-
-	struct dbgfs_sa_entry *node;
-
-	node = kzalloc(sizeof(*node), GFP_ATOMIC);
-	if (!node)
-		return -ENOMEM;
-
-
-	memset(node_name, 0, sizeof(node_name));
-	scnprintf(node_name, sizeof(node_name), "%d", sa_id);
-	dir = debugfs_create_dir(node_name, stats_dir);
-
-	node->dir = dir;
-
-	dbgfs_create_stats_file("bytes", BYTES, sa_id, node);
-	dbgfs_create_stats_file("packets", PACKETS, sa_id, node);
-
-	list_add(&(node->list), &dbgfs_headlist);
-
-	return 0;
-}
-
-int dbgfs_remove_entry(int sa_id)
-{
-	struct dbgfs_sa_entry *node, *tmp;
-
-	list_for_each_entry_safe(node, tmp, &dbgfs_headlist, list) {
-		if (node->priv[PACKETS].sa_id == sa_id) {
-			debugfs_remove(node->priv[PACKETS].file);
-			debugfs_remove(node->priv[BYTES].file);
-			debugfs_remove(node->dir);
-			list_del(&(node->list));
-			kfree(node);
-			break;
-		}
-	}
-
-	return 0;
-}
-
-int dbgfs_cleanup(void)
-{
-	struct dbgfs_sa_entry *node, *tmp;
-
-	list_for_each_entry_safe(node, tmp, &dbgfs_headlist, list) {
-		debugfs_remove(node->priv[PACKETS].file);
-		debugfs_remove(node->priv[BYTES].file);
-		debugfs_remove(node->dir);
-		list_del(&(node->list));
-		kfree(node);
-	}
-		debugfs_remove(stats_dir);
-		debugfs_remove(root_dir);
-
-	return 0;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h
deleted file mode 100644
index 0ac8922..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _DBGFS_CTL_H
-#define _DBGFS_CTL_H
-
-enum count_type {
-	BYTES,
-	PACKETS,
-	MAX_TYPE,
-};
-
-struct priv_data {
-	int sa_id;
-	struct dentry *file;
-	enum count_type type;
-};
-
-struct dbgfs_sa_entry  {
-	struct dentry *dir;
-	struct priv_data priv[MAX_TYPE];
-	struct list_head list;
-};
-
-int dbgfs_init_stats(void);
-int dbgfs_create_entry(int sa_id);
-int dbgfs_remove_entry(int sa_id);
-int dbgfs_cleanup(void);
-
-#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa-shared-interfaces.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa-shared-interfaces.dts
deleted file mode 100644
index f109b76..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa-shared-interfaces.dts
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * B4860QDS Device Tree Source
- *
- * Copyright 2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/include/ "b4860qds.dts"
-
-/ {
-	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
-	 * because apps seed these pools with buffers allocated at
-	 * run-time.
-	 * HOWEVER, the kernel driver requires the buffer-size so
-	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
-	 * things if the base-address is zero (hence the 0xdeadbeef
-	 * values).
-	 */
-	bp7: buffer-pool@7 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <7>;
-		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-	};
-	bp8: buffer-pool@8 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <8>;
-		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp9: buffer-pool@9 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <9>;
-		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	bp10: buffer-pool@10 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <10>;
-		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
-	};
-	bp11: buffer-pool@11 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <11>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp12: buffer-pool@12 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <12>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	bp16: buffer-pool@16 {
-                        compatible = "fsl,b4860-bpool", "fsl,bpool";
-                        fsl,bpid = <16>;
-			fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
-                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-       };
-
-
-	fsl,dpaa {
-		ethernet@0 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
-			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
-		};
-		ethernet@1 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
-			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
-		};
-		ethernet@2 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
-			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
-		};
-		ethernet@5 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp16>;
-			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
-			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
-		};
-
-                /* ethernet@16 declared as MAC-less interface with no "fsl,fman-mac" property.
-                 * USDPAA will seed buffers to this buffer pool and initialize 8 TX Frame
-                 * queues. The ethernet driver will initialize 8 RX default Frame queues.
-                 * On receiving frame at this interface, the ethernet driver will do
-                 * kmap_atomic/kunmap_atomic for that frame. */
-               ethernet@16 {
-                        compatible = "fsl,b4860-dpa-ethernet", "fsl,dpa-ethernet";
-                        fsl,bman-buffer-pools = <&bp16>;
-                        fsl,qman-frame-queues-rx = <4000 8>;
-                        fsl,qman-frame-queues-tx = <4008 8>;
-                        local-mac-address = [00 11 22 33 44 55];
-                };
-
-		dpa-fman0-oh@2 {
-			compatible = "fsl,dpa-oh";
-			/* Define frame queues for the OH port*/
-			/* <OH Rx error, OH Rx default> */
-			fsl,qman-frame-queues-oh = <0x6e 1 0x6f 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman0_oh2>;
-		};
-                dpa_fman0_oh3: dpa-fman0-oh@3 {
-                        compatible = "fsl,dpa-oh";
-                        fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
-                        fsl,bman-buffer-pools = <&bp9>;
-                        fsl,fman-oh-port = <&fman0_oh3>;
-                };
-                dpa_fman0_oh4: dpa-fman0-oh@4 {
-                        compatible = "fsl,dpa-oh";
-                        fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
-                        fsl,bman-buffer-pools = <&bp9>;
-                        fsl,fman-oh-port = <&fman0_oh4>;
-                };
-	};
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa.dts
deleted file mode 100644
index 91c4bcb..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/b4860qds-usdpaa.dts
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * B4860QDS Device Tree Source
- *
- * Copyright 2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/include/ "b4860qds.dts"
-
-/ {
-	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
-	 * because apps seed these pools with buffers allocated at
-	 * run-time.
-	 * HOWEVER, the kernel driver requires the buffer-size so
-	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
-	 * things if the base-address is zero (hence the 0xdeadbeef
-	 * values).
-	 */
-	bp7: buffer-pool@7 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <7>;
-		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-	};
-	bp8: buffer-pool@8 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <8>;
-		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp9: buffer-pool@9 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <9>;
-		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	bp10: buffer-pool@10 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <10>;
-		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
-	};
-	bp11: buffer-pool@11 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <11>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp12: buffer-pool@12 {
-		compatible = "fsl,b4860-bpool", "fsl,bpool";
-		fsl,bpid = <12>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	fsl,dpaa {
-		ethernet@0 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
-			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
-		};
-		ethernet@1 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
-			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
-		};
-		ethernet@2 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
-			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
-		};
-		ethernet@5 {
-			compatible = "fsl,b4860-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
-			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
-		};
-		dpa-fman0-oh@2 {
-			compatible = "fsl,dpa-oh";
-			/* Define frame queues for the OH port*/
-			/* <OH Rx error, OH Rx default> */
-			fsl,qman-frame-queues-oh = <0x6e 1 0x6f 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman0_oh2>;
-		};
-                dpa_fman0_oh3: dpa-fman0-oh@3 {
-                        compatible = "fsl,dpa-oh";
-                        fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
-                        fsl,bman-buffer-pools = <&bp9>;
-                        fsl,fman-oh-port = <&fman0_oh3>;
-                };
-                dpa_fman0_oh4: dpa-fman0-oh@4 {
-                        compatible = "fsl,dpa-oh";
-                        fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
-                        fsl,bman-buffer-pools = <&bp9>;
-                        fsl,fman-oh-port = <&fman0_oh4>;
-                };
-	};
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa-shared-interfaces.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa-shared-interfaces.dts
deleted file mode 100644
index 038e055..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa-shared-interfaces.dts
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * P4080DS Device Tree Source
- *
- * Copyright 2009-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/include/ "p4080ds.dts"
-
-/ {
-	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
-	 * because apps seed these pools with buffers allocated at
-	 * run-time.
-	 * HOWEVER, the kernel driver requires the buffer-size so
-	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
-	 * things if the base-address is zero (hence the 0xdeadbeef
-	 * values).
-	 */
-	bp7: buffer-pool@7 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <7>;
-		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-	};
-	bp8: buffer-pool@8 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <8>;
-		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp9: buffer-pool@9 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <9>;
-		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp16: buffer-pool@16 {
-                        compatible = "fsl,p4080-bpool", "fsl,bpool";
-                        fsl,bpid = <16>;
-                        fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
-                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-       };
-	bp17: buffer-pool@17 {
-                        compatible = "fsl,p4080-bpool", "fsl,bpool";
-                        fsl,bpid = <17>;
-                        fsl,bpool-ethernet-cfg = <0 2048 0 1728 0 0>;
-                        fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-       };
-	fsl,dpaa {
-		ethernet@0 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
-			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
-		};
-
-		/* ethernet@1 will be used as a normal Linux ethernet that
-		 * interfaces to the kernel network stack. All others will be
-		 * dedicated for use by usdpaa */
-
-		ethernet@2 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
-			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
-		};
-		ethernet@3 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
-			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
-		};
-		ethernet@4 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
-			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
-		};
-		ethernet@5 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
-			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
-		};
-		ethernet@6 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
-			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
-		};
-		ethernet@7 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
-			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
-		};
-		ethernet@8 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
-			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
-		};
-		/* ethernet@9 declared as shared MAC. USDPAA will seed buffers to
-		 * this buffer pool. The ethernet driver will initialize the RX default,
-		 * RX error, TX error, TX confirm and 8 TX Frame queues. On receiving frame
-		 * at this interface, the ethernet driver will do kmap_atomic/kunmap_atomic
-		 * for that frame. */
-		ethernet@9 {
-			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,bman-buffer-pools = <&bp17>;
-			fsl,qman-frame-queues-rx = <0x66 1 0x67 1 0x2000 3>;
-			fsl,qman-frame-queues-tx = <0 1 0 1 0x3000 8>;
-		};
-		/* ethernet@16 declared as MAC-less interface with no "fsl,fman-mac" property.
-		 * USDPAA will seed buffers to this buffer pool and initialize 8 TX Frame
-		 * queues. The ethernet driver will initialize 8 RX default Frame queues.
-		 * On receiving frame at this interface, the ethernet driver will do
-		 * kmap_atomic/kunmap_atomic for that frame. */
-		ethernet@16 {
-			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,bman-buffer-pools = <&bp16>;
-			fsl,qman-frame-queues-rx = <4000 8>;
-			fsl,qman-frame-queues-tx = <4008 8>;
-			local-mac-address = [00 11 22 33 44 55];
-		};
-		dpa_fman1_oh1: dpa-fman1-oh@1 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
-			fsl,fman-oh-port = <&fman1_oh1>;
-		};
-		dpa_fman1_oh2: dpa-fman1-oh@2 { /* Define frame queues for the OH port*/
-			compatible = "fsl,dpa-oh"; /* <OH Rx error, OH Rx default> */
-			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
-			fsl,bman-buffer-pools = <&bp8>;
-			fsl,fman-oh-port = <&fman1_oh2>;
-		};
-		dpa_fman1_oh3: dpa-fman1-oh@3 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman1_oh3>;
-		};
-	};
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
deleted file mode 100644
index da0ca0f..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/p4080ds-usdpaa.dts
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * P4080DS Device Tree Source
- *
- * Copyright 2009-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/include/ "p4080ds.dts"
-
-/ {
-	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
-	 * because apps seed these pools with buffers allocated at
-	 * run-time.
-	 * HOWEVER, the kernel driver requires the buffer-size so
-	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
-	 * things if the base-address is zero (hence the 0xdeadbeef
-	 * values).
-	 */
-	bp7: buffer-pool@7 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <7>;
-		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-	};
-	bp8: buffer-pool@8 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <8>;
-		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp9: buffer-pool@9 {
-		compatible = "fsl,p4080-bpool", "fsl,bpool";
-		fsl,bpid = <9>;
-		fsl,bpool-ethernet-cfg = <0 0 0 1728 0 0xfeedabba>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	fsl,dpaa {
-		ethernet@0 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
-			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
-		};
-
-		/* ethernet@1 will be used as a normal Linux ethernet that
-		 * interfaces to the kernel network stack. All others will be
-		 * dedicated for use by usdpaa */
-
-		ethernet@2 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
-			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
-		};
-		ethernet@3 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
-			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
-		};
-		ethernet@4 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
-			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
-		};
-		ethernet@5 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
-			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
-		};
-		ethernet@6 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
-			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
-		};
-		ethernet@7 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
-			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
-		};
-		ethernet@8 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
-			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
-		};
-		ethernet@9 {
-			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x66 1 0x67 1>;
-			fsl,qman-frame-queues-tx = <0x86 1 0x87 1>;
-		};
-		dpa_fman1_oh1: dpa-fman1-oh@1 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
-			fsl,fman-oh-port = <&fman1_oh1>;
-		};
-		dpa_fman1_oh2: dpa-fman1-oh@2 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman1_oh2>;
-		};
-		dpa_fman1_oh3: dpa-fman1-oh@3 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman1_oh3>;
-		};
-	};
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts b/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
deleted file mode 100644
index eaa4657..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/p5020ds-usdpaa.dts
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * P5020DS Device Tree Source
- *
- * Copyright 2010-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/include/ "p5020ds.dts"
-
-/ {
-	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
-	 * because apps seed these pools with buffers allocated at
-	 * run-time.
-	 * HOWEVER, the kernel driver requires the buffer-size so
-	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
-	 * things if the base-address is zero (hence the 0xdeadbeef
-	 * values).
-	 */
-	bp7: buffer-pool@7 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <7>;
-		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-	};
-	bp8: buffer-pool@8 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <8>;
-		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp9: buffer-pool@9 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <9>;
-		fsl,bpool-ethernet-cfg = <0 0 0 1600 0 0xfeedabba>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp10: buffer-pool@10 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <10>;
-		fsl,bpool-thresholds = <0x10 0x30 0x0 0x0>;
-	};
-	bp11: buffer-pool@11 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <11>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-	bp12: buffer-pool@12 {
-		compatible = "fsl,p5020-bpool", "fsl,bpool";
-		fsl,bpid = <12>;
-		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-	};
-
-	fsl,dpaa {
-		ethernet@0 {
-			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
-			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
-		};
-		ethernet@1 {
-			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
-			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
-		};
-		ethernet@2 {
-			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
-			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
-		};
-		ethernet@3 {
-			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
-			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
-		};
-		ethernet@4 {
-			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
-			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
-			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
-		};
-		dpa_fman0_oh1: dpa-fman0-oh@1 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x64 1 0x65 1>;
-			fsl,fman-oh-port = <&fman0_oh1>;
-		};
-		dpa_fman0_oh2: dpa-fman0-oh@2 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x68 1 0x69 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman0_oh2>;
-		};
-		dpa_fman0_oh3: dpa-fman0-oh@3 {
-			compatible = "fsl,dpa-oh";
-			fsl,qman-frame-queues-oh = <0x70 1 0x71 1>;
-			fsl,bman-buffer-pools = <&bp9>;
-			fsl,fman-oh-port = <&fman0_oh3>;
-		};
-	};
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dts/p5020si-post.dtsi b/drivers/staging/fsl_dpa_offload/usecases/dts/p5020si-post.dtsi
deleted file mode 100644
index 4772553..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/dts/p5020si-post.dtsi
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * P5020/5010 Silicon/SoC Device Tree Source (post include)
- *
- * Copyright 2011 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-&lbc {
-	compatible = "fsl,p5020-rev1.0-elbc", "simple-bus";
-	interrupts = <
-		25 2 0 0
-		16 2 1 19
-		>;
-	#address-cells = <2>;
-	#size-cells = <1>;
-};
-
-/* controller at 0x200000 */
-&pci0 {
-	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
-	device_type = "pci";
-	#size-cells = <2>;
-	#address-cells = <3>;
-	bus-range = <0x0 0xff>;
-	clock-frequency = <33333333>;
-	interrupts = <16 2 1 15>;
-	pcie@0 {
-		reg = <0 0 0 0 0>;
-		#interrupt-cells = <1>;
-		#size-cells = <2>;
-		#address-cells = <3>;
-		device_type = "pci";
-		interrupts = <16 2 1 15>;
-		interrupt-map-mask = <0xf800 0 0 7>;
-		interrupt-map = <
-			/* IDSEL 0x0 */
-			0000 0 0 1 &mpic 40 1 0 0
-			0000 0 0 2 &mpic 1 1 0 0
-			0000 0 0 3 &mpic 2 1 0 0
-			0000 0 0 4 &mpic 3 1 0 0
-			>;
-	};
-};
-
-/* controller at 0x201000 */
-&pci1 {
-	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
-	device_type = "pci";
-	#size-cells = <2>;
-	#address-cells = <3>;
-	bus-range = <0 0xff>;
-	clock-frequency = <33333333>;
-	interrupts = <16 2 1 14>;
-	pcie@0 {
-		reg = <0 0 0 0 0>;
-		#interrupt-cells = <1>;
-		#size-cells = <2>;
-		#address-cells = <3>;
-		device_type = "pci";
-		interrupts = <16 2 1 14>;
-		interrupt-map-mask = <0xf800 0 0 7>;
-		interrupt-map = <
-			/* IDSEL 0x0 */
-			0000 0 0 1 &mpic 41 1 0 0
-			0000 0 0 2 &mpic 5 1 0 0
-			0000 0 0 3 &mpic 6 1 0 0
-			0000 0 0 4 &mpic 7 1 0 0
-			>;
-	};
-};
-
-/* controller at 0x202000 */
-&pci2 {
-	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
-	device_type = "pci";
-	#size-cells = <2>;
-	#address-cells = <3>;
-	bus-range = <0x0 0xff>;
-	clock-frequency = <33333333>;
-	interrupts = <16 2 1 13>;
-	pcie@0 {
-		reg = <0 0 0 0 0>;
-		#interrupt-cells = <1>;
-		#size-cells = <2>;
-		#address-cells = <3>;
-		device_type = "pci";
-		interrupts = <16 2 1 13>;
-		interrupt-map-mask = <0xf800 0 0 7>;
-		interrupt-map = <
-			/* IDSEL 0x0 */
-			0000 0 0 1 &mpic 42 1 0 0
-			0000 0 0 2 &mpic 9 1 0 0
-			0000 0 0 3 &mpic 10 1 0 0
-			0000 0 0 4 &mpic 11 1 0 0
-			>;
-	};
-};
-
-/* controller at 0x203000 */
-&pci3 {
-	compatible = "fsl,p5020-pcie", "fsl,qoriq-pcie-v2.2";
-	device_type = "pci";
-	#size-cells = <2>;
-	#address-cells = <3>;
-	bus-range = <0x0 0xff>;
-	clock-frequency = <33333333>;
-	interrupts = <16 2 1 12>;
-	pcie@0 {
-		reg = <0 0 0 0 0>;
-		#interrupt-cells = <1>;
-		#size-cells = <2>;
-		#address-cells = <3>;
-		device_type = "pci";
-		interrupts = <16 2 1 12>;
-		interrupt-map-mask = <0xf800 0 0 7>;
-		interrupt-map = <
-			/* IDSEL 0x0 */
-			0000 0 0 1 &mpic 43 1 0 0
-			0000 0 0 2 &mpic 0 1 0 0
-			0000 0 0 3 &mpic 4 1 0 0
-			0000 0 0 4 &mpic 8 1 0 0
-			>;
-	};
-};
-
-&rio {
-	compatible = "fsl,srio";
-	interrupts = <16 2 1 11>;
-	#address-cells = <2>;
-	#size-cells = <2>;
-	ranges;
-
-	port1 {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		cell-index = <1>;
-	};
-
-	port2 {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		cell-index = <2>;
-	};
-};
-
-&dcsr {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "fsl,dcsr", "simple-bus";
-
-	dcsr-epu@0 {
-		compatible = "fsl,dcsr-epu";
-		interrupts = <52 2 0 0
-			      84 2 0 0
-			      85 2 0 0>;
-		reg = <0x0 0x1000>;
-	};
-	dcsr-npc {
-		compatible = "fsl,dcsr-npc";
-		reg = <0x1000 0x1000 0x1000000 0x8000>;
-	};
-	dcsr-nxc@2000 {
-		compatible = "fsl,dcsr-nxc";
-		reg = <0x2000 0x1000>;
-	};
-	dcsr-corenet {
-		compatible = "fsl,dcsr-corenet";
-		reg = <0x8000 0x1000 0xB0000 0x1000>;
-	};
-	dcsr-dpaa@9000 {
-		compatible = "fsl,p5020-dcsr-dpaa", "fsl,dcsr-dpaa";
-		reg = <0x9000 0x1000>;
-	};
-	dcsr-ocn@11000 {
-		compatible = "fsl,p5020-dcsr-ocn", "fsl,dcsr-ocn";
-		reg = <0x11000 0x1000>;
-	};
-	dcsr-ddr@12000 {
-		compatible = "fsl,dcsr-ddr";
-		dev-handle = <&ddr1>;
-		reg = <0x12000 0x1000>;
-	};
-	dcsr-ddr@13000 {
-		compatible = "fsl,dcsr-ddr";
-		dev-handle = <&ddr2>;
-		reg = <0x13000 0x1000>;
-	};
-	dcsr-nal@18000 {
-		compatible = "fsl,p5020-dcsr-nal", "fsl,dcsr-nal";
-		reg = <0x18000 0x1000>;
-	};
-	dcsr-rcpm@22000 {
-		compatible = "fsl,p5020-dcsr-rcpm", "fsl,dcsr-rcpm";
-		reg = <0x22000 0x1000>;
-	};
-	dcsr-cpu-sb-proxy@40000 {
-		compatible = "fsl,dcsr-e5500-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
-		cpu-handle = <&cpu0>;
-		reg = <0x40000 0x1000>;
-	};
-	dcsr-cpu-sb-proxy@41000 {
-		compatible = "fsl,dcsr-e5500-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
-		cpu-handle = <&cpu1>;
-		reg = <0x41000 0x1000>;
-	};
-};
-
-&bportals {
-/include/ "qoriq-bman1-portals.dtsi"
-};
-
-&qportals {
-/include/ "qoriq-qman1-portals.dtsi"
-};
-
-&soc {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	device_type = "soc";
-	compatible = "simple-bus";
-
-	soc-sram-error {
-		compatible = "fsl,soc-sram-error";
-		interrupts = <16 2 1 29>;
-	};
-
-	corenet-law@0 {
-		compatible = "fsl,corenet-law";
-		reg = <0x0 0x1000>;
-		fsl,num-laws = <32>;
-	};
-
-	ddr1: memory-controller@8000 {
-		compatible = "fsl,qoriq-memory-controller-v4.5", "fsl,qoriq-memory-controller";
-		reg = <0x8000 0x1000>;
-		interrupts = <16 2 1 23>;
-	};
-
-	ddr2: memory-controller@9000 {
-		compatible = "fsl,qoriq-memory-controller-v4.5","fsl,qoriq-memory-controller";
-		reg = <0x9000 0x1000>;
-		interrupts = <16 2 1 22>;
-	};
-
-	cpc: l3-cache-controller@10000 {
-		compatible = "fsl,p5020-l3-cache-controller", "fsl,p4080-l3-cache-controller", "cache";
-		reg = <0x10000 0x1000
-		       0x11000 0x1000>;
-		interrupts = <16 2 1 27
-			      16 2 1 26>;
-	};
-
-	corenet-cf@18000 {
-		compatible = "fsl,corenet-cf";
-		reg = <0x18000 0x1000>;
-		interrupts = <16 2 1 31>;
-		fsl,ccf-num-csdids = <32>;
-		fsl,ccf-num-snoopids = <32>;
-	};
-
-	iommu@20000 {
-		compatible = "fsl,pamu-v1.0", "fsl,pamu";
-		reg = <0x20000 0x4000>;
-		interrupts = <
-			24 2 0 0
-			16 2 1 30>;
-	};
-
-/include/ "qoriq-mpic.dtsi"
-
-	guts: global-utilities@e0000 {
-		compatible = "fsl,qoriq-device-config-1.0";
-		reg = <0xe0000 0xe00>;
-		fsl,has-rstcr;
-		#sleep-cells = <1>;
-		fsl,liodn-bits = <12>;
-	};
-
-	pins: global-utilities@e0e00 {
-		compatible = "fsl,qoriq-pin-control-1.0";
-		reg = <0xe0e00 0x200>;
-		#sleep-cells = <2>;
-	};
-
-	clockgen: global-utilities@e1000 {
-		compatible = "fsl,p5020-clockgen", "fsl,qoriq-clockgen-1.0";
-		reg = <0xe1000 0x1000>;
-		clock-frequency = <0>;
-	};
-
-	rcpm: global-utilities@e2000 {
-		compatible = "fsl,qoriq-rcpm-1.0";
-		reg = <0xe2000 0x1000>;
-		#sleep-cells = <1>;
-	};
-
-	sfp: sfp@e8000 {
-		compatible = "fsl,p5020-sfp", "fsl,qoriq-sfp-1.0";
-		reg	   = <0xe8000 0x1000>;
-	};
-
-	serdes: serdes@ea000 {
-		compatible = "fsl,p5020-serdes";
-		reg	   = <0xea000 0x1000>;
-	};
-
-/include/ "qoriq-dma-0.dtsi"
-/include/ "qoriq-dma-1.dtsi"
-/include/ "qoriq-espi-0.dtsi"
-	spi@110000 {
-		fsl,espi-num-chipselects = <4>;
-	};
-
-/include/ "qoriq-esdhc-0.dtsi"
-	sdhc@114000 {
-		sdhci,auto-cmd12;
-	};
-
-/include/ "qoriq-i2c-0.dtsi"
-/include/ "qoriq-i2c-1.dtsi"
-/include/ "qoriq-duart-0.dtsi"
-/include/ "qoriq-duart-1.dtsi"
-/include/ "qoriq-gpio-0.dtsi"
-/include/ "qoriq-usb2-mph-0.dtsi"
-		usb0: usb@210000 {
-			compatible = "fsl-usb2-mph-v1.6", "fsl,mpc85xx-usb2-mph", "fsl-usb2-mph";
-			phy_type = "utmi";
-			port0;
-		};
-
-/include/ "qoriq-usb2-dr-0.dtsi"
-		usb1: usb@211000 {
-			compatible = "fsl-usb2-dr-v1.6", "fsl,mpc85xx-usb2-dr", "fsl-usb2-dr";
-			dr_mode = "host";
-			phy_type = "utmi";
-		};
-
-/include/ "qoriq-sata2-0.dtsi"
-	sata@220000 {
-		compatible = "fsl,p5020-sata", "fsl,pq-sata-v2";
-	};
-/include/ "qoriq-sata2-1.dtsi"
-	sata@221000 {
-		compatible = "fsl,p5020-sata", "fsl,pq-sata-v2";
-	};
-/include/ "qoriq-sec4.2-0.dtsi"
-/include/ "qoriq-pme-0.dtsi"
-/include/ "qoriq-rman-0.dtsi"
-/include/ "qoriq-qman1.dtsi"
-/include/ "qoriq-bman1.dtsi"
-
-/include/ "qoriq-fman-0.dtsi"
-/include/ "qoriq-fman-0-1g-0.dtsi"
-/include/ "qoriq-fman-0-1g-1.dtsi"
-/include/ "qoriq-fman-0-1g-2.dtsi"
-/include/ "qoriq-fman-0-1g-3.dtsi"
-/include/ "qoriq-fman-0-1g-4.dtsi"
-	fman0: fman@400000 {
-		/* tx - 1g - 0 */
-		port@a8000 {
-			fsl,qman-channel-id = <0x41>;
-		};
-		/* tx - 1g - 1 */
-		port@a9000 {
-			fsl,qman-channel-id = <0x42>;
-		};
-		/* tx - 1g - 2 */
-		port@aa000 {
-			fsl,qman-channel-id = <0x43>;
-		};
-		/* tx - 1g - 3 */
-		port@ab000 {
-			fsl,qman-channel-id = <0x44>;
-		};
-		/* tx - 1g - 4 */
-		port@ac000 {
-			fsl,qman-channel-id = <0x45>;
-		};
-		/* tx - 10g - 0 */
-		port@b0000 {
-			fsl,qman-channel-id = <0x40>;
-		};
-		/* offline 0 */
-		port@81000 {
-			fsl,qman-channel-id = <0x46>;
-		};
-		/* offline 1 */
-		port@82000 {
-			fsl,qman-channel-id = <0x47>;
-		};
-		/* offline 2 */
-		port@83000 {
-			fsl,qman-channel-id = <0x48>;
-		};
-		/* offline 3 */
-		port@84000 {
-			fsl,qman-channel-id = <0x49>;
-		};
-		/* offline 4 */
-		port@85000 {
-			fsl,qman-channel-id = <0x4a>;
-		};
-		/* offline 5 */
-		port@86000 {
-			fsl,qman-channel-id = <0x4b>;
-		};
-	};
-
-/include/ "qoriq-raid1.0-0.dtsi"
-};
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
deleted file mode 100644
index 8065c85..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/fsl_bman.h>
-#include <linux/fsl_qman.h>
-#include <linux/of.h>
-#include <linux/version.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include "lnxwrp_fm.h"
-#include "ports_conf.h"
-#include "platform_defs.h"
-
-static struct of_device_id fman_1g_rx_port[] = {
-	{.compatible = "fsl,fman-port-1g-rx",},
-	{}
-};
-
-static struct of_device_id fman_1g_tx_port[] = {
-	{.compatible = "fsl,fman-port-1g-tx",},
-	{}
-};
-
-static struct of_device_id fman_10g_rx_port[] = {
-	{.compatible = "fsl,fman-port-10g-rx",},
-	{}
-};
-
-static struct of_device_id fman_10g_tx_port[] = {
-	{.compatible = "fsl,fman-port-10g-tx",},
-	{}
-};
-
-static struct of_device_id fman_oh_port[] = {
-	{.compatible = "fsl,fman-port-oh",},
-	{}
-};
-
-static struct of_device_id fman[] = {
-	{.compatible = "fsl,fman",},
-	{}
-};
-
-/*
-	Find the base address of dTSEC device
-	@fm_idx : FMAN index (0/1)
-	@port_idx : port index
-*/
-phys_addr_t get_mac_dev(int fm_id, int port_id)
-{
-	struct device_node *eth_dev_temp = NULL, *eth_dev = NULL,
-	    *mac_node = NULL, *fman_node = NULL;
-	const phandle *mac_phandle, *fm_cell_idx, *mac_cell_idx;
-	int lenp;
-	const uint32_t *regs_addr;
-	uint64_t regs_size;
-	uint64_t phys_addr;
-
-	eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
-					  "fsl,dpa-ethernet-init");
-	while (eth_dev != NULL) {
-		mac_phandle = of_get_property(eth_dev, "fsl,fman-mac", &lenp);
-		if (unlikely(mac_phandle == NULL))
-			goto err;
-
-		mac_node = of_find_node_by_phandle(*mac_phandle);
-		if (unlikely(mac_node == NULL))
-			goto err;
-
-		regs_addr = of_get_address(mac_node, 0, &regs_size, NULL);
-		if (unlikely(regs_addr == NULL))
-			goto err;
-
-		phys_addr = of_translate_address(mac_node, regs_addr);
-		if (unlikely(phys_addr == 0))
-			goto err;
-
-		fman_node = of_get_parent(mac_node);
-		if (!fman_node)
-			goto err;
-
-		fm_cell_idx = of_get_property(fman_node, "cell-index", &lenp);
-		if (!fm_cell_idx)
-			goto err;
-
-		mac_cell_idx = of_get_property(mac_node, "cell-index", &lenp);
-		if (!mac_cell_idx)
-			goto err;
-
-		if ((*mac_cell_idx == port_id) && (*fm_cell_idx == fm_id))
-			return phys_addr;
-
-		eth_dev_temp = eth_dev;
-		eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
-						  "fsl,dpa-ethernet-init");
-	}
-
-err:
-	return 0;
-}
-
-/*
-	Configure a dTSEC to operate in loopback mode
-	fm_idx : FMAN index (0/1)
-	@port_idx : port index
-	@set : 1 to set loopback mode, 0 to reset
-*/
-int config_loopback(int fm_id, int port_idx, int set)
-{
-	char *addr;
-	phys_addr_t mac_phys_addr = 0;
-	u32 val;
-
-	mac_phys_addr = get_mac_dev(fm_id, port_idx);
-	if (!mac_phys_addr)
-		return -ENODEV;
-
-	addr = ioremap(mac_phys_addr, 0x1000);
-	if (!addr) {
-		pr_err("%s : cannot remap mac_phys_addr %llx\n",
-		       __func__, mac_phys_addr);
-		return -ENXIO;
-	}
-#if defined(CONFIG_P4080_BUILD) || defined(CONFIG_P5020_BUILD)
-	val = in_be32((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET));
-#else
-	val = in_be32((u32 *) (addr + 0x08));
-#endif
-	if (set)
-#if defined(CONFIG_P4080_BUILD) || defined(CONFIG_P5020_BUILD)
-		val |= MACCFG1_LOOPBACK;
-#else
-		val |= 0x400;
-#endif
-	else
-		val &= ~MACCFG1_LOOPBACK;
-#if defined(CONFIG_P4080_BUILD) || defined(CONFIG_P5020_BUILD)
-	out_be32((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET), val);
-#else
-	out_be32((u32 *) (addr + 0x08), val);
-#endif
-
-	iounmap((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET));
-
-	return 0;
-
-}
-
-/*
-	Returns fmd wrapper structure associated to a given FMAN
-*/
-t_LnxWrpFmDev *get_fm(int fm_idx)
-{
-	struct device_node *np = NULL;
-	struct device_node *fman_np = NULL;
-	struct platform_device *of_dev = NULL;
-	struct device *dev;
-	t_LnxWrpFmDev *fm_dev = NULL;
-
-	for_each_matching_node(np, fman) {
-		if (*((unsigned int *)of_get_property(np,
-						      "cell-index",
-						      NULL)) == fm_idx) {
-			fman_np = np;
-			break;
-		}
-	}
-
-	if (!fman_np)
-		return NULL;
-
-	of_dev = of_find_device_by_node(fman_np);
-	of_node_put(fman_np);
-	if (unlikely(of_dev == NULL))
-		return NULL;
-
-	dev = &of_dev->dev;
-	fm_dev = dev_get_drvdata(dev);
-	return fm_dev;
-}
-
-/*
-	Returns fmd wrapper structure associated to a given FMAN port
-	@fm_idx : FMAN index (0/1)
-	@port_idx : port index
-	@port_type : type of port (RX/TX/1G/10G , OH)
-*/
-t_LnxWrpFmPortDev *get_fm_port(int fm_idx, int port_idx, e_FmPortType port_type)
-{
-	struct of_device_id *port_dev_id;
-	struct device_node *np = NULL;
-	struct device_node *fman_np = NULL;
-	struct platform_device *of_dev = NULL;
-	struct device *dev;
-	t_LnxWrpFmPortDev *port_dev = NULL;
-
-	switch (port_type) {
-	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
-		port_dev_id = fman_oh_port;
-		break;
-	case e_FM_PORT_TYPE_RX:
-		port_dev_id = fman_1g_rx_port;
-		break;
-	case e_FM_PORT_TYPE_RX_10G:
-		port_dev_id = fman_10g_rx_port;
-		break;
-	case e_FM_PORT_TYPE_TX:
-		port_dev_id = fman_1g_tx_port;
-		break;
-	case e_FM_PORT_TYPE_TX_10G:
-		port_dev_id = fman_10g_tx_port;
-		break;
-	default:
-		return NULL;
-	}
-
-	for_each_matching_node(np, fman) {
-		if (*((unsigned int *)of_get_property(np,
-						      "cell-index",
-						      NULL)) == fm_idx) {
-			fman_np = np;
-			break;
-		}
-	}
-	if (!fman_np)
-		return NULL;
-
-	for (np = of_find_matching_node(fman_np, port_dev_id); np;
-	     np = of_find_matching_node(np, port_dev_id)) {
-		if (*((unsigned int *)of_get_property(np,
-						      "cell-index",
-						      NULL)) == port_idx) {
-			of_dev = of_find_device_by_node(np);
-			of_node_put(np);
-			if (unlikely(of_dev == NULL))
-				break;
-			dev = &of_dev->dev;
-			port_dev = dev_get_drvdata(dev);
-			break;
-		}
-	}
-	return port_dev;
-}
-
-/*
-	Checks if used ports were initialized by FMD
-*/
-int check_ports(void)
-{
-	t_LnxWrpFmDev *fm;
-	t_LnxWrpFmPortDev *port;
-
-	fm = get_fm(FM);
-	if (!fm)
-		return -ENODEV;
-
-	pr_info("Using ports :");
-
-	port = get_fm_port(FM, UL_POST_IPSEC_OH,
-			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-	if (!port)
-		return -ENODEV;
-	pr_info("%s UL_POST_IPSEC_OH ", port->name);
-
-	port = get_fm_port(FM, UL_PRE_IPSEC_OH,
-			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-	if (!port)
-		return -ENODEV;
-	pr_info("%s UL_PRE_IPSEC_OH", port->name);
-
-	port = get_fm_port(FM, DL_POST_IPSEC_OH,
-			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-	if (!port)
-		return -ENODEV;
-	pr_info("%s DL_POST_IPSEC_OH", port->name);
-
-	port = get_fm_port(FM, UL_RX, e_FM_PORT_TYPE_RX);
-	if (!port)
-		return -ENODEV;
-	pr_info("%s UL_RX", port->name);
-
-	port = get_fm_port(FM, DL_RX, e_FM_PORT_TYPE_RX);
-	if (!port)
-		return -ENODEV;
-	pr_info("%s DL_RX\n", port->name);
-
-	return 0;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
deleted file mode 100644
index 9f73c9b..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
+++ /dev/null
@@ -1,586 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <net/genetlink.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <net/xfrm.h>
-#include <net/ipv6.h>
-
-#include "genl_ctl.h"
-
-#ifdef CONFIG_COMPAT
-#include <Peripherals/fm_pcd_ext.h>
-#include <Peripherals/fm_port_ext.h>
-#include "fm_port_ioctls.h"
-#include "lnxwrp_ioctls_fm_compat.h"
-
-struct compat_ipsec_fm_uparms compat_fm_params;
-int i;
-void *ptr;
-#endif /* CONFIG_COMPAT */
-
-int dpa_ipsec_id;
-struct ipsec_fm_uparms fm_params;
-
-int fmc_config(void);
-int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params);
-int init_ob_post_ipsec_tables(struct ipsec_uparms *params);
-int init_ob_pre_ipsec_nat_tables(struct ipsec_uparms *params);
-int init_xfrm_km(struct xfrm_km_uparms *params);
-
-void dump_xfrm_sa(struct xfrm_state *x);
-void dump_xfrm_selector(struct xfrm_selector *sel);
-void dump_xfrm_template(struct xfrm_tmpl *tmpl);
-
-/* family definition */
-static struct genl_family dpa_ipacc_family = {
-	.id = GENL_ID_GENERATE,
-	.hdrsize = 0,
-	.name = "DPA_IPACC",
-	.version = VERSION_NR,
-	.maxattr = A_MAX,
-};
-
-/* Fills the reply to XFRM_NEW_SA user request with policy id information
- for each matching policy. The reply contains one A_POL_INFO attribute for
- each policy. Policy template is matched against the xfrm_state.
-*/
-static int policy_walk_func_fromsa(struct xfrm_policy *pol, int dir, int count,
-				   void *ptr)
-{
-	struct pol_walk_arg_fromsa *arg = (struct pol_walk_arg_fromsa *)ptr;
-	struct xfrm_state *x = arg->x;
-	struct sk_buff *skb = arg->skb;
-	struct xfrm_pol_userinfo xfrm_info;
-	int ret;
-
-	/* we support only one template per policy so only the
-	first transform is checked */
-	if (x->props.family == AF_INET) {
-		if (!((x->id.daddr.a4 == pol->xfrm_vec[0].id.daddr.a4) &&
-			(x->props.saddr.a4 == pol->xfrm_vec[0].saddr.a4) &&
-			(x->id.proto == pol->xfrm_vec[0].id.proto)))
-			/* continue walking */
-				return 0;
-	} else if (x->props.family == AF_INET6) {
-		if ((ipv6_addr_cmp((struct in6_addr *)x->id.daddr.a6,
-			(struct in6_addr *)pol->xfrm_vec[0].id.daddr.a6) ||
-			ipv6_addr_cmp((struct in6_addr *)x->props.saddr.a6,
-			(struct in6_addr *)pol->xfrm_vec[0].saddr.a6) ||
-			(x->id.proto != pol->xfrm_vec[0].id.proto)))
-			return 0;
-	}
-
-	if (dir == XFRM_POLICY_OUT || dir == XFRM_POLICY_IN) {
-		memset(&xfrm_info, 0, sizeof(xfrm_info));
-		xfrm_info.pol_id.sel = pol->selector;
-		xfrm_info.pol_id.dir = (uint8_t)dir;
-		xfrm_info.pol_id.index = pol->index;
-		if (x->encap) {
-			memcpy(&xfrm_info.encap, x->encap,
-			       sizeof(xfrm_info.encap));
-		}
-		ret = nla_put(skb, XFRMA_POLICY, sizeof(xfrm_info), &xfrm_info);
-
-		if (ret) {
-			pr_err("%s(%d): error constructing policy reply\n",
-			       __func__, __LINE__);
-			return ret;
-		}
-	}
-	return 0;
-}
-
-/* Returns xfrm_policy structure needed for state lookup
- */
-static int policy_walk_func_frompol(struct xfrm_policy *pol, int dir, int count,
-				    void *ptr)
-{
-	struct pol_walk_arg_frompol *arg = (struct pol_walk_arg_frompol *)ptr;
-	struct xfrm_userpolicy_info *pol_info = arg->pol_info;
-
-	/* match xfrm_policy selector against user policy info */
-	if (pol_info->sel.family == AF_INET) {
-		if (pol_info->sel.saddr.a4 == pol->selector.saddr.a4 &&
-		pol_info->sel.daddr.a4 == pol->selector.daddr.a4 &&
-		pol_info->sel.proto == pol->selector.proto &&
-		pol_info->sel.family == pol->selector.family) {
-			arg->x = pol;
-			return 1;
-		}
-	} else if (pol_info->sel.family == AF_INET6) {
-		if (!ipv6_addr_cmp((struct in6_addr *)pol_info->sel.saddr.a6,
-		(struct in6_addr *)pol->selector.saddr.a6) &&
-		!ipv6_addr_cmp((struct in6_addr *)pol_info->sel.daddr.a6,
-		(struct in6_addr *)pol->selector.daddr.a6) &&
-		(pol_info->sel.proto == pol->selector.proto) &&
-		pol_info->sel.family == pol->selector.family)
-			arg->x = pol;
-			return 1;
-	}
-	/* continue walking */
-	return 0;
-}
-
-/* Command handler for C_GET_OFFLD_DATA_FROMSA */
-static int get_ipsec_offld_data_fromsa(struct sk_buff *skb_2,
-					struct genl_info *info)
-{
-	struct nlattr *na;
-	struct sk_buff *skb;
-	int rc = 0;
-	void *msg_head;
-	struct new_sa_req sa_req;
-	struct xfrm_state *x;
-	struct xfrm_policy_walk walk;
-	struct pol_walk_arg_fromsa arg;
-	struct xfrm_algo *ealg = NULL;
-	struct xfrm_algo_auth *aalg = NULL;
-
-	/* check user info */
-	na = info->attrs[A_SA_INFO];
-	if (!na) {
-		pr_err("%s(%d) : no A_SA_INFO (%d) attr in user info\n",
-			__func__, __LINE__, A_SA_INFO);
-		return -EINVAL;
-	}
-
-	sa_req = *((typeof(&sa_req)) nla_data(na));
-
-	/* get xfrm_state from user info */
-	x = xfrm_state_lookup(&init_net, 0, &sa_req.sa_info.id.daddr,
-			      sa_req.sa_info.id.spi, sa_req.sa_info.id.proto,
-			      sa_req.sa_info.family);
-	if (!x)
-		return -ENOKEY;
-
-	/* allocate reply */
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (skb == NULL)
-		return -ENOMEM;
-
-	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-			       0, C_GET_OFFLD_DATA_FROMSA);
-	if (msg_head == NULL)
-		goto out;
-
-	aalg = kzalloc(sizeof(*aalg) + x->aalg->alg_key_len / 8, GFP_ATOMIC);
-	if (!aalg) {
-		kfree_skb(skb);
-		return -ENOMEM;
-	}
-	ealg = kzalloc(sizeof(*ealg) + x->ealg->alg_key_len / 8, GFP_ATOMIC);
-	if (!ealg) {
-		kfree_skb(skb);
-		kfree(aalg);
-		return -ENOMEM;
-	}
-
-	memcpy(aalg, x->aalg,
-	       sizeof(struct xfrm_algo_auth) + x->aalg->alg_key_len / 8);
-	rc = nla_put(skb, XFRMA_ALG_AUTH,
-		     sizeof(*aalg) + x->aalg->alg_key_len / 8, aalg);
-	kfree(aalg);
-	if (rc < 0) {
-		kfree(ealg);
-		goto out;
-	}
-
-	memcpy(ealg, x->ealg,
-	       sizeof(struct xfrm_algo) + x->ealg->alg_key_len / 8);
-	rc = nla_put(skb, XFRMA_ALG_CRYPT,
-		     sizeof(*ealg) + x->ealg->alg_key_len / 8, ealg);
-	kfree(ealg);
-	if (rc < 0)
-		goto out;
-
-	/* run policy walking and fill skb with policy information */
-	arg.x = x;
-	arg.skb = skb;
-	xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
-	xfrm_policy_walk(&init_net, &walk, policy_walk_func_fromsa, &arg);
-	xfrm_policy_walk_done(&walk);
-
-	/* send reply to user */
-	genlmsg_end(skb, msg_head);
-	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
-	return rc;
-out:
-	kfree_skb(skb);
-	return rc;
-}
-
-/* Command handler for C_GET_OFFLD_DATA_FROMPOL */
-static int get_ipsec_offld_data_frompol(struct sk_buff *skb_2,
-					struct genl_info *info)
-{
-	struct new_pol_req pol_req;
-	struct nlattr *na;
-	struct xfrm_state *state = NULL;
-	struct xfrm_sa_userinfo xfrm_info;
-	struct sk_buff *skb;
-	void *msg_head;
-	struct xfrm_policy_walk walk;
-	struct pol_walk_arg_frompol arg;
-	struct xfrm_algo *ealg = NULL;
-	struct xfrm_algo_auth *aalg = NULL;
-	int rc = 0;
-
-	/* check user info */
-	na = info->attrs[A_POL_INFO];
-	if (!na) {
-		pr_err("%s(%d) : no A_POL_INFO (%d) attr in user info\n",
-			 __func__, __LINE__, A_POL_INFO);
-		return -EINVAL;
-	}
-
-	pol_req = *((typeof(&pol_req)) nla_data(na));
-
-	/* get xfrm policy for user policy info */
-	arg.pol_info = &pol_req.pol_info;
-	arg.x = NULL;
-	xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_ANY);
-	xfrm_policy_walk(&init_net, &walk, policy_walk_func_frompol, &arg);
-	xfrm_policy_walk_done(&walk);
-	if (!arg.x)
-		return -ENOENT;
-
-	/* state lookup on xfrm_policy tmpl */
-	state = xfrm_state_lookup_byaddr(&init_net, 0,
-					 &arg.x->xfrm_vec[0].id.daddr,
-					 &arg.x->xfrm_vec[0].saddr,
-					 arg.x->xfrm_vec[0].id.proto,
-					 pol_req.pol_info.sel.family);
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-
-	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-				0, C_GET_OFFLD_DATA_FROMPOL);
-	if (!msg_head) {
-		rc = -ENOMEM;
-		goto out;
-	}
-	/* fill an A_SA_INFO attribute if a xfrm state is found */
-	if (state && ((pol_req.pol_info.dir == XFRM_POLICY_IN) ||
-		      (pol_req.pol_info.dir == XFRM_POLICY_OUT))) {
-		aalg =
-		    kzalloc(sizeof(*aalg) + state->aalg->alg_key_len / 8,
-			    GFP_ATOMIC);
-		if (!aalg) {
-			rc = -ENOMEM;
-			goto out;
-		}
-		ealg =
-		    kzalloc(sizeof(*ealg) + state->ealg->alg_key_len / 8,
-			    GFP_ATOMIC);
-		if (!ealg) {
-			kfree(aalg);
-			rc = -ENOMEM;
-			goto out;
-		}
-
-		memcpy(aalg, state->aalg,
-		       sizeof(struct xfrm_algo_auth) +
-		       state->aalg->alg_key_len / 8);
-		rc = nla_put(skb, XFRMA_ALG_AUTH,
-			     sizeof(*aalg) + state->aalg->alg_key_len / 8,
-			     aalg);
-		kfree(aalg);
-		if (rc < 0) {
-			kfree(ealg);
-			goto out;
-		}
-
-		memcpy(ealg, state->ealg,
-		       sizeof(struct xfrm_algo) + state->ealg->alg_key_len / 8);
-		rc = nla_put(skb, XFRMA_ALG_CRYPT,
-			     sizeof(*ealg) + state->ealg->alg_key_len / 8,
-			     ealg);
-		kfree(ealg);
-		if (rc < 0)
-			goto out;
-
-		memset(&xfrm_info, 0, sizeof(xfrm_info));
-		xfrm_info.sa_info.saddr = state->props.saddr;
-		xfrm_info.sa_info.id.daddr = state->id.daddr;
-		xfrm_info.sa_info.id.spi = state->id.spi;
-		xfrm_info.sa_info.id.proto = state->id.proto;
-		xfrm_info.sa_info.family = state->props.family;
-		rc = nla_put(skb, XFRMA_SA, sizeof(xfrm_info), &xfrm_info);
-		if (rc < 0)
-			goto out;
-	}
-	genlmsg_end(skb, msg_head);
-	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
-	return rc;
-out:
-	kfree_skb(skb);
-	return rc;
-}
-
-
-static int put_fm_params(struct sk_buff *skb_2, struct genl_info *info)
-{
-	int rc = 0;
-	struct nlattr *na;
-	struct sk_buff *skb;
-	void *msg_head;
-	int data_size;
-#ifdef CONFIG_COMPAT
-	int size;
-#endif
-
-	na = info->attrs[A_FM_PARAMS];
-	if (!na) {
-		pr_err("%s(%d) : no A_FM_PARAMS (%d) attr in user info\n",
-			__func__, __LINE__, A_FM_PARAMS);
-		return -EINVAL;
-	}
-
-	data_size = na->nla_len - NLA_HDRLEN;
-#ifdef CONFIG_COMPAT
-	size = sizeof(typeof(fm_params));
-	if (size != data_size) {
-		memcpy(&compat_fm_params,
-			(typeof(&compat_fm_params))nla_data(na),
-			 na->nla_len - NLA_HDRLEN);
-		fm_params.pcd_dev = compat_ptr(compat_fm_params.pcd_dev);
-		for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
-			ptr = compat_get_id2ptr(compat_fm_params.cc_in_rx[i],
-					   FM_MAP_TYPE_PCD_NODE);
-			fm_params.cc_in_rx[i] = ptr;
-		}
-
-		fm_params.cc_flow_id =
-				compat_get_id2ptr(compat_fm_params.cc_flow_id,
-						FM_MAP_TYPE_PCD_NODE);
-		for (i = 0; i <  DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
-			if (compat_fm_params.cc_out_pre_enc[i]) {
-				ptr = compat_get_id2ptr(compat_fm_params.
-							cc_out_pre_enc[i],
-							  FM_MAP_TYPE_PCD_NODE);
-				fm_params.cc_out_pre_enc[i] = ptr;
-			}
-		}
-
-		for (i = 0; i <  MAX_POST_ENC_PROTOS; i++) {
-			if (compat_fm_params.cc_out_post_enc[i]) {
-				ptr = compat_get_id2ptr(compat_fm_params.
-							cc_out_post_enc[i],
-							  FM_MAP_TYPE_PCD_NODE);
-				fm_params.cc_out_post_enc[i] = ptr;
-			}
-		}
-		fm_params.cc_out_rx_pre_enc = compat_get_id2ptr(
-					     compat_fm_params.cc_out_rx_pre_enc,
-					     FM_MAP_TYPE_PCD_NODE);
-		fm_params.vpri_update_hm = compat_get_id2ptr(
-						compat_fm_params.vpri_update_hm,
-						FM_MAP_TYPE_PCD_NODE);
-		fm_params.fwd_hm = compat_get_id2ptr(
-						compat_fm_params.fwd_hm,
-						FM_MAP_TYPE_PCD_NODE);
-		fm_params.nat_ip_hm = compat_get_id2ptr(
-						compat_fm_params.nat_ip_hm,
-						FM_MAP_TYPE_PCD_NODE);
-		fm_params.nat_udp_hm = compat_get_id2ptr(
-						compat_fm_params.nat_udp_hm,
-						FM_MAP_TYPE_PCD_NODE);
-
-		fm_params.ip4_num_keys = compat_fm_params.ip4_num_keys;
-		fm_params.ip6_num_keys = compat_fm_params.ip6_num_keys;
-		fm_params.nat_num_keys = compat_fm_params.nat_num_keys;
-		memcpy(fm_params.ip4_keys, compat_fm_params.ip4_keys,
-			sizeof(struct outb_ipv4_keys) * fm_params.ip4_num_keys);
-		memcpy(fm_params.ip6_keys, compat_fm_params.ip6_keys,
-			sizeof(struct outb_ipv6_keys) * fm_params.ip6_num_keys);
-		memcpy(fm_params.nat_keys, compat_fm_params.nat_keys,
-			sizeof(struct outb_nat_keys) * fm_params.nat_num_keys);
-	} else
-#endif
-	memcpy(&fm_params, (typeof(&fm_params))nla_data(na), data_size);
-
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-				0, C_PUT_FM_PARAMS);
-	if (!msg_head) {
-		kfree_skb(skb);
-		return -ENOMEM;
-	}
-	genlmsg_end(skb, msg_head);
-	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
-	return rc;
-}
-
-static int __init_ipsec_offld(struct sk_buff *skb_2, struct genl_info *info)
-{
-	int rc = 0;
-	struct nlattr *na;
-	struct sk_buff *skb;
-	void *msg_head;
-	struct ipsec_uparms params;
-
-	na  = info->attrs[A_INIT_IPSEC_INFO];
-	if (!na) {
-		pr_err("%s(%d) : no A_INIT_IPSEC_INFO (%d) attr in user info\n",
-			__func__, __LINE__, A_INIT_IPSEC_INFO);
-		return -EINVAL;
-	}
-	params = *(typeof(&params))nla_data(na);
-	rc = init_ipsec_offload(&dpa_ipsec_id, &params);
-	if (rc) {
-		pr_err("%s(%d) : Error initalizing IPsec offloading , ret %d\n",
-			__func__, __LINE__, rc);
-		return rc;
-	}
-
-	rc = init_ob_post_ipsec_tables(&params);
-	if (rc) {
-		pr_err("%s(%d) : Error initalizing outbound post "
-			"IPSEC tables, ret %d\n",
-			__func__, __LINE__, rc);
-		return rc;
-	}
-
-	rc = init_ob_pre_ipsec_nat_tables(&params);
-	if (rc) {
-		pr_err("%s(%d) : Error initalizing outbound pre "
-			"IPSEC nat tables, ret %d\n",
-			__func__, __LINE__, rc);
-		return rc;
-	}
-
-
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-				0, C_INIT_IPSEC_OFFLD);
-	if (!msg_head) {
-		kfree_skb(skb);
-		return -ENOMEM;
-	}
-	genlmsg_end(skb, msg_head);
-	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
-	return rc;
-}
-
-static int __init_xfrm_km(struct sk_buff *skb_2, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct sk_buff *skb;
-	void *msg_head;
-	struct xfrm_km_uparms params;
-	int rc = 0;
-
-	na  = info->attrs[A_XFRM_KM_INFO];
-	if (!na) {
-		pr_err("%s(%d) : no A_XFRM_KM_INFO (%d) attr in user info\n",
-			__func__, __LINE__, A_XFRM_KM_INFO);
-		return -EINVAL;
-	}
-	params = *(typeof(&params))nla_data(na);
-	rc = init_xfrm_km(&params);
-	if (rc) {
-		pr_err("%s(%d) : Error initalizing XFRM key manager , ret %d\n",
-			__func__, __LINE__, rc);
-		return rc;
-	}
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-			0, C_INIT_XFRM_KM);
-	if (!msg_head) {
-		kfree_skb(skb);
-		return -ENOMEM;
-	}
-	genlmsg_end(skb, msg_head);
-	rc = genlmsg_unicast(&init_net, skb, info->snd_pid);
-	return rc;
-}
-
-struct genl_ops dpa_ipacc_ops[] = {
-	{
-		.cmd = C_GET_OFFLD_DATA_FROMSA,
-		.flags = 0,
-		.policy = NULL,
-		.doit = get_ipsec_offld_data_fromsa,
-		.dumpit = NULL,
-	},
-	{
-		.cmd = C_GET_OFFLD_DATA_FROMPOL,
-		.flags = 0,
-		.policy = NULL,
-		.doit = get_ipsec_offld_data_frompol,
-		.dumpit = NULL,
-	},
-	{
-		.cmd = C_PUT_FM_PARAMS,
-		.flags = 0,
-		.policy = NULL,
-		.doit = put_fm_params,
-		.dumpit = NULL,
-	},
-	{
-		.cmd = C_INIT_IPSEC_OFFLD,
-		.flags = 0,
-		.policy = NULL,
-		.doit = __init_ipsec_offld,
-		.dumpit = NULL,
-	},
-	{
-		.cmd = C_INIT_XFRM_KM,
-		.flags = 0,
-		.policy = NULL,
-		.doit = __init_xfrm_km,
-		.dumpit = NULL,
-	}
-};
-
-int genl_ctl_init(void)
-{
-	int ret;
-	ret = genl_register_family_with_ops(&dpa_ipacc_family,
-		dpa_ipacc_ops, ARRAY_SIZE(dpa_ipacc_ops));
-	return ret;
-}
-
-int genl_ctl_exit(void)
-{
-	int ret;
-	ret = genl_unregister_family(&dpa_ipacc_family);
-	return ret;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
deleted file mode 100644
index e64f1b2..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _GENL_CTL_H
-#define _GENL_CTL_H
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <net/xfrm.h>
-#include "linux/fsl_dpa_ipsec.h"
-#include "common.h"
-
-/* Attributes
- */
-enum genl_attr {
-	A_UNSPEC,
-	A_SA_INFO,
-	A_POL_INFO,
-	A_FMC_MODEL_PART,
-	A_FMC_MODEL_LAST,
-	A_FM_PARAMS,
-	A_INIT_IPSEC_INFO,
-	A_XFRM_KM_INFO,
-	_A_MAX,
-};
-#define A_MAX (_A_MAX - 1)
-
-#define VERSION_NR 1
-
-/* Commands
- */
-enum genl_cmd {
-	C_UNSPEC,
-	C_GET_OFFLD_DATA_FROMSA,
-	C_GET_OFFLD_DATA_FROMPOL,
-	C_PUT_FMC_MODEL,
-	C_PUT_FM_PARAMS,
-	C_INIT_IPSEC_OFFLD,
-	C_INIT_XFRM_KM,
-	_C_MAX,
-};
-#define C_MAX (_C_MAX - 1)
-
-/* XFRM_NEW_SA event user request
- */
-struct new_sa_req {
-	struct xfrm_usersa_info sa_info;
-};
-
-struct new_pol_req {
-	struct xfrm_userpolicy_info pol_info;
-};
-
-struct pol_walk_arg_fromsa {
-	struct xfrm_state *x;
-	struct sk_buff *skb;
-};
-
-struct pol_walk_arg_frompol {
-	struct xfrm_userpolicy_info *pol_info;
-	struct xfrm_policy *x;
-};
-
-struct ipsec_uparms {
-	__u8 ipf_bpid;
-	__u16 max_sa;
-	__u32 outb_post_tx_fqid;
-	__u32 outb_pre_ipsec_oh_tx_fqid;
-	u8 dmac[ETH_ALEN];
-	u8 smac[ETH_ALEN];
-	__u32 ip_src_ob_nat;
-	__u32 ip_dst_ob_nat;
-	__u32 udp_dport_ob_nat;
-	bool inb_pol_check;
-	u8 vlan_priority;
-	unsigned int mtu_pre_enc;
-};
-
-/* Inbound post IPSEC OH queue types*/
-enum inb_queue_types {
-	DL_GTP_QUEUE = 0,
-	DL_UDP_UPLANE_QUEUE,
-	DL_NON_UDP_UPLANE_QUEUE,
-	INB_MAX_NUM_QUEUES
-};
-
-struct xfrm_km_uparms {
-	__u8 sa_bpid;
-	__u8 sa_wqid;
-	__u32 policy_act_fqid[INB_MAX_NUM_QUEUES];
-	__u32 pol_miss_fqid;
-};
-
-#ifdef CONFIG_COMPAT
-struct compat_ipsec_fm_uparms {
-	compat_uptr_t pcd_dev;
-	compat_uptr_t cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
-	compat_uptr_t cc_flow_id;
-	compat_uptr_t cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
-	compat_uptr_t cc_out_post_enc[MAX_POST_ENC_PROTOS];
-	compat_uptr_t cc_out_rx_pre_enc;
-	compat_uptr_t nat_ip_hm;
-	compat_uptr_t nat_udp_hm;
-	compat_uptr_t vpri_update_hm;
-	compat_uptr_t fwd_hm;
-	int ip4_num_keys;
-	int ip6_num_keys;
-	int nat_num_keys;
-	struct outb_ipv4_keys ip4_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
-	struct outb_ipv6_keys ip6_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
-	struct outb_nat_keys nat_keys[OUTB_NAT_MAX_NUM_KEYS];
-};
-#endif
-
-struct ipsec_fm_uparms {
-	void *pcd_dev;
-	void *cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
-	void *cc_flow_id;
-	void *cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
-	void *cc_out_post_enc[MAX_POST_ENC_PROTOS];
-	void *cc_out_rx_pre_enc;
-	void *nat_ip_hm;
-	void *nat_udp_hm;
-	void *vpri_update_hm;
-	void *fwd_hm;
-	int ip4_num_keys;
-	int ip6_num_keys;
-	int nat_num_keys;
-	struct outb_ipv4_keys ip4_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
-	struct outb_ipv6_keys ip6_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
-	struct outb_nat_keys nat_keys[OUTB_NAT_MAX_NUM_KEYS];
-};
-
-struct xfrm_pol_userinfo {
-	struct xfrm_userpolicy_id pol_id;
-	struct xfrm_encap_tmpl	encap;
-};
-
-struct xfrm_sa_userinfo {
-	struct xfrm_usersa_info sa_info;
-	struct xfrm_encap_tmpl	encap;
-};
-
-
-#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
deleted file mode 100644
index 6325f5a..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ /dev/null
@@ -1,724 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/fdtable.h>
-#include <linux/fsl_dpa_ipsec.h>
-#include <linux/fsl_dpa_classifier.h>
-
-#include "platform_defs.h"
-#include "ports_conf.h"
-#include "genl_ctl.h"
-#include "common.h"
-#include "dbgfs_ctl.h"
-
-#define SETS 0
-#define WAYS 1
-#define IN_SA_PCD_HASH_OFF      0
-
-/* define the number of entries (ways * sets) for each inbound sa type */
-static int num_entries[DPA_IPSEC_MAX_SA_TYPE][2] = {
-		[DPA_IPSEC_SA_IPV4][SETS] = 2,
-		[DPA_IPSEC_SA_IPV4][WAYS] = 8,
-		[DPA_IPSEC_SA_IPV4_NATT][SETS] = 2,
-		[DPA_IPSEC_SA_IPV4_NATT][WAYS] = 8,
-		[DPA_IPSEC_SA_IPV6][SETS] = 2,
-		[DPA_IPSEC_SA_IPV6][WAYS] = 4,
-};
-
-#define IPSEC_START_IN_FLOW_ID  0
-#define CCNODE_OUT_PRE_ENC_NUM_PROTOS 2
-
-#define IPSEC_OUT_POST_ENC_NUM_ENTRIES {				\
-		OUTB_POST_SEC_MAX_NUM_KEYS,				\
-		OUTB_POST_SEC_MAX_NUM_KEYS				\
-};
-
-#define IPSEC_OUT_POST_ENC_KEY_SIZE {					\
-		IPv4_KEY_SIZE,						\
-		IPv6_KEY_SIZE						\
-};
-
-/* These values must be set according to xml pcd file */
-#define IPSEC_OUT_POL_CC_NODE_KEYS  {					   \
-		16, /* Number of keys for DPA_IPSEC_PROTO_TCP_IPV4 CC Node */  \
-		16, /* Number of keys for DPA_IPSEC_PROTO_TCP_IPV6 CC Node */  \
-		16, /* Number of keys for DPA_IPSEC_PROTO_UDP_IPV4 CC Node */  \
-		16, /* Number of keys for DPA_IPSEC_PROTO_UDP_IPV6 CC Node */  \
-		16, /* Number of keys for DPA_IPSEC_PROTO_ICMP_IPV4 CC Node */ \
-		16, /* Number of keys for DPA_IPSEC_PROTO_ICMP_IPV6 CC Node */ \
-		16, /* Number of keys for DPA_IPSEC_PROTO_SCTP_IPV4 CC Node */ \
-		16, /* Number of keys for DPA_IPSEC_PROTO_SCTP_IPV6 CC Node */ \
-		16, /* Number of keys for DPA_IPSEC_PROTO_ANY_IPV4 CC Node */  \
-		8  /* Number of keys for DPA_IPSEC_PROTO_ANY_IPV6 CC Node */  \
-};
-
-#define IPSEC_PRE_DEC_TBL_KEY_SIZE \
-	{ \
-		/* IPV4 SA */ \
-		(DPA_OFFLD_IPv4_ADDR_LEN_BYTES + \
-		 IP_PROTO_FIELD_LEN + \
-		 ESP_SPI_FIELD_LEN), \
-		 /* IPV4 SA w/ NATT*/ \
-		(DPA_OFFLD_IPv4_ADDR_LEN_BYTES + \
-		 IP_PROTO_FIELD_LEN + \
-		 2 * PORT_FIELD_LEN + \
-		 ESP_SPI_FIELD_LEN), \
-		 /* IPV6 SA */ \
-		(DPA_OFFLD_IPv6_ADDR_LEN_BYTES + \
-		 IP_PROTO_FIELD_LEN + \
-		 ESP_SPI_FIELD_LEN) \
-	}
-
-#define IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE \
-	{ \
-		 0,	\
-		 0,	\
-		 0,	\
-		 0,	\
-		 0,	\
-		 0,	\
-		 0,	\
-		 0,	\
-		 (2 * DPA_OFFLD_IPv4_ADDR_LEN_BYTES + \
-		 IP_PROTO_FIELD_LEN + \
-		 2 * PORT_FIELD_LEN), \
-		(2 * DPA_OFFLD_IPv6_ADDR_LEN_BYTES + \
-		 IP_PROTO_FIELD_LEN + \
-		 2 * PORT_FIELD_LEN) \
-	}
-
-#define IPSEC_OUT_POL_KEY_FIELDS	(DPA_IPSEC_KEY_FIELD_SIP |	\
-					 DPA_IPSEC_KEY_FIELD_DIP |	\
-					 DPA_IPSEC_KEY_FIELD_PROTO |	\
-					 DPA_IPSEC_KEY_FIELD_SPORT |	\
-					 DPA_IPSEC_KEY_FIELD_DPORT)
-
-static uint8_t inb_key_size[] = IPSEC_PRE_DEC_TBL_KEY_SIZE;
-static uint8_t outb_key_size[] = IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE;
-static int out_pol_cc_node_keys[] = IPSEC_OUT_POL_CC_NODE_KEYS;
-static int outb_post_enc_ccnode_num_entries[] = IPSEC_OUT_POST_ENC_NUM_ENTRIES;
-static uint8_t outb_post_enc_ccnode_key_size[] = IPSEC_OUT_POST_ENC_KEY_SIZE;
-static struct dpa_ipsec_params ipsec_params;
-static int ipsec_initialized = 0;
-static int hmd_fwd, hmd_vlan, hmd_nat;
-
-extern struct ipsec_fm_uparms fm_params;
-
-int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
-int outb_pre_ipsec_nat_td;
-int outb_post_tx_fqid;
-int outb_update_hmd;
-bool inb_pol_check;
-int manip_desc[OUTB_POST_SEC_MAX_NUM_KEYS];
-int fr_bpid;
-int mtu_pre_enc;
-t_Handle pcd_dev;
-
-int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
-{
-	int i, cls_td;
-	struct dpa_cls_tbl_params cls_tbl_params;
-	int ret;
-	t_LnxWrpFmDev *fm_dev;
-	t_FmPcdParams pcd_params;
-	struct file *fm_pcd_file;
-	t_LnxWrpFmPortDev *ib_oh_post, *ob_oh_post;
-
-	outb_update_hmd = DPA_OFFLD_DESC_NONE;
-	memset(manip_desc, DPA_OFFLD_DESC_NONE, sizeof(manip_desc));
-	memset(&ipsec_params, 0, sizeof(ipsec_params));
-	memset(&pcd_params, 0, sizeof(pcd_params));
-
-	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
-	}
-
-	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-	dbgfs_init_stats();
-	ib_oh_post = get_fm_port(FM, DL_POST_IPSEC_OH,
-				e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-
-	if (!ib_oh_post) {
-		pr_err("%s:%d: Could not get Inbound Post Ipsec OH port\n",
-			__func__, __LINE__);
-		return -EINVAL;
-	}
-
-	ob_oh_post = get_fm_port(FM, UL_POST_IPSEC_OH,
-				e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-
-	if (!ob_oh_post) {
-		pr_err("%s:%d: Could not get Outbound Post Ipsec OH port\n",
-			__func__, __LINE__);
-		return -EINVAL;
-	}
-
-	ipsec_params.max_sa_pairs = params->max_sa;
-	outb_post_tx_fqid = params->outb_post_tx_fqid;
-	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
-	ipsec_params.ipf_bpid = params->ipf_bpid;
-	fr_bpid = ipsec_params.ipf_bpid;
-	mtu_pre_enc = params->mtu_pre_enc;
-	pcd_dev = fm_dev->h_PcdDev;
-	ipsec_params.qm_sec_ch = qm_channel_caam;
-	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
-		/* INB/DL pre SEC classifier */
-		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-		cls_tbl_params.cc_node = fm_params.cc_in_rx[i];
-		cls_tbl_params.type = DPA_CLS_TBL_HASH;
-		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-		cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
-		cls_tbl_params.hash_params.max_ways = num_entries[i][WAYS];
-		cls_tbl_params.hash_params.num_sets = num_entries[i][SETS];
-		cls_tbl_params.hash_params.key_size = inb_key_size[i];
-
-		ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
-		if (ret < 0) {
-			pr_err("%s:%d: Error creating inbound SA "
-				"classif table (%d), err %d\n",
-					__func__, __LINE__, i, ret);
-			return ret;
-		}
-
-		ipsec_params.pre_sec_in_params.dpa_cls_td[i] = cls_td;
-	}
-
-	/* INB/DL  post SEC params */
-	 /* data_off - SEC preheader burst size in bytes */
-	ipsec_params.post_sec_in_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
-	ipsec_params.post_sec_in_params.base_flow_id = IPSEC_START_IN_FLOW_ID;
-	ipsec_params.post_sec_in_params.use_ipv6_pol = FALSE;
-	ipsec_params.post_sec_in_params.qm_tx_ch = ib_oh_post->txCh;
-	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-	cls_tbl_params.cc_node = fm_params.cc_flow_id;
-	cls_tbl_params.type = DPA_CLS_TBL_INDEXED;
-	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-	cls_tbl_params.indexed_params.entries_cnt = ipsec_params.max_sa_pairs;
-	ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
-	if (ret < 0) {
-		pr_err("%s:%d: error creating in sa lookup classif table\n",
-				__func__, __LINE__);
-		goto out_inb_post_sec;
-	}
-
-	/* INB policy verification */
-	ipsec_params.post_sec_in_params.dpa_cls_td = cls_td;
-	ipsec_params.post_sec_in_params.do_pol_check = params->inb_pol_check;
-	inb_pol_check = params->inb_pol_check;
-	if (inb_pol_check)
-		ipsec_params.post_sec_in_params.key_fields =
-						DPA_IPSEC_KEY_FIELD_DPORT;
-
-	/* OUTB/UL post SEC params */
-	/* data_off - SEC preheader burst size in bytes */
-	ipsec_params.post_sec_out_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
-	ipsec_params.post_sec_out_params.qm_tx_ch = ob_oh_post->txCh;
-
-	/* OUTB/UL pre SEC params */
-	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
-		if (fm_params.cc_out_pre_enc[i] != NULL) {
-			memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-			cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-			cls_tbl_params.cc_node = fm_params.cc_out_pre_enc[i];
-			cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
-			cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-			cls_tbl_params.exact_match_params.entries_cnt =
-					out_pol_cc_node_keys[i];
-			cls_tbl_params.exact_match_params.key_size =
-					outb_key_size[i];
-			ret = dpa_classif_table_create(&cls_tbl_params,
-							&cls_td);
-			if (ret < 0) {
-				pr_err("%s:%d: Error creating outbound "
-					"classif table (%d), err %d\n",
-					__func__, __LINE__, i, ret);
-				goto out_outb_pre_sec;
-			}
-
-			ipsec_params.pre_sec_out_params.
-				table[i].dpa_cls_td = cls_td;
-			ipsec_params.pre_sec_out_params.
-				table[i].key_fields = IPSEC_OUT_POL_KEY_FIELDS;
-		} else
-			ipsec_params.pre_sec_out_params.table[i].dpa_cls_td =
-							DPA_OFFLD_DESC_NONE;
-	}
-
-
-
-	ret = dpa_ipsec_init(&ipsec_params, dpa_ipsec_id);
-	if (ret < 0) {
-		pr_err("%s:%d cannot initialize DPA IPsec\n",
-				__func__, __LINE__);
-		goto out_outb_pre_sec;
-	}
-	ipsec_initialized = 1;
-	return ret;
-
-out_outb_pre_sec:
-	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++)
-		if (ipsec_params.pre_sec_out_params.table[i].dpa_cls_td !=
-						DPA_OFFLD_DESC_NONE)
-			dpa_classif_table_free(ipsec_params.
-					pre_sec_out_params.table[i].dpa_cls_td);
-
-out_inb_post_sec:
-	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
-		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
-				dpa_cls_td[i]);
-
-	return ret;
-}
-
-static int create_hm_outb_post_enc(int *outb_hmd, struct ipsec_uparms *params)
-{
-	struct dpa_cls_hm_vlan_params vlan_params;
-	struct dpa_cls_hm_fwd_params fwd_params;
-	struct dpa_cls_hm_fwd_resources fwd_res;
-	struct dpa_cls_hm_vlan_resources vlan_res;
-	struct dpa_cls_hm_fwd_resources *p_fwd_res = NULL;
-	struct dpa_cls_hm_vlan_resources *p_vlan_res = NULL;
-	t_LnxWrpFmDev *fm_dev;
-	struct file *fm_pcd_file;
-	unsigned char data[2 * ETH_ALEN];
-	int err = 0;
-
-	hmd_fwd  =	DPA_OFFLD_DESC_NONE;
-	hmd_vlan   =	DPA_OFFLD_DESC_NONE;
-
-	memset(&fwd_params, 0, sizeof(struct dpa_cls_hm_fwd_params));
-	memset(&vlan_params, 0, sizeof(struct dpa_cls_hm_vlan_params));
-	memset(&vlan_res, 0, sizeof(struct dpa_cls_hm_vlan_resources));
-	memset(&fwd_res, 0, sizeof(struct dpa_cls_hm_fwd_resources));
-
-	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
-	}
-
-	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-
-	memcpy(&data[0], &params->dmac[0], ETH_ALEN);
-	memcpy(&data[6], &params->smac[0], ETH_ALEN);
-
-	/* Remove and insert operation */
-	vlan_params.fm_pcd = fm_dev;
-	vlan_params.type = DPA_CLS_HM_VLAN_EGRESS;
-	vlan_params.egress.update_op = DPA_CLS_HM_VLAN_UPDATE_VPri;
-	vlan_params.egress.update.vpri = params->vlan_priority;
-	vlan_res.vlan_node = fm_params.vpri_update_hm;
-
-	if (vlan_res.vlan_node)
-		p_vlan_res = &vlan_res;
-	err = dpa_classif_set_vlan_hm(&vlan_params, DPA_OFFLD_DESC_NONE,
-					&hmd_vlan, false, p_vlan_res);
-
-	if (err < 0) {
-		pr_err("%d - Failed to create vlan priority update "
-			"hm operation\n", err);
-		return err;
-	}
-
-	/* Forward operation*/
-	fwd_params.fm_pcd = fm_dev;
-	fwd_params.out_if_type = DPA_CLS_HM_IF_TYPE_ETHERNET;
-
-	memcpy(fwd_params.eth.macda, data, ETH_ALEN);
-	memcpy(fwd_params.eth.macsa, &data[6], ETH_ALEN);
-	fwd_res.fwd_node = fm_params.fwd_hm;
-	if (fwd_res.fwd_node)
-		p_fwd_res = &fwd_res;
-	err = dpa_classif_set_fwd_hm(&fwd_params, hmd_vlan,
-					&hmd_fwd, true, p_fwd_res);
-	if (err < 0) {
-		pr_err("%d - Failed to create forward "
-			"hm operation\n", err);
-		return err;
-	}
-
-	*outb_hmd = hmd_fwd;
-
-	return 0;
-}
-
-static int create_hm_outb_pre_enc(int *outb_hmd, struct ipsec_uparms *params)
-{
-	struct dpa_cls_hm_nat_params nat_params;
-	struct dpa_cls_hm_nat_resources nat_res;
-	struct dpa_cls_hm_nat_resources *p_nat_res = NULL;
-	t_LnxWrpFmDev *fm_dev;
-	struct file *fm_pcd_file;
-	int err = 0;
-
-	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
-	}
-
-	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-
-	hmd_nat = DPA_OFFLD_DESC_NONE;
-	/* Update - ip.dest udp.dport */
-	memset(&nat_params, 0, sizeof(struct dpa_cls_hm_nat_params));
-	nat_params.fm_pcd =  fm_dev->h_PcdDev;
-	nat_params.flags = DPA_CLS_HM_NAT_UPDATE_DIP |
-			DPA_CLS_HM_NAT_UPDATE_SIP | DPA_CLS_HM_NAT_UPDATE_DPORT;
-
-	nat_params.proto = DPA_CLS_NAT_PROTO_UDP;
-	nat_params.type = DPA_CLS_HM_NAT_TYPE_TRADITIONAL;
-	nat_params.nat.sip.version = IPVERSION;
-	nat_params.nat.dip.version = IPVERSION;
-	nat_params.nat.sip.addr.ipv4.word = params->ip_src_ob_nat;
-	nat_params.nat.dip.addr.ipv4.word = params->ip_dst_ob_nat;
-	nat_params.dport = (uint16_t)params->udp_dport_ob_nat;
-
-	memset(&nat_res, 0, sizeof(struct dpa_cls_hm_nat_resources));
-
-	nat_res.l3_update_node = fm_params.nat_ip_hm;
-	nat_res.l4_update_node = fm_params.nat_udp_hm;
-
-	if (nat_res.l3_update_node || nat_res.l4_update_node)
-		p_nat_res = &nat_res;
-
-	err = dpa_classif_set_nat_hm(&nat_params, DPA_OFFLD_DESC_NONE,
-					&hmd_nat, true, p_nat_res);
-	if (err < 0) {
-		pr_err("%d - Failed to create nat hm operation\n", err);
-		return err;
-	}
-
-	*outb_hmd = hmd_nat;
-
-	return 0;
-}
-
-int init_ob_post_ipsec_tables(struct ipsec_uparms *params)
-{
-	int i, cls_td;
-	struct dpa_cls_tbl_params cls_tbl_params;
-	struct dpa_cls_tbl_action def_action;
-	int ret;
-	t_LnxWrpFmDev *fm_dev;
-	struct file *fm_pcd_file;
-	struct dpa_offload_lookup_key	key;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	int outb_hmd = DPA_OFFLD_DESC_NONE;
-	key.byte = key_data;
-	key.mask = NULL;
-
-	memset(outb_post_ipsec_td, DPA_OFFLD_DESC_NONE,
-		sizeof(int) * MAX_POST_ENC_PROTOS);
-	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-
-	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
-	}
-
-	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-
-	for (i = 0; i < MAX_POST_ENC_PROTOS; i++) {
-		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-		cls_tbl_params.cc_node = fm_params.cc_out_post_enc[i];
-		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
-		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_KEY;
-		cls_tbl_params.exact_match_params.entries_cnt =
-				outb_post_enc_ccnode_num_entries[i];
-		cls_tbl_params.exact_match_params.key_size =
-				outb_post_enc_ccnode_key_size[i];
-		ret = dpa_classif_table_create(&cls_tbl_params,
-						&cls_td);
-		if (ret < 0) {
-			pr_err("%s:%d: Error creating outbound "
-				"post enc classif table (%d), err %d\n",
-				__func__, __LINE__, i, ret);
-			return ret;
-		}
-
-		outb_post_ipsec_td[i] = cls_td;
-	}
-
-	ret = create_hm_outb_post_enc(&outb_hmd, params);
-	if (ret < 0) {
-		pr_err("%s:%d: Error creating header manip "
-			"post enc. err %d\n",
-			__func__, __LINE__, ret);
-		return ret;
-	}
-	outb_update_hmd = outb_hmd;
-	memset(&def_action, 0, sizeof(def_action));
-	def_action.type = DPA_CLS_TBL_ACTION_ENQ;
-	def_action.enable_statistics = false;
-	def_action.enq_params.new_fqid = outb_post_tx_fqid;
-	def_action.enq_params.hmd = outb_update_hmd;
-	def_action.enq_params.override_fqid = true;
-
-	if (fm_params.ip4_num_keys > 0) {
-		key.size = IPv4_KEY_SIZE;
-		for (i = 0; i < fm_params.ip4_num_keys; i++) {
-			memcpy(key.byte, fm_params.ip4_keys[i].key,
-				IPv4_KEY_SIZE);
-			ret = dpa_classif_table_insert_entry(
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4],
-					&key, &def_action, 0, NULL);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to insert"
-					" static ipv4 entry in outb "
-					"exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4]);
-				return ret;
-			}
-		}
-	}
-
-	if (fm_params.ip6_num_keys > 0) {
-		key.size = IPv6_KEY_SIZE;
-		for (i = 0; i < fm_params.ip6_num_keys; i++) {
-			memcpy(key.byte, fm_params.ip6_keys[i].key,
-				IPv6_KEY_SIZE);
-			ret = dpa_classif_table_insert_entry(
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6],
-					&key, &def_action, 0, NULL);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to insert"
-					" static ipv6 entry in outb "
-					"exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6]);
-				return ret;
-			}
-		}
-	}
-
-
-
-	return ret;
-}
-
-int init_ob_pre_ipsec_nat_tables(struct ipsec_uparms *params)
-{
-	int i, cls_td;
-	struct dpa_cls_tbl_params cls_tbl_params;
-	struct dpa_cls_tbl_action def_action;
-	int ret;
-	t_LnxWrpFmDev *fm_dev;
-	struct file *fm_pcd_file;
-	struct dpa_offload_lookup_key	key;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	int outb_hmd = DPA_OFFLD_DESC_NONE;
-	key.byte = key_data;
-	key.mask = NULL;
-
-	hmd_nat = DPA_OFFLD_DESC_NONE;
-	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
-	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
-	}
-
-	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
-
-	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-
-	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-	cls_tbl_params.cc_node = fm_params.cc_out_rx_pre_enc;
-	cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
-	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_KEY;
-	cls_tbl_params.exact_match_params.entries_cnt = OUTB_NAT_MAX_NUM_KEYS;
-	cls_tbl_params.exact_match_params.key_size = NAT_KEY_SIZE;
-	ret = dpa_classif_table_create(&cls_tbl_params,
-					&cls_td);
-	if (ret < 0) {
-		pr_err("%s:%d: Error creating outbound "
-			"pre enc nat classif table, err %d\n",
-			__func__, __LINE__, ret);
-		return ret;
-	}
-
-	outb_pre_ipsec_nat_td = cls_td;
-
-	ret = create_hm_outb_pre_enc(&outb_hmd, params);
-	if (ret < 0) {
-		pr_err("%s:%d: Error creating header manip "
-			"pre enc. err %d\n",
-			__func__, __LINE__, ret);
-		return ret;
-	}
-
-	hmd_nat = outb_hmd;
-
-	memset(&def_action, 0, sizeof(def_action));
-	def_action.type = DPA_CLS_TBL_ACTION_ENQ;
-	def_action.enable_statistics = false;
-	def_action.enq_params.new_fqid = params->outb_pre_ipsec_oh_tx_fqid;
-	def_action.enq_params.hmd = hmd_nat;
-	def_action.enq_params.override_fqid = true;
-
-	if (fm_params.nat_num_keys > 0) {
-		key.size = NAT_KEY_SIZE;
-		for (i = 0; i < fm_params.nat_num_keys; i++) {
-			memcpy(key.byte, fm_params.nat_keys[i].key,
-					NAT_KEY_SIZE);
-			ret = dpa_classif_table_insert_entry(
-					outb_pre_ipsec_nat_td,
-					&key, &def_action, 0, NULL);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to insert"
-					" static  entry in outb nat pre enc"
-					"exact match table (td=%d)",
-					__func__, __LINE__,
-					outb_pre_ipsec_nat_td);
-				return ret;
-			}
-		}
-	}
-
-	return ret;
-
-}
-
-int cleanup_ipsec_offload(int dpa_ipsec_id)
-{
-	int i, ret;
-	struct dpa_offload_lookup_key	key;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-
-	key.byte = key_data;
-	key.mask = NULL;
-
-	if (!ipsec_initialized)
-		return 0;
-
-	ret = dpa_ipsec_free(dpa_ipsec_id);
-	if (ret < 0) {
-		pr_err("%s:%d: error freeing dpa ipsec instance %d\n",
-			__func__, __LINE__, dpa_ipsec_id);
-		return ret;
-	}
-
-	if (fm_params.ip4_num_keys > 0) {
-		key.size = IPv4_KEY_SIZE;
-		for (i = 0; i < fm_params.ip4_num_keys; i++) {
-			memcpy(key.byte, fm_params.ip4_keys[i].key,
-				IPv4_KEY_SIZE);
-			ret = dpa_classif_table_delete_entry_by_key(
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4],
-					&key);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to remove"
-					" static ipv4 entry in outb "
-					"exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4]);
-				return ret;
-			}
-		}
-	}
-
-	if (fm_params.ip6_num_keys > 0) {
-		key.size = IPv6_KEY_SIZE;
-		for (i = 0; i < fm_params.ip6_num_keys; i++) {
-			memcpy(key.byte, fm_params.ip6_keys[i].key,
-				IPv6_KEY_SIZE);
-			ret = dpa_classif_table_delete_entry_by_key(
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6],
-					&key);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to remove"
-					" static ipv6 entry in outb "
-					"exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6]);
-				return ret;
-			}
-		}
-	}
-
-	if (fm_params.nat_num_keys > 0) {
-		key.size = NAT_KEY_SIZE;
-		for (i = 0; i < fm_params.nat_num_keys; i++) {
-			memcpy(key.byte, fm_params.nat_keys[i].key,
-					NAT_KEY_SIZE);
-			ret = dpa_classif_table_delete_entry_by_key(
-					outb_pre_ipsec_nat_td,
-					&key);
-			if (ret < 0) {
-				pr_err("%s(%d) :Failed to remove"
-					" static entry in outb nat"
-					"exact match table pre enc "
-					"(td=%d)", __func__, __LINE__,
-					outb_pre_ipsec_nat_td);
-				return ret;
-			}
-		}
-	}
-
-	dpa_classif_table_free(outb_pre_ipsec_nat_td);
-
-	for (i = 0; i < MAX_POST_ENC_PROTOS; i++)
-		dpa_classif_table_free(outb_post_ipsec_td[i]);
-
-	if (hmd_nat != DPA_OFFLD_DESC_NONE)
-		dpa_classif_free_hm(hmd_nat);
-
-	if (hmd_vlan != DPA_OFFLD_DESC_NONE)
-		dpa_classif_free_hm(hmd_vlan);
-
-	if (hmd_fwd != DPA_OFFLD_DESC_NONE)
-		dpa_classif_free_hm(hmd_fwd);
-
-	for (i = 0; i < OUTB_POST_SEC_MAX_NUM_KEYS; i++)
-		if (manip_desc[i] != DPA_OFFLD_DESC_NONE)
-			dpa_classif_free_hm(manip_desc[i]);
-
-	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
-		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
-				dpa_cls_td[i]);
-
-	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++)
-		if (ipsec_params.pre_sec_out_params.table[i].dpa_cls_td !=
-						DPA_OFFLD_DESC_NONE)
-			dpa_classif_table_free(ipsec_params.
-					pre_sec_out_params.table[i].dpa_cls_td);
-
-	return 0;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
deleted file mode 100644
index 82c45f6..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/main.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/fsl_bman.h>
-#include <linux/fsl_qman.h>
-
-#include "ports_conf.h"
-#include "common.h"
-#include "dbgfs_ctl.h"
-
-static int dl_loop;
-module_param(dl_loop, int, 0);
-MODULE_PARM_DESC(dl_loop, "\tEnable MAC loopback for DL port\n");
-
-int config_loopback(int fm_id, int port_id, int set);
-int check_ports(void);
-int genl_ctl_init(void);
-int genl_ctl_exit(void);
-void cleanup_xfrm_km(void);
-void cleanup_ipsec_offload(int dpa_ipsec_id);
-
-
-int __init usecase_init(void)
-{
-	int ret = 0;
-
-	ret = check_ports();
-	if (ret < 0)
-		return ret;
-
-	if (dl_loop) {
-		ret = config_loopback(FM, DL_RX, 1);
-		if (ret) {
-			pr_err("%s(%d): Cannot set loopback on DL_RX port!\n",
-				__func__, __LINE__);
-			goto dl_loop_exit;
-		}
-		pr_info("DL_RX port MAC loopback set\n");
-	}
-
-	ret = genl_ctl_init();
-	if (ret < 0) {
-		pr_err("%s(%d): Failed to register DPA_IPACC genl family\n",
-			__func__, __LINE__);
-		goto dl_loop_exit;
-	}
-	pr_info("Registered DPA_IPACC genl family\n");
-
-	return 0;
-
-dl_loop_exit:
-	config_loopback(FM, DL_RX, 0);
-	return ret;
-}
-
-
-void __exit usecase_exit(void)
-{
-	int ret;
-
-	dbgfs_cleanup();
-	pr_info("Unregistering DPA_IPACC genl family\n");
-	ret = genl_ctl_exit();
-	if (ret)
-		pr_err("%s(%d): Failed to unregister DPA_IPACC genl family %d",
-			__func__, __LINE__, ret);
-
-	if (dl_loop) {
-		pr_info("Reseting DL_RX port MAC loopback\n");
-		config_loopback(FM, DL_RX, 0);
-	}
-	cleanup_xfrm_km();
-	cleanup_ipsec_offload(dpa_ipsec_id);
-}
-
-module_init(usecase_init);
-module_exit(usecase_exit);
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h b/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
deleted file mode 100644
index 05dffc7..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/platform_defs.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _PLATFORM_H_
-#define _PLATFORM_H_
-
-/* P4080 refman dTDEC */
-#define MACCFG1_LOOPBACK				0x00000100
-#define FM_1GMAC_CMD_CONF_CTRL_OFFSET	0x100
-
-
-#define SOC_BASE					0xffe000000
-/* P4080 refman MPIC section */
-#define IIDR_BASE					0x50210
-#define JR0_INT_NUM					72
-#define JR_INT_NUM(n)					(JR0_INT_NUM + n)
-#define IIDR(n)					(IIDR_BASE + n*0x20)
-
-#endif /*_PLATFORM_H_*/
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h b/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
deleted file mode 100644
index 0702bb7..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/ports_conf.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _PORTS_H_
-#define _PORTS_H_
-
-/* In this usecase all ports are on the same FM */
-#if defined CONFIG_P4080_BUILD
-#define FM			1
-#define DL_RX			1
-#define UL_RX			0
-#define DL_POST_IPSEC_OH	1
-#define UL_PRE_IPSEC_OH		2
-#define UL_POST_IPSEC_OH	3
-#elif defined CONFIG_P3041_BUILD
-#define FM			0
-#define DL_RX			3
-#define UL_RX			4
-#define DL_POST_IPSEC_OH	1
-#define UL_PRE_IPSEC_OH		2
-#define UL_POST_IPSEC_OH	3
-#elif defined CONFIG_P5020_BUILD
-#define FM			0
-#define DL_RX			3
-#define UL_RX			4
-#define DL_POST_IPSEC_OH	1
-#define UL_PRE_IPSEC_OH		2
-#define UL_POST_IPSEC_OH	3
-#elif defined CONFIG_B4860_BUILD
-#define FM                      0
-#define DL_RX                   2
-#define UL_RX                   5
-#define DL_POST_IPSEC_OH	2
-#define UL_PRE_IPSEC_OH		3
-#define UL_POST_IPSEC_OH	4
-#endif
-#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
deleted file mode 100644
index 0ddeab5..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ /dev/null
@@ -1,1038 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/crypto.h>
-#include <linux/in.h>		/* for IP protocols, IPPROTO_ESP */
-#include <net/xfrm.h>
-#include <net/ipv6.h>
-
-#include <linux/fsl_dpa_ipsec.h>
-
-#include "ports_conf.h"
-
-#include "platform_defs.h"
-#include "genl_ctl.h"
-#include "common.h"
-#include "dbgfs_ctl.h"
-
-#define HASH_SIZE 256
-#define DPA_IPSEC_ADDR_T_IPv4 4
-#define DPA_IPSEC_ADDR_T_IPv6 6
-#define GTP_PORT 0x0868
-
-
-struct workqueue_struct *xfrm_wq;
-
-
-static const u32 jhash_initval = 0xdeadbeef;
-/* offloaded SA hash entry */
-struct sa {
-	struct hlist_node h;
-	struct xfrm_state *state;
-	int dir;
-	int sa_id;
-};
-
-struct dpa_offload_lookup_key	key;
-
-/* offloaded SA's hash table */
-static struct hlist_head sa_htable[HASH_SIZE];
-
-/* Core to run the offloading work.
-*/
-static int offld_work_cpu;
-module_param(offld_work_cpu, int, 0);
-MODULE_PARM_DESC(offld_work_cpu, "\tCPU to run offloading work");
-
-/* Algos lookup table */
-static struct alg_suite {
-	const char *aalg;
-	int icv_truncbits;
-	const char *ealg;
-	int dpa_alg;
-} algs[] = {
-	{
-		.aalg = "hmac(sha1)",
-		.icv_truncbits = 96,
-		.ealg = "cbc(des3_ede)",
-		.dpa_alg = DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_SHA_160
-	}
-};
-
-/* Parameters used by DPA IPsec runtime APIs */
-static struct xfrm_km_uparms usr_params;
-
-/* Policy walking workqueue */
-struct work_arg {
-	struct xfrm_state *x;
-	struct xfrm_policy_walk walk;
-	struct delayed_work work;
-	int from_pol;
-};
-static void work_func(struct work_struct *work);
-static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
-			    void *ptr);
-
-/*
-  Returns core number where CAAM JR0 IRQ is routed.
-  This core is used to run offloading work as auth split key
-  generation enables local BHs to receive CAAM job termination
-  notification.
-*/
-#if defined(CONFIG_P4080_BUILD) || defined(CONFIG_P5020_BUILD)
-int get_offld_work_cpu(void)
-{
-	u32 *addr, iidr;
-	int i;
-	addr = ioremap(SOC_BASE + IIDR(JR0_INT_NUM), sizeof(u32));
-	if (!addr) {
-		pr_err("%s(%d) : Cannot remap IIDR%d\n", __func__,
-		       __LINE__, JR0_INT_NUM);
-		return -1;
-	}
-	iidr = in_be32(addr);
-	iounmap(addr);
-
-	for (i = 0; iidr != 1; iidr = (iidr >> 1), i++)
-		;
-	return i;
-}
-#else
-int get_offld_work_cpu(void)
-{
-	return -ENOTSUPP;
-}
-#endif
-
-/*
- Stores a pair of xfrm_state and DPA IPsec SA on a hash table
- Hash is computed on concatenated auth and crypto keys + 1 direction byte
- */
-static struct sa *hash_sa(struct hlist_head *htable, struct xfrm_state *x,
-			  int dir, int sa_id)
-{
-	struct sa *psa;
-	unsigned int hash_val = 0;
-	unsigned char *hash_key;
-	unsigned int hash_key_size;
-	unsigned char _dir = 0;
-
-	if (!x || (sa_id == -1))
-		return NULL;
-	if (dir != XFRM_POLICY_IN && dir != XFRM_POLICY_OUT)
-		return NULL;
-
-	psa = kzalloc(sizeof(*psa), GFP_ATOMIC);
-	if (!psa) {
-		pr_err("%s(%d) : Cannot allocate hash entry\n",
-		       __func__, __LINE__);
-		return NULL;
-	}
-
-	INIT_HLIST_NODE(&psa->h);
-
-	/* 1 byte for direction */
-	hash_key_size = x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8 + 1;
-	hash_key = kzalloc(hash_key_size, GFP_ATOMIC);
-	if (!hash_key) {
-		pr_err("%s(%d) : Cannot allocate hash key\n",
-		       __func__, __LINE__);
-		kfree(psa);
-		return NULL;
-	}
-
-	memcpy(hash_key, x->aalg->alg_key, x->aalg->alg_key_len / 8);
-	memcpy(hash_key + x->aalg->alg_key_len / 8, x->ealg->alg_key,
-	       x->ealg->alg_key_len / 8);
-	if (dir == XFRM_POLICY_OUT) _dir = 1;
-	memcpy(hash_key + x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8,
-	       &_dir, 1);
-
-	hash_val =
-	    jhash((u32 *) hash_key, hash_key_size, jhash_initval) % HASH_SIZE;
-	hlist_add_head(&psa->h, sa_htable + hash_val);
-	psa->sa_id = sa_id;
-	psa->state = x;
-	psa->dir = dir;
-	kfree(hash_key);
-	return psa;
-}
-
-/*
- Retrieves a pair of xfrm_state and DPA IPsec SA id
-*/
-static struct sa *find_sa(struct hlist_head *htable, struct xfrm_state *x,
-			  int dir)
-{
-	unsigned int hash_val = 0;
-	unsigned char *hash_key;
-	unsigned int hash_key_size = 0;
-	struct hlist_node *entry;
-	int sa_found = 0;
-	unsigned char _dir = 0;
-	struct sa *psa = NULL;
-
-	if (dir != XFRM_POLICY_IN && dir != XFRM_POLICY_OUT)
-		return NULL;
-	/* 1 byte for direction */
-	hash_key_size = x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8 + 1;
-	hash_key = kzalloc(hash_key_size, GFP_ATOMIC);
-	if (!hash_key) {
-		pr_err("%s(%d): Cannot allocate hash key\n",
-		       __func__, __LINE__);
-		return NULL;
-	}
-
-	memcpy(hash_key, x->aalg->alg_key, x->aalg->alg_key_len / 8);
-	memcpy(hash_key + x->aalg->alg_key_len / 8, x->ealg->alg_key,
-	       x->ealg->alg_key_len / 8);
-	if (dir == XFRM_POLICY_OUT) _dir = 1;
-	memcpy(hash_key + x->aalg->alg_key_len / 8 + x->ealg->alg_key_len / 8,
-	       &_dir, 1);
-
-	hash_val =
-	    jhash((u32 *) hash_key, hash_key_size, jhash_initval) % HASH_SIZE;
-	hlist_for_each_entry(psa, entry, sa_htable + hash_val, h) {
-		if (psa && psa->state == x && psa->dir == dir) {
-			sa_found = 1;
-			break;
-		}
-	}
-	if (!sa_found)
-		psa = NULL;
-	kfree(hash_key);
-	return psa;
-}
-
-/* Algos suite lookup
- */
-static inline int alg_suite(struct xfrm_state *x)
-{
-	int i;
-	struct xfrm_algo_desc *aalg_desc;
-	aalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);
-	for (i = 0; i < ARRAY_SIZE(algs); i++) {
-		if (!strcmp(x->aalg->alg_name, algs[i].aalg) &&
-		    (aalg_desc->uinfo.auth.icv_truncbits ==
-		     algs[i].icv_truncbits)
-		    && !strcmp(x->ealg->alg_name, algs[i].ealg))
-			return algs[i].dpa_alg;
-	}
-	return -ENOTSUPP;
-}
-
-/* XFRM state notifications
- */
-static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
-{
-	int ret = 0;
-	unsigned int hash_val;
-	struct hlist_node *entry , *n;
-	struct sa *psa;
-	struct work_arg *work;
-	struct dpa_offload_lookup_key	key;
-	struct xfrm_state *p_state;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	int tbl_desc = DPA_OFFLD_DESC_NONE;
-
-	switch (c->event) {
-	case XFRM_MSG_EXPIRE:
-		pr_info("%s: XFRM_MSG_EXPIRE event, SPI %x\n",
-			__func__, x->id.spi);
-		break;
-
-	case XFRM_MSG_NEWAE:
-		pr_info("%s: XFRM_MSG_NEWAE event, SPI %x\n",
-			__func__, x->id.spi);
-		break;
-
-	case XFRM_MSG_DELSA:
-		pr_info("%s: XFRM_MSG_DELSA event, SPI %x\n",
-			__func__, x->id.spi);
-		psa = find_sa(sa_htable, x, XFRM_POLICY_OUT);
-		if (psa) {
-			ret = dpa_ipsec_remove_sa(psa->sa_id);
-			if (ret < 0)
-				pr_err("%s(%d): Error removing out SA (%d)\n",
-				       __func__, __LINE__, ret);
-			p_state = psa->state;
-			key.byte = key_data;
-			key.mask = NULL;
-			if (p_state->props.family == AF_INET) {
-				tbl_desc =
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-				key.size = (uint8_t)(2 * sizeof(u32));
-				*(u32 *)&key.byte[0] =
-						p_state->props.saddr.a4;
-				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
-			} else {
-				tbl_desc =
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-				key.size = (uint8_t)(2 *
-					       sizeof(p_state->props.saddr.a6));
-				memcpy(&key.byte[0], p_state->props.saddr.a6,
-					sizeof(p_state->props.saddr.a6));
-				memcpy(&key.byte[16], p_state->id.daddr.a6,
-					sizeof(p_state->id.daddr.a6));
-			}
-
-			ret = dpa_classif_table_delete_entry_by_key(tbl_desc,
-								   &key);
-			if (ret < 0)
-				pr_err("%s(%d) :Failed to remove entry #%d in "
-					"outb exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					psa->sa_id, tbl_desc);
-
-			hlist_del(&psa->h);
-			dbgfs_remove_entry(psa->sa_id);
-			kfree(psa);
-			/* remove key from outb post enc exact match table*/
-
-		}
-		psa = find_sa(sa_htable, x, XFRM_POLICY_IN);
-		if (psa) {
-			ret = dpa_ipsec_remove_sa(psa->sa_id);
-			if (ret < 0)
-				pr_info("%s(%d): error removing in SA (%d)\n",
-					__func__, __LINE__, ret);
-			hlist_del(&psa->h);
-			dbgfs_remove_entry(psa->sa_id);
-			kfree(psa);
-		}
-		break;
-
-	case XFRM_MSG_UPDSA:
-		pr_info("%s: XFRM_MSG_UPDSA event, SPI %x\n",
-			__func__, x->id.spi);
-	case XFRM_MSG_NEWSA:
-		/* Only ESP supported */
-		if (x->id.proto == IPPROTO_ESP) {
-			if (c->event == XFRM_MSG_NEWSA)
-				pr_info("%s: XFRM_MSG_NEWSA event, SPI %x\n",
-					__func__, x->id.spi);
-			work = kzalloc(sizeof(*work), GFP_KERNEL);
-			if (!work) {
-				pr_err("%s: Cannot allocate offld work\n",
-					__func__);
-				return -ENOMEM;
-			}
-			work->x = x;
-			INIT_DELAYED_WORK(&work->work, work_func);
-			schedule_delayed_work_on(offld_work_cpu, &work->work,
-						HZ);
-		}
-		break;
-
-	case XFRM_MSG_FLUSHSA:
-		pr_info("%s: XFRM_MSG_FLUSHSA event\n", __func__);
-		key.byte = key_data;
-		key.mask = NULL;
-		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
-			hlist_for_each_entry_safe(psa, entry, n,
-					     sa_htable + hash_val, h) {
-				p_state = psa->state;
-				if (psa->dir == XFRM_POLICY_IN)
-					goto remove_sa;
-
-				if (p_state->props.family == AF_INET) {
-					tbl_desc =
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-					key.size = (uint8_t)(2 * sizeof(u32));
-					*(u32 *)&key.byte[0] =
-							p_state->props.saddr.a4;
-					*(u32 *)&key.byte[4] =
-							p_state->id.daddr.a4;
-				} else {
-					tbl_desc =
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-					key.size = (uint8_t)(2 *
-					       sizeof(p_state->props.saddr.a6));
-					memcpy(&key.byte[0],
-					       p_state->props.saddr.a6,
-					       sizeof(p_state->props.saddr.a6));
-					memcpy(&key.byte[16],
-					       p_state->id.daddr.a6,
-					       sizeof(p_state->id.daddr.a6));
-				}
-				ret = dpa_classif_table_delete_entry_by_key(
-						tbl_desc, &key);
-				if (ret < 0)
-					pr_err("%s(%d) :Failed to remove entry "
-						"#%d in outb exact match table "
-						"post enc (td=%d)",
-						__func__, __LINE__, psa->sa_id,
-						tbl_desc);
-remove_sa:
-				ret = dpa_ipsec_remove_sa(psa->sa_id);
-				if (ret < 0) {
-					pr_info
-					("%s(%d) : Error removing SA (%d)\n",
-					 __func__, __LINE__, ret);
-				}
-				hlist_del(&psa->h);
-				dbgfs_remove_entry(psa->sa_id);
-				kfree(psa);
-			}
-		}
-		break;
-
-	default:
-		pr_info("%s: Unknown SA event %d\n", __func__, c->event);
-		break;
-	}
-
-	return ret;
-}
-
-/* Policy walking
-*/
-static void work_func(struct work_struct *work)
-{
-	struct work_arg *this_work = container_of((struct delayed_work *)work,
-						struct work_arg, work);
-	xfrm_policy_walk_init(&this_work->walk, XFRM_POLICY_TYPE_ANY);
-	xfrm_policy_walk(&init_net, &this_work->walk, policy_walk_func,
-			 this_work);
-	xfrm_policy_walk_done(&this_work->walk);
-	kfree(this_work);
-}
-
-static int offloaded_pol(struct xfrm_selector *sel,
-			  struct dpa_ipsec_policy_params *policies,
-			  int pol_count, int dir)
-{
-	int i;
-	bool found = false;
-
-	for (i = 0; i < pol_count; i++) {
-		struct dpa_ipsec_policy_params pol;
-		memset(&pol, 0, sizeof(pol));
-		memcpy(&pol, &policies[i], sizeof(pol));
-		if (sel->family == AF_INET) {
-			if (pol.dest_addr.addr.ipv4.word == sel->daddr.a4 &&
-			    pol.src_addr.addr.ipv4.word == sel->saddr.a4 &&
-			    pol.protocol == sel->proto &&
-			    pol.src_prefix_len == sel->prefixlen_s &&
-			    pol.dest_prefix_len == sel->prefixlen_d &&
-			    pol.l4.dest_port == sel->dport &&
-			    pol.l4.src_port == sel->sport &&
-			    pol.l4.src_port_mask == sel->sport_mask &&
-			    pol.l4.dest_port_mask == sel->dport_mask) {
-				found = true;
-				return found;
-				}
-
-		} else if (sel->family == AF_INET6) {
-			int src_cmp, dst_cmp;
-			src_cmp = memcmp(pol.src_addr.addr.ipv6.byte,
-					 sel->saddr.a6,
-					 sizeof(sel->saddr.a6));
-			dst_cmp = memcmp(pol.dest_addr.addr.ipv6.byte,
-					 sel->daddr.a6,
-					 sizeof(sel->daddr.a6));
-			if (src_cmp == 0 && dst_cmp == 0 &&
-			    pol.protocol == sel->proto &&
-			    pol.src_prefix_len == sel->prefixlen_s &&
-			    pol.dest_prefix_len == sel->prefixlen_d &&
-			    pol.l4.dest_port == sel->dport &&
-			    pol.l4.src_port == sel->sport &&
-			    pol.l4.src_port_mask == sel->sport_mask &&
-			    pol.l4.dest_port_mask == sel->dport_mask) {
-				found = true;
-				return found;
-			}
-
-		}
-	}
-
-	return found;
-}
-
-static int offload_sa(int dpa_ipsec_id,
-		      struct dpa_ipsec_sa_params *sa_params,
-		      struct xfrm_state *x,
-		      int def_sa_act_fqid,
-		      int policy_miss_fqid, int dir, int *sa_id)
-{
-	struct iphdr outer_iphdr;
-	struct ipv6hdr outer_ip6hdr;
-	struct dpa_cls_tbl_action def_sa_action;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	struct dpa_offload_lookup_key	key;
-	int tbl_desc = DPA_OFFLD_DESC_NONE;
-
-	int ret = 0;
-
-	if (dir != XFRM_POLICY_OUT && dir != XFRM_POLICY_IN)
-		return -EINVAL;
-
-	sa_params->crypto_params.auth_key = x->aalg->alg_key;
-	sa_params->crypto_params.auth_key_len =
-					(uint8_t)x->aalg->alg_key_len / 8;
-	sa_params->crypto_params.cipher_key = x->ealg->alg_key;
-	sa_params->crypto_params.cipher_key_len =
-					(uint8_t)x->ealg->alg_key_len / 8;
-
-	sa_params->spi = x->id.spi;
-	sa_params->sa_bpid = usr_params.sa_bpid;
-	sa_params->crypto_params.alg_suite = alg_suite(x);
-	sa_params->l2_hdr_size = ETH_HLEN;
-	sa_params->enable_stats = 1;
-	if (sa_params->crypto_params.alg_suite < 0)
-		return -ENOTSUPP;
-
-	if (dir == XFRM_POLICY_OUT) {
-		sa_params->sa_dir = DPA_IPSEC_OUTBOUND;
-		sa_params->start_seq_num = 1;
-		sa_params->sa_wqid = usr_params.sa_wqid;
-		key.byte = key_data;
-		key.mask = NULL;
-		if (x->props.family == AF_INET) {
-			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-			key.size = (uint8_t)(2 * sizeof(u32));
-			*(u32 *)&key.byte[0] = x->props.saddr.a4;
-			*(u32 *)&key.byte[4] = x->id.daddr.a4;
-			memset(&outer_iphdr, 0, sizeof(outer_iphdr));
-			outer_iphdr.version = IPVERSION;
-			outer_iphdr.ihl = (uint8_t)(sizeof(outer_iphdr) /
-						    sizeof(u32));
-			outer_iphdr.tot_len = (uint16_t)sizeof(outer_iphdr);
-			outer_iphdr.saddr = x->props.saddr.a4;
-			outer_iphdr.daddr = x->id.daddr.a4;
-			outer_iphdr.protocol = IPPROTO_ESP;
-			sa_params->sa_out_params.outer_ip_header = &outer_iphdr;
-			sa_params->sa_out_params.ip_ver = DPA_IPSEC_ADDR_T_IPv4;
-			sa_params->sa_out_params.ip_hdr_size =
-			    (uint16_t)sizeof(outer_iphdr);
-		} else if (x->props.family == AF_INET6) {
-			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-			key.size = (uint8_t)(2 * sizeof(x->props.saddr.a6));
-			memcpy(&key.byte[0], x->props.saddr.a6,
-				sizeof(x->props.saddr.a6));
-			memcpy(&key.byte[16], x->id.daddr.a6,
-				sizeof(x->id.daddr.a6));
-			memset(&outer_ip6hdr, 0, sizeof(outer_ip6hdr));
-			memcpy(&outer_ip6hdr.saddr, x->props.saddr.a6,
-			       sizeof(x->props.saddr.a6));
-			memcpy(&outer_ip6hdr.daddr, x->id.daddr.a6,
-			       sizeof(x->id.daddr.a6));
-			outer_ip6hdr.version = 0x6;
-			outer_ip6hdr.nexthdr = IPPROTO_ESP;
-			outer_ip6hdr.hop_limit = IPDEFTTL;
-			sa_params->sa_out_params.outer_ip_header =
-			    &outer_ip6hdr;
-			sa_params->sa_out_params.ip_hdr_size =
-			   (uint16_t)sizeof(outer_ip6hdr);
-			sa_params->sa_out_params.ip_ver = DPA_IPSEC_ADDR_T_IPv6;
-		}
-		sa_params->sa_out_params.outer_udp_header = NULL;
-		sa_params->sa_out_params.post_sec_flow_id = 0;
-		sa_params->sa_out_params.init_vector = NULL;
-	} else if (dir == XFRM_POLICY_IN) {
-		sa_params->sa_dir = DPA_IPSEC_INBOUND;
-		sa_params->sa_in_params.use_udp_encap = 0;
-		if (x->props.family == AF_INET) {
-			sa_params->sa_in_params.src_addr.version =
-			    DPA_IPSEC_ADDR_T_IPv4;
-			sa_params->sa_in_params.src_addr.addr.ipv4.word =
-			    x->props.saddr.a4;
-			sa_params->sa_in_params.dest_addr.version =
-			    DPA_IPSEC_ADDR_T_IPv4;
-			sa_params->sa_in_params.dest_addr.addr.ipv4.word =
-			    x->id.daddr.a4;
-		} else if (x->props.family == AF_INET6) {
-			sa_params->sa_in_params.src_addr.version =
-			    DPA_IPSEC_ADDR_T_IPv6;
-			memcpy(sa_params->sa_in_params.src_addr.addr.ipv6.byte,
-			       x->props.saddr.a6, sizeof(x->props.saddr.a6));
-			sa_params->sa_in_params.dest_addr.version =
-			    DPA_IPSEC_ADDR_T_IPv6;
-			memcpy(sa_params->sa_in_params.dest_addr.addr.ipv6.byte,
-			       x->id.daddr.a6, sizeof(x->id.daddr.a6));
-		}
-
-		/* default SA action */
-		memset(&def_sa_action, 0, sizeof(def_sa_action));
-		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
-		def_sa_action.enable_statistics = false;
-		def_sa_action.enq_params.new_fqid = def_sa_act_fqid;
-		def_sa_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
-		def_sa_action.enq_params.override_fqid = true;
-		sa_params->sa_in_params.post_ipsec_action = def_sa_action;
-
-		/* miss action */
-		memset(&def_sa_action, 0, sizeof(def_sa_action));
-		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
-		def_sa_action.enable_statistics = false;
-		def_sa_action.enq_params.new_fqid = policy_miss_fqid;
-		def_sa_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
-		def_sa_action.enq_params.override_fqid = true;
-		sa_params->sa_in_params.policy_miss_action = def_sa_action;
-		sa_params->sa_in_params.arw = DPA_IPSEC_ARSNONE;
-	}
-
-	ret = dpa_ipsec_create_sa(dpa_ipsec_id, sa_params, sa_id);
-
-	if (ret == 0) {
-		/* for outbound dir,  outbound SAs
-		 * are added in post ipsec exact match tables */
-		memset(&def_sa_action, 0, sizeof(def_sa_action));
-		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
-		def_sa_action.enable_statistics = false;
-		def_sa_action.enq_params.new_fqid = outb_post_tx_fqid;
-		def_sa_action.enq_params.hmd = outb_update_hmd;
-		def_sa_action.enq_params.override_fqid = true;
-
-		if (sa_params->sa_dir == DPA_IPSEC_OUTBOUND) {
-			ret = dpa_classif_table_insert_entry(tbl_desc,
-				&key, &def_sa_action, 0, NULL);
-			if (ret < 0)
-				pr_err("%s(%d) :Failed to insert entry #%d in "
-					"outb exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					*sa_id, tbl_desc);
-		}
-
-	}
-
-	return ret;
-}
-
-static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
-				 struct xfrm_selector *sel, int sa_id, int dir,
-				 int policy_act_fqid)
-{
-	int ret = 0;
-	struct dpa_cls_tbl_action policy_action;
-	struct dpa_ipsec_policy_params *pol_array = NULL;
-	int pol_count;
-	bool found_pol;
-
-	pol_count = 0;
-	found_pol = false;
-	/* Get num of sa policies */
-	ret = dpa_ipsec_sa_get_policies(sa_id, pol_array, &pol_count);
-	if (ret < 0) {
-		pr_err("%s:%d: Could not get policies for sa (%d)\n", __func__,
-			__LINE__, sa_id);
-		return ret;
-	}
-
-	if (pol_count) {
-		pol_array = kzalloc(pol_count *
-				    sizeof(struct dpa_ipsec_policy_params),
-				    GFP_KERNEL);
-		/* Get sa policies */
-		ret = dpa_ipsec_sa_get_policies(sa_id, pol_array, &pol_count);
-		if (ret < 0) {
-			pr_err("%s:%d: Could not get policies for sa (%d)\n",
-				__func__, __LINE__, sa_id);
-			return ret;
-		}
-
-		found_pol = offloaded_pol(sel, pol_array, pol_count, dir);
-	}
-
-	if (found_pol) {
-		if (dir == XFRM_POLICY_OUT)
-			pr_info("XFRM_POLICY_OUT policy was prevented "
-			      "from offloading twice\n");
-		else if (dir == XFRM_POLICY_IN)
-			pr_info("XFRM_POLICY_IN policy was prevented "
-			      "from offloading twice\n");
-		else
-			pr_info("Unknown policy was prevented "
-			      "from offloading twice\n");
-		kfree(pol_array);
-		goto no_offld_pol;
-	}
-
-	memset(pol_params, 0, sizeof(*pol_params));
-	if (dir == XFRM_POLICY_OUT) {
-		if (mtu_pre_enc > 0) {
-			struct dpa_cls_hm_update_params update_params;
-			int frag_desc, fra_cnt, max_frags;
-			memset(&update_params, 0,
-			       sizeof(struct dpa_cls_hm_update_params));
-			max_frags = ARRAY_SIZE(manip_desc);
-			update_params.fm_pcd = pcd_dev;
-			update_params.ip_frag_params.df_action =
-					DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY;
-			update_params.ip_frag_params.mtu = mtu_pre_enc;
-			update_params.ip_frag_params.scratch_bpid = fr_bpid;
-			ret = dpa_classif_set_update_hm(&update_params,
-						DPA_OFFLD_DESC_NONE,
-						&frag_desc, true,  NULL);
-			if (ret < 0) {
-				pr_err("%s:%dCould not create fragmentation "
-				       "manip handle %d\n", __func__, __LINE__,
-				       ret);
-				return ret;
-			}
-			pol_params->dir_params.type =
-					DPA_IPSEC_POL_DIR_PARAMS_MANIP;
-			pol_params->dir_params.manip_desc = frag_desc;
-			for (fra_cnt = 0; fra_cnt < max_frags; fra_cnt++)
-				if (manip_desc[fra_cnt] ==
-							DPA_OFFLD_DESC_NONE) {
-					manip_desc[fra_cnt] = frag_desc;
-					break;
-				}
-		}
-	}
-
-	if (sel->family == AF_INET) {
-		pol_params->src_addr.version = DPA_IPSEC_ADDR_T_IPv4;
-		pol_params->src_addr.addr.ipv4.word = sel->saddr.a4;
-		pol_params->dest_addr.version = DPA_IPSEC_ADDR_T_IPv4;
-		pol_params->dest_addr.addr.ipv4.word = sel->daddr.a4;
-	} else if (sel->family == AF_INET6) {
-		pol_params->src_addr.version = DPA_IPSEC_ADDR_T_IPv6;
-		memcpy(pol_params->src_addr.addr.ipv6.byte,
-			sel->saddr.a6, sizeof(sel->saddr.a6));
-		pol_params->dest_addr.version = DPA_IPSEC_ADDR_T_IPv6;
-		memcpy(pol_params->dest_addr.addr.ipv6.byte,
-			sel->daddr.a6, sizeof(sel->daddr.a6));
-	}
-	pol_params->src_prefix_len = sel->prefixlen_s;
-	pol_params->dest_prefix_len = sel->prefixlen_d;
-	pol_params->protocol = sel->proto;
-	pol_params->l4.src_port = sel->sport;
-	pol_params->l4.src_port_mask = sel->sport_mask;
-	pol_params->l4.dest_port = sel->dport;
-	pol_params->l4.dest_port_mask = sel->dport_mask;
-
-	if (sel->proto == IPPROTO_IP)
-		pol_params->masked_proto = true;
-
-	memset(&policy_action, 0, sizeof(policy_action));
-	if (dir == XFRM_POLICY_IN) {
-		policy_action.type = DPA_CLS_TBL_ACTION_ENQ;
-		policy_action.enable_statistics = false;
-		policy_action.enq_params.new_fqid = policy_act_fqid;
-		policy_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
-		policy_action.enq_params.override_fqid = true;
-		pol_params->dir_params.type = DPA_IPSEC_POL_DIR_PARAMS_ACT;
-		pol_params->dir_params.in_action = policy_action;
-	}
-
-	ret = dpa_ipsec_sa_add_policy(sa_id, pol_params);
-
-no_offld_pol:
-	return ret;
-}
-
-/*
- Loops over all XFRM policies and matches the template with the given SA.
- Creates DPA IPsec policies/SAs based on XFRM counterparts.
- */
-static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
-			    void *ptr)
-{
-	int err = 0;
-	int sa_id = -1;
-	struct sa *sa;
-	struct xfrm_state *x = ((struct work_arg *)ptr)->x;
-	int from_pol = ((struct work_arg *)ptr)->from_pol;
-	struct dpa_ipsec_sa_params sa_params;
-	struct dpa_ipsec_policy_params pol_params;
-	int def_sa_fqid, policy_fqid;
-
-	/* we support only one template per policy so only the
-	   first transform is checked */
-	if (x->props.family == AF_INET) {
-		if (!((x->id.daddr.a4 == pol->xfrm_vec[0].id.daddr.a4) &&
-		      (x->props.saddr.a4 == pol->xfrm_vec[0].saddr.a4) &&
-		      (x->id.proto == pol->xfrm_vec[0].id.proto))) {
-			/* continue walking */
-			return 0;
-		}
-	} else if (x->props.family == AF_INET6) {
-		if ((ipv6_addr_cmp((struct in6_addr *)x->id.daddr.a6,
-				   (struct in6_addr *)pol->xfrm_vec[0].id.daddr.
-				   a6)
-		     || ipv6_addr_cmp((struct in6_addr *)x->props.saddr.a6,
-				      (struct in6_addr *)pol->xfrm_vec[0].saddr.
-				      a6)
-		     || (x->id.proto != pol->xfrm_vec[0].id.proto)))
-			return 0;
-	}
-
-	if (dir == XFRM_POLICY_OUT || dir == XFRM_POLICY_IN)
-		sa = find_sa(sa_htable, x, dir);
-	else
-		return 0;	/* continue walking */
-
-	if (pol->selector.proto == IPPROTO_UDP)
-		if (pol->selector.dport == GTP_PORT)
-				policy_fqid = usr_params.
-					policy_act_fqid[DL_GTP_QUEUE];
-			else
-				policy_fqid = usr_params.
-					policy_act_fqid[DL_UDP_UPLANE_QUEUE];
-	else
-		policy_fqid = usr_params.
-				policy_act_fqid[DL_NON_UDP_UPLANE_QUEUE];
-
-	if (!sa) {
-		def_sa_fqid = policy_fqid;
-		memset(&sa_params, 0, sizeof(sa_params));
-		err = offload_sa(dpa_ipsec_id, &sa_params, x,
-				def_sa_fqid, usr_params.pol_miss_fqid,
-				dir, &sa_id);
-		if (err < 0) {
-			pr_err("%s(%d) : Error offloading out SA SPI %d (%d)\n",
-			       __func__, __LINE__, x->id.spi, err);
-			return err;
-		}
-		pr_info("Created SA SPI %x sa_id %d dir %s\n", x->id.spi,
-			sa_id, (dir == XFRM_POLICY_OUT) ? "OUT" : "IN");
-
-		err = dbgfs_create_entry(sa_id);
-
-		if (err < 0) {
-			pr_err("%s(%d) : Error creating dbgfs entry "
-				"for SA (%d), err (%d)\n",
-				__func__, __LINE__, sa_id, err);
-			return err;
-		}
-
-		sa = hash_sa(sa_htable, x, sa_params.sa_dir, sa_id);
-		if (!sa) {
-			pr_err("%s(%d) : Cannot allocate hash entry\n",
-			       __func__, __LINE__);
-			return -ENOMEM;
-		}
-
-	}
-	/* if inbound policy verification is not required, inbound policy is not
-	 * offloaded */
-	if (dir == XFRM_POLICY_IN && inb_pol_check == false)
-		goto no_offload;
-
-	err = offload_policy(&pol_params, &pol->selector, sa->sa_id, dir,
-				policy_fqid);
-	if (err < 0) {
-		pr_err("%s(%d): Error offloading policy index %d (%d)\n",
-		       __func__, __LINE__, pol->index, err);
-		return err;
-	}
-
-no_offload:
-	/* stop walking if notified by policy to avoid
-	offloading twice the same policy*/
-	if (from_pol)
-		return 1;
-
-	return 0;
-}
-
-/* XFRM policy notifications
- */
-static int xfrm_km_policy_notify(struct xfrm_policy *x, int dir,
-				 const struct km_event *c)
-{
-	int ret = 0, sa_id;
-	struct xfrm_state *state;
-	struct work_arg *work;
-	unsigned int hash_val;
-	struct hlist_node *entry, *n;
-	struct sa *psa;
-
-	switch (c->event) {
-	case XFRM_MSG_UPDPOLICY:
-		pr_info("%s: XFRM_MSG_NEWPOLICY event, policy index %d\n",
-			__func__, x->index);
-	case XFRM_MSG_NEWPOLICY:
-		if (c->event == XFRM_MSG_NEWPOLICY)
-			pr_info
-			    ("%s: XFRM_MSG_NEWPOLICY event, policy index %d\n",
-			     __func__, x->index);
-		/* we support only one template per policy so only the
-		   first transform is checked */
-		state = xfrm_state_lookup_byaddr(&init_net, 0,
-						 &x->xfrm_vec[0].id.daddr,
-						 &x->xfrm_vec[0].saddr,
-						 x->xfrm_vec[0].id.proto,
-						 x->family);
-		if (!state)
-			return -ENOENT;
-
-		if ((dir == XFRM_POLICY_IN || dir == XFRM_POLICY_OUT)) {
-			work = kzalloc(sizeof(*work), GFP_KERNEL);
-			if (!work) {
-				pr_err("%s(%d): Cannot allocate offld work\n",
-				       __func__, __LINE__);
-				return -ENOMEM;
-			}
-			work->x = state;
-			work->from_pol = 1;
-			INIT_DELAYED_WORK(&work->work, work_func);
-			schedule_delayed_work_on(offld_work_cpu, &work->work,
-						HZ);
-		}
-
-		break;
-	case XFRM_MSG_DELPOLICY:
-		pr_info("%s: XFRM_MSG_DELPOLICY event, policy index %d\n",
-			__func__, x->index);
-		break;
-	case XFRM_MSG_GETPOLICY:
-		pr_info("%s: XFRM_MSG_GETPOLICY event, policy index %d\n",
-			__func__, x->index);
-		break;
-	case XFRM_MSG_POLEXPIRE:
-		pr_info("%s: XFRM_MSG_POLEXPIRE event, policy index %d\n",
-			__func__, x->index);
-		break;
-	case XFRM_MSG_FLUSHPOLICY:
-		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
-			hlist_for_each_entry_safe(psa, entry, n,
-						sa_htable + hash_val, h) {
-				sa_id = psa->sa_id;
-				pr_info("%s: XFRM_MSG_FLUSHPOLICY. "
-					"Flushing policies for sa %d\n",
-					__func__, sa_id);
-				ret = dpa_ipsec_sa_flush_policies(sa_id);
-				if (ret < 0)
-					pr_err("%s(%d): Could not flush "
-						"policies for sa %d\n",
-						__func__, __LINE__, sa_id);
-			}
-		}
-		break;
-	}
-
-	return ret;
-
-}
-
-int xfrm_km_acquire(struct xfrm_state *x, struct xfrm_tmpl *tmpl,
-		    struct xfrm_policy *xp, int dir)
-{
-	pr_info("%s:\n", __func__);
-	return 0;
-}
-
-static int xfrm_km_initialized;
-
-/* XFRM key manager interface */
-static struct xfrm_mgr xfrm_mgr = {
-	.id = "dpa_ipacc",
-	.notify = xfrm_km_state_notify,
-	.notify_policy = xfrm_km_policy_notify,
-	.acquire = xfrm_km_acquire,
-};
-
-int init_xfrm_km(struct xfrm_km_uparms *params)
-{
-	int err = 0;
-	int core;
-
-	/* store user params for DPA IPsec runtime API */
-	usr_params = *params;
-
-	/* register ourselves as a key manager */
-	err = xfrm_register_km(&xfrm_mgr);
-	if (unlikely(err < 0)) {
-		pr_err("%s(%d): Cannot register %s XFRM key manager (%d)\n",
-		       __func__, __LINE__, xfrm_mgr.id, err);
-		return err;
-	}
-	core = get_offld_work_cpu();
-	if (core != -1)
-		offld_work_cpu = core;
-
-	xfrm_wq = create_singlethread_workqueue("xfrm_wq");
-
-	xfrm_km_initialized = 1;
-	return err;
-}
-
-void cleanup_xfrm_km(void)
-{
-	unsigned int hash_val;
-	struct hlist_node *entry, *n;
-	struct sa *psa;
-	struct dpa_offload_lookup_key	key;
-	struct xfrm_state *p_state;
-	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	int tbl_desc = DPA_OFFLD_DESC_NONE;
-	int ret = 0;
-
-	if (!xfrm_km_initialized)
-		return;
-
-	destroy_workqueue(xfrm_wq);
-	key.byte = key_data;
-	key.mask = NULL;
-	for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
-		hlist_for_each_entry_safe(psa, entry, n,
-					sa_htable + hash_val, h) {
-			p_state = psa->state;
-			if (psa->dir == XFRM_POLICY_IN)
-				goto free_node;
-
-			if (p_state->props.family == AF_INET) {
-				tbl_desc =
-				outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-				key.size = (uint8_t)(2 * sizeof(u32));
-				*(u32 *)&key.byte[0] = p_state->props.saddr.a4;
-				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
-			} else {
-				tbl_desc =
-					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-				key.size = (uint8_t)(2 *
-					       sizeof(p_state->props.saddr.a6));
-				memcpy(&key.byte[0], p_state->props.saddr.a6,
-				       sizeof(p_state->props.saddr.a6));
-				memcpy(&key.byte[16], p_state->id.daddr.a6,
-				       sizeof(p_state->id.daddr.a6));
-			}
-			ret = dpa_classif_table_delete_entry_by_key(tbl_desc,
-								&key);
-			if (ret < 0)
-				pr_err("%s(%d) :Failed to remove entry #%d in "
-					"outb exact match table post enc "
-					"(td=%d)", __func__, __LINE__,
-					psa->sa_id, tbl_desc);
-free_node:
-			hlist_del(&psa->h);
-			kfree(psa);
-		}
-	}
-	xfrm_unregister_km(&xfrm_mgr);
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c
deleted file mode 100644
index 773373f..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_utils.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/crypto.h>
-#include <linux/in.h>		/* for IP protocols, IPPROTO_ESP */
-#include <net/xfrm.h>
-
-
-#if (defined DEBUG_XFRM)
-void dump_xfrm_sa(struct xfrm_state *x)
-{
-	char authenc_name[CRYPTO_MAX_ALG_NAME];
-	int len;
-	char *xfrm_km_states[] = {
-		[XFRM_STATE_VOID] = "void",
-		[XFRM_STATE_ACQ] = "acq",
-		[XFRM_STATE_VALID] = "valid",
-		[XFRM_STATE_ERROR] = "error",
-		[XFRM_STATE_EXPIRED] = "expired",
-		[XFRM_STATE_DEAD] = "dead",
-	};
-
-	/* SA general info */
-	pr_info("\tx = %p\n", x);
-	/* SPI */
-	pr_info("\tx->id.spi = 0x%x\n", htonl(x->id.spi));
-	/* ESP/AH */
-	pr_info("\tx->id.proto = 0x%x\n", htonl(x->id.proto));
-	/* tunnel destination */
-	pr_info("\tx->id.daddr.a4 = %pI4\n", &x->id.daddr.a4);
-	pr_info("\tx->props.saddr.a4 = %pI4\n", &x->props.saddr.a4);
-	pr_info("\tx->km.state = %s\n", xfrm_km_states[x->km.state]);
-	pr_info("\tx->km.dying = %d\n", x->km.dying);
-	pr_info("\tx->data = %p\n", x->data);
-
-	/* NAT-T: x->encap is non-NULL only with UDP Encapsulation */
-	if (x->encap) {
-		struct xfrm_encap_tmpl *encap = x->encap;
-		pr_info("\tNAT-T is enabled\n");
-		pr_info("\t\tx->encap->encap_type: %s\n",
-		       encap->encap_type ==
-		       UDP_ENCAP_ESPINUDP ? "UDP_ENCAP_ESPINUDP" :
-			(encap->encap_type == UDP_ENCAP_ESPINUDP_NON_IKE ?
-				"UDP_ENCAP_ESPINUDP_NON_IKE" : "Unsupported"));
-		pr_info("\t\tx->encap->encap_sport = %d\n",
-		       ntohs(encap->encap_sport));
-		pr_info("\t\tx->encap->encap_dport = %d\n",
-		       ntohs(encap->encap_dport));
-	}
-
-	pr_info("\tx->props.mode = %d\n", x->props.mode);
-	if (x->props.mode == XFRM_MODE_TUNNEL)
-		pr_info("\tSA is TUNNEL mode!\n");
-	else if (x->props.mode == XFRM_MODE_TRANSPORT)
-		pr_info("\tSA is TRANSPORT mode!\n");
-	else
-		pr_err("\tSA has unsupported mode!\n");
-
-	/* Authentication algorithm */
-	if (x->aalg) {
-		struct xfrm_algo_desc *aalg_desc;
-		int i;
-		pr_info("\tx->aalg->alg_name = %s\n",
-		       x->aalg->alg_name);
-		pr_info("\tx->aalg->alg_key_len = %d\n",
-		       x->aalg->alg_key_len);
-		pr_info("\tx->aalg->alg_key:");
-		for (i = 0; i < x->aalg->alg_key_len / 8; i++) {
-			if (i % 16 == 0)
-				pr_cont("\n\t\t");
-			pr_cont("%02x ",
-			       (unsigned char)x->aalg->alg_key[i]);
-		}
-		pr_cont("\n");
-		aalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);
-		BUG_ON(!aalg_desc);
-		pr_info(
-		       "\taalg_desc->uinfo.auth.icv_fullbits = %d, "
-		       "aalg_desc->uinfo.auth.icv_truncbits = %d\n",
-		       aalg_desc->uinfo.auth.icv_fullbits,
-		       aalg_desc->uinfo.auth.icv_truncbits);
-		pr_info(
-		       "\taalg_desc->uinfo.auth.icv_fullbits/8 = %d, "
-		       "aalg_desc->uinfo.auth.icv_truncbits/8 = %d\n",
-		       aalg_desc->uinfo.auth.icv_fullbits / 8,
-		       aalg_desc->uinfo.auth.icv_truncbits / 8);
-	}
-	/* Encryption algorithm */
-	if (x->ealg) {
-		int i;
-		pr_info("\tx->ealg->alg_name = %s\n",
-		       x->ealg->alg_name);
-		pr_info("\tx->ealg->alg_key_len = %d\n",
-		       x->ealg->alg_key_len);
-		pr_info("\tx->ealg->alg_key:");
-		for (i = 0; i < x->ealg->alg_key_len / 8; i++) {
-			if (i % 16 == 0)
-				pr_cont("\n\t\t");
-			pr_cont("%02x ",
-			       (unsigned char)x->ealg->alg_key[i]);
-		}
-		pr_cont("\n");
-	}
-
-	if (x->aead) {
-		int i;
-		pr_info("\tx->aead->alg_name = %s\n",
-		       x->aead->alg_name);
-		pr_info("\tx->aead->alg_key_len = %d\n",
-		       x->aead->alg_key_len);
-		pr_info("\tx->aead->alg_icv_len = %d\n",
-		       x->aead->alg_icv_len);
-		pr_info("\tx->aead->alg_key:");
-		for (i = 0; i < x->aead->alg_key_len / 8; i++) {
-			if (i % 16 == 0)
-				pr_cont("\n\t\t");
-			pr_cont("%02x ",
-			       (unsigned char)x->aead->alg_key[i]);
-		}
-	}
-
-	len = snprintf(authenc_name, CRYPTO_MAX_ALG_NAME, "authenc(%s,%s)",
-		       x->aalg ? x->aalg->alg_name : "digest_null",
-		       x->ealg->alg_name);
-	BUG_ON(len > CRYPTO_MAX_ALG_NAME);
-
-	/*
-	   if (!in_atomic()) {
-	   aead = crypto_alloc_aead(authenc_name, 0, 0);
-	   BUG_ON(!aead);
-	   pr_info(
-		"\tcrypto_aead_ivsize() = %d\n", crypto_aead_ivsize(aead));
-	   crypto_free_aead(aead);
-	   }
-	 */
-	if (x->aead) {
-		pr_info("\tx->aead->alg_name = %s\n",
-		       x->aead->alg_name);
-		pr_info("\tx->aead->alg_key_len = %d\n",
-		       x->aead->alg_key_len);
-		pr_info("\tx->aead->alg_icv_len = %d\n",
-		       x->aead->alg_icv_len);
-	}
-	if (x->type) {
-		pr_info("\tx->type->description = %s\n",
-		       x->type->description);
-		pr_info("\tx->type->flags = 0x%x\n", x->type->flags);
-	}
-	/* Lifetime parameters */
-	pr_info("\tx->lft.soft_byte_limit = %lld\n",
-	       x->lft.soft_byte_limit);
-	pr_info("\tx->lft.hard_byte_limit = %lld\n",
-	       x->lft.hard_byte_limit);
-	pr_info("\tx->lft.soft_packet_limit = %lld\n",
-	       x->lft.soft_packet_limit);
-	pr_info("\tx->lft.hard_packet_limit = %lld\n",
-	       x->lft.hard_packet_limit);
-	pr_info("\tx->lft.soft_add_expires_seconds = %lld\n",
-	       x->lft.soft_add_expires_seconds);
-	pr_info("\tx->lft.hard_add_expires_seconds = %lld\n",
-	       x->lft.hard_add_expires_seconds);
-	pr_info("\tx->lft.soft_use_expires_seconds = %lld\n",
-	       x->lft.soft_use_expires_seconds);
-	pr_info("\tx->lft.hard_use_expires_seconds = %lld\n",
-	       x->lft.hard_use_expires_seconds);
-	pr_info("\n\n");
-}
-
-void dump_xfrm_selector(struct xfrm_selector *sel)
-{
-	pr_info("\tsaddr %pI4 daddr %pI4\n", &sel->saddr.a4,
-	       &sel->daddr.a4);
-	pr_info("\tprefixlen_s %d prefixlen_d %d\n", sel->prefixlen_s,
-	       sel->prefixlen_d);
-	pr_info("\tproto %d\n", sel->proto);
-	pr_info("\tsport %d dport %d\n", sel->sport, sel->dport);
-	pr_info("\tsport mask %04x dport mask %04x\n", sel->sport_mask,
-	       sel->dport_mask);
-}
-
-void dump_xfrm_template(struct xfrm_tmpl *tmpl)
-{
-	pr_info("\ttemplates:\n");
-	pr_info("\t\tdaddr %pI4 spi %x proto %d saddr %pI4 mode %d\n",
-	       &tmpl->id.daddr.a4, tmpl->id.spi, tmpl->id.proto,
-	       &tmpl->saddr.a4, tmpl->mode);
-}
-#else
-void dump_xfrm_sa(struct xfrm_state *x)
-{
-}
-
-void dump_xfrm_selector(struct xfrm_selector *sel)
-{
-}
-
-void dump_xfrm_template(struct xfrm_tmpl *tmpl)
-{
-}
-#endif
-- 
1.7.5.4

