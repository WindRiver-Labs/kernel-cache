From 5aa5e066a4e2ed1ee98a72bbb2366ac4b12ed532 Mon Sep 17 00:00:00 2001
From: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
Date: Fri, 9 Nov 2012 22:03:24 +0000
Subject: [PATCH 395/518] dpa_classifier: Add DPA Multicast API

This patch introduces a new component of DPA Classifier - Multicast
component. The Multicast API is used for managing multicast groups.
The following functions are available:

dpa_classif_mcast_create_group  - create a multicast group
dpa_classif_mcast_import_group  - import an existing group
dpa_classif_mcast_add_member    - add a new member to a group
dpa_classif_mcast_remove_member - remove an existing member from a group
dpa_classif_mcast_free_group    - remove an existing group

Signed-off-by: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  407 +++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |   30 ++
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   84 ++++
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  343 ++++++++++++++++-
 include/linux/fsl_dpa_classifier.h                 |   86 ++++-
 5 files changed, 946 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 2146b07..7d97ffc 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -65,7 +65,9 @@
 
 DEFINE_MUTEX(table_array_lock);
 DEFINE_MUTEX(hm_array_lock);
-
+#if (DPAA_VERSION >= 11)
+DEFINE_MUTEX(mcast_array_lock);
+#endif
 /* DPA Classifier table descriptor table */
 struct dpa_cls_descriptor_table		table_array = {
 	.num_descriptors	= 0,
@@ -81,7 +83,15 @@ struct dpa_cls_descriptor_table		hm_array = {
 	.object			= NULL,
 	.access			= &hm_array_lock
 };
-
+#if (DPAA_VERSION >= 11)
+/* Multicast group descriptor table */
+struct dpa_cls_descriptor_table		mcast_grp_array = {
+	.num_descriptors	= 0,
+	.used_descriptors	= 0,
+	.object			= NULL,
+	.access			= &mcast_array_lock
+};
+#endif
 
 /*
  * Gets the first free descriptor in the indicated descriptor table and fills
@@ -6094,3 +6104,396 @@ int dpa_classif_free_hm(int hmd)
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_free_hm);
+
+#if (DPAA_VERSION >= 11)
+int dpa_classif_mcast_create_group(
+		const struct dpa_cls_mcast_group_params *group_params,
+		int *grpd)
+{
+
+	t_Error err = 0;
+	struct dpa_cls_mcast_group *pgroup;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *hm;
+	uint8_t max_members;
+	struct dpa_cls_tbl_enq_action_desc	*member_params;
+	t_FmPcdFrmReplicGroupParams		grp_params;
+	t_FmPcdCcNextEngineParams		*next_engine_params;
+
+
+	memset(&grp_params, 0, sizeof(t_FmPcdFrmReplicGroupParams));
+
+
+	if (!group_params) {
+		pr_err("\nERROR: %s, %s (%d): Invalid value for group "
+			"params.\n", __FILE__, __func__, __LINE__);
+		err = -EINVAL;
+		return err;
+	}
+
+	if (!grpd) {
+		pr_err("\nERROR: %s, %s (%d): Invalid group desc\n",
+			__FILE__, __func__, __LINE__);
+		err = -EINVAL;
+		return err;
+	}
+
+	if (!group_params->max_members) {
+		pr_err("\nERROR: %s, %s (%d): Invalid value for maximum number"
+			"of members in a group\n", __FILE__, __func__,
+			__LINE__);
+		err = -EINVAL;
+		return err;
+	}
+
+	if ((group_params->max_members > DPA_CLS_MCAST_MAX_NUM_OF_ENTRIES)) {
+		pr_err("\n\nERROR: %s, %s (%d): Maximum number of members "
+			"in group is greater than %d\n", __FILE__, __func__,
+			__LINE__, DPA_CLS_MCAST_MAX_NUM_OF_ENTRIES);
+		err = -EINVAL;
+		return err;
+	}
+
+	pgroup = (typeof(pgroup))kzalloc(sizeof(struct dpa_cls_mcast_group),
+					  GFP_KERNEL);
+	if (!pgroup) {
+		pr_err("\nERROR: %s, %s (%d): No more memory for DPA multicast "
+			"groups.", __FILE__, __func__, __LINE__);
+		err = -ENOMEM;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
+	max_members = group_params->max_members;
+	*grpd = DPA_OFFLD_DESC_NONE;
+
+	err = acquire_descriptor(&mcast_grp_array, pgroup, grpd);
+	if (err < 0)
+		goto dpa_classif_mcast_create_group_error;
+
+	memcpy(&pgroup->group_params, group_params,
+		sizeof(struct dpa_cls_mcast_group_params));
+
+	/*
+	 * initialize the array of used members
+	 */
+	pgroup->member_used = (typeof(pgroup->member_used))
+			    kzalloc(sizeof(bool) *
+			    max_members, GFP_KERNEL);
+	if (!pgroup->member_used) {
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA multicast "
+			"members' index array.", __FILE__, __func__, __LINE__);
+		err = -ENOMEM;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
+	/*
+	 * set parameters for the first member
+	 */
+	member_params = &pgroup->group_params.member_params;
+
+	if (member_params->policer_params != NULL) {
+		pr_err("ERROR: %s, %s (%d): Policing for DPA Classifier flows "
+			"is not yet supported.\n", __FILE__, __func__,
+			__LINE__);
+		err = -ENOSYS;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
+
+	grp_params.maxNumOfEntries = max_members;
+	grp_params.numOfEntries = pgroup->num_members + 1;
+	next_engine_params = &grp_params.nextEngineParams[0];
+
+	next_engine_params->nextEngine = e_FM_PCD_DONE;
+	next_engine_params->params.enqueueParams.action = e_FM_PCD_ENQ_FRAME;
+	next_engine_params->params.enqueueParams.overrideFqid =
+						member_params->override_fqid;
+	next_engine_params->params.enqueueParams.newFqid =
+						member_params->new_fqid;
+
+	if (member_params->hmd != DPA_OFFLD_DESC_NONE) {
+		hm = desc_to_object(&mcast_grp_array, member_params->hmd);
+		if (!hm) {
+			pr_err("ERROR: %s, %s (%d): Invalid hm descriptor "
+				"(hmd=%d).\n", __FILE__, __func__, __LINE__,
+				member_params->hmd);
+			err = -EINVAL;
+			goto dpa_classif_mcast_create_group_error;
+		}
+
+		/*
+		 * Verify that the header manipulation op is a
+		 * chain head
+		 */
+		if (!hm->chain_head) {
+			pr_err("ERROR %s, %s (%d): Only a HM chain head can be "
+				"attached to a classifier table entry. hmd=%d "
+				"is not a chain head.\n", __FILE__, __func__,
+				__LINE__, member_params->hmd);
+			err = -EINVAL;
+			goto dpa_classif_mcast_create_group_error;
+		}
+
+		/*
+		 * Acquire the hm_node structure that is head of
+		 * the header manipulation chain
+		 */
+		hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node,
+					list_node);
+
+		next_engine_params->h_Manip = (t_Handle)hm_node->node;
+	} else
+		next_engine_params->h_Manip = NULL;
+
+	pgroup->group = FM_PCD_FrmReplicSetGroup(group_params->fm_pcd,
+						&grp_params);
+	if (!pgroup->grp_dev) {
+		pr_err("\nERROR: %s: Could not create group %d",
+			__func__, *grpd);
+		err = -EINVAL;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
+	pgroup->member_used[pgroup->num_members] = true;
+	pgroup->num_members++;
+
+	return 0;
+
+dpa_classif_mcast_create_group_error:
+	if (pgroup) {
+		kfree(pgroup->member_used);
+		kfree(pgroup);
+		put_descriptor(&mcast_grp_array, *grpd);
+	}
+
+	*grpd = DPA_OFFLD_DESC_NONE;
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_mcast_create_group);
+
+int dpa_classif_mcast_import_group(void *group, int *grpd)
+{
+	struct dpa_cls_mcast_group *pgroup;
+	t_Error err = 0;
+
+	if (!group) {
+		pr_err("\nERROR: %s, %s (%d): Invalid group handle.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	if (!grpd) {
+		pr_err("\nERROR: %s, %s (%d): Invalid group desc.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	*grpd = DPA_OFFLD_DESC_NONE;
+	pgroup = (typeof(pgroup))kzalloc(sizeof(struct dpa_cls_mcast_group),
+					  GFP_KERNEL);
+	if (!pgroup) {
+		pr_err("\nERROR: %s, %s (%d): No more memory for DPA multicast "
+			"groups.", __FILE__, __func__, __LINE__);
+		err = -ENOMEM;
+		return err;
+	}
+
+	err = acquire_descriptor(&mcast_grp_array, pgroup, grpd);
+	if (err < 0)
+		return err;
+
+	pgroup->group = group;
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_mcast_import_group);
+
+int dpa_classif_mcast_add_member(int grpd,
+		const struct dpa_cls_tbl_enq_action_desc *member_params,
+		int *membrd)
+{
+	struct dpa_cls_mcast_group *pgroup;
+	struct dpa_cls_hm_node *hm_node;
+	int member_id;
+	struct dpa_cls_hm *hm;
+	uint8_t max_members;
+	t_Error err = 0;
+	t_FmPcdFrmReplicGroupParams	grp_params;
+	t_FmPcdCcNextEngineParams	*next_engine_params;
+
+	memset(&grp_params, 0, sizeof(t_FmPcdFrmReplicGroupParams));
+	pgroup = desc_to_object(&mcast_grp_array, grpd);
+	if (!pgroup) {
+		pr_err("ERROR: %s, %s (%d): Invalid group descriptor "
+			"(grpd=%d).\n", __FILE__, __func__, __LINE__, grpd);
+		return -EINVAL;
+	}
+
+	if (!member_params) {
+		pr_err("\nERROR: %s, %s (%d): Invalid value for member "
+			"params.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	if (!membrd) {
+		pr_err("\nERROR: %s, %s (%d): Invalid member desc.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	*membrd = DPA_OFFLD_DESC_NONE;
+	if (pgroup->num_members == pgroup->group_params.max_members) {
+		pr_err("\nERROR: %s, %s (%d): Current number of members "
+			"reached maximum value %d.\n", __FILE__, __func__,
+			__LINE__, pgroup->group_params.max_members);
+		return -ENOSPC;
+	}
+
+	max_members = pgroup->group_params.max_members;
+	for (member_id = 0; member_id < max_members; member_id++)
+		if (pgroup->member_used[member_id] == false) {
+			*membrd = member_id;
+			break;
+		}
+
+	pgroup->member_used[*membrd] = true;
+	pgroup->num_members++;
+
+	if (member_params->policer_params != NULL) {
+		pr_err("ERROR: %s, %s (%d): Policing for DPA Classifier flows "
+			"is not yet supported.\n", __FILE__, __func__,
+			__LINE__);
+		err = -ENOSYS;
+		goto dpa_classif_mcast_add_member_error;
+	}
+
+
+	grp_params.maxNumOfEntries = max_members;
+	grp_params.numOfEntries = pgroup->num_members;
+	next_engine_params = &grp_params.nextEngineParams[0];
+	next_engine_params->nextEngine = e_FM_PCD_DONE;
+	next_engine_params->params.enqueueParams.action = e_FM_PCD_ENQ_FRAME;
+	next_engine_params->params.enqueueParams.overrideFqid =
+						member_params->override_fqid;
+	next_engine_params->params.enqueueParams.newFqid =
+						member_params->new_fqid;
+
+	if (member_params->hmd != DPA_OFFLD_DESC_NONE) {
+		hm = desc_to_object(&mcast_grp_array, member_params->hmd);
+		if (!hm) {
+			pr_err("ERROR: %s, %s (%d): Invalid hm descriptor "
+				"(hmd=%d).\n", __FILE__, __func__, __LINE__,
+				member_params->hmd);
+			err = -EINVAL;
+			goto dpa_classif_mcast_add_member_error;
+		}
+
+		/*
+		 * Verify that the header manipulation op is a
+		 * chain head
+		 */
+		if (!hm->chain_head) {
+			pr_err("ERROR %s, %s (%d): Only a HM chain head can be "
+				"attached to a classifier table entry. hmd=%d "
+				"is not a chain head.\n", __FILE__, __func__,
+				__LINE__, member_params->hmd);
+			err = -EINVAL;
+			goto dpa_classif_mcast_add_member_error;
+		}
+
+		/*
+		 * Acquire the hm_node structure that is head of
+		 * the header manipulation chain
+		 */
+		hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node,
+				     list_node);
+
+		next_engine_params->h_Manip = (t_Handle)hm_node->node;
+	} else
+		next_engine_params->h_Manip = NULL;
+
+	err = FM_PCD_FrmReplicAddMember(pgroup->params.fm_pcd,
+				  pgroup->group,
+				  *membrd,
+				  next_engine_params);
+	if (err != E_OK) {
+		pr_err("\nERROR: %s: Could not add member (%d) to "
+			"the group (%d)", __func__, *membrd, grpd);
+		err = -EINVAL;
+		goto dpa_classif_mcast_add_member_error;
+	}
+
+	return 0;
+
+dpa_classif_mcast_add_member_error:
+
+	pgroup->member_used[*membrd] = false;
+	pgroup->num_members--;
+	*membrd = DPA_OFFLD_DESC_NONE;
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_mcast_add_member);
+
+int dpa_classif_mcast_remove_member(int grpd, int membrd)
+{
+	struct dpa_cls_mcast_group *pgroup;
+	t_Error err = 0;
+
+	pgroup = desc_to_object(&mcast_grp_array, grpd);
+	if (!pgroup) {
+		pr_err("ERROR: %s, %s (%d): Invalid group descriptor "
+			"(grpd=%d).\n", __FILE__, __func__, __LINE__, grpd);
+		return -EINVAL;
+	}
+
+	if ((membrd < 0) || (membrd > pgroup->group_params.max_members)) {
+		pr_err("ERROR: %s, %s (%d): Invalid member descriptor "
+			"(grpd=%d).\n", __FILE__, __func__, __LINE__, membrd);
+		return -EINVAL;
+	}
+
+
+	err = FM_PCD_FrmReplicRemoveMember(pgroup->group, membrd);
+	if (err != E_OK) {
+		pr_err("\nERROR: %s, %s (%d): Could not remove member %d from  "
+			"group %d\n", __FILE__, __func__, __LINE__,
+			membrd, grpd);
+		return -EINVAL;
+	}
+
+	pgroup->num_members--;
+	pgroup->member_used[membrd] = false;
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_classif_mcast_remove_member);
+
+int dpa_classif_mcast_free_group(int grpd)
+{
+	struct dpa_cls_mcast_group *pgroup;
+	t_Error err = 0;
+
+	pgroup = desc_to_object(&mcast_grp_array, grpd);
+	if (!pgroup) {
+		pr_err("ERROR: %s, %s (%d): Invalid group descriptor "
+			"(grpd=%d).\n", __FILE__, __func__, __LINE__, grpd);
+		return -EINVAL;
+	}
+
+	err = FM_PCD_FrmReplicDeleteGroup(pgroup->group);
+	if (err != E_OK) {
+		pr_err("\nERROR: %s, %s (%d): Could not delete group (%d)\n",
+			__FILE__, __func__, __LINE__, grpd);
+		return -EINVAL;
+	}
+
+
+	kfree(pgroup->member_used);
+	put_descriptor(&mcast_grp_array, grpd);
+	kfree(pgroup);
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_classif_mcast_free_group);
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index a5762f5..7a16d8b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -78,6 +78,9 @@
 #define unused(x)						(x = x)
 
 
+#if (DPAA_VERSION >= 11)
+#define DPA_CLS_MCAST_MAX_NUM_OF_ENTRIES			64
+#endif
 /* Index management entry */
 struct dpa_cls_tbl_entry {
 
@@ -320,7 +323,34 @@ struct dpa_cls_hm {
 	 */
 	struct list_head		list_node;
 };
+#if (DPAA_VERSION >= 11)
+struct dpa_cls_mcast_group {
+	/*
+	 * Group descriptor
+	 */
+	int		grpd;
 
+	/*
+	 * Group parameters
+	 */
+	struct		dpa_cls_mcast_group_params group_params;
+
+	/*
+	 * Current number of members
+	 */
+	unsigned int	num_members;
+
+	/*
+	 * Members' ids used in the group
+	*/
+	bool		*member_used;
+
+	/*
+	 * External group handle
+	 */
+	void		*group;
+};
+#endif
 #ifdef __DPA_CLASSIFIER_C
 /*
  * Allocates the array of internally managed Cc nodes based on
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index cf06684..a14b276 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -173,6 +173,28 @@ struct ioc_dpa_cls_hm_mpls_params {
 	int modify_flags;
 };
 
+struct ioc_dpa_cls_mcast_group_params {
+	struct dpa_cls_mcast_group_params mcast_grp_params;
+	int grpd;
+};
+
+struct ioc_dpa_cls_mcast_import_params {
+	void *group;
+	int grpd;
+};
+
+struct ioc_dpa_cls_mcast_member_params {
+	int grpd;
+	struct dpa_cls_tbl_enq_action_desc member_params;
+	int membrd;
+};
+
+struct ioc_dpa_cls_mcast_remove_params {
+	int grpd;
+	int membrd;
+};
+
+
 #ifdef CONFIG_COMPAT
 
 struct dpa_cls_compat_tbl_params {
@@ -444,6 +466,27 @@ struct compat_ioc_dpa_cls_hm_mpls_params {
 	int modify_flags;
 };
 
+struct dpa_cls_compat_mcast_group_params {
+	uint8_t	max_members;
+	compat_uptr_t	fm_pcd;
+	struct	dpa_cls_compat_tbl_enq_action_desc member_params;
+};
+
+struct compat_ioc_dpa_cls_mcast_group_params {
+	struct dpa_cls_compat_mcast_group_params mcast_grp_params;
+	int grpd;
+};
+
+struct compat_ioc_dpa_cls_mcast_import_params {
+	compat_uptr_t group;
+	int grpd;
+};
+
+struct compat_ioc_dpa_cls_mcast_member_params {
+	int grpd;
+	struct dpa_cls_compat_tbl_enq_action_desc member_params;
+	int membrd;
+};
 
 int dpa_cls_tbl_entry_params_compatcpy(
 	struct ioc_dpa_cls_tbl_entry_params			*kparam,
@@ -525,6 +568,13 @@ int dpa_cls_hm_mpls_params_compatcpy(
 	struct ioc_dpa_cls_hm_mpls_params			*kparam,
 	const struct compat_ioc_dpa_cls_hm_mpls_params		*uparam);
 
+int dpa_cls_mcast_group_params_compatcpy(
+	struct ioc_dpa_cls_mcast_group_params			*kparam,
+	struct compat_ioc_dpa_cls_mcast_group_params		*uparam);
+
+int dpa_cls_mcast_member_params_compatcpy(
+	struct ioc_dpa_cls_mcast_member_params			*kparam,
+	struct compat_ioc_dpa_cls_mcast_member_params		*uparam);
 #endif /* CONFIG_COMPAT */
 
 
@@ -750,4 +800,38 @@ int dpa_cls_hm_mpls_params_compatcpy(
 #define DPA_CLS_IOC_FREE_HM				\
 	_IOR(DPA_CLS_IOC_MAGIC, 30, int)
 
+#define DPA_CLS_IOC_MCAST_CREATE_GROUP				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 31, struct ioc_dpa_cls_mcast_group_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MCAST_CREATE_GROUP			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 31,				\
+	      struct compat_ioc_dpa_cls_mcast_group_params)
+#endif
+
+#define DPA_CLS_IOC_MCAST_IMPORT_GROUP				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 32, struct ioc_dpa_cls_mcast_import_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MCAST_IMPORT_GROUP			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 32,				\
+	      struct compat_ioc_dpa_cls_mcast_import_params)
+#endif
+
+#define DPA_CLS_IOC_MCAST_ADD_MEMBER				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 33, struct ioc_dpa_cls_mcast_member_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MCAST_ADD_MEMBER			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 33,				\
+	      struct compat_ioc_dpa_cls_mcast_member_params)
+#endif
+
+#define DPA_CLS_IOC_MCAST_REMOVE_MEMBER				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 34, struct ioc_dpa_cls_mcast_remove_params)
+
+#define DPA_CLS_IOC_MCAST_FREE_GROUP				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 35, struct ioc_dpa_cls_hm_mpls_params)
+
+
 #endif /* __DPA_CLASSIFIER_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 48c3ae7..45818e9 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -191,6 +191,12 @@ static long do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode);
 
 static long do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_mcast_create_group(unsigned long args, bool compat_mode);
+
+static long do_ioctl_mcast_import_group(unsigned long args, bool compat_mode);
+
+static long do_ioctl_mcast_add_member(unsigned long args, bool compat_mode);
+
 void *translate_fm_pcd_handle(void *fm_pcd);
 
 static const struct file_operations dpa_classif_fops = {
@@ -553,7 +559,65 @@ long wrp_dpa_classif_do_ioctl(
 	case DPA_CLS_IOC_FREE_HM:
 		ret = dpa_classif_free_hm((int)args);
 		break;
-
+#ifdef CONFIG_COMPAT
+	case	DPA_CLS_IOC_COMPAT_MCAST_CREATE_GROUP:
+#endif /* CONFIG_COMPAT */
+	case	DPA_CLS_IOC_MCAST_CREATE_GROUP:
+		ret = do_ioctl_mcast_create_group(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
+	case	DPA_CLS_IOC_COMPAT_MCAST_IMPORT_GROUP:
+#endif /* CONFIG_COMPAT */
+	case	DPA_CLS_IOC_MCAST_IMPORT_GROUP:
+		ret = do_ioctl_mcast_import_group(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
+	case	DPA_CLS_IOC_COMPAT_MCAST_ADD_MEMBER:
+#endif /* CONFIG_COMPAT */
+	case	DPA_CLS_IOC_MCAST_ADD_MEMBER:
+		ret = do_ioctl_mcast_add_member(args, compat_mode);
+		break;
+	case	DPA_CLS_IOC_MCAST_REMOVE_MEMBER: {
+		struct ioc_dpa_cls_mcast_remove_params params;
+		int sz;
+		sz = sizeof(struct ioc_dpa_cls_mcast_remove_params);
+		if (copy_from_user(&params,
+				 (struct ioc_dpa_cls_mcast_remove_params *)args,
+				 sz)) {
+			pr_err("ERROR: %s, %s (%d):Could not copy parameters",
+				__FILE__, __func__, __LINE__);
+			return -EINVAL;
+			}
+#if (DPAA_VERSION >= 11)
+		ret = dpa_classif_mcast_remove_member(params.grpd,
+						      params.membrd);
+#else
+		pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
+		       "platform.\n", __FILE__, __func__, __LINE__);
+		ret = -EINVAL;
+		return ret;
+#endif
+		break;
+	}
+	case	DPA_CLS_IOC_MCAST_FREE_GROUP: {
+		int grpd;
+		if (copy_from_user(&grpd, (int *)args, sizeof(int))) {
+			pr_err("ERROR: %s, %s (%d):Could not copy parameters",
+				__FILE__, __func__, __LINE__);
+			return -EINVAL;
+		}
+#if (DPAA_VERSION >= 11)
+		ret = dpa_classif_mcast_free_group(grpd);
+#else
+		pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
+		       "platform.\n", __FILE__, __func__, __LINE__);
+		ret = -EINVAL;
+		return ret;
+#endif
+		if (ret < 0)
+			return ret;
+		break;
+	}
 	default:
 		pr_err("ERROR: %s, %s (%d): DPA Classifier ioctl command "
 			"(0x%x) not suppoted", __FILE__, __func__, __LINE__,
@@ -1453,6 +1517,227 @@ static long  do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode)
 					kparam.modify_flags);
 }
 
+static long do_ioctl_mcast_create_group(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_mcast_group_params kparam;
+	struct dpa_cls_tbl_policer_params policer_params;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_mcast_group_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		kparam.mcast_grp_params.member_params.policer_params =
+								&policer_params;
+		/*
+		 * Transfer the data into the kernel space params:
+		 */
+		ret = dpa_cls_mcast_group_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/*
+	 * Translate FM_PCD file descriptor
+	 */
+	if ((long)kparam.mcast_grp_params.fm_pcd >= 0) {
+		kparam.mcast_grp_params.fm_pcd =
+			translate_fm_pcd_handle(kparam.mcast_grp_params.fm_pcd);
+		if (!kparam.mcast_grp_params.fm_pcd)
+			return -EINVAL;
+	}
+
+	if (kparam.mcast_grp_params.member_params.policer_params) {
+		if (copy_from_user(&policer_params,
+				kparam.mcast_grp_params.member_params.
+				policer_params,
+			sizeof(policer_params))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"policer params.\n", __FILE__, __func__,
+				__LINE__);
+			return -EBUSY;
+		}
+		kparam.mcast_grp_params.member_params.policer_params =
+								&policer_params;
+	}
+#if (DPAA_VERSION >= 11)
+	ret = dpa_classif_mcast_create_group(&kparam.mcast_grp_params,
+					     &kparam.grpd);
+#else
+	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
+	       "platform.\n", __FILE__, __func__, __LINE__);
+	ret = -EINVAL;
+	return ret;
+#endif
+
+	if (ret < 0)
+		return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.grpd = kparam.grpd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) <--\n", __func__,
+		__LINE__));
+
+	return ret;
+}
+
+static long do_ioctl_mcast_import_group(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_mcast_import_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_mcast_import_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+		kparam.group = compat_get_id2ptr(uparam.group,
+						FM_MAP_TYPE_PCD_NODE);
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+#if (DPAA_VERSION >= 11)
+	ret = dpa_classif_mcast_import_group(kparam.group,
+					     &kparam.grpd);
+#else
+	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
+	       "platform.\n", __FILE__, __func__, __LINE__);
+	ret = -EINVAL;
+	return ret;
+#endif
+	if (ret < 0)
+		return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.grpd = kparam.grpd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) <--\n", __func__,
+		__LINE__));
+
+	return ret;
+}
+
+static long do_ioctl_mcast_add_member(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_mcast_member_params kparam;
+	struct dpa_cls_tbl_policer_params policer_params;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_mcast_member_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		kparam.member_params.policer_params = &policer_params;
+		/*
+		 * Transfer the data into the kernel space params:
+		 */
+		ret = dpa_cls_mcast_member_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	if (kparam.member_params.policer_params) {
+		if (copy_from_user(&policer_params,
+				kparam.member_params.policer_params,
+					sizeof(policer_params))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"policer params.\n", __FILE__, __func__,
+				__LINE__);
+			return -EBUSY;
+		}
+
+		kparam.member_params.policer_params = &policer_params;
+	}
+#if (DPAA_VERSION >= 11)
+	ret = dpa_classif_mcast_add_member(kparam.grpd, &kparam.member_params,
+					    &kparam.membrd);
+#else
+	pr_err("ERROR: %s, %s (%d): Multicast not supported  on this"
+	       "platform.\n", __FILE__, __func__, __LINE__);
+	ret = -EINVAL;
+	return ret;
+#endif
+	if (ret < 0)
+		return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.membrd = kparam.membrd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) <--\n", __func__,
+		__LINE__));
+
+	return ret;
+}
+
+
 static long do_ioctl_table_modify_miss_action(unsigned long	args,
 					bool			compat_mode)
 {
@@ -2615,4 +2900,60 @@ int dpa_cls_hm_mpls_params_compatcpy(
 	return 0;
 }
 
+int dpa_cls_mcast_group_params_compatcpy(
+		struct ioc_dpa_cls_mcast_group_params *kparam,
+		struct compat_ioc_dpa_cls_mcast_group_params *uparam)
+{
+	kparam->mcast_grp_params.max_members =
+					uparam->mcast_grp_params.max_members;
+	kparam->mcast_grp_params.fm_pcd = compat_ptr(uparam->mcast_grp_params.
+							fm_pcd);
+	kparam->mcast_grp_params.member_params.override_fqid =
+			uparam->mcast_grp_params.member_params.override_fqid;
+	kparam->mcast_grp_params.member_params.new_fqid =
+			uparam->mcast_grp_params.member_params.new_fqid;
+	if (compat_ptr(uparam->mcast_grp_params.member_params.policer_params)) {
+		if (copy_from_user(kparam->mcast_grp_params.member_params.
+				policer_params,
+			compat_ptr(uparam->mcast_grp_params.member_params.
+					policer_params),
+			sizeof(struct dpa_cls_tbl_policer_params))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"policer params.\n", __FILE__, __func__,
+				__LINE__);
+			return -EBUSY;
+		}
+	} else
+		kparam->mcast_grp_params.member_params.policer_params = NULL;
+
+	kparam->mcast_grp_params.member_params.hmd =
+				uparam->mcast_grp_params.member_params.hmd;
+
+	return 0;
+}
+
+int dpa_cls_mcast_member_params_compatcpy(
+		struct ioc_dpa_cls_mcast_member_params *kparam,
+		struct compat_ioc_dpa_cls_mcast_member_params *uparam)
+{
+	kparam->grpd = uparam->grpd;
+	kparam->member_params.hmd = uparam->member_params.hmd;
+	kparam->member_params.new_fqid = uparam->member_params.new_fqid;
+	kparam->member_params.override_fqid =
+					uparam->member_params.override_fqid;
+	if (compat_ptr(uparam->member_params.policer_params)) {
+		if (copy_from_user(kparam->member_params.policer_params,
+			compat_ptr(uparam->member_params.policer_params),
+			sizeof(struct dpa_cls_tbl_policer_params))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"policer params.\n", __FILE__, __func__,
+				__LINE__);
+			return -EBUSY;
+		}
+	} else
+		kparam->member_params.policer_params = NULL;
+
+	return 0;
+}
+
 #endif /* CONFIG_COMPAT */
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 7be3ca3..b3ad095 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -78,7 +78,13 @@ enum dpa_cls_tbl_action_type {
 	DPA_CLS_TBL_ACTION_ENQ,
 
 	/* Go to another table and re-classify the packet */
-	DPA_CLS_TBL_ACTION_NEXT_TABLE
+	DPA_CLS_TBL_ACTION_NEXT_TABLE,
+
+	/*
+	 * Send frames to a multicast group
+	 */
+	DPA_CLS_TBL_ACTION_MCAST
+
 };
 
 /* DPA Classifier Table Entry Modification Types */
@@ -267,6 +273,20 @@ struct dpa_cls_tbl_next_table_desc {
 	int		next_td;
 };
 
+struct dpa_cls_tbl_mcast_group_desc {
+
+	/*
+	 * Descriptor of the multicast group to use with a specific table entry.
+	 */
+	int		grpd;
+
+	/*
+	 * Descriptor of the header manipulation chain that will be performed
+	 * before sending the frames to the multicast group
+	 */
+	int		hmd;
+};
+
 /* DPA Classifier action descriptor */
 struct dpa_cls_tbl_action {
 
@@ -289,6 +309,13 @@ struct dpa_cls_tbl_action {
 		 * classifier table
 		 */
 		struct dpa_cls_tbl_next_table_desc	next_table_params;
+
+		/*
+		 * Specific parameters for sending the frame to a multicast
+		 * group
+		 */
+		struct dpa_cls_tbl_mcast_group_desc	mcast_params;
+
 	};
 };
 
@@ -1448,4 +1475,61 @@ int dpa_classif_modify_mpls_hm(int hmd,
 int dpa_classif_free_hm(int hmd);
 
 
+/*
+ * Multicast API
+ */
+
+/*
+ * Multicast group parameters
+ */
+struct dpa_cls_mcast_group_params {
+	/*
+	 * Maximum number of members in group
+	 */
+	uint8_t		max_members;
+
+	/*
+	 * Handle of the FM PCD that owns the Cc node that will
+	 * point to the group
+	 */
+	void		*fm_pcd;
+
+	/*
+	 * Member parameters. A group must have at least
+	 * one member
+	 */
+	struct		dpa_cls_tbl_enq_action_desc member_params;
+};
+
+/*
+ * Creates a multicast group with one member
+ */
+int dpa_classif_mcast_create_group(
+		const struct dpa_cls_mcast_group_params *group_params,
+		int *grpd);
+
+/*
+ * Creates a multicast group based on an existing replicator returned by
+ * the fmc tool
+ */
+int dpa_classif_mcast_import_group(void *group, int *grpd);
+
+/*
+ * Adds a new member to a multicast group
+ */
+int dpa_classif_mcast_add_member(int grpd,
+		const struct dpa_cls_tbl_enq_action_desc *member_params,
+		int *membrd);
+
+/*
+ * Removes a member from a multicast group
+ */
+int dpa_classif_mcast_remove_member(int grpd, int membrd);
+
+/*
+ * Removes an existing group
+ */
+int dpa_classif_mcast_free_group(int grpd);
+
+
 #endif /* __FSL_DPA_CLASSIFIER_H */
-- 
1.7.5.4

