From 1d9642a5db2e96b3c361189efc6a689741400ad7 Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Thu, 28 Jun 2012 14:24:17 +0000
Subject: [PATCH 247/518] dpa_offload_use_case: Transmit only the ccnodes
 handles from userspace

This module initially permited to execute the fmc model into kernel space
and return  the handles used by ipsec classifier tables. Due to the
problems introduced by 32 bit userspace / 64 bit kernel space which
would have implied modifications in fmlib and also a compatible fmc_model structure,
the ccnodes will be generated in userspace by fmc_exec and sent to
kernel space through netlink.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/Makefile  |    2 -
 drivers/staging/fsl_dpa_offload/usecases/common.h  |    4 -
 .../staging/fsl_dpa_offload/usecases/fm_utils.c    |   41 -
 drivers/staging/fsl_dpa_offload/usecases/fmc.h     |  217 ------
 .../staging/fsl_dpa_offload/usecases/fmc_exec.c    |  783 --------------------
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |   80 ++-
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |   19 +
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |   21 +-
 drivers/staging/fsl_dpa_offload/usecases/main.c    |    2 -
 .../staging/fsl_dpa_offload/usecases/pcd_init.c    |  127 ----
 10 files changed, 79 insertions(+), 1217 deletions(-)
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc.h
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/usecases/pcd_init.c

diff --git a/drivers/staging/fsl_dpa_offload/usecases/Makefile b/drivers/staging/fsl_dpa_offload/usecases/Makefile
index 1ae1be6..ac461cc 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/Makefile
+++ b/drivers/staging/fsl_dpa_offload/usecases/Makefile
@@ -12,8 +12,6 @@ obj-$(CONFIG_FSL_IPACC_USECASES) = fsl_ipacc_uc.o
 fsl_ipacc_uc-objs += 		main.o \
 				fm_utils.o \
 				genl_ctl.o \
-				fmc_exec.o \
-				pcd_init.o \
 				ipsec_init.o \
 				xfrm_km.o \
 				xfrm_utils.o \
diff --git a/drivers/staging/fsl_dpa_offload/usecases/common.h b/drivers/staging/fsl_dpa_offload/usecases/common.h
index 3a48a68..927ffb6 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/common.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/common.h
@@ -40,11 +40,7 @@ t_LnxWrpFmPortDev *get_fm_port(int fm_idx,
 				int port_idx,
 				e_FmPortType port_type);
 
-extern struct fmc_model_t cmodel;
 
-extern t_Handle cc_in_rx;
-extern t_Handle cc_flow_id;
-extern t_Handle cc_out_pre_enc[2];
 
 extern int dpa_ipsec_id;
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
index d2ef5d7..810786a 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
@@ -38,7 +38,6 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include "lnxwrp_fm.h"
-#include "fmc.h"
 #include "ports_conf.h"
 #include "platform_defs.h"
 
@@ -308,43 +307,3 @@ int check_ports(void)
 
 	return 0;
 }
-
-/*
-	returns handles to fmc_exec.c
- */
-t_Handle SYS_GetHandle(fm_type entity, int id)
-{
-	t_LnxWrpFmDev *fm;
-	t_LnxWrpFmPortDev *port;
-	static int fm_id;
-	t_Handle h_obj = NULL;
-
-	switch (entity) {
-	case e_SYS_SUBMODULE_FM:
-		fm = get_fm(id);
-		if (fm) {
-			fm_id = fm->id;
-			h_obj = fm->h_Dev;
-		}
-		break;
-	case e_SYS_SUBMODULE_FM_PCD:
-		fm = get_fm(fm_id);
-		if (fm)
-			h_obj = fm->h_PcdDev;
-		break;
-	case e_SYS_SUBMODULE_FM_PORT_HO:
-		port = get_fm_port(fm_id, id,
-				   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
-		h_obj = port->h_Dev;
-		break;
-	case e_SYS_SUBMODULE_FM_PORT_1GRx:
-		port = get_fm_port(fm_id, id, e_FM_PORT_TYPE_RX);
-		h_obj = port->h_Dev;
-		break;
-	default:
-		pr_err("\nInvalid element type\n");
-		break;
-	}
-
-	return h_obj;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc.h b/drivers/staging/fsl_dpa_offload/usecases/fmc.h
deleted file mode 100644
index 9722028..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/fmc.h
+++ /dev/null
@@ -1,217 +0,0 @@
-/* ============================================================================
- *
- * Copyright (c) 2009-2012, Freescale Semiconductor, Inc.
- *
- * MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without
- * limitation the rights to use, copy, modify, merge, publish, distribute,
- * sublicense, and/or sell copies of the Software, and to permit persons
- * to whom the Software is furnished to do so, subject to the following
- * conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- *  File Name : fmc.h
- *  Author    : Serge Lamikhov-Center
- *
- * ========================================================================= */
-
-#ifndef LIBFMC_H
-#define LIBFMC_H
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-#include <std_ext.h>
-#include <error_ext.h>
-#include <part_ext.h>
-#include <fm_ext.h>
-#include <Peripherals/fm_pcd_ext.h>
-#include <Peripherals/fm_port_ext.h>
-
-#define FMC_OUTPUT_FORMAT_VER 0x104
-
-#define FMC_NAME_LEN             64
-#define FMC_FMAN_NUM              2
-#define FMC_PORTS_PER_FMAN       16
-#define FMC_SCHEMES_NUM          32
-#define FMC_SCHEME_PROTOCOLS_NUM 16
-#define FMC_CC_NODES_NUM        256
-#define FMC_PLC_NUM              64
-#define MAX_SP_CODE_SIZE      0x7C0
-#define FMC_MANIP_MAX             8
-#define FMC_INSERT_MAX           56
-
-#define FMC_APPLY_ORDER( Index, Type, Element ) \
-    .ao[Index].type  = Type,                    \
-    .ao[Index].index = Element
-
-typedef enum fm_type {
-	e_SYS_SUBMODULE_FM = 0,
-	e_SYS_SUBMODULE_FM_PCD,
-	e_SYS_SUBMODULE_FM_PORT_HO,
-	e_SYS_SUBMODULE_FM_PORT_1GRx
-} fm_type;
-
-typedef struct fmc_fman_t {
-    unsigned int       number;
-    unsigned int       port_count;
-    unsigned int       ports[FMC_PORTS_PER_FMAN];
-    char               name[FMC_NAME_LEN];
-    t_Handle           handle;
-    char               pcd_name[FMC_NAME_LEN];
-    t_Handle           pcd_handle;
-
-#ifndef P1023
-    unsigned int       offload_support;
-
-    unsigned int       reasm_count;
-    t_FmPcdManipParams reasm[FMC_MANIP_MAX];
-    char               reasm_name[FMC_MANIP_MAX][FMC_NAME_LEN];
-    t_Handle           reasm_handle[FMC_MANIP_MAX];
-
-    unsigned int       frag_count;
-    t_FmPcdManipParams frag[FMC_MANIP_MAX];
-    char               frag_name[FMC_MANIP_MAX][FMC_NAME_LEN];
-    t_Handle           frag_handle[FMC_MANIP_MAX];
-
-	unsigned int       hdr_count;
-    t_FmPcdManipParams hdr[FMC_MANIP_MAX];
-	uint8_t			   insertData[FMC_MANIP_MAX][FMC_INSERT_MAX];
-    char               hdr_name[FMC_MANIP_MAX][FMC_NAME_LEN];
-    t_Handle           hdr_handle[FMC_MANIP_MAX];
-#endif /* P1023 */
-} fmc_fman;
-
-
-typedef struct fmc_port_t {
-    e_FmPortType         type;                      ///< Port type
-    unsigned int         number;                    ///< Port number
-    t_FmPcdNetEnvParams  distinctionUnits;          ///< Port's network env
-    t_FmPortPcdParams    pcdParam;
-    t_FmPortPcdPrsParams prsParam;
-    t_FmPortPcdKgParams  kgParam;
-    t_FmPortPcdCcParams  ccParam;
-    char                 name[FMC_NAME_LEN];
-    t_Handle             handle;
-    t_Handle             env_id_handle;
-    t_Handle             cctree_handle;
-
-    unsigned int         schemes_count;             ///< Number of used schemes
-    unsigned int         schemes[FMC_SCHEMES_NUM];  ///< Schemes used by this port
-
-    unsigned int         ccnodes_count;             ///< Number of used CC nodes
-    unsigned int         ccnodes[FMC_CC_NODES_NUM]; ///< Class. nodes used by this port
-
-    unsigned int         ccroot_count;
-    unsigned int         ccroot[FMC_CC_NODES_NUM];
-#ifndef P1023
-	unsigned int         ccroot_manip[FMC_CC_NODES_NUM];
-#endif /* P1023 */
-
-    unsigned int         reasm_index;
-} fmc_port;
-
-
-typedef enum fmc_apply_order_e {
-    FMCEngineStart,
-    FMCEngineEnd,
-    FMCPortStart,
-    FMCPortEnd,
-    FMCScheme,
-    FMCCCNode,
-    FMCCCTree,
-    FMCPolicer
-} fmc_apply_order_e;
-
-
-typedef struct fmc_apply_order_t {
-    fmc_apply_order_e   type;
-    unsigned int        index;
-} fmc_apply_order;
-
-
-typedef struct fmc_model_t {
-    unsigned int             format_version;
-    unsigned int             sp_enable;           ///< Soft parser enable flag
-    t_FmPcdPrsSwParams       sp;                  ///< Soft parser configuration
-    uint8_t                  spCode[MAX_SP_CODE_SIZE];
-
-    unsigned int             fman_count;                ///< Number of used FMan engines
-    fmc_fman                 fman[FMC_FMAN_NUM];
-
-    unsigned int             port_count;                ///< Number of used FMan ports
-    fmc_port                 port[FMC_FMAN_NUM * FMC_PORTS_PER_FMAN];
-
-    unsigned int             scheme_count;     ///< Number of used KeyGen schemes
-    char                     scheme_name  [FMC_SCHEMES_NUM][FMC_NAME_LEN];
-    t_Handle                 scheme_handle[FMC_SCHEMES_NUM];
-    t_FmPcdKgSchemeParams    scheme       [FMC_SCHEMES_NUM];
-
-    unsigned int             ccnode_count;       ///< Number of used CC nodes
-    char                     ccnode_name         [FMC_CC_NODES_NUM][FMC_NAME_LEN];
-    t_Handle                 ccnode_handle       [FMC_CC_NODES_NUM];
-    t_FmPcdCcNodeParams      ccnode              [FMC_CC_NODES_NUM];
-    uint8_t                  cckeydata           [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS]
-                                                 [FM_PCD_MAX_SIZE_OF_KEY];
-    unsigned char            ccmask              [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS]
-                                                 [FM_PCD_MAX_SIZE_OF_KEY];
-    unsigned int             ccentry_action_index[FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
-    unsigned char            ccentry_frag        [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
-	unsigned char            ccentry_manip       [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
-    unsigned int             ccmiss_action_index [FMC_CC_NODES_NUM];
-
-    unsigned int             policer_count; ///< Number of used policers
-    char                     policer_name        [FMC_PLC_NUM][FMC_NAME_LEN];
-    t_FmPcdPlcrProfileParams policer             [FMC_PLC_NUM];
-    t_Handle                 policer_handle      [FMC_PLC_NUM];
-    unsigned int             policer_action_index[FMC_PLC_NUM][3];
-
-    unsigned int             ao_count;               ///< Number of 'apply order' elements
-    fmc_apply_order          ao[FMC_FMAN_NUM*FMC_PORTS_PER_FMAN*(FMC_SCHEMES_NUM+FMC_CC_NODES_NUM)];
-} fmc_model;
-
-
-int fmc_compile(
-        fmc_model*   model,
-        const char*  nameCfg,
-        const char*  namePCD,
-        const char*  namePDL,
-        const char*  nameSP,
-        unsigned int swOffset,
-        unsigned int dontWarn,
-        const char** dump
-);
-
-int fmc_execute( fmc_model* model );
-
-int fmc_clean( fmc_model* model );
-
-const char* fmc_get_error( void );
-
-t_Handle fmc_get_handle(
-            fmc_model*   model,
-            unsigned int engine_number,
-            e_FmPortType port_type,
-            unsigned int port_number,
-            const char*  name
-);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif // LIBFMC_H
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c b/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c
deleted file mode 100644
index 61bb6ee..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c
+++ /dev/null
@@ -1,783 +0,0 @@
-/* ============================================================================
- *
- * Copyright (c) 2009-2012, Freescale Semiconductor, Inc.
- *
- * MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without
- * limitation the rights to use, copy, modify, merge, publish, distribute,
- * sublicense, and/or sell copies of the Software, and to permit persons
- * to whom the Software is furnished to do so, subject to the following
- * conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- *  File Name : fmc_exec.c
- *  Author    : Serge Lamikhov-Center
- *
- * ========================================================================= */
-
-#include <linux/kernel.h>
-
-#ifdef NETCOMM_SW
-    #include "sys_ext.h"
-#endif
-
-#include "fmc.h"
-
-t_Handle SYS_GetHandle(fm_type entity, int id);
-// Forward declaration of static functions
-static int fmc_exec_engine_start( fmc_model* model, unsigned int index,
-                                  unsigned int* p_relative_scheme_index );
-static int fmc_exec_engine_end  ( fmc_model* model, unsigned int index );
-static int fmc_exec_port_start  ( fmc_model* model, unsigned int engine,
-                                  unsigned int index );
-static int fmc_exec_port_end    ( fmc_model* model, unsigned int engine,
-                                  unsigned int index );
-static int fmc_exec_scheme      ( fmc_model* model,  unsigned int engine,
-                                  unsigned int port, unsigned int index,
-                                  unsigned int relative_scheme_index );
-static int fmc_exec_ccnode      ( fmc_model* model, unsigned int engine,
-                                  unsigned int index );
-static int fmc_exec_cctree      ( fmc_model* model,  unsigned int engine,
-                                  unsigned int port );
-static int fmc_exec_policer     ( fmc_model* model, unsigned int engine,
-                                  unsigned int index );
-
-static int fmc_clean_engine_start( fmc_model* model, unsigned int index );
-static int fmc_clean_engine_end  ( fmc_model* model, unsigned int index );
-static int fmc_clean_port_start  ( fmc_model* model, unsigned int engine,
-                                   unsigned int index );
-static int fmc_clean_port_end    ( fmc_model* model, unsigned int engine,
-                                   unsigned int index );
-static int fmc_clean_scheme      ( fmc_model* model,  unsigned int engine,
-                                   unsigned int port, unsigned int index );
-static int fmc_clean_ccnode      ( fmc_model* model, unsigned int engine,
-                                   unsigned int index );
-static int fmc_clean_cctree      ( fmc_model* model,  unsigned int engine,
-                                   unsigned int port );
-static int fmc_clean_policer     ( fmc_model* model, unsigned int engine,
-                                   unsigned int index );
-
-
-/* -------------------------------------------------------------------------- */
-int
-fmc_execute( fmc_model* model )
-{
-    int          ret                   = 0;
-    unsigned int current_engine        = 0;
-    unsigned int current_port          = 0;
-    unsigned int relative_scheme_index = 0;
-    unsigned int i;
-
-    if ( model->format_version != FMC_OUTPUT_FORMAT_VER ) {
-        return 0xFFFFFFFF;
-    }
-
-    for ( i = 0; i < model->ao_count; i++ ) {
-        switch ( model->ao[i].type ) {
-            case FMCEngineStart:
-                current_engine        = model->ao[i].index;
-                relative_scheme_index = 0;
-                ret = fmc_exec_engine_start( model, current_engine,
-                                             &relative_scheme_index );
-                break;
-            case FMCEngineEnd:
-                ret = fmc_exec_engine_end( model, current_engine );
-                break;
-            case FMCPortStart:
-                current_port = model->ao[i].index;
-                ret = fmc_exec_port_start( model, current_engine, current_port );
-                break;
-            case FMCPortEnd:
-                ret = fmc_exec_port_end( model, current_engine, current_port );
-                break;
-            case FMCScheme:
-                ret = fmc_exec_scheme( model, current_engine, current_port,
-                                       model->ao[i].index, relative_scheme_index++ );
-                break;
-            case FMCCCNode:
-                ret = fmc_exec_ccnode( model, current_engine, model->ao[i].index );
-                break;
-            case FMCCCTree:
-                ret = fmc_exec_cctree( model, current_engine, model->ao[i].index );
-                break;
-            case FMCPolicer:
-                ret = fmc_exec_policer( model, current_engine, model->ao[i].index );
-                break;
-			default:
-				break;
-        }
-
-        // Exit the loop in case of failure
-        if ( ret != 0 ) {
-            break;
-        }
-    }
-
-    return ret;
-}
-
-
-/* -------------------------------------------------------------------------- */
-int
-fmc_clean( fmc_model* model )
-{
-    int          ret = 0;
-    unsigned int current_engine;
-    unsigned int current_port;
-    unsigned int i, j;
-
-    if ( model->format_version != FMC_OUTPUT_FORMAT_VER ) {
-        return 0xFFFFFFFF;
-    }
-
-    for ( j = 0; j < model->ao_count; j++ ) {
-        // Clean entities in reverse order of applying
-        i = model->ao_count - j - 1;
-        switch ( model->ao[i].type ) {
-            case FMCEngineStart:
-                current_engine = model->ao[i].index;
-                ret = fmc_clean_engine_start( model, current_engine );
-                break;
-            case FMCEngineEnd:
-                current_engine = model->ao[i].index;
-                ret = fmc_clean_engine_end( model, current_engine );
-                break;
-            case FMCPortStart:
-                current_port = model->ao[i].index;
-                ret = fmc_clean_port_start( model, current_engine, current_port );
-                break;
-            case FMCPortEnd:
-                current_port = model->ao[i].index;
-                ret = fmc_clean_port_end( model, current_engine, current_port );
-                break;
-            case FMCScheme:
-                ret = fmc_clean_scheme( model, current_engine, current_port,
-                                        model->ao[i].index );
-                break;
-            case FMCCCNode:
-                ret = fmc_clean_ccnode( model, current_engine, model->ao[i].index );
-                break;
-            case FMCCCTree:
-                ret = fmc_clean_cctree( model, current_engine, model->ao[i].index );
-                break;
-            case FMCPolicer:
-                ret = fmc_clean_policer( model, current_engine, model->ao[i].index );
-                break;
-			default:
-				break;
-        }
-
-        // Exit the loop in case of failure
-        if ( ret != 0 ) {
-            break;
-        }
-    }
-
-    return ret;
-}
-
-
-/* -------------------------------------------------------------------------- */
-t_Handle
-fmc_get_handle(
-            fmc_model*   model,
-            unsigned int engine_number,
-            e_FmPortType port_type,
-            unsigned int port_number,
-            const char*  name
-)
-{
-    unsigned int engine  = 0;
-    unsigned int port    = 0;
-    unsigned int found   = 0;
-    unsigned int ccindex = 0;
-    unsigned int i;
-
-    // Find engine index
-    for ( engine = 0; engine < model->fman_count; engine++ ) {
-        if ( model->fman[engine].number == engine_number ) {
-            found = 1;
-            break;
-        }
-    }
-    if ( !found ) {
-        return 0;
-    }
-
-    // Check whether it is a 'policy' name. Return PCD handle then
-    if ( strcmp( model->fman[engine].pcd_name, name ) == 0 ) {
-        return model->fman[engine].pcd_handle;
-    }
-
-#ifndef P1023
-    // Check fragmentation names
-    for ( i = 0; i < model->fman[engine].frag_count; i++ ) {
-        if ( strcmp( model->fman[engine].frag_name[i], name ) == 0 ) {
-            return model->fman[engine].frag_handle[i];
-        }
-    }
-
-	// Check reassembly names
-    for ( i = 0; i < model->fman[engine].reasm_count; i++ ) {
-        if ( strcmp( model->fman[engine].reasm_name[i], name ) == 0 ) {
-            return model->fman[engine].reasm_handle[i];
-        }
-    }
-
-	// Check header manip names
-    for ( i = 0; i < model->fman[engine].hdr_count; i++ ) {
-        if ( strcmp( model->fman[engine].hdr_name[i], name ) == 0 ) {
-            return model->fman[engine].hdr_handle[i];
-        }
-    }
-#endif /* P1023 */
-
-    // Find port index
-    found = 0;
-    for ( port = 0; port < model->fman[engine].port_count; port++ ) {
-        unsigned int port_index = model->fman[engine].ports[port];
-        if ( model->port[port_index].type   == port_type &&
-             model->port[port_index].number == port_number ) {
-            found = 1;
-            break;
-        }
-    }
-    if ( !found ) {
-        return 0;
-    }
-
-    // Find CC handle according to found engine and port
-    for ( ccindex =0; ccindex < model->port[port].ccnodes_count; ccindex++ ) {
-        unsigned int index = model->port[port].ccnodes[ccindex];
-        if ( strcmp( model->ccnode_name[index], name ) == 0 ) {
-            return model->ccnode_handle[index];
-        }
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_engine_start( fmc_model* model, unsigned int index,
-                       unsigned int* p_relative_scheme_index )
-{
-#ifndef P1023
-    unsigned int i;
-#endif
-
-    t_FmPcdParams fmPcdParams = {0};
-
-    // Open FMan device
-#ifndef NETCOMM_SW
-    model->fman[index].handle = FM_Open( model->fman[index].number );
-#else
-    model->fman[index].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM,
-                                               model->fman[index].number );
-#endif
-    if ( model->fman[index].handle == 0 ) {
-        return 1;
-    }
-
-    // Open FMan device
-    fmPcdParams.h_Fm = model->fman[index].handle;
-#ifndef NETCOMM_SW
-    model->fman[index].pcd_handle = FM_PCD_Open( &fmPcdParams );
-#else
-    model->fman[index].pcd_handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PCD,
-                                                   model->fman[index].number );
-#endif
-    if ( model->fman[index].pcd_handle == 0 ) {
-        return 2;
-    }
-
-    if ( model->sp_enable ) {
-        FM_PCD_PrsLoadSw( model->fman[index].pcd_handle, &(model->sp) );
-    }
-#ifndef P1023
-    if ( model->fman[index].reasm_count     > 0 ||
-         model->fman[index].frag_count      > 0 ||
-         model->fman[index].offload_support > 0 ) {
-        FM_PCD_SetAdvancedOffloadSupport( model->fman[index].pcd_handle );
-    }
-#endif /* P1023 */
-
-    FM_PCD_Enable( model->fman[index].pcd_handle );
-
-#ifndef P1023
-    for ( i = 0; i < model->fman[index].reasm_count; i++ ) {
-		if ( model->fman[index].reasm[i].u.reassem.hdr == HEADER_TYPE_IPv6 ) {
-			model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[0] =
-                (*p_relative_scheme_index)++;
-            model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[1] =
-                (*p_relative_scheme_index)++;
-        }
-        else {
-            model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[0] =
-                (*p_relative_scheme_index)++;
-        }
-
-        model->fman[index].reasm_handle[i] =
-            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
-                                 &model->fman[index].reasm[i] );
-    }
-
-    for ( i = 0; i < model->fman[index].frag_count; i++ ) {
-        model->fman[index].frag_handle[i] =
-            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
-                                 &model->fman[index].frag[i] );
-    }
-
-	for ( i = 0; i < model->fman[index].hdr_count; i++ ) {
-		if ( model->fman[index].hdr[i].u.hdr.insrt )
-		{
-			model->fman[index].hdr[i].u.hdr.insrtParams.u.generic.p_Data = model->fman[index].insertData[i];
-		}
-
-        model->fman[index].hdr_handle[i] =
-            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
-                                 &model->fman[index].hdr[i] );
-    }
-#endif /* P1023 */
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_engine_end( fmc_model* model, unsigned int index )
-{
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_port_start( fmc_model* model, unsigned int engine, unsigned int port )
-{
-    t_FmPortParams  fmPortParam      = {0};
-
-    fmc_fman* pengine = &model->fman[engine];
-    fmc_port* pport   = &model->port[port];
-
-    fmPortParam.h_Fm     = pengine->handle;
-    fmPortParam.portId   = pport->number;
-    fmPortParam.portType = pport->type;
-
-#ifndef NETCOMM_SW
-    model->port[port].handle = FM_PORT_Open( &fmPortParam );
-#else
-    if (fmPortParam.portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        model->port[port].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PORT_HO,
-                                                  fmPortParam.portId );
-    else
-        model->port[port].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PORT_1GRx,
-                                                  fmPortParam.portId );
-#endif
-    if ( pport->handle == 0 ) {
-        return 3;
-    }
-
-    pport->env_id_handle = FM_PCD_NetEnvCharacteristicsSet(
-                                pengine->pcd_handle,
-                                &pport->distinctionUnits );
-    if ( pport->env_id_handle == 0 ) {
-        return 4;
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_port_end( fmc_model* model, unsigned int engine, unsigned int port )
-{
-    t_Error err;
-    fmc_port* pport = &model->port[port];
-    unsigned int i;
-
-    unsigned int        reasm_index;
-    reasm_index            		= model->port[port].reasm_index;
-
-    pport->pcdParam.h_NetEnv    = pport->env_id_handle;
-    pport->pcdParam.p_PrsParams = &pport->prsParam;
-    pport->pcdParam.h_IpReassemblyManip = model->fman[engine].reasm_handle[reasm_index - 1];
-
-    // Add KeyGen runtime parameters
-    if ( pport->schemes_count != 0 ) {
-        pport->kgParam.numOfSchemes = pport->schemes_count;
-
-        pport->pcdParam.p_KgParams = &pport->kgParam;
-        for ( i = 0; i < pport->schemes_count; ++i ) {
-            pport->pcdParam.p_KgParams->h_Schemes[ i ] =
-                model->scheme_handle[ pport->schemes[i] ];
-        }
-    }
-
-    // Add CC runtime parameters
-    if ( pport->ccnodes_count != 0 || pport->reasm_index > 0 ) {
-        pport->pcdParam.p_CcParams           = &pport->ccParam;
-        pport->pcdParam.p_CcParams->h_CcTree = pport->cctree_handle;
-    }
-
-    err = FM_PORT_Disable( pport->handle );
-    if ( err ) { return 5; }
-    err = FM_PORT_SetPCD( pport->handle, &pport->pcdParam );
-    if ( err ) { return 6; }
-    err = FM_PORT_Enable( pport->handle );
-    if ( err ) { return 7; }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_scheme( fmc_model* model,  unsigned int engine,
-                 unsigned int port, unsigned int index,
-                 unsigned int relative_scheme_index )
-{
-    model->scheme[index].netEnvParams.h_NetEnv = model->port[port].env_id_handle;
-    model->scheme[index].id.relativeSchemeId   = relative_scheme_index;
-
-    // Fill next engine handles
-    if ( model->scheme[index].nextEngine == e_FM_PCD_CC ) {
-        model->scheme[index].kgNextEngineParams.cc.h_CcTree =
-                                                model->port[port].cctree_handle;
-    }
-
-    model->scheme_handle[index] =
-	FM_PCD_KgSchemeSet( model->fman[engine].pcd_handle,
-                            &(model->scheme[index]) );
-    if ( model->scheme_handle[index] == 0 ) {
-        return 5;
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_ccnode( fmc_model* model, unsigned int engine,
-                 unsigned int index )
-{
-    unsigned int i;
-    unsigned int action_index;
-
-    for ( i = 0; i < model->ccnode[index].keysParams.numOfKeys; ++i ) {
-        action_index = model->ccentry_action_index[index][i];
-        if ( model->ccnode[index].keysParams.keyParams[i]
-                               .ccNextEngineParams.nextEngine == e_FM_PCD_KG ) {
-            model->ccnode[index].keysParams.keyParams[i]
-                .ccNextEngineParams.params.kgParams.h_DirectScheme =
-                                             model->scheme_handle[action_index];
-        }
-        else if ( model->ccnode[index].keysParams.keyParams[i]
-                               .ccNextEngineParams.nextEngine == e_FM_PCD_CC ) {
-            model->ccnode[index].keysParams.keyParams[i]
-                .ccNextEngineParams.params.ccParams.h_CcNode =
-                                             model->ccnode_handle[action_index];
-        }
-
-#ifndef P1023
-        if ( model->ccentry_frag[index][i] != 0 ) {
-            model->ccnode[index].keysParams.keyParams[i].ccNextEngineParams.h_Manip =
-                model->fman[engine].frag_handle[ model->ccentry_frag[index][i] - 1 ];
-        }
-
-		if ( model->ccentry_manip[index][i] != 0 ) {
-            model->ccnode[index].keysParams.keyParams[i].ccNextEngineParams.h_Manip =
-                model->fman[engine].hdr_handle[ model->ccentry_manip[index][i] - 1 ];
-        }
-#endif /* P1023 */
-
-		if (model->ccnode[index].extractCcParams.extractNonHdr.action == e_FM_PCD_ACTION_INDEXED_LOOKUP) {
-			model->ccnode[index].keysParams.keyParams[i].p_Key = NULL;
-			model->ccnode[index].keysParams.keyParams[i].p_Mask = NULL;
-		} else {
-			model->ccnode[index].keysParams.keyParams[i].p_Key =
-				model->cckeydata[index][i];
-			model->ccnode[index].keysParams.keyParams[i].p_Mask =
-				model->ccmask[index][i];
-		}
-    }
-
-    action_index = model->ccmiss_action_index[index];
-    if ( model->ccnode[index].keysParams.ccNextEngineParamsForMiss
-                           .nextEngine == e_FM_PCD_KG ) {
-        model->ccnode[index].keysParams.ccNextEngineParamsForMiss
-            .params.kgParams.h_DirectScheme =
-                                         model->scheme_handle[action_index];
-    }
-    else if ( model->ccnode[index].keysParams.ccNextEngineParamsForMiss
-                           .nextEngine == e_FM_PCD_CC ) {
-        model->ccnode[index].keysParams.ccNextEngineParamsForMiss
-            .params.ccParams.h_CcNode = model->ccnode_handle[action_index];
-    }
-
-
-    model->ccnode_handle[index] =
-	FM_PCD_MatchTableSet( model->fman[engine].pcd_handle,
-                          &(model->ccnode[index]) );
-
-    if ( model->ccnode_handle[index] == 0 ) {
-        return 6;
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_cctree( fmc_model* model, unsigned int engine,
-                 unsigned int port )
-{
-    static t_FmPcdCcTreeParams ccTreeParams = { 0 };
-#ifndef P1023
-    unsigned int        reasm_index;
-#endif /* P1023 */
-    unsigned int        i;
-
-    memset(&ccTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
-    ccTreeParams.numOfGrps = model->port[port].ccroot_count;
-    ccTreeParams.h_NetEnv  = model->port[port].env_id_handle;
-#ifndef P1023
-    reasm_index            = model->port[port].reasm_index;
-#endif /* P1023 */
-
-    for ( i = 0; i < model->port[port].ccroot_count; ++i ) {
-        ccTreeParams.ccGrpParams[i].numOfDistinctionUnits = 0;
-        ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].
-            nextEngine = e_FM_PCD_CC;
-        ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].
-            params.ccParams.h_CcNode =
-                model->ccnode_handle[model->port[port].ccroot[i]];
-#ifndef P1023
-		if ( model->port[port].ccroot_manip[i] > 0 )
-		{
-			ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].h_Manip =
-				model->fman[engine].hdr_handle[model->port[port].ccroot_manip[i] - 1];
-		}
-#endif /* P1023 */
-    }
-
-    model->port[port].cctree_handle =
-	FM_PCD_CcRootBuild( model->fman[engine].pcd_handle,
-                            &ccTreeParams );
-    if ( model->port[port].cctree_handle == 0 ) {
-        return 7;
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_exec_policer( fmc_model* model, unsigned int engine,
-                  unsigned int index )
-{
-    unsigned int action_index;
-
-    // Fill next engine handles
-    action_index = model->policer_action_index[index][0];
-    switch ( model->policer[index].nextEngineOnGreen ) {
-        case e_FM_PCD_PLCR:
-            model->policer[index].paramsOnGreen.h_Profile =
-                model->policer_handle[action_index];
-            break;
-        case e_FM_PCD_KG:
-            model->policer[index].paramsOnGreen.h_DirectScheme =
-                model->scheme_handle[action_index];
-            break;
-		default:
-			break;
-    }
-    action_index = model->policer_action_index[index][1];
-    switch ( model->policer[index].nextEngineOnYellow ) {
-        case e_FM_PCD_PLCR:
-            model->policer[index].paramsOnYellow.h_Profile =
-                model->policer_handle[action_index];
-            break;
-        case e_FM_PCD_KG:
-            model->policer[index].paramsOnYellow.h_DirectScheme =
-                model->scheme_handle[action_index];
-            break;
-		default:
-			break;
-    }
-    action_index = model->policer_action_index[index][2];
-    switch ( model->policer[index].nextEngineOnRed ) {
-        case e_FM_PCD_PLCR:
-            model->policer[index].paramsOnRed.h_Profile =
-                model->policer_handle[action_index];
-            break;
-        case e_FM_PCD_KG:
-            model->policer[index].paramsOnRed.h_DirectScheme =
-                model->scheme_handle[action_index];
-            break;
-		default:
-			break;
-    }
-
-    model->policer_handle[index] =
-        FM_PCD_PlcrProfileSet( model->fman[engine].pcd_handle,
-                               &(model->policer[index]) );
-    if ( model->policer_handle[index] == 0 ) {
-        return 8;
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_engine_start( fmc_model* model, unsigned int index )
-{
-    unsigned int i;
-
-#ifndef P1023
-    for ( i = 0; i < model->fman[index].frag_count; i++ ) {
-        FM_PCD_ManipNodeDelete( model->fman[index].frag_handle[i] );
-    }
-
-    for ( i = 0; i < model->fman[index].reasm_count; i++ ) {
-        FM_PCD_ManipNodeDelete( model->fman[index].reasm_handle[i] );
-    }
-
-	for ( i = 0; i < model->fman[index].hdr_count; i++ ) {
-        FM_PCD_ManipNodeDelete( model->fman[index].hdr_handle[i] );
-    }
-#endif /* P1023 */
-
-    if ( model->fman[index].pcd_handle != 0 ) {
-#ifndef NETCOMM_SW
-        FM_PCD_Close( model->fman[index].pcd_handle );
-#endif
-    }
-    if ( model->fman[index].handle != 0 ) {
-#ifndef NETCOMM_SW
-        FM_Close( model->fman[index].handle );
-#endif
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_engine_end( fmc_model* model, unsigned int index )
-{
-    FM_PCD_Disable( model->fman[index].pcd_handle );
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_port_start( fmc_model* model, unsigned int engine, unsigned int port )
-{
-    fmc_port* pport = &model->port[port];
-
-    if ( pport->handle == 0 ) {
-        return 0;
-    }
-
-    FM_PCD_NetEnvCharacteristicsDelete( pport->env_id_handle );
-
-#ifndef NETCOMM_SW
-    FM_PORT_Close( pport->handle );
-#endif
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_port_end( fmc_model* model, unsigned int engine, unsigned int port )
-{
-    t_Error err;
-    fmc_port* pport = &model->port[port];
-
-    if ( pport->handle == 0 ) {
-        return 0;
-    }
-
-    err = FM_PORT_DeletePCD( pport->handle );
-    if ( err ) { return 6; }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_scheme( fmc_model* model,  unsigned int engine,
-                 unsigned int port, unsigned int index )
-{
-    if ( model->scheme_handle[index] != 0 ) {
-        FM_PCD_KgSchemeDelete( model->scheme_handle[index] );
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_ccnode( fmc_model* model, unsigned int engine,
-                 unsigned int index )
-{
-    if ( model->ccnode_handle[index] != 0 ) {
-        FM_PCD_MatchTableDelete( model->ccnode_handle[index] );
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_cctree( fmc_model* model, unsigned int engine,
-                 unsigned int port )
-{
-    if ( model->port[port].cctree_handle != 0 ) {
-        FM_PCD_CcRootDelete( model->port[port].cctree_handle );
-    }
-
-    return 0;
-}
-
-
-/* -------------------------------------------------------------------------- */
-static int
-fmc_clean_policer( fmc_model* model, unsigned int engine,
-                  unsigned int index )
-{
-    if ( model->policer_handle[index] != 0 ) {
-        FM_PCD_PlcrProfileDelete( model->policer_handle[index] );
-    }
-
-    return 0;
-}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
index 95ddff0..3dbe6d6 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -34,12 +34,20 @@
 #include <linux/kernel.h>
 #include <net/xfrm.h>
 #include <net/ipv6.h>
-#include "fmc.h"
 
 #include "genl_ctl.h"
 
-struct fmc_model_t cmodel;
+#ifdef CONFIG_COMPAT
+#include <Peripherals/fm_pcd_ext.h>
+#include <Peripherals/fm_port_ext.h>
+#include "fm_port_ioctls.h"
+#include "lnxwrp_ioctls_fm_compat.h"
+
+struct compat_ipsec_fm_uparms compat_fm_params;
+#endif /* CONFIG_COMPAT */
+
 int dpa_ipsec_id;
+struct ipsec_fm_uparms fm_params;
 
 int fmc_config(void);
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params);
@@ -326,45 +334,51 @@ out:
 	return rc;
 }
 
-static int put_fmc_model(struct sk_buff *skb_2, struct genl_info *info)
+
+static int put_fm_params(struct sk_buff *skb_2, struct genl_info *info)
 {
 	int rc = 0;
 	struct nlattr *na;
 	struct sk_buff *skb;
 	void *msg_head;
-	static u8 *buff = (u8 *)&cmodel;
-
-	na = info->attrs[A_FMC_MODEL_PART];
-	if (na) {
-		memcpy(buff, (typeof(buff))nla_data(na),
-			na->nla_len - NLA_HDRLEN);
-		buff += na->nla_len - NLA_HDRLEN;
-	} else {
-		na = info->attrs[A_FMC_MODEL_LAST];
-		if (na) {
-			memcpy(buff, (typeof(buff))nla_data(na),
-				na->nla_len - NLA_HDRLEN);
-			buff += na->nla_len - NLA_HDRLEN;
-
-			rc = fmc_config();
-			if (rc) {
-				pr_err("%s(%d) : Error applying PCD\n",
-					__func__, __LINE__);
-				return rc;
-			}
-
-		} else {
-			pr_err("%s(%d) : no A_FMC_MODEL_PART or "
-				" A_FMC_MODEL_LAST attr in user info",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
+	int size, data_size;
+
+	na = info->attrs[A_FM_PARAMS];
+	if (!na) {
+		pr_err("%s(%d) : no A_FM_PARAMS (%d) attr in user info\n",
+			__func__, __LINE__, A_FM_PARAMS);
+		return -EINVAL;
 	}
+
+	data_size = na->nla_len - NLA_HDRLEN;
+	size = sizeof(typeof(fm_params));
+#ifdef CONFIG_COMPAT
+	if (size != data_size) {
+		memcpy(&compat_fm_params,
+			(typeof(&compat_fm_params))nla_data(na),
+			 na->nla_len - NLA_HDRLEN);
+		fm_params.pcd_dev = compat_ptr(compat_fm_params.pcd_dev);
+		fm_params.cc_in_rx =
+				compat_get_id2ptr(compat_fm_params.cc_in_rx,
+						FM_MAP_TYPE_PCD_NODE);
+		fm_params.cc_flow_id =
+				compat_get_id2ptr(compat_fm_params.cc_flow_id,
+						FM_MAP_TYPE_PCD_NODE);
+		fm_params.cc_out_pre_enc[0] =
+			compat_get_id2ptr(compat_fm_params.cc_out_pre_enc[0],
+					FM_MAP_TYPE_PCD_NODE);
+		fm_params.cc_out_pre_enc[1] =
+			compat_get_id2ptr(compat_fm_params.cc_out_pre_enc[1],
+					FM_MAP_TYPE_PCD_NODE);
+	} else
+#endif
+	memcpy(&fm_params, (typeof(&fm_params))nla_data(na), data_size);
+
 	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
 	if (!skb)
 		return -ENOMEM;
 	msg_head = genlmsg_put(skb, 0, info->snd_seq + 1, &dpa_ipacc_family,
-				0, C_PUT_FMC_MODEL);
+				0, C_PUT_FM_PARAMS);
 	if (!msg_head) {
 		kfree_skb(skb);
 		return -ENOMEM;
@@ -461,10 +475,10 @@ struct genl_ops dpa_ipacc_ops[] = {
 		.dumpit = NULL,
 	},
 	{
-		.cmd = C_PUT_FMC_MODEL,
+		.cmd = C_PUT_FM_PARAMS,
 		.flags = 0,
 		.policy = NULL,
-		.doit = put_fmc_model,
+		.doit = put_fm_params,
 		.dumpit = NULL,
 	},
 	{
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
index ba989df..c4b2636 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -42,6 +42,7 @@ enum genl_attr {
 	A_POL_INFO,
 	A_FMC_MODEL_PART,
 	A_FMC_MODEL_LAST,
+	A_FM_PARAMS,
 	A_INIT_IPSEC_INFO,
 	A_XFRM_KM_INFO,
 	_A_MAX,
@@ -57,6 +58,7 @@ enum genl_cmd {
 	C_GET_OFFLD_DATA_FROMSA,
 	C_GET_OFFLD_DATA_FROMPOL,
 	C_PUT_FMC_MODEL,
+	C_PUT_FM_PARAMS,
 	C_INIT_IPSEC_OFFLD,
 	C_INIT_XFRM_KM,
 	_C_MAX,
@@ -95,4 +97,21 @@ struct xfrm_km_uparms {
 	__u32 def_sa_fqid;
 	__u32 pol_miss_fqid;
 };
+
+#ifdef CONFIG_COMPAT
+struct compat_ipsec_fm_uparms {
+	compat_uptr_t pcd_dev;
+	compat_uptr_t cc_in_rx;
+	compat_uptr_t cc_flow_id;
+	compat_uptr_t cc_out_pre_enc[2];
+};
+#endif
+struct ipsec_fm_uparms {
+	void *pcd_dev;
+	void *cc_in_rx;
+	void *cc_flow_id;
+	void *cc_out_pre_enc[2];
+};
+
+
 #endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index f5ed386..15df9b5 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -31,6 +31,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/fdtable.h>
 #include <linux/fsl_dpa_ipsec.h>
 #include <linux/fsl_dpa_classifier.h>
 
@@ -47,6 +48,8 @@
 static struct dpa_ipsec_params ipsec_params;
 static int ipsec_initialized = 0;
 
+extern struct ipsec_fm_uparms fm_params;
+
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 {
 	int i, j, cls_td;
@@ -54,16 +57,18 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	int ret;
 	t_LnxWrpFmDev *fm_dev;
 	t_FmPcdParams pcd_params;
+	struct file *fm_pcd_file;
 
 	memset(&ipsec_params, 0, sizeof(ipsec_params));
 	memset(&pcd_params, 0, sizeof(pcd_params));
 
-	fm_dev = get_fm(FM);
-	if (!fm_dev) {
-		pr_err("%s(%d): Cannot get FM %d\n", __func__, __LINE__, FM);
+	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
 		return -EINVAL;
 	}
 
+	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
 	dbgfs_init_stats();
 	ipsec_params.max_sa_pairs = params->max_sa;
 
@@ -74,7 +79,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	/* INB/DL pre SEC params */
 	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
 	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-	cls_tbl_params.cc_node = cc_in_rx;
+	cls_tbl_params.cc_node = fm_params.cc_in_rx;
 	cls_tbl_params.type = DPA_CLS_TBL_HASH;
 	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
 	cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
@@ -98,7 +103,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 			OH_PORT_CHANNEL(FM, DL_POST_IPSEC_OH);
 	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
 	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-	cls_tbl_params.cc_node = cc_flow_id;
+	cls_tbl_params.cc_node = fm_params.cc_flow_id;
 	cls_tbl_params.type = DPA_CLS_TBL_INDEXED;
 	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
 	cls_tbl_params.indexed_params.entries_cnt = ipsec_params.max_sa_pairs;
@@ -121,10 +126,10 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 			OH_PORT_CHANNEL(FM, UL_POST_IPSEC_OH);
 
 	/* OUTB/UL pre SEC params */
-	for (i = 0; i < ARRAY_SIZE(cc_out_pre_enc); i++) {
+	for (i = 0; i < ARRAY_SIZE(fm_params.cc_out_pre_enc); i++) {
 		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
 		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-		cls_tbl_params.cc_node = cc_out_pre_enc[i];
+		cls_tbl_params.cc_node = fm_params.cc_out_pre_enc[i];
 		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
 		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
 		cls_tbl_params.exact_match_params.entries_cnt =
@@ -175,7 +180,7 @@ int cleanup_ipsec_offload(int dpa_ipsec_id)
 	dpa_classif_table_free(ipsec_params.
 				pre_sec_in_params.dpa_cls_td);
 
-	for (i = 0; i < ARRAY_SIZE(cc_out_pre_enc); i++)
+	for (i = 0; i < ARRAY_SIZE(fm_params.cc_out_pre_enc); i++)
 		dpa_classif_table_free(ipsec_params.
 				pre_sec_out_params.dpa_cls_td[i]);
 	dpa_ipsec_free(dpa_ipsec_id);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
index c316c5c..82c45f6 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/main.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/main.c
@@ -46,7 +46,6 @@ int config_loopback(int fm_id, int port_id, int set);
 int check_ports(void);
 int genl_ctl_init(void);
 int genl_ctl_exit(void);
-void fmc_cleanup(void);
 void cleanup_xfrm_km(void);
 void cleanup_ipsec_offload(int dpa_ipsec_id);
 
@@ -102,7 +101,6 @@ void __exit usecase_exit(void)
 	}
 	cleanup_xfrm_km();
 	cleanup_ipsec_offload(dpa_ipsec_id);
-	fmc_cleanup();
 }
 
 module_init(usecase_init);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c b/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c
deleted file mode 100644
index fbf6c4e..0000000
--- a/drivers/staging/fsl_dpa_offload/usecases/pcd_init.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include "fmc.h"
-#include "ports_conf.h"
-
-#include "common.h"
-
-/* cc nodes required by DPA IPsec offloading */
-t_Handle cc_in_rx, cc_flow_id, cc_out_pre_enc[2];
-static int pcd_initialized;
-
-int fmc_config(void)
-{
-	int ret;
-	char ccnode_path[64];
-	/* execute fmc model */
-	ret = fmc_execute(&cmodel);
-	if (ret != E_OK) {
-		pr_err("%s(%d) : Failed to execute the fmc model\n",
-			__func__, __LINE__);
-		return -EINVAL;
-	}
-
-	/* get cc nodes handles */
-	memset(ccnode_path, 0, sizeof(ccnode_path));
-	sprintf(ccnode_path, "fm%d/port/1G/%d/ccnode/dl_rx_e_IN_RX_ccnode",
-		FM, DL_RX);
-	cc_in_rx = fmc_get_handle(&cmodel, FM, e_FM_PORT_TYPE_RX, DL_RX,
-				/*"dl_rx_e_IN_RX_ccnode"*/
-				ccnode_path);
-	if (!cc_in_rx) {
-		pr_err("%s(%d): Error getting cc_in_rx handle\n",
-			__func__, __LINE__);
-		goto out;
-	}
-
-	memset(ccnode_path, 0, sizeof(ccnode_path));
-	sprintf(ccnode_path,
-		"fm%d/port/OFFLINE/%d/ccnode/flow_id_e_IN_POST_DEC_ccnode",
-		FM, DL_POST_IPSEC_OH);
-	cc_flow_id = fmc_get_handle(&cmodel, FM,
-			e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
-			DL_POST_IPSEC_OH,
-			/*"flow_id_e_IN_POST_DEC_ccnode"*/
-			ccnode_path);
-	if (!cc_flow_id) {
-		pr_err("%s(%d) : error getting cc_flow_id handle\n",
-			__func__, __LINE__);
-		goto out;
-	}
-
-	memset(ccnode_path, 0, sizeof(ccnode_path));
-	sprintf(ccnode_path,
-		"fm%d/port/OFFLINE/%d/ccnode/e_OUT_PRE_ENC_ccnode0",
-		FM, UL_PRE_IPSEC_OH);
-	cc_out_pre_enc[0] = fmc_get_handle(&cmodel, FM,
-				e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
-				UL_PRE_IPSEC_OH,
-				/*"e_OUT_PRE_ENC_ccnode0"*/
-				ccnode_path);
-	if (!cc_out_pre_enc[0]) {
-		pr_err("%s(%d) : Error getting cc_out_pre_enc[0] handle\n",
-			__func__, __LINE__);
-		goto out;
-	}
-
-	memset(ccnode_path, 0, sizeof(ccnode_path));
-	sprintf(ccnode_path,
-		"fm%d/port/OFFLINE/%d/ccnode/e_OUT_PRE_ENC_ccnode1",
-		FM, UL_PRE_IPSEC_OH);
-	cc_out_pre_enc[1] = fmc_get_handle(&cmodel, FM,
-				e_FM_PORT_TYPE_OH_OFFLINE_PARSING,
-				UL_PRE_IPSEC_OH,
-				/*"e_OUT_PRE_ENC_ccnode1"*/
-				ccnode_path);
-	if (!cc_out_pre_enc[1]) {
-		pr_err("%s(%d) : Error getting cc_out_pre_enc[1]\n",
-			__func__, __LINE__);
-		goto out;
-	}
-
-	pcd_initialized = 1;
-	return 0;
-
-out:
-	fmc_clean(&cmodel);
-	return -EINVAL;
-
-	return 0;
-}
-
-void fmc_cleanup(void)
-{
-	if (!pcd_initialized)
-		return;
-	fmc_clean(&cmodel);
-}
-- 
1.7.5.4

