From 7ff4555ab7a06020285bc96561caa37dac09634f Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Date: Thu, 6 Jun 2013 11:56:03 +0300
Subject: [PATCH 005/130] dpa_offload: Improved error messages with runtime
 information in DPA Stats

Updated all error messages from dpa_stats component by using the new
macro's (log_err and log_warn) defined in dpa_offload. Added additional
runtime information related to the counters that reported the error like
counter id or member index for class counters

Change-Id: Ib13652905bbbcb1da37385aa750d361452d7c09d
Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2875
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Chereji Marian-Cornel-R27762 <marian.chereji@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Fetch from http://git.freescale.com/git/cgit.cgi/ppc/sdk/linux.git/,
 Tag: fsl-sdk-v1.4.5
 rebase on current context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c     |  539 +++++++++++++++--------
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |  274 +++++++-----
 2 files changed, 510 insertions(+), 303 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index c54c30d..1114035 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -81,24 +81,26 @@ static int check_dpa_stats_params(const struct dpa_stats_params *params)
 {
 	/* Check init parameters */
 	if (!params) {
-		pr_err("Invalid DPA Stats parameters handle\n");
+		log_err("DPA Stats instance parameters cannot be NULL\n");
 		return -EINVAL;
 	}
 
 	/* There must be at least one counter */
 	if (params->max_counters == 0 ||
 	    params->max_counters > DPA_STATS_MAX_NUM_OF_COUNTERS) {
-		pr_err("Invalid DPA Stats number of counters\n");
+		log_err("Parameter max_counters %d must be in range (1 - %d)\n",
+			params->max_counters, DPA_STATS_MAX_NUM_OF_COUNTERS);
 		return -EDOM;
 	}
 
 	if (!params->storage_area) {
-		pr_err("Invalid DPA Stats storage area\n");
+		log_err("Parameter storage_area cannot be NULL\n");
 		return -EINVAL;
 	}
 
 	if (params->storage_area_len < STATS_VAL_SIZE) {
-		pr_err("Invalid DPA Stats storage area length\n");
+		log_err("Parameter storage_area_len %d cannot be bellow %d\n",
+			params->storage_area_len, STATS_VAL_SIZE);
 		return -EINVAL;
 	}
 
@@ -116,7 +118,11 @@ static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_HashTableFindNGetKeyStatistics(entry->cc_node,
 				entry->key.size, entry->key.byte, &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Table statistics\n");
+			log_err("Check failed for Classifier Hash Table counter"
+				" id %d due to incorrect parameters: handle="
+				"0x%p, keysize=%d, keybyte=\n", cnt_cb->id,
+				entry->cc_node, entry->key.size);
+			dump_lookup_key(&entry->key);
 			return -EIO;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_hash_stats;
@@ -125,7 +131,11 @@ static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_MatchTableGetKeyStatistics(
 				entry->cc_node, entry->key.byte[0], &stats);
 		if (err != 0) {
-			pr_err("Invalid Classifier Table counter parameters\n");
+			log_err("Check failed for Classifier Indexed Table "
+				"counter id %d due to incorrect parameters: "
+				"handle=0x%p, keysize=%d keybyte=\n",
+				cnt_cb->id, entry->cc_node, entry->key.size);
+			dump_lookup_key(&entry->key);
 			return -EIO;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_index_stats;
@@ -135,13 +145,18 @@ static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				entry->key.size, entry->key.byte,
 				entry->key.mask, &stats);
 		if (err != 0) {
-			pr_err("Invalid Classifier Table counter parameters\n");
+			log_err("Check failed for Classifier Exact Match Table "
+				"counter id %d due to incorrect parameters: "
+				"handle=0x%p, keysize=%d, keybyte=\n",
+				cnt_cb->id, entry->cc_node, entry->key.size);
+			dump_lookup_key(&entry->key);
 			return -EINVAL;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_match_stats;
 		break;
 	default:
-		pr_err("Invalid table type\n");
+		log_err("Unsupported DPA Classifier table type %d\n",
+			cnt_cb->tbl_cb.type);
 		return -EINVAL;
 	}
 	return 0;
@@ -160,7 +175,11 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node,
 				key->size, key->byte, &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Table statistics\n");
+			log_err("Check failed for Classification Node counter "
+				"id %d due to incorrect parameters: handle="
+				"0x%p, keysize=%d, keybyte=\n", cnt_cb->id,
+				cnt_cb->ccnode_cb.cc_node, key->size);
+			dump_lookup_key(key);
 			return -EIO;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_hash_stats;
@@ -170,7 +189,11 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node,
 				key->byte[0], &stats);
 		if (err != 0) {
-			pr_err("Invalid Classifier Table counter parameters\n");
+			log_err("Check failed for Classification Node counter "
+				"id %d due to incorrect parameters: handle=0x%p"
+				", keysize=%d, keybyte=\n", cnt_cb->id,
+				cnt_cb->ccnode_cb.cc_node, key->size);
+			dump_lookup_key(key);
 			return -EIO;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_index_stats;
@@ -180,13 +203,18 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node, key->size, key->byte,
 				key->mask, &stats);
 		if (err != 0) {
-			pr_err("Invalid Classifier Table counter parameters\n");
+			log_err("Check failed for Classification Node counter "
+				"id %d due to incorrect parameters: handle=0x%p"
+				", keysize=%d, keybyte=\n", cnt_cb->id,
+				cnt_cb->ccnode_cb.cc_node, key->size);
+			dump_lookup_key(key);
 			return -EINVAL;
 		}
 		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_match_stats;
 		break;
 	default:
-		pr_err("Invalid table type\n");
+		log_err("Unsupported Classification Node type %d",
+			cnt_cb->tbl_cb.type);
 		return -EINVAL;
 	}
 	return 0;
@@ -204,7 +232,8 @@ static int get_new_cnt(struct dpa_stats *dpa_stats,
 
 	/* Get an id for new Counter */
 	if (cq_get_4bytes(dpa_stats->cnt_id_cq, &id) < 0) {
-		pr_err("No more unused counter ids\n");
+		log_err("Cannot create new counter, no more free counter ids "
+			"available\n");
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
 	}
@@ -218,7 +247,8 @@ static int get_new_cnt(struct dpa_stats *dpa_stats,
 			break;
 
 	if (i == dpa_stats->config.max_counters) {
-		pr_err("All counters have been used\n");
+		log_err("Maximum number of available counters %d was reached\n",
+			dpa_stats->config.max_counters);
 		cq_put_4bytes(dpa_stats->cnt_id_cq, id);
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
@@ -253,7 +283,8 @@ static int get_new_req(struct dpa_stats *dpa_stats,
 
 	/* Get an id for a new request */
 	if (cq_get_4bytes(dpa_stats->req_id_cq, &id) < 0) {
-		pr_err("No more unused request ids\n");
+		log_err("Cannot create new request, no more free request ids "
+			"available\n");
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
 	}
@@ -267,7 +298,8 @@ static int get_new_req(struct dpa_stats *dpa_stats,
 			break;
 
 	if (i == DPA_STATS_MAX_NUM_OF_REQUESTS) {
-		pr_err("All requests have been used\n");
+		log_err("Maximum number of available requests %d was reached\n",
+			DPA_STATS_MAX_NUM_OF_REQUESTS);
 		cq_put_4bytes(dpa_stats->req_id_cq, id);
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
@@ -300,7 +332,7 @@ static int put_cnt(struct dpa_stats *dpa_stats, struct dpa_stats_cnt_cb *cnt_cb)
 	/* Release the Counter id in the Counter IDs circular queue */
 	err = cq_put_4bytes(dpa_stats->cnt_id_cq, cnt_cb->id);
 	if (err < 0) {
-		pr_err("Could not release the counter id %d\n", cnt_cb->id);
+		log_err("Cannot release the counter id %d\n", cnt_cb->id);
 		return -EDOM;
 	}
 
@@ -350,14 +382,13 @@ static int put_req(struct dpa_stats *dpa_stats, struct dpa_stats_req_cb *req_cb)
 	/* Release the Counter id in the Counter IDs circular queue */
 	err = cq_put_4bytes(dpa_stats->req_id_cq, req_cb->id);
 	if (err < 0) {
-		pr_err("Could not release the counter id %d\n", req_cb->id);
+		log_err("Cannot release the request id %d\n", req_cb->id);
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
 	}
 
 	/* Mark the Counter id as 'not used' */
-	dpa_stats->used_req_ids[req_cb->index] =
-						DPA_OFFLD_INVALID_OBJECT_ID;
+	dpa_stats->used_req_ids[req_cb->index] = DPA_OFFLD_INVALID_OBJECT_ID;
 
 	/* Clear all 'req_cb' information by setting them to a maximum value */
 	req_cb->index = DPA_OFFLD_INVALID_OBJECT_ID;
@@ -381,14 +412,15 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	/* Create circular queue that holds free counter IDs */
 	dpa_stats->cnt_id_cq = cq_new(config.max_counters, sizeof(int));
 	if (!dpa_stats->cnt_id_cq) {
-		pr_err("Could not create Counter IDs circular queue\n");
+		log_err("Cannot create circular queue to store counter ids\n");
 		return -ENOMEM;
 	}
 
 	/* Fill the circular queue with ids */
 	for (i = 0; i < config.max_counters; i++)
 		if (cq_put_4bytes(dpa_stats->cnt_id_cq, i) < 0) {
-			pr_err("Could not fill Counter IDs circular queue\n");
+			log_err("Cannot fill circular queue with counter "
+				"ids\n");
 			return -EDOM;
 		}
 
@@ -396,7 +428,8 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->used_cnt_ids = kmalloc(
 			config.max_counters * sizeof(uint32_t), GFP_KERNEL);
 	if (!dpa_stats->used_cnt_ids) {
-		pr_err("No more memory for used counter ids array\n");
+		log_err("Cannot allocate memory to store %d \'in use\' counter "
+			"ids\n", config.max_counters);
 		return -ENOMEM;
 	}
 	memset(dpa_stats->used_cnt_ids, DPA_OFFLD_INVALID_OBJECT_ID,
@@ -406,7 +439,8 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->cnts_cb = kzalloc(config.max_counters *
 			sizeof(struct dpa_stats_cnt_cb), GFP_KERNEL);
 	if (!dpa_stats->cnts_cb) {
-		pr_err("No more memory for used counters control blocks\n");
+		log_err("Cannot allocate memory to store %d internal counter "
+			"structures\n", config.max_counters);
 		return -ENOMEM;
 	}
 
@@ -433,7 +467,7 @@ static int free_cnts_resources(struct dpa_stats *dpa_stats)
 			/* Release the counter id in the Counter IDs cq */
 			err = put_cnt(dpa_stats, &dpa_stats->cnts_cb[id]);
 			if (err < 0) {
-				pr_err("Failed to release a counter id\n");
+				log_err("Cannot release counter id %d\n", id);
 				return err;
 			}
 	}
@@ -466,7 +500,7 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->async_req_workqueue = alloc_workqueue("async_req_workqueue",
 			WQ_UNBOUND | WQ_MEM_RECLAIM, WORKQUEUE_MAX_ACTIVE);
 	if (!dpa_stats->async_req_workqueue) {
-		pr_err("Creating async request work queue failed\n");
+		log_err("Cannot allocate asynchronous requests work queue\n");
 		return -ENOSPC;
 	}
 
@@ -474,14 +508,15 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->req_id_cq = cq_new(
 			DPA_STATS_MAX_NUM_OF_REQUESTS, sizeof(int));
 	if (!dpa_stats->req_id_cq) {
-		pr_err("Could not create Request IDs circular queue\n");
+		log_err("Cannot create circular queue to store request ids\n");
 		return -ENOMEM;
 	}
 
 	/* Fill the circular queue with ids */
 	for (i = 0; i < DPA_STATS_MAX_NUM_OF_REQUESTS; i++)
 		if (cq_put_4bytes(dpa_stats->req_id_cq, i) < 0) {
-			pr_err("Could not fill Request IDs circular queue\n");
+			log_err("Cannot fill circular queue with request "
+				"ids\n");
 			return -EDOM;
 		}
 
@@ -489,7 +524,8 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->used_req_ids = kmalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 			sizeof(uint32_t), GFP_KERNEL);
 	if (!dpa_stats->used_req_ids) {
-		pr_err("No more memory for used req ids array\n");
+		log_err("Cannot allocate memory to store \'in use\' request "
+			"ids\n");
 		return -ENOMEM;
 	}
 	memset(dpa_stats->used_req_ids, DPA_OFFLD_INVALID_OBJECT_ID,
@@ -499,7 +535,8 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->reqs_cb = kzalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 				sizeof(struct dpa_stats_req_cb), GFP_KERNEL);
 	if (!dpa_stats->reqs_cb) {
-		pr_err("No more memory for requests control blocks\n");
+		log_err("Cannot allocate memory to store internal requests "
+			"structure\n");
 		return -ENOMEM;
 	}
 
@@ -509,7 +546,8 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 				kzalloc(DPA_STATS_MAX_NUM_OF_COUNTERS *
 						sizeof(int), GFP_KERNEL);
 		if (!dpa_stats->reqs_cb[i].config.cnts_ids) {
-			pr_err("No more memory for array of counter ids\n");
+			log_err("Cannot allocate memory for array of counter "
+				"ids\n");
 			return -ENOMEM;
 		}
 
@@ -540,7 +578,7 @@ static int free_reqs_resources(struct dpa_stats *dpa_stats)
 			/* Release the request id in the Requests IDs cq */
 			err = put_req(dpa_stats, req_cb);
 			if (err < 0) {
-				pr_err("Failed to release a request id\n");
+				log_err("Cannot release request id %d\n", id);
 				return err;
 			}
 
@@ -580,7 +618,7 @@ static void free_resources(void)
 
 	/* Sanity check */
 	if (!gbl_dpa_stats) {
-		pr_err("DPA stats instance is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return;
 	}
 	dpa_stats = gbl_dpa_stats;
@@ -617,7 +655,8 @@ static int treat_cnts_request(struct dpa_stats *dpa_stats,
 		/* Call counter's retrieve function */
 		err = cnt_cb->f_get_cnt_stats(req_cb, cnt_cb);
 		if (err < 0) {
-			pr_err("Failed to retrieve counter values\n");
+			log_err("Cannot retrieve the value for counter id %d\n",
+				id);
 			mutex_unlock(&cnt_cb->lock);
 			unblock_sched_cnts(dpa_stats, params.cnts_ids,
 					   params.cnts_ids_len);
@@ -929,20 +968,21 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 {
 	/* Check that key byte pointer is valid */
 	if (!src->byte) {
-		pr_err("Key byte pointer can't be NULL\n");
+		log_err("Lookup key descriptor byte cannot be NULL\n");
 		return -EINVAL;
 	}
 
 	/* Check that key size is not zero */
 	if (src->size == 0) {
-		pr_err("Key size can't be zero\n");
+		log_err("Lookup key descriptor size (%d) must be in range (1 - "
+			"%d) bytes\n", src->size, DPA_OFFLD_MAXENTRYKEYSIZE);
 		return -EINVAL;
 	}
 
 	/* Allocate memory to store the key byte array */
 	dst->byte = kmalloc(src->size, GFP_KERNEL);
 	if (!dst->byte) {
-		pr_err("No more memory for key byte\n");
+		log_err("No more memory for lookup key descriptor byte\n");
 		return -ENOMEM;
 	}
 	memcpy(dst->byte, src->byte, src->size);
@@ -952,7 +992,8 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 		/* Allocate memory to store the key mask array */
 		dst->mask = kmalloc(src->size, GFP_KERNEL);
 		if (!dst->mask) {
-			pr_err("No more memory for key mask\n");
+			log_err("No more memory for lookup key descriptor "
+				"mask\n");
 			kfree(dst->byte);
 			return -ENOMEM;
 		}
@@ -1020,7 +1061,7 @@ static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
 	/* Get FMAN device node */
 	dev_node = get_fman_dev_node(src.engine_id);
 	if (!dev_node) {
-		pr_err("FMan device node couldn't be found\n");
+		log_err("Cannot find FMan device node\n");
 		return -EINVAL;
 	}
 
@@ -1036,7 +1077,7 @@ static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
 			fm_mac = get_fman_mac_handle(
 					dev_node, src.eth_id, mac_name);
 			if (!fm_mac) {
-				pr_err("Ethernet device node couldn't be found\n");
+				log_err("Cannot find Ethernet device node\n");
 				return -EINVAL;
 			}
 		}
@@ -1051,7 +1092,7 @@ static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
 			fm_mac = get_fman_mac_handle(
 					dev_node, src.eth_id, mac_name);
 			if (!fm_mac) {
-				pr_err("Ethernet device node couldn't be found\n");
+				log_err("Cannot find Ethernet device node\n");
 				return -EINVAL;
 			}
 		}
@@ -1087,26 +1128,28 @@ static int set_frag_manip(int td, struct dpa_stats_lookup_key *entry)
 
 	err = dpa_classif_table_lookup_by_key(td, &entry->key, &action);
 	if (err != 0) {
-		pr_err("Unable to retrieve next action parameters\n");
+		log_err("Cannot retrieve next action parameters from table "
+			"%d\n", td);
 		return -EINVAL;
 	}
 
 	if (action.type != DPA_CLS_TBL_ACTION_ENQ) {
-		pr_err("Fragmentation statistics per flow are "
-			"supported only for action enqueue\n");
+		log_err("Fragmentation statistics per flow are supported only "
+			"for action enqueue\n");
 		return -EINVAL;
 	}
 
 	entry->frag = dpa_classif_get_frag_hm_handle(action.enq_params.hmd);
 	if (!entry->frag) {
-		pr_err("Unable to retrieve fragmentation handle\n");
+		log_err("Cannot retrieve Fragmentation handle from hmd %d\n",
+			action.enq_params.hmd);
 		return -EINVAL;
 	}
 
 	/* Check the user-provided fragmentation handle */
 	err = FM_PCD_ManipGetStatistics(entry->frag, &stats);
 	if (err < 0) {
-		pr_err("Invalid Fragmentation manip handle\n");
+		log_err("Invalid Fragmentation manip handle\n");
 		return -EINVAL;
 	}
 
@@ -1122,13 +1165,15 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int	 err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Ethernet counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_ETH_ALL) {
-		pr_err("Invalid Ethernet counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_ETH_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1139,7 +1184,8 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Get FM MAC handle */
 	err = get_fm_mac(params->eth_params.src, &fm_mac);
 	if (err != 0) {
-		pr_err("Could not obtain FM MAC handle!\n");
+		log_err("Cannot retrieve Ethernet MAC handle for counter id "
+			"%d\n", cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1165,7 +1211,7 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
@@ -1175,7 +1221,13 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL) ||
 		(cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES &&
 		cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL))) {
-		pr_err("Invalid Reassembly counter selection\n");
+		log_err("Parameter cnt_sel %d must be in one of the ranges (1 -"
+			"%d), (%d - %d), (%d - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_REASS_GEN_ALL,
+			DPA_STATS_CNT_REASS_IPv4_FRAMES,
+			DPA_STATS_CNT_REASS_IPv4_ALL,
+			DPA_STATS_CNT_REASS_IPv6_FRAMES,
+			DPA_STATS_CNT_REASS_IPv6_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1185,7 +1237,8 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Check the user-provided reassembly manip */
 	err = FM_PCD_ManipGetStatistics(params->reass_params.reass, &stats);
 	if (err < 0) {
-		pr_err("Invalid Reassembly manip handle\n");
+		log_err("Invalid Reassembly manip handle for counter id %d\n",
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1218,13 +1271,15 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Fragmentation counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_FRAG_ALL) {
-		pr_err("Invalid Fragmentation counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_FRAG_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1234,7 +1289,8 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Check the user-provided fragmentation handle */
 	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
 	if (err < 0) {
-		pr_err("Invalid Fragmentation manip handle\n");
+		log_err("Invalid Fragmentation manip handle for counter id "
+			"%d\n", cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1256,16 +1312,18 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			   const struct dpa_stats_cnt_params *params)
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
-	uint32_t cnt_sel = params->reass_params.cnt_sel;
+	uint32_t cnt_sel = params->plcr_params.cnt_sel;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Policer counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_PLCR_ALL) {
-		pr_err("Invalid Policer counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_PLCR_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1297,7 +1355,7 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0, frag_stats = -1;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
@@ -1319,20 +1377,25 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		frag_stats = 1;
 
 	} else {
-		pr_err("Invalid Classifier Table counter selection\n");
+		log_err("Parameter cnt_sel %d must be in one of the ranges (%d "
+			"- %d), (%d - %d), for counter id %d\n", cnt_sel,
+			DPA_STATS_CNT_CLASSIF_BYTES, DPA_STATS_CNT_CLASSIF_ALL,
+			DPA_STATS_CNT_FRAG_TOTAL_FRAMES, DPA_STATS_CNT_FRAG_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
 	err = dpa_classif_table_get_params(prm.td, &cls_tbl);
 	if (err != 0) {
-		pr_err("Invalid Classifier Table descriptor\n");
+		log_err("Invalid table descriptor %d for counter id %d\n",
+			prm.td, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Copy the key descriptor */
 	err = copy_key_descriptor(&prm.key, &cnt_tbl_cb->keys[0].key);
 	if (err != 0) {
-		pr_err("Unable to copy key descriptor\n");
+		log_err("Cannot copy key descriptor from user parameters\n");
 		return -EINVAL;
 	}
 
@@ -1352,7 +1415,8 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	if (frag_stats) {
 		err = set_frag_manip(prm.td, &cnt_tbl_cb->keys[0]);
 		if (err < 0) {
-			pr_err("Invalid Fragmentation manip handle\n");
+			log_err("Invalid Fragmentation manip handle for counter"
+				" id %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
 		/* Map Classifier Table counter selection to Frag stats */
@@ -1381,20 +1445,22 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Classification Node counter selection */
 	if (prm.cnt_sel == 0 ||  prm.cnt_sel > DPA_STATS_CNT_CLASSIF_ALL) {
-		pr_err("Invalid Classif_Node counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", prm.cnt_sel,
+			DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Copy the key descriptor */
 	err = copy_key_descriptor(&prm.key, &cnt_cb->ccnode_cb.keys[0]);
 	if (err != 0) {
-		pr_err("Unable to copy key descriptor\n");
+		log_err("Cannot copy key descriptor from user parameters\n");
 		return -EINVAL;
 	}
 
@@ -1405,10 +1471,8 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Check the Classifier Node counter parameters */
 	err = check_ccnode_counter(cnt_cb,
 				   prm.ccnode_type, &cnt_cb->ccnode_cb.keys[0]);
-	if (err != 0) {
-		pr_err("Invalid Classif Node counter parameters\n");
+	if (err != 0)
 		return -EINVAL;
-	}
 
 	/* Map Classif Node counter selection to CcNode statistics */
 	cnt_sel_to_stats(&cnt_cb->info,
@@ -1430,7 +1494,7 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
@@ -1450,7 +1514,9 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
 		cnt_cb->info.stats_num = 2;
 	} else {
-		pr_err("Invalid IPSec counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (%d - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_NUM_OF_BYTES,
+			DPA_STATS_CNT_NUM_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1460,7 +1526,9 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[0], &stats);
 	if (err < 0) {
-		pr_err("Invalid IPSec counter parameters\n");
+		log_err("Check failed for IPSec counter id %d due to incorrect "
+			"parameters: sa_id=%d\n", cnt_cb->id,
+			cnt_cb->ipsec_cb.sa_id[0]);
 		return -EINVAL;
 	}
 
@@ -1480,14 +1548,16 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Ethernet counter selection */
 	if (params->eth_params.cnt_sel == 0 ||
 	    params->eth_params.cnt_sel > DPA_STATS_CNT_ETH_ALL) {
-		pr_err("Invalid Ethernet counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_ETH_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1499,7 +1569,8 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Get FM MAC handle */
 		err = get_fm_mac(params->eth_params.src[i], &fm_mac);
 		if (err != 0) {
-			pr_err("Could not obtain FM MAC handle!\n");
+			log_err("Cannot obtain Ethernet MAC handle for counter "
+				"id %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
 
@@ -1528,7 +1599,7 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
@@ -1538,7 +1609,13 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	       cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL) ||
 	      (cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES &&
 	       cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL))) {
-		pr_err("Invalid Reassembly counter selection\n");
+		log_err("Parameter cnt_sel %d must be in one of the ranges (1 -"
+			" %d), (%d - %d), (%d - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_REASS_GEN_ALL,
+			DPA_STATS_CNT_REASS_IPv4_FRAMES,
+			DPA_STATS_CNT_REASS_IPv4_ALL,
+			DPA_STATS_CNT_REASS_IPv6_FRAMES,
+			DPA_STATS_CNT_REASS_IPv6_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1550,7 +1627,8 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Check the user-provided reassembly manip */
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			pr_err("Invalid Reassembly manip handle\n");
+			log_err("Invalid Reassembly manip handle for counter id"
+				" %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
 	}
@@ -1584,13 +1662,15 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Fragmentation counter selection */
 	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_FRAG_ALL)) {
-		pr_err("Invalid Fragmentation counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_FRAG_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1602,7 +1682,8 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Check the user-provided fragmentation handle */
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			pr_err("Invalid Fragmentation manip handle\n");
+			log_err("Invalid Fragmentation manip handle for counter"
+				"id %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
 	}
@@ -1629,13 +1710,15 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	uint32_t cnt_sel = params->plcr_params.cnt_sel, i;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Policer counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_PLCR_ALL) {
-		pr_err("Invalid Policer counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_PLCR_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1678,14 +1761,15 @@ static int set_cls_cnt_classif_tbl_pair(
 
 	/* Check that key byte is not NULL */
 	if (!pair->first_key.byte) {
-		pr_err("Invalid argument: NULL key byte pointer\n");
+		log_err("First key descriptor byte of the user pair cannot be "
+			"NULL for table descriptor %d\n", td);
 		return -EFAULT;
 	}
 
 	/* Copy first key descriptor parameters*/
 	err = copy_key_descriptor(&pair->first_key, &tbl_key);
 	if (err != 0) {
-		pr_err("Unable to copy key descriptor\n");
+		log_err("Cannot copy first key descriptor of the user pair\n");
 		return -EINVAL;
 	}
 
@@ -1693,13 +1777,14 @@ static int set_cls_cnt_classif_tbl_pair(
 	 * table the next table connected on a "next-action" */
 	err = dpa_classif_table_lookup_by_key(td, &tbl_key, &action);
 	if (err != 0) {
-		pr_err("Unable to retrieve next action parameters\n");
+		log_err("Cannot retrieve next action parameters for table "
+			"descriptor %d\n", td);
 		return -EINVAL;
 	}
 
 	if (action.type != DPA_CLS_TBL_ACTION_NEXT_TABLE) {
-		pr_err("Double key is supported only if "
-				"two tables are connected\n");
+		log_err("Pair key is supported only if two tables are "
+			"connected");
 		return -EINVAL;
 	}
 
@@ -1707,7 +1792,7 @@ static int set_cls_cnt_classif_tbl_pair(
 	err = dpa_classif_table_get_params(
 			action.next_table_params.next_td, &cls_tbl);
 	if (err != 0) {
-		pr_err("Unable to retrieve next table parameters\n");
+		log_err("Cannot retrieve next table %d parameters\n", td);
 		return -EINVAL;
 	}
 
@@ -1720,7 +1805,7 @@ static int set_cls_cnt_classif_tbl_pair(
 	/* Set as lookup key the second key descriptor from the pair */
 	err = copy_key_descriptor(&pair->second_key, &lookup_key->key);
 	if (err != 0) {
-		pr_err("Unable to copy key descriptor\n");
+		log_err("Cannot copy second key descriptor of the user pair\n");
 		return -EINVAL;
 	}
 
@@ -1739,7 +1824,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Classifier Table descriptor */
 	if (params->classif_tbl_params.td == DPA_OFFLD_INVALID_OBJECT_ID) {
-		pr_err("Invalid Classifier Table descriptor\n");
+		log_err("Invalid table descriptor %d for counter id %d\n",
+			params->classif_tbl_params.td, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1761,7 +1847,11 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		frag_stats = 1;
 
 	} else {
-		pr_err("Invalid Classifier Table counter selection\n");
+		log_err("Parameter cnt_sel %d must be in one of the ranges (%d "
+			"- %d), (%d - %d), for counter id %d\n", cnt_sel,
+			DPA_STATS_CNT_CLASSIF_BYTES, DPA_STATS_CNT_CLASSIF_ALL,
+			DPA_STATS_CNT_FRAG_TOTAL_FRAMES, DPA_STATS_CNT_FRAG_ALL,
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1773,7 +1863,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Get CcNode from table descriptor */
 		err = dpa_classif_table_get_params(prm.td, &cls_tbl);
 		if (err != 0) {
-			pr_err("Invalid argument: Table descriptor\n");
+			log_err("Invalid table descriptor %d for counter id "
+				"%d\n", prm.td, cnt_cb->id);
 			return -EINVAL;
 		}
 
@@ -1794,7 +1885,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = copy_key_descriptor(&prm.keys[i],
 						  &cnt_tbl_cb->keys[i].key);
 			if (err != 0) {
-				pr_err("Unable to copy key descriptor\n");
+				log_err("Cannot copy key descriptor from user "
+					"parameters\n");
 				return -EINVAL;
 			}
 
@@ -1818,7 +1910,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = set_cls_cnt_classif_tbl_pair(cnt_tbl_cb, prm.td,
 					&prm.pairs[i], &cnt_tbl_cb->keys[i]);
 			if (err != 0) {
-				pr_err("Unable to set the key pair\n");
+				log_err("Cannot set classifier table pair key "
+					"for counter id %d\n", cnt_cb->id);
 				return -EINVAL;
 			}
 
@@ -1832,7 +1925,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 		break;
 	default:
-		pr_err("Invalid argument: key type\n");
+		log_err("Parameter key_type %d must be in range (%d - %d) for "
+			"counter id %d\n", prm.key_type,
+			DPA_STATS_CLASSIF_SINGLE_KEY,
+			DPA_STATS_CLASSIF_PAIR_KEY, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1844,7 +1940,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 			err = set_frag_manip(prm.td, &cnt_cb->tbl_cb.keys[i]);
 			if (err < 0) {
-				pr_err("Invalid Fragmentation manip handle\n");
+				log_err("Invalid Fragmentation manip handle for"
+					" counter id %d\n", cnt_cb->id);
 				return -EINVAL;
 			}
 		}
@@ -1876,13 +1973,15 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
 	/* Check Classification Cc Node counter selection */
 	if (prm.cnt_sel == 0 ||  prm.cnt_sel > DPA_STATS_CNT_CLASSIF_ALL) {
-		pr_err("Invalid Classif_Node counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
+			"counter id %d\n", prm.cnt_sel,
+			DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1894,17 +1993,16 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		err = copy_key_descriptor(&prm.keys[i],
 				&cnt_cb->ccnode_cb.keys[i]);
 		if (err != 0) {
-			pr_err("Unable to copy key descriptor\n");
+			log_err("Cannot copy key descriptor from user "
+				"parameters\n");
 			return -EINVAL;
 		}
 
 		/* Check the Classifier Node counter parameters */
 		err = check_ccnode_counter(cnt_cb,
 				prm.ccnode_type, &cnt_cb->ccnode_cb.keys[i]);
-		if (err != 0) {
-			pr_err("Invalid Classif Node counter parameters\n");
+		if (err != 0)
 			return -EINVAL;
-		}
 	}
 
 	/* Map Classif Node counter selection to CcNode statistics */
@@ -1928,7 +2026,7 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	int err = 0;
 
 	if (!dpa_stats) {
-		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EFAULT;
 	}
 
@@ -1948,7 +2046,9 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
 		cnt_cb->info.stats_num = 2;
 	} else {
-		pr_err("Invalid IPSec counter selection\n");
+		log_err("Parameter cnt_sel %d must be in range (%d - %d) for "
+			"counter id %d\n", cnt_sel, DPA_STATS_CNT_NUM_OF_BYTES,
+			DPA_STATS_CNT_NUM_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1962,7 +2062,10 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i],
 					&stats);
 			if (err < 0) {
-				pr_err("Invalid IPSec counter parameters\n");
+				log_err("Check failed for IPSec counter id %d "
+					"due to incorrect parameters: sa_id=%d"
+					"\n", cnt_cb->id,
+					cnt_cb->ipsec_cb.sa_id[i]);
 				return -EINVAL;
 			}
 		} else {
@@ -1986,14 +2089,17 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 
 	/* Check that counter is of type Classifier table */
 	if (cnt_cb->type != DPA_STATS_CNT_CLASSIF_TBL) {
-		pr_err("Operation permitted only on counter "
-				"type DPA_STATS_CNT_CLASSIF_TBL\n");
+		log_err("Operation permitted only on counter type "
+			"DPA_STATS_CNT_CLASSIF_TBL %d for counter id %d\n",
+			DPA_STATS_CNT_CLASSIF_TBL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Check that member index does not exceeds class size */
 	if (member_index < 0 || member_index >= cnt_cb->members_num) {
-		pr_err("Member index is out of class counter size\n");
+		log_err("Parameter member_index %d must be in range (0 - %d) "
+			"for counter id %d\n", member_index,
+			cnt_cb->members_num - 1, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2024,14 +2130,17 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 			err = copy_key_descriptor(&prm->key,
 					&tbl_cb->keys[member_index].key);
 			if (err != 0) {
-				pr_err("Unable to copy key descriptor\n");
+				log_err("Cannot copy key descriptor from user "
+					"parameters\n");
 				return -EINVAL;
 			}
 		} else {
 			err = set_cls_cnt_classif_tbl_pair(tbl_cb, tbl_cb->td,
 				&prm->pair, &tbl_cb->keys[member_index]);
 			if (err != 0) {
-				pr_err("Unable to configure the key pair\n");
+				log_err("Cannot configure the pair key for "
+					"counter id %d of member %d\n",
+					cnt_cb->id, member_index);
 				return -EINVAL;
 			}
 		}
@@ -2044,7 +2153,8 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 			err = set_frag_manip(tbl_cb->td,
 					&tbl_cb->keys[member_index]);
 			if (err < 0) {
-				pr_err("Invalid Fragmentation manip handle\n");
+				log_err("Invalid Fragmentation manip handle for"
+					" counter id %d\n", cnt_cb->id);
 				return -EINVAL;
 			}
 		}
@@ -2062,14 +2172,17 @@ int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
 
 	/* Check that counter is of type IPSec */
 	if (cnt_cb->type != DPA_STATS_CNT_IPSEC) {
-		pr_err("Operation permitted only on counter "
-				"type DPA_STATS_CNT_IPSEC\n");
+		log_err("Operation permitted only on counter type "
+			"DPA_STATS_CNT_IPSEC %d for counter id %d\n",
+			DPA_STATS_CNT_IPSEC, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Check that member index does not exceeds class size */
 	if (member_idx < 0 || member_idx >= cnt_cb->members_num) {
-		pr_err("Member index is out of class counter size\n");
+		log_err("Parameter member_index %d must be in range (0 - %d) "
+			"for counter id %d\n", member_idx,
+			cnt_cb->members_num - 1, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2182,7 +2295,8 @@ static int get_cnt_eth_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Ethernet Counter value\n");
+			log_err("Cannot retrieve Ethernet statistics for "
+				"counter id %d\n", cnt_cb->id);
 			return -ENOENT;
 		}
 
@@ -2202,7 +2316,8 @@ static int get_cnt_reass_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			pr_err("Couldn't retrieve Reassembly statistics\n");
+			log_err("Cannot retrieve Reassembly statistics for "
+				"counter id %d\n", cnt_cb->id);
 			return -ESRCH;
 		}
 
@@ -2223,7 +2338,8 @@ static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			pr_err("Couldn't retrieve Fragmentation statistics\n");
+			log_err("Cannot retrieve Fragmentation statistics for "
+				"counter id %d\n", cnt_cb->id);
 			return -EINTR;
 		}
 
@@ -2297,7 +2413,8 @@ static int get_cnt_cls_tbl_match_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->tbl_cb.keys[i].key.byte,
 				cnt_cb->tbl_cb.keys[i].key.mask, &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Table statistics\n");
+			log_err("Cannot retrieve Classifier Exact Match Table "
+				"statistics for counter id %d\n", cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -2330,7 +2447,8 @@ static int get_cnt_cls_tbl_hash_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->tbl_cb.keys[i].key.byte,
 				&stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Table statistics\n");
+			log_err("Cannot retrieve Classifier Hash Table "
+				"statistics for counter id %d\n", cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -2362,7 +2480,8 @@ static int get_cnt_cls_tbl_index_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->tbl_cb.keys[i].key.byte[0],
 				&stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Table statistics\n");
+			log_err("Cannot retrieve Classifier Indexed Table "
+				"statistics for counter id %d\n", cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -2393,7 +2512,8 @@ static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 		err = FM_PCD_ManipGetStatistics(
 				cnt_cb->tbl_cb.keys[i].frag, &stats);
 		if (err < 0) {
-			pr_err("Couldn't retrieve Fragmentation statistics\n");
+			log_err("Cannot retrieve Fragmentation statistics for "
+				"counter id %d\n", cnt_cb->id);
 			return -EINTR;
 		}
 		get_cnt_32bit_stats(req_cb,
@@ -2417,7 +2537,9 @@ static int get_cnt_ccnode_match_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->ccnode_cb.keys[i].byte,
 				cnt_cb->ccnode_cb.keys[i].mask, &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Node statistics\n");
+			log_err("Cannot retrieve Classification Cc Node Exact "
+				"Match statistics for counter id %d\n",
+				cnt_cb->id);
 			return -ENXIO;
 		}
 
@@ -2439,7 +2561,8 @@ static int get_cnt_ccnode_hash_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->ccnode_cb.keys[i].size,
 				cnt_cb->ccnode_cb.keys[i].byte, &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Node statistics\n");
+			log_err("Cannot retrieve Classification Cc Node Hash "
+				"statistics for counter id %d\n", cnt_cb->id);
 			return -ENXIO;
 		}
 
@@ -2460,7 +2583,8 @@ static int get_cnt_ccnode_index_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->ccnode_cb.cc_node,
 				cnt_cb->ccnode_cb.keys[i].byte[0], &stats);
 		if (err != 0) {
-			pr_err("Couldn't retrieve Classif Node statistics\n");
+			log_err("Cannot retrieve Classification Cc Node Index "
+				"statistics for counter id %d\n", cnt_cb->id);
 			return -ENXIO;
 		}
 
@@ -2491,7 +2615,8 @@ static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
 
 		err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i], &stats);
 		if (err < 0) {
-			pr_err("Couldn't retrieve IPSec statistics\n");
+			log_err("Cannot retrieve IPSec statistics for counter "
+				"id %d\n", cnt_cb->id);
 			return -E2BIG;
 		}
 
@@ -2514,7 +2639,7 @@ static void async_req_work_func(struct work_struct *work)
 
 	err = treat_cnts_request(dpa_stats, req_cb);
 	if (err < 0) {
-		pr_err("Failed to retrieve counter values\n");
+		log_err("Cannot obtain counter values in asynchronous mode\n");
 		req_cb->bytes_num = err;
 	}
 
@@ -2525,7 +2650,7 @@ static void async_req_work_func(struct work_struct *work)
 	/* Release the request control block */
 	err = put_req(dpa_stats, req_cb);
 	if (err < 0)
-		pr_err("Failed to release request control block\n");
+		log_err("Cannot release internal request structure\n");
 
 	return;
 }
@@ -2540,8 +2665,8 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 
 	/* Sanity checks */
 	if (gbl_dpa_stats) {
-		pr_err("dpa_stats component already initialized.\n");
-		pr_err("Multiple DPA Stats Instances are not supported.\n");
+		log_err("DPA Stats component already initialized. Multiple DPA "
+			"Stats instances are not supported.\n");
 		return -EPERM;
 	}
 
@@ -2553,7 +2678,8 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Control block allocation */
 	dpa_stats = kzalloc(sizeof(struct dpa_stats), GFP_KERNEL);
 	if (!dpa_stats) {
-		pr_err("Could not allocate memory for control block.\n");
+		log_err("Cannot allocate memory for internal DPA Stats "
+			"structure.\n");
 		return -ENOMEM;
 	}
 
@@ -2614,12 +2740,12 @@ int dpa_stats_create_counter(int dpa_stats_id,
 	unused(dpa_stats_id);
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
 	if (!dpa_stats_cnt_id) {
-		pr_err("dpa_stats_cnt_id can't be NULL\n");
+		log_err("Parameter dpa_stats_cnt_id cannot be NULL\n");
 		return -EINVAL;
 	}
 	*dpa_stats_cnt_id = DPA_OFFLD_INVALID_OBJECT_ID;
@@ -2628,7 +2754,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 	err = get_new_cnt(dpa_stats, &cnt_cb);
 	if (err < 0) {
-		pr_err("Failed retrieving a preallocated counter\n");
+		log_err("Cannot retrieve preallocated internal counter "
+			"structure\n");
 		return err;
 	}
 
@@ -2642,7 +2769,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_eth_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create ETH counter\n");
+			log_err("Cannot create Ethernet counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2652,7 +2780,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_reass_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Reassembly counter\n");
+			log_err("Cannot create Reassembly counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2662,7 +2791,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_frag_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Fragmentation counter\n");
+			log_err("Cannot create Fragmentation counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2672,7 +2802,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_plcr_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Policer counter\n");
+			log_err("Cannot create Policer counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2681,7 +2812,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Classif Table counter\n");
+			log_err("Cannot create Classifier Table counter id "
+				"%d\n", cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2690,7 +2822,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Classif Cc Node counter\n");
+			log_err("Cannot create Classification Cc Node counter "
+				"id %d\n", cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2700,16 +2833,20 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_ipsec_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create IPSec counter\n");
+			log_err("Cannot create IPSec counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
 	case DPA_STATS_CNT_TRAFFIC_MNG:
-		pr_err("Counter type not supported\n");
+		log_err("Counter of type DPA_STATS_CNT_TRAFFIC_MNG(%d) is not "
+			"supported for counter id %d",
+			DPA_STATS_CNT_TRAFFIC_MNG, cnt_cb->id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	default:
-		pr_err("Invalid counter type\n");
+		log_err("Unsupported counter type %d for counter id %d\n",
+			params->type, cnt_cb->id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	};
@@ -2754,19 +2891,20 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 	unused(dpa_stats_id);
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
 	if (!dpa_stats_cnt_id) {
-		pr_err("dpa_stats_cnt_id can't be NULL\n");
+		log_err("Parameter dpa_stats_cnt_id cannot be NULL\n");
 		return -EINVAL;
 	}
 	*dpa_stats_cnt_id = DPA_OFFLD_INVALID_OBJECT_ID;
 
 	if (params->class_members > DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS) {
-		pr_err("exceed maximum number of class members: %d\n",
-				DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS);
+		log_err("Parameter class_members %d exceeds maximum number of "
+			"class members: %d\n", params->class_members,
+			DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS);
 		return -EINVAL;
 	}
 
@@ -2774,7 +2912,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 	err = get_new_cnt(dpa_stats, &cnt_cb);
 	if (err < 0) {
-		pr_err("Failed retrieving a preallocated counter\n");
+		log_err("Cannot retrieve preallocated internal counter "
+			"structure\n");
 		return err;
 	}
 
@@ -2788,7 +2927,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_eth_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create ETH counter\n");
+			log_err("Cannot create Ethernet counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2798,7 +2938,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_reass_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Reassembly counter\n");
+			log_err("Cannot create Reassembly counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2808,7 +2949,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_frag_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Fragmentation counter\n");
+			log_err("Cannot create Fragmentation counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2818,7 +2960,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_plcr_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Policer counter\n");
+			log_err("Cannot create Policer counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2827,7 +2970,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Classif Table counter\n");
+			log_err("Cannot create Classifier Table counter id "
+				"%d\n", cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2836,7 +2980,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create Classif Cc Node counter\n");
+			log_err("Cannot create Classification Cc Node counter "
+				"id %d\n", cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -2846,17 +2991,21 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_ipsec_cb(cnt_cb, params);
 		if (err != 0) {
-			pr_err("Failed to create IPSec counter\n");
+			log_err("Cannot create IPSec counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 
 		break;
 	case DPA_STATS_CNT_TRAFFIC_MNG:
-		pr_err("Counter type not supported\n");
+		log_err("Counter of type DPA_STATS_CNT_TRAFFIC_MNG(%d) is not "
+			"supported for counter id %d",
+			DPA_STATS_CNT_TRAFFIC_MNG, cnt_cb->id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	default:
-		pr_err("Invalid counter type\n");
+		log_err("Unsupported counter type %d for counter id %d\n",
+			params->type, cnt_cb->id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	};
@@ -2897,7 +3046,7 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 	int err = 0;
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
@@ -2905,13 +3054,15 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 
 	if (dpa_stats_cnt_id < 0 ||
 			dpa_stats_cnt_id > dpa_stats->config.max_counters) {
-		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d"
+			")\n", dpa_stats_cnt_id,
+			dpa_stats->config.max_counters - 1);
 		return -EINVAL;
 	}
 
 	/* Counter scheduled for the retrieve mechanism can't be modified */
 	if (cnt_is_sched(dpa_stats, dpa_stats_cnt_id)) {
-		pr_err("Counter id %d is in use\n", dpa_stats_cnt_id);
+		log_err("Counter id %d is in use\n", dpa_stats_cnt_id);
 		return -EBUSY;
 	}
 
@@ -2925,7 +3076,7 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 
 	/* Validity check for this counter */
 	if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		log_err("Counter id %d is not initialized\n", dpa_stats_cnt_id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	}
@@ -2935,7 +3086,8 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 		/* Modify classifier table class member */
 		err = set_classif_tbl_member(params, member_index, cnt_cb);
 		if (err < 0) {
-			pr_err("Failed to modify class member\n");
+			log_err("Cannot modify member %d of counter id %d\n",
+				member_index, dpa_stats_cnt_id);
 			mutex_unlock(&cnt_cb->lock);
 			return -EINVAL;
 		}
@@ -2944,12 +3096,16 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 		/* Modify IPSec class member */
 		err = set_ipsec_member(params, member_index, cnt_cb);
 		if (err < 0) {
-			pr_err("Failed to modify class member\n");
+			log_err("Cannot modify member %d of counter id %d\n",
+				member_index, dpa_stats_cnt_id);
 			mutex_unlock(&cnt_cb->lock);
 			return -EINVAL;
 		}
 	} else {
-		pr_err("Invalid member type\n");
+		log_err("Parameter type %d for counter id %d must be in range "
+			"(%d - %d)\n", params->type, dpa_stats_cnt_id,
+			DPA_STATS_CLS_MEMBER_SINGLE_KEY,
+			DPA_STATS_CLS_MEMBER_SA_ID);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	}
@@ -2969,7 +3125,7 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 	uint32_t i;
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
@@ -2977,13 +3133,15 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 
 	if (dpa_stats_cnt_id < 0 ||
 			dpa_stats_cnt_id > dpa_stats->config.max_counters) {
-		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d"
+			")\n", dpa_stats_cnt_id,
+			dpa_stats->config.max_counters - 1);
 		return -EINVAL;
 	}
 
 	/* Counter scheduled for the retrieve mechanism can't be removed */
 	if (cnt_is_sched(dpa_stats, dpa_stats_cnt_id)) {
-		pr_err("Counter id %d is in use\n", dpa_stats_cnt_id);
+		log_err("Counter id %d is in use\n", dpa_stats_cnt_id);
 		return -EBUSY;
 	}
 
@@ -2997,7 +3155,7 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 
 	/* Validity check for this counter */
 	if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		log_err("Counter id %d is not initialized\n", dpa_stats_cnt_id);
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	}
@@ -3019,7 +3177,7 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 	/* Release the counter id in the Counter IDs circular queue */
 	err = put_cnt(dpa_stats, cnt_cb);
 	if (err < 0) {
-		pr_err("Failed to release a preallocated counter\n");
+		log_err("Cannot release preallocated internal structure\n");
 		mutex_unlock(&cnt_cb->lock);
 		return -EINVAL;
 	}
@@ -3042,19 +3200,19 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	uint32_t i = 0;
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
 	/* Check user-provided cnts_len pointer */
 	if (!cnts_len) {
-		pr_err("Parameter cnts_len can't be NULL\n");
+		log_err("Parameter cnts_len cannot be NULL\n");
 		return -EINVAL;
 	}
 
 	/* Check user-provided params.cnts_ids pointer */
 	if (!params.cnts_ids) {
-		pr_err("Parameter params.cnts_ids can't be NULL\n");
+		log_err("Parameter cnts_ids cannot be NULL\n");
 		return -EINVAL;
 	}
 
@@ -3065,8 +3223,10 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	for (i = 0; i < params.cnts_ids_len; i++) {
 		if (params.cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID ||
 		    params.cnts_ids[i] > dpa_stats->config.max_counters) {
-			pr_err("Invalid Counter id %d provided\n",
-					params.cnts_ids[i]);
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized "
+				"or is greater than maximum counters %d\n", i,
+				params.cnts_ids[i],
+				dpa_stats->config.max_counters);
 			return -EINVAL;
 		}
 	}
@@ -3085,7 +3245,8 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 
 		/* Check if counter control block is initialized */
 		if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-			pr_err("Invalid Counter id %d provided\n", cnt_id);
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized"
+				"\n", i, cnt_id);
 			mutex_unlock(&cnt_cb->lock);
 			unblock_sched_cnts(dpa_stats, params.cnts_ids,
 					   params.cnts_ids_len);
@@ -3099,8 +3260,10 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	/* Check user-provided parameters */
 	if ((params.storage_area_offset + *cnts_len) >
 		dpa_stats->config.storage_area_len) {
-		pr_err("Invalid offset %d provided\n",
-				params.storage_area_offset);
+		log_err("Parameter storage_area_offset %d and counters length "
+			"%d exceeds configured storage_area_len %d\n",
+			params.storage_area_offset, *cnts_len,
+			dpa_stats->config.storage_area_len);
 		unblock_sched_cnts(dpa_stats, params.cnts_ids,
 				   params.cnts_ids_len);
 		return -EINVAL;
@@ -3109,7 +3272,8 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	/* Create a new request */
 	err = get_new_req(dpa_stats, &req_id, &req_cb);
 	if (err < 0) {
-		pr_err("Failed retrieving a preallocated request\n");
+		log_err("Cannot retrieve preallocated internal request "
+			"structure\n");
 		/* Release counters locks */
 		unblock_sched_cnts(dpa_stats, params.cnts_ids,
 				   params.cnts_ids_len);
@@ -3133,7 +3297,7 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 		/* Call is synchronous */
 		err = treat_cnts_request(dpa_stats, req_cb);
 		if (err < 0)
-			pr_err("Failed to retrieve counter values\n");
+			log_err("Cannot retrieve counter values\n");
 
 		err = put_req(dpa_stats, req_cb);
 
@@ -3156,19 +3320,19 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 	int err = 0;
 
 	if (!gbl_dpa_stats) {
-		pr_err("dpa_stats component is not initialized\n");
+		log_err("DPA Stats component is not initialized\n");
 		return -EPERM;
 	}
 
 	/* Check user-provided cnts_len pointer */
 	if (cnts_ids_len == 0) {
-		pr_err("Parameter cnts_ids_len can't be 0\n");
+		log_err("Parameter cnts_ids_len cannot be 0\n");
 		return -EINVAL;
 	}
 
 	/* Check user-provided cnts_ids pointer */
 	if (!cnts_ids) {
-		pr_err("Parameter cnts_ids can't be NULL\n");
+		log_err("Parameter cnts_ids cannot be NULL\n");
 		return -EINVAL;
 	}
 
@@ -3177,7 +3341,10 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 	for (i = 0; i < cnts_ids_len; i++)
 		if (cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID ||
 		    cnts_ids[i] > dpa_stats->config.max_counters) {
-			pr_err("Invalid Counter id %d provided\n", cnts_ids[i]);
+			log_err("Counter id (cnts_ids[%d]) %d is not "
+				"initialized or is greater than maximum "
+				"counters %d\n", i, cnts_ids[i],
+				dpa_stats->config.max_counters - 1);
 			return -EINVAL;
 		}
 
@@ -3191,7 +3358,8 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 		/* Acquire counter lock */
 		err = mutex_trylock(&cnt_cb->lock);
 		if (err == 0) {
-			pr_err("Counter %d is being used\n", cnts_ids[i]);
+			log_err("Counter id (cnt_ids[%d]) %d is in use\n", i,
+				cnts_ids[i]);
 			unblock_sched_cnts(dpa_stats,
 					   cnts_ids, cnts_ids_len);
 			return -EBUSY;
@@ -3199,7 +3367,8 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 
 		/* Check if counter control block is initialized */
 		if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-			pr_err("Invalid Counter id %d provided\n", cnts_ids[i]);
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized"
+				"\n", i, cnts_ids[i]);
 			mutex_unlock(&cnt_cb->lock);
 			unblock_sched_cnts(dpa_stats,
 					   cnts_ids, cnts_ids_len);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 2c7a692..1c89866 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -173,7 +173,7 @@ int wrp_dpa_stats_init(void)
 	dpa_stats_cdev_major =
 	    register_chrdev(0, DPA_STATS_CDEV, &dpa_stats_fops);
 	if (dpa_stats_cdev_major < 0) {
-		pr_err("Could not register DPA Stats character device\n");
+		log_err("Cannot register DPA Stats character device\n");
 		return dpa_stats_cdev_major;
 	}
 
@@ -249,7 +249,8 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 					 wrp_dpa_stats.k_mem +
 					 event->params.storage_area_offset,
 					 event->params.bytes_written)) {
-				pr_err("Couldn't copy counters values to storage area\n");
+				log_err("Cannot copy counter values to storage "
+					"area\n");
 				return -EFAULT;
 			}
 		}
@@ -303,7 +304,8 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 					 wrp_dpa_stats.k_mem +
 					 event->params.storage_area_offset,
 					 event->params.bytes_written)) {
-				pr_err("Couldn't copy counters values to storage area\n");
+				log_err("Cannot copy counter values to storage "
+					"area\n");
 				return -EFAULT;
 			}
 		}
@@ -361,7 +363,8 @@ static int wrp_dpa_stats_queue_event(struct dpa_stats_event_queue *event_queue,
 {
 	/* If the event queue is already full, abort: */
 	if (atomic_read(&event_queue->count) >= QUEUE_MAX_EVENTS) {
-		pr_err("Event queue is full!\n");
+		log_err("Cannot enqueue new event, queue is full(%d)\n",
+			QUEUE_MAX_EVENTS);
 		return -EBUSY;
 	}
 
@@ -447,7 +450,7 @@ void do_ioctl_req_done_cb(int dpa_stats_id,
 	}
 
 	if (!found) {
-		pr_err("Event was not found in the event list!\n");
+		log_err("Cannot find event in the event list\n");
 		mutex_unlock(&wrp_dpa_stats.async_req_lock);
 		return;
 	}
@@ -455,7 +458,7 @@ void do_ioctl_req_done_cb(int dpa_stats_id,
 	/* Generate new event description: */
 	event = kmalloc(sizeof(struct dpa_stats_event), GFP_KERNEL);
 	if (!event) {
-		pr_err("No more memory for events !\n");
+		log_err("Cannot allocate memory for a new event\n");
 		mutex_unlock(&wrp_dpa_stats.async_req_lock);
 		return;
 	}
@@ -471,7 +474,7 @@ void do_ioctl_req_done_cb(int dpa_stats_id,
 
 	/* Queue this event */
 	if (wrp_dpa_stats_queue_event(&wrp_dpa_stats.ev_queue, event) != 0) {
-		pr_err("Failed to queue event.\n");
+		log_err("Cannot enqueue a new event\n");
 		kfree(event);
 		return;
 	}
@@ -497,7 +500,8 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 		 */
 		params.storage_area = phys_to_virt(prm->phys_stg_area);
 		if (!params.storage_area) {
-			pr_err("Invalid physical memory address\n");
+			log_err("Invalid physical memory address for storage "
+				"area\n");
 			return -EINVAL;
 		}
 		wrp_dpa_stats.k_mem = NULL;
@@ -509,7 +513,8 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 		params.storage_area = kzalloc(
 				prm->storage_area_len, GFP_KERNEL);
 		if (!params.storage_area) {
-			pr_err("Could not allocate kernel storage area\n");
+			log_err("Cannot allocate memory for kernel storage "
+				"area\n");
 			return -ENOMEM;
 		}
 
@@ -529,7 +534,8 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 	wrp_dpa_stats.async_req_group = kmalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 				sizeof(struct list_head), GFP_KERNEL);
 	if (!wrp_dpa_stats.async_req_group) {
-		pr_err("Could not allocate memory for async requests group\n");
+		log_err("Cannot allocate memory for asynchronous requests "
+			"group\n");
 		return -ENOMEM;
 	}
 
@@ -551,8 +557,8 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 				list_del(&async_req_ev->node);
 				kfree(async_req_ev);
 			}
-			pr_err("Could not allocate "
-				"memory for asynchronous request event\n");
+			log_err("Cannot allocate memory for asynchronous "
+				"request event\n");
 			return -ENOMEM;
 		}
 
@@ -572,7 +578,7 @@ static long do_ioctl_stats_free(void *args)
 	long ret;
 
 	if (copy_from_user(&dpa_stats_id, (int *)args, sizeof(int))) {
-		pr_err("Could not copy parameters\n");
+		log_err("Cannot copy user parameters\n");
 		return -EINVAL;
 	}
 
@@ -601,7 +607,7 @@ static int do_ioctl_stats_create_counter(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&prm, args, sizeof(prm))) {
-		pr_err("Could not copy Counter parameters\n");
+		log_err("Cannot copy from user the counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -612,7 +618,7 @@ static int do_ioctl_stats_create_counter(void *args)
 		ret = copy_key_descriptor(
 				&prm.cnt_params.classif_tbl_params.key, &key);
 	if (ret != 0) {
-		pr_err("Could not copy the key descriptor\n");
+		log_err("Cannot copy the key descriptor\n");
 		return -EINVAL;
 	}
 
@@ -622,7 +628,7 @@ static int do_ioctl_stats_create_counter(void *args)
 		return ret;
 
 	if (copy_to_user(args, &prm, sizeof(prm))) {
-		pr_err("Could not copy to user the Counter ID\n");
+		log_err("Cannot copy to user the counter parameters\n");
 		ret = -EINVAL;
 	}
 
@@ -643,7 +649,7 @@ static int do_ioctl_stats_compat_create_counter(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&uprm, args, sizeof(uprm))) {
-		pr_err("Could not copy Counter parameters\n");
+		log_err("Cannot copy from user counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -705,7 +711,7 @@ static int do_ioctl_stats_compat_create_counter(void *args)
 	uprm.cnt_id = kprm.cnt_id;
 
 	if (copy_to_user(args, &uprm, sizeof(uprm))) {
-		pr_err("Could not copy to user the Counter ID\n");
+		log_err("Cannot copy to user counter parameters\n");
 		ret = -EINVAL;
 	}
 
@@ -734,7 +740,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&prm, args, sizeof(prm))) {
-		pr_err("Could not copy Counter parameters\n");
+		log_err("Cannot copy from user class counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -746,14 +752,15 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		/* Allocate memory to store the sources array */
 		eth_src = kmalloc(eth_src_size, GFP_KERNEL);
 		if (!eth_src) {
-			pr_err("No more memory for ethernet sources array\n");
+			log_err("Cannot allocate memory for Ethernet sources "
+				"array\n");
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(eth_src,
 				   prm.cnt_params.eth_params.src,
 				   eth_src_size)) {
-			pr_err("Could not copy array of ethernet sources\n");
+			log_err("Cannot copy array of Ethernet sources\n");
 			kfree(eth_src);
 			return -EBUSY;
 		}
@@ -764,7 +771,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 					 prm.cnt_params.class_members,
 					 prm.cnt_params.reass_params.reass);
 		if (ret < 0) {
-			pr_err("Could not copy array of reass objects\n");
+			log_err("Cannot copy array of Reassembly objects\n");
 			kfree(cls_objs);
 			return -EBUSY;
 		}
@@ -774,7 +781,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 					 prm.cnt_params.class_members,
 					 prm.cnt_params.frag_params.frag);
 		if (ret < 0) {
-			pr_err("Could not copy array of frag objects\n");
+			log_err("Cannot copy array of Fragmentation objects\n");
 			kfree(cls_objs);
 			return -EBUSY;
 		}
@@ -784,7 +791,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 					 prm.cnt_params.class_members,
 					 prm.cnt_params.plcr_params.plcr);
 		if (ret < 0) {
-			pr_err("Could not copy array of policer objects\n");
+			log_err("Cannot copy array of Policer objects\n");
 			kfree(cls_objs);
 			return -EBUSY;
 		}
@@ -799,7 +806,8 @@ static int do_ioctl_stats_create_class_counter(void *args)
 
 				ret = copy_key_descriptor(&tbl->keys[i], &key);
 				if (ret != 0) {
-					pr_err("Couldn't copy the key descriptor\n");
+					log_err("Cannot copy the key descriptor"
+						"\n");
 					return -EINVAL;
 				}
 			}
@@ -811,14 +819,16 @@ static int do_ioctl_stats_create_class_counter(void *args)
 				ret = copy_key_descriptor(
 						&tbl->pairs[i].first_key, &key);
 				if (ret != 0) {
-					pr_err("Could not copy the key descriptor\n");
+					log_err("Cannot copy the first key "
+						"descriptor of pair-key\n");
 					return -EINVAL;
 				}
 
 				ret = copy_key_descriptor(
 					&tbl->pairs[i].second_key, &key);
 				if (ret != 0) {
-					pr_err("Could not copy the key descriptor\n");
+					log_err("Cannot copy the second key "
+						"descriptor of pair-key\n");
 					return -EINVAL;
 				}
 			}
@@ -830,7 +840,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		for (i = 0; i < prm.cnt_params.class_members; i++) {
 			ret = copy_key_descriptor(&cnode->keys[i], &key);
 			if (ret != 0) {
-				pr_err("Could not copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor\n");
 				return -EINVAL;
 			}
 		}
@@ -839,14 +849,14 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		/* Allocate memory to store the sa ids array */
 		sa_ids = kmalloc(prm.cnt_params.class_members, GFP_KERNEL);
 		if (!sa_ids) {
-			pr_err("No more memory for sa ids pointer\n");
+			log_err("Cannot allocate memory for SA ids array\n");
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(sa_ids,
 				prm.cnt_params.ipsec_params.sa_id,
 				(prm.cnt_params.class_members * sizeof(int)))) {
-			pr_err("Could not copy array of SA ids\n");
+			log_err("Cannot copy from user array of SA ids\n");
 			kfree(sa_ids);
 			return -EBUSY;
 		}
@@ -863,7 +873,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		return ret;
 
 	if (copy_to_user(args, &prm, sizeof(prm))) {
-		pr_err("Could not copy to user the Counter ID\n");
+		log_err("Cannot copy to user class counter parameters\n");
 		ret = -EINVAL;
 	}
 
@@ -921,7 +931,7 @@ static int do_ioctl_stats_compat_create_class_counter(void *args)
 	uint32_t i = 0;
 
 	if (copy_from_user(&uprm, args, sizeof(uprm))) {
-		pr_err("Could not copy Counter parameters\n");
+		log_err("Cannot copy from user the class counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -1008,7 +1018,7 @@ static int do_ioctl_stats_compat_create_class_counter(void *args)
 	uprm.cnt_id = kprm.cnt_id;
 
 	if (copy_to_user(args, &uprm, sizeof(uprm))) {
-		pr_err("Could not copy to user the Counter ID\n");
+		log_err("Cannot copy to user the counter id\n");
 		ret = -EINVAL;
 	}
 
@@ -1070,7 +1080,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	int ret;
 
 	if (copy_from_user(&prm, args, sizeof(prm))) {
-		pr_err("Could not copy user parameters\n");
+		log_err("Cannot copy from user the class counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -1079,7 +1089,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		if (prm.params.key.byte) {
 			ret = copy_key_descriptor(&prm.params.key, &key);
 			if (ret != 0) {
-				pr_err("Couldn't copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor\n");
 				return -EINVAL;
 			}
 		}
@@ -1090,14 +1100,16 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 			ret = copy_key_descriptor(
 					&prm.params.pair.first_key, &key);
 			if (ret != 0) {
-				pr_err("Could not copy the key descriptor\n");
+				log_err("Cannot copy the first key descriptor "
+					"of the pair-key\n");
 				return -EINVAL;
 			}
 
 			ret = copy_key_descriptor(
 					&prm.params.pair.second_key, &key);
 			if (ret != 0) {
-				pr_err("Could not copy the key descriptor\n");
+				log_err("Cannot copy the second key descriptor "
+					"of the pair-key\n");
 				return -EINVAL;
 			}
 		}
@@ -1105,8 +1117,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		break;
 	default:
-		pr_err("Invalid class member type\n");
-		return -EINVAL;
+		break;
 	}
 
 	ret = dpa_stats_modify_class_counter(prm.cnt_id,
@@ -1128,13 +1139,11 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		break;
 	default:
-		pr_err("Invalid class member type\n");
 		break;
 	}
 
 	if (copy_to_user(args, &prm, sizeof(prm))) {
-		pr_err("Could not write "
-		       "dpa_stats_modify_class_counter result\n");
+		log_err("Cannot copy to user the class counter result\n");
 		return -EBUSY;
 	}
 
@@ -1149,7 +1158,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 	int ret;
 
 	if (copy_from_user(&uprm, args, sizeof(uprm))) {
-		pr_err("Could not copy user parameters\n");
+		log_err("Cannot copy from user the class counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -1164,8 +1173,11 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 			ret = copy_key_descriptor_compatcpy(
 					&kprm.params.key,
 					&uprm.params.key);
-			if (ret < 0)
+			if (ret < 0) {
+				log_err("Cannot copy the key descriptor\n");
 				return ret;
+			}
+
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
@@ -1180,7 +1192,8 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 					&kprm.params.pair.second_key,
 					&uprm.params.pair.second_key);
 			if (ret != 0) {
-				pr_err("Could not copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor of the "
+					"pair-key\n");
 				return -EINVAL;
 			}
 		}
@@ -1189,8 +1202,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 		kprm.params.sa_id = uprm.params.sa_id;
 		break;
 	default:
-		pr_err("Invalid class member type\n");
-		return -EINVAL;
+		break;
 	}
 
 	ret = dpa_stats_modify_class_counter(kprm.cnt_id,
@@ -1214,13 +1226,11 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		break;
 	default:
-		pr_err("Invalid class member type\n");
 		break;
 	}
 
 	if (copy_to_user(args, &uprm, sizeof(uprm))) {
-		pr_err("Could not write "
-				"dpa_stats_modify_class_counter result\n");
+		log_err("Cannot copy to user class counter result\n");
 		return -EBUSY;
 	}
 
@@ -1235,7 +1245,7 @@ static int do_ioctl_stats_get_counters(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&prm, args, sizeof(prm))) {
-		pr_err("Could not copy Request parameters\n");
+		log_err("Cannot copy from user request parameters\n");
 		return -EINVAL;
 	}
 
@@ -1243,7 +1253,8 @@ static int do_ioctl_stats_get_counters(void *args)
 	cnts_ids = kzalloc(prm.req_params.cnts_ids_len *
 			   sizeof(int), GFP_KERNEL);
 	if (!cnts_ids) {
-		pr_err("Could not allocate requested counters array\n");
+		log_err("Cannot allocate memory for requested counter ids "
+			"array\n");
 		return -ENOMEM;
 	}
 
@@ -1251,7 +1262,8 @@ static int do_ioctl_stats_get_counters(void *args)
 	if (copy_from_user(cnts_ids,
 			   prm.req_params.cnts_ids,
 			   (prm.req_params.cnts_ids_len * sizeof(int)))) {
-		pr_err("Could not copy requested counters ids\n");
+		log_err("Cannot copy from user array of requested counter "
+			"ids\n");
 		kfree(prm.req_params.cnts_ids);
 		return -EINVAL;
 	}
@@ -1283,12 +1295,13 @@ static int do_ioctl_stats_get_counters(void *args)
 					  (wrp_dpa_stats.k_mem +
 					  prm.req_params.storage_area_offset),
 					  prm.cnts_len)) {
-				pr_err("Couldn't copy counters values to storage area\n");
+				log_err("Cannot copy counter values to storage "
+					"area\n");
 				return -EINVAL;
 			}
 
 		if (copy_to_user(args, &prm, sizeof(prm))) {
-			pr_err("Could not copy to user the counters length\n");
+			log_err("Cannot copy to user the counter parameters\n");
 			ret = -EINVAL;
 		}
 	}
@@ -1304,7 +1317,7 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&uprm, args, sizeof(uprm))) {
-		pr_err("Could not copy Request parameters\n");
+		log_err("Cannot copy from user request parameters\n");
 		return -EINVAL;
 	}
 
@@ -1321,7 +1334,8 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	kprm.req_params.cnts_ids = kzalloc(kprm.req_params.cnts_ids_len *
 					   sizeof(int), GFP_KERNEL);
 	if (!kprm.req_params.cnts_ids) {
-		pr_err("Could not allocate requested counters array\n");
+		log_err("Cannot allocate memory for requested counter ids "
+			"array\n");
 		return -ENOMEM;
 	}
 
@@ -1329,7 +1343,8 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	if (copy_from_user(kprm.req_params.cnts_ids,
 			   (compat_ptr)(uprm.req_params.cnts_ids),
 			   (kprm.req_params.cnts_ids_len * sizeof(int)))) {
-		pr_err("Could not copy requested counters ids\n");
+		log_err("Cannot copy from user the array of requested counter "
+			"ids\n");
 		kfree(kprm.req_params.cnts_ids);
 		return -EINVAL;
 	}
@@ -1359,14 +1374,15 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 					(wrp_dpa_stats.k_mem +
 					kprm.req_params.storage_area_offset),
 					kprm.cnts_len)) {
-				pr_err("Couldn't copy counters values to storage area\n");
+				log_err("Cannot copy counter values to storage "
+					"area\n");
 				return -EINVAL;
 			}
 
 		uprm.cnts_len = kprm.cnts_len;
 
 		if (copy_to_user(args, &uprm, sizeof(uprm))) {
-			pr_err("Could not copy to user the counters length\n");
+			log_err("Cannot copy to user the counter parameters\n");
 			ret = -EINVAL;
 		}
 	}
@@ -1382,14 +1398,14 @@ static int do_ioctl_stats_reset_counters(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&prm, args, sizeof(prm))) {
-		pr_err("Could not copy Counters Reset parameters\n");
+		log_err("Cannot copy from user reset counter parameters\n");
 		return -EINVAL;
 	}
 
 	/* Allocate kernel-space memory area to copy the counters ids */
 	cnt_ids = kzalloc(prm.cnts_ids_len * sizeof(int), GFP_KERNEL);
 	if (!cnt_ids) {
-		pr_err("Could not allocate counters ids array\n");
+		log_err("Cannot allocate memory for counter ids array\n");
 		return -ENOMEM;
 	}
 
@@ -1397,7 +1413,8 @@ static int do_ioctl_stats_reset_counters(void *args)
 	if (copy_from_user(cnt_ids,
 			prm.cnts_ids,
 			(prm.cnts_ids_len * sizeof(int)))) {
-		pr_err("Could not copy requested counters ids\n");
+		log_err("Cannot copy from user array of requested counter "
+			"ids\n");
 		kfree(cnt_ids);
 		return -EINVAL;
 	}
@@ -1412,7 +1429,7 @@ static int do_ioctl_stats_reset_counters(void *args)
 	kfree(cnt_ids);
 
 	if (copy_to_user(args, &prm, sizeof(prm))) {
-		pr_err("Could not copy the result to user space\n");
+		log_err("Cannot copy to user the counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -1427,7 +1444,7 @@ static int do_ioctl_stats_compat_reset_counters(void *args)
 	long ret = 0;
 
 	if (copy_from_user(&uprm, args, sizeof(uprm))) {
-		pr_err("Could not copy Counters Reset parameters\n");
+		log_err("Cannot copy from user counter reset parameters\n");
 		return -EINVAL;
 	}
 
@@ -1437,7 +1454,7 @@ static int do_ioctl_stats_compat_reset_counters(void *args)
 	/* Allocate kernel-space memory area to copy the counters ids */
 	kprm.cnts_ids = kzalloc(kprm.cnts_ids_len * sizeof(int), GFP_KERNEL);
 	if (!kprm.cnts_ids) {
-		pr_err("Could not allocate counters ids array\n");
+		log_err("Cannot allocate memory for counter ids array\n");
 		return -ENOMEM;
 	}
 
@@ -1445,7 +1462,7 @@ static int do_ioctl_stats_compat_reset_counters(void *args)
 	if (copy_from_user(kprm.cnts_ids,
 			(compat_ptr)(uprm.cnts_ids),
 			(kprm.cnts_ids_len * sizeof(int)))) {
-		pr_err("Could not copy requested counters ids\n");
+		log_err("Cannot copy from user array of counter ids\n");
 		kfree(kprm.cnts_ids);
 		return -EINVAL;
 	}
@@ -1459,7 +1476,7 @@ static int do_ioctl_stats_compat_reset_counters(void *args)
 	kfree(kprm.cnts_ids);
 
 	if (copy_to_user(args, &uprm, sizeof(uprm))) {
-		pr_err("Could not copy the result to user space\n");
+		log_err("Cannot copy to user the counter parameters\n");
 		return -EINVAL;
 	}
 
@@ -1479,7 +1496,8 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 
 		/* Copy parameters from user-space */
 		if (copy_from_user(&kparam, (void *)args, sizeof(kparam))) {
-			pr_err("Could not read dpa_stats_init user space args\n");
+			log_err("Cannot copy from user dpa_stats_init "
+				"arguments\n");
 			return -EBUSY;
 		}
 
@@ -1489,7 +1507,7 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 
 		/* Copy paramters to user-space */
 		if (copy_to_user((void *)args, &kparam, sizeof(kparam))) {
-			pr_err("Could not write dpa_stats_init result\n");
+			log_err("Cannot copy to user dpa_stats_init result\n");
 			return -EBUSY;
 		}
 		break;
@@ -1518,7 +1536,7 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 		int dpa_stats_cnt_id;
 		if (copy_from_user(&dpa_stats_cnt_id, (int *)args,
 				    sizeof(int))) {
-			pr_err("Could not copy parameters\n");
+			log_err("Cannot copy from user the parameters\n");
 			return -EINVAL;
 		}
 
@@ -1539,8 +1557,8 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 			return ret;
 		break;
 	default:
-		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
-				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
+		log_err("Unsupported ioctl 0x%08x, type 0x%02x, nr 0x%02x\n",
+			cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
 		break;
 	}
 	return ret;
@@ -1561,7 +1579,8 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp,
 
 		/* Copy parameters from user space */
 		if (copy_from_user(&uparam, (void *)args, sizeof(uparam))) {
-			pr_err("Could not read dpa_stats_init user space args\n");
+			log_err("Cannot copy from user dpa_stats_init "
+				"arguments\n");
 			return -EBUSY;
 		}
 		dpa_stats_init_compatcpy(&kparam, &uparam);
@@ -1573,7 +1592,7 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp,
 		/* Copy result to user-space */
 		uparam.dpa_stats_id = kparam.dpa_stats_id;
 		if (copy_to_user((void *)args, &uparam, sizeof(uparam))) {
-			pr_err("Could not write dpa_stats_init result\n");
+			log_err("Cannot copy to user dpa_stats_init result\n");
 			return -EBUSY;
 		}
 		break;
@@ -1603,7 +1622,7 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp,
 
 		if (copy_from_user(&dpa_stats_cnt_id, (int *)args,
 				    sizeof(int))) {
-			pr_err("Could not copy parameters\n");
+			log_err("Cannot copy from user counter parameters\n");
 			return -EINVAL;
 		}
 
@@ -1623,8 +1642,8 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp,
 			return ret;
 		break;
 	default:
-		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
-				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
+		log_err("Unsupported ioctl 0x%08x, type 0x%02x, nr 0x%02x\n",
+			cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
 		break;
 	}
 	return ret;
@@ -1640,8 +1659,8 @@ static long store_get_cnts_async_params(
 
 	mutex_lock(&wrp_dpa_stats.async_req_lock);
 	if (list_empty(&wrp_dpa_stats.async_req_pool)) {
-		pr_err("Reached maximum supported number "
-			"of simultaneous asynchronous requests\n");
+		log_err("Reached maximum supported number of simultaneous "
+			"asynchronous requests\n");
 		kfree(kprm->req_params.cnts_ids);
 		mutex_unlock(&wrp_dpa_stats.async_req_lock);
 		return -EDOM;
@@ -1672,19 +1691,19 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 			       struct dpa_offload_lookup_key *tmp)
 {
 	if (!src->byte) {
-		pr_err("Key byte pointer can't be NULL\n");
+		log_err("Key descriptor byte from user cannot be NULL\n");
 		return -EINVAL;
 	}
 
 	/* Allocate memory to store the key byte array */
 	tmp->byte = kmalloc(src->size, GFP_KERNEL);
 	if (!tmp->byte) {
-		pr_err("No more memory for key pointer\n");
+		log_err("Cannot allocate memory for key descriptor byte\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(tmp->byte, src->byte, src->size)) {
-		pr_err("Could not copy key byte\n");
+		log_err("Cannot copy from user the key descriptor byte\n");
 		kfree(tmp->byte);
 		return -EBUSY;
 	}
@@ -1694,13 +1713,15 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		/* Allocate memory to store the key mask array */
 		tmp->mask = kmalloc(src->size, GFP_KERNEL);
 		if (!tmp->mask) {
-			pr_err("No more memory for mask pointer\n");
+			log_err("Cannot allocate memory for key descriptor "
+				"mask\n");
 			kfree(tmp->byte);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(tmp->mask, src->mask, src->size)) {
-			pr_err("Could not copy key mask\n");
+			log_err("Cannot copy from user the key descriptor "
+				"mask\n");
 			kfree(tmp->byte);
 			kfree(tmp->mask);
 			return -EBUSY;
@@ -1722,27 +1743,29 @@ static int copy_key_descriptor_compatcpy(
 	/* Allocate memory to store the key byte array */
 	kparam->byte = kmalloc(kparam->size, GFP_KERNEL);
 	if (!kparam->byte) {
-		pr_err("No more memory for key pointer\n");
+		log_err("Cannot allocate memory for key descriptor byte\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(kparam->byte, compat_ptr(uparam->byte),
 		uparam->size)) {
-		pr_err("Could not copy key byte\n");
+		log_err("Cannot copy from user the key descriptor byte\n");
 		return -EBUSY;
 	}
 	if (compat_ptr(uparam->mask)) {
 		/* Allocate memory to store the key mask array */
 		kparam->mask = kmalloc(kparam->size, GFP_KERNEL);
 		if (!kparam->mask) {
-			pr_err("No more memory for mask pointer\n");
+			log_err("Cannot allocate memory for key descriptor "
+				"mask\n");
 			kfree(kparam->byte);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(kparam->mask, compat_ptr(uparam->mask),
 			uparam->size)) {
-			pr_err("Could not copy key mask\n");
+			log_err("Cannot copy from user the key descriptor "
+				"mask\n");
 			return -EBUSY;
 		}
 	} else
@@ -1754,15 +1777,15 @@ static int copy_key_descriptor_compatcpy(
 
 static int copy_class_members(void *objs, unsigned int size, void *dst)
 {
-	/* Allocate memory to store the array of reass objects */
+	/* Allocate memory to store the array of objects */
 	objs = kmalloc(size * sizeof(void *), GFP_KERNEL);
 	if (!objs) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate memory for objects array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(objs, dst, (size * sizeof(void *)))) {
-		pr_err("Could not copy array of objects\n");
+		log_err("Cannot copy from user array of objects\n");
 		kfree(objs);
 		return -EBUSY;
 	}
@@ -1832,12 +1855,13 @@ static long dpa_stats_eth_cls_compatcpy(struct dpa_stats_cls_cnt_eth *kprm,
 	/* Allocate memory to store the sources array */
 	kprm->src = kzalloc(size, GFP_KERNEL);
 	if (!kprm->src) {
-		pr_err("No more memory for ethernet sources array\n");
+		log_err("Cannot allocate kernel memory for Ethernet sources "
+			"array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(kprm->src, compat_ptr(uprm->src), size)) {
-		pr_err("Could not copy array of ethernet sources\n");
+		log_err("Cannot copy from user array of Ethernet sources\n");
 		kfree(kprm->src);
 		return -EBUSY;
 	}
@@ -1854,20 +1878,22 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	/* Allocate memory to store the array of user-space reass objects */
 	reass = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
 	if (!reass) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate memory for Reassembly objects "
+			"array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(reass, compat_ptr(uprm->reass),
 			(sizeof(compat_uptr_t) * cls_members))) {
-		pr_err("Could not copy array of objects\n");
+		log_err("Cannot copy from user array of Reassembly objects\n");
 		return -EBUSY;
 	}
 
 	/* Allocate memory to store the array of kernel space reass objects */
 	kprm->reass = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->reass) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate kernel memory for Reassembly objects "
+			"array\n");
 		return -ENOMEM;
 	}
 
@@ -1889,20 +1915,23 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	/* Allocate memory to store the array of user-space frag objects */
 	ufrag = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
 	if (!ufrag) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate memory for Fragmentation objects "
+			"array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(ufrag, compat_ptr(uprm->frag),
 			(sizeof(compat_uptr_t) * cls_members))) {
-		pr_err("Could not copy array of objects\n");
+		log_err("Cannot copy from user array of Fragmentation "
+			"objects\n");
 		return -EBUSY;
 	}
 
 	/* Allocate memory to store the array of kernel space frag objects */
 	kprm->frag = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->frag) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate kernel memory for Fragmentation "
+			"objects array\n");
 		return -ENOMEM;
 	}
 
@@ -1924,20 +1953,21 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	/* Allocate memory to store the array of user-space policer objects */
 	uplcr = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
 	if (!uplcr) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate memory for Policer objects array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(uplcr, compat_ptr(uprm->plcr),
 			(sizeof(compat_uptr_t) * cls_members))) {
-		pr_err("Could not copy array of objects\n");
+		log_err("Cannot copy from user array of Policer objects\n");
 		return -EBUSY;
 	}
 
 	/* Allocate memory to store the array of kernel space policer objects */
 	kprm->plcr = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->plcr) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate kernel memory for Policer objects "
+			"array\n");
 		return -ENOMEM;
 	}
 
@@ -1967,7 +1997,8 @@ static long dpa_stats_tbl_cls_compatcpy(
 		size = sizeof(struct dpa_offload_lookup_key) * cls_members;
 		kprm->keys = kzalloc(size, GFP_KERNEL);
 		if (!kprm->keys) {
-			pr_err("No more memory for class members pointers\n");
+			log_err("Cannot allocate kernel memory for lookup keys "
+				"array\n");
 			return -ENOMEM;
 		}
 
@@ -1975,12 +2006,13 @@ static long dpa_stats_tbl_cls_compatcpy(
 				cls_members;
 		keys = kzalloc(size, GFP_KERNEL);
 		if (!keys) {
-			pr_err("No more memory for class members pointers\n");
+			log_err("Cannot allocate memory for lookup keys "
+				"array\n");
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(keys, (compat_ptr)(uprm->keys), size)) {
-			pr_err("Could not copy array of objects\n");
+			log_err("Cannot copy from user array of lookup keys\n");
 			kfree(keys);
 			return -EBUSY;
 		}
@@ -1992,7 +2024,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 			ret = copy_key_descriptor_compatcpy(&kprm->keys[i],
 					&keys[i]);
 			if (ret != 0) {
-				pr_err("Couldn't copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor\n");
 				kfree(keys);
 				return -EINVAL;
 			}
@@ -2002,7 +2034,8 @@ static long dpa_stats_tbl_cls_compatcpy(
 		size = sizeof(struct dpa_offload_lookup_key_pair) * cls_members;
 		kprm->pairs = kzalloc(size, GFP_KERNEL);
 		if (!kprm->pairs) {
-			pr_err("No more memory for class members pointers\n");
+			log_err("Cannot allocate kernel memory for pair lookup "
+				"keys array\n");
 			return -ENOMEM;
 		}
 
@@ -2010,12 +2043,14 @@ static long dpa_stats_tbl_cls_compatcpy(
 				cls_members;
 		pairs = kzalloc(size, GFP_KERNEL);
 		if (!pairs) {
-			pr_err("No more memory for class members pointers\n");
+			log_err("Cannot allocate memory for pair lookup keys "
+				"array\n");
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(pairs, (compat_ptr)(uprm->pairs), size)) {
-			pr_err("Could not copy array of objects\n");
+			log_err("Cannot copy from user array of pair lookup "
+				"keys\n");
 			kfree(pairs);
 			return -EBUSY;
 		}
@@ -2028,7 +2063,8 @@ static long dpa_stats_tbl_cls_compatcpy(
 					&kprm->pairs[i].first_key,
 					&pairs[i].first_key);
 			if (ret != 0) {
-				pr_err("Couldn't copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor for the"
+					" first lookup key\n");
 				kfree(pairs);
 				return -EINVAL;
 			}
@@ -2037,7 +2073,8 @@ static long dpa_stats_tbl_cls_compatcpy(
 					&kprm->pairs[i].second_key,
 					&pairs[i].second_key);
 			if (ret != 0) {
-				pr_err("Couldn't copy the key descriptor\n");
+				log_err("Cannot copy the key descriptor for the"
+					" second lookup key\n", uprm->td);
 				kfree(pairs);
 				return -EINVAL;
 			}
@@ -2063,19 +2100,20 @@ static long dpa_stats_ccnode_cls_compatcpy(
 	size = sizeof(struct dpa_offload_lookup_key) * cls_members;
 	kprm->keys = kzalloc(size, GFP_KERNEL);
 	if (!kprm->keys) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate kernel memory for lookup keys "
+			"array\n");
 		return -ENOMEM;
 	}
 
 	size = sizeof(struct compat_ioc_dpa_offld_lookup_key) * cls_members;
 	keys = kzalloc(size, GFP_KERNEL);
 	if (!keys) {
-		pr_err("No more memory for class members pointers\n");
+		log_err("Cannot allocate memory for lookup keys array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(keys, (compat_ptr)(uprm->keys), size)) {
-		pr_err("Could not copy array of objects\n");
+		log_err("Cannot copy from user array of lookup keys\n");
 		kfree(keys);
 		return -EBUSY;
 	}
@@ -2083,7 +2121,7 @@ static long dpa_stats_ccnode_cls_compatcpy(
 	for (i = 0; i < cls_members; i++) {
 		ret = copy_key_descriptor_compatcpy(&kprm->keys[i], &keys[i]);
 		if (ret != 0) {
-			pr_err("Couldn't copy the key descriptor\n");
+			log_err("Cannot copy the key descriptor\n");
 			kfree(keys);
 			return -EINVAL;
 		}
@@ -2101,14 +2139,14 @@ static long dpa_stats_ipsec_cls_compatcpy(struct dpa_stats_cls_cnt_ipsec *kprm,
 	/* Allocate memory to store the sa ids array */
 	kprm->sa_id = kmalloc(cls_members * sizeof(int), GFP_KERNEL);
 	if (!kprm->sa_id) {
-		pr_err("No more memory for sa ids pointer\n");
+		log_err("Cannot allocate memory for SA ids array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(kprm->sa_id,
 			(compat_ptr)(uprm->sa_id),
 			(cls_members * sizeof(int)))) {
-		pr_err("Could not copy array of SA ids\n");
+		log_err("Cannot copy from user array of SA ids\n");
 		kfree(kprm->sa_id);
 		return -EBUSY;
 	}
-- 
1.7.5.4

