From 12d0b2899fab051e7fe534f8c5fb87056f3251d4 Mon Sep 17 00:00:00 2001
From: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
Date: Tue, 13 Nov 2012 13:36:29 +0000
Subject: [PATCH 413/518] offload_use_case: Add fragmentation descriptor for
 each outbound policy

Outbound policies used the same fragmentation descriptor. That meant that
a  special operation chain attached to a  policy shared with the other
chains the same fragmentation operation. This is not correct from the
FMD driver perspective and could lead to unexpected errors regarding
header manipulation. This patch fixes the above issue by creating different
fragmentaition operations for each outbound policy.

Signed-off-by: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/common.h  |    6 ++-
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |   34 ++++++-------------
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   29 +++++++++++++++-
 3 files changed, 42 insertions(+), 27 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/common.h b/drivers/staging/fsl_dpa_offload/usecases/common.h
index db436b8..03b70cb 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/common.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/common.h
@@ -71,6 +71,8 @@ extern int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
 extern int outb_post_tx_fqid;
 extern int outb_update_hmd;
 extern bool inb_pol_check;
-extern int manip_desc;
-
+extern int manip_desc[OUTB_POST_SEC_MAX_NUM_KEYS];
+extern int mtu_pre_enc;
+extern int fr_bpid;
+extern t_Handle pcd_dev;
 #endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index e0b74a9..6325f5a 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -139,7 +139,10 @@ int outb_pre_ipsec_nat_td;
 int outb_post_tx_fqid;
 int outb_update_hmd;
 bool inb_pol_check;
-int manip_desc;
+int manip_desc[OUTB_POST_SEC_MAX_NUM_KEYS];
+int fr_bpid;
+int mtu_pre_enc;
+t_Handle pcd_dev;
 
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 {
@@ -152,7 +155,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	t_LnxWrpFmPortDev *ib_oh_post, *ob_oh_post;
 
 	outb_update_hmd = DPA_OFFLD_DESC_NONE;
-	manip_desc	= DPA_OFFLD_DESC_NONE;
+	memset(manip_desc, DPA_OFFLD_DESC_NONE, sizeof(manip_desc));
 	memset(&ipsec_params, 0, sizeof(ipsec_params));
 	memset(&pcd_params, 0, sizeof(pcd_params));
 
@@ -186,26 +189,10 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	outb_post_tx_fqid = params->outb_post_tx_fqid;
 	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
 	ipsec_params.ipf_bpid = params->ipf_bpid;
+	fr_bpid = ipsec_params.ipf_bpid;
+	mtu_pre_enc = params->mtu_pre_enc;
+	pcd_dev = fm_dev->h_PcdDev;
 	ipsec_params.qm_sec_ch = qm_channel_caam;
-	if (params->mtu_pre_enc > 0) {
-		struct dpa_cls_hm_update_params update_params;
-		memset(&update_params, 0,
-		       sizeof(struct dpa_cls_hm_update_params));
-		update_params.fm_pcd = fm_dev->h_PcdDev;
-		update_params.ip_frag_params.df_action =
-					DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY;
-		update_params.ip_frag_params.mtu = params->mtu_pre_enc;
-		update_params.ip_frag_params.scratch_bpid = params->ipf_bpid;
-		ret = dpa_classif_set_update_hm(&update_params,
-						DPA_OFFLD_DESC_NONE,
-						&manip_desc, true,  NULL);
-		if (ret < 0) {
-			pr_err("%s:%dCould not create fragmentation manip "
-				"handle %d\n", __func__, __LINE__, ret);
-			return ret;
-		}
-	}
-
 	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
 		/* INB/DL pre SEC classifier */
 		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
@@ -719,8 +706,9 @@ int cleanup_ipsec_offload(int dpa_ipsec_id)
 	if (hmd_fwd != DPA_OFFLD_DESC_NONE)
 		dpa_classif_free_hm(hmd_fwd);
 
-	if (manip_desc != DPA_OFFLD_DESC_NONE)
-		dpa_classif_free_hm(manip_desc);
+	for (i = 0; i < OUTB_POST_SEC_MAX_NUM_KEYS; i++)
+		if (manip_desc[i] != DPA_OFFLD_DESC_NONE)
+			dpa_classif_free_hm(manip_desc[i]);
 
 	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
 		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 4542d0d..a9eb4e9 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -589,10 +589,35 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 
 	memset(pol_params, 0, sizeof(*pol_params));
 	if (dir == XFRM_POLICY_OUT) {
-		if (manip_desc != DPA_OFFLD_DESC_NONE) {
+		if (mtu_pre_enc > 0) {
+			struct dpa_cls_hm_update_params update_params;
+			int frag_desc, fra_cnt, max_frags;
+			memset(&update_params, 0,
+			       sizeof(struct dpa_cls_hm_update_params));
+			max_frags = ARRAY_SIZE(manip_desc);
+			update_params.fm_pcd = pcd_dev;
+			update_params.ip_frag_params.df_action =
+					DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY;
+			update_params.ip_frag_params.mtu = mtu_pre_enc;
+			update_params.ip_frag_params.scratch_bpid = fr_bpid;
+			ret = dpa_classif_set_update_hm(&update_params,
+						DPA_OFFLD_DESC_NONE,
+						&frag_desc, true,  NULL);
+			if (ret < 0) {
+				pr_err("%s:%dCould not create fragmentation "
+				       "manip handle %d\n", __func__, __LINE__,
+				       ret);
+				return ret;
+			}
 			pol_params->dir_params.type =
 					DPA_IPSEC_POL_DIR_PARAMS_MANIP;
-			pol_params->dir_params.manip_desc = manip_desc;
+			pol_params->dir_params.manip_desc = frag_desc;
+			for (fra_cnt = 0; fra_cnt < max_frags; fra_cnt++)
+				if (manip_desc[fra_cnt] ==
+							DPA_OFFLD_DESC_NONE) {
+					manip_desc[fra_cnt] = frag_desc;
+					break;
+				}
 		}
 	}
 
-- 
1.7.5.4

