From 31e7439ec9b87ae95d9f9ce68eaa2be725c935f6 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:55:43 +0000
Subject: [PATCH 255/518] dpa_stats: Added support for Policer counter

Added support for Policer single and class counter.
Application can use this counter to retrieve
policer profile statistics

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  150 +++++++++++++++++++++++++++
 include/linux/fsl_dpa_stats.h               |   46 ++++++++
 2 files changed, 196 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index cc1f93b..3433d20 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -397,6 +397,25 @@ static void create_cnt_frag_stats(struct dpa_stats *dpa_stats)
 			(void *)&stats.generatedFragments - (void *)&stats;
 }
 
+static void create_cnt_plcr_stats(struct dpa_stats *dpa_stats)
+{
+	/* DPA_STATS_CNT_PLCR_GREEN_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_POLICER][0] =
+			e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER;
+	/* DPA_STATS_CNT_PLCR_YELLOW_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_POLICER][1] =
+			e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER;
+	/* DPA_STATS_CNT_PLCR_RED_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_POLICER][2] =
+			e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER;
+	/* DPA_STATS_CNT_PLCR_RECOLOR_YELLOW_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_POLICER][3] =
+		e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER;
+	/* DPA_STATS_CNT_PLCR_RECOLOR_RED_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_POLICER][4] =
+		e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER;
+}
+
 static t_Handle get_fman_ethernet_dev_node(
 		struct device_node *parent_dev_node, int port_id)
 {
@@ -639,6 +658,40 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->reass_params.cnt_sel;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Policer counter selection */
+	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_PLCR_ALL)) {
+		pr_err("Invalid Policer counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs[0] = params->plcr_params.plcr;
+	cnt_gen_cb->objs_num = 1;
+
+	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
+		cnt_sel -= 1;
+
+	/* Map Policer counter selection to policer statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -802,6 +855,43 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->plcr_params.cnt_sel;
+	uint32_t i;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Policer counter selection */
+	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_PLCR_ALL)) {
+		pr_err("Invalid Policer counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs_num = params->class_members;
+
+	for (i = 0; i < params->class_members; i++)
+		cnt_gen_cb->objs[0] = params->plcr_params.plcr;
+
+	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
+		cnt_sel -= 1;
+
+	/* Map Policer counter selection to policer statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
+				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -934,6 +1024,45 @@ static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_plcr_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct stats_info *info = &cnt_cb->gen_cb.info;
+	uint64_t stats_val = 0;
+	uint32_t i = 0, j = 0;
+
+	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+		for (j = 0; j < info->stats_num; j++) {
+			stats_val = (uint64_t)FM_PCD_PlcrProfileGetCounter(
+				cnt_cb->gen_cb.objs[i], info->stats_off[j]);
+
+			/* Check for rollover */
+			if (stats_val < info->last_stats[i][j])
+				info->stats[i][j] +=
+					((unsigned long int)0xffffffff -
+					info->last_stats[i][j]) + stats_val;
+			else
+				info->stats[i][j] += stats_val -
+					info->last_stats[i][j];
+
+			/* Store the current value as the last read value */
+			info->last_stats[i][j] = stats_val;
+
+			/* Write the memory location */
+			*(uint32_t *)(req_cb->request_area) =
+					(uint32_t)info->stats[i][j];
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE;
+
+			if (info->reset)
+				info->stats[i][j] = 0;
+		}
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -980,6 +1109,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map Fragmentation counters to FMAN Fragmentation statistics */
 	create_cnt_frag_stats(dpa_stats);
 
+	/* Map Policer counters to FMAN Policer statistics */
+	create_cnt_plcr_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -1045,6 +1177,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_FRAG;
 		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
 		break;
+	case DPA_STATS_CNT_POLICER:
+		err = set_cnt_plcr_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Policer counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_POLICER;
+		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -1133,6 +1274,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_FRAG;
 		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
 		break;
+	case DPA_STATS_CNT_POLICER:
+		err = set_cls_cnt_plcr_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Policer counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_POLICER;
+		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 1c518f4..4fe61aa 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -274,6 +274,34 @@ struct dpa_stats_cnt_frag {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Policer counters */
+enum dpa_stats_cnt_plcr_sel {
+	/* Number of 'green' frames */
+	DPA_STATS_CNT_PLCR_GREEN_PKTS		= 0x00000001,
+	/* Number of 'yellow' frames */
+	DPA_STATS_CNT_PLCR_YELLOW_PKTS		= 0x00000002,
+	/* Number of 'red' frames */
+	DPA_STATS_CNT_PLCR_RED_PKTS		= 0x00000004,
+	/* Number of recolored 'yellow' frames */
+	DPA_STATS_CNT_PLCR_RECOLOR_YELLOW_PKTS	= 0x00000008,
+	/* Number of recolored 'red' frames */
+	DPA_STATS_CNT_PLCR_RECOLOR_RED_PKTS	= 0x00000010,
+	/* Select all counters */
+	DPA_STATS_CNT_PLCR_ALL			= 0x00000020
+};
+
+/* DPA Stats Policer counter parameters */
+struct dpa_stats_cnt_plcr {
+	/* Pointer to the Policer object */
+	void	*plcr;
+
+	/*
+	 * Single or multiple selection of Policer counters
+	 * from enum dpa_stats_cnt_plcr_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -289,6 +317,9 @@ struct dpa_stats_cnt_params {
 
 		/* Parameters for IP Fragmentation counter */
 		struct dpa_stats_cnt_frag frag_params;
+
+		/* Parameters for Policer counter */
+		struct dpa_stats_cnt_plcr plcr_params;
 	};
 };
 
@@ -326,6 +357,18 @@ struct dpa_stats_cls_cnt_frag {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Policer class counter parameters */
+struct dpa_stats_cls_cnt_plcr {
+	/* Array of pointers of Policer objects */
+	void	**plcr;
+
+	/*
+	 * Single or multiple selection of Policer counters
+	 * from enum dpa_stats_cnt_plcr_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -344,6 +387,9 @@ struct dpa_stats_cls_cnt_params {
 
 		/* Parameters for IP Fragmentation class counter */
 		struct dpa_stats_cls_cnt_frag frag_params;
+
+		/* Parameters for Policer class counter */
+		struct dpa_stats_cls_cnt_plcr plcr_params;
 	};
 };
 
-- 
1.7.5.4

