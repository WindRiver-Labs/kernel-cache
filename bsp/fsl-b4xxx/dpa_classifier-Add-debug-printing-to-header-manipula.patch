From af66a02b364b24bca8e1493b14a7de89e8d45e5e Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 22 Feb 2013 21:41:21 +0000
Subject: [PATCH 464/518] dpa_classifier: Add debug printing to header
 manipulation API

Added debug information printing to the functions that are managing
the header manipulation operations.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  332 +++++++++++++++++++++-
 1 files changed, 326 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index ad10c06..a4edfd8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -868,14 +868,24 @@ EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_key);
 
 static void dump_lookup_key(const struct dpa_offload_lookup_key *key)
 {
-	int i;
+	int i, offset;
+	char data[3 * FM_PCD_MAX_SIZE_OF_KEY + 10];
 
-	for (i = 0; i < key->size; i++)
-		pr_err(" %02x", key->byte[i]);
-	pr_err(". Mask was (hex):");
+	offset = 0;
+	for (i = 0; i < key->size; i++) {
+		sprintf(&data[offset], " %02x", key->byte[i]);
+		offset += 3;
+	}
+	data[offset] = 0;
+	pr_err("%s. Mask was (hex):", data);
+	offset = 0;
 	if (key->mask) {
-		for (i = 0; i < key->size; i++)
-			pr_err(" %02x", key->mask[i]);
+		for (i = 0; i < key->size; i++) {
+			sprintf(&data[offset], " %02x", key->mask[i]);
+			offset += 3;
+		}
+		data[offset] = 0;
+		pr_err("%s", data);
 	} else
 		pr_err("n/a");
 }
@@ -3679,10 +3689,137 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	pcurrent = list_entry(item, struct dpa_cls_hm_node, list_node);
 	pcurrent->params.h_NextManip = (pnext) ? (t_Handle)pnext->node : NULL;
 
+#ifdef DPA_CLASSIFIER_DEBUG
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Dumping HM node params.\n",
+		__func__, __LINE__));
+	switch (pcurrent->params.type) {
+	case e_FM_PCD_MANIP_HDR:
+		dpa_cls_dbg(("	hm_node_params.type = "
+			"e_FM_PCD_MANIP_HDR\n"));
+		dpa_cls_dbg(("	hm_node_params.u.hdr.rmv = %d\n",
+			pcurrent->params.u.hdr.rmv));
+		if (pcurrent->params.u.hdr.rmv) {
+			dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams"
+				".type = %d\n",
+				pcurrent->params.u.hdr.rmvParams.type));
+		}
+		dpa_cls_dbg(("	hm_node_params.u.hdr.insrt = %d\n",
+			pcurrent->params.u.hdr.insrt));
+		if (pcurrent->params.u.hdr.insrt) {
+			dpa_cls_dbg(("	hm_node_params.u.hdr.insrtParams"
+				".type = %d\n",
+				pcurrent->params.u.hdr.insrtParams.type));
+		}
+		dpa_cls_dbg(("	hm_node_params.u.hdr.fieldUpdate = %d\n",
+			pcurrent->params.u.hdr.fieldUpdate));
+		if (pcurrent->params.u.hdr.fieldUpdate) {
+			switch (pcurrent->params.u.hdr.fieldUpdateParams.
+								type) {
+			case e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN:
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.type = "
+					"HDR_FIELD_UPDATE_VLAN\n"));
+				break;
+			case e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4:
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.type = "
+					"HDR_FIELD_UPDATE_IPv4\n"));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.ipv4."
+					"validUpdates = 0x%x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.ipv4.
+					validUpdates));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.ipv4."
+					"tos = 0x%02x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.ipv4.
+					tos));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.ipv4."
+					"id = 0x%04x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.ipv4.
+					id));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.ipv4."
+					"src = 0x%08x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.ipv4.
+					src));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.ipv4."
+					"dst = 0x%08x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.ipv4.
+					dst));
+				break;
+			case e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6:
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.type = "
+					"HDR_FIELD_UPDATE_IPv6\n"));
+				break;
+			case e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP:
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.type = "
+					"HDR_FIELD_UPDATE_TCP_UDP\n"));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.tcpUdp."
+					"validUpdates = 0x%x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.tcpUdp.
+					validUpdates));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.tcpUdp."
+					"src = 0x%04x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.tcpUdp.
+					src));
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.u.tcpUdp."
+					"dst = 0x%04x\n",
+					pcurrent->params.u.hdr.
+					fieldUpdateParams.u.tcpUdp.
+					dst));
+				break;
+			default:
+				dpa_cls_dbg(("	hm_node_params.u.hdr."
+					"fieldUpdateParams.type = %d "
+					"(unknown)\n",
+					pcurrent->params.u.hdr.
+						fieldUpdateParams.type));
+			}
+		}
+		dpa_cls_dbg(("	hm_node_params.u.hdr.custom = %d\n",
+			pcurrent->params.u.hdr.custom));
+		if (pcurrent->params.u.hdr.custom) {
+			dpa_cls_dbg(("	hm_node_params.u.hdr."
+				"custom.type = %d\n",
+				pcurrent->params.u.hdr.customParams.type));
+		}
+		break;
+	case e_FM_PCD_MANIP_FRAG:
+		dpa_cls_dbg(("	hm_node_params.type = "
+			"e_FM_PCD_MANIP_FRAG\n"));
+		break;
+	default:
+		dpa_cls_dbg(("	hm_node_params.type = %d (unspecified)\n",
+			pcurrent->params.type));
+		break;
+	}
+	dpa_cls_dbg(("	hm_node_params.h_NextManip = 0x%p\n",
+		pcurrent->params.h_NextManip));
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): End of HM node params.\n",
+		__func__, __LINE__));
+#endif /* DPA_CLASSIFIER_DEBUG */
 	if (!pcurrent->node) {
 		pcurrent->node = (void *) FM_PCD_ManipNodeSet(
 							(t_Handle) fm_pcd,
 							&pcurrent->params);
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): CREATE new HM "
+			"node (h_node=0x%p).\n", __func__, __LINE__,
+			pcurrent->node));
 		if (!pcurrent->node) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_ManipNodeSet. Failed to initialize low "
@@ -3693,6 +3830,9 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 
 		pcurrent->flags |= DPA_CLS_HM_NODE_INTERNAL;
 	} else {
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): REPLACE existing "
+			"HM node (h_node=0x%p).\n", __func__, __LINE__,
+			pcurrent->node));
 		/* Need to sync with an existing node */
 		memcpy(&params, &pcurrent->params, sizeof(params));
 		params.h_NextManip = NULL;
@@ -3905,6 +4045,9 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	int err;
 	struct dpa_cls_hm *pnat_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!nat_params) {
 		pr_err("ERROR: %s, %s (%d): \"nat_params\" cannot be NULL.\n",
@@ -3966,6 +4109,9 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 nat_hm_error:
@@ -3989,6 +4135,9 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 	enum dpa_cls_hm_node_type l4_update_node = DPA_CLS_HM_NODE_LAST_ENTRY;
 	unsigned int ip_ver = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pnat_hm);
 
 	pnat_hm->num_nodes = 2;
@@ -4079,6 +4228,9 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 
 	add_local_hm_nodes_to_chain(pnat_hm);
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -4091,6 +4243,9 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 	BUG_ON(pnat_hm->num_nodes < 1);
 	BUG_ON(pnat_hm->num_nodes > 2);
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (pnat_hm->hm_node[0]) {
 		hm_node = pnat_hm->hm_node[0];
 
@@ -4229,6 +4384,9 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -4242,6 +4400,9 @@ int dpa_classif_modify_nat_hm(int hmd,
 	int ret = 0;
 	int i;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -4411,6 +4572,9 @@ int dpa_classif_modify_nat_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_nat_hm);
@@ -4424,6 +4588,9 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	int err;
 	struct dpa_cls_hm *pfwd_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!fwd_params) {
 		pr_err("ERROR: %s, %s (%d): \"fwd_params\" cannot be NULL.\n",
@@ -4485,6 +4652,9 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 fwd_hm_error:
@@ -4503,6 +4673,9 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 	struct dpa_cls_hm_node *hm_node;
 	void * const *phm_nodes;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pfwd_hm);
 
 	pfwd_hm->num_nodes = 3;
@@ -4541,6 +4714,9 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 
 	add_local_hm_nodes_to_chain(pfwd_hm);
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -4550,6 +4726,9 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 	uint8_t size;
 	uint8_t *pdata;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pfwd_hm);
 	BUG_ON(pfwd_hm->num_nodes < 1);
 	BUG_ON(!pfwd_hm->hm_node[0]);
@@ -4655,6 +4834,9 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -4668,6 +4850,9 @@ int dpa_classif_modify_fwd_hm(int hmd,
 	int ret = 0;
 	int i;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -4811,6 +4996,9 @@ int dpa_classif_modify_fwd_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_fwd_hm);
@@ -4822,6 +5010,9 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	int err;
 	struct dpa_cls_hm *premove_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!remove_params) {
 		pr_err("ERROR: %s, %s (%d): \"remove_params\" cannot be NULL.\n",
@@ -4884,6 +5075,9 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 remove_hm_error:
@@ -4903,6 +5097,9 @@ static int remove_hm_prepare_nodes(struct dpa_cls_hm *premove_hm,
 	void * const *phm_nodes;
 	int err = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!premove_hm);
 
 	premove_hm->num_nodes = 1;
@@ -4928,6 +5125,9 @@ static int remove_hm_prepare_nodes(struct dpa_cls_hm *premove_hm,
 		add_local_hm_nodes_to_chain(premove_hm);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -4935,6 +5135,9 @@ static int remove_hm_update_params(struct dpa_cls_hm *premove_hm)
 {
 	struct dpa_cls_hm_node *hm_node;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!premove_hm);
 	BUG_ON(premove_hm->num_nodes != 1);
 	BUG_ON(!premove_hm->hm_node[0]);
@@ -4976,6 +5179,9 @@ static int remove_hm_update_params(struct dpa_cls_hm *premove_hm)
 		break;
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -4989,6 +5195,9 @@ int dpa_classif_modify_remove_hm(int hmd,
 	t_Error error;
 	int ret = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -5059,6 +5268,9 @@ int dpa_classif_modify_remove_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_remove_hm);
@@ -5070,6 +5282,9 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	int err;
 	struct dpa_cls_hm *pinsert_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!insert_params) {
 		pr_err("ERROR: %s, %s (%d): \"insert_params\" cannot be NULL.\n",
@@ -5132,6 +5347,9 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 insert_hm_error:
@@ -5151,6 +5369,9 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 	void * const *phm_nodes;
 	int err = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pinsert_hm);
 
 	pinsert_hm->num_nodes = 1;
@@ -5176,6 +5397,9 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 		add_local_hm_nodes_to_chain(pinsert_hm);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -5186,6 +5410,9 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	uint8_t *pdata = NULL;
 	struct dpa_cls_hm_node *hm_node;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pinsert_hm);
 	BUG_ON(pinsert_hm->num_nodes != 1);
 	BUG_ON(!pinsert_hm->hm_node[0]);
@@ -5269,6 +5496,9 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	hm_node->params.u.hdr.insrtParams.u.generic.p_Data	= pdata;
 	hm_node->params.u.hdr.insrtParams.u.generic.replace	= FALSE;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -5284,6 +5514,9 @@ int dpa_classif_modify_insert_hm(int hmd,
 	int mask;
 	uint8_t *pdata;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -5423,6 +5656,9 @@ int dpa_classif_modify_insert_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_insert_hm);
@@ -5434,6 +5670,9 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	int err;
 	struct dpa_cls_hm *pupdate_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!update_params) {
 		pr_err("ERROR: %s, %s (%d): \"update_params\" cannot be NULL.\n",
@@ -5496,6 +5735,9 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 update_hm_error:
@@ -5517,6 +5759,9 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 	int update_ops, replace_ops;
 	int err = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pupdate_hm);
 
 	pupdate_hm->num_nodes = 2;
@@ -5613,6 +5858,9 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 
 	add_local_hm_nodes_to_chain(pupdate_hm);
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -5621,6 +5869,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	struct dpa_cls_hm_node *hm_node;
 	int update_ops, replace_ops;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pupdate_hm);
 	BUG_ON(pupdate_hm->num_nodes < 1);
 	BUG_ON(!pupdate_hm->hm_node[0]);
@@ -5851,6 +6102,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -5865,6 +6119,9 @@ int dpa_classif_modify_update_hm(int hmd,
 	int ret = 0;
 	int ip_update;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -6058,6 +6315,9 @@ int dpa_classif_modify_update_hm(int hmd,
 
 	/* update[1] not supported at this time */
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_update_hm);
@@ -6071,6 +6331,9 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 	int err;
 	struct dpa_cls_hm *pvlan_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!vlan_params) {
 		pr_err("ERROR: %s, %s (%d): \"vlan_params\" cannot be NULL.\n",
@@ -6132,6 +6395,9 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 vlan_hm_error:
@@ -6151,6 +6417,9 @@ static int vlan_hm_prepare_nodes(struct dpa_cls_hm *pvlan_hm,
 	void * const *phm_nodes;
 	int err = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pvlan_hm);
 
 	pvlan_hm->num_nodes = 1;
@@ -6176,6 +6445,9 @@ static int vlan_hm_prepare_nodes(struct dpa_cls_hm *pvlan_hm,
 		add_local_hm_nodes_to_chain(pvlan_hm);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -6185,6 +6457,9 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 	uint8_t size;
 	uint8_t *pdata;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pvlan_hm);
 	BUG_ON(pvlan_hm->num_nodes != 1);
 	BUG_ON(!pvlan_hm->hm_node[0]);
@@ -6280,6 +6555,9 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 		break;
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -6292,6 +6570,9 @@ int dpa_classif_modify_vlan_hm(int hmd,
 	t_Error error;
 	int ret = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -6407,6 +6688,9 @@ int dpa_classif_modify_vlan_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_vlan_hm);
@@ -6420,6 +6704,9 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 	int err;
 	struct dpa_cls_hm *pmpls_hm;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!mpls_params) {
 		pr_err("ERROR: %s, %s (%d): \"mpls_params\" cannot be NULL.\n",
@@ -6481,6 +6768,9 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 				__LINE__);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 
 mpls_hm_error:
@@ -6500,6 +6790,9 @@ static int mpls_hm_prepare_nodes(struct dpa_cls_hm *pmpls_hm,
 	void * const *phm_nodes;
 	int err = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pmpls_hm);
 
 	pmpls_hm->num_nodes = 1;
@@ -6525,6 +6818,9 @@ static int mpls_hm_prepare_nodes(struct dpa_cls_hm *pmpls_hm,
 		add_local_hm_nodes_to_chain(pmpls_hm);
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return err;
 }
 
@@ -6534,6 +6830,9 @@ static int mpls_hm_update_params(struct dpa_cls_hm *pmpls_hm)
 	uint8_t size;
 	uint8_t *pdata;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	BUG_ON(!pmpls_hm);
 	BUG_ON(pmpls_hm->num_nodes != 1);
 	BUG_ON(!pmpls_hm->hm_node[0]);
@@ -6587,6 +6886,9 @@ static int mpls_hm_update_params(struct dpa_cls_hm *pmpls_hm)
 		break;
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -6599,6 +6901,9 @@ int dpa_classif_modify_mpls_hm(int hmd,
 	t_Error error;
 	int ret = 0;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if (!modify_flags)
 		/* Nothing to do */
 		return 0;
@@ -6663,6 +6968,9 @@ int dpa_classif_modify_mpls_hm(int hmd,
 		}
 	}
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_mpls_hm);
@@ -6673,6 +6981,9 @@ int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd)
 	struct dpa_cls_hm *pstatic_hm, *pcurrent;
 	struct dpa_cls_hm_node *hm_node;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	/* Parameters sanity checks: */
 	if (!hm) {
 		pr_err("ERROR: %s, %s (%d): \"hm\" cannot be NULL.\n",
@@ -6725,6 +7036,9 @@ int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd)
 		}
 	pstatic_hm->chain_head = true;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 
@@ -6876,6 +7190,9 @@ int dpa_classif_free_hm(int hmd)
 	struct dpa_cls_hm_node *hm_node;
 	int i = 1;
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
 	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
 		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
 			"Should be between %d and %d.\n", __FILE__, __func__,
@@ -6913,6 +7230,9 @@ int dpa_classif_free_hm(int hmd)
 
 	remove_hm_op(hmd);
 
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_free_hm);
-- 
1.7.5.4

