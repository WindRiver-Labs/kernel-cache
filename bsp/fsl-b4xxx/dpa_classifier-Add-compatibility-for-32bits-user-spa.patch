From effaa2bb0183b1be9eb86c7434bb292dd707bbf0 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 12 Jun 2012 21:14:49 +0000
Subject: [PATCH 209/518] dpa_classifier: Add compatibility for 32bits user
 space apps + 64bits kernel mode

Rendered ioctl command management compatible to 32 bits user
space applications when kernel is compiled for 64 bit
architectures.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
(cherry picked from commit 578a27750510e9cc0342fb597e0d8d8467da3eeb)
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |  171 +++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   | 1089 ++++++++++++++++----
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.h   |   12 +
 include/linux/fsl_dpa_classifier.h                 |    2 +-
 4 files changed, 1073 insertions(+), 201 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 769aa61..84243f2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -40,7 +40,7 @@
 
 /* Other includes */
 #include "linux/ioctl.h"
-
+#include <linux/compat.h>
 
 struct ioc_dpa_cls_tbl_params {
 	struct dpa_cls_tbl_params table_params;
@@ -108,26 +108,176 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 	int reset;
 };
 
+
+#ifdef CONFIG_COMPAT
+
+struct dpa_cls_compat_tbl_params {
+	compat_uptr_t			fm_pcd;
+	compat_uptr_t			cc_node;
+	enum dpa_cls_tbl_type		type;
+	enum dpa_cls_tbl_entry_mgmt	entry_mgmt;
+	union {
+		struct dpa_cls_tbl_hash_params		hash_params;
+		struct dpa_cls_tbl_indexed_params	indexed_params;
+		struct dpa_cls_tbl_exact_match_params	exact_match_params;
+	};
+};
+
+struct compat_ioc_dpa_cls_tbl_params {
+	struct dpa_cls_compat_tbl_params table_params;
+	int td;
+};
+
+struct dpa_cls_compat_tbl_enq_action_desc {
+	int		override_fqid;
+	uint32_t	new_fqid;
+	compat_uptr_t	policer_params;
+	compat_uptr_t	hm;
+};
+
+struct dpa_cls_compat_tbl_action {
+	enum dpa_cls_tbl_action_type	type;
+	int				enable_statistics;
+	union {
+		struct dpa_cls_compat_tbl_enq_action_desc enq_params;
+		struct dpa_cls_tbl_next_table_desc	  next_table_params;
+	};
+};
+
+struct compat_ioc_dpa_cls_tbl_miss_action {
+	int td;
+	struct dpa_cls_compat_tbl_action miss_action;
+};
+
+struct compat_ioc_dpa_cls_tbl_entry_params {
+	int td;
+	struct dpa_cls_tbl_key key;
+	struct dpa_cls_compat_tbl_action action;
+	int priority;
+	int entry_id;
+};
+
+struct dpa_cls_compat_tbl_entry_mod_params {
+	enum dpa_cls_tbl_modify_type	type;
+	compat_uptr_t			key;
+	compat_uptr_t			action;
+};
+
+struct compat_ioc_dpa_cls_tbl_entry_mod_by_key {
+	int td;
+	struct dpa_cls_tbl_key key;
+	struct dpa_cls_compat_tbl_entry_mod_params mod_params;
+};
+
+struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref {
+	int td;
+	int entry_id;
+	struct dpa_cls_compat_tbl_entry_mod_params mod_params;
+};
+
+struct compat_ioc_dpa_cls_tbl_lookup_by_key {
+	int td;
+	struct dpa_cls_tbl_key key;
+	struct dpa_cls_compat_tbl_action action;
+};
+
+struct compat_ioc_dpa_cls_tbl_lookup_by_ref {
+	int td;
+	int entry_id;
+	struct dpa_cls_compat_tbl_action action;
+};
+
+
+void dpa_cls_tbl_entry_params_compatcpy(
+		struct ioc_dpa_cls_tbl_entry_params *kparam,
+		const struct compat_ioc_dpa_cls_tbl_entry_params *uparam);
+
+void dpa_cls_tbl_params_compatcpy(
+		struct ioc_dpa_cls_tbl_params *kparam,
+		const struct compat_ioc_dpa_cls_tbl_params *uparam);
+
+void dpa_cls_tbl_miss_action_params_compatcpy(
+		struct ioc_dpa_cls_tbl_miss_action *kparam,
+		const struct compat_ioc_dpa_cls_tbl_miss_action *uparam);
+
+void dpa_cls_tbl_action_params_compatcpy(
+		struct dpa_cls_tbl_action *kparam,
+		const struct dpa_cls_compat_tbl_action *uparam);
+
+void dpa_cls_tbl_action_params_rcompatcpy(
+		struct dpa_cls_compat_tbl_action *uparam,
+		const struct dpa_cls_tbl_action *kparam);
+
+void dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
+		struct ioc_dpa_cls_tbl_entry_mod_by_key *kparam,
+		const struct compat_ioc_dpa_cls_tbl_entry_mod_by_key *uparam);
+
+void dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
+		struct ioc_dpa_cls_tbl_entry_mod_by_ref *kparam,
+		const struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref *uparam);
+
+void dpa_cls_tbl_entry_mod_params_compatcpy(
+		struct dpa_cls_tbl_entry_mod_params *kparam,
+		const struct dpa_cls_compat_tbl_entry_mod_params *uparam);
+
+void dpa_cls_tbl_lookup_by_key_params_compatcpy(
+		struct ioc_dpa_cls_tbl_lookup_by_key *kparam,
+		const struct compat_ioc_dpa_cls_tbl_lookup_by_key *uparam);
+
+void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
+		struct ioc_dpa_cls_tbl_lookup_by_ref *kparam,
+		const struct compat_ioc_dpa_cls_tbl_lookup_by_ref *uparam);
+
+#endif /* CONFIG_COMPAT */
+
+
 #define DPA_CLS_IOC_MAGIC				0xbe
 
 #define DPA_CLS_IOC_TBL_CREATE				\
 	_IOWR(DPA_CLS_IOC_MAGIC, 0, struct ioc_dpa_cls_tbl_params)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_CREATE			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 0, struct compat_ioc_dpa_cls_tbl_params)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_FREE				\
-	_IOW(DPA_CLS_IOC_MAGIC, 1, uint8_t *)
+	_IOW(DPA_CLS_IOC_MAGIC, 1, int)
 
 #define DPA_CLS_IOC_TBL_MODIFY_MISS_ACTION		\
 	_IOW(DPA_CLS_IOC_MAGIC, 2, struct ioc_dpa_cls_tbl_miss_action)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_MODIFY_MISS_ACTION	\
+	_IOW(DPA_CLS_IOC_MAGIC, 2, struct compat_ioc_dpa_cls_tbl_miss_action)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_INSERT_ENTRY			\
 	_IOWR(DPA_CLS_IOC_MAGIC, 3, struct ioc_dpa_cls_tbl_entry_params)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_INSERT_ENTRY		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 3, struct compat_ioc_dpa_cls_tbl_entry_params)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_KEY		\
 	_IOW(DPA_CLS_IOC_MAGIC, 4, struct ioc_dpa_cls_tbl_entry_mod_by_key)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_MODIFY_ENTRY_BY_KEY	\
+	_IOW(DPA_CLS_IOC_MAGIC, 4,			\
+		struct compat_ioc_dpa_cls_tbl_entry_mod_by_key)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_REF		\
 	_IOW(DPA_CLS_IOC_MAGIC, 5, struct ioc_dpa_cls_tbl_entry_mod_by_ref)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_MODIFY_ENTRY_BY_REF	\
+	_IOW(DPA_CLS_IOC_MAGIC, 5,			\
+		struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY		\
 	_IOW(DPA_CLS_IOC_MAGIC, 6, struct ioc_dpa_cls_tbl_entry_by_key)
 
@@ -137,11 +287,21 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 #define DPA_CLS_IOC_TBL_LOOKUP_BY_KEY			\
 	_IOR(DPA_CLS_IOC_MAGIC, 8, struct ioc_dpa_cls_tbl_lookup_by_key)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_LOOKUP_BY_KEY		\
+	_IOR(DPA_CLS_IOC_MAGIC, 8, struct compat_ioc_dpa_cls_tbl_lookup_by_key)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_LOOKUP_BY_REF			\
 	_IOR(DPA_CLS_IOC_MAGIC, 9, struct ioc_dpa_cls_tbl_lookup_by_ref)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_LOOKUP_BY_REF		\
+	_IOR(DPA_CLS_IOC_MAGIC, 9, struct compat_ioc_dpa_cls_tbl_lookup_by_ref)
+#endif /* CONFIG_COMPAT */
+
 #define DPA_CLS_IOC_TBL_FLUSH				\
-	_IOW(DPA_CLS_IOC_MAGIC, 10, uint8_t *)
+	_IOW(DPA_CLS_IOC_MAGIC, 10, int)
 
 #define DPA_CLS_IOC_TBL_GET_STATS_BY_KEY		\
 	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_stats_by_key)
@@ -158,5 +318,10 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 #define DPA_CLS_IOC_TBL_GET_PARAMS			\
 	_IOWR(DPA_CLS_IOC_MAGIC, 13, struct ioc_dpa_cls_tbl_params)
 
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_TBL_GET_PARAMS			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 13, struct dpa_cls_compat_tbl_params)
+#endif /* CONFIG_COMPAT */
+
 
 #endif /* __DPA_CLASSIFIER_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index fd0209f..541bafa 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -44,13 +44,50 @@
 #include <linux/uaccess.h>
 #include <linux/fdtable.h>
 #include "lnxwrp_fm.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+#ifdef CONFIG_COMPAT
+#include "lnxwrp_ioctls_fm_compat.h"
+#endif /* CONFIG_COMPAT */
+
+
+static long do_ioctl_table_create(unsigned long args, bool compat_mode);
+
+static long do_ioctl_table_modify_miss_action(unsigned long	args,
+				bool			compat_mode);
+
+static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode);
+
+static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
+				bool			compat_mode);
+
+static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
+				bool			compat_mode);
+
+static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode);
+
+static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode);
+
+
+#ifdef CONFIG_COMPAT
+
+extern const unsigned char map_node_name[][ID_MAP_NAME_SIZE];
+
+#define FM_NODE			map_node_name[0]
+#define PORT_NODE		map_node_name[1]
+#define PCD_NODE		map_node_name[2]
+
+#endif /* CONFIG_COMPAT */
 
 static const struct file_operations dpa_classif_fops = {
 	.owner			= THIS_MODULE,
 	.open			= wrp_dpa_classif_open,
 	.read			= wrp_dpa_classif_read,
 	.write			= wrp_dpa_classif_write,
-	.unlocked_ioctl	= wrp_dpa_classif_ioctl,
+	.unlocked_ioctl		= wrp_dpa_classif_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl		= wrp_dpa_classif_compat_ioctl,
+#endif /* CONFIG_COMPAT */
 	.release		= wrp_dpa_classif_release
 };
 
@@ -121,154 +158,84 @@ ssize_t wrp_dpa_classif_write(
 }
 
 
+#ifdef CONFIG_COMPAT
+long wrp_dpa_classif_compat_ioctl(
+		struct file	*filp,
+		unsigned int	cmd,
+		unsigned long	args)
+{
+	return wrp_dpa_classif_do_ioctl(filp, cmd, args, true);
+}
+#endif /* CONFIG_COMPAT */
+
+
 long wrp_dpa_classif_ioctl(
+		struct file	*filp,
+		unsigned int	cmd,
+		unsigned long	args)
+{
+	return wrp_dpa_classif_do_ioctl(filp, cmd, args, false);
+}
+
+
+long wrp_dpa_classif_do_ioctl(
 			struct file	*filp,
 			unsigned int	cmd,
-			unsigned long	args)
+			unsigned long	args,
+			bool		compat_mode)
 {
-	long	ret = 0;
+	long ret = 0;
 
 
 	switch (cmd) {
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_CREATE:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_CREATE:
-	{
-		struct ioc_dpa_cls_tbl_params param;
-		struct file *fm_pcd_file;
-		t_LnxWrpFmDev *fm_wrapper_dev;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-				   (struct ioc_dpa_cls_tbl_params *) args,
-				   sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_create user space args");
-			return -EBUSY;
-		}
-
-		/* Translate FM_PCD file descriptor */
-		fm_pcd_file = fcheck((unsigned int)param.table_params.fm_pcd);
-		if (!fm_pcd_file) {
-			xx_pr_err("Could not acquire PCD handle");
-			return -EINVAL;
-		}
-		fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-		param.table_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
-
-		/* Call function */
-		ret = dpa_classif_table_create(&param.table_params, &param.td);
-		if (ret < 0)
-			return ret;
-
-		/* Return results to user space */
-		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_create result");
-			return -EBUSY;
-		}
-
+		ret = do_ioctl_table_create(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_FREE:
 		ret = dpa_classif_table_free((int)args);
 		break;
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_MODIFY_MISS_ACTION:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_MODIFY_MISS_ACTION:
-	{
-		struct ioc_dpa_cls_tbl_miss_action param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-				   (struct ioc_dpa_cls_tbl_miss_action *) args,
-				    sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_modify_miss_action user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_modify_miss_action(param.td,
-							   &param.miss_action);
-
+		ret = do_ioctl_table_modify_miss_action(args, compat_mode);
 		break;
-	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_INSERT_ENTRY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_INSERT_ENTRY:
-	{
-		struct ioc_dpa_cls_tbl_entry_params param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-				   (struct ioc_dpa_cls_tbl_entry_params *) args,
-				    sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_insert_entry user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_insert_entry(param.td,
-						     &param.key,
-						     &param.action,
-						     param.priority,
-						     &param.entry_id);
-		if (ret < 0)
-			return ret;
-
-		/* Return results to user space */
-		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_insert_entry result");
-			return -EBUSY;
-		}
-
+		ret = do_ioctl_table_insert_entry(args, compat_mode);
 		break;
-	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_MODIFY_ENTRY_BY_KEY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_KEY:
-	{
-		struct ioc_dpa_cls_tbl_entry_mod_by_key param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-			      (struct ioc_dpa_cls_tbl_entry_mod_by_key *) args,
-			       sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_key user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_modify_entry_by_key(param.td,
-							    &param.key,
-							    &param.mod_params);
-
+		ret = do_ioctl_table_modify_entry_by_key(args, compat_mode);
 		break;
-	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_MODIFY_ENTRY_BY_REF:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_REF:
-	{
-		struct ioc_dpa_cls_tbl_entry_mod_by_ref param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_mod_by_ref *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_ref user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_modify_entry_by_ref(param.td,
-							    param.entry_id,
-							    &param.mod_params);
-
+		ret = do_ioctl_table_modify_entry_by_ref(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY:
 	{
 		struct ioc_dpa_cls_tbl_entry_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_by_key *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_key user space args (#1)");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_delete_entry_by_key user "
+				"space args (#1)");
 			return -EBUSY;
 		}
 
@@ -284,10 +251,10 @@ long wrp_dpa_classif_ioctl(
 		struct ioc_dpa_cls_tbl_entry_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_by_ref *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_ref user space args (#1)");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_delete_entry_by_ref user "
+				"space args (#1)");
 			return -EBUSY;
 		}
 
@@ -298,61 +265,19 @@ long wrp_dpa_classif_ioctl(
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_LOOKUP_BY_KEY:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_LOOKUP_BY_KEY:
-	{
-		struct ioc_dpa_cls_tbl_lookup_by_key param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-				(struct ioc_dpa_cls_tbl_lookup_by_key *) args,
-				sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_lookup_by_key(param.td,
-						      &param.key,
-						      &param.action);
-		if (ret < 0)
-			return ret;
-
-		/* Return results to user space */
-		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_lookup_by_key result");
-			return -EBUSY;
-		}
-
+		ret = do_ioctl_table_lookup_by_key(args, compat_mode);
 		break;
-	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_LOOKUP_BY_REF:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_LOOKUP_BY_REF:
-	{
-		struct ioc_dpa_cls_tbl_lookup_by_ref param;
-
-		/* Prepare arguments */
-		if (copy_from_user(&param,
-				(struct ioc_dpa_cls_tbl_lookup_by_ref *) args,
-				sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_lookup_by_ref user space args (#1)");
-			return -EBUSY;
-		}
-
-		/* Call function */
-		ret = dpa_classif_table_lookup_by_ref(param.td,
-						      param.entry_id,
-						      &param.action);
-		if (ret < 0)
-			return ret;
-
-		/* Return results to user space */
-		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_lookup_by_ref result");
-			return -EBUSY;
-		}
-
+		ret = do_ioctl_table_lookup_by_ref(args, compat_mode);
 		break;
-	}
 
 	case DPA_CLS_IOC_TBL_FLUSH:
 		ret = dpa_classif_table_flush((int)args);
@@ -363,10 +288,10 @@ long wrp_dpa_classif_ioctl(
 		struct ioc_dpa_cls_tbl_entry_stats_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_stats_by_key *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#1)");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_get_entry_stats_by_key user "
+				"space args (#1)");
 			return -EBUSY;
 		}
 
@@ -380,7 +305,9 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_key result");
+			xx_pr_err("Could not write "
+				"dpa_classif_table_get_entry_stats_by_key "
+				"result");
 			return -EBUSY;
 		}
 
@@ -392,10 +319,10 @@ long wrp_dpa_classif_ioctl(
 		struct ioc_dpa_cls_tbl_entry_stats_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_stats_by_ref *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#1)");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_get_entry_stats_by_ref user "
+				"space args (#1)");
 			return -EBUSY;
 		}
 
@@ -409,7 +336,9 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_ref result");
+			xx_pr_err("Could not write "
+				"dpa_classif_table_get_entry_stats_by_ref "
+				"result");
 			return -EBUSY;
 		}
 
@@ -421,10 +350,10 @@ long wrp_dpa_classif_ioctl(
 		struct ioc_dpa_cls_tbl_entry_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_by_key *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_reset_entry_stats_by_key user space args");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_reset_entry_stats_by_key "
+				"user space args");
 			return -EBUSY;
 		}
 
@@ -440,10 +369,10 @@ long wrp_dpa_classif_ioctl(
 		struct ioc_dpa_cls_tbl_entry_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-			(struct ioc_dpa_cls_tbl_entry_by_ref *) args,
-			sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_reset_entry_stats_by_ref user space args");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_reset_entry_stats_by_ref "
+				"user space args");
 			return -EBUSY;
 		}
 
@@ -453,16 +382,18 @@ long wrp_dpa_classif_ioctl(
 
 		break;
 	}
-
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_TBL_GET_PARAMS:
+#endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_TBL_GET_PARAMS:
 	{
 		struct ioc_dpa_cls_tbl_params param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&param,
-				   (struct ioc_dpa_cls_tbl_params *) args,
-				   sizeof(param))) {
-			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
+		if (copy_from_user(&param, (void *) args, sizeof(param))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_lookup_by_key user space "
+				"args (#1)");
 			return -EBUSY;
 		}
 
@@ -474,7 +405,8 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write dpa_classif_table_get_params result");
+			xx_pr_err("Could not write "
+				"dpa_classif_table_get_params result");
 			return -EBUSY;
 		}
 
@@ -482,10 +414,773 @@ long wrp_dpa_classif_ioctl(
 	}
 
 	default:
-		xx_pr_err("DPA Classifier ioctl command (%u) not suppoted",
+		xx_pr_err("DPA Classifier ioctl command (0x%x) not suppoted",
 			cmd);
 		return -EINVAL;
 	}
 
 	return ret;
 }
+
+static long do_ioctl_table_create(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_tbl_params kparam;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_params uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read dpa_classif_table_create "
+				"user space args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_params_compatcpy(&kparam, &uparam);
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			xx_pr_err("Could not read dpa_classif_table_create "
+				"user space args");
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)kparam.table_params.fm_pcd);
+	if (!fm_pcd_file) {
+		xx_pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	kparam.table_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+	/* Call function */
+	ret = dpa_classif_table_create(&kparam.table_params,
+					&kparam.td);
+	if (ret < 0)
+		return ret;
+
+	/* Return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.td = kparam.td;
+		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
+			xx_pr_err("Could not write dpa_classif_table_create "
+				"result");
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			xx_pr_err("Could not write dpa_classif_table_create "
+				"result");
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_table_modify_miss_action(unsigned long	args,
+					bool			compat_mode)
+{
+	struct ioc_dpa_cls_tbl_miss_action kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_miss_action uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_miss_action user "
+				"space args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_miss_action_params_compatcpy(&kparam,
+			&uparam);
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_miss_action user "
+				"space args");
+			return -EBUSY;
+		}
+
+	/* Call function */
+	return dpa_classif_table_modify_miss_action(kparam.td,
+						&kparam.miss_action);
+}
+
+
+static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_tbl_entry_params kparam;
+	struct dpa_cls_tbl_policer_params policer_params;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_entry_params uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_insert_entry user space "
+				"args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_entry_params_compatcpy(&kparam, &uparam);
+
+		/* Check if we need to copy also the policer params */
+		if ((uparam.action.type == DPA_CLS_TBL_ACTION_ENQ) &&
+			(uparam.action.enq_params.policer_params != 0)) {
+			if (copy_from_user(&policer_params,
+			compat_ptr(uparam.action.enq_params.policer_params),
+				sizeof(policer_params))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_insert_entry user "
+					"space args (#2)");
+				return -EBUSY;
+			}
+		kparam.action.enq_params.policer_params = &policer_params;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&kparam, (void *) args,
+				    sizeof(kparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_insert_entry user space "
+				"args (#1)");
+			return -EBUSY;
+		}
+
+		/* Check if we need to copy also the policer params */
+		if ((kparam.action.type == DPA_CLS_TBL_ACTION_ENQ) &&
+		(kparam.action.enq_params.policer_params != NULL)) {
+			if (copy_from_user(&policer_params,
+				kparam.action.enq_params.policer_params,
+				sizeof(policer_params))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_insert_entry user "
+					"space args (#2)");
+				return -EBUSY;
+			}
+		kparam.action.enq_params.policer_params = &policer_params;
+		}
+	}
+
+	/* Call function */
+	ret = dpa_classif_table_insert_entry(kparam.td,
+					&kparam.key,
+					&kparam.action,
+					kparam.priority,
+					&kparam.entry_id);
+	if (ret < 0)
+		return ret;
+
+	/* In case of success return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.entry_id = kparam.entry_id;
+
+		if (copy_to_user(compat_ptr(args), &uparam,
+				sizeof(uparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_insert_entry result");
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam,
+				sizeof(kparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_insert_entry result");
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
+					bool			compat_mode)
+{
+	struct ioc_dpa_cls_tbl_entry_mod_by_key kparam;
+	struct dpa_cls_tbl_key key;
+	struct dpa_cls_tbl_action action;
+	struct dpa_cls_tbl_policer_params policer_params;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_entry_mod_by_key uparam;
+	struct dpa_cls_compat_tbl_action compat_action;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args),
+				sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_key user "
+				"space args (#1)");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_entry_mod_by_key_params_compatcpy(&kparam,
+			&uparam);
+
+		/* Check if we need to copy the new key and action */
+		if (uparam.mod_params.key) {
+			if (copy_from_user(&key,
+				compat_ptr(uparam.mod_params.key),
+				sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_key "
+					"user space args (#2)");
+				return -EBUSY;
+			}
+			kparam.mod_params.key = &key;
+		}
+
+		if (uparam.mod_params.action) {
+			if (copy_from_user(&compat_action,
+				compat_ptr(uparam.mod_params.action),
+				sizeof(struct dpa_cls_compat_tbl_action))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_key "
+					"user space args (#3)");
+				return -EBUSY;
+			}
+
+			dpa_cls_tbl_action_params_compatcpy(&action,
+				&compat_action);
+
+			kparam.mod_params.action = &action;
+
+			/* Check if we need to copy policer params */
+			if ((compat_action.type ==
+				DPA_CLS_TBL_ACTION_ENQ) &&
+				(compat_action.enq_params.
+					policer_params)) {
+				if (copy_from_user(&policer_params,
+					compat_ptr(compat_action.
+					enq_params.policer_params),
+					sizeof(policer_params))) {
+					xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_key user "
+				"space args (#4)");
+					return -EBUSY;
+				}
+				kparam.mod_params.action->enq_params.
+					policer_params =
+					&policer_params;
+			}
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&kparam, (void *) args,
+				sizeof(kparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_key user "
+				"space args (#1)");
+			return -EBUSY;
+		}
+
+		/* Check if we need to copy the new key and action */
+		if (kparam.mod_params.key) {
+			if (copy_from_user(&key,
+				kparam.mod_params.key,
+				sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_key "
+					"user space args (#2)");
+				return -EBUSY;
+			}
+			kparam.mod_params.key = &key;
+		}
+
+		if (kparam.mod_params.action) {
+			if (copy_from_user(&action,
+				kparam.mod_params.action,
+				sizeof(struct dpa_cls_tbl_action))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_key "
+					"user space args (#3)");
+				return -EBUSY;
+			}
+			kparam.mod_params.action = &action;
+
+			/* Check if we need to copy policer params */
+			if ((kparam.mod_params.action->type ==
+				DPA_CLS_TBL_ACTION_ENQ) &&
+				(kparam.mod_params.action->enq_params.
+					policer_params)) {
+				if (copy_from_user(&policer_params,
+					kparam.mod_params.
+					action->enq_params.
+					policer_params,
+					sizeof(policer_params))) {
+					xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_key user "
+				"space args (#4)");
+					return -EBUSY;
+				}
+				kparam.mod_params.action->enq_params.
+					policer_params =
+					&policer_params;
+			}
+		}
+	}
+
+	/* Call function */
+	return dpa_classif_table_modify_entry_by_key(kparam.td,
+						&kparam.key,
+						&kparam.mod_params);
+
+}
+
+static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
+					bool			compat_mode)
+{
+	struct ioc_dpa_cls_tbl_entry_mod_by_ref kparam;
+	struct dpa_cls_tbl_key key;
+	struct dpa_cls_tbl_action action;
+	struct dpa_cls_tbl_policer_params policer_params;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref uparam;
+	struct dpa_cls_compat_tbl_action compat_action;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_ref user "
+				"space args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(&kparam,
+			&uparam);
+
+		/* Check if we need to copy the new key and action */
+		if (uparam.mod_params.key) {
+			if (copy_from_user(&key,
+				compat_ptr(uparam.mod_params.key),
+				sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_ref "
+					"user space args (#2)");
+				return -EBUSY;
+			}
+			kparam.mod_params.key = &key;
+		}
+
+		if (uparam.mod_params.action) {
+			if (copy_from_user(&compat_action,
+				compat_ptr(uparam.mod_params.action),
+				sizeof(struct dpa_cls_compat_tbl_action))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_ref "
+					"user space args (#3)");
+				return -EBUSY;
+			}
+
+			dpa_cls_tbl_action_params_compatcpy(&action,
+				&compat_action);
+
+			kparam.mod_params.action = &action;
+
+			/* Check if we need to copy policer params */
+			if ((compat_action.type ==
+				DPA_CLS_TBL_ACTION_ENQ) &&
+				(compat_action.enq_params.
+					policer_params)) {
+				if (copy_from_user(&policer_params,
+					compat_ptr(compat_action.
+					enq_params.policer_params),
+					sizeof(policer_params))) {
+					xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_ref user "
+				"space args (#4)");
+					return -EBUSY;
+				}
+				kparam.mod_params.action->enq_params.
+					policer_params =
+					&policer_params;
+			}
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_ref user "
+				"space args (#1)");
+			return -EBUSY;
+		}
+
+		/* Check if we need to copy the new key and action */
+		if (kparam.mod_params.key) {
+			if (copy_from_user(&key,
+				kparam.mod_params.key,
+				sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_ref "
+					"user space args (#2)");
+				return -EBUSY;
+			}
+			kparam.mod_params.key = &key;
+		}
+
+		if (kparam.mod_params.action) {
+			if (copy_from_user(&action,
+				kparam.mod_params.action,
+				sizeof(struct dpa_cls_tbl_action))) {
+				xx_pr_err("Could not read "
+					"dpa_classif_table_modify_entry_by_ref "
+					"user space args (#3)");
+				return -EBUSY;
+			}
+			kparam.mod_params.action = &action;
+
+			/* Check if we need to copy policer params */
+			if ((kparam.mod_params.action->type ==
+				DPA_CLS_TBL_ACTION_ENQ) &&
+				(kparam.mod_params.action->enq_params.
+					policer_params)) {
+				if (copy_from_user(&policer_params,
+					kparam.mod_params.
+					action->enq_params.
+					policer_params,
+					sizeof(policer_params))) {
+					xx_pr_err("Could not read "
+				"dpa_classif_table_modify_entry_by_ref user "
+				"space args (#4)");
+					return -EBUSY;
+				}
+				kparam.mod_params.action->enq_params.
+					policer_params =
+					&policer_params;
+			}
+		}
+	}
+
+	/* Call function */
+	return dpa_classif_table_modify_entry_by_ref(kparam.td,
+						kparam.entry_id,
+						&kparam.mod_params);
+}
+
+static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_tbl_lookup_by_key kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_lookup_by_key uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_lookup_by_key user space "
+				"args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_lookup_by_key_params_compatcpy(&kparam,
+			&uparam);
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_lookup_by_key user space "
+				"args (#1)");
+			return -EBUSY;
+		}
+
+	/* Call function */
+	ret = dpa_classif_table_lookup_by_key(kparam.td,
+					      &kparam.key,
+					      &kparam.action);
+	if (ret < 0)
+		return ret;
+
+	if (kparam.action.type == DPA_CLS_TBL_ACTION_ENQ)
+		/*
+		 * Reset policer params pointer as it has no meaning in user
+		 * space
+		 */
+		kparam.action.enq_params.policer_params = NULL;
+
+	/* Return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
+			&kparam.action);
+
+		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_lookup_by_key result");
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_lookup_by_key result");
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_tbl_lookup_by_ref kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_tbl_lookup_by_ref uparam;
+
+	/* Prepare arguments */
+	if (compat_mode) {
+		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
+			xx_pr_err("Could not read "
+				"dpa_classif_table_lookup_by_ref user space args");
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		dpa_cls_tbl_lookup_by_ref_params_compatcpy(&kparam,
+			&uparam);
+	} else
+#endif /* CONFIG_COMPAT */
+
+	/* Prepare arguments */
+	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+		xx_pr_err("Could not read dpa_classif_table_lookup_by_ref user "
+			"space args (#1)");
+		return -EBUSY;
+	}
+
+	/* Call function */
+	ret = dpa_classif_table_lookup_by_ref(kparam.td,
+					      kparam.entry_id,
+					      &kparam.action);
+	if (ret < 0)
+		return ret;
+
+	if (kparam.action.type == DPA_CLS_TBL_ACTION_ENQ)
+		/*
+		 * Reset policer params pointer as it has no meaning in user
+		 * space
+		 */
+		kparam.action.enq_params.policer_params = NULL;
+
+	/* Return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
+			&kparam.action);
+
+		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_lookup_by_ref result");
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			xx_pr_err("Could not write "
+				"dpa_classif_table_lookup_by_ref result");
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+
+void dpa_cls_tbl_entry_params_compatcpy(
+		struct ioc_dpa_cls_tbl_entry_params			*kparam,
+		const struct compat_ioc_dpa_cls_tbl_entry_params	*uparam)
+{
+	kparam->td		= uparam->td;
+	kparam->priority	= uparam->priority;
+	kparam->entry_id	= uparam->entry_id;
+
+	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+
+	dpa_cls_tbl_action_params_compatcpy(&kparam->action, &uparam->action);
+}
+
+void dpa_cls_tbl_action_params_compatcpy(
+		struct dpa_cls_tbl_action			*kparam,
+		const struct dpa_cls_compat_tbl_action		*uparam)
+{
+	kparam->type			= uparam->type;
+	kparam->enable_statistics	= uparam->enable_statistics;
+
+	switch (uparam->type) {
+	case DPA_CLS_TBL_ACTION_ENQ:
+		kparam->enq_params.override_fqid =
+				uparam->enq_params.override_fqid;
+		kparam->enq_params.new_fqid =
+				uparam->enq_params.new_fqid;
+
+		if (uparam->enq_params.hm != 0) {
+			kparam->enq_params.hm = compat_get_id2ptr(
+				uparam->enq_params.hm, PCD_NODE);
+		} else
+			kparam->enq_params.hm = NULL;
+
+		/* Policer params are a separate data structure which is
+		 * managed by the caller */
+		kparam->enq_params.policer_params = NULL;
+
+		break;
+	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
+		kparam->next_table_params.next_td =
+				uparam->next_table_params.next_td;
+		break;
+	default:
+		break;
+	}
+}
+
+void dpa_cls_tbl_action_params_rcompatcpy(
+		struct dpa_cls_compat_tbl_action	*uparam,
+		const struct dpa_cls_tbl_action		*kparam)
+{
+	uparam->type			= kparam->type;
+	uparam->enable_statistics	= kparam->enable_statistics;
+
+	switch (kparam->type) {
+	case DPA_CLS_TBL_ACTION_ENQ:
+		uparam->enq_params.override_fqid =
+				kparam->enq_params.override_fqid;
+		uparam->enq_params.new_fqid =
+				kparam->enq_params.new_fqid;
+
+		if (kparam->enq_params.hm != NULL) {
+			uparam->enq_params.hm = compat_get_ptr2id(
+				kparam->enq_params.hm, PCD_NODE);
+		} else
+			uparam->enq_params.hm = 0;
+
+		/* Policer params are a separate data structure which is
+		 * managed by the caller */
+		uparam->enq_params.policer_params = 0;
+
+		break;
+	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
+		uparam->next_table_params.next_td =
+				kparam->next_table_params.next_td;
+		break;
+	default:
+		break;
+	}
+}
+
+void dpa_cls_tbl_params_compatcpy(
+		struct ioc_dpa_cls_tbl_params			*kparam,
+		const struct compat_ioc_dpa_cls_tbl_params	*uparam)
+{
+	kparam->table_params.fm_pcd = compat_ptr(uparam->table_params.fm_pcd);
+	kparam->table_params.cc_node = compat_get_id2ptr(
+					uparam->table_params.cc_node,
+					PCD_NODE);
+
+	kparam->table_params.type	= uparam->table_params.type;
+	kparam->table_params.entry_mgmt	= uparam->table_params.entry_mgmt;
+
+	switch (uparam->table_params.type) {
+	case DPA_CLS_TBL_INDEXED:
+		memcpy(&kparam->table_params.indexed_params,
+				&uparam->table_params.indexed_params,
+				sizeof(struct dpa_cls_tbl_indexed_params));
+		break;
+	case DPA_CLS_TBL_HASH:
+		memcpy(&kparam->table_params.hash_params,
+				&uparam->table_params.hash_params,
+				sizeof(struct dpa_cls_tbl_hash_params));
+
+		break;
+	case DPA_CLS_TBL_EXACT_MATCH:
+		memcpy(&kparam->table_params.exact_match_params,
+				&uparam->table_params.exact_match_params,
+				sizeof(struct dpa_cls_tbl_exact_match_params));
+
+		break;
+	}
+}
+
+void dpa_cls_tbl_miss_action_params_compatcpy(
+		struct ioc_dpa_cls_tbl_miss_action		*kparam,
+		const struct compat_ioc_dpa_cls_tbl_miss_action	*uparam)
+{
+	kparam->td = uparam->td;
+
+	dpa_cls_tbl_action_params_compatcpy(&kparam->miss_action,
+			&uparam->miss_action);
+}
+
+void dpa_cls_tbl_entry_mod_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_mod_by_key			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_mod_by_key	*uparam)
+{
+	kparam->td = uparam->td;
+
+	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+
+	dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
+		&uparam->mod_params);
+}
+
+void dpa_cls_tbl_entry_mod_params_compatcpy(
+	struct dpa_cls_tbl_entry_mod_params			*kparam,
+	const struct dpa_cls_compat_tbl_entry_mod_params	*uparam)
+{
+	kparam->type = uparam->type;
+
+	/* Key params and action params are separate data structures which are
+	 * managed by the caller */
+	kparam->key	= NULL;
+	kparam->action	= NULL;
+}
+
+void dpa_cls_tbl_entry_mod_by_ref_params_compatcpy(
+	struct ioc_dpa_cls_tbl_entry_mod_by_ref			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_entry_mod_by_ref	*uparam)
+{
+	kparam->td		= uparam->td;
+	kparam->entry_id	= uparam->entry_id;
+
+	dpa_cls_tbl_entry_mod_params_compatcpy(&kparam->mod_params,
+		&uparam->mod_params);
+}
+
+void dpa_cls_tbl_lookup_by_key_params_compatcpy(
+	struct ioc_dpa_cls_tbl_lookup_by_key			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_lookup_by_key	*uparam)
+{
+	kparam->td = uparam->td;
+	memcpy(&kparam->key, &uparam->key, sizeof(struct dpa_cls_tbl_key));
+}
+
+void dpa_cls_tbl_lookup_by_ref_params_compatcpy(
+	struct ioc_dpa_cls_tbl_lookup_by_ref			*kparam,
+	const struct compat_ioc_dpa_cls_tbl_lookup_by_ref	*uparam)
+{
+	kparam->td		= uparam->td;
+	kparam->entry_id	= uparam->entry_id;
+}
+
+#endif /* CONFIG_COMPAT */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
index 4bcdc7f..411a332 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
@@ -70,5 +70,17 @@ long	wrp_dpa_classif_ioctl(
 			unsigned int	cmd,
 			unsigned long	args);
 
+long	wrp_dpa_classif_do_ioctl(
+			struct file	*filp,
+			unsigned int	cmd,
+			unsigned long	args,
+			bool		compat_mode);
+
+#ifdef CONFIG_COMPAT
+long	wrp_dpa_classif_compat_ioctl(
+			struct file	*filp,
+			unsigned int	cmd,
+			unsigned long	args);
+#endif
 
 #endif /* __WRP_DPA_CLASSIFIER_H */
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 2192674..cc02413 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -283,7 +283,7 @@ struct dpa_cls_tbl_entry_mod_params {
 /* DPA Classifier table entry statistics */
 struct dpa_cls_tbl_entry_stats {
 
-	unsigned long int	total_pkts;	/* The total number of
+	uint64_t		total_pkts;	/* The total number of
 						* packets that have hit the
 						* entry */
 };
-- 
1.7.5.4

