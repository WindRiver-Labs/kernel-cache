From cfa0b0dca73412b1eabcc458e65583aa6ac4b82f Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 31 Oct 2012 15:18:47 +0000
Subject: [PATCH 346/518] dpa_classifier: Get rid of xx_sanity_checks

xx_sanity checks were replaced with the actual code that they are
generating. "fsl_dpa_compat.h", "dpa_compat.h" and "dpa_compat.c"
files were no longer necessary and they were removed. The code was
updated all over where "dpa_compat.h" header file was included.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Makefile           |    9 +-
 drivers/staging/fsl_dpa_offload/cq.c               |    3 +
 drivers/staging/fsl_dpa_offload/cq.h               |    3 +-
 drivers/staging/fsl_dpa_offload/crc8.c             |    6 +-
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  560 +++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |    4 +
 drivers/staging/fsl_dpa_offload/dpa_compat.c       |  321 -----------
 drivers/staging/fsl_dpa_offload/dpa_compat.h       |  199 -------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h        |    2 -
 .../staging/fsl_dpa_offload/dpa_offload_module.c   |    1 -
 drivers/staging/fsl_dpa_offload/dpa_stats.c        |    1 -
 drivers/staging/fsl_dpa_offload/dpa_stats.h        |    1 -
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    1 -
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c    |    1 -
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c    |    2 -
 include/linux/fsl_dpa_classifier.h                 |    1 -
 include/linux/fsl_dpa_compat.h                     |   50 --
 include/linux/fsl_dpa_offload.h                    |    2 -
 include/linux/fsl_dpa_stats.h                      |    1 -
 19 files changed, 436 insertions(+), 732 deletions(-)
 delete mode 100644 drivers/staging/fsl_dpa_offload/dpa_compat.c
 delete mode 100644 drivers/staging/fsl_dpa_offload/dpa_compat.h
 delete mode 100644 include/linux/fsl_dpa_compat.h

diff --git a/drivers/staging/fsl_dpa_offload/Makefile b/drivers/staging/fsl_dpa_offload/Makefile
index 1527ccb..a9da7cc 100644
--- a/drivers/staging/fsl_dpa_offload/Makefile
+++ b/drivers/staging/fsl_dpa_offload/Makefile
@@ -41,13 +41,12 @@ EXTRA_CFLAGS += \
 	-Idrivers/crypto/caam \
 	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper \
 	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd \
-	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc \
-	-DDPA_OFFLOAD_SANITY_CHECKS
+	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc
 
 obj-$(CONFIG_FSL_IPACC_USECASES)   += usecases/
 
 obj-$(CONFIG_FSL_DPA_OFFLOAD) += dpa_offload.o
 
-dpa_offload-objs :=  crc8.o dpa_classifier.o dpa_compat.o dpa_ipsec.o \
-		     dpa_ipsec_desc.o cq.o dpa_stats.o wrp_dpa_classifier.o \
-		     wrp_dpa_ipsec.o wrp_dpa_stats.o dpa_offload_module.o
+dpa_offload-objs :=  crc8.o dpa_classifier.o dpa_ipsec.o dpa_ipsec_desc.o \
+		cq.o dpa_stats.o wrp_dpa_classifier.o wrp_dpa_ipsec.o \
+		wrp_dpa_stats.o dpa_offload_module.o
diff --git a/drivers/staging/fsl_dpa_offload/cq.c b/drivers/staging/fsl_dpa_offload/cq.c
index 6d2992c..c8615a3 100644
--- a/drivers/staging/fsl_dpa_offload/cq.c
+++ b/drivers/staging/fsl_dpa_offload/cq.c
@@ -39,6 +39,9 @@
 
 #include "cq.h"
 
+#include <linux/slab.h>
+#include <linux/delay.h>
+
 struct cq *cq_new(int max_items, int item_size)
 {
 	struct cq *cq;
diff --git a/drivers/staging/fsl_dpa_offload/cq.h b/drivers/staging/fsl_dpa_offload/cq.h
index a9484ee..c7d8e2a 100644
--- a/drivers/staging/fsl_dpa_offload/cq.h
+++ b/drivers/staging/fsl_dpa_offload/cq.h
@@ -36,7 +36,8 @@
 #ifndef __CQ_H
 #define __CQ_H
 
-#include "dpa_compat.h"
+#include <linux/types.h>
+#include <linux/mutex.h>
 
 /* Circular queue structure */
 struct cq {
diff --git a/drivers/staging/fsl_dpa_offload/crc8.c b/drivers/staging/fsl_dpa_offload/crc8.c
index fe67068..64d336f 100644
--- a/drivers/staging/fsl_dpa_offload/crc8.c
+++ b/drivers/staging/fsl_dpa_offload/crc8.c
@@ -37,9 +37,7 @@
 /* DPA offloading layer includes */
 #include "crc8.h"
 
-/* FMD includes */
-#include "dpa_compat.h"
-
+#include <linux/bug.h>
 
 static uint8_t crc8_table[256];
 static bool crc8_initialized;
@@ -75,7 +73,7 @@ uint8_t crc8(const uint8_t *buf, unsigned int len)
 	int i;
 
 
-	xx_assert(crc8_initialized);
+	BUG_ON(!crc8_initialized);
 
 
 	for (i = 0; i < len; i++)
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 119535f..0b86a0e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -39,7 +39,6 @@
 
 
 /* DPA offloading layer includes */
-#include "dpa_compat.h"
 #include "dpa_classifier.h"
 #include "crc8.h"
 #include "crc64.h"
@@ -102,8 +101,17 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	struct dpa_cls_table *ptable;
 	unsigned int i;
 
-	xx_sanity_check_return_value(params, "params", -EINVAL);
-	xx_sanity_check_return_value(td, "td", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!params) {
+		pr_err("ERROR: %s, %s (%d): \"params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!td) {
+		pr_err("ERROR: %s, %s (%d): \"td\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*td = DPA_OFFLD_DESC_NONE;
 
@@ -346,7 +354,12 @@ int dpa_classif_table_modify_miss_action(int			td,
 	t_FmPcdCcNextEngineParams miss_engine_params;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(miss_action, "miss_action", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!miss_action) {
+		pr_err("ERROR: %s, %s (%d): \"miss_action\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -384,9 +397,9 @@ int dpa_classif_table_modify_miss_action(int			td,
 			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_HashTableModifyMissNextEngine "
-				"(td=%d, Cc node handle=0x%x).\n", __FILE__,
+				"(td=%d, Cc node handle=0x%p).\n", __FILE__,
 				__func__, __LINE__, td,
-				(unsigned)ptable->params.cc_node);
+				ptable->params.cc_node);
 			return -EBUSY;
 		}
 	} else {
@@ -396,9 +409,9 @@ int dpa_classif_table_modify_miss_action(int			td,
 			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableModifyMissNextEngine (td=%d, "
-				"Cc node handle=0x%x).\n", __FILE__, __func__,
+				"Cc node handle=0x%p).\n", __FILE__, __func__,
 				__LINE__, td,
-				(unsigned)ptable->int_cc_node[0].cc_node);
+				ptable->int_cc_node[0].cc_node);
 			return -EBUSY;
 		}
 	}
@@ -417,11 +430,28 @@ int dpa_classif_table_insert_entry(int				td,
 	int err = 0;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(key, "key", -EINVAL);
-	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
-	xx_sanity_check_return_value(((key->size > 0) &&
-		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
-	xx_sanity_check_return_value(action, "action", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!key) {
+		pr_err("ERROR: %s, %s (%d): \"key\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!key->byte) {
+		pr_err("ERROR: %s, %s (%d): \"key->byte\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((key->size <= 0) || (key->size > DPA_OFFLD_MAXENTRYKEYSIZE)) {
+		pr_err("ERROR: %s, %s (%d): Key size should be between %d and "
+			"%d.\n", __FILE__, __func__, __LINE__, 1,
+			DPA_OFFLD_MAXENTRYKEYSIZE);
+		return -EINVAL;
+	}
+	if (!action) {
+		pr_err("ERROR: %s, %s (%d): \"action\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -507,11 +537,28 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 	uint8_t *new_mask;
 	t_FmPcdCcKeyParams key_params;
 
-	xx_sanity_check_return_value(key, "key", -EINVAL);
-	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
-	xx_sanity_check_return_value(((key->size > 0) &&
-		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
-	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!key) {
+		pr_err("ERROR: %s, %s (%d): \"key\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!key->byte) {
+		pr_err("ERROR: %s, %s (%d): \"key->byte\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((key->size <= 0) || (key->size > DPA_OFFLD_MAXENTRYKEYSIZE)) {
+		pr_err("ERROR: %s, %s (%d): Key size should be between %d and "
+			"%d.\n", __FILE__, __func__, __LINE__, 1,
+			DPA_OFFLD_MAXENTRYKEYSIZE);
+		return -EINVAL;
+	}
+	if (!mod_params) {
+		pr_err("ERROR: %s, %s (%d): \"mod_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -548,8 +595,14 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 			memset(&key_params, 0, sizeof(key_params));
 			switch (mod_params->type) {
 			case DPA_CLS_TBL_MODIFY_ACTION:
-				xx_sanity_check_return_value(mod_params->action,
-					"mod_params.action", -EINVAL);
+				/* Parameter sanity check: */
+				if (!mod_params->action) {
+					pr_err("ERROR: %s, %s (%d): "
+						"\"mod_params->action\" cannot "
+						"be NULL.\n", __FILE__,
+						__func__, __LINE__);
+					return -EINVAL;
+				}
 
 				ret = action_to_next_engine_params(
 						mod_params->action,
@@ -587,10 +640,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNModifyNextEngine"
-					". td=%d, Cc node handle=0x%x, entry "
+					". td=%d, Cc node handle=0x%p, entry "
 					"key (hex) (%d byte(s)):", __FILE__,
 					__func__, __LINE__, td,
-				(unsigned)ptable->int_cc_node[0].cc_node,
+					ptable->int_cc_node[0].cc_node,
 					key->size);
 				dump_lookup_key(key);
 				pr_err("\n");
@@ -607,11 +660,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_HashTableModifyNextEngine. "
-					"td=%d, Cc node handle=0x%x, entry key "
+					"td=%d, Cc node handle=0x%p, entry key "
 					"(hex) (%d byte(s)):", __FILE__,
 					__func__, __LINE__, td,
-					(unsigned)ptable->params.cc_node,
-					key->size);
+					ptable->params.cc_node, key->size);
 				dump_lookup_key(key);
 				pr_err("\n");
 				return -EBUSY;
@@ -624,8 +676,16 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				 * Only exact match tables support this type of
 				 * modification.
 				 */
-				xx_sanity_check_return_value(mod_params->action,
-					"mod_params.action", -EINVAL);
+				BUG_ON(ptable->params.type !=
+						DPA_CLS_TBL_EXACT_MATCH);
+				/* Parameter sanity check: */
+				if (!mod_params->action) {
+					pr_err("ERROR: %s, %s (%d): "
+						"\"mod_params->action\" cannot "
+						"be NULL.\n", __FILE__,
+						__func__, __LINE__);
+					return -EINVAL;
+				}
 
 				ret = action_to_next_engine_params(
 						mod_params->action,
@@ -650,8 +710,16 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				 * Only exact match tables support this type of
 				 * modification.
 				 */
-				xx_sanity_check_return_value(mod_params->key,
-					"mod_params.key", -EINVAL);
+				BUG_ON(ptable->params.type !=
+						DPA_CLS_TBL_EXACT_MATCH);
+				/* Parameter sanity check: */
+				if (!mod_params->key) {
+					pr_err("ERROR: %s, %s (%d): "
+						"\"mod_params->key\" cannot "
+						"be NULL.\n", __FILE__,
+						__func__, __LINE__);
+					return -EINVAL;
+				}
 
 				memcpy(key_data, key->byte, key->size);
 				if (key->mask) {
@@ -683,11 +751,11 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNModifyKey. "
-					"td=%d, Cc node handle=0x%x, trying to "
+					"td=%d, Cc node handle=0x%p, trying to "
 					"modify entry w/ key (hex) (%d "
 					"byte(s)):", __FILE__, __func__,
 					__LINE__, td,
-				(unsigned)ptable->int_cc_node[0].cc_node,
+					ptable->int_cc_node[0].cc_node,
 					key->size);
 				dump_lookup_key(key);
 				pr_err("\n");
@@ -706,11 +774,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 		"FM_PCD_MatchTableFindNModifyKeyAndNextEngine. td=%d, Cc node "
-				"handle=0x%x, trying to modify entry w/ key "
+				"handle=0x%p, trying to modify entry w/ key "
 				"(hex) (%d byte(s)):", __FILE__, __func__,
 				__LINE__, td,
-				(unsigned)ptable->int_cc_node[0].cc_node,
-				key->size);
+				ptable->int_cc_node[0].cc_node, key->size);
 				dump_lookup_key(key);
 				pr_err("\n");
 				return -EBUSY;
@@ -826,11 +893,23 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 
 	BUG_ON(!ptable);
 
-	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
-		"entry_id", -EINVAL);
-	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
+	/* Parameters sanity checks: */
+	if ((entry_id < 0) || (entry_id >= ptable->entries_cnt)) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d). Should "
+			"be between %d and %d for this table.\n", __FILE__,
+			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
+		return -EINVAL;
+	}
+	if (!ptable->entry[entry_id].valid) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
+			__FILE__, __func__, __LINE__, entry_id);
+		return -EINVAL;
+	}
+	if (!mod_params) {
+		pr_err("ERROR: %s, %s (%d): \"mod_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		cc_node_index	= 0;
@@ -843,8 +922,14 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	switch (mod_params->type) {
 	case DPA_CLS_TBL_MODIFY_ACTION:
-		xx_sanity_check_return_value(mod_params->action,
-			"mod_params.action", -EINVAL);
+		/* Parameter sanity check: */
+		if (!mod_params->action) {
+			pr_err("ERROR: %s, %s (%d): \"mod_params->action\" "
+				"cannot be NULL.\n", __FILE__, __func__,
+				__LINE__);
+			return -EINVAL;
+		}
+
 		errno = action_to_next_engine_params(mod_params->action,
 						&next_engine_params);
 		if (errno < 0)
@@ -856,9 +941,9 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableModifyNextEngine. Entry "
-				"ref=%d, Cc node handle=0x%x, entry index=%d.\n",
+				"ref=%d, Cc node handle=0x%p, entry index=%d.\n",
 				__FILE__, __func__, __LINE__, entry_id,
-				(unsigned)cc_node, entry_index);
+				cc_node, entry_index);
 			return -EBUSY;
 		}
 
@@ -866,9 +951,14 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 	case DPA_CLS_TBL_MODIFY_KEY:
 		/* Only exact match tables support this type of modification. */
 		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
-		xx_sanity_check_return_value(mod_params->key,
-			"mod_params.key", -EINVAL);
 
+		/* Parameters sanity checks: */
+		if (!mod_params->key) {
+			pr_err("ERROR: %s, %s (%d): \"mod_params->key\" "
+				"cannot be NULL.\n", __FILE__, __func__,
+				__LINE__);
+			return -EINVAL;
+		}
 		if (mod_params->key->size !=
 			ptable->params.exact_match_params.key_size) {
 			pr_err("ERROR: %s, %s (%d): New key size (%d bytes) "
@@ -904,9 +994,9 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableModifyKey. Entry ref=%d, Cc "
-				"node handle=0x%x, entry index=%d.\n",
+				"node handle=0x%p, entry index=%d.\n",
 				__FILE__, __func__, __LINE__, entry_id,
-				(unsigned)cc_node, entry_index);
+				cc_node, entry_index);
 			return -EBUSY;
 		}
 
@@ -914,11 +1004,19 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 	case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
 		/* Only exact match tables support this type of modification. */
 		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
-		xx_sanity_check_return_value(mod_params->key,
-			"mod_params.key", -EINVAL);
-		xx_sanity_check_return_value(mod_params->action,
-			"mod_params.action", -EINVAL);
-
+		/* Parameters sanity checks: */
+		if (!mod_params->key) {
+			pr_err("ERROR: %s, %s (%d): \"mod_params->key\" "
+				"cannot be NULL.\n", __FILE__, __func__,
+				__LINE__);
+			return -EINVAL;
+		}
+		if (!mod_params->action) {
+			pr_err("ERROR: %s, %s (%d): \"mod_params->action\" "
+				"cannot be NULL.\n", __FILE__, __func__,
+				__LINE__);
+			return -EINVAL;
+		}
 		if (mod_params->key->size !=
 			ptable->params.exact_match_params.key_size) {
 			pr_err("ERROR: %s, %s (%d): New key size (%d bytes) "
@@ -959,9 +1057,9 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableModifyKeyAndNextEngine. "
-				"Entry ref=%d, Cc node handle=0x%x, entry "
+				"Entry ref=%d, Cc node handle=0x%p, entry "
 				"index=%d.\n", __FILE__, __func__, __LINE__,
-				entry_id, (unsigned)cc_node, entry_index);
+				entry_id, cc_node, entry_index);
 			return -EBUSY;
 		}
 
@@ -1045,10 +1143,23 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 	struct list_head *list_current;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(key, "key", -EINVAL);
-	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
-	xx_sanity_check_return_value(((key->size > 0) &&
-		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!key) {
+		pr_err("ERROR: %s, %s (%d): \"key\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!key->byte) {
+		pr_err("ERROR: %s, %s (%d): \"key->byte\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((key->size <= 0) || (key->size > DPA_OFFLD_MAXENTRYKEYSIZE)) {
+		pr_err("ERROR: %s, %s (%d): Key size should be between %d and "
+			"%d.\n", __FILE__, __func__, __LINE__, 1,
+			DPA_OFFLD_MAXENTRYKEYSIZE);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -1092,10 +1203,10 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableFindNRemoveKey. "
-					"td=%d, Cc node handle=0x%x, trying to "
+					"td=%d, Cc node handle=0x%p, trying to "
 					"remove entry w/ key (hex) (%d byte(s)):",
 					__FILE__, __func__, __LINE__, td,
-				(unsigned)ptable->int_cc_node[0].cc_node,
+					ptable->int_cc_node[0].cc_node,
 					key->size);
 				dump_lookup_key(key);
 				pr_err("\n");
@@ -1124,12 +1235,12 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 					pr_err("ERROR: %s, %s (%d): FMan "
 						"driver call failed - "
 						"FM_PCD_HashTableRemoveKey. "
-						"td=%d, Cc node handle=0x%x, "
+						"td=%d, Cc node handle=0x%p, "
 						"trying to remove entry w/ key "
 						"(hex) (%d byte(s)):",
 						__FILE__, __func__, __LINE__,
 						td,
-					(unsigned)ptable->params.cc_node,
+						ptable->params.cc_node,
 						key->size);
 					dump_lookup_key(key);
 					pr_err("\n");
@@ -1214,10 +1325,18 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 
 	BUG_ON(!ptable);
 
-	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
-		"entry_id", -EINVAL);
+	/* Parameters sanity checks: */
+	if ((entry_id < 0) || (entry_id >= ptable->entries_cnt)) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d). Should "
+			"be between %d and %d for this table.\n", __FILE__,
+			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
+		return -EINVAL;
+	}
+	if (!ptable->entry[entry_id].valid) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
+			__FILE__, __func__, __LINE__, entry_id);
+		return -EINVAL;
+	}
 
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	entry_index	= ptable->entry[entry_id].entry_index;
@@ -1235,8 +1354,8 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_MatchTableRemoveKey. Entry ref=%d, Cc "
-				"node handle=0x%x, entry index=%d.\n", __FILE__,
-				__func__, __LINE__, entry_id, (unsigned)cc_node,
+				"node handle=0x%p, entry index=%d.\n", __FILE__,
+				__func__, __LINE__, entry_id, cc_node,
 				entry_index);
 			return -EBUSY;
 		}
@@ -1303,11 +1422,28 @@ int dpa_classif_table_lookup_by_key(int				td,
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(key, "key", -EINVAL);
-	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
-	xx_sanity_check_return_value(((key->size > 0) &&
-		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
-	xx_sanity_check_return_value(action, "action", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!key) {
+		pr_err("ERROR: %s, %s (%d): \"key\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!key->byte) {
+		pr_err("ERROR: %s, %s (%d): \"key->byte\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((key->size <= 0) || (key->size > DPA_OFFLD_MAXENTRYKEYSIZE)) {
+		pr_err("ERROR: %s, %s (%d): Key size should be between %d and "
+			"%d.\n", __FILE__, __func__, __LINE__, 1,
+			DPA_OFFLD_MAXENTRYKEYSIZE);
+		return -EINVAL;
+	}
+	if (!action) {
+		pr_err("ERROR: %s, %s (%d): \"action\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -1362,7 +1498,12 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct list_head *shadow_list_entry;
 
-	xx_sanity_check_return_value(action, "action", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!action) {
+		pr_err("ERROR: %s, %s (%d): \"action\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -1375,10 +1516,18 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	mutex_lock(&ptable->access);
 	release_desc_table(&table_array);
 
-	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
-		"entry_id", -EINVAL);
+	/* Parameters sanity checks: */
+	if ((entry_id < 0) || (entry_id >= ptable->entries_cnt)) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d). Should "
+			"be between %d and %d for this table.\n", __FILE__,
+			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
+		return -EINVAL;
+	}
+	if (!ptable->entry[entry_id].valid) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
+			__FILE__, __func__, __LINE__, entry_id);
+		return -EINVAL;
+	}
 
 	if (!ptable->shadow_table) {
 		mutex_unlock(&ptable->access);
@@ -1505,10 +1654,9 @@ static int flush_table(struct dpa_cls_table *ptable)
 			if (err != E_OK) {
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - FM_PCD_MatchTableRemoveKey. "
-					"Cc node handle=0x%x, entry index=%d.\n",
+					"Cc node handle=0x%p, entry index=%d.\n",
 					__FILE__, __func__, __LINE__,
-					(unsigned)cc_node,
-					index_entry->entry_index);
+					cc_node, index_entry->entry_index);
 				return -EBUSY;
 			}
 
@@ -1531,11 +1679,28 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	int err;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(key, "key", -EINVAL);
-	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
-	xx_sanity_check_return_value(((key->size > 0) &&
-		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
-	xx_sanity_check_return_value(stats, "stats", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!key) {
+		pr_err("ERROR: %s, %s (%d): \"key\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!key->byte) {
+		pr_err("ERROR: %s, %s (%d): \"key->byte\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((key->size <= 0) || (key->size > DPA_OFFLD_MAXENTRYKEYSIZE)) {
+		pr_err("ERROR: %s, %s (%d): Key size should be between %d and "
+			"%d.\n", __FILE__, __func__, __LINE__, 1,
+			DPA_OFFLD_MAXENTRYKEYSIZE);
+		return -EINVAL;
+	}
+	if (!stats) {
+		pr_err("ERROR: %s, %s (%d): \"stats\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -1623,11 +1788,23 @@ static int table_get_entry_stats_by_ref(struct dpa_cls_table	*ptable,
 
 	BUG_ON(!ptable);
 
-	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
-		"entry_id", -EINVAL);
-	xx_sanity_check_return_value(stats, "stats", -EINVAL);
+	/* Parameters sanity checks: */
+	if ((entry_id < 0) || (entry_id >= ptable->entries_cnt)) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d). Should "
+			"be between %d and %d for this table.\n", __FILE__,
+			__func__, __LINE__, entry_id, 0, ptable->entries_cnt-1);
+		return -EINVAL;
+	}
+	if (!ptable->entry[entry_id].valid) {
+		pr_err("ERROR: %s, %s (%d): Invalid \"entry_id\" (%d).\n",
+			__FILE__, __func__, __LINE__, entry_id);
+		return -EINVAL;
+	}
+	if (!stats) {
+		pr_err("ERROR: %s, %s (%d): \"stats\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	index_entry	= &ptable->entry[entry_id];
@@ -1644,7 +1821,12 @@ int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
 {
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(params, "params", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!params) {
+		pr_err("ERROR: %s, %s (%d): \"params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	lock_desc_table(&table_array);
 	ptable = desc_to_object(&table_array, td);
@@ -1764,9 +1946,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableGetNextEngine. Cc "
-					"node handle=0x%x, entry index=%d.\n",
+					"node handle=0x%p, entry index=%d.\n",
 					__FILE__, __func__, __LINE__,
-					(unsigned)cc_node, i);
+					cc_node, i);
 				return -EBUSY;
 			}
 
@@ -1818,9 +2000,9 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 				pr_err("ERROR: %s, %s (%d): FMan driver call "
 					"failed - "
 					"FM_PCD_MatchTableGetNextEngine. Cc "
-					"node handle=0x%x, entry index=%d.\n",
+					"node handle=0x%p, entry index=%d.\n",
 					__FILE__, __func__, __LINE__,
-					(unsigned)cc_node, i);
+					cc_node, i);
 				err = -EBUSY;
 				goto table_init_hash_error;
 			}
@@ -2204,9 +2386,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	if (err != E_OK) {
 		pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 			"FM_PCD_MatchTableAddKey. Entry ref=%d, Cc node "
-			"handle=0x%x, entry index=%d.\n", __FILE__, __func__,
-			__LINE__, k,
-			(unsigned)cls_table->int_cc_node[0].cc_node,
+			"handle=0x%p, entry index=%d.\n", __FILE__, __func__,
+			__LINE__, k, cls_table->int_cc_node[0].cc_node,
 			cls_table->entry[k].entry_index);
 		return -EBUSY;
 	}
@@ -2349,8 +2530,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		if (err != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_HashTableAddKey. HASH table "
-				"handle=0x%x.\n", __FILE__, __func__, __LINE__,
-				(unsigned)cls_table->params.cc_node);
+				"handle=0x%p.\n", __FILE__, __func__, __LINE__,
+				cls_table->params.cc_node);
 			return -EBUSY;
 		}
 
@@ -2419,9 +2600,9 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if (err != E_OK) {
 		pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 			"FM_PCD_MatchTableAddKey. Entry ref=%d, HASH set=%llu,"
-			" Cc node handle=0x%x, entry index=%d.\n", __FILE__,
+			" Cc node handle=0x%p, entry index=%d.\n", __FILE__,
 			__func__, __LINE__, j, hash_set_index,
-		(unsigned)cls_table->int_cc_node[hash_set_index].cc_node,
+			cls_table->int_cc_node[hash_set_index].cc_node,
 			cls_table->entry[j].entry_index);
 		return -EBUSY;
 	}
@@ -3343,8 +3524,7 @@ int remove_hm_chain(struct list_head *chain_head, struct list_head *item)
 		if (error != E_OK) {
 			pr_warn("WARNING: Memory leak: failed to remove low "
 				"level HM #%d from this chain. Manip node "
-				"handle=0x%x.\n", index,
-				(unsigned)pcurrent->node);
+				"handle=0x%p.\n", index, pcurrent->node);
 			pr_warn("WARNING: FMan driver call failed - "
 				"FM_PCD_ManipNodeDelete.\n");
 		}
@@ -3431,9 +3611,13 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 
 	if (next_hmd != DPA_OFFLD_DESC_NONE)
 		/* Check whether [next_hmd] is a valid descriptor */
-		xx_sanity_check_return_value(((next_hmd >= 0) &&
-			(next_hmd < hm_array.num_descriptors)), "next_hmd",
-			-EINVAL);
+		if ((next_hmd < 0) || (next_hmd >= hm_array.num_descriptors)) {
+			pr_err("ERROR: %s, %s (%d): Invalid next HM descriptor "
+				"(next_hmd=%d). Should be between %d and %d.\n",
+				__FILE__, __func__, __LINE__, next_hmd, 0,
+				hm_array.num_descriptors-1);
+			return -EINVAL;
+		}
 
 	/* Allocate header manipulation object */
 	hm = kzalloc(sizeof(struct dpa_cls_hm), GFP_KERNEL);
@@ -3501,8 +3685,17 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 	int err;
 	struct dpa_cls_hm *pnat_hm;
 
-	xx_sanity_check_return_value(nat_params, "nat_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!nat_params) {
+		pr_err("ERROR: %s, %s (%d): \"nat_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -3835,8 +4028,17 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	int err;
 	struct dpa_cls_hm *pfwd_hm;
 
-	xx_sanity_check_return_value(fwd_params, "fwd_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!fwd_params) {
+		pr_err("ERROR: %s, %s (%d): \"fwd_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -4029,8 +4231,17 @@ int dpa_classif_set_remove_hm(const struct dpa_cls_hm_remove_params
 	int err;
 	struct dpa_cls_hm *premove_hm;
 
-	xx_sanity_check_return_value(remove_params, "remove_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!remove_params) {
+		pr_err("ERROR: %s, %s (%d): \"remove_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -4187,8 +4398,17 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	int err;
 	struct dpa_cls_hm *pinsert_hm;
 
-	xx_sanity_check_return_value(insert_params, "insert_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!insert_params) {
+		pr_err("ERROR: %s, %s (%d): \"insert_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -4400,11 +4620,23 @@ int dpa_classif_modify_insert_hm(int hmd,
 		/* Nothing to do */
 		return 0;
 
-	xx_sanity_check_return_value(new_insert_params, "new_insert_params",
-		-EINVAL);
-	xx_sanity_check_return_value(((hmd >= 0) &&
-		(hmd < hm_array.num_descriptors)), "hmd", -EINVAL);
-	xx_sanity_check_return_value(hm_array.object[hmd], "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!new_insert_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_insert_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
 
 	pinsert_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
 
@@ -4514,9 +4746,8 @@ int dpa_classif_modify_insert_hm(int hmd,
 		if (error != E_OK) {
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
 				"FM_PCD_ManipNodeReplace, while trying to modify"
-				" hmd=%d, manip node handle=0x%x.\n", __FILE__,
-				__func__, __LINE__, hmd,
-				(unsigned)hm_node->node);
+				" hmd=%d, manip node handle=0x%p.\n", __FILE__,
+				__func__, __LINE__, hmd, hm_node->node);
 			return -EBUSY;
 		}
 	}
@@ -4532,8 +4763,17 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	int err;
 	struct dpa_cls_hm *pupdate_hm;
 
-	xx_sanity_check_return_value(update_params, "update_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!update_params) {
+		pr_err("ERROR: %s, %s (%d): \"update_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -4961,8 +5201,17 @@ int dpa_classif_set_vlan_hm(const struct dpa_cls_hm_vlan_params	*vlan_params,
 	int err;
 	struct dpa_cls_hm *pvlan_hm;
 
-	xx_sanity_check_return_value(vlan_params, "vlan_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!vlan_params) {
+		pr_err("ERROR: %s, %s (%d): \"vlan_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -5183,8 +5432,17 @@ int dpa_classif_set_mpls_hm(const struct dpa_cls_hm_mpls_params	*mpls_params,
 	int err;
 	struct dpa_cls_hm *pmpls_hm;
 
-	xx_sanity_check_return_value(mpls_params, "mpls_params", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!mpls_params) {
+		pr_err("ERROR: %s, %s (%d): \"mpls_params\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
@@ -5349,12 +5607,24 @@ int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd)
 	struct dpa_cls_hm *pstatic_hm, *pcurrent;
 	struct dpa_cls_hm_node *hm_node;
 
-	xx_sanity_check_return_value(hm, "hm", -EINVAL);
-	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+	/* Parameters sanity checks: */
+	if (!hm) {
+		pr_err("ERROR: %s, %s (%d): \"hm\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (!hmd) {
+		pr_err("ERROR: %s, %s (%d): \"hmd\" cannot be NULL.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
 
 	err = create_new_hm_op(hmd, next_hmd);
-	if (err < 0)
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to create static HM op.\n",
+			__FILE__, __func__, __LINE__);
 		return err;
+	}
 
 	pstatic_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
 
@@ -5400,8 +5670,12 @@ void *dpa_classif_get_static_hm_handle(int hmd)
 		/* Nothing to do */
 		return NULL;
 
-	xx_sanity_check_return_value(((hmd >= 0) &&
-		(hmd < hm_array.num_descriptors)), "hmd", NULL);
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return NULL;
+	}
 
 	if (!hm_array.object[hmd])
 		return NULL;
@@ -5425,8 +5699,12 @@ void *dpa_classif_get_frag_hm_handle(int hmd)
 		/* Nothing to do */
 		return NULL;
 
-	xx_sanity_check_return_value(((hmd >= 0) &&
-		(hmd < hm_array.num_descriptors)), "hmd", NULL);
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return NULL;
+	}
 
 	if (!hm_array.object[hmd])
 		return NULL;
@@ -5455,8 +5733,12 @@ int dpa_classif_free_hm(int hmd)
 {
 	struct dpa_cls_hm *phm;
 
-	xx_sanity_check_return_value(((hmd >= 0) &&
-		(hmd < hm_array.num_descriptors)), "hmd", -EINVAL);
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
 
 	phm = (struct dpa_cls_hm *) hm_array.object[hmd];
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 7419dad..2f9978a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -59,6 +59,10 @@
 
 #define DPA_CLS_HM_MAX_NODES_PER_OP				3
 
+
+#define unused(x)						(x = x)
+
+
 /* Index management entry */
 struct dpa_cls_tbl_entry {
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_compat.c b/drivers/staging/fsl_dpa_offload/dpa_compat.c
deleted file mode 100644
index 80cb2b3..0000000
--- a/drivers/staging/fsl_dpa_offload/dpa_compat.c
+++ /dev/null
@@ -1,321 +0,0 @@
-
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * DPA Offloading Compatibility Layer.
- */
-
-/* DPA offloading layer includes */
-#include "dpa_compat.h"
-
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-
-#define DEBUG_MAX_FILE_NAME_SIZE				62
-#define DEBUG_MAX_FUNC_NAME_SIZE				56
-
-
-struct dpa_offld_memory_block_info {
-	void			*mem;
-	char			file_name[DEBUG_MAX_FILE_NAME_SIZE + 1];
-	char			func_name[DEBUG_MAX_FUNC_NAME_SIZE + 1];
-	unsigned int		file_line;
-	size_t			size;
-	void			(*free_func)(void *);
-	struct list_head	node;
-};
-
-
-static struct list_head mem_block_list = {&mem_block_list, &mem_block_list};
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
-
-
-void *dpa_offld_malloc(size_t size, int zero)
-{
-	void *memory;
-	unsigned long flags;
-
-
-	local_irq_save(flags);
-
-	memory = (zero) ? kzalloc(size, GFP_KERNEL) : kmalloc(size, GFP_KERNEL);
-
-	local_irq_restore(flags);
-
-	return memory;
-}
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-void dpa_offld_free(void *memory)
-{
-	kfree(memory);
-}
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
-
-void *dpa_offld_malloc_smart(size_t	size,
-			int		mem_partition_id,
-			unsigned int	alignment,
-			int		zero)
-{
-	void *memory, *tmp;
-
-
-	if (alignment < sizeof(void *))
-		return NULL;
-	size += alignment + sizeof(void *);
-	tmp = dpa_offld_malloc(size, zero);
-	if (tmp == NULL)
-		return NULL;
-	memory = (void *)(((unsigned long)tmp + alignment + sizeof(void *)) &
-			~((unsigned long)alignment - 1));
-	*(void **)((uint8_t *)memory - sizeof(void *)) = tmp;
-
-	return memory;
-}
-
-void dpa_offld_free_smart(void *memory)
-{
-	dpa_offld_free(*(void **)((uint8_t *)memory - sizeof(void*)));
-}
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-void *xx_malloc_debug(size_t	size,
-		int		zero,
-		const char	*file_name,
-		const char	*func_name,
-		unsigned int	file_line)
-{
-	struct dpa_offld_memory_block_info *memblk;
-	int str_offs = 0;
-	size_t str_len;
-
-
-	memblk = (struct dpa_offld_memory_block_info *)
-		dpa_offld_malloc(sizeof(struct dpa_offld_memory_block_info), 0);
-	if (!memblk)
-		return NULL;
-
-	memblk->size	= size;
-	memblk->mem	= dpa_offld_malloc(size, zero);
-	if (!memblk->mem) {
-		dpa_offld_free(memblk);
-		return NULL;
-	}
-	memblk->free_func = dpa_offld_free;
-	memblk->file_line = file_line;
-
-	str_len = strlen(file_name);
-	if (str_len > DEBUG_MAX_FILE_NAME_SIZE) {
-		str_offs	= str_len - DEBUG_MAX_FILE_NAME_SIZE;
-		str_len		= DEBUG_MAX_FILE_NAME_SIZE;
-	}
-	memcpy(memblk->file_name, &file_name[str_offs], str_len + 1);
-
-	str_len		= strlen(func_name);
-	str_offs	= 0;
-	if (str_len > DEBUG_MAX_FUNC_NAME_SIZE) {
-		str_offs	= str_len - DEBUG_MAX_FUNC_NAME_SIZE;
-		str_len		= DEBUG_MAX_FUNC_NAME_SIZE;
-	}
-	memcpy(memblk->func_name, &func_name[str_offs], str_len + 1);
-
-	list_add_tail(&memblk->node, &mem_block_list);
-
-	return memblk->mem;
-}
-
-void xx_free_debug(void *memory)
-{
-	struct list_head *temp;
-	struct dpa_offld_memory_block_info *memblk;
-	int found = 0;
-
-
-	if (list_empty(&mem_block_list)) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Attempt to free unallocated memory\n  (0x%p).\n",
-			__LINE__, __func__, memory);
-		dump_stack();
-		return;
-	}
-
-	/* Find memory block in list */
-	list_for_each(temp, &mem_block_list) {
-		memblk = list_entry(temp, struct dpa_offld_memory_block_info,
-				node);
-		if (memblk->mem == memory) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Attempt to free unallocated memory\n  (0x%p).\n",
-			__LINE__, __func__, memory);
-		dump_stack();
-		return;
-	}
-
-	list_del(temp);
-	if (memblk->free_func != dpa_offld_free) {
-		pr_err("\nERROR: Freeing memory with the wrong \"free\" function.\n");
-		pr_err("  Memory block @ 0x%p\n", memblk->mem);
-		pr_err("  Allocated in: %s\n", memblk->file_name);
-		pr_err("  Line %d, function \"%s\"\n", memblk->file_line,
-			memblk->func_name);
-		memblk->free_func(memblk->mem);
-	} else
-		dpa_offld_free(memblk->mem);
-
-	dpa_offld_free(memblk);
-}
-
-void *xx_malloc_smart_debug(size_t	size,
-			int		mem_partition_id,
-			unsigned int	alignment,
-			int		zero,
-			const char	*file_name,
-			const char	*func_name,
-			unsigned int	file_line)
-{
-	struct dpa_offld_memory_block_info *memblk;
-	int str_offs = 0;
-	size_t str_len;
-
-
-	memblk = (struct dpa_offld_memory_block_info *)
-		dpa_offld_malloc(sizeof(struct dpa_offld_memory_block_info), 0);
-	if (!memblk)
-		return NULL;
-
-	memblk->size	= size;
-	memblk->mem	= dpa_offld_malloc_smart(size,
-						mem_partition_id,
-						alignment,
-						zero);
-	if (!memblk->mem) {
-		dpa_offld_free(memblk);
-		return NULL;
-	}
-	memblk->free_func = dpa_offld_free_smart;
-	memblk->file_line = file_line;
-
-	str_len = strlen(file_name);
-	if (str_len > DEBUG_MAX_FILE_NAME_SIZE) {
-		str_offs	= str_len - DEBUG_MAX_FILE_NAME_SIZE;
-		str_len		= DEBUG_MAX_FILE_NAME_SIZE;
-	}
-	memcpy(memblk->file_name, &file_name[str_offs], str_len + 1);
-
-	str_len		= strlen(func_name);
-	str_offs	= 0;
-	if (str_len > DEBUG_MAX_FUNC_NAME_SIZE) {
-		str_offs	= str_len - DEBUG_MAX_FUNC_NAME_SIZE;
-		str_len		= DEBUG_MAX_FUNC_NAME_SIZE;
-	}
-	memcpy(memblk->func_name, &func_name[str_offs], str_len + 1);
-
-	list_add_tail(&memblk->node, &mem_block_list);
-
-	return memblk->mem;
-}
-
-void xx_free_smart_debug(void *memory)
-{
-	struct list_head *temp;
-	struct dpa_offld_memory_block_info *memblk;
-	int found = 0;
-
-
-	if (list_empty(&mem_block_list)) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Attempt to free unallocated\n  memory (0x%p).\n",
-			__LINE__, __func__, memory);
-		dump_stack();
-		return;
-	}
-
-	/* Find memory block in list */
-	list_for_each(temp, &mem_block_list) {
-		memblk = list_entry(temp, struct dpa_offld_memory_block_info,
-				node);
-		if (memblk->mem == memory) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Attempt to free unallocated\n  memory (0x%p).\n",
-			__LINE__, __func__, memory);
-		dump_stack();
-		return;
-	}
-
-	list_del(temp);
-	if (memblk->free_func != dpa_offld_free_smart) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Freeing memory with the wrong\n  \"free\" function.\n",
-			__LINE__, __func__);
-		pr_err("  Memory block @ 0x%p\n", memblk->mem);
-		pr_err("  Allocated in: %s\n", memblk->file_name);
-		pr_err("  Line %d, function \"%s\"\n", memblk->file_line,
-			memblk->func_name);
-		memblk->free_func(memblk->mem);
-	} else
-		dpa_offld_free_smart(memblk->mem);
-
-	dpa_offld_free(memblk);
-}
-
-void dpa_offld_display_mem_leaks(void)
-{
-	struct list_head *temp;
-	struct dpa_offld_memory_block_info *memblk;
-
-
-	if (list_empty(&mem_block_list)) {
-		pr_info("\nDEBUG: No memory leaks detected.\n");
-		return;
-	} else {
-		pr_warn("\nWARNING: Listing MEMORY LEAKS.\n");
-		list_for_each(temp, &mem_block_list) {
-			memblk = list_entry(temp,
-					struct dpa_offld_memory_block_info,
-					node);
-			pr_warn("\nLeaking %u bytes @ 0x%p\n",
-				(unsigned)memblk->size, memblk->mem);
-			pr_warn("  Allocated in: %s\n", memblk->file_name);
-			pr_warn("  Line %d, function \"%s\"\n",
-				memblk->file_line, memblk->func_name);
-		}
-		pr_warn("\nDEBUG: Done listing memory leaks.\n");
-	}
-}
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_compat.h b/drivers/staging/fsl_dpa_offload/dpa_compat.h
deleted file mode 100644
index c68a3f3..0000000
--- a/drivers/staging/fsl_dpa_offload/dpa_compat.h
+++ /dev/null
@@ -1,199 +0,0 @@
-
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * DPA Offloading Layer compatibility layer interface for kernel space/user
- * space integration
- */
-
-#ifndef __DPA_COMPAT_H
-#define __DPA_COMPAT_H
-
-
-/* Linux kernel includes: */
-#include "linux/types.h"
-#include "linux/slab.h"
-#include "linux/printk.h"
-
-/* FMan driver includes: */
-#include "error_ext.h" /* for translating FMan LLD errTypeStrings */
-
-
-/*
- * Memory management
- */
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-
-#define xx_malloc(size) \
-	xx_malloc_debug(size, 0,  __FILE__, __func__, __LINE__)
-
-#define xx_zalloc(size) \
-	xx_malloc_debug(size, \
-			1, \
-			__FILE__, \
-			__func__, \
-			__LINE__)
-
-#define xx_free					xx_free_debug
-
-#define xx_malloc_smart(size, partition_id, alignment) \
-	xx_malloc_smart_debug(size, \
-			partition_id, \
-			alignment, \
-			0, \
-			__FILE__, \
-			__func__, \
-			__LINE__)
-
-#define xx_zalloc_smart(size, partition_id, alignment) \
-	xx_malloc_smart_debug(size, \
-			partition_id, \
-			alignment, \
-			1, \
-			__FILE__, \
-			__func__, \
-			__LINE__)
-
-#define xx_free_smart				xx_free_smart_debug
-
-#define xx_display_mem_leaks			dpa_offld_display_mem_leaks
-
-#else /* not in DEBUG_MEMORY mode */
-
-#define dpa_offld_free				kfree
-
-#define xx_malloc(size) \
-			dpa_offld_malloc(size, 0)
-#define xx_zalloc(size) \
-			dpa_offld_malloc(size, 1)
-#define xx_free					kfree
-#define xx_malloc_smart(size, \
-			mem_partition_id, \
-			alignment) \
-	dpa_offld_malloc_smart(size, mem_partition_id, alignment, 0)
-#define xx_zalloc_smart(size, \
-			mem_partition_id, \
-			alignment) \
-	dpa_offld_malloc_smart(size, \
-			mem_partition_id, \
-			alignment, \
-			1)
-#define xx_free_smart				dpa_offld_free_smart
-#define xx_display_mem_leaks()
-
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
-
-
-void	*dpa_offld_malloc(size_t size, int zero);
-
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-void	dpa_offld_free(void *memory);
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
-
-void	*dpa_offld_malloc_smart(size_t		size,
-				int		mem_partition_id,
-				unsigned int	alignment,
-				int		zero);
-
-void	dpa_offld_free_smart(void *memory);
-
-#ifdef DPA_OFFLOAD_DEBUG_MEMORY
-void	*xx_malloc_debug(size_t		size,
-			int		zero,
-			const char	*file_name,
-			const char	*func_name,
-			unsigned int	file_line);
-
-void	xx_free_debug(void *memory);
-
-void	*xx_malloc_smart_debug(size_t		size,
-				int		mem_partition_id,
-				unsigned int	alignment,
-				int		zero,
-				const char	*file_name,
-				const char	*func_name,
-				unsigned int	file_line);
-
-void	xx_free_smart_debug(void *memory);
-
-void	dpa_offld_display_mem_leaks(void);
-#endif /* DPA_OFFLOAD_DEBUG_MEMORY */
-
-
-/*
- * Error Reporting
- */
-
-/* After we won't use anymore xx_malloc and
- * friends this whole file + compat file shall be removed.
- */
-#define xx_pr_err(...)
-
-/*
- * Error Checking
- */
-#ifdef DPA_OFFLOAD_DEBUG
-#define xx_assert(cond) \
-	if (!(cond)) { \
-		pr_err( \
-			"\nERROR: DEBUG assertion failed: %s, line %d\n", \
-			__FILE__, \
-			__LINE__); \
-		panic("DPA offloading layer"); \
-	}
-#else
-#define xx_assert(cond)
-#endif /* DPA_OFFLOAD_DEBUG */
-
-#ifdef DPA_OFFLOAD_SANITY_CHECKS
-#define xx_sanity_check_return_value(cond, var_desc, ret) \
-	if (!cond) { \
-		pr_err("\nERROR: %s, %s (%d): Invalid value for %s.\n", \
-			__FILE__, __func__, __LINE__, var_desc); \
-		return ret; \
-	}
-
-#define xx_sanity_check_return(cond, var_desc) \
-	if (!cond) { \
-		pr_err("\nERROR: %s, %s (%d): Invalid value for %s.\n", \
-			__FILE, __func__, __LINE__, var_desc); \
-		return; \
-	}
-#else
-#define xx_sanity_check_return_value(cond, var_desc, ret)
-#define xx_sanity_check_return(cond, var_desc)
-#endif
-
-
-#endif /* __DPA_COMPAT_H */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 2f2525e..ea9837f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -49,8 +49,6 @@
 
 #include "desc.h"
 
-#include "dpa_compat.h"
-
 #include "fm_pcd_ext.h"
 #include "cq.h"
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_offload_module.c b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
index 8130c1b..aaf6693 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
@@ -35,7 +35,6 @@
 
 #include <linux/module.h>
 
-#include "dpa_compat.h"
 #include "dpa_offload_module.h"
 #include "wrp_dpa_classifier.h"
 #include "wrp_dpa_ipsec.h"
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 11606f4..85c94a0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -38,7 +38,6 @@
 #include "dpaa_eth.h"
 
 /* DPA offloading layer includes */
-#include "dpa_compat.h"
 #include "dpa_stats.h"
 #include "dpa_classifier.h"
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index a0f0456..407dbe5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -40,7 +40,6 @@
 /* DPA offloading layer includes */
 #include "linux/fsl_dpa_stats.h"
 #include "linux/fsl_dpa_ipsec.h"
-#include "dpa_compat.h"
 #include "cq.h"
 
 #define MAX_NUM_OF_STATS 23
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index f26b238..7b047cb 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -38,7 +38,6 @@
 #include <linux/fsl_dpa_classifier.h>
 #include "wrp_dpa_classifier.h"
 #include "dpa_classifier_ioctl.h"
-#include "dpa_compat.h"
 
 /* Other includes */
 #include <linux/uaccess.h>
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 36d10b8..7193a41 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -37,7 +37,6 @@
 #include <linux/kernel.h>
 #include <linux/uaccess.h>
 
-#include "dpa_compat.h"
 #include <linux/fsl_dpa_ipsec.h>
 #include "dpa_ipsec_ioctl.h"
 #include "wrp_dpa_ipsec.h"
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 92bea21..ad2e31c 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -44,8 +44,6 @@
 #include <linux/atomic.h>
 #include <linux/spinlock.h>
 
-#include "dpa_compat.h"
-
 #include "lnxwrp_fm.h"
 #include "fm_port_ioctls.h"
 #ifdef CONFIG_COMPAT
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 9b85610..1b5a20a 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -39,7 +39,6 @@
 
 
 /* DPA offloading layer includes */
-#include "fsl_dpa_compat.h"
 #include "fsl_dpa_offload.h"
 
 
diff --git a/include/linux/fsl_dpa_compat.h b/include/linux/fsl_dpa_compat.h
deleted file mode 100644
index 3b417c1..0000000
--- a/include/linux/fsl_dpa_compat.h
+++ /dev/null
@@ -1,50 +0,0 @@
-
-/* Copyright 2008-2012 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * DPA Offloading Layer compatibility layer type definitions for kernel
- * space/user space integration
- */
-
-#ifndef __FSL_DPA_COMPAT_H
-#define __FSL_DPA_COMPAT_H
-
-
-#ifndef __KERNEL__
-	#include "usdpaa/compat.h"
-#endif
-
-
-#define unused(x)					(x = x)
-
-
-#endif /* __FSL_DPA_COMPAT_H */
diff --git a/include/linux/fsl_dpa_offload.h b/include/linux/fsl_dpa_offload.h
index 8791341..3cfbd0e 100644
--- a/include/linux/fsl_dpa_offload.h
+++ b/include/linux/fsl_dpa_offload.h
@@ -38,8 +38,6 @@
 #define __FSL_DPA_OFFLOAD_H
 
 
-#include "fsl_dpa_compat.h"
-
 #include <linux/if_ether.h>
 #include <linux/ip.h>
 
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index d2b5ab1..878fd98 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -37,7 +37,6 @@
 #define __FSL_DPA_STATS_H
 
 /* DPA offloading layer includes */
-#include "fsl_dpa_compat.h"
 #include "fsl_dpa_offload.h"
 
 /* Other includes */
-- 
1.7.5.4

