From a055ca5a6ea4a61d2334fb2d73e7887a5a5afab2 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Wed, 13 Jun 2012 13:40:07 +0000
Subject: [PATCH 210/518] Update wrapper to support running in 32/64 bit
 scenarios

Changes to the IOCTL handling code required for enabling it to function
correctly in a scenarion where the usdpaa (and all other userspace apps)
are compiled and run on 32 bits and the kernel runs on 64 bits.

Also, fix the way userspace memory is addressed. It is now done through
the copy_from/to_user functions.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |  131 +++-
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |  902 +++++++++++++++++----
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h   |    5 +
 3 files changed, 872 insertions(+), 166 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index 3acd16a..fe21540 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -38,51 +38,162 @@
 #define __DPA_IPSEC_IOCTL_H
 
 #include "linux/ioctl.h"
+#ifdef CONFIG_COMPAT
+#include "linux/compat.h"
+#include "dpa_classifier_ioctl.h"
+#endif
 
 struct ioc_dpa_ipsec_params {
 	struct dpa_ipsec_params dpa_ipsec_params;
 	int dpa_ipsec_id;
 };
 
+#ifdef CONFIG_COMPAT
+struct ioc_compat_ipsec_init_params {
+	struct dpa_ipsec_pre_sec_in_params pre_sec_in_params;
+	struct dpa_ipsec_post_sec_in_params post_sec_in_params;
+	struct dpa_ipsec_pre_sec_out_params pre_sec_out_params;
+	struct dpa_ipsec_post_sec_out_params post_sec_out_params;
+	compat_uptr_t fm_pcd;
+	uint16_t qm_sec_ch;
+	uint16_t max_sa_pairs;
+	compat_uptr_t fqid_pool;
+	uint8_t ipf_bpid;
+};
+
+struct ioc_compat_dpa_ipsec_params {
+	struct ioc_compat_ipsec_init_params dpa_ipsec_params;
+	int dpa_ipsec_id;
+};
+#endif
+
 struct ioc_dpa_ipsec_sa_params {
 	int dpa_ipsec_id;
 	struct dpa_ipsec_sa_params sa_params;
 	int sa_id;
 };
 
+#ifdef CONFIG_COMPAT
+struct ioc_compat_sa_init_vector {
+	compat_uptr_t init_vector;
+	uint8_t length;
+};
+
+struct ioc_compat_sa_crypto_params {
+	enum dpa_ipsec_cipher_alg alg_suite;
+	compat_uptr_t cipher_key;
+	uint8_t cipher_key_len;
+	compat_uptr_t auth_key;
+	uint8_t auth_key_len;
+};
+
+struct ioc_compat_sa_out_params {
+	compat_uptr_t init_vector;
+	enum dpa_ipsec_ip_addr_type addr_type;
+	uint16_t ip_hdr_size;
+	compat_uptr_t outer_ip_header;
+	compat_uptr_t outer_udp_header;
+	uint16_t post_sec_flow_id;
+};
+
+struct ioc_compat_sa_in_params {
+	enum dpa_ipsec_arw arw;
+	int use_var_iphdr_len;
+	struct dpa_ipsec_ip_address src_addr;
+	struct dpa_ipsec_ip_address dest_addr;
+	int use_udp_encap;
+	uint16_t src_port;
+	uint16_t dest_port;
+	uint32_t policy_miss_fqid;
+	struct dpa_cls_compat_tbl_action post_ipsec_action;
+};
+
+struct ioc_compat_sa_params {
+	uint32_t spi;
+	int use_ext_seq_num;
+	uint64_t start_seq_num;
+	uint32_t l2_hdr_size;
+	enum dpa_ipsec_sa_mode sa_mode;
+	enum dpa_ipsec_sa_proto sa_proto;
+	uint8_t hdr_upd_flags;
+	uint8_t sa_wqid;
+	uint8_t sa_bpid;
+	int	enable_stats;
+	struct ioc_compat_sa_crypto_params crypto_params;
+	enum dpa_ipsec_direction sa_dir;
+	union {
+		struct ioc_compat_sa_in_params sa_in_params;
+		struct ioc_compat_sa_out_params sa_out_params;
+	};
+};
+
+struct ioc_compat_dpa_ipsec_sa_params {
+	int dpa_ipsec_id;
+	struct ioc_compat_sa_params sa_params;
+	int sa_id;
+};
+#endif
+
 struct ioc_dpa_ipsec_add_rem_policy {
 	struct dpa_ipsec_policy_params pol_params;
 	int sa_id;
 };
 
-struct ioc_dpa_ipsec_sa_rekeying_prm {
+struct ioc_dpa_ipsec_rekey_prm {
 	struct dpa_ipsec_sa_params sa_params;
 	int auto_rmv_old_sa;
 	int sa_id;		/* old sa id */
 	int new_sa_id;		/* newly created sa id */
 };
 
-struct ioc_dpa_ipsec_sa_get_policies {
+#ifdef CONFIG_COMPAT
+struct ioc_compat_dpa_ipsec_rekey_prm {
+	struct ioc_compat_sa_params sa_params;
+	int auto_rmv_old_sa;
+	int sa_id;		/* old sa id */
+	int new_sa_id;		/* newly created sa id */
+};
+#endif
+
+struct ioc_dpa_ipsec_get_policies {
 	int sa_id;		/* sa id */
 	struct dpa_ipsec_policy_params *policy_params;
-	int *num_pol;		/* number of policies */
+	int num_pol;		/* number of policies */
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_dpa_ipsec_get_policies {
+	int sa_id;		/* sa id */
+	compat_uptr_t policy_params;
+	int num_pol;		/* number of policies */
 };
+#endif
 
 struct ioc_dpa_ipsec_sa_get_stats {
 	int sa_id;		/* sa id */
-	struct dpa_ipsec_sa_stats *sa_stats;
+	struct dpa_ipsec_sa_stats sa_stats;
 };
 
 #define DPA_IPSEC_IOC_MAGIC	0xee
 
 #define DPA_IPSEC_IOC_INIT \
 		_IOWR(DPA_IPSEC_IOC_MAGIC, 0, struct ioc_dpa_ipsec_params)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_INIT_COMPAT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 0, \
+		      struct ioc_compat_dpa_ipsec_params)
+#endif
 
 #define DPA_IPSEC_IOC_FREE \
 		_IOW(DPA_IPSEC_IOC_MAGIC, 1, int)
 
 #define DPA_IPSEC_IOC_CREATE_SA \
 		_IOWR(DPA_IPSEC_IOC_MAGIC, 2, struct ioc_dpa_ipsec_sa_params)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_CREATE_SA_COMPAT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 2, \
+		      struct ioc_compat_dpa_ipsec_sa_params)
+#endif
 
 #define DPA_IPSEC_IOC_REMOVE_SA \
 		_IOW(DPA_IPSEC_IOC_MAGIC, 3, int)
@@ -94,13 +205,21 @@ struct ioc_dpa_ipsec_sa_get_stats {
 	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_dpa_ipsec_add_rem_policy)
 
 #define DPA_IPSEC_IOC_SA_REKEYING \
-	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_dpa_ipsec_sa_rekeying_prm)
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_dpa_ipsec_rekey_prm)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_SA_REKEYING_COMPAT \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_compat_dpa_ipsec_rekey_prm)
+#endif
 
 #define DPA_IPSEC_IOC_FLUSH_ALL_SA \
 		_IOW(DPA_IPSEC_IOC_MAGIC, 7, int)
 
 #define DPA_IPSEC_IOC_GET_SA_POLICIES \
-	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_dpa_ipsec_sa_get_policies)
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_dpa_ipsec_get_policies)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_compat_dpa_ipsec_get_policies)
+#endif
 
 #define DPA_IPSEC_IOC_FLUSH_SA_POLICIES \
 	_IOW(DPA_IPSEC_IOC_MAGIC, 9, int)
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 59eb136..99cacb8 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -46,16 +46,715 @@
 #include <linux/fdtable.h>
 #include "lnxwrp_fm.h"
 
+#define UDP_HDR_SIZE 8
+
 static const struct file_operations dpa_ipsec_fops = {
 	.owner = THIS_MODULE,
 	.open = wrp_dpa_ipsec_open,
 	.read = NULL,
 	.write = NULL,
 	.unlocked_ioctl = wrp_dpa_ipsec_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = wrp_dpa_ipsec_ioctl_compat,
+#endif
 	.release = wrp_dpa_ipsec_release
 };
 
 static int dpa_ipsec_cdev_major = -1;
+static long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
+				   unsigned long args, bool compat);
+
+#ifdef CONFIG_COMPAT
+
+#define COMPAT_K_TO_US 0 /* copy from Kernel to User */
+#define COMPAT_US_TO_K 1 /* copy from User to Kernel */
+
+static void compat_copy_dpa_ipsec_init(struct ioc_dpa_ipsec_params *prm,
+				struct ioc_compat_dpa_ipsec_params *compat_prm,
+				uint8_t	compat)
+{
+	struct ioc_compat_ipsec_init_params *init_compat_prm;
+	struct dpa_ipsec_params	*init_prm;
+
+	init_compat_prm = &compat_prm->dpa_ipsec_params;
+	init_prm = &prm->dpa_ipsec_params;
+
+	if (compat == COMPAT_US_TO_K) {
+		init_prm->fm_pcd = (void *)compat_ptr(init_compat_prm->fm_pcd);
+		init_prm->fqid_pool = (struct qman_fqid_pool *)
+					compat_ptr(init_compat_prm->fqid_pool);
+		init_prm->ipf_bpid = init_compat_prm->ipf_bpid;
+		init_prm->max_sa_pairs = init_compat_prm->max_sa_pairs;
+		init_prm->post_sec_in_params =
+					init_compat_prm->post_sec_in_params;
+		init_prm->post_sec_out_params =
+					init_compat_prm->post_sec_out_params;
+		init_prm->pre_sec_in_params =
+					init_compat_prm->pre_sec_in_params;
+		init_prm->pre_sec_out_params =
+					init_compat_prm->pre_sec_out_params;
+		init_prm->qm_sec_ch = init_compat_prm->qm_sec_ch;
+	} else
+		/* copy the ID of the newly initialized DPA IPSec instance */
+		compat_prm->dpa_ipsec_id = prm->dpa_ipsec_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static void compat_copy_sa_in_params(struct dpa_ipsec_sa_in_params *prm,
+				struct ioc_compat_sa_in_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->arw = compat_prm->arw;
+		prm->use_var_iphdr_len = compat_prm->use_var_iphdr_len;
+		prm->src_addr = compat_prm->src_addr;
+		prm->dest_addr = compat_prm->dest_addr;
+		prm->use_udp_encap = compat_prm->use_udp_encap;
+		prm->src_port = compat_prm->src_port;
+		prm->dest_port = compat_prm->dest_port;
+		prm->policy_miss_fqid = compat_prm->policy_miss_fqid;
+		memset(&prm->post_ipsec_action, 0,
+		       sizeof(prm->post_ipsec_action));
+		dpa_cls_tbl_action_params_compatcpy(&prm->post_ipsec_action,
+					&compat_prm->post_ipsec_action);
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+static void compat_copy_sa_out_params(struct dpa_ipsec_sa_out_params *prm,
+				struct ioc_compat_sa_out_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->init_vector = (struct dpa_ipsec_init_vector *)
+					compat_ptr(compat_prm->init_vector);
+		prm->addr_type = compat_prm->addr_type;
+		prm->ip_hdr_size = compat_prm->ip_hdr_size;
+		prm->outer_ip_header = (void *)
+					compat_ptr(compat_prm->outer_ip_header);
+		prm->outer_udp_header =	(void *)
+				compat_ptr(compat_prm->outer_udp_header);
+		prm->post_sec_flow_id = compat_prm->post_sec_flow_id;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_sa_crypto_params(struct dpa_ipsec_sa_crypto_params *prm,
+				struct ioc_compat_sa_crypto_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+
+		prm->alg_suite = compat_prm->alg_suite;
+		prm->auth_key = (uint8_t *)compat_ptr(compat_prm->auth_key);
+		prm->auth_key_len = compat_prm->auth_key_len;
+		prm->cipher_key = (uint8_t *)compat_ptr(compat_prm->cipher_key);
+		prm->cipher_key_len = compat_prm->cipher_key_len;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_sa_params(struct dpa_ipsec_sa_params *sa_prm,
+				struct ioc_compat_sa_params *sa_compat_prm,
+				bool compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		/* copy common (both IN & OUT SA) parameters */
+		sa_prm->spi = sa_compat_prm->spi;
+		sa_prm->use_ext_seq_num = sa_compat_prm->use_ext_seq_num;
+		sa_prm->start_seq_num = sa_compat_prm->start_seq_num;
+		sa_prm->l2_hdr_size = sa_compat_prm->l2_hdr_size;
+		sa_prm->sa_mode = sa_compat_prm->sa_mode;
+		sa_prm->sa_proto = sa_compat_prm->sa_proto;
+		sa_prm->hdr_upd_flags = sa_compat_prm->hdr_upd_flags;
+		sa_prm->sa_wqid = sa_compat_prm->sa_wqid;
+		sa_prm->sa_bpid = sa_compat_prm->sa_bpid;
+		sa_prm->enable_stats = sa_compat_prm->enable_stats;
+		sa_prm->sa_dir = sa_compat_prm->sa_dir;
+
+		/* copy crypto parameters (containing multiple pointers) */
+		compat_copy_sa_crypto_params(&sa_prm->crypto_params,
+					     &sa_compat_prm->crypto_params,
+					     COMPAT_US_TO_K);
+
+		/* copy direction specific (IN / OUT) parameters */
+		if (sa_prm->sa_dir == DPA_IPSEC_INBOUND)
+			compat_copy_sa_in_params(&sa_prm->sa_in_params,
+						 &sa_compat_prm->sa_in_params,
+						 COMPAT_US_TO_K);
+		else
+			compat_copy_sa_out_params(&sa_prm->sa_out_params,
+						  &sa_compat_prm->sa_out_params,
+						  COMPAT_US_TO_K);
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_dpa_ipsec_create_sa(struct ioc_dpa_ipsec_sa_params *prm,
+			struct ioc_compat_dpa_ipsec_sa_params *compat_prm,
+			uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K)
+		/* copy SA params from userspace */
+		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
+				      compat);
+	else
+		/* copy the ID of the newly created DPA IPSec SA */
+		compat_prm->sa_id = prm->sa_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static int compat_copy_sa_out_iv(struct dpa_ipsec_init_vector *sa_iv,
+				compat_uptr_t compat_iv_ptr, uint8_t compat)
+{
+	struct ioc_compat_sa_init_vector *compat_sa_iv, tmp_sa_iv;
+
+	compat_sa_iv =
+		(struct ioc_compat_sa_init_vector *)compat_ptr(compat_iv_ptr);
+
+	if (compat == COMPAT_US_TO_K) {
+		if (copy_from_user(&tmp_sa_iv, compat_sa_iv, sizeof(tmp_sa_iv)))
+			return -EINVAL;
+		sa_iv->init_vector = (uint8_t *)
+					compat_ptr(tmp_sa_iv.init_vector);
+		sa_iv->length = tmp_sa_iv.length;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+	return 0;
+}
+
+static void compat_copy_dpa_ipsec_rekey_sa(struct ioc_dpa_ipsec_rekey_prm *prm,
+			struct ioc_compat_dpa_ipsec_rekey_prm *compat_prm,
+			uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		/* copy rekeying specific params */
+		prm->auto_rmv_old_sa = compat_prm->auto_rmv_old_sa;
+		prm->sa_id = compat_prm->sa_id;
+
+		/* copy SA params from userspace */
+		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
+				      compat);
+	} else
+		/* copy the ID of the newly created DPA IPSec SA */
+		compat_prm->new_sa_id = prm->new_sa_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static void compat_copy_dpa_ipsec_get_pols(
+			struct ioc_dpa_ipsec_get_policies *prm,
+			struct ioc_compat_dpa_ipsec_get_policies *compat_prm,
+			uint8_t compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->num_pol = compat_prm->num_pol;
+		prm->sa_id = compat_prm->sa_id;
+		prm->policy_params = (struct dpa_ipsec_policy_params *)
+					compat_ptr(compat_prm->policy_params);
+	} else
+		compat_prm->num_pol = prm->num_pol;
+}
+
+#endif
+
+/* free memory allocated for copying SA params from US */
+static void free_sa_params(struct dpa_ipsec_sa_params *prm)
+{
+	struct dpa_ipsec_sa_crypto_params *crypto_params;
+
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		struct dpa_ipsec_sa_out_params *sa_out_prm;
+
+		sa_out_prm = &prm->sa_out_params;
+		if (sa_out_prm->init_vector) {
+			xx_free(sa_out_prm->init_vector->init_vector);
+			xx_free(sa_out_prm->init_vector);
+		}
+		xx_free(sa_out_prm->outer_ip_header);
+		xx_free(sa_out_prm->outer_udp_header);
+	} else {
+		struct dpa_cls_tbl_action *sa_in_act;
+
+		sa_in_act = &prm->sa_in_params.post_ipsec_action;
+		if (sa_in_act->type == DPA_CLS_TBL_ACTION_ENQ)
+			xx_free(sa_in_act->enq_params.policer_params);
+	}
+
+	crypto_params = &prm->crypto_params;
+	xx_free(crypto_params->auth_key);
+	xx_free(crypto_params->cipher_key);
+}
+
+/* handle any required memory transfers (US to K) when creating/rekeying a SA */
+#ifdef CONFIG_COMPAT
+static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm,
+			     struct ioc_compat_sa_params *compat_prm,
+			     bool compat)
+#else
+static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
+#endif
+{
+	struct dpa_ipsec_sa_out_params *sa_out_prm;
+	struct dpa_ipsec_sa_crypto_params *crypto_params;
+	struct dpa_ipsec_init_vector *sa_out_iv = NULL;
+	uint8_t *auth_key =  NULL, *cipher_key = NULL, *iv_array = NULL;
+	void *out_ip_hdr = NULL, *out_udp_hdr = NULL;
+	struct dpa_cls_tbl_policer_params *policer_prm = NULL;
+	int err = 0;
+
+	/* allocate memory and copy SA out params (if required)*/
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		sa_out_prm = &prm->sa_out_params;
+		if (sa_out_prm->outer_ip_header) {
+			out_ip_hdr = xx_malloc(sa_out_prm->ip_hdr_size);
+			if (!out_ip_hdr) {
+				xx_pr_err("Error - alloc SA out hdr");
+				return -ENOMEM;
+			}
+			if (copy_from_user(out_ip_hdr,
+					   sa_out_prm->outer_ip_header,
+					   sa_out_prm->ip_hdr_size)) {
+				xx_pr_err("Error - copy SA out hdr");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_prm->outer_ip_header = out_ip_hdr;
+		}
+		if (sa_out_prm->outer_udp_header) {
+			out_udp_hdr = xx_malloc(UDP_HDR_SIZE);
+			if (!out_udp_hdr) {
+				xx_pr_err("Error - alloc SA out udp hdr");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+			if (copy_from_user(out_udp_hdr,
+					   sa_out_prm->outer_udp_header,
+					   UDP_HDR_SIZE)) {
+				xx_pr_err("Error - copy SA out udp hdr");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_prm->outer_udp_header = out_udp_hdr;
+		}
+		if (sa_out_prm->init_vector) {
+			sa_out_iv = (struct dpa_ipsec_init_vector *)
+						xx_malloc(sizeof(*sa_out_iv));
+			if (!sa_out_iv) {
+				xx_pr_err("Error - alloc SA out IV struct");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+#ifdef CONFIG_COMPAT
+			if (compat) {
+				struct ioc_compat_sa_out_params *compat_out_prm;
+
+				compat_out_prm = &compat_prm->sa_out_params;
+				err = compat_copy_sa_out_iv(sa_out_iv,
+						compat_out_prm->init_vector,
+						COMPAT_US_TO_K);
+			} else
+#endif
+				if (copy_from_user(sa_out_iv,
+						   sa_out_prm->init_vector,
+						   sizeof(*sa_out_iv)))
+					err = -EINVAL;
+			if (err < 0) {
+				xx_pr_err("Error - copy SA out IV struct");
+				return err;
+			}
+			sa_out_prm->init_vector = sa_out_iv;
+
+			/* if the IV array is NULL, don't bother to copy it */
+			if (!sa_out_iv->init_vector)
+				goto copy_crypto_keys;
+
+			iv_array = (uint8_t *)xx_malloc(sa_out_iv->length);
+			if (!iv_array) {
+				xx_pr_err("Error - alloc SA out IV array");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+			if (copy_from_user(iv_array, sa_out_iv->init_vector,
+					   sa_out_iv->length)) {
+				xx_pr_err("Error - copy SA out IV array");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_iv->init_vector = iv_array;
+		}
+	} else {
+		/* handle any required memory transfer from US to K */
+		struct dpa_cls_tbl_action *cls_action;
+
+		cls_action = &prm->sa_in_params.post_ipsec_action;
+		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
+		    cls_action->enq_params.policer_params != NULL) {
+			policer_prm = xx_malloc(sizeof(*policer_prm));
+			if (!policer_prm) {
+				xx_pr_err("Error alloc CLS POL param");
+				return -ENOMEM;
+			}
+			if (copy_from_user(policer_prm,
+					  cls_action->enq_params.policer_params,
+					  sizeof(*policer_prm))) {
+				xx_pr_err("Error - copy CLS POL param");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			cls_action->enq_params.policer_params = policer_prm;
+		}
+	}
+
+copy_crypto_keys:
+	/*
+	 * allocate memory and copy the keys from userspace
+	 * (if required - if keys are not NULL)
+	 */
+	crypto_params = &prm->crypto_params;
+	if (crypto_params->auth_key) {
+		auth_key = (uint8_t *)xx_malloc(crypto_params->auth_key_len);
+		if (!auth_key) {
+			xx_pr_err("Couldn't allocate memory for SA auth key");
+			err = -ENOMEM;
+			goto free_create_sa_keys_mem;
+		}
+		if (copy_from_user(auth_key, crypto_params->auth_key,
+				   crypto_params->auth_key_len)) {
+			xx_pr_err("Could not copy SA auth key!");
+			err = -EINVAL;
+			goto free_create_sa_keys_mem;
+		}
+		crypto_params->auth_key = auth_key;
+	}
+
+	if (crypto_params->cipher_key) {
+		cipher_key =
+			(uint8_t *)xx_malloc(crypto_params->cipher_key_len);
+		if (!cipher_key) {
+			xx_pr_err("Couldn't allocate memory for SA cipher key");
+			err = -ENOMEM;
+			goto free_create_sa_keys_mem;
+		}
+		if (copy_from_user(cipher_key, crypto_params->cipher_key,
+				   crypto_params->cipher_key_len)) {
+			xx_pr_err("Could not copy SA auth key!");
+			err = -EINVAL;
+			goto free_create_sa_keys_mem;
+		}
+		crypto_params->cipher_key = cipher_key;
+	}
+
+	return 0;
+
+free_create_sa_keys_mem:
+	xx_free(auth_key);
+	xx_free(cipher_key);
+
+free_create_copied_sa_mem:
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		xx_free(iv_array);
+		xx_free(sa_out_iv);
+		xx_free(out_ip_hdr);
+		xx_free(out_udp_hdr);
+	} else
+		xx_free(policer_prm);
+
+	return err;
+}
+
+static int do_init_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_params prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_params compat_prm;
+#endif
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+	int err;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			xx_pr_err("Could not copy DPA IPSec init parameters");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			xx_pr_err("Could not copy DPA IPSec init parameters");
+			return -EINVAL;
+		}
+
+	/*
+	 * only the default allocation mechanism can be used when the using
+	 * IOCTLS to initialize and control a DPA IPSec instance
+	 */
+	if (prm.dpa_ipsec_params.fqid_pool) {
+		xx_pr_err("FQID pool option is not supported via IOCTLS");
+		return -EINVAL;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned int)prm.dpa_ipsec_params.fm_pcd);
+	if (!fm_pcd_file) {
+		xx_pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	prm.dpa_ipsec_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+	err = dpa_ipsec_init(&prm.dpa_ipsec_params,
+			     &prm.dpa_ipsec_id);
+	if (err < 0)
+		return err;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			xx_pr_err("Could not copy to user the DPA IPSec ID");
+			return -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			xx_pr_err("Could not copy to user the ID");
+			return -EINVAL;
+		}
+
+	return 0;
+}
+
+static int do_create_sa_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_sa_params prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_sa_params compat_prm;
+#endif
+	int err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			xx_pr_err("Could not copy SA parameters");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
+						COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			xx_pr_err("Could not copy SA parameters");
+			return -EINVAL;
+		}
+
+#ifdef CONFIG_COMPAT
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
+#else
+	err = do_copy_sa_params(&prm.sa_params);
+#endif
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_create_sa(prm.dpa_ipsec_id, &prm.sa_params, &prm.sa_id);
+	if (err < 0)
+		goto free_create_sa_mem;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
+						COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			xx_pr_err("Could not copy to user the SA ID");
+			err = -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			xx_pr_err("Could not copy to user the SA ID");
+			err = -EINVAL;
+		}
+
+free_create_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
+static int do_sa_rekey_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_rekey_prm prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_rekey_prm compat_prm;
+#endif
+	int err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			xx_pr_err("Could not copy SA rekeying params");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
+					       COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			xx_pr_err("Could not copy SA rekeying params");
+			return -EINVAL;
+		}
+
+#ifdef CONFIG_COMPAT
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
+#else
+	err = do_copy_sa_params(&prm.sa_params);
+#endif
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_sa_rekeying(prm.sa_id, &prm.sa_params,
+				    default_rekey_event_cb, prm.auto_rmv_old_sa,
+				    &prm.new_sa_id);
+	if (err < 0)
+		goto free_rekey_sa_mem;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
+					       COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			xx_pr_err("Could not copy to user new SA ID");
+			err = -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			xx_pr_err("Could not copy to user new SA ID");
+			err = -EINVAL;
+		}
+
+free_rekey_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
+static int do_sa_get_policies_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_get_policies prm;
+	struct dpa_ipsec_policy_params *policy_params;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_get_policies compat_prm;
+#endif
+	int sa_id, num_pol, err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			xx_pr_err("Could not copy params for policy retrieval");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
+					       COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			xx_pr_err("Could not copy params for policy retrieval");
+			return -EINVAL;
+		}
+
+	if (prm.sa_id < 0) {
+		xx_pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	sa_id = prm.sa_id;
+	if (!prm.policy_params) {
+		err = dpa_ipsec_sa_get_policies(sa_id, NULL, &num_pol);
+		if (err < 0) {
+			xx_pr_err("Get policies count failed\n");
+			return err;
+		}
+
+		prm.num_pol = num_pol;
+#ifdef CONFIG_COMPAT
+		if (compat) {
+			compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
+						       COMPAT_K_TO_US);
+		if (copy_to_user(args, &compat_prm, sizeof(compat_prm))) {
+				xx_pr_err("Cannot copy policy count to user");
+				return -EINVAL;
+			}
+		} else
+#endif
+			if (copy_to_user(args, &prm, sizeof(prm))) {
+				xx_pr_err("Cannot copy policy count to user");
+				return -EINVAL;
+			}
+		return 0;
+	}
+
+	num_pol = prm.num_pol;
+	if (num_pol <= 0) {
+		xx_pr_err("Invalid number of policies for SA ID# %d\n", sa_id);
+		return -EINVAL;
+	}
+
+	policy_params =	xx_zalloc(num_pol * sizeof(*policy_params));
+	if (!policy_params) {
+		xx_pr_err("Could not allocate memory for policy array");
+		return -ENOMEM;
+	}
+
+	err = dpa_ipsec_sa_get_policies(sa_id, policy_params, &num_pol);
+	if (err < 0 && err != -EAGAIN) {
+		xx_pr_err("Could not retrieve SA policies");
+		goto err_pol_cleanup;
+	} else if (err == -EAGAIN)
+		xx_pr_err("Not all SA policies could be retrieved");
+
+	if (copy_to_user(prm.policy_params, policy_params,
+			 num_pol * sizeof(*policy_params))) {
+		xx_pr_err("Could not return policy parameters\n");
+		err = -EINVAL;
+	}
+	/*
+	 * None of the values of the members in the input structure have been
+	 * modified, so there is no need to copy the input structure back to the
+	 * user
+	 */
+
+err_pol_cleanup:
+	xx_free(policy_params);
+
+	return err;
+}
 
 int wrp_dpa_ipsec_init(void)
 {
@@ -94,46 +793,32 @@ int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-
 long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
-			 unsigned long args)
+			    unsigned long args)
+{
+	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, false);
+}
+
+#ifdef CONFIG_COMPAT
+long wrp_dpa_ipsec_ioctl_compat(struct file *filp, unsigned int cmd,
+				unsigned long args)
+{
+	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, true);
+}
+#endif
+
+long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args, bool compat)
 {
 	long ret = 0;
 	int err = 0;
 
 	switch (cmd) {
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_INIT_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_INIT: {
-		struct ioc_dpa_ipsec_params prm;
-		struct file *fm_pcd_file;
-		t_LnxWrpFmDev *fm_wrapper_dev;
-		if (copy_from_user(&prm,
-				   (struct ioc_dpa_ipsec_params *) args,
-				    sizeof(prm))) {
-			xx_pr_err("Could not copy parameters ");
-			return -EINVAL;
-		}
-
-		/* Translate FM_PCD file descriptor */
-		fm_pcd_file = fcheck((unsigned int)
-					prm.dpa_ipsec_params.fm_pcd);
-		if (!fm_pcd_file) {
-			xx_pr_err("Could not acquire PCD handle");
-			return -EINVAL;
-		}
-		fm_wrapper_dev =
-			((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-		prm.dpa_ipsec_params.fm_pcd =
-				(void *)fm_wrapper_dev->h_PcdDev;
-
-		err = dpa_ipsec_init(&prm.dpa_ipsec_params,
-				     &prm.dpa_ipsec_id);
-		if (err < 0)
-			return err;
-
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user the SA id");
-			return -EINVAL;
-		}
+		ret = do_init_ioctl((void *)args, compat);
 		break;
 	}
 
@@ -150,24 +835,11 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_CREATE_SA_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_CREATE_SA: {
-		struct ioc_dpa_ipsec_sa_params prm;
-		if (copy_from_user(&prm,
-				(struct ioc_dpa_ipsec_sa_params *) args,
-				 sizeof(prm))) {
-			xx_pr_err("Could not copy parameters");
-			return -EINVAL;
-		}
-		err = dpa_ipsec_create_sa(prm.dpa_ipsec_id,
-					  &prm.sa_params,
-					  &prm.sa_id);
-		if (err < 0)
-			return err;
-
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user the SA id");
-			return -EINVAL;
-		}
+		ret = do_create_sa_ioctl((void *)args, compat);
 		break;
 	}
 
@@ -198,6 +870,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			return err;
 		break;
 	}
+
 	case DPA_IPSEC_IOC_REMOVE_POLICY: {
 		struct ioc_dpa_ipsec_add_rem_policy pol;
 		if (copy_from_user(&pol,
@@ -214,27 +887,11 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_SA_REKEYING_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_SA_REKEYING: {
-		struct ioc_dpa_ipsec_sa_rekeying_prm prm;
-
-		if (copy_from_user(&prm,
-			  (struct ioc_dpa_ipsec_sa_rekeying_prm *) args,
-			   sizeof(prm))) {
-			xx_pr_err("Could not copy parameters for rekeying");
-			return -EINVAL;
-		}
-
-		err = dpa_ipsec_sa_rekeying(prm.sa_id, &prm.sa_params,
-					    default_rekey_event_cb,
-					    prm.auto_rmv_old_sa,
-					    &prm.new_sa_id);
-		if (err < 0)
-			return err;
-
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user the SA id");
-			return -EINVAL;
-		}
+		ret = do_sa_rekey_ioctl((void *)args, compat);
 		break;
 	}
 
@@ -253,74 +910,11 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_GET_SA_POLICIES: {
-		struct ioc_dpa_ipsec_sa_get_policies prm, *in_prm;
-		int sa_id, num_pol;
-
-		in_prm = (struct ioc_dpa_ipsec_sa_get_policies *) args;
-		if (in_prm->sa_id < 0) {
-			xx_pr_err("Invalid input SA id\n");
-			return -EINVAL;
-		}
-
-		if (!in_prm->policy_params) {
-			if (!in_prm->num_pol) {
-				xx_pr_err("Invalid parameters\n");
-				return -EINVAL;
-			} else {
-				sa_id = in_prm->sa_id;
-				err = dpa_ipsec_sa_get_policies(sa_id,
-							NULL, &num_pol);
-				if (err < 0) {
-					xx_pr_err("Get policy count failed\n");
-					return err;
-				}
-				if (copy_to_user(in_prm->num_pol,
-						 &num_pol,
-						 sizeof(int))) {
-					xx_pr_err("Couldn't copy parameters\n");
-					return -EINVAL;
-				}
-				return 0;
-			}
-		}
-
-		sa_id = in_prm->sa_id;
-		if (copy_from_user(&num_pol,
-				   in_prm->num_pol, sizeof(int))) {
-			xx_pr_err("Could not copy user parameters\n");
-			return -EINVAL;
-		}
-		if (num_pol <= 0) {
-			xx_pr_err("Invalid number of policies for sa id %d\n",
-				  sa_id);
-			return -EINVAL;
-		}
-
-		prm.policy_params =
-			xx_zalloc(num_pol * sizeof(*prm.policy_params));
-		if (!prm.policy_params) {
-			xx_pr_err("No more memory");
-			return -ENOMEM;
-		}
-
-		err = dpa_ipsec_sa_get_policies(sa_id,
-						prm.policy_params,
-						&num_pol);
-		if (err < 0) {
-			xx_pr_err("Store policy failed");
-			ret = err;
-			goto err_pol_cleanup;
-		}
-
-		if (copy_to_user(in_prm->policy_params,
-				prm.policy_params,
-				num_pol * sizeof(*prm.policy_params))) {
-			xx_pr_err("Could not copy parameters\n");
-			ret = -EINVAL;
-		}
-err_pol_cleanup:
-		kfree(prm.policy_params);
+		ret = do_sa_get_policies_ioctl((void *)args, compat);
 		break;
 	}
 
@@ -353,44 +947,32 @@ err_pol_cleanup:
 	}
 
 	case DPA_IPSEC_IOC_GET_SA_STATS: {
-		struct ioc_dpa_ipsec_sa_get_stats prm, *in_prm;
-		int sa_id;
+		struct ioc_dpa_ipsec_sa_get_stats prm;
 
-		in_prm = (struct ioc_dpa_ipsec_sa_get_stats *)args;
-		if (in_prm->sa_id < 0) {
-			xx_pr_err("Invalid input SA id\n");
+		if (copy_from_user(&prm,
+				(struct ioc_dpa_ipsec_sa_get_stats *)args,
+				sizeof(prm))) {
+			xx_pr_err("Could not copy from user stats params");
 			return -EINVAL;
 		}
 
-		if (!in_prm->sa_stats) {
-			xx_pr_err("Invalid parameters\n");
+		if (prm.sa_id < 0) {
+			xx_pr_err("Invalid input SA id\n");
 			return -EINVAL;
 		}
 
-		sa_id = in_prm->sa_id;
-
-		prm.sa_stats = xx_zalloc(sizeof(*prm.sa_stats));
-		if (!prm.sa_stats) {
-			xx_pr_err("No more memory");
-			return -ENOMEM;
-		}
-
-		err = dpa_ipsec_sa_get_stats(sa_id, prm.sa_stats);
+		err = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
 		if (err < 0) {
 			xx_pr_err("Getting stats failed\n");
-			kfree(prm.sa_stats);
 			return err;
 		}
 
-		if (copy_to_user(in_prm->sa_stats, prm.sa_stats,
-				 sizeof(*prm.sa_stats))) {
-			xx_pr_err("Could not copy parameters\n");
-			kfree(prm.sa_stats);
+		if (copy_to_user((struct ioc_dpa_ipsec_sa_get_stats *)args,
+				 &prm, sizeof(prm))) {
+			xx_pr_err("Could not copy stats to user\n");
 			return -EINVAL;
 		}
 
-		kfree(prm.sa_stats);
-
 		break;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
index 6b04be3..f67abad 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
@@ -50,6 +50,11 @@ int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp);
 long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			 unsigned long args);
 
+#ifdef CONFIG_COMPAT
+long wrp_dpa_ipsec_ioctl_compat(struct file *filp, unsigned int cmd,
+				unsigned long args);
+#endif
+
 int default_rekey_event_cb(int dpa_ipsec_id, int sa_id, int error);
 
 #endif	/* WRP_DPA_IPSEC_H_ */
-- 
1.7.5.4

