From d78fe78b5e65e542a19f23c12ab8e8862fbc41e0 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Tue, 7 Aug 2012 21:47:17 +0000
Subject: [PATCH 262/518] Update manipulation objects management

Some features of the DPA IPSec component require the use of special
purpose uCode header manipulations. Proper management of the objects
used to control these header manipulations is very important because
these are all allocated in the MURAM.

Add the following optimizations:
- do not create frag manipulation object if MTU = 0;
- do not create a new manipulation object for policies attached to
outbound SAs if only the DSCP / ECN feature is required
- outbound child SAs inherit parent's generic (for DSCP / ECN)
manipulation objects

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  122 +++++++++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    1 -
 2 files changed, 85 insertions(+), 38 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index e6b82ee..976410c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1153,6 +1153,12 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	BUG_ON(!out_frag);
 	BUG_ON(!frag_hmd);
 
+	if (!out_frag->mtu) {
+		/* no need to create a manipulation object */
+		*frag_hmd = DPA_OFFLD_DESC_NONE;
+		return 0;
+	}
+
 	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
 	frag_param = &pcd_manip_params.u.frag;
 	pcd_manip_params.type = e_FM_PCD_MANIP_FRAG;
@@ -1187,8 +1193,8 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd,
 	BUG_ON(!hmd);
 
 	if (!sa->use_var_iphdr_len && !sa->dscp_copy && !sa->ecn_copy) {
-		/* no need to create a manipulation object */
-		*hmd = DPA_OFFLD_DESC_NONE;
+		/* no need to create a new manipulation objects chain */
+		*hmd = next_hmd;
 		return 0;
 	}
 
@@ -1323,7 +1329,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_entry_mod_params params;
 	int table, err;
-	int hmd;
+	int frag_hmd = DPA_OFFLD_DESC_NONE, pol_hmd = DPA_OFFLD_DESC_NONE;
 	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 
@@ -1375,7 +1381,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 						DPA_IPSEC_POL_DIR_PARAMS_FRAG) {
 			err = create_frag_manip(dpa_ipsec,
 					       &pol_params->dir_params.out_frag,
-					       &policy_entry->hmd);
+					       &frag_hmd);
 			if (err < 0) {
 				pr_err("Could not create Manip node for fragmentation!\n");
 				return -EAGAIN;
@@ -1383,21 +1389,35 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		}
 
 		/* Init IPSec Manip. object (if required) for outbound policy */
-		err = create_ipsec_manip(sa,
-					policy_entry->hmd,
-					&policy_entry->ipsec_hmd);
-		if (err < 0) {
-			xx_pr_err("Could not create Manip obj for policy!\n");
-			return err;
+		if (frag_hmd != DPA_OFFLD_DESC_NONE) {
+			/* need to chain the IPSec Manip and Frag Manip */
+			err = create_ipsec_manip(sa, frag_hmd,
+						 &policy_entry->hmd);
+			if (err < 0) {
+				pr_err("Couldn't create policy manip chain!\n");
+				return err;
+			}
+			pol_hmd = policy_entry->hmd;
+		} else {
+			if (sa->ipsec_hmd == DPA_OFFLD_DESC_NONE) {
+				/*
+				 * need to create the IPSec Manip (per SA),
+				 * if it was not created earlier
+				 */
+				err = create_ipsec_manip(sa,
+							 DPA_OFFLD_DESC_NONE,
+							 &sa->ipsec_hmd);
+				if (err < 0) {
+					pr_err("Couldn't create SA manip!\n");
+					return err;
+				}
+			}
+			pol_hmd = sa->ipsec_hmd;
 		}
-		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE)
-			hmd = policy_entry->ipsec_hmd;
-		else
-			hmd = policy_entry->hmd;
 
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-				    qman_fq_fqid((sa->to_sec_fq)), hmd);
+				    qman_fq_fqid((sa->to_sec_fq)), pol_hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 					      policy_entry->pol_params.priority,
@@ -1415,34 +1435,25 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			return err;
 		}
 
-		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_manip(policy_entry->ipsec_hmd);
-			if (err < 0) {
-				xx_pr_err("Couldn't delete ipsec manip\n");
-				return err;
-			}
-			policy_entry->ipsec_hmd = DPA_OFFLD_DESC_NONE;
-		}
-
 		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE) {
 			err = destroy_manip(policy_entry->hmd);
 			if (err < 0) {
-				pr_err("Couldn't delete frag manip\n");
+				pr_err("Couldn't delete frag & ipsec manip\n");
 				return err;
 			}
 			policy_entry->hmd = DPA_OFFLD_DESC_NONE;
 		}
+
 		break;
 	case MNG_OP_MODIFY:
-		if (policy_entry->ipsec_hmd != DPA_OFFLD_DESC_NONE)
-			hmd = policy_entry->ipsec_hmd;
+		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE)
+			pol_hmd = policy_entry->hmd;
 		else
-			hmd = policy_entry->hmd;
+			pol_hmd = sa->ipsec_hmd;
 
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-				    qman_fq_fqid((sa->to_sec_fq)),
-				    policy_entry->hmd);
+				    qman_fq_fqid((sa->to_sec_fq)), pol_hmd);
 
 		memset(&params, 0, sizeof(params));
 		params.type = DPA_CLS_TBL_MODIFY_ACTION;
@@ -2282,6 +2293,9 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 		return -ENOMEM;
 	}
 
+	/* Initialize the policy Manip handle to an invalid value */
+	pol_entry->hmd = DPA_OFFLD_DESC_NONE;
+
 	/* copy policy parameters */
 	pol_entry->pol_params = *policy_params;
 
@@ -2651,7 +2665,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
 		err_rb = destroy_manip(sa->ipsec_hmd);
 		if (err_rb < 0) {
-			xx_pr_err("Could not delete manip object!\n");
+			pr_err("Could not delete manip object!\n");
 			return err_rb;
 		}
 		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
@@ -2709,7 +2723,7 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
 		err_rb = destroy_manip(sa->ipsec_hmd);
 		if (err_rb < 0) {
-			xx_pr_err("Could not delete manip object!\n");
+			pr_err("Could not delete manip object!\n");
 			return err_rb;
 		}
 		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
@@ -2862,12 +2876,15 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		goto create_sa_err;
 	}
 
+	/* Initialize the SA Manip handle to an invalid value */
+	sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
+
 	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		err = create_ipsec_manip(sa, DPA_OFFLD_DESC_NONE,
 			&sa->ipsec_hmd);
 		if (err < 0) {
-			xx_pr_err("Could not create Manip object for in SA!\n");
+			pr_err("Could not create Manip object for in SA!\n");
 			goto create_sa_err;
 		}
 	}
@@ -3017,11 +3034,11 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 				return err;
 		}
 
-		if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
-				(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
+		/* destroy SA manip */
+		if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
 			err = destroy_manip(sa->ipsec_hmd);
 			if (err < 0) {
-				xx_pr_err("Could not delete manip object!\n");
+				pr_err("Could not delete manip object!\n");
 				return err;
 			}
 			sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
@@ -3097,6 +3114,16 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 			return err;
 	}
 
+	/* destroy SA manip */
+	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
+		err = destroy_manip(sa->ipsec_hmd);
+		if (err < 0) {
+			pr_err("Could not delete manip object!\n");
+			return err;
+		}
+		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
+	}
+
 	/* Destroy the TO_SEC and FROM_SEC queues */
 	err = remove_sa_fq_pair(sa);
 	if (err != 0) {
@@ -3214,6 +3241,16 @@ static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
 		return err;
 	}
 
+	/* destroy SA manip, if one was initialized */
+	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
+		err = destroy_manip(sa->ipsec_hmd);
+		if (err < 0) {
+			pr_err("Couldn't delete SA manip\n");
+			return err;
+		}
+		sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
+	}
+
 	/* Destroy the TO_SEC and FROM_SEC queues */
 	err = remove_sa_fq_pair(sa);
 	if (err < 0) {
@@ -3523,6 +3560,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	mutex_lock(&new_sa->lock);
 	new_sa->dpa_ipsec = old_sa->dpa_ipsec;
 	new_sa->inbound_flowid = old_sa->inbound_flowid;
+	new_sa->ipsec_hmd = old_sa->ipsec_hmd;
 	new_sa->inbound_indx_entry = -1;
 	new_sa->rekey_event_cb = rekey_event_cb;
 	if (auto_rmv_old_sa) {
@@ -3555,7 +3593,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		err = create_ipsec_manip(new_sa, DPA_OFFLD_DESC_NONE,
 			&new_sa->ipsec_hmd);
 		if (err < 0) {
-			xx_pr_err("Could not create Manip object for in SA!\n");
+			pr_err("Could not create Manip object for in SA!\n");
 			goto rekey_sa_err;
 		}
 	}
@@ -3831,6 +3869,16 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 			if (err == -ENOTRECOVERABLE)
 				return err;
 		}
+
+		/* destroy SA manip */
+		if (old_sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
+			err = destroy_manip(old_sa->ipsec_hmd);
+			if (err < 0) {
+				pr_err("Could not delete manip object!\n");
+				return err;
+			}
+			old_sa->ipsec_hmd = DPA_OFFLD_DESC_NONE;
+		}
 	}
 
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 1b106d4..6d04279 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -346,7 +346,6 @@ struct dpa_ipsec_policy_entry {
 	struct dpa_ipsec_policy_params pol_params; /* Policy parameters       */
 	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
 	int hmd;		/* Header manip for frag      */
-	int ipsec_hmd; /* Manip obj used for special IPSec functions      */
 	struct list_head node;	/* Node in linked list			      */
 };
 
-- 
1.7.5.4

