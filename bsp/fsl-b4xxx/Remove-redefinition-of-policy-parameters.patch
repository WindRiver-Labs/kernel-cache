From 27be3b6b52f2da3444bffa10b658bf26e685ae26 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:13 +0000
Subject: [PATCH 235/518] Remove redefinition of policy parameters

Remove internal dpa_ipsec_policy_selectors structure which includes
a subset of the fields of the dpa_ipsec_policy_parameters structure,
thus optimizing security policy processing.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  127 ++++++++++-----------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   31 +++----
 2 files changed, 60 insertions(+), 98 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 337ed31..b3e625d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -992,7 +992,7 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 }
 
 static int fill_policy_key(int td,
-			   struct dpa_ipsec_policy_selectors *pol_sel,
+			   struct dpa_ipsec_policy_params *pol_params,
 			   uint8_t key_fields,
 			   uint8_t *key, uint8_t *mask, uint8_t *key_len)
 {
@@ -1000,7 +1000,7 @@ static int fill_policy_key(int td,
 	uint8_t offset = 0, field_mask = 0, tbl_key_size = 0;
 	int err = 0, i;
 
-	BUG_ON(!pol_sel);
+	BUG_ON(!pol_params);
 	BUG_ON(!key);
 	BUG_ON(!mask);
 	BUG_ON(!key_len);
@@ -1011,66 +1011,66 @@ static int fill_policy_key(int td,
 		switch (key_fields & field_mask) {
 		case DPA_IPSEC_KEY_FIELD_SIP:
 			memcpy(key + offset,
-			       IP_ADDR(pol_sel->src_addr),
-			       IP_ADDR_LEN(pol_sel->src_addr));
+			       IP_ADDR(pol_params->src_addr),
+			       IP_ADDR_LEN(pol_params->src_addr));
 			err = set_ip_addr_mask(mask + offset,
-					       pol_sel->src_prefix_len,
-					       IP_ADDR_LEN(pol_sel->src_addr));
+					     pol_params->src_prefix_len,
+					     IP_ADDR_LEN(pol_params->src_addr));
 			if (err < 0)
 				return err;
-			offset += IP_ADDR_LEN(pol_sel->src_addr);
+			offset += IP_ADDR_LEN(pol_params->src_addr);
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DIP:
 			memcpy(key + offset,
-			       IP_ADDR(pol_sel->dest_addr),
-			       IP_ADDR_LEN(pol_sel->dest_addr));
+			       IP_ADDR(pol_params->dest_addr),
+			       IP_ADDR_LEN(pol_params->dest_addr));
 			err = set_ip_addr_mask(mask + offset,
-					       pol_sel->dest_prefix_len,
-					       IP_ADDR_LEN(pol_sel->dest_addr));
+					    pol_params->dest_prefix_len,
+					    IP_ADDR_LEN(pol_params->dest_addr));
 			if (err < 0)
 				return err;
-			offset += IP_ADDR_LEN(pol_sel->dest_addr);
+			offset += IP_ADDR_LEN(pol_params->dest_addr);
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_PROTO:
-			SET_BYTE_VAL_IN_ARRAY(key, offset, pol_sel->protocol);
-			SET_IP_PROTO_MASK(mask, offset, pol_sel->masked_proto);
+		      SET_BYTE_VAL_IN_ARRAY(key, offset, pol_params->protocol);
+		      SET_IP_PROTO_MASK(mask, offset, pol_params->masked_proto);
 			offset += IP_PROTO_FIELD_LEN;
 			break;
 
 		/* case DPA_IPSEC_KEY_FIELD_ICMP_TYPE: */
 		case DPA_IPSEC_KEY_FIELD_SPORT:
-			if (pol_sel->protocol == IPPROTO_ICMP) {
+			if (pol_params->protocol == IPPROTO_ICMP) {
 				SET_BYTE_VAL_IN_ARRAY(key, offset,
-						      pol_sel->icmp.icmp_type);
+						    pol_params->icmp.icmp_type);
 				SET_BYTE_VAL_IN_ARRAY(mask, offset,
-						  pol_sel->icmp.icmp_type_mask);
+					       pol_params->icmp.icmp_type_mask);
 				offset += ICMP_HDR_FIELD_LEN;
 			} else {
 				memcpy(key + offset,
-				       (uint8_t *) &(pol_sel->l4.src_port),
+				       (uint8_t *) &(pol_params->l4.src_port),
 				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-						 pol_sel->l4.src_port_mask);
+						 pol_params->l4.src_port_mask);
 				offset += PORT_FIELD_LEN;
 			}
 			break;
 
 		/* case DPA_IPSEC_KEY_FIELD_ICMP_CODE: */
 		case DPA_IPSEC_KEY_FIELD_DPORT:
-			if (pol_sel->protocol == IPPROTO_ICMP) {
+			if (pol_params->protocol == IPPROTO_ICMP) {
 				SET_BYTE_VAL_IN_ARRAY(key, offset,
-						      pol_sel->icmp.icmp_code);
+						    pol_params->icmp.icmp_code);
 				SET_BYTE_VAL_IN_ARRAY(mask, offset,
-						  pol_sel->icmp.icmp_code_mask);
+					       pol_params->icmp.icmp_code_mask);
 				offset += ICMP_HDR_FIELD_LEN;
 			} else {
 				memcpy(key + offset,
-				       (uint8_t *) &(pol_sel->l4.dest_port),
+				       (uint8_t *) &(pol_params->l4.dest_port),
 				       PORT_FIELD_LEN);
 				SET_L4_PORT_MASK(mask, offset,
-						 pol_sel->l4.dest_port_mask);
+						 pol_params->l4.dest_port_mask);
 				offset += PORT_FIELD_LEN;
 			}
 			break;
@@ -1151,10 +1151,11 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	frag_param = &pcd_manip_params.u.frag;
 	pcd_manip_params.type = e_FM_PCD_MANIP_FRAG;
 	frag_param->hdr  = HEADER_TYPE_IPv4;
-	frag_param->u.ipFrag.sizeForFragmentation = policy_entry->mtu;
+	frag_param->u.ipFrag.sizeForFragmentation =
+						policy_entry->pol_params.mtu;
 	frag_param->u.ipFrag.scratchBpid = dpa_ipsec->config.ipf_bpid;
 	frag_param->u.ipFrag.dontFragAction =
-			pcd_df_action[policy_entry->df_action];
+			pcd_df_action[policy_entry->pol_params.df_action];
 	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
 	if (!*hm) {
 		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
@@ -1221,7 +1222,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 				 enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	struct dpa_ipsec_policy_selectors *policy_selectors;
+	struct dpa_ipsec_policy_params *pol_params;
 	uint8_t key_len;
 	struct dpa_cls_tbl_action *action;
 	struct dpa_cls_tbl_key tbl_key;
@@ -1237,7 +1238,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 
 	dpa_ipsec = sa->dpa_ipsec;
 	BUG_ON(!dpa_ipsec);
-	policy_selectors = &policy_entry->policy_selectors;
+	pol_params = &policy_entry->pol_params;
 
 	switch (op_type) {
 	case MNG_OP_ADD:
@@ -1251,7 +1252,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		 * DST_PORT	- from Policy handle (for UDP & TCP)
 		 */
 		err = fill_policy_key(sa->em_inpol_td,
-				      policy_selectors,
+				      pol_params,
 				      dpa_ipsec->config.post_sec_in_params.
 				      key_fields, tbl_key.byte, tbl_key.mask,
 				      &key_len);
@@ -1260,9 +1261,9 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 
 		action = &sa->def_sa_action;
 		err = dpa_classif_table_insert_entry(sa->em_inpol_td, &tbl_key,
-						     action,
-						     policy_entry->priority,
-						     &entry_id);
+					      action,
+					      policy_entry->pol_params.priority,
+					      &entry_id);
 		if (err < 0) {
 			pr_err("Could not insert key in EM table\n");
 			return err;
@@ -1292,7 +1293,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
-	struct dpa_ipsec_policy_selectors *policy_selectors;
+	struct dpa_ipsec_policy_params *pol_params;
 	uint8_t key_len, table_idx, key_fields;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
@@ -1307,11 +1308,11 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	BUG_ON(!dpa_ipsec);
 	pre_sec_out_params = &dpa_ipsec->config.pre_sec_out_params;
 
-	policy_selectors = &policy_entry->policy_selectors;
-	if (IP_ADDR_TYPE_IPV4(policy_selectors->dest_addr))
-		table_idx = GET_POL_TABLE_IDX(policy_selectors->protocol, IPV4);
+	pol_params = &policy_entry->pol_params;
+	if (IP_ADDR_TYPE_IPV4(pol_params->dest_addr))
+		table_idx = GET_POL_TABLE_IDX(pol_params->protocol, IPV4);
 	else
-		table_idx = GET_POL_TABLE_IDX(policy_selectors->protocol, IPV6);
+		table_idx = GET_POL_TABLE_IDX(pol_params->protocol, IPV6);
 	table = pre_sec_out_params->table[table_idx].dpa_cls_td;
 	key_fields = pre_sec_out_params->table[table_idx].key_fields;
 
@@ -1335,13 +1336,13 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		 * SRC_PORT     - from Policy handle (for UDP & TCP & SCTP)
 		 * DST_PORT     - from Policy handle (for UDP & TCP & SCTP)
 		 */
-		err = fill_policy_key(table, policy_selectors, key_fields,
+		err = fill_policy_key(table, pol_params, key_fields,
 				tbl_key.byte, tbl_key.mask, &key_len);
 		if (err < 0)
 			return err;
 
 		/* Configure fragmentation */
-		if (policy_entry->mtu) {
+		if (pol_params->mtu) {
 			err = create_frag_manip(dpa_ipsec, policy_entry, &hm);
 			if (err < 0) {
 				pr_err("Could not create Manip node for fragmentation!\n");
@@ -1365,9 +1366,9 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		fill_cls_action_enq(&action, FALSE,
 				    qman_fq_fqid((sa->to_sec_fq)), hm);
 
-		err = dpa_classif_table_insert_entry(table, &tbl_key,
-						&action, policy_entry->priority,
-						&policy_entry->entry_id);
+		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
+					      policy_entry->pol_params.priority,
+					      &policy_entry->entry_id);
 		if (err < 0) {
 			pr_err("Could not add key in exact match table\n");
 			return err;
@@ -2195,23 +2196,6 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	return 0;
 }
 
-static void copy_policy_selectors(struct dpa_ipsec_policy_params *policy_params,
-			struct dpa_ipsec_policy_selectors *policy_selectors)
-{
-	/* TODO: find a better way to do this */
-	policy_selectors->src_addr = policy_params->src_addr;
-	policy_selectors->src_prefix_len = policy_params->src_prefix_len;
-	policy_selectors->dest_addr = policy_params->dest_addr;
-	policy_selectors->dest_prefix_len = policy_params->dest_prefix_len;
-	policy_selectors->protocol = policy_params->protocol;
-	policy_selectors->masked_proto = policy_params->masked_proto;
-	/*
-	 * copy the bigger structure in the union to ensure that all memory is
-	 * initialized
-	 */
-	policy_selectors->l4 = policy_params->l4;
-}
-
 static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 				struct dpa_ipsec_policy_params *policy_params,
 				struct dpa_ipsec_policy_entry **policy_entry)
@@ -2227,10 +2211,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 		pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
 	}
-	copy_policy_selectors(policy_params, &pol_entry->policy_selectors);
-	pol_entry->mtu = policy_params->mtu;
-	pol_entry->df_action = policy_params->df_action;
-	pol_entry->priority = policy_params->priority;
+	pol_entry->pol_params = *policy_params;
 	list_add(&pol_entry->node, &sa->policy_headlist);
 
 	*policy_entry = pol_entry;
@@ -2243,7 +2224,6 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 				struct dpa_ipsec_policy_entry **policy_entry)
 {
 	struct dpa_ipsec_policy_entry *pol_entry, *tmp_policy_entry;
-	struct dpa_ipsec_policy_selectors pol_sel;
 
 	BUG_ON(!sa);
 	BUG_ON(!policy_params);
@@ -2254,12 +2234,11 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 		return -EDOM;
 	}
 
-	copy_policy_selectors(policy_params, &pol_sel);
 	list_for_each_entry_safe(pol_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
-		if (!memcmp(&pol_entry->policy_selectors, &pol_sel,
-				sizeof(pol_sel)) &&
-		    pol_entry->priority == policy_params->priority) {
+		if (!memcmp(&pol_entry->pol_params, &policy_params,
+			    POL_MATCH_SIZE(policy_params)) &&
+		    pol_entry->pol_params.priority == policy_params->priority) {
 			/* found entry matching the input policy parameters */
 			*policy_entry = pol_entry;
 			return 0;
@@ -2304,9 +2283,6 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
-		struct dpa_ipsec_policy_params *pol_param;
-		struct dpa_ipsec_policy_selectors *pol_sel;
-
 		pol_count++;
 		if (pol_count > num_pol) {
 			pr_err("Num policies in this SA greater than %d",
@@ -2314,14 +2290,7 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 			return -EAGAIN;
 		}
 
-		pol_param = (struct dpa_ipsec_policy_params *)policy_entry;
-		pol_sel = (struct dpa_ipsec_policy_selectors *)
-				&policy_params[pol_count - 1];
-		copy_policy_selectors(pol_param, pol_sel);
-		policy_params[pol_count - 1].mtu = policy_entry->mtu;
-		policy_params[pol_count - 1].df_action =
-						policy_entry->df_action;
-		policy_params[pol_count - 1].priority = policy_entry->priority;
+		policy_params[pol_count - 1] = policy_entry->pol_params;
 	}
 
 	return 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index c2a367f..b15fa29 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -186,6 +186,16 @@
 
 #define INVALID_INB_FLOW_ID	0xFFFF
 
+/*
+ * calculate the size of the fields in the policy params structure that
+ * are used to identify a policy
+ */
+#define POL_MATCH_SIZE(pol_params) \
+	(sizeof(pol_params->src_addr) + sizeof(pol_params->src_prefix_len) + \
+	 sizeof(pol_params->dest_addr) + sizeof(pol_params->dest_prefix_len) + \
+	 sizeof(pol_params->protocol) + sizeof(pol_params->masked_proto) + \
+	 sizeof(pol_params->l4))
+
 /* DPA IPSec Encryption & authentication algorithm identifiers */
 struct ipsec_alg_suite {
 	uint16_t	enc_alg;
@@ -331,28 +341,11 @@ struct dpa_ipsec {
 	struct mutex lock; /* Lock for this dpa_ipsec instance */
 };
 
-/* DPA IPSEC - Security Policy Selectors */
-struct dpa_ipsec_policy_selectors {
-	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
-	uint8_t src_prefix_len;	/* Source network prefix		      */
-	struct dpa_ipsec_ip_address dest_addr;	/**< Destination IP address   */
-	uint8_t dest_prefix_len; /* Destination network prefix		      */
-	uint8_t protocol;	/* Protocol				      */
-	bool masked_proto;	/* Mask the entire protocol field	      */
-	union {
-		struct dpa_ipsec_l4_params	l4;	/* L4 protos params   */
-		struct dpa_ipsec_icmp_params	icmp;	/* ICMP proto params  */
-	};
-};
-
 /* DPA IPSEC - Security Policy Parameter Entry */
 struct dpa_ipsec_policy_entry {
-	struct dpa_ipsec_policy_selectors policy_selectors;/* Policy selectors*/
-	uint16_t mtu;	/* Maximum size of packets matching policy selectors  */
-	enum dpa_ipsec_df_action df_action;	/* Action when DF bit is set  */
-	int priority;		/* Policy priority                            */
+	struct dpa_ipsec_policy_params pol_params; /* Policy parameters       */
 	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
-	struct dpa_cls_tbl_header_manip *hm;	/* Header manipulation        */
+	struct dpa_cls_tbl_header_manip *hm;	/* Header manip for frag      */
 	void *ipsec_manip; /* Manip obj used for special IPSec functions      */
 	struct list_head node;	/* Node in linked list			      */
 };
-- 
1.7.5.4

