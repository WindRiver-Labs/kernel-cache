From ab9c1e0fdf225af4456b4dfa7641848d4f85641d Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:09 +0000
Subject: [PATCH 231/518] Remove dependency on QMan FQID management
 (qman_fqid_pool_*) API

Allow the upper layer to specify a range of FQIDs to be used by the
DPA IPSec instance for internal queues, without requiring that a
qman_fqid_pool object to be initialized.

This removes the limitations relatetd to the used of a
qman_fqid_pool and also removes the dependency of the DPA IPSec API
on QMan driver API.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c       |   77 +++++++++++++++++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h       |    4 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |    2 +-
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |   40 +++++++----
 include/linux/fsl_dpa_ipsec.h                     |   12 +++-
 5 files changed, 110 insertions(+), 25 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 30c9ad1..a7229df 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -219,7 +219,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	const struct dpa_ipsec_pre_sec_out_params *pre_sec_out_prms;
 	const struct dpa_ipsec_pre_sec_in_params *pre_sec_in_prms;
 	struct dpa_cls_tbl_params table_params;
-	int i, err, valid_tables = 0;
+	int i, err, valid_tables = 0, fqid_range_size, min_fqid_num;
 
 	if (!prms) {
 		pr_err("Invalid DPA IPsec parameters handle\n");
@@ -346,6 +346,17 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
+	/* Verify the parameters of the FQID range - if one was provided */
+	if (prms->fqid_range) {
+		fqid_range_size = prms->fqid_range->end_fqid -
+						prms->fqid_range->start_fqid;
+		min_fqid_num = prms->max_sa_pairs * 2 * NUM_FQS_PER_SA;
+		if (fqid_range_size <= 0 || fqid_range_size <  min_fqid_num) {
+			pr_err("Insufficient number of FQIDs in range!\n");
+			return -EINVAL;
+		}
+	}
+
 	return 0;
 }
 
@@ -617,6 +628,46 @@ static void put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 	mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
 }
 
+/* initialize fqid management CQ */
+static int create_fqid_cq(struct dpa_ipsec *dpa_ipsec)
+{
+	struct dpa_ipsec_fqid_range *fqid_range;
+	struct cq *fqid_cq;
+	int i;
+
+	BUG_ON(!dpa_ipsec);
+
+	if (dpa_ipsec->config.fqid_range) {
+		fqid_range = dpa_ipsec->config.fqid_range;
+		fqid_cq = cq_new(fqid_range->end_fqid - fqid_range->start_fqid,
+				 sizeof(uint32_t));
+		if (!fqid_cq) {
+			pr_err("Could not create CQ for FQID management!\n");
+			return -ENOMEM;
+		}
+
+		dpa_ipsec->sa_mng.fqid_cq = fqid_cq;
+
+		/* fill the CQ */
+		for (i = fqid_range->start_fqid; i < fqid_range->end_fqid; i++)
+			if (cq_put_4bytes(fqid_cq, (uint16_t)i) < 0) {
+				pr_err("Could not fill fqid management CQ!\n");
+				return -EDOM;
+			}
+	}
+
+	return 0;
+}
+
+/* destroy the FQID management CQ - if one was initialized */
+static inline void destroy_fqid_cq(struct dpa_ipsec *dpa_ipsec)
+{
+	if (dpa_ipsec->sa_mng.fqid_cq) {
+		cq_delete(dpa_ipsec->sa_mng.fqid_cq);
+		dpa_ipsec->sa_mng.fqid_cq = NULL;
+	}
+}
+
 /*
  * Create a circular queue with id's for aquiring SA's handles
  * Allocate a maximum number of SA internal structures to be used at runtime.
@@ -650,6 +701,13 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		}
 	}
 
+	/* initialize the circular queue for FQIDs management */
+	err = create_fqid_cq(dpa_ipsec);
+	if (err < 0) {
+		pr_err("Could not initialize FQID management mechanism!\n");
+		return err;
+	}
+
 	/* alloc SA array */
 	sa = kzalloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa), GFP_KERNEL);
 	if (!sa) {
@@ -849,6 +907,9 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 		sa_mng->sa_id_cq = NULL;
 	}
 
+	/* destroy fqid management CQ */
+	destroy_fqid_cq(dpa_ipsec);
+
 	/* release inbound flow ID management CQ */
 	destroy_inbound_flowid_cq(dpa_ipsec->sa_mng.inbound_flowid_cq);
 	dpa_ipsec->sa_mng.inbound_flowid_cq = NULL;
@@ -1559,10 +1620,10 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 	BUG_ON(!dpa_ipsec);
 	BUG_ON(!fqid);
 
-	if (dpa_ipsec->config.fqid_pool != NULL) {
-		err = qman_fqid_pool_alloc(dpa_ipsec->config.fqid_pool, fqid);
+	if (dpa_ipsec->sa_mng.fqid_cq != NULL) {
+		err = cq_get_4bytes(dpa_ipsec->sa_mng.fqid_cq, fqid);
 		if (err < 0)
-			pr_err("FQID allocation (from pool) failure."
+			pr_err("FQID allocation (from range) failure."
 				   "QMan error code %d\n", err);
 		return err;
 	}
@@ -1580,6 +1641,7 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 static void put_free_fqid(uint32_t fqid)
 {
 	struct dpa_ipsec *dpa_ipsec;
+	int err;
 
 	if (!gbl_dpa_ipsec) {
 		pr_err("There is no DPA IPSec instance initialized\n");
@@ -1588,9 +1650,10 @@ static void put_free_fqid(uint32_t fqid)
 	dpa_ipsec = gbl_dpa_ipsec;
 
 	/* recycle the FQID */
-	if (dpa_ipsec->config.fqid_pool != NULL)
-		qman_fqid_pool_free(dpa_ipsec->config.fqid_pool, fqid);
-	else
+	if (dpa_ipsec->sa_mng.fqid_cq != NULL) {
+		err = cq_put_4bytes(dpa_ipsec->sa_mng.fqid_cq, fqid);
+		BUG_ON(err < 0);
+	} else
 		qman_release_fqid(fqid);
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index eb3499e..5b76fbc 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -174,6 +174,9 @@
 #define MAX_AUTH_KEY_LEN    256
 #define MAX_BUFFER_POOL_ID  63
 
+/* number of FQs that will be created internally for each SA */
+#define NUM_FQS_PER_SA		2
+
 #define UDP_HEADER_LEN		8
 #define NEXT_HEADER_IS_IPv4	0x04
 
@@ -312,6 +315,7 @@ struct dpa_ipsec_sa_mng {
 						   currently in the rekeying
 						   process                    */
 	struct mutex sa_rekeying_headlist_lock; /* Lock for the rekeying list */
+	struct cq *fqid_cq; /* Circular queue with FQIDs for internal FQs     */
 };
 
 /* DPA IPSEC - Control Block */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index fe21540..ab6a089 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -57,7 +57,7 @@ struct ioc_compat_ipsec_init_params {
 	compat_uptr_t fm_pcd;
 	uint16_t qm_sec_ch;
 	uint16_t max_sa_pairs;
-	compat_uptr_t fqid_pool;
+	compat_uptr_t fqid_range;
 	uint8_t ipf_bpid;
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index a3bf493..dad5b03 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -81,8 +81,8 @@ static void compat_copy_dpa_ipsec_init(struct ioc_dpa_ipsec_params *prm,
 
 	if (compat == COMPAT_US_TO_K) {
 		init_prm->fm_pcd = (void *)compat_ptr(init_compat_prm->fm_pcd);
-		init_prm->fqid_pool = (struct qman_fqid_pool *)
-					compat_ptr(init_compat_prm->fqid_pool);
+		init_prm->fqid_range = (struct dpa_ipsec_fqid_range *)
+					compat_ptr(init_compat_prm->fqid_range);
 		init_prm->ipf_bpid = init_compat_prm->ipf_bpid;
 		init_prm->max_sa_pairs = init_compat_prm->max_sa_pairs;
 		init_prm->post_sec_in_params =
@@ -490,6 +490,7 @@ static int do_init_ioctl(void *args, bool compat)
 #ifdef CONFIG_COMPAT
 	struct ioc_compat_dpa_ipsec_params compat_prm;
 #endif
+	struct dpa_ipsec_fqid_range *fqid_range = NULL;
 	struct file *fm_pcd_file;
 	t_LnxWrpFmDev *fm_wrapper_dev;
 	int err;
@@ -508,27 +509,35 @@ static int do_init_ioctl(void *args, bool compat)
 			return -EINVAL;
 		}
 
-	/*
-	 * only the default allocation mechanism can be used when the using
-	 * IOCTLS to initialize and control a DPA IPSec instance
-	 */
-	if (prm.dpa_ipsec_params.fqid_pool) {
-		pr_err("FQID pool option is not supported via IOCTLS");
-		return -EINVAL;
+	/* copy FQID range params - if configured */
+	if (prm.dpa_ipsec_params.fqid_range) {
+		fqid_range = kmalloc(sizeof(*fqid_range), GFP_KERNEL);
+		if (!fqid_range) {
+			pr_err("FQID range allocation failed!\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(prm.dpa_ipsec_params.fqid_range, fqid_range,
+				   sizeof(*fqid_range))) {
+			pr_err("Could not copy FQID range params!\n");
+			err = -EINVAL;
+			goto free_ipsec_init_mem;
+		}
+		prm.dpa_ipsec_params.fqid_range = fqid_range;
 	}
 
 	/* Translate FM_PCD file descriptor */
 	fm_pcd_file = fcheck((unsigned int)prm.dpa_ipsec_params.fm_pcd);
 	if (!fm_pcd_file) {
 		pr_err("Could not acquire PCD handle");
-		return -EINVAL;
+		err = -EINVAL;
+		goto free_ipsec_init_mem;
 	}
 	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
 	prm.dpa_ipsec_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 	err = dpa_ipsec_init(&prm.dpa_ipsec_params,
 			     &prm.dpa_ipsec_id);
 	if (err < 0)
-		return err;
+		goto free_ipsec_init_mem;
 
 #ifdef CONFIG_COMPAT
 	if (compat) {
@@ -536,16 +545,19 @@ static int do_init_ioctl(void *args, bool compat)
 		if (copy_to_user((void *)args, &compat_prm,
 				 sizeof(compat_prm))) {
 			pr_err("Could not copy to user the DPA IPSec ID");
-			return -EINVAL;
+			err = -EINVAL;
 		}
 	} else
 #endif
 		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
 			pr_err("Could not copy to user the ID");
-			return -EINVAL;
+			err = -EINVAL;
 		}
 
-	return 0;
+free_ipsec_init_mem:
+	kfree(fqid_range);
+
+	return err;
 }
 
 static int do_create_sa_ioctl(void *args, bool compat)
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 3cd9fe1..e5046b7 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -173,6 +173,12 @@ struct dpa_ipsec_post_sec_out_params {
 	uint16_t qm_tx_ch; /* QMan channel of the post encrytion OH port      */
 };
 
+/* DPA IPSec FQID range parameters */
+struct dpa_ipsec_fqid_range {
+	uint32_t	start_fqid;
+	uint32_t	end_fqid;
+};
+
 /* IPsec parameters used to configure the DPA IPsec instance */
 struct dpa_ipsec_params {
 	struct dpa_ipsec_pre_sec_in_params pre_sec_in_params;
@@ -183,9 +189,9 @@ struct dpa_ipsec_params {
 	uint16_t qm_sec_ch;	/* QMan channel# for the SEC		      */
 	uint16_t max_sa_pairs;	/* Maximum number of SA pairs
 				 * (1 SA Pair = 1 In SA + 1 Out SA)	      */
-	struct qman_fqid_pool *fqid_pool; /* FQID pool to be used by DPA IPSec
-					   * for allocating FQIDs for internal
-					   * frame queues		      */
+	struct dpa_ipsec_fqid_range *fqid_range; /* FQID range to be used by
+						  * DPA IPSec for allocating
+						  * FQIDs for internal FQs    */
 	uint8_t ipf_bpid;	/* Scratch buffer pool for IP Frag.	      */
 };
 
-- 
1.7.5.4

