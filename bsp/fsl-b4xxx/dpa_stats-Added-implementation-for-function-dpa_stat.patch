From 0daa5ea8b2c88537a7948fec8bf255935bcb4168 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Thu, 25 Oct 2012 23:13:50 +0000
Subject: [PATCH 336/518] dpa_stats: Added implementation for function
 dpa_stats_reset_counters

Implemented function dpa_stats_reset_counters both in driver and
wrapper. In order to have an optimized implementation, moved structure
stats_info inside structure dpa_stats_cnt_cb.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c       |  374 ++++++++++++---------
 drivers/staging/fsl_dpa_offload/dpa_stats.h       |   12 +-
 drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h |   14 +
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c   |  104 ++++++-
 4 files changed, 328 insertions(+), 176 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index df4bc1b..c939e23 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -508,6 +508,8 @@ static int treat_cnts_request(struct dpa_stats *dpa_stats,
 		/* Acquire counter lock */
 		mutex_lock(&cnt_cb->lock);
 
+		cnt_cb->info.reset = req_cb->config.reset_cnts;
+
 		/* Call counter's retrieve function */
 		err = cnt_cb->f_get_cnt_stats(req_cb, cnt_cb);
 		if (err < 0) {
@@ -951,7 +953,6 @@ static int set_frag_manip(int td, struct dpa_stats_lookup_key *entry)
 static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->eth_params.cnt_sel;
 	t_Handle h_FmMac = NULL;
@@ -978,15 +979,15 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs[0] = h_FmMac;
-	cnt_gen_cb->objs_num = 1;
+	cnt_cb->gen_cb.objs[0] = h_FmMac;
+	cnt_cb->members_num = 1;
 
 	/* Map Ethernet counter selection to FM MAC statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -994,10 +995,9 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
-	struct t_FmPcdManipStats stats;
 	uint32_t cnt_sel = params->reass_params.cnt_sel;
+	struct t_FmPcdManipStats stats;
 	int err;
 
 	if (!dpa_stats) {
@@ -1015,8 +1015,8 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs[0] = params->reass_params.reass;
-	cnt_gen_cb->objs_num = 1;
+	cnt_cb->gen_cb.objs[0] = params->reass_params.reass;
+	cnt_cb->members_num = 1;
 
 	/* Check the user-provided reassembly manip */
 	err = FM_PCD_ManipGetStatistics(params->reass_params.reass, &stats);
@@ -1035,11 +1035,11 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			~(DPA_STATS_CNT_REASS_IPv6_FRAMES - 1);
 
 	/* Map Reassembly counter selection to Manip statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_REASS], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1047,7 +1047,6 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->frag_params.cnt_sel;
 	struct t_FmPcdManipStats stats;
@@ -1064,8 +1063,8 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs[0] = params->frag_params.frag;
-	cnt_gen_cb->objs_num = 1;
+	cnt_cb->gen_cb.objs[0] = params->frag_params.frag;
+	cnt_cb->members_num = 1;
 
 	/* Check the user-provided fragmentation handle */
 	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
@@ -1078,11 +1077,11 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_sel -= 1;
 
 	/* Map Fragmentation counter selection to Manip statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1090,7 +1089,6 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->reass_params.cnt_sel;
 
@@ -1105,18 +1103,18 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs[0] = params->plcr_params.plcr;
-	cnt_gen_cb->objs_num = 1;
+	cnt_cb->gen_cb.objs[0] = params->plcr_params.plcr;
+	cnt_cb->members_num = 1;
 
 	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
 		cnt_sel -= 1;
 
 	/* Map Policer counter selection to policer statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1175,7 +1173,7 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Store CcNode handle and set number of keys to one */
 	cnt_tbl_cb->keys[0].cc_node = cls_tbl.cc_node;
 	cnt_tbl_cb->keys[0].valid = TRUE;
-	cnt_tbl_cb->keys_num = 1;
+	cnt_cb->members_num = 1;
 
 	/* Check the Classifier Table counter */
 	err = FM_PCD_MatchTableFindNGetKeyStatistics(
@@ -1195,19 +1193,19 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			return -EINVAL;
 		}
 		/* Map Classifier Table counter selection to Frag stats */
-		cnt_sel_to_stats(&cnt_tbl_cb->info,
+		cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
 
 		/* Change the retrieve routine */
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
 	} else
 		/* Map Classifier Table counter selection to CcNode stats */
-		cnt_sel_to_stats(&cnt_tbl_cb->info,
+		cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
 			(cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_tbl_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1215,7 +1213,6 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_classif_cb *cnt_ccnode_cb = &cnt_cb->ccnode_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cnt_classif_node prm = params->classif_node_params;
 	t_FmPcdCcKeyStatistics stats;
@@ -1233,34 +1230,34 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Copy the key descriptor */
-	err = copy_key_descriptor(&prm.key, &cnt_ccnode_cb->keys[0]);
+	err = copy_key_descriptor(&prm.key, &cnt_cb->ccnode_cb.keys[0]);
 	if (err != 0) {
 		pr_err("Unable to copy key descriptor\n");
 		return -EINVAL;
 	}
 
 	/* Store CcNode handle and set number of keys to one */
-	cnt_ccnode_cb->cc_node = prm.cc_node;
-	cnt_ccnode_cb->keys_num = 1;
+	cnt_cb->ccnode_cb.cc_node = prm.cc_node;
+	cnt_cb->members_num = 1;
 
 	/* Check the Classifier Node counter parameters */
 	err = FM_PCD_MatchTableFindNGetKeyStatistics(
-			cnt_ccnode_cb->cc_node,
-			cnt_ccnode_cb->keys[0].size,
-			cnt_ccnode_cb->keys[0].byte,
-			cnt_ccnode_cb->keys[0].mask, &stats);
+			cnt_cb->ccnode_cb.cc_node,
+			cnt_cb->ccnode_cb.keys[0].size,
+			cnt_cb->ccnode_cb.keys[0].byte,
+			cnt_cb->ccnode_cb.keys[0].mask, &stats);
 	if (err != 0) {
 		pr_err("Invalid Classif Node counter parameters\n");
 		return -EINVAL;
 	}
 
 	/* Map Classif Node counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_ccnode_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
 		(prm.cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_ccnode_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1268,7 +1265,6 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cnt_params *params)
 {
-	struct dpa_stats_cnt_ipsec_cb *cnt_ipsec_cb = &cnt_cb->ipsec_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_ipsec_sa_stats stats;
 	uint32_t cnt_sel = params->ipsec_params.cnt_sel;
@@ -1281,27 +1277,27 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Map IPSec counter selection to statistics */
 	if (cnt_sel == DPA_STATS_CNT_NUM_OF_BYTES) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_ipsec_cb->info.stats_num = 1;
+		cnt_cb->info.stats_num = 1;
 	} else if (cnt_sel == DPA_STATS_CNT_NUM_OF_PACKETS) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_ipsec_cb->info.stats_num = 1;
+		cnt_cb->info.stats_num = 1;
 	} else if (cnt_sel == DPA_STATS_CNT_NUM_ALL) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_ipsec_cb->info.stats_off[1] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[1] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_ipsec_cb->info.stats_num = 2;
+		cnt_cb->info.stats_num = 2;
 	} else {
 		pr_err("Invalid IPSec counter selection");
 		return -EINVAL;
 	}
 
-	cnt_ipsec_cb->sa_id[0] = params->ipsec_params.sa_id;
-	cnt_ipsec_cb->valid[0] = TRUE;
-	cnt_ipsec_cb->sa_id_num = 1;
+	cnt_cb->ipsec_cb.sa_id[0] = params->ipsec_params.sa_id;
+	cnt_cb->ipsec_cb.valid[0] = TRUE;
+	cnt_cb->members_num = 1;
 
 	err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[0], &stats);
 	if (err < 0) {
@@ -1310,7 +1306,7 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_ipsec_cb->info.stats_num;
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 	return 0;
 }
@@ -1318,7 +1314,6 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->eth_params.cnt_sel;
 	t_Handle h_FmMac = NULL;
@@ -1358,25 +1353,24 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			return -EINVAL;
 		}
 
-		cnt_gen_cb->objs[i] = h_FmMac;
+		cnt_cb->gen_cb.objs[i] = h_FmMac;
 	}
 
-	cnt_gen_cb->objs_num = params->class_members;
+	cnt_cb->members_num = params->class_members;
 
 	/* Map Ethernet counter selection to FM MAC statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
-				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct t_FmPcdManipStats stats;
 	uint32_t cnt_sel = params->reass_params.cnt_sel;
@@ -1399,13 +1393,13 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs_num = params->class_members;
+	cnt_cb->members_num = params->class_members;
 
 	for (i = 0; i < params->class_members; i++) {
-		cnt_gen_cb->objs[i] = params->reass_params.reass[i];
+		cnt_cb->gen_cb.objs[i] = params->reass_params.reass[i];
 
 		/* Check the user-provided reassembly manip */
-		err = FM_PCD_ManipGetStatistics(cnt_gen_cb->objs[i], &stats);
+		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
 			pr_err("Invalid Reassembly manip handle\n");
 			return -EINVAL;
@@ -1422,23 +1416,21 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			~(DPA_STATS_CNT_REASS_IPv6_FRAMES - 1);
 
 	/* Map Reassembly counter selection to Manip statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_REASS], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
-				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->frag_params.cnt_sel, i;
 	struct t_FmPcdManipStats stats;
-	uint32_t cnt_sel = params->frag_params.cnt_sel;
-	uint32_t i = 0;
 	int err;
 
 	if (!dpa_stats) {
@@ -1452,13 +1444,13 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs_num = params->class_members;
+	cnt_cb->members_num = params->class_members;
 
 	for (i = 0; i < params->class_members; i++) {
-		cnt_gen_cb->objs[i] = params->frag_params.frag[i];
+		cnt_cb->gen_cb.objs[i] = params->frag_params.frag[i];
 
 		/* Check the user-provided fragmentation handle */
-		err = FM_PCD_ManipGetStatistics(cnt_gen_cb->objs[i], &stats);
+		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
 			pr_err("Invalid Fragmentation manip handle\n");
 			return -EINVAL;
@@ -1469,22 +1461,20 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_sel -= 1;
 
 	/* Map Fragmentation counter selection to Manip statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
-				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
-	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
-	uint32_t cnt_sel = params->plcr_params.cnt_sel;
-	uint32_t i;
+	uint32_t cnt_sel = params->plcr_params.cnt_sel, i;
 
 	if (!dpa_stats) {
 		pr_err("Invalid argument: NULL DPA Stats instance\n");
@@ -1497,21 +1487,21 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_gen_cb->objs_num = params->class_members;
+	cnt_cb->members_num = params->class_members;
 
 	for (i = 0; i < params->class_members; i++)
-		cnt_gen_cb->objs[0] = params->plcr_params.plcr;
+		cnt_cb->gen_cb.objs[0] = params->plcr_params.plcr;
 
 	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
 		cnt_sel -= 1;
 
 	/* Map Policer counter selection to policer statistics */
-	cnt_sel_to_stats(&cnt_gen_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
-				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -1582,10 +1572,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
 	struct dpa_stats_cnt_classif_tbl_cb *cnt_tbl_cb = &cnt_cb->tbl_cb;
-	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cls_cnt_classif_tbl prm = params->classif_tbl_params;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_cls_tbl_params cls_tbl;
-	struct t_FmPcdCcKeyStatistics stats;
+	t_FmPcdCcKeyStatistics stats;
 	uint32_t i = 0, cnt_sel = prm.cnt_sel;
 	int err = 0, frag_stats = -1;
 
@@ -1618,7 +1608,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	cnt_tbl_cb->td = params->classif_tbl_params.td;
-	cnt_tbl_cb->keys_num = params->class_members;
+	cnt_cb->members_num = params->class_members;
 
 	if (prm.key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
 		/* Get CcNode from table descriptor */
@@ -1709,27 +1699,26 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 
 		/* Map Classif Node counter selection to fragmentation stats */
-		cnt_sel_to_stats(&cnt_tbl_cb->info,
+		cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
 
 		/* Change the retrieve routine */
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
 	} else
 		/* Map Classif Node counter selection to CcNode statistics */
-		cnt_sel_to_stats(&cnt_tbl_cb->info,
+		cnt_sel_to_stats(&cnt_cb->info,
 			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
 			(cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_tbl_cb->keys_num *
-			STATS_VAL_SIZE * cnt_tbl_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+			STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
-	struct dpa_stats_cnt_classif_cb *cnt_ccnode_cb = &cnt_cb->ccnode_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_stats_cls_cnt_classif_node prm = params->classif_node_params;
 	t_FmPcdCcKeyStatistics stats;
@@ -1747,13 +1736,13 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	cnt_ccnode_cb->cc_node = prm.cc_node;
-	cnt_ccnode_cb->keys_num = params->class_members;
+	cnt_cb->ccnode_cb.cc_node = prm.cc_node;
+	cnt_cb->members_num = params->class_members;
 
 	for (i = 0; i < params->class_members; i++) {
 		/* Copy the key descriptor */
 		err = copy_key_descriptor(&prm.keys[i],
-				&cnt_ccnode_cb->keys[i]);
+				&cnt_cb->ccnode_cb.keys[i]);
 		if (err != 0) {
 			pr_err("Unable to copy key descriptor\n");
 			return -EINVAL;
@@ -1761,10 +1750,10 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 		/* Check the Classifier Node counter parameters */
 		err = FM_PCD_MatchTableFindNGetKeyStatistics(
-				cnt_ccnode_cb->cc_node,
-				cnt_ccnode_cb->keys[i].size,
-				cnt_ccnode_cb->keys[i].byte,
-				cnt_ccnode_cb->keys[i].mask, &stats);
+				cnt_cb->ccnode_cb.cc_node,
+				cnt_cb->ccnode_cb.keys[i].size,
+				cnt_cb->ccnode_cb.keys[i].byte,
+				cnt_cb->ccnode_cb.keys[i].mask, &stats);
 		if (err != 0) {
 			pr_err("Invalid Classif Node counter parameters\n");
 			return -EINVAL;
@@ -1772,23 +1761,23 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Map Classif Node counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_ccnode_cb->info,
+	cnt_sel_to_stats(&cnt_cb->info,
 		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
 		(prm.cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_ccnode_cb->keys_num *
-			STATS_VAL_SIZE * cnt_ccnode_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
-		const struct dpa_stats_cls_cnt_params *params)
+		const struct dpa_stats_cls_cnt_params *prm)
 {
 	struct dpa_stats_cnt_ipsec_cb *cnt_ipsec_cb = &cnt_cb->ipsec_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_ipsec_sa_stats stats;
-	uint32_t cnt_sel = params->ipsec_params.cnt_sel, i = 0;
+	uint32_t cnt_sel = prm->ipsec_params.cnt_sel, i = 0;
 	int err = 0;
 
 	if (!dpa_stats) {
@@ -1798,30 +1787,29 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Map IPSec counter selection to statistics */
 	if (cnt_sel == DPA_STATS_CNT_NUM_OF_BYTES) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_ipsec_cb->info.stats_num = 1;
+		cnt_cb->info.stats_num = 1;
 	} else if (cnt_sel  == DPA_STATS_CNT_NUM_OF_PACKETS) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_ipsec_cb->info.stats_num = 1;
+		cnt_cb->info.stats_num = 1;
 	} else if (cnt_sel  == DPA_STATS_CNT_NUM_ALL) {
-		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_ipsec_cb->info.stats_off[1] = dpa_stats->stats_sel[
+		cnt_cb->info.stats_off[1] = dpa_stats->stats_sel[
 			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_ipsec_cb->info.stats_num = 2;
+		cnt_cb->info.stats_num = 2;
 	} else {
 		pr_err("Invalid IPSec counter selection");
 		return -EINVAL;
 	}
 
-	cnt_ipsec_cb->sa_id_num = params->class_members;
+	cnt_cb->members_num = prm->class_members;
 
-	for (i = 0; i < params->class_members; i++) {
-		if (params->ipsec_params.sa_id[i] !=
-				DPA_OFFLD_INVALID_OBJECT_ID) {
-			cnt_ipsec_cb->sa_id[i] = params->ipsec_params.sa_id[i];
+	for (i = 0; i < prm->class_members; i++) {
+		if (prm->ipsec_params.sa_id[i] != DPA_OFFLD_INVALID_OBJECT_ID) {
+			cnt_ipsec_cb->sa_id[i] = prm->ipsec_params.sa_id[i];
 			cnt_ipsec_cb->valid[i] = TRUE;
 
 			err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i],
@@ -1836,8 +1824,8 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_ipsec_cb->sa_id_num *
-			STATS_VAL_SIZE * cnt_ipsec_cb->info.stats_num;
+	cnt_cb->bytes_num = cnt_cb->members_num *
+			STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -1856,7 +1844,7 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
 	}
 
 	/* Check that member index does not exceeds class size */
-	if ((member_index < 0) || (member_index >= cnt_cb->tbl_cb.keys_num)) {
+	if ((member_index < 0) || (member_index >= cnt_cb->members_num)) {
 		pr_err("Member index is out of class counter size\n");
 		return -EINVAL;
 	}
@@ -1869,9 +1857,9 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
 	tbl_cb->keys[member_index].key.mask = NULL;
 
 	/* Reset the statistics */
-	for (i = 0; i < tbl_cb->info.stats_num; i++) {
-		tbl_cb->info.stats[member_index][i] = 0;
-		tbl_cb->info.last_stats[member_index][i] = 0;
+	for (i = 0; i < cnt_cb->info.stats_num; i++) {
+		cnt_cb->info.stats[member_index][i] = 0;
+		cnt_cb->info.last_stats[member_index][i] = 0;
 	}
 
 	if (params->type == DPA_STATS_CLS_MEMBER_SINGLE_KEY) {
@@ -1933,15 +1921,15 @@ int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
 	}
 
 	/* Check that member index does not exceeds class size */
-	if ((member_idx < 0) || (member_idx >= cnt_cb->ipsec_cb.sa_id_num)) {
+	if ((member_idx < 0) || (member_idx >= cnt_cb->members_num)) {
 		pr_err("Member index is out of class counter size\n");
 		return -EINVAL;
 	}
 
 	/* Reset the statistics */
-	for (i = 0; i < ipsec_cb->info.stats_num; i++) {
-		ipsec_cb->info.stats[member_idx][i] = 0;
-		ipsec_cb->info.last_stats[member_idx][i] = 0;
+	for (i = 0; i < cnt_cb->info.stats_num; i++) {
+		cnt_cb->info.stats[member_idx][i] = 0;
+		cnt_cb->info.last_stats[member_idx][i] = 0;
 	}
 
 	if (params->sa_id == DPA_OFFLD_INVALID_OBJECT_ID) {
@@ -2032,17 +2020,14 @@ static int get_cnt_eth_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->gen_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err != 0) {
 			pr_err("Couldn't retrieve Ethernet Counter value\n");
 			return -ENOENT;
 		}
 
-		get_cnt_64bit_stats(req_cb,
-				&cnt_cb->gen_cb.info, (void *)&stats, i);
+		get_cnt_64bit_stats(req_cb, &cnt_cb->info, (void *)&stats, i);
 	}
 
 	return 0;
@@ -2055,16 +2040,14 @@ static int get_cnt_reass_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->gen_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
 			pr_err("Couldn't retrieve Reassembly statistics\n");
 			return -ESRCH;
 		}
 
-		get_cnt_32bit_stats(req_cb, &cnt_cb->gen_cb.info,
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info,
 				&stats.u.reassem.u.ipReassem, i);
 	}
 
@@ -2078,16 +2061,14 @@ static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->gen_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
 			pr_err("Couldn't retrieve Fragmentation statistics\n");
 			return -EINTR;
 		}
 
-		get_cnt_32bit_stats(req_cb, &cnt_cb->gen_cb.info,
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info,
 				&stats.u.frag.u.ipFrag, i);
 	}
 
@@ -2097,13 +2078,11 @@ static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
 static int get_cnt_plcr_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb)
 {
-	struct stats_info *info = &cnt_cb->gen_cb.info;
+	struct stats_info *info = &cnt_cb->info;
 	uint64_t stats_val = 0;
 	uint32_t i = 0, j = 0;
 
-	cnt_cb->gen_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		for (j = 0; j < info->stats_num; j++) {
 			stats_val = (uint64_t)FM_PCD_PlcrProfileGetCounter(
 				cnt_cb->gen_cb.objs[i], info->stats_off[j]);
@@ -2142,21 +2121,17 @@ static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->tbl_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->tbl_cb.keys_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		if (!cnt_cb->tbl_cb.keys[i].valid) {
 			/* Write the memory location */
 			memset(req_cb->request_area, 0,
-				cnt_cb->tbl_cb.info.stats_num *
-					STATS_VAL_SIZE);
+				cnt_cb->info.stats_num * STATS_VAL_SIZE);
 
 			/* Update the memory pointer */
 			req_cb->request_area += STATS_VAL_SIZE *
-					cnt_cb->tbl_cb.info.stats_num;
+					cnt_cb->info.stats_num;
 			continue;
 		}
-
 		err = FM_PCD_MatchTableFindNGetKeyStatistics(
 				cnt_cb->tbl_cb.keys[i].cc_node,
 				cnt_cb->tbl_cb.keys[i].key.size,
@@ -2166,8 +2141,7 @@ static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
 			pr_err("Couldn't retrieve Classif Table statistics\n");
 			return -EIO;
 		}
-
-		get_cnt_32bit_stats(req_cb, &cnt_cb->tbl_cb.info, &stats, i);
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
 	}
 
 	return 0;
@@ -2180,18 +2154,16 @@ static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->tbl_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->tbl_cb.keys_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		if (!cnt_cb->tbl_cb.keys[i].valid) {
 			/* Write the memory location */
 			memset(req_cb->request_area, 0,
-				cnt_cb->tbl_cb.info.stats_num *
+				cnt_cb->info.stats_num *
 					STATS_VAL_SIZE);
 
 			/* Update the memory pointer */
 			req_cb->request_area += STATS_VAL_SIZE *
-					cnt_cb->tbl_cb.info.stats_num;
+					cnt_cb->info.stats_num;
 			continue;
 		}
 
@@ -2201,8 +2173,8 @@ static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 			pr_err("Couldn't retrieve Fragmentation statistics\n");
 			return -EINTR;
 		}
-		get_cnt_32bit_stats(req_cb, &cnt_cb->tbl_cb.info,
-				&stats.u.frag.u.ipFrag, i);
+		get_cnt_32bit_stats(req_cb,
+				&cnt_cb->info, &stats.u.frag.u.ipFrag, i);
 	}
 
 	return 0;
@@ -2215,9 +2187,7 @@ static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->ccnode_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->ccnode_cb.keys_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_MatchTableFindNGetKeyStatistics(
 				cnt_cb->ccnode_cb.cc_node,
 				cnt_cb->ccnode_cb.keys[i].size,
@@ -2229,7 +2199,7 @@ static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
 		}
 
 		get_cnt_32bit_stats(req_cb,
-				&cnt_cb->ccnode_cb.info, (void *)&stats, i);
+				&cnt_cb->info, (void *)&stats, i);
 	}
 
 	return 0;
@@ -2242,18 +2212,15 @@ static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
 	uint32_t i = 0;
 	int err = 0;
 
-	cnt_cb->ipsec_cb.info.reset = req_cb->config.reset_cnts;
-
-	for (i = 0; i < cnt_cb->ipsec_cb.sa_id_num; i++) {
+	for (i = 0; i < cnt_cb->members_num; i++) {
 		if (!cnt_cb->ipsec_cb.valid[i]) {
 			/* Write the memory location */
 			memset(req_cb->request_area, 0,
-					cnt_cb->ipsec_cb.info.stats_num *
-					STATS_VAL_SIZE);
+				cnt_cb->info.stats_num * STATS_VAL_SIZE);
 
 			/* Update the memory pointer */
-			req_cb->request_area += STATS_VAL_SIZE *
-					cnt_cb->ipsec_cb.info.stats_num;
+			req_cb->request_area +=
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
 			continue;
 		}
@@ -2264,7 +2231,7 @@ static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
 			return -E2BIG;
 		}
 
-		get_cnt_32bit_stats(req_cb, &cnt_cb->ipsec_cb.info, &stats, i);
+		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
 	}
 
 	return 0;
@@ -2774,7 +2741,7 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 
 	/* Remove the allocated memory for keys bytes and masks */
 	if (cnt_cb->type == DPA_STATS_CNT_CLASSIF_NODE) {
-		for (i = 0; i < cnt_cb->ccnode_cb.keys_num; i++) {
+		for (i = 0; i < cnt_cb->members_num; i++) {
 			kfree(cnt_cb->ccnode_cb.keys[i].byte);
 			kfree(cnt_cb->ccnode_cb.keys[i].mask);
 		}
@@ -2782,7 +2749,7 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 
 	/* Remove the allocated memory for keys bytes and masks */
 	if (cnt_cb->type == DPA_STATS_CNT_CLASSIF_TBL) {
-		for (i = 0; i < cnt_cb->tbl_cb.keys_num; i++) {
+		for (i = 0; i < cnt_cb->members_num; i++) {
 			kfree(cnt_cb->tbl_cb.keys[i].key.byte);
 			kfree(cnt_cb->tbl_cb.keys[i].key.mask);
 		}
@@ -2922,6 +2889,81 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 }
 EXPORT_SYMBOL(dpa_stats_get_counters);
 
+int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
+{
+	struct dpa_stats *dpa_stats = NULL;
+	struct dpa_stats_cnt_cb *cnt_cb = NULL;
+	uint32_t i = 0;
+	int err = 0;
+
+	if (!gbl_dpa_stats) {
+		pr_err("dpa_stats component is not initialized\n");
+		return -EPERM;
+	}
+
+	/* Check user-provided cnts_len pointer */
+	if (!cnts_ids_len) {
+		pr_err("Parameter cnts_ids_len can't be 0\n");
+		return -EINVAL;
+	}
+
+	/* Check user-provided cnts_ids pointer */
+	if (!cnts_ids) {
+		pr_err("Parameter cnts_ids can't be NULL\n");
+		return -EINVAL;
+	}
+
+	dpa_stats = gbl_dpa_stats;
+
+	for (i = 0; i < cnts_ids_len; i++) {
+		if ((cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID) ||
+		   (cnts_ids[i] > dpa_stats->config.max_counters)) {
+			pr_err("Invalid Counter id %d provided\n", cnts_ids[i]);
+			return -EINVAL;
+		}
+	}
+
+	block_sched_cnts(dpa_stats, cnts_ids, cnts_ids_len, 0);
+
+	/* Calculate number of bytes occupied by the counters */
+	for (i = 0; i < cnts_ids_len; i++) {
+		if ((cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID) ||
+			(cnts_ids[i] > dpa_stats->config.max_counters)) {
+			pr_err("Invalid Counter id %d provided\n", cnts_ids[i]);
+			return -EINVAL;
+		}
+
+		/* Get counter's control block */
+		cnt_cb = &(dpa_stats->cnts_cb[cnts_ids[i]]);
+
+		/* Acquire counter lock */
+		err = mutex_trylock(&cnt_cb->lock);
+		if (err == 0) {
+			pr_err("Counter %d is being used\n", cnts_ids[i]);
+			unblock_sched_cnts(dpa_stats,
+					cnts_ids, cnts_ids_len, 0);
+			return -EBUSY;
+		}
+
+		/* Check if counter control block is initialized */
+		if (cnt_cb->cnt_index == DPA_OFFLD_INVALID_OBJECT_ID) {
+			pr_err("Invalid Counter id %d provided\n", cnts_ids[i]);
+			mutex_unlock(&cnt_cb->lock);
+			unblock_sched_cnts(dpa_stats,
+					cnts_ids, cnts_ids_len, 0);
+			return -EINVAL;
+		}
+		memset(&cnt_cb->info.stats, 0, (MAX_NUM_OF_MEMBERS *
+				MAX_NUM_OF_STATS * sizeof(uint64_t)));
+		mutex_unlock(&cnt_cb->lock);
+	}
+
+	unblock_sched_cnts(dpa_stats, cnts_ids, cnts_ids_len, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_stats_reset_counters);
+
 int dpa_stats_free(int dpa_stats_id)
 {
 	/* multiple DPA Stats instances are not currently supported */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index b467000..e7de776 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -101,9 +101,6 @@ struct stats_info {
 struct dpa_stats_cnt_gen_cb {
 	void *objs[MAX_NUM_OF_MEMBERS]; /* Array of objects for which to
 				       retrieve statistics */
-	unsigned int objs_num;  /* Number of objects for which to
-				   retrieve statistics */
-	struct stats_info info; /* Counter's statistics information */
 };
 
 /* DPA Stats Classifier Table key descriptor */
@@ -119,8 +116,6 @@ struct dpa_stats_cnt_classif_tbl_cb {
 	int td; /* Table descriptor */
 	struct dpa_stats_lookup_key keys[MAX_NUM_OF_MEMBERS]; /* Array of
 			 key descriptors for which to provide statistics */
-	unsigned int keys_num; /* Number of keys descriptors */
-	struct stats_info info; /* Counter's statistics information */
 };
 
 /* DPA Stats Classif Node control block */
@@ -128,16 +123,12 @@ struct dpa_stats_cnt_classif_cb {
 	void *cc_node;  /* Handle of Cc Node the lookup keys belong to */
 	struct dpa_offload_lookup_key keys[MAX_NUM_OF_MEMBERS]; /* Array of
 			 key descriptors for which to provide statistics */
-	unsigned int keys_num; /* Number of keys descriptors */
-	struct stats_info info;  /* Counter's statistics information */
 };
 
 /* DPA Stats IPSec Counter control block */
 struct dpa_stats_cnt_ipsec_cb {
 	int sa_id[MAX_NUM_OF_MEMBERS]; /* Array of Security Association ids */
 	bool valid[MAX_NUM_OF_MEMBERS]; /* Security Association id is valid */
-	unsigned int sa_id_num; /* Number of SA ids to retrieve statistics for*/
-	struct stats_info info; /* Counter's statistics information */
 };
 
 typedef int get_cnt_stats(struct dpa_stats_req_cb *req_cb,
@@ -152,6 +143,9 @@ struct dpa_stats_cnt_cb {
 	struct mutex lock; /* Lock for this counter control block */
 	bool used; /* Counter has been scheduled for retrieve */
 	enum dpa_stats_cnt_type type; /* Counter type */
+	struct stats_info info; /* Counter's statistics information */
+	unsigned int members_num;  /* Number of objects for which to
+				   retrieve statistics */
 	union {
 		struct dpa_stats_cnt_gen_cb gen_cb;
 		struct dpa_stats_cnt_classif_tbl_cb tbl_cb;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
index 52f9578..5dd741c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
@@ -70,6 +70,11 @@ struct ioc_dpa_stats_cnt_request_params {
 	dpa_stats_request_cb request_done;
 };
 
+struct ioc_dpa_stats_cnts_reset_params {
+	int *cnts_ids;
+	unsigned int cnts_ids_len;
+};
+
 #ifdef CONFIG_COMPAT
 struct dpa_stats_compat_params {
 	unsigned int max_counters;
@@ -287,4 +292,13 @@ struct compat_dpa_stats_event_params {
 				struct compat_ioc_dpa_stats_cnt_request_params)
 #endif
 
+#define DPA_STATS_IOC_RESET_COUNTERS					\
+	_IOWR(DPA_STATS_IOC_MAGIC, 7, struct ioc_dpa_stats_cnts_reset_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_RESET_COUNTERS				\
+	_IOWR(DPA_STATS_IOC_MAGIC, 7,					\
+				struct compat_ioc_dpa_stats_cnts_reset_params)
+#endif
+
 #endif /* __DPA_STATS_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 1712af5..9a2ff97 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -1299,7 +1299,99 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 }
 #endif
 
-long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
+static int do_ioctl_stats_reset_counters(void *args)
+{
+	struct ioc_dpa_stats_cnts_reset_params prm;
+	int *cnt_ids;
+	long ret = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy Counters Reset parameters");
+		return -EINVAL;
+	}
+
+	/* Allocate kernel-space memory area to copy the counters ids */
+	cnt_ids = kzalloc(prm.cnts_ids_len * sizeof(int), GFP_KERNEL);
+	if (!cnt_ids) {
+		pr_err("Could not allocate counters ids array\n");
+		return -ENOMEM;
+	}
+
+	/* Copy the user provided counter ids */
+	if (copy_from_user(cnt_ids,
+			prm.cnts_ids,
+			(prm.cnts_ids_len * sizeof(int)))) {
+		pr_err("Could not copy requested counters ids\n");
+		kfree(cnt_ids);
+		return -EINVAL;
+	}
+	prm.cnts_ids = cnt_ids;
+
+	ret = dpa_stats_reset_counters(prm.cnts_ids, prm.cnts_ids_len);
+	if (ret < 0) {
+		kfree(prm.cnts_ids);
+		return ret;
+	}
+
+	kfree(cnt_ids);
+
+	if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+		pr_err("Could not copy the result to user space\n");
+		ret = -EINVAL;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static int do_ioctl_stats_compat_reset_counters(void *args)
+{
+	struct ioc_dpa_stats_cnts_reset_params kprm;
+	struct compat_ioc_dpa_stats_cnts_reset_params uprm;
+	long ret = 0;
+
+	if (copy_from_user(&uprm, args, sizeof(uprm))) {
+		pr_err("Could not copy Counters Reset parameters");
+		return -EINVAL;
+	}
+
+	memset(&kprm, 0, sizeof(struct ioc_dpa_stats_cnts_reset_params));
+	kprm.cnts_ids_len = uprm.cnts_ids_len;
+
+	/* Allocate kernel-space memory area to copy the counters ids */
+	kprm.cnts_ids = kzalloc(kprm.cnts_ids_len * sizeof(int), GFP_KERNEL);
+	if (!kprm.cnts_ids) {
+		pr_err("Could not allocate counters ids array\n");
+		return -ENOMEM;
+	}
+
+	/* Copy the user provided counter ids */
+	if (copy_from_user(kprm.cnts_ids,
+			(compat_ptr)(uprm.cnts_ids),
+			(kprm.cnts_ids_len * sizeof(int)))) {
+		pr_err("Could not copy requested counters ids\n");
+		kfree(kprm.cnts_ids);
+		return -EINVAL;
+	}
+
+	ret = dpa_stats_reset_counters(kprm.cnts_ids, kprm.cnts_ids_len);
+	if (ret < 0) {
+		kfree(kprm.cnts_ids);
+		return ret;
+	}
+
+	kfree(kprm.cnts_ids);
+
+	if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
+		pr_err("Could not copy the result to user space\n");
+		ret = -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+static long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
 			 unsigned long args)
 {
 	long ret = 0;
@@ -1365,6 +1457,11 @@ long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
 		if (ret < 0)
 			return ret;
 		break;
+	case DPA_STATS_IOC_RESET_COUNTERS:
+		ret = do_ioctl_stats_reset_counters((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
 	default:
 		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
 				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
@@ -1443,6 +1540,11 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp, unsigned int cmd,
 		if (ret < 0)
 			return ret;
 		break;
+	case DPA_STATS_IOC_COMPAT_RESET_COUNTERS:
+		ret = do_ioctl_stats_compat_reset_counters((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
 	default:
 		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
 				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
-- 
1.7.5.4

