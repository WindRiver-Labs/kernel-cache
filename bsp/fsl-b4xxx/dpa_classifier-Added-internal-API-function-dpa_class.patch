From 18e8c587157b6e76361957d38daf487a4ceae448 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:58:27 +0000
Subject: [PATCH 243/518] dpa_classifier: Added internal API function
 dpa_classif_import_static_hm

The DPA IPSec component needs some special header manipulations to be
imported and used with the DPA Classifier. As these header manipulations
cannot be created with the DPA Classifier HM API, an internal function
was created in the DPA Classifier, which is used as a shortcut to import
a header manipulation defined using the FMan driver low level API.

This internal DPA Classifier API is intended to be used only by the DPA
offloading driver components.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   80 ++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   18 +++++-
 2 files changed, 93 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 796c020..0e38b83 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -34,6 +34,10 @@
  * DPA Classifier Application Programming Interface implementation
  */
 
+
+#define __DPA_CLASSIFIER_C
+
+
 /* DPA offloading layer includes */
 #include "dpa_compat.h"
 #include "dpa_classifier.h"
@@ -2559,8 +2563,7 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	return err;
 }
 
-static int remove_hm_chain(struct list_head	*chain_head,
-			struct list_head	*current)
+int remove_hm_chain(struct list_head *chain_head, struct list_head *current)
 {
 	int err = 0;
 	struct dpa_cls_hm_node *pcurrent;
@@ -2568,7 +2571,7 @@ static int remove_hm_chain(struct list_head	*chain_head,
 	if (current->next != chain_head) {
 		/* Remove the rest of the HM chain */
 		err = remove_hm_chain(chain_head, current->next);
-		if (err)
+		if (err < 0)
 			return err;
 	}
 
@@ -2580,6 +2583,8 @@ static int remove_hm_chain(struct list_head	*chain_head,
 
 	list_del(current);
 
+	kfree(current);
+
 	return err;
 }
 
@@ -4081,6 +4086,72 @@ int dpa_classif_modify_mpls_hm(int hmd,
 	return -ENOSYS;
 }
 
+int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd)
+{
+	int err;
+	struct dpa_cls_hm *pstatic_hm, *pcurrent;
+	struct dpa_cls_hm_node *hm_node;
+
+	xx_sanity_check_return_value(hm, "hm", -EINVAL);
+	xx_sanity_check_return_value(hmd, "hmd", -EINVAL);
+
+	err = create_new_hm_op(hmd, next_hmd);
+	if (err < 0)
+		return err;
+
+	pstatic_hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
+
+	pstatic_hm->type = DPA_CLS_HM_TYPE_STATIC;
+
+	/* Create a header manip node: */
+	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+	if (!hm_node) {
+		pr_err("ERROR: %s, %s (%d): No more RAM for header manip "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	hm_node->node = hm;
+	INIT_LIST_HEAD(&hm_node->list_node);
+
+	pstatic_hm->hm_node[0]	= hm_node;
+	pstatic_hm->num_nodes	= 1;
+
+	add_local_hm_nodes_to_chain(pstatic_hm);
+
+	if (!list_empty(&pstatic_hm->list_node))
+		/*
+		 * Move the "chain head" flag on the current header
+		 * manipulation
+		 */
+		list_for_each_entry(pcurrent,
+				&pstatic_hm->list_node,
+				list_node) {
+			pcurrent->chain_head = false;
+		}
+	pstatic_hm->chain_head = true;
+
+	return 0;
+}
+
+void *dpa_classif_get_static_hm_handle(int hmd)
+{
+	struct dpa_cls_hm *hm;
+
+	xx_sanity_check_return_value(((hmd >= 0) &&
+		(hmd < hm_array.num_descriptors)), "hmd", NULL);
+
+	if (!hm_array.object[hmd])
+		return NULL;
+
+	hm = hm_array.object[hmd];
+
+	if (hm->type != DPA_CLS_HM_TYPE_STATIC)
+		return NULL;
+
+	return hm->hm_node[0]->node;
+}
+
 int dpa_classif_free_hm(int hmd)
 {
 	struct dpa_cls_hm *phm;
@@ -4099,7 +4170,8 @@ int dpa_classif_free_hm(int hmd)
 		 * This is a header manip chain head, hence remove the entire
 		 * chain of low level ops
 		 */
-		if (remove_hm_chain(phm->hm_chain, phm->hm_chain) < 0)
+		if (remove_hm_chain(phm->hm_chain, phm->hm_chain)
+			< 0)
 			pr_err("WARNING: Failed to remove HM nodes for chain "
 				"hmd=%d.\n", hmd);
 	}
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index e44a035..f037a37 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -230,6 +230,7 @@ enum dpa_cls_hm_type {
 	DPA_CLS_HM_TYPE_UPDATE,
 	DPA_CLS_HM_TYPE_VLAN,
 	DPA_CLS_HM_TYPE_MPLS,
+	DPA_CLS_HM_TYPE_STATIC,
 	DPA_CLS_HM_LAST_ENTRY
 };
 
@@ -258,7 +259,7 @@ struct dpa_cls_hm {
 	struct list_head		list_node;
 };
 
-
+#ifdef __DPA_CLASSIFIER_C
 /*
  * Allocates the array of internally managed Cc nodes based on
  * their number. The number of internally managed Cc nodes must
@@ -366,5 +367,20 @@ static inline void key_apply_mask(const struct dpa_cls_tbl_key	*key,
 				uint8_t				*new_key,
 				unsigned int			key_size);
 
+#endif /*__DPA_CLASSIFIER_C */
+
+
+/*
+ * Imports a header manipulation defined using the low level driver (FMD) API,
+ * for use with DPA Classifier
+ */
+int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd);
+
+/*
+ * Provides the FMan driver handle of the static header manipulation associated
+ * with a specified header manipulation descriptor
+ */
+void *dpa_classif_get_static_hm_handle(int hmd);
+
 
 #endif /* __DPA_CLASSIFIER_H */
-- 
1.7.5.4

