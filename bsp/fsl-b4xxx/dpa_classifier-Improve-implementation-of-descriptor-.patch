From 4a0064fcc7fb8092ba15813c19363cc355232e07 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 3 Aug 2012 23:32:44 +0000
Subject: [PATCH 224/518] dpa_classifier: Improve implementation of descriptor
 tables

Replaced the management of the table descriptor tables with a set
of data structures and functions which are performing generic descriptor
table management. These functions are more flexible and can now be used
to manage any type of descriptor tables, especially applicable also to
the header manipulation and multicast control objects.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  366 +++++++++++++---------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   47 ++-
 2 files changed, 248 insertions(+), 165 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 5aac8d6..5eebe05 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -45,20 +45,23 @@
 #include "fm_pcd_ext.h"
 
 
-/*
- * Granularity of the array mapping table descriptors to table
- * control structures in number of elements
- */
-#define DPA_CLS_TBL_ARRAYSIZEGRANULARITY			10
+/* Granularity of the descriptor tables */
+#define DPA_CLS_ARRAYSIZEGRANULARITY				10
 
 
-/* Array for mapping table descriptors to table control structures */
-static struct dpa_cls_table **table;
-/* Number of tables currently supported by the mapping array */
-static unsigned int num_tables;
-/* Number of entries currently in use in the mapping array */
-static unsigned int table_entries_in_use;
+/* DPA Classifier table descriptor table */
+struct dpa_cls_descriptor_table		table_array = {
+	.num_descriptors	= 0,
+	.used_descriptors	= 0,
+	.object			= NULL
+};
 
+/* Header manipulation descriptor table */
+struct dpa_cls_descriptor_table		hm_array = {
+	.num_descriptors	= 0,
+	.used_descriptors	= 0,
+	.object			= NULL
+};
 
 int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				int				*td)
@@ -76,17 +79,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	if (err < 0)
 		return err;
 
-	if (get_new_table_descriptor(td) < 0) {
-		err = extend_table_array();
-		if (err < 0)
-			return err;
-
-		/*
-		 * If extending the table was successful it is impossible for
-		 * the following function to fail
-		 */
-		get_new_table_descriptor(td);
-	}
+	err = acquire_new_descriptor(&table_array, td);
+	if (err < 0)
+		return err;
 
 	ptable = kzalloc(sizeof(*ptable), GFP_KERNEL);
 	if (!ptable) {
@@ -168,7 +163,8 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			INIT_LIST_HEAD(&ptable->shadow_table->shadow_entry[i]);
 	}
 
-	table[*td] = ptable;
+
+	table_array.object[*td] = ptable;
 	init_crc8_table(CRC8_WCDMA_POLY);
 
 	return err;
@@ -189,7 +185,7 @@ dpa_classif_table_create_error:
 		ptable->entries_cnt = 0;
 
 		kfree(ptable);
-		put_table_descriptor(*td);
+		put_descriptor(&table_array, *td);
 	}
 
 	*td = -1;
@@ -203,11 +199,11 @@ int dpa_classif_table_free(int td)
 	int err;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 
-	ptable = table[td];
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 
 	/* Flush the entries in the table */
 	err = dpa_classif_table_flush(td);
@@ -238,9 +234,9 @@ int dpa_classif_table_free(int td)
 
 	free_table_management(ptable);
 
-	kfree(table[td]);
+	kfree(table_array.object[td]);
 
-	put_table_descriptor(td);
+	put_descriptor(&table_array, td);
 
 	return err;
 }
@@ -255,12 +251,12 @@ int dpa_classif_table_modify_miss_action(int			td,
 	unsigned int i;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(miss_action, "miss_action", -EINVAL);
 
-	ptable = table[td];
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		pr_err("Miss Action for DPA Classifier Indexed Tables is not supported.");
@@ -309,10 +305,11 @@ int dpa_classif_table_insert_entry(int				td,
 				int				*entry_id)
 {
 	int err = 0;
+	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
@@ -321,27 +318,29 @@ int dpa_classif_table_insert_entry(int				td,
 	 * this one (this verification is only possible if a shadow table is
 	 * used)
 	 */
-	if ((table[td]->shadow_table) &&
-			(find_shadow_entry(table[td], key) != NULL)) {
-		pr_err("DPA Classifier table entry already exists.");
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+	if ((ptable->shadow_table) &&
+			(find_shadow_entry(ptable, key) != NULL)) {
+		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry already "
+			"exists.\n", __FILE__, __func__, __LINE__);
 		return -EEXIST;
 	}
 
-	switch (table[td]->params.type) {
+	switch (ptable->params.type) {
 	case DPA_CLS_TBL_INDEXED:
-		err = table_insert_entry_indexed(table[td],
+		err = table_insert_entry_indexed(ptable,
 						key,
 						action,
 						entry_id);
 		break;
 	case DPA_CLS_TBL_HASH:
-		err = table_insert_entry_hash(table[td],
+		err = table_insert_entry_hash(ptable,
 						key,
 						action,
 						entry_id);
 		break;
 	case DPA_CLS_TBL_EXACT_MATCH:
-		err = table_insert_entry_exact_match(table[td],
+		err = table_insert_entry_exact_match(ptable,
 						key,
 						action,
 						priority,
@@ -349,8 +348,9 @@ int dpa_classif_table_insert_entry(int				td,
 		break;
 #ifdef DPA_OFFLOAD_DEBUG
 	default:
-		pr_err("Unknown table type (%d).",
-			(int)table[td]->params.type);
+		pr_err("ERROR: %s, %s (%d): Unknown table type (%d).\n",
+			__FILE__, __func__, __LINE__,
+			(int)ptable->params.type);
 		err = -EINVAL;
 		break;
 #endif /* DPA_OFFLOAD_DEBUG */
@@ -365,21 +365,25 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
 	int entry_id;
+	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
 	/* Check for unsupported modifications */
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
-		(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		pr_err("Modify entry key is supported only on exact match tables.");
+		(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
+		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
+			"on exact match tables.\n", __FILE__, __func__,
+			__LINE__);
 		return -ENOSYS;
 	}
 
-	entry_id = key_to_entry_id(table[td], key);
+	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
 		pr_err("Unable to determine entry_id.");
 		return entry_id;
@@ -410,23 +414,27 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	t_Handle cc_node;
 	struct list_head *shadow_list_entry, *new_bucket_list;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+
 	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
-			(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		pr_err("Modify entry key is supported only on exact match tables.");
+			(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
+		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
+			"on exact match tables.\n", __FILE__, __func__,
+			__LINE__);
 		return -ENOSYS;
 	}
 
-	ptable		= table[td];
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	entry_index	= ptable->entry[entry_id].entry_index;
 
@@ -578,12 +586,13 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 {
 	int entry_id;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 
-	entry_id = key_to_entry_id(table[td], key);
+	entry_id = key_to_entry_id((struct dpa_cls_table *)
+			table_array.object[td], key);
 	if (entry_id < 0) {
 		pr_err("Unable to determine entry_id.");
 		return entry_id;
@@ -607,15 +616,17 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+
 	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
 
-	ptable		= table[td];
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	entry_index	= ptable->entry[entry_id].entry_index;
 
@@ -712,23 +723,27 @@ int dpa_classif_table_lookup_by_key(int				td,
 	struct list_head *pos;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
+	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
-	if (!table[td]->shadow_table) {
-		pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+	if (!ptable->shadow_table) {
+		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
+			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
+			__func__, __LINE__);
 		return -ENOSYS;
 	}
 
-	pos = find_shadow_entry(table[td], key);
+	pos = find_shadow_entry(ptable, key);
 	if (!pos)
 		return -ENODEV;
 
-	if (table[td]->params.type == DPA_CLS_TBL_INDEXED) {
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		shadow_entry_indexed = list_entry(pos,
 					struct dpa_cls_tbl_shadow_entry_indexed,
 					list_node);
@@ -753,23 +768,29 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct list_head *shadow_list_entry;
+	struct dpa_cls_table *ptable;
+
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
-	if (!table[td]->shadow_table) {
-		pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+	if (!ptable->shadow_table) {
+		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
+			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
+			__func__, __LINE__);
 		return -ENOSYS;
 	}
 
-	if (table[td]->params.type == DPA_CLS_TBL_INDEXED) {
-		shadow_list_entry = table[td]->shadow_table->
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		shadow_list_entry = ptable->shadow_table->
 					shadow_entry[entry_id].next;
 		shadow_entry_indexed = list_entry(shadow_list_entry,
 					struct dpa_cls_tbl_shadow_entry_indexed,
@@ -778,7 +799,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 		memcpy(action, &shadow_entry_indexed->action,
 			sizeof(struct dpa_cls_tbl_action));
 	} else {
-		shadow_list_entry = table[td]->entry[entry_id].shadow_entry;
+		shadow_list_entry = ptable->entry[entry_id].shadow_entry;
 		shadow_entry = list_entry(shadow_list_entry,
 					struct dpa_cls_tbl_shadow_entry,
 					list_node);
@@ -804,15 +825,16 @@ int dpa_classif_table_flush(int td)
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 
-	if (list_empty(&table[td]->entry_list))
+	if (list_empty(&ptable->entry_list))
 		/* Table is already empty. Nothing to do */
 		return 0;
 
-	ptable = table[td];
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		memset(&next_engine_params, 0,
 			sizeof(t_FmPcdCcNextEngineParams));
@@ -902,13 +924,14 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 {
 	int entry_id;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
-	entry_id = key_to_entry_id(table[td], key);
+	entry_id = key_to_entry_id((struct dpa_cls_table *)
+					table_array.object[td], key);
 	if (entry_id < 0) {
 		pr_err("Unable to determine entry_id.");
 		return entry_id;
@@ -932,16 +955,18 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 	struct dpa_cls_table *ptable;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+
 	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
-	ptable		= table[td];
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
 	index_entry	= &ptable->entry[entry_id];
 	entry_index	= index_entry->entry_index;
@@ -972,12 +997,13 @@ int dpa_classif_table_reset_entry_stats_by_key(int			td,
 {
 	int entry_id;
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 
-	entry_id = key_to_entry_id(table[td], key);
+	entry_id = key_to_entry_id((struct dpa_cls_table *)
+					table_array.object[td], key);
 	if (entry_id < 0) {
 		pr_err("Unable to determine entry_id.");
 		return entry_id;
@@ -993,19 +1019,23 @@ int dpa_classif_table_reset_entry_stats_by_ref(int		td,
 	unsigned int cc_node_index;
 	struct dpa_cls_tbl_entry *index_entry;
 	t_Handle cc_node;
+	struct dpa_cls_table *ptable;
+
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+
+	ptable = (struct dpa_cls_table *) table_array.object[td];
 
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
-		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
-	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
 
-	cc_node_index	= table[td]->entry[entry_id].int_cc_node_index;
-	index_entry	= &table[td]->entry[entry_id];
+	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
+	index_entry	= &ptable->entry[entry_id];
 
-	cc_node = (t_Handle)table[td]->int_cc_node[cc_node_index].cc_node;
+	cc_node = (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	index_entry->last_stats.total_pkts =
 		(unsigned long) FM_PCD_MatchTableGetKeyCounter(cc_node,
 						index_entry->entry_index);
@@ -1017,12 +1047,16 @@ EXPORT_SYMBOL(dpa_classif_table_reset_entry_stats_by_ref);
 
 int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
 {
-	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
-		-EINVAL);
-	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	struct dpa_cls_table *ptable;
+
+	xx_sanity_check_return_value(((td >= 0) &&
+		(td < table_array.num_descriptors)), "td", -EINVAL);
+	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(params, "params", -EINVAL);
 
-	memcpy(params, &table[td]->params, sizeof(struct dpa_cls_tbl_params));
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+
+	memcpy(params, &ptable->params, sizeof(struct dpa_cls_tbl_params));
 
 	return 0;
 }
@@ -1921,15 +1955,20 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
-		if ((action->next_table_params.next_td >= num_tables) ||
-			(!table[action->next_table_params.next_td])) {
-			pr_err("Invalid next table descriptor (0x%08x).",
+		if ((action->next_table_params.next_td >=
+				table_array.num_descriptors) ||
+			(!table_array.object[action->next_table_params.
+								next_td])) {
+			pr_err("ERROR: %s, %s (%d): Invalid next table "
+				"descriptor (%d).\n", __FILE__, __func__,
+				__LINE__,
 				(unsigned)action->next_table_params.next_td);
 			return -EINVAL;
 		}
 
 		next_engine_params->nextEngine = e_FM_PCD_CC;
-		next_table = table[action->next_table_params.next_td];
+		next_table = (struct dpa_cls_table *)
+			table_array.object[action->next_table_params.next_td];
 		next_engine_params->params.ccParams.h_CcNode =
 			(t_Handle)next_table->params.cc_node;
 
@@ -1971,64 +2010,89 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 	return shadow_entry->entry_id;
 }
 
-static int extend_table_array(void)
+static int extend_descriptor_table(struct dpa_cls_descriptor_table *desc_table)
 {
 	unsigned int new_table_size = 0;
-	struct dpa_cls_table **new_table_array;
+	void **new_objects_array;
 
-	if (table)
-		new_table_size = num_tables;
+	if (desc_table->object)
+		new_table_size = desc_table->num_descriptors;
 
-	new_table_size += DPA_CLS_TBL_ARRAYSIZEGRANULARITY;
+	new_table_size += DPA_CLS_ARRAYSIZEGRANULARITY;
 
-	new_table_array = kzalloc(new_table_size * sizeof(*new_table_array),
-				  GFP_KERNEL);
-	if (!new_table_array) {
-		pr_err("No more memory for DPA Classifier table management.");
+	new_objects_array = (void **)
+		kzalloc(new_table_size * sizeof(void *), GFP_KERNEL);
+	if (!new_objects_array) {
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"descriptor table.\n", __FILE__, __func__, __LINE__);
 		return -ENOMEM;
 	}
 
-	if (num_tables)
+	if (desc_table->num_descriptors)
 		/*
-		 * Transfer pointers to existing tables into the new table
-		 * array
+		 * Transfer pointers to existing objects into the new
+		 * descriptor array
 		 */
-		memcpy(new_table_array, table,
-			num_tables * sizeof(struct dpa_cls_table *));
+		memcpy(new_objects_array, desc_table->object,
+			desc_table->num_descriptors * sizeof(void *));
 
-	table		= new_table_array;
-	num_tables	= new_table_size;
+	kfree(desc_table->object);
+
+	desc_table->object		= new_objects_array;
+	desc_table->num_descriptors	= new_table_size;
 
 	return 0;
 }
 
-static int get_new_table_descriptor(int *td)
+static int get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
+	int *desc)
 {
 	int i;
 
-	if (table_entries_in_use >= num_tables)
+	if (desc_table->used_descriptors >= desc_table->num_descriptors)
 		return -ENOSPC;
 
-	for (i = 0; i < num_tables; i++)
-		if (table[i] == NULL) {
-			*td = i;
+	for (i = 0; i < desc_table->num_descriptors; i++)
+		if (desc_table->object[i] == NULL) {
+			*desc = i;
 			break;
 		}
 
-	table_entries_in_use++;
+	desc_table->used_descriptors++;
+
+	return 0;
+}
+
+static int acquire_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
+	int *desc)
+{
+	int err;
+
+	if (get_new_descriptor(desc_table, desc) < 0) {
+		err = extend_descriptor_table(desc_table);
+		if (err < 0)
+			return err;
+
+		/*
+		 * If extending the table was successful it is impossible for
+		 * the following function to fail
+		 */
+		get_new_descriptor(desc_table, desc);
+	}
 
 	return 0;
 }
 
-static inline void put_table_descriptor(int td)
+static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
+	int desc)
 {
-	if (table[td] != NULL) {
-		if (--table_entries_in_use == 0) {
-			kfree(table);
-			table = NULL;
-			num_tables = 0;
+	if (desc_table->object[desc] != NULL) {
+		if (--desc_table->used_descriptors == 0) {
+			kfree(desc_table->object);
+			desc_table->object		= NULL;
+			desc_table->num_descriptors	= 0;
 		} else
-			table[td] = NULL;
+			desc_table->object[desc]	= NULL;
 	}
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index d2ba7c3..219eab3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -193,6 +193,18 @@ struct dpa_cls_table {
 	struct dpa_cls_tbl_params		params;
 };
 
+/* Definition of a generic descriptor table */
+struct dpa_cls_descriptor_table {
+	/* Total number of descriptors in the table */
+	unsigned int	num_descriptors;
+
+	/* Number of currently used descriptors */
+	unsigned int	used_descriptors;
+
+	/* Array of descriptors */
+	void		**object;
+};
+
 
 /*
  * Allocates the array of internally managed Cc nodes based on
@@ -273,27 +285,34 @@ static int	key_to_entry_id(const struct dpa_cls_table *cls_table,
 	const struct dpa_cls_tbl_key *key);
 
 /*
- * Extends with one more step the array mapping the table
- * descriptors to table control structures. The array is
- * reallocated with a constant number of new elements which is
- * defined by the DPA Classifier implementation.
+ * Extends with one more step an existing descriptor table. The array is
+ * reallocated with a constant number of new elements which is defined by the
+ * DPA Classifier implementation.
+ */
+static int	extend_descriptor_table(struct dpa_cls_descriptor_table
+								*desc_table);
+
+/*
+ * Gets the first free descriptor in the indicated descriptor table. If there
+ * are no available descriptors, the function fails.
  */
-static int	extend_table_array(void);
+static int	get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
+								int *desc);
 
 /*
- * Gets the first free table descriptor in the array mapping
- * table descriptors to table control structures. In case the
- * mapping array is overflowed (or it doesn't exist at all), the
- * function will attempt to extend it (or create it).
+ * Gets the first free descriptor in the indicated descriptor table. In case
+ * the descriptor table overflows (or it doesn't exist at all), the function
+ * will attempt to extend it (or create it).
  */
-static int	get_new_table_descriptor(int *td);
+static int acquire_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
+	int *desc);
 
 /*
- * Releases a table descriptor. In case the array mapping table
- * table descriptors to table control structures is completely
- * empty the function removes it.
+ * Releases a descriptor to a descriptor table. In case the descriptor table
+ * is completely empty, the function removes it.
  */
-static inline void put_table_descriptor(int td);
+static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
+								int desc);
 
 /*
  * Applies the key mask on the key and provides the updated key
-- 
1.7.5.4

