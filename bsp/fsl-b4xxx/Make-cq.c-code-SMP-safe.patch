From 04d48afae2f8553fae46c3d351f3de4541fe3a17 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:47:16 +0000
Subject: [PATCH 160/518] Make cq.c code SMP safe

added synchronization mechanism in the DPA IPSec cq.c code
lock cq structure to prevent simultaneous access

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/cq.c |   56 ++++++++++++++++++++++++++++++----
 drivers/staging/fsl_dpa_offload/cq.h |    1 +
 2 files changed, 51 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/cq.c b/drivers/staging/fsl_dpa_offload/cq.c
index e4c6739..67e4606 100644
--- a/drivers/staging/fsl_dpa_offload/cq.c
+++ b/drivers/staging/fsl_dpa_offload/cq.c
@@ -53,6 +53,7 @@ struct cq *cq_new(int max_items, int item_size)
 		cq->item_size = item_size;
 		cq->items_in_queue = 0;
 		cq->first = 0;
+		mutex_init(&cq->cq_lock);
 		memset(cq->items, 0, max_items * item_size);
 	}
 
@@ -62,7 +63,10 @@ struct cq *cq_new(int max_items, int item_size)
 void cq_delete(struct cq *cq)
 {
 	xx_assert(cq);
-
+	while (mutex_is_locked(&cq->cq_lock)) {
+		udelay(100);
+		cpu_relax();
+	}
 	xx_free(cq);
 }
 
@@ -72,11 +76,17 @@ int cq_flush(struct cq *cq)
 
 	xx_assert(cq);
 
+	/* Acquire circular queue lock */
+	mutex_lock(&cq->cq_lock);
+
 	items_in_queue = cq->items_in_queue;
 	cq->first = 0;
 	cq->items_in_queue = 0;
 	memset(cq->items, 0, cq->max_items * cq->item_size);
 
+	/* Release circular queue lock */
+	mutex_unlock(&cq->cq_lock);
+
 	return items_in_queue;
 }
 
@@ -87,14 +97,19 @@ int cq_put(struct cq *cq, void *item)
 
 	xx_assert(cq);
 
+	/* Acquire circular queue lock */
+	mutex_lock(&cq->cq_lock);
+
 	first = cq->first;
 	max_items = cq->max_items;
 	items_in_queue = cq->items_in_queue;
 	item_size = cq->item_size;
 
 	/* Check if queue is full */
-	if (items_in_queue == max_items)
+	if (items_in_queue == max_items) {
+		mutex_unlock(&cq->cq_lock);
 		return -1;
+	}
 
 	if ((first + items_in_queue) < max_items)
 		put_pos = (first + items_in_queue) * item_size;
@@ -106,6 +121,9 @@ int cq_put(struct cq *cq, void *item)
 
 	cq->items_in_queue++;
 
+	/* Release circular queue lock */
+	mutex_unlock(&cq->cq_lock);
+
 	return items_in_queue + 1;
 }
 
@@ -149,10 +167,16 @@ int cq_get(struct cq *cq, void *item)
 	xx_assert(cq);
 	xx_assert(item);
 
+	/* Acquire circular queue lock */
+	mutex_lock(&cq->cq_lock);
+
 	items_in_queue = cq->items_in_queue;
 	/* Check if queue is empty */
-	if (items_in_queue == 0)
+	if (items_in_queue == 0) {
+		/* Release circular queue lock */
+		mutex_unlock(&cq->cq_lock);
 		return -1;
+	}
 
 	first = cq->first;
 	item_size = cq->item_size;
@@ -166,6 +190,9 @@ int cq_get(struct cq *cq, void *item)
 		first = 0;
 	cq->first = first;
 
+	/* Release circular queue lock */
+	mutex_unlock(&cq->cq_lock);
+
 	return items_in_queue - 1;
 }
 
@@ -207,9 +234,18 @@ int cq_get_8bytes(struct cq *cq, uint64_t *item)
 
 int cq_items_in_queue(struct cq *cq)
 {
+	int items_in_queue;
 	xx_assert(cq);
 
-	return cq->items_in_queue;
+	/* Acquire circular queue lock */
+	mutex_lock(&cq->cq_lock);
+
+	items_in_queue = cq->items_in_queue;
+
+	/* Release circular queue lock */
+	mutex_unlock(&cq->cq_lock);
+
+	return items_in_queue;
 }
 
 int cq_read(struct cq *cq, void *read_item, int position)
@@ -220,10 +256,15 @@ int cq_read(struct cq *cq, void *read_item, int position)
 	xx_assert(cq);
 	xx_assert(read_item);
 
+	/* Acquire circular queue lock */
+	mutex_lock(&cq->cq_lock);
+
 	items_in_queue = cq->items_in_queue;
 	/* Check if queue is empty and if position is valid */
-	if (items_in_queue == 0 || position > items_in_queue)
+	if (items_in_queue == 0 || position > items_in_queue) {
+		mutex_unlock(&cq->cq_lock);
 		return -1;
+	}
 
 	item_size = cq->item_size;
 	first = cq->first;
@@ -235,8 +276,11 @@ int cq_read(struct cq *cq, void *read_item, int position)
 	else
 		bytePosition = (first + position - 1) * item_size;
 
-	/*read from queue */
+	/* Read from queue */
 	memcpy(read_byte, cq->items + bytePosition, item_size);
 
+	/* Release circular queue lock */
+	mutex_unlock(&cq->cq_lock);
+
 	return items_in_queue;
 }
diff --git a/drivers/staging/fsl_dpa_offload/cq.h b/drivers/staging/fsl_dpa_offload/cq.h
index cf44d4a..a9484ee 100644
--- a/drivers/staging/fsl_dpa_offload/cq.h
+++ b/drivers/staging/fsl_dpa_offload/cq.h
@@ -44,6 +44,7 @@ struct cq {
 	int item_size;		/* Size of each item in the queue */
 	int items_in_queue;	/* Number of items in the queue */
 	int first;			/* Index of first item in queue */
+	struct mutex cq_lock;	/* Circular queue lock */
 	uint8_t items[0];		/* Holds the elements in the queue -
 					 * fake size */
 };
-- 
1.7.5.4

