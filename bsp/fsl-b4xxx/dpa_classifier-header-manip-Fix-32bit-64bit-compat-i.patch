From a0ca6b50c98131b58a1fe153a4695adfaed6105e Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Fri, 18 Jan 2013 20:35:20 +0000
Subject: [PATCH 460/518] dpa_classifier header manip: Fix 32bit/64bit compat
 issue related to IPv4 options field

Update type and NAT type header operations contained structures that
were incorrect for 64 bit kernel compat mode.
These structures are used to transmit ipv4 header information from
userspace classifier lib to the kernel, through ioctls. In these
structures a pointer was present - options field.
In compat mode, additional compat structures should be created to
transmit through ioctls the 32bit options pointers from userspace
into 64 bit kernel.

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   21 ++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   98 +++++++++++++++++++-
 2 files changed, 112 insertions(+), 7 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 4573d8a..9b17d91 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -365,13 +365,28 @@ struct compat_ioc_dpa_cls_hm_vlan_params {
 	int modify_flags;
 };
 
+struct compat_ipv4_header {
+	struct iphdr			header;
+	compat_uptr_t			options;
+	unsigned int			options_size;
+};
+
+struct dpa_cls_compat_hm_nat_pt_params {
+	enum dpa_cls_hm_nat_pt_type		type;
+
+	union {
+		struct compat_ipv4_header	ipv4;
+		struct ipv6_header		ipv6;
+	} new_header;
+};
+
 struct dpa_cls_compat_hm_nat_params {
 	int	flags;
 	enum dpa_cls_hm_nat_proto	proto;
 	enum dpa_cls_hm_nat_type	type;
 	union {
 		struct dpa_cls_hm_traditional_nat_params	nat;
-		struct dpa_cls_hm_nat_pt_params			nat_pt;
+		struct dpa_cls_compat_hm_nat_pt_params		nat_pt;
 	};
 	uint16_t	sport;
 	uint16_t	dport;
@@ -395,8 +410,8 @@ struct compat_ioc_dpa_cls_hm_nat_params {
 struct dpa_cls_compat_hm_update_params {
 	int	op_flags;
 	union {
-		struct iphdr		new_ipv4_hdr;
-		struct ipv6_header	new_ipv6_hdr;
+		struct compat_ipv4_header	new_ipv4_hdr;
+		struct ipv6_header		new_ipv6_hdr;
 	} replace;
 	union {
 		struct dpa_cls_hm_l3_update_params	l3;
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index f4dc243..aacf444 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1083,6 +1083,9 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 	long ret = 0;
 	struct ioc_dpa_cls_hm_nat_params kparam;
 	struct dpa_cls_hm_nat_resources *p_res = NULL;
+	int type;
+	unsigned int sz;
+	uint8_t *options = NULL;
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_hm_nat_params uparam;
 
@@ -1120,9 +1123,32 @@ static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
 			return -EINVAL;
 	}
 
+	if (kparam.nat_params.type == DPA_CLS_HM_NAT_TYPE_NAT_PT) {
+		type = kparam.nat_params.nat_pt.type;
+		if (type == DPA_CLS_HM_NAT_PT_IPv6_TO_IPv4) {
+			sz = kparam.nat_params.nat_pt.new_header.ipv4.
+				options_size;
+			options = kzalloc(sz * sizeof(*options), GFP_KERNEL);
+			if (!options) {
+				pr_err("ERROR: %s, %s (%d): Failed to allocate"
+					" memory for  options param for"
+					" DPA_CLS_HM_NAT_TYPE_NAT_PT parameter"
+					" type.\n", __FILE__, __func__,
+					__LINE__);
+				return -ENOMEM;
+			}
+			copy_from_user(options,
+					kparam.nat_params.nat_pt.new_header.
+					ipv4.options, sz);
+			kparam.nat_params.nat_pt.new_header.ipv4.options =
+									options;
+		}
+	}
+
 	ret =  dpa_classif_set_nat_hm(&kparam.nat_params, kparam.next_hmd,
 				      &kparam.hmd, kparam.chain_head,
 				      p_res);
+	kfree(options);
 	if (ret < 0)
 			return ret;
 
@@ -1187,6 +1213,8 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 	long ret = 0;
 	struct ioc_dpa_cls_hm_update_params kparam;
 	struct dpa_cls_hm_update_resources *p_res = NULL;
+	unsigned int sz;
+	uint8_t *options = NULL;
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_hm_update_params uparam;
 
@@ -1224,9 +1252,28 @@ static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
 			return -EINVAL;
 	}
 
+	if (kparam.update_params.op_flags == DPA_CLS_HM_REPLACE_IPv6_BY_IPv4) {
+		sz = kparam.update_params.replace.new_ipv4_hdr.options_size;
+		options = kzalloc(sz * sizeof(*options), GFP_KERNEL);
+		if (!options) {
+			pr_err("ERROR: %s, %s (%d): Failed to allocate memory "
+				"for  options param for"
+				" DPA_CLS_HM_REPLACE_IPv6_BY_IPv4"
+				" parameter type.\n", __FILE__, __func__,
+				__LINE__);
+			return -ENOMEM;
+		}
+
+		copy_from_user(options,
+				kparam.update_params.replace.new_ipv4_hdr.
+				options, sz);
+		kparam.update_params.replace.new_ipv4_hdr.options = options;
+	}
+
 	ret =  dpa_classif_set_update_hm(&kparam.update_params, kparam.next_hmd,
 					&kparam.hmd, kparam.chain_head,
 					p_res);
+	kfree(options);
 	if (ret < 0)
 			return ret;
 
@@ -2717,11 +2764,32 @@ int dpa_cls_hm_nat_params_compatcpy(
 		struct ioc_dpa_cls_hm_nat_params			*kparam,
 		const struct compat_ioc_dpa_cls_hm_nat_params		*uparam)
 {
+	int type;
 	kparam->nat_params.flags	= uparam->nat_params.flags;
 	kparam->nat_params.proto	= uparam->nat_params.proto;
 	kparam->nat_params.type		= uparam->nat_params.type;
-	memcpy(&kparam->nat_params.nat_pt, &uparam->nat_params.nat_pt,
-		sizeof(kparam->nat_params.nat_pt));
+	kparam->nat_params.nat_pt.type	= uparam->nat_params.nat_pt.type;
+	type = kparam->nat_params.nat_pt.type;
+
+	switch (type) {
+	case DPA_CLS_HM_NAT_PT_IPv6_TO_IPv4:
+		kparam->nat_params.nat_pt.new_header.ipv4.options_size =
+			uparam->nat_params.nat_pt.new_header.ipv4.options_size;
+		kparam->nat_params.nat_pt.new_header.ipv4.options =
+			compat_ptr(uparam->nat_params.nat_pt.new_header.ipv4.
+				   options);
+		memcpy(&kparam->nat_params.nat_pt.new_header.ipv4.header,
+			&uparam->nat_params.nat_pt.new_header.ipv4.header,
+			sizeof(struct iphdr));
+		break;
+	case DPA_CLS_HM_NAT_PT_IPv4_TO_IPv6:
+		memcpy(&kparam->nat_params.nat_pt.new_header.ipv6,
+			&uparam->nat_params.nat_pt.new_header.ipv6,
+			sizeof(struct ipv6_header));
+		break;
+	default:
+		break;
+	}
 
 	kparam->nat_params.fm_pcd = compat_ptr(uparam->nat_params.fm_pcd);
 	kparam->nat_params.sport = uparam->nat_params.sport;
@@ -2753,15 +2821,37 @@ int dpa_cls_hm_update_params_compatcpy(
 		struct ioc_dpa_cls_hm_update_params			*kparam,
 		const struct compat_ioc_dpa_cls_hm_update_params	*uparam)
 {
+	int op_flags;
+
 	kparam->update_params.op_flags = uparam->update_params.op_flags;
-	memcpy(&kparam->update_params.replace, &uparam->update_params.replace,
-		sizeof(kparam->update_params.replace));
+	op_flags = kparam->update_params.op_flags;
 	memcpy(&kparam->update_params.update, &uparam->update_params.update,
 		sizeof(kparam->update_params.update));
 	memcpy(&kparam->update_params.ip_frag_params,
 		&uparam->update_params.ip_frag_params,
 		sizeof(kparam->update_params.ip_frag_params));
 
+	switch (op_flags) {
+	case DPA_CLS_HM_REPLACE_IPv4_BY_IPv6:
+		memcpy(&kparam->update_params.replace.new_ipv6_hdr,
+			&uparam->update_params.replace.new_ipv6_hdr,
+			sizeof(struct ipv6_header));
+		break;
+	case DPA_CLS_HM_REPLACE_IPv6_BY_IPv4:
+		kparam->update_params.replace.new_ipv4_hdr.options_size =
+			uparam->update_params.replace.new_ipv4_hdr.options_size;
+		kparam->update_params.replace.new_ipv4_hdr.options =
+			compat_ptr(uparam->update_params.replace.new_ipv4_hdr.
+				   options);
+		memcpy(&kparam->update_params.replace.new_ipv4_hdr.header,
+			&uparam->update_params.replace.new_ipv4_hdr.header,
+			sizeof(struct iphdr));
+		break;
+	default:
+		break;
+	}
+
+
 	kparam->update_params.fm_pcd = compat_ptr(uparam->update_params.fm_pcd);
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
-- 
1.7.5.4

