From f641653193385be926061ff053f3944fc0d40732 Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Tue, 5 Mar 2013 16:06:43 +0000
Subject: [PATCH 508/518] dpa_classifier: Update classifier multicast
 component for multicast member index management

Changes in FMD driver for replicator component determined that multicast
members indexes to be updated automatically when members were added or removed.
In this situation dpa_classifier multicast component had to manage the
members' indexes internally. These indexes represent references to
the real indexes from FMD driver.

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   79 +++++++++++++++++++---
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   10 +++
 2 files changed, 79 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 4f6ea17..32ff4de 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -7367,6 +7367,7 @@ int dpa_classif_mcast_create_group(
 
 	t_Error err = 0;
 	struct dpa_cls_mcast_group *pgroup;
+	int member_id;
 	uint8_t max_members;
 	struct dpa_cls_tbl_enq_action_desc	*member_params;
 	t_FmPcdFrmReplicGroupParams		*replic_grp_params = NULL;
@@ -7439,11 +7440,27 @@ int dpa_classif_mcast_create_group(
 			    max_members, GFP_KERNEL);
 	if (!pgroup->member_used) {
 		pr_err("ERROR: %s, %s (%d): No more memory for DPA multicast "
-			"members' index array.", __FILE__, __func__, __LINE__);
+			"used members array.", __FILE__, __func__, __LINE__);
 		err = -ENOMEM;
 		goto dpa_classif_mcast_create_group_error;
 	}
 
+	/*
+	 * initialize the array of indexes of used members
+	 */
+	pgroup->member_ids = (typeof(pgroup->member_ids))
+			    kzalloc(sizeof(int) *
+			    max_members, GFP_KERNEL);
+	if (!pgroup->member_ids) {
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA multicast "
+			"index members array.", __FILE__, __func__, __LINE__);
+		err = -ENOMEM;
+		goto dpa_classif_mcast_create_group_error;
+	}
+
+	for (member_id = 0; member_id < max_members; member_id++)
+		pgroup->member_ids[member_id] = DPA_OFFLD_DESC_NONE;
+
 	/* Group is not imported */
 	if (group_params->group == NULL) {
 		/*
@@ -7510,13 +7527,19 @@ int dpa_classif_mcast_create_group(
 
 		pgroup->group = FM_PCD_FrmReplicSetGroup(group_params->fm_pcd,
 							replic_grp_params);
-		pgroup->member_used[pgroup->num_members] = true;
+		/* A newly created group has at least one member - member 0 */
+		pgroup->member_used[0] = true;
+		pgroup->member_ids[0] = 0;
 		pgroup->num_members++;
 	} else {
 		pgroup->group = group_params->group;
 		/* mark prefilled members in index array member */
-		memset(pgroup->member_used, 1,
-			group_params->prefilled_members * sizeof(bool));
+		for (member_id = 0; member_id < group_params->prefilled_members;
+		     member_id++) {
+			pgroup->member_used[member_id] = true;
+			pgroup->member_ids[member_id] = member_id;
+			pgroup->last_index = member_id;
+		}
 		pgroup->num_members = group_params->prefilled_members;
 	}
 
@@ -7537,6 +7560,7 @@ int dpa_classif_mcast_create_group(
 dpa_classif_mcast_create_group_error:
 	if (pgroup) {
 		kfree(pgroup->member_used);
+		kfree(pgroup->member_ids);
 		kfree(pgroup);
 		put_descriptor(&mcast_grp_array, *grpd);
 	}
@@ -7598,6 +7622,17 @@ int dpa_classif_mcast_add_member(int grpd,
 	pgroup->member_used[*membrd] = true;
 	pgroup->num_members++;
 
+	if (unlikely(pgroup->member_ids[*membrd] != DPA_OFFLD_DESC_NONE)) {
+		pr_err("\nERROR: %s, %s (%d): Current member index  %d"
+			"is already in use .\n", __FILE__, __func__,
+			__LINE__, *membrd);
+		return -ENOSPC;
+	}
+
+	/* A newly added member is always the last member in the group */
+	pgroup->last_index++;
+	pgroup->member_ids[*membrd] = pgroup->last_index;
+
 	if (member_params->policer_params != NULL) {
 		pr_err("ERROR: %s, %s (%d): Policing for DPA Classifier flows "
 			"is not yet supported.\n", __FILE__, __func__,
@@ -7655,8 +7690,8 @@ int dpa_classif_mcast_add_member(int grpd,
 		next_engine_params->h_Manip = NULL;
 
 	err = FM_PCD_FrmReplicAddMember(pgroup->group,
-				  *membrd,
-				  next_engine_params);
+					pgroup->member_ids[*membrd],
+					next_engine_params);
 	if (err != E_OK) {
 		pr_err("\nERROR: %s: Could not add member (%d) to "
 			"the group (%d)", __func__, *membrd, grpd);
@@ -7672,6 +7707,10 @@ dpa_classif_mcast_add_member_error:
 	pgroup->member_used[*membrd] = false;
 	pgroup->num_members--;
 	*membrd = DPA_OFFLD_DESC_NONE;
+
+	pgroup->member_ids[*membrd] = DPA_OFFLD_DESC_NONE;
+	pgroup->last_index--;
+
 	kfree(replic_grp_params);
 
 	return err;
@@ -7681,6 +7720,8 @@ EXPORT_SYMBOL(dpa_classif_mcast_add_member);
 int dpa_classif_mcast_remove_member(int grpd, int membrd)
 {
 	struct dpa_cls_mcast_group *pgroup;
+	int member_id;
+	uint8_t max_members;
 	t_Error err = 0;
 
 	pgroup = desc_to_object(&mcast_grp_array, grpd);
@@ -7690,14 +7731,20 @@ int dpa_classif_mcast_remove_member(int grpd, int membrd)
 		return -EINVAL;
 	}
 
-	if ((membrd < 0) || (membrd > pgroup->group_params.max_members)) {
+	if ((membrd <= 0) || (membrd > pgroup->group_params.max_members)) {
 		pr_err("ERROR: %s, %s (%d): Invalid member descriptor "
 			"(grpd=%d).\n", __FILE__, __func__, __LINE__, membrd);
 		return -EINVAL;
 	}
 
+	if (pgroup->member_ids[membrd] == DPA_OFFLD_DESC_NONE) {
+		pr_err("ERROR: %s, %s (%d): Member was already removed "
+			"(membrd=%d).\n", __FILE__, __func__, __LINE__, membrd);
+		return -EINVAL;
+	}
 
-	err = FM_PCD_FrmReplicRemoveMember(pgroup->group, membrd);
+	err = FM_PCD_FrmReplicRemoveMember(pgroup->group,
+					   pgroup->member_ids[membrd]);
 	if (err != E_OK) {
 		pr_err("\nERROR: %s, %s (%d): Could not remove member %d from  "
 			"group %d\n", __FILE__, __func__, __LINE__,
@@ -7708,6 +7755,19 @@ int dpa_classif_mcast_remove_member(int grpd, int membrd)
 	pgroup->num_members--;
 	pgroup->member_used[membrd] = false;
 
+	max_members = pgroup->group_params.max_members;
+
+	/* update indexes in index array when removing a member */
+	for (member_id = 0; member_id < max_members; member_id++) {
+		/* update all indexes greater than the removed index */
+		if (pgroup->member_ids[member_id] > pgroup->member_ids[membrd])
+				pgroup->member_ids[member_id]--;
+	}
+
+	pgroup->member_ids[membrd] = DPA_OFFLD_DESC_NONE;
+	pgroup->last_index--;
+
+
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_mcast_remove_member);
@@ -7735,8 +7795,7 @@ int dpa_classif_mcast_free_group(int grpd)
 	}
 
 	kfree(pgroup->member_used);
-
-
+	kfree(pgroup->member_ids);
 	put_descriptor(&mcast_grp_array, grpd);
 	kfree(pgroup);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 7cb8ea3..c74b2ac 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -346,6 +346,16 @@ struct dpa_cls_mcast_group {
 	bool		*member_used;
 
 	/*
+	 * Members' id array.
+	 */
+	int		*member_ids;
+
+	/*
+	 * Index of the last member in group
+	 */
+	int		last_index;
+
+	/*
 	 * Group handle
 	 */
 	void		*group;
-- 
1.7.5.4

