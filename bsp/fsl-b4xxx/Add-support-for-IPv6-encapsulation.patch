From 77ce83e9e4a4a13485e84b0eda729eeb999c3b0f Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 17 May 2012 20:36:16 +0000
Subject: [PATCH 152/518] Add support for IPv6 encapsulation

Update code to support encapsulating IPv4 & IPv6 packets both in
IPv6 ESP packets and IPv4 ESP packets.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   78 +++++++++++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    1 +
 2 files changed, 63 insertions(+), 16 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 3f81b97..44d455a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -885,7 +885,6 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 		xx_pr_err("Invalid argument: NULL mask parameter\n");
 		return -EFAULT;
 	}
-	memset(mask, 0, mask_len);
 
 	off = prefix_len / 8;
 	bit = prefix_len % 8;
@@ -1923,6 +1922,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 				    struct dpa_ipsec_sa_params *sa_params)
 {
 	struct iphdr *outer_ip_hdr;
+	enum dpa_ipsec_ip_addr_type ip_addr_type;
 	int err;
 
 	/* sanity checks */
@@ -1939,6 +1939,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->sa_dir = DPA_IPSEC_OUTBOUND;
 	sa->sa_bpid = sa_params->sa_bpid;
 	sa->sa_wqid = sa_params->sa_wqid;
+	ip_addr_type = sa_params->sa_out_params.addr_type;
 
 	err = set_cipher_auth_alg(sa_params->crypto_params.alg_suite,
 				  &sa->cipher_data.cipher_type,
@@ -1959,13 +1960,17 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->sec_desc->pdb_en.spi = sa_params->spi;
 	sa->sec_desc->pdb_en.options = PDBOPTS_ESP_TUNNEL |
 				       PDBOPTS_ESP_INCIPHDR |
-				       PDBOPTS_ESP_IPHDRSRC |
-				       PDBOPTS_ESP_UPDATE_CSUM;
+				       PDBOPTS_ESP_IPHDRSRC;
 	if (sa_params->hdr_upd_flags) {
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DSCP)
 			sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_DIFFSERV;
-		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DF)
-			sa->sec_desc->pdb_en.hmo_rsvd |= PDBHMO_ESP_DFBIT;
+		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DF) {
+			if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv4)
+				sa->sec_desc->pdb_en.hmo_rsvd |=
+							PDBHMO_ESP_DFBIT;
+			else
+				xx_pr_warn("Copy DF not supported for IPv6 SA");
+		}
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_DEC_TTL)
 			sa->sec_desc->pdb_en.hmo_rsvd |=
 					PDBHMO_ESP_ENCAP_DEC_TTL;
@@ -1978,6 +1983,11 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->sec_desc->pdb_en.seq_num =
 				sa_params->start_seq_num & SEQ_NUM_LOW_MASK;
 
+	if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv6)
+		sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_IPV6;
+	else
+		sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_UPDATE_CSUM;
+
 	if (!sa_params->sa_out_params.init_vector)
 		sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_IVSRC;
 	else
@@ -1985,8 +1995,6 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		       sa_params->sa_out_params.init_vector->init_vector,
 		       sa_params->sa_out_params.init_vector->length);
 
-	sa->sec_desc->pdb_en.ip_nh = NEXT_HEADER_IS_IPv4;
-
 	sa->outbound_flowid = sa_params->sa_out_params.post_sec_flow_id;
 
 	/* Copy the outer header and generate the original header checksum */
@@ -2012,18 +2020,32 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 				sa_params->sa_out_params.ip_hdr_size);
 		udp_hdr->check = 0x0000;
 
-		/* make sure next header type is UDP */
-		outer_ip_hdr = (struct iphdr *)
+		if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv4) {
+			outer_ip_hdr = (struct iphdr *)
 						&sa->sec_desc->pdb_en.ip_hdr[0];
-		outer_ip_hdr->protocol = IPPROTO_UDP;
+			outer_ip_hdr->protocol = IPPROTO_UDP;
+		} else {
+			/*
+			 * this should never be reached - it should be checked
+			 * before in check SA params function
+			 */
+			xx_pr_err("NAT-T is not supported for IPv6 SAs\n");
+			return -EINVAL;
+		}
 	} else {
 		sa->sec_desc->pdb_en.ip_hdr_len =
 				sa_params->sa_out_params.ip_hdr_size;
 	}
 
-	outer_ip_hdr = (struct iphdr *) &sa->sec_desc->pdb_en.ip_hdr[0];
-	outer_ip_hdr->check = ip_fast_csum((unsigned char *)outer_ip_hdr,
-					   outer_ip_hdr->ihl);
+	if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv4) {
+		outer_ip_hdr = (struct iphdr *) &sa->sec_desc->pdb_en.ip_hdr[0];
+		outer_ip_hdr->check =
+			ip_fast_csum((unsigned char *)outer_ip_hdr,
+				     outer_ip_hdr->ihl);
+	}
+
+	/* Only IPv4 inner packets are currently supported */
+	sa->sec_desc->pdb_en.ip_nh = 0x04;
 
 #ifdef DEBUG_PARAM
 	/* Printing all the parameters */
@@ -2097,8 +2119,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	sa->sec_desc->pdb_dec.seq_num =
 			sa_params->start_seq_num & SEQ_NUM_LOW_MASK;
 	sa->sec_desc->pdb_dec.options = PDBOPTS_ESP_TUNNEL |
-					PDBOPTS_ESP_OUTFMT |
-					PDBOPTS_ESP_VERIFY_CSUM;
+					PDBOPTS_ESP_OUTFMT;
 
 	if (sa_params->use_ext_seq_num) {
 		sa->sec_desc->pdb_dec.seq_num_ext_hi =
@@ -2106,6 +2127,12 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ESN;
 	}
 
+	if (sa_params->sa_in_params.dest_addr.addr_type ==
+							DPA_IPSEC_ADDR_T_IPv6)
+		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_IPVSN;
+	else
+		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_VERIFY_CSUM;
+
 	switch (sa_params->sa_in_params.arw) {
 	case DPA_IPSEC_ARSNONE:
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ARSNONE;
@@ -2123,7 +2150,12 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	/* Updated the offset to the point in frame were the encrypted
 	 * stuff starts.*/
-	sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
+	if (sa_params->sa_in_params.dest_addr.addr_type ==
+							DPA_IPSEC_ADDR_T_IPv6)
+		sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
+					(uint16_t) sizeof(struct ipv6hdr);
+	else
+		sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
 					(uint16_t) sizeof(struct iphdr);
 	if (sa->use_udp_encap)
 		sa->sec_desc->pdb_dec.hmo_ip_hdr_len += UDP_HEADER_LEN;
@@ -2453,6 +2485,13 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 				   "Specify a valid encapsulation header\n");
 			return -EINVAL;
 		}
+
+		if (sa_params->sa_out_params.outer_udp_header &&
+			sa_params->sa_out_params.addr_type ==
+				DPA_IPSEC_ADDR_T_IPv6) {
+			xx_pr_err("NAT-T is not supported for IPV6 SAs\n");
+			return -EINVAL;
+		}
 	} else {
 		/* Inbound SA */
 		if (sa_params->sa_in_params.src_addr.addr_type !=
@@ -2460,6 +2499,13 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 			xx_pr_err("Source and destination IP address must be of same type\n");
 			return -EINVAL;
 		}
+
+		if (sa_params->sa_in_params.use_udp_encap &&
+			sa_params->sa_in_params.src_addr.addr_type ==
+				DPA_IPSEC_ADDR_T_IPv6) {
+			xx_pr_err("NAT-T is not supported for IPV6 SAs\n");
+			return -EINVAL;
+		}
 	}
 
 	/* check buffer pool ID validity */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index f21c41f..00f9ca1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -42,6 +42,7 @@
 
 /*For IP header structure definition */
 #include <linux/ip.h>
+#include <linux/ipv6.h>
 
 /*For UDP header structure definition */
 #include <linux/udp.h>
-- 
1.7.5.4

