From 151f000208e6579632b4b82b5bf95070275faffe Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:52:44 +0000
Subject: [PATCH 171/518] Reconstructed dpa_ipsec_remove_sa function to make
 it SMP safe

Splited in several functions the dpa_ipsec_remove_sa function.

Now the external API function is resposible for acquiring locks and
to call by case the specific processing depending on the SA type (IN/OUT)

The following functions added expect that locks are acquired properly
before calling them:
  -remove_inbound_sa  - condensed all the stuff to be done for removing
                          an inbound SA.
  -remove_outbound_sa - what to do for removal of outbound SA.

Further block splitting done for remove_inbound_sa by
creating remove_inbound_flow_id_classif which removes
the inbound index entry for this SA and releases the exact
match table in the free inbound policy table list + releases
also the flow id index.

Funtional descriptrion:
    If SA is parent:
        remove SA
        Call the rekeying callback to inform the upper layer that rekeying
        process was finished for this SA and is ready for use.
    If SA is child:
        return since rekeying is in progress.
    If SA is single
        remove SA

Created/moved in dpa_ipsec.h:
    created some useful inline function for determining if a SA is
    parent/child, if it's on a rekeying list or if it's a single SA.
    created schedule_sa function
    moved rekey_err_report
    moved sa_currently_on_rekeying_list

Updated all the errors that dpa_ipsec_remove_sa function can return
so that upper layer can take appropriate action.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  438 ++++++++++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   50 +++
 2 files changed, 383 insertions(+), 105 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 48242e2..75df16a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -52,6 +52,9 @@ static t_FmPcdManipParams pcd_manip_params;
 /* Global dpa_ipsec component */
 struct dpa_ipsec *gbl_dpa_ipsec;
 
+static int sa_flush_policies(struct dpa_ipsec_sa *sa);
+static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa);
+
 /* Debug support functions */
 
 #ifdef DEBUG_PARAM
@@ -1601,6 +1604,37 @@ static int remove_inbound_hash_entry(struct dpa_ipsec_sa *sa)
 	return 0;
 }
 
+static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
+{
+	struct dpa_ipsec *dpa_ipsec;
+	int td, err;
+
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
+
+	td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
+
+	err = dpa_classif_table_delete_entry_by_ref(td, sa->inbound_indx_entry);
+	if (err < 0) {
+		xx_pr_err("Could not remove SA entry in indexed table\n");
+		return err;
+	}
+
+	if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
+		/* AV's note: TODO - add BUG_ON in put_free_inbpol_tbl
+		 * and make this function void */
+		put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
+
+	/* AV's note: TODO - add BUG_ON in put_inbound_flowid */
+	err = put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+	if (err < 0)
+		return err;
+
+	sa->inbound_indx_entry = -1;
+
+	return 0;
+}
+
 static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 {
 	int err = 0;
@@ -2977,127 +3011,335 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 EXPORT_SYMBOL(dpa_ipsec_create_sa);
 
 /*
- * The steps implemented here are:
- * 1. Remove the PCD entries that make traffic to go to SEC
+ * Expects that locks are acquired for this SA and its child if any.
+ * Expects that no child SA is passed to it
+ *
+ * Function description:
+ * Steps done for a parent SA:
+ * 1. Remove the PCD entry that makes traffic to go to SEC
  * 2. Wait until SEC consumes the frames in the TO_SEC queue of this SA
- * 3. Wait until FROM_SEC queue gets empty, frames are distributed by the post
- *    SEC offline port according to its PCD entries
- * 4. Remove the TO_SEC queue
- * 5. Remove the FROM_SEC queue if:
- *	this SA is not a rekeyed SA
- *	the rekeying process has been completed i.e TO_SEC queue is scheduled
- * 6. Remove all the PCD entries from the post SEC offline port
- *	special case for inbound SA with policy check enabled:
- *		- flush all policies
- *		- detach the Exact Match Table from the Index Table
- * 7. Free all memory used for this SA i.e recycle this SA
+ * 3. Schedule the TO SEC FQ of the child SA even if no traffic arrived on it
+ * 4. Inherit parent SA's inbound post decryption classification
+ * 5. If policy verification is enabled inherit parent SA's policies.
+ * 6. Remove the child SA for the rekeying list
+ * 7. Remove the parent SA's TO_SEC FQ
+ * 8. Free all memory used for this SA i.e recycle this SA
  *
- * AV's note: TODO - Check if the SA id is refering to a SA
- *	parent that has a child SA not scheduled. If so schedule this child SA
- *	TO SEC FQ even if no frames arrived encrypted with its key (SPI, ...)
- *	and remove it from the rekeying SA list.
- *	This feature depends on proper locking mechanism for SA. Cleverly add
- *	the synchronization mechanism.
+ * Steps done for a single SA:
+ * 1. Remove the PCD entries that make traffic to go to SEC
+ * 2. Remove TO_SEC FQ and FROM_SEC FQ
+ *	2.1. Wait until SEC consumes the frames in the TO_SEC queue of this SA
+ *	2.2. Wait until FROM_SEC queue gets empty, frames are distributed by the
+ *	     post SEC offline port according to its PCD entries
+ * 3. If policy verification is enabled, flush SA policies.
+ * 4. Remove the index entry from the post SEC offline port index table
+ * 5. Free all memory used for this SA i.e recycle this SA
  */
-int dpa_ipsec_remove_sa(int sa_id)
+static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 {
-	struct dpa_ipsec *dpa_ipsec;
-	struct dpa_ipsec_sa *sa;
-	int err = 0;
-
-	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec instance initialized\n");
-		return -EPERM;
-	}
+	struct dpa_ipsec_sa *child_sa;
+	int err, timeout = WAIT4_FQ_EMPTY_TIMEOUT;
 
-	dpa_ipsec = gbl_dpa_ipsec;
-
-	sa = get_sa_from_sa_id(sa_id);
-	if (!sa) {
-		xx_pr_err("Invalid SA handle for sa id %d\n", sa_id);
-		return -EINVAL;
-	}
+	if (sa_is_parent(sa)) {
+		child_sa = sa->child_sa;
 
-	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
-		/* Remove the PCD entry that makes traffic to go to SEC
-		 * First check that we have a valid entry reference.
-		 * In case previous add/remove operations failed, this entry
-		 * may already have been removed
-		 */
+		/* Remove PCD entry that makes traffic go to SEC if the entry
+		 * is valid. */
 		if (sa->inbound_hash_entry != -1) {
-			err = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
-			if (err < 0) {
-				xx_pr_err("Could not remove the PCD entry for this SA\n");
+			err = remove_inbound_hash_entry(sa);
+			if (err == -ENOTRECOVERABLE)
 				return err;
-			}
 		}
 
-		/* Destroy the TO_SEC and FROM_SEC queues */
-		err = remove_sa_fq_pair(sa);
-		if (err != 0) {
-			xx_pr_err("Could not remove the SEC frame queues\n");
-			return err;
+		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
+		if (err < 0) {
+			xx_pr_err("Waiting old SA's TO SEC FQ to get empty\n");
+			return -ETIME;
 		}
 
-		/* Flush policy if policy check is enabled */
-		if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
-			err = dpa_ipsec_sa_flush_policies(sa->id);
-			if (err < 0) {
-				xx_pr_err("Couldn't flush inbound policies");
-				return err;
-			}
+		/* schedule child SA */
+		err = schedule_sa(child_sa);
+		if (unlikely(err < 0)) {
+			xx_pr_err("Scheduling child SA %d failed\n",
+				  child_sa->id);
+			return -EIO;
 		}
 
-		/* Remove the flow id classification after decrypt */
-		if (sa->inbound_indx_entry != -1) {
-			int td;
-			td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
-			err = dpa_classif_table_delete_entry_by_ref(td,
-							sa->inbound_indx_entry);
-			if (err < 0) {
-				xx_pr_err("Could not remove SA entry in indexed table\n");
-				return err;
-			}
-			if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
-				put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
-			put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
-			sa->inbound_indx_entry = -1;
+		/* Update the child SA with parent SA's inbound indx entry */
+		child_sa->inbound_indx_entry = sa->inbound_indx_entry;
+
+		/* Inherit parent SA's policy list and then set it empty */
+		if (sa->dpa_ipsec->config.post_sec_in_params.do_pol_check)
+			list_splice_init(&sa->policy_headlist,
+					 &child_sa->policy_headlist);
+
+		/* Acquire protective lock for the SA rekeying list */
+		mutex_lock(&sa->dpa_ipsec->sa_mng.sa_rekeying_headlist_lock);
+
+		child_sa->parent_sa = NULL;
+		sa->child_sa = NULL;
+
+		/* Remove the child SA from rekeying list */
+		list_del(&child_sa->sa_rekeying_node);
+
+		/* Invalidate the FROM SEC FQ of parent SA */
+		memset(sa->from_sec_fq, 0, sizeof(struct qman_fq));
+		sa->from_sec_fq->fqid = 0;
+
+		/* Release the list lock so other threads may use it */
+		mutex_unlock(&sa->dpa_ipsec->sa_mng.sa_rekeying_headlist_lock);
+
+		/* Call rekeying callback to inform upper layer that rekeying
+		 * process was finished for this SA and is ready for use */
+		if (child_sa->rekey_event_cb)
+			child_sa->rekey_event_cb(0, child_sa->id, 0);
+
+		/* Now free the parent SA structure and all its resources */
+		err = remove_sa_sec_fq(sa->to_sec_fq);
+		if (err < 0) {
+			xx_pr_err("Couln't remove SA %d TO SEC FQ\n", sa->id);
+			return -EUCLEAN;
 		}
 
-		/* Mark SA as free */
+		/* Recycle parent SA memory */
 		err = put_sa(sa);
-		if (err < 0) {
-			xx_pr_err("Could not recycle the sa with id %d\n",
-				  sa->id);
-			return err;
+		if (unlikely(err < 0)) {
+			xx_pr_err("Could not recycle parent SA.\n");
+			return -EDQUOT;
 		}
-	} else {  /* DPA_IPSEC_OUTBOUND */
-		/* Flush policies in order to remove the PCD entries that direct
-		 * traffic to SEC */
-		err = dpa_ipsec_sa_flush_policies(sa->id);
-		if (err < 0) {
-			xx_pr_err("Could not flush outbound policies\n");
+
+		return 0;
+	}
+
+	BUG_ON(sa_is_child(sa));
+
+	/* SA is single i.e has no child and can't be child for other SA */
+
+	/* Remove PCD entry that makes traffic go to SEC entry is valid */
+	if (sa->inbound_hash_entry != -1) {
+		err = remove_inbound_hash_entry(sa);
+		if (err == -ENOTRECOVERABLE)
 			return err;
-		}
+	}
+
+	/* Destroy the TO_SEC and FROM_SEC queues */
+	err = remove_sa_fq_pair(sa);
+	if (err != 0) {
+		xx_pr_err("Could not remove the SEC frame queues\n");
+		return err;
+	}
 
-		/* Destroy the TO_SEC and FROM_SEC queues */
-		err = remove_sa_fq_pair(sa);
+	/* Flush policy if policy check is enabled */
+	if (sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		err = sa_flush_policies(sa);
 		if (err < 0) {
-			xx_pr_err("Could not remove the SEC frame queues\n");
+			xx_pr_err("Could not flush inbound policies");
 			return err;
 		}
+	}
 
-		/* Mark SA as free */
-		err = put_sa(sa);
-		if (err < 0) {
-			xx_pr_err("Could not recycle the sa with id %d\n",
-				  sa->id);
+	/* Remove the flow id classification after decryption */
+	if (sa->inbound_indx_entry != -1) {
+		err = remove_inbound_flow_id_classif(sa);
+		if (err < 0)
 			return err;
+	}
+
+	/* Mark SA as free */
+	err = put_sa(sa);
+	if (err < 0) {
+		xx_pr_err("Could not recycle the sa with id %d\n", sa->id);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * Expects that locks are acquired for this SA and its child if any.
+ * Expects that no child SA is passed to it
+ *
+ * Function description:
+ * Steps done for a parent SA:
+ * 1. Call the sa_rekeying_outbound function which is going to:
+ *	a. wait until TO SEC FQ is empty or timeout
+ *	b. schedule the child TO SEC FQ
+ *	c. remove the parent TO SEC FQ
+ *	d. free all memory used for this SA i.e recycle this SA
+ * 2. In case error code is telling that child SA is ready to use, i.e
+ *    sa_rekeying_outbound returned 0, -EUCLEAN, -EDQUOT:
+ *	a. lock SA rekeying list
+ *	b. set as single the parent SA and child SA i.e parent SA has no child
+ *	   and child SA has no parent
+ *	c. remove the child SA from the rekeying list, rekeying was complete
+ *	d. invalidate parent SA's TO SEC FQ
+ *	e. unlock SA rekeying list
+ *	f. if child SA has a valid callback trigger this call to inform upper
+ *	   layer that this SA was rekeyed successfully.
+ *
+ * Steps done for a single SA:
+ * 1. Flush SA policies i.e remove the PCD entries that direct traffic to SEC
+ * 2. Remove TO_SEC FQ and FROM_SEC FQ
+ *	2.1. Wait until SEC consumes the frames in the TO_SEC queue of this SA
+ *	2.2. Wait until FROM_SEC queue gets empty, frames are distributed by the
+ *	     post SEC offline port according to its PCD entries
+ * 3. Free all memory used for this SA i.e recycle this SA
+ */
+static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
+{
+	struct dpa_ipsec_sa *child_sa;
+	struct dpa_ipsec_sa_mng *sa_mng;
+	int err;
+
+	if (sa_is_parent(sa)) {
+		child_sa = sa->child_sa;
+
+		err = sa_rekeying_outbound(child_sa);
+
+		/* Remove child SA from rekeying list if processing was OK */
+		if (err == 0 || err == -EUCLEAN || err == -EDQUOT) {
+			/* Acquire protective lock for the SA rekeying list */
+			mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+
+			sa->child_sa = NULL;
+			child_sa->parent_sa = NULL;
+
+			/* Remove the child SA from rekeying list */
+			list_del(&child_sa->sa_rekeying_node);
+
+			/* Invalidate the FROM SEC FQ of parent SA */
+			memset(sa->from_sec_fq, 0, sizeof(struct qman_fq));
+			sa->from_sec_fq->fqid = 0;
+
+			/* Release the list lock so other threads may use it */
+			mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
+
+			/* Call rekeying callback to inform upper layer that
+			 * rekeying process was finished for this SA and is
+			 * ready for used */
+			if (child_sa->rekey_event_cb)
+				child_sa->rekey_event_cb(0, child_sa->id, 0);
 		}
+
+		return err;
+	}
+
+	BUG_ON(sa_is_child(sa));
+
+	/* SA is single i.e has no child and can't be child for other SA */
+
+	/* Flush policies i.e remove PCD entries that direct traffic to SEC */
+	err = sa_flush_policies(sa);
+	if (err < 0) {
+		xx_pr_err("Could not flush outbound policies\n");
+		return err;
+	}
+
+	/* Destroy the TO_SEC and FROM_SEC queues */
+	err = remove_sa_fq_pair(sa);
+	if (err < 0) {
+		xx_pr_err("Could not remove the SEC frame queues\n");
+		return err;
+	}
+
+	/* Mark SA as free */
+	err = put_sa(sa);
+	if (err < 0) {
+		xx_pr_err("Could not recycle the SA id %d\n", sa->id);
+		return err;
 	}
 
 	return 0;
 }
+
+/*
+ * Function description:
+ *
+ * SA is single (has no child SA and its not a child for other SA):
+ *	- acquire lock for SA, return -EAGAIN if lock is contended.
+ * SA is child:
+ *	- return error code -EINPROGRESS since this SA is in rekeying process
+ *	- to remove this SA first must be removed its parent SA using API or the
+ *	  rekeying process finished successfully for this SA
+ * SA is parent:
+ *	- always acquire parent SA lock before child SA lock
+ *	- acquire lock for SA, return -EAGAIN if lock is contended
+ *	- acquire lock for SA's child, return -EAGAIN if lock is contended
+ *	- call remove_inbound_sa or remove_outbound_sa depending on the SA
+ *	  direction, which will do the work required and call the rekeying
+ *	  callback to inform upper layer about the child SA success.
+ *	  Returned code:
+ *		a. -ENOTRECOVERABLE if failed to removed the
+ *		    PCD entry of the inbound SA that makes traffic go to SEC.
+ *		    recommended action: recall this function for several times
+ *		    and if the returned code is the same, then reboot the system
+ *		b. -ETIME if the parent SA's TO SEC FQ is not yet empty
+ *		c. -EIO if failed to schedule the child's TO SEC FQ. Unlikely.
+ *		d. -EUCLEAN if parent SA needs cleaning (its TO SEC FQ couldn't
+ *		    be removed)
+ *		e. -EDQUOT if failed to recycle the parent SA.
+ *	  In case of -EUCLEAN and -EDQUOT the recommended action is to call
+ *	  dpa_ipsec_remove with the parent SA id. Child SA id is ready to work.
+ *	- release SA's child lock
+ *	- release SA lock
+ */
+int dpa_ipsec_remove_sa(int sa_id)
+{
+	struct dpa_ipsec *dpa_ipsec;
+	struct dpa_ipsec_sa_mng *sa_mng;
+	struct dpa_ipsec_sa *sa, *child_sa = NULL;
+	int ret = 0;
+
+	if (!gbl_dpa_ipsec) {
+		xx_pr_err("There is no dpa_ipsec instance initialized\n");
+		return -EPERM;
+	}
+
+	dpa_ipsec = gbl_dpa_ipsec;
+	sa_mng = &dpa_ipsec->sa_mng;
+
+	sa = get_sa_from_sa_id(sa_id);
+	if (!sa) {
+		xx_pr_err("Invalid SA handle for SA id %d\n", sa_id);
+		return -EINVAL;
+	}
+
+	/* Always acquire parent lock before child's lock */
+	ret = mutex_trylock(&sa->lock);
+	if (ret == 0)
+		return -EAGAIN;
+
+	if (sa_is_child(sa)) {
+		xx_pr_err("This SA %d is a child in rekeying process\n", sa_id);
+		mutex_unlock(&sa->lock);
+		return -EINPROGRESS;
+	}
+
+	/* SA is parent? If so acquire its child's lock */
+	if (sa_is_parent(sa)) {
+		child_sa = sa->child_sa;
+		BUG_ON(!child_sa);
+		ret = mutex_trylock(&child_sa->lock);
+		if (ret == 0) {
+			mutex_unlock(&sa->lock);
+			return -EAGAIN;
+		}
+	}
+
+	if (sa->sa_dir == DPA_IPSEC_INBOUND)
+		ret = remove_inbound_sa(sa);
+	else
+		ret = remove_outbound_sa(sa);
+
+	/* Release child's lock first */
+	if (child_sa)
+		mutex_unlock(&child_sa->lock);
+
+	/* Release parent lock */
+	mutex_unlock(&sa->lock);
+
+	return ret;
+}
 EXPORT_SYMBOL(dpa_ipsec_remove_sa);
 
 int dpa_ipsec_sa_add_policy(int sa_id,
@@ -3183,13 +3425,6 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_remove_policy);
 
-static inline int sa_currently_in_rekeying(struct dpa_ipsec_sa *sa)
-{
-	if (sa->parent_sa || sa->child_sa)
-		return TRUE;
-	return FALSE;
-}
-
 /*
  * Returned error code: -EUSERS
  *	- if both parent SA and child SA are in invalid state, some or none of
@@ -3430,13 +3665,6 @@ rekey_sa_err:
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_rekeying);
 
-static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
-				int dpa_ipsec_id, uint32_t sa_id, int err)
-{
-	if (rekey_event_cb)
-		rekey_event_cb(dpa_ipsec_id, sa_id, err);
-}
-
 /*
  * Expects that SA's parent and SA's lock are acquired in this order.
  *
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 0d43133..33132d5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -338,4 +338,54 @@ struct dpa_ipsec_policy_entry {
 
 void sa_rekeying_work_func(struct work_struct *work);
 
+static inline int sa_currently_on_rekeying_list(struct dpa_ipsec_sa *sa)
+{
+	return (sa->sa_rekeying_node.next == LIST_POISON1 &&
+		sa->sa_rekeying_node.prev == LIST_POISON2) ? FALSE : TRUE;
+}
+
+static inline int sa_currently_in_rekeying(struct dpa_ipsec_sa *sa)
+{
+	return (sa->parent_sa || sa->child_sa) ? TRUE : FALSE;
+}
+
+static inline int sa_is_parent(struct dpa_ipsec_sa *sa)
+{
+	return sa->child_sa ? TRUE : FALSE;
+}
+
+static inline int sa_is_child(struct dpa_ipsec_sa *sa)
+{
+	return sa->parent_sa ? TRUE : FALSE;
+}
+
+static inline int sa_is_single(struct dpa_ipsec_sa *sa)
+{
+	return (!sa_is_parent(sa) && !sa_is_child(sa)) ? TRUE : FALSE;
+}
+
+static inline int schedule_sa(struct dpa_ipsec_sa *sa)
+{
+	enum qman_fq_state state;
+	u32 flags;
+	int err;
+
+	qman_fq_state(sa->to_sec_fq, &state, &flags);
+	if (state == qman_fq_state_parked) {
+		err = qman_schedule_fq(sa->to_sec_fq);
+		if (unlikely(err < 0))
+			return -EIO;
+		return 0;
+	}
+
+	return (state == qman_fq_state_sched) ? 0 : -EPERM;
+}
+
+static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
+				int dpa_ipsec_id, uint32_t sa_id, int err)
+{
+	if (rekey_event_cb)
+		rekey_event_cb(dpa_ipsec_id, sa_id, err);
+}
+
 #endif	/* __DPA_IPSEC_H__ */
-- 
1.7.5.4

