From 037e374e2b8d46c41dcc54b94be396e4b9ceb75b Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Wed, 12 Sep 2012 21:26:16 +0000
Subject: [PATCH 322/518] offload_use_case: Modify usecase to support Nat,
 Insert/Remove Vpri Update and Frag post decryption
 header manip operations

Added NAT classification node on outbound pre encryption - exact match table -
for monitoring udp data flows. For this ccnode a nat header manipulation
operation is performed.
Added  outbound post encryption exact match table for IPSEC and non IPSEc
flows (Ipv4 and IPv6). Non IPSEC entries will be transmited from usersspace
through netlink. On each entry a header manipulation chan of operations
is performed. (insert, remove, vpri update , fragmentation)

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/common.h  |   28 ++
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |   38 ++
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |   27 ++
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |  456 +++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |  165 +++++++-
 5 files changed, 705 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/common.h b/drivers/staging/fsl_dpa_offload/usecases/common.h
index 927ffb6..d6252ce 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/common.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/common.h
@@ -35,6 +35,30 @@
 #include <linux/kernel.h>
 #include "lnxwrp_fm.h"
 
+enum outb_post_enc_proto {
+	OUTB_POST_ENC_IPv4 = 0,
+	OUTB_POST_ENC_IPv6,
+	MAX_POST_ENC_PROTOS
+};
+
+#define NAT_KEY_SIZE 6
+#define IPv4_KEY_SIZE 8
+#define IPv6_KEY_SIZE 32
+#define OUTB_POST_SEC_MAX_NUM_KEYS 16
+#define OUTB_NAT_MAX_NUM_KEYS 2
+
+struct outb_nat_keys {
+	u8	key[NAT_KEY_SIZE];
+};
+
+struct outb_ipv4_keys {
+	u8	key[IPv4_KEY_SIZE];
+};
+
+struct outb_ipv6_keys {
+	u8	key[IPv6_KEY_SIZE];
+};
+
 t_LnxWrpFmDev *get_fm(int fm_idx);
 t_LnxWrpFmPortDev *get_fm_port(int fm_idx,
 				int port_idx,
@@ -43,5 +67,9 @@ t_LnxWrpFmPortDev *get_fm_port(int fm_idx,
 
 
 extern int dpa_ipsec_id;
+extern int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
+extern int outb_post_tx_fqid;
+extern int outb_update_hmd;
+
 
 #endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
index a91fe55..eb4dcf9 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -53,6 +53,8 @@ struct ipsec_fm_uparms fm_params;
 
 int fmc_config(void);
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params);
+int init_ob_post_ipsec_tables(struct ipsec_uparms *params);
+int init_ob_pre_ipsec_nat_tables(struct ipsec_uparms *params);
 int init_xfrm_km(struct xfrm_km_uparms *params);
 
 void dump_xfrm_sa(struct xfrm_state *x);
@@ -377,6 +379,25 @@ static int put_fm_params(struct sk_buff *skb_2, struct genl_info *info)
 				fm_params.cc_out_pre_enc[i] = ptr;
 			}
 		}
+
+		for (i = 0; i <  MAX_POST_ENC_PROTOS; i++) {
+			if (fm_params.cc_out_post_enc[i] != NULL) {
+				ptr = compat_get_id2ptr(compat_fm_params.
+							cc_out_post_enc[i],
+							  FM_MAP_TYPE_PCD_NODE);
+				fm_params.cc_out_post_enc[i] = ptr;
+			}
+		}
+
+		fm_params.ip4_num_keys = compat_fm_params.ip4_num_keys;
+		fm_params.ip6_num_keys = compat_fm_params.ip6_num_keys;
+		fm_params.nat_num_keys = compat_fm_params.nat_num_keys;
+		memcpy(fm_params.ip4_keys, compat_fm_params.ip4_keys,
+			sizeof(struct outb_ipv4_keys) * fm_params.ip4_num_keys);
+		memcpy(fm_params.ip6_keys, compat_fm_params.ip6_keys,
+			sizeof(struct outb_ipv6_keys) * fm_params.ip6_num_keys);
+		memcpy(fm_params.nat_keys, compat_fm_params.nat_keys,
+			sizeof(struct outb_nat_keys) * fm_params.nat_num_keys);
 	} else
 #endif
 	memcpy(&fm_params, (typeof(&fm_params))nla_data(na), data_size);
@@ -417,6 +438,23 @@ static int __init_ipsec_offld(struct sk_buff *skb_2, struct genl_info *info)
 		return rc;
 	}
 
+	rc = init_ob_post_ipsec_tables(&params);
+	if (rc) {
+		pr_err("%s(%d) : Error initalizing outbound post "
+			"IPSEC tables, ret %d\n",
+			__func__, __LINE__, rc);
+		return rc;
+	}
+
+	rc = init_ob_pre_ipsec_nat_tables(&params);
+	if (rc) {
+		pr_err("%s(%d) : Error initalizing outbound pre "
+			"IPSEC nat tables, ret %d\n",
+			__func__, __LINE__, rc);
+		return rc;
+	}
+
+
 	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
 	if (!skb)
 		return -ENOMEM;
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
index dd7a8c1..d84907c 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -34,6 +34,7 @@
 #include <linux/kernel.h>
 #include <net/xfrm.h>
 #include "linux/fsl_dpa_ipsec.h"
+#include "common.h"
 
 /* Attributes
  */
@@ -89,6 +90,15 @@ struct pol_walk_arg_frompol {
 struct ipsec_uparms {
 	__u8 ipf_bpid;
 	__u16 max_sa;
+	__u32 outb_post_tx_fqid;
+	__u32 outb_pre_ipsec_oh_tx_fqid;
+	u8 dmac[ETH_ALEN];
+	u8 smac[ETH_ALEN];
+	u8 vlan_priority;
+	__u16 mtu_post_enc;
+	__u32 ip_src_ob_nat;
+	__u32 ip_dst_ob_nat;
+	__u32 udp_dport_ob_nat;
 };
 
 /* Inbound post IPSEC OH queue types*/
@@ -113,13 +123,30 @@ struct compat_ipsec_fm_uparms {
 	compat_uptr_t cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
 	compat_uptr_t cc_flow_id;
 	compat_uptr_t cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
+	compat_uptr_t cc_out_post_enc[MAX_POST_ENC_CCNODES];
+	compat_uptr_t cc_out_rx_pre_enc;
+	int ip4_num_keys;
+	int ip6_num_keys;
+	int nat_num_keys;
+	struct outb_ipv4_keys ip4_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
+	struct outb_ipv6_keys ip6_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
+	struct outb_nat_keys nat_keys[OUTB_NAT_MAX_NUM_KEYS];
 };
 #endif
+
 struct ipsec_fm_uparms {
 	void *pcd_dev;
 	void *cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
 	void *cc_flow_id;
 	void *cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
+	void *cc_out_post_enc[MAX_POST_ENC_PROTOS];
+	void *cc_out_rx_pre_enc;
+	int ip4_num_keys;
+	int ip6_num_keys;
+	int nat_num_keys;
+	struct outb_ipv4_keys ip4_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
+	struct outb_ipv6_keys ip6_keys[OUTB_POST_SEC_MAX_NUM_KEYS];
+	struct outb_nat_keys nat_keys[OUTB_NAT_MAX_NUM_KEYS];
 };
 
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index fb0f93c..e8199cd 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -41,12 +41,33 @@
 #include "common.h"
 #include "dbgfs_ctl.h"
 
+#define SETS 0
+#define WAYS 1
 #define IN_SA_PCD_HASH_OFF      0
-#define IN_SA_PCD_HASH_SETS	2
-#define CCNODE_MAX_NUM_OF_WAYS  8
+
+/* define the number of entries (ways * sets) for each inbound sa type */
+static int num_entries[DPA_IPSEC_MAX_SA_TYPE][2] = {
+		[DPA_IPSEC_SA_IPV4][SETS] = 2,
+		[DPA_IPSEC_SA_IPV4][WAYS] = 8,
+		[DPA_IPSEC_SA_IPV4_NATT][SETS] = 2,
+		[DPA_IPSEC_SA_IPV4_NATT][WAYS] = 8,
+		[DPA_IPSEC_SA_IPV6][SETS] = 2,
+		[DPA_IPSEC_SA_IPV6][WAYS] = 4,
+};
+
 #define IPSEC_START_IN_FLOW_ID  0
 #define CCNODE_OUT_PRE_ENC_NUM_PROTOS 2
 
+#define IPSEC_OUT_POST_ENC_NUM_ENTRIES {				\
+		OUTB_POST_SEC_MAX_NUM_KEYS,				\
+		OUTB_POST_SEC_MAX_NUM_KEYS				\
+};
+
+#define IPSEC_OUT_POST_ENC_KEY_SIZE {					\
+		IPv4_KEY_SIZE,						\
+		IPv6_KEY_SIZE						\
+};
+
 /* These values must be set according to xml pcd file */
 #define IPSEC_OUT_POL_CC_NODE_KEYS  {					   \
 		16, /* Number of keys for DPA_IPSEC_PROTO_TCP_IPV4 CC Node */  \
@@ -58,7 +79,7 @@
 		16, /* Number of keys for DPA_IPSEC_PROTO_SCTP_IPV4 CC Node */ \
 		16, /* Number of keys for DPA_IPSEC_PROTO_SCTP_IPV6 CC Node */ \
 		16, /* Number of keys for DPA_IPSEC_PROTO_ANY_IPV4 CC Node */  \
-		16  /* Number of keys for DPA_IPSEC_PROTO_ANY_IPV6 CC Node */  \
+		8  /* Number of keys for DPA_IPSEC_PROTO_ANY_IPV6 CC Node */  \
 };
 
 #define IPSEC_PRE_DEC_TBL_KEY_SIZE \
@@ -105,11 +126,19 @@
 static int inb_key_size[] = IPSEC_PRE_DEC_TBL_KEY_SIZE;
 static int outb_key_size[] = IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE;
 static int out_pol_cc_node_keys[] = IPSEC_OUT_POL_CC_NODE_KEYS;
+static int outb_post_enc_ccnode_num_entries[] = IPSEC_OUT_POST_ENC_NUM_ENTRIES;
+static int outb_post_enc_ccnode_key_size[] = IPSEC_OUT_POST_ENC_KEY_SIZE;
 static struct dpa_ipsec_params ipsec_params;
 static int ipsec_initialized = 0;
+static int hmd_ins, hmd_rm, hmd_vlan, hmd_frag, hmd_nat;
 
 extern struct ipsec_fm_uparms fm_params;
 
+int outb_post_ipsec_td[MAX_POST_ENC_PROTOS];
+int outb_pre_ipsec_nat_td;
+int outb_post_tx_fqid;
+int outb_update_hmd;
+
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 {
 	int i, cls_td;
@@ -119,6 +148,8 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	t_FmPcdParams pcd_params;
 	struct file *fm_pcd_file;
 
+	outb_update_hmd = DPA_OFFLD_DESC_NONE;
+
 	memset(&ipsec_params, 0, sizeof(ipsec_params));
 	memset(&pcd_params, 0, sizeof(pcd_params));
 
@@ -131,7 +162,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
 	dbgfs_init_stats();
 	ipsec_params.max_sa_pairs = params->max_sa;
-
+	outb_post_tx_fqid = params->outb_post_tx_fqid;
 	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
 	ipsec_params.ipf_bpid = params->ipf_bpid;
 	ipsec_params.qm_sec_ch = qm_channel_caam;
@@ -144,8 +175,8 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 		cls_tbl_params.type = DPA_CLS_TBL_HASH;
 		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
 		cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
-		cls_tbl_params.hash_params.max_ways = CCNODE_MAX_NUM_OF_WAYS;
-		cls_tbl_params.hash_params.num_sets = IN_SA_PCD_HASH_SETS;
+		cls_tbl_params.hash_params.max_ways = num_entries[i][WAYS];
+		cls_tbl_params.hash_params.num_sets = num_entries[i][SETS];
 		cls_tbl_params.hash_params.key_size = inb_key_size[i];
 
 		ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
@@ -246,13 +277,424 @@ out_inb_post_sec:
 	return ret;
 }
 
+static int create_hm_outb_post_enc(int *outb_hmd, struct ipsec_uparms *params)
+{
+	struct dpa_cls_hm_remove_params rm_params;
+	struct dpa_cls_hm_insert_params ins_params;
+	struct dpa_cls_hm_vlan_params vlan_params;
+	struct dpa_cls_hm_update_params update_params;
+	t_LnxWrpFmDev *fm_dev;
+	struct file *fm_pcd_file;
+	unsigned char data[2 * ETH_ALEN];
+	int err = 0;
+
+	hmd_frag =	DPA_OFFLD_DESC_NONE;
+	hmd_ins  =	DPA_OFFLD_DESC_NONE;
+	hmd_rm   =	DPA_OFFLD_DESC_NONE;
+	hmd_vlan =	DPA_OFFLD_DESC_NONE;
+
+	memset(&rm_params, 0, sizeof(struct dpa_cls_hm_remove_params));
+	memset(&ins_params, 0, sizeof(struct dpa_cls_hm_insert_params));
+
+	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
+
+	memcpy(&data[0], &params->dmac[0], ETH_ALEN);
+	memcpy(&data[6], &params->smac[0], ETH_ALEN);
+
+	/* Remove and insert operation */
+	rm_params.type = DPA_CLS_HM_REMOVE_CUSTOM;
+	rm_params.custom.offset = 0;
+	rm_params.custom.size = 2 * ETH_ALEN;
+	rm_params.fm_pcd = fm_dev->h_PcdDev;
+	ins_params.type = DPA_CLS_HM_INSERT_CUSTOM;
+	ins_params.custom.offset = 0x00;
+	ins_params.custom.size = 2 * ETH_ALEN;
+	ins_params.custom.data = data;
+	ins_params.fm_pcd = fm_dev->h_PcdDev;
+
+	/* VLAN priority update operation */
+	memset(&vlan_params, 0, sizeof(struct dpa_cls_hm_vlan_params));
+	vlan_params.fm_pcd = fm_dev->h_PcdDev;
+	vlan_params.type = DPA_CLS_HM_VLAN_EGRESS;
+	vlan_params.egress.update_op = DPA_CLS_HM_VLAN_UPDATE_VPri;
+	vlan_params.egress.update.vpri = params->vlan_priority;
+
+	/* Update - fragmentation operation */
+	memset(&update_params, 0, sizeof(struct dpa_cls_hm_update_params));
+	update_params.fm_pcd =  fm_dev->h_PcdDev;
+	update_params.op_flags = DPA_CLS_HM_UPDATE_NONE;
+	update_params.ip_frag_params.mtu = params->mtu_post_enc;
+	update_params.ip_frag_params.scratch_bpid = params->ipf_bpid;
+	update_params.ip_frag_params.df_action =
+					DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY;
+
+	if (params->mtu_post_enc) {
+		err = dpa_classif_set_update_hm(&update_params,
+						DPA_OFFLD_DESC_NONE,
+						&hmd_frag, false, NULL);
+
+		if (err < 0) {
+			pr_err("%d - Failed to create frag hm operation\n",
+				err);
+			return err;
+		}
+	}
+
+	err = dpa_classif_set_vlan_hm(&vlan_params, hmd_frag,
+					&hmd_vlan, false, NULL);
+
+	if (err < 0) {
+		pr_err("%d - Failed to create vlan hm update vpri operation\n",
+			err);
+		return err;
+	}
+
+
+	err = dpa_classif_set_insert_hm(&ins_params, hmd_vlan,
+			&hmd_ins, false, NULL);
+	if (err < 0) {
+		pr_err("%d - Failed to create insert hm operation\n", err);
+		return err;
+	}
+
+	err = dpa_classif_set_remove_hm(&rm_params, hmd_ins, &hmd_rm, true,
+					NULL);
+
+	if (err < 0) {
+		pr_err("%d - Failed to create remove hm operation\n", err);
+		return err;
+	}
+
+	*outb_hmd = hmd_rm;
+
+	return 0;
+}
+
+static int create_hm_outb_pre_enc(int *outb_hmd, struct ipsec_uparms *params)
+{
+	struct dpa_cls_hm_nat_params nat_params;
+	t_LnxWrpFmDev *fm_dev;
+	struct file *fm_pcd_file;
+	int err = 0;
+
+	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
+
+	hmd_nat = DPA_OFFLD_DESC_NONE;
+	/* Update - ip.dest udp.dport */
+	memset(&nat_params, 0, sizeof(struct dpa_cls_hm_nat_params));
+	nat_params.fm_pcd =  fm_dev->h_PcdDev;
+	nat_params.flags = DPA_CLS_HM_NAT_UPDATE_DIP |
+			DPA_CLS_HM_NAT_UPDATE_SIP | DPA_CLS_HM_NAT_UPDATE_DPORT;
+
+	nat_params.proto = DPA_CLS_NAT_PROTO_UDP;
+	nat_params.type = DPA_CLS_HM_NAT_TYPE_TRADITIONAL;
+	nat_params.nat.sip.version = IPVERSION;
+	nat_params.nat.dip.version = IPVERSION;
+	nat_params.nat.sip.addr.ipv4.word = params->ip_src_ob_nat;
+	nat_params.nat.dip.addr.ipv4.word = params->ip_dst_ob_nat;
+	nat_params.dport = params->udp_dport_ob_nat;
+
+	err = dpa_classif_set_nat_hm(&nat_params, DPA_OFFLD_DESC_NONE,
+					&hmd_nat, true, NULL);
+	if (err < 0) {
+		pr_err("%d - Failed to create nat hm operation\n", err);
+		return err;
+	}
+
+	*outb_hmd = hmd_nat;
+
+	return 0;
+}
+
+int init_ob_post_ipsec_tables(struct ipsec_uparms *params)
+{
+	int i, cls_td;
+	struct dpa_cls_tbl_params cls_tbl_params;
+	struct dpa_cls_tbl_action def_action;
+	int ret;
+	t_LnxWrpFmDev *fm_dev;
+	struct file *fm_pcd_file;
+	struct dpa_offload_lookup_key	key;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	int outb_hmd = DPA_OFFLD_DESC_NONE;
+	key.byte = key_data;
+	key.mask = NULL;
+
+	memset(outb_post_ipsec_td, DPA_OFFLD_DESC_NONE,
+		sizeof(int) * MAX_POST_ENC_PROTOS);
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+
+	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
+
+	for (i = 0; i < MAX_POST_ENC_PROTOS; i++) {
+		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+		cls_tbl_params.cc_node = fm_params.cc_out_post_enc[i];
+		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_KEY;
+		cls_tbl_params.exact_match_params.entries_cnt =
+				outb_post_enc_ccnode_num_entries[i];
+		cls_tbl_params.exact_match_params.key_size =
+				outb_post_enc_ccnode_key_size[i];
+		ret = dpa_classif_table_create(&cls_tbl_params,
+						&cls_td);
+		if (ret < 0) {
+			pr_err("%s:%d: Error creating outbound "
+				"post enc classif table (%d), err %d\n",
+				__func__, __LINE__, i, ret);
+			return ret;
+		}
+
+		outb_post_ipsec_td[i] = cls_td;
+	}
+
+	ret = create_hm_outb_post_enc(&outb_hmd, params);
+	if (ret < 0) {
+		pr_err("%s:%d: Error creating header manip "
+			"post enc. err %d\n",
+			__func__, __LINE__, ret);
+		return ret;
+	}
+	outb_update_hmd = outb_hmd;
+	memset(&def_action, 0, sizeof(def_action));
+	def_action.type = DPA_CLS_TBL_ACTION_ENQ;
+	def_action.enable_statistics = false;
+	def_action.enq_params.new_fqid = outb_post_tx_fqid;
+	def_action.enq_params.hmd = outb_update_hmd;
+	def_action.enq_params.override_fqid = true;
+
+	if (fm_params.ip4_num_keys > 0) {
+		key.size = IPv4_KEY_SIZE;
+		for (i = 0; i < fm_params.ip4_num_keys; i++) {
+			memcpy(key.byte, fm_params.ip4_keys[i].key,
+				IPv4_KEY_SIZE);
+			ret = dpa_classif_table_insert_entry(
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4],
+					&key, &def_action, 0, NULL);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to insert"
+					" static ipv4 entry in outb "
+					"exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4]);
+				return ret;
+			}
+		}
+	}
+
+	if (fm_params.ip6_num_keys > 0) {
+		key.size = IPv6_KEY_SIZE;
+		for (i = 0; i < fm_params.ip6_num_keys; i++) {
+			memcpy(key.byte, fm_params.ip6_keys[i].key,
+				IPv6_KEY_SIZE);
+			ret = dpa_classif_table_insert_entry(
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6],
+					&key, &def_action, 0, NULL);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to insert"
+					" static ipv6 entry in outb "
+					"exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6]);
+				return ret;
+			}
+		}
+	}
+
+
+
+	return ret;
+}
+
+int init_ob_pre_ipsec_nat_tables(struct ipsec_uparms *params)
+{
+	int i, cls_td;
+	struct dpa_cls_tbl_params cls_tbl_params;
+	struct dpa_cls_tbl_action def_action;
+	int ret;
+	t_LnxWrpFmDev *fm_dev;
+	struct file *fm_pcd_file;
+	struct dpa_offload_lookup_key	key;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	int outb_hmd = DPA_OFFLD_DESC_NONE;
+	key.byte = key_data;
+	key.mask = NULL;
+
+	hmd_nat = DPA_OFFLD_DESC_NONE;
+	fm_pcd_file = fcheck((unsigned long)fm_params.pcd_dev);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		return -EINVAL;
+	}
+
+	fm_dev = (t_LnxWrpFmDev *)fm_pcd_file->private_data;
+
+	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+
+	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+	cls_tbl_params.cc_node = fm_params.cc_out_rx_pre_enc;
+	cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_KEY;
+	cls_tbl_params.exact_match_params.entries_cnt = OUTB_NAT_MAX_NUM_KEYS;
+	cls_tbl_params.exact_match_params.key_size = NAT_KEY_SIZE;
+	ret = dpa_classif_table_create(&cls_tbl_params,
+					&cls_td);
+	if (ret < 0) {
+		pr_err("%s:%d: Error creating outbound "
+			"pre enc nat classif table, err %d\n",
+			__func__, __LINE__, ret);
+		return ret;
+	}
+
+	outb_pre_ipsec_nat_td = cls_td;
+
+	ret = create_hm_outb_pre_enc(&outb_hmd, params);
+	if (ret < 0) {
+		pr_err("%s:%d: Error creating header manip "
+			"pre enc. err %d\n",
+			__func__, __LINE__, ret);
+		return ret;
+	}
+
+	hmd_nat = outb_hmd;
+
+	memset(&def_action, 0, sizeof(def_action));
+	def_action.type = DPA_CLS_TBL_ACTION_ENQ;
+	def_action.enable_statistics = false;
+	def_action.enq_params.new_fqid = params->outb_pre_ipsec_oh_tx_fqid;
+	def_action.enq_params.hmd = hmd_nat;
+	def_action.enq_params.override_fqid = true;
+
+	if (fm_params.nat_num_keys > 0) {
+		key.size = NAT_KEY_SIZE;
+		for (i = 0; i < fm_params.nat_num_keys; i++) {
+			memcpy(key.byte, fm_params.nat_keys[i].key,
+					NAT_KEY_SIZE);
+			ret = dpa_classif_table_insert_entry(
+					outb_pre_ipsec_nat_td,
+					&key, &def_action, 0, NULL);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to insert"
+					" static  entry in outb nat pre enc"
+					"exact match table (td=%d)",
+					__func__, __LINE__,
+					outb_pre_ipsec_nat_td);
+				return ret;
+			}
+		}
+	}
+
+	return ret;
+
+}
+
 int cleanup_ipsec_offload(int dpa_ipsec_id)
 {
-	int i;
+	int i, ret;
+	struct dpa_offload_lookup_key	key;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+
+	key.byte = key_data;
+	key.mask = NULL;
 
 	if (!ipsec_initialized)
 		return 0;
 
+	if (fm_params.ip4_num_keys > 0) {
+		key.size = IPv4_KEY_SIZE;
+		for (i = 0; i < fm_params.ip4_num_keys; i++) {
+			memcpy(key.byte, fm_params.ip4_keys[i].key,
+				IPv4_KEY_SIZE);
+			ret = dpa_classif_table_delete_entry_by_key(
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4],
+					&key);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to remove"
+					" static ipv4 entry in outb "
+					"exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4]);
+				return ret;
+			}
+		}
+	}
+
+	if (fm_params.ip6_num_keys > 0) {
+		key.size = IPv6_KEY_SIZE;
+		for (i = 0; i < fm_params.ip6_num_keys; i++) {
+			memcpy(key.byte, fm_params.ip6_keys[i].key,
+				IPv6_KEY_SIZE);
+			ret = dpa_classif_table_delete_entry_by_key(
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6],
+					&key);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to remove"
+					" static ipv6 entry in outb "
+					"exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6]);
+				return ret;
+			}
+		}
+	}
+
+	if (fm_params.nat_num_keys > 0) {
+		key.size = NAT_KEY_SIZE;
+		for (i = 0; i < fm_params.nat_num_keys; i++) {
+			memcpy(key.byte, fm_params.nat_keys[i].key,
+					NAT_KEY_SIZE);
+			ret = dpa_classif_table_delete_entry_by_key(
+					outb_pre_ipsec_nat_td,
+					&key);
+			if (ret < 0) {
+				pr_err("%s(%d) :Failed to remove"
+					" static entry in outb nat"
+					"exact match table pre enc "
+					"(td=%d)", __func__, __LINE__,
+					outb_pre_ipsec_nat_td);
+				return ret;
+			}
+		}
+	}
+
+	dpa_classif_table_free(outb_pre_ipsec_nat_td);
+
+	for (i = 0; i < MAX_POST_ENC_PROTOS; i++)
+		dpa_classif_table_free(outb_post_ipsec_td[i]);
+
+	if (hmd_nat != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(hmd_nat);
+
+	if (hmd_frag != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(hmd_frag);
+
+	if (hmd_vlan != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(hmd_vlan);
+
+	if (hmd_ins != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(hmd_ins);
+
+	if (hmd_rm != DPA_OFFLD_DESC_NONE)
+		dpa_classif_free_hm(hmd_rm);
+
 	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
 		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
 				dpa_cls_td[i]);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 768cae8..6877b54 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -52,6 +52,8 @@
 #define DPA_IPSEC_ADDR_T_IPv6 6
 #define GTP_PORT 0x0868
 
+DEFINE_SPINLOCK(xfrm_lock);
+
 static const u32 jhash_initval = 0xdeadbeef;
 /* offloaded SA hash entry */
 struct sa {
@@ -60,6 +62,9 @@ struct sa {
 	int dir;
 	int sa_id;
 };
+
+struct dpa_offload_lookup_key	key;
+
 /* offloaded SA's hash table */
 static struct hlist_head sa_htable[HASH_SIZE];
 
@@ -252,9 +257,13 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 {
 	int ret = 0;
 	unsigned int hash_val;
-	struct hlist_node *entry;
+	struct hlist_node *entry , *n;
 	struct sa *psa;
 	struct work_arg *work;
+	struct dpa_offload_lookup_key	key;
+	struct xfrm_state *p_state;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	int tbl_desc = DPA_OFFLD_DESC_NONE;
 
 	/* Only ESP supported */
 	if (!(x && (x->id.proto == IPPROTO_ESP)))
@@ -280,9 +289,39 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 			if (ret < 0)
 				pr_err("%s(%d): Error removing out SA (%d)\n",
 				       __func__, __LINE__, ret);
+			p_state = psa->state;
+			key.byte = key_data;
+			key.mask = NULL;
+			if (p_state->props.family == AF_INET) {
+				tbl_desc =
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
+				key.size = 2 * sizeof(u32);
+				*(u32 *)&key.byte[0] =
+						p_state->props.saddr.a4;
+				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
+			} else {
+				tbl_desc =
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
+				key.size = 2 * sizeof(p_state->props.saddr.a6);
+				memcpy(&key.byte[0], p_state->props.saddr.a6,
+					sizeof(p_state->props.saddr.a6));
+				memcpy(&key.byte[16], p_state->id.daddr.a6,
+					sizeof(p_state->id.daddr.a6));
+			}
+
+			ret = dpa_classif_table_delete_entry_by_key(tbl_desc,
+								   &key);
+			if (ret < 0)
+				pr_err("%s(%d) :Failed to remove entry #%d in "
+					"outb exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					psa->sa_id, tbl_desc);
+
 			hlist_del(&psa->h);
 			kfree(psa);
 			dbgfs_remove_entry(psa->sa_id);
+			/* remove key from outb post enc exact match table*/
+
 		}
 		psa = find_sa(sa_htable, x, XFRM_POLICY_IN);
 		if (psa) {
@@ -316,15 +355,51 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 	case XFRM_MSG_FLUSHSA:
 		pr_info("%s: XFRM_MSG_FLUSHSA event\n", __func__);
 		dbgfs_cleanup();
+		key.byte = key_data;
+		key.mask = NULL;
 		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
-			hlist_for_each_entry(psa, entry,
+			hlist_for_each_entry_safe(psa, entry, n,
 					     sa_htable + hash_val, h) {
+				p_state = psa->state;
+				if (psa->dir == XFRM_POLICY_IN)
+					goto remove_sa;
+
+				if (p_state->props.family == AF_INET) {
+					tbl_desc =
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
+					key.size = 2 * sizeof(u32);
+					*(u32 *)&key.byte[0] =
+							p_state->props.saddr.a4;
+					*(u32 *)&key.byte[4] =
+							p_state->id.daddr.a4;
+				} else {
+					tbl_desc =
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
+					key.size = 2 *
+						sizeof(p_state->props.saddr.a6);
+					memcpy(&key.byte[0],
+					       p_state->props.saddr.a6,
+					       sizeof(p_state->props.saddr.a6));
+					memcpy(&key.byte[16],
+					       p_state->id.daddr.a6,
+					       sizeof(p_state->id.daddr.a6));
+				}
+				ret = dpa_classif_table_delete_entry_by_key(
+						tbl_desc, &key);
+				if (ret < 0)
+					pr_err("%s(%d) :Failed to remove entry "
+						"#%d in outb exact match table "
+						"post enc (td=%d)",
+						__func__, __LINE__, psa->sa_id,
+						tbl_desc);
+remove_sa:
 				ret = dpa_ipsec_remove_sa(psa->sa_id);
 				if (ret < 0) {
 					pr_info
 					("%s(%d) : Error removing SA (%d)\n",
 					 __func__, __LINE__, ret);
 				}
+				hlist_del(&psa->h);
 				kfree(psa);
 			}
 		}
@@ -359,6 +434,10 @@ static int offload_sa(int dpa_ipsec_id,
 	struct iphdr outer_iphdr;
 	struct ipv6hdr outer_ip6hdr;
 	struct dpa_cls_tbl_action def_sa_action;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	struct dpa_offload_lookup_key	key;
+	int tbl_desc = DPA_OFFLD_DESC_NONE;
+
 	int ret = 0;
 
 	if (dir != XFRM_POLICY_OUT && dir != XFRM_POLICY_IN)
@@ -381,7 +460,13 @@ static int offload_sa(int dpa_ipsec_id,
 		sa_params->sa_dir = DPA_IPSEC_OUTBOUND;
 		sa_params->start_seq_num = 1;
 		sa_params->sa_wqid = usr_params.sa_wqid;
+		key.byte = key_data;
+		key.mask = NULL;
 		if (x->props.family == AF_INET) {
+			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
+			key.size = 2 * sizeof(u32);
+			*(u32 *)&key.byte[0] = x->props.saddr.a4;
+			*(u32 *)&key.byte[4] = x->id.daddr.a4;
 			memset(&outer_iphdr, 0, sizeof(outer_iphdr));
 			outer_iphdr.version = IPVERSION;
 			outer_iphdr.ihl = sizeof(outer_iphdr) / sizeof(u32);
@@ -394,6 +479,12 @@ static int offload_sa(int dpa_ipsec_id,
 			sa_params->sa_out_params.ip_hdr_size =
 			    sizeof(outer_iphdr);
 		} else if (x->props.family == AF_INET6) {
+			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
+			key.size = 2 * sizeof(x->props.saddr.a6);
+			memcpy(&key.byte[0], x->props.saddr.a6,
+				sizeof(x->props.saddr.a6));
+			memcpy(&key.byte[16], x->id.daddr.a6,
+				sizeof(x->id.daddr.a6));
 			memset(&outer_ip6hdr, 0, sizeof(outer_ip6hdr));
 			memcpy(&outer_ip6hdr.saddr, x->props.saddr.a6,
 			       sizeof(x->props.saddr.a6));
@@ -453,7 +544,31 @@ static int offload_sa(int dpa_ipsec_id,
 		sa_params->sa_in_params.policy_miss_action = def_sa_action;
 		sa_params->sa_in_params.arw = DPA_IPSEC_ARSNONE;
 	}
+
 	ret = dpa_ipsec_create_sa(dpa_ipsec_id, sa_params, sa_id);
+
+	if (ret == 0) {
+		/* for outbound dir,  outbound SAs
+		 * are added in post ipsec exact match tables */
+		memset(&def_sa_action, 0, sizeof(def_sa_action));
+		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
+		def_sa_action.enable_statistics = false;
+		def_sa_action.enq_params.new_fqid = outb_post_tx_fqid;
+		def_sa_action.enq_params.hmd = outb_update_hmd;
+		def_sa_action.enq_params.override_fqid = true;
+
+		if (sa_params->sa_dir == DPA_IPSEC_OUTBOUND) {
+			ret = dpa_classif_table_insert_entry(tbl_desc,
+				&key, &def_sa_action, 0, NULL);
+			if (ret < 0)
+				pr_err("%s(%d) :Failed to insert entry #%d in "
+					"outb exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					*sa_id, tbl_desc);
+		}
+
+	}
+
 	return ret;
 }
 
@@ -710,7 +825,53 @@ int init_xfrm_km(struct xfrm_km_uparms *params)
 
 void cleanup_xfrm_km(void)
 {
+	unsigned int hash_val;
+	struct hlist_node *entry, *n;
+	struct sa *psa;
+	struct dpa_offload_lookup_key	key;
+	struct xfrm_state *p_state;
+	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	int tbl_desc = DPA_OFFLD_DESC_NONE;
+	int ret = 0;
+
 	if (!xfrm_km_initialized)
 		return;
+
+	key.byte = key_data;
+	key.mask = NULL;
+	for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
+		hlist_for_each_entry_safe(psa, entry, n,
+					sa_htable + hash_val, h) {
+			p_state = psa->state;
+			if (psa->dir == XFRM_POLICY_IN)
+				goto free_node;
+
+			if (p_state->props.family == AF_INET) {
+				tbl_desc =
+				outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
+				key.size = 2 * sizeof(u32);
+				*(u32 *)&key.byte[0] = p_state->props.saddr.a4;
+				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
+			} else {
+				tbl_desc =
+					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
+				key.size = 2 * sizeof(p_state->props.saddr.a6);
+				memcpy(&key.byte[0], p_state->props.saddr.a6,
+				       sizeof(p_state->props.saddr.a6));
+				memcpy(&key.byte[16], p_state->id.daddr.a6,
+				       sizeof(p_state->id.daddr.a6));
+			}
+			ret = dpa_classif_table_delete_entry_by_key(tbl_desc,
+								&key);
+			if (ret < 0)
+				pr_err("%s(%d) :Failed to remove entry #%d in "
+					"outb exact match table post enc "
+					"(td=%d)", __func__, __LINE__,
+					psa->sa_id, tbl_desc);
+free_node:
+			hlist_del(&psa->h);
+			kfree(psa);
+		}
+	}
 	xfrm_unregister_km(&xfrm_mgr);
 }
-- 
1.7.5.4

