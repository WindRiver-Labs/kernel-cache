From 06957a3f143fc2dcafaa312f01dae0aace06ff76 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:04 +0000
Subject: [PATCH 221/518] Retrieve and store SEC ERA during initialization

SEC ERA information is important when descriptors are build,
because depending on its value the controller will support
or not some features.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |    3 ++
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h      |    1 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |   34 ++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    1 +
 4 files changed, 39 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 04bf107..2d91316 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2554,6 +2554,9 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	       max_num_sa * sizeof(uint32_t));
 	dpa_ipsec->num_used_sas = 0;
 
+	/* retrieve and store SEC ERA information */
+	get_sec_era_info(dpa_ipsec);
+
 	gbl_dpa_ipsec = dpa_ipsec;
 
 	return 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 1b7d2ef..1069496 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -313,6 +313,7 @@ struct dpa_ipsec {
 	struct dpa_ipsec_sa_mng sa_mng;	/* Internal DPA IPsec SA manager      */
 	uint32_t *used_sa_ids;	/* Sa ids used by this dpa ipsec instance     */
 	int num_used_sas;  /* The current number of sa's used by this instance*/
+	int sec_era; /* SEC ERA information */
 	struct mutex lock; /* Lock for this dpa_ipsec instance */
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 9c9bc1d..7aa080f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -36,9 +36,13 @@
 #include "desc.h"
 #include "error.h"
 #include "jr.h"
+#include "ctrl.h"
 
 #include "dpa_ipsec_desc.h"
 
+/* If SEC ERA is unknown default to this value */
+#define SEC_DEF_ERA	2 /* like in P4080 */
+
 static const struct of_device_id sec_match[] = {
 	{
 	 .compatible = "fsl,sec-v4.0"
@@ -51,6 +55,36 @@ static const struct of_device_id sec_jr_match[] = {
 	}
 };
 
+/* retrieve and store SEC ERA information */
+void get_sec_era_info(struct dpa_ipsec *dpa_ipsec)
+{
+	struct device_node *sec_node;
+	struct platform_device *sec_of_dev;
+	int sec_era = -EINVAL;
+
+	sec_node = of_find_matching_node(NULL, &sec_match[0]);
+	if (sec_node == NULL) {
+		pr_err("Can't find device_node for SEC! Check device tree!\n");
+		goto def_sec_era;
+	}
+
+	sec_of_dev = of_find_device_by_node(sec_node);
+	if (sec_of_dev == NULL) {
+		pr_err(KERN_ERR "SEC platform_device null!\n");
+		goto def_sec_era;
+	}
+
+	sec_era = caam_get_era(sec_of_dev);
+
+def_sec_era:
+	if (sec_era < 0)
+		/* Unknown ERA - use default */
+		sec_era = SEC_DEF_ERA;
+
+	dpa_ipsec->sec_era = sec_era;
+}
+
+
 static struct device *get_jrdev(void)
 {
 	struct device_node *sec_jr_node;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index f114ba9..bd1c11d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -84,6 +84,7 @@ struct sec_descriptor {
 	};
 };
 
+void get_sec_era_info(struct dpa_ipsec *dpa_ipsec);
 int create_sec_descriptor(struct dpa_ipsec_sa *sa);
 int generate_split_key(struct auth_params *auth_param);
 
-- 
1.7.5.4

