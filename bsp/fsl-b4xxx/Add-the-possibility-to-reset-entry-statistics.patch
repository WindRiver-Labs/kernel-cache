From f452f2fd897b6e83df5c8fefd9042938730d1669 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Mar 2012 21:25:15 +0000
Subject: [PATCH 107/518] Add the possibility to reset entry statistics

Added the options and functions to reset statistics. Reset is performed
in software by storing the reference counters and providing the user with
the delta between the hardware counter and the reference counter.

Modified the get_entry_statistics functions signature by adding a new
argument allowing the user to reset the statistics at the exact instant
when they are read.

Added two more functions to reset statistics (by key and by ref) to
allow the user to reset entry statistics without reading them.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  302 +++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |   83 ++++--
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   20 +-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  206 ++++++++------
 include/linux/fsl_dpa_classifier.h                 |   20 ++-
 5 files changed, 411 insertions(+), 220 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index a95cdfb..9dc07fe 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -215,7 +215,8 @@ int dpa_classif_table_free(int td)
 	int err;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 
 	ptable = table[td];
@@ -264,7 +265,8 @@ int dpa_classif_table_modify_miss_action(int			td,
 	struct dpa_cls_table *ptable;
 	t_Handle fm_pcd;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(miss_action, "miss_action", -EINVAL);
 
@@ -338,9 +340,10 @@ int dpa_classif_table_insert_entry(int				td,
 				int				priority,
 				int				*entry_id)
 {
-	int errno;
+	int err = 0;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
@@ -358,32 +361,33 @@ int dpa_classif_table_insert_entry(int				td,
 
 	switch (table[td]->params.type) {
 	case DPA_CLS_TBL_INDEXED:
-		errno = table_insert_entry_indexed(table[td],
+		err = table_insert_entry_indexed(table[td],
 						key,
 						action,
 						entry_id);
-		if (errno < 0)
-			return errno;
 		break;
 	case DPA_CLS_TBL_HASH:
-		errno = table_insert_entry_hash(table[td],
+		err = table_insert_entry_hash(table[td],
 						key,
 						action,
 						entry_id);
-		if (errno < 0)
-			return errno;
 		break;
 	case DPA_CLS_TBL_EXACT_MATCH:
-		errno = table_insert_entry_exact_match(table[td],
+		err = table_insert_entry_exact_match(table[td],
 						key,
 						action,
 						entry_id);
-		if (errno < 0)
-			return errno;
 		break;
+#ifdef DPA_OFFLOAD_DEBUG
+	default:
+		xx_pr_err("Unknown table type (%d).",
+			(int)table[td]->params.type);
+		err = -EINVAL;
+		break;
+#endif /* DPA_OFFLOAD_DEBUG */
 	}
 
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_insert_entry);
 
@@ -391,21 +395,14 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		const struct dpa_cls_tbl_key			*key,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
-	struct list_head *list_entry;
-	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	int entry_id;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
-	/* Check for shadow table */
-	if (!table[td]->shadow_table) {
-		xx_pr_err("Cannot modify entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
-		return -ENOSYS;
-	}
-
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 		(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
@@ -413,20 +410,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		return -ENOSYS;
 	}
 
-	/* Find the shadow entry associated with this key */
-	list_entry = find_shadow_entry(table[td], key);
-	if (list_entry == NULL) {
-		xx_pr_err("DPA Classifier table entry not found.");
-		return -ENODEV;
-	}
-
-	if (table[td]->params.type == DPA_CLS_TBL_INDEXED)
-		entry_id = key->byte[0];
-	else {
-		shadow_entry = list_entry(list_entry,
-				struct dpa_cls_tbl_shadow_entry,
-				list_node);
-		entry_id = shadow_entry->entry_id;
+	entry_id = key_to_entry_id(table[td], key);
+	if (entry_id < 0) {
+		xx_pr_err("Unable to determine entry_id.");
+		return entry_id;
 	}
 
 	return dpa_classif_table_modify_entry_by_ref(td, entry_id, mod_params);
@@ -455,7 +442,8 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	uint8_t index;
 	struct list_head *bucket_head;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
@@ -635,33 +623,17 @@ EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_ref);
 int dpa_classif_table_delete_entry_by_key(int				td,
 					const struct dpa_cls_tbl_key	*key)
 {
-	struct list_head *list_entry;
 	int entry_id;
-	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 
-	if (!table[td]->shadow_table) {
-		xx_pr_err("Cannot delete entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
-		return -ENOSYS;
-	}
-
-	/* Find the shadow entry associated with this key */
-	list_entry = find_shadow_entry(table[td], key);
-	if (list_entry == NULL) {
-		xx_pr_err("DPA Classifier table entry not found.");
-		return -ENODEV;
-	}
-
-	if (table[td]->params.type == DPA_CLS_TBL_INDEXED)
-		entry_id = key->byte[0];
-	else {
-		shadow_entry = list_entry(list_entry,
-					struct dpa_cls_tbl_shadow_entry,
-					list_node);
-		entry_id = shadow_entry->entry_id;
+	entry_id = key_to_entry_id(table[td], key);
+	if (entry_id < 0) {
+		xx_pr_err("Unable to determine entry_id.");
+		return entry_id;
 	}
 
 	return dpa_classif_table_delete_entry_by_ref(td, entry_id);
@@ -682,7 +654,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	struct list_head *bucket_head;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 
 	ptable = table[td];
@@ -759,7 +732,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 				int_cc_node->entry[i].entry_index--;
 	}
 
-		int_cc_node->entry[entry_index].valid = false;
+		int_cc_node->entry[entry_index].valid = 0;
 	}
 	int_cc_node->used--;
 
@@ -802,7 +775,8 @@ int dpa_classif_table_lookup_by_key(int				td,
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
@@ -844,7 +818,8 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	uint8_t entry_index;
 	struct list_head *bucket_head;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
@@ -911,7 +886,8 @@ int dpa_classif_table_flush(int td)
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 
 	ptable = table[td];
@@ -992,7 +968,7 @@ int dpa_classif_table_flush(int td)
 				}
 
 				int_cc_node->used--;
-				int_cc_node->entry[j].valid = false;
+				int_cc_node->entry[j].valid = 0;
 
 		/*
 		 * Update the index management for the Cc node that this entry
@@ -1021,54 +997,120 @@ EXPORT_SYMBOL(dpa_classif_table_flush);
 
 int dpa_classif_table_get_entry_stats_by_key(int			td,
 					const struct dpa_cls_tbl_key	*key,
-					struct dpa_cls_tbl_entry_stats	*stats)
+					struct dpa_cls_tbl_entry_stats	*stats,
+					int				reset)
 {
 	int entry_id;
-	struct list_head *list_entry;
-	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
-	if (!table[td]->shadow_table) {
-		xx_pr_err("Cannot get stats by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
-		return -ENOSYS;
-	}
-
-	/* Find the shadow entry associated with this key */
-	list_entry = find_shadow_entry(table[td], key);
-	if (list_entry == NULL) {
-		xx_pr_err("DPA Classifier table entry not found.");
-		return -ENODEV;
-	}
-
-	if (table[td]->params.type == DPA_CLS_TBL_INDEXED)
-		entry_id = key->byte[0];
-	else {
-		shadow_entry = list_entry(list_entry,
-					struct dpa_cls_tbl_shadow_entry,
-					list_node);
-		entry_id = shadow_entry->entry_id;
+	entry_id = key_to_entry_id(table[td], key);
+	if (entry_id < 0) {
+		xx_pr_err("Unable to determine entry_id.");
+		return entry_id;
 	}
 
-	return dpa_classif_table_get_entry_stats_by_ref(td, entry_id, stats);
+	return dpa_classif_table_get_entry_stats_by_ref(td,
+							entry_id,
+							stats,
+							reset);
 }
 EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_key);
 
 int dpa_classif_table_get_entry_stats_by_ref(int		td,
 				int				entry_id,
-				struct dpa_cls_tbl_entry_stats	*stats)
+				struct dpa_cls_tbl_entry_stats	*stats,
+				int				reset)
 {
 	unsigned int cc_node_index;
 	uint8_t entry_index;
 	t_Handle fm_pcd, cc_node;
+	struct dpa_cls_table *ptable;
+	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
+	ptable = table[td];
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		cc_node_index	= 0;
+		entry_index	= (uint8_t)entry_id;
+	} else {
+		cc_node_index	= ENTRY_ID_GET_NODE(entry_id);
+		entry_index	= (uint8_t)ENTRY_ID_GET_INDEX(entry_id);
+	}
+
+	xx_sanity_check_return_value((cc_node_index <
+			ptable->int_cc_nodes_count),
+		"entry_id",
+		-EINVAL);
+	xx_sanity_check_return_value((entry_index <
+			ptable->int_cc_node[cc_node_index].table_size),
+		"entry_id",
+		-EINVAL);
+
+	fm_pcd = (t_Handle)ptable->params.fm_pcd;
+	cc_node = (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
+	index_entry = &ptable->int_cc_node[cc_node_index].entry[entry_index];
+	stats->total_pkts = (unsigned long) FM_PCD_CcNodeGetKeyCounter(fm_pcd,
+						cc_node,
+						index_entry->entry_index);
+
+	if (stats->total_pkts < index_entry->last_stats.total_pkts)
+		/* Roll over */
+		index_entry->stats.total_pkts +=
+			((unsigned long int)0xffffffff -
+			index_entry->last_stats.total_pkts) + stats->total_pkts;
+	else
+		index_entry->stats.total_pkts += stats->total_pkts -
+					index_entry->last_stats.total_pkts;
+	index_entry->last_stats.total_pkts = stats->total_pkts;
+	stats->total_pkts = index_entry->stats.total_pkts;
+	if (reset)
+		index_entry->stats.total_pkts = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_ref);
+
+int dpa_classif_table_reset_entry_stats_by_key(int			td,
+					const struct dpa_cls_tbl_key	*key)
+{
+	int entry_id;
+
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
+	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+	xx_sanity_check_return_value(key, "key", -EINVAL);
+
+	entry_id = key_to_entry_id(table[td], key);
+	if (entry_id < 0) {
+		xx_pr_err("Unable to determine entry_id.");
+		return entry_id;
+	}
+
+	return dpa_classif_table_reset_entry_stats_by_ref(td, entry_id);
+}
+EXPORT_SYMBOL(dpa_classif_table_reset_entry_stats_by_key);
+
+int dpa_classif_table_reset_entry_stats_by_ref(int		td,
+				int				entry_id)
+{
+	unsigned int cc_node_index;
+	uint8_t entry_index;
+	struct dpa_cls_tbl_entry *index_entry;
+	t_Handle fm_pcd, cc_node;
+
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
+	xx_sanity_check_return_value(table[td], "td", -EINVAL);
+
 	if (table[td]->params.type == DPA_CLS_TBL_INDEXED) {
 		cc_node_index	= 0;
 		entry_index	= (uint8_t)entry_id;
@@ -1088,17 +1130,21 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 
 	fm_pcd = (t_Handle)table[td]->params.fm_pcd;
 	cc_node = (t_Handle)table[td]->int_cc_node[cc_node_index].cc_node;
-	stats->total_pkts = (unsigned long) FM_PCD_CcNodeGetKeyCounter(fm_pcd,
-							cc_node,
-							entry_index);
+	index_entry = &table[td]->int_cc_node[cc_node_index].entry[entry_index];
+	index_entry->last_stats.total_pkts =
+		(unsigned long) FM_PCD_CcNodeGetKeyCounter(fm_pcd,
+						cc_node,
+						index_entry->entry_index);
+	index_entry->stats.total_pkts = 0;
 
 	return 0;
 }
-EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_ref);
+EXPORT_SYMBOL(dpa_classif_table_reset_entry_stats_by_ref);
 
 int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
 {
-	xx_sanity_check_return_value((td < num_tables), "td", -EINVAL);
+	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
+		-EINVAL);
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(params, "params", -EINVAL);
 
@@ -1190,6 +1236,15 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 		}
 	}
 
+	/* Allocate the index management array */
+	cls_table->int_cc_node[0].entry = (struct dpa_cls_tbl_entry *)
+		xx_zalloc(cls_table->int_cc_node[0].table_size *
+			sizeof(struct dpa_cls_tbl_entry));
+	if (!cls_table->int_cc_node[0].entry) {
+		xx_pr_err("No more memory for DPA Classifier table index management.");
+		return -ENOMEM;
+	}
+
 	return 0;
 }
 
@@ -1598,8 +1653,8 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 		if (cls_table->params.type == DPA_CLS_TBL_HASH)
 			key_size = cls_table->params.hash_params.key_size;
 		else
-			key_size = cls_table->params.exact_match_params.
-								key_size;
+			key_size =
+				cls_table->params.exact_match_params.key_size;
 
 		shadow_table_index = crc8(key->byte, key_size);
 
@@ -1653,6 +1708,10 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	xx_assert(action);
 	xx_assert(cls_table->params.type == DPA_CLS_TBL_INDEXED);
 
+	/* Check the index management array if the entry is already used */
+	if (cls_table->int_cc_node[0].entry[key->byte[0]].valid)
+		return -EEXIST;
+
 	memset(&next_engine_params, 0 , sizeof(next_engine_params));
 	errno = action_to_next_engine_params(action, &next_engine_params);
 	if (errno < 0)
@@ -1695,6 +1754,13 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 			&cls_table->shadow_table->shadow_entry[key->byte[0]]);
 	}
 
+	/* Clean up and prepare the index entry */
+	memset(&cls_table->int_cc_node[0].entry[key->byte[0]], 0,
+		sizeof(struct dpa_cls_tbl_entry));
+	cls_table->int_cc_node[0].entry[key->byte[0]].valid = 1;
+	cls_table->int_cc_node[0].entry[key->byte[0]].entry_index =
+		key->byte[0];
+
 	if (entry_id)
 		*entry_id = key->byte[0];
 
@@ -1816,7 +1882,10 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	xx_assert(j < cls_table->int_cc_node[i].table_size);
 
-	cls_table->int_cc_node[i].entry[j].valid = true;
+	/* Clean up and prepare the index entry */
+	memset(&cls_table->int_cc_node[i].entry[j], 0,
+		sizeof(struct dpa_cls_tbl_entry));
+	cls_table->int_cc_node[i].entry[j].valid = 1;
 	cls_table->int_cc_node[i].entry[j].entry_index =
 		(uint8_t)cls_table->int_cc_node[i].used;
 
@@ -1940,7 +2009,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 	xx_assert(j < cls_table->int_cc_node[hash_set_index].table_size);
 
-	cls_table->int_cc_node[hash_set_index].entry[j].valid = true;
+	/* Clean up and prepare the index entry */
+	memset(&cls_table->int_cc_node[hash_set_index].entry[j], 0,
+		sizeof(struct dpa_cls_tbl_entry));
+	cls_table->int_cc_node[hash_set_index].entry[j].valid = 1;
 	cls_table->int_cc_node[hash_set_index].entry[j].entry_index =
 			(uint8_t)cls_table->int_cc_node[hash_set_index].used;
 
@@ -2064,6 +2136,34 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 	return 0;
 }
 
+static int key_to_entry_id(const struct dpa_cls_table *cls_table,
+	const struct dpa_cls_tbl_key *key)
+{
+	struct dpa_cls_tbl_shadow_entry *shadow_entry;
+	struct list_head *shadow_list_entry;
+
+	if (cls_table->params.type == DPA_CLS_TBL_INDEXED)
+		return (int)key->byte[0];
+
+	if (!cls_table->shadow_table) {
+		xx_pr_err("Cannot use runtime functions based on key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+		return -ENOSYS;
+	}
+
+	/* Find the shadow entry associated with this key */
+	shadow_list_entry = find_shadow_entry(cls_table, key);
+	if (shadow_list_entry == NULL) {
+		xx_pr_err("DPA Classifier table entry not found.");
+		return -ENODEV;
+	}
+
+	shadow_entry = list_entry(shadow_list_entry,
+				struct dpa_cls_tbl_shadow_entry,
+				list_node);
+
+	return shadow_entry->entry_id;
+}
+
 static int extend_table_array(void)
 {
 	unsigned int new_table_size = 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 77f351e..d202b88 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -61,15 +61,33 @@
 /* Index management entry */
 struct dpa_cls_tbl_entry {
 
-	bool			valid;		/* true if this entry
-						 * is valid */
-	uint8_t			entry_index;	/* The index of this entry
-						 * in the Cc node table */
-	struct list_head	*shadow_entry;	/* Pointer to the shadow
-						 * entry (if there is
-						 * one) associated with
-						 * this index management
-						 * entry */
+	/**
+	 * \brief	Nonzero if this entry is valid
+	 */
+	int				valid;
+
+	/**
+	 * \brief	The index of this entry in the Cc node table
+	 */
+	uint8_t				entry_index;
+
+	/**
+	 * \brief	Pointer to the shadow entry (if there is one) associated
+	 *		with this index management entry
+	 */
+	struct list_head		*shadow_entry;
+
+	/**
+	 * \brief	Last packet statistics for this entry.
+	 */
+	struct dpa_cls_tbl_entry_stats	stats;
+
+	/**
+	 * \brief	Last statistics counters provided by the low level
+	 *		driver. This is used for low level driver counter roll
+	 *		over protection.
+	 */
+	struct dpa_cls_tbl_entry_stats	last_stats;
 };
 
 /*
@@ -114,21 +132,27 @@ struct dpa_cls_tbl_shadow_table {
 /* Internal FMan Cc Node Management Info */
 struct dpa_cls_tbl_cc_node_info {
 
-	void				*cc_node;	/* Low level driver
-							 * (FMD) handle of
-							 * the Cc node */
-	unsigned int			table_size;	/* The size of this
-							 * Cc node's lookup
-							 * table */
-	unsigned int			used;		/* Number of entries
-							 * in the lookup
-							 * table that are
-							 * currently in
-							 * use */
-	struct dpa_cls_tbl_entry	*entry;		/* Index management
-							 * array. The size
-							 * of this array is
-							 * table_size */
+	/**
+	 * \brief	Low level driver (FMD) handle of the Cc node
+	 */
+	void				*cc_node;
+
+	/**
+	 * \brief	The size of this Cc node's lookup table
+	 */
+	unsigned int			table_size;
+
+	/**
+	 * \brief	Number of entries in the lookup table that are
+	 *		currently in use
+	 */
+	unsigned int			used;
+
+	/**
+	 * \brief	Index management array. The size of this array is
+	 *		<i>table_size</i>
+	 */
+	struct dpa_cls_tbl_entry	*entry;
 };
 
 /* DPA Classifier Table Control Data Structure */
@@ -236,8 +260,15 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
  * Translates action parameters into next engine
  * parameters for use with the low level driver (FMD).
  */
-static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
-				t_FmPcdCcNextEngineParams *next_engine_params);
+static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
+			*action, t_FmPcdCcNextEngineParams *next_engine_params);
+
+/*
+ * Finds the entry_id reference of a table entry specified
+ * by key. This works only on tables managed by key.
+ */
+static int	key_to_entry_id(const struct dpa_cls_table *cls_table,
+	const struct dpa_cls_tbl_key *key);
 
 /*
  * Extends with one more step the array mapping the table
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 96d992a..769aa61 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -43,7 +43,7 @@
 
 
 struct ioc_dpa_cls_tbl_params {
-	struct dpa_cls_tbl_params tbl_params;
+	struct dpa_cls_tbl_params table_params;
 	int td;
 };
 
@@ -72,12 +72,12 @@ struct ioc_dpa_cls_tbl_entry_mod_by_ref {
 	struct dpa_cls_tbl_entry_mod_params mod_params;
 };
 
-struct ioc_dpa_cls_tbl_entry_del_by_key {
+struct ioc_dpa_cls_tbl_entry_by_key {
 	int td;
 	struct dpa_cls_tbl_key key;
 };
 
-struct ioc_dpa_cls_tbl_entry_del_by_ref {
+struct ioc_dpa_cls_tbl_entry_by_ref {
 	int td;
 	int entry_id;
 };
@@ -98,12 +98,14 @@ struct ioc_dpa_cls_tbl_entry_stats_by_key {
 	int td;
 	struct dpa_cls_tbl_key key;
 	struct dpa_cls_tbl_entry_stats stats;
+	int reset;
 };
 
 struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 	int td;
 	int entry_id;
 	struct dpa_cls_tbl_entry_stats stats;
+	int reset;
 };
 
 #define DPA_CLS_IOC_MAGIC				0xbe
@@ -127,13 +129,13 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 	_IOW(DPA_CLS_IOC_MAGIC, 5, struct ioc_dpa_cls_tbl_entry_mod_by_ref)
 
 #define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY		\
-	_IOW(DPA_CLS_IOC_MAGIC, 6, struct ioc_dpa_cls_tbl_entry_del_by_key)
+	_IOW(DPA_CLS_IOC_MAGIC, 6, struct ioc_dpa_cls_tbl_entry_by_key)
 
 #define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF		\
-	_IOW(DPA_CLS_IOC_MAGIC, 7, struct ioc_dpa_cls_tbl_entry_del_by_ref)
+	_IOW(DPA_CLS_IOC_MAGIC, 7, struct ioc_dpa_cls_tbl_entry_by_ref)
 
 #define DPA_CLS_IOC_TBL_LOOKUP_BY_KEY			\
-	_IOR(DPA_CLS_IOC_MAGIC, 8, struct ioc_dpa_cls_tbl_entry_del_by_key)
+	_IOR(DPA_CLS_IOC_MAGIC, 8, struct ioc_dpa_cls_tbl_lookup_by_key)
 
 #define DPA_CLS_IOC_TBL_LOOKUP_BY_REF			\
 	_IOR(DPA_CLS_IOC_MAGIC, 9, struct ioc_dpa_cls_tbl_lookup_by_ref)
@@ -147,6 +149,12 @@ struct ioc_dpa_cls_tbl_entry_stats_by_ref {
 #define DPA_CLS_IOC_TBL_GET_STATS_BY_REF		\
 	_IOR(DPA_CLS_IOC_MAGIC, 12, struct ioc_dpa_cls_tbl_entry_stats_by_ref)
 
+#define DPA_CLS_IOC_TBL_RESET_STATS_BY_KEY		\
+	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_by_key)
+
+#define DPA_CLS_IOC_TBL_RESET_STATS_BY_REF		\
+	_IOR(DPA_CLS_IOC_MAGIC, 11, struct ioc_dpa_cls_tbl_entry_by_ref)
+
 #define DPA_CLS_IOC_TBL_GET_PARAMS			\
 	_IOWR(DPA_CLS_IOC_MAGIC, 13, struct ioc_dpa_cls_tbl_params)
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 40408e6..9c34074 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -132,30 +132,30 @@ long wrp_dpa_classif_ioctl(
 	switch (cmd) {
 	case DPA_CLS_IOC_TBL_CREATE:
 	{
-		struct ioc_dpa_cls_tbl_params	prm;
-		struct file			*fm_pcd_file;
-		t_LnxWrpFmDev			*fm_wrapper_dev;
+		struct ioc_dpa_cls_tbl_params param;
+		struct file *fm_pcd_file;
+		t_LnxWrpFmDev *fm_wrapper_dev;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				   (struct ioc_dpa_cls_tbl_params *) args,
-				   sizeof(prm))) {
+				   sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_create user space args");
 			return -EBUSY;
 		}
 
 		/* Translate FM_PCD file descriptor */
-		fm_pcd_file = fcheck((unsigned int)prm.tbl_params.fm_pcd);
+		fm_pcd_file = fcheck((unsigned int)param.table_params.fm_pcd);
 		fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-		prm.tbl_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+		param.table_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
 
 		/* Call function */
-		ret = dpa_classif_table_create(&prm.tbl_params, &prm.td);
+		ret = dpa_classif_table_create(&param.table_params, &param.td);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_create result");
 			return -EBUSY;
 		}
@@ -169,46 +169,46 @@ long wrp_dpa_classif_ioctl(
 
 	case DPA_CLS_IOC_TBL_MODIFY_MISS_ACTION:
 	{
-		struct ioc_dpa_cls_tbl_miss_action	prm;
+		struct ioc_dpa_cls_tbl_miss_action param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				   (struct ioc_dpa_cls_tbl_miss_action *) args,
-				    sizeof(prm))) {
+				    sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_modify_miss_action user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_modify_miss_action(prm.td,
-							   &prm.miss_action);
+		ret = dpa_classif_table_modify_miss_action(param.td,
+							   &param.miss_action);
 
 		break;
 	}
 
 	case DPA_CLS_IOC_TBL_INSERT_ENTRY:
 	{
-		struct ioc_dpa_cls_tbl_entry_params	prm;
+		struct ioc_dpa_cls_tbl_entry_params param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				   (struct ioc_dpa_cls_tbl_entry_params *) args,
-				    sizeof(prm))) {
+				    sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_insert_entry user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_insert_entry(prm.td,
-						     &prm.key,
-						     &prm.action,
-						     prm.priority,
-						     &prm.entry_id);
+		ret = dpa_classif_table_insert_entry(param.td,
+						     &param.key,
+						     &param.action,
+						     param.priority,
+						     &param.entry_id);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_insert_entry result");
 			return -EBUSY;
 		}
@@ -218,104 +218,103 @@ long wrp_dpa_classif_ioctl(
 
 	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_KEY:
 	{
-		struct ioc_dpa_cls_tbl_entry_mod_by_key	prm;
+		struct ioc_dpa_cls_tbl_entry_mod_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 			      (struct ioc_dpa_cls_tbl_entry_mod_by_key *) args,
-			       sizeof(prm))) {
+			       sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_modify_entry_by_key(prm.td,
-							    &prm.key,
-							    &prm.mod_params);
+		ret = dpa_classif_table_modify_entry_by_key(param.td,
+							    &param.key,
+							    &param.mod_params);
 
 		break;
 	}
 
 	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_REF:
 	{
-		struct ioc_dpa_cls_tbl_entry_mod_by_ref	prm;
+		struct ioc_dpa_cls_tbl_entry_mod_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 			(struct ioc_dpa_cls_tbl_entry_mod_by_ref *) args,
-			sizeof(prm))) {
+			sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_modify_entry_by_ref(prm.td,
-							    prm.entry_id,
-							    &prm.mod_params);
+		ret = dpa_classif_table_modify_entry_by_ref(param.td,
+							    param.entry_id,
+							    &param.mod_params);
 
 		break;
 	}
 
 	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY:
 	{
-		struct ioc_dpa_cls_tbl_entry_del_by_key	prm;
+		struct ioc_dpa_cls_tbl_entry_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
-			(struct ioc_dpa_cls_tbl_entry_del_by_key *) args,
-			sizeof(prm))) {
+		if (copy_from_user(&param,
+			(struct ioc_dpa_cls_tbl_entry_by_key *) args,
+			sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_delete_entry_by_key(prm.td,
-							    &prm.key);
+		ret = dpa_classif_table_delete_entry_by_key(param.td,
+							    &param.key);
 
 		break;
 	}
 
 	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF:
 	{
-		struct ioc_dpa_cls_tbl_entry_del_by_ref	prm;
-
+		struct ioc_dpa_cls_tbl_entry_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
-			(struct ioc_dpa_cls_tbl_entry_del_by_ref *) args,
-			sizeof(prm))) {
+		if (copy_from_user(&param,
+			(struct ioc_dpa_cls_tbl_entry_by_ref *) args,
+			sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_delete_entry_by_ref(prm.td,
-							    prm.entry_id);
+		ret = dpa_classif_table_delete_entry_by_ref(param.td,
+							    param.entry_id);
 
 		break;
 	}
 
 	case DPA_CLS_IOC_TBL_LOOKUP_BY_KEY:
 	{
-		struct ioc_dpa_cls_tbl_lookup_by_key	prm;
+		struct ioc_dpa_cls_tbl_lookup_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				(struct ioc_dpa_cls_tbl_lookup_by_key *) args,
-				sizeof(prm))) {
+				sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_lookup_by_key(prm.td,
-						      &prm.key,
-						      &prm.action);
+		ret = dpa_classif_table_lookup_by_key(param.td,
+						      &param.key,
+						      &param.action);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_lookup_by_key result");
 			return -EBUSY;
 		}
@@ -325,26 +324,25 @@ long wrp_dpa_classif_ioctl(
 
 	case DPA_CLS_IOC_TBL_LOOKUP_BY_REF:
 	{
-		struct ioc_dpa_cls_tbl_lookup_by_ref	prm;
-
+		struct ioc_dpa_cls_tbl_lookup_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				(struct ioc_dpa_cls_tbl_lookup_by_ref *) args,
-				sizeof(prm))) {
+				sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_lookup_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_lookup_by_ref(prm.td,
-						      prm.entry_id,
-						      &prm.action);
+		ret = dpa_classif_table_lookup_by_ref(param.td,
+						      param.entry_id,
+						      &param.action);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_lookup_by_ref result");
 			return -EBUSY;
 		}
@@ -358,26 +356,26 @@ long wrp_dpa_classif_ioctl(
 
 	case DPA_CLS_IOC_TBL_GET_STATS_BY_KEY:
 	{
-		struct ioc_dpa_cls_tbl_entry_stats_by_key	prm;
-
+		struct ioc_dpa_cls_tbl_entry_stats_by_key param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 			(struct ioc_dpa_cls_tbl_entry_stats_by_key *) args,
-			sizeof(prm))) {
+			sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_get_entry_stats_by_key(prm.td,
-							       &prm.key,
-							       &prm.stats);
+		ret = dpa_classif_table_get_entry_stats_by_key(param.td,
+							       &param.key,
+							       &param.stats,
+							       param.reset);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_key result");
 			return -EBUSY;
 		}
@@ -387,26 +385,26 @@ long wrp_dpa_classif_ioctl(
 
 	case DPA_CLS_IOC_TBL_GET_STATS_BY_REF:
 	{
-		struct ioc_dpa_cls_tbl_entry_stats_by_ref	prm;
-
+		struct ioc_dpa_cls_tbl_entry_stats_by_ref param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 			(struct ioc_dpa_cls_tbl_entry_stats_by_ref *) args,
-			sizeof(prm))) {
+			sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_get_entry_stats_by_ref(prm.td,
-							       prm.entry_id,
-							       &prm.stats);
+		ret = dpa_classif_table_get_entry_stats_by_ref(param.td,
+							       param.entry_id,
+							       &param.stats,
+							       param.reset);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_ref result");
 			return -EBUSY;
 		}
@@ -414,26 +412,64 @@ long wrp_dpa_classif_ioctl(
 		break;
 	}
 
-	case DPA_CLS_IOC_TBL_GET_PARAMS:
+	case DPA_CLS_IOC_TBL_RESET_STATS_BY_KEY:
 	{
-		struct ioc_dpa_cls_tbl_params	prm;
+		struct ioc_dpa_cls_tbl_entry_by_key param;
+
+		/* Prepare arguments */
+		if (copy_from_user(&param,
+			(struct ioc_dpa_cls_tbl_entry_by_key *) args,
+			sizeof(param))) {
+			xx_pr_err("Could not read dpa_classif_table_reset_entry_stats_by_key user space args");
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_reset_entry_stats_by_key(param.td,
+							    &param.key);
+
+		break;
+	}
 
+	case DPA_CLS_IOC_TBL_RESET_STATS_BY_REF:
+	{
+		struct ioc_dpa_cls_tbl_entry_by_ref param;
+
+		/* Prepare arguments */
+		if (copy_from_user(&param,
+			(struct ioc_dpa_cls_tbl_entry_by_ref *) args,
+			sizeof(param))) {
+			xx_pr_err("Could not read dpa_classif_table_reset_entry_stats_by_ref user space args");
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_reset_entry_stats_by_ref(param.td,
+							    param.entry_id);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_GET_PARAMS:
+	{
+		struct ioc_dpa_cls_tbl_params param;
 
 		/* Prepare arguments */
-		if (copy_from_user(&prm,
+		if (copy_from_user(&param,
 				   (struct ioc_dpa_cls_tbl_params *) args,
-				   sizeof(prm))) {
+				   sizeof(param))) {
 			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
 		/* Call function */
-		ret = dpa_classif_table_get_params(prm.td, &prm.tbl_params);
+		ret = dpa_classif_table_get_params(param.td,
+						&param.table_params);
 		if (ret < 0)
 			return ret;
 
 		/* Return results to user space */
-		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
+		if (copy_to_user((void *) args, &param, sizeof(param))) {
 			xx_pr_err("Could not write dpa_classif_table_get_params result");
 			return -EBUSY;
 		}
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index a7ceb06..9a76d6a 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -407,7 +407,8 @@ int dpa_classif_table_flush(int td);
  */
 int dpa_classif_table_get_entry_stats_by_key(int			td,
 					const struct dpa_cls_tbl_key	*key,
-					struct dpa_cls_tbl_entry_stats	*stats);
+					struct dpa_cls_tbl_entry_stats	*stats,
+					int				reset);
 
 /*
  * Returns the statistics for a specified entry in a specified
@@ -415,7 +416,22 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
  */
 int dpa_classif_table_get_entry_stats_by_ref(int		td,
 				int				entry_id,
-				struct dpa_cls_tbl_entry_stats	*stats);
+				struct dpa_cls_tbl_entry_stats	*stats,
+				int				reset);
+
+/*
+ * Resets the statistics for a specified entry in a specified
+ * table. The entry is identified by its ref (pointer).
+ */
+int dpa_classif_table_reset_entry_stats_by_key(int			td,
+					const struct dpa_cls_tbl_key	*key);
+
+/*
+ * Resets the statistics for a specified entry in a specified
+ * table. The entry is identified by its ref (pointer).
+ */
+int dpa_classif_table_reset_entry_stats_by_ref(int		td,
+				int				entry_id);
 
 /* Returns the parameters of a classifier table. */
 int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params);
-- 
1.7.5.4

