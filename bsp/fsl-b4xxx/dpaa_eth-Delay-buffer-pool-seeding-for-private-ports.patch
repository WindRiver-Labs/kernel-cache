From 881ab56081481477b5051efdb8a5400ca160151f Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Thu, 7 Mar 2013 23:59:31 +0000
Subject: [PATCH 503/518] dpaa_eth: Delay buffer pool seeding for private
 ports

Until now, all private ports had to be configured to use the same
buffer size, as they all share a common buffer pool.

Create the framework for working with different buffer sizes on the
private ports; the common buffer pool is seeded with buffers large
enough to accomodate frames for all private ports. In order to be able
to compute the largest needed buffer size, the buffer pool seeding is
delayed until the first private interface is raised.

Temporarily disable the boot-time ethernet unit test, which required
the use of the common buffer pool.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig        |    2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   54 ++++++++++++++++++-------
 2 files changed, 40 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index d02081c..1195090 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -207,6 +207,6 @@ config DPAA_ETH_USE_NDO_SELECT_QUEUE
 config DPAA_ETH_UNIT_TESTS
 	bool "Run Unit Tests for DPAA Ethernet"
 	depends on DPA
-	default y
+	default n
 
 endif # NET_VENDOR_FREESCALE
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 4bc8f97..3b1f685 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -172,6 +172,8 @@ int dpa_free_pcd_fqids(struct device *, uint32_t) __attribute__((weak));
 static struct dpa_bp *dpa_bp_array[64];
 
 static struct dpa_bp *default_pool;
+static bool default_pool_seeded;
+static uint32_t default_buf_size;
 
 /* A set of callbacks for hooking into the fastpath at different points. */
 static struct dpaa_eth_hooks_s dpaa_eth_hooks;
@@ -487,7 +489,6 @@ dpa_bp_alloc(struct dpa_bp *dpa_bp)
 	dpa_bp->dev = &pdev->dev;
 
 	if (dpa_bp->kernel_pool) {
-		dpa_make_private_pool(dpa_bp);
 		if (!default_pool)
 			default_pool = dpa_bp;
 	} else {
@@ -1485,6 +1486,11 @@ static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
 	return ERR_PTR(-ENODEV);
 }
 
+static uint32_t dpa_bp_size(struct fm_port *rx_port)
+{
+	return DEFAULT_BUF_SIZE;
+}
+
 /**
  * Turn on HW checksum computation for this outgoing frame.
  * If the current protocol is not something we support in this regard
@@ -2719,6 +2725,7 @@ static int __cold dpa_start(struct net_device *net_dev)
 	int err, i;
 	struct dpa_priv_s *priv;
 	struct mac_device *mac_dev;
+	struct dpa_percpu_priv_s *percpu_priv;
 
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
@@ -2726,6 +2733,24 @@ static int __cold dpa_start(struct net_device *net_dev)
 	if (!mac_dev)
 		goto no_mac;
 
+	/*
+	 * Seed the global buffer pool at the first ifconfig up
+	 * of a private port. Update the percpu buffer counters
+	 * of each private interface.
+	 */
+	if (!priv->shared && !default_pool_seeded) {
+		default_pool->size = default_buf_size;
+		dpa_make_private_pool(default_pool);
+		default_pool_seeded = true;
+	}
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		if (!priv->shared && !percpu_priv->dpa_bp)
+			percpu_priv->dpa_bp = priv->dpa_bp;
+			percpu_priv->dpa_bp_count =
+				per_cpu_ptr(priv->dpa_bp->percpu_count, i);
+	}
+
 	dpaa_eth_napi_enable(priv);
 
 	err = mac_dev->init_phy(net_dev);
@@ -2922,14 +2947,6 @@ dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
 		goto _return_of_node_put;
 	} else if (has_kernel_pool) {
 		dpa_bp->target_count = DEFAULT_COUNT;
-		dpa_bp->size = DEFAULT_BUF_SIZE;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
-		if (dpa_bp->size > PAGE_SIZE) {
-			dev_warn(dev, "Default buffer size too large. "
-				     "Round down to PAGE_SIZE\n");
-			dpa_bp->size = PAGE_SIZE;
-		}
-#endif
 		dpa_bp->kernel_pool = 1;
 	}
 
@@ -3594,7 +3611,6 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 	for (i = 0; i < count; i++) {
 		if (i >= rx_port_param.num_pools)
 			break;
-
 		rx_port_param.pool_param[i].id = bp[i].bpid;
 		rx_port_param.pool_param[i].size = bp[i].size;
 	}
@@ -3762,9 +3778,6 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 		percpu_priv->net_dev = net_dev;
 
-		percpu_priv->dpa_bp = priv->dpa_bp;
-		percpu_priv->dpa_bp_count =
-			per_cpu_ptr(priv->dpa_bp->percpu_count, i);
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 		/* init the percpu list and add some skbs */
 		skb_queue_head_init(&percpu_priv->skb_list);
@@ -3932,8 +3945,6 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		err = PTR_ERR(dpa_bp);
 		goto bp_probe_failed;
 	}
-	if (!dpa_bp->kernel_pool)
-		is_shared = true;
 
 	mac_dev = dpa_mac_probe(_of_dev);
 	if (IS_ERR(mac_dev)) {
@@ -3944,6 +3955,19 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		txport = mac_dev->port_dev[TX];
 	}
 
+	if (!dpa_bp->kernel_pool)
+		is_shared = true;
+	else {
+		/*
+		 * For private ports, need to compute the size of the default
+		 * buffer pool, based on FMan port buffer layout;also update
+		 * the maximum buffer size for private ports if necessary
+		 */
+		dpa_bp->size = dpa_bp_size(rxport);
+		if (dpa_bp->size > default_buf_size)
+			default_buf_size = dpa_bp->size;
+	}
+
 	INIT_LIST_HEAD(&rxfqlist);
 	INIT_LIST_HEAD(&txfqlist);
 
-- 
1.7.5.4

