From aaa561ae648f60eb167d663e6e068b4199cd2699 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Mon, 4 Mar 2013 17:10:59 +0000
Subject: [PATCH 065/518] fmd: chosen node enablement for FMan parameters

Enabling support for additional FMan parameters via device tree chosen node mechanism.
The currect addition includes the following parameters:
- num-tnums
- num-dmas
- fifo-size
- buffer-layout
- vsp-window

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman.h       |   21 ++
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |  108 ++++++++-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.h          |    1 +
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c     |  235 +++++++++++++++++++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |    6 +-
 5 files changed, 345 insertions(+), 26 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
index 6afde38..3efc8ce 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
@@ -113,6 +113,11 @@ struct fm_port_params {
 	bool hash_results;  /**< Put the hash-results in the Rx/Tx buffer */
 	bool time_stamp;    /**< Put the time-stamp in the Rx/Tx buffer */
 	bool frag_enable;   /**< Fragmentation support, for OP only */
+	uint16_t data_align;  /**< value for selecting a data alignment (must be a power of 2);
+                               if write optimization is used, must be >= 16. */
+	uint8_t manip_extra_space;  /**< Maximum extra size needed (insertion-size minus removal-size);
+                                     Note that this field impacts the size of the buffer-prefix
+                                     (i.e. it pushes the data offset); */
 };
 
 /**************************************************************************//**
@@ -193,6 +198,22 @@ void fm_set_rx_port_params(struct fm_port *port,
 void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
 
 /**************************************************************************//**
+ @Function	fm_port_get_buff_layout_ext_params
+
+ @Description	Get data_align and manip_extra_space from the device tree
+                chosen node if aplied. 
+                This function will only update these two parameters.
+                When this port has no such parameters in the device tree
+                values will be set to 0.
+
+ @Param[in]	port	- A handle of the FM port device.
+ @Param[in]	params	- PCD port parameters
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_params *params);
+
+/**************************************************************************//**
  @Function	fm_get_tx_port_channel
 
  @Description	Get qman-channel number for this Tx port.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index 8f715a8..1cc4016 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -77,6 +77,10 @@
 #include "lnxwrp_sysfs_fm.h"
 #include "lnxwrp_sysfs_fm_port.h"
 
+extern struct device_node *GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
+                                                         e_FmPortType       portType,
+                                                         uint8_t            portId);
+
 #define PROC_PRINT(args...) offset += sprintf(buf+offset,args)
 
 #define ADD_ADV_CONFIG_NO_RET(_func, _param)    \
@@ -407,19 +411,6 @@ typedef _Packed struct {
             p_LnxWrpFmDev->rxPorts[FM_MAX_NUM_OF_1G_RX_PORTS+i].settings.param.specificParams.rxParams.liodnOffset =
                 p_Ppids->fmbm_ppid[phys10GRxPortId[i]-1];
 
-#ifdef FM_OP_PARTITION_ERRATA_FMANx8
-    for (i=0; i<FM_MAX_NUM_OF_OH_PORTS; i++)
-    {
-        /* OH port #0 is host-command, don't need this workaround */
-        if (i == 0)
-            continue;
-        if (fmRev == 0x0100)
-            /* TODO: this was opPartitionId = ; opLiodnOffset seems to have the same meaning */
-            p_LnxWrpFmDev->opPorts[i-1].settings.param.specificParams.nonRxParams.opLiodnOffset =
-                p_Ppids->fmbm_ppid[physOhPortId[i]-1];
-    }
-#endif  /* FM_OP_PARTITION_ERRATA_FMANx8 */
-
     return E_OK;
 }
 
@@ -657,6 +648,61 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
     return p_LnxWrpFmDev;
 }
 
+struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx)
+{
+    struct device_node  *dev_node;
+    const uint32_t      *uint32_prop;
+    int                 lenp;
+
+    for_each_compatible_node(dev_node, NULL, "fsl,fman-extended-args") {
+        uint32_prop = (uint32_t *)of_get_property(dev_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("of_get_property(%s, cell-index) failed",
+                          dev_node->full_name));
+            return NULL;
+        }
+        if (WARN_ON(lenp != sizeof(uint32_t)))
+            return NULL;
+        if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+            return NULL;
+        }
+        if (fmIndx == *uint32_prop)
+            return dev_node;
+    }
+
+    return NULL;
+}
+
+static t_Error CheckNConfigFmAdvArgs (t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+    struct device_node  *dev_node;
+    t_Error             err = E_INVALID_VALUE;
+    /*const uint32_t      *uint32_prop;*/
+    const char          *str_prop;
+    int                 lenp;
+
+    dev_node = GetFmAdvArgsDevTreeNode(p_LnxWrpFmDev->id);
+    if (!dev_node) /* no advance parameters for FMan */
+        return E_OK;
+
+    str_prop = (char *)of_get_property(dev_node, "dma-aid-mode", &lenp);
+    if (str_prop) {
+        if (strcmp(str_prop, "port") == 0)
+            err = FM_ConfigDmaAidMode(p_LnxWrpFmDev->h_Dev, e_FM_DMA_AID_OUT_PORT_ID);
+        else if (strcmp(str_prop, "tnum") == 0)
+            err = FM_ConfigDmaAidMode(p_LnxWrpFmDev->h_Dev, e_FM_DMA_AID_OUT_TNUM);
+    }
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    of_node_put(dev_node);
+
+    return E_OK;
+}
+
 static void LnxwrpFmDevExceptionsCb(t_Handle h_App, e_FmExceptions exception)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
@@ -834,6 +880,8 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
                            DEFAULT_TOTAL_FIFO_SIZE_FOR_FMAN_V3H);
 #endif /* (DPAA_VERSION >= 11) */
 
+    CheckNConfigFmAdvArgs(p_LnxWrpFmDev);
+
     if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
@@ -1161,6 +1209,40 @@ void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params)
 }
 EXPORT_SYMBOL(fm_port_pcd_bind);
 
+void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)port;
+    struct device_node  *fm_node, *port_node;
+    const uint32_t       *uint32_prop;
+    int                  lenp;
+
+    params->data_align = 0;
+    params->manip_extra_space = 0;
+
+    fm_node = GetFmAdvArgsDevTreeNode(((t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev)->id);
+    if (!fm_node) /* no advance parameters for FMan */
+        return;
+
+    port_node = GetFmPortAdvArgsDevTreeNode(fm_node,
+                                            p_LnxWrpFmPortDev->settings.param.portType,
+                                            p_LnxWrpFmPortDev->settings.param.portId);
+    if (!port_node) /* no advance parameters for FMan-Port */
+        return;
+
+    uint32_prop = (uint32_t *)of_get_property(port_node, "buffer-layout", &lenp);
+    if (uint32_prop) {
+       if (WARN_ON(lenp != sizeof(uint32_t)*2))
+            return;
+
+        params->manip_extra_space = (uint8_t)uint32_prop[0];
+        params->data_align        = (uint16_t)uint32_prop[1];
+    }
+
+    of_node_put(port_node);
+    of_node_put(fm_node);
+}
+EXPORT_SYMBOL(fm_port_get_buff_layout_ext_params);
+
 int fm_get_tx_port_channel(struct fm_port *port)
 {
     t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
index 40f0934..b2dee57 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
@@ -108,6 +108,7 @@ typedef struct {
     t_Handle                    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmBufferPrefixContent     buffPrefixContent;
     t_Handle                    h_Dev;
+    t_Handle                    h_DfltVsp;
     t_Handle                    h_LnxWrpFmDev;
     uint16_t                    txCh;
     struct device               *dev;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
index 8ddc46a..0f83e8c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
@@ -54,10 +54,15 @@
 #include "sprint_ext.h"
 #include "fm_common.h"
 #include "fm_port_ext.h"
+#if (DPAA_VERSION >= 11)
+#include "fm_vsp_ext.h"
+#endif /* DPAA_VERSION >= 11 */
 #include "fm_ioctls.h"
 #include "lnxwrp_resources.h"
 #include "lnxwrp_sysfs_fm_port.h"
 
+extern struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx);
+
 /* TODO: duplicated, see lnxwrp_fm.c */
 #define ADD_ADV_CONFIG_NO_RET(_func, _param)\
 do {\
@@ -429,6 +434,208 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 	return p_LnxWrpFmPortDev;
 }
 
+struct device_node * GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
+                                                         e_FmPortType       portType,
+                                                         uint8_t            portId)
+{
+    struct device_node  *port_node;
+    const uint32_t      *uint32_prop;
+    int                 lenp;
+    char                *portTypeString;
+
+    switch(portType) {
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
+            portTypeString = "fsl,fman-port-op-extended-args";
+            break;
+        case e_FM_PORT_TYPE_TX:
+            portTypeString = "fsl,fman-port-1g-tx-extended-args";
+            break;
+        case e_FM_PORT_TYPE_TX_10G:
+            portTypeString = "fsl,fman-port-10g-tx-extended-args";
+            break;
+        case e_FM_PORT_TYPE_RX:
+            portTypeString = "fsl,fman-port-1g-rx-extended-args";
+            break;
+        case e_FM_PORT_TYPE_RX_10G:
+            portTypeString = "fsl,fman-port-10g-rx-extended-args";
+            break;
+        default:
+            return NULL;
+    }
+
+    for_each_child_of_node(fm_node, port_node) {
+        uint32_prop = (uint32_t *)of_get_property(port_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("of_get_property(%s, cell-index) failed",
+                          port_node->full_name));
+            return NULL;
+        }
+        if (WARN_ON(lenp != sizeof(uint32_t)))
+            return NULL;
+		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OH_PORTS)) {
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+				     ("of_get_property(%s, cell-index) failed",
+				      port_node->full_name));
+			return NULL;
+		}
+
+    	if ((portId == *uint32_prop) &&
+    	    (of_device_is_compatible(port_node, portTypeString))) {
+            return port_node;
+    	}
+    }
+ 
+    return NULL;
+}
+
+static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    struct device_node      *fm_node, *port_node;
+    t_Error                 err;
+    t_FmPortRsrc            portRsrc;
+    const uint32_t          *uint32_prop;
+    /*const char              *str_prop;*/
+    int                     lenp;
+
+    fm_node = GetFmAdvArgsDevTreeNode(((t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev)->id);
+    if (!fm_node) /* no advance parameters for FMan */
+        return E_OK;
+
+    port_node = GetFmPortAdvArgsDevTreeNode(fm_node,
+                                            p_LnxWrpFmPortDev->settings.param.portType,
+                                            p_LnxWrpFmPortDev->settings.param.portId);
+    if (!port_node) /* no advance parameters for FMan-Port */
+        return E_OK;
+
+    uint32_prop = (uint32_t *)of_get_property(port_node, "num-tnums", &lenp);
+    if (uint32_prop) {    
+    	if (WARN_ON(lenp != sizeof(uint32_t)*2))
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+ 
+        portRsrc.num   = uint32_prop[0];
+        portRsrc.extra = uint32_prop[1];
+ 
+        if ((err = FM_PORT_ConfigNumOfTasks(p_LnxWrpFmPortDev->h_Dev,
+                                            &portRsrc)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    
+    uint32_prop = (uint32_t *)of_get_property(port_node, "num-dmas", &lenp);
+    if (uint32_prop) {  
+    	if (WARN_ON(lenp != sizeof(uint32_t)*2))
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+ 
+        portRsrc.num   = uint32_prop[0];
+        portRsrc.extra = uint32_prop[1];
+ 
+        if ((err = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev,
+                                            &portRsrc)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    
+    uint32_prop = (uint32_t *)of_get_property(port_node, "fifo_size", &lenp);
+    if (uint32_prop) {
+    	if (WARN_ON(lenp != sizeof(uint32_t)*2))
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+ 
+        portRsrc.num   = uint32_prop[0];
+        portRsrc.extra = uint32_prop[1];
+ 
+        if ((err = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev,
+                                            &portRsrc)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    of_node_put(port_node);
+    of_node_put(fm_node);
+
+    return E_OK;
+}
+
+static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    struct device_node      *fm_node, *port_node;
+    t_Error                 err;
+    const uint32_t          *uint32_prop;
+    /*const char              *str_prop;*/
+    int                     lenp;
+
+    fm_node = GetFmAdvArgsDevTreeNode(((t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev)->id);
+    if (!fm_node) /* no advance parameters for FMan */
+        return E_OK;
+
+    port_node = GetFmPortAdvArgsDevTreeNode(fm_node,
+                                            p_LnxWrpFmPortDev->settings.param.portType,
+                                            p_LnxWrpFmPortDev->settings.param.portId);
+    if (!port_node) /* no advance parameters for FMan-Port */
+        return E_OK;
+
+#if (DPAA_VERSION >= 11)
+    uint32_prop = (uint32_t *)of_get_property(port_node, "vsp-window", &lenp);
+    if (uint32_prop) {
+        t_FmPortVSPAllocParams  portVSPAllocParams;
+        t_FmVspParams           fmVspParams;
+        t_LnxWrpFmDev           *p_LnxWrpFmDev;
+        uint8_t                 portId;
+
+        p_LnxWrpFmDev = ((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev);
+    	
+    	if (WARN_ON(lenp != sizeof(uint32_t)*2))
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+        if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX || 
+            p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
+            return E_OK;
+            
+        memset(&portVSPAllocParams, 0, sizeof(portVSPAllocParams));
+        memset(&fmVspParams, 0, sizeof(fmVspParams));
+
+        portVSPAllocParams.numOfProfiles = (uint8_t)uint32_prop[0];
+        portVSPAllocParams.dfltRelativeId = (uint8_t)uint32_prop[1];
+        fmVspParams.h_Fm = p_LnxWrpFmDev->h_Dev;
+        memcpy(&fmVspParams.extBufPools,
+               &p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools,
+               sizeof(t_FmExtPools));
+        fmVspParams.portParams.portType = p_LnxWrpFmPortDev->settings.param.portType;
+        fmVspParams.portParams.portId   = p_LnxWrpFmPortDev->settings.param.portId;
+        fmVspParams.relativeProfileId   = portVSPAllocParams.dfltRelativeId;
+
+        if (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        {
+            portId = fmVspParams.portParams.portId;
+            if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+                portId += FM_MAX_NUM_OF_1G_RX_PORTS;
+            portVSPAllocParams.h_FmTxPort = p_LnxWrpFmDev->txPorts[portId].h_Dev;
+            fmVspParams.liodnOffset = 
+                p_LnxWrpFmDev->rxPorts[portId].settings.param.specificParams.rxParams.liodnOffset;
+        }
+
+        if ((err = FM_PORT_VSPAlloc(p_LnxWrpFmPortDev->h_Dev,
+                                    &portVSPAllocParams)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        p_LnxWrpFmPortDev->h_DfltVsp = FM_VSP_Config(&fmVspParams);
+        if (!p_LnxWrpFmPortDev->h_DfltVsp)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("default-VSP for port!"));
+
+        if ((err = FM_VSP_ConfigBufferPrefixContent(p_LnxWrpFmPortDev->h_DfltVsp,
+                                                    &p_LnxWrpFmPortDev->buffPrefixContent)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        if ((err = FM_VSP_Init(p_LnxWrpFmPortDev->h_DfltVsp)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+#else
+UNUSED(err); UNUSED(uint32_prop); UNUSED(lenp);
+#endif /* (DPAA_VERSION >= 11) */
+
+    of_node_put(port_node);
+    of_node_put(fm_node);
+
+    return E_OK;
+}
+
 static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
@@ -566,9 +773,15 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 #endif
 #endif
 
+    if (CheckNConfigFmPortAdvArgs(p_LnxWrpFmPortDev) != E_OK)
+		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
 	if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
 		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
+    if (CheckNSetFmPortAdvArgs(p_LnxWrpFmPortDev) != E_OK)
+		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
 /* FMan Fifo sizes behind the scene":
  * Using the following formulae (*), under a set of simplifying assumptions (.):
  *  . all ports are configured in Normal Mode (rather than Independent Mode)
@@ -650,6 +863,10 @@ void fm_set_rx_port_params(struct fm_port *port,
 		params->hash_results;
 	p_LnxWrpFmPortDev->buffPrefixContent.passTimeStamp =
 		params->time_stamp;
+	p_LnxWrpFmPortDev->buffPrefixContent.dataAlign =
+		params->data_align;
+	p_LnxWrpFmPortDev->buffPrefixContent.manipExtraSpace =
+		params->manip_extra_space;
 
 	ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig,
 			     FM_MAX_NUM_OF_ADV_SETTINGS)
@@ -683,18 +900,12 @@ void fm_set_tx_port_params(struct fm_port *port,
 		params->hash_results;
 	p_LnxWrpFmPortDev->buffPrefixContent.passTimeStamp =
 		params->time_stamp;
-	p_LnxWrpFmPortDev->settings.frag_enabled = FALSE;
-
-	if ((params->frag_enable == TRUE) &&
-		(p_LnxWrpFmPortDev->settings.param.portType ==
-			e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) {
-
-		p_LnxWrpFmPortDev->settings.frag_enabled = TRUE;
-		p_LnxWrpFmPortDev->buffPrefixContent.dataAlign =
-			FRAG_DATA_ALIGN;
-		p_LnxWrpFmPortDev->buffPrefixContent.manipExtraSpace =
-			FRAG_MANIP_SPACE;
-	}
+	p_LnxWrpFmPortDev->settings.frag_enabled =
+		params->frag_enable;
+	p_LnxWrpFmPortDev->buffPrefixContent.dataAlign =
+		params->data_align;
+	p_LnxWrpFmPortDev->buffPrefixContent.manipExtraSpace =
+		params->manip_extra_space;
 
 	ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig,
 			     FM_MAX_NUM_OF_ADV_SETTINGS)
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 12292d4..765867e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -3522,6 +3522,10 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 		rx_port_param.pool_param[i].size = bp[i].size;
 	}
 
+/* TODO
+	rx_port_param.manip_extra_space = ???
+	rx_port_param.data_align = ???
+*/
 	dpaa_eth_init_port(rx, port, rx_port_param, errq->fqid, defq->fqid,
 			DPA_RX_PRIV_DATA_SIZE, has_timer);
 }
@@ -3972,9 +3976,9 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 	if (mac_dev) {
 		struct fm_port_pcd_param rx_port_pcd_param;
 
+		dpaa_eth_init_tx_port(txport, txerror, txdefault, has_timer);
 		dpaa_eth_init_rx_port(rxport, dpa_bp, count, rxerror,
 				rxdefault, has_timer);
-		dpaa_eth_init_tx_port(txport, txerror, txdefault, has_timer);
 
 		rx_port_pcd_param.cba = dpa_alloc_pcd_fqids;
 		rx_port_pcd_param.cbf = dpa_free_pcd_fqids;
-- 
1.7.5.4

