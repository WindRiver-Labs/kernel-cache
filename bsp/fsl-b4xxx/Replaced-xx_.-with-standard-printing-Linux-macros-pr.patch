From 571709c9f93c462615b768b691b2a8e3f1f4cbbc Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:14:43 +0000
Subject: [PATCH 213/518] Replaced xx_... with standard printing Linux macros
 (pr_err & friends)

updated all existent DPA offloading code in order to use
standard Linux print methods.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  192 ++++----
 drivers/staging/fsl_dpa_offload/dpa_compat.h       |   57 +---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c        |  477 ++++++++++----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c   |   22 +-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   98 ++--
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c    |  106 +++---
 6 files changed, 455 insertions(+), 497 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index c1029d0..611665c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -91,7 +91,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	ptable = (struct dpa_cls_table *)
 			xx_zalloc(sizeof(struct dpa_cls_table));
 	if (!ptable) {
-		xx_pr_err("No more memory for DPA classifier table.");
+		pr_err("No more memory for DPA classifier table.");
 		err = -ENOMEM;
 		goto dpa_classif_table_create_error;
 	}
@@ -104,7 +104,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			(struct dpa_cls_tbl_shadow_table *)
 			xx_zalloc(sizeof(*ptable->shadow_table));
 		if (!ptable->shadow_table) {
-			xx_pr_err("No more memory for DPA classifier shadow table.");
+			pr_err("No more memory for DPA classifier shadow table.");
 			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
 		}
@@ -162,7 +162,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			xx_malloc(ptable->shadow_table->size *
 					sizeof(struct list_head));
 		if (!ptable->shadow_table->shadow_entry) {
-			xx_pr_err("No more memory for DPA Classifier shadow tables.");
+			pr_err("No more memory for DPA Classifier shadow tables.");
 			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
 		}
@@ -281,7 +281,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 	ptable = table[td];
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		xx_pr_err("Miss Action for DPA Classifier Indexed Tables is not supported.");
+		pr_err("Miss Action for DPA Classifier Indexed Tables is not supported.");
 		return -ENOSYS;
 	}
 
@@ -300,9 +300,8 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 		int_cc_node[i].cc_node,	&miss_engine_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err,
-			"FM_PCD_MatchTableModifyMissNextEngine");
-		xx_pr_err("FMan driver call failed.");
+		pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine", __func__);
+		pr_err("FMan driver call failed.");
 		return -EBUSY;
 	}
 }
@@ -326,9 +325,9 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 			int_cc_node[i-1].cc_node, &miss_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err,
-				"FM_PCD_MatchTableModifyMissNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 	}
@@ -362,7 +361,7 @@ int dpa_classif_table_insert_entry(int				td,
 	 */
 	if ((table[td]->shadow_table) &&
 			(find_shadow_entry(table[td], key) != NULL)) {
-		xx_pr_err("DPA Classifier table entry already exists.");
+		pr_err("DPA Classifier table entry already exists.");
 		return -EEXIST;
 	}
 
@@ -388,7 +387,7 @@ int dpa_classif_table_insert_entry(int				td,
 		break;
 #ifdef DPA_OFFLOAD_DEBUG
 	default:
-		xx_pr_err("Unknown table type (%d).",
+		pr_err("Unknown table type (%d).",
 			(int)table[td]->params.type);
 		err = -EINVAL;
 		break;
@@ -414,13 +413,13 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 		(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		xx_pr_err("Modify entry key is supported only on exact match tables.");
+		pr_err("Modify entry key is supported only on exact match tables.");
 		return -ENOSYS;
 	}
 
 	entry_id = key_to_entry_id(table[td], key);
 	if (entry_id < 0) {
-		xx_pr_err("Unable to determine entry_id.");
+		pr_err("Unable to determine entry_id.");
 		return entry_id;
 	}
 
@@ -461,7 +460,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 			(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		xx_pr_err("Modify entry key is supported only on exact match tables.");
+		pr_err("Modify entry key is supported only on exact match tables.");
 		return -ENOSYS;
 	}
 
@@ -481,8 +480,9 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -507,8 +507,8 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				key_data,
 				mask_data);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyKey");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyKey\n", __func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -540,9 +540,9 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				ptable->params.exact_match_params.key_size,
 				&key_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err,
-				"FM_PCD_MatchTableModifyKeyAndNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyKeyAndNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -623,7 +623,7 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 
 	entry_id = key_to_entry_id(table[td], key);
 	if (entry_id < 0) {
-		xx_pr_err("Unable to determine entry_id.");
+		pr_err("Unable to determine entry_id.");
 		return entry_id;
 	}
 
@@ -674,8 +674,9 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -685,8 +686,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 		err = FM_PCD_MatchTableRemoveKey(cc_node,
 					entry_index);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableRemoveKey");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableRemoveKey\n", __func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -757,7 +758,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+		pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
@@ -801,7 +802,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+		pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
@@ -866,9 +867,9 @@ int dpa_classif_table_flush(int td)
 						index_entry->entry_index,
 						&next_engine_params);
 			if (err != E_OK) {
-				xx_pr_fmd_err(err,
-					"FM_PCD_MatchTableModifyNextEngine");
-				xx_pr_err("FMan driver call failed.");
+				pr_err("%s:FM_PCD_MatchTableModifyNextEngine\n",
+					__func__);
+				pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
 			index_entry->valid = 0;
@@ -914,9 +915,9 @@ int dpa_classif_table_flush(int td)
 			err = FM_PCD_MatchTableRemoveKey(cc_node,
 						index_entry->entry_index);
 			if (err != E_OK) {
-				xx_pr_fmd_err(err,
-					"FM_PCD_MatchTableRemoveKey");
-				xx_pr_err("FMan driver call failed.");
+				pr_err("%s: FM_PCD_MatchTableRemoveKey\n",
+					__func__);
+				pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
 
@@ -947,7 +948,7 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 
 	entry_id = key_to_entry_id(table[td], key);
 	if (entry_id < 0) {
-		xx_pr_err("Unable to determine entry_id.");
+		pr_err("Unable to determine entry_id.");
 		return entry_id;
 	}
 
@@ -1016,7 +1017,7 @@ int dpa_classif_table_reset_entry_stats_by_key(int			td,
 
 	entry_id = key_to_entry_id(table[td], key);
 	if (entry_id < 0) {
-		xx_pr_err("Unable to determine entry_id.");
+		pr_err("Unable to determine entry_id.");
 		return entry_id;
 	}
 
@@ -1076,7 +1077,7 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 		xx_zalloc(cls_table->int_cc_nodes_count *
 			sizeof(struct dpa_cls_tbl_cc_node_info));
 	if (!cls_table->int_cc_node) {
-		xx_pr_err("No more memory for DPA Classifier table management.");
+		pr_err("No more memory for DPA Classifier table management.");
 		err = -ENOMEM;
 		goto alloc_table_mgmt_error;
 	}
@@ -1131,8 +1132,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 						i,
 						&next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 	}
@@ -1143,7 +1145,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 		xx_zalloc(cls_table->entries_cnt *
 			sizeof(struct dpa_cls_tbl_entry));
 	if (!cls_table->entry) {
-		xx_pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt = 0;
 		return -ENOMEM;
 	}
@@ -1171,7 +1173,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	hash_set_params = (t_FmPcdCcNodeParams *)
 		xx_zalloc(sizeof(struct t_FmPcdCcNodeParams));
 	if (!hash_set_params) {
-		xx_pr_err("No more memory for DPA Classifier hash table.");
+		pr_err("No more memory for DPA Classifier hash table.");
 		err = -ENOMEM;
 		goto table_init_hash_error;
 	}
@@ -1208,8 +1210,8 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 			(void *)FM_PCD_MatchTableSet(fm_pcd,
 					hash_set_params);
 		if (cls_table->int_cc_node[i].cc_node == NULL) {
-			xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_MatchTableSet");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableSet\n", __func__);
+			pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1223,9 +1225,9 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 						(uint8_t)i,
 						&next_engine_params);
 		if (err_code != E_OK) {
-			xx_pr_fmd_err(err_code,
-				"FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1238,7 +1240,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		xx_zalloc(cls_table->entries_cnt *
 			sizeof(struct dpa_cls_tbl_entry));
 	if (!cls_table->entry) {
-		xx_pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt	= 0;
 		err			= -ENOMEM;
 		goto table_init_hash_error;
@@ -1285,7 +1287,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	cc_node_params = (t_FmPcdCcNodeParams *)
 		xx_zalloc(sizeof(t_FmPcdCcNodeParams));
 	if (!cc_node_params) {
-		xx_pr_err("No more memory for DPA Classifier exact match table.");
+		pr_err("No more memory for DPA Classifier exact match table.");
 		err = -ENOMEM;
 		goto table_init_exact_match_error;
 	}
@@ -1325,9 +1327,8 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 				(void *)FM_PCD_MatchTableSet(fm_pcd,
 					cc_node_params);
 			if (!cls_table->int_cc_node[i].cc_node) {
-				xx_pr_fmd_err(E_NOT_AVAILABLE,
-					"FM_PCD_MatchTableSet");
-				xx_pr_err("FMan driver call failed.");
+				pr_err("%s: FM_PCD_MatchTableSet\n", __func__);
+				pr_err("FMan driver call failed.");
 				err = -EBUSY;
 				goto table_init_exact_match_error;
 			}
@@ -1350,7 +1351,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 		xx_zalloc(cls_table->entries_cnt *
 			sizeof(struct dpa_cls_tbl_entry));
 	if (!cls_table->entry) {
-		xx_pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("No more memory for DPA Classifier table index management.");
 		cls_table->entries_cnt	= 0;
 		err			= -ENOMEM;
 		goto table_init_exact_match_error;
@@ -1405,9 +1406,10 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 			FM_PCD_MatchTableDelete((t_Handle)cls_table->
 				int_cc_node[i].cc_node);
 		else {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
-			xx_pr_warn("DPA Classifier failed to clean up hash table.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine",
+				__func__);
+			pr_err("FMan driver call failed.");
+			pr_warn("DPA Classifier failed to clean hash table.");
 		}
 	}
 }
@@ -1447,9 +1449,10 @@ static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 				FM_PCD_MatchTableDelete((t_Handle)cls_table->
 					int_cc_node[i].cc_node);
 		} else {
-			xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-			xx_pr_err("FMan driver call failed.");
-			xx_pr_warn("DPA Classifier failed to clean up exact match table.");
+			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
+			pr_warn("Classifier failed to clean exact match table");
 		}
 	}
 }
@@ -1469,13 +1472,13 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		 */
 		if (params->exact_match_params.entries_cnt >
 				3 * FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_warn("Large exact match tables might cause performance penalties.");
+			pr_warn("Large exact match tables might cause performance penalties.");
 			break;
 		}
 
 		if (params->exact_match_params.key_size >
 				FM_PCD_MAX_SIZE_OF_KEY) {
-			xx_pr_err("DPA Classifier exact match table key size (%d bytes) exceeds maximum (%d bytes).",
+			pr_err("DPA Classifier exact match table key size (%d bytes) exceeds maximum (%d bytes).",
 				params->exact_match_params.key_size,
 				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
@@ -1485,7 +1488,7 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		if ((params->exact_match_params.use_priorities) &&
 				(params->exact_match_params.entries_cnt >
 				FM_PCD_MAX_NUM_OF_KEYS)) {
-			xx_pr_err("Entry priorities for exact match tables are supported only for small tables (<= %d entries).",
+			pr_err("Entry priorities for exact match tables are supported only for small tables (<= %d entries).",
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -ENOSYS;
 			break;
@@ -1493,7 +1496,7 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		break;
 	case DPA_CLS_TBL_HASH:
 		if (params->hash_params.num_sets > FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err("DPA Classifier hash table number of sets (%d) exceeds maximum (%d).",
+			pr_err("DPA Classifier hash table number of sets (%d) exceeds maximum (%d).",
 				params->hash_params.num_sets,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1506,14 +1509,14 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		while (num_sets < params->hash_params.num_sets)
 			num_sets <<= 1;
 		if (num_sets != params->hash_params.num_sets) {
-			xx_pr_err("DPA Classifier hash table number of sets (%d) must be a power of 2.",
+			pr_err("DPA Classifier hash table number of sets (%d) must be a power of 2.",
 				params->hash_params.num_sets);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->hash_params.max_ways > FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err("DPA Classifier hash table number of ways (%d) exceeds maximum (%d).",
+			pr_err("DPA Classifier hash table number of ways (%d) exceeds maximum (%d).",
 				params->hash_params.max_ways,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1521,7 +1524,7 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		}
 
 		if (params->hash_params.key_size > FM_PCD_MAX_SIZE_OF_KEY) {
-			xx_pr_err("DPA Classifier hash table key size (%d bytes) exceeds maximum (%d bytes).",
+			pr_err("DPA Classifier hash table key size (%d bytes) exceeds maximum (%d bytes).",
 				params->hash_params.key_size,
 				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
@@ -1531,7 +1534,7 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 	case DPA_CLS_TBL_INDEXED:
 		if (params->indexed_params.entries_cnt >
 				FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err("DPA Classifier indexed table size (%d entries) exceeds maximum (%d entries).",
+			pr_err("DPA Classifier indexed table size (%d entries) exceeds maximum (%d entries).",
 				params->indexed_params.entries_cnt,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1539,13 +1542,13 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		}
 
 		if (params->indexed_params.entries_cnt == 0) {
-			xx_pr_err("Indexed table size zero is invalid.");
+			pr_err("Indexed table size zero is invalid.");
 			err = -EINVAL;
 			break;
 		}
 		break;
 	default:
-		xx_pr_err("Unsupported DPA Classifier table type (%d).",
+		pr_err("Unsupported DPA Classifier table type (%d).",
 			params->type);
 		err = -EINVAL;
 	}
@@ -1649,8 +1652,8 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 					key->byte[0],
 					&next_engine_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_MatchTableModifyNextEngine");
-		xx_pr_err("FMan driver call failed.");
+		pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n", __func__);
+		pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_indexed_error;
 	}
@@ -1662,7 +1665,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry_indexed *)
 			xx_zalloc(sizeof(*shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err("No more memory for a new DPA Classifier table entry.");
+			pr_err("No more memory for a new DPA Classifier table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_indexed_error;
 		}
@@ -1753,7 +1756,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	}
 	if (i >= cls_table->int_cc_nodes_count) {
 		/* No more space to add a new entry */
-		xx_pr_err("DPA Classifier exact match table is full. Unable to add a new entry.");
+		pr_err("DPA Classifier exact match table is full. Unable to add a new entry.");
 		errno = -ENOSPC;
 		goto table_insert_entry_exact_match_error;
 	}
@@ -1812,7 +1815,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			 * [entry_index]. In other words, add the current entry
 			 * before the first entry of the next cc node */
 			if (i < cls_table->int_cc_nodes_count - 1)
-				list_for_each(list_current, &cls_table->entry_list) {
+				list_for_each(list_current,
+					      &cls_table->entry_list) {
 					index_entry = list_entry(list_current,
 						struct dpa_cls_tbl_entry,
 						list_node);
@@ -1845,9 +1849,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
 		int_cc_node[i-1].cc_node, &cc_miss_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err,
-				"FM_PCD_MatchTableModifyMissNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			errno = -EBUSY;
 			goto table_insert_entry_exact_match_error;
 		}
@@ -1856,9 +1860,9 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)cls_table->
 		int_cc_node[i].cc_node, &cls_table->miss_next_engine_params);
 		if (err != E_OK) {
-			xx_pr_fmd_err(err,
-				"FM_PCD_MatchTableModifyMissNextEngine");
-			xx_pr_err("FMan driver call failed.");
+			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
+				__func__);
+			pr_err("FMan driver call failed.");
 			errno = -EBUSY;
 			goto table_insert_entry_exact_match_error;
 		}
@@ -1872,8 +1876,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		cls_table->params.exact_match_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_MatchTableAddKey");
-		xx_pr_err("FMan driver call failed.");
+		pr_err("%s: FM_PCD_MatchTableAddKey\n", __func__);
+		pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_exact_match_error;
 	}
@@ -1904,7 +1908,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err("No more memory to add a new DPA Classifier shadow table entry.");
+			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_exact_match_error;
 		}
@@ -1989,7 +1993,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	/* Check if there are entries still available in the selected set */
 	if (cls_table->int_cc_node[hash_set_index].used >=
 			cls_table->int_cc_node[hash_set_index].table_size) {
-		xx_pr_err("Hash set is full. Unable to add this entry.");
+		pr_err("Hash set is full. Unable to add this entry.");
 		errno = -ENOSPC;
 		goto table_insert_entry_hash_error;
 	}
@@ -1999,7 +2003,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		if (!cls_table->entry[j].valid)
 			break;
 
-	xx_assert(j < cls_table->entries_cnt);
+	BUG_ON(j == cls_table->entries_cnt);
 
 	/* Clean up and prepare the index entry */
 	memset(&cls_table->entry[j], 0,
@@ -2035,8 +2039,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		cls_table->params.hash_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		xx_pr_fmd_err(err, "FM_PCD_MatchTableAddKey");
-		xx_pr_err("FMan driver call failed.");
+		pr_err("%s: FM_PCD_MatchTableAddKey\n", __func__);
+		pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_hash_error;
 	}
@@ -2051,7 +2055,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err("No more memory to add a new DPA Classifier shadow table entry.");
+			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_hash_error;
 		}
@@ -2107,7 +2111,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		break;
 	case DPA_CLS_TBL_ACTION_ENQ:
 		if (action->enq_params.policer_params != NULL) {
-			xx_pr_err("Policing for DPA Classifier flows is not yet supported.");
+			pr_err("Policing for DPA Classifier flows is not yet supported.");
 			return -ENOSYS;
 		}
 
@@ -2128,7 +2132,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
 		if ((action->next_table_params.next_td >= num_tables) ||
 			(!table[action->next_table_params.next_td])) {
-			xx_pr_err("Invalid next table descriptor (0x%08x).",
+			pr_err("Invalid next table descriptor (0x%08x).",
 				(unsigned)action->next_table_params.next_td);
 			return -EINVAL;
 		}
@@ -2140,7 +2144,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	default:
-		xx_pr_err("Unsupported DPA Classifier action type (%d).",
+		pr_err("Unsupported DPA Classifier action type (%d).",
 			action->type);
 		return -EINVAL;
 	}
@@ -2158,14 +2162,14 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 		return (int)key->byte[0];
 
 	if (!cls_table->shadow_table) {
-		xx_pr_err("Cannot use runtime functions based on key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+		pr_err("Cannot use runtime functions based on key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
 	/* Find the shadow entry associated with this key */
 	shadow_list_entry = find_shadow_entry(cls_table, key);
 	if (shadow_list_entry == NULL) {
-		xx_pr_err("DPA Classifier table entry not found.");
+		pr_err("DPA Classifier table entry not found.");
 		return -ENODEV;
 	}
 
@@ -2189,7 +2193,7 @@ static int extend_table_array(void)
 	new_table_array = (struct dpa_cls_table **)
 		xx_zalloc(new_table_size * sizeof(struct dpa_cls_table *));
 	if (!new_table_array) {
-		xx_pr_err("No more memory for DPA Classifier table management.");
+		pr_err("No more memory for DPA Classifier table management.");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_compat.h b/drivers/staging/fsl_dpa_offload/dpa_compat.h
index 0b8eb59..130fb9f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_compat.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_compat.h
@@ -154,58 +154,11 @@ void	dpa_offld_display_mem_leaks(void);
 /*
  * Error Reporting
  */
-#ifdef DPA_OFFLOAD_VERBOSE_WARNINGS
-#define	xx_pr_warn(...) \
-	do { \
-		pr_warn("WARNING: %s (%d): %s:", __FILE__, __LINE__, \
-			__func__); \
-		pr_warn(__VA_ARGS__); \
-	} while (0)
-#else
-#define xx_pr_warn(...)
-#endif /* DPA_OFFLOAD_VERBOSE_WARNINGS */
-
-#ifdef DPA_OFFLOAD_VERBOSE_ERRORS
-#define xx_pr_err(...) \
-	do { \
-		pr_err("ERROR: %s (%d): %s:", __FILE__, __LINE__, __func__); \
-		pr_err(__VA_ARGS__); \
-	} while (0)
-
-#define xx_pr_crit(...) \
-	do { \
-		pr_crit("CRITICAL: %s (%d): %s:", __FILE__, __LINE__, \
-			__func__); \
-		pr_crit(__VA_ARGS__); \
-	} while (0)
-
-#define xx_pr_fmd_err(err_code, fmd_api) \
-	pr_err( \
-		"\nERROR (FMan LLD): %s: %s\n", \
-		fmd_api, \
-		errTypeStrings[GET_ERROR_TYPE(err_code)-E_OK-1])
-#else
-#define xx_pr_err(...)
-#define xx_pr_crit(...)
-#define xx_pr_fmd_err(err_code, fmd_api)
-#endif /* DPA_OFFLOAD_VERBOSE_ERRORS */
 
-/*
- * This is the main display macro. Info display is always on (you cannot
- * disable it), so please use it with consideration.
+/* After we won't use anymore xx_malloc and
+ * friends this whole file + compat file shall be removed.
  */
-#define xx_pr_info(...)			pr_info(__VA_ARGS__)
-
-#ifdef DPA_OFFLOAD_VERBOSE_DEBUG
-#define xx_pr_debug(...) \
-	do { \
-		pr_info("DEBUG: %s (%d): %s:", __FILE__, __LINE__, __func__); \
-		pr_info(__VA_ARGS__); \
-	} while (0)
-#else
-#define xx_pr_debug(...)
-#endif /* DPA_OFFLOAD_VERBOSE_DEBUG */
-
+#define xx_pr_err(...)
 
 /*
  * Error Checking
@@ -226,14 +179,14 @@ void	dpa_offld_display_mem_leaks(void);
 #ifdef DPA_OFFLOAD_SANITY_CHECKS
 #define xx_sanity_check_return_value(cond, var_desc, ret) \
 	if (!cond) { \
-		xx_pr_err("\nERROR: %s: Invalid value for %s.\n", __func__, \
+		pr_err("\nERROR: %s: Invalid value for %s.\n", __func__, \
 			   var_desc); \
 		return ret; \
 	}
 
 #define xx_sanity_check_return(cond, var_desc) \
 	if (!cond) { \
-		xx_pr_err("\nERROR: %s: Invalid value for %s.\n", __func__, \
+		pr_err("\nERROR: %s: Invalid value for %s.\n", __func__, \
 			   var_desc); \
 		return; \
 	}
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index e6f8b7b..f21b846 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -66,39 +66,39 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 
 	BUG_ON(!sa);
 
-	xx_pr_info("\n Printing SA SEC PARAM for sa %p\n", sa);
-	xx_pr_info("\n sa_dir = %d\n", sa->sa_dir);
-	xx_pr_info("\n id = %d\n", sa->id);
-	xx_pr_info(" dpa_ipsec addr = %p\n", sa->dpa_ipsec);
-	xx_pr_info(" from_sec_fq addr = %p\n", sa->from_sec_fq);
-
-	xx_pr_info("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type);
-	xx_pr_info("auth_data.auth_key_len = %d\n",
+	pr_info("\n Printing SA SEC PARAM for sa %p\n", sa);
+	pr_info("\n sa_dir = %d\n", sa->sa_dir);
+	pr_info("\n id = %d\n", sa->id);
+	pr_info(" dpa_ipsec addr = %p\n", sa->dpa_ipsec);
+	pr_info(" from_sec_fq addr = %p\n", sa->from_sec_fq);
+
+	pr_info("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type);
+	pr_info("auth_data.auth_key_len = %d\n",
 		sa->auth_data.auth_key_len);
-	xx_pr_info("auth_data.auth_key is\n");
+	pr_info("auth_data.auth_key is\n");
 	for (i = 0; i < sa->auth_data.auth_key_len; i++)
-		xx_pr_info("%x, ", sa->auth_data.auth_key[i]);
+		pr_info("%x, ", sa->auth_data.auth_key[i]);
 
-	xx_pr_info("\n cipher_data.cipher_type = %d\n",
+	pr_info("\n cipher_data.cipher_type = %d\n",
 		sa->cipher_data.cipher_type);
-	xx_pr_info("cipher_data.cipher_key_len = %d\n",
+	pr_info("cipher_data.cipher_key_len = %d\n",
 		sa->cipher_data.cipher_key_len);
-	xx_pr_info("cipher_data.cipher_key is\n");
+	pr_info("cipher_data.cipher_key is\n");
 	for (i = 0; i < sa->cipher_data.cipher_key_len; i++)
-		xx_pr_info("%x, ", sa->cipher_data.cipher_key[i]);
+		pr_info("%x, ", sa->cipher_data.cipher_key[i]);
 
-	xx_pr_info("\n sa_bpid = %d\n", sa->sa_bpid);
-	xx_pr_info(" spi = %d\n", sa->spi);
-	xx_pr_info(" sa_wqid = %d\n", sa->sa_wqid);
-	xx_pr_info(" outbound_flowid = %d\n", sa->outbound_flowid);
+	pr_info("\n sa_bpid = %d\n", sa->sa_bpid);
+	pr_info(" spi = %d\n", sa->spi);
+	pr_info(" sa_wqid = %d\n", sa->sa_wqid);
+	pr_info(" outbound_flowid = %d\n", sa->outbound_flowid);
 
-	xx_pr_info("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type);
-	xx_pr_info("dest_addr = %x.%x.%x.%x\n",
+	pr_info("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type);
+	pr_info("dest_addr = %x.%x.%x.%x\n",
 		sa->dest_addr.ipv4.byte[0],
 		sa->dest_addr.ipv4.byte[1],
 		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]);
-	xx_pr_info("src_addr.addr_type = %d\n", sa->src_addr.addr_type);
-	xx_pr_info("src_addr = %x.%x.%x.%x\n",
+	pr_info("src_addr.addr_type = %d\n", sa->src_addr.addr_type);
+	pr_info("src_addr = %x.%x.%x.%x\n",
 		sa->src_addr.ipv4.byte[0],
 		sa->src_addr.ipv4.byte[1],
 		sa->src_addr.ipv4.byte[2], sa->src_addr.ipv4.byte[3]);
@@ -106,67 +106,67 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		uint8_t *out_hdr;
 		out_hdr = &sa->sec_desc->pdb_en.ip_hdr[0];
-		xx_pr_info("Outer Header length  %d\n",
+		pr_info("Outer Header length  %d\n",
 			sa->sec_desc->pdb_en.ip_hdr_len);
-		xx_pr_info("Outer Header is:\n");
+		pr_info("Outer Header is:\n");
 		for (i = 0; i < sa->sec_desc->pdb_en.ip_hdr_len; i++)
-			xx_pr_info("%x, ", *(out_hdr + i));
+			pr_info("%x, ", *(out_hdr + i));
 
-		xx_pr_info("pdb_en.ip_hdr_len %d\n",
+		pr_info("pdb_en.ip_hdr_len %d\n",
 			sa->sec_desc->pdb_en.ip_hdr_len);
-		xx_pr_info("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi);
-		xx_pr_info("pdb_en.seq_num = %d\n",
+		pr_info("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi);
+		pr_info("pdb_en.seq_num = %d\n",
 			sa->sec_desc->pdb_en.seq_num);
-		xx_pr_info("pdb_en.options = 0x%x\n",
+		pr_info("pdb_en.options = 0x%x\n",
 			sa->sec_desc->pdb_en.options);
-		xx_pr_info("pdb_en.desc_hdr = 0x%x\n",
+		pr_info("pdb_en.desc_hdr = 0x%x\n",
 			sa->sec_desc->pdb_en.desc_hdr);
-		xx_pr_info("pdb_en.ip_nh = 0x%x\n",
+		pr_info("pdb_en.ip_nh = 0x%x\n",
 			sa->sec_desc->pdb_en.ip_nh);
 	} else {
-		xx_pr_info("pdb_dec.hmo_ip_hdr_len %d\n",
+		pr_info("pdb_dec.hmo_ip_hdr_len %d\n",
 			sa->sec_desc->pdb_dec.hmo_ip_hdr_len);
-		xx_pr_info("pdb_dec.options %d\n",
+		pr_info("pdb_dec.options %d\n",
 			sa->sec_desc->pdb_dec.options);
-		xx_pr_info("pdb_dec.seq_num %d\n",
+		pr_info("pdb_dec.seq_num %d\n",
 			sa->sec_desc->pdb_dec.seq_num);
 	}
 
-	xx_pr_info("\n Printing all policies from this SA policy_list\n");
+	pr_info("\n Printing all policies from this SA policy_list\n");
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
 		policy_selectors = &policy_entry->policy_selectors;
-		xx_pr_info("policy_selectors src_addr.addr_type = %d\n",
+		pr_info("policy_selectors src_addr.addr_type = %d\n",
 			policy_selectors->src_addr.addr_type);
-		xx_pr_info("policy_selectors src_addr = %x.%x.%x.%x\n",
+		pr_info("policy_selectors src_addr = %x.%x.%x.%x\n",
 			policy_selectors->src_addr.ipv4.byte[0],
 			policy_selectors->src_addr.ipv4.byte[1],
 			policy_selectors->src_addr.ipv4.byte[2],
 			policy_selectors->src_addr.ipv4.byte[3]);
-		xx_pr_info("\n policy_selectors dest_addr.addr_type = %d\n",
+		pr_info("\n policy_selectors dest_addr.addr_type = %d\n",
 			policy_selectors->dest_addr.addr_type);
-		xx_pr_info("policy_selectors dest_addr = %x.%x.%x.%x\n",
+		pr_info("policy_selectors dest_addr = %x.%x.%x.%x\n",
 			policy_selectors->dest_addr.ipv4.byte[0],
 			policy_selectors->dest_addr.ipv4.byte[1],
 			policy_selectors->dest_addr.ipv4.byte[2],
 			policy_selectors->dest_addr.ipv4.byte[3]);
 
-		xx_pr_info("\n policy_selectors dest_port = %d\n",
+		pr_info("\n policy_selectors dest_port = %d\n",
 			policy_selectors->dest_port);
-		xx_pr_info(" policy_selectors src_port = %d\n",
+		pr_info(" policy_selectors src_port = %d\n",
 			policy_selectors->src_port);
-		xx_pr_info(" policy_selectors dest_port = %d\n",
+		pr_info(" policy_selectors dest_port = %d\n",
 			policy_selectors->dest_port_mask);
-		xx_pr_info(" policy_selectors dest_port = %d\n",
+		pr_info(" policy_selectors dest_port = %d\n",
 			policy_selectors->src_port_mask);
-		xx_pr_info(" policy_selectors proto = %d\n",
+		pr_info(" policy_selectors proto = %d\n",
 			policy_selectors->protocol);
-		xx_pr_info(" policy_selectors dest_prefix_len = %d\n",
+		pr_info(" policy_selectors dest_prefix_len = %d\n",
 			policy_selectors->dest_prefix_len);
-		xx_pr_info(" policy_selectors src_prefix_len = %d\n",
+		pr_info(" policy_selectors src_prefix_len = %d\n",
 			policy_selectors->src_prefix_len);
 	}
-	xx_pr_info("\n Done printing SA SEC PARAM for sa %p\n", sa);
+	pr_info("\n Done printing SA SEC PARAM for sa %p\n", sa);
 
 	return 0;
 }
@@ -189,12 +189,12 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	int i, err, valid_tables = 0;
 
 	if (!prms) {
-		xx_pr_err("Invalid DPA IPsec parameters handle\n");
+		pr_err("Invalid DPA IPsec parameters handle\n");
 		return -EINVAL;
 	}
 
 	if ((prms->post_sec_in_params.do_pol_check) && (!prms->fm_pcd)) {
-		xx_pr_err("Provide a valid PCD handle to enable inbound policy check!\n");
+		pr_err("Provide a valid PCD handle to enable inbound policy check!\n");
 		return -EINVAL;
 	}
 
@@ -212,26 +212,26 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 				       prms->pre_sec_out_params.dpa_cls_td[i],
 				       &table_params);
 			if (err < 0) {
-				xx_pr_err("Couldn't check type of outbound policy lookup table\n");
+				pr_err("Couldn't check type of outbound policy lookup table\n");
 				return -EINVAL;
 			}
 
 			if (table_params.type == DPA_CLS_TBL_INDEXED) {
-				xx_pr_err("Outbound policy lookup table cannot be of type INDEXED\n");
+				pr_err("Outbound policy lookup table cannot be of type INDEXED\n");
 				return -EINVAL;
 			}
 			valid_tables++;
 		}
 
 	if (!valid_tables) {
-		xx_pr_err("Specify at least one table for outbound policy lookup\n");
+		pr_err("Specify at least one table for outbound policy lookup\n");
 		return -EINVAL;
 	}
 
 	/* post decryption SA classification table */
 	if (prms->post_sec_in_params.dpa_cls_td ==
 						  DPA_CLS_INVALID_TABLE_DESC) {
-		xx_pr_err("Specify a valid table for post decryption classification\n");
+		pr_err("Specify a valid table for post decryption classification\n");
 		return -EINVAL;
 	}
 
@@ -239,18 +239,18 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	err = dpa_classif_table_get_params(prms->post_sec_in_params.dpa_cls_td,
 					   &table_params);
 	if (err < 0) {
-		xx_pr_err("Could not check type of post decryption table\n");
+		pr_err("Could not check type of post decryption table\n");
 		return -EINVAL;
 	}
 
 	if (table_params.type != DPA_CLS_TBL_INDEXED) {
-		xx_pr_err("Post decryption table must be of type INDEXED\n");
+		pr_err("Post decryption table must be of type INDEXED\n");
 		return -EINVAL;
 	}
 
 	/* pre decryption SA lookup table */
 	if (prms->pre_sec_in_params.dpa_cls_td < 0) {
-		xx_pr_err("Specify a valid table for SA lookup\n");
+		pr_err("Specify a valid table for SA lookup\n");
 		return -EINVAL;
 	}
 
@@ -258,12 +258,12 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	err = dpa_classif_table_get_params(prms->pre_sec_in_params.dpa_cls_td,
 					   &table_params);
 	if (err < 0) {
-		xx_pr_err("Could not check type of pre decryption table\n");
+		pr_err("Could not check type of pre decryption table\n");
 		return -EINVAL;
 	}
 
 	if (table_params.type == DPA_CLS_TBL_INDEXED) {
-		xx_pr_err("Pre decryption table mustn't be of type index\n");
+		pr_err("Pre decryption table mustn't be of type index\n");
 		return -EINVAL;
 	}
 
@@ -271,7 +271,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	if (prms->pre_sec_out_params.key_fields == 0 ||
 	   (prms->post_sec_in_params.do_pol_check &&
 	    prms->post_sec_in_params.key_fields == 0)) {
-		xx_pr_err("At least one field must be specified for building policy keys\n");
+		pr_err("At least one field must be specified for building policy keys\n");
 		return -EINVAL;
 	}
 
@@ -280,7 +280,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	 * for offloading at least one SA pair
 	 */
 	if (prms->max_sa_pairs == 0) {
-		xx_pr_err("The instance must be configured for offloading at least one SA pair\n");
+		pr_err("The instance must be configured for offloading at least one SA pair\n");
 		return -EINVAL;
 	}
 
@@ -343,7 +343,7 @@ static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 	*cc_node = NULL;
 
 	if (dpa_ipsec->sa_mng.inpol_key_size == 0) {
-		xx_pr_err("Invalid argument: in policy table key size\n");
+		pr_err("Invalid argument: in policy table key size\n");
 		return -EFAULT;
 	}
 
@@ -367,7 +367,7 @@ static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 	*cc_node = FM_PCD_MatchTableSet(dpa_ipsec->config.fm_pcd,
 					&cc_node_prms);
 	if (!*cc_node) {
-		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_CcSetNode");
+		pr_err("%s: FM_PCD_MatchTableSet failed!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -379,10 +379,13 @@ static inline void destroy_inpol_node(struct dpa_ipsec *dpa_ipsec,
 {
 	t_Error fmd_err;
 
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!cc_node);
+
 	fmd_err = FM_PCD_MatchTableDelete(cc_node);
 	if (fmd_err != E_OK) {
-		xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteNode");
-		xx_pr_err("Could not free policy check CC Node\n");
+		pr_err("%s: FM_PCD_MatchTableDelete failed!\n", __func__);
+		pr_err("Could not free policy check CC Node\n");
 	}
 }
 
@@ -409,7 +412,7 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 	params.cc_node = cc_node;
 	err = dpa_classif_table_create(&params, td);
 	if (err < 0) {
-		xx_pr_err("Could not create exact match tbl");
+		pr_err("Could not create exact match tbl");
 		return err;
 	}
 
@@ -423,7 +426,7 @@ static inline void destroy_inpol_cls_tbl(int td)
 	if (td != DPA_CLS_INVALID_TABLE_DESC) {
 		err = dpa_classif_table_free(td);
 		if (err < 0)
-			xx_pr_err("Could not free EM table\n");
+			pr_err("Could not free EM table\n");
 	}
 }
 
@@ -434,7 +437,7 @@ static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t *flowid)
 	BUG_ON(!flowid);
 
 	if (cq_get_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err("Could not retrieve a valid inbound flow ID\n");
+		pr_err("Could not retrieve a valid inbound flow ID\n");
 		return -EDOM;
 	}
 
@@ -447,7 +450,7 @@ static int put_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t flowid)
 	BUG_ON(!dpa_ipsec->sa_mng.inbound_flowid_cq);
 
 	if (cq_put_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err("Could not release inbound flow id\n");
+		pr_err("Could not release inbound flow id\n");
 		return -EDOM;
 	}
 
@@ -463,7 +466,7 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 
 	cq = cq_new(dpa_ipsec->sa_mng.max_num_sa / 2, sizeof(uint16_t));
 	if (!cq) {
-		xx_pr_err("Could not create inbound flow ID management CQ\n");
+		pr_err("Could not create inbound flow ID management CQ\n");
 		return -ENOMEM;
 	}
 
@@ -473,7 +476,7 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa / 2; i++) {
 		err = put_inbound_flowid(dpa_ipsec, (uint16_t) i);
 		if (err < 0) {
-			xx_pr_err("Couldn't fill flow id management queue\n");
+			pr_err("Couldn't fill flow id management queue\n");
 			cq_delete(cq);
 			dpa_ipsec->sa_mng.inbound_flowid_cq = NULL;
 			return err;
@@ -513,7 +516,7 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 		inpol_tbl->used = TRUE;
 		*table_desc = inpol_tbl->td;
 	} else {
-		xx_pr_err("No more free EM tables for inbound policy verification\n");
+		pr_err("No more free EM tables for inbound policy verification\n");
 		ret = -ENOMEM;
 	}
 
@@ -543,7 +546,7 @@ static void put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 	if (inpol_tbl->used)
 		inpol_tbl->used = FALSE;
 	else
-		xx_pr_warn("Exact match table %d is not used\n", table_desc);
+		pr_warn("Exact match table %d is not used\n", table_desc);
 
 	/* Unlock inbound policy list */
 	mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
@@ -569,14 +572,14 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	/* create queue that holds free SA IDs */
 	sa_mng->sa_id_cq = cq_new(sa_mng->max_num_sa, sizeof(int));
 	if (!sa_mng->sa_id_cq) {
-		xx_pr_err("Could not create SA IDs circular queue\n");
+		pr_err("Could not create SA IDs circular queue\n");
 		return -ENOMEM;
 	}
 
 	/* fill with ids */
 	for (i = 0; i < sa_mng->max_num_sa; i++) {
 		if (cq_put_4bytes(sa_mng->sa_id_cq, i) < 0) {
-			xx_pr_err("Could not fill SA ID management CQ\n");
+			pr_err("Could not fill SA ID management CQ\n");
 			return -EDOM;
 		}
 	}
@@ -584,7 +587,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	/* alloc SA array */
 	sa_mng->sa = xx_zalloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
 	if (!sa_mng->sa) {
-		xx_pr_err("Could not allocate memory for SAs\n");
+		pr_err("Could not allocate memory for SAs\n");
 		return -ENOMEM;
 	}
 
@@ -595,31 +598,31 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		sa_mng->sa[i].cipher_data.cipher_key =
 						 xx_zalloc(MAX_CIPHER_KEY_LEN);
 		if (!sa_mng->sa[i].cipher_data.cipher_key) {
-			xx_pr_err("Could not allocate memory for cipher key\n");
+			pr_err("Could not allocate memory for cipher key\n");
 			return -ENOMEM;
 		}
 
 		sa_mng->sa[i].auth_data.auth_key = xx_zalloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.auth_key) {
-			xx_pr_err("Could not allocate memory for authentication key\n");
+			pr_err("Could not allocate memory for authentication key\n");
 			return -ENOMEM;
 		}
 
 		sa_mng->sa[i].auth_data.split_key = xx_zalloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.split_key) {
-			xx_pr_err("Could not allocate memory for authentication split key\n");
+			pr_err("Could not allocate memory for authentication split key\n");
 			return -ENOMEM;
 		}
 
 		sa_mng->sa[i].from_sec_fq = xx_zalloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].from_sec_fq) {
-			xx_pr_err("Can't allocate space for 'from SEC FQ'\n");
+			pr_err("Can't allocate space for 'from SEC FQ'\n");
 			return -ENOMEM;
 		}
 
 		sa_mng->sa[i].to_sec_fq = xx_zalloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].to_sec_fq) {
-			xx_pr_err("Can't allocate space for 'to SEC FQ'\n");
+			pr_err("Can't allocate space for 'to SEC FQ'\n");
 			return -ENOMEM;
 		}
 
@@ -629,7 +632,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		sa_mng->sa[i].sec_desc =
 			xx_zalloc_smart(sizeof(struct sec_descriptor), 0, 64);
 		if (!sa_mng->sa[i].sec_desc) {
-			xx_pr_err("Could not allocate memory for SEC descriptor\n");
+			pr_err("Could not allocate memory for SEC descriptor\n");
 			return -ENOMEM;
 		}
 
@@ -641,7 +644,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 	err = create_inbound_flowid_cq(dpa_ipsec);
 	if (err < 0) {
-		xx_pr_err("Could not create inbound policy flow id cq\n");
+		pr_err("Could not create inbound policy flow id cq\n");
 		return err;
 	}
 
@@ -662,7 +665,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
 			pol_table = xx_zalloc(sizeof(*pol_table));
 			if (!pol_table) {
-				xx_pr_err("Could not allocate memory for policy table");
+				pr_err("Could not allocate memory for policy table");
 				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return -ENOMEM;
 			}
@@ -670,7 +673,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			/* create cc node for inbound policy */
 			err = create_inpol_node(dpa_ipsec, &cc_node);
 			if (err < 0) {
-				xx_pr_err("Could not create cc node for EM table\n");
+				pr_err("Could not create cc node for EM table\n");
 				xx_free(pol_table);
 				mutex_unlock(&sa_mng->inpol_tables_lock);
 				return err;
@@ -681,7 +684,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 						   cc_node,
 						   &pol_table->td);
 			if (err < 0) {
-				xx_pr_err("Failed create in policy table\n");
+				pr_err("Failed create in policy table\n");
 				destroy_inpol_node(dpa_ipsec, cc_node);
 				xx_free(pol_table);
 				mutex_unlock(&sa_mng->inpol_tables_lock);
@@ -703,7 +706,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	dpa_ipsec->sa_mng.sa_rekeying_wq =
 		create_singlethread_workqueue("sa_rekeying_wq");
 	if (!dpa_ipsec->sa_mng.sa_rekeying_wq) {
-		xx_pr_err("Creating SA rekeying work queue failed\n");
+		pr_err("Creating SA rekeying work queue failed\n");
 		return -ENOSPC;
 	}
 
@@ -724,7 +727,7 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
+		pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return;
 	}
 
@@ -796,7 +799,7 @@ static void free_resources(void)
 
 	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no DPA IPSec instance initialized\n");
+		pr_err("There is no DPA IPSec instance initialized\n");
 		return;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -852,7 +855,7 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 	err = dpa_classif_table_insert_entry(table, &tbl_key, action, 0,
 					     &sa->inbound_indx_entry);
 	if (err < 0) {
-		xx_pr_err("Couldn't set default action for SA id %d\n", sa->id);
+		pr_err("Couldn't set default action for SA id %d\n", sa->id);
 		return err;
 	}
 
@@ -955,13 +958,13 @@ static int fill_policy_key(int td,
 	/* get table params (including maximum key size) */
 	err = dpa_classif_table_get_params(td, &tbl_params);
 	if (err < 0) {
-		xx_pr_err("Could not retrieve table maximum key size\n");
+		pr_err("Could not retrieve table maximum key size\n");
 		return -EINVAL;
 	}
 	tbl_key_size = TABLE_KEY_SIZE(tbl_params);
 
 	if (tbl_key_size < offset) {
-		xx_pr_err("Policy key is greater than maximum table key size\n");
+		pr_err("Policy key is greater than maximum table key size\n");
 		return -EINVAL;
 	}
 
@@ -1027,7 +1030,7 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 			pcd_df_action[policy_entry->df_action];
 	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
 	if (!*hm) {
-		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_ManipSetNode");
+		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -1058,7 +1061,7 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa,
 
 	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
 	if (!*hm) {
-		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_ManipSetNode");
+		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -1075,7 +1078,7 @@ static int destroy_manip(struct dpa_ipsec *dpa_ipsec,
 
 	fmd_err = FM_PCD_ManipNodeDelete((t_Handle)hm);
 	if (fmd_err != E_OK) {
-		xx_pr_fmd_err(fmd_err, "FM_PCD_ManipDeleteNode");
+		pr_err("%s: FM_PCD_ManipNodeDelete failed!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -1097,7 +1100,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 	BUG_ON(!policy_entry);
 
 	if (sa->em_inpol_td < 0) {
-		xx_pr_err("Invalid exact match table for SA %d.\n", sa->id);
+		pr_err("Invalid exact match table for SA %d.\n", sa->id);
 		return -EINVAL;
 	}
 
@@ -1130,7 +1133,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 						     policy_entry->priority,
 						     &entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not insert key in EM table\n");
+			pr_err("Could not insert key in EM table\n");
 			return err;
 		}
 		policy_entry->entry_id = entry_id;
@@ -1140,12 +1143,12 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_delete_entry_by_ref(sa->em_inpol_td,
 							    entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not remove key in EM table\n");
+			pr_err("Could not remove key in EM table\n");
 			return err;
 		}
 		break;
 	case MNG_OP_MODIFY:
-		xx_pr_err("Modify operation unsupported for IN Policy PCD\n");
+		pr_err("Modify operation unsupported for IN Policy PCD\n");
 		return -EINVAL;
 	}
 
@@ -1186,7 +1189,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			table =
 			    pre_sec_out_params->dpa_cls_td[DPA_IPSEC_PROTO_ANY];
 		} else {
-			xx_pr_err("No suitable table found for this policy type!\n");
+			pr_err("No suitable table found for this policy type!\n");
 			return -EINVAL;
 		}
 	}
@@ -1212,7 +1215,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		if (policy_entry->mtu) {
 			err = create_frag_manip(dpa_ipsec, policy_entry, &hm);
 			if (err < 0) {
-				xx_pr_err("Could not create Manip node for fragmentation!\n");
+				pr_err("Could not create Manip node for fragmentation!\n");
 				return -EAGAIN;
 			}
 		}
@@ -1228,7 +1231,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 						&action, policy_entry->priority,
 						&policy_entry->entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not add key in exact match table\n");
+			pr_err("Could not add key in exact match table\n");
 			return err;
 		}
 		break;
@@ -1236,14 +1239,14 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_delete_entry_by_ref(table,
 							policy_entry->entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not remove key from EM table\n");
+			pr_err("Could not remove key from EM table\n");
 			return err;
 		}
 
 		if (policy_entry->hm) {
 			err = destroy_manip(dpa_ipsec, policy_entry->hm);
 			if (err < 0) {
-				xx_pr_err("Couldn't delete frag manip\n");
+				pr_err("Couldn't delete frag manip\n");
 				return err;
 			}
 		}
@@ -1263,7 +1266,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 							 policy_entry->entry_id,
 							 &params);
 		if (err < 0) {
-			xx_pr_err("Could not modify key in EM table\n");
+			pr_err("Could not modify key in EM table\n");
 			return err;
 		}
 		break;
@@ -1332,13 +1335,13 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		/* determine padding length based on the table params */
 		err = dpa_classif_table_get_params(table, &tbl_params);
 		if (err < 0) {
-			xx_pr_err("Could not get table maximum key size\n");
+			pr_err("Could not get table maximum key size\n");
 			return err;
 		}
 		tbl_key_size = TABLE_KEY_SIZE(tbl_params);
 
 		if (tbl_key_size < offset) {
-			xx_pr_err("SA lookup key is greater than maximum table key size\n");
+			pr_err("SA lookup key is greater than maximum table key size\n");
 			return -EINVAL;
 		}
 
@@ -1357,7 +1360,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		if (sa->use_var_iphdr_len) {
 			err = create_ipsec_manip(sa, &hm);
 			if (err < 0) {
-				xx_pr_err("Could not create Manip node !\n");
+				pr_err("Could not create Manip node !\n");
 				return -EAGAIN;
 			}
 		}
@@ -1373,7 +1376,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not add key for inbound SA!\n");
+			pr_err("Could not add key for inbound SA!\n");
 			return err;
 		}
 		sa->inbound_hash_entry = entry_id;
@@ -1383,14 +1386,14 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		entry_id = sa->inbound_hash_entry;
 		err = dpa_classif_table_delete_entry_by_ref(table, entry_id);
 		if (err < 0) {
-			xx_pr_err("Could not remove key for inbound SA!\n");
+			pr_err("Could not remove key for inbound SA!\n");
 			return err;
 		}
 
 		if (sa->hm) {
 			err = destroy_manip(dpa_ipsec, sa->hm);
 			if (err < 0) {
-				xx_pr_err("Couldn't delete ipsec manip\n");
+				pr_err("Couldn't delete ipsec manip\n");
 				return err;
 			}
 		}
@@ -1410,7 +1413,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_modify_entry_by_ref(table, entry_id,
 							    &mod_params);
 		if (err < 0) {
-			xx_pr_err("Failed set drop action for inbound SA %d\n",
+			pr_err("Failed set drop action for inbound SA %d\n",
 				  sa->id);
 			return err;
 		}
@@ -1429,7 +1432,7 @@ static int remove_inbound_hash_entry(struct dpa_ipsec_sa *sa)
 
 	err = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 	if (unlikely(err < 0)) {
-		xx_pr_crit("Failed to remove inbound key for SA %d\n", sa->id);
+		pr_crit("Failed to remove inbound key for SA %d\n", sa->id);
 		return -ENOTRECOVERABLE;
 	}
 
@@ -1448,7 +1451,7 @@ static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 
 	err = dpa_classif_table_delete_entry_by_ref(td, sa->inbound_indx_entry);
 	if (err < 0) {
-		xx_pr_err("Could not remove SA entry in indexed table\n");
+		pr_err("Could not remove SA entry in indexed table\n");
 		return err;
 	}
 
@@ -1474,7 +1477,7 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 	if (dpa_ipsec->config.fqid_pool != NULL) {
 		err = qman_fqid_pool_alloc(dpa_ipsec->config.fqid_pool, fqid);
 		if (err < 0)
-			xx_pr_err("FQID allocation (from pool) failure."
+			pr_err("FQID allocation (from pool) failure."
 				   "QMan error code %d\n", err);
 		return err;
 	}
@@ -1482,7 +1485,7 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 	/* No pool defined. Get FQID from default allocator. */
 	err = qman_alloc_fqid(fqid);
 	if (err < 0) {
-		xx_pr_err("FQID allocation (no pool) failure.\n");
+		pr_err("FQID allocation (no pool) failure.\n");
 		return -ERANGE;
 	}
 
@@ -1494,7 +1497,7 @@ static void put_free_fqid(uint32_t fqid)
 	struct dpa_ipsec *dpa_ipsec;
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no DPA IPSec instance initialized\n");
+		pr_err("There is no DPA IPSec instance initialized\n");
 		return;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -1520,7 +1523,7 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 	} while (queryfq_np.frm_cnt && timeout);
 
 	if (timeout == 0) {
-		xx_pr_err("Timeout. Fq with id %d not empty.\n", fq->fqid);
+		pr_err("Timeout. Fq with id %d not empty.\n", fq->fqid);
 		return -EBUSY;
 	}
 
@@ -1543,13 +1546,13 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 
 	err = qman_retire_fq(sec_fq, &flags);
 	if (err < 0) {
-		xx_pr_err("Failed to retire FQ %d\n", sec_fq->fqid);
+		pr_err("Failed to retire FQ %d\n", sec_fq->fqid);
 		return err;
 	}
 
 	err = qman_oos_fq(sec_fq);
 	if (err < 0) {
-		xx_pr_err("Failed to OOS FQ %d\n", sec_fq->fqid);
+		pr_err("Failed to OOS FQ %d\n", sec_fq->fqid);
 		return err;
 	}
 
@@ -1601,7 +1604,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	err = qman_create_fq(fq_id, flags, fq);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Could not create FQ with ID: %u\n", fq_id);
+		pr_err("Could not create FQ with ID: %u\n", fq_id);
 		goto create_sec_fq_err;
 	}
 
@@ -1637,9 +1640,8 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 			error = FM_GetSpecialOperationCoding(fm, sp_op,
 							     &sp_op_code);
 			if (error != E_OK) {
-				xx_pr_fmd_err(error,
-					      "FM_GetSpecialOperationCoding");
-				xx_pr_err("Could not retrieve special op code");
+				pr_err("FM_GetSpecialOperationCoding failed\n");
+				pr_err("Could not retrieve special op code");
 				goto create_sec_fq_err;
 			}
 		}
@@ -1653,7 +1655,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	err = qman_init_fq(fq, flags, &fq_opts);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Could not init FQ with ID: %u\n", fq->fqid);
+		pr_err("Could not init FQ with ID: %u\n", fq->fqid);
 		goto create_sec_fq_err;
 	}
 
@@ -1683,7 +1685,7 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 
 	err = create_sec_descriptor(sa);
 	if (err < 0) {
-		xx_pr_err("Could not create sec descriptor\n");
+		pr_err("Could not create sec descriptor\n");
 		return err;
 	}
 
@@ -1725,7 +1727,7 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 					     sa->dpa_ipsec->config.fm_pcd,
 					     FALSE, sa->from_sec_fq);
 		if (err < 0) {
-			xx_pr_err("From SEC FQ couldn't be created\n");
+			pr_err("From SEC FQ couldn't be created\n");
 			goto create_fq_pair_err;
 		}
 	}
@@ -1741,7 +1743,7 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 			qman_fq_fqid(sa->from_sec_fq), /*ctxB - output SEC fq*/
 			0, NULL, parked_to_secfq, sa->to_sec_fq);
 	if (err < 0) {
-		xx_pr_err("%s FQ(to SEC) couldn't be created\n",
+		pr_err("%s FQ(to SEC) couldn't be created\n",
 				(sa->sa_dir == DPA_IPSEC_OUTBOUND) ? "Encrypt" :
 				"Decrypt");
 		goto create_fq_pair_err;
@@ -1769,7 +1771,7 @@ static inline int set_cipher_auth_alg(enum dpa_ipsec_cipher_alg alg_suite,
 
 	if (*cipher == OP_PCL_IPSEC_INVALID_ALG_ID ||
 	    *auth == OP_PCL_IPSEC_INVALID_ALG_ID) {
-		xx_pr_err("Invalid algorithm suite selected\n");
+		pr_err("Invalid algorithm suite selected\n");
 		return -EINVAL;
 	}
 
@@ -1819,7 +1821,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 				sa->sec_desc->pdb_en.hmo_rsvd |=
 							PDBHMO_ESP_DFBIT;
 			else
-				xx_pr_warn("Copy DF not supported for IPv6 SA");
+				pr_warn("Copy DF not supported for IPv6 SA");
 		}
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_DEC_TTL)
 			sa->sec_desc->pdb_en.hmo_rsvd |=
@@ -1879,7 +1881,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 			 * this should never be reached - it should be checked
 			 * before in check SA params function
 			 */
-			xx_pr_err("NAT-T is not supported for IPv6 SAs\n");
+			pr_err("NAT-T is not supported for IPv6 SAs\n");
 			return -EINVAL;
 		}
 	} else {
@@ -1924,7 +1926,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	if (!rekeying) {
 		err = get_inbound_flowid(dpa_ipsec, &sa->inbound_flowid);
 		if (err < 0) {
-			xx_pr_err("Can't get valid inbound flow id\n");
+			pr_err("Can't get valid inbound flow id\n");
 			sa->inbound_flowid = INVALID_INB_FLOW_ID;
 			return -EINVAL;
 		}
@@ -1989,7 +1991,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ARS64;
 		break;
 	default:
-		xx_pr_err("Invalid ARS mode specified\n");
+		pr_err("Invalid ARS mode specified\n");
 		return -EINVAL;
 	}
 
@@ -2013,7 +2015,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 			sa->sec_desc->pdb_dec.hmo_ip_hdr_len |=
 					PDBHMO_ESP_DECAP_DEC_TTL;
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DF)
-			xx_pr_info("Copy DF bit not supported for inbound SAs");
+			pr_info("Copy DF bit not supported for inbound SAs");
 	}
 
 	memcpy(&sa->src_addr,
@@ -2064,7 +2066,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 
 	pol_entry = xx_zalloc(sizeof(struct dpa_ipsec_policy_entry));
 	if (!pol_entry) {
-		xx_pr_err("Could not allocate memory for policy\n");
+		pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
 	}
 	copy_policy_selectors(policy_params, &pol_entry->policy_selectors);
@@ -2090,7 +2092,7 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 	BUG_ON(!policy_entry);
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err("Policy parameter list is empty\n");
+		pr_err("Policy parameter list is empty\n");
 		return -EDOM;
 	}
 
@@ -2116,7 +2118,7 @@ static inline int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
 	int pol_count = 0;
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_debug("Policy parameter list is empty\n");
+		pr_debug("Policy parameter list is empty\n");
 		return 0;
 	}
 
@@ -2138,7 +2140,7 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 	BUG_ON(!policy_params);
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err("Policy parameter list is empty\n");
+		pr_err("Policy parameter list is empty\n");
 		return 0;
 	}
 
@@ -2149,7 +2151,7 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 
 		pol_count++;
 		if (pol_count > num_pol) {
-			xx_pr_err("Num policies in this SA greater than %d",
+			pr_err("Num policies in this SA greater than %d",
 				num_pol);
 			return -EAGAIN;
 		}
@@ -2175,7 +2177,7 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 	BUG_ON(!policy_entry);
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err("Policy parameter list is empty\n");
+		pr_err("Policy parameter list is empty\n");
 		return -EINVAL;
 	}
 
@@ -2196,25 +2198,25 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		err = update_inbound_policy(sa, policy_entry, MNG_OP_REMOVE);
 		if (err < 0) {
-			xx_pr_err("Could not remove the inbound policy\n");
+			pr_err("Could not remove the inbound policy\n");
 			return err;
 		}
 
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
-			xx_pr_err("Couldn't remove inbound policy from SA policy list\n");
+			pr_err("Couldn't remove inbound policy from SA policy list\n");
 			return err;
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		err = update_outbound_policy(sa, policy_entry, MNG_OP_REMOVE);
 		if (err < 0) {
-			xx_pr_err("Could not remove the outbound policy\n");
+			pr_err("Could not remove the outbound policy\n");
 			return err;
 		}
 
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
-			xx_pr_err("Could not remove outbound policy from SA policy list\n");
+			pr_err("Could not remove outbound policy from SA policy list\n");
 			return err;
 		}
 	}
@@ -2229,7 +2231,7 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	struct dpa_ipsec_sa *sa = NULL;
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec component initialized\n");
+		pr_err("There is no dpa_ipsec component initialized\n");
 		return NULL;
 	}
 
@@ -2237,14 +2239,14 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	sa_mng = &dpa_ipsec->sa_mng;
 
 	if (sa_id < 0 || sa_id > sa_mng->max_num_sa) {
-		xx_pr_err("Invalid SA id %d provided\n", sa_id);
+		pr_err("Invalid SA id %d provided\n", sa_id);
 		return NULL;
 	}
 	sa = &sa_mng->sa[sa_id];
 
 	/* Validity check for this SA */
 	if (sa->used_sa_index == -1) {
-		xx_pr_err("SA with id %d is not valid\n", sa_id);
+		pr_err("SA with id %d is not valid\n", sa_id);
 		return NULL;
 	}
 
@@ -2258,7 +2260,7 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 
 	/* sanity checks */
 	if (!sa_params) {
-		xx_pr_err("Invalid SA parameters handle\n");
+		pr_err("Invalid SA parameters handle\n");
 		return -EINVAL;
 	}
 
@@ -2274,20 +2276,20 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 		return err;
 
 	if (sa_params->crypto_params.auth_key == NULL) {
-		xx_pr_err("A valid authentication key must be provided\n");
+		pr_err("A valid authentication key must be provided\n");
 		return -EINVAL;
 	}
 
 	/* TODO: check cipher_key ONLY if alg != null encryption */
 	if (sa_params->crypto_params.cipher_key == NULL) {
-		xx_pr_err("A valid cipher key must be provided\n");
+		pr_err("A valid cipher key must be provided\n");
 		return -EINVAL;
 	}
 
 	if (sa_params->sa_dir == DPA_IPSEC_OUTBOUND) {
 		if ((sa_params->sa_out_params.ip_hdr_size == 0) ||
 		    (sa_params->sa_out_params.outer_ip_header == NULL)) {
-			xx_pr_err("Transport mode is not currently supported."
+			pr_err("Transport mode is not currently supported."
 				   "Specify a valid encapsulation header\n");
 			return -EINVAL;
 		}
@@ -2295,28 +2297,28 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 		if (sa_params->sa_out_params.outer_udp_header &&
 			sa_params->sa_out_params.addr_type ==
 				DPA_IPSEC_ADDR_T_IPv6) {
-			xx_pr_err("NAT-T is not supported for IPV6 SAs\n");
+			pr_err("NAT-T is not supported for IPV6 SAs\n");
 			return -EINVAL;
 		}
 	} else {
 		/* Inbound SA */
 		if (sa_params->sa_in_params.src_addr.addr_type !=
 		    sa_params->sa_in_params.dest_addr.addr_type) {
-			xx_pr_err("Source and destination IP address must be of same type\n");
+			pr_err("Source and destination IP address must be of same type\n");
 			return -EINVAL;
 		}
 
 		if (sa_params->sa_in_params.use_udp_encap &&
 			sa_params->sa_in_params.src_addr.addr_type ==
 				DPA_IPSEC_ADDR_T_IPv6) {
-			xx_pr_err("NAT-T is not supported for IPV6 SAs\n");
+			pr_err("NAT-T is not supported for IPV6 SAs\n");
 			return -EINVAL;
 		}
 	}
 
 	/* check buffer pool ID validity */
 	if (sa_params->sa_bpid > MAX_BUFFER_POOL_ID) {
-		xx_pr_err("Invalid SA buffer pool ID.\n");
+		pr_err("Invalid SA buffer pool ID.\n");
 		return -EINVAL;
 	}
 
@@ -2343,7 +2345,7 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 
 	/* Get an id for new SA */
 	if (cq_get_4bytes(dpa_ipsec->sa_mng.sa_id_cq, &id) < 0) {
-		xx_pr_err("No more unused SA handles\n");
+		pr_err("No more unused SA handles\n");
 		/* Release DPA IPSec instance lock */
 		mutex_unlock(&dpa_ipsec->lock);
 		return -EDOM;
@@ -2353,7 +2355,7 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 		if (dpa_ipsec->used_sa_ids[i] == DPA_IPSEC_INVALID_SA_ID)
 			break;
 	if (i == dpa_ipsec->sa_mng.max_num_sa) {
-		xx_pr_err("No more used SAs ID holders");
+		pr_err("No more used SAs ID holders");
 		cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
 		/* Release DPA IPSec instance lock */
 		mutex_unlock(&dpa_ipsec->lock);
@@ -2393,7 +2395,7 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	BUG_ON(!dpa_ipsec);
 
 	if (sa->used_sa_index < 0) {
-		xx_pr_crit("Invalid used_sa_index for SA with id %d\n", sa->id);
+		pr_crit("Invalid used_sa_index for SA with id %d\n", sa->id);
 		return -EFAULT;
 	}
 
@@ -2404,7 +2406,7 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	/* Release the SA id in the SA IDs circular queue */
 	err = cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
 	if (err < 0) {
-		xx_pr_err("Could not release the sa id %d\n", sa->id);
+		pr_err("Could not release the sa id %d\n", sa->id);
 		/* Release DPA IPSec instance lock */
 		mutex_unlock(&dpa_ipsec->lock);
 		return -EDOM;
@@ -2435,7 +2437,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 	    (sa->inbound_hash_entry != -1)) {
 		err_rb = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 		if (err_rb < 0) {
-			xx_pr_err("Couln't remove SA lookup table entry\n");
+			pr_err("Couln't remove SA lookup table entry\n");
 			return err_rb;
 		}
 	}
@@ -2448,7 +2450,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
 				sa->inbound_indx_entry);
 		if (err_rb < 0) {
-			xx_pr_err("Couldn't remove post decrypt tbl entry\n");
+			pr_err("Couldn't remove post decrypt tbl entry\n");
 			return err_rb;
 		}
 	}
@@ -2456,7 +2458,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 	err_rb = remove_sa_fq_pair(sa);
 	if (err_rb < 0) {
-		xx_pr_err("Could not remove SA FQs.\n");
+		pr_err("Could not remove SA FQs.\n");
 		return err_rb;
 	}
 
@@ -2482,7 +2484,7 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->inbound_hash_entry != -1) {
 		err_rb = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 		if (err_rb < 0) {
-			xx_pr_err("Couln't remove SA lookup table entry\n");
+			pr_err("Couln't remove SA lookup table entry\n");
 			return err_rb;
 		}
 	}
@@ -2490,7 +2492,7 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 
 	err_rb = remove_sa_fq_pair(sa);
 	if (err_rb < 0) {
-		xx_pr_err("Could not remove SA FQs.\n");
+		pr_err("Could not remove SA FQs.\n");
 		return err_rb;
 	}
 
@@ -2510,8 +2512,8 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 
 	/* sanity checks */
 	if (gbl_dpa_ipsec) {
-		xx_pr_err("There is already an initialized dpa_ipsec component.\n");
-		xx_pr_err("Multiple DPA IPSec Instances aren't currently supported.\n");
+		pr_err("There is already an initialized dpa_ipsec component.\n");
+		pr_err("Multiple DPA IPSec Instances aren't currently supported.\n");
 		return -EPERM;
 	}
 
@@ -2523,7 +2525,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	/* alloc control block */
 	dpa_ipsec = (struct dpa_ipsec *)xx_zalloc(sizeof(struct dpa_ipsec));
 	if (!dpa_ipsec) {
-		xx_pr_err("Could not allocate memory for control block.\n");
+		pr_err("Could not allocate memory for control block.\n");
 		return -ENOMEM;
 	}
 
@@ -2544,7 +2546,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	max_num_sa = dpa_ipsec->sa_mng.max_num_sa;
 	dpa_ipsec->used_sa_ids = xx_malloc(max_num_sa * sizeof(uint32_t));
 	if (!dpa_ipsec->used_sa_ids) {
-		xx_pr_err("No more memory for used sa id's vector ");
+		pr_err("No more memory for used sa id's vector ");
 		free_resources();
 		return -ENOMEM;
 	}
@@ -2568,7 +2570,7 @@ int dpa_ipsec_free(int dpa_ipsec_id)
 	/* destroy all SAs offloaded in this DPA IPSec instance */
 	err = dpa_ipsec_flush_all_sa(0);
 	if (err < 0) {
-		xx_pr_err("Could not remove all SAs from this instance!\n");
+		pr_err("Could not remove all SAs from this instance!\n");
 		return err;
 	}
 
@@ -2590,12 +2592,12 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	unused(dpa_ipsec_id);
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec component initialized\n");
+		pr_err("There is no dpa_ipsec component initialized\n");
 		return -EPERM;
 	}
 
 	if (!sa_id) {
-		xx_pr_err("Invalid SA ID holder\n");
+		pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
 	*sa_id = DPA_IPSEC_INVALID_SA_ID;
@@ -2608,7 +2610,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 	err = get_new_sa(dpa_ipsec, &sa, &id);
 	if (err < 0) {
-		xx_pr_err("Failed retrieving a preallocated SA\n");
+		pr_err("Failed retrieving a preallocated SA\n");
 		return err;
 	}
 
@@ -2628,7 +2630,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		err = copy_sa_params_to_in_sa(sa, sa_params, FALSE);
 
 	if (err < 0) {
-		xx_pr_err("Could not copy SA parameters into SA\n");
+		pr_err("Could not copy SA parameters into SA\n");
 		goto create_sa_err;
 	}
 
@@ -2640,7 +2642,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	/* Call internal function to create SEC FQ according to SA parameters */
 	err = create_sa_fq_pair(sa, FALSE, FALSE);
 	if (err < 0) {
-		xx_pr_err("Could not create SEC frame queues\n");
+		pr_err("Could not create SEC frame queues\n");
 		goto create_sa_err;
 	}
 
@@ -2653,7 +2655,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		 *  PCD of the Rx Port */
 		err = update_pre_sec_inbound_table(sa, MNG_OP_ADD);
 		if (err < 0) {
-			xx_pr_err("Could not update PCD entry\n");
+			pr_err("Could not update PCD entry\n");
 			goto create_sa_err;
 		}
 
@@ -2665,7 +2667,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 			err = get_free_inbpol_tbl(dpa_ipsec, &inbpol_td);
 			if (err < 0) {
-				xx_pr_err("Could not get a free EM table\n");
+				pr_err("Could not get a free EM table\n");
 				goto create_sa_err;
 			}
 			sa->em_inpol_td = inbpol_td;
@@ -2686,7 +2688,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 						&action, 0,
 						&sa->inbound_indx_entry);
 			if (err < 0) {
-				xx_pr_err("Can't link EM table with index table\n");
+				pr_err("Can't link EM table with index table\n");
 				goto create_sa_err;
 			}
 
@@ -2697,14 +2699,14 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			err = dpa_classif_table_modify_miss_action(inbpol_td,
 								 &miss_action);
 			if (err < 0) {
-				xx_pr_err("Can't set policy miss action\n");
+				pr_err("Can't set policy miss action\n");
 				goto create_sa_err;
 			}
 		} else {
 			/* Set the post decryption default action */
 			err = set_in_sa_default_action(sa);
 			if (err < 0) {
-				xx_pr_err("Could not set default action for post decryption\n");
+				pr_err("Could not set default action for post decryption\n");
 				goto create_sa_err;
 			}
 		}
@@ -2779,15 +2781,14 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 
 		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
 		if (err < 0) {
-			xx_pr_err("Waiting old SA's TO SEC FQ to get empty\n");
+			pr_err("Waiting old SA's TO SEC FQ to get empty\n");
 			return -ETIME;
 		}
 
 		/* schedule child SA */
 		err = schedule_sa(child_sa);
 		if (unlikely(err < 0)) {
-			xx_pr_err("Scheduling child SA %d failed\n",
-				  child_sa->id);
+			pr_err("Scheduling child SA %d failed\n", child_sa->id);
 			return -EIO;
 		}
 
@@ -2823,14 +2824,14 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 		/* Now free the parent SA structure and all its resources */
 		err = remove_sa_sec_fq(sa->to_sec_fq);
 		if (err < 0) {
-			xx_pr_err("Couln't remove SA %d TO SEC FQ\n", sa->id);
+			pr_err("Couln't remove SA %d TO SEC FQ\n", sa->id);
 			return -EUCLEAN;
 		}
 
 		/* Recycle parent SA memory */
 		err = put_sa(sa);
 		if (unlikely(err < 0)) {
-			xx_pr_err("Could not recycle parent SA.\n");
+			pr_err("Could not recycle parent SA.\n");
 			return -EDQUOT;
 		}
 
@@ -2851,7 +2852,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 	/* Destroy the TO_SEC and FROM_SEC queues */
 	err = remove_sa_fq_pair(sa);
 	if (err != 0) {
-		xx_pr_err("Could not remove the SEC frame queues\n");
+		pr_err("Could not remove the SEC frame queues\n");
 		return err;
 	}
 
@@ -2859,7 +2860,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 	if (sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
 		err = sa_flush_policies(sa);
 		if (err < 0) {
-			xx_pr_err("Could not flush inbound policies");
+			pr_err("Could not flush inbound policies");
 			return err;
 		}
 	}
@@ -2874,7 +2875,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 	/* Mark SA as free */
 	err = put_sa(sa);
 	if (err < 0) {
-		xx_pr_err("Could not recycle the sa with id %d\n", sa->id);
+		pr_err("Could not recycle the sa with id %d\n", sa->id);
 		return err;
 	}
 
@@ -2961,21 +2962,21 @@ static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
 	/* Flush policies i.e remove PCD entries that direct traffic to SEC */
 	err = sa_flush_policies(sa);
 	if (err < 0) {
-		xx_pr_err("Could not flush outbound policies\n");
+		pr_err("Could not flush outbound policies\n");
 		return err;
 	}
 
 	/* Destroy the TO_SEC and FROM_SEC queues */
 	err = remove_sa_fq_pair(sa);
 	if (err < 0) {
-		xx_pr_err("Could not remove the SEC frame queues\n");
+		pr_err("Could not remove the SEC frame queues\n");
 		return err;
 	}
 
 	/* Mark SA as free */
 	err = put_sa(sa);
 	if (err < 0) {
-		xx_pr_err("Could not recycle the SA id %d\n", sa->id);
+		pr_err("Could not recycle the SA id %d\n", sa->id);
 		return err;
 	}
 
@@ -3019,13 +3020,13 @@ int dpa_ipsec_remove_sa(int sa_id)
 	int ret = 0;
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec instance initialized\n");
+		pr_err("There is no dpa_ipsec instance initialized\n");
 		return -EPERM;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle for SA id %d\n", sa_id);
+		pr_err("Invalid SA handle for SA id %d\n", sa_id);
 		return -EINVAL;
 	}
 
@@ -3035,7 +3036,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 		return -EAGAIN;
 
 	if (sa_is_child(sa)) {
-		xx_pr_err("This SA %d is a child in rekeying process\n", sa_id);
+		pr_err("This SA %d is a child in rekeying process\n", sa_id);
 		mutex_unlock(&sa->lock);
 		return -EINPROGRESS;
 	}
@@ -3074,30 +3075,30 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	int ret;
 
 	if (!policy_params) {
-		xx_pr_err("Invalid policy params handle\n");
+		pr_err("Invalid policy params handle\n");
 		return -EINVAL;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle\n");
+		pr_err("Invalid SA handle\n");
 		return -EINVAL;
 	}
 
 	ret = mutex_trylock(&sa->lock);
 	if (ret == 0) {
-		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
 	}
 
 	if (sa_is_parent(sa) && sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		xx_pr_err("Illegal to set out policy - parent SA %d\n", sa->id);
+		pr_err("Illegal to set out policy - parent SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
 		return -EPERM;
 	}
 
 	if (sa_is_child(sa) && sa->sa_dir == DPA_IPSEC_INBOUND) {
-		xx_pr_err("Illegal to set in policy on child SA %d\n", sa->id);
+		pr_err("Illegal to set in policy on child SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
 		return -EPERM;
 	}
@@ -3109,7 +3110,7 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	ret = store_policy_param_to_sa_pol_list(sa, policy_params,
 						&policy_entry);
 	if (ret < 0) {
-		xx_pr_err("Could not store the policy in the SA\n");
+		pr_err("Could not store the policy in the SA\n");
 		mutex_unlock(&sa->lock);
 		return ret;
 	}
@@ -3119,14 +3120,14 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		ret = update_inbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
-			xx_pr_err("Could not add the inbound policy\n");
+			pr_err("Could not add the inbound policy\n");
 			xx_free(policy_entry);
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		ret = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
-			xx_pr_err("Could not add the outbound policy\n");
+			pr_err("Could not add the outbound policy\n");
 			xx_free(policy_entry);
 		}
 	}
@@ -3145,37 +3146,37 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 	int ret = 0;
 
 	if (!policy_params) {
-		xx_pr_err("Invalid policy parameters handle\n");
+		pr_err("Invalid policy parameters handle\n");
 		return -EINVAL;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle provided\n");
+		pr_err("Invalid SA handle provided\n");
 		return -EINVAL;
 	}
 
 	ret = mutex_trylock(&sa->lock);
 	if (ret == 0) {
-		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
 	}
 
 	if (sa_is_parent(sa) && sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		xx_pr_err("Illegal removing out policy parent SA %d\n", sa->id);
+		pr_err("Illegal removing out policy parent SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
 		return -EPERM;
 	}
 
 	if (sa_is_child(sa) && sa->sa_dir == DPA_IPSEC_INBOUND) {
-		xx_pr_err("Illegal removing in policy, child SA %d\n", sa->id);
+		pr_err("Illegal removing in policy, child SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
 		return -EPERM;
 	}
 
 	ret = find_policy_in_sa_policy_list(sa, policy_params, &policy_entry);
 	if (ret < 0) {
-		xx_pr_err("Could not find policy entry in SA policy list\n");
+		pr_err("Could not find policy entry in SA policy list\n");
 		mutex_unlock(&sa->lock);
 		return ret;
 	}
@@ -3213,13 +3214,13 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	int err = 0, err_rb;
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec instance initialized\n");
+		pr_err("There is no dpa_ipsec instance initialized\n");
 		return -EPERM;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
 	if (!new_sa_id) {
-		xx_pr_err("Invalid SA ID holder\n");
+		pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
 	*new_sa_id = DPA_IPSEC_INVALID_SA_ID;
@@ -3230,20 +3231,20 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	old_sa = get_sa_from_sa_id(sa_id);
 	if (!old_sa) {
-		xx_pr_err("Invalid SA handle provided\n");
+		pr_err("Invalid SA handle provided\n");
 		return -EINVAL;
 	}
 
 	/* Acquire parent SA's lock */
 	err = mutex_trylock(&old_sa->lock);
 	if (err == 0) {
-		xx_pr_err("SA %d is being used\n", old_sa->id);
+		pr_err("SA %d is being used\n", old_sa->id);
 		return -EBUSY;
 	}
 
 	/* Check if SA is currently in rekeying process */
 	if (sa_currently_in_rekeying(old_sa)) {
-		xx_pr_err("SA with id %d is already in rekeying process\n",
+		pr_err("SA with id %d is already in rekeying process\n",
 			  old_sa->id);
 		mutex_unlock(&old_sa->lock);
 		return -EEXIST;
@@ -3251,7 +3252,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	/* Check if new SA parameters are matching the rekeyed SA */
 	if (old_sa->sa_dir != sa_params->sa_dir) {
-		xx_pr_err("New SA parameters don't match the parent SA %d\n",
+		pr_err("New SA parameters don't match the parent SA %d\n",
 			  old_sa->sa_dir);
 		mutex_unlock(&old_sa->lock);
 		return -EINVAL;
@@ -3259,7 +3260,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	err = get_new_sa(dpa_ipsec, &new_sa, &id);
 	if (err < 0) {
-		xx_pr_err("Failed retrieving a preallocated SA\n");
+		pr_err("Failed retrieving a preallocated SA\n");
 		mutex_unlock(&old_sa->lock);
 		return err;
 	}
@@ -3291,7 +3292,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		err = copy_sa_params_to_in_sa(new_sa, sa_params, TRUE);
 
 	if (err < 0) {
-		xx_pr_err("Could not copy SA parameters into SA\n");
+		pr_err("Could not copy SA parameters into SA\n");
 		goto rekey_sa_err;
 	}
 
@@ -3311,7 +3312,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	/* Create SEC queues according to SA parameters */
 	err = create_sa_fq_pair(new_sa, TRUE, TRUE);
 	if (err < 0) {
-		xx_pr_err("Could not create SEC frame queues\n");
+		pr_err("Could not create SEC frame queues\n");
 		goto rekey_sa_err;
 	}
 
@@ -3335,7 +3336,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 				/* Keep both SAs. Both must be removed
 				 * using remove_sa */
 				*new_sa_id = new_sa->id;
-				xx_pr_err("Could't modify outbound policy\n");
+				pr_err("Could't modify outbound policy\n");
 				new_sa->parent_sa = NULL;
 				new_sa->child_sa  = NULL;
 				old_sa->child_sa  = NULL;
@@ -3369,7 +3370,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		/* Need to update the IN SA PCD entry */
 		err = update_pre_sec_inbound_table(new_sa, MNG_OP_ADD);
 		if (err < 0) {
-			xx_pr_err("Could not add PCD entry for new SA\n");
+			pr_err("Could not add PCD entry for new SA\n");
 			goto rekey_sa_err;
 		}
 
@@ -3468,21 +3469,21 @@ static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
 
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 	if (err < 0) {
-		xx_pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
+		pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
 		return -ETIME;
 	}
 
 	/* Schedule the new SA */
 	err = qman_schedule_fq(new_sa->to_sec_fq);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Scheduling the new SA %d failed\n", new_sa->id);
+		pr_err("Scheduling the new SA %d failed\n", new_sa->id);
 		return -EIO;
 	}
 
 	/* Now free the old SA structure and all its resources */
 	err = remove_sa_sec_fq(old_sa->to_sec_fq);
 	if (err < 0) {
-		xx_pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
+		pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
 		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
 				 -EUCLEAN);
 		return -EUCLEAN;
@@ -3491,7 +3492,7 @@ static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
 	/* Recycle SA memory */
 	err = put_sa(old_sa);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Could not recycle parent SA.\n");
+		pr_err("Could not recycle parent SA.\n");
 		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
 				 -EDQUOT);
 		return -EDQUOT;
@@ -3570,14 +3571,14 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 	if (err < 0) {
-		xx_pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
+		pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
 		return -ETIME;
 	}
 
 	/* schedule new inbound SA */
 	err = qman_schedule_fq(new_sa->to_sec_fq);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Scheduling the new SA %d failed\n", new_sa->id);
+		pr_err("Scheduling the new SA %d failed\n", new_sa->id);
 		return -EIO;
 	}
 
@@ -3592,7 +3593,7 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 	/* Now free the old SA structure and all its resources */
 	err = remove_sa_sec_fq(old_sa->to_sec_fq);
 	if (err < 0) {
-		xx_pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
+		pr_err("Couln't remove old SA's %d TO SEC FQ\n", old_sa->id);
 		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
 				 -EUCLEAN);
 		return -EUCLEAN;
@@ -3601,7 +3602,7 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 	/* Recycle SA memory */
 	err = put_sa(old_sa);
 	if (unlikely(err < 0)) {
-		xx_pr_err("Could not recycle parent SA.\n");
+		pr_err("Could not recycle parent SA.\n");
 		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
 				 -EDQUOT);
 		return -EDQUOT;
@@ -3743,7 +3744,7 @@ int dpa_ipsec_disable_sa(int sa_id)
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle for SA id %d\n", sa_id);
+		pr_err("Invalid SA handle for SA id %d\n", sa_id);
 		return -EINVAL;
 	}
 
@@ -3753,7 +3754,7 @@ int dpa_ipsec_disable_sa(int sa_id)
 		return -EAGAIN;
 
 	if (!sa_is_single(sa)) {
-		xx_pr_err("SA %d is a parent or child in rekeying\n", sa_id);
+		pr_err("SA %d is a parent or child in rekeying\n", sa_id);
 		mutex_unlock(&sa->lock);
 		return -EINPROGRESS;
 	}
@@ -3786,7 +3787,7 @@ int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 	unused(dpa_ipsec_id);
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err("There is no dpa_ipsec component initialized\n");
+		pr_err("There is no dpa_ipsec component initialized\n");
 		return -EPERM;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -3817,12 +3818,12 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 	int ret;
 
 	if (sa_id < 0) {
-		xx_pr_err("Invalid SA id");
+		pr_err("Invalid SA id");
 		return -EINVAL;
 	}
 
 	if (!num_pol) {
-		xx_pr_err("Invalid num_pol parameter handle\n");
+		pr_err("Invalid num_pol parameter handle\n");
 		return -EINVAL;
 	}
 
@@ -3834,7 +3835,7 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 
 	ret = mutex_trylock(&sa->lock);
 	if (ret == 0) {
-		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
 	}
 
@@ -3864,7 +3865,7 @@ static int sa_flush_policies(struct dpa_ipsec_sa *sa)
 	list_for_each_entry_safe(pol_entry, tmp, &sa->policy_headlist, node) {
 		err = remove_policy(sa, pol_entry);
 		if (err < 0) {
-			xx_pr_err("Failed remove policy entry SA %d\n", sa->id);
+			pr_err("Failed remove policy entry SA %d\n", sa->id);
 			ret = -EAGAIN;
 			/* continue with the other policies even if error
 			 * occured for this policy */
@@ -3881,13 +3882,13 @@ int dpa_ipsec_sa_flush_policies(int sa_id)
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle for SA id %d\n", sa_id);
+		pr_err("Invalid SA handle for SA id %d\n", sa_id);
 		return -EINVAL;
 	}
 
 	ret = mutex_trylock(&sa->lock);
 	if (ret == 0) {
-		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
 	}
 
@@ -3906,24 +3907,24 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 	uint32_t *desc;
 
 	if (!sa_stats) {
-		xx_pr_err("Invalid SA statistics storage pointer\n");
+		pr_err("Invalid SA statistics storage pointer\n");
 		return -EINVAL;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err("Invalid SA handle for SA id %d\n", sa_id);
+		pr_err("Invalid SA handle for SA id %d\n", sa_id);
 		return -EINVAL;
 	}
 
 	ret = mutex_trylock(&sa->lock);
 	if (ret == 0) {
-		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		pr_err("Failed to acquire lock for SA %d\n", sa->id);
 		return -EBUSY;
 	}
 
 	if (!sa->enable_stats) {
-		xx_pr_err("Statistics are not enabled for SA id %d\n", sa_id);
+		pr_err("Statistics are not enabled for SA id %d\n", sa_id);
 		mutex_unlock(&sa->lock);
 		return -EPERM;
 	}
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 0674347..9c9bc1d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -59,19 +59,19 @@ static struct device *get_jrdev(void)
 
 	sec_jr_node = of_find_matching_node(NULL, &sec_jr_match[0]);
 	if (sec_jr_node == NULL) {
-		xx_pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
+		pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
 		return NULL;
 	}
 
 	sec_jr_node = of_find_matching_node(sec_jr_node, &sec_jr_match[0]);
 	if (sec_jr_node == NULL) {
-		xx_pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
+		pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
 		return NULL;
 	}
 
 	sec_of_jr_dev = of_find_device_by_node(sec_jr_node);
 	if (sec_of_jr_dev == NULL) {
-		xx_pr_err(KERN_ERR "SEC job-ring of_device null\n");
+		pr_err(KERN_ERR "SEC job-ring of_device null\n");
 		return NULL;
 	}
 
@@ -139,7 +139,7 @@ static inline void build_stats_descriptor_part(struct dpa_ipsec_sa *sa,
 		block_size = 16; /* block size in bytes */
 		break;
 	default:
-		xx_pr_crit("Invalid cipher algorithm for SA %d\n", sa->id);
+		pr_crit("Invalid cipher algorithm for SA %d\n", sa->id);
 		return;
 	}
 
@@ -291,7 +291,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 	/* get the jr device  */
 	jrdev = get_jrdev();
 	if (!jrdev) {
-		xx_pr_err("Failed to get the job ring devic, check the dts\n");
+		pr_err("Failed to get the job ring devic, check the dts\n");
 		return -EINVAL;
 	}
 
@@ -305,7 +305,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 					      sa->auth_data.auth_key_len,
 					      DMA_TO_DEVICE);
 	if (!auth_key_dma) {
-		xx_pr_err("Could not DMA map authentication key\n");
+		pr_err("Could not DMA map authentication key\n");
 		return -EINVAL;
 	}
 
@@ -313,7 +313,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 					sa->cipher_data.cipher_key_len,
 					DMA_TO_DEVICE);
 	if (!crypto_key_dma) {
-		xx_pr_err("Could not DMA map cipher key\n");
+		pr_err("Could not DMA map cipher key\n");
 		return -EINVAL;
 	}
 
@@ -382,7 +382,7 @@ int get_split_key_info(struct auth_params *auth_param, u32 *hmac_alg)
 		auth_param->split_key_len = 0;
 		break;
 	default:
-		xx_pr_err("Unsupported authentication algorithm\n");
+		pr_err("Unsupported authentication algorithm\n");
 		return -EINVAL;
 	}
 
@@ -409,13 +409,13 @@ int generate_split_key(struct auth_params *auth_param)
 
 	jrdev = get_jrdev();
 	if (!jrdev) {
-		xx_pr_err("Could not get job ring device, please check dts\n");
+		pr_err("Could not get job ring device, please check dts\n");
 		return -ENODEV;
 	}
 
 	desc = kmalloc(CAAM_CMD_SZ * 6 + CAAM_PTR_SZ * 2, GFP_KERNEL | GFP_DMA);
 	if (!desc) {
-		xx_pr_err("Allocate memory failed for split key desc\n");
+		pr_err("Allocate memory failed for split key desc\n");
 		return -ENOMEM;
 	}
 
@@ -469,7 +469,7 @@ int generate_split_key(struct auth_params *auth_param)
 	}
 
 	if (timeout == 0)
-		xx_pr_err("Timeout waiting for job ring to complete\n");
+		pr_err("Timeout waiting for job ring to complete\n");
 
 	dma_unmap_single(jrdev, dma_addr_out, auth_param->split_key_pad_len,
 			 DMA_FROM_DEVICE);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 541bafa..7dd3119 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -105,7 +105,7 @@ int	wrp_dpa_classif_init(void)
 					WRP_DPA_CLS_CDEVNAME,
 					&dpa_classif_fops);
 	if (dpa_cls_cdev_major < 0) {
-		xx_pr_err("Could not register DPA Classifier Control Device.");
+		pr_err("Could not register DPA Classifier Control Device.");
 		return -EBUSY;
 	}
 
@@ -233,7 +233,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_delete_entry_by_key user "
 				"space args (#1)");
 			return -EBUSY;
@@ -252,7 +252,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_delete_entry_by_ref user "
 				"space args (#1)");
 			return -EBUSY;
@@ -289,7 +289,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_get_entry_stats_by_key user "
 				"space args (#1)");
 			return -EBUSY;
@@ -305,7 +305,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_get_entry_stats_by_key "
 				"result");
 			return -EBUSY;
@@ -320,7 +320,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_get_entry_stats_by_ref user "
 				"space args (#1)");
 			return -EBUSY;
@@ -336,7 +336,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_get_entry_stats_by_ref "
 				"result");
 			return -EBUSY;
@@ -351,7 +351,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_reset_entry_stats_by_key "
 				"user space args");
 			return -EBUSY;
@@ -370,7 +370,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_reset_entry_stats_by_ref "
 				"user space args");
 			return -EBUSY;
@@ -391,7 +391,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_lookup_by_key user space "
 				"args (#1)");
 			return -EBUSY;
@@ -405,7 +405,7 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_get_params result");
 			return -EBUSY;
 		}
@@ -414,7 +414,7 @@ long wrp_dpa_classif_do_ioctl(
 	}
 
 	default:
-		xx_pr_err("DPA Classifier ioctl command (0x%x) not suppoted",
+		pr_err("DPA Classifier ioctl command (0x%x) not suppoted",
 			cmd);
 		return -EINVAL;
 	}
@@ -434,7 +434,7 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read dpa_classif_table_create "
+			pr_err("Could not read dpa_classif_table_create "
 				"user space args");
 			return -EBUSY;
 		}
@@ -444,7 +444,7 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			xx_pr_err("Could not read dpa_classif_table_create "
+			pr_err("Could not read dpa_classif_table_create "
 				"user space args");
 			return -EBUSY;
 		}
@@ -452,7 +452,7 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	/* Translate FM_PCD file descriptor */
 	fm_pcd_file = fcheck((unsigned int)kparam.table_params.fm_pcd);
 	if (!fm_pcd_file) {
-		xx_pr_err("Could not acquire PCD handle");
+		pr_err("Could not acquire PCD handle");
 		return -EINVAL;
 	}
 	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
@@ -469,14 +469,14 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.td = kparam.td;
 		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			xx_pr_err("Could not write dpa_classif_table_create "
+			pr_err("Could not write dpa_classif_table_create "
 				"result");
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			xx_pr_err("Could not write dpa_classif_table_create "
+			pr_err("Could not write dpa_classif_table_create "
 				"result");
 			return -EBUSY;
 		}
@@ -494,7 +494,7 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_miss_action user "
 				"space args");
 			return -EBUSY;
@@ -506,7 +506,7 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_miss_action user "
 				"space args");
 			return -EBUSY;
@@ -529,7 +529,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_insert_entry user space "
 				"args");
 			return -EBUSY;
@@ -544,7 +544,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 			if (copy_from_user(&policer_params,
 			compat_ptr(uparam.action.enq_params.policer_params),
 				sizeof(policer_params))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_insert_entry user "
 					"space args (#2)");
 				return -EBUSY;
@@ -556,7 +556,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 	{
 		if (copy_from_user(&kparam, (void *) args,
 				    sizeof(kparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_insert_entry user space "
 				"args (#1)");
 			return -EBUSY;
@@ -568,7 +568,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 			if (copy_from_user(&policer_params,
 				kparam.action.enq_params.policer_params,
 				sizeof(policer_params))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_insert_entry user "
 					"space args (#2)");
 				return -EBUSY;
@@ -593,7 +593,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 
 		if (copy_to_user(compat_ptr(args), &uparam,
 				sizeof(uparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_insert_entry result");
 			return -EBUSY;
 		}
@@ -601,7 +601,7 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam,
 				sizeof(kparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_insert_entry result");
 			return -EBUSY;
 		}
@@ -624,7 +624,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args),
 				sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_key user "
 				"space args (#1)");
 			return -EBUSY;
@@ -639,7 +639,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			if (copy_from_user(&key,
 				compat_ptr(uparam.mod_params.key),
 				sizeof(struct dpa_cls_tbl_key))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_key "
 					"user space args (#2)");
 				return -EBUSY;
@@ -651,7 +651,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			if (copy_from_user(&compat_action,
 				compat_ptr(uparam.mod_params.action),
 				sizeof(struct dpa_cls_compat_tbl_action))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_key "
 					"user space args (#3)");
 				return -EBUSY;
@@ -671,7 +671,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 					compat_ptr(compat_action.
 					enq_params.policer_params),
 					sizeof(policer_params))) {
-					xx_pr_err("Could not read "
+					pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_key user "
 				"space args (#4)");
 					return -EBUSY;
@@ -686,7 +686,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 	{
 		if (copy_from_user(&kparam, (void *) args,
 				sizeof(kparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_key user "
 				"space args (#1)");
 			return -EBUSY;
@@ -697,7 +697,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			if (copy_from_user(&key,
 				kparam.mod_params.key,
 				sizeof(struct dpa_cls_tbl_key))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_key "
 					"user space args (#2)");
 				return -EBUSY;
@@ -709,7 +709,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			if (copy_from_user(&action,
 				kparam.mod_params.action,
 				sizeof(struct dpa_cls_tbl_action))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_key "
 					"user space args (#3)");
 				return -EBUSY;
@@ -726,7 +726,7 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 					action->enq_params.
 					policer_params,
 					sizeof(policer_params))) {
-					xx_pr_err("Could not read "
+					pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_key user "
 				"space args (#4)");
 					return -EBUSY;
@@ -759,7 +759,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_ref user "
 				"space args");
 			return -EBUSY;
@@ -774,7 +774,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			if (copy_from_user(&key,
 				compat_ptr(uparam.mod_params.key),
 				sizeof(struct dpa_cls_tbl_key))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_ref "
 					"user space args (#2)");
 				return -EBUSY;
@@ -786,7 +786,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			if (copy_from_user(&compat_action,
 				compat_ptr(uparam.mod_params.action),
 				sizeof(struct dpa_cls_compat_tbl_action))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_ref "
 					"user space args (#3)");
 				return -EBUSY;
@@ -806,7 +806,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 					compat_ptr(compat_action.
 					enq_params.policer_params),
 					sizeof(policer_params))) {
-					xx_pr_err("Could not read "
+					pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_ref user "
 				"space args (#4)");
 					return -EBUSY;
@@ -820,7 +820,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_ref user "
 				"space args (#1)");
 			return -EBUSY;
@@ -831,7 +831,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			if (copy_from_user(&key,
 				kparam.mod_params.key,
 				sizeof(struct dpa_cls_tbl_key))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_ref "
 					"user space args (#2)");
 				return -EBUSY;
@@ -843,7 +843,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			if (copy_from_user(&action,
 				kparam.mod_params.action,
 				sizeof(struct dpa_cls_tbl_action))) {
-				xx_pr_err("Could not read "
+				pr_err("Could not read "
 					"dpa_classif_table_modify_entry_by_ref "
 					"user space args (#3)");
 				return -EBUSY;
@@ -860,7 +860,7 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 					action->enq_params.
 					policer_params,
 					sizeof(policer_params))) {
-					xx_pr_err("Could not read "
+					pr_err("Could not read "
 				"dpa_classif_table_modify_entry_by_ref user "
 				"space args (#4)");
 					return -EBUSY;
@@ -888,7 +888,7 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_lookup_by_key user space "
 				"args");
 			return -EBUSY;
@@ -900,7 +900,7 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_lookup_by_key user space "
 				"args (#1)");
 			return -EBUSY;
@@ -927,14 +927,14 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 			&kparam.action);
 
 		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_lookup_by_key result");
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_lookup_by_key result");
 			return -EBUSY;
 		}
@@ -952,7 +952,7 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 	/* Prepare arguments */
 	if (compat_mode) {
 		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			xx_pr_err("Could not read "
+			pr_err("Could not read "
 				"dpa_classif_table_lookup_by_ref user space args");
 			return -EBUSY;
 		}
@@ -965,7 +965,7 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 
 	/* Prepare arguments */
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		xx_pr_err("Could not read dpa_classif_table_lookup_by_ref user "
+		pr_err("Could not read dpa_classif_table_lookup_by_ref user "
 			"space args (#1)");
 		return -EBUSY;
 	}
@@ -991,14 +991,14 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 			&kparam.action);
 
 		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_lookup_by_ref result");
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			xx_pr_err("Could not write "
+			pr_err("Could not write "
 				"dpa_classif_table_lookup_by_ref result");
 			return -EBUSY;
 		}
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 99cacb8..855b730 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -331,13 +331,13 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		if (sa_out_prm->outer_ip_header) {
 			out_ip_hdr = xx_malloc(sa_out_prm->ip_hdr_size);
 			if (!out_ip_hdr) {
-				xx_pr_err("Error - alloc SA out hdr");
+				pr_err("Error - alloc SA out hdr");
 				return -ENOMEM;
 			}
 			if (copy_from_user(out_ip_hdr,
 					   sa_out_prm->outer_ip_header,
 					   sa_out_prm->ip_hdr_size)) {
-				xx_pr_err("Error - copy SA out hdr");
+				pr_err("Error - copy SA out hdr");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -346,14 +346,14 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		if (sa_out_prm->outer_udp_header) {
 			out_udp_hdr = xx_malloc(UDP_HDR_SIZE);
 			if (!out_udp_hdr) {
-				xx_pr_err("Error - alloc SA out udp hdr");
+				pr_err("Error - alloc SA out udp hdr");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
 			if (copy_from_user(out_udp_hdr,
 					   sa_out_prm->outer_udp_header,
 					   UDP_HDR_SIZE)) {
-				xx_pr_err("Error - copy SA out udp hdr");
+				pr_err("Error - copy SA out udp hdr");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -363,7 +363,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 			sa_out_iv = (struct dpa_ipsec_init_vector *)
 						xx_malloc(sizeof(*sa_out_iv));
 			if (!sa_out_iv) {
-				xx_pr_err("Error - alloc SA out IV struct");
+				pr_err("Error - alloc SA out IV struct");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
@@ -382,7 +382,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 						   sizeof(*sa_out_iv)))
 					err = -EINVAL;
 			if (err < 0) {
-				xx_pr_err("Error - copy SA out IV struct");
+				pr_err("Error - copy SA out IV struct");
 				return err;
 			}
 			sa_out_prm->init_vector = sa_out_iv;
@@ -393,13 +393,13 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 
 			iv_array = (uint8_t *)xx_malloc(sa_out_iv->length);
 			if (!iv_array) {
-				xx_pr_err("Error - alloc SA out IV array");
+				pr_err("Error - alloc SA out IV array");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
 			if (copy_from_user(iv_array, sa_out_iv->init_vector,
 					   sa_out_iv->length)) {
-				xx_pr_err("Error - copy SA out IV array");
+				pr_err("Error - copy SA out IV array");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -414,13 +414,13 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		    cls_action->enq_params.policer_params != NULL) {
 			policer_prm = xx_malloc(sizeof(*policer_prm));
 			if (!policer_prm) {
-				xx_pr_err("Error alloc CLS POL param");
+				pr_err("Error alloc CLS POL param");
 				return -ENOMEM;
 			}
 			if (copy_from_user(policer_prm,
 					  cls_action->enq_params.policer_params,
 					  sizeof(*policer_prm))) {
-				xx_pr_err("Error - copy CLS POL param");
+				pr_err("Error - copy CLS POL param");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -437,13 +437,13 @@ copy_crypto_keys:
 	if (crypto_params->auth_key) {
 		auth_key = (uint8_t *)xx_malloc(crypto_params->auth_key_len);
 		if (!auth_key) {
-			xx_pr_err("Couldn't allocate memory for SA auth key");
+			pr_err("Couldn't allocate memory for SA auth key");
 			err = -ENOMEM;
 			goto free_create_sa_keys_mem;
 		}
 		if (copy_from_user(auth_key, crypto_params->auth_key,
 				   crypto_params->auth_key_len)) {
-			xx_pr_err("Could not copy SA auth key!");
+			pr_err("Could not copy SA auth key!");
 			err = -EINVAL;
 			goto free_create_sa_keys_mem;
 		}
@@ -454,13 +454,13 @@ copy_crypto_keys:
 		cipher_key =
 			(uint8_t *)xx_malloc(crypto_params->cipher_key_len);
 		if (!cipher_key) {
-			xx_pr_err("Couldn't allocate memory for SA cipher key");
+			pr_err("Couldn't allocate memory for SA cipher key");
 			err = -ENOMEM;
 			goto free_create_sa_keys_mem;
 		}
 		if (copy_from_user(cipher_key, crypto_params->cipher_key,
 				   crypto_params->cipher_key_len)) {
-			xx_pr_err("Could not copy SA auth key!");
+			pr_err("Could not copy SA auth key!");
 			err = -EINVAL;
 			goto free_create_sa_keys_mem;
 		}
@@ -498,14 +498,14 @@ static int do_init_ioctl(void *args, bool compat)
 #ifdef CONFIG_COMPAT
 	if (compat) {
 		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			xx_pr_err("Could not copy DPA IPSec init parameters");
+			pr_err("Could not copy DPA IPSec init parameters");
 			return -EINVAL;
 		}
 		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_US_TO_K);
 	} else
 #endif
 		if (copy_from_user(&prm, args, sizeof(prm))) {
-			xx_pr_err("Could not copy DPA IPSec init parameters");
+			pr_err("Could not copy DPA IPSec init parameters");
 			return -EINVAL;
 		}
 
@@ -514,14 +514,14 @@ static int do_init_ioctl(void *args, bool compat)
 	 * IOCTLS to initialize and control a DPA IPSec instance
 	 */
 	if (prm.dpa_ipsec_params.fqid_pool) {
-		xx_pr_err("FQID pool option is not supported via IOCTLS");
+		pr_err("FQID pool option is not supported via IOCTLS");
 		return -EINVAL;
 	}
 
 	/* Translate FM_PCD file descriptor */
 	fm_pcd_file = fcheck((unsigned int)prm.dpa_ipsec_params.fm_pcd);
 	if (!fm_pcd_file) {
-		xx_pr_err("Could not acquire PCD handle");
+		pr_err("Could not acquire PCD handle");
 		return -EINVAL;
 	}
 	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
@@ -536,13 +536,13 @@ static int do_init_ioctl(void *args, bool compat)
 		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_K_TO_US);
 		if (copy_to_user((void *)args, &compat_prm,
 				 sizeof(compat_prm))) {
-			xx_pr_err("Could not copy to user the DPA IPSec ID");
+			pr_err("Could not copy to user the DPA IPSec ID");
 			return -EINVAL;
 		}
 	} else
 #endif
 		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user the ID");
+			pr_err("Could not copy to user the ID");
 			return -EINVAL;
 		}
 
@@ -560,7 +560,7 @@ static int do_create_sa_ioctl(void *args, bool compat)
 #ifdef CONFIG_COMPAT
 	if (compat) {
 		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			xx_pr_err("Could not copy SA parameters");
+			pr_err("Could not copy SA parameters");
 			return -EINVAL;
 		}
 		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
@@ -568,7 +568,7 @@ static int do_create_sa_ioctl(void *args, bool compat)
 	} else
 #endif
 		if (copy_from_user(&prm, args, sizeof(prm))) {
-			xx_pr_err("Could not copy SA parameters");
+			pr_err("Could not copy SA parameters");
 			return -EINVAL;
 		}
 
@@ -590,13 +590,13 @@ static int do_create_sa_ioctl(void *args, bool compat)
 						COMPAT_K_TO_US);
 		if (copy_to_user((void *)args, &compat_prm,
 				 sizeof(compat_prm))) {
-			xx_pr_err("Could not copy to user the SA ID");
+			pr_err("Could not copy to user the SA ID");
 			err = -EINVAL;
 		}
 	} else
 #endif
 		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user the SA ID");
+			pr_err("Could not copy to user the SA ID");
 			err = -EINVAL;
 		}
 
@@ -617,7 +617,7 @@ static int do_sa_rekey_ioctl(void *args, bool compat)
 #ifdef CONFIG_COMPAT
 	if (compat) {
 		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			xx_pr_err("Could not copy SA rekeying params");
+			pr_err("Could not copy SA rekeying params");
 			return -EINVAL;
 		}
 		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
@@ -625,7 +625,7 @@ static int do_sa_rekey_ioctl(void *args, bool compat)
 	} else
 #endif
 		if (copy_from_user(&prm, args, sizeof(prm))) {
-			xx_pr_err("Could not copy SA rekeying params");
+			pr_err("Could not copy SA rekeying params");
 			return -EINVAL;
 		}
 
@@ -649,13 +649,13 @@ static int do_sa_rekey_ioctl(void *args, bool compat)
 					       COMPAT_K_TO_US);
 		if (copy_to_user((void *)args, &compat_prm,
 				 sizeof(compat_prm))) {
-			xx_pr_err("Could not copy to user new SA ID");
+			pr_err("Could not copy to user new SA ID");
 			err = -EINVAL;
 		}
 	} else
 #endif
 		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy to user new SA ID");
+			pr_err("Could not copy to user new SA ID");
 			err = -EINVAL;
 		}
 
@@ -677,7 +677,7 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 #ifdef CONFIG_COMPAT
 	if (compat) {
 		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			xx_pr_err("Could not copy params for policy retrieval");
+			pr_err("Could not copy params for policy retrieval");
 			return -EINVAL;
 		}
 		compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
@@ -685,12 +685,12 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 	} else
 #endif
 		if (copy_from_user(&prm, args, sizeof(prm))) {
-			xx_pr_err("Could not copy params for policy retrieval");
+			pr_err("Could not copy params for policy retrieval");
 			return -EINVAL;
 		}
 
 	if (prm.sa_id < 0) {
-		xx_pr_err("Invalid input SA id\n");
+		pr_err("Invalid input SA id\n");
 		return -EINVAL;
 	}
 
@@ -698,7 +698,7 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 	if (!prm.policy_params) {
 		err = dpa_ipsec_sa_get_policies(sa_id, NULL, &num_pol);
 		if (err < 0) {
-			xx_pr_err("Get policies count failed\n");
+			pr_err("Get policies count failed\n");
 			return err;
 		}
 
@@ -708,13 +708,13 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 			compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
 						       COMPAT_K_TO_US);
 		if (copy_to_user(args, &compat_prm, sizeof(compat_prm))) {
-				xx_pr_err("Cannot copy policy count to user");
+				pr_err("Cannot copy policy count to user");
 				return -EINVAL;
 			}
 		} else
 #endif
 			if (copy_to_user(args, &prm, sizeof(prm))) {
-				xx_pr_err("Cannot copy policy count to user");
+				pr_err("Cannot copy policy count to user");
 				return -EINVAL;
 			}
 		return 0;
@@ -722,26 +722,26 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 
 	num_pol = prm.num_pol;
 	if (num_pol <= 0) {
-		xx_pr_err("Invalid number of policies for SA ID# %d\n", sa_id);
+		pr_err("Invalid number of policies for SA ID# %d\n", sa_id);
 		return -EINVAL;
 	}
 
 	policy_params =	xx_zalloc(num_pol * sizeof(*policy_params));
 	if (!policy_params) {
-		xx_pr_err("Could not allocate memory for policy array");
+		pr_err("Could not allocate memory for policy array");
 		return -ENOMEM;
 	}
 
 	err = dpa_ipsec_sa_get_policies(sa_id, policy_params, &num_pol);
 	if (err < 0 && err != -EAGAIN) {
-		xx_pr_err("Could not retrieve SA policies");
+		pr_err("Could not retrieve SA policies");
 		goto err_pol_cleanup;
 	} else if (err == -EAGAIN)
-		xx_pr_err("Not all SA policies could be retrieved");
+		pr_err("Not all SA policies could be retrieved");
 
 	if (copy_to_user(prm.policy_params, policy_params,
 			 num_pol * sizeof(*policy_params))) {
-		xx_pr_err("Could not return policy parameters\n");
+		pr_err("Could not return policy parameters\n");
 		err = -EINVAL;
 	}
 	/*
@@ -765,7 +765,7 @@ int wrp_dpa_ipsec_init(void)
 	dpa_ipsec_cdev_major =
 	    register_chrdev(0, DPA_IPSEC_CDEV, &dpa_ipsec_fops);
 	if (dpa_ipsec_cdev_major < 0) {
-		xx_pr_err("Could not register Dpa Ipsec character device");
+		pr_err("Could not register Dpa Ipsec character device");
 		return dpa_ipsec_cdev_major;
 	}
 	return 0;
@@ -826,7 +826,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		int dpa_ipsec_id;
 		if (copy_from_user(&dpa_ipsec_id, (int *)args,
 				    sizeof(int))) {
-			xx_pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters");
 			return -EINVAL;
 		}
 		err = dpa_ipsec_free(dpa_ipsec_id);
@@ -846,7 +846,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 	case DPA_IPSEC_IOC_REMOVE_SA: {
 		int sa_id;
 		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-			xx_pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters");
 			return -EINVAL;
 		}
 
@@ -861,7 +861,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		if (copy_from_user(&pol,
 			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
 			    sizeof(pol))) {
-			xx_pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters");
 			return -EINVAL;
 		}
 		err = dpa_ipsec_sa_add_policy(pol.sa_id,
@@ -876,7 +876,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		if (copy_from_user(&pol,
 			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
 			    sizeof(pol))) {
-			xx_pr_err("Could not copy parameters\n");
+			pr_err("Could not copy parameters\n");
 			return -EINVAL;
 		}
 
@@ -900,7 +900,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 
 		if (copy_from_user(&dpa_ipsec_id,
 				    (int *)args, sizeof(int))) {
-			xx_pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters");
 			return -EINVAL;
 		}
 
@@ -922,7 +922,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		int sa_id;
 
 		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-			xx_pr_err("Could not copy SA id");
+			pr_err("Could not copy SA id");
 			return -EINVAL;
 		}
 
@@ -936,7 +936,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		int sa_id;
 
 		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-			xx_pr_err("Could not copy SA id\n");
+			pr_err("Could not copy SA id\n");
 			return -EINVAL;
 		}
 
@@ -952,24 +952,24 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		if (copy_from_user(&prm,
 				(struct ioc_dpa_ipsec_sa_get_stats *)args,
 				sizeof(prm))) {
-			xx_pr_err("Could not copy from user stats params");
+			pr_err("Could not copy from user stats params");
 			return -EINVAL;
 		}
 
 		if (prm.sa_id < 0) {
-			xx_pr_err("Invalid input SA id\n");
+			pr_err("Invalid input SA id\n");
 			return -EINVAL;
 		}
 
 		err = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
 		if (err < 0) {
-			xx_pr_err("Getting stats failed\n");
+			pr_err("Getting stats failed\n");
 			return err;
 		}
 
 		if (copy_to_user((struct ioc_dpa_ipsec_sa_get_stats *)args,
 				 &prm, sizeof(prm))) {
-			xx_pr_err("Could not copy stats to user\n");
+			pr_err("Could not copy stats to user\n");
 			return -EINVAL;
 		}
 
@@ -977,7 +977,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 	}
 
 	default:
-		xx_pr_err("Invalid DPA IPsec ioctl\n");
+		pr_err("Invalid DPA IPsec ioctl\n");
 		break;
 	}
 	return ret;
@@ -986,7 +986,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 
 int default_rekey_event_cb(int dpa_ipsec_id, int sa_id, int error)
 {
-	xx_pr_info("DPA IPSec Instance %d || new sa_id %d || error %d\n",
+	pr_info("DPA IPSec Instance %d || new sa_id %d || error %d\n",
 		dpa_ipsec_id, sa_id, error);
 	return 0;
 }
-- 
1.7.5.4

