From 620cf6560299b7322b69333589549dbac665bb71 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Thu, 1 Mar 2012 20:59:21 +0000
Subject: [PATCH 102/518] Modified xx_pr... macros to be variadic && updated
 dpa offload sources accordingly

xx_pr_err and friends are now variadic macros
    Updated dpa_ipsec.c, dpa_classifier.c,dpa_ipsec_desc.c, wrp_dpa_classifier.c,
    wrp_dpa_ipsec.c code to use the new variadic macros for reporting errors/warnings/debug msgs

    Many thanks to Kim Philips for the review and hint

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  144 +++---
 drivers/staging/fsl_dpa_offload/dpa_compat.h       |   27 +-
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c        |  582 ++++++++++----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c   |   24 +-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   44 +-
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c    |   44 +-
 6 files changed, 433 insertions(+), 432 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 8e1ab3c..ec2a044 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -100,7 +100,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	ptable = (struct dpa_cls_table *)
 			xx_zalloc(sizeof(struct dpa_cls_table));
 	if (!ptable) {
-		xx_pr_err(("No more memory for DPA classifier table."));
+		xx_pr_err("No more memory for DPA classifier table.");
 		err = -ENOMEM;
 		goto dpa_classif_table_create_error;
 	}
@@ -127,7 +127,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				xx_zalloc(sizeof(struct
 						dpa_cls_tbl_shadow_table));
 			if (!ptable->shadow_table) {
-				xx_pr_err(("No more memory for DPA classifier shadow table."));
+				xx_pr_err("No more memory for DPA classifier shadow table.");
 				err = -ENOMEM;
 				goto dpa_classif_table_create_error;
 			}
@@ -162,7 +162,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				xx_zalloc(ptable->num_shadow_tables *
 				sizeof(struct dpa_cls_tbl_shadow_table));
 			if (!ptable->shadow_table) {
-				xx_pr_err(("No more memory for DPA classifier shadow table."));
+				xx_pr_err("No more memory for DPA classifier shadow table.");
 				err = -ENOMEM;
 				goto dpa_classif_table_create_error;
 			}
@@ -193,7 +193,7 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				xx_zalloc(sizeof(struct
 						dpa_cls_tbl_shadow_table));
 			if (!ptable->shadow_table) {
-				xx_pr_err(("No more memory for DPA classifier shadow table."));
+				xx_pr_err("No more memory for DPA classifier shadow table.");
 				err = -ENOMEM;
 				goto dpa_classif_table_create_error;
 			}
@@ -301,7 +301,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 	ptable = table[td];
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		xx_pr_err(("Miss Action for DPA Classifier Indexed Tables is not supported."));
+		xx_pr_err("Miss Action for DPA Classifier Indexed Tables is not supported.");
 		return -ENOSYS;
 	}
 
@@ -323,7 +323,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 			if (err != E_OK) {
 				xx_pr_fmd_err(err,
 					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err(("FMan driver call failed."));
+				xx_pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
 		}
@@ -349,7 +349,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 			&miss_engine_params);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyMissNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 	}
@@ -382,7 +382,7 @@ int dpa_classif_table_insert_entry(int				td,
 	 */
 	if ((table[td]->shadow_table) &&
 			(find_shadow_entry(table[td], key) != NULL)) {
-		xx_pr_err(("DPA Classifier table entry already exists."));
+		xx_pr_err("DPA Classifier table entry already exists.");
 		return -EEXIST;
 	}
 
@@ -432,21 +432,21 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 	/* Check for shadow table */
 	if (!table[td]->shadow_table) {
-		xx_pr_err(("Cannot modify entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table."));
+		xx_pr_err("Cannot modify entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 		(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		xx_pr_err(("Modify entry key is supported only on exact match tables."));
+		xx_pr_err("Modify entry key is supported only on exact match tables.");
 		return -ENOSYS;
 	}
 
 	/* Find the shadow entry associated with this key */
 	list_entry = find_shadow_entry(table[td], key);
 	if (list_entry == NULL) {
-		xx_pr_err(("DPA Classifier table entry not found."));
+		xx_pr_err("DPA Classifier table entry not found.");
 		return -ENODEV;
 	}
 
@@ -491,7 +491,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 			(table[td]->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		xx_pr_err(("Modify entry key is supported only on exact match tables."));
+		xx_pr_err("Modify entry key is supported only on exact match tables.");
 		return -ENOSYS;
 	}
 
@@ -531,7 +531,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 						&next_engine_params);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -558,7 +558,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				mask_data);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -594,7 +594,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		if (err != E_OK) {
 			xx_pr_fmd_err(err,
 				"FM_PCD_CcNodeModifyKeyAndNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -657,14 +657,14 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err(("Cannot delete entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table."));
+		xx_pr_err("Cannot delete entry by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
 	/* Find the shadow entry associated with this key */
 	list_entry = find_shadow_entry(table[td], key);
 	if (list_entry == NULL) {
-		xx_pr_err(("DPA Classifier table entry not found."));
+		xx_pr_err("DPA Classifier table entry not found.");
 		return -ENODEV;
 	}
 
@@ -738,7 +738,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 						&next_engine_params);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -752,7 +752,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 					index);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeRemoveKey");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 
@@ -821,7 +821,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err(("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table."));
+		xx_pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
@@ -862,7 +862,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err(("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table."));
+		xx_pr_err("Cannot lookup in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
@@ -946,7 +946,7 @@ int dpa_classif_table_flush(int td)
 			if (err != E_OK) {
 				xx_pr_fmd_err(err,
 					"FM_PCD_CcNodeModifyNextEngine");
-				xx_pr_err(("FMan driver call failed."));
+				xx_pr_err("FMan driver call failed.");
 				return -EBUSY;
 			}
 		}
@@ -1000,7 +1000,7 @@ int dpa_classif_table_flush(int td)
 							index);
 				if (err != E_OK) {
 					xx_pr_fmd_err(err, "FM_PCD_CcNodeRemoveKey");
-					xx_pr_err(("FMan driver call failed."));
+					xx_pr_err("FMan driver call failed.");
 					return -EBUSY;
 				}
 
@@ -1046,14 +1046,14 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
 	if (!table[td]->shadow_table) {
-		xx_pr_err(("Cannot get stats by key in a DPA_CLS_TBL_MANAGE_BY_REF table."));
+		xx_pr_err("Cannot get stats by key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
 		return -ENOSYS;
 	}
 
 	/* Find the shadow entry associated with this key */
 	list_entry = find_shadow_entry(table[td], key);
 	if (list_entry == NULL) {
-		xx_pr_err(("DPA Classifier table entry not found."));
+		xx_pr_err("DPA Classifier table entry not found.");
 		return -ENODEV;
 	}
 
@@ -1132,7 +1132,7 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 		xx_zalloc(cls_table->int_cc_nodes_count *
 			sizeof(struct dpa_cls_tbl_cc_node_info));
 	if (!cls_table->int_cc_node) {
-		xx_pr_err(("No more memory for DPA Classifier table management."));
+		xx_pr_err("No more memory for DPA Classifier table management.");
 		err = -ENOMEM;
 		goto alloc_table_mgmt_error;
 	}
@@ -1198,7 +1198,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 						&next_engine_params);
 		if (err != E_OK) {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			return -EBUSY;
 		}
 	}
@@ -1225,7 +1225,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	hash_set_params = (t_FmPcdCcNodeParams *)
 		xx_zalloc(sizeof(struct t_FmPcdCcNodeParams));
 	if (!hash_set_params) {
-		xx_pr_err(("No more memory for DPA Classifier hash table."));
+		xx_pr_err("No more memory for DPA Classifier hash table.");
 		err = -ENOMEM;
 		goto table_init_hash_error;
 	}
@@ -1260,7 +1260,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 					hash_set_params);
 		if (cls_table->int_cc_node[i].cc_node == NULL) {
 			xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_CcSetNode");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1277,7 +1277,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		if (err_code != E_OK) {
 			xx_pr_fmd_err(err_code,
 				"FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
+			xx_pr_err("FMan driver call failed.");
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1287,7 +1287,7 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 			xx_zalloc(cls_table->int_cc_node[i].table_size *
 				sizeof(struct dpa_cls_tbl_entry));
 		if (!cls_table->int_cc_node[i].entry) {
-			xx_pr_err(("No more memory for DPA Classifier table index management."));
+			xx_pr_err("No more memory for DPA Classifier table index management.");
 			err = -ENOMEM;
 			goto table_init_hash_error;
 		}
@@ -1333,7 +1333,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	cc_node_params = (t_FmPcdCcNodeParams *)
 		xx_zalloc(sizeof(t_FmPcdCcNodeParams));
 	if (!cc_node_params) {
-		xx_pr_err(("No more memory for DPA Classifier exact match table."));
+		xx_pr_err("No more memory for DPA Classifier exact match table.");
 		err = -ENOMEM;
 		goto table_init_exact_match_error;
 	}
@@ -1366,7 +1366,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 			if (!cls_table->int_cc_node[i].cc_node) {
 				xx_pr_fmd_err(E_NOT_AVAILABLE,
 					"FM_PCD_CcSetNode");
-				xx_pr_err(("FMan driver call failed."));
+				xx_pr_err("FMan driver call failed.");
 				err = -EBUSY;
 				goto table_init_exact_match_error;
 			}
@@ -1386,7 +1386,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 			xx_zalloc(cls_table->int_cc_node[i].table_size *
 			sizeof(struct dpa_cls_tbl_entry));
 		if (!cls_table->int_cc_node[i].entry) {
-			xx_pr_err(("No more memory for DPA Classifier table index management."));
+			xx_pr_err("No more memory for DPA Classifier table index management.");
 			err = -ENOMEM;
 			goto table_init_exact_match_error;
 		}
@@ -1442,8 +1442,8 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 				(t_Handle)cls_table->int_cc_node[i].cc_node);
 		else {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
-			xx_pr_warn(("DPA Classifier failed to clean up hash table."));
+			xx_pr_err("FMan driver call failed.");
+			xx_pr_warn("DPA Classifier failed to clean up hash table.");
 		}
 	}
 }
@@ -1485,8 +1485,8 @@ static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 				(t_Handle)cls_table->int_cc_node[i].cc_node);
 		} else {
 			xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-			xx_pr_err(("FMan driver call failed."));
-			xx_pr_warn(("DPA Classifier failed to clean up exact match table."));
+			xx_pr_err("FMan driver call failed.");
+			xx_pr_warn("DPA Classifier failed to clean up exact match table.");
 		}
 	}
 }
@@ -1506,30 +1506,30 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		 */
 		if (params->exact_match_params.entries_cnt >
 				3 * FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_warn(("Large exact match tables might cause performance penalties."));
+			xx_pr_warn("Large exact match tables might cause performance penalties.");
 			break;
 		}
 
 		if (params->exact_match_params.key_size >
 				FM_PCD_MAX_SIZE_OF_KEY) {
-			xx_pr_err(("DPA Classifier exact match table key size (%d bytes) exceeds maximum (%d bytes).",
+			xx_pr_err("DPA Classifier exact match table key size (%d bytes) exceeds maximum (%d bytes).",
 				params->exact_match_params.key_size,
-				FM_PCD_MAX_SIZE_OF_KEY));
+				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->exact_match_params.use_priorities) {
-			xx_pr_err(("Entry priorities for exact match tables are not yet supported."));
+			xx_pr_err("Entry priorities for exact match tables are not yet supported.");
 			err = -ENOSYS;
 			break;
 		}
 		break;
 	case DPA_CLS_TBL_HASH:
 		if (params->hash_params.num_sets > FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err(("DPA Classifier hash table number of sets (%d) exceeds maximum (%d).",
+			xx_pr_err("DPA Classifier hash table number of sets (%d) exceeds maximum (%d).",
 				params->hash_params.num_sets,
-				FM_PCD_MAX_NUM_OF_KEYS));
+				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
 			break;
 		}
@@ -1540,24 +1540,24 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		while (num_sets < params->hash_params.num_sets)
 			num_sets <<= 1;
 		if (num_sets != params->hash_params.num_sets) {
-			xx_pr_err(("DPA Classifier hash table number of sets (%d) must be a power of 2.",
-				params->hash_params.num_sets));
+			xx_pr_err("DPA Classifier hash table number of sets (%d) must be a power of 2.",
+				params->hash_params.num_sets);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->hash_params.max_ways > FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err(("DPA Classifier hash table number of ways (%d) exceeds maximum (%d).",
+			xx_pr_err("DPA Classifier hash table number of ways (%d) exceeds maximum (%d).",
 				params->hash_params.max_ways,
-				FM_PCD_MAX_NUM_OF_KEYS));
+				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->hash_params.key_size > FM_PCD_MAX_SIZE_OF_KEY) {
-			xx_pr_err(("DPA Classifier hash table key size (%d bytes) exceeds maximum (%d bytes).",
+			xx_pr_err("DPA Classifier hash table key size (%d bytes) exceeds maximum (%d bytes).",
 				params->hash_params.key_size,
-				FM_PCD_MAX_SIZE_OF_KEY));
+				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
 			break;
 		}
@@ -1565,22 +1565,22 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 	case DPA_CLS_TBL_INDEXED:
 		if (params->indexed_params.entries_cnt >
 				FM_PCD_MAX_NUM_OF_KEYS) {
-			xx_pr_err(("DPA Classifier indexed table size (%d entries) exceeds maximum (%d entries).",
+			xx_pr_err("DPA Classifier indexed table size (%d entries) exceeds maximum (%d entries).",
 				params->indexed_params.entries_cnt,
-				FM_PCD_MAX_NUM_OF_KEYS));
+				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->indexed_params.entries_cnt == 0) {
-			xx_pr_err(("Indexed table size zero is invalid."));
+			xx_pr_err("Indexed table size zero is invalid.");
 			err = -EINVAL;
 			break;
 		}
 		break;
 	default:
-		xx_pr_err(("Unsupported DPA Classifier table type (%d).",
-			params->type));
+		xx_pr_err("Unsupported DPA Classifier table type (%d).",
+			params->type);
 		err = -EINVAL;
 	}
 
@@ -1695,7 +1695,7 @@ static int init_shadow_tables(struct dpa_cls_table *cls_table)
 			xx_malloc(cls_table->shadow_table[i].size *
 				sizeof(struct list_head));
 		if (!cls_table->shadow_table[i].shadow_entry) {
-			xx_pr_err(("No more memory for DPA Classifier shadow tables."));
+			xx_pr_err("No more memory for DPA Classifier shadow tables.");
 			err = -ENOMEM;
 			goto init_shadow_tables_error;
 		}
@@ -1758,7 +1758,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 					&next_engine_params);
 	if (err != E_OK) {
 		xx_pr_fmd_err(err, "FM_PCD_CcNodeModifyNextEngine");
-		xx_pr_err(("FMan driver call failed."));
+		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_indexed_error;
 	}
@@ -1770,7 +1770,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry_indexed *)
 			xx_zalloc(sizeof(*shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err(("No more memory for a new DPA Classifier table entry."));
+			xx_pr_err("No more memory for a new DPA Classifier table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_indexed_error;
 		}
@@ -1874,7 +1874,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			if (err != E_OK) {
 				xx_pr_fmd_err(err,
 					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err(("FMan driver call failed."));
+				xx_pr_err("FMan driver call failed.");
 				errno = -EBUSY;
 				goto table_insert_entry_exact_match_error;
 			}
@@ -1886,7 +1886,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			if (err != E_OK) {
 				xx_pr_fmd_err(err,
 					"FM_PCD_CcNodeModifyMissNextEngine");
-				xx_pr_err(("FMan driver call failed."));
+				xx_pr_err("FMan driver call failed.");
 				errno = -EBUSY;
 				goto table_insert_entry_exact_match_error;
 			}
@@ -1895,7 +1895,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	if (i > cls_table->int_cc_nodes_count) {
 		/* No more space to add a new entry */
-		xx_pr_err(("DPA Classifier exact match table is full. Unable to add a new entry."));
+		xx_pr_err("DPA Classifier exact match table is full. Unable to add a new entry.");
 		errno = -ENOSPC;
 		goto table_insert_entry_exact_match_error;
 	}
@@ -1921,7 +1921,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		&key_params);
 	if (err != E_OK) {
 		xx_pr_fmd_err(err, "FM_PCD_CcNodeAddKey");
-		xx_pr_err(("FMan driver call failed."));
+		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_exact_match_error;
 	}
@@ -1933,7 +1933,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err(("No more memory to add a new DPA Classifier shadow table entry."));
+			xx_pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_exact_match_error;
 		}
@@ -2019,7 +2019,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	/* Check if there are entries still available in the selected set */
 	if (cls_table->int_cc_node[hash_set_index].used >=
 			cls_table->int_cc_node[hash_set_index].table_size) {
-		xx_pr_err(("DPA Classifier hash table is full. Unable to add a new entry."));
+		xx_pr_err("DPA Classifier hash table is full. Unable to add a new entry.");
 		errno = -ENOSPC;
 		goto table_insert_entry_hash_error;
 	}
@@ -2045,7 +2045,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		&key_params);
 	if (err != E_OK) {
 		xx_pr_fmd_err(err, "FM_PCD_CcNodeAddKey");
-		xx_pr_err(("FMan driver call failed."));
+		xx_pr_err("FMan driver call failed.");
 		errno = -EBUSY;
 		goto table_insert_entry_hash_error;
 	}
@@ -2057,7 +2057,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
-			xx_pr_err(("No more memory to add a new DPA Classifier shadow table entry."));
+			xx_pr_err("No more memory to add a new DPA Classifier shadow table entry.");
 			errno = -ENOMEM;
 			goto table_insert_entry_hash_error;
 		}
@@ -2114,7 +2114,7 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		break;
 	case DPA_CLS_TBL_ACTION_ENQ:
 		if (action->enq_params.policer_params != NULL) {
-			xx_pr_err(("Policing for DPA Classifier flows is not yet supported."));
+			xx_pr_err("Policing for DPA Classifier flows is not yet supported.");
 			return -ENOSYS;
 		}
 
@@ -2135,8 +2135,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
 		if ((action->next_table_params.next_td >= num_tables) ||
 			(!table[action->next_table_params.next_td])) {
-			xx_pr_err(("Invalid next table descriptor (0x%08x).",
-				(unsigned)action->next_table_params.next_td));
+			xx_pr_err("Invalid next table descriptor (0x%08x).",
+				(unsigned)action->next_table_params.next_td);
 			return -EINVAL;
 		}
 
@@ -2147,8 +2147,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	default:
-		xx_pr_err(("Unsupported DPA Classifier action type (%d).",
-			action->type));
+		xx_pr_err("Unsupported DPA Classifier action type (%d).",
+			action->type);
 		return -EINVAL;
 	}
 
@@ -2168,7 +2168,7 @@ static int extend_table_array(void)
 	new_table_array = (struct dpa_cls_table **)
 		xx_zalloc(new_table_size * sizeof(struct dpa_cls_table *));
 	if (!new_table_array) {
-		xx_pr_err(("No more memory for DPA Classifier table management."));
+		xx_pr_err("No more memory for DPA Classifier table management.");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_compat.h b/drivers/staging/fsl_dpa_offload/dpa_compat.h
index 2c57e04..fcd3779 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_compat.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_compat.h
@@ -155,27 +155,28 @@ void	dpa_offld_display_mem_leaks(void);
  * Error Reporting
  */
 #ifdef DPA_OFFLOAD_VERBOSE_WARNINGS
-#define	xx_pr_warn(message) \
+#define	xx_pr_warn(...) \
 	do { \
 		pr_warn("WARNING: %s (%d): %s:", __FILE__, __LINE__, \
 			__func__); \
-		pr_warn message; \
+		pr_warn(__VA_ARGS__); \
 	} while (0)
 #else
-#define xx_pr_warn(message)
+#define xx_pr_warn(...)
 #endif /* DPA_OFFLOAD_VERBOSE_WARNINGS */
 
 #ifdef DPA_OFFLOAD_VERBOSE_ERRORS
-#define xx_pr_err(message) \
+#define xx_pr_err(...) \
 	do { \
 		pr_err("ERROR: %s (%d): %s:", __FILE__, __LINE__, __func__); \
-		pr_err message; \
+		pr_err(__VA_ARGS__); \
 	} while (0)
-#define xx_pr_crit(message) \
+
+#define xx_pr_crit(...) \
 	do { \
 		pr_crit("CRITICAL: %s (%d): %s:", __FILE__, __LINE__, \
 			__func__); \
-		pr_crit message; \
+		pr_crit(__VA_ARGS__); \
 	} while (0)
 
 #define xx_pr_fmd_err(err_code, fmd_api) \
@@ -184,8 +185,8 @@ void	dpa_offld_display_mem_leaks(void);
 		fmd_api, \
 		errTypeStrings[GET_ERROR_TYPE(err_code)-E_OK-1])
 #else
-#define xx_pr_err(message)
-#define xx_pr_crit(message)
+#define xx_pr_err(...)
+#define xx_pr_crit(...)
 #define xx_pr_fmd_err(err_code, fmd_api)
 #endif /* DPA_OFFLOAD_VERBOSE_ERRORS */
 
@@ -193,16 +194,16 @@ void	dpa_offld_display_mem_leaks(void);
  * This is the main display macro. Info display is always on (you cannot
  * disable it), so please use it with consideration.
  */
-#define xx_pr_info(message)			pr_info message
+#define xx_pr_info(...)			pr_info(__VA_ARGS__)
 
 #ifdef DPA_OFFLOAD_VERBOSE_DEBUG
-#define xx_pr_debug(message) \
+#define xx_pr_debug(...) \
 	do { \
 		pr_info("DEBUG: %s (%d): %s:", __FILE__, __LINE__, __func__); \
-		pr_info message; \
+		pr_info(__VA_ARGS__); \
 	} while (0)
 #else
-#define xx_pr_debug(message)
+#define xx_pr_debug(...)
 #endif /* DPA_OFFLOAD_VERBOSE_DEBUG */
 
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 21db189..0c4d266 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -59,111 +59,111 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	struct dpa_ipsec_policy_selectors *policy_selectors;
 
 	if (!sa) {
-		xx_pr_err(("Invalid argument: null SA handle\n"));
+		xx_pr_err("Invalid argument: null SA handle\n");
 		return -EFAULT;
 	}
 
-	xx_pr_info(("\n Printing SA SEC PARAM for sa %p\n", sa));
-	xx_pr_info(("\n sa_dir = %d\n", sa->sa_dir));
-	xx_pr_info(("\n id = %d\n", sa->id));
-	xx_pr_info((" dpa_ipsec addr = %p\n", sa->dpa_ipsec));
-	xx_pr_info((" from_sec_fq addr = %p\n", sa->from_sec_fq));
+	xx_pr_info("\n Printing SA SEC PARAM for sa %p\n", sa);
+	xx_pr_info("\n sa_dir = %d\n", sa->sa_dir);
+	xx_pr_info("\n id = %d\n", sa->id);
+	xx_pr_info(" dpa_ipsec addr = %p\n", sa->dpa_ipsec);
+	xx_pr_info(" from_sec_fq addr = %p\n", sa->from_sec_fq);
 
-	xx_pr_info(("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type));
-	xx_pr_info(("auth_data.auth_key_len = %d\n",
-		sa->auth_data.auth_key_len));
-	xx_pr_info(("auth_data.auth_key is\n"));
+	xx_pr_info("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type);
+	xx_pr_info("auth_data.auth_key_len = %d\n",
+		sa->auth_data.auth_key_len);
+	xx_pr_info("auth_data.auth_key is\n");
 	for (i = 0; i < sa->auth_data.auth_key_len; i++)
-		xx_pr_info((("%x, ", sa->auth_data.auth_key[i])));
+		xx_pr_info("%x, ", sa->auth_data.auth_key[i]);
 
-	xx_pr_info(("\n cipher_data.cipher_type = %d\n",
-		sa->cipher_data.cipher_type));
-	xx_pr_info(("cipher_data.cipher_key_len = %d\n",
-		sa->cipher_data.cipher_key_len));
-	xx_pr_info(("cipher_data.cipher_key is\n"));
+	xx_pr_info("\n cipher_data.cipher_type = %d\n",
+		sa->cipher_data.cipher_type);
+	xx_pr_info("cipher_data.cipher_key_len = %d\n",
+		sa->cipher_data.cipher_key_len);
+	xx_pr_info("cipher_data.cipher_key is\n");
 	for (i = 0; i < sa->cipher_data.cipher_key_len; i++)
-		xx_pr_info((("%x, ", sa->cipher_data.cipher_key[i])));
+		xx_pr_info("%x, ", sa->cipher_data.cipher_key[i]);
 
-	xx_pr_info(("\n sa_bpid = %d\n", sa->sa_bpid));
-	xx_pr_info((" spi = %d\n", sa->spi));
-	xx_pr_info((" sa_wqid = %d\n", sa->sa_wqid));
-	xx_pr_info((" outbound_flowid = %d\n", sa->outbound_flowid));
+	xx_pr_info("\n sa_bpid = %d\n", sa->sa_bpid);
+	xx_pr_info(" spi = %d\n", sa->spi);
+	xx_pr_info(" sa_wqid = %d\n", sa->sa_wqid);
+	xx_pr_info(" outbound_flowid = %d\n", sa->outbound_flowid);
 
-	xx_pr_info(("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type));
-	xx_pr_info(("dest_addr = %x.%x.%x.%x\n",
+	xx_pr_info("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type);
+	xx_pr_info("dest_addr = %x.%x.%x.%x\n",
 		sa->dest_addr.ipv4.byte[0],
 		sa->dest_addr.ipv4.byte[1],
-		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]));
-	xx_pr_info(("src_addr.addr_type = %d\n", sa->src_addr.addr_type));
-	xx_pr_info(("src_addr = %x.%x.%x.%x\n",
+		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]);
+	xx_pr_info("src_addr.addr_type = %d\n", sa->src_addr.addr_type);
+	xx_pr_info("src_addr = %x.%x.%x.%x\n",
 		sa->src_addr.ipv4.byte[0],
 		sa->src_addr.ipv4.byte[1],
-		sa->src_addr.ipv4.byte[2], sa->src_addr.ipv4.byte[3]));
+		sa->src_addr.ipv4.byte[2], sa->src_addr.ipv4.byte[3]);
 
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		uint8_t *out_hdr;
 		out_hdr = &sa->sec_desc->pdb_en.ip_hdr[0];
-		xx_pr_info(("Outer Header length  %d\n",
-			sa->sec_desc->pdb_en.ip_hdr_len));
-		xx_pr_info(("Outer Header is:\n"));
+		xx_pr_info("Outer Header length  %d\n",
+			sa->sec_desc->pdb_en.ip_hdr_len);
+		xx_pr_info("Outer Header is:\n");
 		for (i = 0; i < sa->sec_desc->pdb_en.ip_hdr_len; i++)
-			xx_pr_info(("%x, ", *(out_hdr + i)));
-
-		xx_pr_info(("pdb_en.ip_hdr_len %d\n",
-			sa->sec_desc->pdb_en.ip_hdr_len));
-		xx_pr_info(("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi));
-		xx_pr_info(("pdb_en.seq_num = %d\n",
-			sa->sec_desc->pdb_en.seq_num));
-		xx_pr_info(("pdb_en.options = 0x%x\n",
-			sa->sec_desc->pdb_en.options));
-		xx_pr_info(("pdb_en.desc_hdr = 0x%x\n",
-			sa->sec_desc->pdb_en.desc_hdr));
-		xx_pr_info(("pdb_en.ip_nh = 0x%x\n",
-			sa->sec_desc->pdb_en.ip_nh));
+			xx_pr_info("%x, ", *(out_hdr + i));
+
+		xx_pr_info("pdb_en.ip_hdr_len %d\n",
+			sa->sec_desc->pdb_en.ip_hdr_len);
+		xx_pr_info("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi);
+		xx_pr_info("pdb_en.seq_num = %d\n",
+			sa->sec_desc->pdb_en.seq_num);
+		xx_pr_info("pdb_en.options = 0x%x\n",
+			sa->sec_desc->pdb_en.options);
+		xx_pr_info("pdb_en.desc_hdr = 0x%x\n",
+			sa->sec_desc->pdb_en.desc_hdr);
+		xx_pr_info("pdb_en.ip_nh = 0x%x\n",
+			sa->sec_desc->pdb_en.ip_nh);
 	} else {
-		xx_pr_info(("pdb_dec.hmo_ip_hdr_len %d\n",
-			sa->sec_desc->pdb_dec.hmo_ip_hdr_len));
-		xx_pr_info(("pdb_dec.options %d\n",
-			sa->sec_desc->pdb_dec.options));
-		xx_pr_info(("pdb_dec.seq_num %d\n",
-			sa->sec_desc->pdb_dec.seq_num));
+		xx_pr_info("pdb_dec.hmo_ip_hdr_len %d\n",
+			sa->sec_desc->pdb_dec.hmo_ip_hdr_len);
+		xx_pr_info("pdb_dec.options %d\n",
+			sa->sec_desc->pdb_dec.options);
+		xx_pr_info("pdb_dec.seq_num %d\n",
+			sa->sec_desc->pdb_dec.seq_num);
 	}
 
-	xx_pr_info(("\n Printing all policies from this SA policy_list\n"));
+	xx_pr_info("\n Printing all policies from this SA policy_list\n");
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
 		policy_selectors = &policy_entry->policy_selectors;
-		xx_pr_info(("policy_selectors src_addr.addr_type = %d\n",
-			policy_selectors->src_addr.addr_type));
-		xx_pr_info(("policy_selectors src_addr = %x.%x.%x.%x\n",
+		xx_pr_info("policy_selectors src_addr.addr_type = %d\n",
+			policy_selectors->src_addr.addr_type);
+		xx_pr_info("policy_selectors src_addr = %x.%x.%x.%x\n",
 			policy_selectors->src_addr.ipv4.byte[0],
 			policy_selectors->src_addr.ipv4.byte[1],
 			policy_selectors->src_addr.ipv4.byte[2],
-			policy_selectors->src_addr.ipv4.byte[3]));
-		xx_pr_info(("\n policy_selectors dest_addr.addr_type = %d\n",
-			policy_selectors->dest_addr.addr_type));
-		xx_pr_info(("policy_selectors dest_addr = %x.%x.%x.%x\n",
+			policy_selectors->src_addr.ipv4.byte[3]);
+		xx_pr_info("\n policy_selectors dest_addr.addr_type = %d\n",
+			policy_selectors->dest_addr.addr_type);
+		xx_pr_info("policy_selectors dest_addr = %x.%x.%x.%x\n",
 			policy_selectors->dest_addr.ipv4.byte[0],
 			policy_selectors->dest_addr.ipv4.byte[1],
 			policy_selectors->dest_addr.ipv4.byte[2],
-			policy_selectors->dest_addr.ipv4.byte[3]));
-
-		xx_pr_info(("\n policy_selectors dest_port = %d\n",
-			policy_selectors->dest_port));
-		xx_pr_info((" policy_selectors src_port = %d\n",
-			policy_selectors->src_port));
-		xx_pr_info((" policy_selectors dest_port = %d\n",
-			policy_selectors->dest_port_mask));
-		xx_pr_info((" policy_selectors dest_port = %d\n",
-			policy_selectors->src_port_mask));
-		xx_pr_info((" policy_selectors proto = %d\n",
-			policy_selectors->protocol));
-		xx_pr_info((" policy_selectors dest_prefix_len = %d\n",
-			policy_selectors->dest_prefix_len));
-		xx_pr_info((" policy_selectors src_prefix_len = %d\n",
-			policy_selectors->src_prefix_len));
-	}
-	xx_pr_info(("\n Done printing SA SEC PARAM for sa %p\n", sa));
+			policy_selectors->dest_addr.ipv4.byte[3]);
+
+		xx_pr_info("\n policy_selectors dest_port = %d\n",
+			policy_selectors->dest_port);
+		xx_pr_info(" policy_selectors src_port = %d\n",
+			policy_selectors->src_port);
+		xx_pr_info(" policy_selectors dest_port = %d\n",
+			policy_selectors->dest_port_mask);
+		xx_pr_info(" policy_selectors dest_port = %d\n",
+			policy_selectors->src_port_mask);
+		xx_pr_info(" policy_selectors proto = %d\n",
+			policy_selectors->protocol);
+		xx_pr_info(" policy_selectors dest_prefix_len = %d\n",
+			policy_selectors->dest_prefix_len);
+		xx_pr_info(" policy_selectors src_prefix_len = %d\n",
+			policy_selectors->src_prefix_len);
+	}
+	xx_pr_info("\n Done printing SA SEC PARAM for sa %p\n", sa);
 
 	return 0;
 }
@@ -186,12 +186,12 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	int i, err, valid_tables = 0;
 
 	if (!prms) {
-		xx_pr_err(("Invalid DPA IPsec parameters handle\n"));
+		xx_pr_err("Invalid DPA IPsec parameters handle\n");
 		return -EINVAL;
 	}
 
 	if ((prms->post_sec_in_params.do_pol_check) && (!prms->fm_pcd)) {
-		xx_pr_err(("Provide a valid PCD handle to enable inbound policy check!\n"));
+		xx_pr_err("Provide a valid PCD handle to enable inbound policy check!\n");
 		return -EINVAL;
 	}
 
@@ -209,26 +209,26 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 				       prms->pre_sec_out_params.dpa_cls_td[i],
 				       &table_params);
 			if (err < 0) {
-				xx_pr_err(("Couldn't check type of outbound policy lookup table\n"));
+				xx_pr_err("Couldn't check type of outbound policy lookup table\n");
 				return -EINVAL;
 			}
 
 			if (table_params.type == DPA_CLS_TBL_INDEXED) {
-				xx_pr_err(("Outbound policy lookup table cannot be of type INDEXED\n"));
+				xx_pr_err("Outbound policy lookup table cannot be of type INDEXED\n");
 				return -EINVAL;
 			}
 			valid_tables++;
 		}
 
 	if (!valid_tables) {
-		xx_pr_err(("Specify at least one table for outbound policy lookup\n"));
+		xx_pr_err("Specify at least one table for outbound policy lookup\n");
 		return -EINVAL;
 	}
 
 	/* post decryption SA classification table */
 	if (prms->post_sec_in_params.dpa_cls_td ==
 						  DPA_CLS_INVALID_TABLE_DESC) {
-		xx_pr_err(("Specify a valid table for post decryption classification\n"));
+		xx_pr_err("Specify a valid table for post decryption classification\n");
 		return -EINVAL;
 	}
 
@@ -236,18 +236,18 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	err = dpa_classif_table_get_params(prms->post_sec_in_params.dpa_cls_td,
 					   &table_params);
 	if (err < 0) {
-		xx_pr_err(("Could not check type of post decryption table\n"));
+		xx_pr_err("Could not check type of post decryption table\n");
 		return -EINVAL;
 	}
 
 	if (table_params.type != DPA_CLS_TBL_INDEXED) {
-		xx_pr_err(("Post decryption table must be of type INDEXED\n"));
+		xx_pr_err("Post decryption table must be of type INDEXED\n");
 		return -EINVAL;
 	}
 
 	/* pre decryption SA lookup table */
 	if (prms->pre_sec_in_params.dpa_cls_td < 0) {
-		xx_pr_err(("Specify a valid table for SA lookup\n"));
+		xx_pr_err("Specify a valid table for SA lookup\n");
 		return -EINVAL;
 	}
 
@@ -255,12 +255,12 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	err = dpa_classif_table_get_params(prms->pre_sec_in_params.dpa_cls_td,
 					   &table_params);
 	if (err < 0) {
-		xx_pr_err(("Could not check type of pre decryption table\n"));
+		xx_pr_err("Could not check type of pre decryption table\n");
 		return -EINVAL;
 	}
 
 	if (table_params.type == DPA_CLS_TBL_INDEXED) {
-		xx_pr_err(("Pre decryption table mustn't be of type index\n"));
+		xx_pr_err("Pre decryption table mustn't be of type index\n");
 		return -EINVAL;
 	}
 
@@ -268,7 +268,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	if (prms->pre_sec_out_params.key_fields == 0 ||
 	   (prms->post_sec_in_params.do_pol_check &&
 	    prms->post_sec_in_params.key_fields == 0)) {
-		xx_pr_err(("At least one field must be specified for building policy keys\n"));
+		xx_pr_err("At least one field must be specified for building policy keys\n");
 		return -EINVAL;
 	}
 
@@ -277,7 +277,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	 * for offloading at least one SA pair
 	 */
 	if (prms->max_sa_pairs == 0) {
-		xx_pr_err(("The instance must be configured for offloading at least one SA pair\n"));
+		xx_pr_err("The instance must be configured for offloading at least one SA pair\n");
 		return -EINVAL;
 	}
 
@@ -291,7 +291,7 @@ static int calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 
 	/* sanity checks */
 	if (!key_size) {
-		xx_pr_err(("Invalid argument: NULL key_size parameter\n"));
+		xx_pr_err("Invalid argument: NULL key_size parameter\n");
 		return -EFAULT;
 	}
 
@@ -300,7 +300,7 @@ static int calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 
 	/* more sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
@@ -346,7 +346,7 @@ static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 
 	/* sanity checks */
 	if (!cc_node) {
-		xx_pr_err(("Invalid argument: NULL CC Node handle holder\n"));
+		xx_pr_err("Invalid argument: NULL CC Node handle holder\n");
 		return -EFAULT;
 	}
 
@@ -355,12 +355,12 @@ static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 
 	/* more sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (dpa_ipsec->sa_mng.inpol_key_size == 0) {
-		xx_pr_err(("Invalid argument: in policy table key size\n"));
+		xx_pr_err("Invalid argument: in policy table key size\n");
 		return -EFAULT;
 	}
 
@@ -398,7 +398,7 @@ static inline void destroy_inpol_node(struct dpa_ipsec *dpa_ipsec,
 	fmd_err = FM_PCD_CcDeleteNode(dpa_ipsec->config.fm_pcd, cc_node);
 	if (fmd_err != E_OK) {
 		xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteNode");
-		xx_pr_err(("Could not free policy check CC Node\n"));
+		xx_pr_err("Could not free policy check CC Node\n");
 	}
 }
 
@@ -411,7 +411,7 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 
 	/* sanity checks */
 	if (!td) {
-		xx_pr_err(("Invalid argument: NULL table descriptor holder\n"));
+		xx_pr_err("Invalid argument: NULL table descriptor holder\n");
 		return -EFAULT;
 	}
 
@@ -419,12 +419,12 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 
 	/* more sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!cc_node) {
-		xx_pr_err(("Invalid argument: NULL CC Node handle\n"));
+		xx_pr_err("Invalid argument: NULL CC Node handle\n");
 		return -EFAULT;
 	}
 
@@ -438,7 +438,7 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 	params.cc_node = cc_node;
 	err = dpa_classif_table_create(&params, td);
 	if (err < 0) {
-		xx_pr_err(("Could not create exact match tbl"));
+		xx_pr_err("Could not create exact match tbl");
 		return err;
 	}
 
@@ -452,7 +452,7 @@ static inline void destroy_inpol_cls_tbl(int td)
 	if (td != DPA_CLS_INVALID_TABLE_DESC) {
 		err = dpa_classif_table_free(td);
 		if (err < 0)
-			xx_pr_err(("Could not free EM table\n"));
+			xx_pr_err("Could not free EM table\n");
 	}
 }
 
@@ -460,22 +460,22 @@ static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t *flowid)
 {
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err(("Invalid argument: NULL in policy flow ID CQ\n"));
+		xx_pr_err("Invalid argument: NULL in policy flow ID CQ\n");
 		return -EFAULT;
 	}
 
 	if (!flowid) {
-		xx_pr_err(("Invalid argument: NULL flow ID parameter\n"));
+		xx_pr_err("Invalid argument: NULL flow ID parameter\n");
 		return -EFAULT;
 	}
 
 	if (cq_get_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err(("Could not retrieve a valid inbound flow ID\n"));
+		xx_pr_err("Could not retrieve a valid inbound flow ID\n");
 		return -EDOM;
 	}
 
@@ -486,17 +486,17 @@ static int put_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t flowid)
 {
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err(("Invalid argument: NULL in policy flow ID CQ\n"));
+		xx_pr_err("Invalid argument: NULL in policy flow ID CQ\n");
 		return -EFAULT;
 	}
 
 	if (cq_put_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err(("Could not release inbound flow id\n"));
+		xx_pr_err("Could not release inbound flow id\n");
 		return -EDOM;
 	}
 
@@ -510,14 +510,14 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	cq = cq_new((uint16_t) (dpa_ipsec->sa_mng.max_num_sa / 2),
 		    (uint16_t)sizeof(uint16_t));
 	if (!cq) {
-		xx_pr_err(("Could not create inbound flow ID management CQ\n"));
+		xx_pr_err("Could not create inbound flow ID management CQ\n");
 		return -ENOMEM;
 	}
 
@@ -527,7 +527,7 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa / 2; i++) {
 		err = put_inbound_flowid(dpa_ipsec, (uint16_t) i);
 		if (err < 0) {
-			xx_pr_err(("Couldn't fill flow id management queue\n"));
+			xx_pr_err("Couldn't fill flow id management queue\n");
 			cq_delete(cq);
 			dpa_ipsec->sa_mng.inbound_flowid_cq = NULL;
 			return err;
@@ -551,12 +551,12 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!table_desc) {
-		xx_pr_err(("Invalid argument: in policy table desc holder\n"));
+		xx_pr_err("Invalid argument: in policy table desc holder\n");
 		return -EFAULT;
 	}
 
@@ -569,12 +569,12 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 	if (inpol_tbl->used == FALSE)
 		inpol_tbl->used = TRUE;
 	else {
-		xx_pr_err(("No more free EM tables for inbound policy verification\n"));
+		xx_pr_err("No more free EM tables for inbound policy verification\n");
 		return -ENOMEM;
 	}
 
 	if (inpol_tbl->td < 0) {
-		xx_pr_err(("Invalid table reference\n"));
+		xx_pr_err("Invalid table reference\n");
 		return -EFAULT;
 	}
 
@@ -590,12 +590,12 @@ static int put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (table_desc == DPA_CLS_INVALID_TABLE_DESC) {
-		xx_pr_err(("Invalid argument: in policy table desc holder\n"));
+		xx_pr_err("Invalid argument: in policy table desc holder\n");
 		return -EFAULT;
 	}
 
@@ -606,7 +606,7 @@ static int put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 		break;
 
 	if (inpol_tbl->used == FALSE) {
-		xx_pr_warn(("Exact match table %d is not used\n", table_desc));
+		xx_pr_warn("Exact match table %d is not used\n", table_desc);
 		return 0;
 	} else
 		inpol_tbl->used = FALSE;
@@ -628,7 +628,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
@@ -638,14 +638,14 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	/* create queue that holds free SA IDs */
 	sa_mng->sa_id_cq = cq_new(sa_mng->max_num_sa, (uint16_t) sizeof(int));
 	if (!sa_mng->sa_id_cq) {
-		xx_pr_err(("Could not create SA IDs circular queue\n"));
+		xx_pr_err("Could not create SA IDs circular queue\n");
 		return -ENOMEM;
 	}
 
 	/* fill with ids */
 	for (i = 0; i < sa_mng->max_num_sa; i++) {
 		if (cq_put_4bytes(sa_mng->sa_id_cq, i) < 0) {
-			xx_pr_err(("Could not fill SA ID management CQ\n"));
+			xx_pr_err("Could not fill SA ID management CQ\n");
 			return -EDOM;
 		}
 	}
@@ -653,7 +653,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	/* alloc SA array */
 	sa_mng->sa = xx_malloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
 	if (!sa_mng->sa) {
-		xx_pr_err(("Could not allocate memory for SAs\n"));
+		xx_pr_err("Could not allocate memory for SAs\n");
 		return -ENOMEM;
 	}
 	memset(sa_mng->sa, 0, sa_mng->max_num_sa * sizeof(*sa_mng->sa));
@@ -663,7 +663,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		sa_mng->sa[i].cipher_data.cipher_key =
 						 xx_malloc(MAX_CIPHER_KEY_LEN);
 		if (!sa_mng->sa[i].cipher_data.cipher_key) {
-			xx_pr_err(("Could not allocate memory for cipher key\n"));
+			xx_pr_err("Could not allocate memory for cipher key\n");
 			return -ENOMEM;
 		}
 		memset(sa_mng->sa[i].cipher_data.cipher_key, 0,
@@ -671,27 +671,27 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 		sa_mng->sa[i].auth_data.auth_key = xx_malloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.auth_key) {
-			xx_pr_err(("Could not allocate memory for authentication key\n"));
+			xx_pr_err("Could not allocate memory for authentication key\n");
 			return -ENOMEM;
 		}
 		memset(sa_mng->sa[i].auth_data.auth_key, 0, MAX_AUTH_KEY_LEN);
 
 		sa_mng->sa[i].auth_data.split_key = xx_malloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.split_key) {
-			xx_pr_err(("Could not allocate memory for authentication split key\n"));
+			xx_pr_err("Could not allocate memory for authentication split key\n");
 			return -ENOMEM;
 		}
 		memset(sa_mng->sa[i].auth_data.split_key, 0, MAX_AUTH_KEY_LEN);
 
 		sa_mng->sa[i].from_sec_fq = xx_malloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].from_sec_fq) {
-			xx_pr_err(("Can't allocate space for 'from SEC FQ'\n"));
+			xx_pr_err("Can't allocate space for 'from SEC FQ'\n");
 			return -ENOMEM;
 		}
 
 		sa_mng->sa[i].to_sec_fq = xx_malloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].to_sec_fq) {
-			xx_pr_err(("Can't allocate space for 'to SEC FQ'\n"));
+			xx_pr_err("Can't allocate space for 'to SEC FQ'\n");
 			return -ENOMEM;
 		}
 
@@ -701,7 +701,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		sa_mng->sa[i].sec_desc =
 			xx_malloc_smart(sizeof(struct sec_descriptor), 0, 64);
 		if (!sa_mng->sa[i].sec_desc) {
-			xx_pr_err(("Could not allocate memory for SEC descriptor\n"));
+			xx_pr_err("Could not allocate memory for SEC descriptor\n");
 			return -ENOMEM;
 		}
 		memset(sa_mng->sa[i].sec_desc, 0,
@@ -715,7 +715,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 	err = create_inbound_flowid_cq(dpa_ipsec);
 	if (err < 0) {
-		xx_pr_err(("Could not create inbound policy flow id cq\n"));
+		xx_pr_err("Could not create inbound policy flow id cq\n");
 		return err;
 	}
 
@@ -735,7 +735,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
 			pol_table = xx_malloc(sizeof(*pol_table));
 			if (!pol_table) {
-				xx_pr_err(("Could not allocate memory for policy table"));
+				xx_pr_err("Could not allocate memory for policy table");
 				return -ENOMEM;
 			}
 			memset(pol_table, 0, sizeof(*pol_table));
@@ -743,7 +743,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			/* create cc node for inbound policy */
 			err = create_inpol_node(dpa_ipsec, &cc_node);
 			if (err < 0) {
-				xx_pr_err(("Could not create cc node for EM table\n"));
+				xx_pr_err("Could not create cc node for EM table\n");
 				xx_free(pol_table);
 				return err;
 			}
@@ -753,7 +753,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 						   cc_node,
 						   &pol_table->td);
 			if (err < 0) {
-				xx_pr_err(("Failed create in policy table\n"));
+				xx_pr_err("Failed create in policy table\n");
 				destroy_inpol_node(dpa_ipsec, cc_node);
 				xx_free(pol_table);
 				return err;
@@ -772,7 +772,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	dpa_ipsec->sa_mng.sa_rekeying_wq =
 		create_singlethread_workqueue("sa_rekeying_wq");
 	if (!dpa_ipsec->sa_mng.sa_rekeying_wq) {
-		xx_pr_err(("Creating SA rekeying work queue failed\n"));
+		xx_pr_err("Creating SA rekeying work queue failed\n");
 		return -ENOSPC;
 	}
 
@@ -793,7 +793,7 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return;
 	}
 
@@ -862,7 +862,7 @@ static void free_resources(void)
 
 	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no DPA IPSec instance initialized\n"));
+		xx_pr_err("There is no DPA IPSec instance initialized\n");
 		return;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -887,7 +887,7 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 
 	/* sanity checks */
 	if (!mask) {
-		xx_pr_err(("Invalid argument: NULL mask parameter\n"));
+		xx_pr_err("Invalid argument: NULL mask parameter\n");
 		return -EFAULT;
 	}
 	memset(mask, 0, mask_len);
@@ -912,7 +912,7 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
@@ -928,7 +928,7 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 	err = dpa_classif_table_insert_entry(table, &tbl_key, action, 0,
 					     &sa->inbound_indx_entry);
 	if (err < 0) {
-		xx_pr_err(("Could not set default action for SA id %d\n", id));
+		xx_pr_err("Could not set default action for SA id %d\n", id);
 		return err;
 	}
 
@@ -946,22 +946,22 @@ static int fill_policy_key(int td,
 
 	/* sanity checks */
 	if (!pol_sel) {
-		xx_pr_err(("Invalid argument: NULL policy selectors\n"));
+		xx_pr_err("Invalid argument: NULL policy selectors\n");
 		return -EFAULT;
 	}
 
 	if (!key) {
-		xx_pr_err(("Invalid argument: NULL key container\n"));
+		xx_pr_err("Invalid argument: NULL key container\n");
 		return -EFAULT;
 	}
 
 	if (!mask) {
-		xx_pr_err(("Invalid argument: NULL mask container\n"));
+		xx_pr_err("Invalid argument: NULL mask container\n");
 		return -EFAULT;
 	}
 
 	if (!key_len) {
-		xx_pr_err(("Invalid argument: NULL key_len container\n"));
+		xx_pr_err("Invalid argument: NULL key_len container\n");
 		return -EFAULT;
 	}
 
@@ -1047,13 +1047,13 @@ static int fill_policy_key(int td,
 	/* get table params (including maximum key size) */
 	err = dpa_classif_table_get_params(td, &tbl_params);
 	if (err < 0) {
-		xx_pr_err(("Could not retrieve table maximum key size\n"));
+		xx_pr_err("Could not retrieve table maximum key size\n");
 		return -EINVAL;
 	}
 	tbl_key_size = TABLE_KEY_SIZE(tbl_params);
 
 	if (tbl_key_size < offset) {
-		xx_pr_err(("Policy key is greater than maximum table key size\n"));
+		xx_pr_err("Policy key is greater than maximum table key size\n");
 		return err;
 	}
 
@@ -1099,17 +1099,17 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		xx_pr_err("Invalid argument: NULL policy handle\n");
 		return -EFAULT;
 	}
 
 	if (!hm) {
-		xx_pr_err(("Invalid argument: NULL manip holder\n"));
+		xx_pr_err("Invalid argument: NULL manip holder\n");
 		return -EFAULT;
 	}
 
@@ -1139,12 +1139,12 @@ static int destroy_frag_manip(struct dpa_ipsec *dpa_ipsec,
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!hm) {
-		xx_pr_err(("Invalid argument: NULL header manip handle\n"));
+		xx_pr_err("Invalid argument: NULL header manip handle\n");
 		return -EFAULT;
 	}
 
@@ -1172,17 +1172,17 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		xx_pr_err("Invalid argument: NULL policy handle\n");
 		return -EFAULT;
 	}
 
 	if (sa->em_inpol_td < 0) {
-		xx_pr_err(("Invalid exact match table for SA %d.\n", sa->id));
+		xx_pr_err("Invalid exact match table for SA %d.\n", sa->id);
 		return -EINVAL;
 	}
 
@@ -1212,7 +1212,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_insert_entry(sa->em_inpol_td, &tbl_key,
 						     action, 0, &entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not insert key in EM table\n"));
+			xx_pr_err("Could not insert key in EM table\n");
 			return err;
 		}
 		policy_entry->entry_id = entry_id;
@@ -1222,12 +1222,12 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_delete_entry_by_ref(sa->em_inpol_td,
 							    entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not remove key in EM table\n"));
+			xx_pr_err("Could not remove key in EM table\n");
 			return err;
 		}
 		break;
 	case MNG_OP_MODIFY:
-		xx_pr_err(("Modify operation unsupported for IN Policy PCD\n"));
+		xx_pr_err("Modify operation unsupported for IN Policy PCD\n");
 		return -EINVAL;
 	}
 
@@ -1250,12 +1250,12 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		xx_pr_err("Invalid argument: NULL policy handle\n");
 		return -EFAULT;
 	}
 
@@ -1275,7 +1275,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			table =
 			    pre_sec_out_params->dpa_cls_td[DPA_IPSEC_PROTO_ANY];
 		} else {
-			xx_pr_err(("No suitable table found for this policy type!\n"));
+			xx_pr_err("No suitable table found for this policy type!\n");
 			return -EINVAL;
 		}
 	}
@@ -1301,7 +1301,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		if (policy_entry->mtu) {
 			err = create_frag_manip(dpa_ipsec, policy_entry, &hm);
 			if (err < 0) {
-				xx_pr_err(("Could not create Manip node for fragmentation!\n"));
+				xx_pr_err("Could not create Manip node for fragmentation!\n");
 				return -EAGAIN;
 			}
 		}
@@ -1316,7 +1316,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_insert_entry(table, &tbl_key,
 					   &action, 0, &policy_entry->entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not add key in exact match table\n"));
+			xx_pr_err("Could not add key in exact match table\n");
 			return err;
 		}
 		break;
@@ -1324,14 +1324,14 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_delete_entry_by_ref(table,
 							policy_entry->entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not remove key from EM table\n"));
+			xx_pr_err("Could not remove key from EM table\n");
 			return err;
 		}
 
 		if (policy_entry->hm) {
 			err = destroy_frag_manip(dpa_ipsec, policy_entry->hm);
 			if (err < 0) {
-				xx_pr_err(("Couldn't delete frag manip\n"));
+				xx_pr_err("Couldn't delete frag manip\n");
 				return err;
 			}
 		}
@@ -1351,7 +1351,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 							 policy_entry->entry_id,
 							 &params);
 		if (err < 0) {
-			xx_pr_err(("Could not modify key in EM table\n"));
+			xx_pr_err("Could not modify key in EM table\n");
 			return err;
 		}
 		break;
@@ -1373,7 +1373,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
@@ -1422,13 +1422,13 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		/* determine padding length based on the table params */
 		err = dpa_classif_table_get_params(table, &tbl_params);
 		if (err < 0) {
-			xx_pr_err(("Could not get table maximum key size\n"));
+			xx_pr_err("Could not get table maximum key size\n");
 			return err;
 		}
 		tbl_key_size = TABLE_KEY_SIZE(tbl_params);
 
 		if (tbl_key_size < offset) {
-			xx_pr_err(("SA lookup key is greater than maximum table key size\n"));
+			xx_pr_err("SA lookup key is greater than maximum table key size\n");
 			return err;
 		}
 
@@ -1451,7 +1451,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not add key for inbound SA!\n"));
+			xx_pr_err("Could not add key for inbound SA!\n");
 			return err;
 		}
 		sa->inbound_hash_entry = entry_id;
@@ -1461,14 +1461,14 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		entry_id = sa->inbound_hash_entry;
 		err = dpa_classif_table_delete_entry_by_ref(table, entry_id);
 		if (err < 0) {
-			xx_pr_err(("Could not remove key for inbound SA!\n"));
+			xx_pr_err("Could not remove key for inbound SA!\n");
 			return err;
 		}
 		sa->inbound_hash_entry = -1;
 		break;
 
 	case MNG_OP_MODIFY:
-		xx_pr_err(("Modify operation not supported for IN SA PCD!\n"));
+		xx_pr_err("Modify operation not supported for IN SA PCD!\n");
 		return -EINVAL;
 	}
 
@@ -1481,27 +1481,27 @@ static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!fqid) {
-		xx_pr_err(("Invalid argument: NULL fqid holder\n"));
+		xx_pr_err("Invalid argument: NULL fqid holder\n");
 		return -EFAULT;
 	}
 
 	if (dpa_ipsec->config.fqid_pool != NULL) {
 		err = qman_fqid_pool_alloc(dpa_ipsec->config.fqid_pool, fqid);
 		if (err < 0)
-			xx_pr_err(("FQID allocation (from pool) failure."
-				   "QMan error code %d\n", err));
+			xx_pr_err("FQID allocation (from pool) failure."
+				   "QMan error code %d\n", err);
 		return err;
 	}
 
 	/* No pool defined. Get FQID from default allocator. */
 	*fqid = qm_fq_new();
 	if (*fqid == 0) {
-		xx_pr_err(("FQID allocation (no pool) failure.\n"));
+		xx_pr_err("FQID allocation (no pool) failure.\n");
 		return -ERANGE;
 	}
 
@@ -1515,7 +1515,7 @@ static void put_free_fqid(uint32_t fqid)
 
 	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no DPA IPSec instance initialized\n"));
+		xx_pr_err("There is no DPA IPSec instance initialized\n");
 		return;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -1526,7 +1526,7 @@ static void put_free_fqid(uint32_t fqid)
 	else {
 		err = qm_fq_free_flags(fqid, 0);	/* only warn of error */
 		if (err < 0)
-			xx_pr_warn(("Could not release FQID# %u\n", fqid));
+			xx_pr_warn("Could not release FQID# %u\n", fqid);
 	}
 }
 
@@ -1535,7 +1535,7 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 	struct qm_mcr_queryfq_np queryfq_np;
 
 	if (!fq) {
-		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		xx_pr_err("Invalid argument: NULL fq handle\n");
 		return -EFAULT;
 	}
 
@@ -1547,7 +1547,7 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 	} while (queryfq_np.frm_cnt && timeout);
 
 	if (timeout == 0) {
-		xx_pr_err(("Timeout. Fq with id %d not empty.\n", fq->fqid));
+		xx_pr_err("Timeout. Fq with id %d not empty.\n", fq->fqid);
 		return -EBUSY;
 	}
 
@@ -1560,13 +1560,13 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 
 	/* sanity checks */
 	if (!sec_fq) {
-		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		xx_pr_err("Invalid argument: NULL fq handle\n");
 		return -EFAULT;
 	}
 
 	err = qman_retire_fq(sec_fq, &flags);
 	if (err < 0) {
-		xx_pr_err(("Failed to retire FQ %d\n", sec_fq->fqid));
+		xx_pr_err("Failed to retire FQ %d\n", sec_fq->fqid);
 		return err;
 	}
 
@@ -1576,7 +1576,7 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 
 	err = qman_oos_fq(sec_fq);
 	if (err < 0) {
-		xx_pr_err(("Failed to OOS FQ %d\n", sec_fq->fqid));
+		xx_pr_err("Failed to OOS FQ %d\n", sec_fq->fqid);
 		return err;
 	}
 
@@ -1600,7 +1600,7 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
@@ -1634,7 +1634,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	/* sanity checks */
 	if (!fq) {
-		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		xx_pr_err("Invalid argument: NULL fq handle\n");
 		return -EFAULT;
 	}
 
@@ -1644,7 +1644,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	err = qman_create_fq(fq_id, flags, fq);
 	if (unlikely(err < 0)) {
-		xx_pr_err(("Could not create FQ with ID: %u\n", fq_id));
+		xx_pr_err("Could not create FQ with ID: %u\n", fq_id);
 		goto create_sec_fq_err;
 	}
 
@@ -1681,7 +1681,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	err = qman_init_fq(fq, flags, &fq_opts);
 	if (unlikely(err < 0)) {
-		xx_pr_err(("Could not init FQ with ID: %u\n", fq->fqid));
+		xx_pr_err("Could not init FQ with ID: %u\n", fq->fqid);
 		goto create_sec_fq_err;
 	}
 
@@ -1706,19 +1706,19 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	err = create_sec_descriptor(sa);
 	if (err < 0) {
-		xx_pr_err(("Could not create sec descriptor\n"));
+		xx_pr_err("Could not create sec descriptor\n");
 		return err;
 	}
 
@@ -1752,7 +1752,7 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 					     flow_id, /*ctxB forwarding info*/
 					     FALSE, sa->from_sec_fq);
 		if (err < 0) {
-			xx_pr_err(("From SEC FQ couldn't be created\n"));
+			xx_pr_err("From SEC FQ couldn't be created\n");
 			goto create_fq_pair_err;
 		}
 	}
@@ -1768,9 +1768,9 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 			qman_fq_fqid(sa->from_sec_fq), /*ctxB - output SEC fq*/
 			parked_to_secfq, sa->to_sec_fq);
 	if (err < 0) {
-		xx_pr_err(("%s FQ(to SEC) couldn't be created\n",
+		xx_pr_err("%s FQ(to SEC) couldn't be created\n",
 				(sa->sa_dir == DPA_IPSEC_OUTBOUND) ? "Encrypt" :
-				"Decrypt"));
+				"Decrypt");
 		goto create_fq_pair_err;
 	}
 
@@ -1796,7 +1796,7 @@ static inline int set_cipher_auth_alg(enum dpa_ipsec_cipher_alg alg_suite,
 
 	if (*cipher == OP_PCL_IPSEC_INVALID_ALG_ID ||
 	    *auth == OP_PCL_IPSEC_INVALID_ALG_ID) {
-		xx_pr_err(("Invalid algorithm suite selected\n"));
+		xx_pr_err("Invalid algorithm suite selected\n");
 		return -EINVAL;
 	}
 
@@ -1811,12 +1811,12 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!sa_params) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
@@ -1904,12 +1904,12 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!sa_params) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
@@ -1919,7 +1919,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	if (!rekeying) {
 		err = get_inbound_flowid(dpa_ipsec, &sa->inbound_flowid);
 		if (err < 0) {
-			xx_pr_err(("Can't get valid inbound flow id\n"));
+			xx_pr_err("Can't get valid inbound flow id\n");
 			return -EINVAL;
 		}
 	}
@@ -1975,7 +1975,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ARS64;
 		break;
 	default:
-		xx_pr_err(("Invalid ARS mode specified\n"));
+		xx_pr_err("Invalid ARS mode specified\n");
 		return -EINVAL;
 	}
 
@@ -2028,23 +2028,23 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		xx_pr_err("Invalid argument: NULL policy params handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy entry holder\n"));
+		xx_pr_err("Invalid argument: NULL policy entry holder\n");
 		return -EFAULT;
 	}
 
 	pol_entry = xx_malloc(sizeof(struct dpa_ipsec_policy_entry));
 	if (!pol_entry) {
-		xx_pr_err(("Could not allocate memory for policy\n"));
+		xx_pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
 	}
 	copy_policy_selectors(policy_params, &pol_entry->policy_selectors);
@@ -2067,22 +2067,22 @@ static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		xx_pr_err("Invalid argument: NULL policy params handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy entry holder\n"));
+		xx_pr_err("Invalid argument: NULL policy entry holder\n");
 		return -EFAULT;
 	}
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err(("Policy parameter list is empty\n"));
+		xx_pr_err("Policy parameter list is empty\n");
 		return -EDOM;
 	}
 
@@ -2107,7 +2107,7 @@ static inline int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
 	int pol_count = 0;
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_debug(("Policy parameter list is empty\n"));
+		xx_pr_debug("Policy parameter list is empty\n");
 		return 0;
 	}
 
@@ -2127,17 +2127,17 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		xx_pr_err("Invalid argument: NULL policy params handle\n");
 		return -EFAULT;
 	}
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err(("Policy parameter list is empty\n"));
+		xx_pr_err("Policy parameter list is empty\n");
 		return 0;
 	}
 
@@ -2148,8 +2148,8 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 
 		pol_count++;
 		if (pol_count > num_pol) {
-			xx_pr_err(("Num policies in this SA greater than %d",
-				num_pol));
+			xx_pr_err("Num policies in this SA greater than %d",
+				num_pol);
 			return -EAGAIN;
 		}
 
@@ -2172,17 +2172,17 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 {
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		xx_pr_err("Invalid argument: NULL policy params handle\n");
 		return -EFAULT;
 	}
 
 	if (list_empty(&sa->policy_headlist)) {
-		xx_pr_err(("Policy parameter list is empty\n"));
+		xx_pr_err("Policy parameter list is empty\n");
 		return -EINVAL;
 	}
 
@@ -2199,35 +2199,35 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 
 	/* sanity checks */
 	if (!sa) {
-		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		xx_pr_err("Invalid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 
 	if (!policy_entry) {
-		xx_pr_err(("Invalid argument: NULL policy entry handle\n"));
+		xx_pr_err("Invalid argument: NULL policy entry handle\n");
 		return -EFAULT;
 	}
 
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		err = update_inbound_policy(sa, policy_entry, MNG_OP_REMOVE);
 		if (err < 0) {
-			xx_pr_err(("Could not remove the inbound policy\n"));
+			xx_pr_err("Could not remove the inbound policy\n");
 			return err;
 		}
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
-			xx_pr_err(("Couldn't remove inbound policy from SA policy list\n"));
+			xx_pr_err("Couldn't remove inbound policy from SA policy list\n");
 			return err;
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		err = update_outbound_policy(sa, policy_entry, MNG_OP_REMOVE);
 		if (err < 0) {
-			xx_pr_err(("Could not remove the outbound policy\n"));
+			xx_pr_err("Could not remove the outbound policy\n");
 			return err;
 		}
 		err = remove_policy_from_sa_policy_list(sa, policy_entry);
 		if (err < 0) {
-			xx_pr_err(("Could not remove outbound policy from SA policy list\n"));
+			xx_pr_err("Could not remove outbound policy from SA policy list\n");
 			return err;
 		}
 	}
@@ -2243,7 +2243,7 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 
 	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec component initialized\n"));
+		xx_pr_err("There is no dpa_ipsec component initialized\n");
 		return NULL;
 	}
 
@@ -2251,7 +2251,7 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	sa_mng = &dpa_ipsec->sa_mng;
 
 	if ((sa_id < 0) || (sa_id > sa_mng->max_num_sa)) {
-		xx_pr_err(("Invalid SA id %d provided\n", sa_id));
+		xx_pr_err("Invalid SA id %d provided\n", sa_id);
 		return NULL;
 	}
 	sa = &sa_mng->sa[sa_id];
@@ -2266,7 +2266,7 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 
 	/* sanity checks */
 	if (!sa_params) {
-		xx_pr_err(("Invalid SA parameters handle\n"));
+		xx_pr_err("Invalid SA parameters handle\n");
 		return -EINVAL;
 	}
 
@@ -2282,35 +2282,35 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 		return err;
 
 	if (sa_params->crypto_params.auth_key == NULL) {
-		xx_pr_err(("A valid authentication key must be provided\n"));
+		xx_pr_err("A valid authentication key must be provided\n");
 		return -EINVAL;
 	}
 
 	/* TODO: check cipher_key ONLY if alg != null encryption */
 	if (sa_params->crypto_params.cipher_key == NULL) {
-		xx_pr_err(("A valid cipher key must be provided\n"));
+		xx_pr_err("A valid cipher key must be provided\n");
 		return -EINVAL;
 	}
 
 	if (sa_params->sa_dir == DPA_IPSEC_OUTBOUND) {
 		if ((sa_params->sa_out_params.ip_hdr_size == 0) ||
 		    (sa_params->sa_out_params.outer_ip_header == NULL)) {
-			xx_pr_err(("Transport mode is not currently supported."
-				   "Specify a valid encapsulation header\n"));
+			xx_pr_err("Transport mode is not currently supported."
+				   "Specify a valid encapsulation header\n");
 			return -EINVAL;
 		}
 	} else {
 		/* Inbound SA */
 		if (sa_params->sa_in_params.src_addr.addr_type !=
 		    sa_params->sa_in_params.dest_addr.addr_type) {
-			xx_pr_err(("Source and destination IP address must be of same type\n"));
+			xx_pr_err("Source and destination IP address must be of same type\n");
 			return -EINVAL;
 		}
 	}
 
 	/* check buffer pool ID validity */
 	if (sa_params->sa_bpid > MAX_BUFFER_POOL_ID) {
-		xx_pr_err(("Invalid SA buffer pool ID.\n"));
+		xx_pr_err("Invalid SA buffer pool ID.\n");
 		return -EINVAL;
 	}
 
@@ -2327,24 +2327,24 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 
 	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
 		return -EFAULT;
 	}
 
 	if (!new_sa) {
-		xx_pr_err(("Invalid argument: NULL SA holder\n"));
+		xx_pr_err("Invalid argument: NULL SA holder\n");
 		return -EFAULT;
 	}
 	*new_sa = NULL;
 
 	if (!sa_id) {
-		xx_pr_err(("Invalid argument: NULL ID holder\n"));
+		xx_pr_err("Invalid argument: NULL ID holder\n");
 		return -EFAULT;
 	}
 
 	/* Get an id for new SA */
 	if (cq_get_4bytes(dpa_ipsec->sa_mng.sa_id_cq, &id) < 0) {
-		xx_pr_err(("No more unused SA handles"));
+		xx_pr_err("No more unused SA handles");
 		return -EDOM;
 	}
 
@@ -2352,7 +2352,7 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 		if (dpa_ipsec->used_sa_ids[i] == DPA_IPSEC_INVALID_SA_ID)
 			break;
 	if (i == dpa_ipsec->sa_mng.max_num_sa) {
-		xx_pr_err(("No more used SAs ID holders"));
+		xx_pr_err("No more used SAs ID holders");
 		cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
 		return -EDOM;
 	}
@@ -2386,7 +2386,7 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	dpa_ipsec->num_used_sas--;
 	err = cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
 	if (err < 0) {
-		xx_pr_err(("Could not release the sa id %d\n", sa->id));
+		xx_pr_err("Could not release the sa id %d\n", sa->id);
 		return -EDOM;
 	}
 	sa->used_sa_index = -1;
@@ -2399,7 +2399,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 	struct dpa_ipsec *dpa_ipsec;
 
 	if (!sa) {
-		xx_pr_err(("Inavlid argument: NULL SA handle\n"));
+		xx_pr_err("Inavlid argument: NULL SA handle\n");
 		return -EFAULT;
 	}
 	dpa_ipsec = sa->dpa_ipsec;
@@ -2408,7 +2408,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 	    (sa->inbound_hash_entry != -1)) {
 		err_rb = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 		if (err_rb < 0) {
-			xx_pr_err(("Couln't remove SA lookup table entry\n"));
+			xx_pr_err("Couln't remove SA lookup table entry\n");
 			return err_rb;
 		}
 	}
@@ -2421,7 +2421,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
 				sa->inbound_indx_entry);
 		if (err_rb < 0) {
-			xx_pr_err(("Couldn't remove post decrypt tbl entry\n"));
+			xx_pr_err("Couldn't remove post decrypt tbl entry\n");
 			return err_rb;
 		}
 	}
@@ -2429,7 +2429,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
 
 	err_rb = remove_sa_fq_pair(sa);
 	if (err_rb < 0) {
-		xx_pr_err(("Could not remove SA FQs.\n"));
+		xx_pr_err("Could not remove SA FQs.\n");
 		return err_rb;
 	}
 
@@ -2458,8 +2458,8 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 
 	/* sanity checks */
 	if (gbl_dpa_ipsec) {
-		xx_pr_err(("There is already an initialized dpa_ipsec component.\n"));
-		xx_pr_err(("Multiple DPA IPSec Instances aren't currently supported.\n"));
+		xx_pr_err("There is already an initialized dpa_ipsec component.\n");
+		xx_pr_err("Multiple DPA IPSec Instances aren't currently supported.\n");
 		return -EPERM;
 	}
 
@@ -2471,7 +2471,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	/* alloc control block */
 	dpa_ipsec = (struct dpa_ipsec *)xx_malloc(sizeof(struct dpa_ipsec));
 	if (!dpa_ipsec) {
-		xx_pr_err(("Could not allocate memory for control block.\n"));
+		xx_pr_err("Could not allocate memory for control block.\n");
 		return -ENOMEM;
 	}
 	memset(dpa_ipsec, 0, sizeof(struct dpa_ipsec));
@@ -2490,7 +2490,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	max_num_sa = dpa_ipsec->sa_mng.max_num_sa;
 	dpa_ipsec->used_sa_ids = xx_malloc(max_num_sa * sizeof(uint32_t));
 	if (!dpa_ipsec->used_sa_ids) {
-		xx_pr_err(("No more memory for used sa id's vector "));
+		xx_pr_err("No more memory for used sa id's vector ");
 		free_resources();
 		return -ENOMEM;
 	}
@@ -2514,7 +2514,7 @@ int dpa_ipsec_free(int dpa_ipsec_id)
 	/* destroy all SAs offloaded in this DPA IPSec instance */
 	err = dpa_ipsec_flush_all_sa(0);
 	if (err < 0) {
-		xx_pr_err(("Could not remove all SAs from this instance!\n"));
+		xx_pr_err("Could not remove all SAs from this instance!\n");
 		return err;
 	}
 
@@ -2536,12 +2536,12 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	unused(dpa_ipsec_id);
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec component initialized\n"));
+		xx_pr_err("There is no dpa_ipsec component initialized\n");
 		return -EPERM;
 	}
 
 	if (!sa_id) {
-		xx_pr_err(("Invalid SA ID holder\n"));
+		xx_pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
 	*sa_id = DPA_IPSEC_INVALID_SA_ID;
@@ -2554,7 +2554,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 	err = get_new_sa(dpa_ipsec, &sa, &id);
 	if (err < 0) {
-		xx_pr_err(("Failed retrieveing a preallocated SA\n"));
+		xx_pr_err("Failed retrieveing a preallocated SA\n");
 		return err;
 	}
 
@@ -2572,7 +2572,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	}
 
 	if (err < 0) {
-		xx_pr_err(("Could not copy SA parameters into SA\n"));
+		xx_pr_err("Could not copy SA parameters into SA\n");
 		goto create_sa_err;
 	}
 
@@ -2584,7 +2584,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	/* Call internal function to create SEC FQ according to SA parameters */
 	err = create_sa_fq_pair(sa, FALSE, FALSE);
 	if (err < 0) {
-		xx_pr_err(("Could not create SEC frame queues\n"));
+		xx_pr_err("Could not create SEC frame queues\n");
 		goto create_sa_err;
 	}
 
@@ -2597,7 +2597,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		 *  PCD of the Rx Port */
 		err = update_pre_sec_inbound_table(sa, MNG_OP_ADD);
 		if (err < 0) {
-			xx_pr_err(("Could not update PCD entry\n"));
+			xx_pr_err("Could not update PCD entry\n");
 			goto create_sa_err;
 		}
 
@@ -2609,7 +2609,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 			err = get_free_inbpol_tbl(dpa_ipsec, &inbpol_td);
 			if (err < 0) {
-				xx_pr_err(("Could not get a free EM table\n"));
+				xx_pr_err("Could not get a free EM table\n");
 				goto create_sa_err;
 			}
 			sa->em_inpol_td = inbpol_td;
@@ -2630,7 +2630,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 						&action, 0,
 						&sa->inbound_indx_entry);
 			if (err < 0) {
-				xx_pr_err(("Can't link EM table with index table\n"));
+				xx_pr_err("Can't link EM table with index table\n");
 				goto create_sa_err;
 			}
 
@@ -2641,14 +2641,14 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			err = dpa_classif_table_modify_miss_action(inbpol_td,
 								 &miss_action);
 			if (err < 0) {
-				xx_pr_err(("Can't set policy miss action\n"));
+				xx_pr_err("Can't set policy miss action\n");
 				goto create_sa_err;
 			}
 		} else {
 			/* Set the post decryption default action */
 			err = set_in_sa_default_action(sa);
 			if (err < 0) {
-				xx_pr_err(("Could not set default action for post decryption\n"));
+				xx_pr_err("Could not set default action for post decryption\n");
 				goto create_sa_err;
 			}
 		}
@@ -2698,7 +2698,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 	int err = 0;
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
+		xx_pr_err("There is no dpa_ipsec instance initialized\n");
 		return -EPERM;
 	}
 
@@ -2707,7 +2707,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err(("Invalid SA handle for sa id %d\n", sa_id));
+		xx_pr_err("Invalid SA handle for sa id %d\n", sa_id);
 		return -EINVAL;
 	}
 
@@ -2720,7 +2720,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 		if (sa->inbound_hash_entry != -1) {
 			err = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 			if (err < 0) {
-				xx_pr_err(("Could not remove the PCD entry for this SA\n"));
+				xx_pr_err("Could not remove the PCD entry for this SA\n");
 				return err;
 			}
 		}
@@ -2728,7 +2728,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 		/* Destroy the TO_SEC and FROM_SEC queues */
 		err = remove_sa_fq_pair(sa);
 		if (err != 0) {
-			xx_pr_err(("Could not remove the SEC frame queues\n"));
+			xx_pr_err("Could not remove the SEC frame queues\n");
 			return err;
 		}
 
@@ -2736,7 +2736,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 		if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
 			err = dpa_ipsec_sa_flush_policies(sa->id);
 			if (err < 0) {
-				xx_pr_err(("Couldn't flush inbound policies"));
+				xx_pr_err("Couldn't flush inbound policies");
 				return err;
 			}
 		}
@@ -2748,7 +2748,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 			err = dpa_classif_table_delete_entry_by_ref(td,
 							sa->inbound_indx_entry);
 			if (err < 0) {
-				xx_pr_err(("Could not remove SA entry in indexed table\n"));
+				xx_pr_err("Could not remove SA entry in indexed table\n");
 				return err;
 			}
 			if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
@@ -2760,8 +2760,8 @@ int dpa_ipsec_remove_sa(int sa_id)
 		/* Mark SA as free */
 		err = put_sa(sa);
 		if (err < 0) {
-			xx_pr_err(("Could not recycle the sa with id %d\n",
-				  sa->id));
+			xx_pr_err("Could not recycle the sa with id %d\n",
+				  sa->id);
 			return err;
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
@@ -2769,22 +2769,22 @@ int dpa_ipsec_remove_sa(int sa_id)
 		 * traffic to SEC */
 		err = dpa_ipsec_sa_flush_policies(sa->id);
 		if (err < 0) {
-			xx_pr_err(("Could not flush outbound policies\n"));
+			xx_pr_err("Could not flush outbound policies\n");
 			return err;
 		}
 
 		/* Destroy the TO_SEC and FROM_SEC queues */
 		err = remove_sa_fq_pair(sa);
 		if (err < 0) {
-			xx_pr_err(("Could not remove the SEC frame queues\n"));
+			xx_pr_err("Could not remove the SEC frame queues\n");
 			return err;
 		}
 
 		/* Mark SA as free */
 		err = put_sa(sa);
 		if (err < 0) {
-			xx_pr_err(("Could not recycle the sa with id %d\n",
-				  sa->id));
+			xx_pr_err("Could not recycle the sa with id %d\n",
+				  sa->id);
 			return err;
 		}
 	}
@@ -2801,13 +2801,13 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	int err;
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid policy params handle\n"));
+		xx_pr_err("Invalid policy params handle\n");
 		return -EINVAL;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err(("Invalid SA handle\n"));
+		xx_pr_err("Invalid SA handle\n");
 		return -EINVAL;
 	}
 
@@ -2818,7 +2818,7 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	err = store_policy_param_to_sa_pol_list(sa, policy_params,
 				&policy_entry);
 	if (err < 0) {
-		xx_pr_err(("Could not store the policy in the SA\n"));
+		xx_pr_err("Could not store the policy in the SA\n");
 		return err;
 	}
 
@@ -2827,14 +2827,14 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		err = update_inbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (err < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
-			xx_pr_err(("Could not add the inbound policy\n"));
+			xx_pr_err("Could not add the inbound policy\n");
 			xx_free(policy_entry);
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		err = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (err < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
-			xx_pr_err(("Could not add the outbound policy\n"));
+			xx_pr_err("Could not add the outbound policy\n");
 			xx_free(policy_entry);
 		}
 	}
@@ -2851,19 +2851,19 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 	int err = 0;
 
 	if (!policy_params) {
-		xx_pr_err(("Invalid policy parameters handle\n"));
+		xx_pr_err("Invalid policy parameters handle\n");
 		return -EINVAL;
 	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err(("Invalid SA handle provided\n"));
+		xx_pr_err("Invalid SA handle provided\n");
 		return -EINVAL;
 	}
 
 	err = find_policy_in_sa_policy_list(sa, policy_params, &policy_entry);
 	if (err < 0) {
-		xx_pr_err(("Could not find policy entry in SA policy list\n"));
+		xx_pr_err("Could not find policy entry in SA policy list\n");
 		return err;
 	}
 
@@ -2893,13 +2893,13 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	unused(auto_rmv_old_sa);
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
+		xx_pr_err("There is no dpa_ipsec instance initialized\n");
 		return -EINVAL;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
 	if (!new_sa_id) {
-		xx_pr_err(("Invalid SA ID holder\n"));
+		xx_pr_err("Invalid SA ID holder\n");
 		return -EINVAL;
 	}
 	*new_sa_id = DPA_IPSEC_INVALID_SA_ID;
@@ -2910,7 +2910,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	old_sa = get_sa_from_sa_id(sa_id);
 	if (!old_sa) {
-		xx_pr_err(("Invalid SA handle provided\n"));
+		xx_pr_err("Invalid SA handle provided\n");
 		return -EINVAL;
 	}
 
@@ -2918,7 +2918,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	err = get_new_sa(dpa_ipsec, &new_sa, &id);
 	if (err < 0) {
-		xx_pr_err(("Failed retrieveing a preallocated SA\n"));
+		xx_pr_err("Failed retrieveing a preallocated SA\n");
 		return err;
 	}
 
@@ -2937,7 +2937,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	}
 
 	if (err < 0) {
-		xx_pr_err(("Could not copy SA parameters into SA\n"));
+		xx_pr_err("Could not copy SA parameters into SA\n");
 		goto rekey_sa_err;
 	}
 
@@ -2958,7 +2958,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	 * parameters */
 	err = create_sa_fq_pair(new_sa, TRUE, TRUE);
 	if (err < 0) {
-		xx_pr_err(("Could not create SEC frame queues\n"));
+		xx_pr_err("Could not create SEC frame queues\n");
 		goto rekey_sa_err;
 	}
 
@@ -2982,7 +2982,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 				/* Keep both SAs. Both must be removed
 				 * using remove_sa */
 				*new_sa_id = id;
-				xx_pr_err(("Could't modify outbound policy"));
+				xx_pr_err("Could't modify outbound policy");
 				goto rekey_sa_err;
 			}
 		}
@@ -3011,7 +3011,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		/* Need to update the IN SA PCD entry */
 		err = update_pre_sec_inbound_table(new_sa, MNG_OP_ADD);
 		if (err < 0) {
-			xx_pr_err(("Could not add PCD entry for new SA\n"));
+			xx_pr_err("Could not add PCD entry for new SA\n");
 			goto rekey_sa_err;
 		}
 
@@ -3073,12 +3073,12 @@ void sa_rekeying_work_func(struct work_struct *work)
 				err = update_pre_sec_inbound_table(old_sa,
 								 MNG_OP_REMOVE);
 				if (err < 0) {
-					xx_pr_err(("Could not remove PCD entry for SA\n"));
+					xx_pr_err("Could not remove PCD entry for SA\n");
 					/*Remove the new SA from rekeying list*/
 					list_del(&new_sa->sa_rekeying_node);
 					err = dpa_ipsec_remove_sa(new_sa->id);
 					if (err < 0)
-						xx_pr_err(("Could not remove new sa\n"));
+						xx_pr_err("Could not remove new sa\n");
 					continue;
 				}
 			}
@@ -3106,7 +3106,7 @@ void sa_rekeying_work_func(struct work_struct *work)
 			/* Free the old SA structure and all its resources */
 			err = remove_sa_sec_fq(old_sa->to_sec_fq);
 			if (err < 0) {
-				xx_pr_err(("Could not remove SA FQ pair during rekeying!\n"));
+				xx_pr_err("Could not remove SA FQ pair during rekeying!\n");
 				/* TODO: add this SA to garbage collector */
 				/*Remove the new SA from rekeying list*/
 				list_del(&new_sa->sa_rekeying_node);
@@ -3155,7 +3155,7 @@ void sa_rekeying_work_func(struct work_struct *work)
 
 int dpa_ipsec_disable_sa(int sa_id)
 {
-	xx_pr_err(("This function is currently not supported\n"));
+	xx_pr_err("This function is currently not supported\n");
 	return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(dpa_ipsec_disable_sa);
@@ -3171,7 +3171,7 @@ int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 	unused(dpa_ipsec_id);
 
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec component initialized\n"));
+		xx_pr_err("There is no dpa_ipsec component initialized\n");
 		return -EPERM;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -3186,7 +3186,7 @@ int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 		if (sa_id != DPA_IPSEC_INVALID_SA_ID) {
 			err = dpa_ipsec_remove_sa(sa_id);
 			if (err < 0) {
-				xx_pr_err(("Could not remove SA %d\n", sa_id));
+				xx_pr_err("Could not remove SA %d\n", sa_id);
 				return err;
 			}
 		}
@@ -3204,7 +3204,7 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 	int err;
 
 	if (sa_id < 0) {
-		xx_pr_err(("Invalid SA id"));
+		xx_pr_err("Invalid SA id");
 		return -EINVAL;
 	}
 
@@ -3215,7 +3215,7 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 	}
 
 	if (!num_pol) {
-		xx_pr_err(("Invalid num_pol parameter handle\n"));
+		xx_pr_err("Invalid num_pol parameter handle\n");
 		return -EINVAL;
 	}
 
@@ -3241,7 +3241,7 @@ int dpa_ipsec_sa_flush_policies(int sa_id)
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
-		xx_pr_err(("Invalid SA handle for sa id %d\n", sa_id));
+		xx_pr_err("Invalid SA handle for sa id %d\n", sa_id);
 		return -EINVAL;
 	}
 
@@ -3249,7 +3249,7 @@ int dpa_ipsec_sa_flush_policies(int sa_id)
 				 node) {
 		err = remove_policy(sa, pol_entr);
 		if (err < 0) {
-			xx_pr_err(("Couldn't remove policy entry"));
+			xx_pr_err("Couldn't remove policy entry");
 			return err;
 		}
 	}
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index c46fc37..375eeb7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -59,37 +59,37 @@ static struct device *get_jrdev(void)
 
 	sec_jr_node = of_find_matching_node(NULL, &sec_jr_match[0]);
 	if (sec_jr_node == NULL) {
-		xx_pr_err(("Couln't find the device_node SEC job-ring, check the device tree\n"));
+		xx_pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
 		return NULL;
 	}
 
 	sec_of_jr_dev = of_find_device_by_node(sec_jr_node);
 	if (sec_of_jr_dev == NULL) {
-		xx_pr_err(("SEC job-ring of_device null\n"));
+		xx_pr_err("SEC job-ring of_device null\n");
 		return NULL;
 	}
 
 	sec_jr_dev = &sec_of_jr_dev->dev;
 	if (sec_jr_dev == NULL) {
-		xx_pr_err(("SEC Job Ring Device is null\n"));
+		xx_pr_err("SEC Job Ring Device is null\n");
 		return NULL;
 	}
 
 	sec_jr_node = of_find_matching_node(sec_jr_node, &sec_jr_match[0]);
 	if (sec_jr_node == NULL) {
-		xx_pr_err(("Couln't find the device_node SEC job-ring, check the device tree\n"));
+		xx_pr_err("Couln't find the device_node SEC job-ring, check the device tree\n");
 		return NULL;
 	}
 
 	sec_of_jr_dev = of_find_device_by_node(sec_jr_node);
 	if (sec_of_jr_dev == NULL) {
-		xx_pr_err((KERN_ERR "SEC job-ring of_device null\n"));
+		xx_pr_err(KERN_ERR "SEC job-ring of_device null\n");
 		return NULL;
 	}
 
 	sec_jr_dev = &sec_of_jr_dev->dev;
 	if (sec_jr_dev == NULL) {
-		xx_pr_err((KERN_ERR "SEC Job Ring Device is null\n"));
+		xx_pr_err(KERN_ERR "SEC Job Ring Device is null\n");
 		return NULL;
 	}
 
@@ -174,7 +174,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 	/* get the jr device  */
 	jrdev = get_jrdev();
 	if (!jrdev) {
-		xx_pr_err(("Failed to get the job ring devic, check the dts\n"));
+		xx_pr_err("Failed to get the job ring devic, check the dts\n");
 		return -EINVAL;
 	}
 
@@ -182,7 +182,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 				      sa->auth_data.split_key_pad_len,
 				      DMA_TO_DEVICE);
 	if (!auth_key_dma) {
-		xx_pr_err(("Could not DMA map authentication key\n"));
+		xx_pr_err("Could not DMA map authentication key\n");
 		return -EINVAL;
 	}
 
@@ -190,7 +190,7 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 					sa->cipher_data.cipher_key_len,
 					DMA_TO_DEVICE);
 	if (!crypto_key_dma) {
-		xx_pr_err(("Could not DMA map cipher key\n"));
+		xx_pr_err("Could not DMA map cipher key\n");
 		return -EINVAL;
 	}
 
@@ -237,13 +237,13 @@ int generate_split_key(struct auth_params *auth_param)
 
 	jrdev = get_jrdev();
 	if (!jrdev) {
-		xx_pr_err(("Could not get job ring device, please check dts\n"));
+		xx_pr_err("Could not get job ring device, please check dts\n");
 		return -ENODEV;
 	}
 
 	desc = kmalloc(CAAM_CMD_SZ * 6 + CAAM_PTR_SZ * 2, GFP_KERNEL | GFP_DMA);
 	if (!desc) {
-		xx_pr_err(("Allocate memory failed for split key desc\n"));
+		xx_pr_err("Allocate memory failed for split key desc\n");
 		return -ENOMEM;
 	}
 
@@ -300,7 +300,7 @@ int generate_split_key(struct auth_params *auth_param)
 	}
 
 	if (timeout == 0)
-		xx_pr_err(("Timeout waiting for job ring to complete\n"));
+		xx_pr_err("Timeout waiting for job ring to complete\n");
 
 	dma_unmap_single(jrdev, dma_addr_out, auth_param->split_key_pad_len,
 			 DMA_FROM_DEVICE);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index be3afa6..40408e6 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -68,7 +68,7 @@ int	wrp_dpa_classif_init(void)
 					WRP_DPA_CLS_CDEVNAME,
 					&dpa_classif_fops);
 	if (dpa_cls_cdev_major < 0) {
-		xx_pr_err(("Could not register DPA Classifier Control Device."));
+		xx_pr_err("Could not register DPA Classifier Control Device.");
 		return -EBUSY;
 	}
 
@@ -140,7 +140,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				   (struct ioc_dpa_cls_tbl_params *) args,
 				   sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_create user space args"));
+			xx_pr_err("Could not read dpa_classif_table_create user space args");
 			return -EBUSY;
 		}
 
@@ -156,7 +156,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_create result"));
+			xx_pr_err("Could not write dpa_classif_table_create result");
 			return -EBUSY;
 		}
 
@@ -175,7 +175,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				   (struct ioc_dpa_cls_tbl_miss_action *) args,
 				    sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_modify_miss_action user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_modify_miss_action user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -194,7 +194,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				   (struct ioc_dpa_cls_tbl_entry_params *) args,
 				    sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_insert_entry user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_insert_entry user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -209,7 +209,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_insert_entry result"));
+			xx_pr_err("Could not write dpa_classif_table_insert_entry result");
 			return -EBUSY;
 		}
 
@@ -224,7 +224,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			      (struct ioc_dpa_cls_tbl_entry_mod_by_key *) args,
 			       sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -244,7 +244,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			(struct ioc_dpa_cls_tbl_entry_mod_by_ref *) args,
 			sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_modify_entry_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -264,7 +264,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			(struct ioc_dpa_cls_tbl_entry_del_by_key *) args,
 			sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_key user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -284,7 +284,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			(struct ioc_dpa_cls_tbl_entry_del_by_ref *) args,
 			sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_ref user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_delete_entry_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -303,7 +303,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				(struct ioc_dpa_cls_tbl_lookup_by_key *) args,
 				sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_lookup_by_key user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -316,7 +316,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_lookup_by_key result"));
+			xx_pr_err("Could not write dpa_classif_table_lookup_by_key result");
 			return -EBUSY;
 		}
 
@@ -332,7 +332,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				(struct ioc_dpa_cls_tbl_lookup_by_ref *) args,
 				sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_lookup_by_ref user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_lookup_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -345,7 +345,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_lookup_by_ref result"));
+			xx_pr_err("Could not write dpa_classif_table_lookup_by_ref result");
 			return -EBUSY;
 		}
 
@@ -365,7 +365,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			(struct ioc_dpa_cls_tbl_entry_stats_by_key *) args,
 			sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -378,7 +378,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_get_entry_stats_by_key result"));
+			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_key result");
 			return -EBUSY;
 		}
 
@@ -394,7 +394,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 			(struct ioc_dpa_cls_tbl_entry_stats_by_ref *) args,
 			sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -407,7 +407,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_get_entry_stats_by_ref result"));
+			xx_pr_err("Could not write dpa_classif_table_get_entry_stats_by_ref result");
 			return -EBUSY;
 		}
 
@@ -423,7 +423,7 @@ long wrp_dpa_classif_ioctl(
 		if (copy_from_user(&prm,
 				   (struct ioc_dpa_cls_tbl_params *) args,
 				   sizeof(prm))) {
-			xx_pr_err(("Could not read dpa_classif_table_lookup_by_key user space args (#1)"));
+			xx_pr_err("Could not read dpa_classif_table_lookup_by_key user space args (#1)");
 			return -EBUSY;
 		}
 
@@ -434,7 +434,7 @@ long wrp_dpa_classif_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &prm, sizeof(prm))) {
-			xx_pr_err(("Could not write dpa_classif_table_get_params result"));
+			xx_pr_err("Could not write dpa_classif_table_get_params result");
 			return -EBUSY;
 		}
 
@@ -442,8 +442,8 @@ long wrp_dpa_classif_ioctl(
 	}
 
 	default:
-		xx_pr_err(("DPA Classifier ioctl command (%u) not suppoted",
-			cmd));
+		xx_pr_err("DPA Classifier ioctl command (%u) not suppoted",
+			cmd);
 		return -EINVAL;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 0ed11b7..3d25d6e 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -62,7 +62,7 @@ int wrp_dpa_ipsec_init(void)
 	dpa_ipsec_cdev_major =
 	    register_chrdev(0, DPA_IPSEC_CDEV, &dpa_ipsec_fops);
 	if (dpa_ipsec_cdev_major < 0) {
-		xx_pr_err(("Could not register Dpa Ipsec character device"));
+		xx_pr_err("Could not register Dpa Ipsec character device");
 		return dpa_ipsec_cdev_major;
 	}
 	return 0;
@@ -103,7 +103,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			if (copy_from_user(&prm,
 					   (struct ioc_dpa_ipsec_params *) args,
 					    sizeof(prm))) {
-				xx_pr_err(("Could not copy parameters "));
+				xx_pr_err("Could not copy parameters ");
 				return -EINVAL;
 			}
 			err = dpa_ipsec_init(&prm.dpa_ipsec_params,
@@ -112,7 +112,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 				return err;
 
 			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-				xx_pr_err(("Could not copy to user the SA id"));
+				xx_pr_err("Could not copy to user the SA id");
 				return -EINVAL;
 			}
 			break;
@@ -122,7 +122,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			int dpa_ipsec_id;
 			if (copy_from_user(&dpa_ipsec_id, (int *)args,
 					    sizeof(int))) {
-				xx_pr_err(("Could not copy parameters"));
+				xx_pr_err("Could not copy parameters");
 				return -EINVAL;
 			}
 			err = dpa_ipsec_free(dpa_ipsec_id);
@@ -136,7 +136,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			if (copy_from_user(&prm,
 					(struct ioc_dpa_ipsec_sa_params *) args,
 					 sizeof(prm))) {
-				xx_pr_err(("Could not copy parameters"));
+				xx_pr_err("Could not copy parameters");
 				return -EINVAL;
 			}
 			err = dpa_ipsec_create_sa(prm.dpa_ipsec_id,
@@ -146,7 +146,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 				return err;
 
 			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-				xx_pr_err(("Could not copy to user the SA id"));
+				xx_pr_err("Could not copy to user the SA id");
 				return -EINVAL;
 			}
 			break;
@@ -155,7 +155,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 	case DPA_IPSEC_IOC_REMOVE_SA: {
 			int sa_id;
 			if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-				xx_pr_err(("Could not copy parameters"));
+				xx_pr_err("Could not copy parameters");
 				return -EINVAL;
 			}
 
@@ -170,7 +170,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			if (copy_from_user(&pol,
 				   (struct ioc_dpa_ipsec_add_rem_policy *) args,
 				    sizeof(pol))) {
-				xx_pr_err(("Could not copy parameters"));
+				xx_pr_err("Could not copy parameters");
 				return -EINVAL;
 			}
 			err = dpa_ipsec_sa_add_policy(pol.sa_id,
@@ -184,7 +184,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			if (copy_from_user(&pol,
 				   (struct ioc_dpa_ipsec_add_rem_policy *) args,
 				    sizeof(pol))) {
-				xx_pr_err(("Could not copy parameters\n"));
+				xx_pr_err("Could not copy parameters\n");
 				return -EINVAL;
 			}
 
@@ -201,7 +201,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			if (copy_from_user(&prm,
 				  (struct ioc_dpa_ipsec_sa_rekeying_prm *) args,
 				   sizeof(prm))) {
-				xx_pr_err(("Could not copy parameters for rekeying"));
+				xx_pr_err("Could not copy parameters for rekeying");
 				return -EINVAL;
 			}
 
@@ -212,7 +212,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 				return err;
 
 			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-				xx_pr_err(("Could not copy to user the SA id"));
+				xx_pr_err("Could not copy to user the SA id");
 				return -EINVAL;
 			}
 			break;
@@ -223,7 +223,7 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 
 			if (copy_from_user(&dpa_ipsec_id,
 					    (int *)args, sizeof(int))) {
-				xx_pr_err(("Could not copy parameters"));
+				xx_pr_err("Could not copy parameters");
 				return -EINVAL;
 			}
 
@@ -239,26 +239,26 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 
 			in_prm = (struct ioc_dpa_ipsec_sa_get_policies *) args;
 			if (in_prm->sa_id < 0) {
-				xx_pr_err(("Invalid input sa id\n"));
+				xx_pr_err("Invalid input sa id\n");
 				return -EINVAL;
 			}
 
 			if (!in_prm->policy_params) {
 				if (!in_prm->num_pol) {
-					xx_pr_err(("Invalid parameters\n"));
+					xx_pr_err("Invalid parameters\n");
 					return -EINVAL;
 				} else {
 					sa_id = in_prm->sa_id;
 					err = dpa_ipsec_sa_get_policies(sa_id,
 								NULL, &num_pol);
 					if (err < 0) {
-						xx_pr_err(("sa get policy count failed\n"));
+						xx_pr_err("sa get policy count failed\n");
 						return err;
 					}
 					if (copy_to_user(in_prm->num_pol,
 							 &num_pol,
 							 sizeof(int))) {
-						xx_pr_err(("Could not copy parameters\n"));
+						xx_pr_err("Could not copy parameters\n");
 						return -EINVAL;
 					}
 					return 0;
@@ -268,18 +268,18 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			sa_id = in_prm->sa_id;
 			if (copy_from_user(&num_pol,
 					   in_prm->num_pol, sizeof(int))) {
-				xx_pr_err(("Could not copy user parameters\n"));
+				xx_pr_err("Could not copy user parameters\n");
 				return -EINVAL;
 			}
 			if (num_pol <= 0) {
-				xx_pr_err(("Invalid number of policies for sa id %d\n", sa_id));
+				xx_pr_err("Invalid number of policies for sa id %d\n", sa_id);
 				return -EINVAL;
 			}
 
 			prm.policy_params =
 				xx_malloc(num_pol * sizeof(*prm.policy_params));
 			if (!prm.policy_params) {
-				xx_pr_err(("No more memory"));
+				xx_pr_err("No more memory");
 				return -ENOMEM;
 			}
 			memset(prm.policy_params, 0,
@@ -289,21 +289,21 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 							prm.policy_params,
 							&num_pol);
 			if (err < 0) {
-				xx_pr_err(("Store policy failed"));
+				xx_pr_err("Store policy failed");
 				return err;
 			}
 
 			if (copy_to_user(in_prm->policy_params,
 					prm.policy_params,
 					num_pol * sizeof(*prm.policy_params))) {
-				xx_pr_err(("Could not copy parameters\n"));
+				xx_pr_err("Could not copy parameters\n");
 				return -EINVAL;
 			}
 			kfree(prm.policy_params);
 			break;
 		}
 	default:
-		xx_pr_err(("Invalid DPA IPsec ioctl\n"));
+		xx_pr_err("Invalid DPA IPsec ioctl\n");
 		break;
 	}
 	return ret;
-- 
1.7.5.4

