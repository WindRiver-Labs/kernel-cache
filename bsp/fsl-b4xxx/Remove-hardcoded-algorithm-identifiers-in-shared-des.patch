From 635a5dc4e59cd855710c2ac676e01eab630ef528 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 17 May 2012 20:36:42 +0000
Subject: [PATCH 153/518] Remove hardcoded algorithm identifiers in shared
 descriptor configuration and split key generation
 code.

Before this patch split key generation and encryption and
authentication algorithm configuration in the shared descriptor
was based on hardcoded algorithm identifiers. These changes allow
configuration based on provided parameters.

Signed-off-by: Ion Grigore <ion.grigore@freescale.com>
Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |   85 ++++++++++++++++++----
 1 files changed, 70 insertions(+), 15 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 0799dad..8ef900c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -120,9 +120,15 @@ int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 	key_jump_cmd = append_jump(desc, CLASS_BOTH | JUMP_TEST_ALL |
 				   JUMP_COND_SHRD | JUMP_COND_SELF);
 
-	/* Append split authentication key */
-	append_key(desc, auth_key_dma, sa->auth_data.split_key_len,
-		   CLASS_2 | KEY_ENC | KEY_DEST_MDHA_SPLIT);
+	/* check whether a split of a normal key is used */
+	if (sa->auth_data.split_key_len)
+		/* Append split authentication key */
+		append_key(desc, auth_key_dma, sa->auth_data.split_key_len,
+			   CLASS_2 | KEY_ENC | KEY_DEST_MDHA_SPLIT);
+	else
+		/* Append normal authentication key */
+		append_key(desc, auth_key_dma, sa->auth_data.auth_key_len,
+			   CLASS_2 | KEY_DEST_CLASS_REG);
 
 	/* Append cipher key */
 	append_key(desc, crypto_key_dma, sa->cipher_data.cipher_key_len,
@@ -170,9 +176,15 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 		return -EINVAL;
 	}
 
-	auth_key_dma = dma_map_single(jrdev, sa->auth_data.split_key,
-				      sa->auth_data.split_key_pad_len,
-				      DMA_TO_DEVICE);
+	/* check whether a split of a normal key is used */
+	if (sa->auth_data.split_key_len)
+		auth_key_dma = dma_map_single(jrdev, sa->auth_data.split_key,
+					      sa->auth_data.split_key_pad_len,
+					      DMA_TO_DEVICE);
+	else
+		auth_key_dma = dma_map_single(jrdev, sa->auth_data.auth_key,
+					      sa->auth_data.auth_key_len,
+					      DMA_TO_DEVICE);
 	if (!auth_key_dma) {
 		xx_pr_err("Could not DMA map authentication key\n");
 		return -EINVAL;
@@ -218,16 +230,62 @@ static void split_key_done(struct device *dev, u32 * desc, u32 err,
 	atomic_set(done, 1);
 }
 
-/******************************************************************************/
+/* determine the HASH algorithm and the coresponding split key length */
+int get_split_key_info(struct auth_params *auth_param, u32 *hmac_alg)
+{
+	/*
+	 * Sizes for MDHA pads (*not* keys): MD5, SHA1, 224, 256, 384, 512
+	 * Running digest size
+	 */
+	const u8 mdpadlen[] = {16, 20, 32, 32, 64, 64};
+
+	switch (auth_param->auth_type) {
+	case OP_PCL_IPSEC_HMAC_MD5_96:
+	case OP_PCL_IPSEC_HMAC_MD5_128:
+		*hmac_alg = OP_ALG_ALGSEL_MD5;
+		break;
+	case OP_PCL_IPSEC_HMAC_SHA1_96:
+	case OP_PCL_IPSEC_HMAC_SHA1_160:
+		*hmac_alg = OP_ALG_ALGSEL_SHA1;
+		break;
+	case OP_PCL_IPSEC_HMAC_SHA2_256_128:
+		*hmac_alg = OP_ALG_ALGSEL_SHA256;
+		break;
+	case OP_PCL_IPSEC_HMAC_SHA2_384_192:
+		*hmac_alg = OP_ALG_ALGSEL_SHA384;
+		break;
+	case OP_PCL_IPSEC_HMAC_SHA2_512_256:
+		*hmac_alg = OP_ALG_ALGSEL_SHA512;
+		break;
+	case OP_PCL_IPSEC_AES_XCBC_MAC_96:
+		*hmac_alg = 0;
+		auth_param->split_key_len = 0;
+		break;
+	default:
+		xx_pr_err("Unsupported authentication algorithm\n");
+		return -EINVAL;
+	}
+
+	if (*hmac_alg)
+		auth_param->split_key_len =
+				mdpadlen[(*hmac_alg & OP_ALG_ALGSEL_SUBMASK) >>
+					 OP_ALG_ALGSEL_SHIFT] * 2;
+
+	return 0;
+}
+
 int generate_split_key(struct auth_params *auth_param)
 {
 	struct device *jrdev;
 	dma_addr_t dma_addr_in, dma_addr_out;
-	u32 *desc, timeout = 1000000;
+	u32 *desc, timeout = 1000000, alg_sel = 0;
 	atomic_t done;
 	int ret = 0;
-	/* Sizes for MDHA pads (*not* keys): MD5, SHA1, 224, 256, 384, 512 */
-	static const u8 mdpadlen[] = { 16, 20, 32, 32, 64, 64 };
+
+	ret = get_split_key_info(auth_param, &alg_sel);
+	/* exit if error or there is no need to compute a split key */
+	if (ret < 0 || alg_sel == 0)
+		return ret;
 
 	jrdev = get_jrdev();
 	if (!jrdev) {
@@ -241,9 +299,6 @@ int generate_split_key(struct auth_params *auth_param)
 		return -ENOMEM;
 	}
 
-	auth_param->split_key_len =
-	    mdpadlen[((OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC) &
-		      OP_ALG_ALGSEL_SUBMASK) >> OP_ALG_ALGSEL_SHIFT] * 2;
 	auth_param->split_key_pad_len = ALIGN(auth_param->split_key_len, 16);
 
 	dma_addr_in = dma_map_single(jrdev, auth_param->auth_key,
@@ -272,8 +327,8 @@ int generate_split_key(struct auth_params *auth_param)
 
 	/* Sets MDHA up into an HMAC-INIT */
 	append_operation(desc, (OP_ALG_TYPE_CLASS2 << OP_ALG_TYPE_SHIFT) |
-			 OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC |
-			 OP_ALG_DECRYPT | OP_ALG_AS_INIT);
+			 alg_sel | OP_ALG_AAI_HMAC |
+			OP_ALG_DECRYPT | OP_ALG_AS_INIT);
 
 	/* Do a FIFO_LOAD of zero, this will trigger the internal key expansion
 	   into both pads inside MDHA */
-- 
1.7.5.4

