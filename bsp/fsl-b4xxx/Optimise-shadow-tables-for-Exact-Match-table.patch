From 78f4da1788112293839184d10cd68a91ed069d1f Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Mar 2012 21:24:53 +0000
Subject: [PATCH 106/518] Optimise shadow tables for Exact Match table

The Exact Match tables were using a number of shadow tables which was equal
to the number of internal Cc nodes that were managed. However, the entries
can be managed also using a single shadow table based on a CRC8 hash.

This fix speeds up all the runtime operations on Exact Match tables that
are managed by key. It upgrades the shadow tables management of the Exact
Match tables to use a single CRC8 hashed shadow table.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  271 +++++++---------------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   13 -
 drivers/staging/fsl_dpa_offload/dpa_compat.c     |    3 +-
 3 files changed, 91 insertions(+), 196 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index ba78119..a95cdfb 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -74,9 +74,9 @@ static unsigned int table_entries_in_use;
 int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				int				*td)
 {
-	unsigned int i;
 	int err = 0;
 	struct dpa_cls_table *ptable;
+	unsigned int i;
 
 	xx_sanity_check_return_value(params, "params", -EINVAL);
 	xx_sanity_check_return_value(td, "td", -EINVAL);
@@ -108,34 +108,27 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	/* Copy over the table params into the control block */
 	memcpy(&ptable->params, params, sizeof(struct dpa_cls_tbl_params));
 
+	if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY) {
+		ptable->shadow_table =
+			(struct dpa_cls_tbl_shadow_table *)
+			xx_zalloc(sizeof(*ptable->shadow_table));
+		if (!ptable->shadow_table) {
+			xx_pr_err("No more memory for DPA classifier shadow table.");
+			err = -ENOMEM;
+			goto dpa_classif_table_create_error;
+		}
+	}
+
 	switch (ptable->params.type) {
 	case DPA_CLS_TBL_INDEXED:
 		ptable->int_cc_nodes_count = 1;
-		if (ptable->params.entry_mgmt ==
-				DPA_CLS_TBL_MANAGE_BY_KEY) {
-			/*
-			 * Allocate shadow table depending on the type of
-			 * classifier table
-			 */
+		if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY)
 			/*
 			 * Shadow table is directly indexed with the index in
 			 * the entry key
 			 */
-			ptable->num_shadow_tables = 1;
-			ptable->shadow_table =
-				(struct dpa_cls_tbl_shadow_table *)
-				xx_zalloc(sizeof(struct
-						dpa_cls_tbl_shadow_table));
-			if (!ptable->shadow_table) {
-				xx_pr_err("No more memory for DPA classifier shadow table.");
-				err = -ENOMEM;
-				goto dpa_classif_table_create_error;
-			}
-
-			/* Set shadow table size */
 			ptable->shadow_table->size =
 				ptable->params.indexed_params.entries_cnt;
-		}
 		err = table_init_indexed(ptable);
 		if (err < 0)
 			goto dpa_classif_table_create_error;
@@ -146,32 +139,10 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			ptable->params.exact_match_params.entries_cnt /
 			DPA_CLS_TBL_MAXSHADOWTABLESIZE + 1;
 		if (ptable->params.entry_mgmt ==
-				DPA_CLS_TBL_MANAGE_BY_KEY) {
-			/*
-			 * Allocate shadow table depending on the type of
-			 * classifier table
-			 */
-			/*
-			 * Calculate the number of shadow tables necessary for
-			 * the provided number of entries
-			 */
-			ptable->num_shadow_tables =
-				ptable->int_cc_nodes_count;
-			ptable->shadow_table =
-				(struct dpa_cls_tbl_shadow_table *)
-				xx_zalloc(ptable->num_shadow_tables *
-				sizeof(struct dpa_cls_tbl_shadow_table));
-			if (!ptable->shadow_table) {
-				xx_pr_err("No more memory for DPA classifier shadow table.");
-				err = -ENOMEM;
-				goto dpa_classif_table_create_error;
-			}
-
-			/* Set shadow table sizes */
-			for (i = 0; i < ptable->num_shadow_tables; i++)
-				ptable->shadow_table[i].size =
+				DPA_CLS_TBL_MANAGE_BY_KEY)
+			/* Set shadow table size */
+			ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
-		}
 		err = table_init_exact_match(ptable);
 		if (err < 0)
 			goto dpa_classif_table_create_error;
@@ -180,44 +151,39 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	case DPA_CLS_TBL_HASH:
 		ptable->int_cc_nodes_count =
 			ptable->params.hash_params.num_sets;
-		if (ptable->params.entry_mgmt ==
-				DPA_CLS_TBL_MANAGE_BY_KEY) {
+		if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY)
 			/*
-			 * Allocate shadow table depending on the type of
-			 * classifier table
+			 * Shadow table is indexed using a CRC8 HASH on the
+			 * key
 			 */
-			/* Shadow table is indexed using a HASH on the key */
-			ptable->num_shadow_tables = 1;
-			ptable->shadow_table =
-				(struct dpa_cls_tbl_shadow_table *)
-				xx_zalloc(sizeof(struct
-						dpa_cls_tbl_shadow_table));
-			if (!ptable->shadow_table) {
-				xx_pr_err("No more memory for DPA classifier shadow table.");
-				err = -ENOMEM;
-				goto dpa_classif_table_create_error;
-			}
-
-			/* Set shadow table size */
 			ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
-		}
 		err = table_init_hash(ptable);
 		if (err < 0)
 			goto dpa_classif_table_create_error;
 		break;
 	}
 
-	/* Init shadow tables if necessary */
-	if (ptable->num_shadow_tables) {
-		err = init_shadow_tables(ptable);
-		if (err < 0)
+	/* Init shadow table if necessary */
+	if (ptable->shadow_table) {
+		/* Allocate entries in the shadow table */
+		ptable->shadow_table->shadow_entry = (struct list_head *)
+			xx_malloc(ptable->shadow_table->size *
+					sizeof(struct list_head));
+		if (!ptable->shadow_table->shadow_entry) {
+			xx_pr_err("No more memory for DPA Classifier shadow tables.");
+			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
+		}
+
+		/* Initialize the entries in shadow table */
+		for (i = 0; i < ptable->shadow_table->size; i++)
+			INIT_LIST_HEAD(&ptable->shadow_table->shadow_entry[i]);
 	}
 
 	/* Miss action is drop by default */
 	ptable->miss_next_engine_params.nextEngine = e_FM_PCD_DONE;
-	ptable->miss_next_engine_params.params.enqueueParams.action	=
+	ptable->miss_next_engine_params.params.enqueueParams.action =
 		e_FM_PCD_DROP_FRAME;
 	ptable->miss_next_engine_params.params.enqueueParams.statisticsEn =
 		TRUE;
@@ -230,8 +196,11 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 dpa_classif_table_create_error:
 	/* Something went wrong. Release allocated memory and exit */
 	if (ptable) {
-		if (ptable->shadow_table)
+		if (ptable->shadow_table) {
+			if (ptable->shadow_table->shadow_entry)
+				xx_free(ptable->shadow_table->shadow_entry);
 			xx_free(ptable->shadow_table);
+		}
 
 		xx_free(ptable);
 		put_table_descriptor(*td);
@@ -258,7 +227,8 @@ int dpa_classif_table_free(int td)
 	if (ptable->shadow_table) {
 
 		/* Release shadow table */
-		free_shadow_tables(ptable);
+		if (ptable->shadow_table->shadow_entry)
+			xx_free(ptable->shadow_table->shadow_entry);
 		xx_free(ptable->shadow_table);
 	}
 
@@ -476,6 +446,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 	uint8_t entry_index;
+	uint8_t shadow_table_index;
 	unsigned int cc_node_index;
 	int errno;
 	t_Error err;
@@ -606,7 +577,7 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 
 			bucket_head =
-				ptable->shadow_table[0].
+				ptable->shadow_table->
 					shadow_entry[entry_index].next;
 			shadow_entry_indexed = list_entry(bucket_head,
 				struct dpa_cls_tbl_shadow_entry_indexed,
@@ -625,8 +596,24 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 
 			key	= &shadow_entry->key;
 			action	= &shadow_entry->action;
-		}
 
+			/*
+			 * The entry needs to be re-hashed and relocated
+			 * according to the new key
+			 */
+
+			/* Detach from current bucket: */
+			list_del(&shadow_entry->list_node);
+			/* Recompute bucket: */
+			shadow_table_index = crc8(
+				mod_params->key->byte,
+				ptable->params.exact_match_params.key_size);
+			/* Add to the new bucket: */
+			list_add_tail(
+				&shadow_entry->list_node,
+				&ptable->shadow_table->
+					shadow_entry[shadow_table_index]);
+		}
 
 		if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
 			(mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION))
@@ -776,10 +763,10 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	}
 	int_cc_node->used--;
 
-	if (ptable->num_shadow_tables) {
+	if (ptable->shadow_table) {
 		if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 
-			bucket_head = ptable->shadow_table[0].
+			bucket_head = ptable->shadow_table->
 					shadow_entry[entry_index].next;
 			shadow_entry_indexed = list_entry(bucket_head,
 					struct dpa_cls_tbl_shadow_entry_indexed,
@@ -886,7 +873,7 @@ int dpa_classif_table_lookup_by_ref(int				td,
 
 	if (table[td]->params.type == DPA_CLS_TBL_INDEXED) {
 
-		bucket_head = table[td]->shadow_table[0].
+		bucket_head = table[td]->shadow_table->
 					shadow_entry[entry_index].next;
 		shadow_entry_indexed = list_entry(bucket_head,
 					struct dpa_cls_tbl_shadow_entry_indexed,
@@ -953,9 +940,9 @@ int dpa_classif_table_flush(int td)
 		ptable->int_cc_node[0].used = 0;
 
 	/* Clean up shadow table if it exists */
-	if (ptable->num_shadow_tables) {
+	if (ptable->shadow_table) {
 		for (i = 0; i < ptable->int_cc_node[0].table_size; i++) {
-			shadow_table = &ptable->shadow_table[0];
+			shadow_table = ptable->shadow_table;
 			if (!list_empty(&shadow_table->shadow_entry[i])) {
 				shadow_entry_indexed =
 					list_entry(shadow_table->
@@ -1590,38 +1577,42 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 static struct list_head *find_shadow_entry(const struct dpa_cls_table
 				*cls_table, const struct dpa_cls_tbl_key *key)
 {
-	uint8_t shadow_table_index;
+	uint8_t shadow_table_index, key_size;
 	struct dpa_cls_tbl_shadow_entry *entry;
 	bool found = false;
 	struct list_head *pos, *bucket_list;
-	unsigned int i, j;
+	unsigned int i;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 
 	xx_assert(cls_table);
 	xx_assert(key);
 	xx_assert(cls_table->shadow_table);
 
+	shadow_table = cls_table->shadow_table;
 	if (cls_table->params.type == DPA_CLS_TBL_INDEXED) {
-		shadow_table = &cls_table->shadow_table[0];
 		if (list_empty(&shadow_table->shadow_entry[key->byte[0]]))
 			return NULL;
 		else
 			return shadow_table->shadow_entry[key->byte[0]].next;
 	} else {
-		if (cls_table->params.type == DPA_CLS_TBL_HASH) {
-			shadow_table = &cls_table->shadow_table[0];
-			shadow_table_index = crc8(key->byte,
-				cls_table->params.hash_params.key_size);
-			bucket_list =
-				&shadow_table->shadow_entry[shadow_table_index];
+		if (cls_table->params.type == DPA_CLS_TBL_HASH)
+			key_size = cls_table->params.hash_params.key_size;
+		else
+			key_size = cls_table->params.exact_match_params.
+								key_size;
 
-			if (list_empty(bucket_list))
-				return NULL;
+		shadow_table_index = crc8(key->byte, key_size);
 
-			/*
-			 * Look into the HASH bucket to find the entry with the
-			 * specified key
-			 */
+		bucket_list =
+			&shadow_table->shadow_entry[shadow_table_index];
+
+		if (list_empty(bucket_list))
+			return NULL;
+
+		/*
+		 * Look into the HASH bucket to find the entry with the
+		 * specified key
+		 */
 	list_for_each(pos, bucket_list) {
 		entry = list_entry(pos, struct dpa_cls_tbl_shadow_entry,
 				list_node);
@@ -1634,46 +1625,10 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 				break;
 			}
 		}
-		if (found)
-			break;
-	}
 
-		} else {
-			/*
-			 * Exact match table (DPA_CLS_TBL_EXACT_MATCH). Search
-			 * in all Cc node shadow tables
-			 */
-			shadow_table_index = crc8(key->byte,
-				cls_table->params.exact_match_params.key_size);
-			for (i = 0; i < cls_table->num_shadow_tables; i++) {
-				shadow_table = &cls_table->shadow_table[i];
-				if (list_empty(&shadow_table->
-					shadow_entry[shadow_table_index]))
-					continue;
-
-	/* Search into this bucket */
-	bucket_list = &shadow_table->shadow_entry[shadow_table_index];
-	list_for_each(pos, bucket_list) {
-		entry = list_entry(pos, struct dpa_cls_tbl_shadow_entry,
-				list_node);
-		found = true;
-		/* Verify if the key and mask are identical */
-		for (j = 0; j < DPA_CLS_TBL_MAXENTRYKEYSIZE; j++) {
-			if ((entry->key.byte[j] != key->byte[j]) ||
-					(entry->key.mask[j] != key->mask[j])) {
-				found = false;
-				break;
-			}
-		}
 		if (found)
 			break;
 	}
-
-			if (found)
-				break;
-
-			}
-		}
 	}
 
 	if (found)
@@ -1682,52 +1637,6 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 	return NULL;
 }
 
-static int init_shadow_tables(struct dpa_cls_table *cls_table)
-{
-	unsigned int i, j;
-	int err = 0;
-
-	xx_assert(cls_table);
-
-	for (i = 0; i < cls_table->num_shadow_tables; i++) {
-		/* Allocate entries in the shadow table */
-		cls_table->shadow_table[i].shadow_entry = (struct list_head *)
-			xx_malloc(cls_table->shadow_table[i].size *
-				sizeof(struct list_head));
-		if (!cls_table->shadow_table[i].shadow_entry) {
-			xx_pr_err("No more memory for DPA Classifier shadow tables.");
-			err = -ENOMEM;
-			goto init_shadow_tables_error;
-		}
-
-		/* Initialize the entries in shadow table */
-		for (j = 0; j < cls_table->shadow_table[i].size; j++)
-			INIT_LIST_HEAD(&cls_table->shadow_table[i].
-							shadow_entry[j]);
-	}
-
-	return err;
-
-init_shadow_tables_error:
-	free_shadow_tables(cls_table);
-
-	return err;
-}
-
-static void free_shadow_tables(struct dpa_cls_table *cls_table)
-{
-	unsigned int i;
-
-	xx_assert(cls_table);
-
-	for (i = 0; i < cls_table->num_shadow_tables; i++)
-		if (cls_table->shadow_table[i].shadow_entry) {
-			xx_free(cls_table->shadow_table[i].shadow_entry);
-			memset(&(cls_table->shadow_table[i]), 0,
-				sizeof(struct dpa_cls_tbl_shadow_table));
-		}
-}
-
 static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 				const struct dpa_cls_tbl_key	*key,
 				const struct dpa_cls_tbl_action	*action,
@@ -1766,7 +1675,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	cls_table->int_cc_node[0].used++;
 
 	/* If a shadow table exists, add the action to it */
-	if (cls_table->num_shadow_tables) {
+	if (cls_table->shadow_table) {
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry_indexed *)
 			xx_zalloc(sizeof(*shadow_entry));
 		if (!shadow_entry) {
@@ -1783,7 +1692,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 		 * indexed with the first byte of the entry key
 		 */
 		list_add(&shadow_entry->list_node,
-			&cls_table->shadow_table[0].shadow_entry[key->byte[0]]);
+			&cls_table->shadow_table->shadow_entry[key->byte[0]]);
 	}
 
 	if (entry_id)
@@ -1928,8 +1837,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	cls_table->int_cc_node[i].used++;
 
-	/* If shadow tables exist, add the entry to them */
-	if (cls_table->num_shadow_tables) {
+	/* If shadow table exists, add the entry to them */
+	if (cls_table->shadow_table) {
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
@@ -1951,7 +1860,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		/* Add entry to the proper shadow table. */
 		shadow_table_index = crc8(key->byte,
 				cls_table->params.exact_match_params.key_size);
-		shadow_table = &cls_table->shadow_table[i];
+		shadow_table = cls_table->shadow_table;
 		list_add_tail(&shadow_entry->list_node,
 			&shadow_table->shadow_entry[shadow_table_index]);
 	}
@@ -2053,7 +1962,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	cls_table->int_cc_node[hash_set_index].used++;
 
 	/* If shadow tables exist, add the entry to them */
-	if (cls_table->num_shadow_tables) {
+	if (cls_table->shadow_table) {
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
 		if (!shadow_entry) {
@@ -2075,7 +1984,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		/* Add entry to the proper shadow table. */
 		shadow_table_index = crc8(key->byte,
 				cls_table->params.hash_params.key_size);
-		shadow_table = &cls_table->shadow_table[0];
+		shadow_table = cls_table->shadow_table;
 		list_add_tail(&shadow_entry->list_node,
 			&shadow_table->shadow_entry[shadow_table_index]);
 	}
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 4b67e4e..77f351e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -137,9 +137,6 @@ struct dpa_cls_table {
 	/* Array of shadow tables. NULL if there are none. */
 	struct dpa_cls_tbl_shadow_table		*shadow_table;
 
-	/* Number of shadow tables in the shadow_table array */
-	unsigned int				num_shadow_tables;
-
 	/*
 	 * Array of internally managed FMan Cc nodes. NULL
 	 * if there are none beside the initial Cc node (provided
@@ -211,16 +208,6 @@ static void	table_cleanup_hash(struct dpa_cls_table *cls_table);
 static int	verify_table_params(const struct dpa_cls_tbl_params *params);
 
 /*
- * Initialize shadow tables according to their number and sizes.
- * The number of sizes of the shadow tables must be set in the
- * table control structure before calling this function.
- */
-static int	init_shadow_tables(struct dpa_cls_table *cls_table);
-
-/* Release resources associated with shadow tables. */
-static void	free_shadow_tables(struct dpa_cls_table *cls_table);
-
-/*
  * Finds a specified entry in the shadow tables. The entry is
  * identified by its lookup key.
  */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_compat.c b/drivers/staging/fsl_dpa_offload/dpa_compat.c
index 5c39369..a416d0d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_compat.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_compat.c
@@ -186,8 +186,7 @@ void xx_free_debug(void *memory)
 
 	list_del(temp);
 	if (memblk->free_func != dpa_offld_free) {
-		pr_err("\nERROR: dpa_compat.c (%d), %s: Freeing memory with the wrong\n  \"free\" function.\n",
-			__LINE__, __func__);
+		pr_err("\nERROR: Freeing memory with the wrong \"free\" function.\n");
 		pr_err("  Memory block @ 0x%08x\n", (unsigned)memblk->mem);
 		pr_err("  Allocated in: %s\n", memblk->file_name);
 		pr_err("  Line %d, function \"%s\"\n", memblk->file_line,
-- 
1.7.5.4

