From 34b88de3c20aa7391fbeae12979178bf7c7fff0f Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:11:16 +0000
Subject: [PATCH 6/7] dpa_classifier: Add support for runtime modification of VLAN specific header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  137 ++++++++++++++++++--
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    3 -
 2 files changed, 127 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index ca4ae6f..45a9542 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -6177,13 +6177,9 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 	uint8_t *pdata;
 
 	BUG_ON(!pvlan_hm);
+	BUG_ON(pvlan_hm->num_nodes != 1);
+	BUG_ON(!pvlan_hm->hm_node[0]);
 
-	if ((pvlan_hm->num_nodes < 1) || (!pvlan_hm->hm_node[0])) {
-		pr_err("ERROR: %s, %s (%d): Inconsistency between resources "
-			"and provided parameters.\n", __FILE__, __func__,
-			__LINE__);
-		return -EINVAL;
-	}
 	hm_node = pvlan_hm->hm_node[0];
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
@@ -6269,7 +6265,9 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 		}
 
 		break;
-	default: /* Will never get here */
+	default:
+		/* Should never get here */
+		BUG_ON(1);
 		break;
 	}
 
@@ -6279,9 +6277,128 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 int dpa_classif_modify_vlan_hm(int hmd,
 	const struct dpa_cls_hm_vlan_params *new_vlan_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
-		__LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pvlan_hm;
+	bool update = false;
+	t_Error error;
+	int ret = 0;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	if ((modify_flags & DPA_CLS_HM_VLAN_MOD_INGRESS_NUM_QTAGS) &&
+		(modify_flags != DPA_CLS_HM_VLAN_MOD_INGRESS_NUM_QTAGS)) {
+		pr_err("ERROR: %s, %s (%d): MOD_INGRESS_NUM_QTAGS flag "
+			"cannot be combined with other flags.\n", __FILE__,
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* Parameters sanity checks: */
+	if (!new_vlan_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_vlan_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	pvlan_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pvlan_hm->type != DPA_CLS_HM_TYPE_VLAN) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an VLAN type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	if (modify_flags == DPA_CLS_HM_VLAN_MOD_INGRESS_NUM_QTAGS) {
+		if (pvlan_hm->vlan_params.type != DPA_CLS_HM_VLAN_INGRESS) {
+			pr_err("ERROR: %s, %s (%d): hmd=%d is not an INGRESS "
+				"VLAN type header manipulation.\n", __FILE__,
+				__func__, __LINE__, hmd);
+			return -EINVAL;
+		}
+
+		if (new_vlan_params->ingress.num_tags !=
+				pvlan_hm->vlan_params.ingress.num_tags) {
+			update = true;
+			pvlan_hm->vlan_params.ingress.num_tags =
+					new_vlan_params->ingress.num_tags;
+		}
+	} else {
+		if (pvlan_hm->vlan_params.type != DPA_CLS_HM_VLAN_EGRESS) {
+			pr_err("ERROR: %s, %s (%d): hmd=%d is not an EGRESS "
+				"VLAN type header manipulation.\n", __FILE__,
+				__func__, __LINE__, hmd);
+			return -EINVAL;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_VLAN_MOD_EGRESS_QTAGS) &&
+			(new_vlan_params->egress.num_tags !=
+				pvlan_hm->vlan_params.egress.num_tags)) {
+			update = true;
+			pvlan_hm->vlan_params.egress.num_tags =
+					new_vlan_params->egress.num_tags;
+			memcpy(pvlan_hm->vlan_params.egress.qtag,
+				new_vlan_params->egress.qtag,
+				pvlan_hm->vlan_params.egress.num_tags *
+					sizeof(struct vlan_header));
+		}
+
+		if ((modify_flags & DPA_CLS_HM_VLAN_MOD_EGRESS_UPDATE_OP) &&
+			(new_vlan_params->egress.update_op !=
+				pvlan_hm->vlan_params.egress.update_op)) {
+			update = true;
+			pvlan_hm->vlan_params.egress.update_op =
+					new_vlan_params->egress.update_op;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_VLAN_MOD_EGRESS_VPRI) &&
+			(new_vlan_params->egress.update.vpri !=
+				pvlan_hm->vlan_params.egress.update.vpri)) {
+			update = true;
+			pvlan_hm->vlan_params.egress.update.vpri =
+					new_vlan_params->egress.update.vpri;
+		}
+
+		if (modify_flags &
+			DPA_CLS_HM_VLAN_MOD_EGRESS_DSCP_TO_VPRI_ARRAY) {
+			update = true;
+			memcpy(pvlan_hm->vlan_params.egress.update.dscp_to_vpri,
+				new_vlan_params->egress.update.dscp_to_vpri,
+				DPA_CLS_HM_DSCP_TO_VPRI_TABLE_SIZE);
+		}
+	}
+
+	if (update) {
+		ret = vlan_hm_update_params(pvlan_hm);
+		if (ret == 0) {
+			hm_node = pvlan_hm->hm_node[0];
+
+			error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&hm_node->params);
+			if (error != E_OK) {
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed - FM_PCD_ManipNodeReplace, "
+					"while trying to modify hmd=%d, manip "
+					"node handle=0x%p.\n", __FILE__,
+					__func__, __LINE__, hmd, hm_node->node);
+				return -EBUSY;
+			}
+		}
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_vlan_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index f7fbc50..3c4c6dd 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1071,9 +1071,6 @@ static long do_ioctl_modify_vlan_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d)\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.vlan_params.fm_pcd = translate_fm_pcd_handle(kparam.vlan_params.
-								fm_pcd);
 	if (!kparam.vlan_params.fm_pcd)
 		return -EINVAL;
 
-- 
1.7.0.2

