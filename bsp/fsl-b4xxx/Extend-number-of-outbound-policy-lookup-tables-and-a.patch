From 2179bf4eb3e1a7bc8bd63e0eb3cdea8a3c3a23f4 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:06 +0000
Subject: [PATCH 228/518] Extend number of outbound policy lookup tables and
 allow per table key fields configuration

Add API support for using different tables for outbound policy
lookup depending on the type of IP addresses (IPv4 or IPv6), thus
enabling better MURAM management. The number of tables will
effectively be doubled.

Also allow the policy key structure to be specified independently
for each policy lookup table. This also allows better MURAM
management, especially in environments where the key structure
depends on the type of policy.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   92 +++++++++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   20 +++---
 include/linux/fsl_dpa_ipsec.h               |   29 ++++++---
 3 files changed, 96 insertions(+), 45 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 26a3307..d56855c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -178,13 +178,45 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 static inline void store_ipsec_params(struct dpa_ipsec *dpa_ipsec,
 				      const struct dpa_ipsec_params *params)
 {
+	struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
+	struct dpa_ipsec_pol_table *any_ipv4_table, *any_ipv6_table;
+	int i;
+
 	/* copy config params */
 	dpa_ipsec->config = *params;
+
+	/*
+	 * reconfigure the array of outbound policy table parameters, in order
+	 * to simplify the process of choosing the correct table during runtime
+	 * add / remove policies operations
+	 */
+
+	pre_sec_out_params = &dpa_ipsec->config.pre_sec_out_params;
+	/* get the desc for the ANY tables */
+	any_ipv4_table = &pre_sec_out_params->table[DPA_IPSEC_PROTO_ANY_IPV4];
+	any_ipv6_table = &pre_sec_out_params->table[DPA_IPSEC_PROTO_ANY_IPV6];
+
+	/*
+	 * replace the parameters of a table for a specific protocol, if an
+	 * invalid table desc was provided, with those of the corresponding ANY
+	 * table for that IP version
+	 */
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS - 2; i++) {
+		if (pre_sec_out_params->table[i].dpa_cls_td ==
+							DPA_OFFLD_DESC_NONE) {
+			/* IPV4 table desc are at even indexes (IPV6 at odd) */
+			if (i & 0x01)
+				pre_sec_out_params->table[i] = *any_ipv4_table;
+			else
+				pre_sec_out_params->table[i] = *any_ipv6_table;
+		}
+	}
 }
 
 /* check that the provided params are valid */
 static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 {
+	const struct dpa_ipsec_pre_sec_out_params *pre_sec_out_prms;
 	struct dpa_cls_tbl_params table_params;
 	int i, err, valid_tables = 0;
 
@@ -204,12 +236,22 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	 * - one table for index lookup after decryption
 	 * - one table for SA lookup
 	 */
+
+	/* check outbound policy tables */
+	pre_sec_out_prms = &prms->pre_sec_out_params;
 	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++)
-		if (prms->pre_sec_out_params.dpa_cls_td[i] !=
+		if (pre_sec_out_prms->table[i].dpa_cls_td !=
 						DPA_OFFLD_DESC_NONE) {
+			/* verify that a valid key structure was configured */
+			if (!pre_sec_out_prms->table[i].key_fields) {
+				pr_err("Invalid key struct. for out table %d\n",
+				       i);
+				return -EINVAL;
+			}
+
 			/* verify that it is not an indexed table */
 			err = dpa_classif_table_get_params(
-				       prms->pre_sec_out_params.dpa_cls_td[i],
+					pre_sec_out_prms->table[i].dpa_cls_td,
 				       &table_params);
 			if (err < 0) {
 				pr_err("Couldn't check type of outbound policy lookup table\n");
@@ -267,11 +309,13 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
-	/*verify that at least one field was selected for building policy keys*/
-	if (prms->pre_sec_out_params.key_fields == 0 ||
-	   (prms->post_sec_in_params.do_pol_check &&
-	    prms->post_sec_in_params.key_fields == 0)) {
-		pr_err("At least one field must be specified for building policy keys\n");
+	/*
+	 * verify that at least one field was selected for building inbound
+	 * policy keys
+	 */
+	if (prms->post_sec_in_params.do_pol_check &&
+	    prms->post_sec_in_params.key_fields == 0) {
+		pr_err("At least one field must be specified IN policy keys\n");
 		return -EINVAL;
 	}
 
@@ -1164,8 +1208,9 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 				  enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
+	struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
-	uint8_t key_len, table_idx;
+	uint8_t key_len, table_idx, key_fields;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_header_manip *hm = NULL;
@@ -1177,25 +1222,23 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 	dpa_ipsec = sa->dpa_ipsec;
 	BUG_ON(!dpa_ipsec);
+	pre_sec_out_params = &dpa_ipsec->config.pre_sec_out_params;
 
 	policy_selectors = &policy_entry->policy_selectors;
+	if (IP_ADDR_TYPE_IPV4(policy_selectors->dest_addr))
+		table_idx = GET_POL_TABLE_IDX(policy_selectors->protocol, IPV4);
+	else
+		table_idx = GET_POL_TABLE_IDX(policy_selectors->protocol, IPV6);
+	table = pre_sec_out_params->table[table_idx].dpa_cls_td;
+	key_fields = pre_sec_out_params->table[table_idx].key_fields;
 
-	table_idx = GET_POL_CC_NODE_INDX(policy_selectors->protocol);
-	table = dpa_ipsec->config.pre_sec_out_params.dpa_cls_td[table_idx];
-
+	/*
+	 * check if a valid desc for a proto specific table or an ANY table was
+	 * provided
+	 */
 	if (table == DPA_OFFLD_DESC_NONE) {
-		struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
-		pre_sec_out_params = &dpa_ipsec->config.pre_sec_out_params;
-
-		if ((table_idx != DPA_IPSEC_PROTO_ANY) &&
-		    (pre_sec_out_params->dpa_cls_td[DPA_IPSEC_PROTO_ANY] !=
-				    DPA_OFFLD_DESC_NONE)) {
-			table =
-			    pre_sec_out_params->dpa_cls_td[DPA_IPSEC_PROTO_ANY];
-		} else {
-			pr_err("No suitable table found for this policy type!\n");
-			return -EINVAL;
-		}
+		pr_err("No suitable table found for this policy type!\n");
+		return -EBADF;
 	}
 
 	switch (op_type) {
@@ -1209,8 +1252,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		 * SRC_PORT     - from Policy handle (for UDP & TCP & SCTP)
 		 * DST_PORT     - from Policy handle (for UDP & TCP & SCTP)
 		 */
-		err = fill_policy_key(table, policy_selectors,
-				dpa_ipsec->config.pre_sec_out_params.key_fields,
+		err = fill_policy_key(table, policy_selectors, key_fields,
 				tbl_key.byte, tbl_key.mask, &key_len);
 		if (err < 0)
 			return err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 787f9fb..065fba9 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -137,18 +137,18 @@
 	IPSEC_ALGS_ENTRY(AES_CTR, HMAC_SHA2_512_256)		\
 }
 
-#define GET_POL_CC_NODE_INDX(_proto) \
-	((_proto == IPPROTO_TCP)  ? DPA_IPSEC_PROTO_TCP :  \
-	 (_proto == IPPROTO_UDP)  ? DPA_IPSEC_PROTO_UDP :  \
-	 (_proto == IPPROTO_ICMP) ? DPA_IPSEC_PROTO_ICMP : \
-	 (_proto == IPPROTO_SCTP) ? DPA_IPSEC_PROTO_SCTP : \
-	  DPA_IPSEC_PROTO_ANY)
-
+#define GET_POL_TABLE_IDX(_proto, _ip_ver) \
+	((_proto == IPPROTO_TCP)  ? DPA_IPSEC_PROTO_TCP_##_ip_ver :  \
+	 (_proto == IPPROTO_UDP)  ? DPA_IPSEC_PROTO_UDP_##_ip_ver :  \
+	 (_proto == IPPROTO_ICMP) ? DPA_IPSEC_PROTO_ICMP_##_ip_ver : \
+	 (_proto == IPPROTO_SCTP) ? DPA_IPSEC_PROTO_SCTP_##_ip_ver : \
+	  DPA_IPSEC_PROTO_ANY_##_ip_ver)
+
+#define IP_ADDR_TYPE_IPV4(_ipAddr) (_ipAddr.addr_type == DPA_IPSEC_ADDR_T_IPv4)
 #define IP_ADDR(_ipAddr) \
-	((_ipAddr.addr_type == DPA_IPSEC_ADDR_T_IPv4) ? \
-	(_ipAddr.ipv4.byte) : (_ipAddr.ipv6.byte))
+	(IP_ADDR_TYPE_IPV4(_ipAddr) ? (_ipAddr.ipv4.byte) : (_ipAddr.ipv6.byte))
 #define IP_ADDR_LEN(_ipAddr) \
-	((_ipAddr.addr_type == DPA_IPSEC_ADDR_T_IPv4) ? \
+	(IP_ADDR_TYPE_IPV4(_ipAddr) ? \
 	(IPv4_ADDR_SIZE_IN_BYTES) : (IPv6_ADDR_SIZE_IN_BYTES))
 
 #define SET_IP_PROTO_IN_KEY(_key, _off, _val) (_key[_off] = _val)
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index c9ecbd2..870e2bd 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -101,11 +101,16 @@
 
 /* DPA-IPSec Supported Protocols (for policy offloading) */
 enum dpa_ipsec_proto {
-	DPA_IPSEC_PROTO_TCP = 0,
-	DPA_IPSEC_PROTO_UDP,
-	DPA_IPSEC_PROTO_ICMP,
-	DPA_IPSEC_PROTO_SCTP,
-	DPA_IPSEC_PROTO_ANY,
+	DPA_IPSEC_PROTO_TCP_IPV4 = 0,
+	DPA_IPSEC_PROTO_TCP_IPV6,
+	DPA_IPSEC_PROTO_UDP_IPV4,
+	DPA_IPSEC_PROTO_UDP_IPV6,
+	DPA_IPSEC_PROTO_ICMP_IPV4,
+	DPA_IPSEC_PROTO_ICMP_IPV6,
+	DPA_IPSEC_PROTO_SCTP_IPV4,
+	DPA_IPSEC_PROTO_SCTP_IPV6,
+	DPA_IPSEC_PROTO_ANY_IPV4,
+	DPA_IPSEC_PROTO_ANY_IPV6,
 	DPA_IPSEC_MAX_SUPPORTED_PROTOS
 };
 
@@ -120,6 +125,13 @@ enum dpa_ipsec_data_off {
 	DPA_IPSEC_DATA_OFF_3_BURST
 };
 
+/* DPA IPSec outbound policy lookup table parameters */
+struct dpa_ipsec_pol_table {
+	int	dpa_cls_td; /* DPA Classifier table descriptor		      */
+	uint8_t	key_fields; /* Flags indicating policy key components.
+			     * (use DPA_IPSEC_KEY_FIELD* macros to configure) */
+};
+
 /* DPA-IPSec Pre-Sec Inbound Parameters */
 struct dpa_ipsec_pre_sec_in_params {
 	int dpa_cls_td;		/* SA lookup table descriptor		      */
@@ -127,11 +139,8 @@ struct dpa_ipsec_pre_sec_in_params {
 
 /* DPA-IPSec Pre-Sec Outbound Parameters */
 struct dpa_ipsec_pre_sec_out_params {
-	int dpa_cls_td[DPA_IPSEC_MAX_SUPPORTED_PROTOS];	/* Oubound policy
-							 * lookup table
-							 * descriptors	      */
-	uint8_t key_fields; /* Flags indicating policy key components.
-			     * (use DPA_IPSEC_KEY_FIELD* macros to configure) */
+	/* Oubound policy lookup tables parameters */
+	struct dpa_ipsec_pol_table table[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
 };
 
 /* DPA-IPSec Post-Sec-Inbound Parameters */
-- 
1.7.5.4

