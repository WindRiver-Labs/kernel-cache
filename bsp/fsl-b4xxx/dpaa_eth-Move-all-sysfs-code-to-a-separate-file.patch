From f337386508fef5307e0dfda52eb9efff5863e8cf Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Fri, 18 Jan 2013 21:40:50 +0000
Subject: [PATCH 011/518] dpaa_eth: Move all sysfs code to a separate file

Trying to split dpaa_eth.c in more manageable bits and pieces.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Makefile        |    2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |  143 ---------------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |    3 +
 .../net/ethernet/freescale/dpa/dpaa_eth_sysfs.c    |  188 ++++++++++++++++++++
 4 files changed, 192 insertions(+), 144 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c

diff --git a/drivers/net/ethernet/freescale/dpa/Makefile b/drivers/net/ethernet/freescale/dpa/Makefile
index 5f582cc..4c8defa 100644
--- a/drivers/net/ethernet/freescale/dpa/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/Makefile
@@ -15,7 +15,7 @@ obj-$(CONFIG_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
 obj-$(CONFIG_DPA) += fsl-mac.o fsl-dpa.o
 obj-$(CONFIG_DPA_OFFLINE_PORTS) += fsl-oh.o
 
-fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth.o xgmac_mdio.o memac_mdio.o
+fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth.o dpaa_eth_sysfs.o xgmac_mdio.o memac_mdio.o
 fsl-dpa-sg-objs	:= dpaa_eth_sg.o
 fsl-mac-objs	:= mac.o mac-api.o
 fsl-oh-objs	:= offline_port.o
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 7e3a37d..4e1de88 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -3540,149 +3540,6 @@ int dpa_free_pcd_fqids(struct device *dev, uint32_t base_fqid)
 	return 0;
 }
 
-static ssize_t dpaa_eth_show_addr(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
-	struct mac_device *mac_dev = priv->mac_dev;
-
-	if (mac_dev)
-		return sprintf(buf, "%llx",
-				(unsigned long long)mac_dev->res->start);
-	else
-		return sprintf(buf, "none");
-}
-
-static ssize_t dpaa_eth_show_fqids(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
-	ssize_t bytes = 0;
-	int i = 0;
-	char *str;
-	struct dpa_fq *fq;
-	struct dpa_fq *tmp;
-	struct dpa_fq *prev = NULL;
-	u32 first_fqid = 0;
-	u32 last_fqid = 0;
-	char *prevstr = NULL;
-
-	list_for_each_entry_safe(fq, tmp, &priv->dpa_fq_list, list) {
-		switch (fq->fq_type) {
-		case FQ_TYPE_RX_DEFAULT:
-			str = "Rx default";
-			break;
-		case FQ_TYPE_RX_ERROR:
-			str = "Rx error";
-			break;
-		case FQ_TYPE_RX_PCD:
-			str = "Rx PCD";
-			break;
-		case FQ_TYPE_TX_CONFIRM:
-			str = "Tx confirmation";
-			break;
-		case FQ_TYPE_TX_ERROR:
-			str = "Tx error";
-			break;
-		case FQ_TYPE_TX:
-			str = "Tx";
-			break;
-		default:
-			str = "Unknown";
-		}
-
-		if (prev && (abs(fq->fqid - prev->fqid) != 1 ||
-					str != prevstr)) {
-			if (last_fqid == first_fqid)
-				bytes += sprintf(buf + bytes,
-					"%s: %d\n", prevstr, prev->fqid);
-			else
-				bytes += sprintf(buf + bytes,
-					"%s: %d - %d\n", prevstr,
-					first_fqid, last_fqid);
-		}
-
-		if (prev && abs(fq->fqid - prev->fqid) == 1 && str == prevstr)
-			last_fqid = fq->fqid;
-		else
-			first_fqid = last_fqid = fq->fqid;
-
-		prev = fq;
-		prevstr = str;
-		i++;
-	}
-
-	if (prev) {
-		if (last_fqid == first_fqid)
-			bytes += sprintf(buf + bytes, "%s: %d\n", prevstr,
-					prev->fqid);
-		else
-			bytes += sprintf(buf + bytes, "%s: %d - %d\n", prevstr,
-					first_fqid, last_fqid);
-	}
-
-	return bytes;
-}
-
-static ssize_t dpaa_eth_show_dflt_bpid(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	ssize_t bytes = 0;
-	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
-	struct dpa_bp *dpa_bp = priv->dpa_bp;
-
-	if (priv->bp_count != 1)
-		bytes += snprintf(buf, PAGE_SIZE, "-1\n");
-	else
-		bytes += snprintf(buf, PAGE_SIZE, "%u\n", dpa_bp->bpid);
-
-	return bytes;
-}
-
-static ssize_t dpaa_eth_show_mac_regs(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
-	struct mac_device *mac_dev = priv->mac_dev;
-
-	fm_mac_dump_regs(mac_dev);
-
-	return 0;
-}
-
-static struct device_attribute dpaa_eth_attrs[] = {
-	__ATTR(device_addr, S_IRUGO, dpaa_eth_show_addr, NULL),
-	__ATTR(fqids, S_IRUGO, dpaa_eth_show_fqids, NULL),
-	__ATTR(dflt_bpid, S_IRUGO, dpaa_eth_show_dflt_bpid, NULL),
-	__ATTR(mac_regs, S_IRUGO, dpaa_eth_show_mac_regs, NULL)
-};
-
-static void __devinit dpaa_eth_sysfs_init(struct device *dev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dpaa_eth_attrs); i++)
-		if (device_create_file(dev, &dpaa_eth_attrs[i])) {
-			dev_err(dev, "Error creating sysfs file %s\n",
-				dpaa_eth_attrs[i].attr.name);
-			goto device_create_file_failed;
-		}
-
-	return;
-
-device_create_file_failed:
-	while (i > 0)
-		device_remove_file(dev, &dpaa_eth_attrs[--i]);
-}
-
-static void dpaa_eth_sysfs_remove(struct device *dev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dpaa_eth_attrs); i++)
-		device_remove_file(dev, &dpaa_eth_attrs[i]);
-}
-
 static int dpaa_eth_add_channel(void *__arg)
 {
 	const cpumask_t *cpus = qman_affine_cpus();
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 5fc6efc..6572bf9 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -472,6 +472,9 @@ static inline int dpa_check_rx_mtu(struct sk_buff *skb, int mtu)
 
 void fm_mac_dump_regs(struct mac_device *mac_dev);
 
+void dpaa_eth_sysfs_remove(struct device *dev);
+void dpaa_eth_sysfs_init(struct device *dev);
+
 /* Equivalent to a memset(0), but works faster */
 static inline void clear_fd(struct qm_fd *fd)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c
new file mode 100644
index 0000000..413f27f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c
@@ -0,0 +1,188 @@
+
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <linux/io.h>
+#include <linux/of_net.h>
+#include "dpaa_eth.h"
+
+static ssize_t dpaa_eth_show_addr(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	struct mac_device *mac_dev = priv->mac_dev;
+
+	if (mac_dev)
+		return sprintf(buf, "%llx",
+				(unsigned long long)mac_dev->res->start);
+	else
+		return sprintf(buf, "none");
+}
+
+static ssize_t dpaa_eth_show_fqids(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	ssize_t bytes = 0;
+	int i = 0;
+	char *str;
+	struct dpa_fq *fq;
+	struct dpa_fq *tmp;
+	struct dpa_fq *prev = NULL;
+	u32 first_fqid = 0;
+	u32 last_fqid = 0;
+	char *prevstr = NULL;
+
+	list_for_each_entry_safe(fq, tmp, &priv->dpa_fq_list, list) {
+		switch (fq->fq_type) {
+		case FQ_TYPE_RX_DEFAULT:
+			str = "Rx default";
+			break;
+		case FQ_TYPE_RX_ERROR:
+			str = "Rx error";
+			break;
+		case FQ_TYPE_RX_PCD:
+			str = "Rx PCD";
+			break;
+		case FQ_TYPE_TX_CONFIRM:
+			str = "Tx confirmation";
+			break;
+		case FQ_TYPE_TX_ERROR:
+			str = "Tx error";
+			break;
+		case FQ_TYPE_TX:
+			str = "Tx";
+			break;
+		default:
+			str = "Unknown";
+		}
+
+		if (prev && (abs(fq->fqid - prev->fqid) != 1 ||
+					str != prevstr)) {
+			if (last_fqid == first_fqid)
+				bytes += sprintf(buf + bytes,
+					"%s: %d\n", prevstr, prev->fqid);
+			else
+				bytes += sprintf(buf + bytes,
+					"%s: %d - %d\n", prevstr,
+					first_fqid, last_fqid);
+		}
+
+		if (prev && abs(fq->fqid - prev->fqid) == 1 && str == prevstr)
+			last_fqid = fq->fqid;
+		else
+			first_fqid = last_fqid = fq->fqid;
+
+		prev = fq;
+		prevstr = str;
+		i++;
+	}
+
+	if (prev) {
+		if (last_fqid == first_fqid)
+			bytes += sprintf(buf + bytes, "%s: %d\n", prevstr,
+					prev->fqid);
+		else
+			bytes += sprintf(buf + bytes, "%s: %d - %d\n", prevstr,
+					first_fqid, last_fqid);
+	}
+
+	return bytes;
+}
+
+static ssize_t dpaa_eth_show_dflt_bpid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t bytes = 0;
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	struct dpa_bp *dpa_bp = priv->dpa_bp;
+
+	if (priv->bp_count != 1)
+		bytes += snprintf(buf, PAGE_SIZE, "-1\n");
+	else
+		bytes += snprintf(buf, PAGE_SIZE, "%u\n", dpa_bp->bpid);
+
+	return bytes;
+}
+
+static ssize_t dpaa_eth_show_mac_regs(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	struct mac_device *mac_dev = priv->mac_dev;
+
+	fm_mac_dump_regs(mac_dev);
+
+	return 0;
+}
+
+static struct device_attribute dpaa_eth_attrs[] = {
+	__ATTR(device_addr, S_IRUGO, dpaa_eth_show_addr, NULL),
+	__ATTR(fqids, S_IRUGO, dpaa_eth_show_fqids, NULL),
+	__ATTR(dflt_bpid, S_IRUGO, dpaa_eth_show_dflt_bpid, NULL),
+	__ATTR(mac_regs, S_IRUGO, dpaa_eth_show_mac_regs, NULL)
+};
+
+void dpaa_eth_sysfs_init(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpaa_eth_attrs); i++)
+		if (device_create_file(dev, &dpaa_eth_attrs[i])) {
+			dev_err(dev, "Error creating sysfs file\n");
+			goto device_create_file_failed;
+		}
+
+	return;
+
+device_create_file_failed:
+	while (i > 0)
+		device_remove_file(dev, &dpaa_eth_attrs[--i]);
+}
+
+void dpaa_eth_sysfs_remove(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpaa_eth_attrs); i++)
+		device_remove_file(dev, &dpaa_eth_attrs[i]);
+}
+
+
+
+
+
+
+
-- 
1.7.5.4

