From 08e4f55d83f22afda73ab96e1f056ade531afab9 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:52:23 +0000
Subject: [PATCH 170/518] SA Rekeying processing is now SMP safe.

work done by sa_rekeying_work_func is now synchronized

SA rekeying list protected by lock

SA parent and child are also protected.
Enforced rule: first must acquire parent lock and then child lock.

Removed inbound error recovery since it must not be done
by this layer or maybe we should add special external API
function support for this.

added remove_inbound_hash_entry function which will be
used also by dpa_ipsec_remove_sa, but also is very useful
for inbound rekeying processing

detailed all the errors returned by this rekeying process
so that user layer can take apropriate action

support for user callback, must specify valid function in
rekey_event_cb when calling dpa_ipsec_sa_rekeying

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  253 ++++++++++++++-------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    2 +-
 2 files changed, 130 insertions(+), 125 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 97ad4c4..48242e2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1586,21 +1586,19 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 	return err;
 }
 
-static int inbound_error_recovery(struct dpa_ipsec_sa *sa)
+static int remove_inbound_hash_entry(struct dpa_ipsec_sa *sa)
 {
-	int err = -ENOTRECOVERABLE;
+	int err;
 
-	xx_pr_info("Bases on classifier feature, currently not supported.\n");
+	BUG_ON(!sa);
 
-	/* AV's note: TODO - use here the classifier feature when this is ready.
-	 * if no error occurs set inbound_hash_entry to -1 to mark that
-	 * PCD entry update was done successfully. */
-	if (err == 0) {
-		sa->inbound_hash_entry = -1;
-		return 0;
+	err = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
+	if (unlikely(err < 0)) {
+		xx_pr_crit("Failed to remove inbound key for SA %d\n", sa->id);
+		return -ENOTRECOVERABLE;
 	}
 
-	return -ENOTRECOVERABLE;
+	return 0;
 }
 
 static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
@@ -3440,6 +3438,14 @@ static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
 }
 
 /*
+ * Expects that SA's parent and SA's lock are acquired in this order.
+ *
+ * Function description:
+ *	1. wait until TO SEC FQ is empty or timeout
+ *	2. schedule the child TO SEC FQ
+ *	3. remove the parent TO SEC FQ
+ *	4. free all memory used for this SA i.e recycle this SA
+ *
  * Rekeying process successful if the returned error was: 0, -EUCLEAN, -EDQUOT
  *	- error code 0 for perfect rekeying
  *	- error code -EUCLEAN if during rekeying process the removal of the
@@ -3457,29 +3463,14 @@ static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
  *	- error code -EIO if rekeying failed to schedule the new SA. Upper layer
  *	  has nothing to do since the new SA TO SEC FQ will get scheduled
  *	  eventually.
- *
- * Rekeying process failed: -EFAULT
- *	- If somehow a new SA was linked to the rekeying list but has no parent
- *	  set. This is an internal error for DPA IPSec component. Should never
- *	  happen. The upper layer will get noticed of this error and the
- *	  DPA IPSec will automatically remove the new SA from the rekeying list.
- *	  Upper layer should call again the dpa_ipsec_sa_rekeying for old SA.
  */
 static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
 {
 	struct dpa_ipsec_sa *old_sa;
 	int err, timeout = WAIT4_FQ_EMPTY_TIMEOUT; /* microseconds */
 
-	/* sanity check */
 	old_sa = new_sa->parent_sa;
-	if (!old_sa) {
-		xx_pr_err("Invalid parent SA for child SA id %d\n", new_sa->id);
-		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
-				 -EFAULT);
-		/* Remove the new SA from rekeying list */
-		list_del(&new_sa->sa_rekeying_node);
-		return -EFAULT;
-	}
+	BUG_ON(!old_sa);
 
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 	if (err < 0) {
@@ -3494,9 +3485,6 @@ static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
 		return -EIO;
 	}
 
-	/* Remove the new SA from rekeying list */
-	list_del(&new_sa->sa_rekeying_node);
-
 	/* Now free the old SA structure and all its resources */
 	err = remove_sa_sec_fq(old_sa->to_sec_fq);
 	if (err < 0) {
@@ -3519,6 +3507,9 @@ static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
 }
 
 /*
+ * Expects that SA's parent and SA's lock are acquired in this order.
+ *
+ * Function description:
  * Rekeying process successful if the returned error was: 0, -EUCLEAN, -EDQUOT
  *	- error code 0 for perfect rekeying
  *	- error code -EUCLEAN if during rekeying process the removal of the
@@ -3543,45 +3534,17 @@ static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa)
  *	  has nothing to do since the old SA TO SEC FQ will get scheduled
  *	  eventually.
  *
- * Rekeying process lost MURAM equivalent with 1 PCD entry: -EADV
- *	- Failed to delete the hash entry formed by old SA (SPI, ...)
- *	- If the above action failed than to avoid any possible attacks, the DPA
- *	  IPSec component tries to modify the action of the hash entry formed by
- *	  old SA (SPI, ...) to drop that traffic. If this attempt is successful
- *	  than the system is in a safe state, rekeying might continue, the only
- *	  inconvenient would be losing MURAM equivalent with 1 PCD entry.
- *
- * Rekeying process lost MURAM equivalent with 2 PCD entry: -EL2HLT
- *	- Failed to delete the hash entry formed by old SA (SPI, ...)
- *	- Failed to modify action (to DROP) for the hash entry formed by
- *	  old SA (SPI, ...)
- *	- If all above actions fail, the DPA IPSec component tries to create
- *	  another PCD entry having the same lookup key of the old SA (SPI, ...)
- *	  but with action DROP and greater priority. If this attempt is
- *	  successful the system is in a safe state, rekeying might continue,
- *	  the only inconvenient would be losing MURAM equivalent with 2 PCD
- *	  entries.
- *
  * Rekeying in critical state: -ENOTRECOVERABLE
  *	- Failed to delete the hash entry formed by old SA (SPI, ...)
- *	- Failed to modify action (to DROP) for the hash entry formed by
- *	  old SA (SPI, ...)
- *	- Failed to create another hash entry formed by old SA (SPI, ...) with
- *	  action DROP and having higher priority then the existing one.
- *	- If all above actions failed than the system is in critical state,
- *	  since it is still offloading the old SA. If an attacker would sent
- *	  frames matching the old SA (SPI, ...) than FMAN will direct those
- *	  frames to old SA FQ. In this case the wait until old SA FQ is empty
- *	  is not valid, since being attacked this FQ might not get empty.
+ *	- If an attacker would sent frames matching the old SA (SPI, ...) than
+ *	  FMAN will direct those frames to old SA FQ. In this case the wait
+ *	  until old SA FQ is empty is not valid, since being attacked this FQ
+ *	  might not get empty.
  *	  There is a tiny probability that above scenario to happen, but if it
- *	  does the recommended action would be to reboot the system.
- *
- * Rekeying process failed: -EFAULT
- *	- If somehow a new SA was linked to the rekeying list but has no parent
- *	  set. This is an internal error for DPA IPSec component. Should never
- *	  happen. The upper layer will get noticed of this error and the
- *	  DPA IPSec will automatically remove the new SA from the rekeying list.
- *	  Upper layer should call again the dpa_ipsec_sa_rekeying for old SA.
+ *	  does for several times on the same SA the recommended action would
+ *	  be to call the dpa_ipsec_remove_sa with the parent SA id. In case this
+ *	  function also fails several times then we recommend to reboot the
+ *	  system.
  */
 static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 {
@@ -3589,64 +3552,28 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 	struct qm_mcr_queryfq_np queryfq_np;
 	int err = 0, timeout = WAIT4_FQ_EMPTY_TIMEOUT; /* microseconds */
 
-	/* sanity check */
-	old_sa = new_sa->parent_sa;
-	if (!old_sa) {
-		xx_pr_err("Invalid parent SA for child SA id %d\n", new_sa->id);
-		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
-				 -EFAULT);
-		/* Remove the new SA from rekeying list */
-		list_del(&new_sa->sa_rekeying_node);
-		return -EFAULT;
-	}
-
 	/* Check if the new SA TO SEC FQ has frame descriptors enqueued in it */
 	qman_query_fq_np(new_sa->to_sec_fq, &queryfq_np);
 	if (queryfq_np.frm_cnt == 0)
 		return -EINPROGRESS;
 
-	/* Received at least one packet encrypted with the new SA,
-	 * check if the hash table of old SA was updated properly.*/
-	if (old_sa->inbound_hash_entry == -1)
-		goto resume_rekeying;
+	/*
+	 * Received at least one packet encrypted with the new SA.
+	 * Remove PCD entry that makes traffic go to SEC if the entry is valid.
+	 */
+	old_sa = new_sa->parent_sa;
+	BUG_ON(!old_sa);
 
-	err = update_pre_sec_inbound_table(old_sa, MNG_OP_REMOVE);
-	if (unlikely(err < 0)) {
-		err = update_pre_sec_inbound_table(old_sa, MNG_OP_MODIFY);
-		if (err == 0) {
-			/* report error to upper layer - 1 MURAM entry lost */
-			xx_pr_err("MURAM lost equivalent to one PCD entry\n");
+	if (old_sa->inbound_hash_entry != -1) {
+		err = remove_inbound_hash_entry(old_sa);
+		if (err < 0) {
 			rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
-					 -EADV);
-			goto resume_rekeying;
+					 err);
+			if (err == -ENOTRECOVERABLE)
+				return err;
 		}
-
-		err = inbound_error_recovery(old_sa);
-		if (err == 0) {
-			/* report error to upper layer - 2 MURAM entry lost */
-			xx_pr_err("MURAM lost equivalent to two PCD entries\n");
-			rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
-					 -EL2HLT);
-			goto resume_rekeying;
 		}
 
-		/* Mark hash table entry of old SA as updated, even if a
-		 * critical error occurred. Required so that a later call to
-		 * dpa_ipsec_remove_sa with old SA id, would not try again the
-		 * removal of this entry, consequently failing again. */
-		old_sa->inbound_hash_entry = -1;
-
-		/* Remove the new SA from rekeying list */
-		list_del(&new_sa->sa_rekeying_node);
-
-		/* report critical error */
-		xx_pr_crit("Error recovery failed for SA %d\n", old_sa->id);
-		rekey_err_report(new_sa->rekey_event_cb, 0, new_sa->id,
-				 -ENOTRECOVERABLE);
-		return err;
-	}
-
-resume_rekeying:
 	err = wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 	if (err < 0) {
 		xx_pr_err("Waiting old SA's TO SEC FQ to get empty. Timeout\n");
@@ -3668,9 +3595,6 @@ resume_rekeying:
 		list_splice_init(&old_sa->policy_headlist,
 				 &new_sa->policy_headlist);
 
-	/* Remove the new SA from rekeying list */
-	list_del(&new_sa->sa_rekeying_node);
-
 	/* Now free the old SA structure and all its resources */
 	err = remove_sa_sec_fq(old_sa->to_sec_fq);
 	if (err < 0) {
@@ -3692,24 +3616,102 @@ resume_rekeying:
 	return 0;
 }
 
+static inline struct dpa_ipsec_sa *find_and_lock_sa_to_work_on(
+					struct dpa_ipsec_sa *child_sa,
+					struct dpa_ipsec_sa_mng *sa_mng)
+{
+	struct dpa_ipsec_sa *parent_sa;
+	struct list_head *head;
+	int err;
+
+	head = &sa_mng->sa_rekeying_headlist;
+
+	list_for_each_entry_continue(child_sa, head, sa_rekeying_node) {
+		parent_sa = child_sa->parent_sa;
+		BUG_ON(!parent_sa);
+
+		/* Always acquire parent SA lock before child SA lock */
+		err = mutex_trylock(&parent_sa->lock);
+		if (err == 0)
+			continue;
+
+		/* Acquire child SA lock */
+		err = mutex_trylock(&child_sa->lock);
+		if (err == 0) {
+			mutex_unlock(&parent_sa->lock);
+			continue;
+		}
+
+		return child_sa;
+	}
+
+	return NULL;
+}
+
 void sa_rekeying_work_func(struct work_struct *work)
 {
 	struct dpa_ipsec_sa_mng *sa_mng;
-	struct dpa_ipsec_sa *new_sa, *tmp_sa;
-	struct list_head *head_list;
+	struct dpa_ipsec_sa *child_sa, *parent_sa, *next_child_sa, *pos;
+	struct list_head *head;
+	int err;
 
 	sa_mng = container_of((struct delayed_work *)work,
 			      struct dpa_ipsec_sa_mng, sa_rekeying_work);
-	head_list = &sa_mng->sa_rekeying_headlist;
 
-	list_for_each_entry_safe(new_sa, tmp_sa, head_list, sa_rekeying_node) {
-		if (new_sa->sa_dir == DPA_IPSEC_OUTBOUND)
-			sa_rekeying_outbound(new_sa);
+	/* Acquire protective lock for the SA rekeying list */
+	mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+
+	head = &sa_mng->sa_rekeying_headlist;
+	pos = container_of(head, struct dpa_ipsec_sa, sa_rekeying_node);
+
+	child_sa = find_and_lock_sa_to_work_on(pos, sa_mng);
+
+	/* Release the list lock so other threads may use it */
+	mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
+
+	while (child_sa) {
+		parent_sa = child_sa->parent_sa;
+		BUG_ON(!parent_sa);
+
+		/* Process this child SA accordingly */
+		if (child_sa->sa_dir == DPA_IPSEC_OUTBOUND)
+			err = sa_rekeying_outbound(child_sa);
 		else /* DPA_IPSEC_INBOUND */
-			sa_rekeying_inbound(new_sa);
+			err = sa_rekeying_inbound(child_sa);
+
+		/* Acquire protective lock for the SA rekeying list */
+		mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+
+		next_child_sa = find_and_lock_sa_to_work_on(child_sa, sa_mng);
+
+		/* Remove child SA from rekeying list if processing was OK */
+		if (err == 0 || err == -EUCLEAN || err == -EDQUOT) {
+			parent_sa->child_sa = NULL;
+			child_sa->parent_sa = NULL;
+			list_del(&child_sa->sa_rekeying_node);
 	}
 
-	if (!list_empty(head_list)) {
+		/* Release the list lock so other threads may use it */
+		mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
+
+		if (err == 0 && child_sa->rekey_event_cb)
+			child_sa->rekey_event_cb(0, child_sa->id, err);
+
+		/*
+		 * Parent SA lock is always acquired before child SA lock so
+		 * unlocking them is done backwards
+		 */
+		mutex_unlock(&child_sa->lock);
+		mutex_unlock(&parent_sa->lock);
+
+		child_sa = next_child_sa;
+	}
+
+	/* Acquire protective lock for the sa rekeying list */
+	mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+
+	/* Reschedule work if there is at least one SA in rekeying process */
+	if (!list_empty(head)) {
 		struct timeval timeval;
 		unsigned long jiffies_to_wait;
 
@@ -3722,6 +3724,9 @@ void sa_rekeying_work_func(struct work_struct *work)
 				   jiffies_to_wait);
 	}
 
+	/* Release protective lock for the SA rekeying list */
+	mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
+
 	return;
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index f708747..0d43133 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -256,7 +256,7 @@ struct dpa_ipsec_sa {
 			    check					      */
 	struct dpa_ipsec_sa *parent_sa;	/* Address of the parent SA or NULL   */
 	struct dpa_ipsec_sa *child_sa;	/* Address of the child SA or NULL    */
-	struct list_head sa_rekeying_node; /* Only used for inbound rekeying  */
+	struct list_head sa_rekeying_node; /* For linking in SA rekeying list */
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
 	int use_var_iphdr_len; /* Enable variable IP header length support    */
-- 
1.7.5.4

