From 769de091854347e57602c4dae2f1532011117c63 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Nov 2012 19:06:02 +0000
Subject: [PATCH 380/518] dpa_classifier: Avoid removing header manipulation
 chains that are still in use

The function [dpa_classif_free_hm] did not check whether the
header manipulation that is being removed is part of a chain that is
still attached to a table entry. A lock/release mechanism was implemented
for the header manipulation chains to allow the dpa_classifier to verify
if operations are currently in use. Only if the header manipulation node
was released by all users can it be destroyed.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  156 ++++++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   16 ++-
 2 files changed, 129 insertions(+), 43 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 8ad0180..52574a7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -402,7 +402,8 @@ int dpa_classif_table_modify_miss_action(int			td,
 	}
 
 	/* Fill the [miss_engine_params] structure w/ data */
-	errno = action_to_next_engine_params(miss_action, &miss_engine_params);
+	errno = action_to_next_engine_params(miss_action, &miss_engine_params,
+		NULL);
 	if (errno < 0) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Failed verification of miss action "
@@ -639,7 +640,8 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 				ret = action_to_next_engine_params(
 						mod_params->action,
-						&key_params.ccNextEngineParams);
+						&key_params.ccNextEngineParams,
+						NULL);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -722,7 +724,8 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 				ret = action_to_next_engine_params(
 						mod_params->action,
-						&key_params.ccNextEngineParams);
+						&key_params.ccNextEngineParams,
+						NULL);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -975,8 +978,11 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 			return -EINVAL;
 		}
 
+		/* Release old header manip chain if available */
+		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 		errno = action_to_next_engine_params(mod_params->action,
-						&next_engine_params);
+						&next_engine_params,
+						&ptable->entry[entry_id].hmd);
 		if (errno < 0)
 			return errno;
 
@@ -1074,8 +1080,11 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 
 		memset(&key_params, 0, sizeof(key_params));
 
+		/* Release old header manip chain if available */
+		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 		errno = action_to_next_engine_params(mod_params->action,
-						&key_params.ccNextEngineParams);
+						&key_params.ccNextEngineParams,
+						&ptable->entry[entry_id].hmd);
 		if (errno < 0)
 			return errno;
 
@@ -1443,6 +1452,7 @@ static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
 	}
 
 	ptable->entry[entry_id].valid = 0;
+	dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 
 	int_cc_node->used--;
 
@@ -2419,7 +2429,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	int errno = 0;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry = NULL;
 	t_FmPcdCcKeyParams key_params;
-	int i = 0, k;
+	int i = 0;
+	int k, hmd;
 	uint8_t shadow_table_index;
 	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
@@ -2467,7 +2478,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	}
 
 	errno = action_to_next_engine_params(action,
-				&key_params.ccNextEngineParams);
+				&key_params.ccNextEngineParams,
+				&hmd);
 	if (errno < 0)
 		return errno;
 
@@ -2484,6 +2496,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	cls_table->entry[k].priority = priority;
 	cls_table->entry[k].entry_index =
 				(uint8_t)cls_table->int_cc_node[0].used;
+	cls_table->entry[k].hmd = hmd;
 
 	/* Calculate the position in the index management list where this entry
 	 * should go */
@@ -2632,7 +2645,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	uint8_t shadow_table_index;
 	uint64_t hash_set_index;
 	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
-	int j;
+	int j, hmd;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 	struct list_head *list_current;
 	struct dpa_cls_tbl_entry *index_entry;
@@ -2670,7 +2683,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	key_params.p_Key = key_data;
 
 	errno = action_to_next_engine_params(action,
-				&key_params.ccNextEngineParams);
+				&key_params.ccNextEngineParams,
+				&hmd);
 	if (errno < 0)
 		return errno;
 
@@ -2727,6 +2741,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	cls_table->entry[j].int_cc_node_index = (unsigned int)hash_set_index;
 	cls_table->entry[j].entry_index =
 			(uint8_t)cls_table->int_cc_node[hash_set_index].used;
+	cls_table->entry[j].hmd = hmd;
 
 	/* Calculate the position in the index management list where this entry
 	 * should go */
@@ -2813,11 +2828,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 }
 
 static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
-				t_FmPcdCcNextEngineParams *next_engine_params)
+				t_FmPcdCcNextEngineParams *next_engine_params,
+				int *hmd)
 {
 	struct dpa_cls_table *next_table;
-	struct dpa_cls_hm *hm;
-	struct dpa_cls_hm_node *hm_node;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -2827,6 +2841,9 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 	memset(next_engine_params, 0, sizeof(t_FmPcdCcNextEngineParams));
 
+	if (hmd)
+		*hmd = DPA_OFFLD_DESC_NONE;
+
 	switch (action->type) {
 	case DPA_CLS_TBL_ACTION_DROP:
 		next_engine_params->nextEngine = e_FM_PCD_DONE;
@@ -2852,41 +2869,24 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 				action->enq_params.new_fqid;
 
 		if (action->enq_params.hmd != DPA_OFFLD_DESC_NONE) {
-			/* Verify that the header manip op is valid */
-			if ((action->enq_params.hmd < 0) ||
-				(action->enq_params.hmd >=
-				hm_array.num_descriptors) ||
-				(!hm_array.object[action->enq_params.hmd])) {
-				pr_err("ERROR: %s, %s (%d): Invalid HM "
-					"descriptor (hmd=%d).\n", __FILE__,
-					__func__, __LINE__,
-					action->enq_params.hmd);
+			if (!hmd) {
+				pr_err("ERROR: %s, %s (%d): Header "
+					"manipulations are not allowed on this "
+					"action.\n", __FILE__, __func__,
+					__LINE__);
 				return -EINVAL;
 			}
-
-			hm = (struct dpa_cls_hm *)
-					hm_array.object[action->enq_params.hmd];
-
-			/*
-			 * Verify that the header manipulation op is a chain
-			 * head
-			 */
-			if (!hm->chain_head) {
-				pr_err("ERROR %s, %s (%d): Only a HM chain head "
-					"can be attached to a classifier table "
-					"entry. hmd=%d is not a chain head.\n",
-					__FILE__, __func__, __LINE__,
+			next_engine_params->h_Manip = (t_Handle)
+		dpa_classif_hm_lock_chain(action->enq_params.hmd);
+			if (!next_engine_params->h_Manip) {
+				pr_err("ERROR: %s, %s (%d): Failed to attach "
+					"HM op hmd=%d to classification "
+					"entry.", __FILE__, __func__, __LINE__,
 					action->enq_params.hmd);
 				return -EINVAL;
 			}
 
-			/*
-			 * Acquire the hm_node structure that is head of the
-			 * header manipulation chain
-			 */
-			hm_node = list_entry(hm->hm_chain,
-					struct dpa_cls_hm_node, list_node);
-			next_engine_params->h_Manip = (t_Handle)hm_node->node;
+			*hmd = action->enq_params.hmd;
 		} else
 			next_engine_params->h_Manip = NULL;
 
@@ -5920,8 +5920,12 @@ void *dpa_classif_get_static_hm_handle(int hmd)
 		return NULL;
 	}
 
-	if (!hm_array.object[hmd])
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): HM descriptor hmd=%d is not "
+			"initialized.\n", __FILE__, __func__,
+			__LINE__, hmd);
 		return NULL;
+	}
 
 	hm = hm_array.object[hmd];
 
@@ -5931,6 +5935,64 @@ void *dpa_classif_get_static_hm_handle(int hmd)
 	return hm->hm_node[0]->node;
 }
 
+void *dpa_classif_hm_lock_chain(int hmd)
+{
+	struct dpa_cls_hm *hm;
+	struct dpa_cls_hm_node *hm_node;
+
+	if (hmd == DPA_OFFLD_DESC_NONE)
+		/* Nothing to do */
+		return NULL;
+
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return NULL;
+	}
+
+	hm = hm_array.object[hmd];
+
+	/* Lock all HM nodes */
+	list_for_each_entry(hm_node, hm->hm_chain, list_node)
+		hm_node->ref++;
+
+	/*
+	 * Acquire the hm_node structure that is head of the header manipulation
+	 * chain
+	 */
+	hm_node = list_entry(hm->hm_chain, struct dpa_cls_hm_node, list_node);
+
+	return hm_node->node;
+}
+
+void dpa_classif_hm_release_chain(int hmd)
+{
+	struct dpa_cls_hm *hm;
+	struct dpa_cls_hm_node *hm_node;
+
+	if (hmd == DPA_OFFLD_DESC_NONE)
+		/* Nothing to do */
+		return;
+
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return;
+	}
+
+	hm = hm_array.object[hmd];
+
+	/* Release all HM nodes */
+	list_for_each_entry(hm_node, hm->hm_chain, list_node)
+		if (hm_node->ref)
+			hm_node->ref--;
+		else
+			pr_warn("WARNING: Unbalanced HM node release on manip "
+				"node=0x%p.\n", hm_node->node);
+}
+
 void *dpa_classif_get_frag_hm_handle(int hmd)
 {
 	struct dpa_cls_hm *hm;
@@ -5975,6 +6037,7 @@ void *dpa_classif_get_frag_hm_handle(int hmd)
 int dpa_classif_free_hm(int hmd)
 {
 	struct dpa_cls_hm *phm;
+	struct dpa_cls_hm_node *hm_node;
 
 	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
 		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
@@ -5989,6 +6052,15 @@ int dpa_classif_free_hm(int hmd)
 		/* Descriptor already free */
 		return 0;
 
+	/* Verify whether this header manipulation chain is in use */
+	hm_node = list_entry(phm->hm_chain, struct dpa_cls_hm_node, list_node);
+	if (hm_node->ref) {
+		pr_err("ERROR: %s, %s (%d): Unable to remove HM chain hmd=%d. "
+			"Chain is still used by %d entity(ies).\n", __FILE__,
+			__func__, __LINE__, hmd, hm_node->ref);
+		return -EBUSY;
+	}
+
 	if (phm->chain_head) {
 		/*
 		 * This is a header manip chain head, hence remove the entire
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 26a08cd..8829f0e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -78,6 +78,9 @@ struct dpa_cls_tbl_entry {
 	/* The priority value of this entry in the table */
 	int				priority;
 
+	/* Header manipulation descriptor associated with this entry (if any) */
+	int				hmd;
+
 	/*
 	 * Pointer to the shadow entry (if there is one) associated
 	 * with this index management entry
@@ -208,6 +211,7 @@ struct dpa_cls_descriptor_table {
 struct dpa_cls_hm_node {
 	void			*node;
 	bool			created;
+	unsigned		ref;
 	t_FmPcdManipParams	params;
 	struct list_head	list_node;
 };
@@ -326,7 +330,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
  * low level driver (FMD).
  */
 static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
-	*action, t_FmPcdCcNextEngineParams *next_engine_params);
+	*action, t_FmPcdCcNextEngineParams *next_engine_params, int *hmd);
 
 /*
  * Translates next engine parameters (from FMD) into action parameters for use
@@ -524,6 +528,16 @@ int dpa_classif_import_static_hm(void *hm, int next_hmd, int *hmd);
 void *dpa_classif_get_static_hm_handle(int hmd);
 
 /*
+ * Locks a header manipulation chain (marks as "used"). The header manipulation
+ * operations cannot be removed as long as they are locked. The function
+ * provides the FMan driver handle of the manip node which is chain head.
+ */
+void *dpa_classif_hm_lock_chain(int hmd);
+
+/* Releases a locked header manipulation chain. */
+void dpa_classif_hm_release_chain(int hmd);
+
+/*
  * Given a header manipulation object descriptor, this function searches
  * through the header manipulation chain that this object belongs to and
  * provides the FMan driver handle of the IP fragmentation header manipulation
-- 
1.7.5.4

