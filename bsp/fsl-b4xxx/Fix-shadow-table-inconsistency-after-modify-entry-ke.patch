From aa8436c40114b161d07149c3f17e88b4b2be907a Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Mar 2012 20:15:06 +0000
Subject: [PATCH 111/518] Fix shadow table inconsistency after modify entry
 key

In the [table_modify_entry_by_ref] function, once the user modifies
the key of an entry (currently this operation is possible only for
exact match tables) the associated shadow entry needs to be re-hashed
with the new key. This was not done and once the user modified the
key of an entry, the associated shadow entry could not be found
anymore (shadow table became inconsistent).

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   29 +++++++++++++++++++---
 1 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 6c4d8a3d..5550651 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -427,13 +427,14 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	t_FmPcdCcKeyParams key_params;
 	uint8_t key_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
-	uint8_t entry_index;
-	unsigned int cc_node_index;
+	uint8_t masked_key[DPA_CLS_TBL_MAXENTRYKEYSIZE];
+	uint8_t entry_index, shadow_table_index;
+	unsigned int cc_node_index, key_size;
 	int errno;
 	t_Error err;
 	struct dpa_cls_table *ptable;
 	t_Handle fm_pcd, cc_node;
-	struct list_head *shadow_list_entry;
+	struct list_head *shadow_list_entry, *new_bucket_list;
 
 	xx_sanity_check_return_value(((td >= 0) && (td < num_tables)), "td",
 		-EINVAL);
@@ -560,6 +561,26 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 
 			key	= &shadow_entry->key;
 			action	= &shadow_entry->action;
+
+			if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
+				(mod_params->type ==
+					DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) {
+				/*
+				 * The entry needs to be re-hashed with the new
+				 * key
+				 */
+			key_size = ptable->params.exact_match_params.key_size;
+				key_apply_mask(mod_params->key,
+						masked_key,
+						key_size);
+				shadow_table_index = crc8(masked_key, key_size);
+
+				new_bucket_list =
+			&ptable->shadow_table->shadow_entry[shadow_table_index];
+				list_del(&shadow_entry->list_node);
+				list_add(&shadow_entry->list_node,
+						new_bucket_list);
+			}
 		}
 
 		if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
@@ -1869,7 +1890,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	cls_table->int_cc_node[i].used++;
 
-	/* If shadow table exists, add the entry to them */
+	/* If shadow table exists, add the entry to it */
 	if (cls_table->shadow_table) {
 		shadow_entry = (struct dpa_cls_tbl_shadow_entry *)
 			xx_zalloc(sizeof(struct dpa_cls_tbl_shadow_entry));
-- 
1.7.5.4

