From 473aa4cd6a5c10ceb58b91ddd67f293b82ddc165 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 27 Feb 2013 02:49:44 +0200
Subject: [PATCH 500/518] dpaa_eth: Simplify access to percpu_priv stats

Factor out percpu_priv->stats to simplify the code a bit.
So far, this change only affects the private data paths (i.e. not
shared or MAC-less).

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    |   13 ++++++---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |   10 +++---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   30 +++++++++++-----------
 3 files changed, 28 insertions(+), 25 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 0840635..ea19160 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1659,7 +1659,7 @@ static int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 		goto l3_l4_csum_failed;
 	}
 
-	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+	err = dpa_xmit(priv, &percpu_priv->stats, queue_mapping, &fd);
 
 l3_l4_csum_failed:
 bpools_too_small_error:
@@ -1870,6 +1870,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct dpa_priv_s	*priv;
 	struct qm_fd		 fd;
 	struct dpa_percpu_priv_s *percpu_priv;
+	struct net_device_stats *percpu_stats;
 	int queue_mapping;
 	int err;
 
@@ -1881,6 +1882,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	priv = netdev_priv(net_dev);
 	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	percpu_stats = &percpu_priv->stats;
 
 	clear_fd(&fd);
 	queue_mapping = dpa_get_queue_mapping(skb);
@@ -1890,7 +1892,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
 		if (unlikely(!skb_new)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			kfree_skb(skb);
 			goto done;
 		}
@@ -1927,13 +1929,13 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		 * it's more efficient to unshare it and then use the new skb */
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (unlikely(!skb)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			goto done;
 		}
 		err = skb_to_contig_fd(priv, percpu_priv, skb, &fd);
 	}
 	if (unlikely(err < 0)) {
-		percpu_priv->stats.tx_errors++;
+		percpu_stats->tx_errors++;
 		goto fd_create_failed;
 	}
 
@@ -1946,7 +1948,8 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		percpu_priv->tx_returned++;
 	}
 
-	if (unlikely(dpa_xmit(priv, percpu_priv, queue_mapping, &fd) < 0))
+	if (unlikely(dpa_xmit(priv, percpu_stats, queue_mapping,
+		&fd) < 0))
 		goto xmit_failed;
 
 	net_dev->trans_start = jiffies;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 371c6be..7456c74 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -494,7 +494,7 @@ static inline void clear_fd(struct qm_fd *fd)
 }
 
 static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
-			struct dpa_percpu_priv_s *percpu, int queue,
+			struct net_device_stats *percpu_stats, int queue,
 			struct qm_fd *fd)
 {
 	int err, i;
@@ -519,13 +519,13 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 
 	if (unlikely(err < 0)) {
 		/* TODO differentiate b/w -EBUSY (EQCR full) and other codes? */
-		percpu->stats.tx_errors++;
-		percpu->stats.tx_fifo_errors++;
+		percpu_stats->tx_errors++;
+		percpu_stats->tx_fifo_errors++;
 		return err;
 	}
 
-	percpu->stats.tx_packets++;
-	percpu->stats.tx_bytes += dpa_fd_length(fd);
+	percpu_stats->tx_packets++;
+	percpu_stats->tx_bytes += dpa_fd_length(fd);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 9f189db..75463e4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -435,6 +435,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	dma_addr_t addr = qm_fd_addr(fd);
 	u32 fd_status = fd->status;
 	unsigned int skb_len;
+	struct net_device_stats *percpu_stats = &percpu_priv->stats;
 	int use_gro = net_dev->features & NETIF_F_GRO;
 
 	if (unlikely(fd_status & FM_FD_STAT_ERRORS) != 0) {
@@ -442,7 +443,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
 					fd_status & FM_FD_STAT_ERRORS);
 
-		percpu_priv->stats.rx_errors++;
+		percpu_stats->rx_errors++;
 		goto _release_frame;
 	}
 
@@ -457,7 +458,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			if (netif_msg_rx_err(priv) && net_ratelimit())
 				cpu_netdev_err(net_dev,
 						"Could not alloc skb\n");
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto _release_frame;
 		}
 	}
@@ -484,13 +485,13 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			 * counters to track this event.
 			 */
 			percpu_priv->l4_hxs_errors++;
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto drop_bad_frame;
 		}
 	} else if (fd->format == qm_fd_sg) {
 		if (unlikely(sg_fd_to_skb(priv, fd, skb, &use_gro))) {
 			percpu_priv->l4_hxs_errors++;
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto drop_bad_frame;
 		}
 	} else
@@ -502,7 +503,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	/* IP Reassembled frames are allowed to be larger than MTU */
 	if (unlikely(dpa_check_rx_mtu(skb, net_dev->mtu) &&
 		!(fd_status & FM_FD_IPR))) {
-		percpu_priv->stats.rx_dropped++;
+		percpu_stats->rx_dropped++;
 		goto drop_bad_frame;
 	}
 
@@ -513,16 +514,16 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 		gro_result = napi_gro_receive(&percpu_priv->napi, skb);
 		if (unlikely(gro_result == GRO_DROP)) {
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto packet_dropped;
 		}
 	} else if (unlikely(netif_receive_skb(skb) == NET_RX_DROP)) {
-		percpu_priv->stats.rx_dropped++;
+		percpu_stats->rx_dropped++;
 		goto packet_dropped;
 	}
 
-	percpu_priv->stats.rx_packets++;
-	percpu_priv->stats.rx_bytes += skb_len;
+	percpu_stats->rx_packets++;
+	percpu_stats->rx_bytes += skb_len;
 
 packet_dropped:
 	return;
@@ -583,7 +584,6 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 }
 
 static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
-			      struct dpa_percpu_priv_s *percpu_priv,
 			      struct sk_buff *skb, struct qm_fd *fd)
 {
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
@@ -721,7 +721,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	if (skb_is_nonlinear(skb)) {
 		/* Just create a S/G fd based on the skb */
-		err = skb_to_sg_fd(priv, NULL, skb, &fd);
+		err = skb_to_sg_fd(priv, skb, &fd);
 		percpu_priv->tx_frag_skbuffs++;
 	} else {
 		/*
@@ -735,7 +735,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
 			if (unlikely(!skb_new)) {
 				dev_kfree_skb(skb);
-				percpu_priv->stats.tx_errors++;
+				percpu_stats->tx_errors++;
 				return NETDEV_TX_OK;
 			}
 			dev_kfree_skb(skb);
@@ -748,7 +748,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		 */
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (unlikely(!skb)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			return NETDEV_TX_OK;
 		}
 
@@ -756,12 +756,12 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		err = skb_to_contig_fd(priv, skb, &fd);
 	}
 	if (unlikely(err < 0)) {
-		percpu_priv->stats.tx_errors++;
+		percpu_stats->tx_errors++;
 		dev_kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
 
-	if (unlikely(dpa_xmit(priv, percpu_priv, queue_mapping, &fd) < 0))
+	if (unlikely(dpa_xmit(priv, percpu_stats, queue_mapping, &fd) < 0))
 		goto xmit_failed;
 
 	net_dev->trans_start = jiffies;
-- 
1.7.5.4

