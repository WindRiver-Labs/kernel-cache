From df8dc9d593c2088f6de251269f301cf404de26f5 Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Fri, 23 Mar 2012 00:53:59 +0000
Subject: [PATCH 129/518] Added fixes in system usecase

Added function to extract error queue from eth dev
Added buffer pools ids from userspace (scratch pool for fragmentation, sgbpid for reassembly)
Eliminated deprecated parameters due to FMD/LLD update

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/dip_init.c    |    3 +-
 .../staging/fsl_dpa_offload/usecases/fm_utils.c    |   76 +++++++++++++++++++-
 .../staging/fsl_dpa_offload/usecases/fmc_config.c  |   18 +++--
 drivers/staging/fsl_dpa_offload/usecases/main.c    |    2 +-
 drivers/staging/fsl_dpa_offload/usecases/utils.h   |    2 +
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   35 ++-------
 6 files changed, 96 insertions(+), 40 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/dip_init.c b/drivers/staging/fsl_dpa_offload/usecases/dip_init.c
index ff9ff29..f9d1028 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/dip_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/dip_init.c
@@ -37,6 +37,7 @@
 #include "utils.h"
 #include "dip_init.h"
 #include "ports_conf.h"
+#include "pools.h"
 
 
 static unsigned int start_fqid;
@@ -70,7 +71,7 @@ t_Error DipInit(void)
 		goto out;
 	}
 
-	dipParams.ipf_bpid		= scratchBpid;
+	dipParams.ipf_bpid		= bpids[0];
 	dipParams.qm_sec_ch		= qm_channel_caam;
 
 	/* return required PCD handles to DIP initialization */
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
index 4fa5c8b..0621b87 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
@@ -144,7 +144,79 @@ uint64_t get_mac_dev(int fm_id, int port_id)
 	}
 
 err:
-	return -1;
+	return 0;
+}
+
+/*
+	Return the error queue from eth port
+	@fm_idx : FMAN index (0/1)
+	@port_idx : port index
+*/
+uint32_t get_tx_err_fqid(int fm_idx, int port_idx)
+{
+	struct device_node *eth_dev_temp = NULL, *eth_dev = NULL,
+	*mac_node = NULL, *fman_node = NULL;
+	const phandle *mac_phandle, *fm_cell_idx, *mac_cell_idx;
+	size_t lenp;
+	const uint32_t *regs_addr;
+	uint64_t regs_size;
+	uint64_t phys_addr;
+	uint32_t *eth_all_queues;
+	uint32_t queues_count;
+	uint32_t crt_fqid_base;
+	uint32_t crt_fq_count;
+	int fq_idx;
+
+	eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+			"fsl,dpa-ethernet-init");
+	while (eth_dev != NULL) {
+		mac_phandle = of_get_property(eth_dev, "fsl,fman-mac", &lenp);
+		if (unlikely(mac_phandle == NULL))
+			goto err;
+
+		mac_node = of_find_node_by_phandle(*mac_phandle);
+		if (unlikely(mac_node == NULL))
+			goto err;
+
+		fman_node = of_get_parent(mac_node);
+		if (!fman_node)
+			goto err;
+
+		fm_cell_idx = of_get_property(fman_node, "cell-index", &lenp);
+		if (!fm_cell_idx)
+			goto err;
+
+		mac_cell_idx = of_get_property(mac_node, "cell-index", &lenp);
+		if (!mac_cell_idx)
+			goto err;
+
+		eth_all_queues = (uint32_t *)of_get_property(eth_dev,
+			"fsl,qman-frame-queues-tx", &lenp);
+		if (eth_all_queues == NULL)
+			goto err;
+
+		/* Check that the error and default FQs are there */
+		BUG_ON(lenp % (2 * sizeof(*eth_all_queues)));
+		queues_count = lenp / (2 * sizeof(*eth_all_queues));
+
+		if (queues_count != 2)
+			goto err;
+
+		fq_idx = 0;
+
+		/* Error FQID - must be present */
+		crt_fqid_base = eth_all_queues[fq_idx++];
+		crt_fq_count = eth_all_queues[fq_idx++];
+		if ((*mac_cell_idx == port_idx) && (*fm_cell_idx == fm_idx))
+			return crt_fqid_base;
+
+		eth_dev_temp = eth_dev;
+		eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+				"fsl,dpa-ethernet-init");
+	}
+
+err:
+	return 0;
 }
 
 /*
@@ -159,7 +231,7 @@ int config_loopback(int fm_id, int port_id)
 	u32 val;
 
 	mac_phys_addr = get_mac_dev(fm_id, port_id);
-	if (mac_phys_addr <= 0)
+	if (mac_phys_addr == 0)
 		return -1;
 
 	addr = (uintptr_t)ioremap((mac_phys_addr), 0x1000);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c b/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
index 7547ba3..4bb74d4 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc_config.c
@@ -46,6 +46,7 @@
 #include "dip_init.h"
 #include <linux/fsl_dpa_compat.h>
 #include "softparse.h"
+#include "pools.h"
 
 static t_Handle pcds[2];
 static t_Handle *ports[10];
@@ -135,7 +136,7 @@ e_ErrorType fmc_config(struct dpa_ipsec_params *dipParams)
 		manipParam.fragOrReasmParams.ipFragParams.
 				sizeForFragmentation = mtu_post_enc;
 		manipParam.fragOrReasmParams.ipFragParams.
-				scratchBpid = dipParams->ipf_bpid;
+				scratchBpid = bpids[0];
 		manips[0] = FM_PCD_ManipSetNode(pcds[0], &manipParam);
 		if (manips[0] == NULL) {
 			pr_err("Could not set Manip handler for Fragmentation!");
@@ -661,14 +662,16 @@ e_ErrorType fmc_config(struct dpa_ipsec_params *dipParams)
 	manipParam.fragOrReasm = TRUE;
 	manipParam.fragOrReasmParams.frag = FALSE;
 	manipParam.fragOrReasmParams.hdr = HEADER_TYPE_IPv4;
-	manipParam.fragOrReasmParams.extBufPoolIndx = 9;
+	manipParam.fragOrReasmParams.ipReasmParams.dataMemId = 0;
+	manipParam.fragOrReasmParams.ipReasmParams.dataLiodnOffset = 0;
+	manipParam.fragOrReasmParams.ipReasmParams.sgBpid = bpids[1];
 	manipParam.fragOrReasmParams.ipReasmParams.
 				maxNumFramesInProcess = 1024;
 	manipParam.fragOrReasmParams.
 				ipReasmParams.
 		timeOutMode = e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG;
 	manipParam.fragOrReasmParams.
-		ipReasmParams.fqidForTimeOutFrames = 473;
+		ipReasmParams.fqidForTimeOutFrames = get_tx_err_fqid(FM, UL_RX);
 	manipParam.fragOrReasmParams.
 		ipReasmParams.
 		numOfFramesPerHashEntry =  e_FM_PCD_MANIP_EIGHT_WAYS_HASH;
@@ -912,12 +915,14 @@ e_ErrorType fmc_config(struct dpa_ipsec_params *dipParams)
 	manipParam.fragOrReasm = TRUE;
 	manipParam.fragOrReasmParams.frag = FALSE;
 	manipParam.fragOrReasmParams.hdr = HEADER_TYPE_IPv4;
-	manipParam.fragOrReasmParams.extBufPoolIndx = 9;
+	manipParam.fragOrReasmParams.ipReasmParams.dataMemId = 0;
+	manipParam.fragOrReasmParams.ipReasmParams.dataLiodnOffset = 0;
+	manipParam.fragOrReasmParams.ipReasmParams.sgBpid = bpids[2];
 	manipParam.fragOrReasmParams.ipReasmParams.maxNumFramesInProcess = 1024;
 	manipParam.fragOrReasmParams.ipReasmParams.
 			timeOutMode = e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG;
 	manipParam.fragOrReasmParams.ipReasmParams.
-				fqidForTimeOutFrames = 472;
+			fqidForTimeOutFrames =  get_tx_err_fqid(FM, DL_RX);
 	manipParam.fragOrReasmParams.ipReasmParams.
 		numOfFramesPerHashEntry =  e_FM_PCD_MANIP_EIGHT_WAYS_HASH;
 	manipParam.fragOrReasmParams.ipReasmParams.
@@ -925,9 +930,6 @@ e_ErrorType fmc_config(struct dpa_ipsec_params *dipParams)
 	manipParam.fragOrReasmParams.ipReasmParams.
 			relativeSchemeId[0] = relativeSchemeId++;
 	manipParam.fragOrReasmParams.ipReasmParams.minFragSize[0] = 0;
-	manipParam.fragOrReasmParams.ipReasmParams.
-			liodnOffset = rx_port->settings.param.
-					specificParams.rxParams.liodnOffset;
 
 	manips[manipId] = FM_PCD_ManipSetNode(pcds[0], &manipParam);
 	if (manips[manipId] == 0)
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
index 64fd499..e610f75 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/main.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/main.c
@@ -74,7 +74,7 @@ MODULE_PARM_DESC(eth_rx_fqid, "\tEthernet tap interface Rx FQID to use");
 /* USDPAA buffer pools ids and references */
 /* BMAN has maximum 64 pools - USDPAA bpid is an index in this array */
 struct bman_pool *usdpaa_pools[64];
-int bpids[64] = {7, 8, 9};
+int bpids[64] = {4, 5, 6, 9};
 static int bpids_argc = 3;
 module_param_array(bpids, int, &bpids_argc, 0);
 MODULE_PARM_DESC(bpids, "\tBuffer pools ids used by USDPAA app");
diff --git a/drivers/staging/fsl_dpa_offload/usecases/utils.h b/drivers/staging/fsl_dpa_offload/usecases/utils.h
index 8be1f7b..cca2731 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/utils.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/utils.h
@@ -94,6 +94,8 @@ int config_loopback(int fm_id, int port_id);
 
 int create_scratch_pool(void);
 
+uint32_t get_tx_err_fqid(int fm_idx, int port_idx);
+
 t_LnxWrpFmDev *get_fm(int fm_idx);
 
 void dump_xfrm_sa(struct xfrm_state *x);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 1367920..7fa6cee 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -367,7 +367,7 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 				saParams.start_seq_num = 1;
 				saParams.l2_hdr_size = ETH_HLEN;
 				saParams.sa_wqid = 7;
-				saParams.sa_bpid = bpids[2];
+				saParams.sa_bpid = bpids[3];
 				/* FIXME - support other algorithms too */
 				saParams.crypto_params.alg_suite =
 				    DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_SHA_160;
@@ -483,7 +483,7 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 				    DPA_IPSEC_ADDR_T_IPv4;
 				saParams.sa_in_params.dest_addr.ipv4.word =
 				    x->id.daddr.a4;
-				saParams.sa_bpid = bpids[2];
+				saParams.sa_bpid = bpids[3];
 
 				fm = get_fm(FM);
 				if (!fm) {
@@ -493,37 +493,16 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 					return err;
 				}
 
-				/* DL POST SEC */
-				memset(&cls_tbl_params, 0,
-				       sizeof(cls_tbl_params));
-				cls_tbl_params.fm_pcd = fm->h_PcdDev;
-				cls_tbl_params.cc_node = h_CcNodeInPostDec;
-				cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
-				cls_tbl_params.entry_mgmt =
-				    DPA_CLS_TBL_MANAGE_BY_REF;
-				/* FIXME: DL POST SEC
-				classification keys number */
-				cls_tbl_params.exact_match_params.entries_cnt =
-				    1;
-				/* FIXME: DL POST SEC
-				classification keys size */
-				cls_tbl_params.exact_match_params.key_size = 2;
-				err =
-				    dpa_classif_table_create
-				    (&cls_tbl_params, &cls_td);
-				if (err < 0) {
-					pr_info("%s: Error creating out SA lookup classif table\n",
-					     __func__);
-					return err;
-				}
 
 				memset(&def_sa_action, 0,
 				       sizeof(def_sa_action));
 				def_sa_action.type =
-				    DPA_CLS_TBL_ACTION_NEXT_TABLE;
+						DPA_CLS_TBL_ACTION_ENQ;
 				def_sa_action.enable_statistics = FALSE;
-				def_sa_action.next_table_params.next_td =
-				    cls_td;
+				def_sa_action.enq_params.new_fqid =
+								DL_GTP_QUEUE;
+				def_sa_action.enq_params.override_fqid = TRUE;
+
 				saParams.sa_in_params.post_ipsec_action =
 				    def_sa_action;
 				saParams.sa_in_params.policy_miss_fqid =
-- 
1.7.5.4

