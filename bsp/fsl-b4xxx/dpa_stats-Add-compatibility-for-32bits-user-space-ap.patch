From 93250d2f2473d1af9cedb26bea914dbd7c4f7aa0 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Thu, 25 Oct 2012 23:13:36 +0000
Subject: [PATCH 335/518] dpa_stats: Add compatibility for 32bits user space
 apps + 64bits kernel mode

Rendered ioctl command management compatible to 32 bits user
space applications when kernel is compiled for 64 bit
architectures.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h |  208 ++++-
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c   | 1010 ++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h   |    5 +
 3 files changed, 1199 insertions(+), 24 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
index f77cc80..52f9578 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats_ioctl.h
@@ -70,27 +70,221 @@ struct ioc_dpa_stats_cnt_request_params {
 	dpa_stats_request_cb request_done;
 };
 
+#ifdef CONFIG_COMPAT
+struct dpa_stats_compat_params {
+	unsigned int max_counters;
+	compat_uptr_t storage_area;
+	unsigned int storage_area_len;
+};
+
+struct compat_ioc_dpa_stats_params {
+	struct dpa_stats_compat_params stats_params;
+	int dpa_stats_id;
+};
+
+struct dpa_stats_compat_cnt_reass {
+	compat_uptr_t reass;
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cnt_frag {
+	compat_uptr_t frag;
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cnt_plcr {
+	compat_uptr_t plcr;
+	unsigned int cnt_sel;
+};
+
+struct compat_ioc_dpa_offld_lookup_key {
+	compat_uptr_t byte;
+	compat_uptr_t mask;
+	uint8_t size;
+};
+
+struct dpa_stats_compat_cnt_classif_tbl {
+	int td;
+	struct compat_ioc_dpa_offld_lookup_key key;
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cnt_classif_node {
+	compat_uptr_t cc_node;
+	enum dpa_stats_classif_node_type ccnode_type;
+	struct compat_ioc_dpa_offld_lookup_key key;
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cnt_params {
+	enum dpa_stats_cnt_type type;
+	union {
+		struct dpa_stats_cnt_eth eth_params;
+		struct dpa_stats_compat_cnt_reass reass_params;
+		struct dpa_stats_compat_cnt_frag frag_params;
+		struct dpa_stats_compat_cnt_plcr plcr_params;
+		struct dpa_stats_compat_cnt_classif_tbl classif_tbl_params;
+		struct dpa_stats_compat_cnt_classif_node classif_node_params;
+		struct dpa_stats_cnt_ipsec ipsec_params;
+		struct dpa_stats_cnt_traffic_mng traffic_mng_params;
+	};
+};
+
+struct compat_ioc_dpa_stats_cnt_params {
+	int stats_id;
+	struct dpa_stats_compat_cnt_params cnt_params;
+	int cnt_id;
+};
+
+struct dpa_stats_compat_cls_cnt_eth {
+	compat_uptr_t src;
+	enum dpa_stats_cnt_eth_sel cnt_sel;
+};
+
+struct dpa_stats_compat_cls_cnt_classif_tbl {
+	int td;
+	enum dpa_stats_classif_key_type   key_type;
+	union {
+		compat_uptr_t keys;
+		compat_uptr_t pairs;
+	};
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cls_cnt_classif_node {
+	compat_uptr_t cc_node;
+	enum dpa_stats_classif_node_type ccnode_type;
+	compat_uptr_t keys;
+	unsigned int cnt_sel;
+};
+
+struct dpa_stats_compat_cls_cnt_ipsec {
+	compat_uptr_t sa_id;
+	enum dpa_stats_cnt_sel cnt_sel;
+};
+
+struct dpa_stats_compat_cls_cnt_traffic_mng {
+	enum dpa_stats_cnt_traffic_mng_src src;
+	compat_uptr_t src_id;
+	enum dpa_stats_cnt_sel cnt_sel;
+};
+
+struct dpa_stats_compat_cls_cnt_params {
+	unsigned int class_members;
+	enum dpa_stats_cnt_type type;
+	union {
+		struct dpa_stats_compat_cls_cnt_eth eth_params;
+		struct dpa_stats_compat_cnt_reass reass_params;
+		struct dpa_stats_compat_cnt_frag frag_params;
+		struct dpa_stats_compat_cnt_plcr plcr_params;
+		struct dpa_stats_compat_cls_cnt_classif_tbl classif_tbl_params;
+		struct dpa_stats_compat_cls_cnt_classif_node ccnode_params;
+		struct dpa_stats_compat_cls_cnt_ipsec ipsec_params;
+		struct dpa_stats_compat_cls_cnt_traffic_mng traffic_mng_params;
+	};
+};
+
+struct compat_ioc_dpa_stats_cls_cnt_params {
+	int stats_id;
+	struct dpa_stats_compat_cls_cnt_params cnt_params;
+	int cnt_id;
+};
+
+struct compat_ioc_dpa_offld_lookup_key_pair {
+	struct compat_ioc_dpa_offld_lookup_key first_key;
+	struct compat_ioc_dpa_offld_lookup_key second_key;
+};
+
+struct dpa_stats_compat_cls_member_params {
+	enum dpa_stats_cls_member_type type;
+	union {
+		struct compat_ioc_dpa_offld_lookup_key key;
+		struct compat_ioc_dpa_offld_lookup_key_pair pair;
+		int sa_id;
+	};
+};
+
+struct compat_ioc_dpa_stats_cls_member_params {
+	int cnt_id;
+	struct dpa_stats_compat_cls_member_params params;
+	int member_index;
+};
+
+struct dpa_stats_compat_cnt_request_params {
+	compat_uptr_t cnts_ids;
+	unsigned int cnts_ids_len;
+	bool reset_cnts;
+	unsigned int storage_area_offset;
+};
+
+struct compat_ioc_dpa_stats_cnt_request_params {
+	struct dpa_stats_compat_cnt_request_params req_params;
+	int cnts_len;
+	compat_uptr_t request_done;
+};
+
+struct compat_ioc_dpa_stats_cnts_reset_params {
+	compat_uptr_t cnts_ids;
+	unsigned int cnts_ids_len;
+};
+
+struct compat_dpa_stats_event_params {
+	int		dpa_stats_id;
+	unsigned int	storage_area_offset;
+	unsigned int	cnts_written;
+	int		bytes_written;
+	compat_uptr_t request_done;
+};
+#endif
 #define DPA_STATS_IOC_MAGIC				0xde
 
-#define DPA_STATS_IOC_INIT				\
+#define DPA_STATS_IOC_INIT						\
 	_IOWR(DPA_STATS_IOC_MAGIC, 0, struct ioc_dpa_stats_params)
 
-#define DPA_STATS_IOC_FREE				\
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_INIT					\
+	_IOWR(DPA_STATS_IOC_MAGIC, 0, struct compat_ioc_dpa_stats_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_STATS_IOC_FREE						\
 	_IOW(DPA_STATS_IOC_MAGIC, 1, int)
 
-#define DPA_STATS_IOC_CREATE_COUNTER			\
+#define DPA_STATS_IOC_CREATE_COUNTER					\
 	_IOWR(DPA_STATS_IOC_MAGIC, 2, struct ioc_dpa_stats_cnt_params)
 
-#define DPA_STATS_IOC_CREATE_CLASS_COUNTER		\
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_CREATE_COUNTER				\
+	_IOWR(DPA_STATS_IOC_MAGIC, 2, struct compat_ioc_dpa_stats_cnt_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_STATS_IOC_CREATE_CLASS_COUNTER				\
 	_IOWR(DPA_STATS_IOC_MAGIC, 3, struct ioc_dpa_stats_cls_cnt_params)
 
-#define DPA_STATS_IOC_MODIFY_CLASS_COUNTER		\
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_CREATE_CLASS_COUNTER			\
+	_IOWR(DPA_STATS_IOC_MAGIC, 3,					\
+				struct compat_ioc_dpa_stats_cls_cnt_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_STATS_IOC_MODIFY_CLASS_COUNTER				\
 	_IOWR(DPA_STATS_IOC_MAGIC, 4, struct ioc_dpa_stats_cls_member_params)
 
-#define DPA_STATS_IOC_REMOVE_COUNTER			\
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_MODIFY_CLASS_COUNTER			\
+	_IOWR(DPA_STATS_IOC_MAGIC, 4,					\
+				struct compat_ioc_dpa_stats_cls_member_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_STATS_IOC_REMOVE_COUNTER					\
 	_IOW(DPA_STATS_IOC_MAGIC, 5, int)
 
-#define DPA_STATS_IOC_GET_COUNTERS			 \
+#define DPA_STATS_IOC_GET_COUNTERS					\
 	_IOWR(DPA_STATS_IOC_MAGIC, 6, struct ioc_dpa_stats_cnt_request_params)
 
+#ifdef CONFIG_COMPAT
+#define DPA_STATS_IOC_COMPAT_GET_COUNTERS				\
+	_IOWR(DPA_STATS_IOC_MAGIC, 6,					\
+				struct compat_ioc_dpa_stats_cnt_request_params)
+#endif
+
 #endif /* __DPA_STATS_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index f0e439c..1712af5 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -46,12 +46,21 @@
 
 #include "dpa_compat.h"
 
+#include "lnxwrp_fm.h"
+#include "fm_port_ioctls.h"
+#ifdef CONFIG_COMPAT
+#include "lnxwrp_ioctls_fm_compat.h"
+#endif /* CONFIG_COMPAT */
+
 static const struct file_operations dpa_stats_fops = {
 	.owner = THIS_MODULE,
 	.open = wrp_dpa_stats_open,
 	.read = wrp_dpa_stats_read,
 	.write = NULL,
 	.unlocked_ioctl = wrp_dpa_stats_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl		= wrp_dpa_stats_compat_ioctl,
+#endif /* CONFIG_COMPAT */
 	.release = wrp_dpa_stats_release
 };
 
@@ -82,6 +91,68 @@ static int copy_class_members(void *objs, unsigned int size, void *dst);
 static long store_get_cnts_async_params(
 		struct ioc_dpa_stats_cnt_request_params *kprm);
 
+#ifdef CONFIG_COMPAT
+static long wrp_dpa_stats_do_compat_ioctl(struct file *filp, unsigned int cmd,
+		unsigned long args);
+
+static int copy_key_descriptor_compatcpy(struct dpa_offload_lookup_key *kparam,
+		const struct compat_ioc_dpa_offld_lookup_key *uparam);
+
+static void dpa_stats_init_compatcpy(struct ioc_dpa_stats_params *kparam,
+		struct compat_ioc_dpa_stats_params *uparam);
+
+static void dpa_stats_reass_cnt_compatcpy(struct dpa_stats_cnt_reass *kprm,
+		struct dpa_stats_compat_cnt_reass *uprm);
+
+static void dpa_stats_frag_cnt_compatcpy(struct dpa_stats_cnt_frag *kprm,
+		struct dpa_stats_compat_cnt_frag *uprm);
+
+static void dpa_stats_plcr_cnt_compatcpy(struct dpa_stats_cnt_plcr *kprm,
+		struct dpa_stats_compat_cnt_plcr *uprm);
+
+static long dpa_stats_tbl_cnt_compatcpy(struct dpa_stats_cnt_classif_tbl *kprm,
+		struct dpa_stats_compat_cnt_classif_tbl *uprm);
+
+static long dpa_stats_ccnode_cnt_compatcpy(
+		struct dpa_stats_cnt_classif_node *kprm,
+		struct dpa_stats_compat_cnt_classif_node *uprm);
+
+static long dpa_stats_eth_cls_compatcpy(
+		struct dpa_stats_cls_cnt_eth *kprm,
+		struct dpa_stats_compat_cls_cnt_eth *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_reass_cls_compatcpy(
+		struct dpa_stats_cls_cnt_reass *kprm,
+		struct dpa_stats_compat_cnt_reass *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_frag_cls_compatcpy(
+		struct dpa_stats_cls_cnt_frag *kprm,
+		struct dpa_stats_compat_cnt_frag *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_plcr_cls_compatcpy(
+		struct dpa_stats_cls_cnt_plcr *kprm,
+		struct dpa_stats_compat_cnt_plcr *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_tbl_cls_compatcpy(
+		struct dpa_stats_cls_cnt_classif_tbl *kprm,
+		struct dpa_stats_compat_cls_cnt_classif_tbl *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_ccnode_cls_compatcpy(
+		struct dpa_stats_cls_cnt_classif_node *kprm,
+		struct dpa_stats_compat_cls_cnt_classif_node *uprm,
+		uint32_t cls_members);
+
+static long dpa_stats_ipsec_cls_compatcpy(
+		struct dpa_stats_cls_cnt_ipsec *kprm,
+		struct dpa_stats_compat_cls_cnt_ipsec *uprm,
+		uint32_t cls_members);
+#endif
+
 int wrp_dpa_stats_init(void)
 {
 	/* Cannot initialize the wrapper twice */
@@ -125,12 +196,78 @@ int wrp_dpa_stats_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+long wrp_dpa_stats_compat_ioctl(struct file *filp, unsigned int	cmd,
+				unsigned long args)
+{
+	return wrp_dpa_stats_do_compat_ioctl(filp, cmd, args);
+}
+#endif /* CONFIG_COMPAT */
+
 long wrp_dpa_stats_ioctl(struct file *filp, unsigned int cmd,
 			    unsigned long args)
 {
 	return wrp_dpa_stats_do_ioctl(filp, cmd, args);
 }
 
+#ifdef CONFIG_COMPAT
+ssize_t wrp_dpa_stats_read(struct file *file,
+				char *buf, size_t count, loff_t *off)
+{
+	struct dpa_stats_event  *event;
+	struct compat_dpa_stats_event_params ev_prm;
+	size_t      c = 0;
+
+	/* Make sure that the size of the buffer requested by the user is
+	 * at least the size of an event  */
+	if (count < sizeof(struct compat_dpa_stats_event_params))
+		return -EINVAL;
+
+	/* Dequeue first event by using a blocking call */
+	event = wrp_dpa_stats_dequeue_event(&wrp_dpa_stats.ev_queue, 0);
+
+	while (event != NULL) {
+		memset(&ev_prm, 0,
+				sizeof(struct compat_dpa_stats_event_params));
+
+		if (event->params.bytes_written > 0) {
+			if (copy_to_user((wrp_dpa_stats.us_mem +
+					event->params.storage_area_offset),
+					(wrp_dpa_stats.k_mem +
+					event->params.storage_area_offset),
+					event->params.bytes_written)) {
+				pr_err("Couldn't copy counters values to storage area\n");
+				return -EFAULT;
+			}
+		}
+
+		ev_prm.bytes_written = event->params.bytes_written;
+		ev_prm.cnts_written = event->params.cnts_written;
+		ev_prm.dpa_stats_id = event->params.dpa_stats_id;
+		ev_prm.storage_area_offset = event->params.storage_area_offset;
+		ev_prm.request_done = ptr_to_compat(event->params.request_done);
+
+		if (copy_to_user(buf+c, &ev_prm, sizeof(ev_prm)) != 0) {
+			kfree(event);
+			return -EFAULT;
+		}
+
+		kfree(event);
+
+		count   -= sizeof(struct compat_dpa_stats_event_params);
+		c       += sizeof(struct compat_dpa_stats_event_params);
+
+		if (count < sizeof(struct compat_dpa_stats_event_params))
+			break;
+
+		/* For subsequent events, don't block */
+		event = wrp_dpa_stats_dequeue_event(
+				&wrp_dpa_stats.ev_queue, O_NONBLOCK);
+	}
+
+	return c;
+}
+#else
 ssize_t wrp_dpa_stats_read(struct file *file,
 				char *buf, size_t count, loff_t *off)
 {
@@ -178,6 +315,7 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 
 	return c;
 }
+#endif
 
 static void wrp_dpa_stats_event_queue_init(
 		struct dpa_stats_event_queue *event_queue)
@@ -460,6 +598,92 @@ static int do_ioctl_stats_create_counter(void *args)
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static int do_ioctl_stats_compat_create_counter(void *args)
+{
+	struct ioc_dpa_stats_cnt_params kprm;
+	struct compat_ioc_dpa_stats_cnt_params uprm;
+	long ret = 0;
+
+	if (copy_from_user(&uprm, args, sizeof(uprm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	memset(&kprm, 0, sizeof(struct ioc_dpa_stats_cnt_params));
+	kprm.stats_id = uprm.stats_id;
+	kprm.cnt_params.type = uprm.cnt_params.type;
+
+	switch (kprm.cnt_params.type) {
+	case DPA_STATS_CNT_ETH:
+		memcpy(&kprm.cnt_params.eth_params,
+			&uprm.cnt_params.eth_params,
+			sizeof(struct dpa_stats_cnt_eth));
+		break;
+	case DPA_STATS_CNT_REASS:
+		dpa_stats_reass_cnt_compatcpy(&kprm.cnt_params.reass_params,
+				&uprm.cnt_params.reass_params);
+		break;
+	case DPA_STATS_CNT_FRAG:
+		dpa_stats_frag_cnt_compatcpy(&kprm.cnt_params.frag_params,
+				&uprm.cnt_params.frag_params);
+		break;
+	case DPA_STATS_CNT_POLICER:
+		dpa_stats_plcr_cnt_compatcpy(&kprm.cnt_params.plcr_params,
+				&uprm.cnt_params.plcr_params);
+		break;
+	case DPA_STATS_CNT_CLASSIF_TBL:
+		ret = dpa_stats_tbl_cnt_compatcpy(
+				&kprm.cnt_params.classif_tbl_params,
+				&uprm.cnt_params.classif_tbl_params);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_CLASSIF_NODE:
+		ret = dpa_stats_ccnode_cnt_compatcpy(
+				&kprm.cnt_params.classif_node_params,
+				&uprm.cnt_params.classif_node_params);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_IPSEC:
+		memcpy(&kprm.cnt_params.ipsec_params,
+				&uprm.cnt_params.ipsec_params,
+				sizeof(struct dpa_stats_cnt_ipsec));
+		break;
+	case DPA_STATS_CNT_TRAFFIC_MNG:
+		memcpy(&kprm.cnt_params.traffic_mng_params,
+				&uprm.cnt_params.traffic_mng_params,
+				sizeof(struct dpa_stats_cnt_traffic_mng));
+		break;
+	default:
+		break;
+	}
+
+	ret = dpa_stats_create_counter(kprm.stats_id,
+			&kprm.cnt_params, &kprm.cnt_id);
+	if (ret < 0)
+		return ret;
+
+	uprm.cnt_id = kprm.cnt_id;
+
+	if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
+		pr_err("Could not copy to user the Counter ID");
+		ret = -EINVAL;
+	}
+
+	if (kprm.cnt_params.type == DPA_STATS_CNT_CLASSIF_NODE) {
+		kfree(kprm.cnt_params.classif_node_params.key.byte);
+		kfree(kprm.cnt_params.classif_node_params.key.mask);
+	} else if (kprm.cnt_params.type == DPA_STATS_CNT_CLASSIF_TBL) {
+		kfree(kprm.cnt_params.classif_tbl_params.key.byte);
+		kfree(kprm.cnt_params.classif_tbl_params.key.mask);
+	}
+
+	return ret;
+}
+#endif
+
 static int do_ioctl_stats_create_class_counter(void *args)
 {
 	struct ioc_dpa_stats_cls_cnt_params prm;
@@ -654,6 +878,138 @@ static int do_ioctl_stats_create_class_counter(void *args)
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static int do_ioctl_stats_compat_create_class_counter(void *args)
+{
+	struct ioc_dpa_stats_cls_cnt_params kprm;
+	struct compat_ioc_dpa_stats_cls_cnt_params uprm;
+	struct dpa_stats_cls_cnt_params *kprm_cls = &kprm.cnt_params;
+	struct dpa_stats_compat_cls_cnt_params *uprm_cls = &uprm.cnt_params;
+	long ret = 0;
+	uint32_t i = 0;
+
+	if (copy_from_user(&uprm, args, sizeof(uprm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	memset(&kprm, 0, sizeof(struct ioc_dpa_stats_cls_cnt_params));
+	kprm.stats_id = uprm.stats_id;
+	kprm_cls->type = uprm_cls->type;
+	kprm_cls->class_members = uprm_cls->class_members;
+
+	switch (kprm.cnt_params.type) {
+	case DPA_STATS_CNT_ETH:
+		ret = dpa_stats_eth_cls_compatcpy(&kprm_cls->eth_params,
+			&uprm_cls->eth_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_REASS:
+		ret = dpa_stats_reass_cls_compatcpy(&kprm_cls->reass_params,
+			&uprm_cls->reass_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_FRAG:
+		ret = dpa_stats_frag_cls_compatcpy(&kprm_cls->frag_params,
+			&uprm_cls->frag_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_POLICER:
+		ret = dpa_stats_plcr_cls_compatcpy(&kprm_cls->plcr_params,
+			&uprm_cls->plcr_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_CLASSIF_TBL:
+		ret = dpa_stats_tbl_cls_compatcpy(&kprm_cls->classif_tbl_params,
+			&uprm_cls->classif_tbl_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_CLASSIF_NODE:
+		ret = dpa_stats_ccnode_cls_compatcpy(
+			&kprm_cls->classif_node_params,
+			&uprm_cls->ccnode_params,
+			kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_CNT_IPSEC:
+		ret = dpa_stats_ipsec_cls_compatcpy(&kprm_cls->ipsec_params,
+			&uprm_cls->ipsec_params, kprm_cls->class_members);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	}
+
+	ret = dpa_stats_create_class_counter(
+			kprm.stats_id, kprm_cls, &kprm.cnt_id);
+	if (ret < 0)
+		return ret;
+
+	uprm.cnt_id = kprm.cnt_id;
+
+	if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
+		pr_err("Could not copy to user the Counter ID");
+		ret = -EINVAL;
+	}
+
+	switch (uprm.cnt_params.type) {
+	case DPA_STATS_CNT_ETH:
+		kfree(kprm_cls->eth_params.src);
+		break;
+	case DPA_STATS_CNT_REASS:
+		kfree(kprm_cls->reass_params.reass);
+		break;
+	case DPA_STATS_CNT_FRAG:
+		kfree(kprm_cls->frag_params.frag);
+		break;
+	case DPA_STATS_CNT_POLICER:
+		kfree(kprm_cls->plcr_params.plcr);
+		break;
+	case DPA_STATS_CNT_CLASSIF_TBL:
+	{
+		struct dpa_stats_cls_cnt_classif_tbl *tbl =
+				&kprm_cls->classif_tbl_params;
+
+		for (i = 0; i < kprm_cls->class_members; i++) {
+			if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+				kfree(tbl->keys[i].byte);
+				kfree(tbl->keys[i].mask);
+			}
+
+			if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+				kfree(tbl->pairs[i].first_key.byte);
+				kfree(tbl->pairs[i].first_key.mask);
+				kfree(tbl->pairs[i].second_key.byte);
+				kfree(tbl->pairs[i].second_key.mask);
+			}
+		}
+		break;
+	}
+	case DPA_STATS_CNT_CLASSIF_NODE:
+		for (i = 0; i < kprm_cls->class_members; i++) {
+			kfree(kprm_cls->classif_node_params.keys[i].byte);
+			kfree(kprm_cls->classif_node_params.keys[i].mask);
+		}
+		break;
+	case DPA_STATS_CNT_IPSEC:
+		kfree(kprm_cls->ipsec_params.sa_id);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+#endif
+
 static int do_ioctl_stats_modify_class_counter(void *args)
 {
 	struct ioc_dpa_stats_cls_member_params prm;
@@ -713,6 +1069,89 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+static int do_ioctl_stats_compat_modify_class_counter(void *args)
+{
+	struct ioc_dpa_stats_cls_member_params kprm;
+	struct compat_ioc_dpa_stats_cls_member_params uprm;
+	int ret;
+
+	if (copy_from_user(&uprm, args, sizeof(uprm))) {
+		pr_err("Could not copy Counter parameters");
+		return -EINVAL;
+	}
+
+	memset(&kprm, 0, sizeof(struct ioc_dpa_stats_cls_member_params));
+	kprm.cnt_id = uprm.cnt_id;
+	kprm.member_index = uprm.member_index;
+	kprm.params.type = uprm.params.type;
+
+	switch (kprm.params.type) {
+	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
+		if (compat_ptr(uprm.params.key.byte)) {
+			ret = copy_key_descriptor_compatcpy(
+					&kprm.params.key,
+					&uprm.params.key);
+			if (ret < 0)
+				return ret;
+		}
+		break;
+	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
+		if (compat_ptr(uprm.params.pair.first_key.byte)) {
+			ret = copy_key_descriptor_compatcpy(
+					&kprm.params.pair.first_key,
+					&uprm.params.pair.first_key);
+			if (ret < 0)
+				return ret;
+
+			ret = copy_key_descriptor_compatcpy(
+					&kprm.params.pair.second_key,
+					&uprm.params.pair.second_key);
+			if (ret != 0) {
+				pr_err("Could not copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+		break;
+	case DPA_STATS_CLS_MEMBER_SA_ID:
+		break;
+	default:
+		pr_err("invalid class member type\n");
+		break;
+	}
+
+	ret = dpa_stats_modify_class_counter(kprm.cnt_id,
+			&kprm.params, kprm.member_index);
+	if (ret < 0)
+		return ret;
+
+	uprm.cnt_id = kprm.cnt_id;
+
+	switch (kprm.params.type) {
+	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
+		kfree(kprm.params.key.byte);
+		kfree(kprm.params.key.mask);
+		break;
+	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
+		kfree(kprm.params.pair.first_key.byte);
+		kfree(kprm.params.pair.first_key.mask);
+		kfree(kprm.params.pair.second_key.byte);
+		kfree(kprm.params.pair.second_key.mask);
+		break;
+	default:
+		pr_err("invalid class member type\n");
+		break;
+	}
+
+	if (copy_to_user((void *) args, &uprm, sizeof(uprm))) {
+		pr_err("Could not write dpa_stats_init result");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+#endif
+
 static int do_ioctl_stats_get_counters(void *args)
 {
 	struct ioc_dpa_stats_cnt_request_params prm;
@@ -781,27 +1220,106 @@ static int do_ioctl_stats_get_counters(void *args)
 	return ret;
 }
 
-long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
-			 unsigned long args)
+#ifdef CONFIG_COMPAT
+static int do_ioctl_stats_compat_get_counters(void *args)
 {
+	struct ioc_dpa_stats_cnt_request_params kprm;
+	struct compat_ioc_dpa_stats_cnt_request_params uprm;
 	long ret = 0;
 
-	switch (cmd) {
-	case DPA_STATS_IOC_INIT:
-	{
-		struct ioc_dpa_stats_params kparam;
-
-		/* Copy parameters from user-space */
-		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("Could not read dpa_stats_init user space args");
-			return -EBUSY;
-		}
+	if (copy_from_user(&uprm, args, sizeof(uprm))) {
+		pr_err("Could not copy Request parameters");
+		return -EINVAL;
+	}
 
-		ret = do_ioctl_stats_init(&kparam);
-		if (ret < 0)
-			return ret;
+	memset(&kprm, 0, sizeof(struct ioc_dpa_stats_cnt_request_params));
+	kprm.cnts_len = uprm.cnts_len;
+	kprm.request_done = (dpa_stats_request_cb)
+			((compat_ptr)(uprm.request_done));
+	kprm.req_params.cnts_ids_len = uprm.req_params.cnts_ids_len;
+	kprm.req_params.reset_cnts = uprm.req_params.reset_cnts;
+	kprm.req_params.storage_area_offset =
+			uprm.req_params.storage_area_offset;
 
-		/* Copy paramters to user-space */
+	/* Allocate kernel-space memory area to copy the counters ids */
+	kprm.req_params.cnts_ids = kzalloc(kprm.req_params.cnts_ids_len *
+			sizeof(int), GFP_KERNEL);
+	if (!kprm.req_params.cnts_ids) {
+		pr_err("Could not allocate requested counters array\n");
+		return -ENOMEM;
+	}
+
+	/* Copy the user provided counter ids */
+	if (copy_from_user(kprm.req_params.cnts_ids,
+			(compat_ptr)(uprm.req_params.cnts_ids),
+			(kprm.req_params.cnts_ids_len * sizeof(int)))) {
+		pr_err("Could not copy requested counters ids\n");
+		kfree(kprm.req_params.cnts_ids);
+		return -EINVAL;
+	}
+
+	/* If counters request is asynchronous */
+	if (kprm.request_done) {
+		ret = store_get_cnts_async_params(&kprm);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = dpa_stats_get_counters(kprm.req_params,
+			&kprm.cnts_len,
+			kprm.request_done);
+	if (ret < 0) {
+		kfree(kprm.req_params.cnts_ids);
+		return ret;
+	}
+
+	/* Request was sent, release the array of counter ids */
+	kfree(kprm.req_params.cnts_ids);
+
+	/* If request is synchronous copy counters values to user space */
+	if (!kprm.request_done) {
+		if (copy_to_user((wrp_dpa_stats.us_mem +
+				kprm.req_params.storage_area_offset),
+				(wrp_dpa_stats.k_mem +
+				kprm.req_params.storage_area_offset),
+				kprm.cnts_len)) {
+			pr_err("Couldn't copy counters values to storage area\n");
+			return -EINVAL;
+		}
+
+		uprm.cnts_len = kprm.cnts_len;
+
+		if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
+			pr_err("Could not copy to user the Counter ID");
+			ret = -EINVAL;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args)
+{
+	long ret = 0;
+
+	switch (cmd) {
+	case DPA_STATS_IOC_INIT:
+	{
+		struct ioc_dpa_stats_params kparam;
+
+		/* Copy parameters from user-space */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("Could not read dpa_stats_init user space args");
+			return -EBUSY;
+		}
+
+		ret = do_ioctl_stats_init(&kparam);
+		if (ret < 0)
+			return ret;
+
+		/* Copy paramters to user-space */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
 			pr_err("Could not write dpa_stats_init result");
 			return -EBUSY;
@@ -855,6 +1373,85 @@ long wrp_dpa_stats_do_ioctl(struct file *filp, unsigned int cmd,
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static long wrp_dpa_stats_do_compat_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args)
+{
+	long ret = 0;
+
+	switch (cmd) {
+	case DPA_STATS_IOC_COMPAT_INIT:
+	{
+		struct ioc_dpa_stats_params kparam;
+		struct compat_ioc_dpa_stats_params uparam;
+
+		/* Copy parameters from user space */
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("Could not read dpa_stats_init user space args");
+			return -EBUSY;
+		}
+		dpa_stats_init_compatcpy(&kparam, &uparam);
+
+		ret = do_ioctl_stats_init(&kparam);
+		if (ret < 0)
+			return ret;
+
+		/* Copy result to user-space */
+		uparam.dpa_stats_id = kparam.dpa_stats_id;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("Could not write dpa_stats_init result");
+			return -EBUSY;
+		}
+		break;
+	}
+	case DPA_STATS_IOC_FREE:
+		ret = do_ioctl_stats_free((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_COMPAT_CREATE_COUNTER:
+		ret = do_ioctl_stats_compat_create_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_COMPAT_CREATE_CLASS_COUNTER:
+		ret = do_ioctl_stats_compat_create_class_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_COMPAT_MODIFY_CLASS_COUNTER:
+		ret = do_ioctl_stats_compat_modify_class_counter((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	case DPA_STATS_IOC_REMOVE_COUNTER:{
+		int dpa_stats_cnt_id;
+
+		if (copy_from_user(&dpa_stats_cnt_id, (int *)args,
+				    sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+
+		ret = dpa_stats_remove_counter(dpa_stats_cnt_id);
+		if (ret < 0)
+			return ret;
+		break;
+	}
+	case DPA_STATS_IOC_COMPAT_GET_COUNTERS:
+		ret = do_ioctl_stats_compat_get_counters((void *)args);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		pr_err("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
+				cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
+		break;
+	}
+	return ret;
+}
+#endif
+
 static long store_get_cnts_async_params(
 		struct ioc_dpa_stats_cnt_request_params *kprm)
 {
@@ -940,10 +1537,52 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+static int copy_key_descriptor_compatcpy(
+		struct dpa_offload_lookup_key			*kparam,
+		const struct compat_ioc_dpa_offld_lookup_key	*uparam)
+{
+	BUG_ON(uparam->size <= 0);
+
+	kparam->size = uparam->size;
+
+	/* Allocate memory to store the key byte array */
+	kparam->byte = kmalloc(kparam->size, GFP_KERNEL);
+	if (!kparam->byte) {
+		pr_err("No more memory for key pointer\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kparam->byte, compat_ptr(uparam->byte),
+		uparam->size)) {
+		pr_err("Could not copy key byte\n");
+		return -EBUSY;
+	}
+	if (compat_ptr(uparam->mask)) {
+		/* Allocate memory to store the key mask array */
+		kparam->mask = kmalloc(kparam->size, GFP_KERNEL);
+		if (!kparam->mask) {
+			pr_err("No more memory for mask pointer\n");
+			kfree(kparam->byte);
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(kparam->mask, compat_ptr(uparam->mask),
+			uparam->size)) {
+			pr_err("Could not copy key mask\n");
+			return -EBUSY;
+		}
+	} else
+		kparam->mask = NULL;
+
+	return 0;
+}
+#endif
+
 static int copy_class_members(void *objs, unsigned int size, void *dst)
 {
 	/* Allocate memory to store the array of reass objects */
-	objs = kmalloc(size, GFP_KERNEL);
+	objs = kmalloc(size * sizeof(void *), GFP_KERNEL);
 	if (!objs) {
 		pr_err("No more memory for class members pointers\n");
 		return -ENOMEM;
@@ -958,3 +1597,340 @@ static int copy_class_members(void *objs, unsigned int size, void *dst)
 
 	return 0;
 }
+
+#ifdef CONFIG_COMPAT
+static void dpa_stats_init_compatcpy(struct ioc_dpa_stats_params *kparam,
+		struct compat_ioc_dpa_stats_params *uparam)
+{
+	kparam->dpa_stats_id = uparam->dpa_stats_id;
+	kparam->stats_params.max_counters = uparam->stats_params.max_counters;
+	kparam->stats_params.storage_area_len =
+				uparam->stats_params.storage_area_len;
+	kparam->stats_params.storage_area =
+				compat_ptr(uparam->stats_params.storage_area);
+}
+
+static void dpa_stats_reass_cnt_compatcpy(struct dpa_stats_cnt_reass *kprm,
+		struct dpa_stats_compat_cnt_reass *uprm)
+{
+	kprm->reass = compat_get_id2ptr(uprm->reass, FM_MAP_TYPE_PCD_NODE);
+	kprm->cnt_sel = uprm->cnt_sel;
+}
+
+static void dpa_stats_frag_cnt_compatcpy(struct dpa_stats_cnt_frag *kprm,
+		struct dpa_stats_compat_cnt_frag *uprm)
+{
+	kprm->frag = compat_get_id2ptr(uprm->frag, FM_MAP_TYPE_PCD_NODE);
+	kprm->cnt_sel = uprm->cnt_sel;
+}
+
+static void dpa_stats_plcr_cnt_compatcpy(struct dpa_stats_cnt_plcr *kprm,
+		struct dpa_stats_compat_cnt_plcr *uprm)
+{
+	kprm->plcr = compat_get_id2ptr(uprm->plcr, FM_MAP_TYPE_PCD_NODE);
+	kprm->cnt_sel = uprm->cnt_sel;
+}
+
+static long dpa_stats_tbl_cnt_compatcpy(struct dpa_stats_cnt_classif_tbl *kprm,
+		struct dpa_stats_compat_cnt_classif_tbl *uprm)
+{
+	kprm->td = uprm->td;
+	kprm->cnt_sel = uprm->cnt_sel;
+	return copy_key_descriptor_compatcpy(&kprm->key, &uprm->key);
+}
+
+static long dpa_stats_ccnode_cnt_compatcpy(
+		struct dpa_stats_cnt_classif_node *kprm,
+		struct dpa_stats_compat_cnt_classif_node *uprm)
+{
+	kprm->cnt_sel = uprm->cnt_sel;
+	kprm->ccnode_type = uprm->ccnode_type;
+	kprm->cc_node = compat_get_id2ptr(uprm->cc_node, FM_MAP_TYPE_PCD_NODE);
+	return copy_key_descriptor_compatcpy(&kprm->key, &uprm->key);
+}
+
+static long dpa_stats_eth_cls_compatcpy(struct dpa_stats_cls_cnt_eth *kprm,
+		struct dpa_stats_compat_cls_cnt_eth *uprm, uint32_t cls_members)
+{
+	uint32_t size = 0;
+
+	size = cls_members * sizeof(struct dpa_stats_cnt_eth_src);
+
+	/* Allocate memory to store the sources array */
+	kprm->src = kzalloc(size, GFP_KERNEL);
+	if (!kprm->src) {
+		pr_err("No more memory for ethernet sources array\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kprm->src, compat_ptr(uprm->src), size)) {
+		pr_err("Could not copy array of ethernet sources\n");
+		kfree(kprm->src);
+		return -EBUSY;
+	}
+	kprm->cnt_sel = uprm->cnt_sel;
+	return 0;
+}
+
+static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
+		struct dpa_stats_compat_cnt_reass *uprm, uint32_t cls_members)
+{
+	compat_uptr_t *reass;
+	uint32_t i = 0;
+
+	/* Allocate memory to store the array of user-space reass objects */
+	reass = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
+	if (!reass) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(reass, compat_ptr(uprm->reass),
+			(sizeof(compat_uptr_t) * cls_members))) {
+		pr_err("Could not copy array of objects\n");
+		return -EBUSY;
+	}
+
+	/* Allocate memory to store the array of kernel space reass objects */
+	kprm->reass = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
+	if (!kprm->reass) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < cls_members; i++)
+		kprm->reass[i] = compat_get_id2ptr(
+				reass[i], FM_MAP_TYPE_PCD_NODE);
+
+	kprm->cnt_sel = uprm->cnt_sel;
+	return 0;
+}
+
+static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
+		struct dpa_stats_compat_cnt_frag *uprm, uint32_t cls_members)
+{
+	compat_uptr_t *ufrag;
+	uint32_t i = 0;
+
+	/* Allocate memory to store the array of user-space frag objects */
+	ufrag = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
+	if (!ufrag) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(ufrag, compat_ptr(uprm->frag),
+			(sizeof(compat_uptr_t) * cls_members))) {
+		pr_err("Could not copy array of objects\n");
+		return -EBUSY;
+	}
+
+	/* Allocate memory to store the array of kernel space frag objects */
+	kprm->frag = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
+	if (!kprm->frag) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < cls_members; i++)
+		kprm->frag[i] = compat_get_id2ptr(
+				ufrag[i], FM_MAP_TYPE_PCD_NODE);
+
+	kprm->cnt_sel = uprm->cnt_sel;
+	return 0;
+}
+
+static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
+		struct dpa_stats_compat_cnt_plcr *uprm, uint32_t cls_members)
+{
+	compat_uptr_t *uplcr;
+	uint32_t i = 0;
+
+	/* Allocate memory to store the array of user-space policer objects */
+	uplcr = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
+	if (!uplcr) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(uplcr, compat_ptr(uprm->plcr),
+			(sizeof(compat_uptr_t) * cls_members))) {
+		pr_err("Could not copy array of objects\n");
+		return -EBUSY;
+	}
+
+	/* Allocate memory to store the array of kernel space policer objects */
+	kprm->plcr = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
+	if (!kprm->plcr) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < cls_members; i++)
+		kprm->plcr[i] = compat_get_id2ptr(
+				uplcr[i], FM_MAP_TYPE_PCD_NODE);
+
+	kprm->cnt_sel = uprm->cnt_sel;
+	return 0;
+}
+
+static long dpa_stats_tbl_cls_compatcpy(
+		struct dpa_stats_cls_cnt_classif_tbl *kprm,
+		struct dpa_stats_compat_cls_cnt_classif_tbl *uprm,
+		uint32_t cls_members)
+{
+	struct compat_ioc_dpa_offld_lookup_key *keys;
+	struct compat_ioc_dpa_offld_lookup_key_pair *pairs;
+	uint32_t size = 0, i;
+	long ret;
+
+	kprm->cnt_sel = uprm->cnt_sel;
+	kprm->td = uprm->td;
+	kprm->key_type = uprm->key_type;
+
+	if (kprm->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+		size = sizeof(struct dpa_offload_lookup_key) * cls_members;
+		kprm->keys = kzalloc(size, GFP_KERNEL);
+		if (!kprm->keys) {
+			pr_err("No more memory for class members pointers\n");
+			return -ENOMEM;
+		}
+
+		size = sizeof(struct compat_ioc_dpa_offld_lookup_key) *
+				cls_members;
+		keys = kzalloc(size, GFP_KERNEL);
+		if (!keys) {
+			pr_err("No more memory for class members pointers\n");
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(keys, (compat_ptr)(uprm->keys), size)) {
+			pr_err("Could not copy array of objects\n");
+			kfree(keys);
+			return -EBUSY;
+		}
+
+		for (i = 0; i < cls_members; i++) {
+			if (!compat_ptr(keys[i].byte))
+				continue;
+
+			ret = copy_key_descriptor_compatcpy(&kprm->keys[i],
+					&keys[i]);
+			if (ret != 0) {
+				pr_err("Couldn't copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+	} else if (kprm->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+		size = sizeof(struct dpa_offload_lookup_key_pair) * cls_members;
+		kprm->pairs = kzalloc(size, GFP_KERNEL);
+		if (!kprm->pairs) {
+			pr_err("No more memory for class members pointers\n");
+			return -ENOMEM;
+		}
+
+		size = sizeof(struct compat_ioc_dpa_offld_lookup_key_pair) *
+				cls_members;
+		pairs = kzalloc(size, GFP_KERNEL);
+		if (!pairs) {
+			pr_err("No more memory for class members pointers\n");
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(pairs, (compat_ptr)(uprm->pairs), size)) {
+			pr_err("Could not copy array of objects\n");
+			kfree(pairs);
+			return -EBUSY;
+		}
+
+		for (i = 0; i < cls_members; i++) {
+			if (!compat_ptr(pairs[i].first_key.byte))
+				continue;
+
+			ret = copy_key_descriptor_compatcpy(
+					&kprm->pairs[i].first_key,
+					&pairs[i].first_key);
+			if (ret != 0) {
+				pr_err("Couldn't copy the key descriptor\n");
+				return -EINVAL;
+			}
+
+			ret = copy_key_descriptor_compatcpy(
+					&kprm->pairs[i].second_key,
+					&pairs[i].second_key);
+			if (ret != 0) {
+				pr_err("Couldn't copy the key descriptor\n");
+				return -EINVAL;
+			}
+		}
+	}
+	return ret;
+}
+
+static long dpa_stats_ccnode_cls_compatcpy(
+		struct dpa_stats_cls_cnt_classif_node *kprm,
+		struct dpa_stats_compat_cls_cnt_classif_node *uprm,
+		uint32_t cls_members)
+{
+	struct compat_ioc_dpa_offld_lookup_key *keys;
+	uint32_t size, i;
+	long ret = 0;
+
+	kprm->cc_node = compat_get_id2ptr(uprm->cc_node, FM_MAP_TYPE_PCD_NODE);
+	kprm->cnt_sel = uprm->cnt_sel;
+	kprm->ccnode_type = uprm->ccnode_type;
+
+	size = sizeof(struct dpa_offload_lookup_key) * cls_members;
+	kprm->keys = kzalloc(size, GFP_KERNEL);
+	if (!kprm->keys) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	size = sizeof(struct compat_ioc_dpa_offld_lookup_key) * cls_members;
+	keys = kzalloc(size, GFP_KERNEL);
+	if (!keys) {
+		pr_err("No more memory for class members pointers\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(keys, (compat_ptr)(uprm->keys), size)) {
+		pr_err("Could not copy array of objects\n");
+		kfree(keys);
+		return -EBUSY;
+	}
+
+	for (i = 0; i < cls_members; i++) {
+		ret = copy_key_descriptor_compatcpy(&kprm->keys[i], &keys[i]);
+		if (ret != 0) {
+			pr_err("Couldn't copy the key descriptor\n");
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+static long dpa_stats_ipsec_cls_compatcpy(
+		struct dpa_stats_cls_cnt_ipsec *kprm,
+		struct dpa_stats_compat_cls_cnt_ipsec *uprm,
+		uint32_t cls_members)
+{
+	kprm->cnt_sel = uprm->cnt_sel;
+
+	/* Allocate memory to store the sa ids array */
+	kprm->sa_id = kmalloc(cls_members * sizeof(int), GFP_KERNEL);
+	if (!kprm->sa_id) {
+		pr_err("No more memory for sa ids pointer\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kprm->sa_id,
+			(compat_ptr)(uprm->sa_id),
+			(cls_members * sizeof(int)))) {
+		pr_err("Could not copy array of SA ids\n");
+		kfree(kprm->sa_id);
+		return -EBUSY;
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h
index 453ee71..ec04625 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.h
@@ -53,6 +53,11 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 long	wrp_dpa_stats_ioctl(struct file *filp, unsigned int cmd,
 			 unsigned long args);
 
+#ifdef CONFIG_COMPAT
+long	wrp_dpa_stats_compat_ioctl(struct file *filp, unsigned int cmd,
+			unsigned long args);
+#endif
+
 #define QUEUE_MAX_EVENTS 2048
 
 struct dpa_stats_event_params {
-- 
1.7.5.4

