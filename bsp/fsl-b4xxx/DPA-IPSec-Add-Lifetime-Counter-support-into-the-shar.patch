From 920353a0d030e4847af12619338a620b872bd4ec Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Thu, 17 May 2012 22:41:49 +0000
Subject: [PATCH 156/518] DPA IPSec - Add Lifetime Counter support into the
 shared descriptor

Use 2 words after PDB to store statistics.
First word for packet count and second for bytes count.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h      |    2 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |  143 ++++++++++++++++++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    4 +-
 3 files changed, 140 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 00f9ca1..69c6805 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -223,6 +223,8 @@ struct dpa_ipsec_sa {
 			  /*Allocated at initialization time.
 			   * Holds valid information after creating the
 			   * shared descriptor according to the SA information*/
+	uint8_t	stats_offset; /* Offset of the statistics (in bytes)  */
+	bool	enable_stats; /* Enable counting packets and bytes processed  */
 	struct qman_fq *to_sec_fq; /*From this Frame Queue SEC consumes frames*/
 	struct qman_fq *from_sec_fq; /*In this Frame Queue SEC will enqueue the
 				encryption/decryption result (FD).            */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 8ef900c..3869566 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -94,26 +94,139 @@ static inline u32 get_ipsec_op_type(enum dpa_ipsec_direction sa_dir)
 					      OP_TYPE_ENCAP_PROTOCOL;
 }
 
+static inline void build_stats_descriptor_part(struct dpa_ipsec_sa *sa,
+					       size_t pdb_len)
+{
+	u32 *desc, *padding_jump;
+	u32 block_size, stats_offset, offset;
+
+	BUG_ON(!sa);
+
+	desc = (u32 *) sa->sec_desc->desc;
+
+	stats_offset = sizeof(sa->sec_desc->hdr_word) + pdb_len -
+		       DPA_IPSEC_STATS_LEN * sizeof(u32);
+	sa->stats_offset = stats_offset;
+	memset((u8 *)desc + stats_offset, 0, DPA_IPSEC_STATS_LEN * sizeof(u32));
+
+	/* Copy from descriptor to MATH REG 0 the current statistics */
+	append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | MOVE_WAITCOMP |
+		    (stats_offset << MOVE_OFFSET_SHIFT) | sizeof(u64));
+
+	/* Load 1 in MATH REG 1 */
+	append_math_add(desc, REG1, ZERO, ONE, MATH_LEN_8BYTE);
+
+	/*
+	 * Perform 32-bit left shift of DEST and concatenate with left 32 bits
+	 * of SRC1 i.e MATH REG 1 = 0x00000001_00000000
+	 */
+	append_math_ldshift(desc, REG1, REG0, REG1, MATH_LEN_8BYTE);
+
+	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
+		/* MATH REG 2 = Sequence in length */
+		append_math_add_imm_u32(desc, REG2, SEQINLEN, IMM, 0);
+		goto after_padding;
+	} else {
+		/* MATH REG 2 = Sequence in length + 2 */
+		append_math_add_imm_u32(desc, REG2, SEQINLEN, IMM, 2);
+	}
+
+	switch (sa->cipher_data.cipher_type) {
+	case OP_PCL_IPSEC_3DES:
+		block_size = 8; /* block size in bytes */
+		break;
+	case OP_PCL_IPSEC_AES_CBC:
+	case OP_PCL_IPSEC_AES_CTR:
+	case OP_PCL_IPSEC_AES_XTS:
+	case OP_PCL_IPSEC_AES_CCM8:
+	case OP_PCL_IPSEC_AES_CCM12:
+	case OP_PCL_IPSEC_AES_CCM16:
+	case OP_PCL_IPSEC_AES_GCM8:
+	case OP_PCL_IPSEC_AES_GCM12:
+	case OP_PCL_IPSEC_AES_GCM16:
+		block_size = 16; /* block size in bytes */
+		break;
+	default:
+		xx_pr_crit("Invalid cipher algorithm for SA %d\n", sa->id);
+		return;
+	}
+
+	/* Adding padding to byte counter */
+	append_math_and_imm_u32(desc, REG3, REG2, IMM, block_size - 1);
+
+	/* Previous operation result is 0 i.e padding added to bytes count */
+	padding_jump = append_jump(desc, CLASS_BOTH | JUMP_TEST_ALL |
+				   JUMP_COND_MATH_Z);
+
+	/* MATH REG 2 = MATH REG 2 + 1 */
+	append_math_add(desc, REG2, REG2, ONE, MATH_LEN_8BYTE);
+
+	/* jump back to adding padding i.e jump back 4 words */
+	offset = (-4) & 0x000000FF;
+	append_jump(desc, (offset << JUMP_OFFSET_SHIFT));
+
+	set_jump_tgt_here(desc, padding_jump);
+	/* Done adding padding to byte counter */
+
+after_padding:
+	/* MATH REG 1  = MATH REG 1 + MATH REG 2 */
+	append_math_add(desc, REG1, REG1, REG2, MATH_LEN_8BYTE);
+
+	/* MATH REG0 = MATH REG 0 + MATH REG1 */
+	append_math_add(desc, REG0, REG0, REG1, MATH_LEN_8BYTE);
+
+	/* Store in the descriptor but not in external memory */
+	append_move(desc, MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF | MOVE_WAITCOMP |
+		    (stats_offset << MOVE_OFFSET_SHIFT) | sizeof(u64));
+}
+
+static inline void save_stats_in_external_mem(struct dpa_ipsec_sa *sa)
+{
+	u32 *desc;
+	u32 stats_offset;
+
+	desc = (u32 *) sa->sec_desc->desc;
+
+	/* statistics offset = predetermined offset */
+	stats_offset = sa->stats_offset;
+
+	/* Store command: in the case of the Descriptor Buffer the length
+	 * is specified in 4-byte words, but in all other cases the length
+	 * is specified in bytes. Offset in 4 byte words */
+	append_store(desc, 0, DPA_IPSEC_STATS_LEN, LDST_CLASS_DECO |
+		     ((stats_offset / 4) << LDST_OFFSET_SHIFT) |
+		     LDST_SRCDST_WORD_DESCBUF_SHARED);
+
+	/* Jump with CALM to be sure previous operation was finished */
+	append_jump(desc, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
+}
+
 int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 			    dma_addr_t auth_key_dma,
 			    dma_addr_t crypto_key_dma, u8 bytes_to_copy)
 {
 	u32 *desc, *key_jump_cmd;
 	int opthdrsz;
+	size_t pdb_len = 0;
 
 	desc = (u32 *) sa->sec_desc->desc;
+
+	/* Reserve 2 words for statistics */
+	if (sa->enable_stats)
+		pdb_len = DPA_IPSEC_STATS_LEN * sizeof(u32);
+
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		/* Compute optional header size, rounded up to descriptor
 		 * word size */
 		opthdrsz = (sa->sec_desc->pdb_en.ip_hdr_len + 3) & ~3;
-		init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL,
-				 sizeof(struct ipsec_encap_pdb) + opthdrsz);
+		pdb_len += sizeof(struct ipsec_encap_pdb) + opthdrsz;
+		init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL, pdb_len);
 	} else {
 		/* Since ipsec_decap_pdb has cbc which stores ESN
 		*into its second field and there is also seq_num_ext_hi we
 		*must subtract 1 word for ESN */
-		init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL,
-				 sizeof(struct ipsec_decap_pdb) - sizeof(u32));
+		pdb_len += sizeof(struct ipsec_decap_pdb) - sizeof(u32);
+		init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL, pdb_len);
 	}
 
 	/* Key jump */
@@ -136,10 +249,12 @@ int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 
 	set_jump_tgt_here(desc, key_jump_cmd);
 
-	/*
-	 * actual move
-	 * ld: deco-deco-ctrl len=0 offs=8 imm -auto-nfifo-entries
-	 */
+	if (bytes_to_copy == 0)
+		goto skip_byte_copy;
+
+	/* Copy L2 header from the original packet to the outer packet */
+
+	/* ld: deco-deco-ctrl len=0 offs=8 imm -auto-nfifo-entries */
 	append_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);
 
 	/* seqfifold: both msgdata-last2-last1-flush1 len=4 */
@@ -156,9 +271,21 @@ int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 	/* seqfifostr: msgdata len=4 */
 	append_seq_fifo_store(desc, FIFOST_TYPE_MESSAGE_DATA, bytes_to_copy);
 
+	/* Done coping L2 header from the original packet to the outer packet */
+
+skip_byte_copy:
+
+	if (sa->enable_stats)
+		build_stats_descriptor_part(sa, pdb_len);
+
+	/* Protocol specific operation */
 	append_operation(desc, OP_PCLID_IPSEC |
 			 get_ipsec_op_type(sa->sa_dir) |
 			 sa->cipher_data.cipher_type | sa->auth_data.auth_type);
+
+	if (sa->enable_stats)
+		save_stats_in_external_mem(sa);
+
 	return 0;
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index ae90945..f114ba9 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -36,6 +36,8 @@
 #include "dpa_ipsec.h"
 #include "desc_constr.h"
 
+#define DPA_IPSEC_STATS_LEN	2	/* length in words */
+
 /* preheader */
 struct preheader {
 	union {
@@ -74,7 +76,7 @@ struct sec_descriptor {
 	struct preheader preheader;	/* SEC preheader */
 	/* SEC Shared Descriptor */
 	union {
-		uint32_t desc[CAAM_DESC_BYTES_MAX];
+		uint32_t desc[MAX_CAAM_DESCSIZE];
 		struct desc_hdr desc_hdr;
 #define hdr_word	desc_hdr.hdr_word
 #define pdb_en		desc_hdr.pdb_en
-- 
1.7.5.4

