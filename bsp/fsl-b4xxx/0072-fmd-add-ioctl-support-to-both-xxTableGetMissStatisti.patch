From 19ec2b9938e1df0a3425a62f2b60ba9a6a4ed96b Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Wed, 31 Jul 2013 14:32:12 +0300
Subject: [PATCH 072/130] fmd: add ioctl support to both
 xxTableGetMissStatistics functions

FM_PCD_MatchTableGetMissStatistics and FM_PCD_HashTableGetMissStatistics

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Change-Id: I56a02300f4603245344effc898ff9fdd137d8e4c
Reviewed-on: http://git.am.freescale.net:8181/3905
Reviewed-by: Schmitt Richard-B43082 <B43082@freescale.com>
Tested-by: Schmitt Richard-B43082 <B43082@freescale.com>
[Fetch from http://git.freescale.com/git/cgit.cgi/ppc/sdk/linux.git/,
 Tag: fsl-sdk-v1.4.5
 rebase on current context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |  149 ++++++++++++++++++++
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.c     |   20 +++-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.h     |   11 ++
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h |   74 ++++++++++
 4 files changed, 252 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 5813a6b..e5c98ae 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -1946,6 +1946,155 @@ invalid_port_id:
             XX_Free(param);
             break;
         }
+
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT:
+#endif
+        case FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT:
+        {
+            ioc_fm_pcd_cc_tbl_get_miss_params_t param;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                {
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_miss_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+
+            err = FM_PCD_MatchTableGetMissStatistics((t_Handle) param.id,
+                                                     (t_FmPcdCcKeyStatistics *) &param.miss_statistics);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                                  &param,
+                                  sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+            }
+
+            break;
+        }
+
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT:
+#endif
+        case FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT:
+        {
+            ioc_fm_pcd_cc_tbl_get_miss_params_t param;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                {
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_miss_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+
+            err = FM_PCD_HashTableGetMissStatistics((t_Handle) param.id,
+                                                     (t_FmPcdCcKeyStatistics *) &param.miss_statistics);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                                  &param,
+                                  sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+            }
+
+            break;
+        }
+
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_HASH_TABLE_SET_COMPAT:
 #endif
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 68142b6..af582cb 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -506,7 +506,7 @@ void compat_copy_fm_pcd_hash_table(
 {
     if (compat == COMPAT_US_TO_K)
     {
-        param-> max_num_of_keys = compat_param->max_num_of_keys;
+        param->max_num_of_keys  = compat_param->max_num_of_keys;
         param->statistics_mode  = compat_param->statistics_mode;
         param->kg_hash_shift    = compat_param->kg_hash_shift;
         param->hash_res_mask    = compat_param->hash_res_mask;
@@ -516,7 +516,7 @@ void compat_copy_fm_pcd_hash_table(
     }
     else
     {
-        compat_param-> max_num_of_keys = param->max_num_of_keys;
+        compat_param->max_num_of_keys  = param->max_num_of_keys;
         compat_param->statistics_mode  = param->statistics_mode;
         compat_param->kg_hash_shift    = param->kg_hash_shift;
         compat_param->hash_res_mask    = param->hash_res_mask;
@@ -844,6 +844,22 @@ void compat_copy_fm_port_vsp_alloc_params(
 }
 #endif /* (DPAA_VERSION >= 11) */
 
+void compat_copy_fm_pcd_cc_tbl_get_miss(
+        ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param,
+        ioc_fm_pcd_cc_tbl_get_miss_params_t *param,
+        uint8_t compat)
+{
+    if (compat == COMPAT_US_TO_K)
+    {
+        param->id = compat_pcd_id2ptr(compat_param->id);
+        memcpy(&param->miss_statistics, &compat_param->miss_statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
+    } else {
+        compat_param->id = compat_add_ptr2id(param->id, FM_MAP_TYPE_PCD_NODE);
+        memcpy(&compat_param->miss_statistics, &param->miss_statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
+    }
+}
+
+
 void compat_copy_fm_pcd_net_env(
         ioc_compat_fm_pcd_net_env_params_t *compat_param,
         ioc_fm_pcd_net_env_params_t *param,
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
index f8655db..ae19b68 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -521,6 +521,12 @@ typedef struct ioc_compat_fm_ctrl_mon_counters_params_t {
     compat_uptr_t p_mon;
 } ioc_compat_fm_ctrl_mon_counters_params_t;
 
+typedef struct ioc_compat_fm_pcd_cc_tbl_get_miss_params_t {
+    compat_uptr_t                   id;
+    ioc_fm_pcd_cc_key_statistics_t  miss_statistics;
+} ioc_compat_fm_pcd_cc_tbl_get_miss_params_t;
+
+
 /* } pcd compat structures */
 
 void compat_obj_delete(
@@ -568,6 +574,11 @@ void compat_copy_fm_pcd_cc_tree(
         ioc_fm_pcd_cc_tree_params_t *param,
         uint8_t compat);
 
+void compat_copy_fm_pcd_cc_tbl_get_miss(
+        ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param,
+        ioc_fm_pcd_cc_tbl_get_miss_params_t *param,
+        uint8_t compat);
+
 void compat_fm_pcd_prs_sw(
         ioc_compat_fm_pcd_prs_sw_params_t *compat_param,
         ioc_fm_pcd_prs_sw_params_t *param,
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 93bbebb..8c07f18 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -2117,6 +2117,80 @@ typedef struct ioc_fm_pcd_frm_replic_member_params_t {
 } ioc_fm_pcd_frm_replic_member_params_t;
 #endif /* DPAA_VERSION >= 11 */
 
+
+typedef struct ioc_fm_pcd_cc_key_statistics_t {
+    uint32_t    byte_count;      /**< This counter reflects byte count of frames that
+                                     were matched by this key. */
+    uint32_t    frame_count;     /**< This counter reflects count of frames that
+                                     were matched by this key. */
+#if (DPAA_VERSION >= 11)
+    uint32_t    frame_length_range_count[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                /**< These counters reflect how many frames matched
+                                     this key in 'RMON' statistics mode:
+                                     Each counter holds the number of frames of a
+                                     specific frames length range, according to the
+                                     ranges provided at initialization. */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_cc_key_statistics_t;
+
+
+typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
+    void                            *id;
+    ioc_fm_pcd_cc_key_statistics_t  miss_statistics;
+} ioc_fm_pcd_cc_tbl_get_miss_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of miss entry
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry; The
+                total frames count will be returned in the counter of the
+                first range (as only one frame length range was defined).
+
+ @Param[in]     h_CcNode            A handle to the node
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_fm_pcd_cc_tbl_get_miss_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of 'miss'
+                entry of the a hash table.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry;
+
+ @Param[in]     h_HashTbl           A handle to a hash table
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_fm_pcd_cc_tbl_get_miss_params_t)
+
+
 /**************************************************************************//**
  @Function      FM_PCD_NetEnvCharacteristicsSet
 
-- 
1.7.5.4

