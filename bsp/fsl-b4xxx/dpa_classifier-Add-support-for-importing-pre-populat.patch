From a8c79999a92b9e0d4343be8148260b08e38cb786 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Thu, 9 Aug 2012 16:13:04 +0000
Subject: [PATCH 281/518] dpa_classifier: Add support for importing
 pre-populated indexed tables

DPA Classifier used to remove (replace with DROP) all the entries in
an indexed Cc node at initialization. This is no longer done as it
may destroy pre-populated entries. Instead, the indexed tables are
now importing the entries from the associated Cc node. In this context
insert_entry and delete_entry no longer make sense. Henceforth only
modify_entry actions will be possible on an indexed table and this
type of table will only be managed BY_KEY (i.e. indexed tables managed
BY_REF will no exist).

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  392 +++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   25 +-
 2 files changed, 215 insertions(+), 202 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 2cc72fe..683ed9b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -126,9 +126,6 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			 */
 			ptable->shadow_table->size =
 				ptable->params.indexed_params.entries_cnt;
-		err = table_init_indexed(ptable);
-		if (err < 0)
-			goto dpa_classif_table_create_error;
 		break;
 
 	case DPA_CLS_TBL_EXACT_MATCH:
@@ -138,9 +135,6 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			/* Set shadow table size */
 			ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
-		err = table_init_exact_match(ptable);
-		if (err < 0)
-			goto dpa_classif_table_create_error;
 		break;
 
 	case DPA_CLS_TBL_HASH:
@@ -153,10 +147,12 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			 */
 			ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
-		err = table_init_hash(ptable);
-		if (err < 0)
-			goto dpa_classif_table_create_error;
 		break;
+	default:
+		pr_err("ERROR: %s, %s (%d): Unsupported DPA Classifier table "
+			"type (%d).\n", __FILE__, __func__, __LINE__,
+			ptable->params.type);
+		goto dpa_classif_table_create_error;
 	}
 
 	/* Init shadow table if necessary */
@@ -178,6 +174,19 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			INIT_LIST_HEAD(&ptable->shadow_table->shadow_entry[i]);
 	}
 
+	switch (ptable->params.type) {
+	case DPA_CLS_TBL_INDEXED:
+		err = table_init_indexed(ptable);
+		break;
+	case DPA_CLS_TBL_EXACT_MATCH:
+		err = table_init_exact_match(ptable);
+		break;
+	case DPA_CLS_TBL_HASH:
+		err = table_init_hash(ptable);
+		break;
+	}
+	if (err < 0)
+		goto dpa_classif_table_create_error;
 
 	table_array.object[*td] = ptable;
 	init_crc8_table(CRC8_WCDMA_POLY);
@@ -330,12 +339,20 @@ int dpa_classif_table_insert_entry(int				td,
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
+	ptable = (struct dpa_cls_table *) table_array.object[td];
+
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		pr_err("ERROR: %s, %s (%d): Insert entry in an indexed table "
+			"makes no sense. Please use modify_entry instead.\n",
+			__FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+
 	/*
 	 * Verify if there is already an entry in the table which conflicts with
 	 * this one (this verification is only possible if a shadow table is
 	 * used)
 	 */
-	ptable = (struct dpa_cls_table *) table_array.object[td];
 	if ((ptable->shadow_table) &&
 			(find_shadow_entry(ptable, key) != NULL)) {
 		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry already "
@@ -344,12 +361,6 @@ int dpa_classif_table_insert_entry(int				td,
 	}
 
 	switch (ptable->params.type) {
-	case DPA_CLS_TBL_INDEXED:
-		err = table_insert_entry_indexed(ptable,
-						key,
-						action,
-						entry_id);
-		break;
 	case DPA_CLS_TBL_HASH:
 		err = table_insert_entry_hash(ptable,
 						key,
@@ -363,14 +374,8 @@ int dpa_classif_table_insert_entry(int				td,
 						priority,
 						entry_id);
 		break;
-#ifdef DPA_OFFLOAD_DEBUG
 	default:
-		pr_err("ERROR: %s, %s (%d): Unknown table type (%d).\n",
-			__FILE__, __func__, __LINE__,
-			(int)ptable->params.type);
-		err = -EINVAL;
-		break;
-#endif /* DPA_OFFLOAD_DEBUG */
+		BUG_ON(0);
 	}
 
 	return err;
@@ -457,8 +462,13 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		return -ENOSYS;
 	}
 
-	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
-	entry_index	= ptable->entry[entry_id].entry_index;
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		cc_node_index	= 0;
+		entry_index	= entry_id;
+	} else {
+		cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
+		entry_index	= ptable->entry[entry_id].entry_index;
+	}
 
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	switch (mod_params->type) {
@@ -578,7 +588,6 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	/* If a shadow table exists, update the data in the shadow table */
 	if (ptable->shadow_table) {
 		if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-
 			shadow_list_entry =
 				ptable->shadow_table->
 					shadow_entry[entry_index].next;
@@ -589,7 +598,6 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 			key	= NULL;
 			action	= &shadow_entry_indexed->action;
 		} else {
-
 			shadow_list_entry =
 					ptable->entry[entry_id].shadow_entry;
 			shadow_entry = list_entry(shadow_list_entry,
@@ -671,7 +679,6 @@ EXPORT_SYMBOL(dpa_classif_table_delete_entry_by_key);
 int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 {
 	t_Error err;
-	t_FmPcdCcNextEngineParams next_engine_params;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	uint8_t entry_index;
@@ -699,29 +706,9 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
 	int_cc_node = &ptable->int_cc_node[cc_node_index];
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		/*
-		 * Cannot remove an entry from an indexed table. We will
-		 * replace it with DROP
-		 */
-		memset(&next_engine_params, 0,
-			sizeof(t_FmPcdCcNextEngineParams));
-		next_engine_params.nextEngine = e_FM_PCD_DONE;
-		next_engine_params.params.enqueueParams.action =
-			e_FM_PCD_DROP_FRAME;
-		next_engine_params.statisticsEn = FALSE;
-		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
-						entry_index,
-						&next_engine_params);
-		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyNextEngine failed\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-
-		/* No indexes updates are necessary for the indexed table */
+		pr_err("ERROR: %s, %s (%d): Delete entry is not allowed on an "
+			" indexed table.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
 	} else {
 		/* For all the other tables types we can remove the key */
 		err = FM_PCD_MatchTableRemoveKey(cc_node,
@@ -892,8 +879,7 @@ int dpa_classif_table_flush(int td)
 {
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
-	t_FmPcdCcNextEngineParams next_engine_params;
-	unsigned int cc_node_index;
+	unsigned int cc_node_index, i;
 	t_Error err;
 	struct dpa_cls_table *ptable;
 	t_Handle cc_node;
@@ -912,45 +898,19 @@ int dpa_classif_table_flush(int td)
 		return 0;
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		memset(&next_engine_params, 0,
-			sizeof(t_FmPcdCcNextEngineParams));
-		next_engine_params.nextEngine = e_FM_PCD_DONE;
-		next_engine_params.params.enqueueParams.action =
-			e_FM_PCD_DROP_FRAME;
-		next_engine_params.statisticsEn = FALSE;
-
-		cc_node = (t_Handle)ptable->int_cc_node[0].cc_node;
-		list_for_each_entry(index_entry,
-				&ptable->entry_list,
-				list_node) {
-			err = FM_PCD_MatchTableModifyNextEngine(cc_node,
-						index_entry->entry_index,
-						&next_engine_params);
-			if (err != E_OK) {
-				pr_err("ERROR: %s, %s (%d): "
-					"FM_PCD_MatchTableModifyNextEngine "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
-				pr_err("ERROR: %s, %s (%d): FMan driver call "
-					"failed.\n", __FILE__, __func__,
-					__LINE__);
-				return -EBUSY;
-			}
-			index_entry->valid = 0;
-
-			/* Clean up associated shadow entry if it exists */
-			if (index_entry->shadow_entry) {
+		if (ptable->shadow_table) {
+			for (i = 0;
+				i < ptable->params.indexed_params.entries_cnt;
+									i++) {
 				shadow_entry_indexed =
-					list_entry(index_entry->shadow_entry,
-				struct dpa_cls_tbl_shadow_entry_indexed,
-				list_node);
+			list_entry(ptable->shadow_table->shadow_entry[i].next,
+			struct dpa_cls_tbl_shadow_entry_indexed,
+			list_node);
 
 				list_del(&shadow_entry_indexed->list_node);
 				kfree(shadow_entry_indexed);
 			}
 		}
-		INIT_LIST_HEAD(&ptable->entry_list);
-		ptable->int_cc_node[0].used = 0;
 	} else {
 		/* Flush the table from tail to head to avoid having to update
 		 * the remaining entry indexes all the time */
@@ -1199,6 +1159,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	uint8_t i;
 	t_FmPcdCcNextEngineParams next_engine_params;
 	t_Handle cc_node;
+	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry;
 
 	BUG_ON(!cls_table);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
@@ -1212,28 +1173,11 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	cls_table->int_cc_node[0].cc_node = cls_table->params.cc_node;
 	cls_table->int_cc_node[0].table_size =
 		cls_table->params.indexed_params.entries_cnt;
+	/* Indexed table is always pre-populated: */
+	cls_table->int_cc_node[0].used =
+		cls_table->params.indexed_params.entries_cnt;
 
-	/* Initialize all the actions in the indexed table with DROP */
-	memset(&next_engine_params, 0, sizeof(t_FmPcdCcNextEngineParams));
-	next_engine_params.nextEngine = e_FM_PCD_DONE;
-	next_engine_params.params.enqueueParams.action = e_FM_PCD_DROP_FRAME;
-
-	cc_node	= (t_Handle)cls_table->params.cc_node;
-	for (i = 0; i < cls_table->params.indexed_params.entries_cnt; i++) {
-		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
-						i,
-						&next_engine_params);
-		if (err != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
-			return -EBUSY;
-		}
-	}
-
-	/* Allocate the index management array */
+	/* Allocate and initialize the index management array */
 	cls_table->entries_cnt = cls_table->params.indexed_params.entries_cnt;
 	cls_table->entry =
 		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
@@ -1247,6 +1191,55 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	}
 	INIT_LIST_HEAD(&cls_table->entry_list);
 
+	for (i = 0; i < cls_table->entries_cnt; i++) {
+		/* Clean up and prepare the index entry */
+		memset(&cls_table->entry[i], 0,
+			sizeof(struct dpa_cls_tbl_entry));
+		cls_table->entry[i].valid	= 1;
+		cls_table->entry[i].entry_index	= i;
+	}
+
+	/*
+	 * If we have a shadow table, import the actions from the indexed Cc
+	 * node now
+	 */
+	if (cls_table->shadow_table) {
+		cc_node	= (t_Handle)cls_table->params.cc_node;
+		for (i = 0; i < cls_table->params.indexed_params.entries_cnt;
+									i++) {
+			err = FM_PCD_MatchTableGetNextEngine(cc_node,
+							i,
+							&next_engine_params);
+			if (err != E_OK) {
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableGetNextEngine "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
+
+			shadow_entry = kzalloc(sizeof(*shadow_entry),
+								GFP_KERNEL);
+			if (!shadow_entry) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"importing indexed entries into DPA "
+					"Classifier.\n", __FILE__, __func__,
+					__LINE__);
+				return -ENOMEM;
+			}
+
+			next_engine_params_to_action(&next_engine_params,
+				&shadow_entry->action);
+
+			/* Add entry to the shadow table. */
+			list_add(&shadow_entry->list_node,
+				&cls_table->shadow_table->shadow_entry[i]);
+		}
+	}
+
 	return 0;
 }
 
@@ -1535,91 +1528,6 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 	return NULL;
 }
 
-static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
-			const struct dpa_offload_lookup_key	*key,
-			const struct dpa_cls_tbl_action		*action,
-			int					*entry_id)
-{
-	t_Error err;
-	int errno = 0;
-	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry = NULL;
-	t_FmPcdCcNextEngineParams next_engine_params;
-	t_Handle cc_node;
-
-	BUG_ON(!cls_table);
-	BUG_ON(!key);
-	BUG_ON(!action);
-	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
-
-	if (key->size != 1) {
-		pr_err("ERROR: %s, %s (%d): Bad key format for index table. "
-			"Key size must be 1.\n", __FILE__, __func__, __LINE__);
-		return -EINVAL;
-	}
-
-	/* Check the index management array if the entry is already used */
-	if (cls_table->entry[key->byte[0]].valid)
-		return -EEXIST;
-
-	memset(&next_engine_params, 0 , sizeof(next_engine_params));
-	errno = action_to_next_engine_params(action, &next_engine_params);
-	if (errno < 0)
-		return errno;
-
-	cc_node	= (t_Handle)cls_table->int_cc_node[0].cc_node;
-	/* Considering the index as the first byte in the key... */
-	err = FM_PCD_MatchTableModifyNextEngine(cc_node,
-					key->byte[0],
-					&next_engine_params);
-	if (err != E_OK) {
-		pr_err("ERROR: %s, %s (%d): "
-			"FM_PCD_MatchTableModifyNextEngine failed.\n",
-			__FILE__, __func__, __LINE__);
-		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-			__FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
-
-	cls_table->int_cc_node[0].used++;
-
-	/* If a shadow table exists, add the action to it */
-	if (cls_table->shadow_table) {
-		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
-		if (!shadow_entry) {
-			pr_err("ERROR: %s, %s (%d): No more memory for a new "
-				"DPA Classifier table entry.\n",
-				__FILE__, __func__, __LINE__);
-			return -ENOMEM;
-		}
-
-		memcpy(&shadow_entry->action, action,
-			sizeof(struct dpa_cls_tbl_action));
-
-		/*
-		 * Add entry to the shadow table. Shadow table is actually
-		 * indexed with the first byte of the entry key
-		 */
-		list_add(&shadow_entry->list_node,
-			&cls_table->shadow_table->shadow_entry[key->byte[0]]);
-	}
-
-	/* Clean up and prepare the index entry */
-	memset(&cls_table->entry[key->byte[0]], 0,
-		sizeof(struct dpa_cls_tbl_entry));
-	cls_table->entry[key->byte[0]].valid		= 1;
-	cls_table->entry[key->byte[0]].entry_index	= key->byte[0];
-
-	/*
-	 * Index management list is not necessary to be updated for indexed
-	 * tables.
-	 */
-
-	if (entry_id)
-		*entry_id = key->byte[0];
-
-	return 0;
-}
-
 static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			const struct dpa_offload_lookup_key	*key,
 			const struct dpa_cls_tbl_action		*action,
@@ -2099,14 +2007,91 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 	return 0;
 }
 
+static int next_engine_params_to_action(const t_FmPcdCcNextEngineParams
+	*next_engine_params, struct dpa_cls_tbl_action *action)
+{
+	BUG_ON(!action);
+	BUG_ON(!next_engine_params);
+
+	if (next_engine_params->statisticsEn == TRUE)
+		action->enable_statistics = true;
+
+	switch (next_engine_params->nextEngine) {
+	case e_FM_PCD_DONE:
+		switch (next_engine_params->params.enqueueParams.action) {
+		case e_FM_PCD_ENQ_FRAME:
+			action->type = DPA_CLS_TBL_ACTION_ENQ;
+		action->enq_params.hmd = DPA_OFFLD_DESC_NONE;
+		action->enq_params.new_fqid =
+			next_engine_params->params.enqueueParams.newFqid;
+		if (next_engine_params->params.enqueueParams.overrideFqid ==
+			TRUE)
+			action->enq_params.override_fqid = true;
+		action->enq_params.policer_params = NULL;
+			break;
+		case e_FM_PCD_DROP_FRAME:
+			action->type = DPA_CLS_TBL_ACTION_DROP;
+			break;
+		default:
+			pr_warn("WARNING: DPA Classifier does not directly "
+				"support this type of e_FM_PCD_DONE action "
+				"(%d).\n", next_engine_params->params.
+				enqueueParams.action);
+			action->type = DPA_CLS_TBL_ACTION_NONE;
+			break;
+		}
+		break;
+	case e_FM_PCD_PLCR:
+		action->type = DPA_CLS_TBL_ACTION_ENQ;
+		action->enq_params.new_fqid =
+				next_engine_params->params.plcrParams.newFqid;
+		action->enq_params.override_fqid = true;
+		action->enq_params.hmd = DPA_OFFLD_DESC_NONE;
+		if (next_engine_params->params.plcrParams.overrideParams ==
+			TRUE)
+			action->enq_params.policer_params->
+				modify_policer_params = true;
+		action->enq_params.policer_params->new_rel_profile_id =
+			next_engine_params->params.plcrParams.
+				newRelativeProfileId;
+		if (next_engine_params->params.plcrParams.sharedProfile ==
+			TRUE)
+			action->enq_params.policer_params->shared_profile =
+				next_engine_params->params.plcrParams.
+					sharedProfile;
+		break;
+	case e_FM_PCD_CC:
+	case e_FM_PCD_HASH:
+		action->type = DPA_CLS_TBL_ACTION_NEXT_TABLE;
+		action->next_table_params.next_td =
+			handle_to_td(next_engine_params->params.ccParams.
+				h_CcNode);
+		break;
+	default:
+		pr_warn("WARNING: DPA Classifier does not directly support "
+			"this type of NextEngine parameters (%d).\n",
+			next_engine_params->nextEngine);
+		action->type = DPA_CLS_TBL_ACTION_NONE;
+	}
+
+	return 0;
+}
+
 static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 	const struct dpa_offload_lookup_key *key)
 {
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct list_head *shadow_list_entry;
 
-	if (cls_table->params.type == DPA_CLS_TBL_INDEXED)
+	if (cls_table->params.type == DPA_CLS_TBL_INDEXED) {
+		if (key->size != 1) {
+			pr_err("ERROR: %s, %s (%d): Bad key format for index "
+				"table. Key size must be 1.\n", __FILE__,
+				__func__, __LINE__);
+			return -EINVAL;
+		}
 		return (int)key->byte[0];
+	}
 
 	if (!cls_table->shadow_table) {
 		pr_err("ERROR: %s, %s (%d): Cannot use runtime functions based "
@@ -2130,6 +2115,27 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 	return shadow_entry->entry_id;
 }
 
+static int handle_to_td(void *cc_node)
+{
+	int i;
+	struct dpa_cls_table *table;
+
+	for (i = 0; i < table_array.num_descriptors; i++) {
+		if (table_array.object[i]) {
+			table = (struct dpa_cls_table *) table_array.object[i];
+			if ((unsigned long)table->params.cc_node ==
+				(unsigned long)cc_node)
+				break;
+		}
+	}
+
+	if (i < table_array.num_descriptors)
+		return i;
+	else
+		/* No matching classification table found */
+		return DPA_OFFLD_DESC_NONE;
+}
+
 static int extend_descriptor_table(struct dpa_cls_descriptor_table *desc_table)
 {
 	unsigned int new_table_size = 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 1f58845..fd55f41 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -296,12 +296,6 @@ static int	verify_table_params(const struct dpa_cls_tbl_params *params);
 static struct list_head *find_shadow_entry(const struct dpa_cls_table
 			*cls_table, const struct dpa_offload_lookup_key *key);
 
-/* Add a new entry in an indexed table. */
-static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
-			const struct dpa_offload_lookup_key	*key,
-			const struct dpa_cls_tbl_action		*action,
-			int					*entry_id);
-
 /* Add a new entry in an exact match table. */
 static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			const struct dpa_offload_lookup_key	*key,
@@ -316,11 +310,18 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 			int					*entry_id);
 
 /*
- * Translates action parameters into next engine
- * parameters for use with the low level driver (FMD).
+ * Translates action parameters into next engine parameters for use with the
+ * low level driver (FMD).
  */
 static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
-			*action, t_FmPcdCcNextEngineParams *next_engine_params);
+	*action, t_FmPcdCcNextEngineParams *next_engine_params);
+
+/*
+ * Translates next engine parameters (from FMD) into action parameters for use
+ * with the DPA Classifier.
+ */
+static int	next_engine_params_to_action(const t_FmPcdCcNextEngineParams
+	*next_engine_params, struct dpa_cls_tbl_action *action);
 
 /*
  * Finds the entry_id reference of a table entry specified
@@ -330,6 +331,12 @@ static int	key_to_entry_id(const struct dpa_cls_table *cls_table,
 	const struct dpa_offload_lookup_key *key);
 
 /*
+ * Finds the table which is based on a specified Cc node and returns its
+ * descriptor.
+ */
+static int	handle_to_td(void *cc_node);
+
+/*
  * Extends with one more step an existing descriptor table. The array is
  * reallocated with a constant number of new elements which is defined by the
  * DPA Classifier implementation.
-- 
1.7.5.4

