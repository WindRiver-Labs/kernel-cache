From 6395b74f50852923bcf1ceeeb4ab5f5469356100 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:16:54 +0000
Subject: [PATCH 220/518] Updated Classifier code to use BUG_ON for assert
 conditions

replaced xx_assert with BUG_ON macro

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   68 +++++++++++-----------
 1 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index e757b97..254a8f2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -1061,7 +1061,7 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 {
 	int err = 0;
 
-	xx_assert(cls_table);
+	BUG_ON(!cls_table);
 
 	/* Allocate the necessary table management tools */
 	cls_table->int_cc_node =
@@ -1083,7 +1083,7 @@ alloc_table_mgmt_error:
 
 static void free_table_management(struct dpa_cls_table *cls_table)
 {
-	xx_assert(cls_table);
+	BUG_ON(!cls_table);
 
 	kfree(cls_table->int_cc_node);
 
@@ -1098,9 +1098,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	t_FmPcdCcNextEngineParams next_engine_params;
 	t_Handle cc_node;
 
-	xx_assert(cls_table);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_INDEXED);
-	xx_assert(cls_table->int_cc_nodes_count == 1);
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
+	BUG_ON(cls_table->int_cc_nodes_count != 1);
 
 	errno = alloc_table_management(cls_table);
 	if (errno < 0)
@@ -1153,8 +1153,8 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	t_Error err_code;
 	t_Handle fm_pcd, cc_node;
 
-	xx_assert(cls_table);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_HASH);
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
 
 	err = alloc_table_management(cls_table);
 	if (err < 0)
@@ -1261,8 +1261,8 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	unsigned int i;
 	t_Handle fm_pcd;
 
-	xx_assert(cls_table);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_EXACT_MATCH);
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
 
 	err = alloc_table_management(cls_table);
 	if (err < 0)
@@ -1366,8 +1366,8 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 	t_Error err;
 	t_Handle cc_node;
 
-	xx_assert(cls_table);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_HASH);
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
 
 	cc_node = (t_Handle)cls_table->params.cc_node;
 	for (i = 0; (i < cls_table->int_cc_nodes_count) &&
@@ -1413,8 +1413,8 @@ static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
 	t_Error err;
 	t_Handle cc_node;
 
-	xx_assert(cls_table);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_EXACT_MATCH);
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
 
 	/* Uncouple the first Cc node from the initial one */
 	memset(&cc_miss_engine_params, 0, sizeof(cc_miss_engine_params));
@@ -1448,7 +1448,7 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 	int err = 0;
 	unsigned int num_sets;
 
-	xx_assert(params);
+	BUG_ON(!params);
 
 	switch (params->type) {
 	case DPA_CLS_TBL_EXACT_MATCH:
@@ -1553,9 +1553,9 @@ static struct list_head *find_shadow_entry(const struct dpa_cls_table
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 	uint8_t masked_key[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 
-	xx_assert(cls_table);
-	xx_assert(key);
-	xx_assert(cls_table->shadow_table);
+	BUG_ON(!cls_table);
+	BUG_ON(!key);
+	BUG_ON(!cls_table->shadow_table);
 
 	shadow_table = cls_table->shadow_table;
 	if (cls_table->params.type == DPA_CLS_TBL_INDEXED) {
@@ -1618,10 +1618,10 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	t_FmPcdCcNextEngineParams next_engine_params;
 	t_Handle cc_node;
 
-	xx_assert(cls_table);
-	xx_assert(key);
-	xx_assert(action);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_INDEXED);
+	BUG_ON(!cls_table);
+	BUG_ON(!key);
+	BUG_ON(!action);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
 
 	/* Check the index management array if the entry is already used */
 	if (cls_table->entry[key->byte[0]].valid)
@@ -1707,10 +1707,10 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	struct dpa_cls_tbl_entry *index_entry;
 	struct list_head *list_current;
 
-	xx_assert(cls_table);
-	xx_assert(key);
-	xx_assert(action);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_EXACT_MATCH);
+	BUG_ON(!cls_table);
+	BUG_ON(!key);
+	BUG_ON(!action);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_EXACT_MATCH);
 
 	memset(&key_params, 0, sizeof(t_FmPcdCcKeyParams));
 
@@ -1750,7 +1750,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		if (!cls_table->entry[k].valid)
 			break;
 
-	xx_assert(k < cls_table->entries_cnt);
+	BUG_ON(k == cls_table->entries_cnt);
 
 	/* Clean up and prepare the index entry */
 	memset(&cls_table->entry[k], 0,
@@ -1767,7 +1767,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		list_current = &cls_table->entry_list;
 	else {
 		if (cls_table->params.exact_match_params.use_priorities) {
-			xx_assert(cls_table->entry[k].int_cc_node_index == 0);
+			BUG_ON(cls_table->entry[k].int_cc_node_index != 0);
 
 			/*
 			 * Have to recalculate the position of this entry based
@@ -1943,10 +1943,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	struct list_head *list_current;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_assert(cls_table);
-	xx_assert(key);
-	xx_assert(action);
-	xx_assert(cls_table->params.type == DPA_CLS_TBL_HASH);
+	BUG_ON(!cls_table);
+	BUG_ON(!key);
+	BUG_ON(!action);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
 
 	memset(&key_params, 0, sizeof(t_FmPcdCcKeyParams));
 
@@ -1970,7 +1970,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	hash_set_index = (uint64_t)(hash_set_index & cls_table->hash_mask) >>
 		(8 * (6 - cls_table->params.hash_params.hash_offs) + 4);
 
-	xx_assert(hash_set_index < cls_table->int_cc_nodes_count);
+	BUG_ON(hash_set_index >= cls_table->int_cc_nodes_count);
 
 	/* Check if there are entries still available in the selected set */
 	if (cls_table->int_cc_node[hash_set_index].used >=
@@ -2074,8 +2074,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 {
 	struct dpa_cls_table *next_table;
 
-	xx_assert(action);
-	xx_assert(next_engine_params);
+	BUG_ON(!action);
+	BUG_ON(!next_engine_params);
 
 	memset(next_engine_params, 0, sizeof(t_FmPcdCcNextEngineParams));
 
-- 
1.7.5.4

