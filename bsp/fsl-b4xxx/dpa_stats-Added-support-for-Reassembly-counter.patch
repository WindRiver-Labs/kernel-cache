From 76264467b1564aa3629ebb8a95f00b0e1e0f8430 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:53:51 +0000
Subject: [PATCH 253/518] dpa_stats: Added support for Reassembly counter

Added support for Reassembly single and class counter. Application
can use this counter to retrieve statistics for IP Reassembly
mechanism and/or IP protocol: IPv4 and IPv6

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  270 +++++++++++++++++++++++++++
 include/linux/fsl_dpa_stats.h               |  103 ++++++++++
 2 files changed, 373 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 61f901d..459c176 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -300,6 +300,88 @@ static void create_cnt_eth_stats(struct dpa_stats *dpa_stats)
 	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][19] = 0;
 }
 
+static void create_cnt_reass_stats(struct dpa_stats *dpa_stats)
+{
+	struct t_FmPcdManipReassemIpStats stats;
+
+	/* DPA_STATS_CNT_REASS_TIMEOUT */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][0] =
+			(void *)&stats.timeout - (void *)&stats;
+	/* DPA_STATS_CNT_REASS_RFD_POOL_BUSY */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][1] =
+			(void *)&stats.rfdPoolBusy - (void *)&stats;
+	/* DPA_STATS_CNT_REASS_INT_BUFF_BUSY */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][2] =
+			(void *)&stats.internalBufferBusy - (void *)&stats;
+	/* DPA_STATS_CNT_REASS_EXT_BUFF_BUSY */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][3] =
+			(void *)&stats.externalBufferBusy - (void *)&stats;
+	/* DPA_STATS_CNT_REASS_SG_FRAGS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][4] =
+			(void *)&stats.sgFragments - (void *)&stats;
+	/* DPA_STATS_CNT_REASS_DMA_SEM */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][5] =
+			(void *)&stats.dmaSemaphoreDepletion - (void *)&stats;
+
+	/* DPA_STATS_CNT_REASS_IPv4_FRAMES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][7] = (void *)
+			&stats.specificHdrStatistics[0].successfullyReassembled
+			- (void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = (void *)
+			&stats.specificHdrStatistics[0].validFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][9] = (void *)
+			&stats.specificHdrStatistics[0].processedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][10] = (void *)
+			&stats.specificHdrStatistics[0].malformedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][11] = (void *)
+			&stats.specificHdrStatistics[0].discardedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][12] = (void *)
+			&stats.specificHdrStatistics[0].autoLearnBusy -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][13] = (void *)
+			&stats.specificHdrStatistics[0].moreThan16Fragments -
+			(void *)&stats;
+
+	/* DPA_STATS_CNT_REASS_IPv6_FRAMES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][15] = (void *)
+			&stats.specificHdrStatistics[1].successfullyReassembled
+			- (void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][16] = (void *)
+			&stats.specificHdrStatistics[1].validFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][17] = (void *)
+			&stats.specificHdrStatistics[1].processedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][18] = (void *)
+			&stats.specificHdrStatistics[1].malformedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][19] = (void *)
+			&stats.specificHdrStatistics[1].discardedFragments -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][20] = (void *)
+			&stats.specificHdrStatistics[1].autoLearnBusy -
+			(void *)&stats;
+	/* DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][21] = (void *)
+			&stats.specificHdrStatistics[1].moreThan16Fragments -
+			(void *)&stats;
+}
+
 static t_Handle get_fman_ethernet_dev_node(
 		struct device_node *parent_dev_node, int port_id)
 {
@@ -446,6 +528,59 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct t_FmPcdManipStats stats;
+	uint32_t cnt_sel = params->reass_params.cnt_sel;
+	int err;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* User can combine counters only from a group */
+	if (!(((cnt_sel != 0) && (cnt_sel <= DPA_STATS_CNT_REASS_GEN_ALL)) ||
+		((cnt_sel >= DPA_STATS_CNT_REASS_IPv4_FRAMES) &&
+		(cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL)) ||
+		((cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES) &&
+		(cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL)))) {
+		pr_err("Invalid Reassembly counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs[0] = params->reass_params.reass;
+	cnt_gen_cb->objs_num = 1;
+
+	/* Check the user-provided reassembly manip */
+	err = FM_PCD_ManipGetStatistics(params->reass_params.reass, &stats);
+	if (err < 0) {
+		pr_err("Invalid Reassembly manip handle\n");
+		return -EINVAL;
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_REASS_GEN_ALL)
+		cnt_sel -= 1;
+	else if (cnt_sel == DPA_STATS_CNT_REASS_IPv4_ALL)
+		cnt_sel = (cnt_sel - 1) &
+			~(DPA_STATS_CNT_REASS_IPv4_FRAMES - 1);
+	else if (cnt_sel == DPA_STATS_CNT_REASS_IPv6_ALL)
+		cnt_sel = (cnt_sel - 1) &
+			~(DPA_STATS_CNT_REASS_IPv6_FRAMES - 1);
+
+	/* Map Reassembly counter selection to Manip statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_REASS], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -504,6 +639,99 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct t_FmPcdManipStats stats;
+	uint32_t cnt_sel = params->reass_params.cnt_sel;
+	uint32_t i = 0;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* User can combine counters only from a group */
+	if (!(((cnt_sel != 0) &&
+		(cnt_sel <= DPA_STATS_CNT_REASS_GEN_ALL)) ||
+		((cnt_sel >= DPA_STATS_CNT_REASS_IPv4_FRAMES) &&
+		(cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL)) ||
+		((cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES) &&
+		(cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL)))) {
+		pr_err("Invalid Reassembly counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs_num = params->class_members;
+
+	for (i = 0; i < params->class_members; i++) {
+		cnt_gen_cb->objs[i] = params->reass_params.reass[i];
+
+		/* Check the user-provided reassembly manip */
+		err = FM_PCD_ManipGetStatistics(cnt_gen_cb->objs[i], &stats);
+		if (err < 0) {
+			pr_err("Invalid Reassembly manip handle\n");
+			return -EINVAL;
+		}
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_REASS_GEN_ALL)
+		cnt_sel -= 1;
+	else if (cnt_sel == DPA_STATS_CNT_REASS_IPv4_ALL)
+		cnt_sel = (cnt_sel - 1) &
+			~(DPA_STATS_CNT_REASS_IPv4_FRAMES - 1);
+	else if (cnt_sel == DPA_STATS_CNT_REASS_IPv6_ALL)
+		cnt_sel = (cnt_sel - 1) &
+			~(DPA_STATS_CNT_REASS_IPv6_FRAMES - 1);
+
+	/* Map Reassembly counter selection to Manip statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_REASS], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
+				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	return 0;
+}
+
+static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
+		struct stats_info *stats_info, void *stats, uint32_t idx)
+{
+	uint32_t j = 0;
+	uint64_t stats_val;
+
+	for (j = 0; j < stats_info->stats_num; j++) {
+		/* Get statistics value */
+		stats_val = (uint64_t)(*((uint32_t *)
+				(stats + stats_info->stats_off[j])));
+
+		/* Check for rollover */
+		if (stats_val < stats_info->last_stats[idx][j])
+			stats_info->stats[idx][j] +=
+				((unsigned long int)0xffffffff -
+				stats_info->last_stats[idx][j]) + stats_val;
+		else
+			stats_info->stats[idx][j] += stats_val -
+				stats_info->last_stats[idx][j];
+
+		/* Store the current value as the last read value */
+		stats_info->last_stats[idx][j] = stats_val;
+
+		/* Write the memory location */
+		*(uint32_t *)(req_cb->request_area) =
+				(uint32_t)stats_info->stats[idx][j];
+
+		/* Update the memory pointer */
+		req_cb->request_area += STATS_VAL_SIZE;
+
+		if (stats_info->reset)
+			stats_info->stats[idx][j] = 0;
+	}
+}
+
 static inline void get_cnt_64bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -559,6 +787,27 @@ static int get_cnt_eth_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_reass_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct t_FmPcdManipStats stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
+		if (err < 0) {
+			pr_err("Couldn't retrieve Reassembly statistics\n");
+			return -ESRCH;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->gen_cb.info,
+				&stats.u.reassem.u.ipReassem, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -599,6 +848,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map each Ethernet counter selection to a FM-MAC statistics */
 	create_cnt_eth_stats(dpa_stats);
 
+	/* Map Reassembly counters to FMAN Reassembly statistics */
+	create_cnt_reass_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -646,6 +898,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_ETH;
 		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
 		break;
+	case DPA_STATS_CNT_REASS:
+		err = set_cnt_reass_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Reassembly counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_REASS;
+		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -716,6 +977,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_ETH;
 		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
 		break;
+	case DPA_STATS_CNT_REASS:
+		err = set_cls_cnt_reass_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Reassembly counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_REASS;
+		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 2f6f6c9..764e37d 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -166,6 +166,90 @@ struct dpa_stats_cnt_eth {
 	uint32_t cnt_sel;
 };
 
+/*
+ * DPA Stats IP Reassembly selection of counters that provide
+ * common information for both IPv4 and IPv6 protocols
+ */
+enum dpa_stats_cnt_reass_gen_sel {
+	/* Number of timeout occurrences */
+	DPA_STATS_CNT_REASS_TIMEOUT		= 0x00000001,
+	/* Number of failed attempts to allocate a Reassembly Frame Descriptor*/
+	DPA_STATS_CNT_REASS_RFD_POOL_BUSY	= 0x00000002,
+	/* Number of internal buffer busy occurrences */
+	DPA_STATS_CNT_REASS_INT_BUFF_BUSY	= 0x00000004,
+	/* Number of external buffer busy occurrences */
+	DPA_STATS_CNT_REASS_EXT_BUFF_BUSY	= 0x00000008,
+	/* Number of Scatter/Gather fragments */
+	DPA_STATS_CNT_REASS_SG_FRAGS		= 0x00000010,
+	/* Number of failed attempts to allocate a DMA semaphore */
+	DPA_STATS_CNT_REASS_DMA_SEM		= 0x00000020,
+	/* Select all counters from dpa_stats_cnt_reass_common_sel */
+	DPA_STATS_CNT_REASS_GEN_ALL		= 0x00000040
+};
+
+/*
+ * DPA Stats IP Reassembly selection of counters that provide
+ * information only for IPv4 protocol
+ */
+enum dpa_stats_cnt_reass_ipv4_sel {
+	/* Number of successfully reassembled IPv4 frames */
+	DPA_STATS_CNT_REASS_IPv4_FRAMES		= 0x00000080,
+	/* Number of valid IPv4 fragments */
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID	 = 0x00000100,
+	/* Number of processed IPv4 fragments */
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL	 = 0x00000200,
+	/* Number of malformed IPv4 fragments */
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED = 0x00000400,
+	/* Number of discarded IPv4 fragments except Timeout condition */
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED = 0x00000800,
+	/* Number of busy conditions due to Automatic Learning Hash access */
+	DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY	 = 0x00001000,
+	/*
+	 * Number of IPv4 fragments occurrences when the number of
+	 * fragments-per-frame exceeds 16
+	 */
+	DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS  = 0x00002000,
+	/* Select all counters from dpa_stats_cnt_reass_ipv4_sel */
+	DPA_STATS_CNT_REASS_IPv4_ALL		 = 0x00004000
+};
+
+/*
+ * DPA Stats IP Reassembly selection of counters that provide
+ * information only for IPv6 protocol
+ */
+enum dpa_stats_cnt_reass_ipv6_sel {
+	/* Number of successfully reassembled IPv6 frames*/
+	DPA_STATS_CNT_REASS_IPv6_FRAMES		= 0x00008000,
+	/* Number of valid IPv6 fragments */
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID	 = 0x00010000,
+	/* Number of processed IPv6 fragments */
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL	 = 0x00020000,
+	/* Number of malformed IPv6 fragments */
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED = 0x00040000,
+	/* Number of discarded IPv6 fragments except Timeout condition */
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED = 0x00080000,
+	/* Number of busy conditions due to Automatic Learning Hash access */
+	DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY  = 0x00100000,
+	/*
+	 * Number of IPv6 fragments occurrences when the number of
+	 * fragments-per-frame exceeds 16
+	 */
+	DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS  = 0x00200000,
+	/* Select all counters from dpa_stats_cnt_reass_ipv6_sel */
+	DPA_STATS_CNT_REASS_IPv6_ALL		 = 0x00400000
+};
+
+/* DPA Stats IP Reassembly counter parameters */
+struct dpa_stats_cnt_reass {
+	/* Pointer to the IP Reassembly object*/
+	void	*reass;
+
+	/* Single or multiple selection of IP Reassembly counters from one of
+	 * the enums: dpa_stats_cnt_reass_gen_sel, dpa_stats_cnt_reass_ipv4_sel
+	 * or dpa_stats_cnt_reass_ipv6_sel */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -175,6 +259,9 @@ struct dpa_stats_cnt_params {
 	union {
 		/* Parameters for Ethernet counter */
 		struct dpa_stats_cnt_eth eth_params;
+
+		/* Parameters for IP Reassembly counter */
+		struct dpa_stats_cnt_reass reass_params;
 	};
 };
 
@@ -187,6 +274,19 @@ struct dpa_stats_cls_cnt_eth {
 	enum dpa_stats_cnt_eth_sel cnt_sel;
 };
 
+/* DPA Stats IP Reassembly class counter parameters */
+struct dpa_stats_cls_cnt_reass {
+	/* Array of pointers of IP Reassembly objects */
+	void	**reass;
+
+	/*
+	 * Single or multiple selections of IP Reassembly counters
+	 * from one of the enums dpa_stats_cnt_reass_gen_sel,
+	 * dpa_stats_cnt_reass_ipv4_sel or dpa_stats_cnt_reass_ipv6_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -199,6 +299,9 @@ struct dpa_stats_cls_cnt_params {
 	union {
 		/* Parameters for Ethernet class counter */
 		struct dpa_stats_cls_cnt_eth eth_params;
+
+		/* Parameters for IP Reassembly class counter */
+		struct dpa_stats_cls_cnt_reass reass_params;
 	};
 };
 
-- 
1.7.5.4

