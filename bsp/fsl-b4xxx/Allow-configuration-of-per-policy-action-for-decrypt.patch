From 6e20d200fcc9b695a49e9cdaa21c3e4717acf1bd Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:14 +0000
Subject: [PATCH 236/518] Allow configuration of per policy action for
 decrypted frames

Add support for per inbound policy (flow) configuration of the
action that should be performed for decrypted frames that passed
inbound policy verification.

If inbound policy verification is disabled or no action is specified
for a policy (i.e NULL), the action that was configured at SA
initialization will be performed for all frames that were decrypted
using that SA, regardless of the inbound policy (flow).

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c       |   28 ++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |   38 +++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |  118 +++++++++++++++++----
 include/linux/fsl_dpa_ipsec.h                     |   37 +++++--
 4 files changed, 183 insertions(+), 38 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index b3e625d..b7cacb6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1138,24 +1138,23 @@ static inline void fill_cls_action_drop(struct dpa_cls_tbl_action *action,
 }
 
 static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
-			     struct dpa_ipsec_policy_entry *policy_entry,
+			     struct dpa_ipsec_pol_frag_params *out_frag,
 			     struct dpa_cls_tbl_header_manip **hm)
 {
 	t_FmPcdManipFragParams *frag_param;
 
 	BUG_ON(!dpa_ipsec);
-	BUG_ON(!policy_entry);
+	BUG_ON(!out_frag);
 	BUG_ON(!hm);
 
 	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
 	frag_param = &pcd_manip_params.u.frag;
 	pcd_manip_params.type = e_FM_PCD_MANIP_FRAG;
 	frag_param->hdr  = HEADER_TYPE_IPv4;
-	frag_param->u.ipFrag.sizeForFragmentation =
-						policy_entry->pol_params.mtu;
+	frag_param->u.ipFrag.sizeForFragmentation = out_frag->mtu;
 	frag_param->u.ipFrag.scratchBpid = dpa_ipsec->config.ipf_bpid;
 	frag_param->u.ipFrag.dontFragAction =
-			pcd_df_action[policy_entry->pol_params.df_action];
+					pcd_df_action[out_frag->df_action];
 	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
 	if (!*hm) {
 		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
@@ -1259,7 +1258,10 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		if (err < 0)
 			return err;
 
-		action = &sa->def_sa_action;
+		if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT)
+			action = &pol_params->dir_params.in_action;
+		else
+			action = &sa->def_sa_action;
 		err = dpa_classif_table_insert_entry(sa->em_inpol_td, &tbl_key,
 					      action,
 					      policy_entry->pol_params.priority,
@@ -1342,8 +1344,11 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			return err;
 
 		/* Configure fragmentation */
-		if (pol_params->mtu) {
-			err = create_frag_manip(dpa_ipsec, policy_entry, &hm);
+		if (pol_params->dir_params.type ==
+						DPA_IPSEC_POL_DIR_PARAMS_FRAG) {
+			err = create_frag_manip(dpa_ipsec,
+					       &pol_params->dir_params.out_frag,
+					       &hm);
 			if (err < 0) {
 				pr_err("Could not create Manip node for fragmentation!\n");
 				return -EAGAIN;
@@ -2211,7 +2216,11 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 		pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
 	}
+
+	/* copy policy parameters */
 	pol_entry->pol_params = *policy_params;
+
+	/* add policy to the SA's policy list */
 	list_add(&pol_entry->node, &sa->policy_headlist);
 
 	*policy_entry = pol_entry;
@@ -2308,7 +2317,10 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 		return -EINVAL;
 	}
 
+	/* unlink this policy from SA's list */
 	list_del(&policy_entry->node);
+
+	/* release memory used for holding policy general parameters */
 	kfree(policy_entry);
 
 	return 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index 046e9b2..0412894 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -139,6 +139,36 @@ struct ioc_dpa_ipsec_add_rem_policy {
 	int sa_id;
 };
 
+#ifdef CONFIG_COMPAT
+struct ioc_compat_pol_dir_params {
+	enum dpa_ipsec_pol_dir_params_type type;
+	union {
+		struct dpa_ipsec_pol_frag_params out_frag;
+		struct dpa_cls_compat_tbl_action in_action;
+	};
+};
+
+struct ioc_compat_policy_params {
+	struct dpa_ipsec_ip_address src_addr;
+	uint8_t src_prefix_len;
+	struct dpa_ipsec_ip_address dest_addr;
+	uint8_t dest_prefix_len;
+	uint8_t protocol;
+	bool masked_proto;
+	union {
+		struct dpa_ipsec_l4_params	l4;
+		struct dpa_ipsec_icmp_params	icmp;
+	};
+	struct dpa_ipsec_pol_dir_params dir_params;
+	int priority;		/* Policy priority			      */
+};
+
+struct ioc_compat_dpa_ipsec_add_rem_policy {
+	struct ioc_compat_policy_params pol_params;
+	int sa_id;
+};
+#endif
+
 struct ioc_dpa_ipsec_rekey_prm {
 	struct dpa_ipsec_sa_params sa_params;
 	int auto_rmv_old_sa;
@@ -200,9 +230,17 @@ struct ioc_dpa_ipsec_sa_get_stats {
 
 #define DPA_IPSEC_IOC_ADD_POLICY \
 	_IOW(DPA_IPSEC_IOC_MAGIC, 4, struct ioc_dpa_ipsec_add_rem_policy)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_ADD_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 4, struct ioc_compat_dpa_ipsec_add_rem_policy)
+#endif
 
 #define DPA_IPSEC_IOC_REMOVE_POLICY \
 	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_dpa_ipsec_add_rem_policy)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_REMOVE_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_compat_dpa_ipsec_add_rem_policy)
+#endif
 
 #define DPA_IPSEC_IOC_SA_REKEYING \
 	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_dpa_ipsec_rekey_prm)
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 481a9a5..2499b36 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -267,6 +267,43 @@ static void compat_copy_dpa_ipsec_rekey_sa(struct ioc_dpa_ipsec_rekey_prm *prm,
 		 */
 }
 
+static void compat_copy_dpa_ipsec_add_rem_policy(
+			struct ioc_dpa_ipsec_add_rem_policy *prm,
+			struct ioc_compat_dpa_ipsec_add_rem_policy *compat_prm,
+			uint8_t compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->sa_id = compat_prm->sa_id;
+		prm->pol_params.src_addr = compat_prm->pol_params.src_addr;
+		prm->pol_params.src_prefix_len =
+					  compat_prm->pol_params.src_prefix_len;
+		prm->pol_params.dest_addr = compat_prm->pol_params.src_addr;
+		prm->pol_params.dest_prefix_len =
+					 compat_prm->pol_params.dest_prefix_len;
+		prm->pol_params.protocol = compat_prm->pol_params.protocol;
+		prm->pol_params.masked_proto =
+					    compat_prm->pol_params.masked_proto;
+		prm->pol_params.l4 = compat_prm->pol_params.l4;
+		memset(&prm->pol_params.dir_params, 0,
+					    sizeof(prm->pol_params.dir_params));
+		if (compat_prm->pol_params.dir_params.type ==
+						DPA_IPSEC_POL_DIR_PARAMS_FRAG)
+			prm->pol_params.dir_params.out_frag =
+				     compat_prm->pol_params.dir_params.out_frag;
+		else if (compat_prm->pol_params.dir_params.type) {
+			dpa_cls_tbl_action_params_compatcpy(
+				  &prm->pol_params.dir_params.in_action,
+				  &compat_prm->pol_params.dir_params.in_action);
+		}
+		prm->pol_params.dir_params.type =
+					 compat_prm->pol_params.dir_params.type;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
 static void compat_copy_dpa_ipsec_get_pols(
 			struct ioc_dpa_ipsec_get_policies *prm,
 			struct ioc_compat_dpa_ipsec_get_policies *compat_prm,
@@ -712,6 +749,56 @@ free_rekey_sa_mem:
 	return err;
 }
 
+static int do_add_rem_policy_ioctl(void *args, bool add_pol, bool compat)
+{
+	struct ioc_dpa_ipsec_add_rem_policy prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_add_rem_policy compat_prm;
+#endif
+	struct dpa_cls_tbl_policer_params *policer_prm = NULL;
+	int err;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm,
+			   (struct ioc_compat_dpa_ipsec_add_rem_policy *) args,
+			    sizeof(compat_prm))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_add_rem_policy(&prm, &compat_prm,
+						     COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm,
+			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
+			    sizeof(prm))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+
+	if (prm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+		err = copy_policer_params(&prm.pol_params.dir_params.in_action,
+					  &policer_prm);
+		if (err < 0) {
+			if (!policer_prm)
+				return err;
+			else
+				goto free_pol_memory;
+		}
+	}
+
+	if (add_pol)
+		err = dpa_ipsec_sa_add_policy(prm.sa_id, &prm.pol_params);
+	else
+		err = dpa_ipsec_sa_remove_policy(prm.sa_id, &prm.pol_params);
+
+free_pol_memory:
+	kfree(policer_prm);
+
+	return err;
+}
+
 static int do_sa_get_policies_ioctl(void *args, bool compat)
 {
 	struct ioc_dpa_ipsec_get_policies prm;
@@ -903,34 +990,19 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_ADD_POLICY_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_ADD_POLICY: {
-		struct ioc_dpa_ipsec_add_rem_policy pol;
-		if (copy_from_user(&pol,
-			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
-			    sizeof(pol))) {
-			pr_err("Could not copy parameters");
-			return -EINVAL;
-		}
-		err = dpa_ipsec_sa_add_policy(pol.sa_id,
-					      &pol.pol_params);
-		if (err < 0)
-			return err;
+		ret = do_add_rem_policy_ioctl((void *)args, true, compat);
 		break;
 	}
 
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_REMOVE_POLICY_COMPAT:
+#endif
 	case DPA_IPSEC_IOC_REMOVE_POLICY: {
-		struct ioc_dpa_ipsec_add_rem_policy pol;
-		if (copy_from_user(&pol,
-			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
-			    sizeof(pol))) {
-			pr_err("Could not copy parameters\n");
-			return -EINVAL;
-		}
-
-		err = dpa_ipsec_sa_remove_policy(pol.sa_id,
-						 &pol.pol_params);
-		if (err < 0)
-			return err;
+		ret = do_add_rem_policy_ioctl((void *)args, false, compat);
 		break;
 	}
 
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index ddc1ce9..61f054e 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -448,6 +448,35 @@ struct dpa_ipsec_icmp_params {
 	uint8_t	icmp_code_mask; /* Mask for ICMP code field		      */
 };
 
+/* DPA IPSec direction specific policy params types */
+enum dpa_ipsec_pol_dir_params_type {
+	DPA_IPSEC_POL_DIR_PARAMS_NONE = 0, /* No direction specific params */
+	DPA_IPSEC_POL_DIR_PARAMS_FRAG, /* Frag params (outbound policies only)*/
+	DPA_IPSEC_POL_DIR_PARAMS_ACT, /* Action params (inbound policies only)*/
+};
+
+/* DPA IPSec outbound policies params (fragmentation params) */
+struct dpa_ipsec_pol_frag_params {
+	uint16_t mtu;		/* Maximum size of unencrypted fragments.
+				 * Packets with a bigger size will be
+				 * automatically fragmented. 0 = disabled     */
+	enum dpa_ipsec_df_action df_action; /* Action to be performed when IP
+					     * fragmentation is configured for
+					     * this flow and the DF bit is set
+					     * in the input frame             */
+};
+
+/* DPA IPSec direction specific parameters for Security Policies */
+struct dpa_ipsec_pol_dir_params {
+	enum dpa_ipsec_pol_dir_params_type type;
+	union {
+		struct dpa_ipsec_pol_frag_params out_frag;
+		struct dpa_cls_tbl_action in_action; /* Action to be performed
+						      * for frames matching
+						      * the policy selectors  */
+	};
+};
+
 /* DPA-IPSec Security Policy Parameters */
 struct dpa_ipsec_policy_params {
 	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
@@ -460,13 +489,7 @@ struct dpa_ipsec_policy_params {
 		struct dpa_ipsec_l4_params	l4;	/* L4 protos params   */
 		struct dpa_ipsec_icmp_params	icmp;	/* ICMP proto params  */
 	};
-	uint16_t mtu;		/* Maximum size of unencrypted fragments.
-				 * Packets with a bigger size will be
-				 * automatically fragmented. 0 = disabled     */
-	enum dpa_ipsec_df_action df_action; /* Action to be performed when IP
-					     * fragmentation is configured for
-					     * this flow and the DF bit is set
-					     * in the input frame             */
+	struct dpa_ipsec_pol_dir_params dir_params;
 	int priority;		/* Policy priority			      */
 };
 
-- 
1.7.5.4

