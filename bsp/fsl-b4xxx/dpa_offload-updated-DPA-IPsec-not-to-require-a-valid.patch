From e6a5369d3ac0f772bd69c379e670beaa0e2d9069 Mon Sep 17 00:00:00 2001
From: Andrei Varvara <andrei.varvara@freescale.com>
Date: Tue, 23 Apr 2013 17:06:18 +0300
Subject: [PATCH] dpa_offload: updated DPA IPsec not to require a valid index
 table

Index table was mandatory when initializing the dpa ipsec.
If upper layer does not require action per SA after decryption,
then there is no need for a valid index table.

Updated the code so that index table is no longer mandatory.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Delivered from the Freescale directly.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   75 ++++++++++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    8 +++
 2 files changed, 64 insertions(+), 19 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index a8c80ca..ba6e8a7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -270,11 +270,17 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
-	/* post decryption SA classification table */
-	if (prms->post_sec_in_params.dpa_cls_td ==
-						  DPA_OFFLD_DESC_NONE) {
-		pr_err("Specify a valid table for post decryption classification\n");
-		return -EINVAL;
+	/*
+	 * In classification base on SA that decrypted traffic is not required
+	 * than the post decryption classification table could be invalid.
+	 * In this case inbound policy verification is not supported.
+	 */
+	if (prms->post_sec_in_params.dpa_cls_td == DPA_OFFLD_DESC_NONE) {
+		if (prms->post_sec_in_params.do_pol_check) {
+			pr_err("Index table required policy check enabled\n");
+			return -EINVAL;
+		}
+		goto skip_post_decryption_check;
 	}
 
 	/* get post decryption table parameters */
@@ -301,6 +307,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
+skip_post_decryption_check:
 	/* check pre decryption SA lookup tables */
 	valid_tables = 0;
 	pre_sec_in_prms = &prms->pre_sec_in_params;
@@ -911,12 +918,22 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		sa[i].inbound_sa_td = DPA_OFFLD_DESC_NONE;
 	}
 
-	err = create_inbound_flowid_cq(dpa_ipsec);
-	if (err < 0) {
-		pr_err("Could not create inbound policy flow id cq\n");
-		return err;
+	/*
+	 * Inbound flow id circular queue is required only if a valid index
+	 * table is set.
+	 */
+	if (!ignore_post_ipsec_action(dpa_ipsec)) {
+		err = create_inbound_flowid_cq(dpa_ipsec);
+		if (err < 0) {
+			pr_err("Could not create inbound policy flow id cq\n");
+			return err;
+		}
+	} else {
+		/* Not required */
+		dpa_ipsec->sa_mng.inbound_flowid_cq = NULL;
 	}
 
+
 	/* If policy check is enabled than for every possible inbound SA create
 	 * an Exact Match Table and link it to the Inbound Index Table */
 	if (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) {
@@ -1164,7 +1181,7 @@ static int set_flow_id_action(struct dpa_ipsec_sa *sa,
 	BUG_ON(!sa);
 	BUG_ON(!action);
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
+	dpa_ipsec = sa->dpa_ipsec;
 
 	/* Currently the flowid cannot be greater than 255 */
 	key_data	= (uint8_t)sa->inbound_flowid;
@@ -1960,10 +1977,10 @@ static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 	int err;
 
 	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
 
 	memset(&action, 0, sizeof(action));
 	action.type = DPA_CLS_TBL_ACTION_DROP;
-
 	err = set_flow_id_action(sa, &action);
 	if (err < 0) {
 		pr_err("Could not remove SA entry in indexed table\n");
@@ -1973,9 +1990,6 @@ static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 	if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
 		put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
 
-	err = put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
-	if (err < 0)
-		return err;
 	sa->valid_flowid_entry = false;
 
 	return 0;
@@ -2460,7 +2474,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	BUG_ON(!dpa_ipsec);
 
 	/* reserve a FlowID for this SA only if we are not rekeying */
-	if (!rekeying) {
+	if (!ignore_post_ipsec_action(dpa_ipsec) && !rekeying) {
 		err = get_inbound_flowid(dpa_ipsec, &sa->inbound_flowid);
 		if (err < 0) {
 			pr_err("Can't get valid inbound flow id\n");
@@ -3114,8 +3128,15 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 	/* Free the SA id and FlowID (for inbound SAs only).*/
 	if (sa->sa_dir == DPA_IPSEC_INBOUND &&
-	    sa->inbound_flowid != INVALID_INB_FLOW_ID)
-		put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+	    !ignore_post_ipsec_action(dpa_ipsec) &&
+	    sa->inbound_flowid != INVALID_INB_FLOW_ID) {
+		err_rb = put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+		if (err_rb < 0) {
+			pr_err("Could not put flow id in circular queue.\n");
+			return err_rb;
+		}
+		sa->inbound_flowid = INVALID_INB_FLOW_ID;
+	}
 
 	err_rb = put_sa(sa);
 
@@ -3377,6 +3398,9 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 				goto create_sa_err;
 			}
 		} else {
+			if (ignore_post_ipsec_action(sa->dpa_ipsec))
+				goto sa_done;
+
 			/* Set the post decryption default action */
 			err = set_flow_id_action(sa, &sa->def_sa_action);
 			if (err < 0) {
@@ -3386,7 +3410,8 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		}
 	}
 
-	/* SA done ok. Return the SA id */
+	/* SA done OK. Return the SA id */
+sa_done:
 	*sa_id = id;
 
 	/* Unlock the SA structure */
@@ -3566,7 +3591,8 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 	}
 
 	/* Remove the flow id classification after decryption */
-	if (sa->valid_flowid_entry) {
+	if (!ignore_post_ipsec_action(sa->dpa_ipsec) &&
+	    sa->valid_flowid_entry) {
 		err = remove_inbound_flow_id_classif(sa);
 		if (err < 0)
 			return err;
@@ -3804,6 +3830,17 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		return -EBUSY;
 	}
 
+	BUG_ON(!sa->dpa_ipsec);
+	mutex_lock(&sa->dpa_ipsec->lock);
+	if (sa->sa_dir == DPA_IPSEC_INBOUND &&
+	    !sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		pr_err("Inbound policy verification is disabled.\n");
+		mutex_unlock(&sa->dpa_ipsec->lock);
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+	mutex_unlock(&sa->dpa_ipsec->lock);
+
 	ret = check_policy_params(sa, policy_params);
 	if (ret < 0) {
 		mutex_unlock(&sa->lock);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 39d27f1..d197fd6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -445,4 +445,12 @@ static inline void rekey_err_report(dpa_ipsec_rekey_event_cb rekey_event_cb,
 		rekey_event_cb(dpa_ipsec_id, sa_id, err);
 }
 
+/* If index table is invalid the IPsec action per inbound SA will be ignored  */
+static inline int ignore_post_ipsec_action(struct dpa_ipsec *dpa_ipsec)
+{
+	if (dpa_ipsec->config.post_sec_in_params.dpa_cls_td > 0)
+		return FALSE;
+	return TRUE;
+}
+
 #endif	/* __DPA_IPSEC_H__ */
-- 
1.7.5.4

