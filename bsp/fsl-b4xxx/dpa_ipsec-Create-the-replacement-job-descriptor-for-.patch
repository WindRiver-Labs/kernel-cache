From 14d52e1fa70152b96d410532ea7ea20992899b04 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 15 Feb 2013 22:15:46 +0000
Subject: [PATCH 484/518] dpa_ipsec: Create the replacement job descriptor for
 enabling/changing the anti replay window size

Created the replacement job descriptor for enabling/disabling
the ARS or changing the size of the anti replay window.

On normal execution, this job descriptor will end with a
halt user error. The packet that exits CAAM will have the
SA Id of the SA that was submitted for changing.

The halt with user error is very important for post CAAM
processing. The intended result is for the offline port to
send the frame to the error queue.

Running this job descriptor is done by enquing a frame
descriptor to the FQ to CAAM, with RJD command set and the
address set to point to RJD.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |  187 ++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    1 +
 2 files changed, 188 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 1a6a959..f26c178 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -1482,6 +1482,193 @@ done_shared_desc:
 	return 0;
 }
 
+/*
+ * Create descriptor for updating the anti replay window size
+ * [21] B0951A17       jobhdr: shrsz=21 shr share=serial reo len=23
+ * [22] 00000000               sharedesc->@0x02abb5008
+ * [23] 2ABB5008
+ * [24] 79340008         move: descbuf+0[00] -> math0, len=8 wait
+ * [25] A82CC108         math: (0 - 1)->math1 len=8
+ * [26] AC214108         math: (math1 - imm1)->math1 len=8 ifb
+ * [27] 000000C0               imm1=192
+ * [28] A8501008         math: (math0 & math1)->math0 len=8
+ * [29] 1640180A           ld: deco-descbuf len=10 offs=24
+ * [30] 00000000               ptr->@0x02abb5434
+ * [31] 2ABB5434
+ * [32] A1001001         jump: jsl1 all-match[calm] offset=1 local->[33]
+ * [33] A00000F7         jump: all-match[] always-jump offset=-9 local->[24]
+ * [34] AC404008         math: (math0 | imm1)->math0 len=8 ifb
+ * [35] 000000C0               imm1=192
+ * [36] 79430008         move: math0 -> descbuf+0[00], len=8 wait
+ * [37] 79631804         move: math2 -> descbuf+24[06], len=4 wait
+ * [38] 56420107          str: deco-shrdesc+1 len=7
+ * [39] A8034304         math: (math3 + imm1)->math3 len=4
+ * [40] 00000000               imm1=0
+ * [41] 78720008         move: math3+0 -> ofifo, len=8
+ * [42] 68300008	 seqfifostr: msgdata len=8
+ * [43] A1C01002         jump: jsl1 all-match[calm] halt-user status=2
+ */
+int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw)
+{
+	uint32_t *desc, *rjobd, off;
+	uint8_t options;
+	enum dpa_ipsec_arw c_arw;
+	size_t ars_off;
+	dma_addr_t dma_shdesc;
+
+	/* Check input parameters */
+	BUG_ON(!sa);
+	if (sa->sa_dir != DPA_IPSEC_INBOUND) {
+		pr_err("ARS update not supported for outbound SA %d\n", sa->id);
+		return -EINVAL;
+	}
+
+	BUG_ON(!sa->sec_desc);
+	desc = (uint32_t *)sa->sec_desc->desc;
+	options = (uint8_t)(*(desc + 1) & 0x000000FF);
+	c_arw = options >> 6;
+	if (c_arw == arw) {
+		pr_err("SA %d has already set this ARS %d\n", sa->id, arw);
+		return -EALREADY;
+	}
+
+	/* Get DMA address for this SA shared descriptor */
+	dma_shdesc = dma_map_single(sa->dpa_ipsec->jrdev, sa->sec_desc->desc,
+				    desc_len(sa->sec_desc->desc) * sizeof(u32),
+				    DMA_BIDIRECTIONAL);
+	if (!dma_shdesc) {
+		pr_err("Failed DMA map shared descriptor for SA %d\n", sa->id);
+		return -ENXIO;
+	}
+
+	/* Create replacement job descriptor for ARS update */
+	BUG_ON(!sa->rjob_desc);
+	rjobd = sa->rjob_desc;
+
+	init_job_desc(rjobd, HDR_SHARE_SERIAL | HDR_SHARED | HDR_REVERSE |
+		      (desc_len(sa->sec_desc->desc) << HDR_START_IDX_SHIFT));
+
+	/* Set DMA address of the shared descriptor */
+	append_ptr(rjobd, dma_shdesc);
+
+	/* Retrieve header and options from PDB in MATH 0 */
+	append_move(rjobd, MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | MOVE_WAITCOMP |
+		    (0 << MOVE_OFFSET_SHIFT) | sizeof(u64));
+
+	/* MATH_REG1 = 0xFFFFFFFF_FFFFFFFF */
+	append_math_sub(rjobd, REG1, ZERO, ONE, MATH_LEN_8BYTE);
+
+	/* MATH_REG1 = 0xFFFFFFFF_FFFFFF3F */
+	append_math_sub_imm_u64_ifb(rjobd, REG1, REG1, IMM, 0xC0);
+
+	/* Reset ARS bits */
+	append_math_and(rjobd, REG0, REG0, REG1, MATH_LEN_8BYTE);
+
+	/*
+	 * Overwrite RJD immediately after the SHD pointer i.e shared descriptor
+	 * length plus 1 plus another 3 words
+	 * Offset and length are expressed in words
+	 * 3w - RJD header + SHD pointer
+	 * 5w - five instructions for doing some part of ARS modification
+	 * 3w - load instruction + pointer
+	 * 1w - jump calm
+	 * 1w - jump back to the remaining descriptor
+	 */
+	append_load(rjobd, virt_to_phys((void *)(rjobd + 3 + 5 + 3 + 1 + 1)),
+		    10, LDST_CLASS_DECO | LDST_SRCDST_WORD_DESCBUF |
+		    ((desc_len(sa->sec_desc->desc) + 3) << LDST_OFFSET_SHIFT));
+
+	/* wait for completion o previous operation */
+	append_jump(rjobd, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
+
+	/* jump back to remaining descriptor i.e jump back 9 words */
+	off = (-9) & 0x000000FF;
+	append_jump(rjobd, (off << JUMP_OFFSET_SHIFT));
+
+	/* Convert PDB ARS to new size */
+	switch (arw) {
+	case DPA_IPSEC_ARSNONE:
+		/*
+		 * nothing to do because previous command reseted ARS bits
+		 * add 2 NOPs to conserve descriptor size
+		 */
+		append_cmd(rjobd, 0xA0000001); /* NOP for SEC */
+		append_cmd(rjobd, 0xA0000001); /* NOP for SEC */
+		break;
+	case DPA_IPSEC_ARS32:
+		append_math_or_imm_u64_ifb(rjobd, REG0, REG0, IMM,
+					   PDBOPTS_ESP_ARS32);
+		break;
+	case DPA_IPSEC_ARS64:
+		append_math_or_imm_u64_ifb(rjobd, REG0, REG0, IMM,
+					   PDBOPTS_ESP_ARS64);
+		break;
+	default:
+		pr_err("Invalid ARS\n");
+		BUG();
+	}
+
+	/* Put header and options back to PDB */
+	append_move(rjobd, MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF | MOVE_WAITCOMP |
+		    (0 << MOVE_OFFSET_SHIFT) | sizeof(u64));
+
+	/*
+	 * anti_replay[0] - used for 32ARS - LS bit represent the frame with
+	 * highest SEQ number that has been successfully authenticated so far
+	 * i.e the frame that had SEQ/ESN from PDB seq_num/seq_num_ext_hi
+	 *
+	 * anti_replay[1] - used when 64ARS is configured - LS bit represent
+	 * a frame with a immediate older SEQ number than the MS bit of the
+	 * anti_replay[0] i.e
+	 * SEQ(LS bit of anti_replay[1]) = SEQ(MS bit of anti_replay[0]) - 1;
+	 *
+	 * always reset to 0 all bits from anti_replay[1]
+	 * reset to 0 all bits from anti_replay[0] only if updating from ARS to
+	 * no ARS.
+	 * MOVE_SRC_MATH2 was not used until now i.e has value 0
+	 */
+	ars_off = offsetof(struct ipsec_decap_pdb, anti_replay);
+	if (arw == DPA_IPSEC_ARSNONE)
+		append_move(rjobd, MOVE_SRC_MATH2 | MOVE_DEST_DESCBUF |
+			    MOVE_WAITCOMP | (ars_off << MOVE_OFFSET_SHIFT) |
+			    sizeof(u64));
+	else
+		append_move(rjobd, MOVE_SRC_MATH2 | MOVE_DEST_DESCBUF |
+			    MOVE_WAITCOMP |
+			    ((ars_off + 4) << MOVE_OFFSET_SHIFT) | sizeof(u32));
+
+	/*
+	 * Update shared descriptor in memory - only PDB
+	 * special case - offset and length are in words
+	 */
+	append_store(rjobd, 0, sizeof(struct ipsec_decap_pdb) / sizeof(u32),
+		     LDST_CLASS_DECO | (1 << LDST_OFFSET_SHIFT) |
+		     LDST_SRCDST_WORD_DESCBUF_SHARED);
+
+	append_math_add_imm_u32(rjobd, REG3, REG3, IMM, sa->id);
+
+	/* move: ififo->deco-alnblk -> ofifo, len=4 */
+	append_move(rjobd, MOVE_SRC_MATH3 | MOVE_DEST_OUTFIFO | 8);
+
+	/* seqfifostr: msgdata len=4 */
+	append_seq_fifo_store(rjobd, FIFOST_TYPE_MESSAGE_DATA, 8);
+
+	/*
+	 * Exit replacement job descriptor, halt with user error
+	 * FD status will be a special user error, generated only on request by
+	 * a descriptor command (not by any other circumstance) i.e no confusing
+	 * this frame for any other error. Jump with CALM to be sure previous
+	 * operation was finished
+	 */
+	append_cmd(rjobd, 0xA1C01002);
+
+	dma_unmap_single(sa->dpa_ipsec->jrdev, dma_shdesc,
+			 desc_len(sa->sec_desc->desc) * sizeof(u32),
+			 DMA_BIDIRECTIONAL);
+
+	return 0;
+}
+
 static void split_key_done(struct device *dev, u32 * desc, u32 err,
 			   void *context)
 {
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index 07630f16..16edff4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -90,5 +90,6 @@ struct sec_descriptor {
 int get_sec_info(struct dpa_ipsec *dpa_ipsec);
 int create_sec_descriptor(struct dpa_ipsec_sa *sa);
 int generate_split_key(struct auth_params *auth_param);
+int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw);
 
 #endif	/* _DPA_IPSEC_DESC_H_ */
-- 
1.7.5.4

