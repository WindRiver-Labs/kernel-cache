From b6763b60ee48c36f9a3af817f01d996cddf8ca23 Mon Sep 17 00:00:00 2001
From: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
Date: Thu, 17 May 2012 15:55:46 +0000
Subject: [PATCH 184/518] dpa_offload use case : add FMC and FMD related
 utilities

Signed-off-by: Alexandru BADICIOIU <alexandru.badicioiu@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/fm_utils.c    |  350 +++++++++
 drivers/staging/fsl_dpa_offload/usecases/fmc.h     |  215 ++++++
 .../staging/fsl_dpa_offload/usecases/fmc_exec.c    |  780 ++++++++++++++++++++
 3 files changed, 1345 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc.h
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c

diff --git a/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
new file mode 100644
index 0000000..d2ef5d7
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fm_utils.c
@@ -0,0 +1,350 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fsl_bman.h>
+#include <linux/fsl_qman.h>
+#include <linux/of.h>
+#include <linux/version.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include "lnxwrp_fm.h"
+#include "fmc.h"
+#include "ports_conf.h"
+#include "platform_defs.h"
+
+static struct of_device_id fman_1g_rx_port[] = {
+	{.compatible = "fsl,fman-port-1g-rx",},
+	{}
+};
+
+static struct of_device_id fman_1g_tx_port[] = {
+	{.compatible = "fsl,fman-port-1g-tx",},
+	{}
+};
+
+static struct of_device_id fman_10g_rx_port[] = {
+	{.compatible = "fsl,fman-port-10g-rx",},
+	{}
+};
+
+static struct of_device_id fman_10g_tx_port[] = {
+	{.compatible = "fsl,fman-port-10g-tx",},
+	{}
+};
+
+static struct of_device_id fman_oh_port[] = {
+	{.compatible = "fsl,fman-port-oh",},
+	{}
+};
+
+static struct of_device_id fman[] = {
+	{.compatible = "fsl,fman",},
+	{}
+};
+
+/*
+	Find the base address of dTSEC device
+	@fm_idx : FMAN index (0/1)
+	@port_idx : port index
+*/
+phys_addr_t get_mac_dev(int fm_id, int port_id)
+{
+	struct device_node *eth_dev_temp = NULL, *eth_dev = NULL,
+	    *mac_node = NULL, *fman_node = NULL;
+	const phandle *mac_phandle, *fm_cell_idx, *mac_cell_idx;
+	size_t lenp;
+	const uint32_t *regs_addr;
+	uint64_t regs_size;
+	uint64_t phys_addr;
+
+	eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+					  "fsl,dpa-ethernet-init");
+	while (eth_dev != NULL) {
+		mac_phandle = of_get_property(eth_dev, "fsl,fman-mac", &lenp);
+		if (unlikely(mac_phandle == NULL))
+			goto err;
+
+		mac_node = of_find_node_by_phandle(*mac_phandle);
+		if (unlikely(mac_node == NULL))
+			goto err;
+
+		regs_addr = of_get_address(mac_node, 0, &regs_size, NULL);
+		if (unlikely(regs_addr == NULL))
+			goto err;
+
+		phys_addr = of_translate_address(mac_node, regs_addr);
+		if (unlikely(phys_addr == 0))
+			goto err;
+
+		fman_node = of_get_parent(mac_node);
+		if (!fman_node)
+			goto err;
+
+		fm_cell_idx = of_get_property(fman_node, "cell-index", &lenp);
+		if (!fm_cell_idx)
+			goto err;
+
+		mac_cell_idx = of_get_property(mac_node, "cell-index", &lenp);
+		if (!mac_cell_idx)
+			goto err;
+
+		if ((*mac_cell_idx == port_id) && (*fm_cell_idx == fm_id))
+			return phys_addr;
+
+		eth_dev_temp = eth_dev;
+		eth_dev = of_find_compatible_node(eth_dev_temp, NULL,
+						  "fsl,dpa-ethernet-init");
+	}
+
+err:
+	return 0;
+}
+
+/*
+	Configure a dTSEC to operate in loopback mode
+	fm_idx : FMAN index (0/1)
+	@port_idx : port index
+	@set : 1 to set loopback mode, 0 to reset
+*/
+int config_loopback(int fm_id, int port_idx, int set)
+{
+	char *addr;
+	phys_addr_t mac_phys_addr = 0;
+	u32 val;
+
+	mac_phys_addr = get_mac_dev(fm_id, port_idx);
+	if (!mac_phys_addr)
+		return -ENODEV;
+
+	addr = ioremap(mac_phys_addr, 0x1000);
+	if (!addr) {
+		pr_err("%s : cannot remap mac_phys_addr %llx\n",
+		       __func__, mac_phys_addr);
+		return -ENXIO;
+	}
+
+	val = in_be32((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET));
+
+	if (set)
+		val |= MACCFG1_LOOPBACK;
+	else
+		val &= ~MACCFG1_LOOPBACK;
+
+	out_be32((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET), val);
+
+	iounmap((u32 *) (addr + FM_1GMAC_CMD_CONF_CTRL_OFFSET));
+
+	return 0;
+
+}
+
+/*
+	Returns fmd wrapper structure associated to a given FMAN
+*/
+t_LnxWrpFmDev *get_fm(int fm_idx)
+{
+	struct device_node *np = NULL;
+	struct device_node *fman_np = NULL;
+	struct platform_device *of_dev = NULL;
+	struct device *dev;
+	t_LnxWrpFmDev *fm_dev = NULL;
+
+	for_each_matching_node(np, fman) {
+		if (*((unsigned int *)of_get_property(np,
+						      "cell-index",
+						      NULL)) == fm_idx) {
+			fman_np = np;
+			break;
+		}
+	}
+
+	if (!fman_np)
+		return NULL;
+
+	of_dev = of_find_device_by_node(fman_np);
+	of_node_put(fman_np);
+	if (unlikely(of_dev == NULL))
+		return NULL;
+
+	dev = &of_dev->dev;
+	fm_dev = dev_get_drvdata(dev);
+	return fm_dev;
+}
+
+/*
+	Returns fmd wrapper structure associated to a given FMAN port
+	@fm_idx : FMAN index (0/1)
+	@port_idx : port index
+	@port_type : type of port (RX/TX/1G/10G , OH)
+*/
+t_LnxWrpFmPortDev *get_fm_port(int fm_idx, int port_idx, e_FmPortType port_type)
+{
+	struct of_device_id *port_dev_id;
+	struct device_node *np = NULL;
+	struct device_node *fman_np = NULL;
+	struct platform_device *of_dev = NULL;
+	struct device *dev;
+	t_LnxWrpFmPortDev *port_dev = NULL;
+
+	switch (port_type) {
+	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
+		port_dev_id = fman_oh_port;
+		break;
+	case e_FM_PORT_TYPE_RX:
+		port_dev_id = fman_1g_rx_port;
+		break;
+	case e_FM_PORT_TYPE_RX_10G:
+		port_dev_id = fman_10g_rx_port;
+		break;
+	case e_FM_PORT_TYPE_TX:
+		port_dev_id = fman_1g_tx_port;
+		break;
+	case e_FM_PORT_TYPE_TX_10G:
+		port_dev_id = fman_10g_tx_port;
+		break;
+	default:
+		return NULL;
+	}
+
+	for_each_matching_node(np, fman) {
+		if (*((unsigned int *)of_get_property(np,
+						      "cell-index",
+						      NULL)) == fm_idx) {
+			fman_np = np;
+			break;
+		}
+	}
+	if (!fman_np)
+		return NULL;
+
+	for (np = of_find_matching_node(fman_np, port_dev_id); np;
+	     np = of_find_matching_node(np, port_dev_id)) {
+		if (*((unsigned int *)of_get_property(np,
+						      "cell-index",
+						      NULL)) == port_idx) {
+			of_dev = of_find_device_by_node(np);
+			of_node_put(np);
+			if (unlikely(of_dev == NULL))
+				break;
+			dev = &of_dev->dev;
+			port_dev = dev_get_drvdata(dev);
+			break;
+		}
+	}
+	return port_dev;
+}
+
+/*
+	Checks if used ports were initialized by FMD
+*/
+int check_ports(void)
+{
+	t_LnxWrpFmDev *fm;
+	t_LnxWrpFmPortDev *port;
+
+	fm = get_fm(FM);
+	if (!fm)
+		return -ENODEV;
+
+	pr_info("Using ports :");
+
+	port = get_fm_port(FM, UL_POST_IPSEC_OH,
+			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return -ENODEV;
+	pr_info("%s UL_POST_IPSEC_OH ", port->name);
+
+	port = get_fm_port(FM, UL_PRE_IPSEC_OH,
+			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return -ENODEV;
+	pr_info("%s UL_PRE_IPSEC_OH", port->name);
+
+	port = get_fm_port(FM, DL_POST_IPSEC_OH,
+			   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+	if (!port || !port->pcd_owner_params.dev)
+		return -ENODEV;
+	pr_info("%s DL_POST_IPSEC_OH", port->name);
+
+	port = get_fm_port(FM, UL_RX, e_FM_PORT_TYPE_RX);
+	if (!port || !port->pcd_owner_params.dev)
+		return -ENODEV;
+	pr_info("%s UL_RX", port->name);
+
+	port = get_fm_port(FM, DL_RX, e_FM_PORT_TYPE_RX);
+	if (!port || !port->pcd_owner_params.dev)
+		return -ENODEV;
+	pr_info("%s DL_RX\n", port->name);
+
+	return 0;
+}
+
+/*
+	returns handles to fmc_exec.c
+ */
+t_Handle SYS_GetHandle(fm_type entity, int id)
+{
+	t_LnxWrpFmDev *fm;
+	t_LnxWrpFmPortDev *port;
+	static int fm_id;
+	t_Handle h_obj = NULL;
+
+	switch (entity) {
+	case e_SYS_SUBMODULE_FM:
+		fm = get_fm(id);
+		if (fm) {
+			fm_id = fm->id;
+			h_obj = fm->h_Dev;
+		}
+		break;
+	case e_SYS_SUBMODULE_FM_PCD:
+		fm = get_fm(fm_id);
+		if (fm)
+			h_obj = fm->h_PcdDev;
+		break;
+	case e_SYS_SUBMODULE_FM_PORT_HO:
+		port = get_fm_port(fm_id, id,
+				   e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+		h_obj = port->h_Dev;
+		break;
+	case e_SYS_SUBMODULE_FM_PORT_1GRx:
+		port = get_fm_port(fm_id, id, e_FM_PORT_TYPE_RX);
+		h_obj = port->h_Dev;
+		break;
+	default:
+		pr_err("\nInvalid element type\n");
+		break;
+	}
+
+	return h_obj;
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc.h b/drivers/staging/fsl_dpa_offload/usecases/fmc.h
new file mode 100644
index 0000000..ed0faee
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc.h
@@ -0,0 +1,215 @@
+/* ============================================================================
+ *
+ * Copyright (c) 2009-2012, Freescale Semiconductor, Inc.
+ *
+ * MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ *  File Name : fmc.h
+ *  Author    : Serge Lamikhov-Center
+ *
+ * ========================================================================= */
+
+#ifndef LIBFMC_H
+#define LIBFMC_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include <std_ext.h>
+#include <error_ext.h>
+#include <part_ext.h>
+#include <fm_ext.h>
+#include <Peripherals/fm_pcd_ext.h>
+#include <Peripherals/fm_port_ext.h>
+
+#define FMC_OUTPUT_FORMAT_VER 0x104
+
+#define FMC_NAME_LEN             64
+#define FMC_FMAN_NUM              2
+#define FMC_PORTS_PER_FMAN       16
+#define FMC_SCHEMES_NUM          32
+#define FMC_SCHEME_PROTOCOLS_NUM 16
+#define FMC_CC_NODES_NUM        256
+#define FMC_PLC_NUM              64
+#define MAX_SP_CODE_SIZE      0x7C0
+#define FMC_MANIP_MAX             8
+#define FMC_INSERT_MAX           56
+
+#define FMC_APPLY_ORDER( Index, Type, Element ) \
+    .ao[Index].type  = Type,                    \
+    .ao[Index].index = Element
+
+typedef enum fm_type {
+	e_SYS_SUBMODULE_FM = 0,
+	e_SYS_SUBMODULE_FM_PCD,
+	e_SYS_SUBMODULE_FM_PORT_HO,
+	e_SYS_SUBMODULE_FM_PORT_1GRx
+} fm_type;
+
+typedef struct fmc_fman_t {
+    unsigned int       number;
+    unsigned int       port_count;
+    unsigned int       ports[FMC_PORTS_PER_FMAN];
+    char               name[FMC_NAME_LEN];
+    t_Handle           handle;
+    char               pcd_name[FMC_NAME_LEN];
+    t_Handle           pcd_handle;
+
+#ifndef P1023
+    unsigned int       reasm_count;
+    t_FmPcdManipParams reasm[FMC_MANIP_MAX];
+    char               reasm_name[FMC_MANIP_MAX][FMC_NAME_LEN];
+    t_Handle           reasm_handle[FMC_MANIP_MAX];
+
+    unsigned int       frag_count;
+    t_FmPcdManipParams frag[FMC_MANIP_MAX];
+    char               frag_name[FMC_MANIP_MAX][FMC_NAME_LEN];
+    t_Handle           frag_handle[FMC_MANIP_MAX];
+
+	unsigned int       hdr_count;
+    t_FmPcdManipParams hdr[FMC_MANIP_MAX];
+	uint8_t			   insertData[FMC_MANIP_MAX][FMC_INSERT_MAX];
+    char               hdr_name[FMC_MANIP_MAX][FMC_NAME_LEN];
+    t_Handle           hdr_handle[FMC_MANIP_MAX];
+#endif /* P1023 */
+} fmc_fman;
+
+
+typedef struct fmc_port_t {
+    e_FmPortType         type;                      ///< Port type
+    unsigned int         number;                    ///< Port number
+    t_FmPcdNetEnvParams  distinctionUnits;          ///< Port's network env
+    t_FmPortPcdParams    pcdParam;
+    t_FmPortPcdPrsParams prsParam;
+    t_FmPortPcdKgParams  kgParam;
+    t_FmPortPcdCcParams  ccParam;
+    char                 name[FMC_NAME_LEN];
+    t_Handle             handle;
+    t_Handle             env_id_handle;
+    t_Handle             cctree_handle;
+
+    unsigned int         schemes_count;             ///< Number of used schemes
+    unsigned int         schemes[FMC_SCHEMES_NUM];  ///< Schemes used by this port
+
+    unsigned int         ccnodes_count;             ///< Number of used CC nodes
+    unsigned int         ccnodes[FMC_CC_NODES_NUM]; ///< Class. nodes used by this port
+
+    unsigned int         ccroot_count;
+    unsigned int         ccroot[FMC_CC_NODES_NUM];
+#ifndef P1023
+	unsigned int         ccroot_manip[FMC_CC_NODES_NUM];
+#endif /* P1023 */
+
+    unsigned int         reasm_index;
+} fmc_port;
+
+
+typedef enum fmc_apply_order_e {
+    FMCEngineStart,
+    FMCEngineEnd,
+    FMCPortStart,
+    FMCPortEnd,
+    FMCScheme,
+    FMCCCNode,
+    FMCCCTree,
+    FMCPolicer
+} fmc_apply_order_e;
+
+
+typedef struct fmc_apply_order_t {
+    fmc_apply_order_e   type;
+    unsigned int        index;
+} fmc_apply_order;
+
+
+typedef struct fmc_model_t {
+    unsigned int             format_version;
+    unsigned int             sp_enable;           ///< Soft parser enable flag
+    t_FmPcdPrsSwParams       sp;                  ///< Soft parser configuration
+    uint8_t                  spCode[MAX_SP_CODE_SIZE];
+
+    unsigned int             fman_count;                ///< Number of used FMan engines
+    fmc_fman                 fman[FMC_FMAN_NUM];
+
+    unsigned int             port_count;                ///< Number of used FMan ports
+    fmc_port                 port[FMC_FMAN_NUM * FMC_PORTS_PER_FMAN];
+
+    unsigned int             scheme_count;     ///< Number of used KeyGen schemes
+    char                     scheme_name  [FMC_SCHEMES_NUM][FMC_NAME_LEN];
+    t_Handle                 scheme_handle[FMC_SCHEMES_NUM];
+    t_FmPcdKgSchemeParams    scheme       [FMC_SCHEMES_NUM];
+
+    unsigned int             ccnode_count;       ///< Number of used CC nodes
+    char                     ccnode_name         [FMC_CC_NODES_NUM][FMC_NAME_LEN];
+    t_Handle                 ccnode_handle       [FMC_CC_NODES_NUM];
+    t_FmPcdCcNodeParams      ccnode              [FMC_CC_NODES_NUM];
+    uint8_t                  cckeydata           [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS]
+                                                 [FM_PCD_MAX_SIZE_OF_KEY];
+    unsigned char            ccmask              [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS]
+                                                 [FM_PCD_MAX_SIZE_OF_KEY];
+    unsigned int             ccentry_action_index[FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
+    unsigned char            ccentry_frag        [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
+	unsigned char            ccentry_manip       [FMC_CC_NODES_NUM][FM_PCD_MAX_NUM_OF_KEYS];
+    unsigned int             ccmiss_action_index [FMC_CC_NODES_NUM];
+
+    unsigned int             policer_count; ///< Number of used policers
+    char                     policer_name        [FMC_PLC_NUM][FMC_NAME_LEN];
+    t_FmPcdPlcrProfileParams policer             [FMC_PLC_NUM];
+    t_Handle                 policer_handle      [FMC_PLC_NUM];
+    unsigned int             policer_action_index[FMC_PLC_NUM][3];
+
+    unsigned int             ao_count;               ///< Number of 'apply order' elements
+    fmc_apply_order          ao[FMC_FMAN_NUM*FMC_PORTS_PER_FMAN*(FMC_SCHEMES_NUM+FMC_CC_NODES_NUM)];
+} fmc_model;
+
+
+int fmc_compile(
+        fmc_model*   model,
+        const char*  nameCfg,
+        const char*  namePCD,
+        const char*  namePDL,
+        const char*  nameSP,
+        unsigned int swOffset,
+        unsigned int dontWarn,
+        const char** dump
+);
+
+int fmc_execute( fmc_model* model );
+
+int fmc_clean( fmc_model* model );
+
+const char* fmc_get_error( void );
+
+t_Handle fmc_get_handle(
+            fmc_model*   model,
+            unsigned int engine_number,
+            e_FmPortType port_type,
+            unsigned int port_number,
+            const char*  name
+);
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif // LIBFMC_H
diff --git a/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c b/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c
new file mode 100644
index 0000000..a6363dd
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/fmc_exec.c
@@ -0,0 +1,780 @@
+/* ============================================================================
+ *
+ * Copyright (c) 2009-2012, Freescale Semiconductor, Inc.
+ *
+ * MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ *  File Name : fmc_exec.c
+ *  Author    : Serge Lamikhov-Center
+ *
+ * ========================================================================= */
+
+#include <linux/kernel.h>
+
+#ifdef NETCOMM_SW
+    #include "sys_ext.h"
+#endif
+
+#include "fmc.h"
+
+t_Handle SYS_GetHandle(fm_type entity, int id);
+// Forward declaration of static functions
+static int fmc_exec_engine_start( fmc_model* model, unsigned int index,
+                                  unsigned int* p_relative_scheme_index );
+static int fmc_exec_engine_end  ( fmc_model* model, unsigned int index );
+static int fmc_exec_port_start  ( fmc_model* model, unsigned int engine,
+                                  unsigned int index );
+static int fmc_exec_port_end    ( fmc_model* model, unsigned int engine,
+                                  unsigned int index );
+static int fmc_exec_scheme      ( fmc_model* model,  unsigned int engine,
+                                  unsigned int port, unsigned int index,
+                                  unsigned int relative_scheme_index );
+static int fmc_exec_ccnode      ( fmc_model* model, unsigned int engine,
+                                  unsigned int index );
+static int fmc_exec_cctree      ( fmc_model* model,  unsigned int engine,
+                                  unsigned int port );
+static int fmc_exec_policer     ( fmc_model* model, unsigned int engine,
+                                  unsigned int index );
+
+static int fmc_clean_engine_start( fmc_model* model, unsigned int index );
+static int fmc_clean_engine_end  ( fmc_model* model, unsigned int index );
+static int fmc_clean_port_start  ( fmc_model* model, unsigned int engine,
+                                   unsigned int index );
+static int fmc_clean_port_end    ( fmc_model* model, unsigned int engine,
+                                   unsigned int index );
+static int fmc_clean_scheme      ( fmc_model* model,  unsigned int engine,
+                                   unsigned int port, unsigned int index );
+static int fmc_clean_ccnode      ( fmc_model* model, unsigned int engine,
+                                   unsigned int index );
+static int fmc_clean_cctree      ( fmc_model* model,  unsigned int engine,
+                                   unsigned int port );
+static int fmc_clean_policer     ( fmc_model* model, unsigned int engine,
+                                   unsigned int index );
+
+
+/* -------------------------------------------------------------------------- */
+int
+fmc_execute( fmc_model* model )
+{
+    int          ret                   = 0;
+    unsigned int current_engine        = 0;
+    unsigned int current_port          = 0;
+    unsigned int relative_scheme_index = 0;
+    unsigned int i;
+
+    if ( model->format_version != FMC_OUTPUT_FORMAT_VER ) {
+        return 0xFFFFFFFF;
+    }
+
+    for ( i = 0; i < model->ao_count; i++ ) {
+        switch ( model->ao[i].type ) {
+            case FMCEngineStart:
+                current_engine        = model->ao[i].index;
+                relative_scheme_index = 0;
+                ret = fmc_exec_engine_start( model, current_engine,
+                                             &relative_scheme_index );
+                break;
+            case FMCEngineEnd:
+                ret = fmc_exec_engine_end( model, current_engine );
+                break;
+            case FMCPortStart:
+                current_port = model->ao[i].index;
+                ret = fmc_exec_port_start( model, current_engine, current_port );
+                break;
+            case FMCPortEnd:
+                ret = fmc_exec_port_end( model, current_engine, current_port );
+                break;
+            case FMCScheme:
+                ret = fmc_exec_scheme( model, current_engine, current_port,
+                                       model->ao[i].index, relative_scheme_index++ );
+                break;
+            case FMCCCNode:
+                ret = fmc_exec_ccnode( model, current_engine, model->ao[i].index );
+                break;
+            case FMCCCTree:
+                ret = fmc_exec_cctree( model, current_engine, model->ao[i].index );
+                break;
+            case FMCPolicer:
+                ret = fmc_exec_policer( model, current_engine, model->ao[i].index );
+                break;
+			default:
+				break;
+        }
+
+        // Exit the loop in case of failure
+        if ( ret != 0 ) {
+            break;
+        }
+    }
+
+    return ret;
+}
+
+
+/* -------------------------------------------------------------------------- */
+int
+fmc_clean( fmc_model* model )
+{
+    int          ret = 0;
+    unsigned int current_engine;
+    unsigned int current_port;
+    unsigned int i, j;
+
+    if ( model->format_version != FMC_OUTPUT_FORMAT_VER ) {
+        return 0xFFFFFFFF;
+    }
+
+    for ( j = 0; j < model->ao_count; j++ ) {
+        // Clean entities in reverse order of applying
+        i = model->ao_count - j - 1;
+        switch ( model->ao[i].type ) {
+            case FMCEngineStart:
+                current_engine = model->ao[i].index;
+                ret = fmc_clean_engine_start( model, current_engine );
+                break;
+            case FMCEngineEnd:
+                current_engine = model->ao[i].index;
+                ret = fmc_clean_engine_end( model, current_engine );
+                break;
+            case FMCPortStart:
+                current_port = model->ao[i].index;
+                ret = fmc_clean_port_start( model, current_engine, current_port );
+                break;
+            case FMCPortEnd:
+                current_port = model->ao[i].index;
+                ret = fmc_clean_port_end( model, current_engine, current_port );
+                break;
+            case FMCScheme:
+                ret = fmc_clean_scheme( model, current_engine, current_port,
+                                        model->ao[i].index );
+                break;
+            case FMCCCNode:
+                ret = fmc_clean_ccnode( model, current_engine, model->ao[i].index );
+                break;
+            case FMCCCTree:
+                ret = fmc_clean_cctree( model, current_engine, model->ao[i].index );
+                break;
+            case FMCPolicer:
+                ret = fmc_clean_policer( model, current_engine, model->ao[i].index );
+                break;
+			default:
+				break;
+        }
+
+        // Exit the loop in case of failure
+        if ( ret != 0 ) {
+            break;
+        }
+    }
+
+    return ret;
+}
+
+
+/* -------------------------------------------------------------------------- */
+t_Handle
+fmc_get_handle(
+            fmc_model*   model,
+            unsigned int engine_number,
+            e_FmPortType port_type,
+            unsigned int port_number,
+            const char*  name
+)
+{
+    unsigned int engine  = 0;
+    unsigned int port    = 0;
+    unsigned int found   = 0;
+    unsigned int ccindex = 0;
+    unsigned int i;
+
+    // Find engine index
+    for ( engine = 0; engine < model->fman_count; engine++ ) {
+        if ( model->fman[engine].number == engine_number ) {
+            found = 1;
+            break;
+        }
+    }
+    if ( !found ) {
+        return 0;
+    }
+
+    // Check whether it is a 'policy' name. Return PCD handle then
+    if ( strcmp( model->fman[engine].pcd_name, name ) == 0 ) {
+        return model->fman[engine].pcd_handle;
+    }
+
+#ifndef P1023
+    // Check fragmentation names
+    for ( i = 0; i < model->fman[engine].frag_count; i++ ) {
+        if ( strcmp( model->fman[engine].frag_name[i], name ) == 0 ) {
+            return model->fman[engine].frag_handle[i];
+        }
+    }
+
+	// Check reassembly names
+    for ( i = 0; i < model->fman[engine].reasm_count; i++ ) {
+        if ( strcmp( model->fman[engine].reasm_name[i], name ) == 0 ) {
+            return model->fman[engine].reasm_handle[i];
+        }
+    }
+
+	// Check header manip names
+    for ( i = 0; i < model->fman[engine].hdr_count; i++ ) {
+        if ( strcmp( model->fman[engine].hdr_name[i], name ) == 0 ) {
+            return model->fman[engine].hdr_handle[i];
+        }
+    }
+#endif /* P1023 */
+
+    // Find port index
+    found = 0;
+    for ( port = 0; port < model->fman[engine].port_count; port++ ) {
+        unsigned int port_index = model->fman[engine].ports[port];
+        if ( model->port[port_index].type   == port_type &&
+             model->port[port_index].number == port_number ) {
+            found = 1;
+            break;
+        }
+    }
+    if ( !found ) {
+        return 0;
+    }
+
+    // Find CC handle according to found engine and port
+    for ( ccindex =0; ccindex < model->port[port].ccnodes_count; ccindex++ ) {
+        unsigned int index = model->port[port].ccnodes[ccindex];
+        if ( strcmp( model->ccnode_name[index], name ) == 0 ) {
+            return model->ccnode_handle[index];
+        }
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_engine_start( fmc_model* model, unsigned int index,
+                       unsigned int* p_relative_scheme_index )
+{
+#ifndef P1023
+    unsigned int i;
+#endif
+
+    t_FmPcdParams fmPcdParams = {0};
+
+    // Open FMan device
+#ifndef NETCOMM_SW
+    model->fman[index].handle = FM_Open( model->fman[index].number );
+#else
+    model->fman[index].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM,
+                                               model->fman[index].number );
+#endif
+    if ( model->fman[index].handle == 0 ) {
+        return 1;
+    }
+
+    // Open FMan device
+    fmPcdParams.h_Fm = model->fman[index].handle;
+#ifndef NETCOMM_SW
+    model->fman[index].pcd_handle = FM_PCD_Open( &fmPcdParams );
+#else
+    model->fman[index].pcd_handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PCD,
+                                                   model->fman[index].number );
+#endif
+    if ( model->fman[index].pcd_handle == 0 ) {
+        return 2;
+    }
+
+    if ( model->sp_enable ) {
+        FM_PCD_PrsLoadSw( model->fman[index].pcd_handle, &(model->sp) );
+    }
+#ifndef P1023
+	if (model->fman[index].reasm_count > 0 || model->fman[index].frag_count > 0) {
+		FM_PCD_SetAdvancedOffloadSupport(model->fman[index].pcd_handle);
+	}
+#endif /* P1023 */
+
+    FM_PCD_Enable( model->fman[index].pcd_handle );
+
+#ifndef P1023
+    for ( i = 0; i < model->fman[index].reasm_count; i++ ) {
+		if ( model->fman[index].reasm[i].u.reassem.hdr == HEADER_TYPE_IPv6 ) {
+			model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[0] =
+                (*p_relative_scheme_index)++;
+            model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[1] =
+                (*p_relative_scheme_index)++;
+        }
+        else {
+            model->fman[index].reasm[i].u.reassem.u.ipReassem.relativeSchemeId[0] =
+                (*p_relative_scheme_index)++;
+        }
+
+        model->fman[index].reasm_handle[i] =
+            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
+                                 &model->fman[index].reasm[i] );
+    }
+
+    for ( i = 0; i < model->fman[index].frag_count; i++ ) {
+        model->fman[index].frag_handle[i] =
+            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
+                                 &model->fman[index].frag[i] );
+    }
+
+	for ( i = 0; i < model->fman[index].hdr_count; i++ ) {
+		if ( model->fman[index].hdr[i].u.hdr.insrt )
+		{
+			model->fman[index].hdr[i].u.hdr.insrtParams.u.generic.p_Data = model->fman[index].insertData[i];
+		}
+
+        model->fman[index].hdr_handle[i] =
+            FM_PCD_ManipNodeSet( model->fman[index].pcd_handle,
+                                 &model->fman[index].hdr[i] );
+    }
+#endif /* P1023 */
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_engine_end( fmc_model* model, unsigned int index )
+{
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_port_start( fmc_model* model, unsigned int engine, unsigned int port )
+{
+    t_FmPortParams  fmPortParam      = {0};
+
+    fmc_fman* pengine = &model->fman[engine];
+    fmc_port* pport   = &model->port[port];
+
+    fmPortParam.h_Fm     = pengine->handle;
+    fmPortParam.portId   = pport->number;
+    fmPortParam.portType = pport->type;
+
+#ifndef NETCOMM_SW
+    model->port[port].handle = FM_PORT_Open( &fmPortParam );
+#else
+    if (fmPortParam.portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        model->port[port].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PORT_HO,
+                                                  fmPortParam.portId );
+    else
+        model->port[port].handle = SYS_GetHandle( e_SYS_SUBMODULE_FM_PORT_1GRx,
+                                                  fmPortParam.portId );
+#endif
+    if ( pport->handle == 0 ) {
+        return 3;
+    }
+
+    pport->env_id_handle = FM_PCD_NetEnvCharacteristicsSet(
+                                pengine->pcd_handle,
+                                &pport->distinctionUnits );
+    if ( pport->env_id_handle == 0 ) {
+        return 4;
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_port_end( fmc_model* model, unsigned int engine, unsigned int port )
+{
+    t_Error err;
+    fmc_port* pport = &model->port[port];
+    unsigned int i;
+
+    unsigned int        reasm_index;
+    reasm_index            		= model->port[port].reasm_index;
+
+    pport->pcdParam.h_NetEnv    = pport->env_id_handle;
+    pport->pcdParam.p_PrsParams = &pport->prsParam;
+    pport->pcdParam.h_IpReassemblyManip = model->fman[engine].reasm_handle[reasm_index - 1];
+
+    // Add KeyGen runtime parameters
+    if ( pport->schemes_count != 0 ) {
+        pport->kgParam.numOfSchemes = pport->schemes_count;
+
+        pport->pcdParam.p_KgParams = &pport->kgParam;
+        for ( i = 0; i < pport->schemes_count; ++i ) {
+            pport->pcdParam.p_KgParams->h_Schemes[ i ] =
+                model->scheme_handle[ pport->schemes[i] ];
+        }
+    }
+
+    // Add CC runtime parameters
+    if ( pport->ccnodes_count != 0 || pport->reasm_index > 0 ) {
+        pport->pcdParam.p_CcParams           = &pport->ccParam;
+        pport->pcdParam.p_CcParams->h_CcTree = pport->cctree_handle;
+    }
+
+    err = FM_PORT_Disable( pport->handle );
+    if ( err ) { return 5; }
+    err = FM_PORT_SetPCD( pport->handle, &pport->pcdParam );
+    if ( err ) { return 6; }
+    err = FM_PORT_Enable( pport->handle );
+    if ( err ) { return 7; }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_scheme( fmc_model* model,  unsigned int engine,
+                 unsigned int port, unsigned int index,
+                 unsigned int relative_scheme_index )
+{
+    model->scheme[index].netEnvParams.h_NetEnv = model->port[port].env_id_handle;
+    model->scheme[index].id.relativeSchemeId   = relative_scheme_index;
+
+    // Fill next engine handles
+    if ( model->scheme[index].nextEngine == e_FM_PCD_CC ) {
+        model->scheme[index].kgNextEngineParams.cc.h_CcTree =
+                                                model->port[port].cctree_handle;
+    }
+
+    model->scheme_handle[index] =
+	FM_PCD_KgSchemeSet( model->fman[engine].pcd_handle,
+                            &(model->scheme[index]) );
+    if ( model->scheme_handle[index] == 0 ) {
+        return 5;
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_ccnode( fmc_model* model, unsigned int engine,
+                 unsigned int index )
+{
+    unsigned int i;
+    unsigned int action_index;
+
+    for ( i = 0; i < model->ccnode[index].keysParams.numOfKeys; ++i ) {
+        action_index = model->ccentry_action_index[index][i];
+        if ( model->ccnode[index].keysParams.keyParams[i]
+                               .ccNextEngineParams.nextEngine == e_FM_PCD_KG ) {
+            model->ccnode[index].keysParams.keyParams[i]
+                .ccNextEngineParams.params.kgParams.h_DirectScheme =
+                                             model->scheme_handle[action_index];
+        }
+        else if ( model->ccnode[index].keysParams.keyParams[i]
+                               .ccNextEngineParams.nextEngine == e_FM_PCD_CC ) {
+            model->ccnode[index].keysParams.keyParams[i]
+                .ccNextEngineParams.params.ccParams.h_CcNode =
+                                             model->ccnode_handle[action_index];
+        }
+
+#ifndef P1023
+        if ( model->ccentry_frag[index][i] != 0 ) {
+            model->ccnode[index].keysParams.keyParams[i].ccNextEngineParams.h_Manip =
+                model->fman[engine].frag_handle[ model->ccentry_frag[index][i] - 1 ];
+        }
+
+		if ( model->ccentry_manip[index][i] != 0 ) {
+            model->ccnode[index].keysParams.keyParams[i].ccNextEngineParams.h_Manip =
+                model->fman[engine].hdr_handle[ model->ccentry_manip[index][i] - 1 ];
+        }
+#endif /* P1023 */
+
+		if (model->ccnode[index].extractCcParams.extractNonHdr.action == e_FM_PCD_ACTION_INDEXED_LOOKUP) {
+			model->ccnode[index].keysParams.keyParams[i].p_Key = NULL;
+			model->ccnode[index].keysParams.keyParams[i].p_Mask = NULL;
+		} else {
+			model->ccnode[index].keysParams.keyParams[i].p_Key =
+				model->cckeydata[index][i];
+			model->ccnode[index].keysParams.keyParams[i].p_Mask =
+				model->ccmask[index][i];
+		}
+    }
+
+    action_index = model->ccmiss_action_index[index];
+    if ( model->ccnode[index].keysParams.ccNextEngineParamsForMiss
+                           .nextEngine == e_FM_PCD_KG ) {
+        model->ccnode[index].keysParams.ccNextEngineParamsForMiss
+            .params.kgParams.h_DirectScheme =
+                                         model->scheme_handle[action_index];
+    }
+    else if ( model->ccnode[index].keysParams.ccNextEngineParamsForMiss
+                           .nextEngine == e_FM_PCD_CC ) {
+        model->ccnode[index].keysParams.ccNextEngineParamsForMiss
+            .params.ccParams.h_CcNode = model->ccnode_handle[action_index];
+    }
+
+
+    model->ccnode_handle[index] =
+	FM_PCD_MatchTableSet( model->fman[engine].pcd_handle,
+                          &(model->ccnode[index]) );
+
+    if ( model->ccnode_handle[index] == 0 ) {
+        return 6;
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_cctree( fmc_model* model, unsigned int engine,
+                 unsigned int port )
+{
+    static t_FmPcdCcTreeParams ccTreeParams = { 0 };
+#ifndef P1023
+    unsigned int        reasm_index;
+#endif /* P1023 */
+    unsigned int        i;
+
+    ccTreeParams.numOfGrps = model->port[port].ccroot_count;
+    ccTreeParams.h_NetEnv  = model->port[port].env_id_handle;
+#ifndef P1023
+    reasm_index            = model->port[port].reasm_index;
+#endif /* P1023 */
+
+    for ( i = 0; i < model->port[port].ccroot_count; ++i ) {
+        ccTreeParams.ccGrpParams[i].numOfDistinctionUnits = 0;
+        ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].
+            nextEngine = e_FM_PCD_CC;
+        ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].
+            params.ccParams.h_CcNode =
+                model->ccnode_handle[model->port[port].ccroot[i]];
+#ifndef P1023
+		if ( model->port[port].ccroot_manip[i] > 0 )
+		{
+			ccTreeParams.ccGrpParams[i].nextEnginePerEntriesInGrp[0].h_Manip =
+				model->fman[engine].hdr_handle[model->port[port].ccroot_manip[i] - 1];
+		}
+#endif /* P1023 */
+    }
+
+    model->port[port].cctree_handle =
+	FM_PCD_CcRootBuild( model->fman[engine].pcd_handle,
+                            &ccTreeParams );
+    if ( model->port[port].cctree_handle == 0 ) {
+        return 7;
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_exec_policer( fmc_model* model, unsigned int engine,
+                  unsigned int index )
+{
+    unsigned int action_index;
+
+    // Fill next engine handles
+    action_index = model->policer_action_index[index][0];
+    switch ( model->policer[index].nextEngineOnGreen ) {
+        case e_FM_PCD_PLCR:
+            model->policer[index].paramsOnGreen.h_Profile =
+                model->policer_handle[action_index];
+            break;
+        case e_FM_PCD_KG:
+            model->policer[index].paramsOnGreen.h_DirectScheme =
+                model->scheme_handle[action_index];
+            break;
+		default:
+			break;
+    }
+    action_index = model->policer_action_index[index][1];
+    switch ( model->policer[index].nextEngineOnYellow ) {
+        case e_FM_PCD_PLCR:
+            model->policer[index].paramsOnYellow.h_Profile =
+                model->policer_handle[action_index];
+            break;
+        case e_FM_PCD_KG:
+            model->policer[index].paramsOnYellow.h_DirectScheme =
+                model->scheme_handle[action_index];
+            break;
+		default:
+			break;
+    }
+    action_index = model->policer_action_index[index][2];
+    switch ( model->policer[index].nextEngineOnRed ) {
+        case e_FM_PCD_PLCR:
+            model->policer[index].paramsOnRed.h_Profile =
+                model->policer_handle[action_index];
+            break;
+        case e_FM_PCD_KG:
+            model->policer[index].paramsOnRed.h_DirectScheme =
+                model->scheme_handle[action_index];
+            break;
+		default:
+			break;
+    }
+
+    model->policer_handle[index] =
+        FM_PCD_PlcrProfileSet( model->fman[engine].pcd_handle,
+                               &(model->policer[index]) );
+    if ( model->policer_handle[index] == 0 ) {
+        return 8;
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_engine_start( fmc_model* model, unsigned int index )
+{
+    unsigned int i;
+
+#ifndef P1023
+    for ( i = 0; i < model->fman[index].frag_count; i++ ) {
+        FM_PCD_ManipNodeDelete( model->fman[index].frag_handle[i] );
+    }
+
+    for ( i = 0; i < model->fman[index].reasm_count; i++ ) {
+        FM_PCD_ManipNodeDelete( model->fman[index].reasm_handle[i] );
+    }
+
+	for ( i = 0; i < model->fman[index].hdr_count; i++ ) {
+        FM_PCD_ManipNodeDelete( model->fman[index].hdr_handle[i] );
+    }
+#endif /* P1023 */
+
+    if ( model->fman[index].pcd_handle != 0 ) {
+#ifndef NETCOMM_SW
+        FM_PCD_Close( model->fman[index].pcd_handle );
+#endif
+    }
+    if ( model->fman[index].handle != 0 ) {
+#ifndef NETCOMM_SW
+        FM_Close( model->fman[index].handle );
+#endif
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_engine_end( fmc_model* model, unsigned int index )
+{
+    FM_PCD_Disable( model->fman[index].pcd_handle );
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_port_start( fmc_model* model, unsigned int engine, unsigned int port )
+{
+    fmc_port* pport = &model->port[port];
+
+    if ( pport->handle == 0 ) {
+        return 0;
+    }
+
+    FM_PCD_NetEnvCharacteristicsDelete( pport->env_id_handle );
+
+#ifndef NETCOMM_SW
+    FM_PORT_Close( pport->handle );
+#endif
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_port_end( fmc_model* model, unsigned int engine, unsigned int port )
+{
+    t_Error err;
+    fmc_port* pport = &model->port[port];
+
+    if ( pport->handle == 0 ) {
+        return 0;
+    }
+
+    err = FM_PORT_DeletePCD( pport->handle );
+    if ( err ) { return 6; }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_scheme( fmc_model* model,  unsigned int engine,
+                 unsigned int port, unsigned int index )
+{
+    if ( model->scheme_handle[index] != 0 ) {
+        FM_PCD_KgSchemeDelete( model->scheme_handle[index] );
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_ccnode( fmc_model* model, unsigned int engine,
+                 unsigned int index )
+{
+    if ( model->ccnode_handle[index] != 0 ) {
+        FM_PCD_MatchTableDelete( model->ccnode_handle[index] );
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_cctree( fmc_model* model, unsigned int engine,
+                 unsigned int port )
+{
+    if ( model->port[port].cctree_handle != 0 ) {
+        FM_PCD_CcRootDelete( model->port[port].cctree_handle );
+    }
+
+    return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+static int
+fmc_clean_policer( fmc_model* model, unsigned int engine,
+                  unsigned int index )
+{
+    if ( model->policer_handle[index] != 0 ) {
+        FM_PCD_PlcrProfileDelete( model->policer_handle[index] );
+    }
+
+    return 0;
+}
-- 
1.7.5.4

