From 44640d3fd0175e9ebe6cb3feb913aa543564f182 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 13 Nov 2012 13:32:14 +0200
Subject: [PATCH 411/518] dpa_classifier: Release header manipulations at
 table flush

When flushing the tables the header manipulation descriptors were not
released. This was preventing the user application from destroying the
header manipulation ops used in the table, unless it removed all the
table entries one by one.

The "flush_table" function was updated to release the header
manipulation ops. For indexed tables the delete entry action does not make
sense, hence the flush function will replace all table entries with DROP.
As the user must be able to call the flush function any number of times
he/she wants and then be able to return to normal mode of operation for
(i.e. not necessarily destroy the table immediately), the destruction of
the shadow table for the indexed tables was moved to a separate cleanup
function.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   90 ++++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |    5 +-
 2 files changed, 72 insertions(+), 23 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 82d727c..b8cbfe3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -336,25 +336,23 @@ int dpa_classif_table_free(int td)
 	/* Flush the entries in the table */
 	err = flush_table(ptable);
 
-	/* Check shadow table if it exists */
-	if (ptable->shadow_table) {
-		/* Release shadow table */
-		kfree(ptable->shadow_table->shadow_entry);
-		kfree(ptable->shadow_table);
-	}
-#if 0
 	switch (ptable->params.type) {
 	case DPA_CLS_TBL_EXACT_MATCH:
-		table_cleanup_exact_match(ptable);
 		break;
 	case DPA_CLS_TBL_INDEXED:
 		table_cleanup_indexed(ptable);
 		break;
 	case DPA_CLS_TBL_HASH:
-		table_cleanup_hash(ptable);
 		break;
 	}
-#endif
+
+	/* Check shadow table if it exists */
+	if (ptable->shadow_table) {
+		/* Release shadow table */
+		kfree(ptable->shadow_table->shadow_entry);
+		kfree(ptable->shadow_table);
+	}
+
 	/* Free entry index management */
 	kfree(ptable->entry);
 	ptable->entry		= NULL;
@@ -1068,6 +1066,7 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 	case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
 		/* Only exact match tables support this type of modification. */
 		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
+
 		/* Parameters sanity checks: */
 		if (!mod_params->key) {
 			pr_err("ERROR: %s, %s (%d): \"mod_params->key\" "
@@ -1701,13 +1700,13 @@ EXPORT_SYMBOL(dpa_classif_table_flush);
 static int flush_table(struct dpa_cls_table *ptable)
 {
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
-	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	unsigned int cc_node_index, i;
 	t_Error err;
 	t_Handle cc_node;
 	struct list_head *list_current, *tmp;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
+	t_FmPcdCcNextEngineParams next_engine_params;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -1722,18 +1721,31 @@ static int flush_table(struct dpa_cls_table *ptable)
 		return 0;
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		if (ptable->shadow_table) {
-			for (i = 0;
-				i < ptable->params.indexed_params.entries_cnt;
-									i++) {
-				shadow_entry_indexed =
-			list_entry(ptable->shadow_table->shadow_entry[i].next,
-			struct dpa_cls_tbl_shadow_entry_indexed,
-			list_node);
+		cc_node = ptable->params.cc_node;
+
+		/* Replace all indexed entries with DROP */
+		memset(&next_engine_params, 0, sizeof(next_engine_params));
+		next_engine_params.nextEngine = e_FM_PCD_DONE;
+		next_engine_params.params.enqueueParams.action =
+						e_FM_PCD_DROP_FRAME;
 
-				list_del(&shadow_entry_indexed->list_node);
-				kfree(shadow_entry_indexed);
+		for (i = 0; i < ptable->params.indexed_params.entries_cnt;
+									i++) {
+			err = FM_PCD_MatchTableModifyNextEngine(cc_node,
+							i,
+							&next_engine_params);
+			if (err != E_OK) {
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed - "
+					"FM_PCD_MatchTableModifyNextEngine. "
+					"Cc node handle=0x%p, entry index=%d.\n",
+					__FILE__, __func__, __LINE__,
+					cc_node, i);
+				return -EBUSY;
 			}
+
+			dpa_classif_hm_release_chain(ptable->entry[i].hmd);
+			ptable->entry[i].hmd = DPA_OFFLD_DESC_NONE;
 		}
 	} else {
 		/* Flush the table from tail to head to avoid having to update
@@ -1762,6 +1774,7 @@ static int flush_table(struct dpa_cls_table *ptable)
 								cc_node;
 			int_cc_node = &ptable->int_cc_node[cc_node_index];
 
+			dpa_classif_hm_release_chain(index_entry->hmd);
 			err = FM_PCD_MatchTableRemoveKey(cc_node,
 						index_entry->entry_index);
 			if (err != E_OK) {
@@ -2070,10 +2083,13 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	for (i = 0; i < cls_table->entries_cnt; i++) {
 		/* Clean up and prepare the index entry */
 		memset(&cls_table->entry[i], 0,
-			sizeof(struct dpa_cls_tbl_entry));
+					sizeof(struct dpa_cls_tbl_entry));
 		cls_table->entry[i].flags	|= DPA_CLS_TBL_ENTRY_VALID;
 		cls_table->entry[i].entry_index	= i;
 		cls_table->entry[i].hmd		= DPA_OFFLD_DESC_NONE;
+
+		list_add(&cls_table->entry[i].list_node,
+					&cls_table->entry_list);
 	}
 
 	/*
@@ -2109,6 +2125,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 			next_engine_params_to_action(&next_engine_params,
 				&shadow_entry->action);
 
+			cls_table->entry[i].shadow_entry =
+						&shadow_entry->list_node;
+
 			/* Add entry to the shadow table. */
 			list_add(&shadow_entry->list_node,
 				&cls_table->shadow_table->shadow_entry[i]);
@@ -2248,6 +2267,33 @@ table_init_exact_match_error:
 	return err;
 }
 
+static void table_cleanup_indexed(struct dpa_cls_table *cls_table)
+{
+	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
+	int i;
+
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
+		__LINE__));
+
+	BUG_ON(!cls_table);
+	BUG_ON(cls_table->params.type != DPA_CLS_TBL_INDEXED);
+
+	for (i = 0; i < cls_table->params.indexed_params.entries_cnt; i++)
+		if (cls_table->entry[i].shadow_entry) {
+
+			shadow_entry_indexed =
+				list_entry(cls_table->entry[i].shadow_entry,
+				struct dpa_cls_tbl_shadow_entry_indexed,
+				list_node);
+
+			list_del(&shadow_entry_indexed->list_node);
+			kfree(shadow_entry_indexed);
+		}
+
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+		__LINE__));
+}
+
 static int verify_table_params(const struct dpa_cls_tbl_params *params)
 {
 	int err = 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 7a16d8b..11826bc 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -314,7 +314,7 @@ struct dpa_cls_hm {
 	/* Specifies the number of used items in the [hm_node] array */
 	unsigned int			num_nodes;
 
-	/* Pointer to the low level driver HM node chain */
+	/* Pointer to the low level driver HM manip node chain */
 	struct list_head		*hm_chain;
 
 	/*
@@ -375,6 +375,9 @@ static int	table_init_hash(struct dpa_cls_table *cls_table);
 /* Initialize an exact match table. */
 static int	table_init_exact_match(struct dpa_cls_table *cls_table);
 
+/* Clean up after an indexed table */
+static void table_cleanup_indexed(struct dpa_cls_table *cls_table);
+
 /*
  * Runs a verification of the table parameters against certain
  * ranges and limitations.
-- 
1.7.5.4

