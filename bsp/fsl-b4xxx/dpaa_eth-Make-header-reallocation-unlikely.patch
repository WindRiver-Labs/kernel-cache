From 02060ff4ec834d014ca8f847b96c82f93d17a3f1 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 28 Jan 2013 17:13:41 +0200
Subject: [PATCH 043/518] dpaa_eth: Make header reallocation unlikely

The headroom of an egress skb should be at least equal to
the netdevice's needed_headroom, even in forwarding cases. In fact,
the stack itself reallocs the headroom (ip_finish_output2()) if the
current one is less than LL_RESERVED_SPACE(dev).

Make the guarding condition unlikely. Probably the only scenario we're
talking about is ASF, and even that only in some cases.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    |    2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |    1 +
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |    5 +++--
 3 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 99888ac..1c96063 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1848,7 +1848,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	/* Use the Tx queue of the current cpu */
 	queue_mapping = smp_processor_id();
 
-	if (skb_headroom(skb) < DPA_BP_HEAD) {
+	if (unlikely(skb_headroom(skb) < DPA_BP_HEAD)) {
 		struct sk_buff *skb_new;
 
 		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index c1917b3..ab05560 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -146,6 +146,7 @@ struct dpaa_eth_hooks_s {
 
 void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
+/* The netdevice's needed_headroom */
 #define DPA_BP_HEAD (DPA_TX_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
 			DPA_HASH_RESULTS_SIZE)
 #define DPA_BP_SIZE(s)	(DPA_BP_HEAD + dpa_get_rx_extra_headroom() + (s))
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index a08f656..c4b44c0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -793,9 +793,10 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	} else {
 		/*
 		 * Make sure we have enough headroom to accomodate private
-		 * data, parse results, etc
+		 * data, parse results, etc. Normally this shouldn't happen if
+		 * we're here via the standard kernel stack.
 		 */
-		if (skb_headroom(skb) < DPA_BP_HEAD) {
+		if (unlikely(skb_headroom(skb) < DPA_BP_HEAD)) {
 			struct sk_buff *skb_new;
 
 			skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
-- 
1.7.5.4

