From af9025088ade7ef891855d810081bef7b8fd35f1 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:15:33 +0000
Subject: [PATCH 215/518] Replaced the xx_smart_malloc with standard Linux
 memory alloc/align

sec_desc_unaligned stores the address given by kmalloc, used when
freeing the allocated memory.
sec_desc holds the 64 byte alligned address, in which DPA IPSec is
constructing the SEC 4.x descriptor.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   19 ++++++++++---------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   14 +++++++++-----
 2 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 8b43bc0..04bf107 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -630,15 +630,17 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			return -ENOMEM;
 		}
 
-		/* Allocate space for the sec descriptor which is holding the
-		 * preheader information and the share descriptor. 64 bit align.
+		/* Allocate space for the SEC descriptor which is holding the
+		 * preheader information and the share descriptor.
+		 * Required 64 byte align.
 		 */
-		sa_mng->sa[i].sec_desc =
-			xx_zalloc_smart(sizeof(struct sec_descriptor), 0, 64);
-		if (!sa_mng->sa[i].sec_desc) {
+		sa[i].sec_desc_unaligned =
+			kzalloc(sizeof(struct sec_descriptor) + 64, GFP_KERNEL);
+		if (!sa[i].sec_desc_unaligned) {
 			pr_err("Could not allocate memory for SEC descriptor\n");
 			return -ENOMEM;
 		}
+		sa[i].sec_desc = PTR_ALIGN(sa[i].sec_desc_unaligned, 64);
 
 		/* Initialize the policy parameter list which will hold all
 		 * inbound or outbound policy parameters which were use to
@@ -765,10 +767,9 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 			kfree(sa_mng->sa[i].to_sec_fq);
 			sa_mng->sa[i].to_sec_fq = NULL;
 
-			if (sa_mng->sa[i].sec_desc) {
-				xx_free_smart(sa_mng->sa[i].sec_desc);
-				sa_mng->sa[i].sec_desc = NULL;
-			}
+			kfree(sa_mng->sa[i].sec_desc_unaligned);
+			sa_mng->sa[i].sec_desc_unaligned = NULL;
+			sa_mng->sa[i].sec_desc = NULL;
 		}
 		kfree(sa_mng->sa);
 		sa_mng->sa = NULL;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 9a38445..1b7d2ef 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -219,11 +219,15 @@ struct dpa_ipsec_sa {
 	uint32_t id;			    /* Used to index in circular queue*/
 	struct cipher_params cipher_data;   /* Encryption parameters	      */
 	struct auth_params auth_data;	    /* Authentication key parameters  */
-	struct sec_descriptor *sec_desc;    /* Computed SEC 4.x descriptor    */
-			  /*Allocated at initialization time.
-			   * Holds valid information after creating the
-			   * shared descriptor according to the SA information*/
-	uint32_t stats_offset; /* Offset of the statistics (in bytes)  */
+	struct sec_descriptor *sec_desc_unaligned; /* Allocated at init time.
+					  * When releasing memory only free
+					  * this pointer and do not act on
+					  * sec_desc address		      */
+	struct sec_descriptor *sec_desc; /* 64 byte aligned address where is
+					  * computed the SEC 4.x descriptor
+					  * according to the SA information.
+					  * do not free this pointer!	      */
+	uint32_t stats_offset; /* Offset of the statistics (in bytes)	      */
 	bool	enable_stats; /* Enable counting packets and bytes processed  */
 	struct qman_fq *to_sec_fq; /*From this Frame Queue SEC consumes frames*/
 	struct qman_fq *from_sec_fq; /*In this Frame Queue SEC will enqueue the
-- 
1.7.5.4

