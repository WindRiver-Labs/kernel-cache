From 71be9d9f18c3bca0fd3e60f78500baa8d1ba30fb Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Tue, 11 Sep 2012 18:03:55 +0000
Subject: [PATCH 288/518] dpa_classifier: Add compatibility for 64 bit kernel

Added compat functions and structures in classifier API for 64 bit
kernel compatibility

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |  308 ++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   | 1033 +++++++++++++++++---
 2 files changed, 1201 insertions(+), 140 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 0aaf464..5cd924d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -118,6 +118,7 @@ struct ioc_dpa_cls_hm_remove_params {
 	int hmd;
 	struct dpa_cls_hm_remove_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
 struct ioc_dpa_cls_hm_insert_params {
@@ -126,6 +127,7 @@ struct ioc_dpa_cls_hm_insert_params {
 	int hmd;
 	struct dpa_cls_hm_insert_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
 struct ioc_dpa_cls_hm_vlan_params {
@@ -134,6 +136,7 @@ struct ioc_dpa_cls_hm_vlan_params {
 	int hmd;
 	struct dpa_cls_hm_vlan_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
 struct ioc_dpa_cls_hm_nat_params {
@@ -142,6 +145,7 @@ struct ioc_dpa_cls_hm_nat_params {
 	int hmd;
 	struct dpa_cls_hm_nat_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
 struct ioc_dpa_cls_hm_update_params {
@@ -150,6 +154,7 @@ struct ioc_dpa_cls_hm_update_params {
 	int hmd;
 	struct dpa_cls_hm_update_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
 struct ioc_dpa_cls_hm_fwd_params {
@@ -158,8 +163,17 @@ struct ioc_dpa_cls_hm_fwd_params {
 	int hmd;
 	struct dpa_cls_hm_fwd_resources res;
 	bool chain_head;
+	int modify_flags;
 };
 
+struct ioc_dpa_cls_hm_mpls_params {
+	struct dpa_cls_hm_mpls_params mpls_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_hm_mpls_resources res;
+	bool chain_head;
+	int modify_flags;
+};
 
 #ifdef CONFIG_COMPAT
 
@@ -257,6 +271,179 @@ struct compat_ioc_dpa_cls_tbl_lookup_by_ref {
 	struct dpa_cls_compat_tbl_action action;
 };
 
+struct dpa_cls_compat_hm_remove_resources {
+	compat_uptr_t	remove_node;
+};
+
+struct dpa_cls_compat_hm_remove_params {
+	enum dpa_cls_hm_remove_type	type;
+	struct dpa_cls_hm_custom_rm_params custom;
+	compat_uptr_t fm_pcd;
+};
+
+struct compat_ioc_dpa_cls_hm_remove_params {
+	struct dpa_cls_compat_hm_remove_params rm_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_remove_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_insert_resources {
+	compat_uptr_t	insert_node;
+};
+
+struct dpa_cls_compat_hm_custom_ins_params {
+	uint8_t		offset;
+	uint8_t		size;
+	compat_uptr_t	data;
+};
+
+struct dpa_cls_compat_hm_insert_params {
+	enum dpa_cls_hm_insert_type	type;
+	union {
+		struct dpa_cls_hm_eth_ins_params eth;
+		struct dpa_cls_hm_pppoe_ins_params		pppoe;
+		uint16_t					ppp_pid;
+		struct dpa_cls_compat_hm_custom_ins_params	custom;
+	};
+	compat_uptr_t	fm_pcd;
+};
+
+struct compat_ioc_dpa_cls_hm_insert_params {
+	struct dpa_cls_compat_hm_insert_params ins_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_insert_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_vlan_params {
+	enum dpa_cls_hm_vlan_type	type;
+	union {
+		struct dpa_cls_hm_ingress_vlan_params	ingress;
+		struct dpa_cls_hm_egress_vlan_params	egress;
+	};
+	compat_uptr_t	fm_pcd;
+};
+
+struct dpa_cls_compat_hm_vlan_resources {
+	compat_uptr_t	vlan_node;
+};
+
+struct compat_ioc_dpa_cls_hm_vlan_params {
+	struct dpa_cls_compat_hm_vlan_params vlan_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_vlan_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_nat_params {
+	int	flags;
+	enum dpa_cls_hm_nat_proto	proto;
+	enum dpa_cls_hm_nat_type	type;
+	union {
+		struct dpa_cls_hm_traditional_nat_params	nat;
+		struct dpa_cls_hm_nat_pt_params			nat_pt;
+	} params;
+	uint16_t	sport;
+	uint16_t	dport;
+	compat_uptr_t	fm_pcd;
+};
+
+struct dpa_cls_compat_hm_nat_resources {
+	compat_uptr_t	l3_update_node;
+	compat_uptr_t	l4_update_node;
+};
+
+struct compat_ioc_dpa_cls_hm_nat_params {
+	struct dpa_cls_compat_hm_nat_params nat_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_nat_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_update_params {
+	int	op_flags;
+	union {
+		struct iphdr		new_ipv4_hdr;
+		struct ipv6_header	new_ipv6_hdr;
+	} replace;
+	union {
+		struct dpa_cls_hm_l3_update_params	l3;
+		struct dpa_cls_hm_l4_update_params	l4;
+	} update;
+	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
+	compat_uptr_t				fm_pcd;
+};
+
+struct dpa_cls_compat_hm_update_resources {
+	compat_uptr_t	update_node;
+	compat_uptr_t	ip_frag_node;
+
+};
+
+struct compat_ioc_dpa_cls_hm_update_params {
+	struct dpa_cls_compat_hm_update_params update_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_update_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_fwd_params {
+	enum dpa_cls_hm_out_if_type	out_if_type;
+	union {
+		struct dpa_cls_hm_fwd_l2_param		eth;
+		struct dpa_cls_hm_fwd_pppoe_param	pppoe;
+		struct dpa_cls_hm_fwd_ppp_param		ppp;
+	};
+	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
+	compat_uptr_t				fm_pcd;
+};
+
+struct dpa_cls_compat_hm_fwd_resources {
+	compat_uptr_t	fwd_node;
+	compat_uptr_t	pppoe_node;
+	compat_uptr_t	ip_frag_node;
+};
+
+struct compat_ioc_dpa_cls_hm_fwd_params {
+	struct dpa_cls_compat_hm_fwd_params fwd_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_fwd_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
+struct dpa_cls_compat_hm_mpls_params {
+	enum dpa_cls_hm_mpls_type	type;
+	struct mpls_header		mpls_hdr[DPA_CLS_HM_MAX_MPLS_LABELS];
+	unsigned int			num_labels;
+	compat_uptr_t			fm_pcd;
+};
+
+struct dpa_cls_compat_hm_mpls_resources {
+	compat_uptr_t	ins_rm_node;
+};
+
+struct compat_ioc_dpa_cls_hm_mpls_params {
+	struct dpa_cls_compat_hm_mpls_params mpls_params;
+	int next_hmd;
+	int hmd;
+	struct dpa_cls_compat_hm_mpls_resources res;
+	bool chain_head;
+	int modify_flags;
+};
+
 
 int dpa_cls_tbl_entry_params_compatcpy(
 	struct ioc_dpa_cls_tbl_entry_params			*kparam,
@@ -310,6 +497,34 @@ int dpa_lookup_key_params_compatcpy(
 		struct dpa_offload_lookup_key			*kparam,
 		const struct compat_ioc_dpa_offld_lookup_key	*uparam);
 
+int dpa_cls_hm_remove_params_compatcpy(
+	struct ioc_dpa_cls_hm_remove_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_remove_params	*uparam);
+
+int dpa_cls_hm_insert_params_compatcpy(
+	struct ioc_dpa_cls_hm_insert_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_insert_params	*uparam);
+
+int dpa_cls_hm_vlan_params_compatcpy(
+	struct ioc_dpa_cls_hm_vlan_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_vlan_params		*uparam);
+
+int dpa_cls_hm_nat_params_compatcpy(
+	struct ioc_dpa_cls_hm_nat_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_nat_params		*uparam);
+
+int dpa_cls_hm_update_params_compatcpy(
+	struct ioc_dpa_cls_hm_update_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_update_params	*uparam);
+
+int dpa_cls_hm_fwd_params_compatcpy(
+	struct ioc_dpa_cls_hm_fwd_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_fwd_params		*uparam);
+
+int dpa_cls_hm_mpls_params_compatcpy(
+	struct ioc_dpa_cls_hm_mpls_params			*kparam,
+	const struct compat_ioc_dpa_cls_hm_mpls_params		*uparam);
+
 #endif /* CONFIG_COMPAT */
 
 
@@ -432,51 +647,118 @@ int dpa_lookup_key_params_compatcpy(
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_REMOVE_HM		\
 	_IOWR(DPA_CLS_IOC_MAGIC, 16,			\
-		struct compat_ioc_dpa_cls_hm_ingress_rm_params)
+		struct compat_ioc_dpa_cls_hm_remove_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_MODIFY_REMOVE_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 17, struct ioc_dpa_cls_hm_remove_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_REMOVE_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 17,			\
+		struct compat_ioc_dpa_cls_hm_remove_params)
 #endif /* CONFIG_COMPAT */
 
 #define DPA_CLS_IOC_SET_INSERT_HM			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 17, struct ioc_dpa_cls_hm_insert_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 18, struct ioc_dpa_cls_hm_insert_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_INSERT_HM		\
-	_IOWR(DPA_CLS_IOC_MAGIC, 17,			\
-		struct compat_ioc_dpa_cls_hm_egress_ins_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 18,			\
+		struct compat_ioc_dpa_cls_hm_insert_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_MODIFY_INSERT_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 19, struct ioc_dpa_cls_hm_insert_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_INSERT_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 19,			\
+		struct compat_ioc_dpa_cls_hm_insert_params)
 #endif /* CONFIG_COMPAT */
 
 #define DPA_CLS_IOC_SET_VLAN_HM				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 18, struct ioc_dpa_cls_hm_vlan_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct ioc_dpa_cls_hm_vlan_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_VLAN_HM			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 18, struct compat_ioc_dpa_cls_hm_vlan_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct compat_ioc_dpa_cls_hm_vlan_params)
 #endif /* CONFIG_COMPAT */
 
+#define DPA_CLS_IOC_MODIFY_VLAN_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct ioc_dpa_cls_hm_vlan_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_VLAN_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct compat_ioc_dpa_cls_hm_vlan_params)
+#endif /* CONFIG_COMPAT */
+
+
 #define DPA_CLS_IOC_SET_NAT_HM				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 19, struct ioc_dpa_cls_hm_nat_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 22, struct ioc_dpa_cls_hm_nat_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_NAT_HM			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 19, struct compat_ioc_dpa_cls_hm_nat_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 22, struct compat_ioc_dpa_cls_hm_nat_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_MODIFY_NAT_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 23, struct ioc_dpa_cls_hm_nat_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_NAT_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 23, struct compat_ioc_dpa_cls_hm_nat_params)
 #endif /* CONFIG_COMPAT */
 
 #define DPA_CLS_IOC_SET_UPDATE_HM			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct ioc_dpa_cls_hm_update_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 24, struct ioc_dpa_cls_hm_update_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_UPDATE_HM		\
-	_IOWR(DPA_CLS_IOC_MAGIC, 20, struct compat_ioc_dpa_cls_hm_update_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 24, struct compat_ioc_dpa_cls_hm_update_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_MODIFY_UPDATE_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 25, struct ioc_dpa_cls_hm_update_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_UPDATE_HM		\
+	_IOWR(DPA_CLS_IOC_MAGIC, 25, struct compat_ioc_dpa_cls_hm_update_params)
 #endif /* CONFIG_COMPAT */
 
 #define DPA_CLS_IOC_SET_FWD_HM				\
-	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct ioc_dpa_cls_hm_fwd_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 26, struct ioc_dpa_cls_hm_fwd_params)
 
 #ifdef CONFIG_COMPAT
 #define DPA_CLS_IOC_COMPAT_SET_FWD_HM			\
-	_IOWR(DPA_CLS_IOC_MAGIC, 21, struct compat_ioc_dpa_cls_hm_fwd_params)
+	_IOWR(DPA_CLS_IOC_MAGIC, 26, struct compat_ioc_dpa_cls_hm_fwd_params)
 #endif /* CONFIG_COMPAT */
 
+#define DPA_CLS_IOC_MODIFY_FWD_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 27, struct ioc_dpa_cls_hm_fwd_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_FWD_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 27, struct compat_ioc_dpa_cls_hm_fwd_params)
+#endif /* CONFIG_COMPAT */
+
+#define DPA_CLS_IOC_SET_MPLS_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 28, struct ioc_dpa_cls_hm_mpls_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_SET_MPLS_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 28, struct compat_ioc_dpa_cls_hm_mpls_params)
+#endif
+
+#define DPA_CLS_IOC_MODIFY_MPLS_HM				\
+	_IOWR(DPA_CLS_IOC_MAGIC, 29, struct ioc_dpa_cls_hm_mpls_params)
+
+#ifdef CONFIG_COMPAT
+#define DPA_CLS_IOC_COMPAT_MODIFY_MPLS_HM			\
+	_IOWR(DPA_CLS_IOC_MAGIC, 29, struct compat_ioc_dpa_cls_hm_mpls_params)
+#endif
+
 #define DPA_CLS_IOC_FREE_HM				\
-	_IOR(DPA_CLS_IOC_MAGIC, 22, int)
+	_IOR(DPA_CLS_IOC_MAGIC, 30, int)
 
 #endif /* __DPA_CLASSIFIER_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index a2ff12b..68dbf5c 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -159,17 +159,35 @@ static long do_ioctl_table_reset_stats_by_key(unsigned long	args,
 static long do_ioctl_set_remove_hm(unsigned long	args,
 				bool			compat_mode);
 
+static long do_ioctl_modify_remove_hm(unsigned long	args,
+				bool			compat_mode);
+
 static long do_ioctl_set_insert_hm(unsigned long	args,
 				bool			compat_mode);
 
+static long do_ioctl_modify_insert_hm(unsigned long	args,
+				bool			compat_mode);
+
 static long do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_modify_vlan_hm(unsigned long args, bool compat_mode);
+
 static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_modify_nat_hm(unsigned long args, bool compat_mode);
+
 static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_modify_update_hm(unsigned long args, bool compat_mode);
+
 static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode);
 
+static long do_ioctl_modify_fwd_hm(unsigned long args, bool compat_mode);
+
+static long do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode);
+
+static long do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode);
+
 void *translate_fm_pcd_handle(void *fm_pcd);
 
 static const struct file_operations dpa_classif_fops = {
@@ -467,35 +485,83 @@ long wrp_dpa_classif_do_ioctl(
 		ret = do_ioctl_set_remove_hm(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_REMOVE_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_REMOVE_HM:
+		ret = do_ioctl_modify_remove_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_INSERT_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_INSERT_HM:
 		ret = do_ioctl_set_insert_hm(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_INSERT_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_INSERT_HM:
+		ret = do_ioctl_modify_insert_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_VLAN_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_VLAN_HM:
 		ret = do_ioctl_set_vlan_hm(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_VLAN_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_VLAN_HM:
+		ret = do_ioctl_modify_vlan_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_NAT_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_NAT_HM:
 		ret = do_ioctl_set_nat_hm(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_NAT_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_NAT_HM:
+		ret = do_ioctl_modify_nat_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_UPDATE_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_UPDATE_HM:
 		ret = do_ioctl_set_update_hm(args, compat_mode);
 		break;
 #ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_UPDATE_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_UPDATE_HM:
+		ret = do_ioctl_modify_update_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
 	case DPA_CLS_IOC_COMPAT_SET_FWD_HM:
 #endif /* CONFIG_COMPAT */
 	case DPA_CLS_IOC_SET_FWD_HM:
 		ret = do_ioctl_set_fwd_hm(args, compat_mode);
 		break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_FWD_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_FWD_HM:
+		ret = do_ioctl_modify_fwd_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_SET_MPLS_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_SET_MPLS_HM:
+		ret = do_ioctl_set_mpls_hm(args, compat_mode);
+		break;
+#ifdef CONFIG_COMPAT
+	case DPA_CLS_IOC_COMPAT_MODIFY_MPLS_HM:
+#endif /* CONFIG_COMPAT */
+	case DPA_CLS_IOC_MODIFY_MPLS_HM:
+		ret = do_ioctl_modify_mpls_hm(args, compat_mode);
+		break;
 	case DPA_CLS_IOC_FREE_HM:
 		ret = dpa_classif_free_hm((int)args);
 		break;
@@ -578,13 +644,30 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 	long ret = 0;
 	struct ioc_dpa_cls_hm_remove_params kparam;
 	struct dpa_cls_hm_remove_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_remove_params uparam;
 
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"dpa_classif_set_ingress_remove_hm user space args.\n",
-			__FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_remove_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_remove_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_remove_hm user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Translate FM_PCD file descriptor */
 	kparam.rm_params.fm_pcd = translate_fm_pcd_handle(kparam.rm_params.
@@ -603,12 +686,65 @@ static long do_ioctl_set_remove_hm(unsigned long args, bool compat_mode)
 	if (ret < 0)
 		return ret;
 
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_ingress_remove_hm result.\n",
-			__FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
+	/* Return results to user space */
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_remove_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_remove_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_modify_remove_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_remove_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_remove_params uparam;
+
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_remove_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_remove_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_remove_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.rm_params.fm_pcd = translate_fm_pcd_handle(kparam.rm_params.
+								fm_pcd);
+	if (!kparam.rm_params.fm_pcd)
+		return -EINVAL;
+
+	ret = dpa_classif_modify_remove_hm(kparam.hmd, &kparam.rm_params,
+					   kparam.modify_flags);
 
 	return ret;
 }
@@ -618,196 +754,638 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	long ret = 0;
 	struct ioc_dpa_cls_hm_insert_params kparam;
 	struct dpa_cls_hm_insert_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_insert_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_insert_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_insert_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
 
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_insert_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	/* Translate FM_PCD file descriptor */
+	kparam.ins_params.fm_pcd = translate_fm_pcd_handle(kparam.ins_params.
+								fm_pcd);
+	if (!kparam.ins_params.fm_pcd)
+		return -EINVAL;
+
+	if (kparam.res.insert_node)
+		p_res = &kparam.res;
+
+	ret = dpa_classif_set_insert_hm(&kparam.ins_params, kparam.next_hmd,
+					&kparam.hmd, kparam.chain_head,
+					p_res);
+
+	if (ret < 0)
+			return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_insert_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_insert_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+
+}
+
+static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_insert_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_insert_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_insert_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_insert_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+			      "dpa_classif_modify_insert_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.ins_params.fm_pcd = translate_fm_pcd_handle(kparam.ins_params.
+								fm_pcd);
+	if (!kparam.ins_params.fm_pcd)
+		return -EINVAL;
+
+	ret = dpa_classif_modify_insert_hm(kparam.hmd, &kparam.ins_params,
+					   kparam.modify_flags);
+
+
+	return ret;
+}
+
+static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_vlan_params kparam;
+	struct dpa_cls_hm_vlan_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_vlan_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_vlan_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_vlan_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_vlan_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.vlan_params.fm_pcd = translate_fm_pcd_handle(kparam.vlan_params.
+								fm_pcd);
+	if (!kparam.vlan_params.fm_pcd)
+		return -EINVAL;
+
+	if (kparam.res.vlan_node)
+			p_res = &kparam.res;
+
+	ret = dpa_classif_set_vlan_hm(&kparam.vlan_params, kparam.next_hmd,
+				      &kparam.hmd, kparam.chain_head,
+				      p_res);
+
+	if (ret < 0)
+			return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_vlan_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_vlan_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+
+}
+
+static long do_ioctl_modify_vlan_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_vlan_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_vlan_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_vlan_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_vlan_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif
 	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
 		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"dpa_classif_set_egress_insert_hm user space args.\n",
+			"dpa_classif_modify_vlan_hm user space args.\n",
 			__FILE__, __func__, __LINE__);
 		return -EBUSY;
 	}
 
 	/* Translate FM_PCD file descriptor */
-	kparam.ins_params.fm_pcd = translate_fm_pcd_handle(kparam.ins_params.
+	kparam.vlan_params.fm_pcd = translate_fm_pcd_handle(kparam.vlan_params.
 								fm_pcd);
-	if (!kparam.ins_params.fm_pcd)
+	if (!kparam.vlan_params.fm_pcd)
 		return -EINVAL;
 
-	if (kparam.res.insert_node)
+	ret = dpa_classif_modify_vlan_hm(kparam.hmd, &kparam.vlan_params,
+					kparam.modify_flags);
+
+	return ret;
+}
+
+static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_nat_params kparam;
+	struct dpa_cls_hm_nat_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_nat_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_nat_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_nat_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_nat_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.nat_params.fm_pcd = translate_fm_pcd_handle(kparam.nat_params.
+								fm_pcd);
+	if (!kparam.nat_params.fm_pcd)
+		return -EINVAL;
+
+	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
 		p_res = &kparam.res;
 
-	ret = dpa_classif_set_insert_hm(&kparam.ins_params, kparam.next_hmd,
+	ret =  dpa_classif_set_nat_hm(&kparam.nat_params, kparam.next_hmd,
+				      &kparam.hmd, kparam.chain_head,
+				      p_res);
+
+	if (ret < 0)
+			return ret;
+
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_nat_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_nat_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_modify_nat_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_nat_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_nat_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_nat_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_nat_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_nat_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.nat_params.fm_pcd = translate_fm_pcd_handle(kparam.nat_params.
+								fm_pcd);
+	if (!kparam.nat_params.fm_pcd)
+		return -EINVAL;
+
+	ret = dpa_classif_modify_nat_hm(kparam.hmd, &kparam.nat_params,
+					kparam.modify_flags);
+
+	return ret;
+}
+
+static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_update_params kparam;
+	struct dpa_cls_hm_update_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_update_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_update_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_update_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"do_ioctl_set_update_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.update_params.fm_pcd = translate_fm_pcd_handle(kparam.
+						update_params.fm_pcd);
+	if (!kparam.update_params.fm_pcd)
+		return -EINVAL;
+
+	if (kparam.res.ip_frag_node || kparam.res.update_node)
+		p_res = &kparam.res;
+
+	ret =  dpa_classif_set_update_hm(&kparam.update_params, kparam.next_hmd,
 					&kparam.hmd, kparam.chain_head,
 					p_res);
 
+
 	if (ret < 0)
 			return ret;
 
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_egress_insert_hm result.\n",
-			__FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_update_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_update_hm result.\n", __FILE__,
+				__func__, __LINE__);
+			return -EBUSY;
+		}
+
+	return ret;
+}
+
+static long do_ioctl_modify_update_hm(unsigned long args, bool compat_mode)
+{
+	long ret = 0;
+	struct ioc_dpa_cls_hm_update_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_update_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_update_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_update_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+			       "dpa_classif_modify_update_hm user "
+			       "space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+	/* Translate FM_PCD file descriptor */
+	kparam.update_params.fm_pcd = translate_fm_pcd_handle(kparam.
+						update_params.fm_pcd);
+	if (!kparam.update_params.fm_pcd)
+		return -EINVAL;
+
+	ret = dpa_classif_modify_update_hm(kparam.hmd, &kparam.update_params,
+					   kparam.modify_flags);
 
 	return ret;
-
 }
 
-static long  do_ioctl_set_vlan_hm(unsigned long args, bool compat_mode)
+static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
-	struct ioc_dpa_cls_hm_vlan_params kparam;
-	struct dpa_cls_hm_vlan_resources *p_res = NULL;
+	struct ioc_dpa_cls_hm_fwd_params kparam;
+	struct dpa_cls_hm_fwd_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_fwd_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_fwd_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"dpa_classif_set_vlan_hm user space args.\n", __FILE__,
-			__func__, __LINE__);
-		return -EBUSY;
-	}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_fwd_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_fwd_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Translate FM_PCD file descriptor */
-	kparam.vlan_params.fm_pcd = translate_fm_pcd_handle(kparam.vlan_params.
+	kparam.fwd_params.fm_pcd = translate_fm_pcd_handle(kparam.fwd_params.
 								fm_pcd);
-	if (!kparam.vlan_params.fm_pcd)
+	if (!kparam.fwd_params.fm_pcd)
 		return -EINVAL;
 
-	if (kparam.res.vlan_node)
-			p_res = &kparam.res;
+	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
+	    kparam.res.pppoe_node)
+		p_res = &kparam.res;
+
+	ret = dpa_classif_set_fwd_hm(&kparam.fwd_params, kparam.next_hmd,
+				&kparam.hmd, kparam.chain_head,
+				p_res);
 
-	ret = dpa_classif_set_vlan_hm(&kparam.vlan_params, kparam.next_hmd,
-				      &kparam.hmd, kparam.chain_head,
-				      p_res);
 
 	if (ret < 0)
 			return ret;
 
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_vlan_hm result.\n", __FILE__, __func__,
-			__LINE__);
-		return -EBUSY;
-	}
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_update_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_fwd_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	return ret;
-
 }
 
-static long do_ioctl_set_nat_hm(unsigned long args, bool compat_mode)
+static long do_ioctl_modify_fwd_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
-	struct ioc_dpa_cls_hm_nat_params kparam;
-	struct dpa_cls_hm_nat_resources *p_res = NULL;
+	struct ioc_dpa_cls_hm_fwd_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_fwd_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_fwd_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"dpa_classif_set_nat_hm user space args.\n", __FILE__,
-			__func__, __LINE__);
-		return -EBUSY;
-	}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_fwd_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_modify_fwd_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Translate FM_PCD file descriptor */
-	kparam.nat_params.fm_pcd = translate_fm_pcd_handle(kparam.nat_params.
+	kparam.fwd_params.fm_pcd = translate_fm_pcd_handle(kparam.fwd_params.
 								fm_pcd);
-	if (!kparam.nat_params.fm_pcd)
+	if (!kparam.fwd_params.fm_pcd)
 		return -EINVAL;
 
-	if (kparam.res.l3_update_node || kparam.res.l4_update_node)
-		p_res = &kparam.res;
-
-	ret =  dpa_classif_set_nat_hm(&kparam.nat_params, kparam.next_hmd,
-				      &kparam.hmd, kparam.chain_head,
-				      p_res);
-
-	if (ret < 0)
-			return ret;
-
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_nat_hm result.\n", __FILE__, __func__,
-			__LINE__);
-		return -EBUSY;
-	}
+	ret = dpa_classif_modify_fwd_hm(kparam.hmd, &kparam.fwd_params,
+					kparam.modify_flags);
 
 	return ret;
 }
 
-static long do_ioctl_set_update_hm(unsigned long args, bool compat_mode)
+static long  do_ioctl_set_mpls_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
-	struct ioc_dpa_cls_hm_update_params kparam;
-	struct dpa_cls_hm_update_resources *p_res = NULL;
+	struct ioc_dpa_cls_hm_mpls_params kparam;
+	struct dpa_cls_hm_mpls_resources *p_res = NULL;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_mpls_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_set_mpls_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: "
-			"do_ioctl_set_update_hm user space args.\n", __FILE__,
-			__func__, __LINE__);
-		return -EBUSY;
-	}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_mpls_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed:"
+				"dpa_classif_set_mpls_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Translate FM_PCD file descriptor */
-	kparam.update_params.fm_pcd = translate_fm_pcd_handle(kparam.
-						update_params.fm_pcd);
-	if (!kparam.update_params.fm_pcd)
+	kparam.mpls_params.fm_pcd = translate_fm_pcd_handle(kparam.mpls_params.
+								fm_pcd);
+	if (!kparam.mpls_params.fm_pcd)
 		return -EINVAL;
 
-	if (kparam.res.ip_frag_node || kparam.res.update_node)
+	if (kparam.res.ins_rm_node)
 		p_res = &kparam.res;
 
-	ret =  dpa_classif_set_update_hm(&kparam.update_params, kparam.next_hmd,
-					&kparam.hmd, kparam.chain_head,
-					p_res);
-
+	ret = dpa_classif_set_mpls_hm(&kparam.mpls_params, kparam.next_hmd,
+				&kparam.hmd, kparam.chain_head,
+				p_res);
 
 	if (ret < 0)
-			return ret;
+		return ret;
 
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_update_hm result.\n", __FILE__,
-			__func__, __LINE__);
-		return -EBUSY;
-	}
+#ifdef CONFIG_COMPAT
+	if (compat_mode) {
+		uparam.hmd = kparam.hmd;
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_mpls_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_set_mpls_hm result.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	return ret;
 }
 
-static long do_ioctl_set_fwd_hm(unsigned long args, bool compat_mode)
+static long  do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
-	struct ioc_dpa_cls_hm_fwd_params kparam;
-	struct dpa_cls_hm_fwd_resources *p_res = NULL;
+	struct ioc_dpa_cls_hm_mpls_params kparam;
+#ifdef CONFIG_COMPAT
+	struct compat_ioc_dpa_cls_hm_mpls_params uparam;
+	if (compat_mode) {
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"do_ioctl_modify_mpls_hm user "
+				"space args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Read failed: dpa_classif_set_fwd_hm"
-			" user space args.\n", __FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
+		/* Transfer the data into the kernel space params: */
+		ret = dpa_cls_hm_mpls_params_compatcpy(&kparam, &uparam);
+		if (ret < 0)
+			return ret;
+
+	} else
+#endif /* CONFIG_COMPAT */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed:"
+				"dpa_classif_modify_mpls_hm user space args.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Translate FM_PCD file descriptor */
-	kparam.fwd_params.fm_pcd = translate_fm_pcd_handle(kparam.fwd_params.
+	kparam.mpls_params.fm_pcd = translate_fm_pcd_handle(kparam.mpls_params.
 								fm_pcd);
-	if (!kparam.fwd_params.fm_pcd)
+	if (!kparam.mpls_params.fm_pcd)
 		return -EINVAL;
 
-	if (kparam.res.ip_frag_node || kparam.res.fwd_node ||
-	    kparam.res.pppoe_node)
-		p_res = &kparam.res;
-
-	ret = dpa_classif_set_fwd_hm(&kparam.fwd_params, kparam.next_hmd,
-				&kparam.hmd, kparam.chain_head,
-				p_res);
-
-
-	if (ret < 0)
-			return ret;
-
-	if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-		pr_err("ERROR: %s, %s (%d): Write failed: "
-			"dpa_classif_set_fwd_hm result.\n", __FILE__, __func__,
-			__LINE__);
-		return -EBUSY;
-	}
+	ret = dpa_classif_modify_mpls_hm(kparam.hmd, &kparam.mpls_params,
+					kparam.modify_flags);
 
 	return ret;
 }
@@ -1428,7 +2006,7 @@ void *translate_fm_pcd_handle(void *fm_pcd)
 	struct file *fm_pcd_file;
 	t_LnxWrpFmDev *fm_wrapper_dev;
 
-	fm_pcd_file = fcheck((unsigned int)fm_pcd);
+	fm_pcd_file = fcheck((unsigned long)fm_pcd);
 	if (!fm_pcd_file) {
 		pr_err("ERROR: %s, %s (%d): Could not translate PCD handle.\n",
 			__FILE__, __func__, __LINE__);
@@ -1709,4 +2287,205 @@ int dpa_cls_tbl_lookup_by_ref_params_compatcpy(
 	return 0;
 }
 
+int dpa_cls_hm_remove_params_compatcpy(
+		struct ioc_dpa_cls_hm_remove_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_remove_params	*uparam)
+{
+	kparam->rm_params.type = uparam->rm_params.type;
+	memcpy(&kparam->rm_params.custom, &uparam->rm_params.custom,
+		sizeof(struct dpa_cls_hm_custom_rm_params));
+	kparam->rm_params.fm_pcd = compat_ptr(uparam->rm_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.remove_node = compat_get_id2ptr(uparam->res.remove_node,
+						    FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_insert_params_compatcpy(
+		struct ioc_dpa_cls_hm_insert_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_insert_params	*uparam)
+{
+	int type;
+
+	type = kparam->ins_params.type;
+	switch (type) {
+	case DPA_CLS_HM_INSERT_CUSTOM:
+		kparam->ins_params.custom.offset = uparam->ins_params.
+							custom.offset;
+		kparam->ins_params.custom.size = uparam->ins_params.
+							custom.size;
+		kparam->ins_params.custom.data = compat_ptr(uparam->ins_params.
+							custom.data);
+		break;
+	case DPA_CLS_HM_INSERT_ETHERNET:
+		memcpy(&kparam->ins_params.eth, &uparam->ins_params.eth,
+			sizeof(struct dpa_cls_hm_eth_ins_params));
+		break;
+	case DPA_CLS_HM_INSERT_PPPoE:
+		memcpy(&kparam->ins_params.pppoe, &uparam->ins_params.pppoe,
+			sizeof(struct dpa_cls_hm_pppoe_ins_params));
+		break;
+	case DPA_CLS_HM_INSERT_PPP:
+		kparam->ins_params.ppp_pid = uparam->ins_params.ppp_pid;
+		break;
+	default:
+		break;
+	}
+	kparam->ins_params.fm_pcd = compat_ptr(uparam->ins_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.insert_node = compat_get_id2ptr(uparam->res.insert_node,
+						    FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_vlan_params_compatcpy(
+		struct ioc_dpa_cls_hm_vlan_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_vlan_params		*uparam)
+{
+	int type;
+
+	type = kparam->vlan_params.type;
+	switch (type) {
+	case DPA_CLS_HM_VLAN_INGRESS:
+		memcpy(&kparam->vlan_params.ingress,
+			&uparam->vlan_params.ingress,
+			sizeof(struct dpa_cls_hm_ingress_vlan_params));
+		break;
+	case DPA_CLS_HM_VLAN_EGRESS:
+		memcpy(&kparam->vlan_params.ingress,
+			&uparam->vlan_params.egress,
+			sizeof(struct dpa_cls_hm_egress_vlan_params));
+		break;
+	default:
+		break;
+	}
+
+	kparam->vlan_params.fm_pcd = compat_ptr(uparam->vlan_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.vlan_node = compat_get_id2ptr(uparam->res.vlan_node,
+						FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_nat_params_compatcpy(
+		struct ioc_dpa_cls_hm_nat_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_nat_params		*uparam)
+{
+	kparam->nat_params.flags = uparam->nat_params.flags;
+	kparam->nat_params.proto = uparam->nat_params.proto;
+	kparam->nat_params.type = uparam->nat_params.type;
+	memcpy(&kparam->nat_params.params, &uparam->nat_params.params,
+		sizeof(kparam->nat_params.params));
+
+	kparam->nat_params.fm_pcd = compat_ptr(uparam->nat_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.l3_update_node =
+			compat_get_id2ptr(uparam->res.l3_update_node,
+					FM_MAP_TYPE_PCD_NODE);
+	kparam->res.l4_update_node =
+			compat_get_id2ptr(uparam->res.l4_update_node,
+					FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_update_params_compatcpy(
+		struct ioc_dpa_cls_hm_update_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_update_params	*uparam)
+{
+	kparam->update_params.op_flags = uparam->update_params.op_flags;
+	memcpy(&kparam->update_params.replace, &uparam->update_params.replace,
+		sizeof(kparam->update_params.replace));
+	memcpy(&kparam->update_params.update, &uparam->update_params.update,
+		sizeof(kparam->update_params.update));
+	memcpy(&kparam->update_params.ip_frag_params,
+		&uparam->update_params.ip_frag_params,
+		sizeof(kparam->update_params.ip_frag_params));
+	kparam->update_params.fm_pcd = compat_ptr(uparam->update_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.update_node = compat_get_id2ptr(uparam->res.update_node,
+						FM_MAP_TYPE_PCD_NODE);
+	kparam->res.ip_frag_node = compat_get_id2ptr(uparam->res.ip_frag_node,
+							FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_fwd_params_compatcpy(
+		struct ioc_dpa_cls_hm_fwd_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_fwd_params		*uparam)
+{
+	int type;
+
+	type = kparam->fwd_params.out_if_type;
+	kparam->fwd_params.out_if_type = uparam->fwd_params.out_if_type;
+	switch (type) {
+	case DPA_CLS_HM_IF_TYPE_ETHERNET:
+		memcpy(&kparam->fwd_params.eth, &uparam->fwd_params.eth,
+			sizeof(struct dpa_cls_hm_fwd_l2_param));
+		break;
+	case DPA_CLS_HM_IF_TYPE_PPPoE:
+		memcpy(&kparam->fwd_params.pppoe, &uparam->fwd_params.pppoe,
+			sizeof(struct dpa_cls_hm_fwd_pppoe_param));
+		break;
+	case DPA_CLS_HM_IF_TYPE_PPP:
+		memcpy(&kparam->fwd_params.ppp, &uparam->fwd_params.ppp,
+			sizeof(struct dpa_cls_hm_fwd_ppp_param));
+		break;
+	default:
+		break;
+	}
+
+	kparam->fwd_params.fm_pcd = compat_ptr(uparam->fwd_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.fwd_node = compat_get_id2ptr(uparam->res.fwd_node,
+						FM_MAP_TYPE_PCD_NODE);
+	kparam->res.pppoe_node = compat_get_id2ptr(uparam->res.pppoe_node,
+						FM_MAP_TYPE_PCD_NODE);
+	kparam->res.ip_frag_node = compat_get_id2ptr(uparam->res.ip_frag_node,
+						FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
+int dpa_cls_hm_mpls_params_compatcpy(
+		struct ioc_dpa_cls_hm_mpls_params			*kparam,
+		const struct compat_ioc_dpa_cls_hm_mpls_params		*uparam)
+{
+	kparam->mpls_params.type = uparam->mpls_params.type;
+	memcpy(kparam->mpls_params.mpls_hdr, uparam->mpls_params.mpls_hdr,
+		sizeof(struct mpls_header) * DPA_CLS_HM_MAX_MPLS_LABELS);
+	kparam->mpls_params.num_labels = uparam->mpls_params.num_labels;
+	kparam->mpls_params.fm_pcd = compat_ptr(uparam->mpls_params.fm_pcd);
+	kparam->next_hmd = uparam->next_hmd;
+	kparam->hmd =  uparam->hmd;
+	kparam->res.ins_rm_node = compat_get_id2ptr(uparam->res.ins_rm_node,
+				FM_MAP_TYPE_PCD_NODE);
+	kparam->chain_head = uparam->chain_head;
+	kparam->modify_flags = uparam->modify_flags;
+
+	return 0;
+}
+
 #endif /* CONFIG_COMPAT */
-- 
1.7.5.4

