From 433c9f1b7fda12fb79da8c5f9aac2a3defee3592 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 20:00:49 +0000
Subject: [PATCH 292/518] dpa_classifier: Rendered DPA Classifier thread safe

Adjusted the following functions to be thread safe:

dpa_classif_table_create
dpa_classif_table_free
dpa_classif_table_modify_miss_action
dpa_classif_table_insert_entry
dpa_classif_table_modify_entry_by_key
dpa_classif_table_modify_entry_by_ref
dpa_classif_table_delete_entry_by_key
dpa_classif_table_delete_entry_by_ref
dpa_classif_table_lookup_by_key
dpa_classif_table_lookup_by_ref
dpa_classif_table_flush
dpa_classif_table_get_entry_stats_by_key
dpa_classif_table_get_entry_stats_by_ref
dpa_classif_table_get_params

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  447 ++++++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   52 ++-
 2 files changed, 363 insertions(+), 136 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 2327f7a..55d2355 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -58,21 +58,43 @@
 #define ETHERTYPE_SIZE						2 /* bytes */
 
 
+DEFINE_MUTEX(table_array_lock);
+DEFINE_MUTEX(hm_array_lock);
+
 /* DPA Classifier table descriptor table */
 struct dpa_cls_descriptor_table		table_array = {
 	.num_descriptors	= 0,
 	.used_descriptors	= 0,
-	.object			= NULL
+	.object			= NULL,
+	.access			= &table_array_lock
 };
 
 /* Header manipulation descriptor table */
 struct dpa_cls_descriptor_table		hm_array = {
 	.num_descriptors	= 0,
 	.used_descriptors	= 0,
-	.object			= NULL
+	.object			= NULL,
+	.access			= &hm_array_lock
 };
 
 
+/*
+ * Gets the first free descriptor in the indicated descriptor table and fills
+ * it with the provided object pointer. If there are no available descriptors,
+ * the function fails. This function is not thread safe.
+ */
+static int get_descriptor(struct dpa_cls_descriptor_table *desc_table,
+						void *object, int *desc);
+
+/*
+ * Extends with one more step an existing descriptor table. The array is
+ * reallocated with a constant number of new elements which is defined by the
+ * DPA Classifier implementation. This function is not thread safe.
+ */
+static int	extend_descriptor_table(struct dpa_cls_descriptor_table
+								*desc_table);
+
+
 int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 				int				*td)
 {
@@ -89,10 +111,6 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	if (err < 0)
 		return err;
 
-	err = acquire_new_descriptor(&table_array, td);
-	if (err < 0)
-		return err;
-
 	ptable = kzalloc(sizeof(*ptable), GFP_KERNEL);
 	if (!ptable) {
 		pr_err("ERROR: %s, %s (%d): No more memory for DPA classifier "
@@ -101,6 +119,8 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 		goto dpa_classif_table_create_error;
 	}
 
+	mutex_init(&ptable->access);
+
 	/* Copy over the table params into the control block */
 	memcpy(&ptable->params, params, sizeof(struct dpa_cls_tbl_params));
 
@@ -188,9 +208,14 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	if (err < 0)
 		goto dpa_classif_table_create_error;
 
-	table_array.object[*td] = ptable;
 	init_crc8_table(CRC8_WCDMA_POLY);
 
+	lock_desc_table(&table_array);
+	err = acquire_descriptor(&table_array, ptable, td);
+	release_desc_table(&table_array);
+	if (err < 0)
+		goto dpa_classif_table_create_error;
+
 	return err;
 
 dpa_classif_table_create_error:
@@ -209,11 +234,8 @@ dpa_classif_table_create_error:
 		ptable->entries_cnt = 0;
 
 		kfree(ptable);
-		put_descriptor(&table_array, *td);
 	}
 
-	*td = DPA_OFFLD_DESC_NONE;
-
 	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_create);
@@ -223,14 +245,19 @@ int dpa_classif_table_free(int td)
 	int err;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	mutex_lock(&ptable->access);
 
 	/* Flush the entries in the table */
-	err = dpa_classif_table_flush(td);
+	err = flush_table(ptable);
 
 	/* Check shadow table if it exists */
 	if (ptable->shadow_table) {
@@ -258,9 +285,10 @@ int dpa_classif_table_free(int td)
 
 	free_table_management(ptable);
 
-	kfree(table_array.object[td]);
-
 	put_descriptor(&table_array, td);
+	release_desc_table(&table_array);
+
+	kfree(ptable);
 
 	return err;
 }
@@ -274,14 +302,21 @@ int dpa_classif_table_modify_miss_action(int			td,
 	t_FmPcdCcNextEngineParams miss_engine_params;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(miss_action, "miss_action", -EINVAL);
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Miss Action for DPA Classifier "
 			"Indexed Tables is not supported.\n", __FILE__,
 			__func__, __LINE__);
@@ -290,13 +325,16 @@ int dpa_classif_table_modify_miss_action(int			td,
 
 	/* Fill the [miss_engine_params] structure w/ data */
 	errno = action_to_next_engine_params(miss_action, &miss_engine_params);
-	if (errno < 0)
+	if (errno < 0) {
+		mutex_unlock(&ptable->access);
 		return errno;
+	}
 
 	if (ptable->params.type == DPA_CLS_TBL_HASH) {
 		err = FM_PCD_HashTableModifyMissNextEngine(ptable->params.
 			cc_node, &miss_engine_params);
 		if (err != E_OK) {
+			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): "
 				"FM_PCD_HashTableModifyMissNextEngine failed.\n",
 				__FILE__, __func__, __LINE__);
@@ -308,6 +346,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 		err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 			int_cc_node[0].cc_node, &miss_engine_params);
 		if (err != E_OK) {
+			mutex_unlock(&ptable->access);
 			pr_err("ERROR: %s, %s (%d): "
 				"FM_PCD_MatchTableModifyMissNextEngine "
 				"failed.\n", __FILE__, __func__, __LINE__);
@@ -316,6 +355,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 			return -EBUSY;
 		}
 	}
+	mutex_unlock(&ptable->access);
 
 	return 0;
 }
@@ -330,18 +370,25 @@ int dpa_classif_table_insert_entry(int				td,
 	int err = 0;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
 	xx_sanity_check_return_value(((key->size > 0) &&
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Insert entry in an indexed table "
 			"makes no sense. Please use modify_entry instead.\n",
 			__FILE__, __func__, __LINE__);
@@ -355,6 +402,7 @@ int dpa_classif_table_insert_entry(int				td,
 	 */
 	if ((ptable->shadow_table) &&
 			(find_shadow_entry(ptable, key) != NULL)) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry already "
 			"exists.\n", __FILE__, __func__, __LINE__);
 		return -EEXIST;
@@ -378,6 +426,7 @@ int dpa_classif_table_insert_entry(int				td,
 		BUG_ON(0);
 	}
 
+	mutex_unlock(&ptable->access);
 	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_insert_entry);
@@ -387,21 +436,30 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
 	int entry_id;
+	int ret;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
 	xx_sanity_check_return_value(((key->size > 0) &&
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
 	/* Check for unsupported modifications */
-	ptable = (struct dpa_cls_table *) table_array.object[td];
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
 		(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Modify entry key is supported only "
 			"on exact match tables.\n", __FILE__, __func__,
 			__LINE__);
@@ -410,13 +468,17 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
 			"associated with this lookup key.\n", __FILE__,
 			__func__, __LINE__);
 		return entry_id;
 	}
 
-	return dpa_classif_table_modify_entry_by_ref(td, entry_id, mod_params);
+	ret = table_modify_entry_by_ref(ptable, entry_id, mod_params);
+	mutex_unlock(&ptable->access);
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_key);
 
@@ -424,6 +486,31 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		int						entry_id,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
+	int err;
+	struct dpa_cls_table *ptable;
+
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
+	err = table_modify_entry_by_ref(ptable, entry_id, mod_params);
+	mutex_unlock(&ptable->access);
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_ref);
+
+static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
+		int						entry_id,
+		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
+{
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct dpa_cls_tbl_action *action;
@@ -437,15 +524,10 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	unsigned int cc_node_index, key_size;
 	int errno;
 	t_Error err;
-	struct dpa_cls_table *ptable;
 	t_Handle cc_node;
 	struct list_head *shadow_list_entry, *new_bucket_list;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
-
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	BUG_ON(!ptable);
 
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
@@ -547,6 +629,8 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 			return -EINVAL;
 		}
 
+		memset(&key_params, 0, sizeof(key_params));
+
 		errno = action_to_next_engine_params(mod_params->action,
 						&key_params.ccNextEngineParams);
 		if (errno < 0)
@@ -557,7 +641,6 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 		 * is not using const pointers and we cannot provide it the
 		 * const pointers that the user provided.
 		 */
-		memset(&key_params, 0, sizeof(key_params));
 		memcpy(key_data,
 			mod_params->key->byte,
 			mod_params->key->size);
@@ -648,52 +731,83 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 
 	return 0;
 }
-EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_ref);
 
 int dpa_classif_table_delete_entry_by_key(int				td,
 				const struct dpa_offload_lookup_key	*key)
 {
 	int entry_id;
+	int err;
+	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
 	xx_sanity_check_return_value(((key->size > 0) &&
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
-			table_array.object[td], key);
+			ptable, key);
 	if (entry_id < 0) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
 			"associated with this lookup key.\n", __FILE__,
 			__func__, __LINE__);
 		return entry_id;
 	}
 
-	return dpa_classif_table_delete_entry_by_ref(td, entry_id);
+	err = table_delete_entry_by_ref(ptable, entry_id);
+	mutex_unlock(&ptable->access);
+
+	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_delete_entry_by_key);
 
 int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 {
+	int err;
+	struct dpa_cls_table *ptable;
+
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
+	err = table_delete_entry_by_ref(ptable, entry_id);
+	mutex_unlock(&ptable->access);
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_table_delete_entry_by_ref);
+
+static int table_delete_entry_by_ref(struct dpa_cls_table *ptable, int entry_id)
+{
 	t_Error err;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	uint8_t entry_index;
 	unsigned int cc_node_index;
-	struct dpa_cls_table *ptable;
 	t_Handle cc_node;
 	struct list_head *shadow_list_entry, *list_current;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
-
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	BUG_ON(!ptable);
 
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
@@ -774,7 +888,6 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 
 	return 0;
 }
-EXPORT_SYMBOL(dpa_classif_table_delete_entry_by_ref);
 
 int dpa_classif_table_lookup_by_key(int				td,
 			const struct dpa_offload_lookup_key	*key,
@@ -785,17 +898,25 @@ int dpa_classif_table_lookup_by_key(int				td,
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
 	xx_sanity_check_return_value(((key->size > 0) &&
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
 	if (!ptable->shadow_table) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
 			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
 			__func__, __LINE__);
@@ -803,8 +924,10 @@ int dpa_classif_table_lookup_by_key(int				td,
 	}
 
 	pos = find_shadow_entry(ptable, key);
-	if (!pos)
+	if (!pos) {
+		mutex_unlock(&ptable->access);
 		return -ENODEV;
+	}
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 		shadow_entry_indexed = list_entry(pos,
@@ -820,6 +943,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 			sizeof(struct dpa_cls_tbl_action));
 	}
 
+	mutex_unlock(&ptable->access);
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_table_lookup_by_key);
@@ -828,24 +952,31 @@ int dpa_classif_table_lookup_by_ref(int				td,
 				int				entry_id,
 				struct dpa_cls_tbl_action	*action)
 {
+	struct dpa_cls_table *ptable;
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct list_head *shadow_list_entry;
-	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
+	xx_sanity_check_return_value(action, "action", -EINVAL);
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
 
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
 	xx_sanity_check_return_value(ptable->entry[entry_id].valid,
 		"entry_id", -EINVAL);
-	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!ptable->shadow_table) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
 			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
 			__func__, __LINE__);
@@ -871,28 +1002,46 @@ int dpa_classif_table_lookup_by_ref(int				td,
 			sizeof(struct dpa_cls_tbl_action));
 	}
 
+	mutex_unlock(&ptable->access);
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_table_lookup_by_ref);
 
 int dpa_classif_table_flush(int td)
 {
+	int err;
+	struct dpa_cls_table *ptable;
+
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
+	err = flush_table(ptable);
+
+	mutex_unlock(&ptable->access);
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_table_flush);
+
+static int flush_table(struct dpa_cls_table *ptable)
+{
 	struct dpa_cls_tbl_shadow_entry *shadow_entry;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	unsigned int cc_node_index, i;
 	t_Error err;
-	struct dpa_cls_table *ptable;
 	t_Handle cc_node;
 	struct list_head *list_current, *tmp;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
-
-	ptable = (struct dpa_cls_table *) table_array.object[td];
-
 	if (list_empty(&ptable->entry_list))
 		/* Table is already empty. Nothing to do */
 		return 0;
@@ -961,35 +1110,45 @@ int dpa_classif_table_flush(int td)
 
 	return 0;
 }
-EXPORT_SYMBOL(dpa_classif_table_flush);
 
 int dpa_classif_table_get_entry_stats_by_key(int			td,
 				const struct dpa_offload_lookup_key	*key,
 				struct dpa_cls_tbl_entry_stats		*stats)
 {
 	int entry_id;
+	int err;
+	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
 	xx_sanity_check_return_value(((key->size > 0) &&
 		(key->size <= DPA_OFFLD_MAXENTRYKEYSIZE)), "key", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
-	entry_id = key_to_entry_id((struct dpa_cls_table *)
-					table_array.object[td], key);
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
+	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
+		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
 			"associated with this lookup key.\n", __FILE__,
 			__func__, __LINE__);
 		return entry_id;
 	}
 
-	return dpa_classif_table_get_entry_stats_by_ref(td,
-							entry_id,
-							stats);
+	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
+	mutex_unlock(&ptable->access);
+
+	return err;
 }
 EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_key);
 
@@ -997,17 +1156,37 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 				int				entry_id,
 				struct dpa_cls_tbl_entry_stats	*stats)
 {
+	struct dpa_cls_table *ptable;
+	int err;
+
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
+
+	err = table_get_entry_stats_by_ref(ptable, entry_id, stats);
+	mutex_unlock(&ptable->access);
+
+	return err;
+}
+EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_ref);
+
+static int table_get_entry_stats_by_ref(struct dpa_cls_table	*ptable,
+				int				entry_id,
+				struct dpa_cls_tbl_entry_stats	*stats)
+{
 	unsigned int cc_node_index;
 	uint8_t entry_index;
 	t_Handle cc_node;
-	struct dpa_cls_table *ptable;
 	struct dpa_cls_tbl_entry *index_entry;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
-
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	BUG_ON(!ptable);
 
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < ptable->entries_cnt)), "entry_id", -EINVAL);
@@ -1025,21 +1204,27 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 
 	return 0;
 }
-EXPORT_SYMBOL(dpa_classif_table_get_entry_stats_by_ref);
 
 int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
 {
 	struct dpa_cls_table *ptable;
 
-	xx_sanity_check_return_value(((td >= 0) &&
-		(td < table_array.num_descriptors)), "td", -EINVAL);
-	xx_sanity_check_return_value(table_array.object[td], "td", -EINVAL);
 	xx_sanity_check_return_value(params, "params", -EINVAL);
 
-	ptable = (struct dpa_cls_table *) table_array.object[td];
+	lock_desc_table(&table_array);
+	ptable = desc_to_object(&table_array, td);
+	if (!ptable) {
+		release_desc_table(&table_array);
+		pr_err("ERROR: %s, %s (%d): No such table (td=%d).\n", __FILE__,
+			__func__, __LINE__, td);
+		return -EINVAL;
+	}
+	mutex_lock(&ptable->access);
+	release_desc_table(&table_array);
 
 	memcpy(params, &ptable->params, sizeof(struct dpa_cls_tbl_params));
 
+	mutex_unlock(&ptable->access);
 	return 0;
 }
 EXPORT_SYMBOL(dpa_classif_table_get_params);
@@ -2096,8 +2281,8 @@ static int extend_descriptor_table(struct dpa_cls_descriptor_table *desc_table)
 	return 0;
 }
 
-static int get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
-	int *desc)
+static int get_descriptor(struct dpa_cls_descriptor_table *desc_table,
+						void *object, int *desc)
 {
 	int i;
 
@@ -2106,6 +2291,7 @@ static int get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
 
 	for (i = 0; i < desc_table->num_descriptors; i++)
 		if (desc_table->object[i] == NULL) {
+			desc_table->object[i] = object;
 			*desc = i;
 			break;
 		}
@@ -2115,12 +2301,16 @@ static int get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
 	return 0;
 }
 
-static int acquire_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
-	int *desc)
+static int acquire_descriptor(struct dpa_cls_descriptor_table *desc_table,
+	void *object, int *desc)
 {
 	int err;
 
-	if (get_new_descriptor(desc_table, desc) < 0) {
+	BUG_ON(!desc_table);
+	BUG_ON(!object);
+	BUG_ON(!desc);
+
+	if (get_descriptor(desc_table, object, desc) < 0) {
 		err = extend_descriptor_table(desc_table);
 		if (err < 0)
 			return err;
@@ -2129,7 +2319,7 @@ static int acquire_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
 		 * If extending the table was successful it is impossible for
 		 * the following function to fail
 		 */
-		get_new_descriptor(desc_table, desc);
+		get_descriptor(desc_table, object, desc);
 	}
 
 	return 0;
@@ -2138,6 +2328,8 @@ static int acquire_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
 static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
 	int desc)
 {
+	BUG_ON(!desc_table);
+
 	if (desc_table->object[desc] != NULL) {
 		if (--desc_table->used_descriptors == 0) {
 			kfree(desc_table->object);
@@ -2148,6 +2340,32 @@ static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
 	}
 }
 
+static inline void lock_desc_table(struct dpa_cls_descriptor_table
+								*desc_table)
+{
+	mutex_lock(desc_table->access);
+}
+
+static inline void release_desc_table(struct dpa_cls_descriptor_table
+								*desc_table)
+{
+	mutex_unlock(desc_table->access);
+}
+
+static void	*desc_to_object(struct dpa_cls_descriptor_table *desc_table,
+								int desc)
+{
+	BUG_ON(!desc_table);
+
+	if ((desc >= 0) && (desc < desc_table->num_descriptors))
+		return table_array.object[desc];
+	else {
+		pr_err("ERROR: %s, %s (%d): No such object (desc=%d).\n",
+			__FILE__, __func__, __LINE__, desc);
+		return NULL;
+	}
+}
+
 static inline void key_apply_mask(const struct dpa_offload_lookup_key *key,
 	uint8_t *new_key)
 {
@@ -2538,24 +2756,24 @@ static int add_local_hm_nodes_to_chain(struct dpa_cls_hm *phm)
 }
 
 static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
-						struct list_head *current)
+						struct list_head *item)
 {
 	int err = 0;
 	struct dpa_cls_hm_node *pcurrent, *pnext;
 
 	BUG_ON(!chain_head);
-	BUG_ON(!current);
+	BUG_ON(!item);
 
-	if (current->next != chain_head) {
+	if (item->next != chain_head) {
 		/* Initialize the rest of the HM chain */
-		err = init_hm_chain(fm_pcd, chain_head, current->next);
+		err = init_hm_chain(fm_pcd, chain_head, item->next);
 		if (err)
 			return err;
 	}
 
 	/* Initialize the current node: */
-	pcurrent = list_entry(current, struct dpa_cls_hm_node, list_node);
-	pnext = list_entry(current->next, struct dpa_cls_hm_node, list_node);
+	pcurrent = list_entry(item, struct dpa_cls_hm_node, list_node);
+	pnext = list_entry(item->next, struct dpa_cls_hm_node, list_node);
 
 	pcurrent->params.h_NextManip = (t_Handle)pnext->node;
 	pcurrent->node = (void *) FM_PCD_ManipNodeSet((t_Handle) fm_pcd,
@@ -2566,32 +2784,32 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	return err;
 }
 
-int remove_hm_chain(struct list_head *chain_head, struct list_head *current)
+int remove_hm_chain(struct list_head *chain_head, struct list_head *item)
 {
 	int err = 0;
 	struct dpa_cls_hm_node *pcurrent;
 
 	BUG_ON(!chain_head);
-	BUG_ON(!current);
+	BUG_ON(!item);
 
 	/* Remove the current node: */
-	pcurrent = list_entry(current, struct dpa_cls_hm_node, list_node);
+	pcurrent = list_entry(item, struct dpa_cls_hm_node, list_node);
 
 	if (FM_PCD_ManipNodeDelete((t_Handle) pcurrent->node) != E_OK) {
 		pr_warn("WARNING: Failed to remove low level HM.\n");
 		pr_warn("WARNING: FMan driver call failed.\n");
 	}
 
-	if (current->next != chain_head) {
+	if (item->next != chain_head) {
 		/* Remove the rest of the HM chain */
-		err = remove_hm_chain(chain_head, current->next);
+		err = remove_hm_chain(chain_head, item->next);
 		if (err < 0)
 			return err;
 	}
 
-	list_del(current);
+	list_del(item);
 
-	kfree(current);
+	kfree(item);
 
 	return err;
 }
@@ -2648,20 +2866,17 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 			(next_hmd < hm_array.num_descriptors)), "next_hmd",
 			-EINVAL);
 
-	err = acquire_new_descriptor(&hm_array, hmd);
-	if (err < 0)
-		return err;
-
 	/* Allocate header manipulation object */
-	hm_array.object[*hmd] = kzalloc(sizeof(struct dpa_cls_hm),
-		GFP_KERNEL);
-	if (!hm_array.object[*hmd]) {
+	hm = kzalloc(sizeof(struct dpa_cls_hm), GFP_KERNEL);
+	if (!hm) {
 		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
 			"ops.\n", __FILE__, __func__, __LINE__);
 		return -ENOMEM;
 	}
 
-	hm = (struct dpa_cls_hm *) hm_array.object[*hmd];
+	err = acquire_descriptor(&hm_array, hm, hmd);
+	if (err < 0)
+		return err;
 
 	INIT_LIST_HEAD(&hm->list_node);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 6108dee..39bb859 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -183,6 +183,8 @@ struct dpa_cls_table {
 
 	/* (Initial) parameters of the DPA Classifier table. */
 	struct dpa_cls_tbl_params		params;
+
+	struct mutex				access;
 };
 
 /* Definition of a generic descriptor table */
@@ -195,6 +197,8 @@ struct dpa_cls_descriptor_table {
 
 	/* Array of descriptors */
 	void		**object;
+
+	struct mutex	*access;
 };
 
 struct dpa_cls_hm_node {
@@ -279,6 +283,19 @@ static int	table_init_exact_match(struct dpa_cls_table *cls_table);
  */
 static int	verify_table_params(const struct dpa_cls_tbl_params *params);
 
+static int	flush_table(struct dpa_cls_table *ptable);
+
+static int	table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
+		int						entry_id,
+		const struct dpa_cls_tbl_entry_mod_params	*mod_params);
+
+static int	table_delete_entry_by_ref(struct dpa_cls_table	*ptable,
+				int				entry_id);
+
+static int	table_get_entry_stats_by_ref(struct dpa_cls_table *ptable,
+				int				entry_id,
+				struct dpa_cls_tbl_entry_stats	*stats);
+
 /*
  * Finds a specified entry in the shadow tables. The entry is
  * identified by its lookup key.
@@ -326,32 +343,27 @@ static int	key_to_entry_id(const struct dpa_cls_table *cls_table,
  */
 static int	handle_to_td(void *cc_node);
 
-/*
- * Extends with one more step an existing descriptor table. The array is
- * reallocated with a constant number of new elements which is defined by the
- * DPA Classifier implementation.
- */
-static int	extend_descriptor_table(struct dpa_cls_descriptor_table
+static inline void lock_desc_table(struct dpa_cls_descriptor_table
 								*desc_table);
 
-/*
- * Gets the first free descriptor in the indicated descriptor table. If there
- * are no available descriptors, the function fails.
- */
-static int	get_new_descriptor(struct dpa_cls_descriptor_table *desc_table,
-								int *desc);
+static inline void release_desc_table(struct dpa_cls_descriptor_table
+								*desc_table);
+
+static void	*desc_to_object(struct dpa_cls_descriptor_table *desc_table,
+								int desc);
 
 /*
- * Gets the first free descriptor in the indicated descriptor table. In case
- * the descriptor table overflows (or it doesn't exist at all), the function
- * will attempt to extend it (or create it).
+ * Gets the first free descriptor in the indicated descriptor table and fills
+ * it with the provided object pointer. In case there are no available
+ * descriptors (or the descriptor table doesn't exist at all), the function
+ * will attempt to extend the descriptor table (or create it).
  */
-static int	acquire_new_descriptor(struct dpa_cls_descriptor_table
-	*desc_table, int *desc);
+static int	acquire_descriptor(struct dpa_cls_descriptor_table
+					*desc_table, void *object, int *desc);
 
 /*
  * Releases a descriptor to a descriptor table. In case the descriptor table
- * is completely empty, the function removes it.
+ * is completely empty, the function removes the descriptor table.
  */
 static inline void put_descriptor(struct dpa_cls_descriptor_table *desc_table,
 								int desc);
@@ -381,11 +393,11 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 
 /* Initializes a chain (list) of low level header manipulation nodes. */
 static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
-						struct list_head *current);
+						struct list_head *item);
 
 /* Removes a chain (list) of low level header manipulation nodes. */
 static int remove_hm_chain(struct list_head	*chain_head,
-			struct list_head	*current);
+			struct list_head	*item);
 
 /*
  * Creates a new classifier header manipulation object and links it to an
-- 
1.7.5.4

