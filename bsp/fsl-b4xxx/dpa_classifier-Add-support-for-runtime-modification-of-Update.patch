From c48a6ea7af6d8da37a873cf151e9316149a228f1 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:11:05 +0000
Subject: [PATCH 5/7] dpa_classifier: Add support for runtime modification of Update type header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  211 +++++++++++++++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    6 -
 2 files changed, 204 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index d7015fe..ca4ae6f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -5613,6 +5613,8 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	int update_ops, replace_ops;
 
 	BUG_ON(!pupdate_hm);
+	BUG_ON(pupdate_hm->num_nodes < 1);
+	BUG_ON(!pupdate_hm->hm_node[0]);
 
 	update_ops = DPA_CLS_HM_UPDATE_IPv4_UPDATE |
 			DPA_CLS_HM_UPDATE_IPv6_UPDATE |
@@ -5624,8 +5626,6 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	hm_node = pupdate_hm->hm_node[0];
 
 	if (pupdate_hm->update_params.op_flags & update_ops) {
-		BUG_ON(!hm_node);
-
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
 		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
@@ -5768,8 +5768,6 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	}
 
 	if (pupdate_hm->update_params.op_flags & replace_ops) {
-		BUG_ON(!hm_node);
-
 		hm_node->params.type		= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.custom	= TRUE;
 		hm_node->params.u.hdr.customParams.type =
@@ -5814,6 +5812,7 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	}
 
 	hm_node = pupdate_hm->hm_node[1];
+
 	if (pupdate_hm->update_params.ip_frag_params.mtu) {
 		/* IP fragmentation option is enabled */
 		BUG_ON(!hm_node);
@@ -5850,9 +5849,207 @@ int dpa_classif_modify_update_hm(int hmd,
 	const struct dpa_cls_hm_update_params *new_update_params,
 	int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
-		__LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pupdate_hm;
+	bool update[2] = { false, false };
+	t_Error error;
+	int ret = 0;
+	int ip_update;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	/* Parameters sanity checks: */
+	if (!new_update_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_update_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	pupdate_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pupdate_hm->type != DPA_CLS_HM_TYPE_UPDATE) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an UPDATE type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	if (modify_flags & DPA_CLS_HM_UPDATE_MOD_IPHDR) {
+		if (pupdate_hm->update_params.op_flags &
+					DPA_CLS_HM_REPLACE_IPv4_BY_IPv6) {
+			memcpy(&pupdate_hm->update_params.replace.new_ipv6_hdr,
+				&new_update_params->replace.new_ipv6_hdr,
+				sizeof(struct ipv6_header));
+		} else if (pupdate_hm->update_params.op_flags &
+					DPA_CLS_HM_REPLACE_IPv6_BY_IPv4) {
+			memcpy(&pupdate_hm->update_params.replace.new_ipv4_hdr.
+				header, &new_update_params->replace.
+				new_ipv4_hdr.header, sizeof(struct iphdr));
+			/* Update IPv4 options */
+			kfree(pupdate_hm->update_params.replace.new_ipv4_hdr.
+				options);
+			if (new_update_params->replace.new_ipv4_hdr.
+					options_size) {
+				pupdate_hm->update_params.replace.new_ipv4_hdr.
+					options = kzalloc(new_update_params->
+					replace.new_ipv4_hdr.options_size,
+					GFP_KERNEL);
+				if (!pupdate_hm->update_params.replace.
+					new_ipv4_hdr.options) {
+					pupdate_hm->update_params.replace.
+						new_ipv4_hdr.options_size = 0;
+					pr_err("ERROR: %s, %s (%d): Out of "
+						"memory while modifying IPv6 "
+						"header replace header "
+						"manipulation hmd=%d.\n",
+						__FILE__, __func__, __LINE__,
+						hmd);
+					return -EINVAL;
+				}
+			} else
+				pupdate_hm->update_params.replace.new_ipv4_hdr.
+					options = NULL;
+			pupdate_hm->update_params.replace.new_ipv4_hdr.
+				options_size = new_update_params->replace.
+				new_ipv4_hdr.options_size;
+		} else {
+			pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't "
+				"work on hmd=%d. It only works on REPLACE "
+				"header manipulations.\n", __FILE__, __func__,
+				__LINE__, modify_flags, hmd);
+			return -EINVAL;
+		}
+		update[0] = true;
+	}
+
+	ip_update = DPA_CLS_HM_UPDATE_IPv4_UPDATE |
+			DPA_CLS_HM_UPDATE_IPv6_UPDATE;
+	if (pupdate_hm->update_params.op_flags & ip_update) {
+		if (modify_flags & DPA_CLS_HM_UPDATE_MOD_SIP) {
+			if (new_update_params->update.l3.ipsa.version !=
+				pupdate_hm->update_params.update.l3.ipsa.
+				version) {
+				pr_err("ERROR: %s, %s (%d): New SIP adress "
+					"version (%d) in UPDATE header "
+					"manipulation hmd=%d cannot be "
+					"different from the old one (%d).\n",
+					__FILE__, __func__, __LINE__,
+					new_update_params->update.l3.ipsa.
+					version, hmd, pupdate_hm->
+					update_params.update.l3.ipsa.version);
+				return -EINVAL;
+			}
+			memcpy(&pupdate_hm->update_params.update.l3.ipsa,
+				&new_update_params->update.l3.ipsa,
+				sizeof(struct dpa_offload_ip_address));
+			update[0] = true;
+		}
+
+		if (modify_flags & DPA_CLS_HM_UPDATE_MOD_DIP) {
+			if (new_update_params->update.l3.ipda.version !=
+				pupdate_hm->update_params.update.l3.ipda.
+				version) {
+				pr_err("ERROR: %s, %s (%d): New DIP adress "
+					"version (%d) in UPDATE header "
+					"manipulation hmd=%d cannot be "
+					"different from the old one (%d).\n",
+					__FILE__, __func__, __LINE__,
+					new_update_params->update.l3.ipda.
+					version, hmd, pupdate_hm->
+					update_params.update.l3.ipda.version);
+				return -EINVAL;
+			}
+			memcpy(&pupdate_hm->update_params.update.l3.ipda,
+				&new_update_params->update.l3.ipda,
+				sizeof(struct dpa_offload_ip_address));
+			update[0] = true;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_TOS_TC) &&
+			(new_update_params->update.l3.tos_tc !=
+				pupdate_hm->update_params.update.l3.tos_tc)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l3.tos_tc =
+					new_update_params->update.l3.tos_tc;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_IP_ID) &&
+			(new_update_params->update.l3.initial_id !=
+			pupdate_hm->update_params.update.l3.initial_id)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l3.initial_id =
+					new_update_params->update.l3.initial_id;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_L3_FLAGS) &&
+			(new_update_params->update.l3.field_flags !=
+			pupdate_hm->update_params.update.l3.field_flags)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l3.field_flags =
+				new_update_params->update.l3.field_flags;
+		}
+	}
+
+	if (pupdate_hm->update_params.op_flags &
+					DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE) {
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_SPORT) &&
+			(new_update_params->update.l4.sport !=
+			pupdate_hm->update_params.update.l4.sport)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l4.sport =
+					new_update_params->update.l4.sport;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_DPORT) &&
+			(new_update_params->update.l4.dport !=
+			pupdate_hm->update_params.update.l4.dport)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l4.dport =
+					new_update_params->update.l4.dport;
+		}
+
+		if ((modify_flags & DPA_CLS_HM_UPDATE_MOD_L4_FLAGS) &&
+			(new_update_params->update.l4.field_flags !=
+			pupdate_hm->update_params.update.l4.field_flags)) {
+			update[0] = true;
+			pupdate_hm->update_params.update.l4.field_flags =
+				new_update_params->update.l4.field_flags;
+		}
+	}
+
+	if (update[0]) {
+		ret = update_hm_update_params(pupdate_hm);
+		if (ret == 0) {
+			hm_node = pupdate_hm->hm_node[0];
+
+			error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&hm_node->params);
+			if (error != E_OK) {
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed - FM_PCD_ManipNodeReplace, "
+					"while trying to modify hmd=%d, manip "
+					"node handle=0x%p.\n", __FILE__,
+					__func__, __LINE__, hmd, hm_node->node);
+				return -EBUSY;
+			}
+		}
+	}
+
+	/* update[1] not supported at this time */
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_update_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 7266898..f7fbc50 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1285,12 +1285,6 @@ static long do_ioctl_modify_update_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d)\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.update_params.fm_pcd = translate_fm_pcd_handle(kparam.
-						update_params.fm_pcd);
-	if (!kparam.update_params.fm_pcd)
-		return -EINVAL;
-
 	return dpa_classif_modify_update_hm(kparam.hmd, &kparam.update_params,
 					   kparam.modify_flags);
 }
-- 
1.7.0.2

