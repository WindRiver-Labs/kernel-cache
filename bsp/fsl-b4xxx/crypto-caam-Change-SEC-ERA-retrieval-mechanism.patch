From d634a9d114cc9cb4d0c7e8724d380da6310f44c3 Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@freescale.com>
Date: Fri, 28 Sep 2012 02:15:26 +0000
Subject: [PATCH 083/518] crypto:caam - Change SEC ERA retrieval mechanism

This patch changes the way SEC ERA is retrieved: instead of
passing the SEC VID register value to the appropriate function,
ERA is retrieved when at SEC driver probe time and stored.
This enables other modules/kernel to retrieve the ERA
by means of the SEC driver device handle.

Signed-off-by: Alex Porosanu <alexandru.porosanu@freescale.com>
Signed-off-by: Mihai Serb <serbmihai@yahoo.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/crypto/caam/ctrl.c   |   79 +++++++++++++++++++++++-------------------
 drivers/crypto/caam/ctrl.h   |    2 +-
 drivers/crypto/caam/intern.h |    3 ++
 3 files changed, 47 insertions(+), 37 deletions(-)

diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 3184902..c535bba 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -159,45 +159,16 @@ static void kick_trng(struct platform_device *pdev)
 
 /**
  * caam_get_era() - Return the ERA of the SEC on SoC, based
- * on the SEC_VID, CCBVID registers.
+ * on the SEC_VID register.
  * Returns the ERA number or -ENOTSUPP if the ERA is unknown.
- * @caam_id - the value of the SEC_VID register
- * @ccbvid - the value of CCBVID register
+ * @pdev - pointer to a platform device
  **/
-int caam_get_era(u64 caam_id, u32 ccb_id)
+int caam_get_era(struct platform_device *pdev)
 {
-	int i;
-	struct ccb_vid *ccb_vid = (struct ccb_vid *)&ccb_id;
-	struct sec_vid *sec_vid = (struct sec_vid *)&caam_id;
-	static const struct {
-		u16 ip_id;
-		u8 maj_rev;
-		u8 era;
-	} caam_eras[] = {
-		{0x0A10, 1, 1},
-		{0x0A10, 2, 2},
-		{0x0A12, 1, 3},
-		{0x0A14, 1, 3},
-		{0x0A14, 2, 4},
-		{0x0A16, 1, 4},
-		{0x0A10, 3, 4},
-		{0x0A11, 1, 4},
-		{0x0A18, 1, 4},
-		{0x0A11, 2, 5},
-		{0x0A12, 2, 5},
-		{0x0A13, 1, 5},
-		{0x0A1C, 1, 5}
-	};
-
-	if (ccb_vid->era)
-		return ccb_vid->era;
-
-	for (i = 0; i < ARRAY_SIZE(caam_eras); i++)
-		if (caam_eras[i].ip_id == sec_vid->ip_id &&
-			caam_eras[i].maj_rev == sec_vid->maj_rev)
-			return caam_eras[i].era;
+	struct device *ctrldev = &pdev->dev;
+	struct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);
 
-	return -ENOTSUPP;
+	return ctrlpriv->era;
 }
 EXPORT_SYMBOL(caam_get_era);
 
@@ -218,11 +189,33 @@ static int caam_probe(struct platform_device *pdev)
 	int ret, ring, rspec;
 	u64 caam_id;
 	u32 ccb_id;
+	u32 era_idx;
 	struct device *dev;
 	struct device_node *nprop, *np;
 	struct caam_ctrl __iomem *ctrl;
 	struct caam_full __iomem *topregs;
 	struct caam_drv_private *ctrlpriv;
+	struct ccb_vid *ccb_vid;
+	struct sec_vid *sec_vid;
+	const struct {
+		u16 ip_id;
+		u8 maj_rev;
+		u8 era;
+	} caam_eras[] = {
+		{0x0A10, 1, 1},
+		{0x0A10, 2, 2},
+		{0x0A12, 1, 3},
+		{0x0A14, 1, 3},
+		{0x0A14, 2, 4},
+		{0x0A16, 1, 4},
+		{0x0A10, 3, 4},
+		{0x0A11, 1, 4},
+		{0x0A18, 1, 4},
+		{0x0A11, 2, 5},
+		{0x0A12, 2, 5},
+		{0x0A13, 1, 5},
+		{0x0A1C, 1, 5}
+	};
 #ifdef CONFIG_DEBUG_FS
 	struct caam_perfmon *perfmon;
 #endif
@@ -338,12 +331,26 @@ static int caam_probe(struct platform_device *pdev)
 	/* Initialize queue allocator lock */
 	spin_lock_init(&ctrlpriv->jr_alloc_lock);
 
+	/* Retrieve & store ERA information */
 	caam_id = rd_reg64(&topregs->ctrl.perfmon.caam_id);
 	ccb_id = rd_reg32(&topregs->ctrl.perfmon.ccb_id);
 
+	sec_vid = (struct sec_vid *)&caam_id;
+	ccb_vid = (struct ccb_vid *)&ccb_id;
+
+	ctrlpriv->era = -ENOTSUPP;
+
+	if (ccb_vid->era)
+		ctrlpriv->era = ccb_vid->era;
+	else
+		for (era_idx = 0; era_idx < ARRAY_SIZE(caam_eras); era_idx++)
+			if (caam_eras[era_idx].ip_id == sec_vid->ip_id &&
+				caam_eras[era_idx].maj_rev == sec_vid->maj_rev)
+				ctrlpriv->era = caam_eras[era_idx].era;
+
 	/* Report "alive" for developer to see */
 	dev_info(dev, "device ID = 0x%016llx (Era %d)\n", caam_id,
-		 caam_get_era(caam_id, ccb_id));
+		 ctrlpriv->era);
 	dev_info(dev, "job rings = %d, qi = %d\n",
 		 ctrlpriv->total_jobrs, ctrlpriv->qi_present);
 
diff --git a/drivers/crypto/caam/ctrl.h b/drivers/crypto/caam/ctrl.h
index 9ceebef..3fdc58f 100644
--- a/drivers/crypto/caam/ctrl.h
+++ b/drivers/crypto/caam/ctrl.h
@@ -8,6 +8,6 @@
 #define CTRL_H
 
 /* Prototypes for backend-level services exposed to APIs */
-int caam_get_era(u64 caam_id, u32 ccb_id);
+int caam_get_era(struct platform_device *pdev);
 
 #endif /* CTRL_H */
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index b220002..34ddd52 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -88,6 +88,9 @@ struct caam_drv_private {
 	u8 qi_present;		/* Nonzero if QI present in device */
 	int secvio_irq;		/* Security violation interrupt number */
 
+	/* SEC ERA */
+	int era;
+
 	/* which jr allocated to scatterlist crypto */
 	atomic_t tfm_count ____cacheline_aligned;
 	/* list of registered crypto algorithms (mk generic context handle?) */
-- 
1.7.5.4

