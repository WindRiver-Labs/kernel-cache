From 6788a113f815282d3f7c6fca5e0d5679b1a0f86d Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 20:02:15 +0000
Subject: [PATCH 299/518] dpa_classifier: Add import feature for insert HM

Implemented the import feature for the insert header manipulation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  223 ++++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   15 +-
 2 files changed, 152 insertions(+), 86 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index e39fd5600..a2121b6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -2630,7 +2630,8 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 	struct dpa_cls_hm *pnext_hm = NULL;
 	struct list_head *chain = NULL;
 	struct dpa_cls_hm_node *hm_node;
-	int i, j;
+	int i;
+	int j = 0;
 
 	if (!num_nodes)
 		/* Nothing to do */
@@ -2652,12 +2653,17 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 		struct dpa_cls_hm *pcurrent;
 
 		/* This HM operation is linked to another HM op */
-		j = 0;
 		for (i = 0; i < num_nodes; i++) {
-			/* If the node is empty, skip to the next */
-			if (!node_array[i])
+			/*
+			 * If the node is empty, save an empty space and skip
+			 * to the next
+			 */
+			if (!node_array[i]) {
+				hm->hm_node[j++] = NULL;
 				continue;
+			}
 
+			/* Check if this node is already in the chain */
 			found = false;
 			list_for_each_entry(hm_node, pnext_hm->hm_chain,
 				list_node) {
@@ -2673,8 +2679,13 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			}
 
 			if (found)
+				/*
+				 * This node already exists in the chain hence
+				 * point to the existing node
+				 */
 				hm->hm_node[j++] = hm_node;
 			else {
+				/* Node does not exist, we need to create it */
 				hm->hm_node[j] = (struct dpa_cls_hm_node *)
 					kzalloc(sizeof(struct dpa_cls_hm_node),
 						GFP_KERNEL);
@@ -2693,9 +2704,7 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 				/* Add this new node to the HM chain: */
 				list_add_tail(&hm->hm_node[j]->list_node,
 						chain);
-				chain = &hm->hm_node[j]->list_node;
-
-				j++;
+				chain = &hm->hm_node[j++]->list_node;
 			}
 		}
 
@@ -2710,12 +2719,16 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			}
 		}
 	} else {
-		j = 0;
 		/* This is an isolated HM operation */
 		for (i = 0; i < num_nodes; i++) {
-			/* If the node is empty, skip to the next */
-			if (!node_array[i])
+			/*
+			 * If the node is empty, save an empty space and skip
+			 * to the next
+			 */
+			if (!node_array[i]) {
+				hm->hm_node[j++] = NULL;
 				continue;
+			}
 
 			hm->hm_node[j] = (struct dpa_cls_hm_node *)
 				kzalloc(sizeof(struct dpa_cls_hm_node),
@@ -2761,18 +2774,16 @@ static int add_local_hm_nodes_to_chain(struct dpa_cls_hm *phm)
 	} else
 		phm->hm_chain = NULL;
 
-	for (i = 0; (i < phm->num_nodes); i++)
+	for (i = 0; i < phm->num_nodes; i++)
 		/*
 		 * If the node exists and it is not already integrated in a HM
 		 * chain...
 		 */
-		if (phm->hm_node[i]) {
-			if (list_empty(&phm->hm_node[i]->list_node)) {
-				if (phm->hm_chain)
-					list_add_tail(&phm->hm_node[i]->
-						list_node, phm->hm_chain);
-			}
-
+		if ((phm->hm_node[i]) &&
+				(list_empty(&phm->hm_node[i]->list_node))) {
+			if (phm->hm_chain)
+				list_add_tail(&phm->hm_node[i]->list_node,
+								phm->hm_chain);
 			phm->hm_chain = &phm->hm_node[i]->list_node;
 		}
 
@@ -2792,7 +2803,9 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 						struct list_head *item)
 {
 	int err = 0;
+	t_Error error;
 	struct dpa_cls_hm_node *pcurrent, *pnext;
+	t_FmPcdManipParams params;
 
 	BUG_ON(!chain_head);
 	BUG_ON(!item);
@@ -2809,10 +2822,32 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	pnext = list_entry(item->next, struct dpa_cls_hm_node, list_node);
 
 	pcurrent->params.h_NextManip = (t_Handle)pnext->node;
-	pcurrent->node = (void *) FM_PCD_ManipNodeSet((t_Handle) fm_pcd,
+	if (!pcurrent->node) {
+		pcurrent->node = (void *) FM_PCD_ManipNodeSet(
+							(t_Handle) fm_pcd,
 							&pcurrent->params);
-	if (!pcurrent->node)
-		err = -EINVAL;
+		if (!pcurrent->node) {
+			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeSet "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			err = -EINVAL;
+		}
+
+		pcurrent->created = true;
+	} else {
+		/* Need to sync with an existing node */
+		memcpy(&params, &pcurrent->params, sizeof(params));
+		params.h_NextManip = NULL;
+		error = FM_PCD_ManipNodeReplace(pcurrent->node, &params);
+		if (error != E_OK) {
+			pr_err("ERROR: %s, %s (%d): FM_PCD_ManipNodeReplace "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			err = -EBUSY;
+		}
+	}
 
 	return err;
 }
@@ -2821,6 +2856,7 @@ int remove_hm_chain(struct list_head *chain_head, struct list_head *item)
 {
 	int err = 0;
 	struct dpa_cls_hm_node *pcurrent;
+	t_Error error;
 
 	BUG_ON(!chain_head);
 	BUG_ON(!item);
@@ -2828,9 +2864,12 @@ int remove_hm_chain(struct list_head *chain_head, struct list_head *item)
 	/* Remove the current node: */
 	pcurrent = list_entry(item, struct dpa_cls_hm_node, list_node);
 
-	if (FM_PCD_ManipNodeDelete((t_Handle) pcurrent->node) != E_OK) {
-		pr_warn("WARNING: Failed to remove low level HM.\n");
-		pr_warn("WARNING: FMan driver call failed.\n");
+	if ((pcurrent->created) && (pcurrent->node)) {
+		error = FM_PCD_ManipNodeDelete((t_Handle) pcurrent->node);
+		if (error != E_OK) {
+			pr_warn("WARNING: Failed to remove low level HM.\n");
+			pr_warn("WARNING: FMan driver call failed.\n");
+		}
 	}
 
 	if (item->next != chain_head) {
@@ -2935,6 +2974,27 @@ static int create_new_hm_op(int *hmd, int next_hmd)
 	return err;
 }
 
+static void remove_hm_op(int hmd)
+{
+	struct dpa_cls_hm *phm;
+
+	BUG_ON((hmd < 0) || (hmd >= hm_array.num_descriptors));
+
+	phm = (struct dpa_cls_hm *) hm_array.object[hmd];
+
+	if (!phm)
+		/* Descriptor already free. Nothing to do */
+		return;
+
+	/* If this op is attached to others, detach it first from the list */
+	if (!list_empty(&phm->list_node))
+		list_del(&phm->list_node);
+
+	put_descriptor(&hm_array, hmd);
+
+	kfree(phm);
+}
+
 int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 			int					next_hmd,
 			int					*hmd,
@@ -3560,12 +3620,6 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	if (res) {
-		pr_err("ERROR: %s, %s (%d): Header manipulation import is not "
-			"yet supported.\n", __FILE__, __func__, __LINE__);
-		return -ENOSYS;
-	}
-
 	err = insert_hm_check_params(insert_params);
 	if (err < 0)
 		return err;
@@ -3583,69 +3637,94 @@ int dpa_classif_set_insert_hm(const struct dpa_cls_hm_insert_params
 	memcpy(&pinsert_hm->insert_params, insert_params,
 						sizeof(*insert_params));
 
-	if (res)
-		err = import_insert_hm(pinsert_hm, res);
-	else {
-		err = init_insert_hm(pinsert_hm);
-		if (err) {
-			dpa_classif_free_hm(*hmd);
-			*hmd = DPA_OFFLD_DESC_NONE;
-			return err;
-		}
-
-		if (chain_head)
-			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pinsert_hm->insert_params.fm_pcd,
-				pinsert_hm->hm_chain, pinsert_hm->hm_chain);
+	err = insert_hm_prepare_nodes(pinsert_hm, res);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to acquire necessary HM "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		goto insert_hm_error;
 	}
 
-	if (err) {
-		dpa_classif_free_hm(*hmd);
-		*hmd = DPA_OFFLD_DESC_NONE;
+	err = insert_hm_update_params(pinsert_hm);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to update low level header "
+			"manipulation parameters.\n", __FILE__, __func__,
+			__LINE__);
+		goto insert_hm_error;
 	}
 
+	if (chain_head)
+		err = init_hm_chain(pinsert_hm->insert_params.fm_pcd,
+				pinsert_hm->hm_chain,
+				pinsert_hm->hm_chain);
+
+	return err;
+
+insert_hm_error:
+
+	remove_hm_op(*hmd);
+
+	*hmd = DPA_OFFLD_DESC_NONE;
+
 	return err;
 }
 EXPORT_SYMBOL(dpa_classif_set_insert_hm);
 
-static int import_insert_hm(struct dpa_cls_hm *pinsert_hm,
+static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 				const struct dpa_cls_hm_insert_resources *res)
 {
+	struct dpa_cls_hm_node *hm_node;
 	void * const *phm_nodes;
-	int err;
+	int err = 0;
 
 	BUG_ON(!pinsert_hm);
-	BUG_ON(!res);
 
-	phm_nodes = &res->insert_node;
+	pinsert_hm->num_nodes = 1;
 
-	err = import_hm_nodes_to_chain(phm_nodes, 1, pinsert_hm);
+	if (res) { /* Import HM nodes */
+		phm_nodes = &res->insert_node;
 
-	/* Update here the hm nodes parameters */
+		err = import_hm_nodes_to_chain(phm_nodes,
+					pinsert_hm->num_nodes,
+					pinsert_hm);
+	} else { /* Create HM nodes */
+		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+		if (!hm_node) {
+			pr_err("ERROR: %s, %s (%d): Not enough memory for "
+				"header manip nodes.\n", __FILE__, __func__,
+				__LINE__);
+			return -ENOMEM;
+		}
+
+		INIT_LIST_HEAD(&hm_node->list_node);
+		pinsert_hm->hm_node[0]	= hm_node;
+
+		add_local_hm_nodes_to_chain(pinsert_hm);
+	}
 
 	return err;
 }
 
-static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
+static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 {
-	struct dpa_cls_hm_node *hm_node = NULL;
-	unsigned int size;
+	unsigned int size = 0;
 	uint8_t offset = 0;
-	uint8_t *pdata;
+	uint8_t *pdata = NULL;
+	struct dpa_cls_hm_node *hm_node;
 
 	BUG_ON(!pinsert_hm);
 
-	/* Create a header insert node: */
-	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-	if (!hm_node) {
-		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
-			"nodes.\n", __FILE__, __func__, __LINE__);
-		return -ENOMEM;
+	if ((pinsert_hm->num_nodes < 1) || (!pinsert_hm->hm_node[0])) {
+		pr_err("ERROR: %s, %s (%d): Inconsistency between resources "
+			"and provided parameters.\n", __FILE__, __func__,
+			__LINE__);
+		return -EINVAL;
 	}
+	hm_node = pinsert_hm->hm_node[0];
 
 	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 	hm_node->params.u.hdr.insrt		= TRUE;
 	hm_node->params.u.hdr.insrtParams.type	= e_FM_PCD_MANIP_INSRT_GENERIC;
+	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 	switch (pinsert_hm->insert_params.type) {
 	case DPA_CLS_HM_INSERT_ETHERNET:
@@ -3656,7 +3735,6 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 		if (!pdata) {
 			pr_err("ERROR: %s, %s (%d): Not enough memory for "
 				"insert HM.\n", __FILE__, __func__, __LINE__);
-			kfree(hm_node);
 			return -ENOMEM;
 		}
 
@@ -3678,12 +3756,12 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 			memcpy(&pdata[offset],
 		&pinsert_hm->insert_params.eth.eth_header.h_proto,
 				ETHERTYPE_SIZE);
+			offset = 0;
 		} else
+			/* Copy the entire Ethernet header */
 			memcpy(pdata,
 				&pinsert_hm->insert_params.eth.eth_header,
 				sizeof(struct ethhdr));
-
-		offset = 0;
 		break;
 	case DPA_CLS_HM_INSERT_PPP:
 		size	= PPP_HEADER_SIZE;
@@ -3691,10 +3769,10 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 		if (!pdata) {
 			pr_err("ERROR: %s, %s (%d): Not enough memory for "
 				"insert HM.\n", __FILE__, __func__, __LINE__);
-			kfree(hm_node);
 			return -ENOMEM;
 		}
 
+		/* Copy the PPP PID */
 		memcpy(pdata, &pinsert_hm->insert_params.ppp_pid,
 			PPP_HEADER_SIZE);
 		break;
@@ -3704,9 +3782,8 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 		offset	= pinsert_hm->insert_params.custom.offset;
 		break;
 	default:
-		/* Will never get here */
-		kfree(hm_node);
-		return -EINVAL;
+		/* Should never get here */
+		BUG_ON(false);
 	}
 
 	hm_node->params.u.hdr.insrtParams.u.generic.offset	= offset;
@@ -3714,12 +3791,6 @@ static int init_insert_hm(struct dpa_cls_hm *pinsert_hm)
 	hm_node->params.u.hdr.insrtParams.u.generic.p_Data	= pdata;
 	hm_node->params.u.hdr.insrtParams.u.generic.replace	= FALSE;
 
-	INIT_LIST_HEAD(&hm_node->list_node);
-	pinsert_hm->hm_node[0]	= hm_node;
-	pinsert_hm->num_nodes	= 1;
-
-	add_local_hm_nodes_to_chain(pinsert_hm);
-
 	return 0;
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index b1bb7b5..2db5ed1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -203,6 +203,7 @@ struct dpa_cls_descriptor_table {
 
 struct dpa_cls_hm_node {
 	void			*node;
+	bool			created;
 	t_FmPcdManipParams	params;
 	struct list_head	list_node;
 };
@@ -405,6 +406,8 @@ static int remove_hm_chain(struct list_head	*chain_head,
  */
 static int create_new_hm_op(int *hmd, int next_hmd);
 
+static void remove_hm_op(int hmd);
+
 /*
  * Verifies that the parameters provided for a NAT type header manipulation op
  * are correct.
@@ -470,18 +473,10 @@ static int init_remove_hm(struct dpa_cls_hm *premove_hm);
 static int insert_hm_check_params(const struct dpa_cls_hm_insert_params
 	*insert_params);
 
-/*
- * Imports the low level header manipulation nodes for a header insert
- * classifier header manipulation op.
- */
-static int import_insert_hm(struct dpa_cls_hm *pinsert_hm,
+static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 				const struct dpa_cls_hm_insert_resources *res);
 
-/*
- * Creates the low level header manipulation nodes for a header insert
- * classifier header manipulation op.
- */
-static int init_insert_hm(struct dpa_cls_hm *pinsert_hm);
+static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm);
 
 /*
  * Verifies that the parameters provided for a header update header
-- 
1.7.5.4

