From 5975f1b9b324168e0f6fa993534d6f31730e5f73 Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Mon, 29 Oct 2012 22:54:47 +0000
Subject: [PATCH 355/518] offload_use_case: Free the IPSEC resources when
 exiting the usecase

IPSEC instance is freed when exiting the usecase (inbound and outbound
SAs are removed). Also when sending a flush command for the policies
(for example with setkey tool) they are removed.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |    7 +++
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   53 +++++++++++++-------
 2 files changed, 41 insertions(+), 19 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index 0fde9d6..d4648f9 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -623,6 +623,13 @@ int cleanup_ipsec_offload(int dpa_ipsec_id)
 	if (!ipsec_initialized)
 		return 0;
 
+	ret = dpa_ipsec_free(dpa_ipsec_id);
+	if (ret < 0) {
+		pr_err("%s:%d: error freeing dpa ipsec instance %d\n",
+			__func__, __LINE__, dpa_ipsec_id);
+		return ret;
+	}
+
 	if (fm_params.ip4_num_keys > 0) {
 		key.size = IPv4_KEY_SIZE;
 		for (i = 0; i < fm_params.ip4_num_keys; i++) {
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 9b1c66e..e78e5a9 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -267,10 +267,6 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 	uint8_t	key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	int tbl_desc = DPA_OFFLD_DESC_NONE;
 
-	/* Only ESP supported */
-	if (!(x && (x->id.proto == IPPROTO_ESP)))
-		return 0;
-
 	switch (c->event) {
 	case XFRM_MSG_EXPIRE:
 		pr_info("%s: XFRM_MSG_EXPIRE event, SPI %x\n",
@@ -341,23 +337,26 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 		pr_info("%s: XFRM_MSG_UPDSA event, SPI %x\n",
 			__func__, x->id.spi);
 	case XFRM_MSG_NEWSA:
-		if (c->event == XFRM_MSG_NEWSA)
-			pr_info("%s: XFRM_MSG_NEWSA event, SPI %x\n",
-				__func__, x->id.spi);
-		work = kzalloc(sizeof(*work), GFP_KERNEL);
-		if (!work) {
-			pr_err("%s: Cannot allocate offld work\n", __func__);
-			return -ENOMEM;
+		/* Only ESP supported */
+		if (x->id.proto == IPPROTO_ESP) {
+			if (c->event == XFRM_MSG_NEWSA)
+				pr_info("%s: XFRM_MSG_NEWSA event, SPI %x\n",
+					__func__, x->id.spi);
+			work = kzalloc(sizeof(*work), GFP_KERNEL);
+			if (!work) {
+				pr_err("%s: Cannot allocate offld work\n",
+					__func__);
+				return -ENOMEM;
+			}
+			work->x = x;
+			INIT_DELAYED_WORK(&work->work, work_func);
+			schedule_delayed_work_on(offld_work_cpu, &work->work,
+						HZ);
 		}
-		work->x = x;
-		INIT_DELAYED_WORK(&work->work, work_func);
-		schedule_delayed_work_on(offld_work_cpu, &work->work,
-					HZ);
 		break;
 
 	case XFRM_MSG_FLUSHSA:
 		pr_info("%s: XFRM_MSG_FLUSHSA event\n", __func__);
-		dbgfs_cleanup();
 		key.byte = key_data;
 		key.mask = NULL;
 		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
@@ -403,6 +402,7 @@ remove_sa:
 					 __func__, __LINE__, ret);
 				}
 				hlist_del(&psa->h);
+				dbgfs_remove_entry(psa->sa_id);
 				kfree(psa);
 			}
 		}
@@ -734,9 +734,12 @@ no_offload:
 static int xfrm_km_policy_notify(struct xfrm_policy *x, int dir,
 				 const struct km_event *c)
 {
-	int ret = 0;
+	int ret = 0, sa_id;
 	struct xfrm_state *state;
 	struct work_arg *work;
+	unsigned int hash_val;
+	struct hlist_node *entry, *n;
+	struct sa *psa;
 
 	switch (c->event) {
 	case XFRM_MSG_UPDPOLICY:
@@ -785,8 +788,20 @@ static int xfrm_km_policy_notify(struct xfrm_policy *x, int dir,
 			__func__, x->index);
 		break;
 	case XFRM_MSG_FLUSHPOLICY:
-		pr_info("%s: XFRM_MSG_FLUSHPOLICY event, policy index %d\n",
-			__func__, x->index);
+		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
+			hlist_for_each_entry_safe(psa, entry, n,
+						sa_htable + hash_val, h) {
+				sa_id = psa->sa_id;
+				pr_info("%s: XFRM_MSG_FLUSHPOLICY. "
+					"Flushing policies for sa %d\n",
+					__func__, sa_id);
+				ret = dpa_ipsec_sa_flush_policies(sa_id);
+				if (ret < 0)
+					pr_err("%s(%d): Could not flush "
+						"policies for sa %d\n",
+						__func__, __LINE__, sa_id);
+			}
+		}
 		break;
 	}
 
-- 
1.7.5.4

