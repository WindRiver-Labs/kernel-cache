From 89a28441d54cf946815281d27134e2e670d35938 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:07 +0000
Subject: [PATCH 229/518] Extend number of SA lookup tables

Add support in the API for using more than one table for SA lookup
and thus enable better MURAM management.

The changes allow configuring a table for each type of supported SA
(IPv4, IPv4 with NAT-T support, IPv6) and thus eliminate the need
to pad some of the SA keys in order to have the same size for all
keys.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   61 ++++++++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    6 +++
 include/linux/fsl_dpa_ipsec.h               |   10 ++++-
 3 files changed, 57 insertions(+), 20 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index d56855c..28e0ec8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -217,6 +217,7 @@ static inline void store_ipsec_params(struct dpa_ipsec *dpa_ipsec,
 static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 {
 	const struct dpa_ipsec_pre_sec_out_params *pre_sec_out_prms;
+	const struct dpa_ipsec_pre_sec_in_params *pre_sec_in_prms;
 	struct dpa_cls_tbl_params table_params;
 	int i, err, valid_tables = 0;
 
@@ -290,22 +291,28 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
-	/* pre decryption SA lookup table */
-	if (prms->pre_sec_in_params.dpa_cls_td < 0) {
-		pr_err("Specify a valid table for SA lookup\n");
-		return -EINVAL;
-	}
-
-	/* verify that it is not an indexed table */
-	err = dpa_classif_table_get_params(prms->pre_sec_in_params.dpa_cls_td,
-					   &table_params);
-	if (err < 0) {
-		pr_err("Could not check type of pre decryption table\n");
-		return -EINVAL;
-	}
+	/* check pre decryption SA lookup tables */
+	valid_tables = 0;
+	pre_sec_in_prms = &prms->pre_sec_in_params;
+	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
+		if (pre_sec_in_prms->dpa_cls_td[i] != DPA_OFFLD_DESC_NONE) {
+			/* verify that it is not an indexed table */
+			err = dpa_classif_table_get_params(
+						pre_sec_in_prms->dpa_cls_td[i],
+						&table_params);
+			if (err < 0) {
+				pr_err("Couldn't check type of SA table\n");
+				return -EINVAL;
+			}
 
-	if (table_params.type == DPA_CLS_TBL_INDEXED) {
-		pr_err("Pre decryption table mustn't be of type index\n");
+			if (table_params.type == DPA_CLS_TBL_INDEXED) {
+				pr_err("SA tables mustn't be of type index\n");
+				return -EINVAL;
+			}
+			valid_tables++;
+		}
+	if (!valid_tables) {
+		pr_err("Specify at least one valid table for SA lookup\n");
 		return -EINVAL;
 	}
 
@@ -690,6 +697,9 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		 * inbound or outbound policy parameters which were use to
 		 * generate PCD entries */
 		INIT_LIST_HEAD(&sa[i].policy_headlist);
+
+		/* init the inbound SA lookup table desc with an invalid value*/
+		sa[i].inbound_sa_td = DPA_OFFLD_DESC_NONE;
 	}
 
 	err = create_inbound_flowid_cq(dpa_ipsec);
@@ -1349,7 +1359,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 					enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	int table, entry_id, offset, err = 0, tbl_key_size = 0, i;
+	int table, table_idx, entry_id, offset, err = 0, tbl_key_size = 0, i;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
@@ -1360,10 +1370,21 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 	dpa_ipsec = sa->dpa_ipsec;
 	BUG_ON(!dpa_ipsec);
-	table = dpa_ipsec->config.pre_sec_in_params.dpa_cls_td;
 
 	switch (op_type) {
 	case MNG_OP_ADD:
+		/* Determine the correct table to be used for this type of SA */
+		table_idx = GET_SA_TABLE_IDX(sa->dest_addr, sa->use_udp_encap);
+		table =
+		      dpa_ipsec->config.pre_sec_in_params.dpa_cls_td[table_idx];
+		if (table == DPA_OFFLD_DESC_NONE) {
+			pr_err("No SA table defined for this type of SA\n");
+			return -EBADF;
+		}
+
+		/* Store the table descriptor to be used in subsequent ops */
+		sa->inbound_sa_td = table;
+
 		/*Mark classifier entry id as invalid until it's properly
 		 * inserted*/
 		sa->inbound_hash_entry = -1;
@@ -1441,7 +1462,8 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 	case MNG_OP_REMOVE:
 		entry_id = sa->inbound_hash_entry;
-		err = dpa_classif_table_delete_entry_by_ref(table, entry_id);
+		err = dpa_classif_table_delete_entry_by_ref(sa->inbound_sa_td,
+							    entry_id);
 		if (err < 0) {
 			pr_err("Could not remove key for inbound SA!\n");
 			return err;
@@ -1458,7 +1480,8 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		mod_params.action = &action;
 
 		entry_id = sa->inbound_hash_entry;
-		err = dpa_classif_table_modify_entry_by_ref(table, entry_id,
+		err = dpa_classif_table_modify_entry_by_ref(sa->inbound_sa_td,
+							    entry_id,
 							    &mod_params);
 		if (err < 0) {
 			pr_err("Failed set drop action for inbound SA %d\n",
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 065fba9..eb3499e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -162,6 +162,10 @@
 		(_tbl_params.type == DPA_CLS_TBL_EXACT_MATCH) ?	\
 			 tbl_params.exact_match_params.key_size : 0)
 
+#define GET_SA_TABLE_IDX(_dest_addr, _use_udp_encap) \
+	(!IP_ADDR_TYPE_IPV4(_dest_addr) ? DPA_IPSEC_SA_IPV6 :  \
+	 _use_udp_encap ? DPA_IPSEC_SA_IPV4_NATT :  DPA_IPSEC_SA_IPV4)
+
 #define SEQ_NUM_HI_MASK		0xFFFFFFFF00000000
 #define SEQ_NUM_LOW_MASK	0x00000000FFFFFFFF
 
@@ -252,6 +256,8 @@ struct dpa_ipsec_sa {
 				   with inbound_flowid			      */
 	int inbound_hash_entry;	/* Entry in the hash table
 				   corresponding to SPI extended key	      */
+	int inbound_sa_td; /* Descriptor for the SA lookup table in which this
+			    * SA's key will be placed */
 	struct dpa_cls_tbl_action def_sa_action;
 	struct list_head policy_headlist; /* Head of the policy param list
 			 used to store all the in/out policy parameters in order
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 870e2bd..66ad985 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -114,6 +114,14 @@ enum dpa_ipsec_proto {
 	DPA_IPSEC_MAX_SUPPORTED_PROTOS
 };
 
+/* DPA IPSec supported types of SAs */
+enum dpa_ipsec_sa_type {
+	DPA_IPSEC_SA_IPV4 = 0,
+	DPA_IPSEC_SA_IPV4_NATT,
+	DPA_IPSEC_SA_IPV6,
+	DPA_IPSEC_MAX_SA_TYPE
+};
+
 /*
  * DPA-IPSec Post SEC Data Offsets. 1 BURST = 32 or 64 bytes
  * depending on SEC configuration. Default BURST size = 64 bytes
@@ -134,7 +142,7 @@ struct dpa_ipsec_pol_table {
 
 /* DPA-IPSec Pre-Sec Inbound Parameters */
 struct dpa_ipsec_pre_sec_in_params {
-	int dpa_cls_td;		/* SA lookup table descriptor		      */
+	int dpa_cls_td[DPA_IPSEC_MAX_SA_TYPE]; /* SA lookup tables descriptors*/
 };
 
 /* DPA-IPSec Pre-Sec Outbound Parameters */
-- 
1.7.5.4

