From 86fceb4012c500eeeef60acddbd3e534c392cb8d Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 18:05:03 +0000
Subject: [PATCH 289/518] dpa_classifier: Fix allocation problem for custom
 parameter received from userspace

When receiving a pointer - for custom parameters for hm insert operation -
from userspace through ioctl, memory must be allocated
in kernel.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   35 +++++++++++++++++++-
 1 files changed, 34 insertions(+), 1 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 68dbf5c..6c72c4e 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -754,6 +754,8 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	long ret = 0;
 	struct ioc_dpa_cls_hm_insert_params kparam;
 	struct dpa_cls_hm_insert_resources *p_res = NULL;
+	uint8_t *data = NULL;
+	uint8_t sz;
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_hm_insert_params uparam;
 	if (compat_mode) {
@@ -786,6 +788,21 @@ static long do_ioctl_set_insert_hm(unsigned long args, bool compat_mode)
 	if (kparam.res.insert_node)
 		p_res = &kparam.res;
 
+	if (kparam.ins_params.type == DPA_CLS_HM_INSERT_CUSTOM) {
+		sz = kparam.ins_params.custom.size;
+		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
+		if (!data) {
+			pr_err("ERROR: %s, %s (%d): Could not allocate memory "
+				"for  data param  for DPA_CLS_HM_INSERT_CUSTOM"
+				" parameter type.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
+		}
+
+		copy_from_user(data, kparam.ins_params.custom.data, sz);
+		kparam.ins_params.custom.data = data;
+	}
+
 	ret = dpa_classif_set_insert_hm(&kparam.ins_params, kparam.next_hmd,
 					&kparam.hmd, kparam.chain_head,
 					p_res);
@@ -819,6 +836,8 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 {
 	long ret = 0;
 	struct ioc_dpa_cls_hm_insert_params kparam;
+	uint8_t *data = NULL;
+	uint8_t sz;
 #ifdef CONFIG_COMPAT
 	struct compat_ioc_dpa_cls_hm_insert_params uparam;
 	if (compat_mode) {
@@ -849,10 +868,24 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 	if (!kparam.ins_params.fm_pcd)
 		return -EINVAL;
 
+	if (kparam.ins_params.type == DPA_CLS_HM_INSERT_CUSTOM) {
+		sz = kparam.ins_params.custom.size;
+		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
+		if (!data) {
+			pr_err("ERROR: %s, %s (%d): Could not allocate memory "
+				"for data param for DPA_CLS_HM_INSERT_CUSTOM "
+				"parameter type.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
+		}
+
+		copy_from_user(data, kparam.ins_params.custom.data, sz);
+		kparam.ins_params.custom.data = data;
+	}
+
 	ret = dpa_classif_modify_insert_hm(kparam.hmd, &kparam.ins_params,
 					   kparam.modify_flags);
 
-
 	return ret;
 }
 
-- 
1.7.5.4

