From cdbcfbe5ef40e4596cf93d916602abbddb89aaee Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 1 Mar 2012 16:35:16 +0000
Subject: [PATCH 100/518] General code optimization and cleanup in
 fsl_dpa_offload/dpa_ipsec.c

- Replaced pr_info with corresponding macro used in dpa_offload code
- Synchronized error code generation across all internal and external
functions in dpa_ipsec.c
- Added support for freeing fragmentation header manipulation
- Fixed size of outbound flowid in dpa_ipsec_sa structure
- Cosmetics: coding style, created symetrical functions for create /
destroy

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c | 1480 +++++++++++++++++----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   11 +-
 2 files changed, 933 insertions(+), 558 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 2219f9f..536ab96 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -37,17 +37,10 @@
 #include "dpa_ipsec_desc.h"
 
 /* DPA IPsec Mapping between API DF bit action and FM PCD DF bit action */
-e_FmPcdManipDontFragAction	pcd_df_action[] = {
-	/* DPA_IPSEC_DF_ACTION_DISCARD */
-	e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET,
-	/* DPA_IPSEC_DF_ACTION_OVERRIDE */
-	e_FM_PCD_MANIP_FRAGMENT_PACKECT,
-	/* DPA_IPSEC_DF_ACTION_CONTINUE */
-	e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG
-};
+e_FmPcdManipDontFragAction pcd_df_action[] = PCD_DF_ACTION;
 
 /* DPA IPsec Mapping between API algorithm suites and SEC algorithm IDs */
-struct ipsec_alg_suite	ipsec_algs[] = IPSEC_ALGS;
+struct ipsec_alg_suite ipsec_algs[] = IPSEC_ALGS;
 
 /* globally allocated because of performance constraints */
 static t_FmPcdCcNodeParams cc_node_prms;
@@ -65,105 +58,112 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
 
-	if (!sa)
-		xx_pr_err(("Invalid input: null SA handle\n"));
+	if (!sa) {
+		xx_pr_err(("Invalid argument: null SA handle\n"));
+		return -EFAULT;
+	}
 
-	pr_info("\n Printing SA SEC PARAM for sa %p\n", sa);
-	pr_info("\n sa_dir = %d\n", sa->sa_dir);
-	pr_info("\n id = %d\n", sa->id);
-	pr_info(" dpa_ipsec addr = %p\n", sa->dpa_ipsec);
-	pr_info(" from_sec_fq addr = %p\n", sa->from_sec_fq);
+	xx_pr_info(("\n Printing SA SEC PARAM for sa %p\n", sa));
+	xx_pr_info(("\n sa_dir = %d\n", sa->sa_dir));
+	xx_pr_info(("\n id = %d\n", sa->id));
+	xx_pr_info((" dpa_ipsec addr = %p\n", sa->dpa_ipsec));
+	xx_pr_info((" from_sec_fq addr = %p\n", sa->from_sec_fq));
 
-	pr_info("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type);
-	pr_info("auth_data.auth_key_len = %d\n", sa->auth_data.auth_key_len);
-	pr_info("auth_data.auth_key is\n");
+	xx_pr_info(("\n auth_data.auth_type = %d\n", sa->auth_data.auth_type));
+	xx_pr_info(("auth_data.auth_key_len = %d\n",
+		sa->auth_data.auth_key_len));
+	xx_pr_info(("auth_data.auth_key is\n"));
 	for (i = 0; i < sa->auth_data.auth_key_len; i++)
-		pr_info(("%x, ", sa->auth_data.auth_key[i]));
+		xx_pr_info((("%x, ", sa->auth_data.auth_key[i])));
 
-	pr_info("\n cipher_data.cipher_type = %d\n",
-		sa->cipher_data.cipher_type);
-	pr_info("cipher_data.cipher_key_len = %d\n",
-		sa->cipher_data.cipher_key_len);
-	pr_info("cipher_data.cipher_key is\n");
+	xx_pr_info(("\n cipher_data.cipher_type = %d\n",
+		sa->cipher_data.cipher_type));
+	xx_pr_info(("cipher_data.cipher_key_len = %d\n",
+		sa->cipher_data.cipher_key_len));
+	xx_pr_info(("cipher_data.cipher_key is\n"));
 	for (i = 0; i < sa->cipher_data.cipher_key_len; i++)
-		pr_info(("%x, ", sa->cipher_data.cipher_key[i]));
+		xx_pr_info((("%x, ", sa->cipher_data.cipher_key[i])));
 
-	pr_info("\n sa_bpid = %d\n", sa->sa_bpid);
-	pr_info(" spi = %d\n", sa->spi);
-	pr_info(" sa_wqid = %d\n", sa->sa_wqid);
-	pr_info(" out_flow_id = %d\n", sa->out_flow_id);
+	xx_pr_info(("\n sa_bpid = %d\n", sa->sa_bpid));
+	xx_pr_info((" spi = %d\n", sa->spi));
+	xx_pr_info((" sa_wqid = %d\n", sa->sa_wqid));
+	xx_pr_info((" outbound_flowid = %d\n", sa->outbound_flowid));
 
-	pr_info("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type);
-	pr_info("dest_addr = %x.%x.%x.%x\n",
+	xx_pr_info(("dest_addr.addr_type = %d\n", sa->dest_addr.addr_type));
+	xx_pr_info(("dest_addr = %x.%x.%x.%x\n",
 		sa->dest_addr.ipv4.byte[0],
 		sa->dest_addr.ipv4.byte[1],
-		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]);
-	pr_info("src_addr.addr_type = %d\n", sa->src_addr.addr_type);
-	pr_info("src_addr = %x.%x.%x.%x\n",
+		sa->dest_addr.ipv4.byte[2], sa->dest_addr.ipv4.byte[3]));
+	xx_pr_info(("src_addr.addr_type = %d\n", sa->src_addr.addr_type));
+	xx_pr_info(("src_addr = %x.%x.%x.%x\n",
 		sa->src_addr.ipv4.byte[0],
 		sa->src_addr.ipv4.byte[1],
-		sa->src_addr.ipv4.byte[2], sa->src_addr.ipv4.byte[3]);
+		sa->src_addr.ipv4.byte[2], sa->src_addr.ipv4.byte[3]));
 
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		uint8_t *out_hdr;
 		out_hdr = &sa->sec_desc->pdb_en.ip_hdr[0];
-		pr_info("Outer Header length  %d\n",
-			sa->sec_desc->pdb_en.ip_hdr_len);
-		pr_info("Outer Header is:\n");
+		xx_pr_info(("Outer Header length  %d\n",
+			sa->sec_desc->pdb_en.ip_hdr_len));
+		xx_pr_info(("Outer Header is:\n"));
 		for (i = 0; i < sa->sec_desc->pdb_en.ip_hdr_len; i++)
-			pr_info("%x, ", *(out_hdr + i));
-
-		pr_info("pdb_en.ip_hdr_len %d\n",
-			sa->sec_desc->pdb_en.ip_hdr_len);
-		pr_info("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi);
-		pr_info("pdb_en.seq_num = %d\n", sa->sec_desc->pdb_en.seq_num);
-		pr_info("pdb_en.options = 0x%x\n",
-			sa->sec_desc->pdb_en.options);
-		pr_info("pdb_en.desc_hdr = 0x%x\n",
-			sa->sec_desc->pdb_en.desc_hdr);
-		pr_info("pdb_en.ip_nh = 0x%x\n", sa->sec_desc->pdb_en.ip_nh);
+			xx_pr_info(("%x, ", *(out_hdr + i)));
+
+		xx_pr_info(("pdb_en.ip_hdr_len %d\n",
+			sa->sec_desc->pdb_en.ip_hdr_len));
+		xx_pr_info(("pdb_en.spi = %d\n", sa->sec_desc->pdb_en.spi));
+		xx_pr_info(("pdb_en.seq_num = %d\n",
+			sa->sec_desc->pdb_en.seq_num));
+		xx_pr_info(("pdb_en.options = 0x%x\n",
+			sa->sec_desc->pdb_en.options));
+		xx_pr_info(("pdb_en.desc_hdr = 0x%x\n",
+			sa->sec_desc->pdb_en.desc_hdr));
+		xx_pr_info(("pdb_en.ip_nh = 0x%x\n",
+			sa->sec_desc->pdb_en.ip_nh));
 	} else {
-		pr_info("pdb_dec.hmo_ip_hdr_len %d\n",
-			sa->sec_desc->pdb_dec.hmo_ip_hdr_len);
-		pr_info("pdb_dec.options %d\n", sa->sec_desc->pdb_dec.options);
-		pr_info("pdb_dec.seq_num %d\n", sa->sec_desc->pdb_dec.seq_num);
+		xx_pr_info(("pdb_dec.hmo_ip_hdr_len %d\n",
+			sa->sec_desc->pdb_dec.hmo_ip_hdr_len));
+		xx_pr_info(("pdb_dec.options %d\n",
+			sa->sec_desc->pdb_dec.options));
+		xx_pr_info(("pdb_dec.seq_num %d\n",
+			sa->sec_desc->pdb_dec.seq_num));
 	}
 
-	pr_info("\n Printing all policies from this SA policy_list\n");
+	xx_pr_info(("\n Printing all policies from this SA policy_list\n"));
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
 		policy_selectors = &policy_entry->policy_selectors;
-		pr_info("policy_selectors src_addr.addr_type = %d\n",
-			policy_selectors->src_addr.addr_type);
-		pr_info("policy_selectors src_addr = %x.%x.%x.%x\n",
+		xx_pr_info(("policy_selectors src_addr.addr_type = %d\n",
+			policy_selectors->src_addr.addr_type));
+		xx_pr_info(("policy_selectors src_addr = %x.%x.%x.%x\n",
 			policy_selectors->src_addr.ipv4.byte[0],
 			policy_selectors->src_addr.ipv4.byte[1],
 			policy_selectors->src_addr.ipv4.byte[2],
-			policy_selectors->src_addr.ipv4.byte[3]);
-		pr_info("\n policy_selectors dest_addr.addr_type = %d\n",
-			policy_selectors->dest_addr.addr_type);
-		pr_info("policy_selectors dest_addr = %x.%x.%x.%x\n",
+			policy_selectors->src_addr.ipv4.byte[3]));
+		xx_pr_info(("\n policy_selectors dest_addr.addr_type = %d\n",
+			policy_selectors->dest_addr.addr_type));
+		xx_pr_info(("policy_selectors dest_addr = %x.%x.%x.%x\n",
 			policy_selectors->dest_addr.ipv4.byte[0],
 			policy_selectors->dest_addr.ipv4.byte[1],
 			policy_selectors->dest_addr.ipv4.byte[2],
-			policy_selectors->dest_addr.ipv4.byte[3]);
-
-		pr_info("\n policy_selectors dest_port = %d\n",
-			policy_selectors->dest_port);
-		pr_info(" policy_selectors src_port = %d\n",
-			policy_selectors->src_port);
-		pr_info(" policy_selectors dest_port = %d\n",
-			policy_selectors->dest_port_mask);
-		pr_info(" policy_selectors dest_port = %d\n",
-			policy_selectors->src_port_mask);
-		pr_info(" policy_selectors proto = %d\n",
-			policy_selectors->protocol);
-		pr_info(" policy_selectors dest_prefix_len = %d\n",
-			policy_selectors->dest_prefix_len);
-		pr_info(" policy_selectors src_prefix_len = %d\n",
-			policy_selectors->src_prefix_len);
-	}
-	pr_info("\n Done printing SA SEC PARAM for sa %p\n", sa);
+			policy_selectors->dest_addr.ipv4.byte[3]));
+
+		xx_pr_info(("\n policy_selectors dest_port = %d\n",
+			policy_selectors->dest_port));
+		xx_pr_info((" policy_selectors src_port = %d\n",
+			policy_selectors->src_port));
+		xx_pr_info((" policy_selectors dest_port = %d\n",
+			policy_selectors->dest_port_mask));
+		xx_pr_info((" policy_selectors dest_port = %d\n",
+			policy_selectors->src_port_mask));
+		xx_pr_info((" policy_selectors proto = %d\n",
+			policy_selectors->protocol));
+		xx_pr_info((" policy_selectors dest_prefix_len = %d\n",
+			policy_selectors->dest_prefix_len));
+		xx_pr_info((" policy_selectors src_prefix_len = %d\n",
+			policy_selectors->src_prefix_len));
+	}
+	xx_pr_info(("\n Done printing SA SEC PARAM for sa %p\n", sa));
 
 	return 0;
 }
@@ -175,9 +175,6 @@ int print_sa_sec_param(struct dpa_ipsec_sa *sa)
 static inline void store_ipsec_params(struct dpa_ipsec *dpa_ipsec,
 				      const struct dpa_ipsec_params *params)
 {
-	xx_assert(dpa_ipsec);
-	xx_assert(params);
-
 	/* copy config params */
 	dpa_ipsec->config = *params;
 }
@@ -188,7 +185,10 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	struct dpa_cls_tbl_params table_params;
 	int i, err, valid_tables = 0;
 
-	xx_assert(prms);
+	if (!prms) {
+		xx_pr_err(("Invalid DPA IPsec parameters handle\n"));
+		return -EINVAL;
+	}
 
 	if ((prms->post_sec_in_params.do_pol_check) && (!prms->fm_pcd)) {
 		xx_pr_err(("Provide a valid PCD handle to enable inbound policy check!\n"));
@@ -284,12 +284,25 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 	return 0;
 }
 
-static uint8_t calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec)
+static int calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 {
 	uint8_t key_fields, field_mask = 0;
-	uint8_t key_size = 0, i;
+	int i;
+
+	/* sanity checks */
+	if (!key_size) {
+		xx_pr_err(("Invalid argument: NULL key_size parameter\n"));
+		return -EFAULT;
+	}
 
-	xx_assert(dpa_ipsec);
+	/* default value for key_size (set now in case a failure occurs later)*/
+	*key_size = 0;
+
+	/* more sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
 
 	key_fields = dpa_ipsec->config.post_sec_in_params.key_fields;
 
@@ -298,41 +311,58 @@ static uint8_t calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec)
 		switch (key_fields & field_mask) {
 		case DPA_IPSEC_KEY_FIELD_SIP:
 			if (dpa_ipsec->config.post_sec_in_params.use_ipv6_pol)
-				key_size += IPv6_ADDR_SIZE_IN_BYTES;
+				*key_size += IPv6_ADDR_SIZE_IN_BYTES;
 			else
-				key_size += IPv4_ADDR_SIZE_IN_BYTES;
+				*key_size += IPv4_ADDR_SIZE_IN_BYTES;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DIP:
 			if (dpa_ipsec->config.post_sec_in_params.use_ipv6_pol)
-				key_size += IPv6_ADDR_SIZE_IN_BYTES;
+				*key_size += IPv6_ADDR_SIZE_IN_BYTES;
 			else
-				key_size += IPv4_ADDR_SIZE_IN_BYTES;
+				*key_size += IPv4_ADDR_SIZE_IN_BYTES;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_PROTO:
-			key_size += IP_PROTO_FIELD_LEN;
+			*key_size += IP_PROTO_FIELD_LEN;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_SPORT:
-			key_size += PORT_FIELD_LEN;
+			*key_size += PORT_FIELD_LEN;
 			break;
 
 		case DPA_IPSEC_KEY_FIELD_DPORT:
-			key_size += PORT_FIELD_LEN;
+			*key_size += PORT_FIELD_LEN;
 			break;
 		}
 	}
 
-	return key_size;
+	return 0;
 }
 
-static void *create_inpol_node(struct dpa_ipsec *dpa_ipsec)
+static int create_inpol_node(struct dpa_ipsec *dpa_ipsec, void **cc_node)
 {
-	void *cc_node;
 	t_FmPcdCcNextEngineParams *next_engine_miss_action;
 
-	xx_assert(dpa_ipsec->sa_mng.inpol_key_size != 0);
+	/* sanity checks */
+	if (!cc_node) {
+		xx_pr_err(("Invalid argument: NULL CC Node handle holder\n"));
+		return -EFAULT;
+	}
+
+	/* default value for cc_node (set now in case a failure occurs later) */
+	*cc_node = NULL;
+
+	/* more sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (dpa_ipsec->sa_mng.inpol_key_size == 0) {
+		xx_pr_err(("Invalid argument: in policy table key size\n"));
+		return -EFAULT;
+	}
 
 	memset(&cc_node_prms, 0, sizeof(cc_node_prms));
 	cc_node_prms.extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
@@ -351,26 +381,102 @@ static void *create_inpol_node(struct dpa_ipsec *dpa_ipsec)
 			     &cc_node_prms.keysParams.ccNextEngineParamsForMiss;
 	next_engine_miss_action->nextEngine = e_FM_PCD_DONE;
 
-	cc_node = FM_PCD_CcSetNode(dpa_ipsec->config.fm_pcd, &cc_node_prms);
+	*cc_node = FM_PCD_CcSetNode(dpa_ipsec->config.fm_pcd, &cc_node_prms);
+	if (!*cc_node) {
+		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_CcSetNode");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static inline void destroy_inpol_node(struct dpa_ipsec *dpa_ipsec,
+				      void *cc_node)
+{
+	t_Error fmd_err;
+
+	fmd_err = FM_PCD_CcDeleteNode(dpa_ipsec->config.fm_pcd, cc_node);
+	if (fmd_err != E_OK) {
+		xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteNode");
+		xx_pr_err(("Could not free policy check CC Node\n"));
+	}
+}
+
+static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
+				void *cc_node,
+				int *td)
+{
+	struct dpa_cls_tbl_params params;
+	int err;
+
+	/* sanity checks */
+	if (!td) {
+		xx_pr_err(("Invalid argument: NULL table descriptor holder\n"));
+		return -EFAULT;
+	}
+
+	*td = DPA_CLS_INVALID_TABLE_DESC;
 
-	return cc_node;
+	/* more sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!cc_node) {
+		xx_pr_err(("Invalid argument: NULL CC Node handle\n"));
+		return -EFAULT;
+	}
+
+	memset(&params, 0, sizeof(params));
+	params.fm_pcd = dpa_ipsec->config.fm_pcd;
+	params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+	params.type = DPA_CLS_TBL_EXACT_MATCH;
+	params.exact_match_params.entries_cnt = DPA_IPSEC_MAX_IN_POL_PER_SA;
+	params.exact_match_params.key_size = dpa_ipsec->sa_mng.inpol_key_size;
+	params.exact_match_params.use_priorities = 0;
+	params.cc_node = cc_node;
+	err = dpa_classif_table_create(&params, td);
+	if (err < 0) {
+		xx_pr_err(("Could not create exact match tbl"));
+		return err;
+	}
+
+	return 0;
 }
 
-static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t * flowid)
+static inline void destroy_inpol_cls_tbl(int td)
 {
+	int err;
+
+	if (td != DPA_CLS_INVALID_TABLE_DESC) {
+		err = dpa_classif_table_free(td);
+		if (err < 0)
+			xx_pr_err(("Could not free EM table\n"));
+	}
+}
+
+static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t *flowid)
+{
+	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("The DPA IPSec instance was not initialized\n"));
-		return -EINVAL;
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
 	}
 
 	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err(("Null inbould policy flowid circular queue\n"));
-		return -EINVAL;
+		xx_pr_err(("Invalid argument: NULL in policy flow ID CQ\n"));
+		return -EFAULT;
+	}
+
+	if (!flowid) {
+		xx_pr_err(("Invalid argument: NULL flow ID parameter\n"));
+		return -EFAULT;
 	}
 
 	if (cq_get_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err(("Could not get valid inbound flow id\n"));
-		return -ENOMEM;
+		xx_pr_err(("Could not retrieve a valid inbound flow ID\n"));
+		return -EDOM;
 	}
 
 	return 0;
@@ -378,19 +484,20 @@ static int get_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t * flowid)
 
 static int put_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t flowid)
 {
+	/* sanity checks */
 	if (!dpa_ipsec) {
-		xx_pr_err(("The DPA IPSec instance was not initialized\n"));
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
 		return -EFAULT;
 	}
 
 	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err(("Null inbound policy flowid circular queue\n"));
+		xx_pr_err(("Invalid argument: NULL in policy flow ID CQ\n"));
 		return -EFAULT;
 	}
 
 	if (cq_put_2bytes(dpa_ipsec->sa_mng.inbound_flowid_cq, flowid) < 0) {
-		xx_pr_err(("Could not put inbound flow id\n"));
-		return -ERANGE;
+		xx_pr_err(("Could not release inbound flow id\n"));
+		return -EDOM;
 	}
 
 	return 0;
@@ -401,6 +508,12 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	void *cq;
 	int i, err;
 
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
 	cq = cq_new((uint16_t) (dpa_ipsec->sa_mng.max_num_sa / 2),
 		    (uint16_t)sizeof(uint16_t));
 	if (!cq) {
@@ -424,21 +537,11 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	return 0;
 }
 
-static int destroy_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
+static inline void destroy_inbound_flowid_cq(struct cq *inbound_flowid_cq)
 {
-	if (!dpa_ipsec) {
-		xx_pr_err(("The DPA IPSec instance was not initialized\n"));
-		return -EINVAL;
-	}
-
-	if (!dpa_ipsec->sa_mng.inbound_flowid_cq) {
-		xx_pr_err(("Null inbould policy flowid circular queue\n"));
-		return -EINVAL;
-	}
-
-	cq_delete(dpa_ipsec->sa_mng.inbound_flowid_cq);
-
-	return 0;
+	/* sanity checks */
+	if (inbound_flowid_cq)
+		cq_delete(inbound_flowid_cq);
 }
 
 static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
@@ -446,9 +549,15 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 	struct inpol_tbl *inpol_tbl;
 	struct list_head *head;
 
-	if ((!dpa_ipsec) || (!table_desc)) {
-		xx_pr_err(("Invalid input parameters"));
-		return -EINVAL;
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!table_desc) {
+		xx_pr_err(("Invalid argument: in policy table desc holder\n"));
+		return -EFAULT;
 	}
 
 	head = &dpa_ipsec->sa_mng.inpol_tables;
@@ -466,7 +575,7 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 
 	if (inpol_tbl->td < 0) {
 		xx_pr_err(("Invalid table reference\n"));
-		return -EINVAL;
+		return -EFAULT;
 	}
 
 	*table_desc = inpol_tbl->td;
@@ -479,9 +588,15 @@ static int put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 	struct inpol_tbl *inpol_tbl;
 	struct list_head *head;
 
-	if ((!dpa_ipsec) || (table_desc < 0)) {
-		xx_pr_err(("Invalid input parameters"));
-		return -EINVAL;
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (table_desc == DPA_CLS_INVALID_TABLE_DESC) {
+		xx_pr_err(("Invalid argument: in policy table desc holder\n"));
+		return -EFAULT;
 	}
 
 	head = &dpa_ipsec->sa_mng.inpol_tables;
@@ -511,10 +626,16 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	struct dpa_ipsec_sa_mng *sa_mng;
 	int i = 0, err;
 
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
 	sa_mng = &dpa_ipsec->sa_mng;
 	sa_mng->max_num_sa = dpa_ipsec->config.max_sa_pairs * 2;
 
-	/* create queue that holds free queues' ids */
+	/* create queue that holds free SA IDs */
 	sa_mng->sa_id_cq = cq_new(sa_mng->max_num_sa, (uint16_t) sizeof(int));
 	if (!sa_mng->sa_id_cq) {
 		xx_pr_err(("Could not create SA IDs circular queue\n"));
@@ -522,8 +643,12 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	}
 
 	/* fill with ids */
-	for (i = 0; i < sa_mng->max_num_sa; i++)
-		cq_put_4bytes(sa_mng->sa_id_cq, i);
+	for (i = 0; i < sa_mng->max_num_sa; i++) {
+		if (cq_put_4bytes(sa_mng->sa_id_cq, i) < 0) {
+			xx_pr_err(("Could not fill SA ID management CQ\n"));
+			return -EDOM;
+		}
+	}
 
 	/* alloc SA array */
 	sa_mng->sa = xx_malloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
@@ -598,12 +723,13 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	 * an Exact Match Table and link it to the Inbound Index Table */
 	if (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) {
 		struct inpol_tbl *pol_table;
-		struct dpa_cls_tbl_params params;
 		void *cc_node;
 
 		/* calculate key size for policy verification tables */
-		dpa_ipsec->sa_mng.inpol_key_size =
-						calc_in_pol_key_size(dpa_ipsec);
+		err = calc_in_pol_key_size(dpa_ipsec,
+				&dpa_ipsec->sa_mng.inpol_key_size);
+		if (err < 0)
+			return err;
 
 		INIT_LIST_HEAD(&sa_mng->inpol_tables);
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
@@ -615,27 +741,23 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 			memset(pol_table, 0, sizeof(*pol_table));
 
 			/* create cc node for inbound policy */
-			cc_node = create_inpol_node(dpa_ipsec);
-			if (!cc_node) {
+			err = create_inpol_node(dpa_ipsec, &cc_node);
+			if (err < 0) {
 				xx_pr_err(("Could not create cc node for EM table\n"));
-				return -ENOEXEC;
+				xx_free(pol_table);
+				return err;
 			}
 			pol_table->cc_node = cc_node;
-			memset(&params, 0, sizeof(params));
-			params.fm_pcd = dpa_ipsec->config.fm_pcd;
-			params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-			params.type = DPA_CLS_TBL_EXACT_MATCH;
-			params.exact_match_params.entries_cnt =
-						    DPA_IPSEC_MAX_IN_POL_PER_SA;
-			params.exact_match_params.key_size =
-					       dpa_ipsec->sa_mng.inpol_key_size;
-			params.exact_match_params.use_priorities = 0;
-			params.cc_node = cc_node;
-			err = dpa_classif_table_create(&params, &pol_table->td);
+
+			err = create_inpol_cls_tbl(dpa_ipsec,
+						   cc_node,
+						   &pol_table->td);
 			if (err < 0) {
-				xx_pr_err(("Could not create exact match tbl"));
+				xx_pr_err(("Failed create in policy table\n"));
+				xx_free(pol_table);
 				return err;
 			}
+
 			list_add(&pol_table->table_list,
 				 &dpa_ipsec->sa_mng.inpol_tables);
 		}
@@ -663,73 +785,73 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 /* cleanup SA manager */
 static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 {
-	struct dpa_ipsec_sa_mng *sa_mng =
-				(struct dpa_ipsec_sa_mng *)&dpa_ipsec->sa_mng;
+	struct dpa_ipsec_sa_mng *sa_mng;
 	struct inpol_tbl *pol_tbl, *tmp;
 	struct list_head *head;
-	int i = 0, err;
-	t_Error	fmd_err;
+	int i = 0;
 
-	/* Remove the DPA IPsec created tables for policy verification */
-	head = &sa_mng->inpol_tables;
-	list_for_each_entry_safe(pol_tbl, tmp, head, table_list) {
-		err = dpa_classif_table_free(pol_tbl->td);
-		if (err < 0)
-			xx_pr_err(("Could not free policy check EM table\n"));
-		list_del(&pol_tbl->table_list);
-		fmd_err = FM_PCD_CcDeleteNode(dpa_ipsec->config.fm_pcd,
-				pol_tbl->cc_node);
-		if (fmd_err != E_OK)
-			xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteNode");
-		xx_free(pol_tbl);
-	}
-
-	if (!sa_mng->sa) {
-		xx_pr_err(("Sa vector null"));
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
 		return;
 	}
 
+	sa_mng = (struct dpa_ipsec_sa_mng *)&dpa_ipsec->sa_mng;
+	/* Remove the DPA IPsec created tables for policy verification */
+	if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		head = &sa_mng->inpol_tables;
+		list_for_each_entry_safe(pol_tbl, tmp, head, table_list) {
+			destroy_inpol_cls_tbl(pol_tbl->td);
+			list_del(&pol_tbl->table_list);
+			destroy_inpol_node(dpa_ipsec, pol_tbl->cc_node);
+			xx_free(pol_tbl);
+		}
+	}
 
 	/* dealloc cipher/auth stuff */
-	for (i = 0; i < sa_mng->max_num_sa; i++) {
-		if (sa_mng->sa[i].cipher_data.cipher_key) {
-			xx_free(sa_mng->sa[i].cipher_data.cipher_key);
-			sa_mng->sa[i].cipher_data.cipher_key = NULL;
-		}
-		if (sa_mng->sa[i].auth_data.auth_key) {
-			xx_free(sa_mng->sa[i].auth_data.auth_key);
-			sa_mng->sa[i].auth_data.auth_key = NULL;
-		}
-		if (sa_mng->sa[i].auth_data.split_key) {
-			xx_free(sa_mng->sa[i].auth_data.split_key);
-			sa_mng->sa[i].auth_data.split_key = NULL;
-		}
-		if (sa_mng->sa[i].from_sec_fq) {
-			xx_free(sa_mng->sa[i].from_sec_fq);
-			sa_mng->sa[i].from_sec_fq = NULL;
-		}
-		if (sa_mng->sa[i].to_sec_fq) {
-			xx_free(sa_mng->sa[i].to_sec_fq);
-			sa_mng->sa[i].to_sec_fq = NULL;
-		}
-		if (sa_mng->sa[i].sec_desc) {
-			xx_free_smart(sa_mng->sa[i].sec_desc);
-			sa_mng->sa[i].sec_desc = NULL;
+	if (sa_mng->sa) {
+		for (i = 0; i < sa_mng->max_num_sa; i++) {
+			if (sa_mng->sa[i].cipher_data.cipher_key) {
+				xx_free(sa_mng->sa[i].cipher_data.cipher_key);
+				sa_mng->sa[i].cipher_data.cipher_key = NULL;
+			}
+			if (sa_mng->sa[i].auth_data.auth_key) {
+				xx_free(sa_mng->sa[i].auth_data.auth_key);
+				sa_mng->sa[i].auth_data.auth_key = NULL;
+			}
+			if (sa_mng->sa[i].auth_data.split_key) {
+				xx_free(sa_mng->sa[i].auth_data.split_key);
+				sa_mng->sa[i].auth_data.split_key = NULL;
+			}
+			if (sa_mng->sa[i].from_sec_fq) {
+				xx_free(sa_mng->sa[i].from_sec_fq);
+				sa_mng->sa[i].from_sec_fq = NULL;
+			}
+			if (sa_mng->sa[i].to_sec_fq) {
+				xx_free(sa_mng->sa[i].to_sec_fq);
+				sa_mng->sa[i].to_sec_fq = NULL;
+			}
+			if (sa_mng->sa[i].sec_desc) {
+				xx_free_smart(sa_mng->sa[i].sec_desc);
+				sa_mng->sa[i].sec_desc = NULL;
+			}
 		}
+		xx_free(sa_mng->sa);
+		sa_mng->sa = NULL;
 	}
 
-	cq_delete(sa_mng->sa_id_cq);
-	sa_mng->sa_id_cq = NULL;
+	/* release SA ID management CQ */
+	if (sa_mng->sa_id_cq) {
+		cq_delete(sa_mng->sa_id_cq);
+		sa_mng->sa_id_cq = NULL;
+	}
 
-	destroy_inbound_flowid_cq(dpa_ipsec);
+	/* release inbound flow ID management CQ */
+	destroy_inbound_flowid_cq(dpa_ipsec->sa_mng.inbound_flowid_cq);
 
+	/* destroy rekeying workqueue */
 	if (sa_mng->sa_rekeying_wq)
 		destroy_workqueue(sa_mng->sa_rekeying_wq);
-
-	xx_free(sa_mng->sa);
-	sa_mng->sa = NULL;
-
-	return;
 }
 
 /* cleanup Ipsec */
@@ -737,8 +859,9 @@ static void free_resources(void)
 {
 	struct dpa_ipsec *dpa_ipsec;
 
+	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
-		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
+		xx_pr_err(("There is no DPA IPSec instance initialized\n"));
 		return;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -754,14 +877,18 @@ static void free_resources(void)
 /* Runtime functions */
 
 /* Convert prefixLen into IP address's netmask. */
-static void set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
+static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 			     uint8_t mask_len)
 {
 	static const uint8_t mask_bits[] = {0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8,
 					    0xfc, 0xfe, 0xff};
 	uint8_t bit, off;
 
-	xx_assert(mask);
+	/* sanity checks */
+	if (!mask) {
+		xx_pr_err(("Invalid argument: NULL mask parameter\n"));
+		return -EFAULT;
+	}
 	memset(mask, 0, mask_len);
 
 	off = prefix_len / 8;
@@ -770,6 +897,8 @@ static void set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 		*mask++ = 0xff;
 	if (bit)
 		*mask = mask_bits[bit];
+
+	return 0;
 }
 
 static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
@@ -780,14 +909,17 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 	struct dpa_cls_tbl_action *action;
 	int err, id;
 
-	xx_assert(sa);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
 	id = sa->id;
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 	/* AV's note: TODO - case when inbound_flowid is greater than 255 */
-	memset(tbl_key.byte, 0, DPA_CLS_TBL_MAXENTRYKEYSIZE);
-	memset(tbl_key.mask, 0, DPA_CLS_TBL_MAXENTRYKEYSIZE);
+	memset(&tbl_key, 0, sizeof(tbl_key));
 	tbl_key.byte[0] = (uint8_t) sa->inbound_flowid;
 
 	action = &sa->def_sa_action;
@@ -811,6 +943,27 @@ static int fill_policy_key(int td,
 	uint8_t offset = 0, field_mask = 0, tbl_key_size = 0;
 	int err = 0, i;
 
+	/* sanity checks */
+	if (!policy_selectors) {
+		xx_pr_err(("Invalid argument: NULL policy selectors\n"));
+		return -EFAULT;
+	}
+
+	if (!key) {
+		xx_pr_err(("Invalid argument: NULL key container\n"));
+		return -EFAULT;
+	}
+
+	if (!mask) {
+		xx_pr_err(("Invalid argument: NULL mask container\n"));
+		return -EFAULT;
+	}
+
+	if (!key_len) {
+		xx_pr_err(("Invalid argument: NULL key_len container\n"));
+		return -EFAULT;
+	}
+
 	/* Fill in the key components */
 	for (i = 0; i < DPA_IPSEC_MAX_KEY_FIELDS; i++) {
 		field_mask = (uint8_t) (1 << i);
@@ -819,9 +972,11 @@ static int fill_policy_key(int td,
 			memcpy(key + offset,
 			       IP_ADDR(policy_selectors->src_addr),
 			       IP_ADDR_LEN(policy_selectors->src_addr));
-			set_ip_addr_mask(mask + offset,
-				       policy_selectors->src_prefix_len,
-				       IP_ADDR_LEN(policy_selectors->src_addr));
+			err = set_ip_addr_mask(mask + offset,
+				policy_selectors->src_prefix_len,
+				IP_ADDR_LEN(policy_selectors->src_addr));
+			if (err < 0)
+				return err;
 			offset += IP_ADDR_LEN(policy_selectors->src_addr);
 			break;
 
@@ -829,9 +984,11 @@ static int fill_policy_key(int td,
 			memcpy(key + offset,
 			       IP_ADDR(policy_selectors->dest_addr),
 			       IP_ADDR_LEN(policy_selectors->dest_addr));
-			set_ip_addr_mask(mask + offset,
-				      policy_selectors->dest_prefix_len,
-				      IP_ADDR_LEN(policy_selectors->dest_addr));
+			err = set_ip_addr_mask(mask + offset,
+				policy_selectors->dest_prefix_len,
+				IP_ADDR_LEN(policy_selectors->dest_addr));
+			if (err < 0)
+				return err;
 			offset += IP_ADDR_LEN(policy_selectors->dest_addr);
 			break;
 
@@ -914,53 +1071,145 @@ static int fill_policy_key(int td,
 	return 0;
 }
 
+/*
+ * fill dpa_cls_action structure with common values
+ * if new_fqid = 0, the FQID will not be overridden
+ */
+static inline void fill_cls_action_enq(struct dpa_cls_tbl_action *action_prm,
+				       int en_stats, uint32_t new_fqid,
+				       struct dpa_cls_tbl_header_manip *hmanip)
+{
+	action_prm->type = DPA_CLS_TBL_ACTION_ENQ;
+	action_prm->enable_statistics = en_stats;
+	if (new_fqid != 0) {
+		action_prm->enq_params.new_fqid = new_fqid;
+		action_prm->enq_params.override_fqid = TRUE;
+	} else
+		action_prm->enq_params.override_fqid = FALSE;
+	action_prm->enq_params.policer_params = NULL;
+	action_prm->enq_params.hm = hmanip;
+}
+
+static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
+			     struct dpa_ipsec_policy_entry *policy_entry,
+			     struct dpa_cls_tbl_header_manip **hm)
+{
+	t_FmPcdManipFragOrReasmParams *frag_param;
+
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		return -EFAULT;
+	}
+
+	if (!hm) {
+		xx_pr_err(("Invalid argument: NULL manip holder\n"));
+		return -EFAULT;
+	}
+
+	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
+	frag_param = &pcd_manip_params.fragOrReasmParams;
+	pcd_manip_params.fragOrReasm = TRUE;
+	frag_param->frag = TRUE;
+	frag_param->hdr  = HEADER_TYPE_IPv4;
+	frag_param->ipFragParams.sizeForFragmentation =
+					policy_entry->mtu;
+	frag_param->ipFragParams.scratchBpid =
+				dpa_ipsec->config.ipf_bpid;
+	frag_param->ipFragParams.dontFragAction =
+			pcd_df_action[policy_entry->df_action];
+	*hm = FM_PCD_ManipSetNode(dpa_ipsec->config.fm_pcd,
+				  &pcd_manip_params);
+	if (!*hm) {
+		xx_pr_fmd_err(E_NOT_AVAILABLE, "FM_PCD_ManipSetNode");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int destroy_frag_manip(struct dpa_ipsec *dpa_ipsec,
+				      struct dpa_cls_tbl_header_manip *hm)
+{
+	t_Error fmd_err;
+
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!hm) {
+		xx_pr_err(("Invalid argument: NULL header manip handle\n"));
+		return -EFAULT;
+	}
+
+	fmd_err = FM_PCD_ManipDeleteNode(dpa_ipsec->config.fm_pcd,
+			(t_Handle)hm);
+	if (fmd_err != E_OK) {
+		xx_pr_fmd_err(fmd_err, "FM_PCD_ManipDeleteNode");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
 static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 				 struct dpa_ipsec_policy_entry *policy_entry,
 				 enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
-	uint8_t keyLength;
-	uint8_t key[MAX_SIZE_POLICY_KEY];
-	uint8_t mask[MAX_SIZE_POLICY_KEY];
+	uint8_t key_len;
 	struct dpa_cls_tbl_action *action;
 	struct dpa_cls_tbl_key tbl_key;
 	int entry_id;
 	int err;
 
-	xx_assert(sa);
-	xx_assert(policy_entry);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
-	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
-	policy_selectors = &(policy_entry->policy_selectors);
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		return -EFAULT;
+	}
 
 	if (sa->em_inpol_td < 0) {
 		xx_pr_err(("Invalid exact match table for SA %d.\n", sa->id));
 		return -EINVAL;
 	}
 
+	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
+	policy_selectors = &(policy_entry->policy_selectors);
+
 	switch (op_type) {
 	case MNG_OP_ADD:
-		memset(key, 0, MAX_SIZE_POLICY_KEY);
-		memset(mask, 0, MAX_SIZE_POLICY_KEY);
+		memset(&tbl_key, 0, sizeof(tbl_key));
 
 		/* Key contains:
-		 * IP SRC ADDR  - from Policy handle
-		 * IP DST ADDR  - from Policy handle
-		 * IP_PROTO     - from Policy handle
-		 * SRC_PORT             - from Policy handle (for UDP & TCP)
-		 * DST_PORT             - from Policy handle (for UDP & TCP)
+		 * IP SRC ADDR	- from Policy handle
+		 * IP DST ADDR	- from Policy handle
+		 * IP_PROTO	- from Policy handle
+		 * SRC_PORT	- from Policy handle (for UDP & TCP)
+		 * DST_PORT	- from Policy handle (for UDP & TCP)
 		 */
 		err = fill_policy_key(sa->em_inpol_td,
 				      policy_selectors,
 				      dpa_ipsec->config.post_sec_in_params.
-				      key_fields, key, mask, &keyLength);
+				      key_fields, tbl_key.byte, tbl_key.mask,
+				      &key_len);
 		if (err < 0)
 			return err;
 
 		action = &sa->def_sa_action;
-		memcpy(tbl_key.byte, key, MAX_SIZE_POLICY_KEY);
-		memcpy(tbl_key.mask, mask, MAX_SIZE_POLICY_KEY);
 		err = dpa_classif_table_insert_entry(sa->em_inpol_td, &tbl_key,
 						     action, 0, &entry_id);
 		if (err < 0) {
@@ -992,9 +1241,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_policy_selectors *policy_selectors;
-	uint8_t keyLength, table_idx;
-	uint8_t key[MAX_SIZE_POLICY_KEY];
-	uint8_t mask[MAX_SIZE_POLICY_KEY];
+	uint8_t key_len, table_idx;
 	int table;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
@@ -1002,8 +1249,16 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_entry_mod_params params;
 	int err;
 
-	xx_assert(sa);
-	xx_assert(policy_entry);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy handle\n"));
+		return -EFAULT;
+	}
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 	policy_selectors = &(policy_entry->policy_selectors);
@@ -1028,8 +1283,8 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 	switch (op_type) {
 	case MNG_OP_ADD:
-		memset(key, 0, MAX_SIZE_POLICY_KEY);
-		memset(mask, 0, MAX_SIZE_POLICY_KEY);
+		memset(&tbl_key, 0, sizeof(tbl_key));
+
 		/* Key may contain:
 		 * IP SRC ADDR  - from Policy handle
 		 * IP DST ADDR  - from Policy handle
@@ -1039,42 +1294,23 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		 */
 		err = fill_policy_key(table, policy_selectors,
 				dpa_ipsec->config.pre_sec_out_params.key_fields,
-				key, mask, &keyLength);
+				tbl_key.byte, tbl_key.mask, &key_len);
 		if (err < 0)
 			return err;
 
 		/* Configure fragmentation */
 		if (policy_entry->mtu) {
-			t_FmPcdManipFragOrReasmParams *frag_param;
-
-			memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
-			frag_param = &pcd_manip_params.fragOrReasmParams;
-			pcd_manip_params.fragOrReasm = TRUE;
-			frag_param->frag = TRUE;
-			frag_param->hdr  = HEADER_TYPE_IPv4;
-			frag_param->ipFragParams.sizeForFragmentation =
-							policy_entry->mtu;
-			frag_param->ipFragParams.scratchBpid =
-						dpa_ipsec->config.ipf_bpid;
-			frag_param->ipFragParams.dontFragAction =
-					pcd_df_action[policy_entry->df_action];
-			hm = FM_PCD_ManipSetNode(dpa_ipsec->config.fm_pcd,
-						 &pcd_manip_params);
-			if (!hm) {
+			err = create_frag_manip(dpa_ipsec, policy_entry, &hm);
+			if (err < 0) {
 				xx_pr_err(("Could not create Manip node for fragmentation!\n"));
 				return -EAGAIN;
 			}
 		}
 
-		memcpy(&tbl_key.byte, key, keyLength);
-		memcpy(&tbl_key.mask, mask, keyLength);
 		memset(&action, 0, sizeof(action));
-		action.type = DPA_CLS_TBL_ACTION_ENQ;
-		action.enable_statistics = FALSE;
-		action.enq_params.new_fqid = qman_fq_fqid((sa->to_sec_fq));
-		action.enq_params.override_fqid = TRUE;
-		action.enq_params.policer_params = NULL;
-		action.enq_params.hm = hm;
+		fill_cls_action_enq(&action, FALSE,
+			qman_fq_fqid((sa->to_sec_fq)), hm);
+
 		/* Store the header manipulation into the policy entry */
 		policy_entry->hm = hm;
 
@@ -1092,15 +1328,21 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			xx_pr_err(("Could not remove key from EM table\n"));
 			return err;
 		}
+
+		if (policy_entry->hm) {
+			err = destroy_frag_manip(dpa_ipsec, policy_entry->hm);
+			if (err < 0) {
+				xx_pr_err(("Couldn't delete frag manip\n"));
+				return err;
+			}
+
+		}
+
 		break;
 	case MNG_OP_MODIFY:
 		memset(&action, 0, sizeof(action));
-		action.type = DPA_CLS_TBL_ACTION_ENQ;
-		action.enable_statistics = FALSE;
-		action.enq_params.hm = policy_entry->hm;
-		action.enq_params.new_fqid = qman_fq_fqid(sa->to_sec_fq);
-		action.enq_params.override_fqid = TRUE;
-		action.enq_params.policer_params = NULL;
+		fill_cls_action_enq(&action, FALSE,
+			qman_fq_fqid((sa->to_sec_fq)), policy_entry->hm);
 
 		memset(&params, 0, sizeof(params));
 		params.type = DPA_CLS_TBL_MODIFY_ACTION;
@@ -1124,15 +1366,18 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 					enum mng_op_type op_type)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	uint8_t key[MAX_SIZE_IP_UDP_SPI_KEY];
-	uint8_t mask[MAX_SIZE_IP_UDP_SPI_KEY];
 	int table, entry_id;
 	struct dpa_cls_tbl_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
 	int offset, err = 0, tbl_key_size = 0, i;
+	uint8_t *key, *mask;
 
-	xx_assert(sa);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 	table = dpa_ipsec->config.pre_sec_in_params.dpa_cls_td;
@@ -1143,8 +1388,9 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		 * inserted*/
 		sa->inbound_hash_entry = -1;
 
-		memset(key, 0, MAX_SIZE_IP_UDP_SPI_KEY);
-		memset(mask, 0, MAX_SIZE_IP_UDP_SPI_KEY);
+		memset(&tbl_key, 0, sizeof(tbl_key));
+		key = tbl_key.byte;
+		mask = tbl_key.mask;
 
 		/* Key contains:
 		 * IP DST ADDR  - from SA handle
@@ -1200,16 +1446,9 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		memset(mask, 0xFF, offset);
 
 		/* Complete the parameters for table insert function */
-		memcpy(tbl_key.byte, key, MAX_SIZE_IP_UDP_SPI_KEY);
-		memcpy(tbl_key.mask, mask, MAX_SIZE_IP_UDP_SPI_KEY);
-
 		memset(&action, 0, sizeof(action));
-		action.type = DPA_CLS_TBL_ACTION_ENQ;
-		action.enable_statistics = FALSE;
-		action.enq_params.new_fqid = qman_fq_fqid(sa->to_sec_fq);
-		action.enq_params.override_fqid = TRUE;
-		action.enq_params.hm = NULL;
-		action.enq_params.policer_params = NULL;
+		fill_cls_action_enq(&action, FALSE,
+			qman_fq_fqid((sa->to_sec_fq)), NULL);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
@@ -1238,10 +1477,21 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 	return err;
 }
 
-static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t * fqid)
+static int get_new_fqid(struct dpa_ipsec *dpa_ipsec, uint32_t *fqid)
 {
 	int err = 0;
 
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!fqid) {
+		xx_pr_err(("Invalid argument: NULL fqid holder\n"));
+		return -EFAULT;
+	}
+
 	if (dpa_ipsec->config.fqid_pool != NULL) {
 		err = qman_fqid_pool_alloc(dpa_ipsec->config.fqid_pool, fqid);
 		if (err < 0)
@@ -1265,6 +1515,11 @@ static void put_free_fqid(uint32_t fqid)
 	struct dpa_ipsec *dpa_ipsec;
 	int err;
 
+	/* sanity checks */
+	if (!gbl_dpa_ipsec) {
+		xx_pr_err(("There is no DPA IPSec instance initialized\n"));
+		return;
+	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
 	/* recycle the FQID */
@@ -1277,23 +1532,23 @@ static void put_free_fqid(uint32_t fqid)
 	}
 }
 
-static int wait_until_fq_empty(struct qman_fq *fq, int *timeout)
+static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 {
 	struct qm_mcr_queryfq_np queryfq_np;
 
-	if ((!fq) || (!timeout)) {
-		xx_pr_err(("Invalid input arguments\n"));
-		return -EINVAL;
+	if (!fq) {
+		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		return -EFAULT;
 	}
 
 	do {
 		qman_query_fq_np(fq, &queryfq_np);
 		cpu_relax();
 		udelay(1);
-		*timeout = *timeout - 1;
-	} while (queryfq_np.frm_cnt && *timeout);
+		timeout = timeout - 1;
+	} while (queryfq_np.frm_cnt && timeout);
 
-	if (*timeout == 0) {
+	if (timeout == 0) {
 		xx_pr_err(("Timeout. Fq with id %d not empty.\n", fq->fqid));
 		return -EBUSY;
 	}
@@ -1305,9 +1560,10 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 {
 	int err, flags, timeout = 10000;
 
+	/* sanity checks */
 	if (!sec_fq) {
-		xx_pr_err(("Invalid FQ pointer address specified!\n"));
-		return -EINVAL;
+		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		return -EFAULT;
 	}
 
 	err = qman_retire_fq(sec_fq, &flags);
@@ -1316,14 +1572,14 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 		return err;
 	}
 
-	err = wait_until_fq_empty(sec_fq, &timeout);
+	err = wait_until_fq_empty(sec_fq, timeout);
 	if (err < 0)
-		return -EBUSY;
+		return err;
 
 	err = qman_oos_fq(sec_fq);
 	if (err < 0) {
 		xx_pr_err(("Failed to OOS FQ %d\n", sec_fq->fqid));
-		return -EBUSY;
+		return err;
 	}
 
 	qman_destroy_fq(sec_fq, 0);
@@ -1344,6 +1600,12 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 	int err;
 	u32 flags;
 
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
 	to_sec_fq = sa->to_sec_fq;
 	from_sec_fq = sa->from_sec_fq;
 
@@ -1363,27 +1625,28 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 	return 0;
 }
 
-static int create_sec_frame_queue(uint32_t *fq_id, uint16_t channel,
+static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 				  uint16_t wq_id, uint32_t ctx_a_hi,
 				  uint32_t ctx_a_lo, uint32_t ctxB, bool parked,
-				  void *sec_fq)
+				  struct qman_fq *fq)
 {
 	struct qm_mcc_initfq fq_opts;
-	struct qman_fq *fq;
 	uint32_t flags;
 	int err = 0;
 
-	xx_assert(fq_id);
-	xx_assert(sec_fq);
+	/* sanity checks */
+	if (!fq) {
+		xx_pr_err(("Invalid argument: NULL fq handle\n"));
+		return -EFAULT;
+	}
 
-	fq = (struct qman_fq *)sec_fq;
 	memset(fq, 0, sizeof(struct qman_fq));
 
 	flags = QMAN_FQ_FLAG_LOCKED | QMAN_FQ_FLAG_TO_DCPORTAL;
 
-	err = qman_create_fq(*fq_id, flags, fq);
+	err = qman_create_fq(fq_id, flags, fq);
 	if (unlikely(err < 0)) {
-		xx_pr_err(("Could not create FQ with ID: %u\n", *fq_id));
+		xx_pr_err(("Could not create FQ with ID: %u\n", fq_id));
 		goto create_sec_fq_err;
 	}
 
@@ -1408,7 +1671,7 @@ static int create_sec_frame_queue(uint32_t *fq_id, uint16_t channel,
 		 * configure forwarding / flowID info:
 		 * - enable ctxB;
 		 * - set ctxA override;
-		 * - set in ctxB FQID or FlowID.
+		 * - set in ctxB the FlowID.
 		 */
 		fq_opts.we_mask |= QM_INITFQ_WE_CONTEXTB;
 		fq_opts.fqd.context_a.hi |= (1 << 31);
@@ -1439,16 +1702,20 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	void *ctxtA;
 	uint32_t ctxtA_hi, ctxtA_lo;
 	phys_addr_t addr;
-	struct qman_fq *from_Sec;
 	struct dpa_ipsec *dpa_ipsec;
 	uint32_t fqid_from_sec = 0, fqid_to_sec = 0;
+	uint16_t qm_tx_ch, flow_id;
 	int err;
 
-	xx_assert(sa);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 	if (!dpa_ipsec) {
-		xx_pr_err(("Null IPSec Port pointer\n"));
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
 		return -EFAULT;
 	}
 
@@ -1464,80 +1731,51 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	ctxtA_lo = (uint32_t) (addr);
 
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
-		/* If reuse FROM SEC FQ is false than create other FROM SEC FQ
-		 * and set it as output frame queue for this SA. Otherwise
-		 * profit that you poses a valid FROM SEC FQ from the OLD SA
-		 * and use it accordingly.
-		 */
-		if (!reuse_from_secfq) {
-			/* acquire fqid for 'FROM SEC' fq */
-			err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
-			if (err < 0)
-				return err;
+		qm_tx_ch = dpa_ipsec->config.post_sec_out_params.qm_tx_ch;
+		flow_id = sa->outbound_flowid;
+	} else {
+		qm_tx_ch = dpa_ipsec->config.post_sec_in_params.qm_tx_ch;
+		flow_id = sa->inbound_flowid;
+	}
 
-			err = create_sec_frame_queue(&fqid_from_sec,
-				 dpa_ipsec->config.post_sec_out_params.qm_tx_ch,
-				 sa->sa_wqid, 0, 0, /* ctxA */
-				 sa->out_flow_id, /*ctxB forwarding info*/
-				 FALSE, sa->from_sec_fq);
-			if (err < 0) {
-				xx_pr_err(("From SEC FQ couldn't be done\n"));
-				goto create_fq_pair_err;
-			}
-		}
 
-		/* acquire fqid for 'TO SEC' fq */
-		err = get_new_fqid(dpa_ipsec, &fqid_to_sec);
+	/* If reuse FROM SEC FQ is false than create other FROM SEC FQ
+	 * and set it as output frame queue for this SA. Otherwise
+	 * profit that you poses a valid FROM SEC FQ from the OLD SA
+	 * and use it accordingly.
+	 */
+	if (!reuse_from_secfq) {
+		/* acquire fqid for 'FROM SEC' fq */
+		err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
 		if (err < 0)
-			goto create_fq_pair_err;
+			return err;
 
-		from_Sec = sa->from_sec_fq;
-		err = create_sec_frame_queue(&fqid_to_sec,
-				dpa_ipsec->config.qm_sec_ch,
-				sa->sa_wqid, ctxtA_hi, ctxtA_lo, /* ctxA */
-				qman_fq_fqid(from_Sec), /*ctxB - output SEC fq*/
-				parked_to_secfq, sa->to_sec_fq);
+		err = create_sec_frame_queue(fqid_from_sec,
+				qm_tx_ch,
+				sa->sa_wqid, 0, 0, /* ctxA */
+				flow_id, /*ctxB forwarding info*/
+				FALSE, sa->from_sec_fq);
 		if (err < 0) {
-			xx_pr_err(("Encrypt FQ(to SEC) couldn't be created\n"));
+			xx_pr_err(("From SEC FQ couldn't be created\n"));
 			goto create_fq_pair_err;
 		}
-	} else { /* DPA_IPSEC_INBOUND */
-		/* If reuse FROM SEC FQ is false than create other FROM SEC FQ
-		 * and set it as output frame queue for this SA. Otherwise
-		 * profit that you poses a valid FROM SEC FQ from the OLD SA
-		 * and use it accordingly.
-		 */
-		if (!reuse_from_secfq) {
-			/* acquire fqid for 'FROM SEC' fq */
-			err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
-			if (err < 0)
-				return err;
-			err = create_sec_frame_queue(&fqid_from_sec,
-				  dpa_ipsec->config.post_sec_in_params.qm_tx_ch,
-				  sa->sa_wqid, 0, 0,	/* ctxA */
-				  sa->inbound_flowid,	/* flowID */
-				  FALSE, sa->from_sec_fq);
-			if (err < 0) {
-				xx_pr_err(("Decrypt FQ(from SEC) couldn't be created\n"));
-				goto create_fq_pair_err;
-			}
-		}
+	}
 
-		/* acquire fqid for 'TO SEC' fq */
-		err = get_new_fqid(dpa_ipsec, &fqid_to_sec);
-		if (err < 0)
-			goto create_fq_pair_err;
+	/* acquire fqid for 'TO SEC' fq */
+	err = get_new_fqid(dpa_ipsec, &fqid_to_sec);
+	if (err < 0)
+		goto create_fq_pair_err;
 
-		from_Sec = sa->from_sec_fq;
-		err = create_sec_frame_queue(&fqid_to_sec,
-					dpa_ipsec->config.qm_sec_ch,
-					sa->sa_wqid, ctxtA_hi, ctxtA_lo,
-					from_Sec->fqid,	/*ctxB - output SEC fq*/
-					parked_to_secfq, sa->to_sec_fq);
-		if (err < 0) {
-			xx_pr_err(("Decrypt FQ(to SEC) couldn't be created"));
-			goto create_fq_pair_err;
-		}
+	err = create_sec_frame_queue(fqid_to_sec,
+			dpa_ipsec->config.qm_sec_ch,
+			sa->sa_wqid, ctxtA_hi, ctxtA_lo, /* ctxA */
+			qman_fq_fqid(sa->from_sec_fq), /*ctxB - output SEC fq*/
+			parked_to_secfq, sa->to_sec_fq);
+	if (err < 0) {
+		xx_pr_err(("%s FQ(to SEC) couldn't be created\n",
+				(sa->sa_dir == DPA_IPSEC_OUTBOUND) ? "Encrypt" :
+				"Decrypt"));
+		goto create_fq_pair_err;
 	}
 
 	return 0;
@@ -1552,21 +1790,19 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 		put_free_fqid(fqid_to_sec); /*a FQID was allocated;recycle it*/
 
 	return err;
-
 }
 
-static int set_cipher_auth_alg(enum dpa_ipsec_cipher_alg alg_suite,
+static inline int set_cipher_auth_alg(enum dpa_ipsec_cipher_alg alg_suite,
 			       uint16_t *cipher, uint16_t * auth)
 {
-	xx_assert(cipher);
-	xx_assert(auth);
-
 	*cipher = ipsec_algs[alg_suite].enc_alg;
 	*auth = ipsec_algs[alg_suite].auth_alg;
 
 	if (*cipher == OP_PCL_IPSEC_INVALID_ALG_ID ||
-	    *auth == OP_PCL_IPSEC_INVALID_ALG_ID)
+	    *auth == OP_PCL_IPSEC_INVALID_ALG_ID) {
+		xx_pr_err(("Invalid algorithm suite selected\n"));
 		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -1577,8 +1813,16 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	struct ip_header *outer_ip_hdr;
 	int err;
 
-	xx_assert(sa);
-	xx_assert(sa_params);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!sa_params) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
 	sa->sa_dir = DPA_IPSEC_OUTBOUND;
 	sa->parent_sa = NULL;
@@ -1623,7 +1867,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 
 	sa->sec_desc->pdb_en.ip_nh = NEXT_HEADER_IS_IPv4;
 
-	sa->out_flow_id = sa_params->sa_out_params.post_sec_flow_id;
+	sa->outbound_flowid = sa_params->sa_out_params.post_sec_flow_id;
 
 	/* Copy the outer header and generate the original header checksum */
 	memcpy(&sa->sec_desc->pdb_en.ip_hdr[0],
@@ -1662,8 +1906,16 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec *dpa_ipsec;
 	int err;
 
-	xx_assert(sa);
-	xx_assert(sa_params);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!sa_params) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
 
@@ -1772,59 +2024,90 @@ static void copy_policy_selectors(struct dpa_ipsec_policy_params *policy_params,
 	return;
 }
 
-static struct dpa_ipsec_policy_entry *store_policy_param_to_sa_pol_list(
-				struct dpa_ipsec_sa *sa,
-				struct dpa_ipsec_policy_params *policy_params)
+static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
+				struct dpa_ipsec_policy_params *policy_params,
+				struct dpa_ipsec_policy_entry **policy_entry)
 {
-	struct dpa_ipsec_policy_entry *policy_entry;
+	struct dpa_ipsec_policy_entry *pol_entry;
+
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
 
-	xx_assert(sa);
-	xx_assert(policy_params);
+	if (!policy_params) {
+		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		return -EFAULT;
+	}
 
-	policy_entry = xx_malloc(sizeof(struct dpa_ipsec_policy_entry));
 	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy entry holder\n"));
+		return -EFAULT;
+	}
+
+	pol_entry = xx_malloc(sizeof(struct dpa_ipsec_policy_entry));
+	if (!pol_entry) {
 		xx_pr_err(("Could not allocate memory for policy\n"));
-		return NULL;
+		return -ENOMEM;
 	}
-	copy_policy_selectors(policy_params, &policy_entry->policy_selectors);
-	policy_entry->mtu = policy_params->mtu;
-	policy_entry->df_action = policy_params->df_action;
-	policy_entry->priority = policy_params->priority;
-	list_add(&policy_entry->node, &sa->policy_headlist);
-	return policy_entry;
+	copy_policy_selectors(policy_params, &pol_entry->policy_selectors);
+	pol_entry->mtu = policy_params->mtu;
+	pol_entry->df_action = policy_params->df_action;
+	pol_entry->priority = policy_params->priority;
+	list_add(&pol_entry->node, &sa->policy_headlist);
+
+	*policy_entry = pol_entry;
+
+	return 0;
 }
 
-static struct dpa_ipsec_policy_entry *find_policy_in_sa_policy_list(
-				struct dpa_ipsec_sa  *sa,
-				struct dpa_ipsec_policy_params *policy_params)
+static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
+				struct dpa_ipsec_policy_params *policy_params,
+				struct dpa_ipsec_policy_entry **policy_entry)
 {
-	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
+	struct dpa_ipsec_policy_entry *pol_entry, *tmp_policy_entry;
 	struct dpa_ipsec_policy_selectors policy_selectors;
 
-	xx_assert(sa);
-	xx_assert(policy_params);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_params) {
+		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy entry holder\n"));
+		return -EFAULT;
+	}
 
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err(("Policy parameter list is empty\n"));
-		return NULL;
+		return -EDOM;
 	}
 
-	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
+	list_for_each_entry_safe(pol_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node) {
 		copy_policy_selectors(policy_params, &policy_selectors);
-		if (!memcmp(&policy_entry->policy_selectors, &policy_selectors,
+		if (!memcmp(&pol_entry->policy_selectors,
+			    &policy_selectors,
 			    sizeof(struct dpa_ipsec_policy_selectors))) {
 			/* found the entry that matches the input policy
 			 * parameters */
-			return policy_entry;
+			*policy_entry = pol_entry;
+			return 0;
 		}
 	}
 
 	/* did not find the entry that matches the input policy parameters */
-	return NULL;
+	return -EDOM;
 }
 
-static int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
+static inline int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	int pol_count = 0;
@@ -1848,6 +2131,17 @@ static int copy_all_policies(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
 	int pol_count = 0;
 
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_params) {
+		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		return -EFAULT;
+	}
+
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err(("Policy parameter list is empty\n"));
 		return 0;
@@ -1882,8 +2176,16 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 					     struct dpa_ipsec_policy_entry
 					     *policy_entry)
 {
-	xx_assert(sa);
-	xx_assert(policy_entry);
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy params handle\n"));
+		return -EFAULT;
+	}
 
 	if (list_empty(&sa->policy_headlist)) {
 		xx_pr_err(("Policy parameter list is empty\n"));
@@ -1901,6 +2203,17 @@ static int remove_policy(struct dpa_ipsec_sa *sa,
 {
 	int err;
 
+	/* sanity checks */
+	if (!sa) {
+		xx_pr_err(("Invalid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+
+	if (!policy_entry) {
+		xx_pr_err(("Invalid argument: NULL policy entry handle\n"));
+		return -EFAULT;
+	}
+
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		err = update_inbound_policy(sa, policy_entry, MNG_OP_REMOVE);
 		if (err < 0) {
@@ -1934,6 +2247,7 @@ static struct dpa_ipsec_sa *get_sa_from_sa_id(int sa_id)
 	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *sa = NULL;
 
+	/* sanity checks */
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err(("There is no dpa_ipsec component initialized\n"));
 		return NULL;
@@ -1956,7 +2270,11 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 	uint16_t cipher_alg, auth_alg;
 	int err = 0;
 
-	xx_assert(sa_params);
+	/* sanity checks */
+	if (!sa_params) {
+		xx_pr_err(("Invalid SA parameters handle\n"));
+		return -EINVAL;
+	}
 
 	/*
 	 * check crypto params:
@@ -2005,6 +2323,115 @@ static int check_sa_params(struct dpa_ipsec_sa_params *sa_params)
 	return 0;
 }
 
+static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
+		      struct dpa_ipsec_sa **new_sa,
+		      uint32_t *sa_id)
+{
+	struct dpa_ipsec_sa *sa;
+	uint32_t id;
+	int i;
+
+	/* sanity checks */
+	if (!dpa_ipsec) {
+		xx_pr_err(("Invalid argument: NULL DPA IPSec instance\n"));
+		return -EFAULT;
+	}
+
+	if (!new_sa) {
+		xx_pr_err(("Invalid argument: NULL SA holder\n"));
+		return -EFAULT;
+	}
+	*new_sa = NULL;
+
+	if (!sa_id) {
+		xx_pr_err(("Invalid argument: NULL ID holder\n"));
+		return -EFAULT;
+	}
+
+	/* Get an id for new SA */
+	if (cq_get_4bytes(dpa_ipsec->sa_mng.sa_id_cq, &id) < 0) {
+		xx_pr_err(("No more unused SA handles"));
+		return -EDOM;
+	}
+
+	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa; i++)
+		if (dpa_ipsec->used_sa_ids[i] == DPA_IPSEC_INVALID_SA_ID)
+			break;
+	if (i == dpa_ipsec->sa_mng.max_num_sa) {
+		xx_pr_err(("No more used SAs ID holders"));
+		cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
+		return -EDOM;
+	}
+
+	/* Acquire a preallocated SA structure */
+	sa = &(dpa_ipsec->sa_mng.sa[id]);
+	/* AV's TODO: create a clean function for preallocated SA structure
+	 * and call here that function */
+	sa->id = id;
+	sa->used_sa_index = i;
+	dpa_ipsec->used_sa_ids[i] = sa->id;
+	dpa_ipsec->num_used_sas++;
+
+	*sa_id = id;
+	*new_sa = sa;
+
+	return 0;
+}
+
+static int rollback_create_sa(struct dpa_ipsec_sa *sa, uint32_t id)
+{
+	int err_rb;
+	struct dpa_ipsec *dpa_ipsec;
+
+	if (!sa) {
+		xx_pr_err(("Inavlid argument: NULL SA handle\n"));
+		return -EFAULT;
+	}
+	dpa_ipsec = sa->dpa_ipsec;
+
+	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
+	    (sa->inbound_hash_entry != -1)) {
+		err_rb = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
+		if (err_rb < 0) {
+			xx_pr_err(("Couln't remove SA lookup table entry\n"));
+			return err_rb;
+		}
+	}
+	sa->inbound_hash_entry = -1;
+
+	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
+	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) &&
+	    (sa->inbound_indx_entry != -1)) {
+		err_rb = dpa_classif_table_delete_entry_by_ref(
+				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
+				sa->inbound_indx_entry);
+		if (err_rb < 0) {
+			xx_pr_err(("Couldn't remove post decrypt tbl entry\n"));
+			return err_rb;
+		}
+	}
+	sa->inbound_indx_entry = -1;
+
+	err_rb = remove_sa_fq_pair(sa);
+	if (err_rb < 0) {
+		xx_pr_err(("Could not remove SA FQs.\n"));
+		return err_rb;
+	}
+
+	/* Free the SA id and FlowID (for inbound SAs only).*/
+	put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+	if (sa->used_sa_index != -1) {
+		sa->dpa_ipsec->used_sa_ids[sa->used_sa_index] =
+					DPA_IPSEC_INVALID_SA_ID;
+		sa->used_sa_index = -1;
+		sa->dpa_ipsec->num_used_sas--;
+	}
+	cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
+
+
+	return 0;
+}
+
 int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 {
 	struct dpa_ipsec *dpa_ipsec = NULL;
@@ -2014,15 +2441,13 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	/* multiple DPA IPSec instances are not currently supported */
 	unused(dpa_ipsec_id);
 
+	/* sanity checks */
 	if (gbl_dpa_ipsec) {
 		xx_pr_err(("There is already an initialized dpa_ipsec component.\n"));
 		xx_pr_err(("Multiple DPA IPSec Instances aren't currently supported.\n"));
-		return -EAGAIN;
+		return -EPERM;
 	}
 
-	xx_sanity_check_return_value(params, "initialization parameters",
-				     -EINVAL);
-
 	/* make sure all user params are ok and init can start */
 	err = check_ipsec_params(params);
 	if (err < 0)
@@ -2051,6 +2476,7 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 	dpa_ipsec->used_sa_ids = xx_malloc(max_num_sa * sizeof(uint32_t));
 	if (!dpa_ipsec->used_sa_ids) {
 		xx_pr_err(("No more memory for used sa id's vector "));
+		free_resources();
 		return -ENOMEM;
 	}
 	memset(dpa_ipsec->used_sa_ids, DPA_IPSEC_INVALID_SA_ID,
@@ -2074,7 +2500,7 @@ int dpa_ipsec_free(int dpa_ipsec_id)
 	err = dpa_ipsec_flush_all_sa(0);
 	if (err < 0) {
 		xx_pr_err(("Could not remove all SAs from this instance!\n"));
-		return -EINVAL;
+		return err;
 	}
 
 	free_resources();
@@ -2087,10 +2513,9 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			struct dpa_ipsec_sa_params *sa_params, int *sa_id)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *sa;
 	uint32_t id;
-	int err = 0, err_rb = 0, i;
+	int err = 0, err_rb = 0;
 
 	/* multiple DPA IPSec instances are not currently supported */
 	unused(dpa_ipsec_id);
@@ -2100,47 +2525,28 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		return -EPERM;
 	}
 
-	if (!sa_params) {
-		xx_pr_err(("Invalid input params\n"));
+	if (!sa_id) {
+		xx_pr_err(("Invalid SA ID holder\n"));
 		return -EINVAL;
 	}
+	*sa_id = DPA_IPSEC_INVALID_SA_ID;
 
 	err = check_sa_params(sa_params);
 	if (err < 0)
 		return err;
 
-	*sa_id = DPA_IPSEC_INVALID_SA_ID;
 	dpa_ipsec = gbl_dpa_ipsec;
-	sa_mng = &dpa_ipsec->sa_mng;
 
-	/* Get an id for new SA */
-	if (cq_get_4bytes(sa_mng->sa_id_cq, &id) < 0) {
-		xx_pr_err(("No more unused SA handles"));
-		return -ERANGE;
+	err = get_new_sa(dpa_ipsec, &sa, &id);
+	if (err < 0) {
+		xx_pr_err(("Failed retrieveing a preallocated SA\n"));
+		return err;
 	}
 
-	/* Acquire a preallocated SA structure */
-	sa = &sa_mng->sa[id];
-	/* AV's TODO: create a clean function for preallocated SA structure
-	 * and call here that function */
-
 	/* Update internal SA structure */
-	sa->id = id;
 	sa->sa_dir = sa_params->sa_dir;
 	sa->dpa_ipsec = dpa_ipsec;
 
-	sa->used_sa_index = -1;
-	for (i = 0; i < sa->dpa_ipsec->sa_mng.max_num_sa; i++)
-		if (sa->dpa_ipsec->used_sa_ids[i] == DPA_IPSEC_INVALID_SA_ID)
-			break;
-	if (i == sa->dpa_ipsec->sa_mng.max_num_sa) {
-		xx_pr_err(("No more unused SAs"));
-		goto create_sa_err;
-	}
-	sa->used_sa_index = i;
-	sa->dpa_ipsec->used_sa_ids[i] = sa->id;
-	sa->dpa_ipsec->num_used_sas++;
-
 	/* Copy SA params into the internal SA structure */
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		sa->parent_sa = NULL;
@@ -2214,12 +2620,9 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			}
 
 			memset(&miss_action, 0, sizeof(miss_action));
-			miss_action.type = DPA_CLS_TBL_ACTION_ENQ;
-			miss_action.enq_params.hm = NULL;
-			miss_action.enq_params.new_fqid = sa->policy_miss_fqid;
-			miss_action.enq_params.override_fqid = TRUE;
-			miss_action.enq_params.policer_params = NULL;
-			miss_action.enable_statistics = FALSE;
+			fill_cls_action_enq(&action, FALSE,
+				sa->policy_miss_fqid, NULL);
+
 			err = dpa_classif_table_modify_miss_action(inbpol_td,
 								 &miss_action);
 			if (err < 0) {
@@ -2244,51 +2647,13 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	/* Something went wrong. Begin rollback */
  create_sa_err:
 
-	/* Prepare to return a invalid SA if rollback succeeds */
-	*sa_id = DPA_IPSEC_INVALID_SA_ID;
-
-	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
-	    (sa->inbound_hash_entry != -1)) {
-		err_rb = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
-		if (err_rb < 0) {
-			xx_pr_err(("Could not remove SA entry from lookup table.\n"));
-			*sa_id = id;
-		}
-	}
-	sa->inbound_hash_entry = -1;
-
-	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
-	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) &&
-	    (sa->inbound_indx_entry != -1)) {
-		err_rb = dpa_classif_table_delete_entry_by_ref(
-				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
-				sa->inbound_indx_entry);
-		if (err_rb < 0) {
-			xx_pr_err(("Could not remove entry in post decryption table\n"));
-			*sa_id = id;
-		}
-	}
-	sa->inbound_indx_entry = -1;
-
-	err_rb = remove_sa_fq_pair(sa);
-	if (err_rb < 0) {
-		xx_pr_err(("Could not remove SA FQs.\n"));
+	/* A invalid SA ID is returned if rollback succeeds and the actual
+	 * reserved SA ID if it fails. The SA ID can be used to try again to
+	 * free resources by calling dpa_ipsec_remove_sa
+	 */
+	err_rb = rollback_create_sa(sa, id);
+	if (err_rb < 0)
 		*sa_id = id;
-	}
-
-	/* RollBack succeeded. Free the SA id and FlowID (for inbound SAs only).
-	 * If any of these operations fail, do nothing, because this will
-	 * result in blocking the IDs (not a critical resource)*/
-	if (*sa_id == DPA_IPSEC_INVALID_SA_ID) {
-		put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
-		if (sa->used_sa_index != -1) {
-			sa->dpa_ipsec->used_sa_ids[sa->used_sa_index] =
-					DPA_IPSEC_INVALID_SA_ID;
-			sa->used_sa_index = -1;
-			sa->dpa_ipsec->num_used_sas--;
-		}
-		cq_put_4bytes(sa_mng->sa_id_cq, id);
-	}
 
 	return err;
 }
@@ -2314,7 +2679,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
-		return -EINVAL;
+		return -EPERM;
 	}
 
 	dpa_ipsec = gbl_dpa_ipsec;
@@ -2337,36 +2702,36 @@ int dpa_ipsec_remove_sa(int sa_id)
 			err = update_pre_sec_inbound_table(sa, MNG_OP_REMOVE);
 			if (err < 0) {
 				xx_pr_err(("Could not remove the PCD entry for this SA\n"));
-				return -EAGAIN;
+				return err;
 			}
 		}
 
 		/* AV's note: Wait until all the frames from the TO_SEC FQ are
 		 * consumed */
-		wait_until_fq_empty(sa->to_sec_fq, &timeout);
-		if (timeout == 0) {
+		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
+		if (err < 0) {
 			/* AV's note: TODO Add this SA to the SA garbage
 			 * collector list because we can't remove it until
 			 *  it's to SEC FQ is empty. */
-			return -EBUSY;
+			return err;
 		}
 
 		/* AV's note: Wait until all the frames from the FROM_SEC FQ are
 		 * consumed */
 		timeout = 10000;
-		wait_until_fq_empty(sa->from_sec_fq, &timeout);
-		if (timeout == 0) {
+		err = wait_until_fq_empty(sa->from_sec_fq, timeout);
+		if (err < 0) {
 			/* AV's note: TODO Add this SA to the SA garbage
 			 * collector list because we can't remove it until it's
 			 * to SEC FQ is empty. */
-			return -EBUSY;
+			return err;
 		}
 
 		/* Destroy the TO_SEC and FROM_SEC queues */
 		err = remove_sa_fq_pair(sa);
 		if (err != 0) {
 			xx_pr_err(("Could not remove the SEC frame queues\n"));
-			return -EAGAIN;
+			return err;
 		}
 
 		/* Free all memory used for this SA */
@@ -2381,7 +2746,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 					err = remove_policy(sa, pol_entr);
 					if (err < 0) {
 						xx_pr_err(("Couldn't remove policy entry"));
-						return -EAGAIN;
+						return err;
 					}
 				}
 			}
@@ -2389,7 +2754,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 							sa->inbound_indx_entry);
 			if (err < 0) {
 				xx_pr_err(("Could not remove SA entry in indexed table\n"));
-				return -EAGAIN;
+				return err;
 			}
 			put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
 		} else {
@@ -2398,7 +2763,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 							sa->inbound_indx_entry);
 				if (err < 0) {
 					xx_pr_err(("Could not remove SA entry in indexed table\n"));
-					return -EAGAIN;
+					return err;
 				}
 			}
 		}
@@ -2422,7 +2787,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 				err = remove_policy(sa, pol_entr);
 				if (err < 0) {
 					xx_pr_err(("Could not remove policy PCD entry\n"));
-					return -EAGAIN;
+					return err;
 				}
 			}
 		}
@@ -2431,7 +2796,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 		err = remove_sa_fq_pair(sa);
 		if (err < 0) {
 			xx_pr_err(("Could not remove the SEC frame queues\n"));
-			return -EAGAIN;
+			return err;
 		}
 
 		/* Mark as free index in used sa ids vector of this dpa ipsec
@@ -2454,7 +2819,10 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	struct dpa_ipsec_sa *sa;
 	int err;
 
-	xx_sanity_check_return_value(policy_params, "policy params", -EINVAL);
+	if (!policy_params) {
+		xx_pr_err(("Invalid policy params handle\n"));
+		return -EINVAL;
+	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
@@ -2466,10 +2834,11 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 	 * Store all the in/out policies into the SA policy param list in order
 	 * to know what to remove when SA expires.
 	 */
-	policy_entry = store_policy_param_to_sa_pol_list(sa, policy_params);
-	if (!policy_entry) {
+	err = store_policy_param_to_sa_pol_list(sa, policy_params,
+				&policy_entry);
+	if (err < 0) {
 		xx_pr_err(("Could not store the policy in the SA\n"));
-		return -EINVAL;
+		return err;
 	}
 
 	/*Insert inbound or outbound policy for this SA depending on it's type*/
@@ -2478,16 +2847,18 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		if (err < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			xx_pr_err(("Could not add the inbound policy\n"));
+			xx_free(policy_entry);
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		err = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
 		if (err < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			xx_pr_err(("Could not add the outbound policy\n"));
+			xx_free(policy_entry);
 		}
 	}
 
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(dpa_ipsec_sa_add_policy);
 
@@ -2498,7 +2869,10 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 	struct dpa_ipsec_sa *sa;
 	int err = 0;
 
-	xx_sanity_check_return_value(policy_params, "policy params", -EINVAL);
+	if (!policy_params) {
+		xx_pr_err(("Invalid policy params handle\n"));
+		return -EINVAL;
+	}
 
 	sa = get_sa_from_sa_id(sa_id);
 	if (!sa) {
@@ -2506,10 +2880,11 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 		return -EINVAL;
 	}
 
-	policy_entry = find_policy_in_sa_policy_list(sa, policy_params);
-	if (!policy_entry) {
+	err = find_policy_in_sa_policy_list(sa, policy_params,
+				&policy_entry);
+	if (err < 0) {
 		xx_pr_err(("Could not find policy entry in SA policy list\n"));
-		return -EAGAIN;
+		return err;
 	}
 
 	/* found the policy entry in SA policy parameter list;
@@ -2531,24 +2906,28 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *old_sa, *new_sa;
 	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
-	uint32_t id, i;
+	uint32_t id;
 	int err = 0, timeout = 10000;
 
 	unused(rekey_event_cb);
 	unused(auto_rmv_old_sa);
 
-	if ((!sa_params) || (sa_params->sa_bpid > MAX_BUFFER_POOL_ID)) {
-		xx_pr_err(("Invalid input params\n"));
-		return -EINVAL;
-	}
-
-	*new_sa_id = DPA_IPSEC_INVALID_SA_ID;
 	if (!gbl_dpa_ipsec) {
 		xx_pr_err(("There is no dpa_ipsec instance initialized\n"));
 		return -EINVAL;
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
+	if (!new_sa_id) {
+		xx_pr_err(("Invalid SA ID holder\n"));
+		return -EINVAL;
+	}
+	*new_sa_id = DPA_IPSEC_INVALID_SA_ID;
+
+	err = check_sa_params(sa_params);
+	if (err < 0)
+		return err;
+
 	old_sa = get_sa_from_sa_id(sa_id);
 	if (!old_sa) {
 		xx_pr_err(("Invalid SA handle provided\n"));
@@ -2556,29 +2935,16 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	}
 
 	sa_mng = &dpa_ipsec->sa_mng;
-	/* Get an id for new SA */
-	if (cq_get_4bytes(sa_mng->sa_id_cq, &id) < 0) {
-		xx_pr_err(("No more unused SA's handles\n"));
-		return -ENOMEM;
+
+	err = get_new_sa(dpa_ipsec, &new_sa, &id);
+	if (err < 0) {
+		xx_pr_err(("Failed retrieveing a preallocated SA\n"));
+		return err;
 	}
 
-	/* Aquire an preallocated SA structure  */
-	new_sa = &sa_mng->sa[id];
 	/* Update the new SA structure */
 	new_sa->dpa_ipsec = old_sa->dpa_ipsec;
-	new_sa->id = id;
 	new_sa->inbound_flowid = old_sa->inbound_flowid;
-	new_sa->used_sa_index = -1;
-	for (i = 0; i < new_sa->dpa_ipsec->sa_mng.max_num_sa; i++)
-		if (new_sa->dpa_ipsec->used_sa_ids[i] == -1)
-			break;
-	if (i == new_sa->dpa_ipsec->sa_mng.max_num_sa) {
-		xx_pr_err(("No more unused SAs"));
-		return -ERANGE;
-	}
-	new_sa->used_sa_index = i;
-	new_sa->dpa_ipsec->used_sa_ids[i] = new_sa->id;
-	new_sa->dpa_ipsec->num_used_sas++;
 	new_sa->inbound_indx_entry = -1;
 
 	/* Copy SA params into the internal SA structure */
@@ -2644,7 +3010,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		}
 		/* AV's note: Wait until all the frames from the old TO SEC FQ
 		 * are consumed and then schedule the new TO SEC FQ */
-		wait_until_fq_empty(old_sa->to_sec_fq, &timeout);
+		wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 
 		qman_schedule_fq(new_sa->to_sec_fq);
 
@@ -2742,7 +3108,7 @@ void sa_rekeying_work_func(struct work_struct *work)
 			/* AV's note: Wait until all the frames from the old
 			 * TO SEC FQ are consumed and then schedule the new TO
 			 * SEC FQ */
-			wait_until_fq_empty(old_sa->to_sec_fq, &timeout);
+			wait_until_fq_empty(old_sa->to_sec_fq, timeout);
 
 			/* If timeout has reached 0 it means that there are
 			 * still frames inside OLD SA TO SEC Frame Queue,
@@ -2870,15 +3236,15 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 		return -EINVAL;
 	}
 
+	if (!num_pol) {
+		xx_pr_err(("Invalid num_pol parameter handle\n"));
+		return -EINVAL;
+	}
+
 	if (!policy_params) {
-		if (!num_pol) {
-			xx_pr_err(("Invalid input parameters"));
-			return -EINVAL;
-		} else {
-			/* get the number of policies for SA with id sa_id */
-			*num_pol = get_policy_count_for_sa(sa);
-			return 0;
-		}
+		/* get the number of policies for SA with id sa_id */
+		*num_pol = get_policy_count_for_sa(sa);
+		return 0;
 	}
 
 	err = copy_all_policies(sa, policy_params, *num_pol);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index ad9aa37..9412f27 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -49,6 +49,15 @@
 
 
 /* MACRO declaration */
+#define PCD_DF_ACTION	{				\
+	/* DPA_IPSEC_DF_ACTION_DISCARD */		\
+	e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET,	\
+	/* DPA_IPSEC_DF_ACTION_OVERRIDE */		\
+	e_FM_PCD_MANIP_FRAGMENT_PACKECT,		\
+	/* DPA_IPSEC_DF_ACTION_CONTINUE */		\
+	e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG		\
+}
+
 #define OP_PCL_IPSEC_INVALID_ALG_ID	0xFFFF
 
 #define IPSEC_ALGS_ENTRY(enc, auth)	{		\
@@ -225,7 +234,7 @@ struct dpa_ipsec_sa {
 	uint32_t spi;	/* IPsec Security parameter index		      */
 	struct dpa_ipsec_ip_address src_addr;  /* Source IP address           */
 	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
-	uint32_t out_flow_id; /* Value used to classify frames encrypted
+	uint16_t outbound_flowid; /* Value used to classify frames encrypted
 				 with this SA				      */
 	bool use_udp_encap;   /* NAT-T is activated for this SA.
 				Only for inbound  SAs			      */
-- 
1.7.5.4

