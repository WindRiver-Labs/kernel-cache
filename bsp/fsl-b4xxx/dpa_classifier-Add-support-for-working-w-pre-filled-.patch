From 1e044bcb71349cafa786c3c9078875ef42612819 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 29 Oct 2012 21:34:14 +0000
Subject: [PATCH 341/518] dpa_classifier: Add support for working w/
 pre-filled Cc nodes

DPA Classifier had a limitation related to the Cc nodes provided as
a base for the tables: it only knew how to work with empty Cc nodes.
Recently, a new requirement stated that DPA Classifier should do its
best to manage also entries that were added the Cc nodes prior to calling
the dpa_classif_table_create function (so called pre-filled Cc nodes).
This support was added now and it requires the user to specify the
number of entries that are already populated in the base Cc node. The
feature makes sense for exact match and HASH tables only. Indexed
tables are pre-populated by definition.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  488 ++++++++++++++++----
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    2 +
 include/linux/fsl_dpa_classifier.h                 |    7 +
 3 files changed, 413 insertions(+), 84 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 73d62b422..b475a62 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -124,49 +124,78 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 	/* Copy over the table params into the control block */
 	memcpy(&ptable->params, params, sizeof(struct dpa_cls_tbl_params));
 
-	if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY) {
-		ptable->shadow_table =
-			kzalloc(sizeof(*ptable->shadow_table), GFP_KERNEL);
-		if (!ptable->shadow_table) {
-			pr_err("ERROR: %s, %s (%d): No more memory for DPA "
-				"classifier shadow table.\n", __FILE__,
-				__func__, __LINE__);
-			err = -ENOMEM;
-			goto dpa_classif_table_create_error;
-		}
-	}
-
 	switch (ptable->params.type) {
 	case DPA_CLS_TBL_INDEXED:
 		ptable->int_cc_nodes_count = 1;
-		if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY)
+		if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY) {
+			ptable->shadow_table =
+				kzalloc(sizeof(*ptable->shadow_table),
+					GFP_KERNEL);
+			if (!ptable->shadow_table) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"DPA classifier shadow table.\n",
+					__FILE__, __func__, __LINE__);
+				err = -ENOMEM;
+				goto dpa_classif_table_create_error;
+			}
 			/*
 			 * Shadow table is directly indexed with the index in
 			 * the entry key
 			 */
 			ptable->shadow_table->size =
 				ptable->params.indexed_params.entries_cnt;
+		}
+
 		break;
 
 	case DPA_CLS_TBL_EXACT_MATCH:
 		ptable->int_cc_nodes_count = 1;
 		if (ptable->params.entry_mgmt ==
-				DPA_CLS_TBL_MANAGE_BY_KEY)
+				DPA_CLS_TBL_MANAGE_BY_KEY) {
+			ptable->shadow_table =
+				kzalloc(sizeof(*ptable->shadow_table),
+					GFP_KERNEL);
+			if (!ptable->shadow_table) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"DPA classifier shadow table.\n",
+					__FILE__, __func__, __LINE__);
+				err = -ENOMEM;
+				goto dpa_classif_table_create_error;
+			}
+
 			/* Set shadow table size */
 			ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
+		}
+
 		break;
 
 	case DPA_CLS_TBL_HASH:
-		ptable->int_cc_nodes_count =
-			ptable->params.hash_params.num_sets;
-		if (ptable->params.entry_mgmt == DPA_CLS_TBL_MANAGE_BY_KEY)
-			/*
-			 * Shadow table is indexed using a CRC8 HASH on the
-			 * key
-			 */
-			ptable->shadow_table->size =
+		if (!ptable->params.prefilled_entries) {
+			ptable->int_cc_nodes_count =
+				ptable->params.hash_params.num_sets;
+			if (ptable->params.entry_mgmt ==
+						DPA_CLS_TBL_MANAGE_BY_KEY) {
+				ptable->shadow_table =
+					kzalloc(sizeof(*ptable->shadow_table),
+						GFP_KERNEL);
+				if (!ptable->shadow_table) {
+					pr_err("ERROR: %s, %s (%d): No more "
+						"memory for DPA classifier "
+						"shadow table.\n", __FILE__,
+						__func__, __LINE__);
+					err = -ENOMEM;
+					goto dpa_classif_table_create_error;
+				}
+
+				/*
+				 * Shadow table is indexed using a CRC8 HASH on
+				 * the key
+				 */
+				ptable->shadow_table->size =
 					DPA_CLS_TBL_MAXSHADOWTABLESIZE;
+			}
+		}
 		break;
 	default:
 		pr_err("ERROR: %s, %s (%d): Unsupported DPA Classifier table "
@@ -423,7 +452,7 @@ int dpa_classif_table_insert_entry(int				td,
 						entry_id);
 		break;
 	default:
-		BUG_ON(0);
+		BUG_ON(1);
 	}
 
 	mutex_unlock(&ptable->access);
@@ -436,8 +465,16 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
 	int entry_id;
-	int ret;
+	int ret = 0;
 	struct dpa_cls_table *ptable;
+	t_Error err;
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t new_key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t new_mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t *mask;
+	uint8_t *new_mask;
+	t_FmPcdCcKeyParams key_params;
 
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
@@ -468,11 +505,165 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
-		mutex_unlock(&ptable->access);
-		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
-			"associated with this lookup key.\n", __FILE__,
-			__func__, __LINE__);
-		return entry_id;
+		if ((entry_id == -ENODEV) &&
+					(ptable->params.prefilled_entries)) {
+			/*
+			 * This entry may have been added to the Cc node before
+			 * the DPA Classifier was created. Try to modify it by
+			 * key directly using the FMan driver.
+			 */
+			memset(&key_params, 0, sizeof(key_params));
+			switch (mod_params->type) {
+			case DPA_CLS_TBL_MODIFY_ACTION:
+				xx_sanity_check_return_value(mod_params->action,
+					"mod_params.action", -EINVAL);
+
+				ret = action_to_next_engine_params(
+						mod_params->action,
+						&key_params.ccNextEngineParams);
+				if (ret < 0) {
+					mutex_unlock(&ptable->access);
+					return ret;
+				}
+
+				memcpy(key_data, key->byte, key->size);
+				if (key->mask) {
+					memcpy(mask_data, key->mask, key->size);
+					mask = mask_data;
+				} else
+					mask = NULL;
+
+		if (ptable->params.type == DPA_CLS_TBL_EXACT_MATCH) {
+			err = FM_PCD_MatchTableFindNModifyNextEngine(
+				(t_Handle)ptable->int_cc_node[0].cc_node,
+				key->size,
+				key_data,
+				mask,
+				&key_params.ccNextEngineParams);
+			if (err != E_OK) {
+				mutex_unlock(&ptable->access);
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableFindNModifyNextEngine"
+					" failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
+		} else { /* Table is HASH */
+			err = FM_PCD_HashTableModifyNextEngine(
+				(t_Handle)ptable->params.cc_node,
+				key->size,
+				key_data,
+				&key_params.ccNextEngineParams);
+			if (err != E_OK) {
+				mutex_unlock(&ptable->access);
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_HashTableModifyNextEngine "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
+		}
+
+				break;
+			case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
+				/*
+				 * Only exact match tables support this type of
+				 * modification.
+				 */
+				xx_sanity_check_return_value(mod_params->action,
+					"mod_params.action", -EINVAL);
+
+				ret = action_to_next_engine_params(
+						mod_params->action,
+						&key_params.ccNextEngineParams);
+				if (ret < 0) {
+					mutex_unlock(&ptable->access);
+					return ret;
+				}
+
+				/* Fall into DPA_CLS_TBL_MODIFY_KEY */
+			case DPA_CLS_TBL_MODIFY_KEY:
+				/*
+				 * Only exact match tables support this type of
+				 * modification.
+				 */
+				xx_sanity_check_return_value(mod_params->key,
+					"mod_params.key", -EINVAL);
+
+				memcpy(key_data, key->byte, key->size);
+				if (key->mask) {
+					memcpy(mask_data, key->mask, key->size);
+					mask = mask_data;
+				} else
+					mask = NULL;
+
+				memcpy(new_key_data, mod_params->key->byte,
+					mod_params->key->size);
+				if (mod_params->key->mask) {
+					memcpy(new_mask_data,
+						mod_params->key->mask,
+						mod_params->key->size);
+					new_mask = new_mask_data;
+				} else
+					new_mask = NULL;
+
+		if (mod_params->type == DPA_CLS_TBL_MODIFY_KEY) {
+			err = FM_PCD_MatchTableFindNModifyKey(
+				(t_Handle)ptable->int_cc_node[0].cc_node,
+				key->size,
+				key_data,
+				mask,
+				new_key_data,
+				new_mask);
+			if (err != E_OK) {
+				mutex_unlock(&ptable->access);
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableFindNModifyKey "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
+		} else {
+			key_params.p_Key	= new_key_data;
+			key_params.p_Mask	= new_mask;
+			err = FM_PCD_MatchTableFindNModifyKeyAndNextEngine(
+				(t_Handle)ptable->int_cc_node[0].cc_node,
+				key->size,
+				key_data,
+				mask,
+				&key_params);
+			if (err != E_OK) {
+				mutex_unlock(&ptable->access);
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableFindNModifyKeyAndNextEngine "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+				return -EBUSY;
+			}
+		}
+
+				break;
+			}
+
+			mutex_unlock(&ptable->access);
+			return ret;
+		} else {
+			mutex_unlock(&ptable->access);
+			pr_err("ERROR: %s, %s (%d): Unable to determine "
+				"entry_id associated with this lookup key.\n",
+				__FILE__, __func__, __LINE__);
+			return entry_id;
+		}
 	}
 
 	ret = table_modify_entry_by_ref(ptable, entry_id, mod_params);
@@ -724,7 +915,7 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 			memcpy(key->byte,
 				mod_params->key->byte,
 				key->size);
-			if (key->mask)
+			if ((key->mask) && (mod_params->key->mask))
 				memcpy(key->mask,
 					mod_params->key->mask,
 					key->size);
@@ -744,8 +935,14 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 				const struct dpa_offload_lookup_key	*key)
 {
 	int entry_id;
-	int err;
+	int err = 0;
+	t_Error error;
 	struct dpa_cls_table *ptable;
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t *mask;
+	struct list_head *list_current;
+	struct dpa_cls_tbl_entry *index_entry;
 
 	xx_sanity_check_return_value(key, "key", -EINVAL);
 	xx_sanity_check_return_value(key->byte, "key", -EINVAL);
@@ -766,11 +963,87 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 			ptable, key);
 	if (entry_id < 0) {
-		mutex_unlock(&ptable->access);
-		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
-			"associated with this lookup key.\n", __FILE__,
-			__func__, __LINE__);
-		return entry_id;
+		if ((entry_id == -ENODEV) &&
+				(ptable->params.prefilled_entries)) {
+			/*
+			 * This entry may have been added to the Cc node before
+			 * the DPA Classifier was created. Try to delete it by
+			 * key directly using the FMan driver.
+			 */
+
+			memcpy(key_data, key->byte, key->size);
+			if (key->mask) {
+				memcpy(mask_data, key->mask, key->size);
+				mask = mask_data;
+			} else
+				mask = NULL;
+
+			switch (ptable->params.type) {
+			case DPA_CLS_TBL_EXACT_MATCH:
+
+			error = FM_PCD_MatchTableFindNRemoveKey(
+				(t_Handle)ptable->int_cc_node[0].cc_node,
+				key->size,
+				key_data,
+				mask);
+			if (error != E_OK) {
+				mutex_unlock(&ptable->access);
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableFindNRemoveKey"
+					" failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				return -EBUSY;
+			}
+
+			/* Update the index management for all entries. */
+			list_current = ptable->entry_list.next;
+			while (list_current != &ptable->entry_list) {
+				index_entry = list_entry(list_current,
+						struct dpa_cls_tbl_entry,
+						list_node);
+				index_entry->entry_index--;
+				list_current = list_current->next;
+			}
+
+				break;
+			case DPA_CLS_TBL_HASH:
+
+				error = FM_PCD_HashTableRemoveKey(
+					(t_Handle)ptable->params.cc_node,
+					key->size,
+					key_data);
+				if (error != E_OK) {
+					mutex_unlock(&ptable->access);
+					pr_err("ERROR: %s, %s (%d): "
+						"FM_PCD_HashTableRemoveKey"
+						" failed.\n", __FILE__,
+						__func__, __LINE__);
+					pr_err("ERROR: %s, %s (%d): FMan "
+						"driver call failed.\n",
+						__FILE__, __func__, __LINE__);
+					return -EBUSY;
+				}
+
+				/* No entry management at all. */
+
+				break;
+			default:
+				BUG_ON(1);
+				break;
+			}
+
+			mutex_unlock(&ptable->access);
+			return err;
+		} else {
+			mutex_unlock(&ptable->access);
+			pr_err("ERROR: %s, %s (%d): Unable to determine "
+				"entry_id associated with this lookup key.\n",
+				__FILE__, __func__, __LINE__);
+			return entry_id;
+		}
 	}
 
 	err = table_delete_entry_by_ref(ptable, entry_id);
@@ -925,7 +1198,7 @@ int dpa_classif_table_lookup_by_key(int				td,
 
 	if (!ptable->shadow_table) {
 		mutex_unlock(&ptable->access);
-		pr_err("ERROR: %s, %s (%d): Cannot lookup in a "
+		pr_err("ERROR: %s, %s (%d): Cannot lookup by key in a "
 			"DPA_CLS_TBL_MANAGE_BY_REF table.\n", __FILE__,
 			__func__, __LINE__);
 		return -ENOSYS;
@@ -1050,6 +1323,11 @@ static int flush_table(struct dpa_cls_table *ptable)
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
+	if ((ptable->params.type == DPA_CLS_TBL_HASH) &&
+			(ptable->params.prefilled_entries))
+		/* Flush not available for pre-filled HASH tables */
+		return 0;
+
 	if (list_empty(&ptable->entry_list))
 		/* Table is already empty. Nothing to do */
 		return 0;
@@ -1144,6 +1422,15 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	mutex_lock(&ptable->access);
 	release_desc_table(&table_array);
 
+	if ((ptable->params.type == DPA_CLS_TBL_HASH) &&
+			(ptable->params.prefilled_entries)) {
+		mutex_unlock(&ptable->access);
+		/* get_entry_stats not supported on prefilled HASH tables */
+		pr_err("ERROR: %s, %s (%d): get_entry_stats_by_key is not "
+			"supported on prefilled HASH tables.\n", __FILE__,
+			__func__, __LINE__);
+		return -ENOSYS;
+	}
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
 		mutex_unlock(&ptable->access);
@@ -1244,6 +1531,9 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 	BUG_ON(!cls_table);
 
 	/* Allocate the necessary table management tools */
+	if (!cls_table->int_cc_nodes_count)
+		return 0;
+
 	cls_table->int_cc_node =
 		kzalloc(cls_table->int_cc_nodes_count *
 			sizeof(*cls_table->int_cc_node), GFP_KERNEL);
@@ -1295,6 +1585,7 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 	/* Indexed table is always pre-populated: */
 	cls_table->int_cc_node[0].used =
 		cls_table->params.indexed_params.entries_cnt;
+	cls_table->params.prefilled_entries = 0;
 
 	/* Allocate and initialize the index management array */
 	cls_table->entries_cnt = cls_table->params.indexed_params.entries_cnt;
@@ -1377,54 +1668,58 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		return err;
 
 	cc_node	= (t_Handle)cls_table->params.cc_node;
-	for (i = 0; i < cls_table->params.hash_params.num_sets; i++) {
-		/*
-		 * Acquire next engine parameters for each index entry in the
-		 * main HASH Cc node.
-		 */
-		if (FM_PCD_MatchTableGetNextEngine(cc_node,
+	if (!cls_table->params.prefilled_entries) {
+		for (i = 0; i < cls_table->params.hash_params.num_sets; i++) {
+			/*
+			 * Acquire next engine parameters for each index entry
+			 * in the main HASH Cc node.
+			 */
+			if (FM_PCD_MatchTableGetNextEngine(cc_node,
 						i,
 						&next_engine_params) != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableGetNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableGetNextEngine "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				err = -EBUSY;
+				goto table_init_hash_error;
+			}
+
+			/*
+			 * Store the HASH set handle into the internal Cc nodes
+			 * data structures.
+			 */
+			BUG_ON(next_engine_params.nextEngine != e_FM_PCD_CC);
+			cls_table->int_cc_node[i].cc_node =
+				next_engine_params.params.ccParams.h_CcNode;
+			cls_table->int_cc_node[i].table_size =
+				cls_table->params.hash_params.max_ways;
+		}
+
+		/* Allocate the index management array */
+		cls_table->entries_cnt = cls_table->params.hash_params.
+			num_sets * cls_table->params.hash_params.max_ways;
+		cls_table->entry = kzalloc(cls_table->entries_cnt *
+					sizeof(*cls_table->entry), GFP_KERNEL);
+		if (!cls_table->entry) {
+			pr_err("ERROR: %s, %s (%d): No more memory for DPA "
+				"Classifier table index management.\n",
 				__FILE__, __func__, __LINE__);
-			err = -EBUSY;
+			cls_table->entries_cnt	= 0;
+			err			= -ENOMEM;
 			goto table_init_hash_error;
 		}
+		INIT_LIST_HEAD(&cls_table->entry_list);
 
-		/*
-		 * Store the HASH set handle into the internal Cc nodes data
-		 * structures.
-		 */
-		BUG_ON(next_engine_params.nextEngine != e_FM_PCD_CC);
-		cls_table->int_cc_node[i].cc_node =
-			next_engine_params.params.ccParams.h_CcNode;
-		cls_table->int_cc_node[i].table_size =
-			cls_table->params.hash_params.max_ways;
+		cls_table->hash_mask =
+			(uint64_t)(cls_table->params.hash_params.num_sets - 1)
+			<< (8 * (6 - cls_table->params.hash_params.hash_offs)
+			+ 4) ;
 	}
 
-	/* Allocate the index management array */
-	cls_table->entries_cnt = cls_table->params.hash_params.num_sets *
-		cls_table->params.hash_params.max_ways;
-	cls_table->entry =
-		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
-			GFP_KERNEL);
-	if (!cls_table->entry) {
-		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
-			"table index management.\n", __FILE__, __func__,
-			__LINE__);
-		cls_table->entries_cnt	= 0;
-		err			= -ENOMEM;
-		goto table_init_hash_error;
-	}
-	INIT_LIST_HEAD(&cls_table->entry_list);
-
-	cls_table->hash_mask =
-		(uint64_t)(cls_table->params.hash_params.num_sets - 1) <<
-		(8 * (6 - cls_table->params.hash_params.hash_offs) + 4) ;
-
 	return err;
 
 table_init_hash_error:
@@ -1448,6 +1743,7 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	cls_table->int_cc_node[0].cc_node = cls_table->params.cc_node;
 	cls_table->int_cc_node[0].table_size =
 		cls_table->params.exact_match_params.entries_cnt;
+	cls_table->int_cc_node[0].used = cls_table->params.prefilled_entries;
 
 	/* Allocate the index management array */
 	cls_table->entries_cnt =
@@ -1743,7 +2039,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			}
 			/* If there are such entries in the list */
 			if (&index_entry->list_node != &cls_table->entry_list) {
-				/* Shall add this entry in the position of
+				/* We shall add this entry in the position of
 				 * the [current] one */
 				cls_table->entry[k].entry_index =
 					index_entry->entry_index;
@@ -1903,6 +2199,26 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if (errno < 0)
 		return errno;
 
+	if (cls_table->params.prefilled_entries) {
+		/*
+		 * If pre-filled entries exist, fall through to the low level
+		 * driver only
+		 */
+		err = FM_PCD_HashTableAddKey(
+				(t_Handle)cls_table->params.cc_node,
+				cls_table->params.hash_params.key_size,
+				&key_params);
+		if (err != E_OK) {
+			pr_err("ERROR: %s, %s (%d): FM_PCD_HashTableAddKey "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
+
+		return 0;
+	}
+
 	hash_set_index = crc64_init();
 	hash_set_index = crc64_compute(key_data,
 				cls_table->params.hash_params.key_size,
@@ -2212,6 +2528,11 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 		return (int)key->byte[0];
 	}
 
+	if ((cls_table->params.type == DPA_CLS_TBL_HASH) &&
+			(cls_table->params.prefilled_entries))
+		/* Cannot lookup in a prefilled HASH table */
+		return -ENODEV;
+
 	if (!cls_table->shadow_table) {
 		pr_err("ERROR: %s, %s (%d): Cannot use runtime functions based "
 			"on key in a DPA_CLS_TBL_MANAGE_BY_REF table.\n",
@@ -3637,7 +3958,7 @@ static int remove_hm_update_params(struct dpa_cls_hm *premove_hm)
 		break;
 	default:
 		/* Should never get here */
-		BUG_ON(true);
+		BUG_ON(1);
 		break;
 	}
 
@@ -3752,7 +4073,7 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 
 static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 {
-	unsigned int size = 0;
+	uint8_t size = 0;
 	uint8_t offset = 0;
 	uint8_t *pdata = NULL;
 	struct dpa_cls_hm_node *hm_node;
@@ -3829,7 +4150,7 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 		break;
 	default:
 		/* Should never get here */
-		BUG_ON(true);
+		BUG_ON(1);
 	}
 
 	hm_node->params.u.hdr.insrtParams.u.generic.offset	= offset;
@@ -3926,7 +4247,6 @@ int dpa_classif_modify_insert_hm(int hmd,
 			memcpy(&pdata[offset],
 		&pinsert_hm->insert_params.eth.eth_header.h_proto,
 				ETHERTYPE_SIZE);
-			offset = 0;
 		} else
 			/* Copy the entire Ethernet header */
 			memcpy(pdata,
@@ -3963,7 +4283,7 @@ int dpa_classif_modify_insert_hm(int hmd,
 		break;
 	default:
 		/* Should never get here */
-		BUG_ON(true);
+		BUG_ON(1);
 	}
 
 	if (update) {
@@ -4342,7 +4662,7 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 				replaceType =
 				e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4;
 			hm_node->params.u.hdr.customParams.u.ipHdrReplace.
-				hdrSize = sizeof(struct iphdr);
+				hdrSize = (uint8_t)sizeof(struct iphdr);
 			memcpy(hm_node->params.u.hdr.customParams.u.
 				ipHdrReplace.hdr,
 				&pupdate_hm->update_params.replace.new_ipv4_hdr,
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index a75b212..6a54127 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -2146,6 +2146,8 @@ int dpa_cls_tbl_params_compatcpy(
 
 	kparam->table_params.type	= uparam->table_params.type;
 	kparam->table_params.entry_mgmt	= uparam->table_params.entry_mgmt;
+	kparam->table_params.prefilled_entries =
+					uparam->table_params.prefilled_entries;
 
 	switch (uparam->table_params.type) {
 	case DPA_CLS_TBL_INDEXED:
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 93be0a2..528ff15 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -167,6 +167,13 @@ struct dpa_cls_tbl_params {
 		/* Parameters for exact match table */
 		struct dpa_cls_tbl_exact_match_params	exact_match_params;
 	};
+
+	/*
+	 * Number of entries in the table which are pre-filled from the
+	 * skeleton. The assumption is always that these entries are the first
+	 * entries in the table and with the highest priority.
+	 */
+	unsigned int				prefilled_entries;
 };
 
 /* Policer parameters */
-- 
1.7.5.4

