From 80dd3f39a5c207aa4082e1aff036563eb5ef9abd Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:59:45 +0000
Subject: [PATCH 260/518] dpa_stats: Added support for modifying a class
 member

Class counters members can be modified at run-time: invalidate,
set or update a class member.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  155 +++++++++++++++++++++++++++
 include/linux/fsl_dpa_stats.h               |   46 ++++++++
 2 files changed, 201 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index c24a1e0..836c85b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -1626,6 +1626,106 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
+		int member_index, struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct dpa_stats_cnt_classif_tbl_cb *tbl_cb = &cnt_cb->tbl_cb;
+	uint32_t i = 0;
+	int err = 0;
+
+	/* Check that counter is of type Classifier table */
+	if (cnt_cb->type != DPA_STATS_CNT_CLASSIF_TBL) {
+		pr_err("Operation permitted only on counter "
+				"type DPA_STATS_CNT_CLASSIF_TBL\n");
+		return -EINVAL;
+	}
+
+	/* Check that member index does not exceeds class size */
+	if ((member_index < 0) || (member_index >= cnt_cb->tbl_cb.keys_num)) {
+		pr_err("Member index is out of class counter size\n");
+		return -EINVAL;
+	}
+
+	/* Release the old key memory */
+	kfree(tbl_cb->keys[member_index].key.byte);
+	tbl_cb->keys[member_index].key.byte = NULL;
+
+	kfree(tbl_cb->keys[member_index].key.mask);
+	tbl_cb->keys[member_index].key.mask = NULL;
+
+	/* Reset the statistics */
+	for (i = 0; i < tbl_cb->info.stats_num; i++) {
+		tbl_cb->info.stats[member_index][i] = 0;
+		tbl_cb->info.last_stats[member_index][i] = 0;
+	}
+
+	if (!params->key.byte) {
+		/* Mark the key as invalid */
+		tbl_cb->keys[member_index].valid = FALSE;
+
+	} else {
+		tbl_cb->keys[member_index].valid = TRUE;
+
+		if (params->type == DPA_STATS_CLS_MEMBER_SINGLE_KEY) {
+			/* Copy the key descriptor */
+			err = copy_key_descriptor(&params->key,
+					&tbl_cb->keys[member_index].key);
+			if (err != 0) {
+				pr_err("Unable to copy key descriptor\n");
+				return -EINVAL;
+			}
+
+		} else {
+			err = set_cls_cnt_classif_tbl_pair(tbl_cb->td,
+					&params->pair,
+					&tbl_cb->keys[member_index]);
+			if (err != 0) {
+				pr_err("Unable to copy key descriptor\n");
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
+		int member_idx, struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct dpa_stats_cnt_ipsec_cb *ipsec_cb = &cnt_cb->ipsec_cb;
+	uint32_t i = 0;
+
+	/* Check that counter is of type IPSec */
+	if (cnt_cb->type != DPA_STATS_CNT_IPSEC) {
+		pr_err("Operation permitted only on counter "
+				"type DPA_STATS_CNT_IPSEC\n");
+		return -EINVAL;
+	}
+
+	/* Check that member index does not exceeds class size */
+	if ((member_idx < 0) || (member_idx >= cnt_cb->ipsec_cb.sa_id_num)) {
+		pr_err("Member index is out of class counter size\n");
+		return -EINVAL;
+	}
+
+	/* Reset the statistics */
+	for (i = 0; i < ipsec_cb->info.stats_num; i++) {
+		ipsec_cb->info.stats[member_idx][i] = 0;
+		ipsec_cb->info.last_stats[member_idx][i] = 0;
+	}
+
+	if (params->sa_id == DPA_OFFLD_INVALID_OBJECT_ID) {
+		/* Mark that corresponding SA id as invalid */
+		ipsec_cb->valid[member_idx] = FALSE;
+	} else {
+		/* Mark the corresponding SA id as valid */
+		ipsec_cb->valid[member_idx] = TRUE;
+		ipsec_cb->sa_id[member_idx] = params->sa_id;
+	}
+
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -2293,6 +2393,61 @@ create_counter_err:
 }
 EXPORT_SYMBOL(dpa_stats_create_class_counter);
 
+int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
+		const struct dpa_stats_cls_member_params *params,
+		int member_index)
+{
+	struct dpa_stats *dpa_stats = NULL;
+	struct dpa_stats_cnt_cb *cnt_cb = NULL;
+	int err = 0;
+
+	if (!gbl_dpa_stats) {
+		pr_err("dpa_stats component is not initialized\n");
+		return -EPERM;
+	}
+
+	dpa_stats = gbl_dpa_stats;
+
+	if ((dpa_stats_cnt_id < 0) ||
+			(dpa_stats_cnt_id > dpa_stats->config.max_counters)) {
+		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		return -EINVAL;
+	}
+
+	/* Get counter control block */
+	cnt_cb = &dpa_stats->cnts_cb[dpa_stats_cnt_id];
+
+	/* Validity check for this Counter */
+	if (cnt_cb->cnt_index == DPA_OFFLD_INVALID_OBJECT_ID) {
+		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		return -EINVAL;
+	}
+
+	if ((params->type == DPA_STATS_CLS_MEMBER_SINGLE_KEY) ||
+		(params->type == DPA_STATS_CLS_MEMBER_PAIR_KEY)) {
+		/* Modify classifier table class member */
+		err = set_classif_tbl_member(params, member_index, cnt_cb);
+		if (err < 0) {
+			pr_err("Failed to modify class member\n");
+			return -EINVAL;
+		}
+
+	} else if (params->type == DPA_STATS_CLS_MEMBER_SA_ID) {
+		/* Modify IPSec class member */
+		err = set_ipsec_member(params, member_index, cnt_cb);
+		if (err < 0) {
+			pr_err("Failed to modify class member\n");
+			return -EINVAL;
+		}
+	} else {
+		pr_err("Invalid member type\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_stats_modify_class_counter);
+
 int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 24d2cac..1666664 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -673,6 +673,45 @@ struct dpa_stats_cls_cnt_params {
 	};
 };
 
+/* DPA Stats class counter member type */
+enum dpa_stats_cls_member_type {
+	/* Classifier table class member single key */
+	DPA_STATS_CLS_MEMBER_SINGLE_KEY = 0,
+	/* Classifier table class member pair key */
+	DPA_STATS_CLS_MEMBER_PAIR_KEY,
+	/* IPSec class member security association id */
+	DPA_STATS_CLS_MEMBER_SA_ID
+};
+
+/* DPA Stats class member parameters */
+struct dpa_stats_cls_member_params {
+
+	/* The type of DPA Stats class counter member */
+	enum dpa_stats_cls_member_type type;
+
+	union {
+		/*
+		 * Key to set or update in case the byte and mask pointers are
+		 * not NULL, or class member to invalidate otherwise
+		 */
+		struct dpa_offload_lookup_key key;
+
+		/*
+		 * Key to set or update in case the byte and mask pointers of
+		 * the first key are not NULL, or class member to invalidate
+		 * otherwise
+		 */
+		struct dpa_offload_lookup_key_pair pair;
+
+		/*
+		 * Security association identifier to set or update or class
+		 * member to invalidate in case the security association has
+		 * an invalid value
+		 */
+		int sa_id;
+	};
+};
+
 /* Creates and initializes a DPA Stats instance */
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id);
 
@@ -688,6 +727,13 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 			const struct dpa_stats_cls_cnt_params *params,
 			int *dpa_stats_cnt_id);
 
+/* Modify a specific member of a DPA Stats class counter. The member to be
+ * modified is identified through the 'member_index' parameter which represents
+ * the member position in the corresponding class counter. */
+int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
+			const struct dpa_stats_cls_member_params *params,
+			int member_index);
+
 /* Remove a DPA Stats counter by releasing all associated resources */
 int dpa_stats_remove_counter(int dpa_stats_cnt_id);
 
-- 
1.7.5.4

