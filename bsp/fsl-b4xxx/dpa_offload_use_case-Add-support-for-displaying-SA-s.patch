From aba33c8620c04168de92fc385a223aa0442c9cca Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Tue, 22 May 2012 14:10:24 +0000
Subject: [PATCH 205/518] dpa_offload_use_case: Add support for displaying SA
 statistics

A new entry is created in the debugfs, each time a  SA is offloaded.
The name of the entry is the SA id and it contains two files - one
that keeps the packet count and the other that keeps bytes count.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/Makefile  |    3 +-
 .../staging/fsl_dpa_offload/usecases/dbgfs_ctl.c   |  176 ++++++++++++++++++++
 .../staging/fsl_dpa_offload/usecases/dbgfs_ctl.h   |   57 +++++++
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |    2 +
 drivers/staging/fsl_dpa_offload/usecases/main.c    |    2 +
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   15 ++
 6 files changed, 254 insertions(+), 1 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
 create mode 100644 drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h

diff --git a/drivers/staging/fsl_dpa_offload/usecases/Makefile b/drivers/staging/fsl_dpa_offload/usecases/Makefile
index 3713de5..1ae1be6 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/Makefile
+++ b/drivers/staging/fsl_dpa_offload/usecases/Makefile
@@ -16,4 +16,5 @@ fsl_ipacc_uc-objs += 		main.o \
 				pcd_init.o \
 				ipsec_init.o \
 				xfrm_km.o \
-				xfrm_utils.o
+				xfrm_utils.o \
+				dbgfs_ctl.o
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
new file mode 100644
index 0000000..13ae7cc
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.c
@@ -0,0 +1,176 @@
+/* Copyright (c) 2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+
+#include <linux/fsl_dpa_ipsec.h>
+#include "dbgfs_ctl.h"
+
+LIST_HEAD(dbgfs_headlist);
+
+struct dentry *root_dir, *stats_dir;
+
+static ssize_t dbgfs_statistics_read(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+
+	char buf[50];
+	struct dpa_ipsec_sa_stats sa_stats;
+	struct priv_data *priv = file->private_data;
+
+	memset(&sa_stats, 0, sizeof(struct dpa_ipsec_sa_stats));
+
+	dpa_ipsec_sa_get_stats(priv->sa_id, &sa_stats);
+
+	switch (priv->type) {
+	case BYTES:
+		scnprintf(buf, sizeof(buf), "%u\n", sa_stats.bytes_count);
+		break;
+	case PACKETS:
+		scnprintf(buf, sizeof(buf), "%u\n", sa_stats.packets_count);
+		break;
+	default:
+		break;
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+static int dbgfs_open_file_generic(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static const struct file_operations default_file_operations = {
+	.read =		dbgfs_statistics_read,
+	.open =		dbgfs_open_file_generic,
+};
+
+int dbgfs_init_stats(void)
+{
+
+	root_dir = debugfs_create_dir("dpa_offload", NULL);
+	stats_dir = debugfs_create_dir("sa_id", root_dir);
+	INIT_LIST_HEAD(&dbgfs_headlist);
+
+	return 0;
+}
+
+static int dbgfs_create_stats_file(char *file_name, enum count_type c_type,
+				int sa_id, struct dbgfs_sa_entry *node)
+{
+	node->priv[c_type].type = c_type;
+	node->priv[c_type].sa_id = sa_id;
+	node->priv[c_type].file = debugfs_create_file(file_name, 0444,
+						node->dir,
+						&node->priv[c_type],
+						&default_file_operations);
+
+	return 0;
+}
+
+int dbgfs_create_entry(int sa_id)
+{
+	char node_name[32];
+	struct dentry *dir;
+	int ret = 0;
+
+	struct dbgfs_sa_entry *node;
+
+	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+	if (!node)
+		return -ENOMEM;
+
+
+	memset(node_name, 0, sizeof(node_name));
+	scnprintf(node_name, sizeof(node_name), "%d", sa_id);
+	dir = debugfs_create_dir(node_name, stats_dir);
+
+	node->dir = dir;
+
+	ret = dbgfs_create_stats_file("bytes", BYTES, sa_id, node);
+	if (ret < 0) {
+		pr_err("%s(%d) : Error creating 'bytes' entry (%d)\n",
+				__func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = dbgfs_create_stats_file("packets", PACKETS, sa_id, node);
+	if (ret < 0) {
+		pr_err("%s(%d) : Error creating 'packets' entry (%d)\n",
+				__func__, __LINE__, ret);
+		return ret;
+	}
+
+	list_add(&(node->list), &dbgfs_headlist);
+
+	return 0;
+}
+
+int dbgfs_remove_entry(int sa_id)
+{
+	struct dbgfs_sa_entry *node, *tmp;
+
+	list_for_each_entry_safe(node, tmp, &dbgfs_headlist, list) {
+		if (node->priv[PACKETS].sa_id == sa_id) {
+			debugfs_remove(node->priv[PACKETS].file);
+			debugfs_remove(node->priv[BYTES].file);
+			debugfs_remove(node->dir);
+			list_del(&(node->list));
+			kfree(node);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+int dbgfs_cleanup(void)
+{
+	struct dbgfs_sa_entry *node, *tmp;
+
+	list_for_each_entry_safe(node, tmp, &dbgfs_headlist, list) {
+		debugfs_remove(node->priv[PACKETS].file);
+		debugfs_remove(node->priv[BYTES].file);
+		debugfs_remove(node->dir);
+		list_del(&(node->list));
+		kfree(node);
+	}
+		debugfs_remove(stats_dir);
+		debugfs_remove(root_dir);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h
new file mode 100644
index 0000000..0ac8922
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/usecases/dbgfs_ctl.h
@@ -0,0 +1,57 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _DBGFS_CTL_H
+#define _DBGFS_CTL_H
+
+enum count_type {
+	BYTES,
+	PACKETS,
+	MAX_TYPE,
+};
+
+struct priv_data {
+	int sa_id;
+	struct dentry *file;
+	enum count_type type;
+};
+
+struct dbgfs_sa_entry  {
+	struct dentry *dir;
+	struct priv_data priv[MAX_TYPE];
+	struct list_head list;
+};
+
+int dbgfs_init_stats(void);
+int dbgfs_create_entry(int sa_id);
+int dbgfs_remove_entry(int sa_id);
+int dbgfs_cleanup(void);
+
+#endif
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index 325e5c9..d44f01e 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -38,6 +38,7 @@
 #include "ports_conf.h"
 #include "genl_ctl.h"
 #include "common.h"
+#include "dbgfs_ctl.h"
 
 #define IN_SA_PCD_HASH_OFF      0
 #define IN_SA_PCD_HASH_SETS     2
@@ -63,6 +64,7 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 		return -EINVAL;
 	}
 
+	dbgfs_init_stats();
 	ipsec_params.max_sa_pairs = params->max_sa;
 
 	ipsec_params.fm_pcd = fm_dev->h_PcdDev;
diff --git a/drivers/staging/fsl_dpa_offload/usecases/main.c b/drivers/staging/fsl_dpa_offload/usecases/main.c
index 23cc1e0..c316c5c 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/main.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/main.c
@@ -36,6 +36,7 @@
 
 #include "ports_conf.h"
 #include "common.h"
+#include "dbgfs_ctl.h"
 
 static int dl_loop;
 module_param(dl_loop, int, 0);
@@ -88,6 +89,7 @@ void __exit usecase_exit(void)
 {
 	int ret;
 
+	dbgfs_cleanup();
 	pr_info("Unregistering DPA_IPACC genl family\n");
 	ret = genl_ctl_exit();
 	if (ret)
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 91d03b1..879d158 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -45,6 +45,7 @@
 #include "platform_defs.h"
 #include "genl_ctl.h"
 #include "common.h"
+#include "dbgfs_ctl.h"
 
 #define HASH_SIZE 256
 static const u32 jhash_initval = 0xdeadbeef;
@@ -277,6 +278,7 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 				       __func__, __LINE__, ret);
 			hlist_del(&psa->h);
 			kfree(psa);
+			dbgfs_remove_entry(psa->sa_id);
 		}
 		psa = find_sa(sa_htable, x, XFRM_POLICY_IN);
 		if (psa) {
@@ -286,6 +288,7 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 					__func__, __LINE__, ret);
 			hlist_del(&psa->h);
 			kfree(psa);
+			dbgfs_remove_entry(psa->sa_id);
 		}
 		break;
 
@@ -308,6 +311,7 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 
 	case XFRM_MSG_FLUSHSA:
 		pr_info("%s: XFRM_MSG_FLUSHSA event\n", __func__);
+		dbgfs_cleanup();
 		for (hash_val = 0; hash_val < HASH_SIZE; hash_val++) {
 			hlist_for_each_entry(psa, entry,
 					     sa_htable + hash_val, h) {
@@ -365,6 +369,7 @@ static int offload_sa(int dpa_ipsec_id,
 	sa_params->sa_bpid = usr_params.sa_bpid;
 	sa_params->crypto_params.alg_suite = alg_suite(x);
 	sa_params->l2_hdr_size = ETH_HLEN;
+	sa_params->enable_stats = 1;
 	if (sa_params->crypto_params.alg_suite < 0)
 		return -ENOTSUPP;
 
@@ -522,6 +527,16 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 		}
 		pr_info("Created SA SPI %x sa_id %d dir %s\n", x->id.spi,
 			sa_id, (dir == XFRM_POLICY_OUT) ? "OUT" : "IN");
+
+		err = dbgfs_create_entry(sa_id);
+
+		if (err < 0) {
+			pr_err("%s(%d) : Error creating dbgfs entry "
+				"for SA (%d), err (%d)\n",
+				__func__, __LINE__, sa_id, err);
+			return err;
+		}
+
 		sa = hash_sa(sa_htable, x, sa_params.sa_dir, sa_id);
 		if (!sa) {
 			pr_err("%s(%d) : Cannot allocate hash entry\n",
-- 
1.7.5.4

