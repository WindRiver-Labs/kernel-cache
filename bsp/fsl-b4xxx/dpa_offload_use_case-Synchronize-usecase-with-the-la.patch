From 9a8971d969e334ac72877beb971da50b15070c1c Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Fri, 3 Aug 2012 21:36:44 +0000
Subject: [PATCH 249/518] dpa_offload_use_case: Synchronize usecase with the
 latest changes from ipsec API

Updated outbound/pre SEC parameters
Updated inbound/pre SEC parameters
Updated outbound policy fragmentation parameter

For the inbound  SAs three types of hash table will be created:
Ipv4, Ipv6 and NAT-T.

On outbound pre SEC a number of exact match tables will be created,
according to the distributions defined in xml policy file.

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |   25 ++-
 .../staging/fsl_dpa_offload/usecases/genl_ctl.h    |    9 +-
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |  172 ++++++++++++++------
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   34 +++--
 4 files changed, 164 insertions(+), 76 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
index 3dbe6d6..a91fe55 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -44,6 +44,8 @@
 #include "lnxwrp_ioctls_fm_compat.h"
 
 struct compat_ipsec_fm_uparms compat_fm_params;
+int i;
+void *ptr;
 #endif /* CONFIG_COMPAT */
 
 int dpa_ipsec_id;
@@ -358,18 +360,23 @@ static int put_fm_params(struct sk_buff *skb_2, struct genl_info *info)
 			(typeof(&compat_fm_params))nla_data(na),
 			 na->nla_len - NLA_HDRLEN);
 		fm_params.pcd_dev = compat_ptr(compat_fm_params.pcd_dev);
-		fm_params.cc_in_rx =
-				compat_get_id2ptr(compat_fm_params.cc_in_rx,
-						FM_MAP_TYPE_PCD_NODE);
+		for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
+			ptr = compat_get_id2ptr(compat_fm_params.cc_in_rx[i],
+					   FM_MAP_TYPE_PCD_NODE);
+			fm_params.cc_in_rx[i] = ptr;
+		}
+
 		fm_params.cc_flow_id =
 				compat_get_id2ptr(compat_fm_params.cc_flow_id,
 						FM_MAP_TYPE_PCD_NODE);
-		fm_params.cc_out_pre_enc[0] =
-			compat_get_id2ptr(compat_fm_params.cc_out_pre_enc[0],
-					FM_MAP_TYPE_PCD_NODE);
-		fm_params.cc_out_pre_enc[1] =
-			compat_get_id2ptr(compat_fm_params.cc_out_pre_enc[1],
-					FM_MAP_TYPE_PCD_NODE);
+		for (i = 0; i <  DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
+			if (fm_params.cc_out_pre_enc[i] != NULL) {
+				ptr = compat_get_id2ptr(compat_fm_params.
+							cc_out_pre_enc[i],
+							  FM_MAP_TYPE_PCD_NODE);
+				fm_params.cc_out_pre_enc[i] = ptr;
+			}
+		}
 	} else
 #endif
 	memcpy(&fm_params, (typeof(&fm_params))nla_data(na), data_size);
diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
index c4b2636..4873fda 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.h
@@ -33,6 +33,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <net/xfrm.h>
+#include "linux/fsl_dpa_ipsec.h"
 
 /* Attributes
  */
@@ -101,16 +102,16 @@ struct xfrm_km_uparms {
 #ifdef CONFIG_COMPAT
 struct compat_ipsec_fm_uparms {
 	compat_uptr_t pcd_dev;
-	compat_uptr_t cc_in_rx;
+	compat_uptr_t cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
 	compat_uptr_t cc_flow_id;
-	compat_uptr_t cc_out_pre_enc[2];
+	compat_uptr_t cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
 };
 #endif
 struct ipsec_fm_uparms {
 	void *pcd_dev;
-	void *cc_in_rx;
+	void *cc_in_rx[DPA_IPSEC_MAX_SA_TYPE];
 	void *cc_flow_id;
-	void *cc_out_pre_enc[2];
+	void *cc_out_pre_enc[DPA_IPSEC_MAX_SUPPORTED_PROTOS];
 };
 
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index 15df9b5..54c6578 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -44,6 +44,54 @@
 #define IN_SA_PCD_HASH_OFF      0
 #define IN_SA_PCD_HASH_SETS     8
 #define CCNODE_MAX_NUM_OF_WAYS  4
+#define IPSEC_START_IN_FLOW_ID  0
+#define CCNODE_OUT_PRE_ENC_NUM_PROTOS 2
+#define IPSEC_PRE_DEC_TBL_KEY_SIZE \
+	{ \
+		/* IPV4 SA */ \
+		(IPv4_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 ESP_SPI_FIELD_LEN), \
+		 /* IPV4 SA w/ NATT*/ \
+		(IPv4_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 2 * PORT_FIELD_LEN + \
+		 ESP_SPI_FIELD_LEN), \
+		 /* IPV6 SA */ \
+		(IPv6_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 ESP_SPI_FIELD_LEN) \
+	}
+
+#define IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE \
+	{ \
+		(2 * IPv4_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 2 * PORT_FIELD_LEN), \
+		(2 * IPv6_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 2 * PORT_FIELD_LEN), \
+		(2 * IPv4_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 2 * PORT_FIELD_LEN), \
+		(2 * IPv6_ADDR_SIZE_IN_BYTES + \
+		 IP_PROTO_FIELD_LEN + \
+		 2 * PORT_FIELD_LEN), \
+		 0,	\
+		 0,	\
+		 0,	\
+		 0,	\
+		 0	\
+	}
+
+#define IPSEC_OUT_POL_KEY_FIELDS	(DPA_IPSEC_KEY_FIELD_SIP |	\
+					 DPA_IPSEC_KEY_FIELD_DIP |	\
+					 DPA_IPSEC_KEY_FIELD_PROTO |	\
+					 DPA_IPSEC_KEY_FIELD_SPORT |	\
+					 DPA_IPSEC_KEY_FIELD_DPORT)
+
+static int inb_key_size[] = IPSEC_PRE_DEC_TBL_KEY_SIZE;
+static int outb_key_size[] = IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE;
 
 static struct dpa_ipsec_params ipsec_params;
 static int ipsec_initialized = 0;
@@ -52,7 +100,7 @@ extern struct ipsec_fm_uparms fm_params;
 
 int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 {
-	int i, j, cls_td;
+	int i, cls_td;
 	struct dpa_cls_tbl_params cls_tbl_params;
 	int ret;
 	t_LnxWrpFmDev *fm_dev;
@@ -76,28 +124,33 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	ipsec_params.ipf_bpid = params->ipf_bpid;
 	ipsec_params.qm_sec_ch = qm_channel_caam;
 
-	/* INB/DL pre SEC params */
-	memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-	cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-	cls_tbl_params.cc_node = fm_params.cc_in_rx;
-	cls_tbl_params.type = DPA_CLS_TBL_HASH;
-	cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-	cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
-	cls_tbl_params.hash_params.max_ways = CCNODE_MAX_NUM_OF_WAYS;
-	cls_tbl_params.hash_params.num_sets = IN_SA_PCD_HASH_SETS;
-	cls_tbl_params.hash_params.key_size = MAX_SIZE_IP_UDP_SPI_KEY;
-	ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
-	if (ret < 0) {
-		pr_err("%s:%d: error creating in sa lookup classif table\n",
-				__func__, __LINE__);
-		return ret;
-	}
+	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
+		/* INB/DL pre SEC classifier */
+		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+		cls_tbl_params.cc_node = fm_params.cc_in_rx[i];
+		cls_tbl_params.type = DPA_CLS_TBL_HASH;
+		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+		cls_tbl_params.hash_params.hash_offs = IN_SA_PCD_HASH_OFF;
+		cls_tbl_params.hash_params.max_ways = CCNODE_MAX_NUM_OF_WAYS;
+		cls_tbl_params.hash_params.num_sets = IN_SA_PCD_HASH_SETS;
+		cls_tbl_params.hash_params.key_size = inb_key_size[i];
+
+		ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
+		if (ret < 0) {
+			pr_err("%s:%d: Error creating inbound SA "
+				"classif table (%d), err %d\n",
+					__func__, __LINE__, i, ret);
+			return ret;
+		}
 
-	ipsec_params.pre_sec_in_params.dpa_cls_td = cls_td;
+		ipsec_params.pre_sec_in_params.dpa_cls_td[i] = cls_td;
+	}
 
 	/* INB/DL  post SEC params */
 	 /* data_off - SEC preheader burst size in bytes */
 	ipsec_params.post_sec_in_params.data_off = DPA_IPSEC_DATA_OFF_3_BURST;
+	ipsec_params.post_sec_in_params.base_flow_id = IPSEC_START_IN_FLOW_ID;
 	ipsec_params.post_sec_in_params.use_ipv6_pol = FALSE;
 	ipsec_params.post_sec_in_params.qm_tx_ch =
 			OH_PORT_CHANNEL(FM, DL_POST_IPSEC_OH);
@@ -126,30 +179,37 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 			OH_PORT_CHANNEL(FM, UL_POST_IPSEC_OH);
 
 	/* OUTB/UL pre SEC params */
-	for (i = 0; i < ARRAY_SIZE(fm_params.cc_out_pre_enc); i++) {
-		memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
-		cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
-		cls_tbl_params.cc_node = fm_params.cc_out_pre_enc[i];
-		cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
-		cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
-		cls_tbl_params.exact_match_params.entries_cnt =
-				ipsec_params.max_sa_pairs;
-		cls_tbl_params.exact_match_params.key_size =
-			MAX_SIZE_POLICY_KEY;
-		ret = dpa_classif_table_create(&cls_tbl_params, &cls_td);
-		if (ret < 0) {
-			pr_err("%s:%d: error creating out sa lookup classif table\n",
-					__func__, __LINE__);
-			goto out_outb_pre_sec;
-		}
-
-		ipsec_params.pre_sec_out_params.dpa_cls_td[i] = cls_td;
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
+		if (fm_params.cc_out_pre_enc[i] != NULL) {
+			memset(&cls_tbl_params, 0, sizeof(cls_tbl_params));
+			cls_tbl_params.fm_pcd = fm_dev->h_PcdDev;
+			cls_tbl_params.cc_node = fm_params.cc_out_pre_enc[i];
+			cls_tbl_params.type = DPA_CLS_TBL_EXACT_MATCH;
+			cls_tbl_params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
+			cls_tbl_params.exact_match_params.entries_cnt =
+					ipsec_params.max_sa_pairs;
+			cls_tbl_params.exact_match_params.key_size =
+					outb_key_size[i];
+			ret = dpa_classif_table_create(&cls_tbl_params,
+							&cls_td);
+			if (ret < 0) {
+				pr_err("%s:%d: Error creating outbound "
+					"classif table (%d), err %d\n",
+					__func__, __LINE__, i, ret);
+				goto out_outb_pre_sec;
+			}
+
+			ipsec_params.pre_sec_out_params.
+				table[i].dpa_cls_td = cls_td;
+			ipsec_params.pre_sec_out_params.
+				table[i].key_fields = IPSEC_OUT_POL_KEY_FIELDS;
+		} else
+			ipsec_params.pre_sec_out_params.table[i].dpa_cls_td =
+							DPA_OFFLD_DESC_NONE;
 	}
-	ipsec_params.pre_sec_out_params.key_fields = DPA_IPSEC_KEY_FIELD_SIP |
-						  DPA_IPSEC_KEY_FIELD_DIP |
-						  DPA_IPSEC_KEY_FIELD_PROTO |
-						  DPA_IPSEC_KEY_FIELD_SPORT |
-						  DPA_IPSEC_KEY_FIELD_DPORT;
+
+
+
 	ret = dpa_ipsec_init(&ipsec_params, dpa_ipsec_id);
 	if (ret < 0) {
 		pr_err("%s:%d cannot initialize DPA IPsec\n",
@@ -160,30 +220,36 @@ int init_ipsec_offload(int *dpa_ipsec_id, struct ipsec_uparms *params)
 	return ret;
 
 out_outb_pre_sec:
-	for (j = 0; j < i; j++)
-		dpa_classif_table_free(ipsec_params.
-					pre_sec_out_params.dpa_cls_td[j]);
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++)
+		if (ipsec_params.pre_sec_out_params.table[i].dpa_cls_td !=
+						DPA_OFFLD_DESC_NONE)
+			dpa_classif_table_free(ipsec_params.
+					pre_sec_out_params.table[i].dpa_cls_td);
 
 out_inb_post_sec:
-		dpa_classif_table_free(ipsec_params.
-					pre_sec_in_params.dpa_cls_td);
+	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
+		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
+				dpa_cls_td[i]);
 
 	return ret;
 }
 
 int cleanup_ipsec_offload(int dpa_ipsec_id)
 {
-
 	int i;
+
 	if (!ipsec_initialized)
 		return 0;
-	dpa_classif_table_free(ipsec_params.
-				pre_sec_in_params.dpa_cls_td);
 
-	for (i = 0; i < ARRAY_SIZE(fm_params.cc_out_pre_enc); i++)
-		dpa_classif_table_free(ipsec_params.
-				pre_sec_out_params.dpa_cls_td[i]);
-	dpa_ipsec_free(dpa_ipsec_id);
+	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++)
+		dpa_classif_table_free(ipsec_params.pre_sec_in_params.
+				dpa_cls_td[i]);
+
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++)
+		if (ipsec_params.pre_sec_out_params.table[i].dpa_cls_td !=
+						DPA_OFFLD_DESC_NONE)
+			dpa_classif_table_free(ipsec_params.
+					pre_sec_out_params.table[i].dpa_cls_td);
 
 	return 0;
 }
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 879d158..4014820 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -429,13 +429,24 @@ static int offload_sa(int dpa_ipsec_id,
 			memcpy(sa_params->sa_in_params.dest_addr.ipv6.byte,
 			       x->id.daddr.a6, sizeof(x->id.daddr.a6));
 		}
+
+		/* default SA action */
 		memset(&def_sa_action, 0, sizeof(def_sa_action));
 		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
-		def_sa_action.enable_statistics = 0;
+		def_sa_action.enable_statistics = false;
 		def_sa_action.enq_params.new_fqid = def_sa_act_fqid;
-		def_sa_action.enq_params.override_fqid = 1;
+		def_sa_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
+		def_sa_action.enq_params.override_fqid = true;
 		sa_params->sa_in_params.post_ipsec_action = def_sa_action;
-		sa_params->sa_in_params.policy_miss_fqid = policy_miss_fqid;
+
+		/* miss action */
+		memset(&def_sa_action, 0, sizeof(def_sa_action));
+		def_sa_action.type = DPA_CLS_TBL_ACTION_ENQ;
+		def_sa_action.enable_statistics = false;
+		def_sa_action.enq_params.new_fqid = policy_miss_fqid;
+		def_sa_action.enq_params.hmd = DPA_OFFLD_DESC_NONE;
+		def_sa_action.enq_params.override_fqid = true;
+		sa_params->sa_in_params.policy_miss_action = def_sa_action;
 		sa_params->sa_in_params.arw = DPA_IPSEC_ARSNONE;
 	}
 	ret = dpa_ipsec_create_sa(dpa_ipsec_id, sa_params, sa_id);
@@ -443,12 +454,15 @@ static int offload_sa(int dpa_ipsec_id,
 }
 
 static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
-				 struct xfrm_selector *sel, int sa_id)
+				 struct xfrm_selector *sel, int sa_id, int dir)
 {
 	int ret = 0;
 
 	memset(pol_params, 0, sizeof(*pol_params));
-	pol_params->mtu = usr_params.mtu_pre_enc;
+	if (dir == XFRM_POLICY_OUT) {
+		pol_params->dir_params.type = DPA_IPSEC_POL_DIR_PARAMS_FRAG;
+		pol_params->dir_params.out_frag.mtu = usr_params.mtu_pre_enc;
+	}
 	if (sel->family == AF_INET) {
 		pol_params->src_addr.addr_type = DPA_IPSEC_ADDR_T_IPv4;
 		pol_params->src_addr.ipv4.word = sel->saddr.a4;
@@ -465,10 +479,10 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 	pol_params->src_prefix_len = sel->prefixlen_s;
 	pol_params->dest_prefix_len = sel->prefixlen_d;
 	pol_params->protocol = sel->proto;
-	pol_params->src_port = sel->sport;
-	pol_params->src_port_mask = sel->sport_mask;
-	pol_params->dest_port = sel->dport;
-	pol_params->dest_port_mask = sel->dport_mask;
+	pol_params->l4.src_port = sel->sport;
+	pol_params->l4.src_port_mask = sel->sport_mask;
+	pol_params->l4.dest_port = sel->dport;
+	pol_params->l4.dest_port_mask = sel->dport_mask;
 
 	ret = dpa_ipsec_sa_add_policy(sa_id, pol_params);
 	return ret;
@@ -545,7 +559,7 @@ static int policy_walk_func(struct xfrm_policy *pol, int dir, int count,
 		}
 
 	}
-	err = offload_policy(&pol_params, &pol->selector, sa->sa_id);
+	err = offload_policy(&pol_params, &pol->selector, sa->sa_id, dir);
 	if (err < 0) {
 		pr_err("%s(%d): Error offloading policy index %d (%d)\n",
 		       __func__, __LINE__, pol->index, err);
-- 
1.7.5.4

