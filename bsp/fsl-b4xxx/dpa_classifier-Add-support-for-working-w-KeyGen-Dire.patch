From 00f67f87081f62daff13d15fbc5282d1efbedc50 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Fri, 9 Nov 2012 19:07:47 +0000
Subject: [PATCH 388/518] dpa_classifier: Add support for working w/ KeyGen
 Direct Schemes

Added support for relaying frames back to the KeyGen instead of
enqueuing them. Added a new parameter to the tables called "distribution".
When this parameter is NULL, the table is backward compatible. Otherwise,
(i.e. if the user provides a KeyGen distribution pointer), all enqueue
actions will select the specified frame queue but they will not enqueue
the frame. Instead the frame will be sent back to the previously
specified KeyGen direct scheme for further processing.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |   88 ++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |    3 +-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |    1 +
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    5 +
 include/linux/fsl_dpa_classifier.h                 |    9 ++
 5 files changed, 71 insertions(+), 35 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 8c4be82..2146b07 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -403,7 +403,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 
 	/* Fill the [miss_engine_params] structure w/ data */
 	errno = action_to_next_engine_params(miss_action, &miss_engine_params,
-		NULL);
+		NULL, NULL);
 	if (errno < 0) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Failed verification of miss action "
@@ -639,9 +639,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				}
 
 				ret = action_to_next_engine_params(
-						mod_params->action,
-						&key_params.ccNextEngineParams,
-						NULL);
+					mod_params->action,
+					&key_params.ccNextEngineParams,
+					NULL,
+					(t_Handle)ptable->params.distribution);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -723,9 +724,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 				}
 
 				ret = action_to_next_engine_params(
-						mod_params->action,
-						&key_params.ccNextEngineParams,
-						NULL);
+					mod_params->action,
+					&key_params.ccNextEngineParams,
+					NULL,
+					(t_Handle)ptable->params.distribution);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -981,8 +983,9 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		/* Release old header manip chain if available */
 		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 		errno = action_to_next_engine_params(mod_params->action,
-						&next_engine_params,
-						&ptable->entry[entry_id].hmd);
+					&next_engine_params,
+					&ptable->entry[entry_id].hmd,
+					(t_Handle)ptable->params.distribution);
 		if (errno < 0)
 			return errno;
 
@@ -1083,8 +1086,9 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		/* Release old header manip chain if available */
 		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 		errno = action_to_next_engine_params(mod_params->action,
-						&key_params.ccNextEngineParams,
-						&ptable->entry[entry_id].hmd);
+					&key_params.ccNextEngineParams,
+					&ptable->entry[entry_id].hmd,
+					(t_Handle)ptable->params.distribution);
 		if (errno < 0)
 			return errno;
 
@@ -2479,7 +2483,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams,
-				&hmd);
+				&hmd,
+				(t_Handle)cls_table->params.distribution);
 	if (errno < 0)
 		return errno;
 
@@ -2684,7 +2689,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams,
-				&hmd);
+				&hmd,
+				(t_Handle)cls_table->params.distribution);
 	if (errno < 0)
 		return errno;
 
@@ -2829,7 +2835,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 				t_FmPcdCcNextEngineParams *next_engine_params,
-				int *hmd)
+				int *hmd,
+				t_Handle distribution)
 {
 	struct dpa_cls_table *next_table;
 
@@ -2855,18 +2862,38 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	case DPA_CLS_TBL_ACTION_ENQ:
-		if (action->enq_params.policer_params != NULL) {
-			pr_err("ERROR: %s, %s (%d): Policing for DPA "
-				"Classifier flows is not yet supported.\n",
-				__FILE__, __func__, __LINE__);
-			return -ENOSYS;
-		}
-
-		next_engine_params->nextEngine = e_FM_PCD_DONE;
-		next_engine_params->params.enqueueParams.action =
-			e_FM_PCD_ENQ_FRAME;
-		next_engine_params->params.enqueueParams.newFqid =
+		if (distribution) {
+			/* Redirect frames to KeyGen direct scheme */
+			next_engine_params->nextEngine = e_FM_PCD_KG;
+			next_engine_params->params.kgParams.h_DirectScheme =
+				distribution;
+			next_engine_params->params.kgParams.newFqid =
 				action->enq_params.new_fqid;
+			if (action->enq_params.override_fqid)
+				next_engine_params->params.kgParams.
+					overrideFqid = TRUE;
+		} else {
+			if (action->enq_params.policer_params != NULL) {
+				pr_err("ERROR: %s, %s (%d): Policing for DPA "
+					"Classifier flows is not yet "
+					"supported.\n",	__FILE__, __func__,
+					__LINE__);
+				return -ENOSYS;
+			}
+
+			next_engine_params->nextEngine = e_FM_PCD_DONE;
+			next_engine_params->params.enqueueParams.action =
+				e_FM_PCD_ENQ_FRAME;
+			next_engine_params->params.enqueueParams.newFqid =
+					action->enq_params.new_fqid;
+
+		if (action->enq_params.override_fqid)
+			next_engine_params->params.enqueueParams.overrideFqid =
+				TRUE;
+		if (action->enable_statistics)
+			next_engine_params->statisticsEn =
+				TRUE;
+		}
 
 		if (action->enq_params.hmd != DPA_OFFLD_DESC_NONE) {
 			if (!hmd) {
@@ -2880,8 +2907,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		dpa_classif_hm_lock_chain(action->enq_params.hmd);
 			if (!next_engine_params->h_Manip) {
 				pr_err("ERROR: %s, %s (%d): Failed to attach "
-					"HM op hmd=%d to classification "
-					"entry.", __FILE__, __func__, __LINE__,
+					"HM op hmd=%d to classification entry.",
+					__FILE__, __func__, __LINE__,
 					action->enq_params.hmd);
 				return -EINVAL;
 			}
@@ -2890,13 +2917,6 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		} else
 			next_engine_params->h_Manip = NULL;
 
-		if (action->enq_params.override_fqid)
-			next_engine_params->params.enqueueParams.overrideFqid =
-				TRUE;
-		if (action->enable_statistics)
-			next_engine_params->statisticsEn =
-				TRUE;
-
 		break;
 	case DPA_CLS_TBL_ACTION_NEXT_TABLE:
 		if ((action->next_table_params.next_td >=
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 1a0d07f..a5762f5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -389,7 +389,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
  * low level driver (FMD).
  */
 static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
-	*action, t_FmPcdCcNextEngineParams *next_engine_params, int *hmd);
+	*action, t_FmPcdCcNextEngineParams *next_engine_params, int *hmd,
+	t_Handle distribution);
 
 /*
  * Translates next engine parameters (from FMD) into action parameters for use
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index adb92be..cf06684 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -178,6 +178,7 @@ struct ioc_dpa_cls_hm_mpls_params {
 struct dpa_cls_compat_tbl_params {
 	compat_uptr_t			fm_pcd;
 	compat_uptr_t			cc_node;
+	compat_uptr_t			distribution;
 	enum dpa_cls_tbl_type		type;
 	enum dpa_cls_tbl_entry_mgmt	entry_mgmt;
 	union {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index ec14359..48c3ae7 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -582,6 +582,7 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 			return -EBUSY;
 		}
 
+		memset(&kparam, 0, sizeof(struct ioc_dpa_cls_tbl_params));
 		/* Transfer the data into the kernel space params: */
 		ret = dpa_cls_tbl_params_compatcpy(&kparam, &uparam);
 		if (ret < 0)
@@ -2209,6 +2210,10 @@ int dpa_cls_tbl_params_compatcpy(
 	kparam->table_params.cc_node = compat_get_id2ptr(
 					uparam->table_params.cc_node,
 					FM_MAP_TYPE_PCD_NODE);
+	if (compat_ptr(uparam->table_params.distribution))
+		kparam->table_params.distribution = compat_get_id2ptr(
+					uparam->table_params.distribution,
+					FM_MAP_TYPE_PCD_NODE);
 
 	kparam->table_params.type	= uparam->table_params.type;
 	kparam->table_params.entry_mgmt	= uparam->table_params.entry_mgmt;
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 6f58903..7be3ca3 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -169,6 +169,15 @@ struct dpa_cls_tbl_params {
 	 */
 	void					*cc_node;
 
+	/*
+	 * Handle to a FMan distribution to send frames to instead of
+	 * enqueuing frames. If this handle is provided (not NULL) the enqueue
+	 * action will only select the frame queue, but it will NOT actually
+	 * enqueue the frame to the selected frame queue. Instead it will send
+	 * the frame to the indicated distribution for further processing.
+	 */
+	void					*distribution;
+
 	/* The type of the DPA Classifier table */
 	enum dpa_cls_tbl_type			type;
 
-- 
1.7.5.4

