From e62913293744ae7617eca675f7c197e1786fc2e9 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Sun, 3 Feb 2013 14:49:56 +0200
Subject: [PATCH 052/518] fmd: fmd19 integration

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |   39 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |  119 ++-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |   31 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   91 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c  |  217 ++---
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c  |  555 ++++++-----
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c   |   51 +-
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h  | 1033 -------------------
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h  |  385 -------
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h   |  466 ---------
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.c       |  271 ++++--
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.h       |   38 +-
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c   |   93 +--
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |  128 ++-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |   33 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/Makefile      |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |   77 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |  305 +++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h       |   40 -
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  270 +++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  118 ++-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |  114 +--
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |  164 ++--
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c   |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fman_kg.c     |  888 ++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fman_prs.c    |  124 +++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |   97 ++-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   20 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |    5 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  261 +++---
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   34 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |   22 -
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |   10 +-
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    2 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   23 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   13 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |   84 ++-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   39 +-
 .../freescale/dpa/NetCommSw/inc/ddr_std_ext.h      |   76 ++
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |    6 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |  104 ++-
 .../freescale/dpa/NetCommSw/inc/flib/fsl_enet.h    |   49 +-
 .../dpa/NetCommSw/inc/flib/fsl_fman_dtsec.h        | 1060 ++++++++++++++++++++
 .../freescale/dpa/NetCommSw/inc/flib/fsl_fman_kg.h |  514 ++++++++++
 .../dpa/NetCommSw/inc/flib/fsl_fman_memac.h        |  381 +++++++
 .../dpa/NetCommSw/inc/flib/fsl_fman_prs.h          |  101 ++
 .../dpa/NetCommSw/inc/flib/fsl_fman_tgec.h         |  472 +++++++++
 .../inc/integrations/P1023/dpaa_integration_ext.h  |   12 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |   18 +-
 .../P3040_P4080_P5020/part_integration_ext.h       |    4 +-
 .../inc/integrations/T4240/dpaa_integration_ext.h  |   22 +-
 .../inc/integrations/T4240/part_integration_ext.h  |    2 +
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    3 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |    9 +
 drivers/net/ethernet/freescale/dpa/mac-api.c       |    6 +-
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |    4 +
 include/linux/fmd/net_ioctls.h                     |   10 +-
 60 files changed, 5549 insertions(+), 3629 deletions(-)
 delete mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
 delete mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
 delete mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_kg.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_prs.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ddr_std_ext.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_dtsec.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_kg.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_memac.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_prs.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_tgec.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index 7b7f96f..ed3674f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -69,9 +69,9 @@
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFFE00
 #endif /* (DPAA_VERSION == 10) */
 
-#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
+#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(struct fman_kg_scheme_regs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
-#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgSchemeRegs)+sizeof(t_FmPcdPlcrProfileRegs))
+#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(struct fman_kg_scheme_regs)+sizeof(t_FmPcdPlcrProfileRegs))
 #define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrProfileRegs)+sizeof(uint32_t))
 #define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
 
@@ -101,8 +101,8 @@ typedef _Packed struct t_HcFrame {
     volatile uint32_t                           extraReg;
     volatile uint32_t                           commandSequence;
     union {
-        t_FmPcdKgSchemeRegs                     schemeRegs;
-        t_FmPcdKgSchemeRegs                     schemeRegsWithoutCounter;
+        struct fman_kg_scheme_regs              schemeRegs;
+        struct fman_kg_scheme_regs              schemeRegsWithoutCounter;
         t_FmPcdPlcrProfileRegs                  profileRegs;
         volatile uint32_t                       singleRegForWrite;    /* for writing SP, CPP, profile counter */
         t_FmPcdKgPortRegs                       portRegsForRead;
@@ -246,6 +246,14 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
     p_FmHc->dataMemId           = DEFAULT_dataMemId;
 
+    err = FillBufPool(p_FmHc);
+    if (err != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+
     if (!FmIsMaster(p_FmHcParams->h_Fm))
         return (t_Handle)p_FmHc;
 
@@ -285,14 +293,6 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         return NULL;
     }
 
-    err = FillBufPool(p_FmHc);
-    if (err != E_OK)
-    {
-        REPORT_ERROR(MAJOR, err, NO_MSG);
-        FmHcFree(p_FmHc);
-        return NULL;
-    }
-
     return (t_Handle)p_FmHc;
 }
 
@@ -375,16 +375,16 @@ void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 }
 
-t_Error FmHcPcdKgSetScheme(t_Handle             h_FmHc,
-                           t_Handle             h_Scheme,
-                           t_FmPcdKgSchemeRegs  *p_SchemeRegs,
-                           bool                 updateCounter)
+t_Error FmHcPcdKgSetScheme(t_Handle                    h_FmHc,
+                           t_Handle                    h_Scheme,
+                           struct fman_kg_scheme_regs  *p_SchemeRegs,
+                           bool                        updateCounter)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
-    uint8_t                             physicalSchemeId, relativeSchemeId;
+    uint8_t                             physicalSchemeId;
     uint32_t                            seqNum;
 
     p_HcFrame = GetBuf(p_FmHc, &seqNum);
@@ -392,13 +392,12 @@ t_Error FmHcPcdKgSetScheme(t_Handle             h_FmHc,
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
-    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, updateCounter);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
-    memcpy(&p_HcFrame->hcSpecificData.schemeRegs, p_SchemeRegs, sizeof(t_FmPcdKgSchemeRegs));
+    memcpy(&p_HcFrame->hcSpecificData.schemeRegs, p_SchemeRegs, sizeof(struct fman_kg_scheme_regs));
     if (!updateCounter)
     {
         p_HcFrame->hcSpecificData.schemeRegs.kgse_dv0   = p_SchemeRegs->kgse_dv0;
@@ -437,7 +436,7 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
-    memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgSchemeRegs));
+    memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(struct fman_kg_scheme_regs));
     p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index a5a8684..e4cb509 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -43,6 +43,7 @@
 #include "xx_ext.h"
 #include "endian_ext.h"
 #include "debug_ext.h"
+#include "crc_mac_addr_ext.h"
 
 #include "fm_common.h"
 #include "dtsec.h"
@@ -108,6 +109,21 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     return E_OK;
 }
 
+/* ......................................................................... */
+
+static uint32_t GetMacAddrHashCode(uint64_t ethAddr)
+{
+    uint32_t crc;
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    crc = GetMirror32(crc);
+
+    return crc;
+}
+
+/* ......................................................................... */
 
 static void UpdateStatistics(t_Dtsec *p_Dtsec)
 {
@@ -179,7 +195,6 @@ static void UpdateStatistics(t_Dtsec *p_Dtsec)
     }
 }
 
-
 /* .............................................................................. */
 
 static uint16_t DtsecGetMaxFrameLength(t_Handle h_Dtsec)
@@ -228,7 +243,7 @@ static void DtsecIsr(t_Handle h_Dtsec)
     if (event & DTSEC_IMASK_XFUNEN)
     {
 #ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
-    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         {
             uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
             /* a. Write 0x00E0_0C00 to DTSEC_ID */
@@ -287,13 +302,6 @@ static void DtsecIsr(t_Handle h_Dtsec)
                 /* e.Write a 0 to bit n of FM_RSTC. */
                 /* cleared by FMAN */
             }
-//            else
-//            {
-                /* If either value has changed, the dTSEC controller is not locked up and the
-                   controller should be allowed to proceed normally by writing the reset value
-                   of 0x0824_0101 to DTSEC_ID. */
-                /* Register is read only */
-//            }
         }
 #endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
 
@@ -388,12 +396,18 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 
     /* Assert the graceful transmit stop bit */
     if (mode & e_COMM_MODE_RX)
+    {
         dtsec_stop_rx(p_MemMap);
 
 #ifdef FM_GRS_ERRATA_DTSEC_A002
-    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-        XX_UDelay(100);
+        if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+            XX_UDelay(100);
+#else  /* FM_GRS_ERRATA_DTSEC_A002 */
+#ifdef FM_GTS_AFTER_DROPPED_FRAME_ERRATA_DTSEC_A004839
+        XX_UDelay(10);
+#endif /* FM_GTS_AFTER_DROPPED_FRAME_ERRATA_DTSEC_A004839 */
 #endif /* FM_GRS_ERRATA_DTSEC_A002 */
+    }
 
     if (mode & e_COMM_MODE_TX)
 #if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
@@ -401,8 +415,6 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
         DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
 #else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
 #ifdef FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
-    if ((p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2) ||
-        (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 5))
         DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
 #else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
         dtsec_stop_tx(p_MemMap);
@@ -649,7 +661,6 @@ static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
     return E_OK;
 }
 
-
 /* .............................................................................. */
 
 static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
@@ -665,6 +676,8 @@ static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
     return E_OK;
 }
 
+/* .............................................................................. */
+
 static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
 {
     t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -718,6 +731,7 @@ static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statist
                 + p_Dtsec->internalStatistics.rbyt;
         p_Statistics->ifInPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RPKT)
                 + p_Dtsec->internalStatistics.rpkt;
+        p_Statistics->ifInUcastPkts = 0;
         p_Statistics->ifInMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RMCA)
                 + p_Dtsec->internalStatistics.rmca;
         p_Statistics->ifInBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBCA)
@@ -726,6 +740,7 @@ static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statist
                 + p_Dtsec->internalStatistics.tbyt;
         p_Statistics->ifOutPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TPKT)
                 + p_Dtsec->internalStatistics.tpkt;
+        p_Statistics->ifOutUcastPkts = 0;
         p_Statistics->ifOutMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TMCA)
                 + p_Dtsec->internalStatistics.tmca;
         p_Statistics->ifOutBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBCA)
@@ -881,18 +896,40 @@ static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
     t_EthHashEntry  *p_HashEntry;
     uint64_t        ethAddr;
     int32_t         bucket;
-    t_Error         err;
+    uint32_t        crc;
+    bool            mcast, ghtx;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    err = (t_Error)dtsec_compute_bucket(p_Dtsec->p_MemMap,
-                                        (uint8_t*)(*p_EthAddr),
-                                        &bucket);
-    if (err != E_OK)
-        RETURN_ERROR(MAJOR, err, ("Could not compute hash bucket"));
+    ghtx = (bool)((dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
+    mcast = (bool)((ethAddr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
+
+    if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Could not compute hash bucket"));
+
+    crc = GetMacAddrHashCode(ethAddr);
+
+    /* considering the 9 highest order bits in crc H[8:0]:
+     * if ghtx = 0 H[8:6] (highest order 3 bits) identify the hash register
+     * and H[5:1] (next 5 bits) identify the hash bit
+     * if ghts = 1 H[8:5] (highest order 4 bits) identify the hash register
+     * and H[4:0] (next 5 bits) identify the hash bit.
+     *
+     * In bucket index output the low 5 bits identify the hash register bit,
+     * while the higher 4 bits identify the hash register
+     */
+
+    if (ghtx)
+        bucket = (int32_t)((crc >> 23) & 0x1ff);
+    else {
+        bucket = (int32_t)((crc >> 24) & 0xff);
+        /* if !ghtx and mcast the bit must be set in gaddr instead of igaddr. */
+        if (mcast)
+            bucket += 0x100;
+    }
 
     dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, TRUE);
 
@@ -919,18 +956,30 @@ static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
     t_EthHashEntry  *p_HashEntry = NULL;
     uint64_t        ethAddr;
     int32_t         bucket;
-    t_Error         err;
+    uint32_t        crc;
+    bool            mcast, ghtx;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    err = (t_Error)dtsec_compute_bucket(p_Dtsec->p_MemMap,
-                                        (uint8_t*)(*p_EthAddr),
-                                        &bucket);
-    if (err != E_OK)
-        RETURN_ERROR(MAJOR, err, ("Could not compute hash bucket"));
+    ghtx = (bool)((dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
+    mcast = (bool)((ethAddr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
+
+    if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Could not compute hash bucket"));
+
+    crc = GetMacAddrHashCode(ethAddr);
+
+    if (ghtx)
+        bucket = (int32_t)((crc >> 23) & 0x1ff);
+    else {
+        bucket = (int32_t)((crc >> 24) & 0xff);
+        /* if !ghtx and mcast the bit must be set in gaddr instead of igaddr. */
+        if (mcast)
+            bucket += 0x100;
+    }
 
     if (ethAddr & MAC_GROUP_ADDRESS)
     {
@@ -1251,25 +1300,24 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     DTSEC_MII_Init(h_Dtsec);
 
-    if (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+    if (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
     {
         uint16_t            tmpReg16;
 
         /* Configure the TBI PHY Control Register */
         tmpReg16 = PHY_TBICON_CLK_SEL | PHY_TBICON_SRESET;
-
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 17, tmpReg16);
 
         tmpReg16 = PHY_TBICON_CLK_SEL;
-
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 17, tmpReg16);
 
         tmpReg16 = (PHY_CR_PHY_RESET | PHY_CR_ANE | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
-
-
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
 
-        tmpReg16 = PHY_TBIANA_SGMII;
+        if (p_Dtsec->enetMode & ENET_IF_SGMII_BASEX)
+            tmpReg16 = PHY_TBIANA_1000X;
+        else
+            tmpReg16 = PHY_TBIANA_SGMII;
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 4, tmpReg16);
 
         tmpReg16 = (PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
@@ -1281,12 +1329,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     maxFrmLn = dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
     err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G,
             p_Dtsec->fmMacControllerDriver.macId, maxFrmLn);
-/* we consider having no IPC a non crasher... */
-/*    if (err) {
-        FreeInitResources(p_Dtsec);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-*/
+
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(EXTENDED_HASH_TABLE_SIZE);
     if (!p_Dtsec->p_MulticastAddrHash) {
         FreeInitResources(p_Dtsec);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index ca02ce2..01296dd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -48,6 +48,21 @@
 #include "fm_mac.h"
 
 
+#define DEFAULT_exceptions            \
+    ((uint32_t)(DTSEC_IMASK_BREN    | \
+                DTSEC_IMASK_RXCEN   | \
+                DTSEC_IMASK_BTEN    | \
+                DTSEC_IMASK_TXCEN   | \
+                DTSEC_IMASK_TXEEN   | \
+                DTSEC_IMASK_ABRTEN  | \
+                DTSEC_IMASK_LCEN    | \
+                DTSEC_IMASK_CRLEN   | \
+                DTSEC_IMASK_XFUNEN  | \
+                DTSEC_IMASK_IFERREN | \
+                DTSEC_IMASK_MAGEN   | \
+                DTSEC_IMASK_TDPEEN  | \
+                DTSEC_IMASK_RDPEEN))
+
 #define GET_EXCEPTION_FLAG(bitMask, exception)  switch (exception){ \
     case e_FM_MAC_EX_1G_BAB_RX:                                     \
         bitMask = DTSEC_IMASK_BREN; break;                          \
@@ -113,21 +128,6 @@ typedef  uint32_t t_ErrorDisable;
 
 #define DTSEC_TO_MII_OFFSET             0x1000  /* number of pattern match registers (entries) */
 
-#define DEFAULT_exceptions              ((uint32_t)(DTSEC_IMASK_BREN    | \
-                                                    DTSEC_IMASK_RXCEN   | \
-                                                    DTSEC_IMASK_BTEN    | \
-                                                    DTSEC_IMASK_TXCEN   | \
-                                                    DTSEC_IMASK_TXEEN   | \
-                                                    DTSEC_IMASK_ABRTEN  | \
-                                                    DTSEC_IMASK_LCEN    | \
-                                                    DTSEC_IMASK_CRLEN   | \
-                                                    DTSEC_IMASK_XFUNEN  | \
-                                                    DTSEC_IMASK_IFERREN | \
-                                                    DTSEC_IMASK_MAGEN   | \
-                                                    DTSEC_IMASK_TDPEEN  | \
-                                                    DTSEC_IMASK_RDPEEN))
-
-
 #define MAX_PHYS                    32 /* maximum number of phys */
 
 #define     VAL32BIT    0x100000000LL
@@ -241,4 +241,5 @@ typedef struct {
     struct dtsec_cfg            *p_DtsecDriverParam;
 } t_Dtsec;
 
+
 #endif /* __DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 9cf829e..e2deaa2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -46,7 +46,7 @@
 #include "fm_mac.h"
 
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 {
@@ -57,12 +57,11 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 #if (DPAA_VERSION == 10)
     if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
-#if FM_MAX_NUM_OF_10G_MACS > 0
     else
-       p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+#if FM_MAX_NUM_OF_10G_MACS > 0
+        p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
 #else
-    else
-        p_FmMacControllerDriver = NULL; /* should not be reached */
+        p_FmMacControllerDriver = NULL;
 #endif /* FM_MAX_NUM_OF_10G_MACS > 0 */
 #else
     p_FmMacControllerDriver = (t_FmMacControllerDriver *)MEMAC_Config(p_FmMacParam);
@@ -85,7 +84,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
     return (t_Handle)p_FmMacControllerDriver;
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Init (t_Handle h_FmMac)
 {
@@ -106,7 +105,7 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Free (t_Handle h_FmMac)
 {
@@ -120,7 +119,7 @@ t_Error FM_MAC_Free (t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
 {
@@ -136,7 +135,7 @@ t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
     return E_OK;
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
 {
@@ -150,7 +149,7 @@ t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal)
 {
@@ -163,7 +162,7 @@ t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool flag)
 {
@@ -177,7 +176,7 @@ t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool flag)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool newVal)
 {
@@ -191,7 +190,7 @@ t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
 {
@@ -205,7 +204,7 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigTbiPhyAddr (t_Handle h_FmMac, uint8_t newVal)
 {
@@ -219,7 +218,7 @@ t_Error FM_MAC_ConfigTbiPhyAddr (t_Handle h_FmMac, uint8_t newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool newVal)
 {
@@ -233,7 +232,7 @@ t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigException (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
 {
@@ -248,7 +247,7 @@ t_Error FM_MAC_ConfigException (t_Handle h_FmMac, e_FmMacExceptions ex, bool ena
 }
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac)
 {
@@ -268,7 +267,7 @@ t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac)
 /* Run Time Control                                                          */
 /*****************************************************************************/
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode)
 {
@@ -282,7 +281,7 @@ t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
 {
@@ -296,7 +295,7 @@ t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Enable1588TimeStamp (t_Handle h_FmMac)
 {
@@ -310,7 +309,7 @@ t_Error FM_MAC_Enable1588TimeStamp (t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
 {
@@ -324,7 +323,7 @@ t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
                                     uint16_t pauseTime)
@@ -340,7 +339,7 @@ t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
                                 uint8_t  priority,
@@ -360,7 +359,7 @@ t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en)
 {
@@ -374,7 +373,7 @@ t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
 {
@@ -388,7 +387,7 @@ t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
 {
@@ -402,7 +401,7 @@ t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel)
 {
@@ -412,13 +411,11 @@ t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statistic
 
     if (p_FmMacControllerDriver->f_FM_MAC_SetStatistics)
         return p_FmMacControllerDriver->f_FM_MAC_SetStatistics(h_FmMac, statisticsLevel);
-#if (DPAA_VERSION >= 11)
-    return E_OK;
-#endif
+
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
 {
@@ -432,7 +429,7 @@ t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
 {
@@ -446,7 +443,7 @@ t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
 {
@@ -460,7 +457,7 @@ t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
 {
@@ -474,7 +471,7 @@ t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
 {
@@ -488,7 +485,7 @@ t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
 {
@@ -502,7 +499,7 @@ t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAdd
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *macVresion)
 {
@@ -517,7 +514,7 @@ t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *macVresion)
 
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *macId)
 {
@@ -531,7 +528,7 @@ t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *macId)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool newVal)
 {
@@ -545,7 +542,7 @@ t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
 {
@@ -556,14 +553,10 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
     if (p_FmMacControllerDriver->f_FM_MAC_AdjustLink)
         return p_FmMacControllerDriver->f_FM_MAC_AdjustLink(h_FmMac, speed, fullDuplex);
 
-#if (DPAA_VERSION >= 11)
-    return E_OK;
-#endif
-
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac)
 {
@@ -577,9 +570,7 @@ t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-
-
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
 {
@@ -593,7 +584,7 @@ t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg,
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data)
 {
@@ -607,7 +598,7 @@ t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, u
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-/* ........................................................................... */
+/* ......................................................................... */
 
 uint16_t FM_MAC_GetMaxFrameLength(t_Handle h_FmMac)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
index ee03fa7..2ba8554 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
@@ -58,51 +58,44 @@ void dtsec_start_rx(struct dtsec_regs *regs)
 	iowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_GRS, &regs->rctrl);
 }
 
-
 void dtsec_defconfig(struct dtsec_cfg *cfg)
 {
-	cfg->halfdup_on = FALSE;
-	cfg->halfdup_retransmit = 0xf;
-	cfg->halfdup_coll_window = 0x37;
-	cfg->halfdup_excess_defer = TRUE;
-	cfg->halfdup_no_backoff = FALSE;
-	cfg->halfdup_bp_no_backoff = FALSE;
-	cfg->halfdup_alt_backoff_val = 0x0A;
-	cfg->halfdup_alt_backoff_en = FALSE;
-
-	cfg->rx_drop_bcast = FALSE;
-	cfg->rx_short_frm = TRUE;
-	cfg->rx_len_check = FALSE;
-	cfg->tx_pad_crc = TRUE;
-	cfg->tx_crc = FALSE;
-	cfg->rx_ctrl_acc = FALSE;
-	cfg->tx_pause_time = 0xf000;
-	cfg->tbipa = 5; /* PHY address 0 is reserved (DPAA RM)*/
-
-	cfg->rx_prepend = 0;
-
-	cfg->ptp_tsu_en = TRUE;
-	cfg->ptp_exception_en = TRUE;
-
-	cfg->preamble_len = 7;
-	cfg->rx_preamble = FALSE;
-	cfg->tx_preamble = FALSE;
-
-	cfg->loopback = FALSE;
-	cfg->rx_time_stamp_en = FALSE;
-	cfg->tx_time_stamp_en = FALSE;
-	cfg->rx_flow = TRUE;
-	cfg->tx_flow = TRUE;
-	cfg->rx_group_hash_exd = FALSE;
-	cfg->tx_pause_time_extd = 0;
-	cfg->rx_promisc = FALSE;
-	cfg->non_back_to_back_ipg1 = 0x40;
-	cfg->non_back_to_back_ipg2 = 0x60;
-	cfg->min_ifg_enforcement = 0x50;
-	cfg->back_to_back_ipg = 0x60;
-	cfg->maximum_frame = 0x600;
-
-	cfg->tbi_phy_addr = 5;
+	cfg->halfdup_on = DEFAULT_HALFDUP_ON;
+	cfg->halfdup_retransmit = DEFAULT_HALFDUP_RETRANSMIT;
+	cfg->halfdup_coll_window = DEFAULT_HALFDUP_COLL_WINDOW;
+	cfg->halfdup_excess_defer = DEFAULT_HALFDUP_EXCESS_DEFER;
+	cfg->halfdup_no_backoff = DEFAULT_HALFDUP_NO_BACKOFF;
+	cfg->halfdup_bp_no_backoff = DEFAULT_HALFDUP_BP_NO_BACKOFF;
+	cfg->halfdup_alt_backoff_val = DEFAULT_HALFDUP_ALT_BACKOFF_VAL;
+	cfg->halfdup_alt_backoff_en = DEFAULT_HALFDUP_ALT_BACKOFF_EN;
+	cfg->rx_drop_bcast = DEFAULT_RX_DROP_BCAST;
+	cfg->rx_short_frm = DEFAULT_RX_SHORT_FRM;
+	cfg->rx_len_check = DEFAULT_RX_LEN_CHECK;
+	cfg->tx_pad_crc = DEFAULT_TX_PAD_CRC;
+	cfg->tx_crc = DEFAULT_TX_CRC;
+	cfg->rx_ctrl_acc = DEFAULT_RX_CTRL_ACC;
+	cfg->tx_pause_time = DEFAULT_TX_PAUSE_TIME;
+	cfg->tbipa = DEFAULT_TBIPA; /* PHY address 0 is reserved (DPAA RM)*/
+	cfg->rx_prepend = DEFAULT_RX_PREPEND;
+	cfg->ptp_tsu_en = DEFAULT_PTP_TSU_EN;
+	cfg->ptp_exception_en = DEFAULT_PTP_EXCEPTION_EN;
+	cfg->preamble_len = DEFAULT_PREAMBLE_LEN;
+	cfg->rx_preamble = DEFAULT_RX_PREAMBLE;
+	cfg->tx_preamble = DEFAULT_TX_PREAMBLE;
+	cfg->loopback = DEFAULT_LOOPBACK;
+	cfg->rx_time_stamp_en = DEFAULT_RX_TIME_STAMP_EN;
+	cfg->tx_time_stamp_en = DEFAULT_TX_TIME_STAMP_EN;
+	cfg->rx_flow = DEFAULT_RX_FLOW;
+	cfg->tx_flow = DEFAULT_TX_FLOW;
+	cfg->rx_group_hash_exd = DEFAULT_RX_GROUP_HASH_EXD;
+	cfg->tx_pause_time_extd = DEFAULT_TX_PAUSE_TIME_EXTD;
+	cfg->rx_promisc = DEFAULT_RX_PROMISC;
+	cfg->non_back_to_back_ipg1 = DEFAULT_NON_BACK_TO_BACK_IPG1;
+	cfg->non_back_to_back_ipg2 = DEFAULT_NON_BACK_TO_BACK_IPG2;
+	cfg->min_ifg_enforcement = DEFAULT_MIN_IFG_ENFORCEMENT;
+	cfg->back_to_back_ipg = DEFAULT_BACK_TO_BACK_IPG;
+	cfg->maximum_frame = DEFAULT_MAXIMUM_FRAME;
+	cfg->tbi_phy_addr = DEFAULT_TBI_PHY_ADDR;
 }
 
 int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
@@ -129,32 +122,33 @@ UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
 	tmp =  ioread32be(&regs->tsec_id2);
 
 	/* check RGMII support */
-	if (iface_mode == enet_if_rgmii ||
-			iface_mode == enet_if_rmii)
+	if (iface_mode == E_ENET_IF_RGMII ||
+			iface_mode == E_ENET_IF_RMII)
 		if (tmp & DTSEC_ID2_INT_REDUCED_OFF)
 			return -EINVAL;
 
-	if (iface_mode == enet_if_sgmii ||
-			iface_mode == enet_if_mii)
+	if (iface_mode == E_ENET_IF_SGMII ||
+			iface_mode == E_ENET_IF_MII)
 		if (tmp & DTSEC_ID2_INT_REDUCED_OFF)
 			return -EINVAL;
 
 	/***************ECNTRL************************/
 
-	is_rgmii = (bool)((iface_mode == enet_if_rgmii) ? TRUE : FALSE);
-	is_sgmii = (bool)((iface_mode == enet_if_sgmii) ? TRUE : FALSE);
-	is_qsgmii = (bool)((iface_mode == enet_if_qsgmii) ? TRUE : FALSE);
+	is_rgmii = (bool)((iface_mode == E_ENET_IF_RGMII) ? TRUE : FALSE);
+	is_sgmii = (bool)((iface_mode == E_ENET_IF_SGMII) ? TRUE : FALSE);
+	is_qsgmii = (bool)((iface_mode == E_ENET_IF_QSGMII) ? TRUE : FALSE);
 
 	tmp = 0;
-	if (is_rgmii || iface_mode == enet_if_gmii)
+	if (is_rgmii || iface_mode == E_ENET_IF_GMII)
 		tmp |= DTSEC_ECNTRL_GMIIM;
 	if (is_sgmii)
 		tmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM);
 	if (is_qsgmii)
-		tmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM | DTSEC_ECNTRL_QSGMIIM);
+		tmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM |
+				DTSEC_ECNTRL_QSGMIIM);
 	if (is_rgmii)
 		tmp |= DTSEC_ECNTRL_RPM;
-	if (iface_speed == enet_speed_100)
+	if (iface_speed == E_ENET_SPEED_100)
 		tmp |= DTSEC_ECNTRL_R100M;
 
 	iowrite32be(tmp, &regs->ecntrl);
@@ -241,9 +235,9 @@ UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
 	/***************MACCFG2***********************/
 	tmp = 0;
 
-	if (iface_speed < enet_speed_1000)
+	if (iface_speed < E_ENET_SPEED_1000)
 		tmp |= MACCFG2_NIBBLE_MODE;
-	else if (iface_speed == enet_speed_1000)
+	else if (iface_speed == E_ENET_SPEED_1000)
 		tmp |= MACCFG2_BYTE_MODE;
 
 	tmp |= ((uint32_t) cfg->preamble_len & 0x0000000f)
@@ -385,47 +379,6 @@ void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
 	macaddr[5] = (uint8_t)((tmp1 & 0xff000000) >> 24);
 }
 
-int dtsec_compute_bucket(struct dtsec_regs *regs, unsigned char addr[6],
-			 int32_t *bucket)
-{
-	uint64_t _addr;
-	uint32_t crc;
-	bool ghtx;
-	bool mcast;
-
-	_addr = (*(uint64_t *)addr) >> 16;
-	ghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? TRUE : FALSE);
-	mcast = (bool)((_addr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
-
-	if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
-		return -EINVAL;
-
-
-	/* CRC calculation - returns 32 bit CRC */
-	crc = ether_crc(6, addr);
-
-	/* considering the 9 highest order bits in crc H[8:0]:
-	 * if ghtx = 0 H[8:6] (highest order 3 bits) identify the hash register
-	 * and H[5:1] (next 5 bits) identify the hash bit
-	 * if ghts = 1 H[8:5] (highest order 4 bits) identify the hash register
-	 * and H[4:0] (next 5 bits) identify the hash bit.
-	 *
-	 * In bucket index output the low 5 bits identify the hash register bit,
-	 * while the higher 4 bits identify the hash register
-	 */
-	if (ghtx)
-		*bucket = (int32_t)((crc >> 23) & 0x1ff);
-	else {
-		*bucket = (int32_t)((crc >> 24) & 0xff);
-	  /* if !ghtx and mcast the bit must be set in gaddr
-	   * instead of igaddr.
-	   */
-	  if (mcast)
-		*bucket += 0x100;
-	}
-	return 0;
-}
-
 void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
 {
 	int reg_idx = (bucket >> 5) & 0xf;
@@ -478,8 +431,7 @@ int dtsec_adjust_link(struct dtsec_regs *regs,
 {
 	uint32_t		tmp;
 
-	if ((iface_mode == enet_if_xgmii || iface_mode == enet_if_sgmii ||
-		iface_mode == enet_if_qsgmii) && !full_dx)
+	if ((speed == E_ENET_SPEED_1000) && !full_dx)
 		return -EINVAL;
 
 	tmp = ioread32be(&regs->maccfg2);
@@ -489,14 +441,14 @@ int dtsec_adjust_link(struct dtsec_regs *regs,
 		tmp |= MACCFG2_FULL_DUPLEX;
 
 	tmp &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
-	if (speed < enet_speed_1000)
+	if (speed < E_ENET_SPEED_1000)
 		tmp |= MACCFG2_NIBBLE_MODE;
-	else if (speed == enet_speed_1000)
+	else if (speed == E_ENET_SPEED_1000)
 		tmp |= MACCFG2_BYTE_MODE;
 	iowrite32be(tmp, &regs->maccfg2);
 
 	tmp = ioread32be(&regs->ecntrl);
-	if (speed == enet_speed_100)
+	if (speed == E_ENET_SPEED_100)
 		tmp |= DTSEC_ECNTRL_R100M;
 	else
 		tmp &= ~DTSEC_ECNTRL_R100M;
@@ -552,13 +504,14 @@ bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
 void dtsec_reset_stat(struct dtsec_regs *regs)
 {
 	/* clear HW counters */
-	iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_CLRCNT, &regs->ecntrl);
+	iowrite32be(ioread32be(&regs->ecntrl) |
+			DTSEC_ECNTRL_CLRCNT, &regs->ecntrl);
 }
 
 int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 {
 	switch (level) {
-	case mac_stat_none:
+	case E_MAC_STAT_NONE:
 		iowrite32be(0xffffffff, &regs->cam1);
 		iowrite32be(0xffffffff, &regs->cam2);
 		iowrite32be(ioread32be(&regs->ecntrl) & ~DTSEC_ECNTRL_STEN,
@@ -566,7 +519,7 @@ int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 		iowrite32be(ioread32be(&regs->imask) & ~DTSEC_IMASK_MSROEN,
 				&regs->imask);
 		break;
-	case mac_stat_partial:
+	case E_MAC_STAT_PARTIAL:
 		iowrite32be(CAM1_ERRORS_ONLY, &regs->cam1);
 		iowrite32be(CAM2_ERRORS_ONLY, &regs->cam2);
 		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
@@ -574,7 +527,7 @@ int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 		iowrite32be(ioread32be(&regs->imask) | DTSEC_IMASK_MSROEN,
 				&regs->imask);
 		break;
-	case mac_stat_mib_grp1:
+	case E_MAC_STAT_MIB_GRP1:
 		iowrite32be((uint32_t)~CAM1_MIB_GRP_1, &regs->cam1);
 		iowrite32be((uint32_t)~CAM2_MIB_GRP_1, &regs->cam2);
 		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
@@ -582,7 +535,7 @@ int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 		iowrite32be(ioread32be(&regs->imask) | DTSEC_IMASK_MSROEN,
 				&regs->imask);
 		break;
-	case mac_stat_full:
+	case E_MAC_STAT_FULL:
 		iowrite32be(0, &regs->cam1);
 		iowrite32be(0, &regs->cam2);
 		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
@@ -633,34 +586,29 @@ void dtsec_clear_addr_in_paddr(struct dtsec_regs *regs, uint8_t paddr_num)
     iowrite32be(0, &regs->macaddr[paddr_num].exact_match2);
 }
 
-/* ........................................................................... */
-
 void dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
-                             uint64_t addr,
-                             uint8_t paddr_num)
+				uint64_t addr,
+				uint8_t paddr_num)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = (uint32_t)(addr);
-    /* swap */
-    tmp = (((tmp & 0x000000FF) << 24) |
-           ((tmp & 0x0000FF00) <<  8) |
-           ((tmp & 0x00FF0000) >>  8) |
-           ((tmp & 0xFF000000) >> 24));
-    iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match1);
+	tmp = (uint32_t)(addr);
+	/* swap */
+	tmp = (((tmp & 0x000000FF) << 24) |
+		((tmp & 0x0000FF00) <<  8) |
+		((tmp & 0x00FF0000) >>  8) |
+		((tmp & 0xFF000000) >> 24));
+	iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match1);
 
-    tmp = (uint32_t)(addr>>32);
-    /* swap */
-    tmp = (((tmp & 0x000000FF) << 24) |
-           ((tmp & 0x0000FF00) <<  8) |
-           ((tmp & 0x00FF0000) >>  8) |
-           ((tmp & 0xFF000000) >> 24));
-    iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match2);
+	tmp = (uint32_t)(addr>>32);
+	/* swap */
+	tmp = (((tmp & 0x000000FF) << 24) |
+		((tmp & 0x0000FF00) <<  8) |
+		((tmp & 0x00FF0000) >>  8) |
+		((tmp & 0xFF000000) >> 24));
+	iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match2);
 }
 
-/* ........................................................................... */
-
-
 void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 {
 	uint32_t tmp;
@@ -678,7 +626,7 @@ void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 
 void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time)
 {
-	uint32_t		ptv = 0;
+	uint32_t ptv = 0;
 
 	/* fixme: don't enable tx pause for half-duplex */
 
@@ -698,7 +646,7 @@ void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time)
 
 void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
 {
-	uint32_t		tmp;
+	uint32_t tmp;
 
 	/* todo: check if mac is set to full-duplex */
 
@@ -710,6 +658,11 @@ void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
 	iowrite32be(tmp, &regs->maccfg1);
 }
 
+uint32_t dtsec_get_rctrl(struct dtsec_regs *regs)
+{
+	return ioread32be(&regs->rctrl);
+}
+
 uint32_t dtsec_get_revision(struct dtsec_regs *regs)
 {
 	return ioread32be(&regs->tsec_id);
@@ -745,13 +698,13 @@ uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs)
 void dtsec_enable_tmr_interrupt(struct dtsec_regs *regs)
 {
 	iowrite32be(ioread32be(&regs->tmr_pemask) | TMR_PEMASK_TSREEN,
-		    &regs->tmr_pemask);
+			&regs->tmr_pemask);
 }
 
 void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs)
 {
 	iowrite32be(ioread32be(&regs->tmr_pemask) & ~TMR_PEMASK_TSREEN,
-		    &regs->tmr_pemask);
+			&regs->tmr_pemask);
 }
 
 void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
index b8fc3c9..a63d06a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
@@ -34,224 +34,260 @@
 #include "fsl_fman_memac.h"
 
 
+uint32_t memac_get_event(struct memac_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->ievent) & ev_mask;
+}
+
+uint32_t memac_get_interrupt_mask(struct memac_regs *regs)
+{
+	return ioread32be(&regs->imask);
+}
+
+void memac_ack_event(struct memac_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ev_mask, &regs->ievent);
+}
+
 void memac_set_promiscuous(struct memac_regs *regs, bool val)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
+	tmp = ioread32be(&regs->command_config);
 
-    if (val)
-        tmp |= CMD_CFG_PROMIS_EN;
-    else
-        tmp &= ~CMD_CFG_PROMIS_EN;
+	if (val)
+		tmp |= CMD_CFG_PROMIS_EN;
+	else
+		tmp &= ~CMD_CFG_PROMIS_EN;
 
-    iowrite32be(tmp, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 }
 
-void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs, uint8_t paddr_num)
+void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs,
+					uint8_t paddr_num)
 {
-    iowrite32be(0x0, &regs->mac_addr[paddr_num].mac_addr_l);
-    iowrite32be(0x0, &regs->mac_addr[paddr_num].mac_addr_u);
+	if (paddr_num == 0) {
+		iowrite32be(0, &regs->mac_addr0.mac_addr_l);
+		iowrite32be(0, &regs->mac_addr0.mac_addr_u);
+	} else {
+		iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_l);
+		iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_u);
+	}
 }
 
-void memac_hardware_add_addr_in_paddr(struct memac_regs *regs, uint8_t *adr, uint8_t paddr_num)
+void memac_hardware_add_addr_in_paddr(struct memac_regs *regs,
+					uint8_t *adr,
+					uint8_t paddr_num)
 {
-    uint32_t tmp0, tmp1;
-
-    tmp0 = (uint32_t)(adr[0] |
-            adr[1] << 8 |
-            adr[2] << 16 |
-            adr[3] << 24);
-    tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
-    iowrite32be(tmp0, &regs->mac_addr[paddr_num].mac_addr_l);
-
-    iowrite32be(tmp1, &regs->mac_addr[paddr_num].mac_addr_u);
+	uint32_t tmp0, tmp1;
+
+	tmp0 = (uint32_t)(adr[0] |
+			adr[1] << 8 |
+			adr[2] << 16 |
+			adr[3] << 24);
+	tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
+
+	if (paddr_num == 0) {
+		iowrite32be(tmp0, &regs->mac_addr0.mac_addr_l);
+		iowrite32be(tmp1, &regs->mac_addr0.mac_addr_u);
+	} else {
+		iowrite32be(tmp0, &regs->mac_addr[paddr_num-1].mac_addr_l);
+		iowrite32be(tmp1, &regs->mac_addr[paddr_num-1].mac_addr_u);
+	}
 }
 
 void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
+	tmp = ioread32be(&regs->command_config);
 
-    if (apply_rx)
-        tmp |= CMD_CFG_RX_EN ;
+	if (apply_rx)
+		tmp |= CMD_CFG_RX_EN;
 
-    if (apply_tx)
-        tmp |= CMD_CFG_TX_EN ;
+	if (apply_tx)
+		tmp |= CMD_CFG_TX_EN;
 
-    iowrite32be(tmp, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 }
 
 void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
+	tmp = ioread32be(&regs->command_config);
 
-    if (apply_rx)
-        tmp &= ~CMD_CFG_RX_EN ;
+	if (apply_rx)
+		tmp &= ~CMD_CFG_RX_EN;
 
-    if (apply_tx)
-        tmp &= ~CMD_CFG_TX_EN ;
+	if (apply_tx)
+		tmp &= ~CMD_CFG_TX_EN;
 
-    iowrite32be(tmp, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 }
 
 void memac_reset_counter(struct memac_regs *regs)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->statn_config);
+	tmp = ioread32be(&regs->statn_config);
 
-    tmp |= STATS_CFG_CLR;
+	tmp |= STATS_CFG_CLR;
 
-    iowrite32be(tmp, &regs->statn_config);
+	iowrite32be(tmp, &regs->statn_config);
 
-    while (ioread32be(&regs->statn_config) & STATS_CFG_CLR) ;
+	while (ioread32be(&regs->statn_config) & STATS_CFG_CLR);
 }
 
 void memac_reset(struct memac_regs *regs)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
+	tmp = ioread32be(&regs->command_config);
 
-    tmp |= CMD_CFG_SW_RESET;
+	tmp |= CMD_CFG_SW_RESET;
 
-    iowrite32be(tmp, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 
-    while (ioread32be(&regs->command_config) & CMD_CFG_SW_RESET) ;
+	while (ioread32be(&regs->command_config) & CMD_CFG_SW_RESET);
 }
 
-void memac_init(struct memac_regs *regs, struct memac_cfg *cfg,
-        enum enet_interface enet_interface, enum enet_speed enet_speed,
-        uint32_t exceptions)
+void memac_init(struct memac_regs *regs,
+		struct memac_cfg *cfg,
+		enum enet_interface enet_interface,
+		enum enet_speed enet_speed,
+		uint32_t exceptions)
 {
-    uint32_t    tmp;
-
-    /* Config */
-    tmp = 0;
-    if (cfg->wan_mode_enable)
-        tmp |= CMD_CFG_WAN_MODE;
-    if (cfg->promiscuous_mode_enable)
-        tmp |= CMD_CFG_PROMIS_EN;
-    if (cfg->pause_forward_enable)
-        tmp |= CMD_CFG_PAUSE_FWD;
-    if (cfg->pause_ignore)
-        tmp |= CMD_CFG_PAUSE_IGNORE;
-    if (cfg->tx_addr_ins_enable)
-        tmp |= CMD_CFG_TX_ADDR_INS;
-    if (cfg->loopback_enable)
-        tmp |= CMD_CFG_LOOPBACK_EN;
-    if (cfg->cmd_frame_enable)
-        tmp |= CMD_CFG_CNT_FRM_EN;
-    if (cfg->send_idle_enable)
-        tmp |= CMD_CFG_SEND_IDLE;
-    if (cfg->no_length_check_enable)
-        tmp |= CMD_CFG_NO_LEN_CHK;
-    if (cfg->rx_sfd_any)
-        tmp |= CMD_CFG_SFD_ANY;
-    if (cfg->pad_enable)
-        tmp |= CMD_CFG_TX_PAD_EN;
-    tmp |= CMD_CFG_CRC_FWD;
-
-    iowrite32be(tmp, &regs->command_config);
-
-    /* Max Frame Length */
-    iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
-
-    /* Pause Time */
-    iowrite32be(cfg->pause_quant, &regs->pause_quanta[0]);
-    iowrite32be(0, &regs->pause_thresh[0]);
-
-    /* interrupts */
-    iowrite32be(EVENTS_MASK, &regs->ievent);
-    iowrite32be(exceptions, &regs->imask);
-
-    /* IF_MODE */
-    tmp = 0;
-    if (enet_speed == enet_speed_10000)
-    {
-        tmp |= IF_MODE_XGMII;
-    }
-    else
-    {
-        tmp |= IF_MODE_GMII;
-        if (enet_interface == enet_if_rgmii)
-            tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
-    }
-    iowrite32be(tmp, &regs->if_mode);
+	uint32_t    tmp;
+
+	/* Config */
+	tmp = 0;
+	if (cfg->wan_mode_enable)
+		tmp |= CMD_CFG_WAN_MODE;
+	if (cfg->promiscuous_mode_enable)
+		tmp |= CMD_CFG_PROMIS_EN;
+	if (cfg->pause_forward_enable)
+		tmp |= CMD_CFG_PAUSE_FWD;
+	if (cfg->pause_ignore)
+		tmp |= CMD_CFG_PAUSE_IGNORE;
+	if (cfg->tx_addr_ins_enable)
+		tmp |= CMD_CFG_TX_ADDR_INS;
+	if (cfg->loopback_enable)
+		tmp |= CMD_CFG_LOOPBACK_EN;
+	if (cfg->cmd_frame_enable)
+		tmp |= CMD_CFG_CNT_FRM_EN;
+	if (cfg->send_idle_enable)
+		tmp |= CMD_CFG_SEND_IDLE;
+	if (cfg->no_length_check_enable)
+		tmp |= CMD_CFG_NO_LEN_CHK;
+	if (cfg->rx_sfd_any)
+		tmp |= CMD_CFG_SFD_ANY;
+	if (cfg->pad_enable)
+		tmp |= CMD_CFG_TX_PAD_EN;
+
+	tmp |= CMD_CFG_CRC_FWD;
+
+	iowrite32be(tmp, &regs->command_config);
+
+	/* Max Frame Length */
+	iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
+
+	/* Pause Time */
+	iowrite32be(cfg->pause_quanta, &regs->pause_quanta[0]);
+	iowrite32be(0, &regs->pause_thresh[0]);
+
+	/* interrupts */
+	iowrite32be(MEMAC_EVENTS_MASK, &regs->ievent);
+	iowrite32be(exceptions, &regs->imask);
+
+	/* IF_MODE */
+	tmp = 0;
+	switch (enet_interface) {
+	case E_ENET_IF_XGMII:
+	case E_ENET_IF_XFI:
+		tmp |= IF_MODE_XGMII;
+		break;
+	default:
+		tmp |= IF_MODE_GMII;
+		if (enet_interface == E_ENET_IF_RGMII)
+			tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
+	}
+	iowrite32be(tmp, &regs->if_mode);
 }
 
 void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->imask);
-    if (enable)
-       tmp |= val;
-    else
-       tmp &= ~val;
+	tmp = ioread32be(&regs->imask);
+	if (enable)
+		tmp |= val;
+	else
+		tmp &= ~val;
 
-    iowrite32be(tmp, &regs->imask);
+	iowrite32be(tmp, &regs->imask);
 }
 
 void memac_set_hash_table(struct memac_regs *regs, uint32_t val)
 {
-    iowrite32be(val, &regs->hashtable_ctrl);
+	iowrite32be(val, &regs->hashtable_ctrl);
 }
 
 uint16_t memac_get_max_frame_length(struct memac_regs *regs)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->maxfrm);
+	tmp = ioread32be(&regs->maxfrm);
 
-    return(uint16_t)tmp;
+	return(uint16_t)tmp;
 }
 
 
-void memac_set_tx_pause_frames(struct memac_regs    *regs,
-                               uint8_t              priority,
-                               uint16_t             pauseTime,
-                               uint16_t             threshTime)
+void memac_set_tx_pause_frames(struct memac_regs *regs,
+				uint8_t priority,
+				uint16_t pause_time,
+				uint16_t thresh_time)
 {
-    uint32_t tmp;
-
-    tmp = ioread32be(&regs->command_config);
-    if (priority == 0xff) //ehud FM_MAC_NO_PFC
-    {
-       tmp &= ~CMD_CFG_PFC_MODE;
-       priority = 0;
-    }
-    else
-        tmp |= CMD_CFG_PFC_MODE;
-
-    iowrite32be(tmp, &regs->command_config);
-
-    tmp = ioread32be(&regs->pause_quanta[priority/2]);
-    tmp &= (~0xFFFF<<(16*(priority%2)));
-    tmp |= ((uint32_t)pauseTime<<(16*(priority%2)));
-    iowrite32be(tmp, &regs->pause_quanta[priority/2]);
-
-    tmp = ioread32be(&regs->pause_thresh[priority/2]);
-    tmp &= (~0xFFFF<<(16*(priority%2)));
-    tmp |= ((uint32_t)threshTime<<(16*(priority%2)));
-    iowrite32be(tmp, &regs->pause_thresh[priority/2]);
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->command_config);
+	if (priority == 0xff) {
+		tmp &= ~CMD_CFG_PFC_MODE;
+		priority = 0;
+	}
+	else
+		tmp |= CMD_CFG_PFC_MODE;
+
+	iowrite32be(tmp, &regs->command_config);
+
+	tmp = ioread32be(&regs->pause_quanta[priority / 2]);
+	if (priority % 2)
+	    tmp &= 0x0000FFFF;
+	else
+	    tmp &= 0xFFFF0000;
+	tmp |= ((uint32_t)pause_time << (16 * (priority % 2)));
+	iowrite32be(tmp, &regs->pause_quanta[priority / 2]);
+
+	tmp = ioread32be(&regs->pause_thresh[priority / 2]);
+	if (priority % 2)
+	        tmp &= 0x0000FFFF;
+	else
+	        tmp &= 0xFFFF0000;
+	tmp |= ((uint32_t)thresh_time<<(16 * (priority % 2)));
+	iowrite32be(tmp, &regs->pause_thresh[priority / 2]);
 }
 
 void memac_set_rx_ignore_pause_frames(struct memac_regs    *regs,bool enable)
 {
-    uint32_t tmp;
+	uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
-    if (enable)
-       tmp |= CMD_CFG_PAUSE_IGNORE;
-    else
-       tmp &= ~CMD_CFG_PAUSE_IGNORE;
+	tmp = ioread32be(&regs->command_config);
+	if (enable)
+		tmp |= CMD_CFG_PAUSE_IGNORE;
+	else
+		tmp &= ~CMD_CFG_PAUSE_IGNORE;
 
-    iowrite32be(tmp, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 }
 
 void memac_set_loopback(struct memac_regs *regs, bool enable)
@@ -268,125 +304,124 @@ void memac_set_loopback(struct memac_regs *regs, bool enable)
     iowrite32be(tmp, &regs->command_config);
 }
 
+
 #define GET_MEMAC_CNTR_64(bn) \
-    (((uint64_t)ioread32be(&regs->bn ## _u) << 32) | \
-            ioread32be(&regs->bn ## _l))
+		(ioread32be(&regs->bn ## _l) | \
+		((uint64_t)ioread32be(&regs->bn ## _u) << 32))
 
-uint64_t memac_get_counter(struct memac_regs *regs, enum memac_counters reg_name)
+uint64_t memac_get_counter(struct memac_regs *regs,
+				enum memac_counters reg_name)
 {
-    uint64_t ret_val;
-
-    switch (reg_name) {
-    case E_MEMAC_COUNTER_R64:
-        ret_val = GET_MEMAC_CNTR_64(r64);
-        break;
-    case E_MEMAC_COUNTER_R127:
-        ret_val = GET_MEMAC_CNTR_64(r127);
-        break;
-    case E_MEMAC_COUNTER_R255:
-        ret_val = GET_MEMAC_CNTR_64(r255);
-        break;
-    case E_MEMAC_COUNTER_R511:
-        ret_val = GET_MEMAC_CNTR_64(r511);
-        break;
-    case E_MEMAC_COUNTER_R1023:
-        ret_val = GET_MEMAC_CNTR_64(r1023);
-        break;
-    case E_MEMAC_COUNTER_R1518:
-        ret_val = GET_MEMAC_CNTR_64(r1518);
-        break;
-    case E_MEMAC_COUNTER_R1519X:
-        ret_val = GET_MEMAC_CNTR_64(r1519x);
-        break;
-    case E_MEMAC_COUNTER_RFRG:
-        ret_val = GET_MEMAC_CNTR_64(rfrg);
-        break;
-    case E_MEMAC_COUNTER_RJBR:
-        ret_val = GET_MEMAC_CNTR_64(rjbr);
-        break;
-    case E_MEMAC_COUNTER_RDRP:
-        ret_val = GET_MEMAC_CNTR_64(rdrp);
-        break;
-    case E_MEMAC_COUNTER_RALN:
-        ret_val = GET_MEMAC_CNTR_64(raln);
-        break;
-    case E_MEMAC_COUNTER_TUND:
-        ret_val = GET_MEMAC_CNTR_64(tund);
-        break;
-    case E_MEMAC_COUNTER_ROVR:
-        ret_val = GET_MEMAC_CNTR_64(rovr);
-        break;
-    case E_MEMAC_COUNTER_RXPF:
-        ret_val = GET_MEMAC_CNTR_64(rxpf);
-        break;
-    case E_MEMAC_COUNTER_TXPF:
-        ret_val = GET_MEMAC_CNTR_64(txpf);
-        break;
-    case E_MEMAC_COUNTER_ROCT:
-        ret_val = GET_MEMAC_CNTR_64(roct);
-        break;
-    case E_MEMAC_COUNTER_RMCA:
-        ret_val = GET_MEMAC_CNTR_64(rmca);
-        break;
-    case E_MEMAC_COUNTER_RBCA:
-        ret_val = GET_MEMAC_CNTR_64(rbca);
-        break;
-    case E_MEMAC_COUNTER_RPKT:
-        ret_val = GET_MEMAC_CNTR_64(rpkt);
-        break;
-    case E_MEMAC_COUNTER_RUCA:
-        ret_val = GET_MEMAC_CNTR_64(ruca);
-        break;
-    case E_MEMAC_COUNTER_RERR:
-        ret_val = GET_MEMAC_CNTR_64(rerr);
-        break;
-    case E_MEMAC_COUNTER_TOCT:
-        ret_val = GET_MEMAC_CNTR_64(toct);
-        break;
-    case E_MEMAC_COUNTER_TMCA:
-        ret_val = GET_MEMAC_CNTR_64(tmca);
-        break;
-    case E_MEMAC_COUNTER_TBCA:
-        ret_val = GET_MEMAC_CNTR_64(tbca);
-        break;
-    case E_MEMAC_COUNTER_TUCA:
-        ret_val = GET_MEMAC_CNTR_64(tuca);
-        break;
-    case E_MEMAC_COUNTER_TERR:
-        ret_val = GET_MEMAC_CNTR_64(terr);
-        break;
-    default:
-        ret_val = 0;
-    }
-
-    return ret_val;
+	uint64_t ret_val;
+
+	switch (reg_name) {
+	case E_MEMAC_COUNTER_R64:
+		ret_val = GET_MEMAC_CNTR_64(r64);
+		break;
+	case E_MEMAC_COUNTER_R127:
+		ret_val = GET_MEMAC_CNTR_64(r127);
+		break;
+	case E_MEMAC_COUNTER_R255:
+		ret_val = GET_MEMAC_CNTR_64(r255);
+		break;
+	case E_MEMAC_COUNTER_R511:
+		ret_val = GET_MEMAC_CNTR_64(r511);
+		break;
+	case E_MEMAC_COUNTER_R1023:
+		ret_val = GET_MEMAC_CNTR_64(r1023);
+		break;
+	case E_MEMAC_COUNTER_R1518:
+		ret_val = GET_MEMAC_CNTR_64(r1518);
+		break;
+	case E_MEMAC_COUNTER_R1519X:
+		ret_val = GET_MEMAC_CNTR_64(r1519x);
+		break;
+	case E_MEMAC_COUNTER_RFRG:
+		ret_val = GET_MEMAC_CNTR_64(rfrg);
+		break;
+	case E_MEMAC_COUNTER_RJBR:
+		ret_val = GET_MEMAC_CNTR_64(rjbr);
+		break;
+	case E_MEMAC_COUNTER_RDRP:
+		ret_val = GET_MEMAC_CNTR_64(rdrp);
+		break;
+	case E_MEMAC_COUNTER_RALN:
+		ret_val = GET_MEMAC_CNTR_64(raln);
+		break;
+	case E_MEMAC_COUNTER_TUND:
+		ret_val = GET_MEMAC_CNTR_64(tund);
+		break;
+	case E_MEMAC_COUNTER_ROVR:
+		ret_val = GET_MEMAC_CNTR_64(rovr);
+		break;
+	case E_MEMAC_COUNTER_RXPF:
+		ret_val = GET_MEMAC_CNTR_64(rxpf);
+		break;
+	case E_MEMAC_COUNTER_TXPF:
+		ret_val = GET_MEMAC_CNTR_64(txpf);
+		break;
+	case E_MEMAC_COUNTER_ROCT:
+		ret_val = GET_MEMAC_CNTR_64(roct);
+		break;
+	case E_MEMAC_COUNTER_RMCA:
+		ret_val = GET_MEMAC_CNTR_64(rmca);
+		break;
+	case E_MEMAC_COUNTER_RBCA:
+		ret_val = GET_MEMAC_CNTR_64(rbca);
+		break;
+	case E_MEMAC_COUNTER_RPKT:
+		ret_val = GET_MEMAC_CNTR_64(rpkt);
+		break;
+	case E_MEMAC_COUNTER_RUCA:
+		ret_val = GET_MEMAC_CNTR_64(ruca);
+		break;
+	case E_MEMAC_COUNTER_RERR:
+		ret_val = GET_MEMAC_CNTR_64(rerr);
+		break;
+	case E_MEMAC_COUNTER_TOCT:
+		ret_val = GET_MEMAC_CNTR_64(toct);
+		break;
+	case E_MEMAC_COUNTER_TMCA:
+		ret_val = GET_MEMAC_CNTR_64(tmca);
+		break;
+	case E_MEMAC_COUNTER_TBCA:
+		ret_val = GET_MEMAC_CNTR_64(tbca);
+		break;
+	case E_MEMAC_COUNTER_TUCA:
+		ret_val = GET_MEMAC_CNTR_64(tuca);
+		break;
+	case E_MEMAC_COUNTER_TERR:
+		ret_val = GET_MEMAC_CNTR_64(terr);
+		break;
+	default:
+		ret_val = 0;
+	}
+
+	return ret_val;
 }
 
 void memac_defconfig(struct memac_cfg *cfg)
 {
-    cfg->reset_on_init              = FALSE;
-    cfg->wan_mode_enable            = FALSE;
-    cfg->promiscuous_mode_enable    = FALSE;
-    cfg->pause_forward_enable       = FALSE;
-    cfg->pause_ignore               = FALSE;
-    cfg->tx_addr_ins_enable         = FALSE;
-    cfg->loopback_enable            = FALSE;
-    cfg->cmd_frame_enable           = FALSE;
-    cfg->rx_error_discard           = FALSE;
-    cfg->send_idle_enable           = FALSE;
-    cfg->no_length_check_enable     = TRUE;
-    cfg->lgth_check_nostdr          = FALSE;
-    cfg->time_stamp_enable          = FALSE;
-    cfg->tx_ipg_length              = 12;
-    cfg->max_frame_length           = 0x600;
-    cfg->pause_quant                = 0xf000;
-    cfg->pad_enable                 = TRUE;
-    cfg->phy_tx_ena_on              = FALSE;
-    cfg->rx_sfd_any                 = FALSE;
-    cfg->rxPblFwd                   = FALSE;
-    cfg->txPblFwd                   = FALSE;
-    cfg->debugMode                  = FALSE;
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    cfg->skip_fman11_workaround     = FALSE;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+	cfg->reset_on_init		= FALSE;
+	cfg->wan_mode_enable		= FALSE;
+	cfg->promiscuous_mode_enable	= FALSE;
+	cfg->pause_forward_enable	= FALSE;
+	cfg->pause_ignore		= FALSE;
+	cfg->tx_addr_ins_enable		= FALSE;
+	cfg->loopback_enable		= FALSE;
+	cfg->cmd_frame_enable		= FALSE;
+	cfg->rx_error_discard		= FALSE;
+	cfg->send_idle_enable		= FALSE;
+	cfg->no_length_check_enable	= TRUE;
+	cfg->lgth_check_nostdr		= FALSE;
+	cfg->time_stamp_enable		= FALSE;
+	cfg->tx_ipg_length		= DEFAULT_TX_IPG_LENGTH;
+	cfg->max_frame_length		= DEFAULT_FRAME_LENGTH;
+	cfg->pause_quanta		= DEFAULT_PAUSE_QUANTA;
+	cfg->pad_enable			= TRUE;
+	cfg->phy_tx_ena_on		= FALSE;
+	cfg->rx_sfd_any			= FALSE;
+	cfg->rx_pbl_fwd			= FALSE;
+	cfg->tx_pbl_fwd			= FALSE;
+	cfg->debug_mode			= FALSE;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
index 176fb86..da0eb5d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
@@ -49,13 +49,13 @@ void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *adr)
 
 void tgec_reset_stat(struct tgec_regs *regs)
 {
-	uint32_t command_config;
+	uint32_t tmp;
 
-	command_config = ioread32be(&regs->command_config);
+	tmp = ioread32be(&regs->command_config);
 
-	command_config |= CMD_CFG_STAT_CLR;
+	tmp |= CMD_CFG_STAT_CLR;
 
-	iowrite32be(command_config, &regs->command_config);
+	iowrite32be(tmp, &regs->command_config);
 
 	while (ioread32be(&regs->command_config) & CMD_CFG_STAT_CLR);
 }
@@ -159,13 +159,10 @@ void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 	uint32_t tmp;
 
 	tmp = ioread32be(&regs->command_config);
-
 	if (apply_rx)
-		tmp |= CMD_CFG_RX_EN ;
-
+		tmp |= CMD_CFG_RX_EN;
 	if (apply_tx)
-		tmp |= CMD_CFG_TX_EN ;
-
+		tmp |= CMD_CFG_TX_EN;
 	iowrite32be(tmp, &regs->command_config);
 }
 
@@ -174,13 +171,10 @@ void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 	uint32_t tmp_reg_32;
 
 	tmp_reg_32 = ioread32be(&regs->command_config);
-
 	if (apply_rx)
 		tmp_reg_32 &= ~CMD_CFG_RX_EN;
-
 	if (apply_tx)
 		tmp_reg_32 &= ~CMD_CFG_TX_EN;
-
 	iowrite32be(tmp_reg_32, &regs->command_config);
 }
 
@@ -288,21 +282,21 @@ uint16_t tgec_get_max_frame_len(struct tgec_regs *regs)
 
 void tgec_defconfig(struct tgec_cfg *cfg)
 {
-	cfg->wan_mode_enable = FALSE;
-	cfg->promiscuous_mode_enable = FALSE;
-	cfg->pause_forward_enable = FALSE;
-	cfg->pause_ignore = FALSE;
-	cfg->tx_addr_ins_enable = FALSE;
-	cfg->loopback_enable = FALSE;
-	cfg->cmd_frame_enable = FALSE;
-	cfg->rx_error_discard = FALSE;
-	cfg->send_idle_enable = FALSE;
-	cfg->no_length_check_enable = TRUE;
-	cfg->lgth_check_nostdr = FALSE;
-	cfg->time_stamp_enable = FALSE;
-	cfg->tx_ipg_length = 12;
-	cfg->max_frame_length = 0x600;
-	cfg->pause_quant = 0xf000;
+	cfg->wan_mode_enable = DEFAULT_WAN_MODE_ENABLE;
+	cfg->promiscuous_mode_enable = DEFAULT_PROMISCUOUS_MODE_ENABLE;
+	cfg->pause_forward_enable = DEFAULT_PAUSE_FORWARD_ENABLE;
+	cfg->pause_ignore = DEFAULT_PAUSE_IGNORE;
+	cfg->tx_addr_ins_enable = DEFAULT_TX_ADDR_INS_ENABLE;
+	cfg->loopback_enable = DEFAULT_LOOPBACK_ENABLE;
+	cfg->cmd_frame_enable = DEFAULT_CMD_FRAME_ENABLE;
+	cfg->rx_error_discard = DEFAULT_RX_ERROR_DISCARD;
+	cfg->send_idle_enable = DEFAULT_SEND_IDLE_ENABLE;
+	cfg->no_length_check_enable = DEFAULT_NO_LENGTH_CHECK_ENABLE;
+	cfg->lgth_check_nostdr = DEFAULT_LGTH_CHECK_NOSTDR;
+	cfg->time_stamp_enable = DEFAULT_TIME_STAMP_ENABLE;
+	cfg->tx_ipg_length = DEFAULT_TX_IPG_LENGTH;
+	cfg->max_frame_length = DEFAULT_MAX_FRAME_LENGTH;
+	cfg->pause_quant = DEFAULT_PAUSE_QUANT;
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 	cfg->skip_fman11_workaround = FALSE;
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
@@ -314,7 +308,7 @@ int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
 	uint32_t tmp;
 
 	/* Config */
-	tmp = 0;
+	tmp = 0x40; /* CRC forward */
 	if (cfg->wan_mode_enable)
 		tmp |= CMD_CFG_WAN_MODE;
 	if (cfg->promiscuous_mode_enable)
@@ -337,7 +331,6 @@ int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
 		tmp |= CMD_CFG_NO_LEN_CHK;
 	if (cfg->time_stamp_enable)
 		tmp |= CMD_CFG_EN_TIMESTAMP;
-	tmp |= 0x40;
 	iowrite32be(tmp, &regs->command_config);
 	/* Max Frame Length */
 	iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
deleted file mode 100644
index 9cf2aa1..0000000
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
+++ /dev/null
@@ -1,1033 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * DOC: dTSEC
- *
- * This section contains description of dTSEC API available in flib.
- */
-
-#ifndef FSL_FMAN_DTSEC_H
-#define FSL_FMAN_DTSEC_H
-
-#include "common/general.h"
-#include "fsl_enet.h"
-
-
-/**
- * DOC: dTSEC Init sequence
- *
- * To prepare dTSEC block for transfer use the following call sequence:
- *
- * - dtsec_defconfig() - This step is optional and yet recommended. Its use is
- * to obtain the default dTSEC configuration parameters.
- *
- * - Change dtsec configuration in &dtsec_cfg. This structure will be used
- * to customize the dTSEC behavior.
- *
- * - dtsec_init() - Applies the configuration on dTSEC hardware.  Note that
- * dTSEC is initialized while both Tx and Rx are disabled.
- *
- * - dtsec_set_mac_address() - Set the station address (mac address).
- * This is used by dTSEC to match against received packets.
- *
- * - dtsec_adjust_link() - Set the link speed and duplex parameters
- * after the PHY establishes the link.
- *
- * - dtsec_enable_tx() and dtsec_enable_rx() to enable transmission and
- * reception.
- */
-
-/**
- * DOC: dTSEC Graceful stop
- *
- * To temporary stop dTSEC activity use dtsec_stop_tx() and dtsec_stop_rx().
- * Note that these functions request dTSEC graceful stop but return before this
- * stop is complete.  To query for graceful stop completion use
- * dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
- * Alternatively the dTSEC interrupt mask can be set to enable graceful stop
- * interrupts.
- *
- * To resume operation after graceful stop use dtsec_start_tx() and
- * dtsec_start_rx().
- */
-
-/**
- * DOC: dTSEC interrupt handling
- *
- * This code does not provide an interrupt handler for dTSEC.  Instead this
- * handler should be implemented and registered to the operating system by the
- * caller.  Some primitives for accessing the event status and mask registers
- * are provided.
- *
- * See "dTSEC Events" section for a list of events that dTSEC can generate.
- */
-
-/**
- * DOC: dTSEC Events
- *
- * Interrupt events cause dTSEC event bits to be set.  Software may poll the
- * event register at any time to check for pending interrupts.  If an event
- * occurs and its corresponding enable bit is set in the interrupt mask
- * register, the event also causes a hardware interrupt at the PIC.
- *
- * To poll for event status use the dtsec_get_event() function.
- * To configure the interrupt mask use dtsec_enable_interrupt() and
- * dtsec_disable_interrupt() functions.
- * After servicing a dTSEC interrupt use dtsec_ack_event to reset the serviced
- * event bit.
- *
- * The following events may be signaled by dTSEC hardware:
- *
- * %DTSEC_IEVENT_BABR - Babbling receive error.  This bit indicates that
- * a frame was received with length in excess of the MAC's maximum frame length
- * register.
- *
- * %DTSEC_IEVENT_RXC - Receive control (pause frame) interrupt.  A pause
- * control frame was received while Rx pause frame handling is enabled.
- * Also see dtsec_handle_rx_pause().
- *
- * %DTSEC_IEVENT_MSRO - MIB counter overflow.  The count for one of the MIB
- * counters has exceeded the size of its register.
- *
- * %DTSEC_IEVENT_GTSC - Graceful transmit stop complete.  Graceful stop is now
- * complete. The transmitter is in a stopped state, in which only pause frames
- * can be transmitted.
- * Also see dtsec_stop_tx().
- *
- * %DTSEC_IEVENT_BABT - Babbling transmit error.  The transmitted frame length
- * has exceeded the value in the MAC's Maximum Frame Length register.
- *
- * %DTSEC_IEVENT_TXC - Transmit control (pause frame) interrupt.  his bit
- * indicates that a control frame was transmitted.
- *
- * %DTSEC_IEVENT_TXE - Transmit error.  This bit indicates that an error
- * occurred on the transmitted channel.  This bit is set whenever any transmit
- * error occurs which causes the dTSEC to discard all or part of a frame
- * (LC, CRL, XFUN).
- *
- * %DTSEC_IEVENT_LC - Late collision.  This bit indicates that a collision
- * occurred beyond the collision window (slot time) in half-duplex mode.
- * The frame is truncated with a bad CRC and the remainder of the frame
- * is discarded.
- *
- * %DTSEC_IEVENT_CRL - Collision retry limit.  is bit indicates that the number
- * of successive transmission collisions has exceeded the MAC's half-duplex
- * register's retransmission maximum count.  The frame is discarded without
- * being transmitted and transmission of the next frame commences.  This only
- * occurs while in half-duplex mode.
- * The number of retransmit attempts can be set in
- * &dtsec_halfdup_cfg.@retransmit before calling dtsec_init().
- *
- * %DTSEC_IEVENT_XFUN - Transmit FIFO underrun.  This bit indicates that the
- * transmit FIFO became empty before the complete frame was transmitted.
- * The frame is truncated with a bad CRC and the remainder of the frame is
- * discarded.
- *
- * %DTSEC_IEVENT_MAG - TBD
- *
- * %DTSEC_IEVENT_MMRD - MII management read completion.
- *
- * %DTSEC_IEVENT_MMWR - MII management write completion.
- *
- * %DTSEC_IEVENT_GRSC - Graceful receive stop complete.  It allows the user to
- * know if the system has completed the stop and it is safe to write to receive
- * registers (status, control or configuration registers) that are used by the
- * system during normal operation.
- *
- * %DTSEC_IEVENT_TDPE - Internal data error on transmit.  This bit indicates
- * that the dTSEC has detected a parity error on its stored transmit data, which
- * is likely to compromise the validity of recently transferred frames.
- *
- * %DTSEC_IEVENT_RDPE - Internal data error on receive.  This bit indicates that
- * the dTSEC has detected a parity error on its stored receive data, which is
- * likely to compromise the validity of recently transferred frames.
- */
-/* Interrupt Mask Register (IMASK) */
-#define DTSEC_IMASK_BREN              0x80000000
-#define DTSEC_IMASK_RXCEN             0x40000000
-#define DTSEC_IMASK_MSROEN            0x04000000
-#define DTSEC_IMASK_GTSCEN            0x02000000
-#define DTSEC_IMASK_BTEN              0x01000000
-#define DTSEC_IMASK_TXCEN             0x00800000
-#define DTSEC_IMASK_TXEEN             0x00400000
-#define DTSEC_IMASK_LCEN              0x00040000
-#define DTSEC_IMASK_CRLEN             0x00020000
-#define DTSEC_IMASK_XFUNEN            0x00010000
-#define DTSEC_IMASK_ABRTEN            0x00008000
-#define DTSEC_IMASK_IFERREN           0x00004000
-#define DTSEC_IMASK_MAGEN             0x00000800
-#define DTSEC_IMASK_MMRDEN            0x00000400
-#define DTSEC_IMASK_MMWREN            0x00000200
-#define DTSEC_IMASK_GRSCEN            0x00000100
-#define DTSEC_IMASK_TDPEEN            0x00000002
-#define DTSEC_IMASK_RDPEEN            0x00000001
-
-/* dtsec timestamp event bits */
-#define TMR_PEMASK_TSREEN		0x00010000
-#define TMR_PEVENT_TSRE			0x00010000
-
-/* Group address bit indication */
-#define MAC_GROUP_ADDRESS		0x0000010000000000ULL
-/* size in bytes of L2 address */
-#define MAC_ADDRLEN                     6
-
-/* register related defines (bits, field offsets..) */
-#define DTSEC_ID1_ID			0xffff0000
-#define DTSEC_ID1_REV_MJ		0x0000FF00
-#define DTSEC_ID1_REV_MN		0x000000ff
-
-#define DTSEC_ID2_INT_REDUCED_OFF	0x00010000
-#define DTSEC_ID2_INT_NORMAL_OFF	0x00020000
-
-#define DTSEC_ECNTRL_CLRCNT         0x00004000
-#define DTSEC_ECNTRL_AUTOZ          0x00002000
-#define DTSEC_ECNTRL_STEN           0x00001000
-#define DTSEC_ECNTRL_CFG_RO         0x80000000
-#define DTSEC_ECNTRL_GMIIM          0x00000040
-#define DTSEC_ECNTRL_TBIM           0x00000020
-#define DTSEC_ECNTRL_SGMIIM         0x00000002
-#define DTSEC_ECNTRL_RPM            0x00000010
-#define DTSEC_ECNTRL_R100M          0x00000008
-#define DTSEC_ECNTRL_RMM            0x00000004
-#define DTSEC_ECNTRL_QSGMIIM        0x00000001
-
-#define DTSEC_TCTRL_THDF            0x00000800
-#define DTSEC_TCTRL_TTSE            0x00000040
-#define DTSEC_TCTRL_GTS             0x00000020
-#define DTSEC_TCTRL_TFC_PAUSE       0x00000010
-
-/* PTV offsets */
-#define PTV_PTE_OFST                16
-
-#define RCTRL_CFA                   0x00008000
-#define RCTRL_GHTX                  0x00000400
-#define RCTRL_RTSE                  0x00000040
-#define RCTRL_GRS                   0x00000020
-#define RCTRL_BC_REJ                0x00000010
-#define RCTRL_MPROM                 0x00000008
-#define RCTRL_RSF                   0x00000004
-#define RCTRL_UPROM                 0x00000001
-#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
-
-#define TMR_CTL_ESFDP               0x00000800
-#define TMR_CTL_ESFDE               0x00000400
-
-#define MACCFG1_SOFT_RESET          0x80000000
-#define MACCFG1_LOOPBACK            0x00000100
-#define MACCFG1_RX_FLOW             0x00000020
-#define MACCFG1_TX_FLOW             0x00000010
-#define MACCFG1_TX_EN               0x00000001
-#define MACCFG1_RX_EN               0x00000004
-#define MACCFG1_RESET_RxMC          0x00080000
-#define MACCFG1_RESET_TxMC          0x00040000
-#define MACCFG1_RESET_RxFUN         0x00020000
-#define MACCFG1_RESET_TxFUN         0x00010000
-
-#define MACCFG2_NIBBLE_MODE         0x00000100
-#define MACCFG2_BYTE_MODE           0x00000200
-#define MACCFG2_PRE_AM_Rx_EN        0x00000080
-#define MACCFG2_PRE_AM_Tx_EN        0x00000040
-#define MACCFG2_LENGTH_CHECK        0x00000010
-#define MACCFG2_MAGIC_PACKET_EN     0x00000008
-#define MACCFG2_PAD_CRC_EN          0x00000004
-#define MACCFG2_CRC_EN              0x00000002
-#define MACCFG2_FULL_DUPLEX         0x00000001
-
-#define PREAMBLE_LENGTH_SHIFT       12
-
-#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
-#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
-#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
-
-#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
-#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
-#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
-#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
-
-#define HAFDUP_ALT_BEB			0x00080000
-#define HAFDUP_BP_NO_BACKOFF		0x00040000
-#define HAFDUP_NO_BACKOFF		0x00020000
-#define HAFDUP_EXCESS_DEFER		0x00010000
-#define HAFDUP_COLLISION_WINDOW		0x000003ff
-
-#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT	20
-#define HAFDUP_RETRANSMISSION_MAX_SHIFT		12
-#define HAFDUP_RETRANSMISSION_MAX		0x0000f000
-
-#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
-
-/* CAR1/2 bits */
-#define DTSEC_CAR1_TR64   0x80000000
-#define DTSEC_CAR1_TR127  0x40000000
-#define DTSEC_CAR1_TR255  0x20000000
-#define DTSEC_CAR1_TR511  0x10000000
-#define DTSEC_CAR1_TRK1   0x08000000
-#define DTSEC_CAR1_TRMAX  0x04000000
-#define DTSEC_CAR1_TRMGV  0x02000000
-
-#define DTSEC_CAR1_RBYT   0x00010000
-#define DTSEC_CAR1_RPKT   0x00008000
-#define DTSEC_CAR1_RFCS   0x00004000
-#define DTSEC_CAR1_RMCA   0x00002000
-#define DTSEC_CAR1_RBCA   0x00001000
-#define DTSEC_CAR1_RXCF   0x00000800
-#define DTSEC_CAR1_RXPF   0x00000400
-#define DTSEC_CAR1_RXUO   0x00000200
-#define DTSEC_CAR1_RALN   0x00000100
-#define DTSEC_CAR1_RFLR   0x00000080
-#define DTSEC_CAR1_RCDE   0x00000040
-#define DTSEC_CAR1_RCSE   0x00000020
-#define DTSEC_CAR1_RUND   0x00000010
-#define DTSEC_CAR1_ROVR   0x00000008
-#define DTSEC_CAR1_RFRG   0x00000004
-#define DTSEC_CAR1_RJBR   0x00000002
-#define DTSEC_CAR1_RDRP   0x00000001
-
-#define DTSEC_CAR2_TJBR   0x00080000
-#define DTSEC_CAR2_TFCS   0x00040000
-#define DTSEC_CAR2_TXCF   0x00020000
-#define DTSEC_CAR2_TOVR   0x00010000
-#define DTSEC_CAR2_TUND   0x00008000
-#define DTSEC_CAR2_TFRG   0x00004000
-#define DTSEC_CAR2_TBYT   0x00002000
-#define DTSEC_CAR2_TPKT   0x00001000
-#define DTSEC_CAR2_TMCA   0x00000800
-#define DTSEC_CAR2_TBCA   0x00000400
-#define DTSEC_CAR2_TXPF   0x00000200
-#define DTSEC_CAR2_TDFR   0x00000100
-#define DTSEC_CAR2_TEDF   0x00000080
-#define DTSEC_CAR2_TSCL   0x00000040
-#define DTSEC_CAR2_TMCL   0x00000020
-#define DTSEC_CAR2_TLCL   0x00000010
-#define DTSEC_CAR2_TXCL   0x00000008
-#define DTSEC_CAR2_TNCL   0x00000004
-#define DTSEC_CAR2_TDRP   0x00000001
-
-#define CAM1_ERRORS_ONLY \
-	(DTSEC_CAR1_RXPF | DTSEC_CAR1_RALN | DTSEC_CAR1_RFLR \
-	| DTSEC_CAR1_RCDE | DTSEC_CAR1_RCSE | DTSEC_CAR1_RUND \
-	| DTSEC_CAR1_ROVR | DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
-	| DTSEC_CAR1_RDRP)
-
-#define CAM2_ERRORS_ONLY (DTSEC_CAR2_TFCS | DTSEC_CAR2_TXPF | DTSEC_CAR2_TDRP)
-
-/*
- * Group of dTSEC specific counters relating to the standard RMON MIB Group 1
- * (or Ethernet) statistics.
- */
-#define CAM1_MIB_GRP_1 \
-	(DTSEC_CAR1_RDRP | DTSEC_CAR1_RBYT | DTSEC_CAR1_RPKT | DTSEC_CAR1_RMCA\
-	| DTSEC_CAR1_RBCA | DTSEC_CAR1_RALN | DTSEC_CAR1_RUND | DTSEC_CAR1_ROVR\
-	| DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
-	| DTSEC_CAR1_TR64 | DTSEC_CAR1_TR127 | DTSEC_CAR1_TR255 \
-	| DTSEC_CAR1_TR511 | DTSEC_CAR1_TRMAX)
-
-#define CAM2_MIB_GRP_1 (DTSEC_CAR2_TNCL | DTSEC_CAR2_TDRP)
-
-/* memory map */
-
-struct dtsec_regs {
-	/* dTSEC General Control and Status Registers */
-	uint32_t tsec_id;	/* 0x000 ETSEC_ID register */
-	uint32_t tsec_id2;	/* 0x004 ETSEC_ID2 register */
-	uint32_t ievent;	/* 0x008 Interrupt event register */
-	uint32_t imask;		/* 0x00C Interrupt mask register */
-	uint32_t reserved0010[1];
-	uint32_t ecntrl;	/* 0x014 E control register */
-	uint32_t ptv;		/* 0x018 Pause time value register */
-	uint32_t tbipa;		/* 0x01C TBI PHY address register */
-	uint32_t tmr_ctrl;	/* 0x020 Time-stamp Control register */
-	uint32_t tmr_pevent;	/* 0x024 Time-stamp event register */
-	uint32_t tmr_pemask;	/* 0x028 Timer event mask register */
-	uint32_t reserved002c[5];
-	uint32_t tctrl;		/* 0x040 Transmit control register */
-	uint32_t reserved0044[3];
-	uint32_t rctrl;		/* 0x050 Receive control register */
-	uint32_t reserved0054[11];
-	uint32_t igaddr[8]; /* 0x080-0x09C Individual/group address registers */
-	uint32_t gaddr[8];	/* 0x0A0-0x0BC Group address registers 0-7 */
-	uint32_t reserved00c0[16];
-	uint32_t maccfg1;		/* 0x100 MAC configuration #1 */
-	uint32_t maccfg2;		/* 0x104 MAC configuration #2 */
-	uint32_t ipgifg;		/* 0x108 IPG/IFG */
-	uint32_t hafdup;		/* 0x10C Half-duplex */
-	uint32_t maxfrm;		/* 0x110 Maximum frame */
-	uint32_t reserved0114[10];
-	uint32_t ifstat;		/* 0x13C Interface status */
-	uint32_t macstnaddr1;		/* 0x140 Station Address,part 1 */
-	uint32_t macstnaddr2;		/* 0x144 Station Address,part 2  */
-	struct {
-	    uint32_t exact_match1; /* octets 1-4 */
-	    uint32_t exact_match2; /* octets 5-6 */
-	} macaddr[15]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
-    uint32_t reserved01c0[16];
-    //	uint32_t reserved0148[61];
-	uint32_t tr64;	/* 0x200 transmit and receive 64 byte frame counter */
-	uint32_t tr127;	/* 0x204 transmit and receive 65 to 127 byte frame
-			 * counter */
-	uint32_t tr255;	/* 0x208 transmit and receive 128 to 255 byte frame
-			 * counter */
-	uint32_t tr511;	/* 0x20C transmit and receive 256 to 511 byte frame
-			 * counter */
-	uint32_t tr1k;	/* 0x210 transmit and receive 512 to 1023 byte frame
-			 * counter */
-	uint32_t trmax;	/* 0x214 transmit and receive 1024 to 1518 byte frame
-			 * counter */
-	uint32_t trmgv;	/* 0x218 transmit and receive 1519 to 1522 byte good
-			 * VLAN frame count */
-	uint32_t rbyt;	/* 0x21C receive byte counter */
-	uint32_t rpkt;	/* 0x220 receive packet counter */
-	uint32_t rfcs;	/* 0x224 receive FCS error counter */
-	uint32_t rmca;	/* 0x228 RMCA receive multicast packet counter */
-	uint32_t rbca;	/* 0x22C receive broadcast packet counter */
-	uint32_t rxcf;	/* 0x230 receive control frame packet counter */
-	uint32_t rxpf;	/* 0x234 receive pause frame packet counter */
-	uint32_t rxuo;	/* 0x238 receive unknown OP code counter */
-	uint32_t raln;	/* 0x23C receive alignment error counter */
-	uint32_t rflr;	/* 0x240 receive frame length error counter */
-	uint32_t rcde;	/* 0x244 receive code error counter */
-	uint32_t rcse;	/* 0x248 receive carrier sense error counter */
-	uint32_t rund;	/* 0x24C receive undersize packet counter */
-	uint32_t rovr;	/* 0x250 receive oversize packet counter */
-	uint32_t rfrg;	/* 0x254 receive fragments counter */
-	uint32_t rjbr;	/* 0x258 receive jabber counter */
-	uint32_t rdrp;	/* 0x25C receive drop */
-	uint32_t tbyt;	/* 0x260 transmit byte counter */
-	uint32_t tpkt;	/* 0x264 transmit packet counter */
-	uint32_t tmca;	/* 0x268 transmit multicast packet counter */
-	uint32_t tbca;	/* 0x26C transmit broadcast packet counter */
-	uint32_t txpf;	/* 0x270 transmit pause control frame counter */
-	uint32_t tdfr;	/* 0x274 transmit deferral packet counter */
-	uint32_t tedf;	/* 0x278 transmit excessive deferral packet counter */
-	uint32_t tscl;	/* 0x27C transmit single collision packet counter */
-	uint32_t tmcl;	/* 0x280 transmit multiple collision packet counter */
-	uint32_t tlcl;	/* 0x284 transmit late collision packet counter */
-	uint32_t txcl;	/* 0x288 transmit excessive collision packet counter */
-	uint32_t tncl;	/* 0x28C transmit total collision counter */
-	uint32_t reserved0290[1];
-	uint32_t tdrp;	/* 0x294 transmit drop frame counter */
-	uint32_t tjbr;	/* 0x298 transmit jabber frame counter */
-	uint32_t tfcs;	/* 0x29C transmit FCS error counter */
-	uint32_t txcf;	/* 0x2A0 transmit control frame counter */
-	uint32_t tovr;	/* 0x2A4 transmit oversize frame counter */
-	uint32_t tund;	/* 0x2A8 transmit undersize frame counter */
-	uint32_t tfrg;	/* 0x2AC transmit fragments frame counter */
-	uint32_t car1;	/* 0x2B0 carry register one register* */
-	uint32_t car2;	/* 0x2B4 carry register two register* */
-	uint32_t cam1;	/* 0x2B8 carry register one mask register */
-	uint32_t cam2;	/* 0x2BC carry register two mask register */
-	uint32_t reserved02c0[848];
-};
-
-/**
- * struct dtsec_mib_grp_1_counters - MIB counter overflows
- *
- * @tr64:	Transmit and Receive 64 byte frame count.  Increment for each
- *		good or bad frame, of any type, transmitted or received, which
- *		is 64 bytes in length.
- * @tr127:	Transmit and Receive 65 to 127 byte frame count.  Increments for
- *		each good or bad frame of any type, transmitted or received,
- *		which is 65-127 bytes in length.
- * @tr255:	Transmit and Receive 128 to 255 byte frame count.  Increments
- *		for each good or bad frame, of any type, transmitted or
- *		received, which is 128-255 bytes in length.
- * @tr511:	Transmit and Receive 256 to 511 byte frame count.  Increments
- *		for each good or bad frame, of any type, transmitted or
- *		received, which is 256-511 bytes in length.
- * @tr1k:	Transmit and Receive 512 to 1023 byte frame count.  Increments
- *		for each good or bad frame, of any type, transmitted or
- *		received, which is 512-1023 bytes in length.
- * @trmax:	Transmit and Receive 1024 to 1518 byte frame count.  Increments
- *		for each good or bad frame, of any type, transmitted or
- *		received, which is 1024-1518 bytes in length.
- * @rfrg:	Receive fragments count.  Increments for each received frame
- *		which is less than 64 bytes in length and contains an invalid
- *		FCS.  This includes integral and non-integral lengths.
- * @rjbr:	Receive jabber count.  Increments for received frames which
- *		exceed 1518 (non VLAN) or 1522 (VLAN) bytes and contain an
- *		invalid FCS.  This includes alignment errors.
- * @rdrp:	Receive dropped packets count.  Increments for received frames
- *		which are streamed to system but are later dropped due to lack
- *		of system resources.  Does not increment for frames rejected due
- *		to address filtering.
- * @raln:	Receive alignment error count.  Increments for each received
- *		frame from 64 to 1518 (non VLAN) or 1522 (VLAN) which contains
- *		an invalid FCS and is not an integral number of bytes.
- * @rund:	Receive undersize packet count.  Increments each time a frame is
- *		received which is less than 64 bytes in length and contains a
- *		valid FCS and is otherwise well formed.  This count does not
- *		include range length errors.
- * @rovr:	Receive oversize packet count.  Increments each time a frame is
- *		received which exceeded 1518 (non VLAN) or 1522 (VLAN) and
- *		contains a valid FCS and is otherwise well formed.
- * @rbyt:	Receive byte count.  Increments by the byte count of frames
- *		received, including those in bad packets, excluding preamble and
- *		SFD but including FCS bytes.
- * @rpkt:	Receive packet count.  Increments for each received frame
- *		(including bad packets, all unicast, broadcast, and multicast
- *		packets).
- * @rmca:	Receive multicast packet count.  Increments for each multicast
- *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
- *		1522 (VLAN), excluding broadcast frames. This count does not
- *		include range/length errors.
- * @rbca:	Receive broadcast packet count.  Increments for each broadcast
- *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
- *		1522 (VLAN), excluding multicast frames. Does not include
- *		range/length errors.
- * @tdrp:	Transmit drop frame count.  Increments each time a memory error
- *		or an underrun has occurred.
- * @tncl:	Transmit total collision counter. Increments by the number of
- *		collisions experienced during the transmission of a frame. Does
- *		not increment for aborted frames.
- *
- * The structure contains a group of dTSEC HW specific counters relating to the
- * standard RMON MIB Group 1 (or Ethernet statistics) counters.  This structure
- * is counting only the carry events of the corresponding HW counters.
- *
- * tr64 to trmax notes: Frame sizes specified are considered excluding preamble
- * and SFD but including FCS bytes.
- */
-struct dtsec_mib_grp_1_counters {
-	uint64_t  rdrp;
-	uint64_t  tdrp;
-
-	uint64_t  rbyt;
-	uint64_t  rpkt;
-	uint64_t  rbca;
-	uint64_t  rmca;
-	uint64_t  raln;
-	uint64_t  rund;
-	uint64_t  rovr;
-	uint64_t  rfrg;
-	uint64_t  rjbr;
-	uint64_t  tncl;
-
-	uint64_t  tr64;
-	uint64_t  tr127;
-	uint64_t  tr255;
-	uint64_t  tr511;
-	uint64_t  tr1k;
-	uint64_t  trmax;
-};
-
-
-enum dtsec_stat_counters {
-	E_DTSEC_STAT_TR64,
-	E_DTSEC_STAT_TR127,
-	E_DTSEC_STAT_TR255,
-	E_DTSEC_STAT_TR511,
-	E_DTSEC_STAT_TR1K,
-	E_DTSEC_STAT_TRMAX,
-	E_DTSEC_STAT_TRMGV,
-	E_DTSEC_STAT_RBYT,
-	E_DTSEC_STAT_RPKT,
-	E_DTSEC_STAT_RMCA,
-	E_DTSEC_STAT_RBCA,
-	E_DTSEC_STAT_RXPF,
-	E_DTSEC_STAT_RALN,
-	E_DTSEC_STAT_RFLR,
-	E_DTSEC_STAT_RCDE,
-	E_DTSEC_STAT_RCSE,
-	E_DTSEC_STAT_RUND,
-	E_DTSEC_STAT_ROVR,
-	E_DTSEC_STAT_RFRG,
-	E_DTSEC_STAT_RJBR,
-	E_DTSEC_STAT_RDRP,
-	E_DTSEC_STAT_TFCS,
-	E_DTSEC_STAT_TBYT,
-	E_DTSEC_STAT_TPKT,
-	E_DTSEC_STAT_TMCA,
-	E_DTSEC_STAT_TBCA,
-	E_DTSEC_STAT_TXPF,
-	E_DTSEC_STAT_TNCL,
-	E_DTSEC_STAT_TDRP
-};
-
-
-/**
- * struct dtsec_cfg - dTSEC configuration
- *
- * @halfdup_on:		Transmit half-duplex flow control, under software
- *			control for 10/100-Mbps half-duplex media. If set,
- *			back pressure is applied to media by raising carrier.
- * @halfdup_retransmit:	Number of retransmission attempts following a collision.
- *			If this is exceeded dTSEC aborts transmission due to
- *			excessive collisions. The standard specifies the
- *			attempt limit to be 15.
- * @halfdup_coll_window:The number of bytes of the frame during which
- *			collisions may occur. The default value of 55
- *			corresponds to the frame byte at the end of the
- *			standard 512-bit slot time window. If collisions are
- *			detected after this byte, the late collision event is
- *			asserted and transmission of current frame is aborted.
- * @rx_drop_bcast:	Discard broadcast frames.  If set, all broadcast frames
- *			will be discarded by dTSEC.
- * @rx_short_frm:	Accept short frames.  If set, dTSEC will accept frames
- *			of length 14..63 bytes.
- * @rx_len_check:	Length check for received frames.  If set, the MAC
- *			checks the frame's length field on receive to ensure it
- *			matches the actual data field length. This only works
- *			for received frames with length field less than 1500.
- *			No check is performed for larger frames.
- * @tx_pad_crc:		Pad and append CRC.  If set, the MAC pads all
- *			transmitted short frames and appends a CRC to every
- *			frame regardless of padding requirement.
- * @tx_crc:		Transmission CRC enable.  If set, the MAC appends a CRC
- *			to all frames.  If frames presented to the MAC have a
- *			valid length and contain a valid CRC, @tx_crc should be
- *			reset.
- *			This field is ignored if @tx_pad_crc is set.
- * @rx_ctrl_acc:	Control frame accept.  If set, this overrides 802.3
- *			standard control frame behavior, and all Ethernet frames
- *			that have an ethertype of 0x8808 are treated as normal
- *			Ethernet frames and passed up to the packet interface on
- *			a DA match.  Received pause control frames are passed to
- *			the packet interface only if Rx flow control is also
- *			disabled.  See dtsec_handle_rx_pause() function.
- * @tx_pause_time:	Transmit pause time value.  This pause value is used as
- *			part of the pause frame to be sent when a transmit pause
- *			frame is initiated.  If set to 0 this disables
- *			transmission of pause frames.
- * @rx_preamble:	Receive preamble enable.  If set, the MAC recovers the
- *			received Ethernet 7-byte preamble and passes it to the
- *			packet interface at the start of each received frame.
- *			This field should be reset for internal MAC loop-back
- *			mode.
- * @tx_preamble:	User defined preamble enable for transmitted frames.
- *			If set, a user-defined preamble must passed to the MAC
- *			and it is transmitted instead of the standard preamble.
- * @preamble_len:	Length, in bytes, of the preamble field preceding each
- *			Ethernet start-of-frame delimiter byte.  The default
- *			value of 0x7 should be used in order to guarantee
- *			reliable operation with IEEE 802.3 compliant hardware.
- * @rx_prepend:		Packet alignment padding length.  The specified number
- *			of bytes (1-31) of zero padding are inserted before the
- *			start of each received frame.  For Ethernet, where
- *			optional preamble extraction is enabled, the padding
- *			appears before the preamble, otherwise the padding
- *			precedes the layer 2 header.
- *
- * This structure contains basic dTSEC configuration and must be passed to
- * dtsec_init() function.  A default set of configuration values can be obtained
- * by calling dtsec_defconfig().
- */
-struct dtsec_cfg {
-	bool		halfdup_on;
-	bool		halfdup_alt_backoff_en;
-	bool		halfdup_excess_defer;
-	bool		halfdup_no_backoff;
-	bool		halfdup_bp_no_backoff;
-	uint8_t		halfdup_alt_backoff_val;
-	uint16_t	halfdup_retransmit;
-	uint16_t	halfdup_coll_window;
-	bool		rx_drop_bcast;
-	bool		rx_short_frm;
-	bool		rx_len_check;
-	bool		tx_pad_crc;
-	bool		tx_crc;
-	bool		rx_ctrl_acc;
-	unsigned short	tx_pause_time;
-	unsigned short	tbipa;
-	bool		ptp_tsu_en;
-	bool		ptp_exception_en;
-	bool		rx_preamble;
-	bool		tx_preamble;
-	unsigned char	preamble_len;
-	unsigned char	rx_prepend;
-	bool		loopback;
-	bool		rx_time_stamp_en;
-	bool		tx_time_stamp_en;
-	bool		rx_flow;
-	bool		tx_flow;
-	bool		rx_group_hash_exd;
-	bool		rx_promisc;
-    uint8_t     tbi_phy_addr;
-	uint16_t	tx_pause_time_extd;
-	uint16_t	maximum_frame;
-	uint32_t	non_back_to_back_ipg1;
-	uint32_t	non_back_to_back_ipg2;
-	uint32_t	min_ifg_enforcement;
-	uint32_t	back_to_back_ipg;
-};
-
-
-/**
- * dtsec_defconfig() - Get default dTSEC configuration
- * @cfg:	pointer to configuration structure.
- *
- * Call this function to obtain a default set of configuration values for
- * initializing dTSEC.  The user can overwrite any of the values before calling
- * dtsec_init(), if specific configuration needs to be applied.
- */
-void dtsec_defconfig(struct dtsec_cfg *cfg);
-
-/**
- * dtsec_init() - Init dTSEC hardware block
- * @regs:		Pointer to dTSEC register block
- * @cfg:		dTSEC configuration data
- * @iface_mode:		dTSEC interface mode, the type of MAC - PHY interface.
- * @iface_speed:	1G or 10G
- * @macaddr:		MAC station address to be assigned to the device
- * @fm_rev_maj:		major rev number
- * @fm_rev_min:		minor rev number
- * @exceptions_mask:	initial exceptions mask
- *
- * This function initializes dTSEC and applies basic configuration.
- *
- * dTSEC initialization sequence:
- * Before enabling Rx/Tx call dtsec_set_address() to set MAC address,
- * dtsec_adjust_link() to configure interface speed and duplex and finally
- * dtsec_enable_tx()/dtsec_enable_rx() to start transmission and reception.
- *
- * Returns: 0 if successful, an error code otherwise.
- */
-int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
-		enum enet_interface iface_mode,
-		enum enet_speed iface_speed,
-		uint8_t *macaddr, uint8_t fm_rev_maj,
-		uint8_t fm_rev_min,
-		uint32_t exception_mask);
-
-/**
- * dtsec_get_revision() - Get dTSEC hardware revision
- * @regs:   Pointer to dTSEC register block
- *
- * Returns dtsec_id content
- *
- * Call this function to obtain the dTSEC hardware version.
- */
-uint32_t dtsec_get_revision(struct dtsec_regs *regs);
-
-/**
- * dtsec_set_uc_promisc() - Sets unicast promiscuous mode
- * @regs:	Pointer to dTSEC register block
- * @enable:	Enable unicast promiscuous mode
- *
- * Use this function to enable/disable dTSEC L2 address filtering.  If the
- * address filtering is disabled all unicast packets are accepted.
- * To set dTSEC in promiscuous mode call both dtsec_set_uc_promisc() and
- * dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
- * addresses.
- */
-void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
-
-/**
- * dtsec_adjust_link() - Adjust dTSEC speed/duplex settings
- * @regs:	Pointer to dTSEC register block
- * @iface_mode: dTSEC interface mode
- * @speed:	Link speed
- * @full_dx:	True for full-duplex, false for half-duplex.
- *
- * This function configures the MAC to function and the desired rates.  Use it
- * to configure dTSEC after dtsec_init() and whenever the link speed changes
- * (for instance following PHY auto-negociation).
- *
- * Returns: 0 if successful, an error code otherwise.
- */
-int dtsec_adjust_link(struct dtsec_regs *regs,
-		enum enet_interface iface_mode,
-		enum enet_speed speed, bool full_dx);
-
-/**
- * dtsec_set_tbi_phy_addr() - Updates TBI address field
- * @regs:	Pointer to dTSEC register block
- * @address:	Valid PHY address in the range of 1 to 31. 0 is reserved.
- *
- * In SGMII mode, the dTSEC's TBIPA field must contain a valid TBI PHY address
- * so that the associated TBI PHY (i.e. the link) may be initialized.
- *
- * Returns: 0 if successful, an error code otherwise.
- */
-int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
-		uint8_t addr);
-
-/**
- * dtsec_disable() - Disable dTSEC Tx and Rx
- * @regs:	Pointer to dTSEC register block
- * @apply_rx:	disable rx side
- * @apply_tx:	disable tx side
- *
- * This function disables Tx and Rx in dTSEC.
- */
-void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
-
-/**
- * dtsec_enable() - Enable dTSEC Tx and Tx
- * @regs:	Pointer to dTSEC register block
- * @apply_rx:	enable rx side
- * @apply_tx:	enable tx side
- *
- * This function resets Tx and Rx graceful stop bit and enables dTSEC Tx and Rx.
- */
-void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
-
-/**
- * dtsec_set_mac_address() - Set MAC station address
- * @regs:   Pointer to dTSEC register block
- * @macaddr:    MAC address array
- *
- * This function sets MAC station address.  To enable unicast reception call
- * this after dtsec_init().  While promiscuous mode is disabled dTSEC will match
- * the destination address of received unicast frames against this address.
- */
-void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
-
-/**
- * dtsec_get_mac_address() - Query MAC station address
- * @regs:   Pointer to dTSEC register block
- * @macaddr:    MAC address array
- */
-void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
-
-/**
- * dtsec_set_max_frame_len() - Set max frame length
- * @regs:	Pointer to dTSEC register block
- * @length:	Max frame length.
- *
- * Sets maximum frame length for received and transmitted frames.  Frames that
- * exceeds this length are truncated.
- */
-
-void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length);
-
-
-/**
- * dtsec_get_max_frame_len() - Query max frame length
- * @regs:	Pointer to dTSEC register block
- *
- * Returns: the current value of the maximum frame length.
- */
-uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs);
-
-
-/**
- * dtsec_handle_rx_pause() - Configure pause frame handling
- * @regs:	Pointer to dTSEC register block
- * @en:		Enable pause frame handling in dTSEC
- *
- * If enabled, dTSEC will handle pause frames internally.  This must be disabled
- * if dTSEC is set in half-duplex mode.
- * If pause frame handling is disabled and &dtsec_cfg.rx_ctrl_acc is set, pause
- * frames will be transferred to the packet interface just like regular Ethernet
- * frames.
- */
-void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en);
-
-/**
- * dtsec_set_tx_pause_time() - Configure Tx pause time
- * @regs:	Pointer to dTSEC register block
- * @time:	Time value included in pause frames
- *
- * Call this function to set the time value used in transmitted pause frames.
- * If time is 0, transmission of pause frames is disabled
- */
-void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time);
-
-/**
- * dtsec_ack_event() - Acknowledge handled events
- * @regs:	Pointer to dTSEC register block
- * @ev_mask:	Events to acknowledge
- *
- * After handling events signaled by dTSEC in either polling or interrupt mode,
- * call this function to reset the associated status bits in dTSEC event
- * register.
- */
-void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
-
-/**
- * dtsec_get_event() - Returns currently asserted events
- * @regs:	Pointer to dTSEC register block
- * @ev_mask:	Mask of relevant events
- *
- * Call this function to obtain a bit-mask of events that are currently asserted
- * in dTSEC, taken from IEVENT register.
- *
- * Returns: a bit-mask of events asserted in dTSEC.
- */
-uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
-/**
- * dtsec_get_interrupt_mask() - Returns a bit-mask of enabled interrupts
- * @regs:   Pointer to dTSEC register block
- *
- * Call this function to obtain a bit-mask of enabled interrupts
- * in dTSEC, taken from IMASK register.
- *
- * Returns: a bit-mask of enabled interrupts in dTSEC.
- */
-uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs);
-
-void dtsec_clear_addr_in_paddr  (struct dtsec_regs *regs,
-                                 uint8_t paddr_num);
-
-void dtsec_add_addr_in_paddr    (struct dtsec_regs *regs,
-                                 uint64_t addr,
-                                 uint8_t paddr_num);
-
-void dtsec_enable_tmr_interrupt (struct dtsec_regs *regs);
-
-void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs);
-
-/**
- * dtsec_disable_interrupt() - Disables interrupts for the specified events
- * @regs:	Pointer to dTSEC register block
- * @ev_mask:	Mask of relevant events
- *
- * Call this function to disable interrupts in dTSEC for the specified events.
- * To enable interrupts use dtsec_enable_interrupt().
- */
-void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
-
-/**
- * dtsec_enable_interrupt() - Enable interrupts for the specified events
- * @regs:	Pointer to dTSEC register block
- * @ev_mask:	Mask of relevant events
- *
- * Call this function to enable interrupts in dTSEC for the specified events.
- * To disable interrupts use dtsec_disable_interrupt().
- */
-void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
-
-/**
- * dtsec_set_ts() - Enables dTSEC timestamps
- * @regs:	Pointer to dTSEC register block
- * @en:		true to enable timestamps, false to disable them
- *
- * Call this function to enable/disable dTSEC timestamps.  This affects both
- * Tx and Rx.
- */
-void dtsec_set_ts(struct dtsec_regs *regs, bool en);
-
-/**
- * dtsec_compute_bucket() - Get bucket index for an address
- * @regs:	Pointer to dTSEC register block
- * @addr:	MAC address
- * @bucket:	pointer to hold the return value of the bucket index
- *
- * This function returns the bucket index associated with the specified address.
- * This index can be used to enable/disable specific buckets.
- *
- * Returns: 0 if successful, an error code otherwise.
- */
-int dtsec_compute_bucket(struct dtsec_regs *regs, unsigned char addr[6],
-			 int32_t *bucket);
-
-/**
- * dtsec_set_bucket() - Enables/disables a filter bucket
- * @regs:   Pointer to dTSEC register block
- * @bucket: Bucket index
- * @enable: true/false to enable/disable this bucket
- *
- * This function enables or disables the specified bucket.  Enabling a bucket
- * associated with an address configures dTSEC to accept received packets
- * with that destination address.
- * Multiple addresses may be associated with the same bucket.  Disabling a
- * bucket will affect all addresses associated with that bucket. A bucket that
- * is enabled requires further filtering and verification in the upper layers
- *
- */
-void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
-
-/**
- * dtsec_reset_filter_table() - Resets the address filtering table
- * @regs:	Pointer to dTSEC register block
- * @mcast:	Reset multicast entries
- * @ucast:	Reset unicast entries
- *
- * Resets all entries in L2 address filter table.  After calling this function
- * all buckets enabled using dtsec_set_bucket() will be disabled.
- * If dtsec_init_filter_table() was called with @unicast_hash set to false,
- * @ucast argument is ignored.
- * This does not affect the primary nor the 15 additional addresses configured
- * using dtsec_set_address() or dtsec_set_match_address().
- */
-void  dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
-
-/**
- * dtsec_set_mc_promisc() - Set multicast promiscous mode
- * @regs:	Pointer to dTSEC register block
- * @enable:	Enable multicast promiscous mode
- *
- * Call this to enable/disable L2 address filtering for multicast packets.
- */
-void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
-
-/* statistics APIs */
-
-/**
- * dtsec_set_stat_level() - Enable a group of MIB statistics counters
- * @regs:	Pointer to dTSEC register block
- * @level:	Specifies a certain group of dTSEC MIB HW counters or _all_,
- *		to specify all the existing counters.
- *		If set to _none_, it disables all the counters.
- *
- * Enables the MIB statistics hw counters and sets up the carry interrupt
- * masks for the counters corresponding to the @level input parameter.
- *
- * Returns: error if invalid @level value given.
- */
-int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
-
-/**
- * dtsec_reset_stat() - Completely resets all dTSEC HW counters
- * @regs:	Pointer to dTSEC register block
- */
-void dtsec_reset_stat(struct dtsec_regs *regs);
-
-/**
- * dtsec_get_clear_carry_regs() - Read and clear carry bits (CAR1-2 registers)
- * @regs:	Pointer to dTSEC register block
- * @car1:	car1 register value
- * @car2:	car2 register value
- *
- * When set, the carry bits signal that an overflow occurred on the
- * corresponding counters.
- * Note that the carry bits (CAR1-2 registers) will assert the
- * %DTSEC_IEVENT_MSRO interrupt if unmasked (via CAM1-2 regs).
- *
- * Returns: true if overflow occurred, otherwise - false
- */
-bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
-				uint32_t *car1, uint32_t *car2);
-
-uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs);
-
-uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
-				enum dtsec_stat_counters reg_name);
-
-void dtsec_start_tx(struct dtsec_regs *regs);
-void dtsec_start_rx(struct dtsec_regs *regs);
-void dtsec_stop_rx(struct dtsec_regs *regs);
-void dtsec_stop_tx(struct dtsec_regs *regs);
-
-
-#endif /* FSL_FMAN_DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
deleted file mode 100644
index 2cba486..0000000
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
+++ /dev/null
@@ -1,385 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef __FSL_FMAN_MEMAC_H
-#define __FSL_FMAN_MEMAC_H
-
-#include "common/general.h"
-#include "fsl_enet.h"
-
-
-#define MEMAC_NUM_OF_PADDRS         7           /* Number of additional exact match MAC address registers */
-
-typedef struct t_MacAddr
-{
-    uint32_t   mac_addr_l;         /* Lower 32 bits of 48-bit MAC address */
-    uint32_t   mac_addr_u;         /* Upper 16 bits of 48-bit MAC address */
-} t_MacAddr;
-
-/* Control and Configuration Register (COMMAND_CONFIG) */
-#define CMD_CFG_MG                  0x80000000  /* 00 Magic Packet detection */
-#define CMD_CFG_REG_LOWP_RXETY      0x01000000  /* 07 Rx low power indication */
-#define CMD_CFG_TX_LOWP_ENA         0x00800000  /* 08 Transmit Low Power Idle Enable */
-#define CMD_CFG_SFD_ANY             0x00200000  /* 10 Disable check of SFD (0xd5) character at frame start */
-#define CMD_CFG_PFC_MODE            0x00080000  /* 12 Enable Priority Flow Control (PFC) mode of operation */
-#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 Payload length check disable */
-#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 Force idle generation */
-#define CMD_CFG_CNT_FRM_EN          0x00002000  /* 18 Control frame reception enable */
-#define CMD_CFG_SW_RESET            0x00001000  /* 19 Software Reset, self clearing bit */
-#define CMD_CFG_TX_PAD_EN           0x00000800  /* 20 Enable padding of frames in transmit direction */
-#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 XGMII/GMII loopback enable */
-#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 Transmit source MAC address insertion */
-#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 Ignore Pause frame quanta */
-#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 Terminate/forward received Pause frames */
-#define CMD_CFG_CRC_FWD             0x00000040  /* 25 Terminate/forward CRC of received frames */
-#define CMD_CFG_PAD_EN              0x00000020  /* 26 Frame padding removal in receive path enable */
-#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 Promiscuous operation enable */
-#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN mode enable */
-#define CMD_CFG_RX_EN               0x00000002  /* 30 MAC receive path enable */
-#define CMD_CFG_TX_EN               0x00000001  /* 31 MAC transmit path enable */
-
-/* Interface Mode Register (IF_MODE) */
-#define IF_MODE_MASK                0x00000003  /* 30-31 Mask on interface mode bits */
-#define IF_MODE_XGMII               0x00000000  /* 30-31 XGMII (10G) interface */
-#define IF_MODE_GMII                0x00000002  /* 30-31 GMII (1G) interface */
-#define IF_MODE_RGMII               0x00000004
-#define IF_MODE_RGMII_AUTO          0x00008000
-
-/* Hash table Control Register (HASHTABLE_CTRL) */
-#define HASH_CTRL_MCAST_SHIFT       26
-#define HASH_CTRL_MCAST_EN          0x00000100  /* 23 Multicast frame reception for the hash entry */
-#define HASH_CTRL_ADDR_MASK         0x0000003F  /* 26-31 Hash table address code */
-
-#define GROUP_ADDRESS               0x0000010000000000LL /* MAC multicast address bit indication */
-#define HASH_TABLE_SIZE             64          /* Hash table size (bits 26-31 in HASHTABLE_CTRL allows for 2^6 entries) */
-
-/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
-#define TX_IPG_LENGTH_MASK          0x0000003F
-
-/* Statistics Configuration Register (STATN_CONFIG) */
-#define STATS_CFG_CLR               0x00000004  /* 29 Reset all counters */
-#define STATS_CFG_CLR_ON_RD         0x00000002  /* 30 Clear on read */
-#define STATS_CFG_SATURATE          0x00000001  /* 31 Saturate at the maximum value */
-
-/* Internal PHY Registers - SGMII */
-#define PHY_SGMII_CR_PHY_RESET      0x8000
-#define PHY_SGMII_CR_RESET_AN       0x0200
-#define PHY_SGMII_CR_DEF_VAL        0x1140
-#define PHY_SGMII_DEV_ABILITY_SGMII 0x4001
-#define PHY_SGMII_IF_MODE_AN        0x0002
-#define PHY_SGMII_IF_MODE_SGMII     0x0001
-
-/* Interrupt Mask Register (IMASK) */
-#define IMASK_PCS                   0x80000000  /* 0 PCS
-                                                 * XGMII - PCS event
-                                                 * GMII - link synchronization event
-                                                 */
-#define IMASK_AN                    0x40000000  /* 1 AN
-                                                 * XGMII - Auto-negotiation event
-                                                 * GMII - Auto-negotiation status
-                                                 */
-#define IMASK_LT                    0x20000000  /* 2 LT
-                                                 * XGMII - Link Training event
-                                                 * GMII - new page received by auto-negotiation function
-                                                 */
-#define IMASK_MGI                   0x00004000  /* 17 Magic packet detection indication event */
-#define IMASK_RX_FIFO_OVFL          0x00001000  /* 19 Receive FIFO overflow event */
-#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 Transmit FIFO underflow event */
-#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 Transmit FIFO overflow event */
-#define IMASK_TX_ECC_ER             0x00000200  /* 22 Transmit frame ECC error event */
-#define IMASK_RX_ECC_ER             0x00000100  /* 23 Receive frame ECC error event */
-#define IMASK_LI_FAULT              0x00000080  /* 24 Link Interruption fault event (XGMII) */
-#define IMASK_RX_EMPTY              0x00000040  /* 25 Receive FIFO empty event */
-#define IMASK_TX_EMPTY              0x00000020  /* 26 Transmit FIFO empty event */
-#define IMASK_RX_LOWP               0x00000010  /* 27 Low Power Idle event */
-#define IMASK_PHY_LOS               0x00000004  /* 29 Phy loss of signal event */
-#define IMASK_REM_FAULT             0x00000002  /* 30 Remote fault event (XGMII) */
-#define IMASK_LOC_FAULT             0x00000001  /* 31 Local fault event (XGMII) */
-
-#define EVENTS_MASK                 ((uint32_t)(IMASK_PCS           |  \
-                                                IMASK_AN            |  \
-                                                IMASK_LT            |  \
-                                                IMASK_MGI           |  \
-                                                IMASK_RX_FIFO_OVFL  |  \
-                                                IMASK_TX_FIFO_UNFL  |  \
-                                                IMASK_TX_FIFO_OVFL  |  \
-                                                IMASK_TX_ECC_ER     |  \
-                                                IMASK_RX_ECC_ER     |  \
-                                                IMASK_LI_FAULT      |  \
-                                                IMASK_RX_EMPTY      |  \
-                                                IMASK_TX_EMPTY      |  \
-                                                IMASK_RX_LOWP       |  \
-                                                IMASK_PHY_LOS       |  \
-                                                IMASK_REM_FAULT     |  \
-                                                IMASK_LOC_FAULT))
-
-enum memac_counters {
-    E_MEMAC_COUNTER_R64,
-    E_MEMAC_COUNTER_R127,
-    E_MEMAC_COUNTER_R255,
-    E_MEMAC_COUNTER_R511,
-    E_MEMAC_COUNTER_R1023,
-    E_MEMAC_COUNTER_R1518,
-    E_MEMAC_COUNTER_R1519X,
-    E_MEMAC_COUNTER_RFRG,
-    E_MEMAC_COUNTER_RJBR,
-    E_MEMAC_COUNTER_RDRP,
-    E_MEMAC_COUNTER_RALN,
-    E_MEMAC_COUNTER_TUND,
-    E_MEMAC_COUNTER_ROVR,
-    E_MEMAC_COUNTER_RXPF,
-    E_MEMAC_COUNTER_TXPF,
-    E_MEMAC_COUNTER_ROCT,
-    E_MEMAC_COUNTER_RMCA,
-    E_MEMAC_COUNTER_RBCA,
-    E_MEMAC_COUNTER_RPKT,
-    E_MEMAC_COUNTER_RUCA,
-    E_MEMAC_COUNTER_RERR,
-    E_MEMAC_COUNTER_TOCT,
-    E_MEMAC_COUNTER_TMCA,
-    E_MEMAC_COUNTER_TBCA,
-    E_MEMAC_COUNTER_TUCA,
-    E_MEMAC_COUNTER_TERR
-};
-
-/*
- * memory map
- */
-struct memac_regs {
-    /* General Control and Status */
-     uint32_t   reserved1[2];
-     uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
-     struct t_MacAddr mac_addr0;                    /* 0x00C-0x010 MAC_ADDR_0...MAC_ADDR_1 */
-     uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
-     uint32_t   reserved2[5];
-     uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
-     uint32_t   reserved3[4];
-     uint32_t   ievent;             /* 0x040 IEVENT - Interrupt event register */
-     uint32_t   tx_ipg_length;      /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
-     uint32_t   reserved4;
-     uint32_t   imask;              /* 0x04C IMASK - Interrupt mask register */
-     uint32_t   reserved5;
-
-     uint32_t   pause_quanta[4];    /* 0x054 CL0x_PAUSE_QUANTA - CL0-7 Pause quanta register */
-     uint32_t   pause_thresh[4];    /* 0x064 CL0x_PAUSE_THRESH - CL0-7 Pause quanta threshold register */
-     uint32_t   rx_pause_status;    /* 0x074 RX_PAUSE_STATUS - Receive pause status register */
-     uint32_t   reserved6[2];
-     struct t_MacAddr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 MAC_ADDR_2...MAC_ADDR_15 */
-     uint32_t   lpwake_timer;       /* 0x0B8 LPWAKE_TIMER - EEE Low Power Wakeup Timer register */
-     uint32_t   sleep_timer;        /* 0x0BC SLEEP_TIMER - Transmit EEE Low Power Timer register */
-     uint32_t   reserved7[8];
-     uint32_t   statn_config;       /* 0x0E0 STATN_CONFIG - Statistics configuration register */
-     uint32_t   reserved8[7];
-
-    /* Rx Statistics Counter */
-     uint32_t   reoct_l;
-     uint32_t   reoct_u;
-     uint32_t   roct_l;
-     uint32_t   roct_u;
-     uint32_t   raln_l;
-     uint32_t   raln_u;
-     uint32_t   rxpf_l;
-     uint32_t   rxpf_u;
-     uint32_t   rfrm_l;
-     uint32_t   rfrm_u;
-     uint32_t   rfcs_l;
-     uint32_t   rfcs_u;
-     uint32_t   rvlan_l;
-     uint32_t   rvlan_u;
-     uint32_t   rerr_l;
-     uint32_t   rerr_u;
-     uint32_t   ruca_l;
-     uint32_t   ruca_u;
-     uint32_t   rmca_l;
-     uint32_t   rmca_u;
-     uint32_t   rbca_l;
-     uint32_t   rbca_u;
-     uint32_t   rdrp_l;
-     uint32_t   rdrp_u;
-     uint32_t   rpkt_l;
-     uint32_t   rpkt_u;
-     uint32_t   rund_l;
-     uint32_t   rund_u;
-     uint32_t   r64_l;
-     uint32_t   r64_u;
-     uint32_t   r127_l;
-     uint32_t   r127_u;
-     uint32_t   r255_l;
-     uint32_t   r255_u;
-     uint32_t   r511_l;
-     uint32_t   r511_u;
-     uint32_t   r1023_l;
-     uint32_t   r1023_u;
-     uint32_t   r1518_l;
-     uint32_t   r1518_u;
-     uint32_t   r1519x_l;
-     uint32_t   r1519x_u;
-     uint32_t   rovr_l;
-     uint32_t   rovr_u;
-     uint32_t   rjbr_l;
-     uint32_t   rjbr_u;
-     uint32_t   rfrg_l;
-     uint32_t   rfrg_u;
-     uint32_t   rcnp_l;
-     uint32_t   rcnp_u;
-     uint32_t   rdrntp_l;
-     uint32_t   rdrntp_u;
-     uint32_t   reserved9[12];
-
-    /* Tx Statistics Counter */
-     uint32_t   teoct_l;
-     uint32_t   teoct_u;
-     uint32_t   toct_l;
-     uint32_t   toct_u;
-     uint32_t   reserved10[2];
-     uint32_t   txpf_l;
-     uint32_t   txpf_u;
-     uint32_t   tfrm_l;
-     uint32_t   tfrm_u;
-     uint32_t   tfcs_l;
-     uint32_t   tfcs_u;
-     uint32_t   tvlan_l;
-     uint32_t   tvlan_u;
-     uint32_t   terr_l;
-     uint32_t   terr_u;
-     uint32_t   tuca_l;
-     uint32_t   tuca_u;
-     uint32_t   tmca_l;
-     uint32_t   tmca_u;
-     uint32_t   tbca_l;
-     uint32_t   tbca_u;
-     uint32_t   reserved11[2];
-     uint32_t   tpkt_l;
-     uint32_t   tpkt_u;
-     uint32_t   tund_l;
-     uint32_t   tund_u;
-     uint32_t   t64_l;
-     uint32_t   t64_u;
-     uint32_t   t127_l;
-     uint32_t   t127_u;
-     uint32_t   t255_l;
-     uint32_t   t255_u;
-     uint32_t   t511_l;
-     uint32_t   t511_u;
-     uint32_t   t1023_l;
-     uint32_t   t1023_u;
-     uint32_t   t1518_l;
-     uint32_t   t1518_u;
-     uint32_t   t1519x_l;
-     uint32_t   t1519x_u;
-     uint32_t   reserved12[6];
-     uint32_t   tcnp_l;
-     uint32_t   tcnp_u;
-     uint32_t   reserved13[14];
-
-    /* Line Interface Control */
-     uint32_t   if_mode;            /* 0x300 IF_MODE - Interface Mode Control register */
-     uint32_t   if_status;          /* 0x304 IF_STATUS - Interface Status register */
-     uint32_t   reserved14[14];
-
-    /* HiGig/2 */
-     uint32_t   hg_config;          /* 0x340 HG_CONFIG - HiGig/2 Control and configuration register */
-     uint32_t   reserved15[3];
-     uint32_t   hg_pause_quanta;    /* 0x350 HG_PAUSE_QUANTA - HiGig2 Pause quanta register */
-     uint32_t   reserved16[3];
-     uint32_t   hg_pause_thresh;    /* 0x360 HG_PAUSE_THRESH - HiGig2 Pause quanta threshold register */
-     uint32_t   reserved17[3];
-     uint32_t   hgrx_pause_status;  /* 0x370 HGRX_PAUSE_STATUS - HiGig2 Receive pause status register*/
-     uint32_t   hg_fifos_status;    /* 0x374 HG_FIFOS_STATUS - HiGig2 fifos status register */
-     uint32_t   rhm;                /* 0x378 RHM - Receive HiGig2 messages counter register */
-     uint32_t   thm;                /* 0x37C THM - Transmit HiGig2 messages counter register */
-};
-
-
-struct memac_cfg {
-
-    bool        reset_on_init;
-    bool        rx_error_discard;
-    bool        pause_ignore;
-    bool        pause_forward_enable;
-    bool        no_length_check_enable;
-    bool        cmd_frame_enable;
-    bool        send_idle_enable;
-    bool        wan_mode_enable;
-    bool        promiscuous_mode_enable;
-    bool        tx_addr_ins_enable;
-    bool        loopback_enable;
-    bool        lgth_check_nostdr;
-    bool        time_stamp_enable;
-    bool        pad_enable;
-    bool        phy_tx_ena_on;
-    bool        rx_sfd_any;
-    bool        rxPblFwd;
-    bool        txPblFwd;
-    bool        debugMode;
-    uint16_t    max_frame_length;
-    uint16_t    pause_quant;
-    uint32_t    tx_ipg_length;
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    bool        skip_fman11_workaround;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-};
-
-/**
- * memac_defconfig() - Get default MEMAC configuration
- * @cfg:    pointer to configuration structure.
- *
- * Call this function to obtain a default set of configuration values for
- * initializing MEMAC. The user can overwrite any of the values before calling
- * memac_init(), if specific configuration needs to be applied.
- */
-void memac_defconfig(struct memac_cfg *cfg);
-void memac_set_promiscuous(struct memac_regs *regs, bool val);
-void memac_hardware_add_addr_in_paddr(struct memac_regs *regs, uint8_t *adr, uint8_t paddr_num);
-void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs, uint8_t paddr_num);
-void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
-void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
-uint64_t memac_get_counter(struct memac_regs *regs, enum memac_counters reg_name);
-void memac_set_tx_pause_frames(struct memac_regs    *regs,
-                               uint8_t              priority,
-                               uint16_t             pauseTime,
-                               uint16_t             threshTime);
-uint16_t memac_get_max_frame_length(struct memac_regs *regs);
-void memac_init(struct memac_regs *regs, struct memac_cfg *cfg,
-        enum enet_interface enet_interface, enum enet_speed enet_speed,
-        uint32_t exceptions);
-void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
-void memac_reset_counter(struct memac_regs *regs);
-void memac_reset(struct memac_regs *regs);
-void memac_set_hash_table(struct memac_regs *regs, uint32_t val);
-void memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
-void memac_set_loopback(struct memac_regs *regs, bool enable);
-void memac_reset_counter(struct memac_regs *regs);
-
-
-#endif /*__FSL_FMAN_MEMAC_H*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
deleted file mode 100644
index 5495b82..0000000
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef __FSL_FMAN_TGEC_H
-#define __FSL_FMAN_TGEC_H
-
-#include "common/general.h"
-#include "fsl_enet.h"
-
-
-/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
-#define TX_IPG_LENGTH_MASK    0x000003ff
-
-enum tgec_counters {
-    E_TGEC_COUNTER_R64,
-    E_TGEC_COUNTER_R127,
-    E_TGEC_COUNTER_R255,
-    E_TGEC_COUNTER_R511,
-    E_TGEC_COUNTER_R1023,
-    E_TGEC_COUNTER_R1518,
-    E_TGEC_COUNTER_R1519X,
-    E_TGEC_COUNTER_TRFRG,
-    E_TGEC_COUNTER_TRJBR,
-    E_TGEC_COUNTER_RDRP,
-    E_TGEC_COUNTER_RALN,
-    E_TGEC_COUNTER_TRUND,
-    E_TGEC_COUNTER_TROVR,
-    E_TGEC_COUNTER_RXPF,
-    E_TGEC_COUNTER_TXPF,
-    E_TGEC_COUNTER_ROCT,
-    E_TGEC_COUNTER_RMCA,
-    E_TGEC_COUNTER_RBCA,
-    E_TGEC_COUNTER_RPKT,
-    E_TGEC_COUNTER_RUCA,
-    E_TGEC_COUNTER_RERR,
-    E_TGEC_COUNTER_TOCT,
-    E_TGEC_COUNTER_TMCA,
-    E_TGEC_COUNTER_TBCA,
-    E_TGEC_COUNTER_TUCA,
-    E_TGEC_COUNTER_TERR
-};
-
-/* Command and Configuration Register (COMMAND_CONFIG) */
-#define CMD_CFG_EN_TIMESTAMP        0x00100000
-#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000
-#define CMD_CFG_NO_LEN_CHK          0x00020000
-#define CMD_CFG_SEND_IDLE           0x00010000
-#define CMD_CFG_RX_ER_DISC          0x00004000
-#define CMD_CFG_CMD_FRM_EN          0x00002000
-#define CMD_CFG_STAT_CLR            0x00001000
-#define CMD_CFG_LOOPBACK_EN         0x00000400
-#define CMD_CFG_TX_ADDR_INS         0x00000200
-#define CMD_CFG_PAUSE_IGNORE        0x00000100
-#define CMD_CFG_PAUSE_FWD           0x00000080
-#define CMD_CFG_PROMIS_EN           0x00000010
-#define CMD_CFG_WAN_MODE            0x00000008
-#define CMD_CFG_RX_EN               0x00000002
-#define CMD_CFG_TX_EN               0x00000001
-
-/* Interrupt Mask Register (IMASK) */
-#define TGEC_IMASK_MDIO_SCAN_EVENT       0x00010000
-#define TGEC_IMASK_MDIO_CMD_CMPL         0x00008000
-#define TGEC_IMASK_REM_FAULT             0x00004000
-#define TGEC_IMASK_LOC_FAULT             0x00002000
-#define TGEC_IMASK_TX_ECC_ER             0x00001000
-#define TGEC_IMASK_TX_FIFO_UNFL          0x00000800
-#define TGEC_IMASK_TX_FIFO_OVFL          0x00000400
-#define TGEC_IMASK_TX_ER                 0x00000200
-#define TGEC_IMASK_RX_FIFO_OVFL          0x00000100
-#define TGEC_IMASK_RX_ECC_ER             0x00000080
-#define TGEC_IMASK_RX_JAB_FRM            0x00000040
-#define TGEC_IMASK_RX_OVRSZ_FRM          0x00000020
-#define TGEC_IMASK_RX_RUNT_FRM           0x00000010
-#define TGEC_IMASK_RX_FRAG_FRM           0x00000008
-#define TGEC_IMASK_RX_LEN_ER             0x00000004
-#define TGEC_IMASK_RX_CRC_ER             0x00000002
-#define TGEC_IMASK_RX_ALIGN_ER           0x00000001
-
-
-#define EVENTS_MASK ((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT    | \
-                TGEC_IMASK_MDIO_CMD_CMPL     | \
-                TGEC_IMASK_REM_FAULT         | \
-                TGEC_IMASK_LOC_FAULT         | \
-                TGEC_IMASK_TX_ECC_ER         | \
-                TGEC_IMASK_TX_FIFO_UNFL      | \
-                TGEC_IMASK_TX_FIFO_OVFL      | \
-                TGEC_IMASK_TX_ER             | \
-                TGEC_IMASK_RX_FIFO_OVFL      | \
-                TGEC_IMASK_RX_ECC_ER         | \
-                TGEC_IMASK_RX_JAB_FRM        | \
-                TGEC_IMASK_RX_OVRSZ_FRM      | \
-                TGEC_IMASK_RX_RUNT_FRM       | \
-                TGEC_IMASK_RX_FRAG_FRM       | \
-                TGEC_IMASK_RX_LEN_ER         | \
-                TGEC_IMASK_RX_CRC_ER         | \
-                TGEC_IMASK_RX_ALIGN_ER))
-
-/* Hashtable Control Register (HASHTABLE_CTRL) */
-#define TGEC_HASH_MCAST_SHIFT  23
-#define TGEC_HASH_MCAST_EN     0x00000200
-#define TGEC_HASH_ADR_MSK      0x000001ff
-
-/*
- * 10G memory map
- */
-struct tgec_regs {
-    uint32_t tgec_id;            /* 0x000 Controller ID */
-    uint32_t scratch;            /* 0x004  */
-    uint32_t command_config;     /* 0x008 Control and configuration */
-    uint32_t mac_addr_0;         /* 0x00c Lower 32 bits of the MAC adr */
-    uint32_t mac_addr_1;         /* 0x010 Upper 16 bits of the MAC adr */
-    uint32_t maxfrm;             /* 0x014 Maximum frame length */
-    uint32_t pause_quant;        /* 0x018 Pause quanta */
-    uint32_t rx_fifo_sections;   /* 0x01c  */
-    uint32_t tx_fifo_sections;   /* 0x020  */
-    uint32_t rx_fifo_almost_f_e; /* 0x024  */
-    uint32_t tx_fifo_almost_f_e; /* 0x028  */
-    uint32_t hashtable_ctrl;     /* 0x02c Hash table control*/
-    uint32_t mdio_cfg_status;    /* 0x030  */
-    uint32_t mdio_command;       /* 0x034  */
-    uint32_t mdio_data;          /* 0x038  */
-    uint32_t mdio_regaddr;       /* 0x03c  */
-    uint32_t status;             /* 0x040  */
-    uint32_t tx_ipg_len;         /* 0x044 Transmitter inter-packet-gap */
-    uint32_t mac_addr_2;         /* 0x048 Lower 32 bits of 2nd MAC adr */
-    uint32_t mac_addr_3;         /* 0x04c Upper 16 bits of 2nd MAC adr */
-    uint32_t rx_fifo_ptr_rd;     /* 0x050  */
-    uint32_t rx_fifo_ptr_wr;     /* 0x054  */
-    uint32_t tx_fifo_ptr_rd;     /* 0x058  */
-    uint32_t tx_fifo_ptr_wr;     /* 0x05c  */
-    uint32_t imask;              /* 0x060 Interrupt mask */
-    uint32_t ievent;             /* 0x064 Interrupt event */
-    uint32_t udp_port;           /* 0x068 Defines a UDP Port number.
-                                          When an UDP/IP frame is received with
-                                          a matching UDP destination port, the
-                                          receive status indication pin
-                                          ff_rx_ts_frm will be asserted. */
-    uint32_t type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames.
-                                          IEEE1588 defines the type 0x88f7 for
-                                          1588 frames. */
-    uint32_t reserved070[4];     /* 0x070 */
-    /*10Ge Statistics Counter */
-    uint32_t tfrm_u;            /* 80 aFramesTransmittedOK */
-    uint32_t tfrm_l;            /* 84 aFramesTransmittedOK */
-    uint32_t rfrm_u;            /* 88 aFramesReceivedOK */
-    uint32_t rfrm_l;            /* 8c aFramesReceivedOK */
-    uint32_t rfcs_u;            /* 90 aFrameCheckSequenceErrors */
-    uint32_t rfcs_l;            /* 94 aFrameCheckSequenceErrors */
-    uint32_t raln_u;            /* 98 aAlignmentErrors */
-    uint32_t raln_l;            /* 9c aAlignmentErrors */
-    uint32_t txpf_u;            /* A0 aPAUSEMACCtrlFramesTransmitted */
-    uint32_t txpf_l;            /* A4 aPAUSEMACCtrlFramesTransmitted */
-    uint32_t rxpf_u;            /* A8 aPAUSEMACCtrlFramesReceived */
-    uint32_t rxpf_l;            /* Ac aPAUSEMACCtrlFramesReceived */
-    uint32_t rlong_u;           /* B0 aFrameTooLongErrors */
-    uint32_t rlong_l;           /* B4 aFrameTooLongErrors */
-    uint32_t rflr_u;            /* B8 aInRangeLengthErrors */
-    uint32_t rflr_l;            /* Bc aInRangeLengthErrors */
-    uint32_t tvlan_u;           /* C0 VLANTransmittedOK */
-    uint32_t tvlan_l;           /* C4 VLANTransmittedOK */
-    uint32_t rvlan_u;           /* C8 VLANReceivedOK */
-    uint32_t rvlan_l;           /* Cc VLANReceivedOK */
-    uint32_t toct_u;            /* D0 ifOutOctets */
-    uint32_t toct_l;            /* D4 ifOutOctets */
-    uint32_t roct_u;            /* D8 ifInOctets */
-    uint32_t roct_l;            /* Dc ifInOctets */
-    uint32_t ruca_u;            /* E0 ifInUcastPkts */
-    uint32_t ruca_l;            /* E4 ifInUcastPkts */
-    uint32_t rmca_u;            /* E8 ifInMulticastPkts */
-    uint32_t rmca_l;            /* Ec ifInMulticastPkts */
-    uint32_t rbca_u;            /* F0 ifInBroadcastPkts */
-    uint32_t rbca_l;            /* F4 ifInBroadcastPkts */
-    uint32_t terr_u;            /* F8 ifOutErrors */
-    uint32_t terr_l;            /* Fc ifOutErrors */
-    uint32_t reserved100[2];    /* 100-108*/
-    uint32_t tuca_u;            /* 108 ifOutUcastPkts */
-    uint32_t tuca_l;            /* 10c ifOutUcastPkts */
-    uint32_t tmca_u;            /* 110 ifOutMulticastPkts */
-    uint32_t tmca_l;            /* 114 ifOutMulticastPkts */
-    uint32_t tbca_u;            /* 118 ifOutBroadcastPkts */
-    uint32_t tbca_l;            /* 11c ifOutBroadcastPkts */
-    uint32_t rdrp_u;            /* 120 etherStatsDropEvents */
-    uint32_t rdrp_l;            /* 124 etherStatsDropEvents */
-    uint32_t reoct_u;           /* 128 etherStatsOctets */
-    uint32_t reoct_l;           /* 12c etherStatsOctets */
-    uint32_t rpkt_u;            /* 130 etherStatsPkts */
-    uint32_t rpkt_l;            /* 134 etherStatsPkts */
-    uint32_t trund_u;           /* 138 etherStatsUndersizePkts */
-    uint32_t trund_l;           /* 13c etherStatsUndersizePkts */
-    uint32_t r64_u;             /* 140 etherStatsPkts64Octets */
-    uint32_t r64_l;             /* 144 etherStatsPkts64Octets */
-    uint32_t r127_u;            /* 148 etherStatsPkts65to127Octets */
-    uint32_t r127_l;            /* 14c etherStatsPkts65to127Octets */
-    uint32_t r255_u;            /* 150 etherStatsPkts128to255Octets */
-    uint32_t r255_l;            /* 154 etherStatsPkts128to255Octets */
-    uint32_t r511_u;            /* 158 etherStatsPkts256to511Octets */
-    uint32_t r511_l;            /* 15c etherStatsPkts256to511Octets */
-    uint32_t r1023_u;           /* 160 etherStatsPkts512to1023Octets */
-    uint32_t r1023_l;           /* 164 etherStatsPkts512to1023Octets */
-    uint32_t r1518_u;           /* 168 etherStatsPkts1024to1518Octets */
-    uint32_t r1518_l;           /* 16c etherStatsPkts1024to1518Octets */
-    uint32_t r1519x_u;          /* 170 etherStatsPkts1519toX */
-    uint32_t r1519x_l;          /* 174 etherStatsPkts1519toX */
-    uint32_t trovr_u;           /* 178 etherStatsOversizePkts */
-    uint32_t trovr_l;           /* 17c etherStatsOversizePkts */
-    uint32_t trjbr_u;           /* 180 etherStatsJabbers */
-    uint32_t trjbr_l;           /* 184 etherStatsJabbers */
-    uint32_t trfrg_u;           /* 188 etherStatsFragments */
-    uint32_t trfrg_l;           /* 18C etherStatsFragments */
-    uint32_t rerr_u;            /* 190 ifInErrors */
-    uint32_t rerr_l;            /* 194 ifInErrors */
-};
-
-
-/**
- * struct tgec_cfg - TGEC configuration
- *
- * @rx_error_discard:    Receive Erroneous Frame Discard Enable. When set to 1
- *            any frame received with an error is discarded in the
- *            Core and not forwarded to the Client interface.
- *            When set to 0 (Reset value), erroneous Frames are
- *            forwarded to the Client interface with ff_rx_err
- *            asserted.
- * @pause_ignore:    Ignore Pause Frame Quanta. If set to 1 received pause
- *            frames are ignored by the MAC. When set to 0
- *            (Reset value) the transmit process is stopped for the
- *            amount of time specified in the pause quanta received
- *            within a pause frame.
- * @pause_forward_enable:
- *            Terminate / Forward Pause Frames. If set to 1 pause
- *            frames are forwarded to the user application. When set
- *            to 0 (Reset value) pause frames are terminated and
- *            discarded within the MAC.
- * @no_length_check_enable:
- *            Payload Length Check Disable. When set to 0
- *            (Reset value), the Core checks the frame's payload
- *            length with the Frame Length/Type field, when set to 1
- *            the payload length check is disabled.
- * @cmd_frame_enable:    Enables reception of all command frames. When set to 1
- *            all Command Frames are accepted, when set to 0
- *            (Reset Value) only Pause Frames are accepted and all
- *            other Command Frames are rejected.
- * @send_idle_enable:    Force Idle Generation. When set to 1, the MAC
- *            permanently sends XGMII Idle sequences even when faults
- *            are received.
- * @wan_mode_enable:    WAN Mode Enable. Sets WAN mode (1) or LAN mode
- *            (0, default) of operation.
- * @promiscuous_mode_enable:
- *            Enables MAC promiscuous operation. When set to 1, all
- *            frames are received without any MAC address filtering,
- *            when set to 0 (Reset value) Unicast Frames with a
- *            destination address not matching the Core MAC Address
- *            (MAC Address programmed in Registers MAC_ADDR_0 and
- *            MAC_ADDR_1 or the MAC address programmed in Registers
- *            MAC_ADDR_2 and MAC_ADDR_3) are rejected.
- * @tx_addr_ins_enable:    Set Source MAC Address on Transmit. If set to 1 the
- *            MAC overwrites the source MAC address received from the
- *            Client Interface with one of the MAC addresses. If set
- *            to 0 (Reset value), the source MAC address from the
- *            Client Interface is transmitted unmodified to the line.
- * @loopback_enable:    PHY Interface Loopback. When set to 1, the signal
- *            loop_ena is set to '1', when set to 0 (Reset value)
- *            the signal loop_ena is set to 0.
- * @lgth_check_nostdr:    The Core interprets the Length/Type field differently
- *            depending on the value of this Bit
- * @time_stamp_enable:    This bit selects between enabling and disabling the
- *            IEEE 1588 functionality. 1: IEEE 1588 is enabled
- *            0: IEEE 1588 is disabled
- * @max_frame_length:    Maximum supported received frame length.
- *            The 10GEC MAC supports reception of any frame size up
- *            to 16,352 bytes (0x3FE0). Typical settings are
- *            0x05EE (1,518 bytes) for standard frames.
- *            Default setting is 0x0600 (1,536 bytes).
- *            Received frames that exceed this stated maximum
- *            are truncated.
- * @pause_quant:    Pause quanta value used with transmitted pause frames.
- *            Each quanta represents a 512 bit-times.
- * @tx_ipg_length:    Transmit Inter-Packet-Gap (IPG) value. A 6-bit value:
- *            Depending on LAN or WAN mode of operation the value has
- *            the following meaning: - LAN Mode: Number of octets in
- *            steps of 4. Valid values are 8, 12, 16, ... 100. DIC is
- *            fully supported (see 10.6.1 page 49) for any setting. A
- *            default of 12 (reset value) must be set to conform to
- *            IEEE802.3ae. Warning: When set to 8, PCS layers may not
- *            be able to perform clock rate compensation. - WAN Mode:
- *            Stretch factor. Valid values are 4..15. The stretch
- *            factor is calculated as (value+1)*8. A default of 12
- *            (reset value) must be set to conform to IEEE 802.3ae
- *            (i.e. 13*8=104). A larger value shrinks the IPG
- *            (increasing bandwidth).
- *
- * This structure contains basic TGEC configuration and must be passed to
- * tgec_init() function.  A default set of configuration values can be obtained
- * by calling tgec_defconfig().
- */
-struct tgec_cfg {
-    bool        rx_error_discard;
-    bool        pause_ignore;
-    bool        pause_forward_enable;
-    bool        no_length_check_enable;
-    bool        cmd_frame_enable;
-    bool        send_idle_enable;
-    bool        wan_mode_enable;
-    bool        promiscuous_mode_enable;
-    bool        tx_addr_ins_enable;
-    bool        loopback_enable;
-    bool        lgth_check_nostdr;
-    bool        time_stamp_enable;
-    uint16_t    max_frame_length;
-    uint16_t    pause_quant;
-    uint32_t    tx_ipg_length;
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    bool        skip_fman11_workaround;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-};
-
-void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *macaddr);
-
-/**
- * tgec_reset_stat() - Completely resets all TGEC HW counters
- * @regs:    Pointer to TGEC register block
- */
-void tgec_reset_stat(struct tgec_regs *regs);
-
-/**
- * tgec_get_counter() - Reads TGEC HW counters
- * @regs:    Pointer to TGEC register block
- * @reg_name:    Counter name according to the appropriate enum
- *
- * Returns:    Required counter value
- */
-
-uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
-
-
-void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
-void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
-void tgec_set_promiscuous(struct tgec_regs *regs, bool val);
-
-/**
- * tgec_set_hash_table() - Sets the Hashtable Control Register
- * @regs:    Pointer to TGEC register block
- * @value:    Value to be written in Hashtable Control Register
- */
-void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value);
-
-/**
- * tgec_tx_mac_pause() - Sets the Pause Quanta Register
- * @regs:    Pointer to TGEC register block
- * @pause_time:    Pause quanta value used with transmitted pause frames.
- *        Each quanta represents a 512 bit-times
- */
-
-void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time);
-
-/**
- * tgec_rx_ignore_mac_pause() - Changes the policy WRT pause frames
- * @regs:    Pointer to TGEC register block
- * @en:        Ignore/Respond to pause frame quanta
- *
- * Sets the value of PAUSE_IGNORE field in the COMMAND_CONFIG Register
- * 0 - MAC stops transmit process for the duration specified
- * in the Pause frame quanta of a received Pause frame.
- * 1 - MAC ignores received Pause frames.
- */
-
-void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en);
-
-/**
- * tgec_enable_1588_time_stamp() - change timestamp functionality
- * @regs:    Pointer to TGEC register block
- * @en:        enable/disable timestamp functionality
- *
- * Sets the value of EN_TIMESTAMP field in the COMMAND_CONFIG Register
- * IEEE 1588 timestamp functionality control:
- * 0 disabled, 1 enabled
- */
-
-void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en);
-
-uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask);
-void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask);
-uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs);
-
-
-/**
- * tgec_add_addr_in_paddr() - Sets additional exact match MAC address
- * @regs:    Pointer to TGEC register block
- * @addr_ptr:    Pointer to 6-byte array containing the MAC address
- *
- * Sets the additional station MAC address
- */
-
-void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *addr_ptr);
-void tgec_clear_addr_in_paddr(struct tgec_regs *regs);
-uint32_t tgec_get_revision(struct tgec_regs *regs);
-void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
-void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
-
-/**
- * tgec_get_max_frame_len() - Returns the maximum frame length value
- * @regs:    Pointer to TGEC register block
- */
-
-uint16_t tgec_get_max_frame_len(struct tgec_regs *regs);
-
-/**
- * tgec_defconfig() - Initialize the main tgec configuration parameters
- * @cfg:    Pointer to tgec_cfg structure
- *
- * This routine determines the values of the tgec_cfg structure members.
- * This structure represents the initial parameters which the tgec controller
- * will be initialized with later when calling the tgec_init function.
- */
-
-void tgec_defconfig(struct tgec_cfg *cfg);
-
-/**
- * tgec_init() - Init tgec hardware block
- * @regs:        Pointer to tgec register block
- * @cfg:        tgec configuration data
- * @exceptions_mask:    initial exceptions mask
- *
- * This function initializes the tgec controller and applies its
- * basic configuration.
- *
- * Returns: 0 if successful, an error code otherwise.
- */
-
-int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
-        uint32_t exception_mask);
-
-
-void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs);
-#endif /* __FSL_FMAN_TGEC_H */
-
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
index 0267b78..6e5440d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
@@ -51,6 +51,35 @@
 /*****************************************************************************/
 /*                      Internal routines                                    */
 /*****************************************************************************/
+
+/* ......................................................................... */
+
+static uint32_t GetMacAddrHashCode(uint64_t ethAddr)
+{
+    uint64_t    mask1, mask2;
+    uint32_t    xor = 0;
+    uint8_t     i, j;
+
+    for (i=0; i < 6; i++)
+    {
+        mask1 = ethAddr & (uint64_t)0x01;
+        ethAddr >>= 1;
+
+        for (j=0; j < 7; j++)
+        {
+            mask2 = ethAddr & (uint64_t)0x01;
+            mask1 ^= mask2;
+            ethAddr >>= 1;
+        }
+        xor |= (mask1 << (5-i));
+    }
+
+    return xor;
+}
+
+
+/* ......................................................................... */
+
 static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
 {
     uint16_t    tmpReg16;
@@ -64,15 +93,59 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x4, tmpReg16);
 
     /* Adjust link timer for SGMII  -
-       1.6 ms in units of 8 ns = 2 * 10^5 = 0x30d40 */
-    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x13, 0x0003);
-    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x12, 0x0d40);
+       According to Cisco SGMII specification the timer should be 1.6 ms.
+       The link_timer register is configured in units of the clock.
+       - When running as 1G SGMII, Serdes clock is 125 MHz, so
+         unit = 1 / (125*10^6 Hz) = 8 ns.
+         1.6 ms in units of 8 ns = 1.6ms / 8ns = 2 * 10^5 = 0x30d40
+       - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so
+         unit = 1 / (312.5*10^6 Hz) = 3.2 ns.
+         1.6 ms in units of 3.2 ns = 1.6ms / 3.2ns = 5 * 10^5 = 0x7a120.
+       Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,
+       we always set up here a value of 2.5 SGMII. */
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x13, 0x0007);
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x12, 0xa120);
+
+    /* Restart AN */
+    tmpReg16 = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x0, tmpReg16);
+}
+
+/* ......................................................................... */
+
+static void SetupSgmiiInternalPhyBaseX(t_Memac *p_Memac, uint8_t phyAddr)
+{
+    uint16_t    tmpReg16;
+
+    /* 1000BaseX mode */
+    tmpReg16 = PHY_SGMII_IF_MODE_1000X;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x14, tmpReg16);
+
+    /* AN Device capability  */
+    tmpReg16 = PHY_SGMII_DEV_ABILITY_1000X;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x4, tmpReg16);
+
+    /* Adjust link timer for SGMII  -
+       For Serdes 1000BaseX auto-negotiation the timer should be 10 ms.
+       The link_timer register is configured in units of the clock.
+       - When running as 1G SGMII, Serdes clock is 125 MHz, so
+         unit = 1 / (125*10^6 Hz) = 8 ns.
+         10 ms in units of 8 ns = 10ms / 8ns = 1250000 = 0x1312d0
+       - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so
+         unit = 1 / (312.5*10^6 Hz) = 3.2 ns.
+         10 ms in units of 3.2 ns = 10ms / 3.2ns = 3125000 = 0x2faf08.
+       Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,
+       we always set up here a value of 2.5 SGMII. */
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x13, 0x002f);
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x12, 0xaf08);
 
     /* Restart AN */
     tmpReg16 = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x0, tmpReg16);
 }
 
+/* ......................................................................... */
+
 static t_Error CheckInitParameters(t_Memac *p_Memac)
 {
     e_FmMacType portType;
@@ -100,39 +173,55 @@ static t_Error CheckInitParameters(t_Memac *p_Memac)
     return E_OK;
 }
 
-
 /* ........................................................................... */
 
 static void MemacErrException(t_Handle h_Memac)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
-    uint32_t    event;
+    struct memac_regs   *regs = p_Memac->p_MemMap;
+    uint32_t    event, imsk;
+
+    event = memac_get_event(regs, 0xffffffff);
 
-    event = GET_UINT32(p_Memac->p_MemMap->ievent);
-    /* do not handle MDIO events */
-    //event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+    /*
+     * Apparently the imask bits are shifted by 16 bits offset from
+     * their corresponding bits in the ievent - hence the >> 16
+     */
+    imsk = memac_get_interrupt_mask(regs) >> 16;;
 
-    event &= GET_UINT32(p_Memac->p_MemMap->imask);
+    /*
+     * Extract all event bits plus the pending interrupts according to
+     * their imask
+     */
+    event = (event & ~(MEMAC_ALL_IMASKS >> 16)) | (event & imsk);
 
-    WRITE_UINT32(p_Memac->p_MemMap->ievent, event);
+    /* Ignoring the status bits */
+    event = event & ~(MEMAC_IEVNT_RX_EMPTY |
+                      MEMAC_IEVNT_TX_EMPTY |
+                      MEMAC_IEVNT_RX_LOWP |
+                      MEMAC_IEVNT_PHY_LOS);
 
-    if (event & IMASK_RX_FIFO_OVFL)
+    memac_ack_event(regs, event);
+
+    if (event & MEMAC_IEVNT_RX_FIFO_OVFL)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
-    if (event & IMASK_TX_FIFO_UNFL)
+    if (event & MEMAC_IEVNT_TX_FIFO_UNFL)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
-    if (event & IMASK_TX_FIFO_OVFL)
+    if (event & MEMAC_IEVNT_TX_FIFO_OVFL)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
-    if (event & IMASK_TX_ECC_ER)
+    if (event & MEMAC_IEVNT_TX_ECC_ER)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
-    if (event & IMASK_RX_ECC_ER)
+    if (event & MEMAC_IEVNT_RX_ECC_ER)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
-    if (event & IMASK_REM_FAULT)
+    if (event & MEMAC_IEVNT_REM_FAULT)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_REM_FAULT);
-    if (event & IMASK_LOC_FAULT)
+    if (event & MEMAC_IEVNT_LOC_FAULT)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
 }
 
 
+/* ......................................................................... */
+
 static void FreeInitResources(t_Memac *p_Memac)
 {
     e_FmMacType portType;
@@ -159,7 +248,7 @@ static void FreeInitResources(t_Memac *p_Memac)
 /*                     mEMAC API routines                                    */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
 {
@@ -173,7 +262,7 @@ static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
 {
@@ -187,7 +276,7 @@ static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
 {
@@ -201,12 +290,26 @@ static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
     return E_OK;
 }
 
+/* .............................................................................. */
+
+static t_Error MemacAdjustLink(t_Handle h_Memac, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+UNUSED(p_Memac);
+DBG(WARNING, ("mEMAC works in automatic-mode; therefore, adjust-link is not needed!"));
+
+    return E_OK;
+}
+
 
 /*****************************************************************************/
 /*                      Memac Configs modification functions                 */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
 {
@@ -220,7 +323,7 @@ static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
 {
@@ -234,7 +337,7 @@ static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigMaxFrameLength(t_Handle h_Memac, uint16_t newVal)
 {
@@ -248,7 +351,7 @@ static t_Error MemacConfigMaxFrameLength(t_Handle h_Memac, uint16_t newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigPad(t_Handle h_Memac, bool newVal)
 {
@@ -262,7 +365,7 @@ static t_Error MemacConfigPad(t_Handle h_Memac, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
 {
@@ -276,7 +379,7 @@ static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigException(t_Handle h_Memac, e_FmMacExceptions exception, bool enable)
 {
@@ -300,8 +403,7 @@ static t_Error MemacConfigException(t_Handle h_Memac, e_FmMacExceptions exceptio
     return E_OK;
 }
 
-
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacConfigResetOnInit(t_Handle h_Memac, bool enable)
 {
@@ -320,6 +422,8 @@ static t_Error MemacConfigResetOnInit(t_Handle h_Memac, bool enable)
 /*                      Memac Run Time API functions                         */
 /*****************************************************************************/
 
+/* ......................................................................... */
+
 static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
                                      uint8_t  priority,
                                      uint16_t pauseTime,
@@ -335,7 +439,7 @@ static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacSetTxAutoPauseFrames(t_Handle h_Memac,
                                          uint16_t pauseTime)
@@ -343,7 +447,7 @@ static t_Error MemacSetTxAutoPauseFrames(t_Handle h_Memac,
     return MemacSetTxPauseFrames(h_Memac, FM_MAC_NO_PFC, pauseTime, 0);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
 {
@@ -357,9 +461,23 @@ static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
     return E_OK;
 }
 
-/* Counters handling */
 /* .............................................................................. */
 
+static t_Error MemacEnable1588TimeStamp(t_Handle h_Memac)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+UNUSED(p_Memac);
+DBG(WARNING, ("mEMAC has 1588 always enabled!"));
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* ......................................................................... */
+
 static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statistics)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
@@ -390,28 +508,30 @@ static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statist
 
 /* MIB II */
     p_Statistics->ifInOctets            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROCT);
+    p_Statistics->ifInUcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RUCA);
     p_Statistics->ifInMcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RMCA);
     p_Statistics->ifInBcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RBCA);
-    p_Statistics->ifInPkts              = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RUCA)
+    p_Statistics->ifInPkts              = p_Statistics->ifInUcastPkts
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
     p_Statistics->ifInErrors            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RERR);
 
     p_Statistics->ifOutOctets           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TOCT);
+    p_Statistics->ifOutUcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUCA);
     p_Statistics->ifOutMcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TMCA);
     p_Statistics->ifOutBcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TBCA);
-    p_Statistics->ifOutPkts             = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUCA)
-                                            + p_Statistics->ifOutMcastPkts
-                                            + p_Statistics->ifOutBcastPkts;
+    p_Statistics->ifOutPkts             = p_Statistics->ifOutUcastPkts
+                                        + p_Statistics->ifOutMcastPkts
+                                        + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
     p_Statistics->ifOutErrors           = memac_get_counter(p_Memac->p_MemMap,  E_MEMAC_COUNTER_TERR);
 
     return E_OK;
 }
 
+/* ......................................................................... */
 
-/* .............................................................................. */
 static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
@@ -424,7 +544,7 @@ static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacResetCounters (t_Handle h_Memac)
 {
@@ -438,7 +558,7 @@ static t_Error MemacResetCounters (t_Handle h_Memac)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
@@ -481,7 +601,7 @@ static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
     RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
@@ -513,13 +633,12 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
     RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
     t_Memac             *p_Memac = (t_Memac *)h_Memac;
     t_EthHashEntry      *p_HashEntry;
-    uint32_t            crc;
     uint32_t            hash;
     uint64_t            ethAddr;
 
@@ -532,10 +651,7 @@ static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
         /* Unicast addresses not supported in hash */
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
 
-    /* CRC calculation */
-    crc = get_mac_addr_crc(ethAddr);
-
-    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+    hash = GetMacAddrHashCode(ethAddr) & HASH_CTRL_ADDR_MASK;
 
     /* Create element to be added to the driver hash table */
     p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
@@ -548,14 +664,13 @@ static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
     t_Memac             *p_Memac = (t_Memac *)h_Memac;
     t_EthHashEntry      *p_HashEntry = NULL;
     t_List              *p_Pos;
-    uint32_t            crc;
     uint32_t            hash;
     uint64_t            ethAddr;
 
@@ -564,10 +679,7 @@ static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 
     ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    /* CRC calculation */
-    crc = get_mac_addr_crc(ethAddr);
-
-    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+    hash = GetMacAddrHashCode(ethAddr) & HASH_CTRL_ADDR_MASK;
 
     LIST_FOR_EACH(p_Pos, &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
     {
@@ -585,9 +697,8 @@ static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacSetException(t_Handle h_Memac, e_FmMacExceptions exception, bool enable)
 {
@@ -613,8 +724,7 @@ static t_Error MemacSetException(t_Handle h_Memac, e_FmMacExceptions exception,
     return E_OK;
 }
 
-
-/* .............................................................................. */
+/* ......................................................................... */
 
 static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
 {
@@ -626,7 +736,7 @@ static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
     return memac_get_max_frame_length(p_Memac->p_MemMap);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 static t_Error MemacDumpRegs(t_Handle h_Memac)
@@ -688,7 +798,7 @@ static t_Error MemacDumpRegs(t_Handle h_Memac)
 /*                      mEMAC Init & Free API                                   */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacInit(t_Handle h_Memac)
 {
@@ -735,7 +845,10 @@ static t_Error MemacInit(t_Handle h_Memac)
     if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_SGMII)
     {
         /* Configure internal SGMII PHY */
-        SetupSgmiiInternalPhy(p_Memac, PHY_MDIO_ADDR);
+        if (p_Memac->enetMode & ENET_IF_SGMII_BASEX)
+            SetupSgmiiInternalPhyBaseX(p_Memac, PHY_MDIO_ADDR);
+        else
+            SetupSgmiiInternalPhy(p_Memac, PHY_MDIO_ADDR);
     }
     else if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_QSGMII)
     {
@@ -747,7 +860,10 @@ static t_Error MemacInit(t_Handle h_Memac)
                register address space and access each one of 4
                ports inside QSGMII. */
             phyAddr = (uint8_t)((PHY_MDIO_ADDR << 2) | i);
-            SetupSgmiiInternalPhy(p_Memac, phyAddr);
+            if (p_Memac->enetMode & ENET_IF_SGMII_BASEX)
+                SetupSgmiiInternalPhyBaseX(p_Memac, phyAddr);
+            else
+                SetupSgmiiInternalPhy(p_Memac, phyAddr);
         }
     }
 
@@ -756,6 +872,8 @@ static t_Error MemacInit(t_Handle h_Memac)
                            portType,
                            p_Memac->fmMacControllerDriver.macId,
                            p_MemacDriverParam->max_frame_length);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("settings Mac max frame length is FAILED"));
 
     p_Memac->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if (!p_Memac->p_MulticastAddrHash)
@@ -771,20 +889,13 @@ static t_Error MemacInit(t_Handle h_Memac)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
     }
 
-    if (portType == e_FM_MAC_10G)
-        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
-                       e_FM_MOD_10G_MAC,
-                       p_Memac->macId,
-                       e_FM_INTR_TYPE_ERR,
-                       MemacErrException,
-                       p_Memac);
-    else
-        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
-                       e_FM_MOD_1G_MAC,
-                       p_Memac->macId,
-                       e_FM_INTR_TYPE_ERR,
-                       MemacErrException,
-                       p_Memac);
+    FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
+                   (portType == e_FM_MAC_10G) ? e_FM_MOD_10G_MAC : e_FM_MOD_1G_MAC,
+                   p_Memac->macId,
+                   e_FM_INTR_TYPE_ERR,
+                   MemacErrException,
+                   p_Memac);
+
 
     XX_Free(p_MemacDriverParam);
     p_Memac->p_MemacDriverParam = NULL;
@@ -792,7 +903,7 @@ static t_Error MemacInit(t_Handle h_Memac)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error MemacFree(t_Handle h_Memac)
 {
@@ -812,7 +923,7 @@ static t_Error MemacFree(t_Handle h_Memac)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
 {
@@ -834,11 +945,11 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_SetException              = MemacSetException;
 
-    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = NULL; /*MemacEnable1588TimeStamp;*/
-    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL; /*MemacDisable1588TimeStamp;*/
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = MemacEnable1588TimeStamp; /* always enabled */
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = MemacSetPromiscuous;
-    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = MemacAdjustLink;
     p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = MemacEnable;
@@ -873,7 +984,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 /*                      mEMAC Config Main Entry                             */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
 {
@@ -916,7 +1027,7 @@ t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
 
     p_Memac->enetMode       = p_FmMacParam->enetMode;
     p_Memac->macId          = p_FmMacParam->macId;
-    p_Memac->exceptions     = DEFAULT_exceptions;
+    p_Memac->exceptions     = MEMAC_default_exceptions;
     p_Memac->f_Exception    = p_FmMacParam->f_Exception;
     p_Memac->f_Event        = p_FmMacParam->f_Event;
     p_Memac->h_App          = p_FmMacParam->h_App;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
index c5c7da0..e1c4c53 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
@@ -48,30 +48,15 @@
 #include "fsl_fman_memac.h"
 
 
+#define MEMAC_default_exceptions    ((uint32_t)(MEMAC_IMASK_TECC_ER | MEMAC_IMASK_RECC_ER))
+
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch (exception){    \
-    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                      \
-        bitMask = IMASK_RX_FIFO_OVFL; break;                                \
-    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                      \
-        bitMask = IMASK_TX_FIFO_UNFL; break;                                \
-    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                      \
-        bitMask = IMASK_TX_FIFO_OVFL; break;                                \
     case e_FM_MAC_EX_10G_1TX_ECC_ER:                                        \
-        bitMask = IMASK_TX_ECC_ER; break;                                   \
+        bitMask = MEMAC_IMASK_TECC_ER; break;                               \
     case e_FM_MAC_EX_10G_RX_ECC_ER:                                         \
-        bitMask = IMASK_RX_ECC_ER; break;                                   \
-    case e_FM_MAC_EX_10G_REM_FAULT:                                         \
-        bitMask = IMASK_REM_FAULT; break;                                   \
-    case e_FM_MAC_EX_10G_LOC_FAULT:                                         \
-        bitMask = IMASK_LOC_FAULT; break;                                           \
+        bitMask = MEMAC_IMASK_RECC_ER; break;                                     \
     default: bitMask = 0;break;}
 
-#define DEFAULT_exceptions          ((uint32_t)(IMASK_RX_FIFO_OVFL  |  \
-                                                IMASK_TX_FIFO_UNFL  |  \
-                                                IMASK_TX_FIFO_OVFL  |  \
-                                                IMASK_TX_ECC_ER     |  \
-                                                IMASK_RX_ECC_ER     |  \
-                                                IMASK_REM_FAULT     |  \
-                                                IMASK_LOC_FAULT))
 
 typedef struct
 {
@@ -94,13 +79,26 @@ typedef struct
     uint32_t                    exceptions;
     struct memac_cfg            *p_MemacDriverParam;
 } t_Memac;
-/* Internal PHY access */
 
+
+/* Internal PHY access */
 #define PHY_MDIO_ADDR               0
 
+/* Internal PHY Registers - SGMII */
+#define PHY_SGMII_CR_PHY_RESET          0x8000
+#define PHY_SGMII_CR_RESET_AN           0x0200
+#define PHY_SGMII_CR_DEF_VAL            0x1140
+#define PHY_SGMII_DEV_ABILITY_SGMII     0x4001
+#define PHY_SGMII_DEV_ABILITY_1000X     0x01A0
+#define PHY_SGMII_IF_MODE_AN            0x0002
+#define PHY_SGMII_IF_MODE_SGMII         0x0001
+#define PHY_SGMII_IF_MODE_1000X         0x0000
+
+
 #define MEMAC_TO_MII_OFFSET         0x030       /* Offset from the MEM map to the MDIO mem map */
 
 t_Error MEMAC_MII_WritePhyReg(t_Handle h_Memac, uint8_t phyAddr, uint8_t reg, uint16_t data);
 t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
+
 #endif /* __MEMAC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
index 23f732d..be5b867 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
@@ -40,16 +40,13 @@
 #include "fm_common.h"
 
 
-static void WritePhyReg10G(t_Memac   *p_Memac,
-                           uint8_t   phyAddr,
-                           uint8_t   reg,
-                           uint16_t  data)
+static void WritePhyReg10G(t_MemacMiiAccessMemMap   *p_MiiAccess,
+                           uint8_t                  phyAddr,
+                           uint8_t                  reg,
+                           uint16_t                 data)
 {
-    t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
-    p_MiiAccess = p_Memac->p_MiiMemMap;
-
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
     /* Leave only MDIO_CLK_DIV bits set on */
     tmpReg &= MDIO_CFG_CLK_DIV_MASK;
@@ -67,7 +64,6 @@ static void WritePhyReg10G(t_Memac   *p_Memac,
     /* Specify phy and register to be accessed */
     WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
     WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
-
     CORE_MemoryBarrier();
 
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
@@ -75,7 +71,6 @@ static void WritePhyReg10G(t_Memac   *p_Memac,
 
     /* Write data */
     WRITE_UINT32(p_MiiAccess->mdio_data, data);
-
     CORE_MemoryBarrier();
 
     /* Wait for write transaction end */
@@ -83,16 +78,13 @@ static void WritePhyReg10G(t_Memac   *p_Memac,
         XX_UDelay(1);
 }
 
-static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
-                             uint8_t   phyAddr,
-                             uint8_t   reg,
-                             uint16_t  *p_Data)
+static uint32_t ReadPhyReg10G(t_MemacMiiAccessMemMap *p_MiiAccess,
+                              uint8_t                phyAddr,
+                              uint8_t                reg,
+                              uint16_t               *p_Data)
 {
-    t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
-    p_MiiAccess = p_Memac->p_MiiMemMap;
-
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
     /* Leave only MDIO_CLK_DIV bits set on */
     tmpReg &= MDIO_CFG_CLK_DIV_MASK;
@@ -110,7 +102,6 @@ static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
     /* Specify phy and register to be accessed */
     WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
     WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
-
     CORE_MemoryBarrier();
 
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
@@ -120,7 +111,6 @@ static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
     tmpReg = phyAddr;
     tmpReg |= MDIO_CTL_READ;
     WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
-
     CORE_MemoryBarrier();
 
     /* Wait for data to be available */
@@ -130,26 +120,16 @@ static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
     /* Check if there was an error */
-    tmpReg  = GET_UINT32(p_MiiAccess->mdio_cfg);
-
-    if (tmpReg & MDIO_CFG_READ_ERR)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE,
-                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
-                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, tmpReg));
-
-    return E_OK;
+    return GET_UINT32(p_MiiAccess->mdio_cfg);
 }
 
-static void WritePhyReg1G(t_Memac   *p_Memac,
-                          uint8_t   phyAddr,
-                          uint8_t   reg,
-                          uint16_t  data)
+static void WritePhyReg1G(t_MemacMiiAccessMemMap    *p_MiiAccess,
+                          uint8_t                   phyAddr,
+                          uint8_t                   reg,
+                          uint16_t                  data)
 {
-    t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
-    p_MiiAccess = p_Memac->p_MiiMemMap;
-
     /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
     tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
@@ -176,16 +156,13 @@ static void WritePhyReg1G(t_Memac   *p_Memac,
         XX_UDelay(1);
 }
 
-static t_Error ReadPhyReg1G(t_Memac   *p_Memac,
-                            uint8_t   phyAddr,
-                            uint8_t   reg,
-                            uint16_t  *p_Data)
+static uint32_t ReadPhyReg1G(t_MemacMiiAccessMemMap  *p_MiiAccess,
+                             uint8_t                 phyAddr,
+                             uint8_t                 reg,
+                             uint16_t                *p_Data)
 {
-    t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
-    p_MiiAccess = p_Memac->p_MiiMemMap;
-
     /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
     tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
@@ -211,14 +188,7 @@ static t_Error ReadPhyReg1G(t_Memac   *p_Memac,
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
     /* Check error */
-    tmpReg  = GET_UINT32(p_MiiAccess->mdio_cfg);
-
-    if (tmpReg & MDIO_CFG_READ_ERR)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE,
-                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
-                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, tmpReg));
-
-    return E_OK;
+    return GET_UINT32(p_MiiAccess->mdio_cfg);
 }
 
 /*****************************************************************************/
@@ -228,19 +198,16 @@ t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
                              uint16_t   data)
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
-    bool                    phy10G;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
 
     /* Figure out interface type - 10G vs 1G.
        In 10G interface both phyAddr and devAddr present. */
-    phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
-
-    if (phy10G)
-        WritePhyReg10G(p_Memac, phyAddr, reg, data);
+    if (ENET_SPEED_FROM_MODE(p_Memac->enetMode) == e_ENET_SPEED_10000)
+        WritePhyReg10G(p_Memac->p_MiiMemMap, phyAddr, reg, data);
     else
-        WritePhyReg1G(p_Memac, phyAddr, reg, data);
+        WritePhyReg1G(p_Memac->p_MiiMemMap, phyAddr, reg, data);
 
     return E_OK;
 }
@@ -252,20 +219,22 @@ t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
                             uint16_t  *p_Data)
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
-    bool                    phy10G;
-    t_Error                 errCode;
+    uint32_t                ans;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
 
     /* Figure out interface type - 10G vs 1G.
        In 10G interface both phyAddr and devAddr present. */
-    phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
-
-    if (phy10G)
-        errCode = ReadPhyReg10G(p_Memac, phyAddr, reg, p_Data);
+    if (ENET_SPEED_FROM_MODE(p_Memac->enetMode) == e_ENET_SPEED_10000)
+        ans = ReadPhyReg10G(p_Memac->p_MiiMemMap, phyAddr, reg, p_Data);
     else
-        errCode = ReadPhyReg1G(p_Memac, phyAddr, reg, p_Data);
+        ans = ReadPhyReg1G(p_Memac->p_MiiMemMap, phyAddr, reg, p_Data);
+
+    if (ans & MDIO_CFG_READ_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
+                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, ans));
 
-    return errCode;
+    return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 6e4b5e3..3cc1440 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -43,6 +43,7 @@
 #include "xx_ext.h"
 #include "endian_ext.h"
 #include "debug_ext.h"
+#include "crc_mac_addr_ext.h"
 
 #include "fm_common.h"
 #include "fsl_fman_tgec.h"
@@ -75,7 +76,21 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
+
+static uint32_t GetMacAddrHashCode(uint64_t ethAddr)
+{
+    uint32_t crc;
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    crc = GetMirror32(crc);
+
+    return crc;
+}
+
+/* ......................................................................... */
 
 static void TgecErrException(t_Handle h_Tgec)
 {
@@ -121,6 +136,8 @@ static void TgecErrException(t_Handle h_Tgec)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
 }
 
+/* ......................................................................... */
+
 static void TgecException(t_Handle h_Tgec)
 {
      t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
@@ -139,6 +156,8 @@ static void TgecException(t_Handle h_Tgec)
          p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
 }
 
+/* ......................................................................... */
+
 static void FreeInitResources(t_Tgec *p_Tgec)
 {
     if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
@@ -159,14 +178,12 @@ static void FreeInitResources(t_Tgec *p_Tgec)
     p_Tgec->p_UnicastAddrHash =     NULL;
 }
 
-/* ........................................................................... */
-
 
 /*****************************************************************************/
 /*                     10G MAC API routines                                  */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 {
@@ -180,7 +197,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 {
@@ -194,7 +211,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 {
@@ -213,7 +230,7 @@ static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 /*                      Tgec Configs modification functions                 */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
 {
@@ -227,7 +244,7 @@ static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
 {
@@ -241,7 +258,7 @@ static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
 {
@@ -255,7 +272,7 @@ static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 {
@@ -271,7 +288,7 @@ static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
 {
@@ -296,7 +313,7 @@ static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception,
 }
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
 {
@@ -316,7 +333,7 @@ static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
 /*                      Tgec Run Time API functions                         */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 /* backward compatibility. will be removed in the future. */
 static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
 {
@@ -324,12 +341,14 @@ static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-
     tgec_tx_mac_pause(p_Tgec->p_MemMap, pauseTime);
 
+
     return E_OK;
 }
 
+/* ......................................................................... */
+
 static t_Error TgecSetTxPauseFrames(t_Handle h_Tgec,
                                     uint8_t  priority,
                                     uint16_t pauseTime,
@@ -347,7 +366,7 @@ static t_Error TgecSetTxPauseFrames(t_Handle h_Tgec,
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
 {
@@ -361,7 +380,7 @@ static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
 {
@@ -396,27 +415,29 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
 
 /* MIB II */
     p_Statistics->ifInOctets            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_ROCT);
+    p_Statistics->ifInUcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RUCA);
     p_Statistics->ifInMcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RMCA);
     p_Statistics->ifInBcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RBCA);
-    p_Statistics->ifInPkts              = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RUCA)
+    p_Statistics->ifInPkts              = p_Statistics->ifInUcastPkts
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
     p_Statistics->ifInErrors            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RERR);
 
     p_Statistics->ifOutOctets           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TOCT);
+    p_Statistics->ifOutUcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TUCA);
     p_Statistics->ifOutMcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TMCA);
     p_Statistics->ifOutBcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TBCA);
-    p_Statistics->ifOutPkts             = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TUCA)
-                                            + p_Statistics->ifOutMcastPkts
-                                            + p_Statistics->ifOutBcastPkts;
+    p_Statistics->ifOutPkts             = p_Statistics->ifOutUcastPkts
+                                        + p_Statistics->ifOutMcastPkts
+                                        + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
     p_Statistics->ifOutErrors           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TERR);
 
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
 {
@@ -430,7 +451,7 @@ static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
 {
@@ -444,7 +465,7 @@ static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
 {
@@ -459,7 +480,7 @@ static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecResetCounters (t_Handle h_Tgec)
 {
@@ -473,7 +494,7 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
@@ -518,7 +539,7 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
     RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
@@ -550,7 +571,7 @@ static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
     RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
@@ -570,7 +591,7 @@ static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
 
     /* CRC calculation */
-    crc = get_mac_addr_crc(ethAddr);
+    crc = GetMacAddrHashCode(ethAddr);
 
     hash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;        /* Take 9 MSB bits */
 
@@ -585,7 +606,7 @@ static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
@@ -602,7 +623,7 @@ static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
     ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
 
     /* CRC calculation */
-    crc = get_mac_addr_crc(ethAddr);
+    crc = GetMacAddrHashCode(ethAddr);
 
     hash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;        /* Take 9 MSB bits */
 
@@ -622,7 +643,7 @@ static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
 {
@@ -636,7 +657,7 @@ static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TgecGetId Not Supported"));
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
 {
@@ -650,7 +671,7 @@ static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
 {
@@ -679,7 +700,7 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
 {
@@ -691,7 +712,7 @@ static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
     return tgec_get_max_frame_len(p_Tgec->p_MemMap);
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
@@ -699,7 +720,7 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     t_Error err;
 
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
-    XX_Print("Applying 10G TX ECC workaround (10GMAC-A004) ...");
+    XX_Print("Applying 10G TX ECC workaround (10GMAC-A004) ... ");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
     tgec_enable(p_Tgec->p_MemMap, TRUE, TRUE);
@@ -720,7 +741,7 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
 }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 static t_Error TgecDumpRegs(t_Handle h_Tgec)
@@ -733,7 +754,6 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
     {
         DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
         DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
-        DUMP_VAR(p_Tgec->p_MemMap, scratch);
         DUMP_VAR(p_Tgec->p_MemMap, command_config);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
@@ -769,7 +789,7 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
 /*                      FM Init & Free API                                   */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecInit(t_Handle h_Tgec)
 {
@@ -810,8 +830,21 @@ static t_Error TgecInit(t_Handle h_Tgec)
     }
 #endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
 
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
+    {
+        if (!p_Tgec->p_TgecDriverParam->skip_fman11_workaround &&
+            ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
+        {
+            FreeInitResources(p_Tgec);
+            REPORT_ERROR(MINOR, err, ("TgecTxEccWorkaround FAILED"));
+        }
+    }
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
     err = tgec_init(p_Tgec->p_MemMap, p_TgecDriverParam, p_Tgec->exceptions);
-    if (err) {
+    if (err)
+    {
         FreeInitResources(p_Tgec);
         RETURN_ERROR(MAJOR, err, ("This TGEC version does not support the required i/f mode"));
     }
@@ -821,13 +854,8 @@ static t_Error TgecInit(t_Handle h_Tgec)
                            e_FM_MAC_10G,
                            p_Tgec->fmMacControllerDriver.macId,
                            p_TgecDriverParam->max_frame_length);
-/* we consider having no IPC a non crasher... */
-/*    if (err)
-    {
-        FreeInitResources(p_Tgec);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-*/
+    /* we consider having no IPC a non crasher... */
+
 #ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         tgec_fm_tx_fifo_corruption_errata_10gmac_a007(p_Tgec->p_MemMap);
@@ -867,7 +895,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static t_Error TgecFree(t_Handle h_Tgec)
 {
@@ -887,7 +915,7 @@ static t_Error TgecFree(t_Handle h_Tgec)
     return E_OK;
 }
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
 {
@@ -951,7 +979,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 /*                      Tgec Config  Main Entry                             */
 /*****************************************************************************/
 
-/* .............................................................................. */
+/* ......................................................................... */
 
 t_Handle TGEC_Config(t_FmMacParams *p_FmMacParam)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index f9bc687..2aa3923 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -48,6 +48,23 @@
 #include "fm_mac.h"
 
 
+#define DEFAULT_exceptions                        \
+    ((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT     |  \
+                TGEC_IMASK_REM_FAULT           |  \
+                TGEC_IMASK_LOC_FAULT           |  \
+                TGEC_IMASK_TX_ECC_ER           |  \
+                TGEC_IMASK_TX_FIFO_UNFL        |  \
+                TGEC_IMASK_TX_FIFO_OVFL        |  \
+                TGEC_IMASK_TX_ER               |  \
+                TGEC_IMASK_RX_FIFO_OVFL        |  \
+                TGEC_IMASK_RX_ECC_ER           |  \
+                TGEC_IMASK_RX_JAB_FRM          |  \
+                TGEC_IMASK_RX_OVRSZ_FRM        |  \
+                TGEC_IMASK_RX_RUNT_FRM         |  \
+                TGEC_IMASK_RX_FRAG_FRM         |  \
+                TGEC_IMASK_RX_CRC_ER           |  \
+                TGEC_IMASK_RX_ALIGN_ER))
+
 #define GET_EXCEPTION_FLAG(bitMask, exception)      switch (exception){ \
     case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                           \
         bitMask = TGEC_IMASK_MDIO_SCAN_EVENT    ; break;                \
@@ -85,22 +102,6 @@
         bitMask = TGEC_IMASK_RX_ALIGN_ER        ; break;                \
     default: bitMask = 0;break;}
 
-#define DEFAULT_exceptions  ((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT     |  \
-                                        TGEC_IMASK_REM_FAULT           |  \
-                                        TGEC_IMASK_LOC_FAULT           |  \
-                                        TGEC_IMASK_TX_ECC_ER           |  \
-                                        TGEC_IMASK_TX_FIFO_UNFL        |  \
-                                        TGEC_IMASK_TX_FIFO_OVFL        |  \
-                                        TGEC_IMASK_TX_ER               |  \
-                                        TGEC_IMASK_RX_FIFO_OVFL        |  \
-                                        TGEC_IMASK_RX_ECC_ER           |  \
-                                        TGEC_IMASK_RX_JAB_FRM          |  \
-                                        TGEC_IMASK_RX_OVRSZ_FRM        |  \
-                                        TGEC_IMASK_RX_RUNT_FRM         |  \
-                                        TGEC_IMASK_RX_FRAG_FRM         |  \
-                                        TGEC_IMASK_RX_CRC_ER           |  \
-                                        TGEC_IMASK_RX_ALIGN_ER))
-
 #define MAX_PACKET_ALIGNMENT        31
 #define MAX_INTER_PACKET_GAP        0x7f
 #define MAX_INTER_PALTERNATE_BEB    0x0f
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
index 34a689b..478ce3c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -12,7 +12,7 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
-fsl-ncsw-Pcd-objs	:= fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o fm_manip.o
+fsl-ncsw-Pcd-objs	:= fman_kg.o fman_prs.o fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o fm_manip.o
 
 ifeq ($(CONFIG_FMAN_T4240),y)
 fsl-ncsw-Pcd-objs	+= fm_replic.o
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 8ff6e31..85810a9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -1490,11 +1490,11 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
 
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
-         case (e_FM_PCD_INVALID):
+        case (e_FM_PCD_INVALID):
             err = E_NOT_SUPPORTED;
             break;
 
-         case (e_FM_PCD_DONE):
+        case (e_FM_PCD_DONE):
             if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME) &&
                 p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
             {
@@ -1540,13 +1540,13 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
         case (e_FM_PCD_CC):
             if (!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
                 RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
-        break;
+            break;
 
 #if (DPAA_VERSION >= 11)
          case (e_FM_PCD_FR):
-             if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
+            if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
-             break;
+            break;
 #endif /* (DPAA_VERSION >= 11) */
 
         default:
@@ -1692,6 +1692,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                 case (NET_HEADER_FIELD_IPv4_PROTO):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
@@ -2085,7 +2086,7 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                        tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK)<< FM_PCD_AD_RESULT_VSP_SHIFT;
+                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     }
                     else
@@ -2117,6 +2118,7 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                 }
                 tmpNia = NIA_KG_DIRECT;
                 tmpNia |= NIA_ENG_KG;
+                tmpNia |= NIA_KG_CC_EN;
                 tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
                 break;
 
@@ -2167,7 +2169,7 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
         }
 
 #if (DPAA_VERSION >= 11)
-       tmpNia |= FM_PCD_AD_RESULT_NO_OM_VSPE;
+        tmpNia |= FM_PCD_AD_RESULT_NO_OM_VSPE;
 #endif /* (DPAA_VERSION >= 11) */
         WRITE_UINT32(p_AdResult->nia, tmpNia);
     }
@@ -2438,7 +2440,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_KeyParams->ccNextEngineParams.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams,&requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2618,8 +2620,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
 #if (DPAA_VERSION >= 11)
         if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic) &&
-            (!(p_KeyParams->ccNextEngineParams.h_Manip)))
+            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic))
             p_AdditionalInfo->h_FrmReplicForAdd = p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -2639,8 +2640,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
-            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
             p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -2705,9 +2705,8 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
 
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
-            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
-            p_AdditionalInfo->h_FrmReplicForRmv =
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+             p_AdditionalInfo->h_FrmReplicForRmv =
                 p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -2768,7 +2767,7 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
 
         if (j == keyIndex)
         {
-            ASSERT_COND(keyIndex < FM_PCD_MAX_NUM_OF_CC_GROUPS);
+            ASSERT_COND(keyIndex < CC_MAX_NUM_OF_KEYS);
             if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
             {
                 /* As statistics were enabled, we need to update the existing
@@ -2902,7 +2901,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_CcNextEngineParams->h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(p_CcNextEngineParams, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(p_CcNextEngineParams, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2921,8 +2920,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
 #if (DPAA_VERSION >= 11)
         if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
-            (!(p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
             p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -2939,8 +2937,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
 #if (DPAA_VERSION >= 11)
         if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
-            (!(p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
             p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -3093,8 +3090,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     }
 #if (DPAA_VERSION >= 11)
         if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-            (p_CcNextEngineParams->params.frParams.h_FrmReplic) &&
-            (!(p_CcNextEngineParams->h_Manip)))
+            (p_CcNextEngineParams->params.frParams.h_FrmReplic))
             p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3482,7 +3478,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3522,7 +3518,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3599,7 +3595,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3636,7 +3632,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3727,7 +3723,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
 
             if (p_KeyParams->ccNextEngineParams.h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
                 p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
@@ -3790,7 +3786,10 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
     }
 
     err = BuildNewNodeModifyNextEngine(h_FmPcd,
@@ -4336,7 +4335,10 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     if (p_FmPcd->p_CcShadow)
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
 
     err = BuildNewNodeModifyNextEngine(p_FmPcd,
                                        p_FmPcdCcTree,
@@ -4393,7 +4395,10 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
 
         useShadowStructs = TRUE;
     }
@@ -4477,7 +4482,10 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
 
         useShadowStructs = TRUE;
     }
@@ -4547,7 +4555,10 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
     }
 
     err = BuildNewNodeModifyNextEngine(h_FmPcd,
@@ -4590,7 +4601,6 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
     if (keyIndex > p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
 
-
     if (keySize != p_CcNode->userSizeOfExtraction)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
 
@@ -4631,7 +4641,10 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
 
         useShadowStructs = TRUE;
     }
@@ -4719,7 +4732,10 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
             return ERROR_CODE(E_BUSY);
+        }
 
         useShadowStructs = TRUE;
     }
@@ -5131,7 +5147,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
             if (p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEgine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
                 if (err)
                 {
                     DeleteTree(p_FmPcdCcTree,p_FmPcd);
@@ -5862,6 +5878,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             }
             else
                 p_CcInformation->index++;
+
             if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
                 h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index c18be36..bdbc8ae 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -48,6 +48,7 @@
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
 #include "fm_kg.h"
+#include "fsl_fman_kg.h"
 
 
 /****************************************/
@@ -90,13 +91,14 @@ static void KgSchemeFlagUnlock(t_Handle h_Scheme)
     FmPcdLockUnlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
-static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
+static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t fmkg_ar)
 {
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
-    /* Wait for GO to be idle and read error */
-    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
-    if (kgar & FM_PCD_KG_KGAR_ERR)
+
+    struct fman_kg_regs *regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    if (fman_kg_write_ar_wait(regs, fmkg_ar))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
+
     return E_OK;
 }
 
@@ -758,16 +760,18 @@ static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
 
 static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
+    struct fman_kg_regs *p_KgRegs;
+
+    uint32_t                tmpKgarReg = 0, intFlags;
     t_Error                 err = E_OK;
 
     /* The calling routine had locked the port, so for each port only one core can access
      * (so we don't need a lock here) */
+
     if (p_FmPcd->h_Hc)
         return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
 
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    p_KgRegs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
     /* lock a common KG reg */
@@ -779,14 +783,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
-
-    if (add)
-        tmpKgpeSp |= spReg;
-    else /* clear */
-        tmpKgpeSp &= ~spReg;
-
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+    fman_kg_write_sp(p_KgRegs, spReg, add);
 
     tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
 
@@ -797,10 +794,12 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
 
 static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    struct fman_kg_regs    *p_KgRegs;
     uint32_t                tmpKgarReg, intFlags;
     t_Error                 err;
 
+    p_KgRegs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
     if (p_FmPcd->h_Hc)
     {
         err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
@@ -808,8 +807,7 @@ static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cpp
     }
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+    fman_kg_write_cpp(p_KgRegs, cppReg);
     tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
@@ -822,7 +820,7 @@ static uint32_t BuildCppReg(t_FmPcd *p_FmPcd, uint8_t clsPlanGrpId)
     uint32_t    tmpKgpeCpp;
 
     tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
-    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_KG_PE_CPP_MASK_SHIFT);
 
     return tmpKgpeCpp;
 }
@@ -842,8 +840,8 @@ static void UnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
 
 static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
 {
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_READ |
+    return (uint32_t)(FM_KG_KGAR_GO |
+                      FM_KG_KGAR_READ |
                       FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
                       DUMMY_PORT_ID |
                       ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
@@ -857,28 +855,16 @@ static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
 static void PcdKgErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event, force, schemeIndexes = 0,index = 0, mask = 0;
+    uint32_t                event,schemeIndexes = 0, index = 0;
+    struct fman_kg_regs    *p_KgRegs;
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-
-    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
-    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
-
-    event &= mask;
-
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if (force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+    p_KgRegs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    fman_kg_get_event(p_KgRegs, &event, &schemeIndexes);
 
-    if (event & FM_PCD_KG_DOUBLE_ECC)
+    if (event & FM_EX_KG_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if (event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    if (event & FM_EX_KG_KEYSIZE_OVERFLOW)
     {
         if (schemeIndexes)
         {
@@ -932,44 +918,14 @@ static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
 static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 {
     t_Error                     err = E_OK;
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    int                         i;
-    uint8_t                     hardwarePortId = 0;
-    uint32_t                    tmpReg;
+    struct fman_kg_regs         *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
 
-    /**********************KGEER******************/
-    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
-    /**********************KGEER******************/
-
-    /**********************KGEEER******************/
-    tmpReg = 0;
-    if (p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
-    {
+    if (p_FmPcd->exceptions & FM_EX_KG_DOUBLE_ECC)
         FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
-    }
-    if (p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
-    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
-    /**********************KGEEER******************/
-
-    /**********************KGFDOR******************/
-    WRITE_UINT32(p_Regs->kgfdor,0);
-    /**********************KGFDOR******************/
 
-    /**********************KGGDV0R******************/
-    WRITE_UINT32(p_Regs->kggdv0r,0);
-    /**********************KGGDV0R******************/
-
-    /**********************KGGDV1R******************/
-    WRITE_UINT32(p_Regs->kggdv1r,0);
-    /**********************KGGDV1R******************/
-
-    /**********************KGGCR******************/
-    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
-    /**********************KGGCR******************/
+    fman_kg_init(p_Regs, p_FmPcd->exceptions, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
 
     /* register even if no interrupts enabled, to allow future enablement */
     FmRegisterIntr(p_FmPcd->h_Fm,
@@ -979,23 +935,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
                    PcdKgErrorException,
                    p_FmPcd);
 
-    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
-
-        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-
-        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    /* enable and enable all scheme interrupts */
-    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
-    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+    fman_kg_enable_scheme_interrupts(p_Regs);
 
     if (p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
@@ -1030,9 +970,9 @@ static t_Error InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
     return E_OK;
 }
 
-static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
-                               t_FmPcdKgSchemeParams    *p_SchemeParams,
-                               t_FmPcdKgSchemeRegs      *p_SchemeRegs)
+static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
+                               t_FmPcdKgSchemeParams      *p_SchemeParams,
+                               struct fman_kg_scheme_regs *p_SchemeRegs)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
@@ -1057,7 +997,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     uint8_t                             currGenId = 0;
 
     memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
-    memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgSchemeRegs));
+    memset(p_SchemeRegs, 0, sizeof(struct fman_kg_scheme_regs));
 
     if (p_SchemeParams->netEnvParams.numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
@@ -1423,6 +1363,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                 case (e_FM_PCD_EXTRACT_BY_HDR):
                     switch (p_Extract->extractByHdr.hdr)
                     {
+
+#ifdef FM_CAPWAP_SUPPORT
+                        case (HEADER_TYPE_UDP_LITE):
+                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                            break;
+#endif
                         case (HEADER_TYPE_UDP_ENCAP_ESP):
                             switch (p_Extract->extractByHdr.type)
                             {
@@ -1558,7 +1504,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
             if (generic)
             {
                 /* set generic register fields */
-                if (currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                if (currGenId >= FM_KG_NUM_OF_GENERIC_REGS)
                     RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
                 if (!code)
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
@@ -1709,7 +1655,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
 
     /* check that are enough generic registers */
-    if (p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+    if (p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_KG_NUM_OF_GENERIC_REGS)
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
@@ -1819,7 +1765,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
     }
     /* clear all unused GEC registers */
-    for ( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for ( i=currGenId ;i<FM_KG_NUM_OF_GENERIC_REGS ; i++)
         p_SchemeRegs->kgse_gec[i] = 0;
 
     /* add base Qid for this scheme */
@@ -1994,12 +1940,10 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 
     /* free blocks */
     if (p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
         KgFreeClsPlanEntries(h_FmPcd,
                              p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
                              p_FmPcd->guestId,
                              p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
-    }
     else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
     {
         memset(&reply, 0, sizeof(reply));
@@ -2314,30 +2258,30 @@ UNUSED(guestId);
 
 void KgEnable(t_FmPcd *p_FmPcd)
 {
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    struct fman_kg_regs *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+    fman_kg_enable(p_Regs);
 }
 
 void KgDisable(t_FmPcd *p_FmPcd)
 {
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    struct fman_kg_regs *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+    fman_kg_disable(p_Regs);
 }
 
 void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    struct fman_kg_cp_regs  *p_FmPcdKgPortRegs;
     uint32_t                tmpKgarReg = 0, intFlags;
     uint16_t                i, j;
 
     /* This routine is protected by the calling routine ! */
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs;
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
@@ -2381,10 +2325,12 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
 
+
     if (FmIsMaster(p_FmPcd->h_Fm))
     {
-        p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcdKg->p_FmPcdKgRegs  = (struct fman_kg_regs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
         p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+        p_FmPcdKg->p_IndirectAccessRegs = (u_FmPcdKgIndirectAccessRegs *)&p_FmPcdKg->p_FmPcdKgRegs->fmkg_indirect[0];
     }
 
     p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
@@ -2689,28 +2635,28 @@ bool FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
 uint32_t FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
 {
     return (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                      FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_WRITE |
-                      FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                      FM_KG_KGAR_GO |
+                      FM_KG_KGAR_WRITE |
+                      FM_KG_KGAR_SEL_SCHEME_ENTRY |
                       DUMMY_PORT_ID |
-                      (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
+                      (updateCounter ? FM_KG_KGAR_SCM_WSEL_UPDATE_CNT:0));
 }
 
 uint32_t FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
 {
     return (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                      FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_READ |
-                      FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                      FM_KG_KGAR_GO |
+                      FM_KG_KGAR_READ |
+                      FM_KG_KGAR_SEL_SCHEME_ENTRY |
                       DUMMY_PORT_ID |
-                      FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
+                      FM_KG_KGAR_SCM_WSEL_UPDATE_CNT);
 
 }
 
 uint32_t FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
 {
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_WRITE |
+    return (uint32_t)(FM_KG_KGAR_GO |
+                      FM_KG_KGAR_WRITE |
                       FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
                       DUMMY_PORT_ID |
                       ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
@@ -2724,8 +2670,8 @@ uint32_t FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
 uint32_t FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_WRITE |
+    return (uint32_t)(FM_KG_KGAR_GO |
+                      FM_KG_KGAR_WRITE |
                       FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
                       hardwarePortId |
                       FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
@@ -2734,8 +2680,8 @@ uint32_t FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
 uint32_t FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_READ |
+    return (uint32_t)(FM_KG_KGAR_GO |
+                      FM_KG_KGAR_READ |
                       FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
                       hardwarePortId |
                       FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
@@ -2744,8 +2690,8 @@ uint32_t FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
 uint32_t FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
 {
 
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_WRITE |
+    return (uint32_t)(FM_KG_KGAR_GO |
+                      FM_KG_KGAR_WRITE |
                       FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
                       hardwarePortId |
                       FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
@@ -2840,9 +2786,9 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
                         intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
                         WriteKgarWait(p_FmPcd, tmpKgarReg);
-                        tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+                        tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode);
                         ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
-                        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA);
+                        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode, tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA);
                         /* call indirect command for scheme write */
                         tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
                         WriteKgarWait(p_FmPcd, tmpKgarReg);
@@ -2874,10 +2820,10 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                 tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
                 intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
                 WriteKgarWait(p_FmPcd, tmpKgarReg);
-                tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+                tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode);
                 ASSERT_COND(tmpReg32 & (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 tmpReg32 &= ~NIA_FM_CTL_AC_CC;
-                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32 | NIA_FM_CTL_AC_PRE_CC);
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode, tmpReg32 | NIA_FM_CTL_AC_PRE_CC);
                 /* call indirect command for scheme write */
                 tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
                 WriteKgarWait(p_FmPcd, tmpKgarReg);
@@ -2889,7 +2835,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
             WriteKgarWait(p_FmPcd, tmpKgarReg);
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_om, value);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_om, value);
             /* call indirect command for scheme write */
             tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
             WriteKgarWait(p_FmPcd, tmpKgarReg);
@@ -2900,10 +2846,10 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
             WriteKgarWait(p_FmPcd, tmpKgarReg);
-            tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+            tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode);
             tmpReg32 &= ~(NIA_ENG_MASK | NIA_AC_MASK);
             tmpReg32 |= value;
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode, tmpReg32);
             /* call indirect command for scheme write */
             tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
             WriteKgarWait(p_FmPcd, tmpKgarReg);
@@ -2926,8 +2872,8 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
 t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemeParams)
 {
     t_FmPcd                             *p_FmPcd;
-    t_FmPcdKgSchemeRegs                 schemeRegs;
-    t_FmPcdKgSchemeRegs                 *p_MemRegs;
+    struct fman_kg_scheme_regs          schemeRegs;
+    struct fman_kg_scheme_regs          *p_MemRegs;
     uint8_t                             i;
     t_Error                             err = E_OK;
     uint32_t                            tmpKgarReg;
@@ -3024,7 +2970,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     physicalSchemeId = p_Scheme->schemeId;
 
     /* configure all 21 scheme registers */
-    p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
+    p_MemRegs = &p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs;
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     WRITE_UINT32(p_MemRegs->kgse_ppc,   schemeRegs.kgse_ppc);
     WRITE_UINT32(p_MemRegs->kgse_ccbs,  schemeRegs.kgse_ccbs);
@@ -3041,7 +2987,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
     WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
     WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
-    for (i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for (i=0 ; i<FM_KG_NUM_OF_GENERIC_REGS ; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
@@ -3087,7 +3033,7 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     /* clear mode register, including enable bit */
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, 0);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode, 0);
 
     /* call indirect command for scheme write */
     tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
@@ -3121,9 +3067,9 @@ uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme)
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
-    spc = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
+    spc = GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_spc);
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
     return spc;
@@ -3154,14 +3100,14 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
     {
        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
     }
 
     /* change counter value */
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc, value);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_spc, value);
 
     /* call indirect command for scheme write */
     tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
@@ -3175,7 +3121,7 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
 t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
 {
    t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs;
+   struct fman_kg_regs  *p_Regs;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
@@ -3186,7 +3132,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
     if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
 
-    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
+    WRITE_UINT32(p_Regs->fmkg_fdor,payloadOffset);
 
     return E_OK;
 }
@@ -3194,7 +3140,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
 t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 {
    t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs;
+   struct fman_kg_regs  *p_Regs;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
@@ -3208,9 +3154,9 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
 
     if (valueId == 0)
-        WRITE_UINT32(p_Regs->kggdv0r,value);
+        WRITE_UINT32(p_Regs->fmkg_gdv0r,value);
     else
-        WRITE_UINT32(p_Regs->kggdv1r,value);
+        WRITE_UINT32(p_Regs->fmkg_gdv1r,value);
     return E_OK;
 }
 
@@ -3234,20 +3180,19 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
 
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_eer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_eeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_seer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_seeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_tpc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_serc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_fdor);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gdv0r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gdv1r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_feer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_ar);
 
     DUMP_SUBTITLE(("\n"));
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -3257,28 +3202,28 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
 
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_mode);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ekfc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ekdv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_bmch);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_bmcl);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_fqb);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_hc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ppc);
 
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_gec, ("kgse_gec"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_KG_NUM_OF_GENERIC_REGS)
         {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_gec[i], sizeof(uint32_t));
         }
 
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_spc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_dv0);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_dv1);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ccbs);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_mv);
     }
     DUMP_SUBTITLE(("\n"));
 
@@ -3292,24 +3237,24 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
 
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, fmkg_pe_sp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, fmkg_pe_cpp);
     }
 
     DUMP_SUBTITLE(("\n"));
     for (j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
     {
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs.kgcpe, ("kgcpe"));
 
         tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
         if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         DUMP_SUBSTRUCT_ARRAY(i, 8)
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs.kgcpe[i], sizeof(uint32_t));
     }
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
index 080b1d5..cb7521a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
@@ -41,7 +41,6 @@
 
 #include "std_ext.h"
 
-
 /***********************************************************************/
 /*          Keygen defines                                             */
 /***********************************************************************/
@@ -56,30 +55,6 @@
 #define KG_SCH_VSP_SHIFT                        24
 #endif /* (DPAA_VERSION >= 11) */
 
-#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
-#define KG_SCH_PP_NO_GEN                        0x10000000
-#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
-#define KG_SCH_MODE_NIA_PLCR                    0x40000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_SCH_BITMASK_MASK                     0x000000FF
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_MASK                         0x00FF0000
-#define FM_PCD_KG_KGAR_ERR                      0x20000000
-#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
-#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
-#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
-#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
-#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
-
-#define FM_PCD_KG_KGAR_GO                       0x80000000
-#define FM_PCD_KG_KGAR_READ                     0x40000000
-#define FM_PCD_KG_KGAR_WRITE                    0x00000000
-#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
-#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
-
-
 typedef uint32_t t_KnownFieldsMasks;
 #define KG_SCH_KN_PORT_ID                   0x80000000
 #define KG_SCH_KN_MACDST                    0x40000000
@@ -220,22 +195,7 @@ switch (i) {                                        \
 /***********************************************************************/
 /*          Keygen defines                                             */
 /***********************************************************************/
-/* Masks */
-#define FM_PCD_KG_KGGCR_EN                      0x80000000
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_ERR_CAP                              0x80000000
-#define KG_ERR_TYPE_DOUBLE                      0x40000000
-#define KG_ERR_ADDR_MASK                        0x00000FFF
-#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
-#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
-#define KG_SCH_MODE_EN                          0x80000000
 
-/* shifts */
-#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
-#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
-
-/* others */
 #define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
 #define NO_VALIDATION                           0x70
 #define KG_ACTION_REG_TO                        1024
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index b81de93..e6c8d2d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -1366,7 +1366,7 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (2):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
         case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Disable Timeout Task with invalid IPRCPT"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
         case (4):
             RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
         case (5):
@@ -1408,8 +1408,8 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
     WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeoutModeAndFqid, tmpReg32);
 
-    /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 128.*/
-    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 128;
+    /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 129.*/
+    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 129;
 
     /*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
     p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr =
@@ -1440,7 +1440,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 32));
+    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 64));
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
     tmpReg64 = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)));
@@ -1482,8 +1482,8 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
 {
     t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
     uint32_t                tmpReg32, autoLearnHashTblSize;
-    uint32_t                numOfWays, setSize, setSizeCode, tmpSetSize, keySize;
-    uint32_t                waySize, numOfSets, tmpNumOfSets, numOfEntries;
+    uint32_t                numOfWays, setSize, setSizeCode, keySize;
+    uint32_t                waySize, numOfSets, numOfEntries;
     uint64_t                tmpReg64;
     uint16_t                minFragSize;
     uintptr_t               *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
@@ -1527,17 +1527,8 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_IpReassCommonTbl) - p_FmPcd->physicalMuramBase);
     WRITE_UINT32((*p_IpReassTbl)->ipReassCommonPrmTblPtr, tmpReg32);
 
-    /*It is recommended that the total number of entries in this table
-    (number of sets * number of ways) will be twice the number of frames that
-     are expected to be reassembled simultaneously.*/
-    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
-
-    /* sets number calculation - number of entries = number of sets * number of ways */
-    numOfSets = numOfEntries / numOfWays;
-
     /* Calculate set size (set size is rounded-up to next power of 2) */
-    LOG2(numOfWays * waySize, tmpSetSize);
-    setSize =  (uint32_t)(1 << (tmpSetSize + (POWER_OF_2(numOfWays * waySize) ? 0 : 1)));
+    NEXT_POWER_OF_2(numOfWays * waySize, setSize);
 
     /* Get set size code */
     LOG2(setSize, setSizeCode);
@@ -1545,15 +1536,23 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     /* Sets ways number and set size code */
     WRITE_UINT16((*p_IpReassTbl)->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
 
+    /* It is recommended that the total number of entries in this table
+    (number of sets * number of ways) will be twice the number of frames that
+     are expected to be reassembled simultaneously.*/
+    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
+
+    /* sets number calculation - number of entries = number of sets * number of ways */
+    numOfSets = numOfEntries / numOfWays;
+
     /* Sets AutoLearnHashKeyMask*/
-    LOG2(numOfSets, tmpNumOfSets);
-    numOfSets = (uint32_t)(1 << (tmpNumOfSets + (POWER_OF_2(numOfSets) ? 0 : 1)));
+    NEXT_POWER_OF_2(numOfSets, numOfSets);
+
     WRITE_UINT16((*p_IpReassTbl)->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
 
     /* Allocation of IP Reassembly Automatic Learning Hash Table - This table resides in external memory.
     The size of this table is determined by the number of sets and the set size.
     Table size = set size * number of sets
-    This tables base address should be aligned to SetSize.*/
+    This table base address should be aligned to SetSize.*/
     autoLearnHashTblSize = numOfSets * setSize;
 
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
@@ -1760,7 +1759,9 @@ static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 
     if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != 0)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
-                                              "Failed to release %d buffers to the BM (missing FBPRs)", fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
+                                              "Failed to release %d buffers to the BM (missing FBPRs)",
+                                              fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
+
     return E_OK;
 }
 
@@ -2915,20 +2916,17 @@ static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip
     return E_OK;
 }
 
-static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
-                               t_FmPcdManip                 *p_Manip,
-                               t_FmPcd                      *p_FmPcd)
+static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
-    t_FmPcdManipHdrInsrtByTemplateParams    *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
-    uint8_t                                 tmpReg8 = 0xff;
-    t_AdOfTypeContLookup                    *p_Ad;
-    bool                                    ipModify = FALSE;
-    uint32_t                                tmpReg32 = 0, tmpRegNia = 0;
-    uint16_t                                tmpReg16 = 0;
-    t_Error                                 err = E_OK;
-    uint8_t                                 extraAddedBytes = 0, blockSize = 0;
-    uint8_t                                 extraAddedBytesAlignedToBlockSize = 0;
-    uint8_t                                 *p_Template = NULL;
+    t_FmPcdManipHdrInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
+    uint8_t                             tmpReg8 = 0xff;
+    t_AdOfTypeContLookup                *p_Ad;
+    bool                                ipModify = FALSE;
+    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t                            tmpReg16 = 0;
+    t_Error                             err = E_OK;
+    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0, log2Num = 0;
+    uint8_t                             *p_Template = NULL;
 
     SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
@@ -2950,12 +2948,11 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
          if (p_InsrtByTemplate->size)
          {
-             p_Manip->p_Template =
-                (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                              p_InsrtByTemplate->size,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-             if (!p_Manip->p_Template)
-                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for manipulation header template"));
+             if(!p_Manip->p_Template)
+                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
 
              tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
              tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
@@ -2967,7 +2964,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
         p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
 
         if (!p_Template)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of manipulation header template"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
 
         memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
 
@@ -2978,27 +2975,21 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
              tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
 
-             if ((tmpReg8 & 0xf0) == 0x40)
+             if((tmpReg8 & 0xf0) == 0x40)
                  tmpReg8 = 4;
-             else if ((tmpReg8 & 0xf0) == 0x60)
+             else if((tmpReg8 & 0xf0) == 0x60)
                  tmpReg8 = 6;
              else
                  tmpReg8 = 0xff;
 
-             if (tmpReg8 == 4)
+             if (tmpReg8 != 0xff)
              {
-                 if ((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
-
-                 if (p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
-
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
-
-                 if (p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
                  {
 
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
                             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
                      extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
                      blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
@@ -3012,32 +3003,44 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
                  {
                      if (!POWER_OF_2(blockSize))
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
-                     blockSize -= 1;
                  }
 
+             }
+             if (tmpReg8 == 4)
+             {
+                 if ((IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                 if (blockSize)
+                     blockSize -= 1;
+
                  if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;// IPV6 - in AD instead of SEQ IND
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);// for IPV6 decrement additional 40 bytes of IPV6 heade size
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
 
 
                  /*IP header template - relevant only for ipv4 CheckSum = 0*/
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
 
 
                  /*UDP checksum has to be 0*/
                  if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
                  {
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
 
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
 
                  }
 
@@ -3046,12 +3049,34 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
                  tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
              }
+             else if (tmpReg8 == 6)
+             {
+                /*TODO - add check for maximum value of blockSize;*/
+                 if (blockSize)
+                    LOG2(blockSize, log2Num);
+                 tmpRegNia |= (uint32_t)log2Num << 24;
+
+                // for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes - 40);
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+               if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+               {
+                 if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+                if (p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_NEXT_HEADER_OFFSET_FROM_IP] != 0x88)
+                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("OUr suppport is only IPv6/UDPLite"));
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP + 1] = 0x08;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+               }
+             }
              else
                  RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
          }
 
          tmpReg32 = tmpReg16 = tmpReg8 = 0;
-
+         /*TODO - check it*/
          if (p_InsrtByTemplate->modifyOuterVlan)
          {
              if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
@@ -3077,7 +3102,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     if (p_Manip->h_Frag)
     {
         tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+        tmpReg32  |= (uint32_t)p_Manip->sizeForFragmentation << 16;
     }
     else
           tmpReg32 = 0xffff0000;
@@ -3355,6 +3380,64 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     return p_Manip;
 }
 
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_CrntMdfManip,
+                                                       t_List            *h_NodesLst)
+{
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfManip = NULL;
+    t_List                  *p_Pos;
+    int                     i = 0;
+    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation     ccNodeInfo;
+
+    LIST_FOR_EACH(p_Pos, &p_CrntMdfManip->nodesLst)
+    {
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        p_NodePtrOnCurrentMdfManip = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+
+        ASSERT_COND(p_NodePtrOnCurrentMdfManip);
+
+        /* Search in the previous node which exact index points on this current modified node for getting AD */
+        for (i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
+        {
+            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                {
+                    if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
+                    else
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                PTR_MOVE(p_NodePtrOnCurrentMdfManip->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
+                    EnqueueNodeInfoToRelevantLst(h_NodesLst, &ccNodeInfo, NULL);
+                }
+            }
+        }
+
+        ASSERT_COND(i != p_NodePtrOnCurrentMdfManip->numOfKeys);
+    }
+}
+
+static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd *p_FmPcd)
+{
+    t_Error err;
+
+   /* Copy the HMTD */
+    IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
+    /* Replace the HMCT table pointer  */
+    WRITE_UINT32(((t_Hmtd *)p_Dest)->hmcdBasePtr,
+              (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
+    /* Call Host Command to replace HMTD by a new HMTD */
+    err = FmHcPcdCcDoDynamicChange(p_FmPcd->h_Hc,
+                                (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
+                                (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
+    if (err)
+        REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
+}
 
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
@@ -3424,7 +3507,7 @@ t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
    return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
 
-t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
+t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
 {
     t_FmPcdManip             *p_Manip;
     t_Error                   err;
@@ -3906,67 +3989,6 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     return p_Manip;
 }
 
-
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_CrntMdfManip,
-                                                       t_List            *h_NodesLst)
-{
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfManip = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
-    t_CcNodeInformation     ccNodeInfo;
-
-    LIST_FOR_EACH(p_Pos, &p_CrntMdfManip->nodesLst)
-    {
-        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfManip = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
-
-        ASSERT_COND(p_NodePtrOnCurrentMdfManip);
-
-        /* Search in the previous node which exact index points on this current modified node for getting AD */
-        for (i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
-        {
-            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            {
-                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
-                {
-                    if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
-                    else
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                PTR_MOVE(p_NodePtrOnCurrentMdfManip->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
-
-                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                    ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
-                    EnqueueNodeInfoToRelevantLst(h_NodesLst, &ccNodeInfo, NULL);
-                }
-            }
-        }
-
-        ASSERT_COND(i != p_NodePtrOnCurrentMdfManip->numOfKeys);
-    }
-}
-
-
-static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd *p_FmPcd)
-{
-    t_Error err;
-
-   /* Copy the HMTD */
-    IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
-    /* Replace the HMCT table pointer  */
-    WRITE_UINT32(((t_Hmtd *)p_Dest)->hmcdBasePtr,
-              (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
-    /* Call Host Command to replace HMTD by a new HMTD */
-    err = FmHcPcdCcDoDynamicChange(p_FmPcd->h_Hc,
-                                (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
-                                (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
-    if (err)
-        REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
-}
-
 t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipParams)
 {
     t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 729c1d9..390ca6e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -68,14 +68,18 @@
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
 
-#define UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP        6
-#define UDP_UDPCHECKSUM_FIELD_SIZE                  2
+#define UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP          6
+#define UDP_CHECKSUM_FIELD_SIZE                     2
+#define UDP_LENGTH_FIELD_OFFSET_FROM_UDP            4
 
-#define IP_DSCECN_FIELD_OFFSET_FROM_IP              1
-#define IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP         2
-#define IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP         10
+#define IPv4_DSCECN_FIELD_OFFSET_FROM_IP            1
+#define IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP       2
+#define IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP       10
 #define VLAN_TAG_FIELD_OFFSET_FROM_ETH              12
-#define IP_ID_FIELD_OFFSET_FROM_IP                  4
+#define IPv4_ID_FIELD_OFFSET_FROM_IP                4
+
+#define IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP          4
+#define IPv6_NEXT_HEADER_OFFSET_FROM_IP             6
 
 #define FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE               0x80
 #define FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN              8
@@ -146,6 +150,7 @@
 #define HMCD_OPCODE_TCP_UDP_CHECKSUM            0x14
 #define HMCD_OPCODE_REPLACE_IP                  0x12
 
+#define HMCD_DSCP_VALUES                        64
 
 #define HMCD_BASIC_SIZE                         4
 #define HMCD_PTR_SIZE                           4
@@ -207,7 +212,7 @@
 
 #define HMCD_IP_REPLACE_L3HDRSIZE_SHIFT         24
 
-#define DSCP_TO_VLAN_TABLE_SIZE                 32
+#define DSCP_TO_VLAN_TABLE_SIZE                    32
 
 #define MANIP_GET_HMCT_SIZE(h_Manip)                    (((t_FmPcdManip *)h_Manip)->tableSize)
 #define MANIP_GET_DATA_SIZE(h_Manip)                    (((t_FmPcdManip *)h_Manip)->dataSize)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 9e7707e..747347c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -1351,6 +1351,18 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
+#ifdef FM_CAPWAP_SUPPORT
+            /* UDP_LITE  */
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_LITE)
+            {
+                /* IPSec UDP encapsulation is currently set to use SHIM1 */
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_LITE;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_UDP;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_UDP;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+            }
+#endif /* FM_CAPWAP_SUPPORT */
+
             /* IP FRAG  */
             if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
                 (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
@@ -1662,41 +1674,41 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
     {
         /* Parser statistics */
         case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_pds);
         case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l2rrs);
         case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l3rrs);
         case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l4rrs);
         case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_srrs);
         case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l2rres);
         case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l3rres);
         case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l4rres);
         case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_srres);
         case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_spcs);
         case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_spscs);
         case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_hxscs);
         case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mrcs);
         case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mrscs);
         case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mwcs);
         case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mwscs);
         case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_fcscs);
         case (e_FM_PCD_KG_COUNTERS_TOTAL):
-               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
+               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_tpc);
 
         /* Policer statistics */
         case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
@@ -1800,36 +1812,36 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
         switch (exception)
         {
             case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_eeer);
                 if (enable)
-                    tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+                    tmpReg |= FM_EX_KG_DOUBLE_ECC;
                 else
-                    tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
-                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                    tmpReg &= ~FM_EX_KG_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_eeer, tmpReg);
                 break;
             case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_eeer);
                 if (enable)
-                    tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+                    tmpReg |= FM_EX_KG_KEYSIZE_OVERFLOW;
                 else
-                    tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
-                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                    tmpReg &= ~FM_EX_KG_KEYSIZE_OVERFLOW;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_eeer, tmpReg);
                 break;
             case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_perer);
                 if (enable)
                     tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
-                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_perer, tmpReg);
                 break;
             case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_pever);
                 if (enable)
                     tmpReg |= FM_PCD_PRS_SINGLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
-                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_pever, tmpReg);
                 break;
             case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
@@ -1923,22 +1935,20 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
         case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
             break;
         case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
             break;
         case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
+            if (!(p_FmPcd->exceptions & FM_EX_KG_DOUBLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_feer, FM_EX_KG_DOUBLE_ECC);
             break;
         case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
+            if (!(p_FmPcd->exceptions & FM_EX_KG_KEYSIZE_OVERFLOW))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_feer, FM_EX_KG_KEYSIZE_OVERFLOW);
             break;
         case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
@@ -2021,58 +2031,58 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     switch (counter)
     {
         case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_pds, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l2rrs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l3rrs, value);
              break;
        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l4rrs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_srrs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l2rres, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l3rres, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_l4rres, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_srres, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_spcs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_spscs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_hxscs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mrcs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mrscs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mwcs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_mwscs, value);
             break;
         case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fmpr_fcscs, value);
              break;
         case (e_FM_PCD_KG_COUNTERS_TOTAL):
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->fmkg_tpc,value);
             break;
 
         /*Policer counters*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index eb004f7..b6b9b35 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -44,6 +44,8 @@
 #include "list_ext.h"
 #include "fm_pcd_ext.h"
 #include "fm_common.h"
+#include "fsl_fman_prs.h"
+#include "fsl_fman_kg.h"
 
 #define __ERR_MODULE__  MODULE_FM_PCD
 
@@ -52,8 +54,7 @@
 /* Defaults                 */
 /****************************/
 #define DEFAULT_plcrAutoRefresh                 FALSE
-#define DEFAULT_prsMaxParseCycleLimit           0
-#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_EX_KG_DOUBLE_ECC | FM_EX_KG_KEYSIZE_OVERFLOW)
 #define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
 #define DEFAULT_fmPcdPlcrExceptions             0
 #define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
@@ -83,25 +84,20 @@
 /****************************/
 /* Error defines           */
 /****************************/
-#define FM_PCD_EX_KG_DOUBLE_ECC                     0x80000000
-#define FM_PCD_EX_KG_KEYSIZE_OVERFLOW               0x40000000
 
 #define FM_PCD_EX_PLCR_DOUBLE_ECC                   0x20000000
 #define FM_PCD_EX_PLCR_INIT_ENTRY_ERROR             0x10000000
 #define FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE      0x08000000
 #define FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE       0x04000000
 
-#define FM_PCD_EX_PRS_DOUBLE_ECC                    0x02000000
-#define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
-
 #define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
 switch (exception){                                                 \
     case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                          \
-        bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
+        bitMask = FM_EX_KG_DOUBLE_ECC; break;                   \
     case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                        \
         bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
     case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:                    \
-        bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
+        bitMask = FM_EX_KG_KEYSIZE_OVERFLOW; break;             \
     case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:                  \
         bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
     case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
@@ -114,19 +110,6 @@ switch (exception){                                                 \
         bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
     default: bitMask = 0;break;}
 
-/****************************/
-/* Parser defines           */
-/****************************/
-#define FM_PCD_PRS_SINGLE_ECC                 0x00004000
-#define FM_PCD_PRS_DOUBLE_ECC                 0x00004000
-#define PRS_MAX_CYCLE_LIMIT                   8191
-
-/***********************************************************************/
-/*          Keygen defines                                             */
-/***********************************************************************/
-#define FM_PCD_KG_DOUBLE_ECC                  0x80000000
-#define FM_PCD_KG_KEYSIZE_OVERFLOW            0x40000000
-
 /***********************************************************************/
 /*          Policer defines                                            */
 /***********************************************************************/
@@ -143,46 +126,6 @@ switch (exception){                                                 \
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct {
-   volatile uint32_t kgoe_sp;
-   volatile uint32_t kgoe_cpp;
-} _PackedType t_FmPcdKgPortConfigRegs;
-
-typedef _Packed struct {
-    volatile uint32_t kgcpe[8];
-} _PackedType t_FmPcdKgClsPlanRegs;
-
-typedef _Packed union {
-    t_FmPcdKgSchemeRegs             schemeRegs;
-    t_FmPcdKgPortConfigRegs         portRegs;
-    t_FmPcdKgClsPlanRegs            clsPlanRegs;
-} _PackedType u_FmPcdKgIndirectAccessRegs;
-
-typedef _Packed struct {
-    volatile uint32_t kggcr;
-    volatile uint32_t res0;
-    volatile uint32_t res1;
-    volatile uint32_t kgeer;
-    volatile uint32_t kgeeer;
-    volatile uint32_t res2;
-    volatile uint32_t res3;
-    volatile uint32_t kgseer;
-    volatile uint32_t kgseeer;
-    volatile uint32_t kggsr;
-    volatile uint32_t kgtpc;
-    volatile uint32_t kgserc;
-    volatile uint32_t res4[4];
-    volatile uint32_t kgfdor;
-    volatile uint32_t kggdv0r;
-    volatile uint32_t kggdv1r;
-    volatile uint32_t res5[5];
-    volatile uint32_t kgfer;
-    volatile uint32_t kgfeer;
-    volatile uint32_t res6[38];
-    u_FmPcdKgIndirectAccessRegs   indirectAccessRegs;
-    volatile uint32_t res[40];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
-    volatile uint32_t kgar;
-} _PackedType t_FmPcdKgRegs;
 
 typedef _Packed struct {
 /* General Configuration and Status Registers */
@@ -217,39 +160,6 @@ typedef _Packed struct {
                                            (for port-ID 1-11, only for supported Port-ID registers) */
 } _PackedType t_FmPcdPlcrRegs;
 
-typedef _Packed struct {
-    volatile uint32_t rpclim;
-    volatile uint32_t rpimac;
-    volatile uint32_t pmeec;
-    volatile uint32_t res1[5];
-    volatile uint32_t pevr;
-    volatile uint32_t pever;
-    volatile uint32_t pevfr;
-    volatile uint32_t perr;
-    volatile uint32_t perer;
-    volatile uint32_t perfr;
-    volatile uint32_t res2[0xA];
-    volatile uint32_t ppsc;
-    volatile uint32_t res3;
-    volatile uint32_t pds;
-    volatile uint32_t l2rrs;
-    volatile uint32_t l3rrs;
-    volatile uint32_t l4rrs;
-    volatile uint32_t srrs;
-    volatile uint32_t l2rres;
-    volatile uint32_t l3rres;
-    volatile uint32_t l4rres;
-    volatile uint32_t srres;
-    volatile uint32_t spcs;
-    volatile uint32_t spscs;
-    volatile uint32_t hxscs;
-    volatile uint32_t mrcs;
-    volatile uint32_t mwcs;
-    volatile uint32_t mrscs;
-    volatile uint32_t mwscs;
-    volatile uint32_t fcscs;
-} _PackedType t_FmPcdPrsRegs;
-
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -328,8 +238,14 @@ typedef struct {
 #endif
 } t_FmPcdKgScheme;
 
+typedef _Packed union {
+    struct fman_kg_scheme_regs schemeRegs;
+    struct fman_kg_pe_regs portRegs;
+    struct fman_kg_cp_regs clsPlanRegs;
+} _PackedType u_FmPcdKgIndirectAccessRegs;
+
 typedef struct {
-    t_FmPcdKgRegs       *p_FmPcdKgRegs;
+    struct fman_kg_regs *p_FmPcdKgRegs;
     uint32_t            schemeExceptionsBitMask;
     uint8_t             numOfSchemes;
     t_Handle            h_HwSpinlock;
@@ -339,6 +255,7 @@ typedef struct {
     uint8_t             emptyClsPlanGrpId;
     t_FmPcdAllocMng     schemesMng[FM_PCD_KG_NUM_OF_SCHEMES]; /* only for MASTER ! */
     t_FmPcdAllocMng     clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+    u_FmPcdKgIndirectAccessRegs *p_IndirectAccessRegs;
 } t_FmPcdKg;
 
 typedef struct {
@@ -381,7 +298,7 @@ typedef struct {
     uint32_t                        *p_SwPrsCode;
     uint32_t                        *p_CurrSwPrs;
     uint8_t                         currLabel;
-    t_FmPcdPrsRegs                  *p_FmPcdPrsRegs;
+    struct fman_prs_regs            *p_FmPcdPrsRegs;
     t_FmPcdPrsLabelParams           labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
     uint32_t                        fmPcdPrsPortIdStatistics;
 } t_FmPcdPrs;
@@ -414,6 +331,7 @@ typedef struct {
 } t_FmPcdNetEnv;
 
 typedef struct {
+    struct fman_prs_cfg          dfltCfg;
     bool                        plcrAutoRefresh;
     uint16_t                    prsMaxParseCycleLimit;
 } t_FmPcdDriverParam;
@@ -526,7 +444,7 @@ uint16_t    FmPcdCcGetNumOfKeys(t_Handle h_CcNode);
 t_Error     ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, e_FmPcdCcStatsMode supportedStatsMode);
 
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
-t_Error     FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_InfoForManip, uint32_t *requiredAction);
+t_Error     FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_InfoForManip, uint32_t *requiredAction);
 void        FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
                                           t_FmPcdCcNextEngineParams    *p_CcNextEngineParams,
                                           t_Handle                     p_Ad,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index fe95bec..ded7960 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -577,7 +577,7 @@ static void FreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_
 
     ASSERT_COND(numOfProfiles);
 
-    for (i=0; i<numOfProfiles; i++)
+    for (i=0; i < numOfProfiles; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
@@ -1793,7 +1793,7 @@ uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCoun
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
         return 0;
     }
-    intFlags = PlcrHwLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
     switch (counter)
@@ -1817,7 +1817,7 @@ uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCoun
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             break;
     }
-    PlcrHwUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     return counterVal;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 3e387b3..e198afd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -46,51 +46,43 @@
 #include "fm_pcd.h"
 #include "fm_pcd_ipc.h"
 #include "fm_prs.h"
+#include "fsl_fman_prs.h"
 
 
 static void PcdPrsErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event, mask, force;
+    uint32_t                event, ev_mask;
+    struct fman_prs_regs     *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
-    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+    ev_mask = fman_prs_get_err_ev_mask(PrsRegs);
 
-    event &= mask;
+    event = fman_prs_get_err_event(PrsRegs, ev_mask);
 
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr);
-    if (force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, force & ~event);
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
+    fman_prs_ack_err_event(PrsRegs, event);
 
     DBG(TRACE, ("parser error - 0x%08x\n",event));
 
-    if (event & FM_PCD_PRS_DOUBLE_ECC)
+    if(event & FM_PCD_PRS_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
 }
 
 static void PcdPrsException(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t            event, force;
+    uint32_t            event, ev_mask;
+    struct fman_prs_regs     *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
-    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr);
-    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+    ev_mask = fman_prs_get_expt_ev_mask(PrsRegs);
+    event = fman_prs_get_expt_event(PrsRegs, ev_mask);
 
     ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
 
     DBG(TRACE, ("parser event - 0x%08x\n",event));
 
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr);
-    if (force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, force & ~event);
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
+    fman_prs_ack_expt_event(PrsRegs, event);
 
     p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
 }
@@ -110,17 +102,18 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
         return NULL;
     }
     memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
+    fman_prs_defconfig(&p_FmPcd->p_FmPcdDriverParam->dfltCfg);
 
     if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
         baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
         p_FmPcdPrs->p_SwPrsCode  = (uint32_t *)UINT_TO_PTR(baseAddr);
-        p_FmPcdPrs->p_FmPcdPrsRegs  = (t_FmPcdPrsRegs *)UINT_TO_PTR(baseAddr + PRS_REGS_OFFSET);
+        p_FmPcdPrs->p_FmPcdPrsRegs  = (struct fman_prs_regs *)UINT_TO_PTR(baseAddr + PRS_REGS_OFFSET);
     }
 
-    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
-    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
-    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics = p_FmPcd->p_FmPcdDriverParam->dfltCfg.port_id_stat;
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = p_FmPcd->p_FmPcdDriverParam->dfltCfg.max_prs_cyc_lim;
+    p_FmPcd->exceptions |= p_FmPcd->p_FmPcdDriverParam->dfltCfg.prs_exceptions;
 
     return p_FmPcdPrs;
 }
@@ -128,12 +121,16 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
 t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
-    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
     uint32_t            *p_TmpCode;
     uint32_t            *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
                                                              FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+    struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+#ifdef FM_CAPWAP_SUPPORT
+    uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
+#else
     uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
-    uint32_t            tmpReg, i;
+#endif /* FM_CAPWAP_SUPPORT */
+    uint32_t            i;
 
     ASSERT_COND(sizeof(swPrsPatch) <= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
 
@@ -147,9 +144,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch),4));
     memcpy((uint8_t *)p_TmpCode, (uint8_t *)swPrsPatch, sizeof(swPrsPatch));
 
-    /**********************RPCLIM******************/
-    WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
-    /**********************FMPL_RPCLIM******************/
+    fman_prs_init(PrsRegs, &p_Param->dfltCfg);
 
     /* register even if no interrupts enabled, to allow future enablement */
     FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR, PcdPrsErrorException, p_FmPcd);
@@ -157,37 +152,11 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /* register even if no interrupts enabled, to allow future enablement */
     FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL, PcdPrsException, p_FmPcd);
 
-    /**********************PEVR******************/
-    WRITE_UINT32(p_Regs->pevr, (FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS) );
-    /**********************PEVR******************/
-
-    /**********************PEVER******************/
-    if (p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
-    {
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
         FmEnableRamsEcc(p_FmPcd->h_Fm);
-        WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
-    }
-    else
-        WRITE_UINT32(p_Regs->pever, 0);
-    /**********************PEVER******************/
 
-    /**********************PERR******************/
-    WRITE_UINT32(p_Regs->perr, FM_PCD_PRS_DOUBLE_ECC);
-    /**********************PERR******************/
-
-    /**********************PERER******************/
-    tmpReg = 0;
-    if (p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
-    {
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
         FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
-    }
-    WRITE_UINT32(p_Regs->perer, tmpReg);
-    /**********************PERER******************/
-
-    /**********************PPSC******************/
-    WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
-    /**********************PPSC******************/
 
     /* load sw parser Ip-Frag patch */
     for (i=0; i<DIV_CEIL(sizeof(swPrsPatch),4); i++)
@@ -208,22 +177,23 @@ void PrsFree(t_FmPcd *p_FmPcd)
 
 void PrsEnable(t_FmPcd *p_FmPcd)
 {
-    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+    struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
-    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
+    fman_prs_enable(PrsRegs);
 }
 
 void PrsDisable(t_FmPcd *p_FmPcd)
 {
-    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+    struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
-    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) & ~FM_PCD_PRS_RPIMAC_EN);
+    fman_prs_disable(PrsRegs);
 }
 
 t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include)
 {
+    struct fman_prs_regs *PrsRegs;
     uint32_t    bitMask = 0;
     uint8_t     prsPortId;
 
@@ -231,6 +201,8 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
+    PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
     GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
     GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId);
 
@@ -239,7 +211,8 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     else
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
 
-    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+    fman_prs_set_stst_port_msk(PrsRegs,
+            p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
 
     return E_OK;
 }
@@ -344,20 +317,21 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    struct fman_prs_regs *PrsRegs;
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
         return;
     }
 
-    if (enable)
-        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
-    else
-        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
+    fman_prs_set_stst(PrsRegs, enable);
 }
 
 t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
@@ -378,7 +352,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     if (!p_SwPrs->override)
     {
-        if (p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
+        if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
     }
     else
@@ -404,7 +378,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for (i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
+    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
     p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
         p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
@@ -428,7 +402,7 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPrsMaxCycleLimit - guest mode!"));
 
     p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
@@ -452,33 +426,31 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FM-PCD parser regs"));
 
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_rpclim);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_rpimac);
     DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pever);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_perr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_perer);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_ppsc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pds);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l2rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l3rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l4rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_srrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l2rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l3rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l4rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_srres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_spcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_spscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_hxscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mrcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mwcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mrscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mwscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_fcscs);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index ca3f09e..3e5974c5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -46,6 +46,16 @@
 /*          SW parser IP_FRAG patch                                    */
 /***********************************************************************/
 
+
+#ifdef FM_CAPWAP_SUPPORT
+#define SW_PRS_UDP_LITE_PATCH   \
+{\
+    0x31,0x92,0x50,0x29,0x00,0x88,0x08,0x16,0x00,0x00, \
+    0x00,0x01,0x00,0x05,0x00,0x81,0x1C,0x0B,0x00,0x01, \
+    0x1B,0xFF,                                    \
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
 #if (DPAA_VERSION == 10)
 /* Version: 106.1.9 */
 #define SW_PRS_IP_FRAG_PATCH                           \
@@ -93,6 +103,7 @@
     0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
     0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
 }
+
 #else
 /* version: 106.3.13 */
 #define SW_PRS_IP_FRAG_PATCH                           \
@@ -158,16 +169,14 @@
 /****************************/
 /* Parser defines           */
 /****************************/
+#define FM_PCD_PRS_SW_TAIL_SIZE             4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+
 /* masks */
 #define PRS_ERR_CAP                         0x80000000
 #define PRS_ERR_TYPE_DOUBLE                 0x40000000
 #define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
 #define PRS_ERR_ADDR_MASK                   0x000001FF
-#define FM_PCD_PRS_RPIMAC_EN                0x00000001
-#define FM_PCD_PRS_SINGLE_ECC               0x00004000
-#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
-#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
-#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
 
 /* others */
 #define PRS_MAX_CYCLE_LIMIT                 8191
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
index c69965a..ae72b25 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
@@ -507,18 +507,8 @@ static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in remove member"));
     }
 
-    switch (GET_ERROR_TYPE(err))
-    {
-        case E_OK:
-            return E_OK;
-
-        case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
-
-        default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     if (p_CurrentMember->h_Manip)
     {
@@ -627,7 +617,8 @@ void FrmReplicGroupUpdateAd(t_Handle  h_ReplicGroup,
     t_FmPcd             *p_FmPcd;
 
     ASSERT_COND(p_ReplicGroup);
-    p_FmPcd    = p_ReplicGroup->h_FmPcd;
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+
     /* build a bypass ad */
     WRITE_UINT32(p_AdResult->fqid, FM_PCD_AD_BYPASS_TYPE |
         (uint32_t)((XX_VirtToPhys(p_ReplicGroup->p_SourceTd)) - p_FmPcd->physicalMuramBase));
@@ -937,7 +928,7 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
 
             /* add the new member to the internal sw member list */
             AddMemberToList(p_ReplicGroup, p_NewMember, &p_PreviousMember->node);
-            break;
+           break;
 
         default:
             /* unlock */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_kg.c
new file mode 100644
index 0000000..6e77c93
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_kg.c
@@ -0,0 +1,888 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fsl_fman_kg.h"
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+
+static uint32_t build_ar_bind_scheme(uint8_t hwport_id, bool write)
+{
+	uint32_t rw;
+
+	rw = write ? (uint32_t)FM_KG_KGAR_WRITE : (uint32_t)FM_KG_KGAR_READ;
+
+	return (uint32_t)(FM_KG_KGAR_GO |
+			rw |
+			FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+			hwport_id |
+			FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+
+static void clear_pe_all_scheme(struct fman_kg_regs *regs, uint8_t hwport_id)
+{
+	uint32_t ar;
+
+	fman_kg_write_sp(regs, 0xffffffff, 0);
+
+	ar = build_ar_bind_scheme(hwport_id, TRUE);
+	fman_kg_write_ar_wait(regs, ar);
+}
+
+static uint32_t build_ar_bind_cls_plan(uint8_t hwport_id, bool write)
+{
+	uint32_t rw;
+
+	rw = write ? (uint32_t)FM_KG_KGAR_WRITE : (uint32_t)FM_KG_KGAR_READ;
+
+	return (uint32_t)(FM_KG_KGAR_GO |
+			rw |
+			FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+			hwport_id |
+			FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
+}
+
+static void clear_pe_all_cls_plan(struct fman_kg_regs *regs, uint8_t hwport_id)
+{
+	uint32_t ar;
+
+	fman_kg_write_cpp(regs, 0);
+
+	ar = build_ar_bind_cls_plan(hwport_id, TRUE);
+	fman_kg_write_ar_wait(regs, ar);
+}
+
+static uint8_t get_gen_ht_code(enum fman_kg_gen_extract_src src,
+				bool no_validation,
+				uint8_t *offset)
+{
+	int	code;
+
+	switch (src) {
+	case E_FMAN_KG_GEN_EXTRACT_ETH:
+		code = no_validation ? 0x73 : 0x3;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_ETYPE:
+		code = no_validation ? 0x77 : 0x7;
+		break;
+ 
+	case E_FMAN_KG_GEN_EXTRACT_SNAP:
+		code = no_validation ? 0x74 : 0x4;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_1:
+		code = no_validation ? 0x75 : 0x5;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_N:
+		code = no_validation ? 0x76 : 0x6;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_PPPoE:
+		code = no_validation ? 0x78 : 0x8;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_MPLS_1:
+		code = no_validation ? 0x79 : 0x9;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_MPLS_2:
+		code = no_validation ? FM_KG_SCH_GEN_HT_INVALID : 0x19;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_MPLS_3:
+		code = no_validation ? FM_KG_SCH_GEN_HT_INVALID : 0x29;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_MPLS_N:
+		code = no_validation ? 0x7a : 0xa;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPv4_1:
+		code = no_validation ? 0x7b : 0xb;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPv6_1:
+		code = no_validation ? 0x7b : 0x1b;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPv4_2:
+		code = no_validation ? 0x7c : 0xc;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPv6_2:
+		code = no_validation ? 0x7c : 0x1c;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_MINENCAP:
+		code = no_validation ? 0x7c : 0x2c;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IP_PID:
+		code = no_validation ? 0x72 : 0x2;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_GRE:
+		code = no_validation ? 0x7d : 0xd;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_TCP:
+		code = no_validation ? 0x7e : 0xe;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_UDP:
+		code = no_validation ? 0x7e : 0x1e;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_SCTP:
+		code = no_validation ? 0x7e : 0x3e;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_DCCP:
+		code = no_validation ? 0x7e : 0x4e;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPSEC_AH:
+		code = no_validation ? 0x7e : 0x2e;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_IPSEC_ESP:
+		code = no_validation ? 0x7e : 0x6e;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_SHIM_1:
+		code = 0x70;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_SHIM_2:
+		code = 0x71;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_FROM_DFLT:
+		code = 0x10;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_FROM_FRAME_START:
+		code = 0x40;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_FROM_PARSE_RESULT:
+		code = 0x20;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_FROM_END_OF_PARSE:
+		code = 0x7f;
+		break;
+
+	case E_FMAN_KG_GEN_EXTRACT_FROM_FQID:
+		code = 0x20;
+		*offset += 0x20;
+		break;
+
+	default:
+		code = FM_KG_SCH_GEN_HT_INVALID;
+	}
+
+	return (uint8_t)code;
+}
+
+static uint32_t build_ar_scheme(uint8_t scheme,
+				uint8_t hwport_id,
+				bool update_counter,
+				bool write)
+{
+	uint32_t rw;
+
+	rw = (uint32_t)(write ? FM_KG_KGAR_WRITE : FM_KG_KGAR_READ);
+
+	return (uint32_t)(FM_KG_KGAR_GO |
+			rw |
+			FM_KG_KGAR_SEL_SCHEME_ENTRY |
+			hwport_id |
+			((uint32_t)scheme << FM_KG_KGAR_NUM_SHIFT) |
+			(update_counter ? FM_KG_KGAR_SCM_WSEL_UPDATE_CNT : 0));
+}
+
+static uint32_t build_ar_cls_plan(uint8_t grp,
+					uint8_t entries_mask,
+					uint8_t hwport_id,
+					bool write)
+{
+	uint32_t rw;
+
+	rw = (uint32_t)(write ? FM_KG_KGAR_WRITE : FM_KG_KGAR_READ);
+
+	return (uint32_t)(FM_KG_KGAR_GO |
+			rw |
+			FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+			hwport_id |
+			((uint32_t)grp << FM_KG_KGAR_NUM_SHIFT) |
+			((uint32_t)entries_mask << FM_KG_KGAR_WSEL_SHIFT));
+}
+
+int fman_kg_write_ar_wait(struct fman_kg_regs *regs, uint32_t fmkg_ar)
+{
+	iowrite32be(fmkg_ar, &regs->fmkg_ar);
+	/* Wait for GO to be idle and read error */
+	while ((fmkg_ar = ioread32be(&regs->fmkg_ar)) & FM_KG_KGAR_GO) ;
+	if (fmkg_ar & FM_PCD_KG_KGAR_ERR)
+		return -EINVAL;
+	return 0;
+}
+
+void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add)
+{
+
+	struct fman_kg_pe_regs *kgpe_regs;
+	uint32_t tmp;
+	
+	kgpe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
+	tmp = ioread32be(&kgpe_regs->fmkg_pe_sp);
+
+	if (add)
+		tmp |= sp;
+	else /* clear */
+		tmp &= ~sp;
+
+	iowrite32be(tmp, &kgpe_regs->fmkg_pe_sp);
+
+}
+
+void fman_kg_write_cpp(struct fman_kg_regs *regs, uint32_t cpp)
+{
+	struct fman_kg_pe_regs *kgpe_regs;
+	
+	kgpe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
+
+	iowrite32be(cpp, &kgpe_regs->fmkg_pe_cpp);
+}
+
+void fman_kg_get_event(struct fman_kg_regs *regs,
+			uint32_t *event,
+			uint32_t *scheme_idx)
+{
+	uint32_t mask, force;
+
+	*event = ioread32be(&regs->fmkg_eer);
+	mask = ioread32be(&regs->fmkg_eeer);
+	*scheme_idx = ioread32be(&regs->fmkg_seer);
+	*scheme_idx &= ioread32be(&regs->fmkg_seeer);
+
+	*event &= mask;
+
+	/* clear the forced events */
+	force = ioread32be(&regs->fmkg_feer);
+	if (force & *event)
+		iowrite32be(force & ~*event ,&regs->fmkg_feer);
+
+	iowrite32be(*event, &regs->fmkg_eer);
+	iowrite32be(*scheme_idx, &regs->fmkg_seer);
+}
+
+
+void fman_kg_init(struct fman_kg_regs *regs,
+			uint32_t exceptions,
+			uint32_t dflt_nia)
+{
+	uint32_t tmp;
+	int i;
+	
+	iowrite32be(FM_EX_KG_DOUBLE_ECC | FM_EX_KG_KEYSIZE_OVERFLOW,
+			&regs->fmkg_eer);
+
+	tmp = 0;
+	if (exceptions & FM_EX_KG_DOUBLE_ECC)
+        	tmp |= FM_EX_KG_DOUBLE_ECC;
+
+	if (exceptions & FM_EX_KG_KEYSIZE_OVERFLOW)
+		tmp |= FM_EX_KG_KEYSIZE_OVERFLOW;
+	
+	iowrite32be(tmp, &regs->fmkg_eeer);
+	iowrite32be(0, &regs->fmkg_fdor);
+	iowrite32be(0, &regs->fmkg_gdv0r);
+	iowrite32be(0, &regs->fmkg_gdv1r);
+	iowrite32be(dflt_nia, &regs->fmkg_gcr);
+
+	/* Clear binding between ports to schemes and classification plans
+	 * so that all ports are not bound to any scheme/classification plan */
+	for (i = 0; i < FMAN_MAX_NUM_OF_HW_PORTS; i++) {
+		clear_pe_all_scheme(regs, (uint8_t)i);
+		clear_pe_all_cls_plan(regs, (uint8_t)i);
+	}
+}
+
+void fman_kg_enable_scheme_interrupts(struct fman_kg_regs *regs)
+{
+	/* enable and enable all scheme interrupts */
+	iowrite32be(0xFFFFFFFF, &regs->fmkg_seer);
+	iowrite32be(0xFFFFFFFF, &regs->fmkg_seeer);
+}
+
+void fman_kg_enable(struct fman_kg_regs *regs)
+{
+	iowrite32be(ioread32be(&regs->fmkg_gcr) | FM_KG_KGGCR_EN,
+			&regs->fmkg_gcr);
+}
+
+void fman_kg_disable(struct fman_kg_regs *regs)
+{
+	iowrite32be(ioread32be(&regs->fmkg_gcr) & ~FM_KG_KGGCR_EN,
+			&regs->fmkg_gcr);
+}
+
+void fman_kg_set_data_after_prs(struct fman_kg_regs *regs, uint8_t offset)
+{
+	iowrite32be(offset, &regs->fmkg_fdor);
+}
+
+void fman_kg_set_dflt_val(struct fman_kg_regs *regs,
+				uint8_t def_id,
+				uint32_t val)
+{
+	if(def_id == 0)
+		iowrite32be(val, &regs->fmkg_gdv0r);
+	else
+		iowrite32be(val, &regs->fmkg_gdv1r);
+}
+
+
+void fman_kg_set_exception(struct fman_kg_regs *regs,
+				uint32_t exception,
+				bool enable)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->fmkg_eeer);
+
+	if (enable) {
+		tmp |= exception;
+	} else {
+		tmp &= ~exception;
+	}
+
+	iowrite32be(tmp, &regs->fmkg_eeer);
+}
+
+void fman_kg_get_exception(struct fman_kg_regs *regs,
+				uint32_t *events,
+				uint32_t *scheme_ids,
+				bool clear)
+{
+	uint32_t mask;
+
+	*events = ioread32be(&regs->fmkg_eer);
+	mask = ioread32be(&regs->fmkg_eeer);
+	*events &= mask;
+ 
+	*scheme_ids = 0;
+
+	if (*events & FM_EX_KG_KEYSIZE_OVERFLOW) {
+		*scheme_ids = ioread32be(&regs->fmkg_seer);
+		mask = ioread32be(&regs->fmkg_seeer);
+		*scheme_ids &= mask;
+	}
+
+	if (clear) {
+		iowrite32be(*scheme_ids, &regs->fmkg_seer);
+		iowrite32be(*events, &regs->fmkg_eer);
+	}
+}
+
+void fman_kg_get_capture(struct fman_kg_regs *regs,
+				struct fman_kg_ex_ecc_attr *ecc_attr,
+				bool clear)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->fmkg_serc);
+
+	if (tmp & KG_FMKG_SERC_CAP) {
+		/* Captured data is valid */
+		ecc_attr->valid = TRUE;
+		ecc_attr->double_ecc =
+			(bool)((tmp & KG_FMKG_SERC_CET) ? TRUE : FALSE);
+		ecc_attr->single_ecc_count =
+			(uint8_t)((tmp & KG_FMKG_SERC_CNT_MSK) >>
+					KG_FMKG_SERC_CNT_SHIFT);
+		ecc_attr->addr = (uint16_t)(tmp & KG_FMKG_SERC_ADDR_MSK);
+
+		if (clear)
+			iowrite32be(KG_FMKG_SERC_CAP, &regs->fmkg_serc);
+	} else {
+		/* No ECC error is captured */
+		ecc_attr->valid = FALSE;
+	}
+}
+
+int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
+				struct fman_kg_scheme_regs *scheme_regs)
+{
+	struct fman_kg_extract_params *extract_params;
+	struct fman_kg_gen_extract_params *gen_params;
+	uint32_t tmp_reg, i, select, mask, fqb;
+	uint8_t offset, shift, ht;
+
+	/* Zero out all registers so no need to care about unused ones */
+	memset(scheme_regs, 0, sizeof(struct fman_kg_scheme_regs));
+
+	/* Mode register */
+	tmp_reg = fm_kg_build_nia(params->next_engine,
+			params->next_engine_action);
+	if (tmp_reg == KG_NIA_INVALID) {
+		return -EINVAL;
+	}
+
+	if (params->next_engine == E_FMAN_PCD_PLCR) {
+		tmp_reg |= FMAN_KG_SCH_MODE_NIA_PLCR;
+	}
+	else if (params->next_engine == E_FMAN_PCD_CC) {
+		tmp_reg |= (uint32_t)params->cc_params.base_offset <<
+				FMAN_KG_SCH_MODE_CCOBASE_SHIFT;
+	}
+	
+	tmp_reg |= FMAN_KG_SCH_MODE_EN;
+	scheme_regs->kgse_mode = tmp_reg;
+
+	/* Match vector */
+	scheme_regs->kgse_mv = params->match_vector;
+
+	extract_params = &params->extract_params;
+
+	/* Scheme default values registers */
+	scheme_regs->kgse_dv0 = extract_params->def_scheme_0;
+	scheme_regs->kgse_dv1 = extract_params->def_scheme_1;
+
+	/* Extract Known Fields Command register */
+	scheme_regs->kgse_ekfc = extract_params->known_fields;
+
+	/* Entry Extract Known Default Value register */
+	tmp_reg = 0;
+	tmp_reg |= extract_params->known_fields_def.mac_addr <<
+			FMAN_KG_SCH_DEF_MAC_ADDR_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.vlan_tci <<
+			FMAN_KG_SCH_DEF_VLAN_TCI_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.etype <<
+			FMAN_KG_SCH_DEF_ETYPE_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ppp_sid <<
+			FMAN_KG_SCH_DEF_PPP_SID_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ppp_pid <<
+			FMAN_KG_SCH_DEF_PPP_PID_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.mpls <<
+			FMAN_KG_SCH_DEF_MPLS_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ip_addr <<
+			FMAN_KG_SCH_DEF_IP_ADDR_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ptype <<
+			FMAN_KG_SCH_DEF_PTYPE_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ip_tos_tc <<
+			FMAN_KG_SCH_DEF_IP_TOS_TC_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ipv6_fl <<
+			FMAN_KG_SCH_DEF_IPv6_FL_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.ipsec_spi <<
+			FMAN_KG_SCH_DEF_IPSEC_SPI_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.l4_port <<
+			FMAN_KG_SCH_DEF_L4_PORT_SHIFT;
+	tmp_reg |= extract_params->known_fields_def.tcp_flg <<
+			FMAN_KG_SCH_DEF_TCP_FLG_SHIFT;
+
+	scheme_regs->kgse_ekdv = tmp_reg;
+
+	/* Generic extract registers */
+	if (extract_params->gen_extract_num > FM_KG_NUM_OF_GENERIC_REGS) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < extract_params->gen_extract_num; i++) {
+		gen_params = extract_params->gen_extract + i;
+
+		tmp_reg = FMAN_KG_SCH_GEN_VALID;
+		tmp_reg |= (uint32_t)gen_params->def_val <<
+				FMAN_KG_SCH_GEN_DEF_SHIFT;
+
+		if (gen_params->type == E_FMAN_KG_HASH_EXTRACT) {
+			if ((gen_params->extract > FMAN_KG_SCH_GEN_SIZE_MAX) ||
+					(gen_params->extract == 0)) {
+				return -EINVAL;
+			}
+		} else {
+			tmp_reg |= FMAN_KG_SCH_GEN_OR;
+		}
+
+		tmp_reg |= (uint32_t)gen_params->extract <<
+				FMAN_KG_SCH_GEN_SIZE_SHIFT;
+		tmp_reg |= (uint32_t)gen_params->mask <<
+				FMAN_KG_SCH_GEN_MASK_SHIFT;
+
+		offset = gen_params->offset;
+		ht = get_gen_ht_code(gen_params->src,
+				gen_params->no_validation,
+				&offset);
+		tmp_reg |= (uint32_t)ht << FMAN_KG_SCH_GEN_HT_SHIFT;
+		tmp_reg |= offset;
+
+		scheme_regs->kgse_gec[i] = tmp_reg;
+	}
+
+	/* Masks registers */
+	if (extract_params->masks_num > FM_KG_EXTRACT_MASKS_NUM) {
+		return -EINVAL;
+	}
+
+	select = 0;
+	mask = 0;
+	fqb = 0;
+	for (i = 0; i < extract_params->masks_num; i++) {
+		/* MCSx fields */
+		KG_GET_MASK_SEL_SHIFT(shift, i);
+		if (extract_params->masks[i].is_known) {
+			/* Mask known field */
+			select |= extract_params->masks[i].field_or_gen_idx <<
+					shift;
+		} else {
+			/* Mask generic extract */
+			select |= (extract_params->masks[i].field_or_gen_idx +
+					FM_KG_MASK_SEL_GEN_BASE) << shift;
+		}
+
+		/* MOx fields - spread between se_bmch and se_fqb registers */
+		KG_GET_MASK_OFFSET_SHIFT(shift, i);
+		if (i < 2) {
+			select |= (uint32_t)extract_params->masks[i].offset <<
+					shift;
+		} else {
+			fqb |= (uint32_t)extract_params->masks[i].offset <<
+					shift;
+		}
+
+		/* BMx fields */
+		KG_GET_MASK_SHIFT(shift, i);
+		mask |= (uint32_t)extract_params->masks[i].mask << shift;
+	}
+
+	/* Finish with rest of BMx fileds -
+	 * don't mask bits for unused masks by setting
+	 * corresponding BMx field = 0xFF */
+	for (i = extract_params->masks_num; i < FM_KG_EXTRACT_MASKS_NUM; i++) {
+		KG_GET_MASK_SHIFT(shift, i);
+		mask |= 0xFF << shift;
+	}
+
+	scheme_regs->kgse_bmch = select;
+	scheme_regs->kgse_bmcl = mask;
+
+	/* Finish with FQB register initialization.
+	 * Check fqid is 24-bit value. */
+	if (params->base_fqid & ~0x00FFFFFF) {
+		return -EINVAL;
+	}
+
+	fqb |= params->base_fqid;
+	scheme_regs->kgse_fqb = fqb;
+
+	/* Hash Configuration register */
+	tmp_reg = 0;
+	if (params->hash_params.use_hash) {
+		/* Check hash mask is 24-bit value */
+		if (params->hash_params.mask & ~0x00FFFFFF) {
+			return -EINVAL;
+		}
+
+		/* Hash function produces 64-bit value, 24 bits of that
+		 * are used to generate fq_id and policer profile.
+		 * Thus, maximal shift is 40 bits to allow 24 bits out of 64.
+		 */
+		if (params->hash_params.shift_r > FMAN_KG_SCH_HASH_HSHIFT_MAX) {
+			return -EINVAL;
+		}
+
+		tmp_reg |= params->hash_params.mask;
+		tmp_reg |= (uint32_t)params->hash_params.shift_r <<
+				FMAN_KG_SCH_HASH_HSHIFT_SHIFT;
+
+		if (params->hash_params.sym) {
+			tmp_reg |= FMAN_KG_SCH_HASH_SYM;
+		}
+
+	}
+
+	if (params->bypass_fqid_gen) {
+		tmp_reg |= FMAN_KG_SCH_HASH_NO_FQID_GEN;
+	}
+
+	scheme_regs->kgse_hc = tmp_reg;
+
+	/* Policer Profile register */
+	if (params->policer_params.bypass_pp_gen) {
+		tmp_reg = FMAN_KG_SCH_PP_NO_GEN;
+	} else {
+		/* Lower 8 bits of 24-bits extracted from hash result
+		 * are used for policer profile generation.
+		 * That leaves maximum shift value = 23. */
+		if (params->policer_params.shift > FMAN_KG_SCH_PP_SHIFT_MAX) {
+			return -EINVAL;
+		}
+
+		tmp_reg = params->policer_params.base;
+		tmp_reg |= ((uint32_t)params->policer_params.shift <<
+				FMAN_KG_SCH_PP_SH_SHIFT) &
+				FMAN_KG_SCH_PP_SH_MASK;
+		tmp_reg |= ((uint32_t)params->policer_params.shift <<
+				FMAN_KG_SCH_PP_SL_SHIFT) &
+				FMAN_KG_SCH_PP_SL_MASK;
+		tmp_reg |= (uint32_t)params->policer_params.mask <<
+				FMAN_KG_SCH_PP_MASK_SHIFT;
+	}
+
+	scheme_regs->kgse_ppc = tmp_reg;
+
+	/* Coarse Classification Bit Select register */
+	if (params->next_engine == E_FMAN_PCD_CC) {
+		scheme_regs->kgse_ccbs = params->cc_params.qlcv_bits_sel;
+	}
+
+	/* Packets Counter register */
+	if (params->update_counter) {
+		scheme_regs->kgse_spc = params->counter_value;
+	}
+
+	return 0;
+}
+
+int fman_kg_write_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				struct fman_kg_scheme_regs *scheme_regs,
+				bool update_counter)
+{
+	struct fman_kg_scheme_regs *kgse_regs;
+	uint32_t tmp_reg;
+	int err, i;
+
+	/* Write indirect scheme registers */
+	kgse_regs = (struct fman_kg_scheme_regs *)&(regs->fmkg_indirect[0]);
+
+	iowrite32be(scheme_regs->kgse_mode, &kgse_regs->kgse_mode);
+	iowrite32be(scheme_regs->kgse_ekfc, &kgse_regs->kgse_ekfc);
+	iowrite32be(scheme_regs->kgse_ekdv, &kgse_regs->kgse_ekdv);
+	iowrite32be(scheme_regs->kgse_bmch, &kgse_regs->kgse_bmch);
+	iowrite32be(scheme_regs->kgse_bmcl, &kgse_regs->kgse_bmcl);
+	iowrite32be(scheme_regs->kgse_fqb, &kgse_regs->kgse_fqb);
+	iowrite32be(scheme_regs->kgse_hc, &kgse_regs->kgse_hc);
+	iowrite32be(scheme_regs->kgse_ppc, &kgse_regs->kgse_ppc);
+	iowrite32be(scheme_regs->kgse_spc, &kgse_regs->kgse_spc);
+	iowrite32be(scheme_regs->kgse_dv0, &kgse_regs->kgse_dv0);
+	iowrite32be(scheme_regs->kgse_dv1, &kgse_regs->kgse_dv1);
+	iowrite32be(scheme_regs->kgse_ccbs, &kgse_regs->kgse_ccbs);
+	iowrite32be(scheme_regs->kgse_mv, &kgse_regs->kgse_mv);
+
+	for (i = 0 ; i < FM_KG_NUM_OF_GENERIC_REGS ; i++)
+		iowrite32be(scheme_regs->kgse_gec[i], &kgse_regs->kgse_gec[i]);
+
+	/* Write AR (Action register) */
+	tmp_reg = build_ar_scheme(scheme_id, hwport_id, update_counter, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	return err;
+}
+
+int fman_kg_delete_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id)
+{
+	struct fman_kg_scheme_regs *kgse_regs;
+	uint32_t tmp_reg;
+	int err, i;
+
+	kgse_regs = (struct fman_kg_scheme_regs *)&(regs->fmkg_indirect[0]);
+
+	/* Clear all registers including enable bit in mode register */
+	for (i = 0; i < (sizeof(struct fman_kg_scheme_regs)) / 4; ++i) {
+		iowrite32be(0, ((uint32_t *)kgse_regs + i));
+	}
+
+	/* Write AR (Action register) */
+	tmp_reg = build_ar_scheme(scheme_id, hwport_id, FALSE, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	return err;
+}
+
+int fman_kg_get_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t *counter)
+{
+	struct fman_kg_scheme_regs  *kgse_regs;
+	uint32_t                    tmp_reg;
+	int                         err;
+
+	kgse_regs = (struct fman_kg_scheme_regs *)&(regs->fmkg_indirect[0]);
+ 
+	tmp_reg = build_ar_scheme(scheme_id, hwport_id, TRUE, FALSE);
+    	err = fman_kg_write_ar_wait(regs, tmp_reg);
+
+	if (err != 0)
+		return err;
+
+	*counter = ioread32be(&kgse_regs->kgse_spc);
+
+	return 0;
+}
+
+int fman_kg_set_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t counter)
+{
+	struct fman_kg_scheme_regs *kgse_regs;
+	uint32_t tmp_reg;
+	int err;
+
+	kgse_regs = (struct fman_kg_scheme_regs *)&(regs->fmkg_indirect[0]);
+
+	tmp_reg = build_ar_scheme(scheme_id, hwport_id, TRUE, FALSE);
+
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	if (err != 0)
+		return err;
+ 
+	/* Keygen indirect access memory contains all scheme_id registers
+	 * by now. Change only counter value. */
+	iowrite32be(counter, &kgse_regs->kgse_spc);
+
+	/* Write back scheme registers */
+	tmp_reg = build_ar_scheme(scheme_id, hwport_id, TRUE, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+
+	return err;
+}
+
+uint32_t fman_kg_get_schemes_total_counter(struct fman_kg_regs *regs)
+{
+    return ioread32be(&regs->fmkg_tpc);
+}
+
+int fman_kg_build_cls_plan(struct fman_kg_cls_plan_params *params,
+				struct fman_kg_cp_regs *cls_plan_regs)
+{
+	uint8_t entries_set, entry_bit;
+	int i;
+
+	/* Zero out all group's register */
+	memset(cls_plan_regs, 0, sizeof(struct fman_kg_cp_regs));
+
+	/* Go over all classification entries in params->entries_mask and
+	 * configure the corresponding cpe register */
+	entries_set = params->entries_mask;
+	for (i = 0; entries_set; i++) {
+		entry_bit = (uint8_t)(0x80 >> i);
+		if ((entry_bit & entries_set) == 0)
+			continue;
+		entries_set ^= entry_bit;
+		cls_plan_regs->kgcpe[i] = params->mask_vector[i];
+	}
+
+	return 0;
+}
+
+int fman_kg_write_cls_plan(struct fman_kg_regs *regs,
+				uint8_t grp_id,
+				uint8_t entries_mask,
+				uint8_t hwport_id,
+				struct fman_kg_cp_regs *cls_plan_regs)
+{
+	struct fman_kg_cp_regs *kgcpe_regs;
+	uint32_t tmp_reg;
+	int i, err;
+
+	/* Check group index is valid and the group isn't empty */
+	if (grp_id >= FM_KG_CLS_PLAN_GRPS_NUM)
+		return -EINVAL;
+
+	/* Write indirect classification plan registers */
+	kgcpe_regs = (struct fman_kg_cp_regs *)&(regs->fmkg_indirect[0]);
+
+	for (i = 0; i < FM_KG_NUM_CLS_PLAN_ENTR; i++) {
+		iowrite32be(cls_plan_regs->kgcpe[i], &kgcpe_regs->kgcpe[i]);
+	}
+
+	tmp_reg = build_ar_cls_plan(grp_id, entries_mask, hwport_id, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	return err;
+}
+
+int fman_kg_write_bind_schemes(struct fman_kg_regs *regs,
+				uint8_t hwport_id,
+				uint32_t schemes)
+{
+	struct fman_kg_pe_regs *kg_pe_regs;
+	uint32_t tmp_reg;
+	int err;
+
+	kg_pe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
+
+	iowrite32be(schemes, &kg_pe_regs->fmkg_pe_sp);
+
+	tmp_reg = build_ar_bind_scheme(hwport_id, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	return err;
+}
+
+int fman_kg_build_bind_cls_plans(uint8_t grp_base,
+					uint8_t grp_mask,
+					uint32_t *bind_cls_plans)
+{
+	/* Check grp_base and grp_mask are 5-bits values */
+	if ((grp_base & ~0x0000001F) || (grp_mask & !0x0000001F))
+		return -EINVAL;
+
+	*bind_cls_plans = (uint32_t) ((grp_mask << FMAN_KG_PE_CPP_MASK_SHIFT) | grp_base);
+	return 0;
+}
+
+
+int fman_kg_write_bind_cls_plans(struct fman_kg_regs *regs,
+					uint8_t hwport_id,
+					uint32_t bind_cls_plans)
+{
+	struct fman_kg_pe_regs *kg_pe_regs;
+	uint32_t tmp_reg;
+	int err;
+
+	kg_pe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
+	
+	iowrite32be(bind_cls_plans, &kg_pe_regs->fmkg_pe_cpp);
+
+	tmp_reg = build_ar_bind_cls_plan(hwport_id, TRUE);
+	err = fman_kg_write_ar_wait(regs, tmp_reg);
+	return err;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_prs.c
new file mode 100644
index 0000000..caa1d28
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fman_prs.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fsl_fman_prs.h"
+
+uint32_t fman_prs_get_err_event(struct fman_prs_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->fmpr_perr) & ev_mask;
+}
+
+uint32_t fman_prs_get_err_ev_mask(struct fman_prs_regs *regs)
+{
+	return ioread32be(&regs->fmpr_perer);
+}
+
+void fman_prs_ack_err_event(struct fman_prs_regs *regs, uint32_t event)
+{
+	iowrite32be(event, &regs->fmpr_perr);
+}
+
+uint32_t fman_prs_get_expt_event(struct fman_prs_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->fmpr_pevr) & ev_mask;
+}
+
+uint32_t fman_prs_get_expt_ev_mask(struct fman_prs_regs *regs)
+{
+	return ioread32be(&regs->fmpr_pever);
+}
+
+void fman_prs_ack_expt_event(struct fman_prs_regs *regs, uint32_t event)
+{
+	iowrite32be(event, &regs->fmpr_pevr);
+}
+
+void fman_prs_defconfig(struct fman_prs_cfg *cfg)
+{
+	cfg->port_id_stat = 0;
+	cfg->max_prs_cyc_lim = DEFAULT_MAX_PRS_CYC_LIM;
+	cfg->prs_exceptions = 0x03000000;
+}
+
+int fman_prs_init(struct fman_prs_regs *regs, struct fman_prs_cfg *cfg)
+{
+	uint32_t tmp;
+
+	iowrite32be(cfg->max_prs_cyc_lim, &regs->fmpr_rpclim);
+	iowrite32be((FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS),
+			&regs->fmpr_pevr);
+
+	if (cfg->prs_exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
+		iowrite32be(FM_PCD_PRS_SINGLE_ECC, &regs->fmpr_pever);
+	else
+		iowrite32be(0, &regs->fmpr_pever);
+
+	iowrite32be(FM_PCD_PRS_DOUBLE_ECC, &regs->fmpr_perr);
+
+	tmp = 0;
+	if (cfg->prs_exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
+		tmp |= FM_PCD_PRS_DOUBLE_ECC;
+	iowrite32be(tmp, &regs->fmpr_perer);
+
+	iowrite32be(cfg->port_id_stat, &regs->fmpr_ppsc);
+
+	return 0;
+}
+
+void fman_prs_enable(struct fman_prs_regs *regs)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->fmpr_rpimac) | FM_PCD_PRS_RPIMAC_EN;
+	iowrite32be(tmp, &regs->fmpr_rpimac);
+}
+
+void fman_prs_disable(struct fman_prs_regs *regs)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->fmpr_rpimac) & ~FM_PCD_PRS_RPIMAC_EN;
+	iowrite32be(tmp, &regs->fmpr_rpimac);
+}
+
+void fman_prs_set_stst_port_msk(struct fman_prs_regs *regs, uint32_t pid_msk)
+{
+	iowrite32be(pid_msk, &regs->fmpr_ppsc);
+}
+
+void fman_prs_set_stst(struct fman_prs_regs *regs, bool enable)
+{
+	if (enable)
+		iowrite32be(FM_PCD_PRS_PPSC_ALL_PORTS, &regs->fmpr_ppsc);
+	else
+		iowrite32be(0, &regs->fmpr_ppsc);
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 556e205..ef41c2b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -167,7 +167,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
         if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
@@ -521,7 +521,6 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
             if (p_BufPoolDepletion->pfcPrioritiesEn[i] == TRUE)
             {
                 vector |= 0x00008000 >> i;
-                break;
             }
         }
         tmpReg |= vector;
@@ -1755,6 +1754,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
                 tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
         }
+
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd) &&
             (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
@@ -1764,6 +1764,16 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                 tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
         }
 
+#ifdef FM_CAPWAP_SUPPORT
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
+                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_LITE))
+        {
+           /* link to sw parser code for udp lite - only if no other code is applied. */
+            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_USER_DEFINED_L4)
+            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
+        }
+#endif /* FM_CAPWAP_SUPPORT */
         for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
             /* For all header set LCV as taken from netEnv*/
@@ -2377,6 +2387,19 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     /* calculate global portId number */
     SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
 
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
+    {
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
+            (p_FmPortParams->portId != FM_OH_PORT_ID))
+            DBG(WARNING,
+                ("Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC.",
+                 FM_OH_PORT_ID));
+
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+            (p_FmPortParams->portId == FM_OH_PORT_ID))
+            DBG(WARNING, ("Use non-zero portId for OP port due to insufficient resources on portId 0."));
+    }
+
     /* Initialize FM port parameters for initialization phase only */
     p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
     /* set memory map pointers */
@@ -2414,12 +2437,26 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
-        p_FmPort->fifoBufs.num                                      = 0;
-        p_FmPort->fifoBufs.extra                                    = 0;
-        p_FmPort->openDmas.num                                      = 0;
-        p_FmPort->openDmas.extra                                    = 0;
-        p_FmPort->tasks.num                                         = 0;
-        p_FmPort->tasks.extra                                       = 0;
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
+            (p_FmPortParams->portId != FM_OH_PORT_ID))
+        {
+            /* Overwrite HC defaults */
+            p_FmPort->fifoBufs.num      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+            p_FmPort->fifoBufs.extra    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
+            p_FmPort->openDmas.num      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
+            p_FmPort->openDmas.extra    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+            p_FmPort->tasks.num         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+            p_FmPort->tasks.extra       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+        }
+        else
+        {
+            p_FmPort->fifoBufs.num                                      = 0;
+            p_FmPort->fifoBufs.extra                                    = 0;
+            p_FmPort->openDmas.num                                      = 0;
+            p_FmPort->openDmas.extra                                    = 0;
+            p_FmPort->tasks.num                                         = 0;
+            p_FmPort->tasks.extra                                       = 0;
+        }
     }
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
@@ -2464,6 +2501,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     case (e_FM_PORT_TYPE_TX):
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
+#ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
+        tmpReg = 0x00001013;
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp, tmpReg);
+#endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
     case (e_FM_PORT_TYPE_TX_10G):
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
         if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
@@ -2518,6 +2559,12 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
         p_FmPort->fifoDeqPipelineDepth =
             (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
+            (p_FmPortParams->portId != FM_OH_PORT_ID))
+        {
+            /* Overwrite HC defaults */
+            p_FmPort->fifoDeqPipelineDepth = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+        }
     }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
@@ -2638,14 +2685,14 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
                                    &p_FmPort->internalBufferOffset);
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-#ifdef FM_BCB_ERRATA_BMI_SW001
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
     if ((p_FmPort->p_FmPortDriverParam->bcbWorkaround) &&
            (p_FmPort->portType == e_FM_PORT_TYPE_RX))
     {
         p_FmPort->p_FmPortDriverParam->errorsToDiscard |= FM_PORT_FRM_ERR_PHYSICAL;
         p_FmPort->fifoBufs.num += 4*KILOBYTE;
     }
-#endif /* FM_BCB_ERRATA_BMI_SW001 */
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
 
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
@@ -3201,7 +3248,7 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
     return E_OK;
 }
 
-#ifdef FM_BCB_ERRATA_BMI_SW001
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
 t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -3213,7 +3260,7 @@ t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort)
 
     return E_OK;
 }
-#endif /* FM_BCB_ERRATA_BMI_SW001 */
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
 
 /****************************************************/
 /*       Hidden-DEBUG Only API                      */
@@ -3486,7 +3533,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                 /* port is disabled */
                 return E_OK;
             else
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Inconsistency: Port's QMI is enabled but BMI disabled"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistency: Port's QMI is enabled but BMI disabled"));
         }
         /* port is disabled */
         return E_OK;
@@ -3506,7 +3553,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         {
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! QMI busy", p_FmPort->name));
+            RETURN_ERROR(MAJOR, E_BUSY, ("%s: can't disable! QMI busy", p_FmPort->name));
         }
     }
 
@@ -3528,7 +3575,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
         WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
 
-        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! BMI Busy", p_FmPort->name));
+        RETURN_ERROR(MAJOR, E_BUSY, ("%s: can't disable! BMI Busy", p_FmPort->name));
     }
 
     p_FmPort->enabled = 0;
@@ -3573,7 +3620,7 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
                 /* port is enabled */
                 return E_OK;
             else
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Inconsistency: Port's BMI is enabled but QMI disabled"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistency: Port's BMI is enabled but QMI disabled"));
         }
         /* port is enabled */
         return E_OK;
@@ -3911,7 +3958,7 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
     {
-        XX_Print ("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num);
+        XX_Print("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num);
         failed = TRUE;
     }
     if (failed)
@@ -3951,7 +3998,7 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
         if (!savedParams.dmaCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
             savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal+2);
         if (!savedParams.fifoCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
-            savedParams.fifoCompVal = currParams.fifoCompVal+2;
+            savedParams.fifoCompVal = currParams.fifoCompVal+(2*BMI_FIFO_UNITS);
     }
 
     XX_Print("best vals: tasks %d, dmas %d, fifos %d\n",
@@ -4071,9 +4118,10 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     {
         case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
         case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
                 return 0;
@@ -4123,7 +4171,6 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     }
     else /* QMI counter */
     {
-
         /* check that counters are enabled */
         if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
         {
@@ -4807,13 +4854,14 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
             }
 
+            /* No user-tree, need to build internal tree */
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
             if (!p_FmPcdCcTreeParams)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
-            /* No user-tree, need to build internal tree */
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));  
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
             p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
+
             if (!p_FmPort->h_IpReassemblyTree)
             {
                 RELEASE_LOCK(p_FmPort->lock);
@@ -4828,7 +4876,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
             fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
-
             XX_Free(p_FmPcdCcTreeParams);
         }
 
@@ -5565,7 +5612,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 #if (DPAA_VERSION >= 11)
         for (j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
             if (p_CongestionGrps->pfcPrioritiesEn[i][j])
-                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
+                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j-1));
 #endif /* (DPAA_VERSION >= 11) */
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index c455131..5c01851 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -166,19 +166,25 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_PORT_MAX_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS 256
 #define FM_PORT_CG_REG_NUM(_cgId) (((FM_PORT_NUM_OF_CONGESTION_GRPS/32)-1)-_cgId/32)
 
+#define FM_OH_PORT_ID                               0
+
 /***********************************************************************/
 /*          SW parser IP-fragmentation labels (offsets)                */
 /***********************************************************************/
 #if (DPAA_VERSION == 10)
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
 #define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
+#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
 #else
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
 #define IP_FRAG_SW_PATCH_IPv4_SIZE              0x046
+#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
 #endif /* (DPAA_VERSION == 10) */
 #define IP_FRAG_SW_PATCH_IPv6_LABEL             \
     (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
 
+#ifdef FM_CAPWAP_SUPPORT
+#define UDP_LITE_SW_PATCH_LABEL                 0x2E0
+#endif /* FM_CAPWAP_SUPPORT */
+
 /**************************************************************************//**
  @Description       Memory Mapped Registers
 *//***************************************************************************/
@@ -525,17 +531,11 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW       | \
                                                  FM_PORT_FRM_ERR_IPRE)
 
-#ifdef FM_DISABLE_SEC_ERRORS
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_NON_FM                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 
-#else
-#define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
-                                                 FM_PORT_FRM_ERR_LENGTH                 | \
-                                                 FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
-#endif /* FM_DISABLE_SEC_ERRORS */
 
 #define BMI_RX_FIFO_PRI_ELEVATION_MASK          0x03FF0000
 #define BMI_RX_FIFO_THRESHOLD_MASK              0x000003FF
@@ -812,9 +812,9 @@ typedef struct {
     bool                                noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
 
-#ifdef FM_BCB_ERRATA_BMI_SW001
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
     bool                                bcbWorkaround;
-#endif /* FM_BCB_ERRATA_BMI_SW001 */
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
 } t_FmPortDriverParam;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 25eecd1..bf358a5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -324,7 +324,10 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
-        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        p_FmPort->im.p_BdRing =
+            (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize),
+                                       p_FmPort->im.fwExtStructsMemId,
+                                       4);
         if (!p_FmPort->im.p_BdRing)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD ring!!!"));
         IOMemSet32(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 24fd395..10601ec 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -64,6 +64,16 @@ static void IpcMsgCompletionCB(t_Handle   h_Fm,
     blockingFlag = FALSE;
 }
 
+static void FreeInitResources(t_Fm *p_Fm)
+{
+    if (p_Fm->camBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
+    if (p_Fm->fifoBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->fifoBaseAddr));
+    if (p_Fm->resAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->resAddr));
+}
+
 static bool IsFmanCtrlCodeLoaded(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram;
@@ -81,7 +91,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 #if (DPAA_VERSION < 11)
     if (!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
-#endif
+#endif /* (DPAA_VERSION < 11) */
     if (p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
     if (!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
@@ -105,7 +115,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
     if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
-#endif
+#endif /* (DPAA_VERSION < 11) */
 #if (DPAA_VERSION >= 11)
     if ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||
             (p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM) ||
@@ -116,11 +126,12 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("emergencyBusSelect value not supported by this integration."));
     if (p_Fm->p_FmDriverParam->dmaStopOnBusError)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaStopOnBusError not supported by this integration."));
-    /* TODO - workaround for simulator not supporting reset values, uncomment! */
-    /*if (p_Fm->p_FmDriverParam->dmaAidMode)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAidMode not supported by this integration."));
+#ifdef FM_AID_MODE_NO_TNUM_SW005
+    if (p_Fm->p_FmDriverParam->dmaAidMode != e_FM_DMA_AID_OUT_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAidMode not supported by this integration."));
+#endif /* FM_AID_MODE_NO_TNUM_SW005 */
     if (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAxiDbgNumOfBeats not supported by this integration."));*/
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAxiDbgNumOfBeats not supported by this integration."));
 #endif /* (DPAA_VERSION >= 11) */
 
     if (!p_Fm->p_FmStateStruct->fmClkFreq)
@@ -459,16 +470,6 @@ static void EnableTimeStamp(t_Fm *p_Fm)
     p_Fm->p_FmStateStruct->enabledTimeStamp = TRUE;
 }
 
-static void FreeInitResources(t_Fm *p_Fm)
-{
-    if (p_Fm->camBaseAddr)
-       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
-    if (p_Fm->fifoBaseAddr)
-       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->fifoBaseAddr));
-    if (p_Fm->resAddr)
-       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->resAddr));
-}
-
 static t_Error ClearIRam(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram;
@@ -546,6 +547,65 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
     return E_OK;
 }
 
+#ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+    uint32_t        tmpReg;
+
+    /* write to IRAM first location the debug instruction */
+    WRITE_UINT32(p_Iram->iadd, 0);
+    while (GET_UINT32(p_Iram->iadd) != 0) ;
+    WRITE_UINT32(p_Iram->idata, FM_FW_DEBUG_INSTRUCTION);
+
+    WRITE_UINT32(p_Iram->iadd, 0);
+    while (GET_UINT32(p_Iram->iadd) != 0) ;
+    while (GET_UINT32(p_Iram->idata) != FM_FW_DEBUG_INSTRUCTION) ;
+
+    /* Enable patch from IRAM */
+    WRITE_UINT32(p_Iram->iready, IRAM_READY);
+    CORE_MemoryBarrier();
+    XX_UDelay(100);
+
+    /* reset FMAN */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
+    CORE_MemoryBarrier();
+    XX_UDelay(100);
+
+    /* verify breakpoint debug status register */
+    tmpReg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
+    if (!tmpReg)
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid debug status register value is '0'"));
+
+    /*************************************/
+    /* Load FMan-Controller code to IRAM */
+    /*************************************/
+    if (ClearIRam(p_Fm) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+        (LoadFmanCtrlCode(p_Fm) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    XX_UDelay(100);
+
+    /* reset FMAN again to start the microcode */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
+    CORE_MemoryBarrier();
+    XX_UDelay(100);
+
+    if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+        /* clear tmpReg event bits in order not to clear standing events */
+        tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
+        CORE_MemoryBarrier();
+        XX_UDelay(100);
+    }
+
+    return E_OK;
+}
+#endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
+
 static void GuestErrorIsr(t_Fm *p_Fm, uint32_t pending)
 {
 #define FM_G_CALL_1G_MAC_ERR_ISR(_id)   \
@@ -889,7 +949,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             ipcOutInitParams.numOfOpenDmas = initParams.numOfOpenDmas;
             ipcOutInitParams.numOfExtraOpenDmas = initParams.numOfExtraOpenDmas;
             memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcOutInitParams, sizeof(ipcOutInitParams));
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcPhysAddr);
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcPortOutInitParams);
             break;
         }
         case (FM_SET_SIZE_OF_FIFO):
@@ -902,7 +962,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                                                           &ipcPortRsrcParams.val,
                                                           &ipcPortRsrcParams.extra,
                                                           (bool)ipcPortRsrcParams.boolInitialConfig);
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            *p_ReplyLength = sizeof(uint32_t);
             break;
         }
         case (FM_SET_NUM_OF_TASKS):
@@ -1262,24 +1322,24 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
 
     if (p_Fm->guestId == NCSW_MASTER_ID)
     {
-        uint32_t      *p_Cpg = (uint32_t*)p_Fm->baseAddr+FM_MM_CGP;
+        uint32_t      *p_Cpg = (uint32_t*)(p_Fm->baseAddr+FM_MM_CGP);
         uint32_t      tmpReg;
         uint32_t      reg_num;
         uint32_t      offset;
 
         ASSERT_COND(p_Fm->baseAddr);
         reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
-        offset  = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))%4;
+        offset  = (congestionGroupId%4);
 
         tmpReg = GET_UINT32(p_Cpg[reg_num]);
 
         if (priorityBitMap)//adding priority
         {
-            if (tmpReg & (0xFF<<(28-(offset*8))))
+            if (tmpReg & (0xFF<<(offset*8)))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE,
                              ("PFC priority for the congestion group is already set!"));
         }
-        tmpReg |= (uint32_t)priorityBitMap << (28-(offset*8));
+        tmpReg |= (uint32_t)priorityBitMap << (offset*8);
             WRITE_UINT32(p_Cpg[reg_num], tmpReg);
     }
 
@@ -1949,7 +2009,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(p_PortParams->fmMuramPhysBaseAddr)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcPortOutInitParams)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         memcpy((uint8_t*)&portOutParams, reply.replyBody, sizeof(t_FmIpcPortOutInitParams));
 
@@ -3483,6 +3543,8 @@ static t_Error InitFmDma(t_Fm *p_Fm)
     }
     tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
     tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
+    tmpReg |= DMA_MODE_SECURE_PROT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
 
 #if (DPAA_VERSION >= 11)
     if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
@@ -3493,8 +3555,6 @@ static t_Error InitFmDma(t_Fm *p_Fm)
     if (p_FmDriverParam->dmaStopOnBusError)
         tmpReg |= DMA_MODE_SBER;
     tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
-    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
-    tmpReg |= DMA_MODE_SECURE_PROT;
 #ifdef FM_PEDANTIC_DMA
     tmpReg |= DMA_MODE_EMERGENCY_READ;
 #endif /* FM_PEDANTIC_DMA */
@@ -3503,7 +3563,8 @@ static t_Error InitFmDma(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
 
     /* configure thresholds register */
-    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
+    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
+    tmpReg |= ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
               ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
               ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
@@ -4039,7 +4100,14 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
     /* Chip dependent, will be configured in Init */
 
+    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
+    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
+#ifdef FM_AID_MODE_NO_TNUM_SW005
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        p_Fm->p_FmDriverParam->dmaAidMode                       = e_FM_DMA_AID_OUT_PORT_ID;
+#endif /* FM_AID_MODE_NO_TNUM_SW005 */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
+
     if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
@@ -4051,13 +4119,10 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
         p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
         p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
-        //p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
         p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
         p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
-        p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
         p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
         p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
-        p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
         p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
         p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
         p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
@@ -4082,6 +4147,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmStateStruct->totalFifoSize =
             (((tmpReg & BMI_TOTAL_FIFO_SIZE_MASK) >> BMI_CFG1_FIFO_SIZE_SHIFT) + 1) * BMI_FIFO_UNITS;
 
+#ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
+        tmpReg = 0x007B0000;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+#endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
+
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2);
         p_Fm->p_FmStateStruct->totalNumOfTasks =
             (uint8_t)(((tmpReg & BMI_TOTAL_NUM_OF_TASKS_MASK) >> BMI_CFG2_TASKS_SHIFT) + 1);
@@ -4097,7 +4167,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
         p_Fm->p_FmDriverParam->dmaCacheOverride                     = (e_FmDmaCacheOverride)((tmpReg & DMA_MODE_CACHE_OR_MASK) >> DMA_MODE_CACHE_OR_SHIFT);
         p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = (uint8_t)((((tmpReg & DMA_MODE_CEN_MASK) >> DMA_MODE_CEN_SHIFT) +1)*DMA_CAM_UNITS);
-        p_Fm->p_FmDriverParam->dmaAidOverride                       = (bool)((tmpReg & DMA_MODE_AID_OR)? TRUE:FALSE);
         p_Fm->p_FmDriverParam->dmaDbgCntMode                        = (e_FmDmaDbgCntMode)((tmpReg & DMA_MODE_DBG_MASK) >> DMA_MODE_DBG_SHIFT);
         p_Fm->p_FmDriverParam->dmaEnEmergency                       = (bool)((tmpReg & DMA_MODE_EB)? TRUE : FALSE);
 
@@ -4196,55 +4265,8 @@ t_Error FM_Init(t_Handle h_Fm)
 #ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
     if (p_FmDriverParam->resetOnInit)
     {
-        t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
-        uint32_t        tmpReg;
-
-        /* write to IRAM first location the debug instruction */
-        WRITE_UINT32(p_Iram->iadd, 0);
-        while (GET_UINT32(p_Iram->iadd) != 0) ;
-        WRITE_UINT32(p_Iram->idata, FM_UCODE_DEBUG_INSTRUCTION);
-
-        WRITE_UINT32(p_Iram->iadd, 0);
-        while (GET_UINT32(p_Iram->iadd) != 0) ;
-        while (GET_UINT32(p_Iram->idata) != FM_UCODE_DEBUG_INSTRUCTION) ;
-
-        /* Enable patch from IRAM */
-        WRITE_UINT32(p_Iram->iready, IRAM_READY);
-        XX_UDelay(100);
-
-        /* reset FMAN */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
-        XX_UDelay(100);
-
-        /* verify breakpoint debug status register */
-        tmpReg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
-        if (!tmpReg)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid debug status register value is '0'"));
-
-        /*************************************/
-        /* Load FMan-Controller code to IRAM */
-        /*************************************/
-        if (ClearIRam(p_Fm) != E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-        if (p_Fm->p_FmDriverParam->firmware.p_Code &&
-            (LoadFmanCtrlCode(p_Fm) != E_OK))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-         XX_UDelay(100);
-
-        /* reset FMAN again to start the microcode */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
-        CORE_MemoryBarrier();
-        XX_UDelay(100);
-
-        if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
-        {
-            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-            /* clear tmpReg event bits in order not to clear standing events */
-            tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
-            CORE_MemoryBarrier();
-            XX_UDelay(100);
-        }
+        if ((err = FwNotResetErratumBugzilla6173WA(p_Fm)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     else
     {
@@ -4454,15 +4476,6 @@ t_Error FM_Free(t_Handle h_Fm)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, 0);
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, 0);
 
-    /* release BMI resources */
-#ifndef CONFIG_KEXEC
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0);
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, 0);
-#endif
-
-    /* disable ECC */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, 0);
-
     if ((p_Fm->guestId == NCSW_MASTER_ID) && (p_Fm->fmModuleName[0] != 0))
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
@@ -4643,6 +4656,7 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
+
     p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
     memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
 
@@ -4887,6 +4901,16 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
     return E_OK;
 }
 
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+UNUSED(p_Fm);
+
+    return E_OK;
+}
 
 /****************************************************/
 /*       API Run-time Control uint functions        */
@@ -5866,18 +5890,13 @@ t_Error FM_CtrlMonStart(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm *)h_Fm;
     t_FmTrbRegs     *p_MonRegs;
-    uint8_t         fmCtrlNum, i;
+    uint8_t         i;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
-        fmCtrlNum = 2;
-    else
-        fmCtrlNum = 4;
-
-    for (i = 0; i < fmCtrlNum; i++)
+    for (i = 0; i < FM_NUM_OF_CTRL; i++)
     {
         p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(i));
 
@@ -5885,7 +5904,8 @@ t_Error FM_CtrlMonStart(t_Handle h_Fm)
         WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_RESET);
         WRITE_UINT32(p_MonRegs->tcrl, TRB_TCRL_RESET);
 
-        /* Configure counter #1 to count all stalls of FM Controller */
+        /* Configure: counter #1 counts all stalls in risc - ldsched stall
+                      counter #2 counts all stalls in risc - other stall*/
         WRITE_UINT32(p_MonRegs->tcrl, TRB_TCRL_RESET | TRB_TCRL_UTIL);
 
         /* Enable monitoring */
@@ -5899,18 +5919,13 @@ t_Error FM_CtrlMonStop(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm *)h_Fm;
     t_FmTrbRegs     *p_MonRegs;
-    uint8_t         fmCtrlNum, i;
+    uint8_t         i;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
-        fmCtrlNum = 2;
-    else
-        fmCtrlNum = 4;
-
-    for (i = 0; i < fmCtrlNum; i++)
+    for (i = 0; i < FM_NUM_OF_CTRL; i++)
     {
         p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(i));
         WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_DISABLE_COUNTERS);
@@ -5923,20 +5938,14 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
 {
     t_Fm            *p_Fm = (t_Fm *)h_Fm;
     t_FmTrbRegs     *p_MonRegs;
-    uint64_t        clkCnt, monValue;
-    uint8_t         fmCtrlNum;
+    uint64_t        clkCnt, utilValue, effValue;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
     SANITY_CHECK_RETURN_ERROR(p_Mon, E_NULL_POINTER);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
-        fmCtrlNum = 2;
-    else
-        fmCtrlNum = 4;
-
-    if (fmCtrlIndex >= fmCtrlNum)
+    if (fmCtrlIndex >= FM_NUM_OF_CTRL)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM Controller index"));
 
     p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(fmCtrlIndex));
@@ -5944,10 +5953,17 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
     clkCnt = (uint64_t)
             ((uint64_t)GET_UINT32(p_MonRegs->tpcch) << 32 | GET_UINT32(p_MonRegs->tpccl));
 
-    monValue = (uint64_t)
+    utilValue = (uint64_t)
             ((uint64_t)GET_UINT32(p_MonRegs->tpc1h) << 32 | GET_UINT32(p_MonRegs->tpc1l));
 
-    p_Mon->percentCnt[0] = (uint8_t)((clkCnt - monValue) * 100 / clkCnt);
+    effValue = (uint64_t)
+            ((uint64_t)GET_UINT32(p_MonRegs->tpc2h) << 32 | GET_UINT32(p_MonRegs->tpc2l));
+
+    p_Mon->percentCnt[0] = (uint8_t)((clkCnt - utilValue) * 100 / clkCnt);
+    if (clkCnt != utilValue)
+        p_Mon->percentCnt[1] = (uint8_t)(((clkCnt - utilValue) - effValue) * 100 / (clkCnt - utilValue));
+    else
+        p_Mon->percentCnt[1] = 0;
 
     return E_OK;
 }
@@ -5956,7 +5972,7 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
 t_Error FM_DumpRegs(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm *)h_Fm;
-    uint8_t         i = 0;
+    uint8_t         i,j = 0;
 
     DECLARE_DUMP;
 
@@ -6000,14 +6016,21 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext1);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext2);
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_drd, ("fmfp_drd"));
-    DUMP_SUBSTRUCT_ARRAY(i, 16)
+    DUMP_SUBTITLE(("\n"));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dra, 0);
+    CORE_MemoryBarrier();
+    for (j=0; j<128; j++)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_drd[i], sizeof(uint32_t));
+        DUMP_TITLE(j, ("fmfp_dra"));
+        DUMP_SUBSTRUCT_ARRAY(i, 4)
+        {
+            DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_drd[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(j, ("fmfp_ts"));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ts[j], sizeof(uint32_t));
     }
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dra);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rstc);
@@ -6027,7 +6050,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
         DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[i], sizeof(uint32_t));
     }
 
-
     DUMP_TITLE(p_Fm->p_FmDmaRegs, ("FM-DMA Regs"));
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmemsr);
@@ -6064,7 +6086,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
         DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_arb[i], sizeof(uint32_t));
     }
 
-
     DUMP_TITLE(p_Fm->p_FmQmiRegs, ("FM-QMI COMMON Regs"));
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index c6c3df2..4f3ad00 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -171,9 +171,11 @@ switch (exception){                                         \
                                             FM_EX_QMI_SINGLE_ECC)
 
 
-#define DEFAULT_totalFifoSize(major)       (((major == 2) || (major == 5))  ?   \
-                                            (100*KILOBYTE):((major == 6) ?      \
-                                            (288*KILOBYTE):((major == 4) ? (46*KILOBYTE):(122*KILOBYTE))))
+#define DEFAULT_totalFifoSize(major)                    \
+    (((major == 2) || (major == 5)) ?                   \
+     (100*KILOBYTE) : ((major == 6) ?                   \
+                       (288*KILOBYTE) : ((major == 4) ? \
+                                         (46*KILOBYTE) : (122*KILOBYTE))))
 
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
@@ -312,7 +314,8 @@ typedef _Packed struct
     volatile uint32_t   fmfp_extc;      /**< FPM External Requests Control */
     volatile uint32_t   fmfp_ext1;      /**< FPM External Requests Config1 */
     volatile uint32_t   fmfp_ext2;      /**< FPM External Requests Config2 */
-    volatile uint32_t   fmfp_drd[16];   /**< FPM Data_Ram Data 0-15 */
+    volatile uint32_t   fmfp_drd[4];    /**< FPM Data_Ram Data 0-3 */
+    volatile uint8_t    res3[48];       /**< reserved */
     volatile uint32_t   fmfp_dra;       /**< FPM Data Ram Access */
     volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
     volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
@@ -324,7 +327,7 @@ typedef _Packed struct
     volatile uint32_t   fmfp_cev[4];    /**< FPM CPU Event 1-4 */
     volatile uint8_t    res4[16];       /**< reserved */
     volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
-    volatile uint8_t    reserved1[0x260];
+    volatile uint8_t    reserved1[0x200];
     volatile uint32_t   fmfp_ts[128];     /**< 0x400: FPM Task Status */
 } _PackedType t_FmFpmRegs;
 
@@ -476,7 +479,7 @@ typedef _Packed struct t_FmTrbRegs
  @Description       General defines
 *//***************************************************************************/
 #define FM_DEBUG_STATUS_REGISTER_OFFSET     0x000d1084UL
-#define FM_UCODE_DEBUG_INSTRUCTION          0x6ffff805UL
+#define FM_FW_DEBUG_INSTRUCTION             0x6ffff805UL
 
 /**************************************************************************//**
  @Description       DMA definitions
@@ -495,7 +498,6 @@ typedef _Packed struct t_FmTrbRegs
 #define DMA_MODE_CEN_MASK                   0x0000E000
 #define DMA_MODE_DBG_MASK                   0x00000380
 
-
 #define DMA_TRANSFER_PORTID_MASK            0xFF000000
 #define DMA_TRANSFER_TNUM_MASK              0x00FF0000
 #define DMA_TRANSFER_LIODN_MASK             0x00000FFF
@@ -515,15 +517,13 @@ typedef _Packed struct t_FmTrbRegs
 #define DMA_STATUS_FM_SPDAT_ECC             0x00080000
 
 #define DMA_STATUS_FM_ECC                   (DMA_STATUS_READ_ECC |          \
-                                            DMA_STATUS_SYSTEM_WRITE_ECC |   \
-                                            DMA_STATUS_FM_WRITE_ECC |       \
-                                            DMA_STATUS_SYSTEM_DPEXT_ECC |   \
-                                            DMA_STATUS_FM_DPEXT_ECC |       \
-                                            DMA_STATUS_SYSTEM_DPDAT_ECC |   \
-                                            DMA_STATUS_FM_DPDAT_ECC |       \
-                                            DMA_STATUS_FM_SPDAT_ECC)
-
-
+                                             DMA_STATUS_SYSTEM_WRITE_ECC |  \
+                                             DMA_STATUS_FM_WRITE_ECC |      \
+                                             DMA_STATUS_SYSTEM_DPEXT_ECC |  \
+                                             DMA_STATUS_FM_DPEXT_ECC |      \
+                                             DMA_STATUS_SYSTEM_DPDAT_ECC |  \
+                                             DMA_STATUS_FM_DPDAT_ECC |      \
+                                             DMA_STATUS_FM_SPDAT_ECC)
 
 #define FM_LIODN_BASE_MASK                  0x00000FFF
 
@@ -732,7 +732,7 @@ typedef _Packed struct t_FmTrbRegs
 #define TRB_TCRH_ENABLE_COUNTERS    0x84008000
 #define TRB_TCRH_DISABLE_COUNTERS   0x8400C000
 #define TRB_TCRL_RESET              0x20000000
-#define TRB_TCRL_UTIL               0x00000400
+#define TRB_TCRL_UTIL               0x00000460
 
 typedef struct {
     void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 12c7098..6476c7a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -145,28 +145,6 @@ typedef _Packed struct t_FmPcdPlcrProfileRegs {
     volatile uint32_t fmpl_res1[12];    /* 0x0D0-0x0FF Reserved */
 } _PackedType t_FmPcdPlcrProfileRegs;
 
-/**************************************************************************//**
- @Description   PCD KG scheme registers
-*//***************************************************************************/
-typedef _Packed struct t_FmPcdKgSchemeRegs {
-    volatile uint32_t kgse_mode;    /**< MODE */
-    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
-    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
-    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
-    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
-    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
-    volatile uint32_t kgse_hc;      /**< Hash Command */
-    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
-    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                   /**< Generic Extract Command */
-    volatile uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
-    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
-    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
-    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
-    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
-    volatile uint32_t kgse_om;      /**< KeyGen Scheme Entry Operation Mode bits */
-    volatile uint32_t kgse_vsp;     /**< KeyGen Scheme Entry Virtual Storage Profile */
-} _PackedType t_FmPcdKgSchemeRegs;
 
 typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
     volatile uint32_t                       portIdAndCapwapReassmTbl;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index eb1a183..db2d60b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -36,7 +36,7 @@
 
 #include "std_ext.h"
 #include "error_ext.h"
-
+#include "fsl_fman_kg.h"
 
 #define __ERR_MODULE__  MODULE_FM_PCD
 
@@ -57,10 +57,10 @@ t_Error     FmHcDumpRegs(t_Handle h_FmHc);
 
 void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
-t_Error     FmHcPcdKgSetScheme(t_Handle             h_FmHc,
-                               t_Handle             h_Scheme,
-                               t_FmPcdKgSchemeRegs  *p_SchemeRegs,
-                               bool                 updateCounter);
+t_Error     FmHcPcdKgSetScheme(t_Handle                   h_FmHc,
+                               t_Handle                   h_Scheme,
+                               struct fman_kg_scheme_regs *p_SchemeRegs,
+                               bool                       updateCounter);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index 77f91d2..c20a6eb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -106,7 +106,7 @@ typedef enum e_DpaaFDFormatType {
 #define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))     /**< Macro to get FD OFFSET field */
 #define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                  /**< Macro to get FD LENGTH field */
 #define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                          /**< Macro to get FD STATUS field */
-#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))                          /**< TODO */
+#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))                          /**< Macro to get FD ADDR (virtual) */
 
 #define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | (((val) << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
                                                                                                         /**< Macro to set FD PID field or LIODN offset*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 195e2d4..6acf50b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -112,7 +112,7 @@ typedef _Packed struct t_FmPrsResult {
     volatile uint8_t     l4r;                /**< Layer 4 result */
     volatile uint8_t     cplan;              /**< Classification plan id */
     volatile uint16_t    nxthdr;             /**< Next Header  */
-    volatile uint16_t    cksum;              /**< running-sum */
+    volatile uint16_t    cksum;              /**< Running-sum */
     volatile uint16_t    flags_frag_off;     /**< Flags & fragment-offset field of the last IP-header */
     volatile uint8_t     route_type;         /**< Routing type field of a IPv6 routing extension header */
     volatile uint8_t     rhp_ip_valid;       /**< Routing Extension Header Present; last bit is IP valid */
@@ -457,7 +457,7 @@ typedef struct t_FmBufPoolDepletion {
 } t_FmBufPoolDepletion;
 
 /**************************************************************************//**
- @Description   A structure for defining Ucode patch for loading.
+ @Description   A Structure for defining Ucode patch for loading.
 *//***************************************************************************/
 typedef struct t_FmFirmwareParams {
     uint32_t                size;                   /**< Size of uCode */
@@ -806,6 +806,17 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
 
 /**************************************************************************//**
+ @Function      FM_ConfigEnableCounters
+
+ @Description   Obsolete, always return E_OK.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
+
+/**************************************************************************//**
  @Function      FM_ConfigDmaDbgCounter
 
  @Description   Define DMA debug counter.
@@ -1261,7 +1272,7 @@ typedef enum e_FmCounters {
 } e_FmCounters;
 
 /**************************************************************************//**
- @Description   A structure for returning FM revision information
+ @Description   A Structure for returning FM revision information
 *//***************************************************************************/
 typedef struct t_FmRevisionInfo {
     uint8_t         majorRev;               /**< Major revision */
@@ -1269,7 +1280,7 @@ typedef struct t_FmRevisionInfo {
 } t_FmRevisionInfo;
 
 /**************************************************************************//**
- @Description   A structure for returning FM ctrl code revision information
+ @Description   A Structure for returning FM ctrl code revision information
 *//***************************************************************************/
 typedef struct t_FmCtrlCodeRevisionInfo {
     uint16_t        packageRev;             /**< Package revision */
@@ -1278,7 +1289,7 @@ typedef struct t_FmCtrlCodeRevisionInfo {
 } t_FmCtrlCodeRevisionInfo;
 
 /**************************************************************************//**
- @Description   A structure for defining DMA status
+ @Description   A Structure for defining DMA status
 *//***************************************************************************/
 typedef struct t_FmDmaStatus {
     bool    cmqNotEmpty;            /**< Command queue is not empty */
@@ -1293,7 +1304,7 @@ typedef struct t_FmDmaStatus {
  @Description   A Structure for obtaining FM controller monitor values
 *//***************************************************************************/
 typedef struct t_FmCtrlMon {
-    uint8_t percentCnt[1];          /**< Percentage value */
+    uint8_t percentCnt[2];          /**< Percentage value */
 } t_FmCtrlMon;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index f18d497..614622e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -169,6 +169,8 @@ typedef struct t_FmMacStatistics {
 /* MIB II */
     uint64_t  ifInOctets;              /**< Total number of byte received. */
     uint64_t  ifInPkts;                /**< Total number of packets received.*/
+    uint64_t  ifInUcastPkts;           /**< Total number of unicast frame received;
+                                            NOTE: this counter is not supported on dTSEC MAC */
     uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received*/
     uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
     uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
@@ -180,6 +182,8 @@ typedef struct t_FmMacStatistics {
                                                - The dedicated Error Code (0xfe, not a code error) was received */
     uint64_t  ifOutOctets;             /**< Total number of byte sent. */
     uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
+    uint64_t  ifOutUcastPkts;          /**< Total number of unicast frame sent;
+                                            NOTE: this counter is not supported on dTSEC MAC */
     uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
     uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
     uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
@@ -205,7 +209,14 @@ typedef struct t_FmMacParams {
     uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
     t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
     uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
-    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
+    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed);
+                                                         Note that the speed should indicate the maximum rate that
+                                                         this MAC should support rather than the actuall speed;
+                                                         i.e. user should use the FM_MAC_AdjustLink() routine to
+                                                         provide accurate speed;
+                                                         In addition, in mEMAC, in case where user is using the higher MACs
+                                                         (i.e. the MACs that should support 10G), user should pass here
+                                                         speed=10000 even if the interface is not allowing that (e.g. SGMII). */
     t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
     int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
                                                          MACs; MUST be set to 'NO_IRQ' for MACs that don't have
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index b2506f3..957741d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -43,6 +43,7 @@
 #include "net_ext.h"
 #include "list_ext.h"
 #include "fm_ext.h"
+#include "fsl_fman_kg.h"
 
 
 /**************************************************************************//**
@@ -85,7 +86,7 @@
                                                                              for private headers. */
 #define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
                                                                              in a distinction unit */
-#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               FM_KG_NUM_OF_GENERIC_REGS /**< Total number of generic KeyGen registers */
 #define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
                                                                              For HW implementation reasons, in most
                                                                              cases less than this will be allowed; The
@@ -215,7 +216,10 @@ typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
  *//***************************************************************************/
 typedef struct t_FmPcdHcParams {
     uintptr_t                   portBaseAddr;       /**< Virtual Address of Host-Command Port memory mapped registers.*/
-    uint8_t                     portId;             /**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports) */
+    uint8_t                     portId;             /**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports);
+                                                         NOTE: When configuring Host Command port for
+                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
+                                                         portId=0 MUST be used. */
     uint16_t                    liodnBase;          /**< LIODN base for this port, to be used together with LIODN offset
                                                          (irrelevant for P4080 revision 1.0) */
     uint32_t                    errFqid;            /**< Host-Command Port error queue Id. */
@@ -846,11 +850,14 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
 
 #define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
                                                      IPV6 Reassembly manipulation requires network
-                                                     environment with IPV6 header and IPV6_FRAG_1 option  */
+                                                     environment with IPV6 header and IPV6_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
 /* @} */
 
 #define FM_PCD_MANIP_MAX_HDR_SIZE               256
 #define FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+
 /**************************************************************************//**
  @Collection    A set of definitions to support Header Manipulation selection.
 *//***************************************************************************/
@@ -929,10 +936,10 @@ typedef enum e_FmPcdExtractByHdrType {
 typedef enum e_FmPcdExtractFrom {
     e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
     e_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
-    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG & CC: Extract from the point where parsing had finished */
     e_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
     e_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
-    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG only: Extract from the parser result */
     e_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
     e_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
 } e_FmPcdExtractFrom;
@@ -1239,7 +1246,7 @@ typedef enum e_FmPcdManipDontFragAction {
                                                         /**< Obsolete, cannot enqueue to error queue;
                                                              In practice, selects to discard packets;
                                                              Will be removed in the future */
-    e_FM_PCD_MANIP_FRAGMENT_PACKET,                     /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_FRAGMENT_PACKECT,                    /**< Fragment packet and continue normal processing */
     e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
 } e_FmPcdManipDontFragAction;
 
@@ -1306,7 +1313,7 @@ typedef union u_FmPcdHdrProtocolOpt {
                                  e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
                                  e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
-                                (Note that starting DPAA 11, NET_HEADER_FIELD_IPv6_NEXT_HDR applies to
+                                (Note that starting from DPAA 1-1, NET_HEADER_FIELD_IPv6_NEXT_HDR applies to
                                  the last next header indication, meaning the next L4, which may be
                                  present at the Ipv6 last extension. On earlier revisions this field
                                  applies to the Next-Header field of the main IPv6 header)
@@ -1335,6 +1342,11 @@ typedef union u_FmPcdHdrProtocolOpt {
                         NET_HEADER_FIELD_UDP_PORT_SRC
                         NET_HEADER_FIELD_UDP_PORT_DST
 
+
+                    HEADER_TYPE_UDP_LITE: - relevant only if FM_CAPWAP_SUPPORT define
+                        NET_HEADER_FIELD_UDP_LITE_PORT_SRC
+                        NET_HEADER_FIELD_UDP_LITE_PORT_DST
+
                     HEADER_TYPE_IPSEC_AH:
                         NET_HEADER_FIELD_IPSEC_AH_SPI
                         NET_HEADER_FIELD_IPSEC_AH_NH
@@ -1388,6 +1400,7 @@ typedef union t_FmPcdFields {
     headerFieldIpv4_t           ipv4;           /**< IPv4                   */
     headerFieldIpv6_t           ipv6;           /**< IPv6                   */
     headerFieldUdp_t            udp;            /**< UDP                    */
+    headerFieldUdpLite_t        udpLite;        /**< UDP Lite               */
     headerFieldTcp_t            tcp;            /**< TCP                    */
     headerFieldSctp_t           sctp;           /**< SCTP                   */
     headerFieldDccp_t           dccp;           /**< DCCP                   */
@@ -1594,12 +1607,15 @@ typedef struct t_FmPcdKgPlcrProfile {
                                                          should indicate the policer profile offset within the
                                                          port's policer profiles or shared window. */
         struct {
-            uint8_t     fqidOffsetShift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
+                                                         final FQID - without the FQID base). */
             uint8_t     fqidOffsetRelativeProfileIdBase;
-                                                    /**< OR of KeyGen results without the FQID base
-                                                         This parameter should indicate the policer profile
-                                                         offset within the port's policer profiles window or
-                                                         SHARED window depends on sharedProfile */
+                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
+                                                         this value will be "OR'ed" with the KeyGen create FQID
+                                                         offset (i.e. not the final FQID - without the FQID base);
+                                                         the final result should indicate the Storage-Profile offset
+                                                         within the FMan Port's relative Storage-Profiles window/
+                                                         (or the SHARED window depends on 'sharedProfile'). */
             uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
         } indirectProfile;                          /**< Indirect profile parameters */
     } profileSelect;                                /**< Direct/indirect profile selection and parameters */
@@ -1622,11 +1638,14 @@ typedef struct t_FmPcdKgStorageProfile {
                                                          should indicate the storage profile offset within the
                                                          port's storage profiles window. */
         struct {
-            uint8_t     fqidOffsetShift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
+                                                         final FQID - without the FQID base). */
             uint8_t     fqidOffsetRelativeProfileIdBase;
-                                                    /**< OR of KeyGen results without the FQID base;
-                                                         should indicate the policer profile offset within the
-                                                         port's storage profiles window. */
+                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
+                                                         this value will be "OR'ed" with the KeyGen create FQID
+                                                         offset (i.e. not the final FQID - without the FQID base);
+                                                         the final result should indicate the Storage-Profile offset
+                                                         within the FMan Port's relative Storage-Profiles window. */
             uint8_t     numOfProfiles;              /**< Range of profiles starting at base. */
         } indirectProfile;                          /**< Indirect profile parameters. */
     } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
@@ -2060,7 +2079,6 @@ typedef struct t_FmPcdPlcrProfileParams {
     bool                                trapProfileOnFlowC;         /**< Obsolete - do not use */
 } t_FmPcdPlcrProfileParams;
 
-#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
@@ -2072,6 +2090,7 @@ typedef struct t_FmManipHdrInfo
     t_FmPcdFields                       fullField;      /**< Relevant only when byField = TRUE: Extract field */
 } t_FmManipHdrInfo;
 
+#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Description   Parameters for defining an insertion manipulation
                 of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
@@ -2184,6 +2203,23 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
 
 /**************************************************************************//**
  @Description   Parameters for configuring IP fragmentation manipulation
+
+ Restrictions:
+     - IP Fragmentation output fragments must not be forwarded to application directly.
+     - Maximum number of fragments per frame is 16.
+     - Fragmentation of IP fragments is not supported.
+     - IPv4 packets containing header Option fields are fragmented by copying all option
+       fields to each fragment, regardless of the copy bit value.
+     - Transmit confirmation is not supported.
+     - Fragmentation after SEC can't handle S/G frames.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - IPF does not support VSP. Therefore, on the same port where we have IPF
+       we cannot support VSP.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
 *//***************************************************************************/
 typedef struct t_FmPcdManipFragIpParams {
     uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
@@ -2195,7 +2231,7 @@ typedef struct t_FmPcdManipFragIpParams {
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
     uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
-                                                             This parameter is relevant when 'sgBpidEn=TRUE';
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
                                                              Same LIODN number is used for these buffers as for the received frames buffers, so buffers
                                                              of this pool need to be allocated in the same memory area as the received buffers.
                                                              If the received buffers arrive from different sources, the Scatter/Gather BP id should be
@@ -2211,6 +2247,12 @@ typedef struct t_FmPcdManipFragIpParams {
                 This is a common structure for both IPv4 and IPv6 reassembly
                 manipulation. For reassembly of both IPv4 and IPv6, make sure to
                 set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
+
+ Restrictions:
+    - Application must define at least one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+    - Reassembly of IPv4 fragments containing Option fields is supported.
+
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemIpParams {
     uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
@@ -2232,7 +2274,7 @@ typedef struct t_FmPcdManipReassemIpParams {
     uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
     uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
     uint16_t                        minFragSize[2];         /**< Minimum fragment size:
-                                                                 minFragSize[0] - for IPv4, minFragSize[1] - for IPv6 */
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
     e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
                                                             /**< Number of frames per hash entry needed for reassembly process:
                                                                  numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
@@ -3150,6 +3192,8 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
                                           t_FmPcdCcKeyStatistics    *p_KeyStatistics);
 
 /**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNGetKeyStatistics
+
  @Description   This routine may be used to get statistics counters of specific key
                 in a CC Node.
 
@@ -3367,6 +3411,8 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
                                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
+ @Function      FM_PCD_HashTableFindNGetKeyStatistics
+
  @Description   This routine may be used to get statistics counters of specific key
                 in a hash table.
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 77d3f05..afa2cd9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -130,10 +130,8 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT      FM_FD_ERR_UNSUPPORTED_FORMAT    /**< Not for Rx-Port! Unsupported Format */
 #define FM_PORT_FRM_ERR_LENGTH                  FM_FD_ERR_LENGTH                /**< Not for Rx-Port! Length Error */
 #define FM_PORT_FRM_ERR_DMA                     FM_FD_ERR_DMA                   /**< DMA Data error */
-#ifdef FM_DISABLE_SEC_ERRORS
-#define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /*< non Frame-Manager error; probably come from SEC that
-                                                                                    was chained to FM */
-#endif /* FM_DISABLE_SEC_ERRORS */
+#define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /**< non Frame-Manager error; probably come from SEC that
+                                                                                     was chained to FM */
 
 #define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
 #define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
@@ -276,7 +274,11 @@ typedef struct t_FmPortParams {
     uintptr_t                   baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
     t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
     e_FmPortType                portType;           /**< Port type */
-    uint8_t                     portId;             /**< Port Id - relative to type */
+    uint8_t                     portId;             /**< Port Id - relative to type;
+                                                         NOTE: When configuring Offline Parsing port for
+                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
+                                                         it is highly recommended NOT to use portId=0 due to lack
+                                                         of HW resources on portId=0. */
     bool                        independentModeEnable;
                                                     /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
     uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
@@ -1170,9 +1172,30 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
 
-#ifdef FM_BCB_ERRATA_BMI_SW001
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigBCBWorkaround
+
+ @Description   Configures BCB errata workaround.
+
+                When BCB errata is applicable, the workaround is always
+                performed by FM Controller. Thus, this functions doesn't
+                actually enable errata workaround but rather allows driver
+                to perform adjustments required due to errata workaround
+                execution in FM controller.
+
+                Applying BCB workaround also configures FM_PORT_FRM_ERR_PHYSICAL
+                errors to be discarded. Thus FM_PORT_FRM_ERR_PHYSICAL can't be
+                set by FM_PORT_SetErrorsRoute() function.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
 t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort);
-#endif /* FM_BCB_ERRATA_BMI_SW001 */
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
 
 #if (DPAA_VERSION >= 11)
 /**************************************************************************//*
@@ -1706,7 +1729,7 @@ t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception,
 t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
 
 /**************************************************************************//*
- @Function      FM_PORT_SetPerformanceCounters
+ @Function      FM_PORT_SetPerformanceCountersParams
 
  @Description   Calling this routine defines port's performance
                 counters parameters.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ddr_std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ddr_std_ext.h
new file mode 100644
index 0000000..69a0025
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ddr_std_ext.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DDR_SDT_EXT_H
+#define __DDR_SDT_EXT_H
+
+
+/**************************************************************************//**
+ @Group         ddr_Generic_Resources
+
+ @Description   ddr generic functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   SPD maximum size
+*//***************************************************************************/
+#define SPD_MAX_SIZE 256
+
+/**************************************************************************//**
+ @Description   DDR types select
+*//***************************************************************************/
+typedef enum e_DdrType
+{
+    e_DDR_DDR1,
+    e_DDR_DDR2,
+    e_DDR_DDR3,
+    e_DDR_DDR3L
+} e_DdrType;
+
+/**************************************************************************//**
+ @Description   DDR Mode.
+*//***************************************************************************/
+typedef enum e_DdrMode
+{
+    e_DDR_BUS_WIDTH_32BIT,
+    e_DDR_BUS_WIDTH_64BIT
+} e_DdrMode;
+
+/** @} */ /* end of ddr_Generic_Resources group */
+
+
+
+#endif /* __DDR_SDT_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index f5148d0..62865bb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -220,7 +220,7 @@
 *//***************************************************************************/
 #define DUMP_ARR(st, phrase) \
     do { \
-        physAddress_t physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
+        physAddress_t physAddr; \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpArrSize = ARRAY_SIZE((st)->phrase); \
         dumpVarSize = sizeof((st)->phrase[0]); \
@@ -228,21 +228,25 @@
         { \
             case 1: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
                     DUMP_Print("0x%010llX: 0x%02x%14s\t%s[%d]\r\n", \
                                physAddr, GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 2: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
                     DUMP_Print("0x%010llX: 0x%04x%12s\t%s[%d]\r\n", \
                                physAddr, GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 4: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
                     DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
                                physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 8: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
                     DUMP_Print("0x%010llX: 0x%016llx\t%s[%d]\r\n", \
                                physAddr, GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
                 } break; \
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index 4b3f3b2..bf76d8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -40,6 +40,7 @@
 #ifndef __ENET_EXT_H
 #define __ENET_EXT_H
 
+#include "fsl_enet.h"
 
 #define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
 #define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
@@ -65,19 +66,27 @@ typedef enum e_EnetAddrType
 *//***************************************************************************/
 typedef enum e_EnetInterface
 {
-    e_ENET_IF_MII   = 0x00010000,   /**< MII interface */
-    e_ENET_IF_RMII  = 0x00020000,   /**< RMII interface */
-    e_ENET_IF_SMII  = 0x00030000,   /**< SMII interface */
-    e_ENET_IF_GMII  = 0x00040000,   /**< GMII interface */
-    e_ENET_IF_RGMII = 0x00050000,   /**< RGMII interface */
-    e_ENET_IF_TBI   = 0x00060000,   /**< TBI interface */
-    e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
-    e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
-    e_ENET_IF_XGMII = 0x00090000,   /**< XGMII interface */
-    e_ENET_IF_QSGMII= 0x000a0000,   /**< QSGMII interface */
-    e_ENET_IF_XFI   = 0x000b0000    /**< XFI interface */
+    e_ENET_IF_MII   = E_ENET_IF_MII,     /**< MII interface */
+    e_ENET_IF_RMII  = E_ENET_IF_RMII,    /**< RMII interface */
+    e_ENET_IF_SMII  = E_ENET_IF_SMII,    /**< SMII interface */
+    e_ENET_IF_GMII  = E_ENET_IF_GMII,    /**< GMII interface */
+    e_ENET_IF_RGMII = E_ENET_IF_RGMII,   /**< RGMII interface */
+    e_ENET_IF_TBI   = E_ENET_IF_TBI,     /**< TBI interface */
+    e_ENET_IF_RTBI  = E_ENET_IF_RTBI,    /**< RTBI interface */
+    e_ENET_IF_SGMII = E_ENET_IF_SGMII,   /**< SGMII interface */
+    e_ENET_IF_XGMII = E_ENET_IF_XGMII,   /**< XGMII interface */
+    e_ENET_IF_QSGMII= E_ENET_IF_QSGMII,  /**< QSGMII interface */
+    e_ENET_IF_XFI   = E_ENET_IF_XFI      /**< XFI interface */
 } e_EnetInterface;
 
+#define ENET_IF_SGMII_BASEX       0x80000000   /**< SGMII/QSGII interface with 1000BaseX
+                                                    auto-negotiation between MAC and phy
+                                                    or backplane;
+                                                    Note: 1000BaseX auto-negotiation relates
+                                                    only to interface between MAC and phy/backplane,
+                                                    SGMII phy can still synchronize with far-end phy
+                                                    at 10Mbps, 100Mbps or 1000Mbps */
+
 /**************************************************************************//**
  @Description   Ethernet Duplex Mode
 *//***************************************************************************/
@@ -92,10 +101,10 @@ typedef enum e_EnetDuplexMode
 *//***************************************************************************/
 typedef enum e_EnetSpeed
 {
-    e_ENET_SPEED_10     = 10,       /**< 10 Mbps */
-    e_ENET_SPEED_100    = 100,      /**< 100 Mbps */
-    e_ENET_SPEED_1000   = 1000,     /**< 1000 Mbps = 1 Gbps */
-    e_ENET_SPEED_10000  = 10000     /**< 10000 Mbps = 10 Gbps */
+    e_ENET_SPEED_10     = E_ENET_SPEED_10,       /**< 10 Mbps */
+    e_ENET_SPEED_100    = E_ENET_SPEED_100,      /**< 100 Mbps */
+    e_ENET_SPEED_1000   = E_ENET_SPEED_1000,     /**< 1000 Mbps = 1 Gbps */
+    e_ENET_SPEED_10000  = E_ENET_SPEED_10000     /**< 10000 Mbps = 10 Gbps */
 } e_EnetSpeed;
 
 /**************************************************************************//**
@@ -103,25 +112,45 @@ typedef enum e_EnetSpeed
 *//***************************************************************************/
 typedef enum e_EnetMode
 {
-    e_ENET_MODE_INVALID     = 0,                                        /**< Invalid Ethernet mode */
-    e_ENET_MODE_MII_10      = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
-    e_ENET_MODE_MII_100     = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
-    e_ENET_MODE_RMII_10     = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
-    e_ENET_MODE_RMII_100    = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
-    e_ENET_MODE_SMII_10     = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
-    e_ENET_MODE_SMII_100    = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
-    e_ENET_MODE_GMII_1000   = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
-    e_ENET_MODE_RGMII_10    = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
-    e_ENET_MODE_RGMII_100   = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
-    e_ENET_MODE_RGMII_1000  = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
-    e_ENET_MODE_TBI_1000    = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
-    e_ENET_MODE_RTBI_1000   = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
-    e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
-    e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
-    e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
-    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
-    e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),    /**<  1000 Mbps QSGMII */
-    e_ENET_MODE_XFI_10000   = (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
+    e_ENET_MODE_INVALID           = 0,                                        /**< Invalid Ethernet mode */
+    e_ENET_MODE_MII_10            = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
+    e_ENET_MODE_MII_100           = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
+    e_ENET_MODE_RMII_10           = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
+    e_ENET_MODE_RMII_100          = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
+    e_ENET_MODE_SMII_10           = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
+    e_ENET_MODE_SMII_100          = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
+    e_ENET_MODE_GMII_1000         = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
+    e_ENET_MODE_RGMII_10          = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
+    e_ENET_MODE_RGMII_100         = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
+    e_ENET_MODE_RGMII_1000        = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
+    e_ENET_MODE_TBI_1000          = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
+    e_ENET_MODE_RTBI_1000         = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
+    e_ENET_MODE_SGMII_10          = (e_ENET_IF_SGMII | e_ENET_SPEED_10),
+                                        /**< 10 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_100         = (e_ENET_IF_SGMII | e_ENET_SPEED_100),
+                                        /**< 100 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_1000        = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_BASEX_10    = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_10),
+                                        /**< 10 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_SGMII_BASEX_100   = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_100),
+                                        /**< 100 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_SGMII_BASEX_1000  = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_QSGMII_1000       = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps QSGMII with auto-negotiation between MAC and
+                                             QSGMII phy according to Cisco QSGMII specification */
+    e_ENET_MODE_QSGMII_BASEX_1000 = (ENET_IF_SGMII_BASEX | e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps QSGMII with 1000BaseX auto-negotiation between
+                                             MAC and QSGMII phy or backplane */
+    e_ENET_MODE_XGMII_10000       = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
+    e_ENET_MODE_XFI_10000         = (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
 } e_EnetMode;
 
 
@@ -141,14 +170,18 @@ typedef enum e_EnetMode
          ((mode) == e_ENET_MODE_SGMII_10   ) || \
          ((mode) == e_ENET_MODE_SGMII_100  ) || \
          ((mode) == e_ENET_MODE_SGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_1000 ) || \
          ((mode) == e_ENET_MODE_XGMII_10000) || \
          ((mode) == e_ENET_MODE_QSGMII_1000) || \
+         ((mode) == e_ENET_MODE_QSGMII_BASEX_1000) || \
          ((mode) == e_ENET_MODE_XFI_10000))
 
 
 #define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
 
-#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0xFFFF0000)
+#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0x0FFF0000)
 #define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
 
 #define ENET_ADDR_TO_UINT64(_enetAddr)                  \
@@ -166,5 +199,6 @@ typedef enum e_EnetMode
                 (_enetAddr)[i] = (uint8_t)((_addr64) >> ((5-i)*8)); \
         } while (0)
 
+
 #endif /* __ENET_EXT_H */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h
index acf7fce..bb0dea9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h
@@ -38,40 +38,39 @@
 */
 
 enum enet_interface {
-    enet_if_mii    = 0x00010000, /**< MII interface */
-    enet_if_rmii   = 0x00020000, /**< RMII interface */
-    enet_if_smii   = 0x00030000, /**< SMII interface */
-    enet_if_gmii   = 0x00040000, /**< GMII interface */
-    enet_if_rgmii  = 0x00050000, /**< RGMII interface */
-    enet_if_tbi    = 0x00060000, /**< TBI interface */
-    enet_if_rtbi   = 0x00070000, /**< RTBI interface */
-    enet_if_sgmii  = 0x00080000, /**< SGMII interface */
-    enet_if_xgmii  = 0x00090000, /**< XGMII interface */
-    enet_if_qsgmii = 0x000a0000, /**< QSGMII interface */
-    enet_if_xfi    = 0x000b0000  /**< XFI interface */
+	E_ENET_IF_MII		= 0x00010000, /**< MII interface */
+	E_ENET_IF_RMII		= 0x00020000, /**< RMII interface */
+	E_ENET_IF_SMII		= 0x00030000, /**< SMII interface */
+	E_ENET_IF_GMII		= 0x00040000, /**< GMII interface */
+	E_ENET_IF_RGMII		= 0x00050000, /**< RGMII interface */
+	E_ENET_IF_TBI		= 0x00060000, /**< TBI interface */
+	E_ENET_IF_RTBI		= 0x00070000, /**< RTBI interface */
+	E_ENET_IF_SGMII		= 0x00080000, /**< SGMII interface */
+	E_ENET_IF_XGMII		= 0x00090000, /**< XGMII interface */
+	E_ENET_IF_QSGMII	= 0x000a0000, /**< QSGMII interface */
+	E_ENET_IF_XFI		= 0x000b0000  /**< XFI interface */
 };
 
 /**
  @Description  Ethernet Speed (nominal data rate)
 */
 enum enet_speed {
-    enet_speed_10     = 10,      /**< 10 Mbps */
-    enet_speed_100    = 100,     /**< 100 Mbps */
-    enet_speed_1000   = 1000,    /**< 1000 Mbps = 1 Gbps */
-    enet_speed_10000  = 10000    /**< 10000 Mbps = 10 Gbps */
+	E_ENET_SPEED_10		= 10,	/**< 10 Mbps */
+	E_ENET_SPEED_100	= 100,	/**< 100 Mbps */
+	E_ENET_SPEED_1000	= 1000,	/**< 1000 Mbps = 1 Gbps */
+	E_ENET_SPEED_10000	= 10000	/**< 10000 Mbps = 10 Gbps */
 };
 
 enum mac_stat_level {
-    /* No statistics */
-    mac_stat_none = 0,
-    /* Only RMON MIB group 1 (ether stats). Optimized for performance */
-    mac_stat_mib_grp1,
-    /* Only error counters are available. Optimized for performance */
-    mac_stat_partial,
-    /* All counters available. Not optimized for performance */
-    mac_stat_full
+	/* No statistics */
+	E_MAC_STAT_NONE = 0,
+	/* Only RMON MIB group 1 (ether stats). Optimized for performance */
+	E_MAC_STAT_MIB_GRP1,
+	/* Only error counters are available. Optimized for performance */
+	E_MAC_STAT_PARTIAL,
+	/* All counters available. Not optimized for performance */
+	E_MAC_STAT_FULL
 };
 
 
-#endif /* __ENET_EXT_H */
-
+#endif /* __FSL_ENET_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_dtsec.h
new file mode 100644
index 0000000..55527c1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_dtsec.h
@@ -0,0 +1,1060 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_DTSEC_H
+#define __FSL_FMAN_DTSEC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+/**
+ * DOC: dTSEC Init sequence
+ *
+ * To prepare dTSEC block for transfer use the following call sequence:
+ *
+ * - dtsec_defconfig() - This step is optional and yet recommended. Its use is
+ * to obtain the default dTSEC configuration parameters.
+ *
+ * - Change dtsec configuration in &dtsec_cfg. This structure will be used
+ * to customize the dTSEC behavior.
+ *
+ * - dtsec_init() - Applies the configuration on dTSEC hardware.  Note that
+ * dTSEC is initialized while both Tx and Rx are disabled.
+ *
+ * - dtsec_set_mac_address() - Set the station address (mac address).
+ * This is used by dTSEC to match against received packets.
+ *
+ * - dtsec_adjust_link() - Set the link speed and duplex parameters
+ * after the PHY establishes the link.
+ *
+ * - dtsec_enable_tx() and dtsec_enable_rx() to enable transmission and
+ * reception.
+ */
+
+/**
+ * DOC: dTSEC Graceful stop
+ *
+ * To temporary stop dTSEC activity use dtsec_stop_tx() and dtsec_stop_rx().
+ * Note that these functions request dTSEC graceful stop but return before this
+ * stop is complete.  To query for graceful stop completion use
+ * dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
+ * Alternatively the dTSEC interrupt mask can be set to enable graceful stop
+ * interrupts.
+ *
+ * To resume operation after graceful stop use dtsec_start_tx() and
+ * dtsec_start_rx().
+ */
+
+/**
+ * DOC: dTSEC interrupt handling
+ *
+ * This code does not provide an interrupt handler for dTSEC.  Instead this
+ * handler should be implemented and registered to the operating system by the
+ * caller.  Some primitives for accessing the event status and mask registers
+ * are provided.
+ *
+ * See "dTSEC Events" section for a list of events that dTSEC can generate.
+ */
+
+/**
+ * DOC: dTSEC Events
+ *
+ * Interrupt events cause dTSEC event bits to be set.  Software may poll the
+ * event register at any time to check for pending interrupts.  If an event
+ * occurs and its corresponding enable bit is set in the interrupt mask
+ * register, the event also causes a hardware interrupt at the PIC.
+ *
+ * To poll for event status use the dtsec_get_event() function.
+ * To configure the interrupt mask use dtsec_enable_interrupt() and
+ * dtsec_disable_interrupt() functions.
+ * After servicing a dTSEC interrupt use dtsec_ack_event to reset the serviced
+ * event bit.
+ *
+ * The following events may be signaled by dTSEC hardware:
+ *
+ * %DTSEC_IEVENT_BABR - Babbling receive error.  This bit indicates that
+ * a frame was received with length in excess of the MAC's maximum frame length
+ * register.
+ *
+ * %DTSEC_IEVENT_RXC - Receive control (pause frame) interrupt.  A pause
+ * control frame was received while Rx pause frame handling is enabled.
+ * Also see dtsec_handle_rx_pause().
+ *
+ * %DTSEC_IEVENT_MSRO - MIB counter overflow.  The count for one of the MIB
+ * counters has exceeded the size of its register.
+ *
+ * %DTSEC_IEVENT_GTSC - Graceful transmit stop complete.  Graceful stop is now
+ * complete. The transmitter is in a stopped state, in which only pause frames
+ * can be transmitted.
+ * Also see dtsec_stop_tx().
+ *
+ * %DTSEC_IEVENT_BABT - Babbling transmit error.  The transmitted frame length
+ * has exceeded the value in the MAC's Maximum Frame Length register.
+ *
+ * %DTSEC_IEVENT_TXC - Transmit control (pause frame) interrupt.  his bit
+ * indicates that a control frame was transmitted.
+ *
+ * %DTSEC_IEVENT_TXE - Transmit error.  This bit indicates that an error
+ * occurred on the transmitted channel.  This bit is set whenever any transmit
+ * error occurs which causes the dTSEC to discard all or part of a frame
+ * (LC, CRL, XFUN).
+ *
+ * %DTSEC_IEVENT_LC - Late collision.  This bit indicates that a collision
+ * occurred beyond the collision window (slot time) in half-duplex mode.
+ * The frame is truncated with a bad CRC and the remainder of the frame
+ * is discarded.
+ *
+ * %DTSEC_IEVENT_CRL - Collision retry limit.  is bit indicates that the number
+ * of successive transmission collisions has exceeded the MAC's half-duplex
+ * register's retransmission maximum count.  The frame is discarded without
+ * being transmitted and transmission of the next frame commences.  This only
+ * occurs while in half-duplex mode.
+ * The number of retransmit attempts can be set in
+ * &dtsec_halfdup_cfg.@retransmit before calling dtsec_init().
+ *
+ * %DTSEC_IEVENT_XFUN - Transmit FIFO underrun.  This bit indicates that the
+ * transmit FIFO became empty before the complete frame was transmitted.
+ * The frame is truncated with a bad CRC and the remainder of the frame is
+ * discarded.
+ *
+ * %DTSEC_IEVENT_MAG - TBD
+ *
+ * %DTSEC_IEVENT_MMRD - MII management read completion.
+ *
+ * %DTSEC_IEVENT_MMWR - MII management write completion.
+ *
+ * %DTSEC_IEVENT_GRSC - Graceful receive stop complete.  It allows the user to
+ * know if the system has completed the stop and it is safe to write to receive
+ * registers (status, control or configuration registers) that are used by the
+ * system during normal operation.
+ *
+ * %DTSEC_IEVENT_TDPE - Internal data error on transmit.  This bit indicates
+ * that the dTSEC has detected a parity error on its stored transmit data, which
+ * is likely to compromise the validity of recently transferred frames.
+ *
+ * %DTSEC_IEVENT_RDPE - Internal data error on receive.  This bit indicates that
+ * the dTSEC has detected a parity error on its stored receive data, which is
+ * likely to compromise the validity of recently transferred frames.
+ */
+/* Interrupt Mask Register (IMASK) */
+#define DTSEC_IMASK_BREN	0x80000000
+#define DTSEC_IMASK_RXCEN	0x40000000
+#define DTSEC_IMASK_MSROEN	0x04000000
+#define DTSEC_IMASK_GTSCEN	0x02000000
+#define DTSEC_IMASK_BTEN	0x01000000
+#define DTSEC_IMASK_TXCEN	0x00800000
+#define DTSEC_IMASK_TXEEN	0x00400000
+#define DTSEC_IMASK_LCEN	0x00040000
+#define DTSEC_IMASK_CRLEN	0x00020000
+#define DTSEC_IMASK_XFUNEN	0x00010000
+#define DTSEC_IMASK_ABRTEN	0x00008000
+#define DTSEC_IMASK_IFERREN	0x00004000
+#define DTSEC_IMASK_MAGEN	0x00000800
+#define DTSEC_IMASK_MMRDEN	0x00000400
+#define DTSEC_IMASK_MMWREN	0x00000200
+#define DTSEC_IMASK_GRSCEN	0x00000100
+#define DTSEC_IMASK_TDPEEN	0x00000002
+#define DTSEC_IMASK_RDPEEN	0x00000001
+
+#define EVENTS_MASK					\
+	((uint32_t)(DTSEC_IMASK_BREN    | \
+				DTSEC_IMASK_RXCEN   | \
+				DTSEC_IMASK_BTEN    | \
+				DTSEC_IMASK_TXCEN   | \
+				DTSEC_IMASK_TXEEN   | \
+				DTSEC_IMASK_ABRTEN  | \
+				DTSEC_IMASK_LCEN    | \
+				DTSEC_IMASK_CRLEN   | \
+				DTSEC_IMASK_XFUNEN  | \
+				DTSEC_IMASK_IFERREN | \
+				DTSEC_IMASK_MAGEN   | \
+				DTSEC_IMASK_TDPEEN  | \
+				DTSEC_IMASK_RDPEEN))
+
+/* dtsec timestamp event bits */
+#define TMR_PEMASK_TSREEN	0x00010000
+#define TMR_PEVENT_TSRE		0x00010000
+
+/* Group address bit indication */
+#define MAC_GROUP_ADDRESS	0x0000010000000000ULL
+/* size in bytes of L2 address */
+#define MAC_ADDRLEN		6
+
+#define DEFAULT_HALFDUP_ON		FALSE
+#define DEFAULT_HALFDUP_RETRANSMIT	0xf
+#define DEFAULT_HALFDUP_COLL_WINDOW	0x37
+#define DEFAULT_HALFDUP_EXCESS_DEFER	TRUE
+#define DEFAULT_HALFDUP_NO_BACKOFF	FALSE
+#define DEFAULT_HALFDUP_BP_NO_BACKOFF	FALSE
+#define DEFAULT_HALFDUP_ALT_BACKOFF_VAL	0x0A
+#define DEFAULT_HALFDUP_ALT_BACKOFF_EN	FALSE
+#define DEFAULT_RX_DROP_BCAST		FALSE
+#define DEFAULT_RX_SHORT_FRM		TRUE
+#define DEFAULT_RX_LEN_CHECK		FALSE
+#define DEFAULT_TX_PAD_CRC		TRUE
+#define DEFAULT_TX_CRC			FALSE
+#define DEFAULT_RX_CTRL_ACC		FALSE
+#define DEFAULT_TX_PAUSE_TIME		0xf000
+#define DEFAULT_TBIPA			5
+#define DEFAULT_RX_PREPEND		0
+#define DEFAULT_PTP_TSU_EN		TRUE
+#define DEFAULT_PTP_EXCEPTION_EN	TRUE
+#define DEFAULT_PREAMBLE_LEN		7
+#define DEFAULT_RX_PREAMBLE		FALSE
+#define DEFAULT_TX_PREAMBLE		FALSE
+#define DEFAULT_LOOPBACK		FALSE
+#define DEFAULT_RX_TIME_STAMP_EN	FALSE
+#define DEFAULT_TX_TIME_STAMP_EN	FALSE
+#define DEFAULT_RX_FLOW			TRUE
+#define DEFAULT_TX_FLOW			TRUE
+#define DEFAULT_RX_GROUP_HASH_EXD	FALSE
+#define DEFAULT_TX_PAUSE_TIME_EXTD	0
+#define DEFAULT_RX_PROMISC		FALSE
+#define DEFAULT_NON_BACK_TO_BACK_IPG1	0x40
+#define DEFAULT_NON_BACK_TO_BACK_IPG2	0x60
+#define DEFAULT_MIN_IFG_ENFORCEMENT	0x50
+#define DEFAULT_BACK_TO_BACK_IPG	0x60
+#define DEFAULT_MAXIMUM_FRAME		0x600
+#define DEFAULT_TBI_PHY_ADDR		5
+
+/* register related defines (bits, field offsets..) */
+#define DTSEC_ID1_ID			0xffff0000
+#define DTSEC_ID1_REV_MJ		0x0000FF00
+#define DTSEC_ID1_REV_MN		0x000000ff
+
+#define DTSEC_ID2_INT_REDUCED_OFF	0x00010000
+#define DTSEC_ID2_INT_NORMAL_OFF	0x00020000
+
+#define DTSEC_ECNTRL_CLRCNT		0x00004000
+#define DTSEC_ECNTRL_AUTOZ		0x00002000
+#define DTSEC_ECNTRL_STEN		0x00001000
+#define DTSEC_ECNTRL_CFG_RO		0x80000000
+#define DTSEC_ECNTRL_GMIIM		0x00000040
+#define DTSEC_ECNTRL_TBIM		0x00000020
+#define DTSEC_ECNTRL_SGMIIM		0x00000002
+#define DTSEC_ECNTRL_RPM		0x00000010
+#define DTSEC_ECNTRL_R100M		0x00000008
+#define DTSEC_ECNTRL_RMM		0x00000004
+#define DTSEC_ECNTRL_QSGMIIM		0x00000001
+
+#define DTSEC_TCTRL_THDF		0x00000800
+#define DTSEC_TCTRL_TTSE		0x00000040
+#define DTSEC_TCTRL_GTS			0x00000020
+#define DTSEC_TCTRL_TFC_PAUSE		0x00000010
+
+/* PTV offsets */
+#define PTV_PTE_OFST		16
+
+#define RCTRL_CFA		0x00008000
+#define RCTRL_GHTX		0x00000400
+#define RCTRL_RTSE		0x00000040
+#define RCTRL_GRS		0x00000020
+#define RCTRL_BC_REJ		0x00000010
+#define RCTRL_MPROM		0x00000008
+#define RCTRL_RSF		0x00000004
+#define RCTRL_UPROM		0x00000001
+#define RCTRL_PROM		(RCTRL_UPROM | RCTRL_MPROM)
+
+#define TMR_CTL_ESFDP		0x00000800
+#define TMR_CTL_ESFDE		0x00000400
+
+#define MACCFG1_SOFT_RESET	0x80000000
+#define MACCFG1_LOOPBACK	0x00000100
+#define MACCFG1_RX_FLOW		0x00000020
+#define MACCFG1_TX_FLOW		0x00000010
+#define MACCFG1_TX_EN		0x00000001
+#define MACCFG1_RX_EN		0x00000004
+#define MACCFG1_RESET_RxMC	0x00080000
+#define MACCFG1_RESET_TxMC	0x00040000
+#define MACCFG1_RESET_RxFUN	0x00020000
+#define MACCFG1_RESET_TxFUN	0x00010000
+
+#define MACCFG2_NIBBLE_MODE	0x00000100
+#define MACCFG2_BYTE_MODE	0x00000200
+#define MACCFG2_PRE_AM_Rx_EN	0x00000080
+#define MACCFG2_PRE_AM_Tx_EN	0x00000040
+#define MACCFG2_LENGTH_CHECK	0x00000010
+#define MACCFG2_MAGIC_PACKET_EN	0x00000008
+#define MACCFG2_PAD_CRC_EN	0x00000004
+#define MACCFG2_CRC_EN		0x00000002
+#define MACCFG2_FULL_DUPLEX	0x00000001
+
+#define PREAMBLE_LENGTH_SHIFT	12
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT	24
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT	16
+#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT	8
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1	0x7F000000
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2	0x007F0000
+#define IPGIFG_MIN_IFG_ENFORCEMENT	0x0000FF00
+#define IPGIFG_BACK_TO_BACK_IPG		0x0000007F
+
+#define HAFDUP_ALT_BEB			0x00080000
+#define HAFDUP_BP_NO_BACKOFF		0x00040000
+#define HAFDUP_NO_BACKOFF		0x00020000
+#define HAFDUP_EXCESS_DEFER		0x00010000
+#define HAFDUP_COLLISION_WINDOW		0x000003ff
+
+#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT	20
+#define HAFDUP_RETRANSMISSION_MAX_SHIFT		12
+#define HAFDUP_RETRANSMISSION_MAX		0x0000f000
+
+#define NUM_OF_HASH_REGS	8 /* Number of hash table registers */
+
+/* CAR1/2 bits */
+#define DTSEC_CAR1_TR64		0x80000000
+#define DTSEC_CAR1_TR127	0x40000000
+#define DTSEC_CAR1_TR255	0x20000000
+#define DTSEC_CAR1_TR511	0x10000000
+#define DTSEC_CAR1_TRK1		0x08000000
+#define DTSEC_CAR1_TRMAX	0x04000000
+#define DTSEC_CAR1_TRMGV	0x02000000
+
+#define DTSEC_CAR1_RBYT		0x00010000
+#define DTSEC_CAR1_RPKT		0x00008000
+#define DTSEC_CAR1_RFCS		0x00004000
+#define DTSEC_CAR1_RMCA		0x00002000
+#define DTSEC_CAR1_RBCA		0x00001000
+#define DTSEC_CAR1_RXCF		0x00000800
+#define DTSEC_CAR1_RXPF		0x00000400
+#define DTSEC_CAR1_RXUO		0x00000200
+#define DTSEC_CAR1_RALN		0x00000100
+#define DTSEC_CAR1_RFLR		0x00000080
+#define DTSEC_CAR1_RCDE		0x00000040
+#define DTSEC_CAR1_RCSE		0x00000020
+#define DTSEC_CAR1_RUND		0x00000010
+#define DTSEC_CAR1_ROVR		0x00000008
+#define DTSEC_CAR1_RFRG		0x00000004
+#define DTSEC_CAR1_RJBR		0x00000002
+#define DTSEC_CAR1_RDRP		0x00000001
+
+#define DTSEC_CAR2_TJBR		0x00080000
+#define DTSEC_CAR2_TFCS		0x00040000
+#define DTSEC_CAR2_TXCF		0x00020000
+#define DTSEC_CAR2_TOVR		0x00010000
+#define DTSEC_CAR2_TUND		0x00008000
+#define DTSEC_CAR2_TFRG		0x00004000
+#define DTSEC_CAR2_TBYT		0x00002000
+#define DTSEC_CAR2_TPKT		0x00001000
+#define DTSEC_CAR2_TMCA		0x00000800
+#define DTSEC_CAR2_TBCA		0x00000400
+#define DTSEC_CAR2_TXPF		0x00000200
+#define DTSEC_CAR2_TDFR		0x00000100
+#define DTSEC_CAR2_TEDF		0x00000080
+#define DTSEC_CAR2_TSCL		0x00000040
+#define DTSEC_CAR2_TMCL		0x00000020
+#define DTSEC_CAR2_TLCL		0x00000010
+#define DTSEC_CAR2_TXCL		0x00000008
+#define DTSEC_CAR2_TNCL		0x00000004
+#define DTSEC_CAR2_TDRP		0x00000001
+
+#define CAM1_ERRORS_ONLY \
+	(DTSEC_CAR1_RXPF | DTSEC_CAR1_RALN | DTSEC_CAR1_RFLR \
+	| DTSEC_CAR1_RCDE | DTSEC_CAR1_RCSE | DTSEC_CAR1_RUND \
+	| DTSEC_CAR1_ROVR | DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
+	| DTSEC_CAR1_RDRP)
+
+#define CAM2_ERRORS_ONLY (DTSEC_CAR2_TFCS | DTSEC_CAR2_TXPF | DTSEC_CAR2_TDRP)
+
+/*
+ * Group of dTSEC specific counters relating to the standard RMON MIB Group 1
+ * (or Ethernet) statistics.
+ */
+#define CAM1_MIB_GRP_1 \
+	(DTSEC_CAR1_RDRP | DTSEC_CAR1_RBYT | DTSEC_CAR1_RPKT | DTSEC_CAR1_RMCA\
+	| DTSEC_CAR1_RBCA | DTSEC_CAR1_RALN | DTSEC_CAR1_RUND | DTSEC_CAR1_ROVR\
+	| DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
+	| DTSEC_CAR1_TR64 | DTSEC_CAR1_TR127 | DTSEC_CAR1_TR255 \
+	| DTSEC_CAR1_TR511 | DTSEC_CAR1_TRMAX)
+
+#define CAM2_MIB_GRP_1 (DTSEC_CAR2_TNCL | DTSEC_CAR2_TDRP)
+
+/* memory map */
+
+struct dtsec_regs {
+	/* dTSEC General Control and Status Registers */
+	uint32_t tsec_id;	/* 0x000 ETSEC_ID register */
+	uint32_t tsec_id2;	/* 0x004 ETSEC_ID2 register */
+	uint32_t ievent;	/* 0x008 Interrupt event register */
+	uint32_t imask;		/* 0x00C Interrupt mask register */
+	uint32_t reserved0010[1];
+	uint32_t ecntrl;	/* 0x014 E control register */
+	uint32_t ptv;		/* 0x018 Pause time value register */
+	uint32_t tbipa;		/* 0x01C TBI PHY address register */
+	uint32_t tmr_ctrl;	/* 0x020 Time-stamp Control register */
+	uint32_t tmr_pevent;	/* 0x024 Time-stamp event register */
+	uint32_t tmr_pemask;	/* 0x028 Timer event mask register */
+	uint32_t reserved002c[5];
+	uint32_t tctrl;		/* 0x040 Transmit control register */
+	uint32_t reserved0044[3];
+	uint32_t rctrl;		/* 0x050 Receive control register */
+	uint32_t reserved0054[11];
+	uint32_t igaddr[8]; 	/* 0x080-0x09C Individual/group address */
+	uint32_t gaddr[8];	/* 0x0A0-0x0BC Group address registers 0-7 */
+	uint32_t reserved00c0[16];
+	uint32_t maccfg1;		/* 0x100 MAC configuration #1 */
+	uint32_t maccfg2;		/* 0x104 MAC configuration #2 */
+	uint32_t ipgifg;		/* 0x108 IPG/IFG */
+	uint32_t hafdup;		/* 0x10C Half-duplex */
+	uint32_t maxfrm;		/* 0x110 Maximum frame */
+	uint32_t reserved0114[10];
+	uint32_t ifstat;		/* 0x13C Interface status */
+	uint32_t macstnaddr1;		/* 0x140 Station Address,part 1 */
+	uint32_t macstnaddr2;		/* 0x144 Station Address,part 2  */
+	struct {
+	    uint32_t exact_match1; /* octets 1-4 */
+	    uint32_t exact_match2; /* octets 5-6 */
+	} macaddr[15];	/* 0x148-0x1BC mac exact match addresses 1-15 */
+	uint32_t reserved01c0[16];
+	uint32_t tr64;	/* 0x200 transmit and receive 64 byte frame counter */
+	uint32_t tr127;	/* 0x204 transmit and receive 65 to 127 byte frame
+			 * counter */
+	uint32_t tr255;	/* 0x208 transmit and receive 128 to 255 byte frame
+			 * counter */
+	uint32_t tr511;	/* 0x20C transmit and receive 256 to 511 byte frame
+			 * counter */
+	uint32_t tr1k;	/* 0x210 transmit and receive 512 to 1023 byte frame
+			 * counter */
+	uint32_t trmax;	/* 0x214 transmit and receive 1024 to 1518 byte frame
+			 * counter */
+	uint32_t trmgv;	/* 0x218 transmit and receive 1519 to 1522 byte good
+			 * VLAN frame count */
+	uint32_t rbyt;	/* 0x21C receive byte counter */
+	uint32_t rpkt;	/* 0x220 receive packet counter */
+	uint32_t rfcs;	/* 0x224 receive FCS error counter */
+	uint32_t rmca;	/* 0x228 RMCA receive multicast packet counter */
+	uint32_t rbca;	/* 0x22C receive broadcast packet counter */
+	uint32_t rxcf;	/* 0x230 receive control frame packet counter */
+	uint32_t rxpf;	/* 0x234 receive pause frame packet counter */
+	uint32_t rxuo;	/* 0x238 receive unknown OP code counter */
+	uint32_t raln;	/* 0x23C receive alignment error counter */
+	uint32_t rflr;	/* 0x240 receive frame length error counter */
+	uint32_t rcde;	/* 0x244 receive code error counter */
+	uint32_t rcse;	/* 0x248 receive carrier sense error counter */
+	uint32_t rund;	/* 0x24C receive undersize packet counter */
+	uint32_t rovr;	/* 0x250 receive oversize packet counter */
+	uint32_t rfrg;	/* 0x254 receive fragments counter */
+	uint32_t rjbr;	/* 0x258 receive jabber counter */
+	uint32_t rdrp;	/* 0x25C receive drop */
+	uint32_t tbyt;	/* 0x260 transmit byte counter */
+	uint32_t tpkt;	/* 0x264 transmit packet counter */
+	uint32_t tmca;	/* 0x268 transmit multicast packet counter */
+	uint32_t tbca;	/* 0x26C transmit broadcast packet counter */
+	uint32_t txpf;	/* 0x270 transmit pause control frame counter */
+	uint32_t tdfr;	/* 0x274 transmit deferral packet counter */
+	uint32_t tedf;	/* 0x278 transmit excessive deferral packet counter */
+	uint32_t tscl;	/* 0x27C transmit single collision packet counter */
+	uint32_t tmcl;	/* 0x280 transmit multiple collision packet counter */
+	uint32_t tlcl;	/* 0x284 transmit late collision packet counter */
+	uint32_t txcl;	/* 0x288 transmit excessive collision packet counter */
+	uint32_t tncl;	/* 0x28C transmit total collision counter */
+	uint32_t reserved0290[1];
+	uint32_t tdrp;	/* 0x294 transmit drop frame counter */
+	uint32_t tjbr;	/* 0x298 transmit jabber frame counter */
+	uint32_t tfcs;	/* 0x29C transmit FCS error counter */
+	uint32_t txcf;	/* 0x2A0 transmit control frame counter */
+	uint32_t tovr;	/* 0x2A4 transmit oversize frame counter */
+	uint32_t tund;	/* 0x2A8 transmit undersize frame counter */
+	uint32_t tfrg;	/* 0x2AC transmit fragments frame counter */
+	uint32_t car1;	/* 0x2B0 carry register one register* */
+	uint32_t car2;	/* 0x2B4 carry register two register* */
+	uint32_t cam1;	/* 0x2B8 carry register one mask register */
+	uint32_t cam2;	/* 0x2BC carry register two mask register */
+	uint32_t reserved02c0[848];
+};
+
+/**
+ * struct dtsec_mib_grp_1_counters - MIB counter overflows
+ *
+ * @tr64:	Transmit and Receive 64 byte frame count.  Increment for each
+ *		good or bad frame, of any type, transmitted or received, which
+ *		is 64 bytes in length.
+ * @tr127:	Transmit and Receive 65 to 127 byte frame count.  Increments for
+ *		each good or bad frame of any type, transmitted or received,
+ *		which is 65-127 bytes in length.
+ * @tr255:	Transmit and Receive 128 to 255 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 128-255 bytes in length.
+ * @tr511:	Transmit and Receive 256 to 511 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 256-511 bytes in length.
+ * @tr1k:	Transmit and Receive 512 to 1023 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 512-1023 bytes in length.
+ * @trmax:	Transmit and Receive 1024 to 1518 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 1024-1518 bytes in length.
+ * @rfrg:	Receive fragments count.  Increments for each received frame
+ *		which is less than 64 bytes in length and contains an invalid
+ *		FCS.  This includes integral and non-integral lengths.
+ * @rjbr:	Receive jabber count.  Increments for received frames which
+ *		exceed 1518 (non VLAN) or 1522 (VLAN) bytes and contain an
+ *		invalid FCS.  This includes alignment errors.
+ * @rdrp:	Receive dropped packets count.  Increments for received frames
+ *		which are streamed to system but are later dropped due to lack
+ *		of system resources.  Does not increment for frames rejected due
+ *		to address filtering.
+ * @raln:	Receive alignment error count.  Increments for each received
+ *		frame from 64 to 1518 (non VLAN) or 1522 (VLAN) which contains
+ *		an invalid FCS and is not an integral number of bytes.
+ * @rund:	Receive undersize packet count.  Increments each time a frame is
+ *		received which is less than 64 bytes in length and contains a
+ *		valid FCS and is otherwise well formed.  This count does not
+ *		include range length errors.
+ * @rovr:	Receive oversize packet count.  Increments each time a frame is
+ *		received which exceeded 1518 (non VLAN) or 1522 (VLAN) and
+ *		contains a valid FCS and is otherwise well formed.
+ * @rbyt:	Receive byte count.  Increments by the byte count of frames
+ *		received, including those in bad packets, excluding preamble and
+ *		SFD but including FCS bytes.
+ * @rpkt:	Receive packet count.  Increments for each received frame
+ *		(including bad packets, all unicast, broadcast, and multicast
+ *		packets).
+ * @rmca:	Receive multicast packet count.  Increments for each multicast
+ *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
+ *		1522 (VLAN), excluding broadcast frames. This count does not
+ *		include range/length errors.
+ * @rbca:	Receive broadcast packet count.  Increments for each broadcast
+ *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
+ *		1522 (VLAN), excluding multicast frames. Does not include
+ *		range/length errors.
+ * @tdrp:	Transmit drop frame count.  Increments each time a memory error
+ *		or an underrun has occurred.
+ * @tncl:	Transmit total collision counter. Increments by the number of
+ *		collisions experienced during the transmission of a frame. Does
+ *		not increment for aborted frames.
+ *
+ * The structure contains a group of dTSEC HW specific counters relating to the
+ * standard RMON MIB Group 1 (or Ethernet statistics) counters.  This structure
+ * is counting only the carry events of the corresponding HW counters.
+ *
+ * tr64 to trmax notes: Frame sizes specified are considered excluding preamble
+ * and SFD but including FCS bytes.
+ */
+struct dtsec_mib_grp_1_counters {
+	uint64_t	rdrp;
+	uint64_t	tdrp;
+	uint64_t	rbyt;
+	uint64_t	rpkt;
+	uint64_t	rbca;
+	uint64_t	rmca;
+	uint64_t	raln;
+	uint64_t	rund;
+	uint64_t	rovr;
+	uint64_t	rfrg;
+	uint64_t	rjbr;
+	uint64_t	tncl;
+	uint64_t	tr64;
+	uint64_t	tr127;
+	uint64_t	tr255;
+	uint64_t	tr511;
+	uint64_t	tr1k;
+	uint64_t	trmax;
+};
+
+enum dtsec_stat_counters {
+	E_DTSEC_STAT_TR64,
+	E_DTSEC_STAT_TR127,
+	E_DTSEC_STAT_TR255,
+	E_DTSEC_STAT_TR511,
+	E_DTSEC_STAT_TR1K,
+	E_DTSEC_STAT_TRMAX,
+	E_DTSEC_STAT_TRMGV,
+	E_DTSEC_STAT_RBYT,
+	E_DTSEC_STAT_RPKT,
+	E_DTSEC_STAT_RMCA,
+	E_DTSEC_STAT_RBCA,
+	E_DTSEC_STAT_RXPF,
+	E_DTSEC_STAT_RALN,
+	E_DTSEC_STAT_RFLR,
+	E_DTSEC_STAT_RCDE,
+	E_DTSEC_STAT_RCSE,
+	E_DTSEC_STAT_RUND,
+	E_DTSEC_STAT_ROVR,
+	E_DTSEC_STAT_RFRG,
+	E_DTSEC_STAT_RJBR,
+	E_DTSEC_STAT_RDRP,
+	E_DTSEC_STAT_TFCS,
+	E_DTSEC_STAT_TBYT,
+	E_DTSEC_STAT_TPKT,
+	E_DTSEC_STAT_TMCA,
+	E_DTSEC_STAT_TBCA,
+	E_DTSEC_STAT_TXPF,
+	E_DTSEC_STAT_TNCL,
+	E_DTSEC_STAT_TDRP
+};
+
+
+/**
+ * struct dtsec_cfg - dTSEC configuration
+ *
+ * @halfdup_on:		Transmit half-duplex flow control, under software
+ *			control for 10/100-Mbps half-duplex media. If set,
+ *			back pressure is applied to media by raising carrier.
+ * @halfdup_retransmit:	Number of retransmission attempts following a collision.
+ *			If this is exceeded dTSEC aborts transmission due to
+ *			excessive collisions. The standard specifies the
+ *			attempt limit to be 15.
+ * @halfdup_coll_window:The number of bytes of the frame during which
+ *			collisions may occur. The default value of 55
+ *			corresponds to the frame byte at the end of the
+ *			standard 512-bit slot time window. If collisions are
+ *			detected after this byte, the late collision event is
+ *			asserted and transmission of current frame is aborted.
+ * @rx_drop_bcast:	Discard broadcast frames.  If set, all broadcast frames
+ *			will be discarded by dTSEC.
+ * @rx_short_frm:	Accept short frames.  If set, dTSEC will accept frames
+ *			of length 14..63 bytes.
+ * @rx_len_check:	Length check for received frames.  If set, the MAC
+ *			checks the frame's length field on receive to ensure it
+ *			matches the actual data field length. This only works
+ *			for received frames with length field less than 1500.
+ *			No check is performed for larger frames.
+ * @tx_pad_crc:		Pad and append CRC.  If set, the MAC pads all
+ *			transmitted short frames and appends a CRC to every
+ *			frame regardless of padding requirement.
+ * @tx_crc:		Transmission CRC enable.  If set, the MAC appends a CRC
+ *			to all frames.  If frames presented to the MAC have a
+ *			valid length and contain a valid CRC, @tx_crc should be
+ *			reset.
+ *			This field is ignored if @tx_pad_crc is set.
+ * @rx_ctrl_acc:	Control frame accept.  If set, this overrides 802.3
+ *			standard control frame behavior, and all Ethernet frames
+ *			that have an ethertype of 0x8808 are treated as normal
+ *			Ethernet frames and passed up to the packet interface on
+ *			a DA match.  Received pause control frames are passed to
+ *			the packet interface only if Rx flow control is also
+ *			disabled.  See dtsec_handle_rx_pause() function.
+ * @tx_pause_time:	Transmit pause time value.  This pause value is used as
+ *			part of the pause frame to be sent when a transmit pause
+ *			frame is initiated.  If set to 0 this disables
+ *			transmission of pause frames.
+ * @rx_preamble:	Receive preamble enable.  If set, the MAC recovers the
+ *			received Ethernet 7-byte preamble and passes it to the
+ *			packet interface at the start of each received frame.
+ *			This field should be reset for internal MAC loop-back
+ *			mode.
+ * @tx_preamble:	User defined preamble enable for transmitted frames.
+ *			If set, a user-defined preamble must passed to the MAC
+ *			and it is transmitted instead of the standard preamble.
+ * @preamble_len:	Length, in bytes, of the preamble field preceding each
+ *			Ethernet start-of-frame delimiter byte.  The default
+ *			value of 0x7 should be used in order to guarantee
+ *			reliable operation with IEEE 802.3 compliant hardware.
+ * @rx_prepend:		Packet alignment padding length.  The specified number
+ *			of bytes (1-31) of zero padding are inserted before the
+ *			start of each received frame.  For Ethernet, where
+ *			optional preamble extraction is enabled, the padding
+ *			appears before the preamble, otherwise the padding
+ *			precedes the layer 2 header.
+ *
+ * This structure contains basic dTSEC configuration and must be passed to
+ * dtsec_init() function.  A default set of configuration values can be obtained
+ * by calling dtsec_defconfig().
+ */
+struct dtsec_cfg {
+	bool		halfdup_on;
+	bool		halfdup_alt_backoff_en;
+	bool		halfdup_excess_defer;
+	bool		halfdup_no_backoff;
+	bool		halfdup_bp_no_backoff;
+	uint8_t		halfdup_alt_backoff_val;
+	uint16_t	halfdup_retransmit;
+	uint16_t	halfdup_coll_window;
+	bool		rx_drop_bcast;
+	bool		rx_short_frm;
+	bool		rx_len_check;
+	bool		tx_pad_crc;
+	bool		tx_crc;
+	bool		rx_ctrl_acc;
+	unsigned short	tx_pause_time;
+	unsigned short	tbipa;
+	bool		ptp_tsu_en;
+	bool		ptp_exception_en;
+	bool		rx_preamble;
+	bool		tx_preamble;
+	unsigned char	preamble_len;
+	unsigned char	rx_prepend;
+	bool		loopback;
+	bool		rx_time_stamp_en;
+	bool		tx_time_stamp_en;
+	bool		rx_flow;
+	bool		tx_flow;
+	bool		rx_group_hash_exd;
+	bool		rx_promisc;
+	uint8_t		tbi_phy_addr;
+	uint16_t	tx_pause_time_extd;
+	uint16_t	maximum_frame;
+	uint32_t	non_back_to_back_ipg1;
+	uint32_t	non_back_to_back_ipg2;
+	uint32_t	min_ifg_enforcement;
+	uint32_t	back_to_back_ipg;
+};
+
+
+/**
+ * dtsec_defconfig() - Get default dTSEC configuration
+ * @cfg:	pointer to configuration structure.
+ *
+ * Call this function to obtain a default set of configuration values for
+ * initializing dTSEC.  The user can overwrite any of the values before calling
+ * dtsec_init(), if specific configuration needs to be applied.
+ */
+void dtsec_defconfig(struct dtsec_cfg *cfg);
+
+/**
+ * dtsec_init() - Init dTSEC hardware block
+ * @regs:		Pointer to dTSEC register block
+ * @cfg:		dTSEC configuration data
+ * @iface_mode:		dTSEC interface mode, the type of MAC - PHY interface.
+ * @iface_speed:	1G or 10G
+ * @macaddr:		MAC station address to be assigned to the device
+ * @fm_rev_maj:		major rev number
+ * @fm_rev_min:		minor rev number
+ * @exceptions_mask:	initial exceptions mask
+ *
+ * This function initializes dTSEC and applies basic configuration.
+ *
+ * dTSEC initialization sequence:
+ * Before enabling Rx/Tx call dtsec_set_address() to set MAC address,
+ * dtsec_adjust_link() to configure interface speed and duplex and finally
+ * dtsec_enable_tx()/dtsec_enable_rx() to start transmission and reception.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
+		enum enet_interface iface_mode,
+		enum enet_speed iface_speed,
+		uint8_t *macaddr, uint8_t fm_rev_maj,
+		uint8_t fm_rev_min,
+		uint32_t exception_mask);
+
+/**
+ * dtsec_get_revision() - Get dTSEC hardware revision
+ * @regs:   Pointer to dTSEC register block
+ *
+ * Returns dtsec_id content
+ *
+ * Call this function to obtain the dTSEC hardware version.
+ */
+uint32_t dtsec_get_revision(struct dtsec_regs *regs);
+
+/**
+ * dtsec_set_uc_promisc() - Sets unicast promiscuous mode
+ * @regs:	Pointer to dTSEC register block
+ * @enable:	Enable unicast promiscuous mode
+ *
+ * Use this function to enable/disable dTSEC L2 address filtering.  If the
+ * address filtering is disabled all unicast packets are accepted.
+ * To set dTSEC in promiscuous mode call both dtsec_set_uc_promisc() and
+ * dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
+ * addresses.
+ */
+void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
+
+/**
+ * dtsec_adjust_link() - Adjust dTSEC speed/duplex settings
+ * @regs:	Pointer to dTSEC register block
+ * @iface_mode: dTSEC interface mode
+ * @speed:	Link speed
+ * @full_dx:	True for full-duplex, false for half-duplex.
+ *
+ * This function configures the MAC to function and the desired rates.  Use it
+ * to configure dTSEC after dtsec_init() and whenever the link speed changes
+ * (for instance following PHY auto-negociation).
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_adjust_link(struct dtsec_regs *regs,
+		enum enet_interface iface_mode,
+		enum enet_speed speed, bool full_dx);
+
+/**
+ * dtsec_set_tbi_phy_addr() - Updates TBI address field
+ * @regs:	Pointer to dTSEC register block
+ * @address:	Valid PHY address in the range of 1 to 31. 0 is reserved.
+ *
+ * In SGMII mode, the dTSEC's TBIPA field must contain a valid TBI PHY address
+ * so that the associated TBI PHY (i.e. the link) may be initialized.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
+		uint8_t addr);
+
+/**
+ * dtsec_disable() - Disable dTSEC Tx and Rx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	disable rx side
+ * @apply_tx:	disable tx side
+ *
+ * This function disables Tx and Rx in dTSEC.
+ */
+void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * dtsec_enable() - Enable dTSEC Tx and Tx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	enable rx side
+ * @apply_tx:	enable tx side
+ *
+ * This function resets Tx and Rx graceful stop bit and enables dTSEC Tx and Rx.
+ */
+void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * dtsec_set_mac_address() - Set MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ *
+ * This function sets MAC station address.  To enable unicast reception call
+ * this after dtsec_init().  While promiscuous mode is disabled dTSEC will match
+ * the destination address of received unicast frames against this address.
+ */
+void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * dtsec_get_mac_address() - Query MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ */
+void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * dtsec_set_max_frame_len() - Set max frame length
+ * @regs:	Pointer to dTSEC register block
+ * @length:	Max frame length.
+ *
+ * Sets maximum frame length for received and transmitted frames.  Frames that
+ * exceeds this length are truncated.
+ */
+
+void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length);
+
+
+/**
+ * dtsec_get_max_frame_len() - Query max frame length
+ * @regs:	Pointer to dTSEC register block
+ *
+ * Returns: the current value of the maximum frame length.
+ */
+uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs);
+
+
+/**
+ * dtsec_handle_rx_pause() - Configure pause frame handling
+ * @regs:	Pointer to dTSEC register block
+ * @en:		Enable pause frame handling in dTSEC
+ *
+ * If enabled, dTSEC will handle pause frames internally.  This must be disabled
+ * if dTSEC is set in half-duplex mode.
+ * If pause frame handling is disabled and &dtsec_cfg.rx_ctrl_acc is set, pause
+ * frames will be transferred to the packet interface just like regular Ethernet
+ * frames.
+ */
+void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en);
+
+/**
+ * dtsec_set_tx_pause_time() - Configure Tx pause time
+ * @regs:	Pointer to dTSEC register block
+ * @time:	Time value included in pause frames
+ *
+ * Call this function to set the time value used in transmitted pause frames.
+ * If time is 0, transmission of pause frames is disabled
+ */
+void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time);
+
+/**
+ * dtsec_ack_event() - Acknowledge handled events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Events to acknowledge
+ *
+ * After handling events signaled by dTSEC in either polling or interrupt mode,
+ * call this function to reset the associated status bits in dTSEC event
+ * register.
+ */
+void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_get_event() - Returns currently asserted events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to obtain a bit-mask of events that are currently asserted
+ * in dTSEC, taken from IEVENT register.
+ *
+ * Returns: a bit-mask of events asserted in dTSEC.
+ */
+uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
+/**
+ * dtsec_get_interrupt_mask() - Returns a bit-mask of enabled interrupts
+ * @regs:   Pointer to dTSEC register block
+ *
+ * Call this function to obtain a bit-mask of enabled interrupts
+ * in dTSEC, taken from IMASK register.
+ *
+ * Returns: a bit-mask of enabled interrupts in dTSEC.
+ */
+uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs);
+
+void dtsec_clear_addr_in_paddr  (struct dtsec_regs *regs,
+                                 uint8_t paddr_num);
+
+void dtsec_add_addr_in_paddr    (struct dtsec_regs *regs,
+                                 uint64_t addr,
+                                 uint8_t paddr_num);
+
+void dtsec_enable_tmr_interrupt (struct dtsec_regs *regs);
+
+void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs);
+
+/**
+ * dtsec_disable_interrupt() - Disables interrupts for the specified events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to disable interrupts in dTSEC for the specified events.
+ * To enable interrupts use dtsec_enable_interrupt().
+ */
+void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_enable_interrupt() - Enable interrupts for the specified events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to enable interrupts in dTSEC for the specified events.
+ * To disable interrupts use dtsec_disable_interrupt().
+ */
+void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_set_ts() - Enables dTSEC timestamps
+ * @regs:	Pointer to dTSEC register block
+ * @en:		true to enable timestamps, false to disable them
+ *
+ * Call this function to enable/disable dTSEC timestamps.  This affects both
+ * Tx and Rx.
+ */
+void dtsec_set_ts(struct dtsec_regs *regs, bool en);
+
+/**
+ * dtsec_set_bucket() - Enables/disables a filter bucket
+ * @regs:   Pointer to dTSEC register block
+ * @bucket: Bucket index
+ * @enable: true/false to enable/disable this bucket
+ *
+ * This function enables or disables the specified bucket.  Enabling a bucket
+ * associated with an address configures dTSEC to accept received packets
+ * with that destination address.
+ * Multiple addresses may be associated with the same bucket.  Disabling a
+ * bucket will affect all addresses associated with that bucket. A bucket that
+ * is enabled requires further filtering and verification in the upper layers
+ *
+ */
+void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
+
+/**
+ * dtsec_reset_filter_table() - Resets the address filtering table
+ * @regs:	Pointer to dTSEC register block
+ * @mcast:	Reset multicast entries
+ * @ucast:	Reset unicast entries
+ *
+ * Resets all entries in L2 address filter table.  After calling this function
+ * all buckets enabled using dtsec_set_bucket() will be disabled.
+ * If dtsec_init_filter_table() was called with @unicast_hash set to false,
+ * @ucast argument is ignored.
+ * This does not affect the primary nor the 15 additional addresses configured
+ * using dtsec_set_address() or dtsec_set_match_address().
+ */
+void  dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
+
+/**
+ * dtsec_set_mc_promisc() - Set multicast promiscous mode
+ * @regs:	Pointer to dTSEC register block
+ * @enable:	Enable multicast promiscous mode
+ *
+ * Call this to enable/disable L2 address filtering for multicast packets.
+ */
+void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
+
+/* statistics APIs */
+
+/**
+ * dtsec_set_stat_level() - Enable a group of MIB statistics counters
+ * @regs:	Pointer to dTSEC register block
+ * @level:	Specifies a certain group of dTSEC MIB HW counters or _all_,
+ *		to specify all the existing counters.
+ *		If set to _none_, it disables all the counters.
+ *
+ * Enables the MIB statistics hw counters and sets up the carry interrupt
+ * masks for the counters corresponding to the @level input parameter.
+ *
+ * Returns: error if invalid @level value given.
+ */
+int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
+
+/**
+ * dtsec_reset_stat() - Completely resets all dTSEC HW counters
+ * @regs:	Pointer to dTSEC register block
+ */
+void dtsec_reset_stat(struct dtsec_regs *regs);
+
+/**
+ * dtsec_get_clear_carry_regs() - Read and clear carry bits (CAR1-2 registers)
+ * @regs:	Pointer to dTSEC register block
+ * @car1:	car1 register value
+ * @car2:	car2 register value
+ *
+ * When set, the carry bits signal that an overflow occurred on the
+ * corresponding counters.
+ * Note that the carry bits (CAR1-2 registers) will assert the
+ * %DTSEC_IEVENT_MSRO interrupt if unmasked (via CAM1-2 regs).
+ *
+ * Returns: true if overflow occurred, otherwise - false
+ */
+bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
+				uint32_t *car1, uint32_t *car2);
+
+uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs);
+
+uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
+				enum dtsec_stat_counters reg_name);
+
+void dtsec_start_tx(struct dtsec_regs *regs);
+void dtsec_start_rx(struct dtsec_regs *regs);
+void dtsec_stop_rx(struct dtsec_regs *regs);
+void dtsec_stop_tx(struct dtsec_regs *regs);
+uint32_t dtsec_get_rctrl(struct dtsec_regs *regs);
+
+#endif /* __FSL_FMAN_DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_kg.h
new file mode 100644
index 0000000..010e4b7
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_kg.h
@@ -0,0 +1,514 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_KG_H
+#define __FSL_FMAN_KG_H
+
+#include "common/general.h"
+
+#define FM_KG_NUM_OF_GENERIC_REGS	8 /**< Num of generic KeyGen regs */
+#define FMAN_MAX_NUM_OF_HW_PORTS	64
+/**< Total num of masks allowed on KG extractions */
+#define FM_KG_EXTRACT_MASKS_NUM		4
+#define FM_KG_NUM_CLS_PLAN_ENTR		8 /**< Num of class. plan regs */
+#define FM_KG_CLS_PLAN_GRPS_NUM		32 /**< Max num of class. groups */
+
+struct fman_kg_regs {
+	uint32_t fmkg_gcr;
+	uint32_t res004;
+	uint32_t res008;
+	uint32_t fmkg_eer;
+	uint32_t fmkg_eeer;
+	uint32_t res014;
+	uint32_t res018;
+	uint32_t fmkg_seer;
+	uint32_t fmkg_seeer;
+	uint32_t fmkg_gsr;
+	uint32_t fmkg_tpc;
+	uint32_t fmkg_serc;
+	uint32_t res030[4];
+	uint32_t fmkg_fdor;
+	uint32_t fmkg_gdv0r;
+	uint32_t fmkg_gdv1r;
+	uint32_t res04c[6];
+	uint32_t fmkg_feer;
+	uint32_t res068[38];
+	uint32_t fmkg_indirect[63];
+	uint32_t fmkg_ar;
+};
+
+struct fman_kg_scheme_regs {
+	uint32_t kgse_mode; /**< MODE */
+	uint32_t kgse_ekfc; /**< Extract Known Fields Command */
+	uint32_t kgse_ekdv; /**< Extract Known Default Value */
+	uint32_t kgse_bmch; /**< Bit Mask Command High */
+	uint32_t kgse_bmcl; /**< Bit Mask Command Low */
+	uint32_t kgse_fqb; /**< Frame Queue Base */
+	uint32_t kgse_hc; /**< Hash Command */
+	uint32_t kgse_ppc; /**< Policer Profile Command */
+	uint32_t kgse_gec[FM_KG_NUM_OF_GENERIC_REGS];
+				/**< Generic Extract Command */
+	uint32_t kgse_spc; /**< KeyGen Scheme Entry Statistic Packet Counter */
+	uint32_t kgse_dv0; /**< KeyGen Scheme Entry Default Value 0 */
+	uint32_t kgse_dv1; /**< KeyGen Scheme Entry Default Value 1 */
+	uint32_t kgse_ccbs; /**< KeyGen Scheme Entry Coarse Classification Bit*/
+	uint32_t kgse_mv; /**< KeyGen Scheme Entry Match vector */
+	uint32_t kgse_om; /**< KeyGen Scheme Entry Operation Mode bits */
+	uint32_t kgse_vsp; /**< KeyGen Scheme Entry Virtual Storage Profile */
+};
+
+struct fman_kg_pe_regs{
+	uint32_t fmkg_pe_sp;
+	uint32_t fmkg_pe_cpp;
+};
+
+struct fman_kg_cp_regs {
+	uint32_t kgcpe[FM_KG_NUM_CLS_PLAN_ENTR];
+};
+
+
+#define FM_KG_KGAR_GO				0x80000000
+#define FM_KG_KGAR_READ				0x40000000
+#define FM_KG_KGAR_WRITE			0x00000000
+#define FM_KG_KGAR_SEL_SCHEME_ENTRY		0x00000000
+#define FM_KG_KGAR_SCM_WSEL_UPDATE_CNT		0x00008000
+
+#define KG_SCH_PP_SHIFT_HIGH			0x80000000
+#define KG_SCH_PP_NO_GEN			0x10000000
+#define KG_SCH_PP_SHIFT_LOW			0x0000F000
+#define KG_SCH_MODE_NIA_PLCR			0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
+#define KG_SCH_BITMASK_MASK			0x000000FF
+#define KG_SCH_GEN_VALID			0x80000000
+#define KG_SCH_GEN_MASK				0x00FF0000
+#define FM_PCD_KG_KGAR_ERR			0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY	0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY		0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP		0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP	0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK		0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID		0x80000000
+#define KG_SCH_HASH_CONFIG_SYM			0x40000000
+
+#define FM_EX_KG_DOUBLE_ECC			0x80000000
+#define FM_EX_KG_KEYSIZE_OVERFLOW		0x40000000
+
+/* ECC capture register */
+#define KG_FMKG_SERC_CAP			0x80000000
+#define KG_FMKG_SERC_CET			0x40000000
+#define KG_FMKG_SERC_CNT_MSK			0x00FF0000
+#define KG_FMKG_SERC_CNT_SHIFT			16
+#define KG_FMKG_SERC_ADDR_MSK			0x000003FF
+
+/* Masks */
+#define FM_KG_KGGCR_EN				0x80000000
+#define KG_SCH_GEN_VALID			0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
+#define KG_ERR_TYPE_DOUBLE			0x40000000
+#define KG_ERR_ADDR_MASK			0x00000FFF
+#define KG_SCH_MODE_EN				0x80000000
+
+/* shifts */
+#define FM_KG_KGAR_NUM_SHIFT			16
+#define FM_KG_PE_CPP_MASK_SHIFT			16
+#define FM_KG_KGAR_WSEL_SHIFT			8
+
+#define FM_KG_SCH_GEN_HT_INVALID		0
+
+#define FM_KG_MASK_SEL_GEN_BASE			0x20
+
+#define KG_GET_MASK_SEL_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: (shift) = 26; break;	\
+	case 1: (shift) = 20; break;	\
+	case 2: (shift) = 10; break;	\
+	case 3: (shift) = 4; break;	\
+	default: (shift) = 0;		\
+}
+
+#define KG_GET_MASK_OFFSET_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: (shift) = 16; break;	\
+	case 1: (shift) = 0; break;	\
+	case 2: (shift) = 28; break;	\
+	case 3: (shift) = 24; break;	\
+	default: (shift) = 0;		\
+}
+
+#define KG_GET_MASK_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: shift = 24; break;	\
+	case 1: shift = 16; break;	\
+	case 2: shift = 8;  break;	\
+	case 3: shift = 0;  break;	\
+	default: shift = 0;		\
+}
+
+/* Port entry CPP register */
+#define FMAN_KG_PE_CPP_MASK_SHIFT	16
+
+/* Scheme registers */
+#define FMAN_KG_SCH_MODE_EN		0x80000000
+#define FMAN_KG_SCH_MODE_NIA_PLCR	0x40000000
+#define FMAN_KG_SCH_MODE_CCOBASE_SHIFT	24
+
+#define FMAN_KG_SCH_DEF_MAC_ADDR_SHIFT	30
+#define FMAN_KG_SCH_DEF_VLAN_TCI_SHIFT	28
+#define FMAN_KG_SCH_DEF_ETYPE_SHIFT	26
+#define FMAN_KG_SCH_DEF_PPP_SID_SHIFT	24
+#define FMAN_KG_SCH_DEF_PPP_PID_SHIFT	22
+#define FMAN_KG_SCH_DEF_MPLS_SHIFT	20
+#define FMAN_KG_SCH_DEF_IP_ADDR_SHIFT	18
+#define FMAN_KG_SCH_DEF_PTYPE_SHIFT	16
+#define FMAN_KG_SCH_DEF_IP_TOS_TC_SHIFT	14
+#define FMAN_KG_SCH_DEF_IPv6_FL_SHIFT	12
+#define FMAN_KG_SCH_DEF_IPSEC_SPI_SHIFT	10
+#define FMAN_KG_SCH_DEF_L4_PORT_SHIFT	8
+#define FMAN_KG_SCH_DEF_TCP_FLG_SHIFT	6
+
+#define FMAN_KG_SCH_GEN_VALID		0x80000000
+#define FMAN_KG_SCH_GEN_SIZE_MAX	16
+#define FMAN_KG_SCH_GEN_OR		0x00008000
+
+#define FMAN_KG_SCH_GEN_DEF_SHIFT	29
+#define FMAN_KG_SCH_GEN_SIZE_SHIFT	24
+#define FMAN_KG_SCH_GEN_MASK_SHIFT	16
+#define FMAN_KG_SCH_GEN_HT_SHIFT	8
+
+#define FMAN_KG_SCH_HASH_HSHIFT_SHIFT	24
+#define FMAN_KG_SCH_HASH_HSHIFT_MAX	0x28
+#define FMAN_KG_SCH_HASH_SYM		0x40000000
+#define FMAN_KG_SCH_HASH_NO_FQID_GEN	0x80000000
+
+#define FMAN_KG_SCH_PP_SH_SHIFT		27
+#define FMAN_KG_SCH_PP_SL_SHIFT		12
+#define FMAN_KG_SCH_PP_SH_MASK		0x80000000
+#define FMAN_KG_SCH_PP_SL_MASK		0x0000F000
+#define FMAN_KG_SCH_PP_SHIFT_MAX	0x17
+#define FMAN_KG_SCH_PP_MASK_SHIFT	16
+#define FMAN_KG_SCH_PP_NO_GEN		0x10000000
+
+enum fman_kg_gen_extract_src {
+	E_FMAN_KG_GEN_EXTRACT_ETH,
+	E_FMAN_KG_GEN_EXTRACT_ETYPE,
+	E_FMAN_KG_GEN_EXTRACT_SNAP,
+	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_1,
+	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_N,
+	E_FMAN_KG_GEN_EXTRACT_PPPoE,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_1,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_2,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_3,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_N,
+	E_FMAN_KG_GEN_EXTRACT_IPv4_1,
+	E_FMAN_KG_GEN_EXTRACT_IPv6_1,
+	E_FMAN_KG_GEN_EXTRACT_IPv4_2,
+	E_FMAN_KG_GEN_EXTRACT_IPv6_2,
+	E_FMAN_KG_GEN_EXTRACT_MINENCAP,
+	E_FMAN_KG_GEN_EXTRACT_IP_PID,
+	E_FMAN_KG_GEN_EXTRACT_GRE,
+	E_FMAN_KG_GEN_EXTRACT_TCP,
+	E_FMAN_KG_GEN_EXTRACT_UDP,
+	E_FMAN_KG_GEN_EXTRACT_SCTP,
+	E_FMAN_KG_GEN_EXTRACT_DCCP,
+	E_FMAN_KG_GEN_EXTRACT_IPSEC_AH,
+	E_FMAN_KG_GEN_EXTRACT_IPSEC_ESP,
+	E_FMAN_KG_GEN_EXTRACT_SHIM_1,
+	E_FMAN_KG_GEN_EXTRACT_SHIM_2,
+	E_FMAN_KG_GEN_EXTRACT_FROM_DFLT,
+	E_FMAN_KG_GEN_EXTRACT_FROM_FRAME_START,
+	E_FMAN_KG_GEN_EXTRACT_FROM_PARSE_RESULT,
+	E_FMAN_KG_GEN_EXTRACT_FROM_END_OF_PARSE,
+	E_FMAN_KG_GEN_EXTRACT_FROM_FQID
+};
+
+struct fman_kg_ex_ecc_attr
+{
+	bool		valid;
+	bool		double_ecc;
+	uint16_t	addr;
+	uint8_t		single_ecc_count;
+};
+
+enum fman_kg_def_select
+{
+	E_FMAN_KG_DEF_GLOBAL_0,
+	E_FMAN_KG_DEF_GLOBAL_1,
+	E_FMAN_KG_DEF_SCHEME_0,
+	E_FMAN_KG_DEF_SCHEME_1
+};
+
+struct fman_kg_extract_def
+{
+	enum fman_kg_def_select	mac_addr;
+	enum fman_kg_def_select	vlan_tci;
+	enum fman_kg_def_select	etype;
+	enum fman_kg_def_select	ppp_sid;
+	enum fman_kg_def_select	ppp_pid;
+	enum fman_kg_def_select	mpls;
+	enum fman_kg_def_select	ip_addr;
+	enum fman_kg_def_select	ptype;
+	enum fman_kg_def_select	ip_tos_tc;
+	enum fman_kg_def_select	ipv6_fl;
+	enum fman_kg_def_select	ipsec_spi;
+	enum fman_kg_def_select	l4_port;
+	enum fman_kg_def_select	tcp_flg;
+};
+
+enum fman_kg_gen_extract_type
+{
+	E_FMAN_KG_HASH_EXTRACT,
+	E_FMAN_KG_OR_EXTRACT
+};
+
+struct fman_kg_gen_extract_params
+{
+	/* Hash or Or-ed extract */
+	enum fman_kg_gen_extract_type	type;
+	enum fman_kg_gen_extract_src	src;
+	bool				no_validation;
+	/* Extraction offset from the header location specified above */
+	uint8_t				offset;
+	/* Size of extraction for FMAN_KG_HASH_EXTRACT,
+	 * hash result shift for FMAN_KG_OR_EXTRACT */
+	uint8_t				extract;
+	uint8_t				mask;
+	/* Default value to use when header specified
+	 * by fman_kg_gen_extract_src doesn't present */
+	enum fman_kg_def_select		def_val;
+};
+
+struct fman_kg_extract_mask
+{
+	/**< Indication if mask is on known field extraction or
+	 * on general extraction; TRUE for known field */
+	bool		is_known;
+	/**< One of FMAN_KG_EXTRACT_xxx defines for known fields mask and
+	 * generic register index for generic extracts mask */
+	uint32_t	field_or_gen_idx;
+	/**< Byte offset from start of the extracted data specified
+	 * by field_or_gen_idx */
+	uint8_t		offset;
+	/**< Byte mask (selected bits will be used) */
+	uint8_t		mask;
+};
+
+struct fman_kg_extract_params
+{
+	/* Or-ed mask of FMAN_KG_EXTRACT_xxx defines */
+	uint32_t				known_fields;
+	struct fman_kg_extract_def		known_fields_def;
+	/* Number of entries in gen_extract */
+	uint8_t					gen_extract_num;
+	struct fman_kg_gen_extract_params	gen_extract[FM_KG_NUM_OF_GENERIC_REGS];
+	/* Number of entries in masks */
+	uint8_t					masks_num;
+	struct fman_kg_extract_mask		masks[FM_KG_EXTRACT_MASKS_NUM];
+	uint32_t				def_scheme_0;
+	uint32_t				def_scheme_1;
+};
+
+struct fman_kg_hash_params
+{
+	bool		use_hash;
+	uint8_t		shift_r;
+	uint32_t	mask; /**< 24-bit mask */
+	bool		sym; /**< Symmetric hash for src and dest pairs */
+};
+
+struct fman_kg_pp_params
+{
+	uint8_t		base;
+	uint8_t		shift;
+	uint8_t		mask;
+	bool		bypass_pp_gen;
+};
+
+struct fman_kg_cc_params
+{
+	uint8_t		base_offset;
+	uint32_t	qlcv_bits_sel;
+};
+
+enum fman_pcd_engine
+{
+	E_FMAN_PCD_INVALID = 0,	/**< Invalid PCD engine indicated*/
+	E_FMAN_PCD_DONE,	/**< No PCD Engine indicated */
+	E_FMAN_PCD_KG,		/**< Keygen indicated */
+	E_FMAN_PCD_CC,		/**< Coarse classification indicated */
+	E_FMAN_PCD_PLCR,	/**< Policer indicated */
+	E_FMAN_PCD_PRS		/**< Parser indicated */
+};
+
+struct fman_kg_cls_plan_params
+{
+	uint8_t entries_mask;
+	uint32_t mask_vector[FM_KG_NUM_CLS_PLAN_ENTR];
+};
+
+struct fman_kg_scheme_params
+{
+	uint32_t			match_vector;
+	struct fman_kg_extract_params	extract_params;
+	struct fman_kg_hash_params	hash_params;
+	uint32_t			base_fqid;
+	/* What we do w/features supported per FM version ?? */
+	bool				bypass_fqid_gen;
+	struct fman_kg_pp_params	policer_params;
+	struct fman_kg_cc_params	cc_params;
+	bool				update_counter;
+	/**< counter_value: Set scheme counter to the specified value;
+	 * relevant only when update_counter = TRUE. */
+	uint32_t			counter_value;
+	enum fman_pcd_engine		next_engine;
+	/**< Next engine action code */
+	uint32_t			next_engine_action;
+};
+
+
+
+int fman_kg_write_ar_wait(struct fman_kg_regs *regs, uint32_t fmkg_ar);
+void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add);
+void fman_kg_write_cpp(struct fman_kg_regs *regs, uint32_t cpp);
+void fman_kg_get_event(struct fman_kg_regs *regs,
+			uint32_t *event,
+			uint32_t *scheme_idx);
+void fman_kg_init(struct fman_kg_regs *regs,
+			uint32_t exceptions,
+			uint32_t dflt_nia);
+void fman_kg_enable_scheme_interrupts(struct fman_kg_regs *regs);
+void fman_kg_enable(struct fman_kg_regs *regs);
+void fman_kg_disable(struct fman_kg_regs *regs);
+int fman_kg_write_bind_cls_plans(struct fman_kg_regs *regs,
+					uint8_t hwport_id,
+					uint32_t bind_cls_plans);
+int fman_kg_build_bind_cls_plans(uint8_t grp_base,
+					uint8_t grp_mask,
+					uint32_t *bind_cls_plans);
+int fman_kg_write_bind_schemes(struct fman_kg_regs *regs,
+				uint8_t hwport_id,
+				uint32_t schemes);
+int fman_kg_write_cls_plan(struct fman_kg_regs *regs,
+				uint8_t grp_id,
+				uint8_t entries_mask,
+				uint8_t hwport_id,
+				struct fman_kg_cp_regs *cls_plan_regs);
+int fman_kg_build_cls_plan(struct fman_kg_cls_plan_params *params,
+				struct fman_kg_cp_regs *cls_plan_regs);
+uint32_t fman_kg_get_schemes_total_counter(struct fman_kg_regs *regs);
+int fman_kg_set_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t counter);
+int fman_kg_get_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t *counter);
+int fman_kg_delete_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id);
+int fman_kg_write_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				struct fman_kg_scheme_regs *scheme_regs,
+				bool update_counter);
+int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
+				struct fman_kg_scheme_regs *scheme_regs);
+void fman_kg_get_capture(struct fman_kg_regs *regs,
+				struct fman_kg_ex_ecc_attr *ecc_attr,
+				bool clear);
+void fman_kg_get_exception(struct fman_kg_regs *regs,
+				uint32_t *events,
+				uint32_t *scheme_ids,
+				bool clear);
+void fman_kg_set_exception(struct fman_kg_regs *regs,
+				uint32_t exception,
+				bool enable);
+void fman_kg_set_dflt_val(struct fman_kg_regs *regs,
+				uint8_t def_id,
+				uint32_t val);
+void fman_kg_set_data_after_prs(struct fman_kg_regs *regs, uint8_t offset);
+
+
+	
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+#define KG_NIA_ORDER_RESTOR	0x00800000
+#define KG_NIA_ENG_FM_CTL	0x00000000
+#define KG_NIA_ENG_PRS		0x00440000
+#define KG_NIA_ENG_KG		0x00480000
+#define KG_NIA_ENG_PLCR		0x004C0000
+#define KG_NIA_ENG_BMI		0x00500000
+#define KG_NIA_ENG_QMI_ENQ	0x00540000
+#define KG_NIA_ENG_QMI_DEQ	0x00580000
+#define KG_NIA_ENG_MASK		0x007C0000
+
+#define KG_NIA_AC_MASK		0x0003FFFF
+
+#define KG_NIA_INVALID		0xFFFFFFFF
+
+static __inline__ uint32_t fm_kg_build_nia(enum fman_pcd_engine next_engine,
+					uint32_t next_engine_action)
+{
+	uint32_t nia;
+
+	if (next_engine_action & ~KG_NIA_AC_MASK)
+		return KG_NIA_INVALID;
+
+	switch (next_engine) {
+	case E_FMAN_PCD_DONE:
+		nia = KG_NIA_ENG_BMI | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_KG:
+		nia = KG_NIA_ENG_KG | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_CC:
+		nia = KG_NIA_ENG_FM_CTL | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_PLCR:
+		nia = KG_NIA_ENG_PLCR | next_engine_action;
+		break;
+
+	default:
+		nia = KG_NIA_INVALID;
+	}
+
+	return nia;
+}
+
+#endif /* __FSL_FMAN_KG_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_memac.h
new file mode 100644
index 0000000..5cf48c7
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_memac.h
@@ -0,0 +1,381 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FSL_FMAN_MEMAC_H
+#define __FSL_FMAN_MEMAC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+
+#define MEMAC_NUM_OF_PADDRS 7 /* Num of additional exact match MAC adr regs */
+
+/* Control and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_MG		0x80000000 /* 00 Magic Packet detection */
+#define CMD_CFG_REG_LOWP_RXETY	0x01000000 /* 07 Rx low power indication */
+#define CMD_CFG_TX_LOWP_ENA	0x00800000 /* 08 Tx Low Power Idle Enable */
+#define CMD_CFG_SFD_ANY		0x00200000 /* 10 Disable SFD check */
+#define CMD_CFG_PFC_MODE	0x00080000 /* 12 Enable PFC */
+#define CMD_CFG_NO_LEN_CHK	0x00020000 /* 14 Payload length check disable */
+#define CMD_CFG_SEND_IDLE	0x00010000 /* 15 Force idle generation */
+#define CMD_CFG_CNT_FRM_EN	0x00002000 /* 18 Control frame rx enable */
+#define CMD_CFG_SW_RESET	0x00001000 /* 19 S/W Reset, self clearing bit */
+#define CMD_CFG_TX_PAD_EN	0x00000800 /* 20 Enable Tx padding of frames */
+#define CMD_CFG_LOOPBACK_EN	0x00000400 /* 21 XGMII/GMII loopback enable */
+#define CMD_CFG_TX_ADDR_INS	0x00000200 /* 22 Tx source MAC addr insertion */
+#define CMD_CFG_PAUSE_IGNORE	0x00000100 /* 23 Ignore Pause frame quanta */
+#define CMD_CFG_PAUSE_FWD	0x00000080 /* 24 Terminate/frwd Pause frames */
+#define CMD_CFG_CRC_FWD		0x00000040 /* 25 Terminate/frwd CRC of frames */
+#define CMD_CFG_PAD_EN		0x00000020 /* 26 Frame padding removal */
+#define CMD_CFG_PROMIS_EN	0x00000010 /* 27 Promiscuous operation enable */
+#define CMD_CFG_WAN_MODE	0x00000008 /* 28 WAN mode enable */
+#define CMD_CFG_RX_EN		0x00000002 /* 30 MAC receive path enable */
+#define CMD_CFG_TX_EN		0x00000001 /* 31 MAC transmit path enable */
+
+/* Interface Mode Register (IF_MODE) */
+#define IF_MODE_MASK		0x00000003 /* 30-31 Mask on i/f mode bits */
+#define IF_MODE_XGMII		0x00000000 /* 30-31 XGMII (10G) interface */
+#define IF_MODE_GMII		0x00000002 /* 30-31 GMII (1G) interface */
+#define IF_MODE_RGMII		0x00000004
+#define IF_MODE_RGMII_AUTO	0x00008000
+
+/* Hash table Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT	26
+#define HASH_CTRL_MCAST_EN	0x00000100 /* 23 Mcast frame rx for hash */
+#define HASH_CTRL_ADDR_MASK	0x0000003F /* 26-31 Hash table address code */
+
+#define GROUP_ADDRESS		0x0000010000000000LL /* MAC mcast indication */
+#define HASH_TABLE_SIZE		64 /* Hash tbl size */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK	0x0000003F
+
+/* Statistics Configuration Register (STATN_CONFIG) */
+#define STATS_CFG_CLR		0x00000004 /* 29 Reset all counters */
+#define STATS_CFG_CLR_ON_RD	0x00000002 /* 30 Clear on read */
+#define STATS_CFG_SATURATE	0x00000001 /* 31 Saturate at the maximum val */
+
+/* Interrupt Mask Register (IMASK) */
+#define MEMAC_IMASK_MGI		0x40000000 /* 1 Magic pkt detec indication */
+#define MEMAC_IMASK_TECC_ER	0x02000000 /* 6 Transmit frame ECC error evnt */
+#define MEMAC_IMASK_RECC_ER	0x01000000 /* 7 Receive frame ECC error evnt */
+
+#define MEMAC_ALL_IMASKS			\
+		((uint32_t)(MEMAC_IMASK_MGI	| \
+			MEMAC_IMASK_TECC_ER	| \
+			MEMAC_IMASK_RECC_ER))
+
+#define MEMAC_IEVNT_PCS			0x80000000 /* PCS (XG). Link sync (G) */
+#define MEMAC_IEVNT_AN			0x40000000 /* Auto-negotiation */
+#define MEMAC_IEVNT_LT			0x20000000 /* Link Training/New page */
+#define MEMAC_IEVNT_MGI			0x00004000 /* Magic pkt detection */
+#define MEMAC_IEVNT_RX_FIFO_OVFL	0x00001000 /* Rx FIFO overflow */
+#define MEMAC_IEVNT_TX_FIFO_UNFL	0x00000800 /* Tx FIFO underflow */
+#define MEMAC_IEVNT_TX_FIFO_OVFL	0x00000400 /* Tx FIFO overflow */
+#define MEMAC_IEVNT_TX_ECC_ER		0x00000200 /* Tx frame ECC error */
+#define MEMAC_IEVNT_RX_ECC_ER		0x00000100 /* Rx frame ECC error */
+#define MEMAC_IEVNT_LI_FAULT		0x00000080 /* Link Interruption flt */
+#define MEMAC_IEVNT_RX_EMPTY		0x00000040 /* Rx FIFO empty */
+#define MEMAC_IEVNT_TX_EMPTY		0x00000020 /* Tx FIFO empty */
+#define MEMAC_IEVNT_RX_LOWP		0x00000010 /* Low Power Idle */
+#define MEMAC_IEVNT_PHY_LOS		0x00000004 /* Phy loss of signal */
+#define MEMAC_IEVNT_REM_FAULT		0x00000002 /* Remote fault (XGMII) */
+#define MEMAC_IEVNT_LOC_FAULT		0x00000001 /* Local fault (XGMII) */
+
+#define MEMAC_EVENTS_MASK					\
+		((uint32_t)(MEMAC_IEVNT_PCS			| \
+				MEMAC_IEVNT_AN			| \
+				MEMAC_IEVNT_LT			| \
+				MEMAC_IEVNT_MGI			| \
+				MEMAC_IEVNT_RX_FIFO_OVFL	| \
+				MEMAC_IEVNT_TX_FIFO_UNFL	| \
+				MEMAC_IEVNT_TX_FIFO_OVFL	| \
+				MEMAC_IEVNT_TX_ECC_ER		| \
+				MEMAC_IEVNT_RX_ECC_ER		| \
+				MEMAC_IEVNT_LI_FAULT		| \
+				MEMAC_IEVNT_RX_EMPTY		| \
+				MEMAC_IEVNT_TX_EMPTY		| \
+				MEMAC_IEVNT_RX_LOWP		| \
+				MEMAC_IEVNT_PHY_LOS		| \
+				MEMAC_IEVNT_REM_FAULT		| \
+				MEMAC_IEVNT_LOC_FAULT))
+
+enum memac_counters {
+	E_MEMAC_COUNTER_R64,
+	E_MEMAC_COUNTER_R127,
+	E_MEMAC_COUNTER_R255,
+	E_MEMAC_COUNTER_R511,
+	E_MEMAC_COUNTER_R1023,
+	E_MEMAC_COUNTER_R1518,
+	E_MEMAC_COUNTER_R1519X,
+	E_MEMAC_COUNTER_RFRG,
+	E_MEMAC_COUNTER_RJBR,
+	E_MEMAC_COUNTER_RDRP,
+	E_MEMAC_COUNTER_RALN,
+	E_MEMAC_COUNTER_TUND,
+	E_MEMAC_COUNTER_ROVR,
+	E_MEMAC_COUNTER_RXPF,
+	E_MEMAC_COUNTER_TXPF,
+	E_MEMAC_COUNTER_ROCT,
+	E_MEMAC_COUNTER_RMCA,
+	E_MEMAC_COUNTER_RBCA,
+	E_MEMAC_COUNTER_RPKT,
+	E_MEMAC_COUNTER_RUCA,
+	E_MEMAC_COUNTER_RERR,
+	E_MEMAC_COUNTER_TOCT,
+	E_MEMAC_COUNTER_TMCA,
+	E_MEMAC_COUNTER_TBCA,
+	E_MEMAC_COUNTER_TUCA,
+	E_MEMAC_COUNTER_TERR
+};
+
+#define DEFAULT_PAUSE_QUANTA	0xf000
+#define DEFAULT_FRAME_LENGTH	0x600
+#define DEFAULT_TX_IPG_LENGTH	12
+
+/*
+ * memory map
+ */
+
+struct mac_addr {
+	uint32_t   mac_addr_l;	/* Lower 32 bits of 48-bit MAC address */
+	uint32_t   mac_addr_u;	/* Upper 16 bits of 48-bit MAC address */
+};
+
+struct memac_regs {
+	/* General Control and Status */
+	uint32_t res0000[2];
+	uint32_t command_config;	/* 0x008 Ctrl and cfg */
+	struct mac_addr mac_addr0;	/* 0x00C-0x010 MAC_ADDR_0...1 */
+	uint32_t maxfrm;		/* 0x014 Max frame length */
+	uint32_t res0018[5];
+	uint32_t hashtable_ctrl;	/* 0x02C Hash table control */
+	uint32_t res0030[4];
+	uint32_t ievent;		/* 0x040 Interrupt event */
+	uint32_t tx_ipg_length;		/* 0x044 Transmitter inter-packet-gap */
+	uint32_t res0048;
+	uint32_t imask;			/* 0x04C Interrupt mask */
+	uint32_t res0050;
+	uint32_t pause_quanta[4];	/* 0x054 Pause quanta */
+	uint32_t pause_thresh[4];	/* 0x064 Pause quanta threshold */
+	uint32_t rx_pause_status;	/* 0x074 Receive pause status */
+	uint32_t res0078[2];
+	struct mac_addr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 mac padr */
+	uint32_t lpwake_timer;		/* 0x0B8 Low Power Wakeup Timer */
+	uint32_t sleep_timer;		/* 0x0BC Transmit EEE Low Power Timer */
+	uint32_t res00c0[8];
+	uint32_t statn_config;		/* 0x0E0 Statistics configuration */
+	uint32_t res00e4[7];
+	/* Rx Statistics Counter */
+	uint32_t reoct_l;
+	uint32_t reoct_u;
+	uint32_t roct_l;
+	uint32_t roct_u;
+	uint32_t raln_l;
+	uint32_t raln_u;
+	uint32_t rxpf_l;
+	uint32_t rxpf_u;
+	uint32_t rfrm_l;
+	uint32_t rfrm_u;
+	uint32_t rfcs_l;
+	uint32_t rfcs_u;
+	uint32_t rvlan_l;
+	uint32_t rvlan_u;
+	uint32_t rerr_l;
+	uint32_t rerr_u;
+	uint32_t ruca_l;
+	uint32_t ruca_u;
+	uint32_t rmca_l;
+	uint32_t rmca_u;
+	uint32_t rbca_l;
+	uint32_t rbca_u;
+	uint32_t rdrp_l;
+	uint32_t rdrp_u;
+	uint32_t rpkt_l;
+	uint32_t rpkt_u;
+	uint32_t rund_l;
+	uint32_t rund_u;
+	uint32_t r64_l;
+	uint32_t r64_u;
+	uint32_t r127_l;
+	uint32_t r127_u;
+	uint32_t r255_l;
+	uint32_t r255_u;
+	uint32_t r511_l;
+	uint32_t r511_u;
+	uint32_t r1023_l;
+	uint32_t r1023_u;
+	uint32_t r1518_l;
+	uint32_t r1518_u;
+	uint32_t r1519x_l;
+	uint32_t r1519x_u;
+	uint32_t rovr_l;
+	uint32_t rovr_u;
+	uint32_t rjbr_l;
+	uint32_t rjbr_u;
+	uint32_t rfrg_l;
+	uint32_t rfrg_u;
+	uint32_t rcnp_l;
+	uint32_t rcnp_u;
+	uint32_t rdrntp_l;
+	uint32_t rdrntp_u;
+	uint32_t res01d0[12];
+	/* Tx Statistics Counter */
+	uint32_t teoct_l;
+	uint32_t teoct_u;
+	uint32_t toct_l;
+	uint32_t toct_u;
+	uint32_t res0210[2];
+	uint32_t txpf_l;
+	uint32_t txpf_u;
+	uint32_t tfrm_l;
+	uint32_t tfrm_u;
+	uint32_t tfcs_l;
+	uint32_t tfcs_u;
+	uint32_t tvlan_l;
+	uint32_t tvlan_u;
+	uint32_t terr_l;
+	uint32_t terr_u;
+	uint32_t tuca_l;
+	uint32_t tuca_u;
+	uint32_t tmca_l;
+	uint32_t tmca_u;
+	uint32_t tbca_l;
+	uint32_t tbca_u;
+	uint32_t res0258[2];
+	uint32_t tpkt_l;
+	uint32_t tpkt_u;
+	uint32_t tund_l;
+	uint32_t tund_u;
+	uint32_t t64_l;
+	uint32_t t64_u;
+	uint32_t t127_l;
+	uint32_t t127_u;
+	uint32_t t255_l;
+	uint32_t t255_u;
+	uint32_t t511_l;
+	uint32_t t511_u;
+	uint32_t t1023_l;
+	uint32_t t1023_u;
+	uint32_t t1518_l;
+	uint32_t t1518_u;
+	uint32_t t1519x_l;
+	uint32_t t1519x_u;
+	uint32_t res02a8[6];
+	uint32_t tcnp_l;
+	uint32_t tcnp_u;
+	uint32_t res02c8[14];
+	/* Line Interface Control */
+	uint32_t if_mode;		/* 0x300 Interface Mode Control */
+	uint32_t if_status;		/* 0x304 Interface Status */
+	uint32_t res0308[14];
+	/* HiGig/2 */
+	uint32_t hg_config;		/* 0x340 Control and cfg */
+	uint32_t res0344[3];
+	uint32_t hg_pause_quanta;	/* 0x350 Pause quanta */
+	uint32_t res0354[3];
+	uint32_t hg_pause_thresh;	/* 0x360 Pause quanta threshold */
+	uint32_t res0364[3];
+	uint32_t hgrx_pause_status;	/* 0x370 Receive pause status */
+	uint32_t hg_fifos_status;	/* 0x374 fifos status */
+	uint32_t rhm;			/* 0x378 rx messages counter */
+	uint32_t thm;			/* 0x37C tx messages counter */
+};
+
+struct memac_cfg {
+	bool		reset_on_init;
+	bool		rx_error_discard;
+	bool		pause_ignore;
+	bool		pause_forward_enable;
+	bool		no_length_check_enable;
+	bool		cmd_frame_enable;
+	bool		send_idle_enable;
+	bool		wan_mode_enable;
+	bool		promiscuous_mode_enable;
+	bool		tx_addr_ins_enable;
+	bool		loopback_enable;
+	bool		lgth_check_nostdr;
+	bool		time_stamp_enable;
+	bool		pad_enable;
+	bool		phy_tx_ena_on;
+	bool		rx_sfd_any;
+	bool		rx_pbl_fwd;
+	bool		tx_pbl_fwd;
+	bool		debug_mode;
+	uint16_t	max_frame_length;
+	uint16_t	pause_quanta;
+	uint32_t	tx_ipg_length;
+};
+
+/**
+ * memac_defconfig() - Get default MEMAC configuration
+ * @cfg:    pointer to configuration structure.
+ *
+ * Call this function to obtain a default set of configuration values for
+ * initializing MEMAC. The user can overwrite any of the values before calling
+ * memac_init(), if specific configuration needs to be applied.
+ */
+void memac_defconfig(struct memac_cfg *cfg);
+void memac_set_promiscuous(struct memac_regs *regs, bool val);
+void memac_hardware_add_addr_in_paddr(struct memac_regs *regs,
+					uint8_t *adr,
+					uint8_t paddr_num);
+void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs,
+					uint8_t paddr_num);
+void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+uint64_t memac_get_counter(struct memac_regs *regs,
+				enum memac_counters reg_name);
+void memac_set_tx_pause_frames(struct memac_regs *regs,
+				uint8_t priority,
+				uint16_t pauseTime,
+				uint16_t threshTime);
+uint16_t memac_get_max_frame_length(struct memac_regs *regs);
+void memac_init(struct memac_regs *regs,
+		struct memac_cfg *cfg,
+		enum enet_interface enet_interface,
+		enum enet_speed enet_speed,
+		uint32_t exceptions);
+void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
+void memac_reset_counter(struct memac_regs *regs);
+void memac_reset(struct memac_regs *regs);
+void memac_set_hash_table(struct memac_regs *regs, uint32_t val);
+void memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
+void memac_set_loopback(struct memac_regs *regs, bool enable);
+void memac_reset_counter(struct memac_regs *regs);
+uint32_t memac_get_event(struct memac_regs *regs, uint32_t ev_mask);
+void memac_ack_event(struct memac_regs *regs, uint32_t ev_mask);
+uint32_t memac_get_interrupt_mask(struct memac_regs *regs);
+
+
+#endif /*__FSL_FMAN_MEMAC_H*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_prs.h
new file mode 100644
index 0000000..30d2ecf
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_prs.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_PRS_H
+#define __FSL_FMAN_PRS_H
+
+#include "common/general.h"
+
+#define FM_PCD_EX_PRS_DOUBLE_ECC	0x02000000
+#define FM_PCD_EX_PRS_SINGLE_ECC	0x01000000
+
+#define FM_PCD_PRS_PPSC_ALL_PORTS	0xffff0000
+#define FM_PCD_PRS_RPIMAC_EN		0x00000001
+#define FM_PCD_PRS_PORT_IDLE_STS	0xffff0000
+#define FM_PCD_PRS_SINGLE_ECC		0x00004000
+#define FM_PCD_PRS_DOUBLE_ECC		0x00004000
+#define PRS_MAX_CYCLE_LIMIT		8191
+
+#define DEFAULT_MAX_PRS_CYC_LIM		0
+
+struct fman_prs_regs {
+	uint32_t fmpr_rpclim;
+	uint32_t fmpr_rpimac;
+	uint32_t pmeec;
+	uint32_t res00c[5];
+	uint32_t fmpr_pevr;
+	uint32_t fmpr_pever;
+	uint32_t res028;
+	uint32_t fmpr_perr;
+	uint32_t fmpr_perer;
+	uint32_t res034;
+	uint32_t res038[10];
+	uint32_t fmpr_ppsc;
+	uint32_t res064;
+	uint32_t fmpr_pds;
+	uint32_t fmpr_l2rrs;
+	uint32_t fmpr_l3rrs;
+	uint32_t fmpr_l4rrs;
+	uint32_t fmpr_srrs;
+	uint32_t fmpr_l2rres;
+	uint32_t fmpr_l3rres;
+	uint32_t fmpr_l4rres;
+	uint32_t fmpr_srres;
+	uint32_t fmpr_spcs;
+	uint32_t fmpr_spscs;
+	uint32_t fmpr_hxscs;
+	uint32_t fmpr_mrcs;
+	uint32_t fmpr_mwcs;
+	uint32_t fmpr_mrscs;
+	uint32_t fmpr_mwscs;
+	uint32_t fmpr_fcscs;
+};
+
+struct fman_prs_cfg {
+	uint32_t	port_id_stat;
+	uint16_t	max_prs_cyc_lim;
+	uint32_t	prs_exceptions;
+};
+
+uint32_t fman_prs_get_err_event(struct fman_prs_regs *regs, uint32_t ev_mask);
+uint32_t fman_prs_get_err_ev_mask(struct fman_prs_regs *regs);
+void fman_prs_ack_err_event(struct fman_prs_regs *regs, uint32_t event);
+uint32_t fman_prs_get_expt_event(struct fman_prs_regs *regs, uint32_t ev_mask);
+uint32_t fman_prs_get_expt_ev_mask(struct fman_prs_regs *regs);
+void fman_prs_ack_expt_event(struct fman_prs_regs *regs, uint32_t event);
+void fman_prs_defconfig(struct fman_prs_cfg *cfg);
+int fman_prs_init(struct fman_prs_regs *regs, struct fman_prs_cfg *cfg);
+void fman_prs_enable(struct fman_prs_regs *regs);
+void fman_prs_disable(struct fman_prs_regs *regs);
+void fman_prs_set_stst_port_msk(struct fman_prs_regs *regs, uint32_t pid_msk);
+void fman_prs_set_stst(struct fman_prs_regs *regs, bool enable);
+#endif /* __FSL_FMAN_PRS_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_tgec.h
new file mode 100644
index 0000000..2505888
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_fman_tgec.h
@@ -0,0 +1,472 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_TGEC_H
+#define __FSL_FMAN_TGEC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK	0x000003ff
+
+enum tgec_counters {
+	E_TGEC_COUNTER_R64,
+	E_TGEC_COUNTER_R127,
+	E_TGEC_COUNTER_R255,
+	E_TGEC_COUNTER_R511,
+	E_TGEC_COUNTER_R1023,
+	E_TGEC_COUNTER_R1518,
+	E_TGEC_COUNTER_R1519X,
+	E_TGEC_COUNTER_TRFRG,
+	E_TGEC_COUNTER_TRJBR,
+	E_TGEC_COUNTER_RDRP,
+	E_TGEC_COUNTER_RALN,
+	E_TGEC_COUNTER_TRUND,
+	E_TGEC_COUNTER_TROVR,
+	E_TGEC_COUNTER_RXPF,
+	E_TGEC_COUNTER_TXPF,
+	E_TGEC_COUNTER_ROCT,
+	E_TGEC_COUNTER_RMCA,
+	E_TGEC_COUNTER_RBCA,
+	E_TGEC_COUNTER_RPKT,
+	E_TGEC_COUNTER_RUCA,
+	E_TGEC_COUNTER_RERR,
+	E_TGEC_COUNTER_TOCT,
+	E_TGEC_COUNTER_TMCA,
+	E_TGEC_COUNTER_TBCA,
+	E_TGEC_COUNTER_TUCA,
+	E_TGEC_COUNTER_TERR
+};
+
+/* Command and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_EN_TIMESTAMP	0x00100000
+#define CMD_CFG_TX_ADDR_INS_SEL	0x00080000
+#define CMD_CFG_NO_LEN_CHK	0x00020000
+#define CMD_CFG_SEND_IDLE	0x00010000
+#define CMD_CFG_RX_ER_DISC	0x00004000
+#define CMD_CFG_CMD_FRM_EN	0x00002000
+#define CMD_CFG_STAT_CLR	0x00001000
+#define CMD_CFG_LOOPBACK_EN	0x00000400
+#define CMD_CFG_TX_ADDR_INS	0x00000200
+#define CMD_CFG_PAUSE_IGNORE	0x00000100
+#define CMD_CFG_PAUSE_FWD	0x00000080
+#define CMD_CFG_PROMIS_EN	0x00000010
+#define CMD_CFG_WAN_MODE	0x00000008
+#define CMD_CFG_RX_EN		0x00000002
+#define CMD_CFG_TX_EN		0x00000001
+
+/* Interrupt Mask Register (IMASK) */
+#define TGEC_IMASK_MDIO_SCAN_EVENT	0x00010000
+#define TGEC_IMASK_MDIO_CMD_CMPL	0x00008000
+#define TGEC_IMASK_REM_FAULT		0x00004000
+#define TGEC_IMASK_LOC_FAULT		0x00002000
+#define TGEC_IMASK_TX_ECC_ER		0x00001000
+#define TGEC_IMASK_TX_FIFO_UNFL		0x00000800
+#define TGEC_IMASK_TX_FIFO_OVFL		0x00000400
+#define TGEC_IMASK_TX_ER			0x00000200
+#define TGEC_IMASK_RX_FIFO_OVFL		0x00000100
+#define TGEC_IMASK_RX_ECC_ER		0x00000080
+#define TGEC_IMASK_RX_JAB_FRM		0x00000040
+#define TGEC_IMASK_RX_OVRSZ_FRM		0x00000020
+#define TGEC_IMASK_RX_RUNT_FRM		0x00000010
+#define TGEC_IMASK_RX_FRAG_FRM		0x00000008
+#define TGEC_IMASK_RX_LEN_ER		0x00000004
+#define TGEC_IMASK_RX_CRC_ER		0x00000002
+#define TGEC_IMASK_RX_ALIGN_ER		0x00000001
+
+#define EVENTS_MASK							\
+	((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT	| \
+				TGEC_IMASK_MDIO_CMD_CMPL	| \
+				TGEC_IMASK_REM_FAULT		| \
+				TGEC_IMASK_LOC_FAULT		| \
+				TGEC_IMASK_TX_ECC_ER		| \
+				TGEC_IMASK_TX_FIFO_UNFL		| \
+				TGEC_IMASK_TX_FIFO_OVFL		| \
+				TGEC_IMASK_TX_ER			| \
+				TGEC_IMASK_RX_FIFO_OVFL		| \
+				TGEC_IMASK_RX_ECC_ER		| \
+				TGEC_IMASK_RX_JAB_FRM		| \
+				TGEC_IMASK_RX_OVRSZ_FRM		| \
+				TGEC_IMASK_RX_RUNT_FRM		| \
+				TGEC_IMASK_RX_FRAG_FRM		| \
+				TGEC_IMASK_RX_LEN_ER		| \
+				TGEC_IMASK_RX_CRC_ER		| \
+				TGEC_IMASK_RX_ALIGN_ER))
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define TGEC_HASH_MCAST_SHIFT	23
+#define TGEC_HASH_MCAST_EN	0x00000200
+#define TGEC_HASH_ADR_MSK	0x000001ff
+
+#define DEFAULT_WAN_MODE_ENABLE		FALSE
+#define DEFAULT_PROMISCUOUS_MODE_ENABLE	FALSE
+#define DEFAULT_PAUSE_FORWARD_ENABLE	FALSE
+#define DEFAULT_PAUSE_IGNORE		FALSE
+#define DEFAULT_TX_ADDR_INS_ENABLE	FALSE
+#define DEFAULT_LOOPBACK_ENABLE		FALSE
+#define DEFAULT_CMD_FRAME_ENABLE	FALSE
+#define DEFAULT_RX_ERROR_DISCARD	FALSE
+#define DEFAULT_SEND_IDLE_ENABLE	FALSE
+#define DEFAULT_NO_LENGTH_CHECK_ENABLE	TRUE
+#define DEFAULT_LGTH_CHECK_NOSTDR	FALSE
+#define DEFAULT_TIME_STAMP_ENABLE	FALSE
+#define DEFAULT_TX_IPG_LENGTH		12
+#define DEFAULT_MAX_FRAME_LENGTH	0x600
+#define DEFAULT_PAUSE_QUANT		0xf000
+
+/*
+ * 10G memory map
+ */
+struct tgec_regs {
+	uint32_t tgec_id;		/* 0x000 Controller ID */
+	uint32_t reserved001[1];	/* 0x004 */
+	uint32_t command_config;	/* 0x008 Control and configuration */
+	uint32_t mac_addr_0;		/* 0x00c Lower 32 bits of the MAC adr */
+	uint32_t mac_addr_1;		/* 0x010 Upper 16 bits of the MAC adr */
+	uint32_t maxfrm;		/* 0x014 Maximum frame length */
+	uint32_t pause_quant;		/* 0x018 Pause quanta */
+	uint32_t rx_fifo_sections;	/* 0x01c  */
+	uint32_t tx_fifo_sections;	/* 0x020  */
+	uint32_t rx_fifo_almost_f_e;	/* 0x024  */
+	uint32_t tx_fifo_almost_f_e;	/* 0x028  */
+	uint32_t hashtable_ctrl;	/* 0x02c Hash table control*/
+	uint32_t mdio_cfg_status;	/* 0x030  */
+	uint32_t mdio_command;		/* 0x034  */
+	uint32_t mdio_data;		/* 0x038  */
+	uint32_t mdio_regaddr;		/* 0x03c  */
+	uint32_t status;		/* 0x040  */
+	uint32_t tx_ipg_len;		/* 0x044 Transmitter inter-packet-gap */
+	uint32_t mac_addr_2;		/* 0x048 Lower 32 bits of 2nd MAC adr */
+	uint32_t mac_addr_3;		/* 0x04c Upper 16 bits of 2nd MAC adr */
+	uint32_t rx_fifo_ptr_rd;	/* 0x050  */
+	uint32_t rx_fifo_ptr_wr;	/* 0x054  */
+	uint32_t tx_fifo_ptr_rd;	/* 0x058  */
+	uint32_t tx_fifo_ptr_wr;	/* 0x05c  */
+	uint32_t imask;			/* 0x060 Interrupt mask */
+	uint32_t ievent;		/* 0x064 Interrupt event */
+	uint32_t udp_port;		/* 0x068 Defines a UDP Port number */
+	uint32_t type_1588v2;		/* 0x06c Type field for 1588v2 */
+	uint32_t reserved070[4];	/* 0x070 */
+	/*10Ge Statistics Counter */
+	uint32_t tfrm_u;		/* 80 aFramesTransmittedOK */
+	uint32_t tfrm_l;		/* 84 aFramesTransmittedOK */
+	uint32_t rfrm_u;		/* 88 aFramesReceivedOK */
+	uint32_t rfrm_l;		/* 8c aFramesReceivedOK */
+	uint32_t rfcs_u;		/* 90 aFrameCheckSequenceErrors */
+	uint32_t rfcs_l;		/* 94 aFrameCheckSequenceErrors */
+	uint32_t raln_u;		/* 98 aAlignmentErrors */
+	uint32_t raln_l;		/* 9c aAlignmentErrors */
+	uint32_t txpf_u;		/* A0 aPAUSEMACCtrlFramesTransmitted */
+	uint32_t txpf_l;		/* A4 aPAUSEMACCtrlFramesTransmitted */
+	uint32_t rxpf_u;		/* A8 aPAUSEMACCtrlFramesReceived */
+	uint32_t rxpf_l;		/* Ac aPAUSEMACCtrlFramesReceived */
+	uint32_t rlong_u;		/* B0 aFrameTooLongErrors */
+	uint32_t rlong_l;		/* B4 aFrameTooLongErrors */
+	uint32_t rflr_u;		/* B8 aInRangeLengthErrors */
+	uint32_t rflr_l;		/* Bc aInRangeLengthErrors */
+	uint32_t tvlan_u;		/* C0 VLANTransmittedOK */
+	uint32_t tvlan_l;		/* C4 VLANTransmittedOK */
+	uint32_t rvlan_u;		/* C8 VLANReceivedOK */
+	uint32_t rvlan_l;		/* Cc VLANReceivedOK */
+	uint32_t toct_u;		/* D0 ifOutOctets */
+	uint32_t toct_l;		/* D4 ifOutOctets */
+	uint32_t roct_u;		/* D8 ifInOctets */
+	uint32_t roct_l;		/* Dc ifInOctets */
+	uint32_t ruca_u;		/* E0 ifInUcastPkts */
+	uint32_t ruca_l;		/* E4 ifInUcastPkts */
+	uint32_t rmca_u;		/* E8 ifInMulticastPkts */
+	uint32_t rmca_l;		/* Ec ifInMulticastPkts */
+	uint32_t rbca_u;		/* F0 ifInBroadcastPkts */
+	uint32_t rbca_l;		/* F4 ifInBroadcastPkts */
+	uint32_t terr_u;		/* F8 ifOutErrors */
+	uint32_t terr_l;		/* Fc ifOutErrors */
+	uint32_t reserved100[2];	/* 100-108*/
+	uint32_t tuca_u;		/* 108 ifOutUcastPkts */
+	uint32_t tuca_l;		/* 10c ifOutUcastPkts */
+	uint32_t tmca_u;		/* 110 ifOutMulticastPkts */
+	uint32_t tmca_l;		/* 114 ifOutMulticastPkts */
+	uint32_t tbca_u;		/* 118 ifOutBroadcastPkts */
+	uint32_t tbca_l;		/* 11c ifOutBroadcastPkts */
+	uint32_t rdrp_u;		/* 120 etherStatsDropEvents */
+	uint32_t rdrp_l;		/* 124 etherStatsDropEvents */
+	uint32_t reoct_u;		/* 128 etherStatsOctets */
+	uint32_t reoct_l;		/* 12c etherStatsOctets */
+	uint32_t rpkt_u;		/* 130 etherStatsPkts */
+	uint32_t rpkt_l;		/* 134 etherStatsPkts */
+	uint32_t trund_u;		/* 138 etherStatsUndersizePkts */
+	uint32_t trund_l;		/* 13c etherStatsUndersizePkts */
+	uint32_t r64_u;			/* 140 etherStatsPkts64Octets */
+	uint32_t r64_l;			/* 144 etherStatsPkts64Octets */
+	uint32_t r127_u;		/* 148 etherStatsPkts65to127Octets */
+	uint32_t r127_l;		/* 14c etherStatsPkts65to127Octets */
+	uint32_t r255_u;		/* 150 etherStatsPkts128to255Octets */
+	uint32_t r255_l;		/* 154 etherStatsPkts128to255Octets */
+	uint32_t r511_u;		/* 158 etherStatsPkts256to511Octets */
+	uint32_t r511_l;		/* 15c etherStatsPkts256to511Octets */
+	uint32_t r1023_u;		/* 160 etherStatsPkts512to1023Octets */
+	uint32_t r1023_l;		/* 164 etherStatsPkts512to1023Octets */
+	uint32_t r1518_u;		/* 168 etherStatsPkts1024to1518Octets */
+	uint32_t r1518_l;		/* 16c etherStatsPkts1024to1518Octets */
+	uint32_t r1519x_u;		/* 170 etherStatsPkts1519toX */
+	uint32_t r1519x_l;		/* 174 etherStatsPkts1519toX */
+	uint32_t trovr_u;		/* 178 etherStatsOversizePkts */
+	uint32_t trovr_l;		/* 17c etherStatsOversizePkts */
+	uint32_t trjbr_u;		/* 180 etherStatsJabbers */
+	uint32_t trjbr_l;		/* 184 etherStatsJabbers */
+	uint32_t trfrg_u;		/* 188 etherStatsFragments */
+	uint32_t trfrg_l;		/* 18C etherStatsFragments */
+	uint32_t rerr_u;		/* 190 ifInErrors */
+	uint32_t rerr_l;		/* 194 ifInErrors */
+};
+
+/**
+ * struct tgec_cfg - TGEC configuration
+ *
+ * @rx_error_discard:    Receive Erroneous Frame Discard Enable. When set to 1
+ *            any frame received with an error is discarded in the
+ *            Core and not forwarded to the Client interface.
+ *            When set to 0 (Reset value), erroneous Frames are
+ *            forwarded to the Client interface with ff_rx_err
+ *            asserted.
+ * @pause_ignore:    Ignore Pause Frame Quanta. If set to 1 received pause
+ *            frames are ignored by the MAC. When set to 0
+ *            (Reset value) the transmit process is stopped for the
+ *            amount of time specified in the pause quanta received
+ *            within a pause frame.
+ * @pause_forward_enable:
+ *            Terminate / Forward Pause Frames. If set to 1 pause
+ *            frames are forwarded to the user application. When set
+ *            to 0 (Reset value) pause frames are terminated and
+ *            discarded within the MAC.
+ * @no_length_check_enable:
+ *            Payload Length Check Disable. When set to 0
+ *            (Reset value), the Core checks the frame's payload
+ *            length with the Frame Length/Type field, when set to 1
+ *            the payload length check is disabled.
+ * @cmd_frame_enable:    Enables reception of all command frames. When set to 1
+ *            all Command Frames are accepted, when set to 0
+ *            (Reset Value) only Pause Frames are accepted and all
+ *            other Command Frames are rejected.
+ * @send_idle_enable:    Force Idle Generation. When set to 1, the MAC
+ *            permanently sends XGMII Idle sequences even when faults
+ *            are received.
+ * @wan_mode_enable:    WAN Mode Enable. Sets WAN mode (1) or LAN mode
+ *            (0, default) of operation.
+ * @promiscuous_mode_enable:
+ *            Enables MAC promiscuous operation. When set to 1, all
+ *            frames are received without any MAC address filtering,
+ *            when set to 0 (Reset value) Unicast Frames with a
+ *            destination address not matching the Core MAC Address
+ *            (MAC Address programmed in Registers MAC_ADDR_0 and
+ *            MAC_ADDR_1 or the MAC address programmed in Registers
+ *            MAC_ADDR_2 and MAC_ADDR_3) are rejected.
+ * @tx_addr_ins_enable:    Set Source MAC Address on Transmit. If set to 1 the
+ *            MAC overwrites the source MAC address received from the
+ *            Client Interface with one of the MAC addresses. If set
+ *            to 0 (Reset value), the source MAC address from the
+ *            Client Interface is transmitted unmodified to the line.
+ * @loopback_enable:    PHY Interface Loopback. When set to 1, the signal
+ *            loop_ena is set to '1', when set to 0 (Reset value)
+ *            the signal loop_ena is set to 0.
+ * @lgth_check_nostdr:    The Core interprets the Length/Type field differently
+ *            depending on the value of this Bit
+ * @time_stamp_enable:    This bit selects between enabling and disabling the
+ *            IEEE 1588 functionality. 1: IEEE 1588 is enabled
+ *            0: IEEE 1588 is disabled
+ * @max_frame_length:    Maximum supported received frame length.
+ *            The 10GEC MAC supports reception of any frame size up
+ *            to 16,352 bytes (0x3FE0). Typical settings are
+ *            0x05EE (1,518 bytes) for standard frames.
+ *            Default setting is 0x0600 (1,536 bytes).
+ *            Received frames that exceed this stated maximum
+ *            are truncated.
+ * @pause_quant:    Pause quanta value used with transmitted pause frames.
+ *            Each quanta represents a 512 bit-times.
+ * @tx_ipg_length:    Transmit Inter-Packet-Gap (IPG) value. A 6-bit value:
+ *            Depending on LAN or WAN mode of operation the value has
+ *            the following meaning: - LAN Mode: Number of octets in
+ *            steps of 4. Valid values are 8, 12, 16, ... 100. DIC is
+ *            fully supported (see 10.6.1 page 49) for any setting. A
+ *            default of 12 (reset value) must be set to conform to
+ *            IEEE802.3ae. Warning: When set to 8, PCS layers may not
+ *            be able to perform clock rate compensation. - WAN Mode:
+ *            Stretch factor. Valid values are 4..15. The stretch
+ *            factor is calculated as (value+1)*8. A default of 12
+ *            (reset value) must be set to conform to IEEE 802.3ae
+ *            (i.e. 13*8=104). A larger value shrinks the IPG
+ *            (increasing bandwidth).
+ *
+ * This structure contains basic TGEC configuration and must be passed to
+ * tgec_init() function.  A default set of configuration values can be obtained
+ * by calling tgec_defconfig().
+ */
+struct tgec_cfg {
+	bool		rx_error_discard;
+	bool		pause_ignore;
+	bool		pause_forward_enable;
+	bool		no_length_check_enable;
+	bool		cmd_frame_enable;
+	bool		send_idle_enable;
+	bool		wan_mode_enable;
+	bool		promiscuous_mode_enable;
+	bool		tx_addr_ins_enable;
+	bool		loopback_enable;
+	bool		lgth_check_nostdr;
+	bool		time_stamp_enable;
+	uint16_t	max_frame_length;
+	uint16_t	pause_quant;
+	uint32_t	tx_ipg_length;
+	bool		skip_fman11_workaround;
+};
+
+void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *macaddr);
+
+/**
+ * tgec_reset_stat() - Completely resets all TGEC HW counters
+ * @regs:    Pointer to TGEC register block
+ */
+void tgec_reset_stat(struct tgec_regs *regs);
+
+/**
+ * tgec_get_counter() - Reads TGEC HW counters
+ * @regs:    Pointer to TGEC register block
+ * @reg_name:    Counter name according to the appropriate enum
+ *
+ * Returns:    Required counter value
+ */
+
+uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
+
+void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+void tgec_set_promiscuous(struct tgec_regs *regs, bool val);
+
+/**
+ * tgec_set_hash_table() - Sets the Hashtable Control Register
+ * @regs:    Pointer to TGEC register block
+ * @value:    Value to be written in Hashtable Control Register
+ */
+void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value);
+
+/**
+ * tgec_tx_mac_pause() - Sets the Pause Quanta Register
+ * @regs:    Pointer to TGEC register block
+ * @pause_time:    Pause quanta value used with transmitted pause frames.
+ *        Each quanta represents a 512 bit-times
+ */
+
+void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time);
+
+/**
+ * tgec_rx_ignore_mac_pause() - Changes the policy WRT pause frames
+ * @regs:    Pointer to TGEC register block
+ * @en:        Ignore/Respond to pause frame quanta
+ *
+ * Sets the value of PAUSE_IGNORE field in the COMMAND_CONFIG Register
+ * 0 - MAC stops transmit process for the duration specified
+ * in the Pause frame quanta of a received Pause frame.
+ * 1 - MAC ignores received Pause frames.
+ */
+
+void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en);
+
+/**
+ * tgec_enable_1588_time_stamp() - change timestamp functionality
+ * @regs:    Pointer to TGEC register block
+ * @en:        enable/disable timestamp functionality
+ *
+ * Sets the value of EN_TIMESTAMP field in the COMMAND_CONFIG Register
+ * IEEE 1588 timestamp functionality control:
+ * 0 disabled, 1 enabled
+ */
+
+void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en);
+
+uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask);
+void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask);
+uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs);
+
+
+/**
+ * tgec_add_addr_in_paddr() - Sets additional exact match MAC address
+ * @regs:    Pointer to TGEC register block
+ * @addr_ptr:    Pointer to 6-byte array containing the MAC address
+ *
+ * Sets the additional station MAC address
+ */
+
+void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *addr_ptr);
+void tgec_clear_addr_in_paddr(struct tgec_regs *regs);
+uint32_t tgec_get_revision(struct tgec_regs *regs);
+void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
+void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
+
+/**
+ * tgec_get_max_frame_len() - Returns the maximum frame length value
+ * @regs:    Pointer to TGEC register block
+ */
+
+uint16_t tgec_get_max_frame_len(struct tgec_regs *regs);
+
+/**
+ * tgec_defconfig() - Initialize the main tgec configuration parameters
+ * @cfg:    Pointer to tgec_cfg structure
+ *
+ * This routine determines the values of the tgec_cfg structure members.
+ * This structure represents the initial parameters which the tgec controller
+ * will be initialized with later when calling the tgec_init function.
+ */
+
+void tgec_defconfig(struct tgec_cfg *cfg);
+
+/**
+ * tgec_init() - Init tgec hardware block
+ * @regs:        Pointer to tgec register block
+ * @cfg:        tgec configuration data
+ * @exceptions_mask:    initial exceptions mask
+ *
+ * This function initializes the tgec controller and applies its
+ * basic configuration.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+
+int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
+        uint32_t exception_mask);
+
+
+void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs);
+
+
+#endif /* __FSL_FMAN_TGEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index f76cecc..fabf8db 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -102,6 +102,7 @@ typedef enum {
 #define SEC_NUM_OF_DECOS    2
 #define SEC_ALL_DECOS_MASK  0x00000003
 #define SEC_RNGB
+#define SEC_NO_ESP_TRAILER_REMOVAL
 
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
@@ -122,7 +123,7 @@ typedef enum {
 #define FM_MAX_NUM_OF_MACSECS       1
 
 #define FM_MACSEC_SUPPORT
-#define FM_DISABLE_SEC_ERRORS
+#define FM_CAPWAP_SUPPORT
 
 #define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
 
@@ -132,13 +133,16 @@ typedef enum {
 #define FM_MAX_NUM_OF_SUB_PORTALS               7
 
 /* Rams defines */
-#define FM_MURAM_SIZE               (64*KILOBYTE)
-#define FM_IRAM_SIZE                (32*KILOBYTE)
+#define FM_MURAM_SIZE                   (64*KILOBYTE)
+#define FM_IRAM_SIZE                    (32*KILOBYTE)
+#define FM_NUM_OF_CTRL                  2
 
 /* PCD defines */
 #define FM_PCD_PLCR_NUM_ENTRIES         32                  /**< Total number of policer profiles */
 #define FM_PCD_KG_NUM_OF_SCHEMES        16                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS     128                 /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000240          /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
 
 /* RTC defines */
 #define FM_RTC_NUM_OF_ALARMS            2
@@ -218,6 +222,8 @@ typedef enum e_FmMacsecInterModuleEvent {
 #define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation, Out of LLD scope */
 #define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation, Out of LLD scope. App must avoid S/G */
 
+#define FM_GTS_AFTER_DROPPED_FRAME_ERRATA_DTSEC_A004839
+
 /* #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
 /*
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 327fe3f..a655882 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -185,14 +185,17 @@ typedef enum
 #define FM_MAX_NUM_OF_SUB_PORTALS               12
 #define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
 
-/* RAMs defines */
-#define FM_MURAM_SIZE                   (160 * KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+/* Rams defines */
+#define FM_MURAM_SIZE                   (160*KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64*KILOBYTE)
+#define FM_NUM_OF_CTRL                  2
 
 /* PCD defines */
-#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+#define FM_PCD_PLCR_NUM_ENTRIES         256             /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32              /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256             /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000200      /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800      /**< Total size of SW parser area */
 
 /* RTC defines */
 #define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
@@ -242,7 +245,7 @@ typedef enum
 #define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
 #define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
 #define FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
-#define FM_TX_INVALID_ECC_ERRATA_10GMAC_A009
+#define FM_TX_INVALID_ECC_ERRATA_10GMAC_A009            /* Out of LLD scope, user may disable ECC exceptions using FM_DisableRamsEcc */
 #define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
 
 #define FM_RX_PREAM_4_ERRATA_DTSEC_A001
@@ -251,6 +254,7 @@ typedef enum
 #define FM_GTS_ERRATA_DTSEC_A004
 #define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012
 #define FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
+#define FM_GTS_AFTER_DROPPED_FRAME_ERRATA_DTSEC_A004839
 
 #define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2          /* No implementation, Out of LLD scope */
 #define FM_TX_LOCKUP_ERRATA_DTSEC6
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
index f0c80b7..03c59b8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
@@ -210,8 +210,8 @@ typedef enum e_ModuleId
     e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
     e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
 
-    e_MODULE_ID_SRIO_PORTS,     	/**< RapidIO controller */
-    e_MODULE_ID_SRIO_MU,        	/**< RapidIO messaging unit module */
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+    e_MODULE_ID_SRIO_MU,            /**< RapidIO messaging unit module */
 
     e_MODULE_ID_DUMMY_LAST
 } e_ModuleId;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
index ba17913..62c2d21 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
@@ -215,11 +215,14 @@ typedef enum
 /* RAMs defines */
 #define FM_MURAM_SIZE                   (384 * KILOBYTE)
 #define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+#define FM_NUM_OF_CTRL                  4
 
 /* PCD defines */
 #define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
 #define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000240          /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
 
 /* RTC defines */
 #define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
@@ -252,18 +255,23 @@ typedef enum
 #define FM_FRAME_END_PARAMS_FOR_OP
 #define FM_DEQ_PIPELINE_PARAMS_FOR_OP
 #define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+#define FM_EXP_FEATURES
 
-/* FM erratas */
-//#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
-
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
-#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
-
+/* FM errata */
+#define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+#define FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
 
+#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
 
 #define FM_BCB_ERRATA_BMI_SW001
 #define FM_LEN_CHECK_ERRATA_FMAN_SW002
+#define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
+
+/*****************************************************************************
+ RMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define RM_MAX_NUM_OF_IB        4           /**< Number of inbound blocks */
+#define RM_NUM_OF_IBCU          8           /**< NUmber of classification units in an inbound block */
 
 
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
index 7f07e13..3254c76 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
@@ -40,6 +40,8 @@
 #define __PART_INTEGRATION_EXT_H
 
 #include "std_ext.h"
+#include "ddr_std_ext.h"
+#include "enet_ext.h"
 #include "dpaa_integration_ext.h"
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index 36d181a..c3341cd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -98,7 +98,8 @@
 
 #define KILOBYTE            0x400UL                 /* 1024 */
 #define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
-#define GIGABYTE            (KILOBYTE * MEGABYTE)   /* 1024*1024*1024 */
+#define GIGABYTE            ((uint64_t)(KILOBYTE * MEGABYTE))   /* 1024*1024*1024 */
+#define TERABYTE            ((uint64_t)(KILOBYTE * GIGABYTE))   /* 1024*1024*1024*1024 */
 
 #undef  NO_IRQ
 #define NO_IRQ              (-1)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index 6827476..8f3bc36 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -195,6 +195,14 @@ typedef uint8_t headerFieldUdp_t;
 
 #define NET_HEADER_FIELD_UDP_PORT_SIZE                  2
 
+typedef uint8_t headerFieldUdpLite_t;
+
+#define NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
+#define NET_HEADER_FIELD_UDP_LITE_PORT_DST              (NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
+
 typedef uint8_t headerFieldUdpEncapEsp_t;
 
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
@@ -381,6 +389,7 @@ typedef enum {
     HEADER_TYPE_IP,
     HEADER_TYPE_TCP,
     HEADER_TYPE_UDP,
+    HEADER_TYPE_UDP_LITE,
     HEADER_TYPE_IPHC,
     HEADER_TYPE_SCTP,
     HEADER_TYPE_SCTP_CHUNK_DATA,
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index efd9576..7a16880 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -426,24 +426,21 @@ static int __cold change_addr(struct mac_device *mac_dev, uint8_t *addr)
 
 static void adjust_link(struct net_device *net_dev)
 {
+#if (DPAA_VERSION < 11)
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
 	struct mac_device *mac_dev = priv->mac_dev;
 	struct phy_device *phy_dev = mac_dev->phy_dev;
-#if (DPAA_VERSION < 11)
 	struct mac_priv_s *mac_priv;
-#endif
 	int	 _errno;
 	t_Error	 err;
 
 	if (!phy_dev->link) {
-#if (DPAA_VERSION < 11)
 		fsl_pq_mdio_lock(NULL);
 
 		mac_priv = (struct mac_priv_s *)macdev_priv(mac_dev);
 		DtsecRestartTbiAN(mac_priv->mac);
 
 		fsl_pq_mdio_unlock(NULL);
-#endif
 		return;
 	}
 
@@ -454,6 +451,7 @@ static void adjust_link(struct net_device *net_dev)
 	if (unlikely(_errno < 0))
 		dpaa_eth_err(mac_dev->dev, "FM_MAC_AdjustLink() = 0x%08x\n",
 				err);
+#endif
 
 	return;
 }
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
index a357662..8488845 100644
--- a/include/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -819,6 +819,8 @@ typedef struct ioc_fm_port_mac_statistics_t {
     /* MIB II */
         uint64_t  if_in_octets;              /**< Total number of byte received. */
         uint64_t  if_in_pkts;                /**< Total number of packets received.*/
+        uint64_t  if_in_ucast_pkts;          /**< Total number of unicast frame received;
+                                             NOTE: this counter is not supported on dTSEC MAC */
         uint64_t  if_in_mcast_pkts;          /**< Total number of multicast frame received*/
         uint64_t  if_in_bcast_pkts;          /**< Total number of broadcast frame received */
         uint64_t  if_in_discards;            /**< Frames received, but discarded due to problems within the MAC RX. */
@@ -830,6 +832,8 @@ typedef struct ioc_fm_port_mac_statistics_t {
                                                    - The dedicated Error Code (0xfe, not a code error) was received */
         uint64_t  if_out_octets;             /**< Total number of byte sent. */
         uint64_t  if_out_pkts;               /**< Total number of packets sent .*/
+        uint64_t  if_out_ucast_pkts;         /**< Total number of unicast frame sent;
+                                             NOTE: this counter is not supported on dTSEC MAC */
         uint64_t  if_out_mcast_pkts;         /**< Total number of multicast frame sent */
         uint64_t  if_out_bcast_pkts;         /**< Total number of multicast frame sent */
         uint64_t  if_out_discards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
index 98cc01c..c99d64c 100644
--- a/include/linux/fmd/net_ioctls.h
+++ b/include/linux/fmd/net_ioctls.h
@@ -85,7 +85,6 @@ typedef uint8_t ioc_header_field_eth_t;
 
 #define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
 
-
 typedef uint16_t ioc_header_field_ip_t;
 
 #define IOC_NET_HEADER_FIELD_IP_VER                         (1)
@@ -196,6 +195,14 @@ typedef uint8_t ioc_header_field_udp_t;
 
 #define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE                  2
 
+typedef uint8_t ioc_header_field_udp_lite_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_DST              (IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
+
 typedef uint8_t ioc_header_field_udp_encap_esp_t;
 
 #define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
@@ -382,6 +389,7 @@ typedef enum {
     e_IOC_NET_HEADER_TYPE_IP,
     e_IOC_NET_HEADER_TYPE_TCP,
     e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_UDP_LITE,
     e_IOC_NET_HEADER_TYPE_IPHC,
     e_IOC_NET_HEADER_TYPE_SCTP,
     e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
-- 
1.7.5.4

