From 9209dfa5277252442000c2db1b9d12d8250dd448 Mon Sep 17 00:00:00 2001
From: Alexandru Badicioiu <b15898@freescale.com>
Date: Mon, 25 Feb 2013 17:12:54 +0000
Subject: [PATCH 487/518] dpa_classifier: Improve support for redirecting
 frames to direct KeyGen schemes

Direct scheme functionality allows dpa_classifier table to continue the
classification process while retaining the fqid as the frame final
destination in the case of match instead of enqueing frames.
Next classification ("classification" parameter) is entered through
the distribution pointed by "distribution" parameter.

Signed-off-by: Alexandru Badicioiu <b15898@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |   79 +++++++++++++++++---
 drivers/staging/fsl_dpa_offload/dpa_classifier.h   |    2 +-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |    1 +
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    8 ++
 include/linux/fsl_dpa_classifier.h                 |    5 +
 5 files changed, 82 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 215429b..4f6ea17 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -46,6 +46,7 @@
 /* FMD includes */
 #include "error_ext.h"
 #include "fm_pcd_ext.h"
+#include "fm_cc.h"
 
 
 /* Granularity of the descriptor tables */
@@ -411,7 +412,7 @@ int dpa_classif_table_modify_miss_action(int			td,
 
 	/* Fill the [miss_engine_params] structure w/ data */
 	errno = action_to_next_engine_params(miss_action, &miss_engine_params,
-		NULL, NULL);
+		NULL, NULL, NULL);
 	if (errno < 0) {
 		mutex_unlock(&ptable->access);
 		pr_err("ERROR: %s, %s (%d): Failed verification of miss action "
@@ -650,7 +651,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 					mod_params->action,
 					&key_params.ccNextEngineParams,
 					NULL,
-					(t_Handle)ptable->params.distribution);
+					(t_Handle)ptable->params.
+							distribution,
+					(t_Handle)ptable->params.
+							classification);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -735,7 +739,10 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 					mod_params->action,
 					&key_params.ccNextEngineParams,
 					NULL,
-					(t_Handle)ptable->params.distribution);
+					(t_Handle)ptable->params.
+						distribution,
+					(t_Handle)ptable->params.
+						classification);
 				if (ret < 0) {
 					mutex_unlock(&ptable->access);
 					pr_err("ERROR: %s, %s (%d): Failed "
@@ -1003,7 +1010,10 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		errno = action_to_next_engine_params(mod_params->action,
 					&next_engine_params,
 					&ptable->entry[entry_id].hmd,
-					(t_Handle)ptable->params.distribution);
+					(t_Handle)ptable->params.
+						distribution,
+					(t_Handle)ptable->params.
+						classification);
 		if (errno < 0)
 			return errno;
 
@@ -1107,7 +1117,10 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		errno = action_to_next_engine_params(mod_params->action,
 					&key_params.ccNextEngineParams,
 					&ptable->entry[entry_id].hmd,
-					(t_Handle)ptable->params.distribution);
+					(t_Handle)ptable->params.
+						distribution,
+					(t_Handle)ptable->params.
+						classification);
 		if (errno < 0)
 			return errno;
 
@@ -2550,7 +2563,8 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams,
 				&hmd,
-				(t_Handle)cls_table->params.distribution);
+				(t_Handle)cls_table->params.distribution,
+				(t_Handle)cls_table->params.classification);
 	if (errno < 0)
 		return errno;
 
@@ -2755,9 +2769,12 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 
 	if (cls_table->params.prefilled_entries) {
 		errno = action_to_next_engine_params(action,
-				&key_params.ccNextEngineParams,
-				NULL,
-				(t_Handle)cls_table->params.distribution);
+					&key_params.ccNextEngineParams,
+					NULL,
+					(t_Handle)cls_table->params.
+						distribution,
+					(t_Handle)cls_table->params.
+						classification);
 		if (errno < 0)
 			return errno;
 
@@ -2783,7 +2800,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams,
 				&hmd,
-				(t_Handle)cls_table->params.distribution);
+				(t_Handle)cls_table->params.distribution,
+				(t_Handle)cls_table->params.classification);
 	if (errno < 0)
 		return errno;
 
@@ -2909,7 +2927,8 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 				t_FmPcdCcNextEngineParams *next_engine_params,
 				int *hmd,
-				t_Handle distribution)
+				t_Handle distribution,
+				t_Handle classification)
 {
 	struct dpa_cls_table *next_table;
 #if (DPAA_VERSION >= 11)
@@ -2938,7 +2957,43 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	case DPA_CLS_TBL_ACTION_ENQ:
-		if (distribution) {
+		if (distribution && classification) {
+			t_FmPcdKgSchemeParams *scheme_params =
+				kzalloc(sizeof(t_FmPcdKgSchemeParams),
+					GFP_KERNEL);
+			if (!scheme_params) {
+				pr_err("ERROR: %s, %s (%d): Failed "
+					 "to alocate direct scheme params.\n",
+					__FILE__, __func__, __LINE__);
+				return -ENOMEM;
+			}
+			memset(scheme_params, 0, sizeof(*scheme_params));
+			scheme_params->modify = true;
+			scheme_params->alwaysDirect = true;
+#if (DPAA_VERSION >= 11)
+			scheme_params->bypassFqidGeneration = true;
+#else
+			scheme_params->bypassFqidGeneration = false;
+#endif
+			scheme_params->id.h_Scheme = distribution;
+			scheme_params->nextEngine = e_FM_PCD_CC;
+			scheme_params->kgNextEngineParams.cc.h_CcTree =
+					classification;
+			scheme_params->kgNextEngineParams.cc.grpId = 0;
+			scheme_params->keyExtractAndHashParams.
+					hashDistributionNumOfFqids = 1;
+
+			distribution = FM_PCD_KgSchemeSet(
+				((t_FmPcdCcTree *)classification)->h_FmPcd,
+				scheme_params);
+			kfree(scheme_params);
+			if (!distribution) {
+				pr_err("ERROR: %s, %s (%d): Failed "
+					"to set direct scheme.\n",
+					__FILE__, __func__, __LINE__);
+				return -EINVAL;
+			}
+
 			/* Redirect frames to KeyGen direct scheme */
 			next_engine_params->nextEngine = e_FM_PCD_KG;
 			next_engine_params->params.kgParams.h_DirectScheme =
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index cfc7378..7cb8ea3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -423,7 +423,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
  */
 static int	action_to_next_engine_params(const struct dpa_cls_tbl_action
 	*action, t_FmPcdCcNextEngineParams *next_engine_params, int *hmd,
-	t_Handle distribution);
+	t_Handle distribution, t_Handle classification);
 
 /*
  * Translates next engine parameters (from FMD) into action parameters for use
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 9b17d91..85395ea 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -201,6 +201,7 @@ struct dpa_cls_compat_tbl_params {
 	compat_uptr_t			fm_pcd;
 	compat_uptr_t			cc_node;
 	compat_uptr_t			distribution;
+	compat_uptr_t                   classification;
 	enum dpa_cls_tbl_type		type;
 	enum dpa_cls_tbl_entry_mgmt	entry_mgmt;
 	union {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 7a32c11..b4d4338 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -2472,6 +2472,10 @@ int dpa_cls_tbl_params_compatcpy(
 		kparam->table_params.distribution = compat_get_id2ptr(
 					uparam->table_params.distribution,
 					FM_MAP_TYPE_PCD_NODE);
+	if (compat_ptr(uparam->table_params.classification))
+		kparam->table_params.classification = compat_get_id2ptr(
+					uparam->table_params.classification,
+					FM_MAP_TYPE_PCD_NODE);
 
 	kparam->table_params.type	= uparam->table_params.type;
 	kparam->table_params.entry_mgmt	= uparam->table_params.entry_mgmt;
@@ -2515,6 +2519,10 @@ int dpa_cls_tbl_params_rcompatcpy(
 		uparam->table_params.distribution = compat_get_ptr2id(
 					kparam->table_params.distribution,
 					FM_MAP_TYPE_PCD_NODE);
+	if (kparam->table_params.classification)
+		uparam->table_params.classification = compat_get_ptr2id(
+					kparam->table_params.classification,
+					FM_MAP_TYPE_PCD_NODE);
 
 	uparam->table_params.type	= kparam->table_params.type;
 	uparam->table_params.entry_mgmt	= kparam->table_params.entry_mgmt;
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 16551e1..af64cd1 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -184,6 +184,11 @@ struct dpa_cls_tbl_params {
 	 */
 	void					*distribution;
 
+	/*
+	 * Handle to a FMan classification to send frames after distribution
+	*/
+	void                                    *classification;
+
 	/* The type of the DPA Classifier table */
 	enum dpa_cls_tbl_type			type;
 
-- 
1.7.5.4

