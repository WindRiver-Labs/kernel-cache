From 8ae039893c5e63e5799753bea16c5a35c85b057c Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 21 Mar 2013 14:54:56 +0800
Subject: [PATCH 024/518] pme: workaround for PME version 2.1.4

PME HW can hang in version 2.1.4
Add workaround to prevent scan larger than 4095B - 127B in size.

Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_pme2/Kconfig        |   12 ++++
 drivers/staging/fsl_pme2/pme2_high.c    |   85 ++++++++++++++++++++++++++++++-
 drivers/staging/fsl_pme2/pme2_private.h |   35 +++++++++++++
 drivers/staging/fsl_pme2/pme2_scan.c    |   12 ++++
 include/linux/fsl_pme.h                 |    3 +
 5 files changed, 145 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_pme2/Kconfig b/drivers/staging/fsl_pme2/Kconfig
index 90b3212..58c5f2d 100644
--- a/drivers/staging/fsl_pme2/Kconfig
+++ b/drivers/staging/fsl_pme2/Kconfig
@@ -140,6 +140,7 @@ config FSL_PME2_TEST_HIGH
 
 config FSL_PME2_TEST_SCAN
 	tristate "PME2 scan self-test"
+	depends on FSL_PME2_CTRL
 	default n
 	---help---
 	  This uses the high-level Qman driver (and the cpu-affine portals it
@@ -198,6 +199,17 @@ config FSL_PME2_SCAN_DEBUG
           The PME2_SCAN driver can optionally trace with more verbosity
           of verbosity.
 
+config FSL_PME_BUG_4K_SCAN_REV_2_1_4
+	bool "workaround for errata in PME version 2.1.4"
+	default y
+	---help---
+          If this option is selected, the driver will be compiled with a
+          workaround for this errata. This prevents scans of SUIs greater
+          than 4095 - 127 bytes when this revision of HW is detected.
+
+	  If in doubt, say Y.
+
+
 endif
 
 config FSL_PME2_STAT_ACCUMULATOR_UPDATE_INTERVAL
diff --git a/drivers/staging/fsl_pme2/pme2_high.c b/drivers/staging/fsl_pme2/pme2_high.c
index 111686b..bdb2d6e 100644
--- a/drivers/staging/fsl_pme2/pme2_high.c
+++ b/drivers/staging/fsl_pme2/pme2_high.c
@@ -250,6 +250,58 @@ static int empty_pipeline(struct pme_ctx *ctx, __maybe_unused u32 flags)
 	return ret;
 }
 
+/**
+ * set_pme_revision - set the pme revision in the ctx
+ *
+ * In order to make decisions based on PME HW version, read this
+ * information and store it on the ctx object.
+ */
+static int set_pme_revision(struct pme_ctx *ctx)
+{
+	int ret = 0;
+	u32 rev1, rev2;
+	struct device_node *dn;
+	const u32 *dt_rev;
+	int len;
+
+#ifdef CONFIG_FSL_PME2_CTRL
+	/* Can try and read it from CCSR */
+	if (pme2_have_control()) {
+		ret = pme_attr_get(pme_attr_rev1, &rev1);
+		if (ret)
+			return ret;
+		ret = pme_attr_get(pme_attr_rev2, &rev2);
+		if (ret)
+			return ret;
+		ctx->pme_rev1 = rev1;
+		ctx->pme_rev2 = rev2;
+		return 0;
+	}
+#endif
+
+	/* Not on control-plane, try and get it from pme portal node */
+	dn = of_find_node_with_property(NULL, "fsl,pme-rev1");
+	if (!dn)
+		return -ENODEV;
+	dt_rev = of_get_property(dn, "fsl,pme-rev1", &len);
+	if (!dt_rev || len != 4) {
+		of_node_put(dn);
+		return -ENODEV;
+	}
+	rev1 = *dt_rev;
+
+	dt_rev = of_get_property(dn, "fsl,pme-rev2", &len);
+	if (!dt_rev || len != 4) {
+		of_node_put(dn);
+		return -ENODEV;
+	}
+	rev2 = *dt_rev;
+	of_node_put(dn);
+	ctx->pme_rev1 = rev1;
+	ctx->pme_rev2 = rev2;
+	return ret;
+}
+
 int pme_ctx_init(struct pme_ctx *ctx, u32 flags, u32 bpid, u8 qosin,
 			u8 qosout, u16 dest,
 			const struct qm_fqd_stashing *stashing)
@@ -268,6 +320,13 @@ int pme_ctx_init(struct pme_ctx *ctx, u32 flags, u32 bpid, u8 qosin,
 	ctx->hw_flow = NULL;
 	ctx->hw_residue = NULL;
 
+	ret = set_pme_revision(ctx);
+	if (ret)
+		goto err;
+#ifdef CONFIG_FSL_PME_BUG_4K_SCAN_REV_2_1_4
+	if (is_version_2_1_4(ctx->pme_rev1, ctx->pme_rev2))
+		ctx->max_scan_size = PME_MAX_SCAN_SIZE_BUG_2_1_4;
+#endif
 	ctx->us_data = kzalloc(sizeof(struct pme_nostash), GFP_KERNEL);
 	if (!ctx->us_data)
 		goto err;
@@ -709,18 +768,40 @@ int pme_ctx_ctrl_nop(struct pme_ctx *ctx, u32 flags,
 }
 EXPORT_SYMBOL(pme_ctx_ctrl_nop);
 
-static inline void __prep_scan(__maybe_unused struct pme_ctx *ctx,
+static inline int __prep_scan(__maybe_unused struct pme_ctx *ctx,
 			struct qm_fd *fd, u32 args, struct pme_ctx_token *token)
 {
 	BUG_ON(ctx->flags & PME_CTX_FLAG_PMTCC);
 	token->cmd_type = pme_cmd_scan;
 	pme_fd_cmd_scan(fd, args);
+#ifdef CONFIG_FSL_PME_BUG_4K_SCAN_REV_2_1_4
+	pr_info("max_scan_size %d\n", ctx->max_scan_size);
+	if (ctx->max_scan_size) {
+		if (fd->format == qm_fd_contig || fd->format == qm_fd_sg) {
+			if (fd->length20 > ctx->max_scan_size) {
+				pr_info("Length = %d\n", fd->length20);
+				return -EINVAL;
+			}
+		} else if (fd->format == qm_fd_contig_big ||
+				fd->format == qm_fd_sg_big) {
+			if (fd->length29 > ctx->max_scan_size) {
+				pr_info("Length = %d\n", fd->length29);
+				return -EINVAL;
+			}
+		}
+	}
+#endif
+	return 0;
 }
 
 int pme_ctx_scan(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
 		struct pme_ctx_token *token)
 {
-	__prep_scan(ctx, fd, args, token);
+	int ret;
+
+	ret = __prep_scan(ctx, fd, args, token);
+	if (ret)
+		return ret;
 	return do_work(ctx, flags, fd, token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_scan);
diff --git a/drivers/staging/fsl_pme2/pme2_private.h b/drivers/staging/fsl_pme2/pme2_private.h
index 4f44f9f..33cbdda 100644
--- a/drivers/staging/fsl_pme2/pme2_private.h
+++ b/drivers/staging/fsl_pme2/pme2_private.h
@@ -178,3 +178,38 @@ int pme2_exclusive_unset(void);
 	pme_map(__f913); \
 })
 
+/* 4k minus residue */
+#define PME_MAX_SCAN_SIZE_BUG_2_1_4	(4095 - 127)
+
+#define PME_PM_IP_REV_1_IP_MJ_MASK 0x0000ff00UL
+#define PME_PM_IP_REV_1_IP_MJ_SHIFT 8UL
+#define PME_PM_IP_REV_1_IP_MN_MASK 0x000000ffUL
+#define PME_PM_IP_REV_1_IP_MN_SHIFT 0UL
+#define PME_PM_IP_REV_2_IP_ERR_MASK 0x0000ff00UL
+#define PME_PM_IP_REV_2_IP_ERR_SHIFT 8UL
+
+static inline int get_major_rev(u32 pme_rev1)
+{
+	return (pme_rev1 & PME_PM_IP_REV_1_IP_MJ_MASK) >>
+		PME_PM_IP_REV_1_IP_MJ_SHIFT;
+}
+
+static inline int get_minor_rev(u32 pme_rev1)
+{
+	return (pme_rev1 & PME_PM_IP_REV_1_IP_MN_MASK) >>
+		PME_PM_IP_REV_1_IP_MN_SHIFT;
+}
+
+static inline int get_errata_rev(u32 pme_rev2)
+{
+	return (pme_rev2 & PME_PM_IP_REV_2_IP_ERR_MASK) >>
+		PME_PM_IP_REV_2_IP_ERR_SHIFT;
+}
+
+static inline int is_version_2_1_4(u32 pme_rev1, u32 pme_rev2)
+{
+	return  (get_major_rev(pme_rev1) == 2) &&
+		(get_minor_rev(pme_rev1) == 1) &&
+		(get_errata_rev(pme_rev2) == 4);
+}
+
diff --git a/drivers/staging/fsl_pme2/pme2_scan.c b/drivers/staging/fsl_pme2/pme2_scan.c
index 3303b23..f00081e 100644
--- a/drivers/staging/fsl_pme2/pme2_scan.c
+++ b/drivers/staging/fsl_pme2/pme2_scan.c
@@ -461,6 +461,18 @@ static int process_scan_cmd(
 	memset(token_p, 0, sizeof(*token_p));
 	/* Copy the command to kernel space */
 	memcpy(&token_p->kernel_op, user_cmd, sizeof(struct pme_scan_cmd));
+
+#ifdef CONFIG_FSL_PME_BUG_4K_SCAN_REV_2_1_4
+	if (session->ctx.max_scan_size) {
+		if (token_p->kernel_op.input.size >
+				session->ctx.max_scan_size) {
+			if (!synchronous)
+				kfree(token_p);
+			return -EINVAL;
+		}
+	}
+#endif
+
 	/* Copy the input */
 	token_p->synchronous = synchronous;
 	token_p->tx_size = token_p->kernel_op.input.size;
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 6e87241..1c8482f 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -490,6 +490,9 @@ struct pme_ctx {
 	struct qm_fqd_stashing stashing;
 	struct qm_fd update_fd;
 	struct pme_nostash *us_data;
+	u32 pme_rev1;
+	u32 pme_rev2;
+	int max_scan_size;
 };
 
 /* Flags for pme_ctx_init() */
-- 
1.7.5.4

