From 9d1101d1142dddd7cf45a66f24b7408420a5f79d Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 21 Mar 2013 15:06:57 +0800
Subject: [PATCH 038/518] powerpc/mpc85xx/e6500: module support for A-006198
 workaround

By letting the compiler obtain the address of the function, we should
avoid problems with module relocation.  Note that on the ppc64 ABI,
when we convert a function pointer to an integer pointer, we get a
pointer to a descriptor rather than the program code, and thus we
need an extra dereference compared to other ABIs.  It is likely that
the relocation problem resulted from the previous asm code trying to
directly reference the code address (i.e. the symbol beginning with a
period).

Signed-off-by: Scott Wood <scottwood@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/hw_irq.h |   22 ++++++++++++++--------
 1 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/arch/powerpc/include/asm/hw_irq.h b/arch/powerpc/include/asm/hw_irq.h
index 3bf2f7d..116e90c 100644
--- a/arch/powerpc/include/asm/hw_irq.h
+++ b/arch/powerpc/include/asm/hw_irq.h
@@ -91,19 +91,22 @@ static inline bool arch_irqs_disabled(void)
 #ifdef CONFIG_FSL_ERRATUM_A_006198
 static inline void __hard_irq_disable(void)
 {
+	void fsl_erratum_a006198_return(void);
 	unsigned long tmp;
 
-	asm volatile("ld %0, 1f@got(2);"
+	asm volatile("bl 2f;"
+		     "2: mflr %0;"
+		     "addi %0, %0, 1f-2b;"
 		     "mtlr %0;"
-		     "ld %0, .fsl_erratum_a006198_return@got(2);"
-		     "mtspr %1, %0;"
+		     "mtspr %1, %4;"
 		     "mfmsr %0;"
 		     "rlwinm %0, %0, 0, ~%3;"
 		     "mtspr %2, %0;"
 		     "rfmci;"
 		     "1: mtmsr %0" : "=&r" (tmp) :
 		     "i" (SPRN_MCSRR0), "i" (SPRN_MCSRR1),
-		     "i" (MSR_EE) : "memory", "lr");
+		     "i" (MSR_EE), "r" (*(u64 *)fsl_erratum_a006198_return) :
+		     "memory", "lr");
 }
 #else
 #define __hard_irq_disable()	asm volatile("wrteei 0" : : : "memory")
@@ -160,17 +163,20 @@ static inline void arch_local_irq_restore(unsigned long flags)
 {
 #if defined(CONFIG_BOOKE)
 #ifdef CONFIG_FSL_ERRATUM_A_006198
+	void fsl_erratum_a006198_return(void);
 	unsigned long tmp;
 
-	asm volatile("ld %0, 1f@got(2);"
+	asm volatile("bl 2f;"
+		     "2: mflr %0;"
+		     "addi %0, %0, 1f-2b;"
 		     "mtlr %0;"
-		     "ld %0, .fsl_erratum_a006198_return@got(2);"
 		     "mtspr %1, %3;"
-		     "mtspr %2, %0;"
+		     "mtspr %2, %4;"
 		     "rfmci;"
 		     "1: mtmsr %3" : "=&r" (tmp) :
 		     "i" (SPRN_MCSRR1), "i" (SPRN_MCSRR0),
-		     "r" (flags) : "memory", "lr");
+		     "r" (flags), "r" (*(u64 *)fsl_erratum_a006198_return) :
+		     "memory", "lr");
 #else
 	asm volatile("wrtee %0" : : "r" (flags) : "memory");
 #endif
-- 
1.7.5.4

