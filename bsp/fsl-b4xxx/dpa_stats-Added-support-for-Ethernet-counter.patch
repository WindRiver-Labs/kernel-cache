From 79f7d8886a6d937d0e118cec5b662ceafa6d962d Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:52:16 +0000
Subject: [PATCH 252/518] dpa_stats: Added support for Ethernet counter

Added support for Ethernet single and class counter. User
can retrieve RMON statistics for one or multiple Ethernet interfaces

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  384 ++++++++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_stats.h |   49 ++++
 include/linux/fsl_dpa_stats.h               |  107 ++++++++
 3 files changed, 538 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index f19b39d..61f901d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -34,6 +34,8 @@
  */
 
 #include <linux/of_platform.h>
+#include "lnxwrp_fm.h"
+#include "dpaa_eth.h"
 
 /* DPA offloading layer includes */
 #include "dpa_compat.h"
@@ -234,6 +236,329 @@ static void free_resources(void)
 	gbl_dpa_stats = NULL;
 }
 
+static void create_cnt_eth_stats(struct dpa_stats *dpa_stats)
+{
+	struct t_FmMacStatistics stats;
+
+	/* DPA_STATS_CNT_ETH_DROP_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][0] =
+			(void *)&stats.eStatsDropEvents - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_BYTES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][1] =
+			(void *)&stats.ifInOctets - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][2] =
+			(void *)&stats.ifInPkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_BC_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][3] =
+			(void *)&stats.ifInBcastPkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_MC_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][4] =
+			(void *)&stats.ifInMcastPkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_CRC_ALIGN_ERR */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][5] =
+			(void *)&stats.eStatCRCAlignErrors - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_UNDERSIZE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][6] =
+			(void *)&stats.eStatUndersizePkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_OVERSIZE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][7] =
+			(void *)&stats.eStatOversizePkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_FRAGMENTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][8] =
+			(void *)&stats.eStatFragments - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_JABBERS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][9] =
+			(void *)&stats.eStatJabbers - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_64BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][10] =
+			(void *)&stats.eStatPkts64 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_65_127BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][11] =
+			(void *)&stats.eStatPkts65to127 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_128_255BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][12] =
+			(void *)&stats.eStatPkts128to255 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_256_511BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][13] =
+			(void *)&stats.eStatPkts256to511 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_512_1023BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][14] =
+			(void *)&stats.eStatPkts512to1023 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_1024_1518BYTE_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][15] =
+			(void *)&stats.eStatPkts1024to1518 - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_OUT_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][16] =
+			(void *)&stats.ifOutPkts - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_OUT_DROP_PKTS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][17] =
+			(void *)&stats.ifOutDiscards - (void *)&stats;
+	/* DPA_STATS_CNT_ETH_IN_UNICAST_PKTS : Not supported for now */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][18] = 0;
+	/* DPA_STATS_CNT_ETH_OUT_UNICAST_PKTS : Not supported for now */
+	dpa_stats->stats_sel[DPA_STATS_CNT_ETH][19] = 0;
+}
+
+static t_Handle get_fman_ethernet_dev_node(
+		struct device_node *parent_dev_node, int port_id)
+{
+	struct device_node *dev_node, *tmp_node = NULL;
+	struct mac_device  *mac_dev = NULL;
+	const uint32_t	*cell_index;
+	char *mac;
+	int lenp;
+
+	if (port_id > DPA_STATS_ETH_1G_PORT3) {
+		mac = "fsl,fman-10g-mac";
+		port_id -= DPA_STATS_ETH_10G_PORT0;
+	} else {
+		mac = "fsl,fman-1g-mac";
+	}
+
+	while ((dev_node = of_find_compatible_node(tmp_node, NULL,
+			mac)) != NULL) {
+		if (parent_dev_node == of_get_parent(dev_node)) {
+			cell_index = (uint32_t *)of_get_property(
+					dev_node, "cell-index", &lenp);
+			if (*cell_index == port_id) {
+				mac_dev = dev_get_drvdata(&
+					of_find_device_by_node(dev_node)->dev);
+				return mac_dev->get_mac_handle(mac_dev);
+			}
+		}
+
+		tmp_node = dev_node;
+	}
+
+	return NULL;
+}
+
+static struct device_node *get_fman_dev_node(int fman_id)
+{
+	struct device_node *dev_node, *tmp_node = NULL;
+	const uint32_t *cell_index;
+	int lenp;
+
+	while ((dev_node = of_find_compatible_node(tmp_node, NULL, "fsl,fman"))
+			!= NULL) {
+		cell_index = (uint32_t *)of_get_property(dev_node, "cell-index",
+						&lenp);
+		if (*cell_index == fman_id)
+			break;
+
+		tmp_node = dev_node;
+	}
+
+	return dev_node;
+}
+
+static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
+{
+	struct device_node *dev_node = NULL;
+	t_Handle *h_FmMac = NULL;
+
+	/* Get FMAN device node */
+	dev_node = get_fman_dev_node(src.engine_id);
+	if (!dev_node) {
+		pr_err("FMan device node couldn't be found\n");
+		return -EINVAL;
+
+	}
+
+	/* Get Ethernet device node */
+	h_FmMac = get_fman_ethernet_dev_node(dev_node, src.eth_id);
+	if (!h_FmMac) {
+		pr_err("Ethernet device node couldn't be found\n");
+		return -EINVAL;
+	}
+
+	/* Return FM MAC handle */
+	*mac = h_FmMac;
+
+	return 0;
+}
+
+static void cnt_sel_to_stats(struct stats_info *stats_info,
+		int *stats_sel, uint32_t cnt_sel)
+{
+	uint32_t bitVal = 0, bitPos = 0, cntPos = 1;
+
+	while (cnt_sel > 0) {
+		bitVal = cnt_sel & 0x00000001;
+		stats_info->stats_off[cntPos - bitVal] = stats_sel[bitPos++];
+		cntPos += bitVal;
+		cnt_sel >>= 1;
+	}
+
+	stats_info->stats_num = cntPos - 1;
+}
+
+static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
+				const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->eth_params.cnt_sel;
+	t_Handle h_FmMac = NULL;
+	int	 err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Ethernet counter selection */
+	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_ETH_ALL)) {
+		pr_err("Invalid Ethernet counter selection\n");
+		return -EINVAL;
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_ETH_ALL)
+		cnt_sel -= 1;
+
+	/* 1G Port, DTSEC controller */
+	if (params->eth_params.src.eth_id < DPA_STATS_ETH_10G_PORT0) {
+		if ((cnt_sel & DPA_STATS_CNT_ETH_IN_UNICAST_PKTS) ||
+			(cnt_sel & DPA_STATS_CNT_ETH_OUT_UNICAST_PKTS)) {
+			pr_err("Invalid Ethernet counter selection\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Get FM MAC handle */
+	err = get_fm_mac(params->eth_params.src, &h_FmMac);
+	if (err != 0) {
+		pr_err("Could not obtain FM MAC handle!\n");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs[0] = h_FmMac;
+	cnt_gen_cb->objs_num = 1;
+
+	/* Map Ethernet counter selection to FM MAC statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+
+	return 0;
+}
+
+static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->eth_params.cnt_sel;
+	t_Handle h_FmMac = NULL;
+	uint32_t i = 0;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Ethernet counter selection */
+	if ((params->eth_params.cnt_sel == 0) ||
+			(params->eth_params.cnt_sel > DPA_STATS_CNT_ETH_ALL)) {
+		pr_err("Invalid Ethernet counter selection");
+		return -EINVAL;
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_ETH_ALL)
+		cnt_sel -= 1;
+
+	for (i = 0; i < params->class_members; i++) {
+		/* 1G Port, DTSEC controller */
+		if (params->eth_params.src[i].eth_id <
+				DPA_STATS_ETH_10G_PORT0) {
+			if ((cnt_sel & DPA_STATS_CNT_ETH_IN_UNICAST_PKTS) ||
+			   (cnt_sel & DPA_STATS_CNT_ETH_OUT_UNICAST_PKTS)) {
+				pr_err("Invalid Ethernet counter selection\n");
+				return -EINVAL;
+			}
+		}
+
+		/* Get FM MAC handle */
+		err = get_fm_mac(params->eth_params.src[i], &h_FmMac);
+		if (err != 0) {
+			pr_err("Could not obtain FM MAC handle!\n");
+			return -EINVAL;
+		}
+
+		cnt_gen_cb->objs[i] = h_FmMac;
+	}
+
+	cnt_gen_cb->objs_num = params->class_members;
+
+	/* Map Ethernet counter selection to FM MAC statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
+				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	return 0;
+}
+
+static inline void get_cnt_64bit_stats(struct dpa_stats_req_cb *req_cb,
+		struct stats_info *stats_info, void *stats, uint32_t idx)
+{
+	uint32_t j = 0;
+	uint64_t stats_val;
+
+	for (j = 0; j < stats_info->stats_num; j++) {
+		/* Get statistics value */
+		stats_val = *((uint64_t *)(stats + stats_info->stats_off[j]));
+
+		/* Check for rollover */
+		if (stats_val < stats_info->last_stats[idx][j])
+			stats_info->stats[idx][j] +=
+				((unsigned long int)0xffffffff -
+				stats_info->last_stats[idx][j]) + stats_val;
+		else
+			stats_info->stats[idx][j] += stats_val -
+				stats_info->last_stats[idx][j];
+
+		/* Store the current value as the last read value */
+		stats_info->last_stats[idx][j] = stats_val;
+
+		/* Write the memory location */
+		*(uint32_t *)(req_cb->request_area) =
+				(uint32_t)stats_info->stats[idx][j];
+
+		/* Update the memory pointer */
+		req_cb->request_area += STATS_VAL_SIZE;
+
+		if (stats_info->reset)
+			stats_info->stats[idx][j] = 0;
+	}
+}
+
+static int get_cnt_eth_stats(struct dpa_stats_req_cb *req_cb,
+			struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmMacStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Ethernet Counter value\n");
+			return -ENOENT;
+		}
+
+		get_cnt_64bit_stats(req_cb,
+				&cnt_cb->gen_cb.info, (void *)&stats, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -271,6 +596,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 		return err;
 	}
 
+	/* Map each Ethernet counter selection to a FM-MAC statistics */
+	create_cnt_eth_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -283,7 +611,7 @@ int dpa_stats_create_counter(int dpa_stats_id,
 {
 	struct dpa_stats *dpa_stats = NULL;
 	struct dpa_stats_cnt_cb *cnt_cb = NULL;
-	int err = 0;
+	int err = 0, err_rb = 0;
 	uint32_t id;
 
 	/* multiple DPA Stats instances are not currently supported */
@@ -308,10 +636,36 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		return err;
 	}
 
+	switch (params->type) {
+	case DPA_STATS_CNT_ETH:
+		err = set_cnt_eth_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create ETH counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_ETH;
+		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
+		break;
+	default:
+		pr_err("Invalid counter type\n");
+		return -EINVAL;
+	};
+
 	/* Counter was created. Return the counter id */
 	*dpa_stats_cnt_id = id;
 
 	return 0;
+
+create_counter_err:
+	/* A invalid Counter ID is returned if 'put_cnt' succeeds and the actual
+	 * reserved Counter ID if it fails. The Counter ID can be used to try
+	 * again to free resources by calling dpa_stats_remove_counter
+	 */
+	err_rb = put_cnt(dpa_stats, cnt_cb);
+	if (err_rb < 0)
+		*dpa_stats_cnt_id = id;
+
+	return err;
 }
 EXPORT_SYMBOL(dpa_stats_create_counter);
 
@@ -322,7 +676,7 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 	struct dpa_stats *dpa_stats = NULL;
 	struct dpa_stats_cnt_cb *cnt_cb = NULL;
 	uint32_t id;
-	int err = 0;
+	int err = 0, err_rb = 0;
 
 	/* multiple DPA Stats instances are not currently supported */
 	unused(dpa_stats_id);
@@ -352,10 +706,36 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		return err;
 	}
 
+	switch (params->type) {
+	case DPA_STATS_CNT_ETH:
+		err = set_cls_cnt_eth_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create ETH counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_ETH;
+		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
+		break;
+	default:
+		pr_err("Invalid counter type\n");
+		return -EINVAL;
+	};
+
 	/* Counter was created. Return the counter id */
 	*dpa_stats_cnt_id = id;
 
 	return 0;
+
+create_counter_err:
+	/* A invalid Counter ID is returned if 'put_cnt' succeeds and the actual
+	 * reserved Counter ID if it fails. The Counter ID can be used to try
+	 * again to free resources by calling dpa_stats_remove_counter
+	 */
+	err_rb = put_cnt(dpa_stats, cnt_cb);
+	if (err_rb < 0)
+		*dpa_stats_cnt_id = id;
+
+	return err;
 }
 EXPORT_SYMBOL(dpa_stats_create_class_counter);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index 10ee6b9..4c8f635 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -42,6 +42,10 @@
 #include "dpa_compat.h"
 #include "cq.h"
 
+#define MAX_NUM_OF_STATS DPA_STATS_MAX_NUM_OF_COUNTERS
+#define NUM_OF_CNT_TYPES (DPA_STATS_CNT_TRAFFIC_MNG + 1)
+#define MAX_NUM_OF_MEMBERS DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS
+
 /* DPA Stats - Control Block */
 struct dpa_stats {
 	struct dpa_stats_params config;	/* Configuration parameters as
@@ -49,14 +53,59 @@ struct dpa_stats {
 	struct cq *cnt_id_cq;	/* Circular Queue with ids for stats counters */
 	uint32_t *used_cnt_ids;	/* Counter ids used by this dpa_stats instance*/
 	struct dpa_stats_cnt_cb *cnts_cb; /* Array of counters control blocks */
+	int stats_sel[NUM_OF_CNT_TYPES][MAX_NUM_OF_STATS]; /* Array that stores
+					the mapping between counter selection
+					and statistics values */
+};
+
+/* DPA Stats  request control block */
+struct dpa_stats_req_cb {
+	uint32_t req_id; /* Request id */
+	uint32_t req_index; /* Request index in the 'used_req_ids'*/
+	void *request_area; /* Address in the storage area
+				associated with this request */
+	uint32_t bytes_num; /* Number of bytes written by this request */
+	uint32_t cnts_num; /* Number of counters written by this request */
+	struct list_head async_req_node; /* For linking async req list */
+};
+
+/* DPA Stats - statistics information */
+struct stats_info {
+	unsigned int stats_off[MAX_NUM_OF_STATS]; /* Array of statistics offsets
+				relative to corresponding statistics area */
+	unsigned int stats_num; /* Number of statistics to retrieve */
+	uint64_t stats[MAX_NUM_OF_MEMBERS][MAX_NUM_OF_STATS]; /* Array to store
+				statistics values */
+	uint64_t last_stats[MAX_NUM_OF_MEMBERS][MAX_NUM_OF_STATS]; /* Array to
+				store previous statistics values */
+	bool reset; /* Reset counter's statistics */
+};
+
+/* DPA Stats General Counter control block */
+struct dpa_stats_cnt_gen_cb {
+	void *objs[MAX_NUM_OF_MEMBERS]; /* Array of objects for which to
+				       retrieve statistics */
+	unsigned int objs_num;  /* Number of objects for which to
+				   retrieve statistics */
+	struct stats_info info;
+				/* Counter's statistics information */
 };
 
+typedef int get_cnt_stats(struct dpa_stats_req_cb *req_cb,
+					struct dpa_stats_cnt_cb *cnt_cb);
+
 /* DPA Stats counter control block */
 struct dpa_stats_cnt_cb {
 	struct dpa_stats *dpa_stats; /* Pointer to DPA Stats */
 	uint32_t cnt_id;  /* Counter identifier */
 	uint32_t cnt_index; /* Counter index in the 'used_cnt_ids'*/
 	uint32_t bytes_num; /* Number of bytes occupied by this counter */
+	enum dpa_stats_cnt_type type; /* Counter type */
+	union {
+		struct dpa_stats_cnt_gen_cb gen_cb;
+	};
+	get_cnt_stats *f_get_cnt_stats; /* Function used to retrieve the
+				statistics for a specific counter */
 };
 
 #endif /* __DPA_STATS_H */
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 36634fd..2f6f6c9 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -78,11 +78,113 @@ enum dpa_stats_cnt_type {
 #endif
 };
 
+/* DPA Stats Ethernet counter selection */
+enum dpa_stats_cnt_eth_sel {
+	/* Total number of dropped packets on receive */
+	DPA_STATS_CNT_ETH_DROP_PKTS		= 0x00000001,
+	/* Total number of received bytes of data */
+	DPA_STATS_CNT_ETH_BYTES			= 0x00000002,
+	/* Total number of received packets */
+	DPA_STATS_CNT_ETH_PKTS			= 0x00000004,
+	/* Total number of received broadcast packets */
+	DPA_STATS_CNT_ETH_BC_PKTS		= 0x00000008,
+	/* Total number of received multicast packets */
+	DPA_STATS_CNT_ETH_MC_PKTS		= 0x00000010,
+	/* Total number of received frames with alignment error or invalid FCS*/
+	DPA_STATS_CNT_ETH_CRC_ALIGN_ERR		= 0x00000020,
+	/*
+	 * Total number of received packets that were
+	 * less than 64 bytes and were well formed
+	 */
+	DPA_STATS_CNT_ETH_UNDERSIZE_PKTS	= 0x00000040,
+	/*
+	 * Total number of received packets that were above 1518 bytes
+	 * (non-VLAN) or 1522 (VLAN) or above a configured maximum frame
+	 * length and were well formed
+	 */
+	DPA_STATS_CNT_ETH_OVERSIZE_PKTS		= 0x00000080,
+	/*
+	 * Total number of received packets that were less than
+	 * 64 bytes and had a bad FCS
+	 */
+	DPA_STATS_CNT_ETH_FRAGMENTS		= 0x00000100,
+	/*
+	 * Total number of received packets with size above 1518 bytes
+	 * (non-VLAN) or 1522 (VLAN) or a configured maximum frame length
+	 * and with an invalid FCS or an alignment error
+	 */
+	DPA_STATS_CNT_ETH_JABBERS		= 0x00000200,
+	/* Total number of received packets with size below 64 bytes*/
+	DPA_STATS_CNT_ETH_64BYTE_PKTS		= 0x00000400,
+	/* Total number of received packets with size between 65 and 127bytes */
+	DPA_STATS_CNT_ETH_65_127BYTE_PKTS	= 0x00000800,
+	/* Total number of received packets with size between 128-255bytes */
+	DPA_STATS_CNT_ETH_128_255BYTE_PKTS	= 0x00001000,
+	/* Total number of received packets with size between 256-511bytes */
+	DPA_STATS_CNT_ETH_256_511BYTE_PKTS	= 0x00002000,
+	/* Total number of received packets with size between 512-1023bytes */
+	DPA_STATS_CNT_ETH_512_1023BYTE_PKTS	= 0x00004000,
+	/* Total number of received packets with size between 1024-1518bytes */
+	DPA_STATS_CNT_ETH_1024_1518BYTE_PKTS	= 0x00008000,
+	/* Total number of packets on transmit */
+	DPA_STATS_CNT_ETH_OUT_PKTS		= 0x00010000,
+	/* Total number of dropped packets on transmit */
+	DPA_STATS_CNT_ETH_OUT_DROP_PKTS		= 0x00020000,
+	/* Total number of unicast packets on receive */
+	DPA_STATS_CNT_ETH_IN_UNICAST_PKTS	= 0x00040000,
+	/* Total number of unicast packets on transmit */
+	DPA_STATS_CNT_ETH_OUT_UNICAST_PKTS	= 0x00080000,
+	/* Select all counters */
+	DPA_STATS_CNT_ETH_ALL			= 0x00100000
+};
+
+/* DPA Stats Ethernet id */
+enum dpa_stats_cnt_eth_id {
+	DPA_STATS_ETH_1G_PORT0 = 0,	/* 1G port, ETH id 0 */
+	DPA_STATS_ETH_1G_PORT1,		/* 1G port, ETH id 1 */
+	DPA_STATS_ETH_1G_PORT2,		/* 1G port, ETH id 2 */
+	DPA_STATS_ETH_1G_PORT3,		/* 1G port, ETH id 3 */
+	DPA_STATS_ETH_10G_PORT0		/* 10G port, ETH id 0 */
+};
+
+/* DPA Stats Ethernet counter source definition */
+struct dpa_stats_cnt_eth_src {
+	/* Index of the engine device the Ethernet interface belongs to */
+	uint8_t engine_id;
+
+	/* Index of the Ethernet interface, relative to the engine */
+	enum dpa_stats_cnt_eth_id eth_id;
+};
+
+/* DPA Stats Ethernet counter parameters */
+struct dpa_stats_cnt_eth {
+	/* Ethernet counter source */
+	struct dpa_stats_cnt_eth_src src;
+
+	/* Single or multiple selections of Ethernet counters
+	 * from enumeration dpa_stats_cnt_eth_sel */
+	uint32_t cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
 	/* The type of DPA Stats counter */
 	enum dpa_stats_cnt_type type;
+
+	union {
+		/* Parameters for Ethernet counter */
+		struct dpa_stats_cnt_eth eth_params;
+	};
+};
+
+/* DPA Stats Ethernet class counter parameters */
+struct dpa_stats_cls_cnt_eth {
+	/* Array of Ethernet counters sources */
+	struct dpa_stats_cnt_eth_src *src;
+
+	/* Single selection of Ethernet counter */
+	enum dpa_stats_cnt_eth_sel cnt_sel;
 };
 
 /* DPA Stats class counter parameters */
@@ -93,6 +195,11 @@ struct dpa_stats_cls_cnt_params {
 
 	/* The type of DPA Stats class counter */
 	enum dpa_stats_cnt_type type;
+
+	union {
+		/* Parameters for Ethernet class counter */
+		struct dpa_stats_cls_cnt_eth eth_params;
+	};
 };
 
 /* Creates and initializes a DPA Stats instance */
-- 
1.7.5.4

