From ad98cab9d8bd6fa00d2a5bc310a6fcdf6106a665 Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Tue, 12 Mar 2013 14:55:07 +0000
Subject: [PATCH 507/518] offline_port: Add support for enabling IP
 Fragmentation in the O/H port driver

In order to enable fragmentation on an offline port, a chosen node
should be configured in dt for that specific port with two parameters:
manip_extra_space and data_align.
In addition external buffer pools must be set for the O/H port in
the dts file (e.g: fsl,bman-buffer-pools = <&bp8>;).

A bool flag is transmited to dpaa_eth_init_port (used further in FMD wrapper)
macro whether or not fragmentation was enabled.
For the dpaa_eth module this flag must be set to false.(FMD frag support is
only available on O/H ports).

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../net/ethernet/freescale/dpa/dpaa_eth-common.h   |    5 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |    6 +-
 drivers/net/ethernet/freescale/dpa/offline_port.c  |  109 +++++++++++++++++++-
 3 files changed, 111 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
index ea110a8..e1590e7 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
@@ -74,14 +74,15 @@ struct dpa_buffer_layout_s {
 #define DPA_HASH_RESULTS_SIZE 8
 
 
-#define dpaa_eth_init_port(type, port, param, errq_id, defq_id, buf_layout) \
+#define dpaa_eth_init_port(type, port, param, errq_id, defq_id, buf_layout,\
+			   frag_enabled) \
 { \
 	param.errq = errq_id; \
 	param.defq = defq_id; \
 	param.priv_data_size = buf_layout->priv_data_size; \
 	param.parse_results = buf_layout->parse_results; \
 	param.hash_results = buf_layout->hash_results; \
-	param.frag_enable = false; \
+	param.frag_enable = frag_enabled; \
 	param.time_stamp = buf_layout->time_stamp; \
 	param.manip_extra_space = buf_layout->manip_extra_space; \
 	param.data_align = buf_layout->data_align; \
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index e12d6cc..3763014 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -3620,9 +3620,10 @@ dpaa_eth_init_tx_port(struct fm_port *port, struct dpa_fq *errq,
 		struct dpa_fq *defq, struct dpa_buffer_layout_s *buf_layout)
 {
 	struct fm_port_params tx_port_param;
+	bool frag_enabled = false;
 
 	dpaa_eth_init_port(tx, port, tx_port_param, errq->fqid, defq->fqid,
-			   buf_layout);
+			   buf_layout, frag_enabled);
 }
 
 static void __devinit
@@ -3632,6 +3633,7 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 {
 	struct fm_port_params rx_port_param;
 	int i;
+	bool frag_enabled = false;
 
 	count = min(ARRAY_SIZE(rx_port_param.pool_param), count);
 	rx_port_param.num_pools = count;
@@ -3647,7 +3649,7 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 	rx_port_param.data_align = ???
 */
 	dpaa_eth_init_port(rx, port, rx_port_param, errq->fqid, defq->fqid,
-			   buf_layout);
+			   buf_layout, frag_enabled);
 }
 
 static void dpa_rx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
diff --git a/drivers/net/ethernet/freescale/dpa/offline_port.c b/drivers/net/ethernet/freescale/dpa/offline_port.c
index 4e9184b..a8afc36 100644
--- a/drivers/net/ethernet/freescale/dpa/offline_port.c
+++ b/drivers/net/ethernet/freescale/dpa/offline_port.c
@@ -47,6 +47,12 @@
 #include "dpaa_eth-common.h"
 
 #define OH_MOD_DESCRIPTION	"FSL FMan Offline Parsing port driver"
+/*
+ * Manip extra space and data alignment for fragmentation
+ */
+#define FRAG_MANIP_SPACE 128
+#define FRAG_DATA_ALIGN 64
+
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Bogdan Hamciuc <bogdan.hamciuc@freescale.com>");
@@ -117,23 +123,31 @@ oh_port_probe(struct platform_device *_of_dev)
 {
 	struct device		*dpa_oh_dev;
 	struct device_node	*dpa_oh_node;
-	int			 lenp, _errno = 0, fq_idx;
-	const phandle		*oh_port_handle;
+	int			 lenp, _errno = 0, fq_idx, n_size, i;
+	const phandle		*oh_port_handle, *bpool_handle;
 	struct platform_device	*oh_of_dev;
-	struct device_node	*oh_node;
+	struct device_node	*oh_node, *bpool_node = NULL, *root_node;
 	struct device		*oh_dev;
 	struct dpa_oh_config_s	*oh_config;
 	uint32_t		*oh_all_queues;
 	uint32_t		 queues_count;
 	uint32_t		 crt_fqid_base;
 	uint32_t		 crt_fq_count;
-	struct fm_port_params	 oh_port_tx_params;
+	bool			frag_enabled = FALSE;
+
+	struct fm_port_params	oh_port_tx_params;
+
 	struct fm_port_pcd_param	oh_port_pcd_params;
 	struct dpa_buffer_layout_s buf_layout;
 	/* True if the current partition owns the OH port. */
 	bool init_oh_port;
 	const struct of_device_id *match;
+	uint32_t crt_ext_pools_count, ext_pool_size;
+	const unsigned int *port_id;
+	const uint32_t		*bpool_cfg;
+	const uint32_t		*bpid;
 
+	memset(&oh_port_tx_params, 0, sizeof(oh_port_tx_params));
 	dpa_oh_dev = &_of_dev->dev;
 	dpa_oh_node = dpa_oh_dev->of_node;
 	BUG_ON(dpa_oh_node == NULL);
@@ -175,6 +189,10 @@ oh_port_probe(struct platform_device *_of_dev)
 	dev_info(dpa_oh_dev, "Found OH node handle compatible with %s.\n",
 		match->compatible);
 
+	port_id = (unsigned  int *)of_get_property(oh_node,
+					"cell-index", &lenp);
+
+	BUG_ON(lenp % sizeof(*port_id));
 	oh_of_dev = of_find_device_by_node(oh_node);
 	BUG_ON(oh_of_dev == NULL);
 	oh_dev = &oh_of_dev->dev;
@@ -279,10 +297,87 @@ oh_port_probe(struct platform_device *_of_dev)
 		goto return_kfree;
 	}
 
+	bpool_handle = of_get_property(dpa_oh_node,
+			"fsl,bman-buffer-pools", &lenp);
+
+	if (bpool_handle == NULL) {
+		dev_info(dpa_oh_dev, "OH port %s has no buffer pool."
+			" Fragmentation will not be enabled\n",
+			oh_node->full_name);
+		goto init_port;
+	}
+
+	/* used for reading ext_pool_size*/
+	root_node = of_find_node_by_path("/");
+	if (root_node == NULL) {
+		dev_err(dpa_oh_dev, "of_find_node_by_path(/) failed\n");
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+
+	n_size = of_n_size_cells(root_node);
+	of_node_put(root_node);
+
+	crt_ext_pools_count = lenp / sizeof(phandle);
+	dev_dbg(dpa_oh_dev, "OH port number of pools = %u\n",
+					crt_ext_pools_count);
+
+	oh_port_tx_params.num_pools = crt_ext_pools_count;
+
+	for (i = 0; i < crt_ext_pools_count; i++) {
+		bpool_node = of_find_node_by_phandle(bpool_handle[i]);
+		if (bpool_node == NULL) {
+			dev_err(dpa_oh_dev, "Invalid Buffer pool node\n");
+			_errno = -EINVAL;
+			goto return_kfree;
+		}
+
+		bpid = of_get_property(bpool_node, "fsl,bpid", &lenp);
+		if (bpid == NULL) {
+			dev_err(dpa_oh_dev, "Invalid Buffer pool Id\n");
+			_errno = -EINVAL;
+			goto return_kfree;
+		}
+
+		BUG_ON(lenp % sizeof(*bpid));
+		oh_port_tx_params.pool_param[i].id = *bpid;
+		dev_dbg(dpa_oh_dev, "OH port bpool id = %u\n", *bpid);
+
+		bpool_cfg = of_get_property(bpool_node,
+				"fsl,bpool-ethernet-cfg", &lenp);
+		if (bpool_cfg == NULL) {
+			dev_err(dpa_oh_dev, "Invalid Buffer pool"
+				" config params\n");
+			_errno = -EINVAL;
+			goto return_kfree;
+		}
+
+		of_read_number(bpool_cfg, n_size);
+		ext_pool_size = of_read_number(bpool_cfg + n_size, n_size);
+		oh_port_tx_params.pool_param[i].size = ext_pool_size;
+		dev_dbg(dpa_oh_dev, "OH port bpool size = %u\n",
+			ext_pool_size);
+		of_node_put(bpool_node);
+
+	}
+
 	oh_set_buffer_layout(oh_config->oh_port, &buf_layout);
+
+
+	if (buf_layout.data_align != FRAG_DATA_ALIGN ||
+	    buf_layout.manip_extra_space != FRAG_MANIP_SPACE)
+		goto init_port;
+
+	frag_enabled = TRUE;
+	dev_info(dpa_oh_dev, "IP Fragmentation enabled for OH port %d",
+		     *port_id);
+
+init_port:
+
 	/* Set Tx params */
 	dpaa_eth_init_port(tx, oh_config->oh_port, oh_port_tx_params,
-		oh_config->error_fqid, oh_config->default_fqid, (&buf_layout));
+		oh_config->error_fqid, oh_config->default_fqid, (&buf_layout),
+		frag_enabled);
 	/* Set PCD params */
 	oh_port_pcd_params.cba = oh_alloc_pcd_fqids;
 	oh_port_pcd_params.cbf = oh_free_pcd_fqids;
@@ -298,6 +393,10 @@ oh_port_probe(struct platform_device *_of_dev)
 	return 0;
 
 return_kfree:
+	if (bpool_node)
+		of_node_put(bpool_node);
+	if (oh_node)
+		of_node_put(oh_node);
 	devm_kfree(dpa_oh_dev, oh_config);
 	return _errno;
 }
-- 
1.7.5.4

