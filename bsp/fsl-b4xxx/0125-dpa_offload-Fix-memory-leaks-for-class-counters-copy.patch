From 231a0967a47c9d90abf65d2ffcfd9e09df4660c6 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 18:29:36 +0300
Subject: [PATCH 125/130] dpa_offload: Fix memory leaks for class counters
 copying

Fix memory leaks that occur in case copying an array of
class members fails. The user-provided array of pointers
need to be copied from user-space pointers to kernel-space
allocated memory.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Change-Id: I219e7e1bdded44f55baa6ed0a80c71f5046916ed
Reviewed-on: http://git.am.freescale.net:8181/5466
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[This is a patch delivered from Freescale against fsl-sdk-v1.4.5,
 rebase on current context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
old mode 100644
new mode 100755
index f141aa8..1d10d82
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -2224,6 +2224,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (copy_from_user(reass, compat_ptr(uprm->reass),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Reassembly objects\n");
+		kfree(reass);
 		return -EBUSY;
 	}
 
@@ -2232,6 +2233,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (!kprm->reass) {
 		log_err("Cannot allocate kernel memory for Reassembly objects "
 			"array\n");
+		kfree(reass);
 		return -ENOMEM;
 	}
 
@@ -2240,6 +2242,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 				reass[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(reass);
 	return 0;
 }
 
@@ -2262,6 +2265,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Fragmentation "
 			"objects\n");
+		kfree(ufrag);
 		return -EBUSY;
 	}
 
@@ -2270,6 +2274,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	if (!kprm->frag) {
 		log_err("Cannot allocate kernel memory for Fragmentation "
 			"objects array\n");
+		kfree(ufrag);
 		return -ENOMEM;
 	}
 
@@ -2278,6 +2283,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 				ufrag[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(ufrag);
 	return 0;
 }
 
@@ -2298,6 +2304,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (copy_from_user(uplcr, compat_ptr(uprm->plcr),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Policer objects\n");
+		kfree(uplcr);
 		return -EBUSY;
 	}
 
@@ -2306,6 +2313,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (!kprm->plcr) {
 		log_err("Cannot allocate kernel memory for Policer objects "
 			"array\n");
+		kfree(uplcr);
 		return -ENOMEM;
 	}
 
@@ -2314,6 +2322,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 				uplcr[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(uplcr);
 	return 0;
 }
 
-- 
1.7.5.4

