From ab1c9e4d38e55cd4778e1bd614d156e41619d9ca Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 8 Mar 2012 17:41:25 +0000
Subject: [PATCH 105/518] Refactorization of internal circular queue
 implementation code

- remove duplicate code
- fix coding style issues reported by reviewers before DPA IPSec
component was integrated in b4_alu branch

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/cq.c        |  305 ++++-----------------------
 drivers/staging/fsl_dpa_offload/cq.h        |  288 ++++++-------------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |    5 +-
 3 files changed, 111 insertions(+), 487 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/cq.c b/drivers/staging/fsl_dpa_offload/cq.c
index 51ed853..e4c6739 100644
--- a/drivers/staging/fsl_dpa_offload/cq.c
+++ b/drivers/staging/fsl_dpa_offload/cq.c
@@ -39,86 +39,53 @@
 
 #include "cq.h"
 
-/******************************************************************************/
-struct cq *cq_new(uint16_t max_items, uint16_t item_size)
+struct cq *cq_new(int max_items, int item_size)
 {
 	struct cq *cq;
 
-	xx_assert(max_items != 0);
-	xx_assert(item_size != 0);
+	xx_assert(max_items);
+	xx_assert(item_size);
 
 	cq = (struct cq *)xx_malloc((uint32_t)
-				(sizeof(struct cq) + (max_items * item_size)));
+				(sizeof(struct cq) + max_items * item_size));
 	if (cq) {
 		cq->max_items = max_items;
 		cq->item_size = item_size;
 		cq->items_in_queue = 0;
 		cq->first = 0;
+		memset(cq->items, 0, max_items * item_size);
 	}
 
 	return cq;
 }
 
-/******************************************************************************/
 void cq_delete(struct cq *cq)
 {
-	xx_assert(cq != 0);
+	xx_assert(cq);
 
 	xx_free(cq);
 }
 
-/******************************************************************************/
 int cq_flush(struct cq *cq)
 {
 	int items_in_queue;
 
-	xx_assert(cq != 0);
+	xx_assert(cq);
 
 	items_in_queue = cq->items_in_queue;
 	cq->first = 0;
 	cq->items_in_queue = 0;
+	memset(cq->items, 0, cq->max_items * cq->item_size);
 
 	return items_in_queue;
 }
 
-/******************************************************************************/
 int cq_put(struct cq *cq, void *item)
 {
-	int put_pos, max_items, first, items_in_queue, item_size, i;
-	uint8_t *byte = item;
-
-	xx_assert(cq != 0);
-
-	first = cq->first;
-	max_items = cq->max_items;
-	items_in_queue = cq->items_in_queue;
-	item_size = cq->item_size;
-
-	/* Check if queue is full */
-	if (items_in_queue == max_items)
-		return -1;
+	int put_pos, max_items, first, items_in_queue, item_size;
+	uint8_t *byte = (uint8_t *)item;
 
-	if ((first + items_in_queue) < max_items)
-		put_pos = ((first + items_in_queue) * item_size);
-	else
-		put_pos = ((first + items_in_queue - max_items) * item_size);
-
-	/* add element to queue */
-	for (i = 0; i < item_size; i++)
-		cq->items[put_pos + i] = *(byte + i);
-
-	cq->items_in_queue++;
-
-	return items_in_queue + 1;
-}
-
-/******************************************************************************/
-int cq_put_unsafe(struct cq *cq, void *item)
-{
-	int put_pos, max_items, first, items_in_queue, item_size, i;
-	uint8_t *byte = item;
-
-	xx_assert(cq != 0);
+	xx_assert(cq);
 
 	first = cq->first;
 	max_items = cq->max_items;
@@ -130,174 +97,54 @@ int cq_put_unsafe(struct cq *cq, void *item)
 		return -1;
 
 	if ((first + items_in_queue) < max_items)
-		put_pos = ((first + items_in_queue) * item_size);
+		put_pos = (first + items_in_queue) * item_size;
 	else
-		put_pos = ((first + items_in_queue - max_items) * item_size);
+		put_pos = (first + items_in_queue - max_items) * item_size;
 
 	/* add element to queue */
-	for (i = 0; i < item_size; i++)
-		cq->items[put_pos + i] = *(byte + i);
+	memcpy(cq->items + put_pos, byte, item_size);
 
 	cq->items_in_queue++;
 
 	return items_in_queue + 1;
 }
 
-/******************************************************************************/
 int cq_put_1byte(struct cq *cq, uint8_t item)
 {
-	int put_pos, max_items, first, items_in_queue;
-
-	xx_assert(cq != 0);
+	xx_assert(cq);
 	xx_assert(cq->item_size == 1);
 
-	first = cq->first;
-	max_items = cq->max_items;
-	items_in_queue = cq->items_in_queue;
-
-	/* Check if queue is full */
-	if (items_in_queue == max_items)
-		return -1;
-
-	if ((first + items_in_queue) < max_items)
-		put_pos = first + items_in_queue;
-	else
-		put_pos = first + items_in_queue - max_items;
-
-	xx_assert((put_pos >= 0) && (put_pos < max_items));
-
-	/* add element to queue */
-	cq->items[put_pos] = item;
-	cq->items_in_queue++;
-
-	return items_in_queue + 1;
+	return cq_put(cq, &item);
 }
 
-/******************************************************************************/
 int cq_put_2bytes(struct cq *cq, uint16_t item)
 {
-	int put_pos, max_items, first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(cq->item_size == 2);
 
-	first = cq->first;
-	max_items = cq->max_items;
-	items_in_queue = cq->items_in_queue;
-
-	/* Check if queue is full */
-	if (items_in_queue == max_items)
-		return -1;
-
-	if ((first + items_in_queue) < max_items)
-		put_pos = first + items_in_queue;
-	else
-		put_pos = first + items_in_queue - max_items;
-
-	xx_assert((put_pos >= 0) && (put_pos < max_items));
-
-	/* add element to queue */
-	*((uint16_t *) cq->items + put_pos) = item;
-	cq->items_in_queue++;
-
-	return items_in_queue + 1;
+	return cq_put(cq, &item);
 }
 
-/******************************************************************************/
 int cq_put_4bytes(struct cq *cq, uint32_t item)
 {
-	int put_pos, max_items, first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(cq->item_size == 4);
 
-	first = cq->first;
-	max_items = cq->max_items;
-	items_in_queue = cq->items_in_queue;
-
-	/* Check if queue is full */
-	if (items_in_queue == max_items)
-		return -1;
-
-	if ((first + items_in_queue) < max_items)
-		put_pos = first + items_in_queue;
-	else
-		put_pos = first + items_in_queue - max_items;
-
-	xx_assert((put_pos >= 0) && (put_pos < max_items));
-
-	/* add element to queue */
-	*((uint32_t *) cq->items + put_pos) = item;
-	cq->items_in_queue++;
-
-	return items_in_queue + 1;
+	return cq_put(cq, &item);
 }
 
-/******************************************************************************/
 int cq_put_8bytes(struct cq *cq, uint64_t item)
 {
-	int put_pos, max_items, first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(cq->item_size == 8);
 
-	first = cq->first;
-	max_items = cq->max_items;
-	items_in_queue = cq->items_in_queue;
-
-	/* Check if queue is full */
-	if (items_in_queue == max_items)
-		return -1;
-
-	if ((first + items_in_queue) < max_items)
-		put_pos = first + items_in_queue;
-	else
-		put_pos = first + items_in_queue - max_items;
-
-	xx_assert((put_pos >= 0) && (put_pos < max_items));
-
-	/* add element to queue */
-	*((uint64_t *) cq->items + put_pos) = item;
-	cq->items_in_queue++;
-
-	return items_in_queue + 1;
+	return cq_put(cq, &item);
 }
 
-/******************************************************************************/
 int cq_get(struct cq *cq, void *item)
 {
-	int get_pos, items_in_queue, item_size, first, i;
-	uint8_t *byte = item;
-
-	xx_assert(cq);
-	xx_assert(item);
-
-	items_in_queue = cq->items_in_queue;
-	/* Check if queue is empty */
-	if (items_in_queue == 0)
-		return -1;
-
-	first = cq->first;
-	item_size = cq->item_size;
-	get_pos = first * item_size;
-
-	/* Get item from queue */
-	for (i = 0; i < item_size; i++)
-		*((byte) + i) = (cq->items[i + get_pos]);
-	cq->items_in_queue--;
-
-	if (++first >= cq->max_items)
-		first = 0;
-	cq->first = (uint16_t) first;
-
-	return items_in_queue - 1;
-}
-
-/******************************************************************************/
-int cq_get_unsafe(struct cq *cq, void *item)
-{
-	int get_pos, items_in_queue, item_size, first, i;
-	uint8_t *byte = item;
+	int get_pos, items_in_queue, item_size, first;
+	uint8_t *byte = (uint8_t *)item;
 
 	xx_assert(cq);
 	xx_assert(item);
@@ -312,145 +159,70 @@ int cq_get_unsafe(struct cq *cq, void *item)
 	get_pos = first * item_size;
 
 	/* Get item from queue */
-	for (i = 0; i < item_size; i++)
-		*((byte) + i) = (cq->items[i + get_pos]);
+	memcpy(byte, cq->items + get_pos, item_size);
 	cq->items_in_queue--;
 
 	if (++first >= cq->max_items)
 		first = 0;
-	cq->first = (uint16_t) first;
+	cq->first = first;
 
 	return items_in_queue - 1;
 }
 
-/******************************************************************************/
-int cq_get_1byte(struct cq *cq, uint8_t * item)
+int cq_get_1byte(struct cq *cq, uint8_t *item)
 {
-	int first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(item);
 	xx_assert(cq->item_size == 1);
 
-	items_in_queue = cq->items_in_queue;
-	/* Check if queue is empty */
-	if (items_in_queue == 0)
-		return -1;
-
-	first = cq->first;
-
-	/* Get item from queue */
-	*item = (cq->items[first]);
-	cq->items_in_queue--;
-
-	if (++first >= cq->max_items)
-		first = 0;
-	cq->first = (uint16_t) first;
-
-	return items_in_queue - 1;
+	return cq_get(cq, item);
 }
 
-/******************************************************************************/
-int cq_get_2bytes(struct cq *cq, uint16_t * item)
+int cq_get_2bytes(struct cq *cq, uint16_t *item)
 {
-	int first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(item);
 	xx_assert(cq->item_size == 2);
 
-	items_in_queue = cq->items_in_queue;
-	/* Check if queue is empty */
-	if (items_in_queue == 0)
-		return -1;
-
-	first = cq->first;
-
-	/* Get item from queue */
-	cq->items_in_queue--;
-	*item = *((uint16_t *) cq->items + first);
-
-	if (++first >= cq->max_items)
-		first = 0;
-	cq->first = (uint16_t) first;
-
-	return items_in_queue - 1;
+	return cq_get(cq, item);
 }
 
-/******************************************************************************/
-int cq_get_4bytes(struct cq *cq, uint32_t * item)
+int cq_get_4bytes(struct cq *cq, uint32_t *item)
 {
-	int first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(item);
 	xx_assert(cq->item_size == 4);
 
-	items_in_queue = cq->items_in_queue;
-	/* Check if queue is empty */
-	if (items_in_queue == 0)
-		return -1;
-
-	first = cq->first;
-
-	/* Get item from queue */
-	cq->items_in_queue--;
-	*item = *((uint32_t *) cq->items + first);
-
-	if (++first >= cq->max_items)
-		first = 0;
-	cq->first = (uint16_t) first;
-
-	return items_in_queue - 1;
+	return cq_get(cq, item);
 }
 
-/******************************************************************************/
-int cq_get_8bytes(struct cq *cq, uint64_t * item)
+int cq_get_8bytes(struct cq *cq, uint64_t *item)
 {
-	int first, items_in_queue;
-
 	xx_assert(cq);
 	xx_assert(item);
 	xx_assert(cq->item_size == 8);
 
-	items_in_queue = cq->items_in_queue;
-	/* Check if queue is empty */
-	if (items_in_queue == 0)
-		return -1;
-
-	first = cq->first;
-
-	/* Get item from queue */
-	cq->items_in_queue--;
-	*item = *((uint64_t *) cq->items + first);
-
-	if (++first >= cq->max_items)
-		first = 0;
-	cq->first = (uint16_t) first;
-
-	return items_in_queue - 1;
+	return cq_get(cq, item);
 }
 
-/******************************************************************************/
 int cq_items_in_queue(struct cq *cq)
 {
 	xx_assert(cq);
 
-	return ((struct cq *)cq)->items_in_queue;
+	return cq->items_in_queue;
 }
 
-/******************************************************************************/
-int cq_read(struct cq *cq, void *read_item, uint16_t position)
+int cq_read(struct cq *cq, void *read_item, int position)
 {
-	int item_size, first, items_in_queue, bytePosition, i;
-	uint8_t *read_byte = read_item;
+	int item_size, first, items_in_queue, bytePosition;
+	uint8_t *read_byte = (uint8_t *)read_item;
 
 	xx_assert(cq);
 	xx_assert(read_item);
 
 	items_in_queue = cq->items_in_queue;
 	/* Check if queue is empty and if position is valid */
-	if ((items_in_queue == 0) || (position > items_in_queue))
+	if (items_in_queue == 0 || position > items_in_queue)
 		return -1;
 
 	item_size = cq->item_size;
@@ -459,13 +231,12 @@ int cq_read(struct cq *cq, void *read_item, uint16_t position)
 	/* Find byte position */
 	if (first + position - 1 > cq->max_items)
 		bytePosition =
-		    (first + position - 1 - cq->max_items) * item_size;
+			(first + position - 1 - cq->max_items) * item_size;
 	else
 		bytePosition = (first + position - 1) * item_size;
 
 	/*read from queue */
-	for (i = 0; i < item_size; i++)
-		*(read_byte + i) = (cq->items[bytePosition + i]);
+	memcpy(read_byte, cq->items + bytePosition, item_size);
 
 	return items_in_queue;
 }
diff --git a/drivers/staging/fsl_dpa_offload/cq.h b/drivers/staging/fsl_dpa_offload/cq.h
index 7efc07c..cf44d4a 100644
--- a/drivers/staging/fsl_dpa_offload/cq.h
+++ b/drivers/staging/fsl_dpa_offload/cq.h
@@ -38,248 +38,102 @@
 
 #include "dpa_compat.h"
 
-/**************************************************************************//**
-   @Description   Circular queue structure
-*//***************************************************************************/
+/* Circular queue structure */
 struct cq {
-	uint16_t max_items;		/* Size of queue */
-	uint16_t item_size;		/* Size of each item in the queue */
-	uint16_t items_in_queue;	/* Number of items in the queue */
-	uint16_t first;			/* Index of first item in queue */
-	uint8_t items[1];		/* Holds the elements in the queue -
-					fake size; (this field must be
-					4-bytes aligned) */
+	int max_items;		/* Size of queue */
+	int item_size;		/* Size of each item in the queue */
+	int items_in_queue;	/* Number of items in the queue */
+	int first;			/* Index of first item in queue */
+	uint8_t items[0];		/* Holds the elements in the queue -
+					 * fake size */
 };
 
-/**************************************************************************//**
- @Function      cq_new
+/* Allocate and initialize a new circular queue */
+struct cq *cq_new(int max_items, int item_size);
 
- @Description   Allocates and initializes a new circular queue.
-
- @Param[in]     max_items    - Maximum number of items in queue.
- @Param[in]     item_size    - Size, in bytes, of each item in the queue.
-
- @Return        Handle to the new object on success;
-		NULL on failure (out of memory).
-*//***************************************************************************/
-struct cq *cq_new(uint16_t max_items, uint16_t item_size);
-
-/**************************************************************************//**
- @Function      cq_delete
-
- @Description   Deletes a circular queue.
-
- @Param[in]     cq - Handle to the circular queue.
-*//***************************************************************************/
+/* Delete a circular queue */
 void cq_delete(struct cq *cq);
 
-/**************************************************************************//**
- @Function      cq_flush
-
- @Description   Empties the circular queue (clears all items).
-
- @Param[in]     cq - Handle to the circular queue.
-
- @Return        The number of items that were flushed from the queue.
-*//***************************************************************************/
+/* Empty the circular queue (clear all items) */
 int cq_flush(struct cq *cq);
 
-/**************************************************************************//**
- @Function      cq_put
-
- @Description   Puts a new item in the circular queue.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - Pointer to the item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-*//***************************************************************************/
+/*
+ * Put a new item in the circular queue
+ * Return number of items in the queue (including the added item) is successful
+ * or (-1) if failed to put the item (queue is full)
+ */
 int cq_put(struct cq *cq, void *item);
 
-/**************************************************************************//**
- @Function      cq_put_unsafe
-
- @Description   Puts a new item in the circular queue.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - Pointer to the item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-
- @Cautions      This routine is not interrupt-safe, but is faster than cq_put();
-		The user must prevent concurrent accesses to the queue.
-*//***************************************************************************/
-int cq_put_unsafe(struct cq *cq, void *item);
-
-/**************************************************************************//**
- @Function      cq_put_1byte
-
- @Description   Puts a new 1-byte item in the circular queue.
-		The routine is more efficient than cq_put.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - The item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-*//***************************************************************************/
+/* Put a new 1-byte item in the circular queue
+ * Return number of items in the queue (including the added item) is successful
+ * or (-1) if failed to put the item (queue is full)
+ */
 int cq_put_1byte(struct cq *cq, uint8_t item);
 
-/**************************************************************************//**
- @Function      cq_put_2bytes
-
- @Description   Puts a new 2-byte item in the circular queue.
-		The routine is more efficient than cq_put.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - The item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-*//***************************************************************************/
+/*
+ * Put a new 2-byte item in the circular queue
+ * Return number of items in the queue (including the added item) is successful
+ * or (-1) if failed to put the item (queue is full)
+ */
 int cq_put_2bytes(struct cq *cq, uint16_t item);
 
-/**************************************************************************//**
- @Function      cq_put_4bytes
-
- @Description   Puts a new 4-byte item in the circular queue.
-		The routine is more efficient than cq_put.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - The item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-*//***************************************************************************/
+/*
+ * Put a new 4-byte item in the circular queue
+ * Return number of items in the queue (including the added item) is successful
+ * or (-1) if failed to put the item (queue is full)
+ */
 int cq_put_4bytes(struct cq *cq, uint32_t item);
 
-/**************************************************************************//**
- @Function      cq_put_8bytes
-
- @Description   Puts a new 8-byte item in the circular queue.
-		The routine is more efficient than cq_put.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - The item that should be added.
-
- @Return        Number of items in the queue (including the added item);
-		Returns (-1) if failed to put the item (queue is full).
-*//***************************************************************************/
+/*
+ * Put a new 8-byte item in the circular queue
+ * Return number of items in the queue (including the added item) is successful
+ * or (-1) if failed to put the item (queue is full)
+ */
 int cq_put_8bytes(struct cq *cq, uint64_t item);
 
-/**************************************************************************//**
- @Function      cq_get
-
- @Description   Gets (and removes) an item from the circular queue.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[out]    item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-*//***************************************************************************/
+/* Get (and removes) an item from the circular queue
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * get an item (queue is empty)
+ */
 int cq_get(struct cq *cq, void *item);
 
-/**************************************************************************//**
- @Function      cq_get_unsafe
-
- @Description   Gets (and removes) an item from the circular queue.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[in]     item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-
- @Cautions      This routine is not interrupt-safe, but is faster than cq_get();
-		The user must prevent concurrent accesses to the queue.
-*//***************************************************************************/
-int cq_get_unsafe(struct cq *cq, void *item);
-
-/**************************************************************************//**
- @Function      cq_get_1byte
-
- @Description   Gets and removes a 1-byte item from the circular queue.
-		The routine is more efficient than cq_get.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[out]    item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-*//***************************************************************************/
-int cq_get_1byte(struct cq *cq, uint8_t * item);
-
-/**************************************************************************//**
- @Function      cq_get_2bytes
-
- @Description   Gets and removes a 2-byte item from the circular queue.
-		The routine is more efficient than cq_get.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[out]    item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-*//***************************************************************************/
-int cq_get_2bytes(struct cq *cq, uint16_t * item);
-
-/**************************************************************************//**
- @Function      cq_get_4bytes
-
- @Description   Gets and removes a 4-byte item from the circular queue.
-		The routine is more efficient than cq_get.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[out]    item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-*//***************************************************************************/
-int cq_get_4bytes(struct cq *cq, uint32_t * item);
-
-/**************************************************************************//**
- @Function      cq_get_8bytes
-
- @Description   Gets and removes a 8-byte item from the circular queue.
-		The routine is more efficient than cq_get.
-
- @Param[in]     cq      - Handle to the circular queue.
- @Param[out]    item    - Pointer that will receive the item from the queue.
-
- @Return        Number of items left in the queue;
-		Returns (-1) if failed to get an item (queue is empty).
-*//***************************************************************************/
-int cq_get_8bytes(struct cq *cq, uint64_t * item);
+/*
+ * Get and removes a 1-byte item from the circular queue
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * get an item (queue is empty)
+ */
+int cq_get_1byte(struct cq *cq, uint8_t *item);
 
-/**************************************************************************//**
- @Function      cq_items_in_queue
+/*
+ * Get and removes a 2-byte item from the circular queue
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * get an item (queue is empty)
+ */
+int cq_get_2bytes(struct cq *cq, uint16_t *item);
 
- @Description   Returns the number of items that are currently in the queue.
+/*
+ * Get and removes a 4-byte item from the circular queue
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * get an item (queue is empty)
+ */
+int cq_get_4bytes(struct cq *cq, uint32_t *item);
 
- @Param[in]     cq   - Handle to the circular queue.
+/*
+ * Get and removes a 8-byte item from the circular queue
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * get an item (queue is empty)
+ */
+int cq_get_8bytes(struct cq *cq, uint64_t *item);
 
- @Return        The number of items in the queue.
-*//***************************************************************************/
+/* Return the number of items that are currently in the queue */
 int cq_items_in_queue(struct cq *cq);
 
-/**************************************************************************//**
- @Function      cq_read
-
- @Description   Reads an item in the queue. The contents of the queue are not
-		altered.
-
- @Param[in]     cq          - Handle to the circular queue.
- @Param[out]    item	    - Pointer that will receive the item from the queue.
- @Param[in]     position    - The position of the item which should be read
-				(1 is the first position in the queue)
-
- @Return        The number of items in the queue; Returns (-1) if failed to
-		read the item (either the queue is empty, or the requested
-		position exceeds number of items).
-*//***************************************************************************/
-int cq_read(struct cq *cq, void *item, uint16_t position);
+/*
+ * Read an item in the queue. The contents of the queue are not altered.
+ * Return number of items left in the queue if successful or (-1) if failed to
+ * read the item (either the queue is empty, or the requested position exceeds
+ * number of items)
+ */
+int cq_read(struct cq *cq, void *item, int position);
 
 #endif /* __CQ_H */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 2e3ab0c..e02a8d0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -514,8 +514,7 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 		return -EFAULT;
 	}
 
-	cq = cq_new((uint16_t) (dpa_ipsec->sa_mng.max_num_sa / 2),
-		    (uint16_t)sizeof(uint16_t));
+	cq = cq_new(dpa_ipsec->sa_mng.max_num_sa / 2, sizeof(uint16_t));
 	if (!cq) {
 		xx_pr_err("Could not create inbound flow ID management CQ\n");
 		return -ENOMEM;
@@ -636,7 +635,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	sa_mng->max_num_sa = dpa_ipsec->config.max_sa_pairs * 2;
 
 	/* create queue that holds free SA IDs */
-	sa_mng->sa_id_cq = cq_new(sa_mng->max_num_sa, (uint16_t) sizeof(int));
+	sa_mng->sa_id_cq = cq_new(sa_mng->max_num_sa, sizeof(int));
 	if (!sa_mng->sa_id_cq) {
 		xx_pr_err("Could not create SA IDs circular queue\n");
 		return -ENOMEM;
-- 
1.7.5.4

