From 746bfe3217458340e01d3a1c645bc0bdd34fcbf3 Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Fri, 11 May 2012 02:21:52 +0000
Subject: [PATCH 143/518] dpa_classifier: change the name current to
 list_current

The name "current" has conflict with the structure "current" defined in
arch/powerpc/include/asm/current.h can caused the compilation failure.
Just rename it to list_current.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   56 +++++++++++-----------
 1 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 28e8f7d..1cc6196 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -634,7 +634,7 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	unsigned int cc_node_index;
 	struct dpa_cls_table *ptable;
 	t_Handle fm_pcd, cc_node;
-	struct list_head *shadow_list_entry, *current;
+	struct list_head *shadow_list_entry, *list_current;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
@@ -688,16 +688,16 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 		 * Update the index management for the Cc node that this entry
 		 * was removed from.
 		 */
-		current = ptable->entry[entry_id].list_node.next;
-		while (current != &ptable->entry_list) {
-			index_entry = list_entry(current,
+		list_current = ptable->entry[entry_id].list_node.next;
+		while (list_current != &ptable->entry_list) {
+			index_entry = list_entry(list_current,
 					struct dpa_cls_tbl_entry,
 					list_node);
 			if (index_entry->int_cc_node_index >
 					cc_node_index)
 				break;
 			index_entry->entry_index--;
-			current = current->next;
+			list_current = list_current->next;
 		}
 
 		list_del(&ptable->entry[entry_id].list_node);
@@ -829,7 +829,7 @@ int dpa_classif_table_flush(int td)
 	t_Error err;
 	struct dpa_cls_table *ptable;
 	t_Handle fm_pcd, cc_node;
-	struct list_head *current, *tmp;
+	struct list_head *list_current, *tmp;
 	struct dpa_cls_tbl_cc_node_info *int_cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
 
@@ -883,9 +883,9 @@ int dpa_classif_table_flush(int td)
 	} else {
 		/* Flush the table from tail to head to avoid having to update
 		 * the remaining entry indexes all the time */
-		current = ptable->entry_list.prev;
-		while (current != &ptable->entry_list) {
-			index_entry = list_entry(current,
+		list_current = ptable->entry_list.prev;
+		while (list_current != &ptable->entry_list) {
+			index_entry = list_entry(list_current,
 						struct dpa_cls_tbl_entry,
 						list_node);
 			if (index_entry->shadow_entry) {
@@ -916,8 +916,8 @@ int dpa_classif_table_flush(int td)
 
 			int_cc_node->used--;
 			index_entry->valid = 0;
-			tmp	= current;
-			current	= current->prev;
+			tmp = list_current;
+			list_current = list_current->prev;
 			list_del(tmp);
 		}
 	}
@@ -1708,7 +1708,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	t_Handle fm_pcd;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
 	struct dpa_cls_tbl_entry *index_entry;
-	struct list_head *current;
+	struct list_head *list_current;
 
 	xx_assert(cls_table);
 	xx_assert(key);
@@ -1767,7 +1767,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	 * should go */
 	if (list_empty(&cls_table->entry_list))
 		/* List is empty. Just add to its tail. */
-		current = &cls_table->entry_list;
+		list_current = &cls_table->entry_list;
 	else {
 		if (cls_table->params.exact_match_params.use_priorities) {
 			xx_assert(cls_table->entry[k].int_cc_node_index == 0);
@@ -1780,15 +1780,15 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			 * Find the first entry with a priority value which is
 			 * higher than or equal to the one to add
 			 */
-			list_for_each(current, &cls_table->entry_list) {
-				index_entry = list_entry(current,
+			list_for_each(list_current, &cls_table->entry_list) {
+				index_entry = list_entry(list_current,
 						struct dpa_cls_tbl_entry,
 						list_node);
 				if (index_entry->priority >= priority)
 					break;
 			}
 			/* If there are such entries in the list */
-			if (current != &cls_table->entry_list) {
+			if (list_current != &cls_table->entry_list) {
 				/* Shall add this entry in the position of
 				 * the [current] one */
 				cls_table->entry[k].entry_index =
@@ -1802,15 +1802,15 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 			 * [entry_index]. In other words, add the current entry
 			 * before the first entry of the next cc node */
 			if (i < cls_table->int_cc_nodes_count - 1)
-				list_for_each(current, &cls_table->entry_list) {
-					index_entry = list_entry(current,
+				list_for_each(list_current, &cls_table->entry_list) {
+					index_entry = list_entry(list_current,
 						struct dpa_cls_tbl_entry,
 						list_node);
 					if (index_entry->int_cc_node_index > i)
 						break;
 				}
 			else
-				current = &cls_table->entry_list;
+				list_current = &cls_table->entry_list;
 	}
 
 	fm_pcd = (t_Handle)cls_table->params.fm_pcd;
@@ -1872,14 +1872,14 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	}
 
 	/* Add the index entry to the index management list */
-	list_add_tail(&cls_table->entry[k].list_node, current);
+	list_add_tail(&cls_table->entry[k].list_node, list_current);
 
 	cls_table->entry[k].valid = 1;
 
 	/* Increment all entry indexes in the current cc node starting from
 	 * [current] on */
-	while (current != &cls_table->entry_list) {
-		index_entry = list_entry(current,
+	while (list_current != &cls_table->entry_list) {
+		index_entry = list_entry(list_current,
 					struct dpa_cls_tbl_entry,
 					list_node);
 		if (index_entry->int_cc_node_index != i)
@@ -1887,7 +1887,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 
 		index_entry->entry_index++;
 
-		current = current->next;
+		list_current = list_current->next;
 	}
 
 	cls_table->int_cc_node[i].used++;
@@ -1948,7 +1948,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	uint8_t mask_data[DPA_CLS_TBL_MAXENTRYKEYSIZE];
 	int j;
 	struct dpa_cls_tbl_shadow_table *shadow_table;
-	struct list_head *current;
+	struct list_head *list_current;
 	struct dpa_cls_tbl_entry *index_entry;
 
 	xx_assert(cls_table);
@@ -2010,13 +2010,13 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if ((list_empty(&cls_table->entry_list)) ||
 		(hash_set_index >= cls_table->int_cc_nodes_count - 1))
 		/* Just add to the tail of the list. */
-		current = &cls_table->entry_list;
+		list_current = &cls_table->entry_list;
 	else {
 		/* Sort the index management list based on [cc_node_index] and
 		 * [entry_index]. In other words, add the current entry
 		 * before the first entry of the next cc node */
-		list_for_each(current, &cls_table->entry_list) {
-			index_entry = list_entry(current,
+		list_for_each(list_current, &cls_table->entry_list) {
+			index_entry = list_entry(list_current,
 						struct dpa_cls_tbl_entry,
 						list_node);
 			if (index_entry->int_cc_node_index > hash_set_index)
@@ -2038,7 +2038,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	}
 
 	/* Add the index entry to the index management list */
-	list_add_tail(&cls_table->entry[j].list_node, current);
+	list_add_tail(&cls_table->entry[j].list_node, list_current);
 
 	cls_table->int_cc_node[hash_set_index].used++;
 
-- 
1.7.5.4

