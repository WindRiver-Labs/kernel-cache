From a7dfdeb560c920400479fc3c760c268996c9a212 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 15 May 2012 19:49:24 +0000
Subject: [PATCH 145/518] dpa_classifier: Add additional sanity check for
 entry references

Added a new sanity check for the runtime functions that require
[entry_id] references from the user. This prevents crashing
when the user feeds in a non-zero, in range, but INVALID entry
reference.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 1cc6196..48c9e40 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -445,6 +445,8 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(mod_params, "mod_params", -EINVAL);
 
 	/* Check for unsupported modifications */
@@ -643,6 +645,8 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		"entry_id", -EINVAL);
 
 	ptable		= table[td];
 	cc_node_index	= ptable->entry[entry_id].int_cc_node_index;
@@ -790,6 +794,8 @@ int dpa_classif_table_lookup_by_ref(int				td,
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(action, "action", -EINVAL);
 
 	if (!table[td]->shadow_table) {
@@ -968,6 +974,8 @@ int dpa_classif_table_get_entry_stats_by_ref(int		td,
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		"entry_id", -EINVAL);
 	xx_sanity_check_return_value(stats, "stats", -EINVAL);
 
 	ptable		= table[td];
@@ -1030,6 +1038,8 @@ int dpa_classif_table_reset_entry_stats_by_ref(int		td,
 	xx_sanity_check_return_value(table[td], "td", -EINVAL);
 	xx_sanity_check_return_value(((entry_id >= 0) &&
 		(entry_id < table[td]->entries_cnt)), "entry_id", -EINVAL);
+	xx_sanity_check_return_value(table[td]->entry[entry_id].valid,
+		"entry_id", -EINVAL);
 
 	cc_node_index	= table[td]->entry[entry_id].int_cc_node_index;
 	index_entry	= &table[td]->entry[entry_id];
-- 
1.7.5.4

