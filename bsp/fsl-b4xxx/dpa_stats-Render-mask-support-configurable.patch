From 47cf85a05425a0919134446fb50041c30d18a63d Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 26 Oct 2012 18:43:13 +0000
Subject: [PATCH 340/518] dpa_stats: Render mask support configurable

Synchronized with the FMAN PCD API which allows
the mask support to be configurable by introducing
the maskSupport parameter in the structure t_KeysParams.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c     |   37 ++++-------
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   73 ++++++++++++----------
 2 files changed, 54 insertions(+), 56 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 0c3a341..11606f4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -892,12 +892,6 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 		return -EINVAL;
 	}
 
-	/* Check that key mask pointer is valid */
-	if (!src->mask) {
-		pr_err("Key mask pointer can't be NULL\n");
-		return -EINVAL;
-	}
-
 	/* Check that key size is not zero */
 	if (!src->size) {
 		pr_err("Key size can't be zero\n");
@@ -912,14 +906,18 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 	}
 	memcpy(dst->byte, src->byte, src->size);
 
-	/* Allocate memory to store the key mask array */
-	dst->mask = kmalloc(src->size, GFP_KERNEL);
-	if (!dst->mask) {
-		pr_err("No more memory for key mask\n");
-		kfree(dst->byte);
-		return -ENOMEM;
-	}
-	memcpy(dst->mask, src->mask, src->size);
+	/* If there is a valid key mask pointer */
+	if (src->mask) {
+		/* Allocate memory to store the key mask array */
+		dst->mask = kmalloc(src->size, GFP_KERNEL);
+		if (!dst->mask) {
+			pr_err("No more memory for key mask\n");
+			kfree(dst->byte);
+			return -ENOMEM;
+		}
+		memcpy(dst->mask, src->mask, src->size);
+	} else
+		dst->mask = NULL;
 
 	/* Store the key size */
 	dst->size = src->size;
@@ -1618,12 +1616,6 @@ static int set_cls_cnt_classif_tbl_pair(
 		return -EFAULT;
 	}
 
-	/* Check that key mask is not NULL */
-	if (!pair->first_key.mask) {
-		pr_err("Invalid argument: NULL key mask pointer\n");
-		return -EFAULT;
-	}
-
 	/* Copy first key descriptor parameters*/
 	err = copy_key_descriptor(&pair->first_key, &tbl_key);
 	if (err != 0) {
@@ -1725,7 +1717,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			/* Store CcNode handle */
 			cnt_tbl_cb->keys[i].cc_node = cls_tbl.cc_node;
 
-			if ((!prm.keys[i].byte) && (!prm.keys[i].mask)) {
+			if (!prm.keys[i].byte) {
 				/* Key is not valid for now */
 				cnt_tbl_cb->keys[i].valid = FALSE;
 				continue;
@@ -1750,8 +1742,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	} else if (prm.key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
 		for (i = 0; i < params->class_members; i++) {
-			if ((!prm.pairs[i].first_key.byte) &&
-				(!prm.pairs[i].first_key.mask)) {
+			if (!prm.pairs[i].first_key.byte) {
 				/* Key is not valid for now */
 				cnt_tbl_cb->keys[i].valid = FALSE;
 				continue;
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 9a2ff97..92bea21 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -758,9 +758,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 
 		if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
 			for (i = 0; i < prm.cnt_params.class_members; i++) {
-
-				if ((!tbl->keys[i].byte) &&
-						(!tbl->keys[i].mask))
+				if (!tbl->keys[i].byte)
 					continue;
 
 				ret = copy_key_descriptor(&tbl->keys[i], &key);
@@ -772,8 +770,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 
 		} else if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
 			for (i = 0; i < prm.cnt_params.class_members; i++) {
-				if ((!tbl->pairs[i].first_key.byte) &&
-					(!tbl->pairs[i].first_key.mask))
+				if (!tbl->pairs[i].first_key.byte)
 					continue;
 
 				ret = copy_key_descriptor(
@@ -1023,7 +1020,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 
 	switch (prm.params.type) {
 	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
-		if ((prm.params.key.byte) && (prm.params.key.mask)) {
+		if (prm.params.key.byte) {
 			ret = copy_key_descriptor(&prm.params.key, &key);
 			if (ret != 0) {
 				pr_err("Couldn't copy the key descriptor\n");
@@ -1061,6 +1058,21 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	if (ret < 0)
 		return ret;
 
+	switch (prm.params.type) {
+	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
+		kfree(prm.params.key.byte);
+		kfree(prm.params.key.mask);
+		break;
+	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
+		kfree(prm.params.pair.first_key.byte);
+		kfree(prm.params.pair.first_key.mask);
+		kfree(prm.params.pair.second_key.byte);
+		kfree(prm.params.pair.second_key.mask);
+		break;
+	default:
+		pr_err("invalid class member type\n");
+		break;
+	}
 	if (copy_to_user((void *) args, &prm, sizeof(prm))) {
 		pr_err("Could not write dpa_stats_init result");
 		return -EBUSY;
@@ -1593,49 +1605,44 @@ static long store_get_cnts_async_params(
 }
 
 static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
-		struct dpa_offload_lookup_key *dst)
+		struct dpa_offload_lookup_key *tmp)
 {
 	if (!src->byte) {
 		pr_err("Key byte pointer can't be NULL\n");
 		return -EINVAL;
 	}
 
-	if (!src->mask) {
-		pr_err("Key mask pointer can't be NULL\n");
-		return -EINVAL;
-	}
-
 	/* Allocate memory to store the key byte array */
-	dst->byte = kmalloc(src->size, GFP_KERNEL);
-	if (!dst->byte) {
+	tmp->byte = kmalloc(src->size, GFP_KERNEL);
+	if (!tmp->byte) {
 		pr_err("No more memory for key pointer\n");
 		return -ENOMEM;
 	}
 
-	if (copy_from_user(dst->byte, src->byte, src->size)) {
-		pr_err("Could not copy key byte");
-		kfree(dst->byte);
+	if (copy_from_user(tmp->byte, src->byte, src->size)) {
+		pr_err("Could not copy key byte\n");
+		kfree(tmp->byte);
 		return -EBUSY;
 	}
+	src->byte = tmp->byte;
 
-	/* Allocate memory to store the key mask array */
-	dst->mask = kmalloc(src->size, GFP_KERNEL);
-	if (!dst->mask) {
-		pr_err("No more memory for mask pointer\n");
-		kfree(dst->byte);
-		return -ENOMEM;
-	}
+	if (src->mask) {
+		/* Allocate memory to store the key mask array */
+		tmp->mask = kmalloc(src->size, GFP_KERNEL);
+		if (!tmp->mask) {
+			pr_err("No more memory for mask pointer\n");
+			kfree(tmp->byte);
+			return -ENOMEM;
+		}
 
-	if (copy_from_user(dst->mask, src->mask, src->size)) {
-		pr_err("Could not copy key mask");
-		kfree(dst->byte);
-		kfree(dst->mask);
-		return -EBUSY;
+		if (copy_from_user(tmp->mask, src->mask, src->size)) {
+			pr_err("Could not copy key mask\n");
+			kfree(tmp->byte);
+			kfree(tmp->mask);
+			return -EBUSY;
+		}
+		src->mask = tmp->mask;
 	}
-
-	src->byte = dst->byte;
-	src->mask = dst->mask;
-
 	return 0;
 }
 
-- 
1.7.5.4

