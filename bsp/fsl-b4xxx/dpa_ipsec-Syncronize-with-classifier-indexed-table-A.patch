From f9601237c241e21f8026f8f7b250746371b3e6b0 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 9 Aug 2012 21:13:37 +0000
Subject: [PATCH 283/518] dpa_ipsec: Syncronize with classifier indexed table
 API updates

The Classifier API no longer includes a function for inserting entries
into indexed tables so the IPSec code must use the modify entry function
instead.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   69 +++++++++++---------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    5 +-
 2 files changed, 31 insertions(+), 43 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index d983610..0580377 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -964,33 +964,39 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 	return 0;
 }
 
-static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
+static int set_flow_id_action(struct dpa_ipsec_sa *sa,
+			      struct dpa_cls_tbl_action *action)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_offload_lookup_key tbl_key;
-	struct dpa_cls_tbl_action *action;
+	struct dpa_cls_tbl_entry_mod_params mod_params;
 	int table, err;
 	uint8_t key_data;
 
 	BUG_ON(!sa);
+	BUG_ON(!action);
 
 	dpa_ipsec = (struct dpa_ipsec *)sa->dpa_ipsec;
-	BUG_ON(!dpa_ipsec);
 
 	/* Currently the flowid cannot be greater than 255 */
 	key_data	= (uint8_t)sa->inbound_flowid;
+
+	memset(&tbl_key, 0, sizeof(tbl_key));
 	tbl_key.byte	= &key_data;
 	tbl_key.mask	= NULL;
-	tbl_key.size	= 1;
+	tbl_key.size	= sizeof(uint8_t);
 
-	action = &sa->def_sa_action;
+	memset(&mod_params, 0, sizeof(mod_params));
+	mod_params.action = action;
+	mod_params.type = DPA_CLS_TBL_MODIFY_ACTION;
 	table = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
-	err = dpa_classif_table_insert_entry(table, &tbl_key, action, 0,
-					     &sa->inbound_indx_entry);
+	err = dpa_classif_table_modify_entry_by_key(table, &tbl_key,
+						    &mod_params);
 	if (err < 0) {
-		pr_err("Couldn't set default action for SA id %d\n", sa->id);
+		pr_err("Couldn't set flowID action for SA id %d\n", sa->id);
 		return err;
 	}
+	sa->valid_flowid_entry = true;
 
 	return 0;
 }
@@ -1629,14 +1635,15 @@ static int remove_inbound_hash_entry(struct dpa_ipsec_sa *sa)
 static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	int td, err;
+	struct dpa_cls_tbl_action action;
+	int err;
 
 	dpa_ipsec = sa->dpa_ipsec;
-	BUG_ON(!dpa_ipsec);
 
-	td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
+	memset(&action, 0, sizeof(action));
+	action.type = DPA_CLS_TBL_ACTION_DROP;
 
-	err = dpa_classif_table_delete_entry_by_ref(td, sa->inbound_indx_entry);
+	err = set_flow_id_action(sa, &action);
 	if (err < 0) {
 		pr_err("Could not remove SA entry in indexed table\n");
 		return err;
@@ -1648,8 +1655,7 @@ static inline int remove_inbound_flow_id_classif(struct dpa_ipsec_sa *sa)
 	err = put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
 	if (err < 0)
 		return err;
-
-	sa->inbound_indx_entry = -1;
+	sa->valid_flowid_entry = false;
 
 	return 0;
 }
@@ -2675,16 +2681,13 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) &&
-	    (sa->inbound_indx_entry != -1)) {
-		err_rb = dpa_classif_table_delete_entry_by_ref(
-				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
-				sa->inbound_indx_entry);
+	    sa->valid_flowid_entry) {
+		err_rb = remove_inbound_flow_id_classif(sa);
 		if (err_rb < 0) {
 			pr_err("Couldn't remove post decrypt tbl entry\n");
 			return err_rb;
 		}
 	}
-	sa->inbound_indx_entry = -1;
 
 	err_rb = remove_sa_fq_pair(sa);
 	if (err_rb < 0) {
@@ -2906,7 +2909,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
 		/*Mark classifier entries as invalid (useful for rolling back)*/
 		sa->inbound_hash_entry = -1;
-		sa->inbound_indx_entry = -1;
+		sa->valid_flowid_entry = false;
 
 		/* Call update_pre_sec_inbound_table to place an entry in the
 		 *  PCD of the Rx Port */
@@ -2918,10 +2921,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 		if (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) {
 			int inbpol_td;
-			int inbindx_td;
 			struct dpa_cls_tbl_action action;
-			struct dpa_offload_lookup_key inbindx_key;
-			uint8_t key_data;
 
 			err = get_free_inbpol_tbl(dpa_ipsec, &inbpol_td);
 			if (err < 0) {
@@ -2932,22 +2932,11 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 			/* Link Exact Match table with the index table on
 			 * inbound_flowid */
-			inbindx_td =
-				dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
-
-			/*TODO - case when flow id is greater than 255 */
-			inbindx_key.byte = &key_data;
-			inbindx_key.mask = NULL;
-			inbindx_key.size = 1;
-			inbindx_key.byte[0] = (uint8_t) sa->inbound_flowid;
 			memset(&action, 0, sizeof(action));
 			action.type = DPA_CLS_TBL_ACTION_NEXT_TABLE;
 			action.next_table_params.next_td = inbpol_td;
 			action.enable_statistics = FALSE;
-			err = dpa_classif_table_insert_entry(inbindx_td,
-						&inbindx_key,
-						&action, 0,
-						&sa->inbound_indx_entry);
+			err = set_flow_id_action(sa, &action);
 			if (err < 0) {
 				pr_err("Can't link EM table with index table\n");
 				goto create_sa_err;
@@ -2961,7 +2950,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			}
 		} else {
 			/* Set the post decryption default action */
-			err = set_in_sa_default_action(sa);
+			err = set_flow_id_action(sa, &sa->def_sa_action);
 			if (err < 0) {
 				pr_err("Could not set default action for post decryption\n");
 				goto create_sa_err;
@@ -3060,7 +3049,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 		}
 
 		/* Update the child SA with parent SA's inbound indx entry */
-		child_sa->inbound_indx_entry = sa->inbound_indx_entry;
+		child_sa->valid_flowid_entry = sa->valid_flowid_entry;
 
 		/* Inherit parent SA's policy list and then set it empty */
 		if (sa->dpa_ipsec->config.post_sec_in_params.do_pol_check)
@@ -3143,7 +3132,7 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 	}
 
 	/* Remove the flow id classification after decryption */
-	if (sa->inbound_indx_entry != -1) {
+	if (sa->valid_flowid_entry) {
 		err = remove_inbound_flow_id_classif(sa);
 		if (err < 0)
 			return err;
@@ -3563,7 +3552,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	new_sa->dpa_ipsec = old_sa->dpa_ipsec;
 	new_sa->inbound_flowid = old_sa->inbound_flowid;
 	new_sa->ipsec_hmd = old_sa->ipsec_hmd;
-	new_sa->inbound_indx_entry = -1;
+	new_sa->valid_flowid_entry = false;
 	new_sa->rekey_event_cb = rekey_event_cb;
 	if (auto_rmv_old_sa) {
 		new_sa->parent_sa = old_sa;
@@ -3897,7 +3886,7 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 	}
 
 	/* Update the new SA with old SA's inbound indx entry */
-	new_sa->inbound_indx_entry = old_sa->inbound_indx_entry;
+	new_sa->valid_flowid_entry = old_sa->valid_flowid_entry;
 
 	/* Inherit old SA policy list and then set it empty */
 	if (old_sa->dpa_ipsec->config.post_sec_in_params.do_pol_check)
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index abe45cf..2f2525e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -269,9 +269,8 @@ struct dpa_ipsec_sa {
 				   Only for inbound  SAs.		      */
 	uint16_t udp_dest_port;	/* Destination UDP port (for UDP encap ESP)
 				   Only for inbound  SAs.                     */
-	uint16_t inbound_flowid; /* Value used for identifying a inbound SA.  */
-	int inbound_indx_entry;	/* Entry in the index table correspondent
-				   with inbound_flowid			      */
+	uint16_t inbound_flowid; /* Value used for identifying an inbound SA. */
+	bool valid_flowid_entry; /* Valid entry in the flowID table	      */
 	int inbound_hash_entry;	/* Entry in the hash table
 				   corresponding to SPI extended key	      */
 	int inbound_sa_td; /* Descriptor for the SA lookup table in which this
-- 
1.7.5.4

