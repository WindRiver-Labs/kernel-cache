From 82d03f3db9c8e73062adc558cd3d63ffdab2904e Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 15 Oct 2012 03:40:40 +0300
Subject: [PATCH 045/518] dpaa_eth: Remove recycling logic from the SG egress
 path

We've never got meaningful results from the recyling stats of the SG
driver. Removing that logic altogether seems like the natural thing to
do.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   67 +---------------------
 1 files changed, 3 insertions(+), 64 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index c4b44c0..1eeea0f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -222,9 +222,8 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 	dma_addr_t addr = qm_fd_addr(fd);
 	struct sk_buff **skbh;
 	struct sk_buff *skb = NULL;
-	enum dma_data_direction dma_dir;
+	const enum dma_data_direction dma_dir = DMA_TO_DEVICE;
 
-	dma_dir = (fd->cmd & FM_FD_CMD_FCO) ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE;
 	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, dma_dir);
 
 	/* retrieve skb back pointer */
@@ -600,9 +599,8 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	unsigned long sgt_page, sg0_page;
 	void *buffer_start;
 	skb_frag_t *frag;
-	int i, j, nr_frags;
-	enum dma_data_direction dma_dir;
-	bool can_recycle = false;
+	int i, j;
+	const enum dma_data_direction dma_dir = DMA_TO_DEVICE;
 
 	fd->format = qm_fd_sg;
 
@@ -635,31 +633,6 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	memset(sgt, 0, DPA_SGT_MAX_ENTRIES * sizeof(*sgt));
 
 	/*
-	 * Decide whether the skb is recycleable. We will need this information
-	 * upfront to decide what DMA mapping direction we want to use.
-	 */
-	nr_frags =  skb_shinfo(skb)->nr_frags;
-	if (!skb_cloned(skb) && !skb_shared(skb) &&
-	   (*percpu_priv->dpa_bp_count + nr_frags + 2 < dpa_bp->target_count)) {
-		can_recycle = true;
-		/*
-		 * We want each fragment to have at least dpa_bp->size bytes.
-		 * If even one fragment is smaller, the entire FD becomes
-		 * unrecycleable.
-		 * Same holds if the fragments are allocated from highmem.
-		 */
-		for (i = 0; i < nr_frags; i++) {
-			skb_frag_t *crt_frag = &skb_shinfo(skb)->frags[i];
-			if ((crt_frag->size < dpa_bp->size) ||
-			    PageHighMem(crt_frag->page)) {
-				can_recycle = false;
-				break;
-			}
-		}
-	}
-	dma_dir = can_recycle ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE;
-
-	/*
 	 * Populate the first SGT entry
 	 * get a new page to store the skb linear buffer content
 	 * in the first SGT entry
@@ -742,12 +715,6 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	fd->addr_hi = upper_32_bits(addr);
 	fd->addr_lo = lower_32_bits(addr);
 
-	if (can_recycle) {
-		/* all pages are going to be recycled */
-		fd->cmd |= FM_FD_CMD_FCO;
-		fd->bpid = dpa_bp->bpid;
-	}
-
 	return 0;
 
 sgt_map_failed:
@@ -832,27 +799,6 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	fd.cmd &= ~FM_FD_CMD_FCO;
 #endif
 
-	if (fd.cmd & FM_FD_CMD_FCO) {
-		/*
-		 * Need to free the skb, but without releasing
-		 * the page fragments, so increment the pages usage count
-		 */
-		int i;
-
-		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++)
-			get_page(skb_shinfo(skb)->frags[i].page);
-
-		/*
-		 * We release back to the pool a number of pages equal to
-		 * the number of skb fragments + one page for the linear
-		 * portion of the skb + one page for the S/G table
-		 */
-		*percpu_priv->dpa_bp_count += skb_shinfo(skb)->nr_frags + 2;
-		percpu_priv->tx_returned++;
-		dev_kfree_skb(skb);
-		skb = NULL;
-	}
-
 	if (unlikely(dpa_xmit(priv, percpu_priv, queue_mapping, &fd) < 0))
 		goto xmit_failed;
 
@@ -861,13 +807,6 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	return NETDEV_TX_OK;
 
 xmit_failed:
-	if (fd.cmd & FM_FD_CMD_FCO) {
-		*percpu_priv->dpa_bp_count -= skb_shinfo(skb)->nr_frags + 2;
-		percpu_priv->tx_returned--;
-
-		dpa_fd_release(net_dev, &fd);
-		return NETDEV_TX_OK;
-	}
 	_dpa_cleanup_tx_fd(priv, &fd);
 	dev_kfree_skb(skb);
 
-- 
1.7.5.4

