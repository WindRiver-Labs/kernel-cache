From c2a40393cc9bce2b4f78be59353278f6a8dc0106 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 20:01:54 +0000
Subject: [PATCH 297/518] dpa_classifier: Add NAT HM feature

Implemented the NAT HM feature. The user can now create NAT type header
manipulations at runtime.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  292 ++++++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |    6 +
 include/linux/fsl_dpa_classifier.h               |    4 +-
 3 files changed, 225 insertions(+), 77 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 7fcc9c8..e39fd5600 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -2385,6 +2385,39 @@ static inline void key_apply_mask(const struct dpa_offload_lookup_key *key,
 		new_key[i] = key->byte[i] & key->mask[i];
 }
 
+static int nat_hm_check_params(const struct dpa_cls_hm_nat_params *nat_params)
+{
+	unsigned int ip_ver = 0;
+
+	BUG_ON(!nat_params);
+
+	/* Check that all IP address versions are the same: */
+	if (nat_params->type == DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
+
+		if (nat_params->flags & DPA_CLS_HM_NAT_UPDATE_SIP)
+			ip_ver = nat_params->nat.sip.version;
+		if (nat_params->flags & DPA_CLS_HM_NAT_UPDATE_DIP) {
+			if ((ip_ver) &&
+				(ip_ver != nat_params->nat.dip.version)) {
+				pr_err("ERROR: %s, %s (%d): Inconsistent SIP "
+					"DIP address versions.\n", __FILE__,
+					__func__, __LINE__);
+				return -EINVAL;
+			}
+			ip_ver = nat_params->nat.dip.version;
+		}
+
+		if ((ip_ver) && (ip_ver != 4) && (ip_ver != 6)) {
+			pr_err("ERROR: %s, %s (%d): Unsupported IP version "
+				"(%d).\n", __FILE__, __func__, __LINE__,
+				ip_ver);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int fwd_hm_check_params(const struct dpa_cls_hm_fwd_params *fwd_params)
 {
 	BUG_ON(!fwd_params);
@@ -2916,9 +2949,15 @@ int dpa_classif_set_nat_hm(const struct dpa_cls_hm_nat_params	*nat_params,
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	pr_err("ERROR: %s, %s (%d): NAT header manipulation is not supported "
-		"yet.\n", __FILE__, __func__, __LINE__);
-	return -ENOSYS;
+	if (res) {
+		pr_err("ERROR: %s, %s (%d): Header manipulation import is not "
+			"yet supported.\n", __FILE__, __func__, __LINE__);
+		return -ENOSYS;
+	}
+
+	err = nat_hm_check_params(nat_params);
+	if (err < 0)
+		return err;
 
 	err = create_new_hm_op(hmd, next_hmd);
 	if (err < 0)
@@ -2981,102 +3020,205 @@ static int init_nat_hm(struct dpa_cls_hm *pnat_hm)
 {
 	struct dpa_cls_hm_node *hm_node = NULL;
 	struct dpa_cls_hm *pnext_hm = NULL;
-	struct dpa_cls_hm *pcurrent;
+	unsigned int ip_ver = 0;
+	enum dpa_cls_hm_node_type l3_update_node = DPA_CLS_HM_NODE_LAST_ENTRY;
+	enum dpa_cls_hm_node_type l4_update_node = DPA_CLS_HM_NODE_LAST_ENTRY;
 
 	BUG_ON(!pnat_hm);
 
+	pnat_hm->num_nodes = 0;
+
+	if (pnat_hm->nat_params.type == DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
+		if (pnat_hm->nat_params.flags &
+			DPA_CLS_HM_NAT_UPDATE_SIP)
+			ip_ver = pnat_hm->nat_params.nat.sip.version;
+		if (pnat_hm->nat_params.flags &
+			DPA_CLS_HM_NAT_UPDATE_DIP)
+			ip_ver = pnat_hm->nat_params.nat.dip.version;
+		if ((pnat_hm->nat_params.flags &
+				DPA_CLS_HM_NAT_UPDATE_SPORT) ||
+				(pnat_hm->nat_params.flags &
+				DPA_CLS_HM_NAT_UPDATE_DPORT))
+			l4_update_node = DPA_CLS_HM_NODE_TCPUDP_HDR_UPDATE;
+		if (ip_ver) {
+			if (ip_ver == 4)
+				l3_update_node =
+					DPA_CLS_HM_NODE_IPv4_HDR_UPDATE;
+			else
+				l3_update_node =
+					DPA_CLS_HM_NODE_IPv6_HDR_UPDATE;
+		}
+	} else {
+		if (pnat_hm->nat_params.nat_pt.type ==
+				DPA_CLS_HM_NAT_PT_IPv6_TO_IPv4)
+			l3_update_node =
+				DPA_CLS_HM_NODE_HDR_REPLACE_IPv6_BY_IPv4;
+		else
+			l3_update_node =
+				DPA_CLS_HM_NODE_HDR_REPLACE_IPv4_BY_IPv6;
+	}
+
+	/* Check if we can attach to an existing update node */
 	if (!list_empty(&pnat_hm->list_node))
 		pnext_hm = list_entry(pnat_hm->list_node.next,
-					struct dpa_cls_hm,
-					list_node);
-
-	if (pnext_hm)
-		/*
-		 * Check if there already is another TCP/UDP update in the
-		 * existing HM chain
-		 */
-		hm_node = find_compatible_hm_node(
-			DPA_CLS_HM_NODE_TCPUDP_HDR_UPDATE,
-			pnext_hm->hm_chain);
+			struct dpa_cls_hm,
+			list_node);
 
-	if (!hm_node) {
-		/* Create a TCP/UDP update node: */
-		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+	if (l3_update_node != DPA_CLS_HM_NODE_LAST_ENTRY) {
+		/* Check if we can attach to an existing L3 update node */
+		if (pnext_hm)
+			hm_node = find_compatible_hm_node(l3_update_node,
+							pnext_hm->hm_chain);
 		if (!hm_node) {
-			pr_err("ERROR: %s, %s (%d): No more memory for header "
-				"manip nodes.\n", __FILE__, __func__, __LINE__);
-			return -ENOMEM;
+			/* Create an L3 update node: */
+			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+			if (!hm_node) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"header manip nodes.\n", __FILE__,
+					__func__, __LINE__);
+				return -ENOMEM;
+			}
+			INIT_LIST_HEAD(&hm_node->list_node);
 		}
 
 		hm_node->params.type = e_FM_PCD_MANIP_HDR;
-		hm_node->params.u.hdr.fieldUpdate = TRUE;
-		hm_node->params.u.hdr.fieldUpdateParams.type =
-				DPA_CLS_HM_NODE_TCPUDP_HDR_UPDATE;
-
-		if (pnext_hm)
-			list_add_tail(&hm_node->list_node,
-					pnext_hm->hm_chain);
-		else
-			INIT_LIST_HEAD(&hm_node->list_node);
 
-		pnat_hm->hm_chain = &hm_node->list_node;
-	} else
-		pnat_hm->hm_chain = pnext_hm->hm_chain;
-
-	/* PARAMETERS FOR LOW LEVEL HM NODE NOT INITIALIZED */
+		if (pnat_hm->nat_params.type ==
+					DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
+			hm_node->params.u.hdr.fieldUpdate = TRUE;
+			if (ip_ver == 4) {
+				hm_node->params.u.hdr.fieldUpdateParams.type =
+					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4;
 
-	pnat_hm->hm_node[0] = hm_node;
+				if (pnat_hm->nat_params.flags &
+						DPA_CLS_HM_NAT_UPDATE_SIP) {
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv4.
+						validUpdates |=
+						HDR_MANIP_IPV4_SRC;
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv4.
+						src = pnat_hm->nat_params.nat.
+						sip.addr.ipv4.word;
+				}
 
-	hm_node = NULL;
+				if (pnat_hm->nat_params.flags &
+						DPA_CLS_HM_NAT_UPDATE_DIP) {
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv4.
+						validUpdates |=
+						HDR_MANIP_IPV4_DST;
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv4.
+						dst = pnat_hm->nat_params.nat.
+						dip.addr.ipv4.word;
+				}
+			} else { /* We're dealing with IPv6 */
+				hm_node->params.u.hdr.fieldUpdateParams.type =
+					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6;
 
-	if (pnext_hm)
-		/*
-		 * Check if there already is another IPv4 update in the
-		 * existing HM chain
-		 */
-		hm_node = find_compatible_hm_node(
-			DPA_CLS_HM_NODE_IPv4_HDR_UPDATE,
-			pnext_hm->hm_chain);
+				if (pnat_hm->nat_params.flags &
+						DPA_CLS_HM_NAT_UPDATE_SIP) {
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv6.
+						validUpdates |=
+						HDR_MANIP_IPV6_SRC;
+					memcpy(hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv6.src,
+						pnat_hm->nat_params.nat.sip.
+						addr.ipv6.byte,
+						DPA_OFFLD_IPv6_ADDR_LEN_BYTES);
+				}
 
-	if (!hm_node) {
-		/* Create an IPv4 update node: */
-		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-		if (!hm_node) {
-			pr_err("ERROR: %s, %s (%d): No more memory for header "
-				"manip nodes.\n", __FILE__, __func__, __LINE__);
-			return -ENOMEM;
+				if (pnat_hm->nat_params.flags &
+						DPA_CLS_HM_NAT_UPDATE_DIP) {
+					hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv4.
+						validUpdates |=
+						HDR_MANIP_IPV6_DST;
+					memcpy(hm_node->params.u.hdr.
+						fieldUpdateParams.u.ipv6.dst,
+						pnat_hm->nat_params.nat.dip.
+						addr.ipv6.byte,
+						DPA_OFFLD_IPv6_ADDR_LEN_BYTES);
+				}
+			}
+		} else { /* NAT-PT */
+			hm_node->params.u.hdr.custom = TRUE;
+			hm_node->params.u.hdr.customParams.type =
+					e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE;
+
+			if (pnat_hm->nat_params.nat_pt.type ==
+					DPA_CLS_HM_NAT_PT_IPv6_TO_IPv4) {
+				hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.replaceType =
+			e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4;
+				hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.hdrSize =
+						sizeof(struct iphdr);
+				memcpy(hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.hdr,
+					&pnat_hm->nat_params.nat_pt.new_header.
+					ipv4, sizeof(struct iphdr));
+			} else {
+				hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.replaceType =
+			e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6;
+				hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.hdrSize =
+					(uint8_t)sizeof(struct ipv6_header);
+				memcpy(hm_node->params.u.hdr.customParams.u.
+					ipHdrReplace.hdr,
+					&pnat_hm->nat_params.nat_pt.new_header.
+					ipv6, sizeof(struct ipv6_header));
+			}
 		}
 
-		hm_node->params.type = e_FM_PCD_MANIP_HDR;
-		hm_node->params.u.hdr.fieldUpdate = TRUE;
-		hm_node->params.u.hdr.fieldUpdateParams.type =
-				DPA_CLS_HM_NODE_IPv4_HDR_UPDATE;
+		pnat_hm->hm_node[pnat_hm->num_nodes++] = hm_node;
+		hm_node = NULL;
+	}
 
+	if (l4_update_node != DPA_CLS_HM_NODE_LAST_ENTRY) {
+		/* Check if we can attach to an existing L4 update node */
 		if (pnext_hm)
-			list_add(&hm_node->list_node,
-					pnext_hm->hm_chain);
-		else
+			hm_node = find_compatible_hm_node(l4_update_node,
+							pnext_hm->hm_chain);
+		if (!hm_node) {
+			/* Create an L3 update node: */
+			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+			if (!hm_node) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"header manip nodes.\n", __FILE__,
+					__func__, __LINE__);
+				return -ENOMEM;
+			}
 			INIT_LIST_HEAD(&hm_node->list_node);
+		}
 
-		pnat_hm->hm_chain = &hm_node->list_node;
-	}
-
-	/* PARAMETERS FOR LOW LEVEL HM NODE NOT INITIALIZED */
+		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
+		hm_node->params.u.hdr.fieldUpdate	= TRUE;
+		hm_node->params.u.hdr.fieldUpdateParams.type =
+				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP;
 
-	pnat_hm->hm_node[1] = hm_node;
-	pnat_hm->num_nodes = 2;
+		if (pnat_hm->nat_params.flags & DPA_CLS_HM_NAT_UPDATE_SPORT) {
+			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.
+				validUpdates |= HDR_MANIP_TCP_UDP_SRC;
+			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.src =
+				pnat_hm->nat_params.sport;
+		}
 
-	/*
-	 * Update the low level ops chain head for all the other
-	 * high level ops in the high level ops chain:
-	 */
-	if ((pnext_hm) && (pnat_hm->hm_chain != pnext_hm->hm_chain)) {
-		list_for_each_entry(pcurrent,
-			&pnat_hm->list_node, list_node) {
-			pcurrent->hm_chain = pnat_hm->hm_chain;
+		if (pnat_hm->nat_params.flags & DPA_CLS_HM_NAT_UPDATE_DPORT) {
+			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.
+				validUpdates |= HDR_MANIP_TCP_UDP_DST;
+			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.dst =
+				pnat_hm->nat_params.dport;
 		}
+
+		pnat_hm->hm_node[pnat_hm->num_nodes++] = hm_node;
 	}
 
+	add_local_hm_nodes_to_chain(pnat_hm);
+
 	return 0;
 }
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 292e11e..b1bb7b5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -406,6 +406,12 @@ static int remove_hm_chain(struct list_head	*chain_head,
 static int create_new_hm_op(int *hmd, int next_hmd);
 
 /*
+ * Verifies that the parameters provided for a NAT type header manipulation op
+ * are correct.
+ */
+static int nat_hm_check_params(const struct dpa_cls_hm_nat_params *nat_params);
+
+/*
  * Imports the low level header manipulation nodes for a NAT classifier header
  * manipulation op.
  */
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index c877da0..93be0a2 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -508,7 +508,7 @@ struct dpa_cls_hm_nat_pt_params {
 
 		/* IPv6 header data to replace IPv4 with */
 		struct ipv6_header		ipv6;
-	} header;
+	} new_header;
 };
 
 /* Definition of a NAT related header manipulation */
@@ -539,7 +539,7 @@ struct dpa_cls_hm_nat_params {
 		 * is selected using the [type] attribute.
 		 */
 		struct dpa_cls_hm_nat_pt_params			nat_pt;
-	} params;
+	};
 
 	/*
 	 * New L4 protocol source port number; used when selected using the
-- 
1.7.5.4

