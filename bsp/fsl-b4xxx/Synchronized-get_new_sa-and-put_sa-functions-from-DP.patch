From e9b21c7f96382ecb086856669ae8bfe9502ce60a Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:49:04 +0000
Subject: [PATCH 163/518] Synchronized get_new_sa and put_sa functions from
 DPA IPSec component

get_new_sa returns a valid id for SA and updates SA instance to
make that SA is used.
put_sa function expects that SA lock is acquired.
Always acquire parent SA prior to child SA if both locks are needed.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   46 ++++++++++++++++-----------
 1 files changed, 27 insertions(+), 19 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 2c960b8..1792aea 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2576,9 +2576,14 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 		return -EFAULT;
 	}
 
+	/* Acquire DPA IPSec instance lock */
+	mutex_lock(&dpa_ipsec->lock);
+
 	/* Get an id for new SA */
 	if (cq_get_4bytes(dpa_ipsec->sa_mng.sa_id_cq, &id) < 0) {
-		xx_pr_err("No more unused SA handles");
+		xx_pr_err("No more unused SA handles\n");
+		/* Release DPA IPSec instance lock */
+		mutex_unlock(&dpa_ipsec->lock);
 		return -EDOM;
 	}
 
@@ -2588,59 +2593,59 @@ static int get_new_sa(struct dpa_ipsec *dpa_ipsec,
 	if (i == dpa_ipsec->sa_mng.max_num_sa) {
 		xx_pr_err("No more used SAs ID holders");
 		cq_put_4bytes(dpa_ipsec->sa_mng.sa_id_cq, id);
+		/* Release DPA IPSec instance lock */
+		mutex_unlock(&dpa_ipsec->lock);
 		return -EDOM;
 	}
 
 	/* Acquire a preallocated SA structure */
 	sa = &(dpa_ipsec->sa_mng.sa[id]);
-	/* AV's TODO: create a clean function for preallocated SA structure
+	/* AV's TODO: create a cleaning function for preallocated SA structure
 	 * and call here that function */
 	sa->id = id;
 	sa->used_sa_index = i;
 	dpa_ipsec->used_sa_ids[sa->used_sa_index] = sa->id;
 	dpa_ipsec->num_used_sas++;
 
+	/* Release DPA IPSec instance lock */
+	mutex_unlock(&dpa_ipsec->lock);
+
 	*sa_id = id;
 	*new_sa = sa;
 
 	return 0;
 }
 
+/* Expects that SA lock is acquired for this SA structure and parent/child SA.
+ * AV's note: always acquire parent SA lock before child SA lock.
+ */
 static int put_sa(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_sa_mng *sa_mng;
-	struct dpa_ipsec_sa *parent_sa, *child_sa;
 	int err;
 
 	dpa_ipsec = sa->dpa_ipsec;
-	sa_mng = &dpa_ipsec->sa_mng;
+	if (!dpa_ipsec) {
+		xx_pr_err("Invalid argument: NULL DPA IPSec instance\n");
+		return -EFAULT;
+	}
 
 	if (sa->used_sa_index < 0) {
 		xx_pr_crit("Invalid used_sa_index for SA with id %d\n", sa->id);
 		return -EFAULT;
 	}
 
-	/* Update successor to have no parent because its parent died */
-	if (sa->child_sa) {
-		child_sa  = sa->child_sa;
-		/* AV's note TODO: acquire lock for child SA */
-		child_sa->parent_sa = NULL;
-		sa->child_sa  = NULL;
-	}
-
-	/* Update parent to have no child because its child died */
-	if (sa->parent_sa) {
-		parent_sa =  sa->parent_sa;
-		/* AV's note TODO: acquire lock for parent SA */
-		parent_sa->child_sa = NULL;
-		sa->parent_sa = NULL;
-	}
+	/* Acquire DPA IPSec instance lock */
+	mutex_lock(&dpa_ipsec->lock);
+	sa_mng = &dpa_ipsec->sa_mng;
 
 	/* Release the SA id in the SA IDs circular queue */
 	err = cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
 	if (err < 0) {
 		xx_pr_err("Could not release the sa id %d\n", sa->id);
+		/* Release DPA IPSec instance lock */
+		mutex_unlock(&dpa_ipsec->lock);
 		return -EDOM;
 	}
 
@@ -2649,6 +2654,9 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	dpa_ipsec->num_used_sas--;
 	sa->used_sa_index = -1;
 
+	/* Release DPA IPSec instance lock */
+	mutex_unlock(&dpa_ipsec->lock);
+
 	return 0;
 }
 
-- 
1.7.5.4

