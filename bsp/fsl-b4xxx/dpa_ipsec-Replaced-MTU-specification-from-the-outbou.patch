From 2d825dc4ab264867feed90036085e7e56c388114 Mon Sep 17 00:00:00 2001
From: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
Date: Sat, 10 Nov 2012 00:11:50 +0000
Subject: [PATCH 398/518] dpa_ipsec: Replaced MTU specification from the
 outbound policy with classifier header manipulation
 descriptor

Removed the runtime creation of fragmentation manipulation from ipsec component
replaced it with classifier header manipulation descriptor which has
to be created apriori with classifier API.

Direct scheme is invoked transparent to DPA IPSec - no change required,
this is done in classifier.

Linkage between DPA IPSec special manip and the manipulation specified
on outbound is assured by the DPA IPSec component.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  177 ++++++++++++++-------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   19 +++-
 include/linux/fsl_dpa_ipsec.h               |   35 +++---
 3 files changed, 131 insertions(+), 100 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 862078a..a34e9d8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -49,8 +49,6 @@ struct ipsec_alg_suite ipsec_algs[] = IPSEC_ALGS;
 /* globally allocated because of performance constraints */
 static t_FmPcdCcNodeParams cc_node_prms;
 
-static t_FmPcdManipParams pcd_manip_params;
-
 /* Global dpa_ipsec component */
 struct dpa_ipsec *gbl_dpa_ipsec;
 
@@ -1312,46 +1310,6 @@ static inline void fill_cls_action_drop(struct dpa_cls_tbl_action *action,
 	action->enable_statistics = en_stats;
 }
 
-static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
-			     struct dpa_ipsec_pol_frag_params *out_frag,
-			     int *frag_hmd)
-{
-	t_FmPcdManipFragParams *frag_param;
-	int err;
-	t_Handle hm;
-
-	BUG_ON(!dpa_ipsec);
-	BUG_ON(!out_frag);
-	BUG_ON(!frag_hmd);
-
-	if (!out_frag->mtu) {
-		/* no need to create a manipulation object */
-		*frag_hmd = DPA_OFFLD_DESC_NONE;
-		return 0;
-	}
-
-	memset(&pcd_manip_params, 0, sizeof(pcd_manip_params));
-	frag_param = &pcd_manip_params.u.frag;
-	pcd_manip_params.type = e_FM_PCD_MANIP_FRAG;
-	frag_param->hdr  = HEADER_TYPE_IPv4;
-	frag_param->u.ipFrag.sizeForFragmentation = out_frag->mtu;
-	frag_param->u.ipFrag.scratchBpid = dpa_ipsec->config.ipf_bpid;
-	frag_param->u.ipFrag.dontFragAction =
-					pcd_df_action[out_frag->df_action];
-	hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
-	if (!hm) {
-		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
-		return -EBUSY;
-	}
-
-	err = dpa_classif_import_static_hm(hm, DPA_OFFLD_DESC_NONE, frag_hmd);
-	if (err < 0)
-		pr_err("%s: Failed to import IP fragmentation into DPA "
-			"Classifier.\n", __func__);
-
-	return err;
-}
-
 /*
  * Used at runtime when preallocation of IPSec manip node is not enabled
  */
@@ -1512,11 +1470,16 @@ static int update_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
 	return ret;
 }
 
-static int destroy_recycle_manip(struct dpa_ipsec_sa *sa, int hmd)
+static int destroy_recycle_manip(struct dpa_ipsec_sa *sa,
+				 struct hmd_entry *entry)
 {
 	t_Handle hm;
-	int err = 0;
+	int hmd, err = 0;
 
+	BUG_ON(!sa);
+	BUG_ON(!entry);
+
+	hmd = entry->hmd;
 	BUG_ON(hmd == DPA_OFFLD_DESC_NONE);
 
 	hm = dpa_classif_get_static_hm_handle(hmd);
@@ -1536,12 +1499,17 @@ static int destroy_recycle_manip(struct dpa_ipsec_sa *sa, int hmd)
 		return 0;
 	}
 
-	/* Destroy hm */
-	err = FM_PCD_ManipNodeDelete(hm);
-	if (err != E_OK) {
-		pr_err("%s: FM_PCD_ManipNodeDelete failed for SA %d!\n",
-			__func__, sa->id);
-		return -EBUSY;
+	if (entry->hmd_special_op) {
+		/*
+		 * Destroy only the IPSec special operation that was created
+		 * inside IPSec
+		 */
+		err = FM_PCD_ManipNodeDelete(hm);
+		if (err != E_OK) {
+			pr_err("%s: FM_PCD_ManipNodeDelete failed for SA %d!\n",
+				__func__, sa->id);
+			return -EBUSY;
+		}
 	}
 
 	return 0;
@@ -1637,7 +1605,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_entry_mod_params params;
 	int table, err;
-	int frag_hmd = DPA_OFFLD_DESC_NONE, pol_hmd = DPA_OFFLD_DESC_NONE;
+	int manip_hmd = DPA_OFFLD_DESC_NONE, pol_hmd = DPA_OFFLD_DESC_NONE;
 	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 
@@ -1686,32 +1654,45 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 		/* Configure fragmentation */
 		if (pol_params->dir_params.type ==
-						DPA_IPSEC_POL_DIR_PARAMS_FRAG) {
-			err = create_frag_manip(dpa_ipsec,
-					       &pol_params->dir_params.out_frag,
-					       &frag_hmd);
-			if (err < 0) {
-				pr_err("Could not create Manip node for fragmentation!\n");
-				return -EAGAIN;
-			}
+					DPA_IPSEC_POL_DIR_PARAMS_MANIP) {
+			manip_hmd = pol_params->dir_params.manip_desc;
+			/*
+			 * check_policy_params validated manip descriptor
+			 */
+			BUG_ON(manip_hmd < 0);
 		}
 
 		/* Init IPSec Manip. object (if required) for outbound policy */
-		if (frag_hmd != DPA_OFFLD_DESC_NONE) {
-			/* need to chain the IPSec Manip and Frag Manip */
-			err = create_ipsec_manip(sa, frag_hmd,
+		if (manip_hmd == DPA_OFFLD_DESC_NONE)
+			goto no_frag_or_manip;
+
+		/* need to chain the IPSec Manip and Frag/Manip */
+		if (sa->dpa_ipsec->config.max_sa_manip_ops == 0)
+			err = create_ipsec_manip(sa, manip_hmd,
 						 &policy_entry->hmd);
-			if (err < 0) {
-				pr_err("Couldn't create policy manip chain!\n");
-				return err;
-			}
-			pol_hmd = policy_entry->hmd;
-		} else {
-			if (sa->ipsec_hmd == DPA_OFFLD_DESC_NONE)
-				/*
-				 * need to create the IPSec Manip (per SA),
-				 * if it was not created earlier
-				 */
+		else
+			err = update_ipsec_manip(sa, manip_hmd,
+						 &policy_entry->hmd);
+		if (err < 0) {
+			pr_err("Couldn't create policy manip chain!\n");
+			return err;
+		}
+
+		pol_hmd = policy_entry->hmd;
+		if (pol_hmd == manip_hmd)
+			policy_entry->hmd_special_op = false;
+		else
+			policy_entry->hmd_special_op = true;
+
+		goto set_manipulation;
+
+no_frag_or_manip:
+		if (sa->ipsec_hmd == DPA_OFFLD_DESC_NONE) {
+			/*
+			 * need to create the IPSec Manip (per SA),
+			 * if it was not created earlier
+			 */
+			if (sa->dpa_ipsec->config.max_sa_manip_ops == 0)
 				err = create_ipsec_manip(sa,
 							 DPA_OFFLD_DESC_NONE,
 							 &sa->ipsec_hmd);
@@ -1723,12 +1704,13 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 				pr_err("Couldn't create SA manip!\n");
 				return err;
 			}
-			pol_hmd = sa->ipsec_hmd;
 		}
+		pol_hmd = sa->ipsec_hmd;
 
+set_manipulation:
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-				    qman_fq_fqid((sa->to_sec_fq)), pol_hmd);
+				    qman_fq_fqid(sa->to_sec_fq), pol_hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 					      policy_entry->pol_params.priority,
@@ -1747,7 +1729,10 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		}
 
 		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_recycle_manip(sa, policy_entry->hmd);
+			struct hmd_entry hmd_entry;
+			hmd_entry.hmd = policy_entry->hmd;
+			hmd_entry.hmd_special_op = policy_entry->hmd_special_op;
+			err = destroy_recycle_manip(sa, &hmd_entry);
 			if (err < 0) {
 				pr_err("Couldn't delete frag & ipsec manip\n");
 				return err;
@@ -2570,9 +2555,15 @@ static int check_policy_params(struct dpa_ipsec_sa *sa,
 	}
 
 	/* check if fragmentation is enabled for inbound SAs */
-	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_FRAG &&
+	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_MANIP &&
 	    sa->sa_dir == DPA_IPSEC_INBOUND) {
-		pr_err("Fragmentation can't be enabled for inbound policy!\n");
+		pr_err("Fragmentation or header manipulation can't be enabled for inbound policy!\n");
+		return -EINVAL;
+	}
+
+	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_MANIP &&
+	    pol_params->dir_params.manip_desc < 0) {
+		pr_err("Invalid manip descriptor for SA id %d\n", sa->id);
 		return -EINVAL;
 	}
 
@@ -2983,7 +2974,10 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
-		err_rb = destroy_recycle_manip(sa, sa->ipsec_hmd);
+		struct hmd_entry hmd_entry;
+		hmd_entry.hmd = sa->ipsec_hmd;
+		hmd_entry.hmd_special_op = true;
+		err_rb = destroy_recycle_manip(sa, &hmd_entry);
 		if (err_rb < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err_rb;
@@ -3038,7 +3032,10 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 			(sa->ipsec_hmd != DPA_OFFLD_DESC_NONE)) {
-		err_rb = destroy_recycle_manip(sa, sa->ipsec_hmd);
+		struct hmd_entry hmd_entry;
+		hmd_entry.hmd = sa->ipsec_hmd;
+		hmd_entry.hmd_special_op = true;
+		err_rb = destroy_recycle_manip(sa, &hmd_entry);
 		if (err_rb < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err_rb;
@@ -3344,7 +3341,10 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 
 		/* destroy SA manip */
 		if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_recycle_manip(sa, sa->ipsec_hmd);
+			struct hmd_entry hmd_entry;
+			hmd_entry.hmd = sa->ipsec_hmd;
+			hmd_entry.hmd_special_op = true;
+			err = destroy_recycle_manip(sa, &hmd_entry);
 			if (err < 0) {
 				pr_err("Could not delete manip object!\n");
 				return err;
@@ -3424,7 +3424,10 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 
 	/* destroy SA manip */
 	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-		err = destroy_recycle_manip(sa, sa->ipsec_hmd);
+		struct hmd_entry hmd_entry;
+		hmd_entry.hmd = sa->ipsec_hmd;
+		hmd_entry.hmd_special_op = true;
+		err = destroy_recycle_manip(sa, &hmd_entry);
 		if (err < 0) {
 			pr_err("Could not delete manip object!\n");
 			return err;
@@ -3551,7 +3554,10 @@ static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
 
 	/* destroy SA manip, if one was initialized */
 	if (sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-		err = destroy_recycle_manip(sa, sa->ipsec_hmd);
+		struct hmd_entry hmd_entry;
+		hmd_entry.hmd = sa->ipsec_hmd;
+		hmd_entry.hmd_special_op = true;
+		err = destroy_recycle_manip(sa, &hmd_entry);
 		if (err < 0) {
 			pr_err("Couldn't delete SA manip\n");
 			return err;
@@ -4184,7 +4190,10 @@ static int sa_rekeying_inbound(struct dpa_ipsec_sa *new_sa)
 
 		/* destroy SA manip */
 		if (old_sa->ipsec_hmd != DPA_OFFLD_DESC_NONE) {
-			err = destroy_recycle_manip(old_sa, old_sa->ipsec_hmd);
+			struct hmd_entry hmd_entry;
+			hmd_entry.hmd = old_sa->ipsec_hmd;
+			hmd_entry.hmd_special_op = true;
+			err = destroy_recycle_manip(old_sa, &hmd_entry);
 			if (err < 0) {
 				pr_err("Could not delete manip object!\n");
 				return err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 1f107b3..0c2f713 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -378,11 +378,28 @@ struct dpa_ipsec {
 	struct mutex lock; /* Lock for this dpa_ipsec instance */
 };
 
+struct hmd_entry {
+	int hmd;
+	bool hmd_special_op;
+};
+
 /* DPA IPSEC - Security Policy Parameter Entry */
 struct dpa_ipsec_policy_entry {
 	struct dpa_ipsec_policy_params pol_params; /* Policy parameters       */
 	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
-	int hmd;		/* Header manip for frag      */
+
+	/*
+	 * Header manip for IPSec special operation or
+	 * if none Header manip for fragmentation or
+	 * manipulation
+	 */
+	int hmd;
+
+	/*
+	 * true is hmd is IPSec special operation, false
+	 * is hmd refers to an outside manip object
+	 */
+	bool hmd_special_op;
 	struct list_head node;	/* Node in linked list			      */
 };
 
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index b431453..2be976d 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -424,27 +424,32 @@ struct dpa_ipsec_icmp_params {
 
 /* DPA IPSec direction specific policy params types */
 enum dpa_ipsec_pol_dir_params_type {
-	DPA_IPSEC_POL_DIR_PARAMS_NONE = 0, /* No direction specific params */
-	DPA_IPSEC_POL_DIR_PARAMS_FRAG, /* Frag params (outbound policies only)*/
-	DPA_IPSEC_POL_DIR_PARAMS_ACT, /* Action params (inbound policies only)*/
-};
-
-/* DPA IPSec outbound policies params (fragmentation params) */
-struct dpa_ipsec_pol_frag_params {
-	uint16_t mtu;		/* Maximum size of unencrypted fragments.
-				 * Packets with a bigger size will be
-				 * automatically fragmented. 0 = disabled     */
-	enum dpa_ipsec_df_action df_action; /* Action to be performed when IP
-					     * fragmentation is configured for
-					     * this flow and the DF bit is set
-					     * in the input frame             */
+	/*
+	 * No direction specific params
+	 */
+	DPA_IPSEC_POL_DIR_PARAMS_NONE = 0,
+
+	 /*
+	  * Fragmentation or header manipulation
+	  * params (outbound policies only)
+	  */
+	DPA_IPSEC_POL_DIR_PARAMS_MANIP,
+
+	 /*
+	  * Action params (inbound policies only)
+	  */
+	DPA_IPSEC_POL_DIR_PARAMS_ACT
 };
 
 /* DPA IPSec direction specific parameters for Security Policies */
 struct dpa_ipsec_pol_dir_params {
 	enum dpa_ipsec_pol_dir_params_type type;
 	union {
-		struct dpa_ipsec_pol_frag_params out_frag;
+		 /*
+		  * Manipulation descriptor for fragmentation or
+		  * header manipulation
+		  */
+		int manip_desc;
 		struct dpa_cls_tbl_action in_action; /* Action to be performed
 						      * for frames matching
 						      * the policy selectors  */
-- 
1.7.5.4

