From 16e4ccae43f91d7fdcf8f2ff1bcab74780197639 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Wed, 14 Mar 2012 13:56:55 +0000
Subject: [PATCH 115/518] Use xx_zalloc to directly allocate zero filled
 memory

- optimize DPA IPSec code by replacing xx_malloc + memset sequence
of function calls with a single call to the xx_zalloc function.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c     |   29 ++++++++---------------
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c |    4 +--
 2 files changed, 11 insertions(+), 22 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index fe1ac6a..176884bb 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -650,45 +650,40 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 	}
 
 	/* alloc SA array */
-	sa_mng->sa = xx_malloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
+	sa_mng->sa = xx_zalloc(sa_mng->max_num_sa * sizeof(*sa_mng->sa));
 	if (!sa_mng->sa) {
 		xx_pr_err("Could not allocate memory for SAs\n");
 		return -ENOMEM;
 	}
-	memset(sa_mng->sa, 0, sa_mng->max_num_sa * sizeof(*sa_mng->sa));
 
 	/* alloc cipher/auth stuff */
 	for (i = 0; i < sa_mng->max_num_sa; i++) {
 		sa_mng->sa[i].cipher_data.cipher_key =
-						 xx_malloc(MAX_CIPHER_KEY_LEN);
+						 xx_zalloc(MAX_CIPHER_KEY_LEN);
 		if (!sa_mng->sa[i].cipher_data.cipher_key) {
 			xx_pr_err("Could not allocate memory for cipher key\n");
 			return -ENOMEM;
 		}
-		memset(sa_mng->sa[i].cipher_data.cipher_key, 0,
-		       MAX_CIPHER_KEY_LEN);
 
-		sa_mng->sa[i].auth_data.auth_key = xx_malloc(MAX_AUTH_KEY_LEN);
+		sa_mng->sa[i].auth_data.auth_key = xx_zalloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.auth_key) {
 			xx_pr_err("Could not allocate memory for authentication key\n");
 			return -ENOMEM;
 		}
-		memset(sa_mng->sa[i].auth_data.auth_key, 0, MAX_AUTH_KEY_LEN);
 
-		sa_mng->sa[i].auth_data.split_key = xx_malloc(MAX_AUTH_KEY_LEN);
+		sa_mng->sa[i].auth_data.split_key = xx_zalloc(MAX_AUTH_KEY_LEN);
 		if (!sa_mng->sa[i].auth_data.split_key) {
 			xx_pr_err("Could not allocate memory for authentication split key\n");
 			return -ENOMEM;
 		}
-		memset(sa_mng->sa[i].auth_data.split_key, 0, MAX_AUTH_KEY_LEN);
 
-		sa_mng->sa[i].from_sec_fq = xx_malloc(sizeof(struct qman_fq));
+		sa_mng->sa[i].from_sec_fq = xx_zalloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].from_sec_fq) {
 			xx_pr_err("Can't allocate space for 'from SEC FQ'\n");
 			return -ENOMEM;
 		}
 
-		sa_mng->sa[i].to_sec_fq = xx_malloc(sizeof(struct qman_fq));
+		sa_mng->sa[i].to_sec_fq = xx_zalloc(sizeof(struct qman_fq));
 		if (!sa_mng->sa[i].to_sec_fq) {
 			xx_pr_err("Can't allocate space for 'to SEC FQ'\n");
 			return -ENOMEM;
@@ -698,13 +693,11 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		 * preheader information and the share descriptor. 64 bit align.
 		 */
 		sa_mng->sa[i].sec_desc =
-			xx_malloc_smart(sizeof(struct sec_descriptor), 0, 64);
+			xx_zalloc_smart(sizeof(struct sec_descriptor), 0, 64);
 		if (!sa_mng->sa[i].sec_desc) {
 			xx_pr_err("Could not allocate memory for SEC descriptor\n");
 			return -ENOMEM;
 		}
-		memset(sa_mng->sa[i].sec_desc, 0,
-		       sizeof(struct sec_descriptor));
 
 		/* Initialize the policy parameter list which will hold all
 		 * inbound or outbound policy parameters which were use to
@@ -732,12 +725,11 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 		INIT_LIST_HEAD(&sa_mng->inpol_tables);
 		for (i = 0; i < dpa_ipsec->config.max_sa_pairs; i++) {
-			pol_table = xx_malloc(sizeof(*pol_table));
+			pol_table = xx_zalloc(sizeof(*pol_table));
 			if (!pol_table) {
 				xx_pr_err("Could not allocate memory for policy table");
 				return -ENOMEM;
 			}
-			memset(pol_table, 0, sizeof(*pol_table));
 
 			/* create cc node for inbound policy */
 			err = create_inpol_node(dpa_ipsec, &cc_node);
@@ -2041,7 +2033,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 		return -EFAULT;
 	}
 
-	pol_entry = xx_malloc(sizeof(struct dpa_ipsec_policy_entry));
+	pol_entry = xx_zalloc(sizeof(struct dpa_ipsec_policy_entry));
 	if (!pol_entry) {
 		xx_pr_err("Could not allocate memory for policy\n");
 		return -ENOMEM;
@@ -2468,12 +2460,11 @@ int dpa_ipsec_init(const struct dpa_ipsec_params *params, int *dpa_ipsec_id)
 		return err;
 
 	/* alloc control block */
-	dpa_ipsec = (struct dpa_ipsec *)xx_malloc(sizeof(struct dpa_ipsec));
+	dpa_ipsec = (struct dpa_ipsec *)xx_zalloc(sizeof(struct dpa_ipsec));
 	if (!dpa_ipsec) {
 		xx_pr_err("Could not allocate memory for control block.\n");
 		return -ENOMEM;
 	}
-	memset(dpa_ipsec, 0, sizeof(struct dpa_ipsec));
 
 	/* store parameters */
 	store_ipsec_params(dpa_ipsec, params);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 3d25d6e..51d8fad 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -277,13 +277,11 @@ long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
 			}
 
 			prm.policy_params =
-				xx_malloc(num_pol * sizeof(*prm.policy_params));
+				xx_zalloc(num_pol * sizeof(*prm.policy_params));
 			if (!prm.policy_params) {
 				xx_pr_err("No more memory");
 				return -ENOMEM;
 			}
-			memset(prm.policy_params, 0,
-			       num_pol * sizeof(*prm.policy_params));
 
 			err = dpa_ipsec_sa_get_policies(sa_id,
 							prm.policy_params,
-- 
1.7.5.4

