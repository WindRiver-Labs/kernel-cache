From 9ca4247a4bd079ac078479e42ec67113de18bff4 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 7 Sep 2012 20:21:59 +0000
Subject: [PATCH 313/518] dpa_stats: Added support for fragmentation
 statistics per flow

Application can retrieve the fragmentation statistics for a specific
flow identified through a single or a pair of keys.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c     |  252 ++++++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_stats.h     |    4 +-
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   11 +
 3 files changed, 214 insertions(+), 53 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 5754259..b8aba91 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -40,6 +40,7 @@
 /* DPA offloading layer includes */
 #include "dpa_compat.h"
 #include "dpa_stats.h"
+#include "dpa_classifier.h"
 
 /* FMD includes */
 #include "fm_pcd_ext.h"
@@ -50,6 +51,9 @@
 /* Global dpa_stats component */
 struct dpa_stats *gbl_dpa_stats;
 
+static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb);
+
 /* check that the provided params are valid */
 static int check_dpa_stats_params(const struct dpa_stats_params *params)
 {
@@ -876,6 +880,40 @@ static void cnt_sel_to_stats(struct stats_info *stats_info,
 	stats_info->stats_num = cntPos - 1;
 }
 
+static int set_frag_manip(int td, struct dpa_stats_lookup_key *entry)
+{
+	struct dpa_cls_tbl_action action;
+	struct t_FmPcdManipStats manipStats;
+	int err = 0;
+
+	err = dpa_classif_table_lookup_by_key(td, &entry->key, &action);
+	if (err != 0) {
+		pr_err("Unable to retrieve next action parameters\n");
+		return -EINVAL;
+	}
+
+	if (action.type != DPA_CLS_TBL_ACTION_ENQ) {
+		pr_err("Fragmentation statistics per flow are "
+			"supported only for action enqueue\n");
+		return -EINVAL;
+	}
+
+	entry->frag = dpa_classif_get_frag_hm_handle(action.enq_params.hmd);
+	if (!entry->frag) {
+		pr_err("Unable to retrieve fragmentation handle\n");
+		return -EINVAL;
+	}
+
+	/* Check the user-provided fragmentation handle */
+	err = FM_PCD_ManipGetStatistics(entry->frag, &manipStats);
+	if (err < 0) {
+		pr_err("Invalid Fragmentation manip handle\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				const struct dpa_stats_cnt_params *params)
 {
@@ -1067,7 +1105,7 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	struct dpa_cls_tbl_params cls_tbl;
 	t_FmPcdCcKeyStatistics stats;
 	uint32_t cnt_sel = prm.cnt_sel;
-	int err = 0;
+	int err = 0, frag_stats = -1;
 
 	if (!dpa_stats) {
 		pr_err("Invalid argument: NULL DPA Stats instance\n");
@@ -1075,16 +1113,27 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Check Classifier Table counter selection */
-	if (!((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
-	    (cnt_sel <= DPA_STATS_CNT_CLASSIF_ALL))) {
+	if ((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
+	    (cnt_sel <= DPA_STATS_CNT_CLASSIF_ALL)) {
+
+		/* Entire group of counters was selected */
+		if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
+			cnt_sel -= 1;
+		frag_stats = 0;
+
+	} else if ((cnt_sel >= DPA_STATS_CNT_FRAG_TOTAL_FRAMES) &&
+		 (cnt_sel <= DPA_STATS_CNT_FRAG_ALL)) {
+
+		/* Entire group of counters was selected */
+		if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
+			cnt_sel -= 1;
+		frag_stats = 1;
+
+	} else {
 		pr_err("Invalid Classifier Table counter selection");
 		return -EINVAL;
 	}
 
-	/* Entire group of counters was selected */
-	if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
-		cnt_sel -= 1;
-
 	err = dpa_classif_table_get_params(prm.td, &cls_tbl);
 	if (err != 0) {
 		pr_err("Invalid Classifier Table descriptor\n");
@@ -1114,10 +1163,23 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	/* Map Classifier Table counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_tbl_cb->info,
-		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-		(cnt_sel >> CLASSIF_STATS_SHIFT));
+	if (frag_stats) {
+		err = set_frag_manip(prm.td, &cnt_tbl_cb->keys[0]);
+		if (err < 0) {
+			pr_err("Invalid Fragmentation manip handle\n");
+			return -EINVAL;
+		}
+		/* Map Classifier Table counter selection to Frag stats */
+		cnt_sel_to_stats(&cnt_tbl_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
+		/* Change the retrieve routine */
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
+	} else
+		/* Map Classifier Table counter selection to CcNode stats */
+		cnt_sel_to_stats(&cnt_tbl_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+			(cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_tbl_cb->info.stats_num;
@@ -1368,7 +1430,7 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_gen_cb->objs_num = params->class_members;
 
 	for (i = 0; i < params->class_members; i++) {
-		cnt_gen_cb->objs[i] = params->frag_params.frag;
+		cnt_gen_cb->objs[i] = params->frag_params.frag[i];
 
 		/* Check the user-provided fragmentation handle */
 		err = FM_PCD_ManipGetStatistics(cnt_gen_cb->objs[i], &stats);
@@ -1500,7 +1562,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	struct dpa_cls_tbl_params cls_tbl;
 	struct t_FmPcdCcKeyStatistics stats;
 	uint32_t i = 0, cnt_sel = prm.cnt_sel;
-	int err = 0;
+	int err = 0, frag_stats = -1;
 
 	/* Check Classifier Table descriptor */
 	if (params->classif_tbl_params.td == DPA_OFFLD_INVALID_OBJECT_ID) {
@@ -1509,16 +1571,27 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	/* Check Classifier Table counter selection */
-	if (!((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
-	    (cnt_sel <= DPA_STATS_CNT_CLASSIF_ALL))) {
+	if ((cnt_sel >= DPA_STATS_CNT_CLASSIF_BYTES) &&
+	    (cnt_sel <= DPA_STATS_CNT_CLASSIF_ALL)) {
+
+		/* Entire group of counters was selected */
+		if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
+			cnt_sel -= 1;
+		frag_stats = 0;
+
+	} else if ((cnt_sel >= DPA_STATS_CNT_FRAG_TOTAL_FRAMES) &&
+		 (cnt_sel <= DPA_STATS_CNT_FRAG_ALL)) {
+
+		/* Entire group of counters was selected */
+		if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
+			cnt_sel -= 1;
+		frag_stats = 1;
+
+	} else {
 		pr_err("Invalid Classifier Table counter selection");
 		return -EINVAL;
 	}
 
-	/* Entire group of counters was selected */
-	if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
-		cnt_sel -= 1;
-
 	cnt_tbl_cb->td = params->classif_tbl_params.td;
 	cnt_tbl_cb->keys_num = params->class_members;
 
@@ -1597,10 +1670,30 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
-	/* Map Classif Node counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_tbl_cb->info,
-		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-		(cnt_sel >> CLASSIF_STATS_SHIFT));
+	if (frag_stats) {
+		/* For every valid key, retrieve the hmcd */
+		for (i = 0; i < params->class_members; i++) {
+			if (!cnt_tbl_cb->keys[i].valid)
+				continue;
+
+			err = set_frag_manip(prm.td, &cnt_cb->tbl_cb.keys[i]);
+			if (err < 0) {
+				pr_err("Invalid Fragmentation manip handle\n");
+				return -EINVAL;
+			}
+		}
+
+		/* Map Classif Node counter selection to fragmentation stats */
+		cnt_sel_to_stats(&cnt_tbl_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
+		/* Change the retrieve routine */
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
+	} else
+		/* Map Classif Node counter selection to CcNode statistics */
+		cnt_sel_to_stats(&cnt_tbl_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+			(cnt_sel >> CLASSIF_STATS_SHIFT));
 
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = cnt_tbl_cb->keys_num *
@@ -1789,6 +1882,15 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *params,
 		}
 	}
 
+	if (cnt_cb->f_get_cnt_stats != get_cnt_cls_tbl_frag_stats)
+		return 0;
+
+	err = set_frag_manip(tbl_cb->td, &cnt_cb->tbl_cb.keys[member_index]);
+	if (err < 0) {
+		pr_err("Invalid Fragmentation manip handle\n");
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -2044,6 +2146,39 @@ static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct t_FmPcdManipStats stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	cnt_cb->tbl_cb.info.reset = req_cb->config.reset_cnts;
+
+	for (i = 0; i < cnt_cb->tbl_cb.keys_num; i++) {
+		if (!cnt_cb->tbl_cb.keys[i].valid) {
+			/* Write the memory location */
+			*(uint32_t *)(req_cb->request_area) = 0;
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE;
+
+			continue;
+		}
+
+		err = FM_PCD_ManipGetStatistics(
+				cnt_cb->tbl_cb.keys[i].frag, &stats);
+		if (err < 0) {
+			pr_err("Couldn't retrieve Fragmentation statistics\n");
+			return -EINTR;
+		}
+		get_cnt_32bit_stats(req_cb, &cnt_cb->tbl_cb.info,
+				&stats.u.frag.u.ipFrag, i);
+	}
+
+	return 0;
+}
+
 static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
 		struct dpa_stats_cnt_cb *cnt_cb)
 {
@@ -2295,67 +2430,74 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 	switch (params->type) {
 	case DPA_STATS_CNT_ETH:
+		cnt_cb->type = DPA_STATS_CNT_ETH;
+		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
+
 		err = set_cnt_eth_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create ETH counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_ETH;
-		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
 		break;
 	case DPA_STATS_CNT_REASS:
+		cnt_cb->type = DPA_STATS_CNT_REASS;
+		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
+
 		err = set_cnt_reass_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Reassembly counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_REASS;
-		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
 		break;
 	case DPA_STATS_CNT_FRAG:
+		cnt_cb->type = DPA_STATS_CNT_FRAG;
+		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
+
 		err = set_cnt_frag_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Fragmentation counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_FRAG;
-		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
 		break;
 	case DPA_STATS_CNT_POLICER:
+		cnt_cb->type = DPA_STATS_CNT_POLICER;
+		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
+
 		err = set_cnt_plcr_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Policer counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_POLICER;
-		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
 		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
+
 		err = set_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Classif Table counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
-		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
+
 		err = set_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Classif Cc Node counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
-		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 		break;
 	case DPA_STATS_CNT_IPSEC:
+		cnt_cb->type = DPA_STATS_CNT_IPSEC;
+		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
+
 		err = set_cnt_ipsec_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create IPSec counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_IPSEC;
-		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
 		break;
 	case DPA_STATS_CNT_TRAFFIC_MNG:
 		pr_err("Counter type not supported\n");
@@ -2433,67 +2575,75 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 	switch (params->type) {
 	case DPA_STATS_CNT_ETH:
+		cnt_cb->type = DPA_STATS_CNT_ETH;
+		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
+
 		err = set_cls_cnt_eth_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create ETH counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_ETH;
-		cnt_cb->f_get_cnt_stats = get_cnt_eth_stats;
 		break;
 	case DPA_STATS_CNT_REASS:
+		cnt_cb->type = DPA_STATS_CNT_REASS;
+		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
+
 		err = set_cls_cnt_reass_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Reassembly counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_REASS;
-		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
 		break;
 	case DPA_STATS_CNT_FRAG:
+		cnt_cb->type = DPA_STATS_CNT_FRAG;
+		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
+
 		err = set_cls_cnt_frag_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Fragmentation counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_FRAG;
-		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
 		break;
 	case DPA_STATS_CNT_POLICER:
+		cnt_cb->type = DPA_STATS_CNT_POLICER;
+		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
+
 		err = set_cls_cnt_plcr_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Policer counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_POLICER;
-		cnt_cb->f_get_cnt_stats = get_cnt_plcr_stats;
 		break;
 	case DPA_STATS_CNT_CLASSIF_TBL:
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
+		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
+
 		err = set_cls_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Classif Table counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
-		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
+
 		err = set_cls_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create Classif Cc Node counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
-		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 		break;
 	case DPA_STATS_CNT_IPSEC:
+		cnt_cb->type = DPA_STATS_CNT_IPSEC;
+		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
+
 		err = set_cls_cnt_ipsec_cb(cnt_cb, params);
 		if (err != 0) {
 			pr_err("Failed to create IPSec counter");
 			goto create_counter_err;
 		}
-		cnt_cb->type = DPA_STATS_CNT_IPSEC;
-		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
+
 		break;
 	case DPA_STATS_CNT_TRAFFIC_MNG:
 		pr_err("Counter type not supported\n");
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index 610ed43..0b90e11 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -107,8 +107,7 @@ struct dpa_stats_cnt_gen_cb {
 				       retrieve statistics */
 	unsigned int objs_num;  /* Number of objects for which to
 				   retrieve statistics */
-	struct stats_info info;
-				/* Counter's statistics information */
+	struct stats_info info; /* Counter's statistics information */
 };
 
 /* DPA Stats Classifier Table key descriptor */
@@ -116,6 +115,7 @@ struct dpa_stats_lookup_key {
 	void *cc_node;  /* Handle of Cc Node the lookup key belongs to */
 	struct dpa_offload_lookup_key key; /* Key descriptor */
 	bool valid; /* Lookup key is valid */
+	void *frag; /* Fragmentation handle corresponding to this key */
 };
 
 /* DPA Stats Classif Table control block */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 2baba1e..e1444e7 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -424,6 +424,16 @@ static int do_ioctl_stats_create_class_counter(void *args)
 			return -EBUSY;
 		}
 		break;
+	case DPA_STATS_CNT_FRAG:
+		ret = copy_class_members(cls_objs,
+				prm.cnt_params.class_members,
+				prm.cnt_params.frag_params.frag);
+		if (ret < 0) {
+			pr_err("Could not copy array of frag objects\n");
+			kfree(cls_objs);
+			return -EBUSY;
+		}
+		break;
 	case DPA_STATS_CNT_POLICER:
 		ret = copy_class_members(cls_objs,
 				prm.cnt_params.class_members,
@@ -521,6 +531,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		kfree(eth_src);
 		break;
 	case DPA_STATS_CNT_REASS:
+	case DPA_STATS_CNT_FRAG:
 	case DPA_STATS_CNT_POLICER:
 		kfree(cls_objs);
 		break;
-- 
1.7.5.4

