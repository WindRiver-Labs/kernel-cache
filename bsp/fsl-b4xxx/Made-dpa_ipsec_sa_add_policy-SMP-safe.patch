From 1165dff8409b035fdd7a6afe5cfd9033fb05e9d4 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:53:38 +0000
Subject: [PATCH 173/518] Made dpa_ipsec_sa_add_policy SMP safe

added proper locking
if SA is outbound parent it is illegal to set outbound policy
if SA is inbound child it is illegal to set inbound policy

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   39 ++++++++++++++++++++------
 1 files changed, 30 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 9e932c2..b57466b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -3345,7 +3345,7 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 {
 	struct dpa_ipsec_policy_entry *policy_entry;
 	struct dpa_ipsec_sa *sa;
-	int err;
+	int ret;
 
 	if (!policy_params) {
 		xx_pr_err("Invalid policy params handle\n");
@@ -3358,35 +3358,56 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		return -EINVAL;
 	}
 
+	ret = mutex_trylock(&sa->lock);
+	if (ret == 0) {
+		xx_pr_err("Failed to acquire lock for SA %d\n", sa->id);
+		return -EBUSY;
+	}
+
+	if (sa_is_parent(sa) && sa->sa_dir == DPA_IPSEC_OUTBOUND) {
+		xx_pr_err("Illegal to set out policy - parent SA %d\n", sa->id);
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+
+	if (sa_is_child(sa) && sa->sa_dir == DPA_IPSEC_INBOUND) {
+		xx_pr_err("Illegal to set in policy on child SA %d\n", sa->id);
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+
 	/* AV's note: one SA could have more in/out policies
 	 * Store all the in/out policies into the SA policy param list in order
 	 * to know what to remove when SA expires.
 	 */
-	err = store_policy_param_to_sa_pol_list(sa, policy_params,
+	ret = store_policy_param_to_sa_pol_list(sa, policy_params,
 						&policy_entry);
-	if (err < 0) {
+	if (ret < 0) {
 		xx_pr_err("Could not store the policy in the SA\n");
-		return err;
+		mutex_unlock(&sa->lock);
+		return ret;
 	}
 
 	/*Insert inbound or outbound policy for this SA depending on it's type*/
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
-		err = update_inbound_policy(sa, policy_entry, MNG_OP_ADD);
-		if (err < 0) {
+		ret = update_inbound_policy(sa, policy_entry, MNG_OP_ADD);
+		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			xx_pr_err("Could not add the inbound policy\n");
 			xx_free(policy_entry);
 		}
 	} else {  /* DPA_IPSEC_OUTBOUND */
-		err = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
-		if (err < 0) {
+		ret = update_outbound_policy(sa, policy_entry, MNG_OP_ADD);
+		if (ret < 0) {
 			remove_policy_from_sa_policy_list(sa, policy_entry);
 			xx_pr_err("Could not add the outbound policy\n");
 			xx_free(policy_entry);
 		}
 	}
 
-	return err;
+	mutex_unlock(&sa->lock);
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_add_policy);
 
-- 
1.7.5.4

