From 5b3be13c6c6d73c08cd40758dc396679c8fb6da5 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Wed, 13 Mar 2013 19:21:47 +0000
Subject: [PATCH 511/518] dpa_ipsec: memcmp not suited for finding policy,
 field by field checking required

Because of the aditional padding on a dpa_ipsec_policy_params
structure the memcmp function was not suited for matching
policies. Would have required from user a memset to 0 on it prior
to populating it with values and passing it to add_policy & remove_policy.
Since this kind of enforcement can not be done and should not be done,
I replaced the memcmp with field by field checking.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   98 ++++++++++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   12 +---
 2 files changed, 83 insertions(+), 27 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index f9926c1..a8c80ca 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2598,6 +2598,13 @@ static int check_policy_params(struct dpa_ipsec_sa *sa,
 		return -EINVAL;
 	}
 
+	/* check if IP address version is valid */
+	if (pol_params->src_addr.version != DPA_IPSEC_ADDR_T_IPv4 &&
+	    pol_params->src_addr.version != DPA_IPSEC_ADDR_T_IPv6) {
+		pr_err("Src and dest IP address types either 4 or 6!\n");
+		return -EINVAL;
+	}
+
 	/* check if fragmentation is enabled for inbound SAs */
 	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_MANIP &&
 	    sa->sa_dir == DPA_IPSEC_INBOUND) {
@@ -2662,30 +2669,88 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 	return 0;
 }
 
-static int find_policy_in_sa_policy_list(struct dpa_ipsec_sa  *sa,
-				struct dpa_ipsec_policy_params *policy_params,
-				struct dpa_ipsec_policy_entry **policy_entry)
+static inline int addr_match(struct dpa_offload_ip_address *addr1,
+			     struct dpa_offload_ip_address *addr2)
 {
-	struct dpa_ipsec_policy_entry *pol_entry, *tmp_policy_entry;
+	if (addr1->version != addr2->version)
+		return false;
+
+	switch (addr1->version) {
+	case DPA_IPSEC_ADDR_T_IPv4:
+		if (addr1->addr.ipv4.word != addr2->addr.ipv4.word)
+			return false;
+		break;
+	case DPA_IPSEC_ADDR_T_IPv6:
+		if (memcmp(&addr1->addr.ipv6.byte, &addr2->addr.ipv6.byte,
+			   DPA_OFFLD_IPv6_ADDR_LEN_BYTES))
+			return false;
+		break;
+	default:
+		/*
+		 * IP's version was checked for validity when policy was
+		 * off-loaded so it can be invalid only if DPA IPsec component
+		 * messed it up.
+		 */
+		pr_err("Invalid IP version\n");
+		BUG();
+	}
+
+	return true;
+}
+
+
+static int find_policy(struct dpa_ipsec_sa *sa,
+		       struct dpa_ipsec_policy_params *pol,
+		       struct dpa_ipsec_policy_entry **policy_entry)
+{
+	struct dpa_ipsec_policy_entry *pol_entry, *tmp;
 
 	BUG_ON(!sa);
-	BUG_ON(!policy_params);
+	BUG_ON(!pol);
 	BUG_ON(!policy_entry);
 
 	if (list_empty(&sa->policy_headlist)) {
-		pr_err("Policy parameter list is empty\n");
+		pr_err("Policy list is empty\n");
 		return -EDOM;
 	}
 
-	list_for_each_entry_safe(pol_entry, tmp_policy_entry,
-				 &sa->policy_headlist, node) {
-		if (!memcmp(&pol_entry->pol_params, policy_params,
-			    POL_MATCH_SIZE(policy_params)) &&
-		    pol_entry->pol_params.priority == policy_params->priority) {
-			/* found entry matching the input policy parameters */
-			*policy_entry = pol_entry;
-			return 0;
+	list_for_each_entry_safe(pol_entry, tmp, &sa->policy_headlist, node) {
+		struct dpa_ipsec_policy_params *cpol;
+		uint8_t cproto;
+
+		cpol = &pol_entry->pol_params;
+		cproto = cpol->protocol;
+
+		if (cpol->dest_prefix_len != pol->dest_prefix_len ||
+		    cpol->src_prefix_len != pol->src_prefix_len ||
+		    !addr_match(&cpol->dest_addr, &pol->dest_addr) ||
+		    !addr_match(&cpol->src_addr, &pol->src_addr) ||
+		    cpol->protocol != pol->protocol ||
+		    cpol->masked_proto != pol->masked_proto ||
+		    cpol->priority != pol->priority)
+			continue;
+
+		if (cproto == IPPROTO_UDP || cproto == IPPROTO_TCP ||
+		    cproto == IPPROTO_SCTP)
+			if (cpol->l4.dest_port != pol->l4.dest_port ||
+			    cpol->l4.dest_port_mask != pol->l4.dest_port_mask ||
+			    cpol->l4.src_port != pol->l4.src_port ||
+			    cpol->l4.src_port_mask != pol->l4.src_port_mask)
+				continue;
+
+		if (cproto == IPPROTO_ICMP || cproto == IPPROTO_ICMPV6) {
+			struct dpa_ipsec_icmp_params *c;
+			c = &cpol->icmp;
+			if (c->icmp_code != pol->icmp.icmp_code ||
+			    c->icmp_code_mask != pol->icmp.icmp_code_mask ||
+			    c->icmp_type != pol->icmp.icmp_type ||
+			    c->icmp_type_mask != pol->icmp.icmp_type_mask)
+				continue;
 		}
+
+		/* found entry matching the input policy parameters */
+		*policy_entry = pol_entry;
+		return 0;
 	}
 
 	/* did not find the entry that matches the input policy parameters */
@@ -2702,6 +2767,7 @@ static inline int get_policy_count_for_sa(struct dpa_ipsec_sa *sa)
 		return 0;
 	}
 
+
 	list_for_each_entry_safe(policy_entry, tmp_policy_entry,
 				 &sa->policy_headlist, node)
 		pol_count++;
@@ -3827,7 +3893,7 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 		return -EPERM;
 	}
 
-	ret = find_policy_in_sa_policy_list(sa, policy_params, &policy_entry);
+	ret = find_policy(sa, policy_params, &policy_entry);
 	if (ret < 0) {
 		pr_err("Could not find policy entry in SA policy list\n");
 		mutex_unlock(&sa->lock);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 7e79654..39d27f1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -129,7 +129,7 @@
 	((_proto == IPPROTO_TCP)  ? DPA_IPSEC_PROTO_TCP_##_ip_ver :	\
 	 (_proto == IPPROTO_UDP)  ? DPA_IPSEC_PROTO_UDP_##_ip_ver :	\
 	((_proto == IPPROTO_ICMP) ||					\
-	 (_proto == IPPROTO_ICMPV6)) ? DPA_IPSEC_PROTO_ICMP_##_ip_ver:	\
+	 (_proto == IPPROTO_ICMPV6)) ? DPA_IPSEC_PROTO_ICMP_##_ip_ver :	\
 	 (_proto == IPPROTO_SCTP) ? DPA_IPSEC_PROTO_SCTP_##_ip_ver :	\
 	  DPA_IPSEC_PROTO_ANY_##_ip_ver)
 
@@ -187,16 +187,6 @@
 #define SEC_DEF_VER 40 /* like in P4080 */
 #define SEC_VER_5_3 53
 
-/*
- * calculate the size of the fields in the policy params structure that
- * are used to identify a policy
- */
-#define POL_MATCH_SIZE(pol_params) \
-	(sizeof(pol_params->src_addr) + sizeof(pol_params->src_prefix_len) + \
-	 sizeof(pol_params->dest_addr) + sizeof(pol_params->dest_prefix_len) + \
-	 sizeof(pol_params->protocol) + sizeof(pol_params->masked_proto) + \
-	 sizeof(pol_params->l4))
-
 /* DPA IPSec Encryption & authentication algorithm identifiers */
 struct ipsec_alg_suite {
 	uint16_t	enc_alg;
-- 
1.7.5.4

