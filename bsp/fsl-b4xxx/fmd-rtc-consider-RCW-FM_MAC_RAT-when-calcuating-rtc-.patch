From 28f7535e5dfe285bf23361893f09910c030adbed Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Wed, 15 Apr 2015 22:06:07 +0900
Subject: [PATCH 2/2] fmd: rtc: consider RCW[FM_MAC_RAT] when calcuating rtc
 ref clock

Change-Id: I1b8a2966ad45f995e7e6b3cdca7f8ed5e0dd397a
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/35026
Reviewed-by: Igal Liberman <Igal.Liberman@freescale.com>
Reviewed-by: Yangbo Lu <yangbo.lu@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
Tested-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Original patch taken from QorIQ-SDK-V1.8-20150619-yocto]
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../freescale/fman/Peripherals/FM/Rtc/fm_rtc.c     |    4 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |   10 +++++
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |    1 +
 .../freescale/fman/Peripherals/FM/fm_ipc.h         |    1 +
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |   13 ++++++
 .../freescale/fman/inc/Peripherals/fm_ext.h        |    3 +
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         |   41 ++++++++++++++++++++
 7 files changed, 71 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
index 5ea7a16..b0bcf26 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
@@ -209,9 +209,9 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
 
     /* find source clock frequency in Mhz */
     if (p_Rtc->p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_SYSTEM)
-         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->ext_src_clk_freq;
+        p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->ext_src_clk_freq;
     else
-        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetClockFreq(p_Rtc->h_Fm)/2);
+        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetMacClockFreq(p_Rtc->h_Fm));
 
     /* if timer in Master mode Initialize TMR_CTRL */
     /* We want the counter (TMR_CNT) to count in nano-seconds */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 4ab4bad..08951bd 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -1064,6 +1064,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 
             /* Get clock frequency */
             ipcParams.fmClkFreq = p_Fm->p_FmStateStruct->fmClkFreq;
+            ipcParams.fmMacClkFreq = p_Fm->p_FmStateStruct->fmMacClkFreq;
 
             fman_get_revision(p_Fm->p_FmFpmRegs,&ipcParams.majorRev,&ipcParams.minorRev);
 
@@ -2498,6 +2499,13 @@ uint16_t FmGetClockFreq(t_Handle h_Fm)
     return p_Fm->p_FmStateStruct->fmClkFreq;
 }
 
+uint16_t FmGetMacClockFreq(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->p_FmStateStruct->fmMacClkFreq;
+}
+
 uint32_t FmGetTimeStampScale(t_Handle h_Fm)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
@@ -3119,6 +3127,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
         memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
 
         p_Fm->p_FmStateStruct->fmClkFreq = ipcParams.fmClkFreq;
+        p_Fm->p_FmStateStruct->fmMacClkFreq = ipcParams.fmMacClkFreq;
         p_Fm->p_FmStateStruct->revInfo.majorRev = ipcParams.majorRev;
         p_Fm->p_FmStateStruct->revInfo.minorRev = ipcParams.minorRev;
     }
@@ -3355,6 +3364,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->h_FmMuram                             = p_FmParam->h_FmMuram;
     p_Fm->h_App                                 = p_FmParam->h_App;
     p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
+    p_Fm->p_FmStateStruct->fmMacClkFreq         = p_FmParam->fmClkFreq / ((!p_FmParam->fmMacClkRatio)? 2: p_FmParam->fmMacClkRatio);
     p_Fm->f_Exception                           = p_FmParam->f_Exception;
     p_Fm->f_BusError                            = p_FmParam->f_BusError;
     p_Fm->p_FmFpmRegs = (struct fman_fpm_regs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index b7b42b5..a49ab0a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -539,6 +539,7 @@ typedef struct
     uint8_t                     fmId;
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
     uint16_t                    fmClkFreq;
+    uint16_t                    fmMacClkFreq;
     t_FmRevisionInfo            revInfo;
 /**************************/
 /* Master Only parameters */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
index f39d5d9..7ce36a7 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
@@ -192,6 +192,7 @@ typedef _Packed struct t_FmIpcIsr
 *//***************************************************************************/
 typedef _Packed struct t_FmIpcParams {
     uint16_t        fmClkFreq;              /**< OUT: FM Clock frequency */
+    uint16_t        fmMacClkFreq;           /**< OUT: FM MAC clock frequence */
     uint8_t         majorRev;               /**< OUT: FM Major revision */
     uint8_t         minorRev;               /**< OUT: FM Minor revision */
 } _PackedType t_FmIpcParams;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index 67728f1..391496b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -1017,6 +1017,19 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
 uint16_t FmGetClockFreq(t_Handle h_Fm);
 
 /**************************************************************************//**
+ @Function      FmGetMacClockFreq
+
+ @Description   Used by MAC driver to get the MAC clock frequency
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        clock-freq on success; 0 otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint16_t FmGetMacClockFreq(t_Handle h_Fm);
+
+/**************************************************************************//**
  @Function      FmGetId
 
  @Description   Used by PCD driver to read rhe FM id
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
index a1a96ae..00951b1 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
@@ -483,6 +483,9 @@ typedef struct t_FmParams {
                                                          to be used by the FM. */
     uint16_t                fmClkFreq;              /**< In Mhz;
                                                          Relevant when FM not runs in "guest-mode". */
+    uint16_t                fmMacClkRatio;          /**< FM MAC Clock ratio, for backward comparability:
+                                                                     when fmMacClkRatio = 0, ratio is 2:1
+                                                                     when fmMacClkRatio = 1, ratio is 1:1  */
     t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to handle exceptions;
                                                          Relevant when FM not runs in "guest-mode". */
     t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to handle exceptions;
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index 2d1e10b..6cdc4b4 100755
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -61,6 +61,7 @@
 #include <linux/fsl/qe.h>        /* For struct qe_firmware */
 #include <sysdev/fsl_soc.h>
 #include <asm/fsl_pm.h>
+#include <asm/fsl_guts.h>
 #include <linux/stat.h>	   /* For file access mask */
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
@@ -889,6 +890,39 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     return FillRestFmInfo(p_LnxWrpFmDev);
 }
 
+/*
+ * Table for matching compatible strings, for device tree
+ * guts node, for QorIQ SOCs.
+ * "fsl,qoriq-device-config-2.0" corresponds to T4 & B4
+ * SOCs. For the older SOCs "fsl,qoriq-device-config-1.0"
+ * string would be used.
+*/
+static const struct of_device_id guts_device_ids[] = {
+        { .compatible = "fsl,qoriq-device-config-1.0", },
+        { .compatible = "fsl,qoriq-device-config-2.0", },
+        {}
+};
+
+static unsigned int get_rcwsr(int regnum)
+{
+	struct ccsr_guts __iomem *guts_regs = NULL;
+	struct device_node *guts_node;
+
+	guts_node = of_find_matching_node(NULL, guts_device_ids);
+	if (!guts_node) {
+		pr_err("could not find GUTS node\n");
+		return 0;
+	}
+	guts_regs = of_iomap(guts_node, 0);
+	of_node_put(guts_node);
+	if (!guts_regs) {
+		pr_err("ioremap of GUTS node failed\n");
+		return 0;
+	}
+
+	return ioread32be(&guts_regs->rcwsr[regnum]);
+}
+
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
     const struct qe_firmware *fw;
@@ -927,6 +961,13 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     }
 #endif
 
+    if(p_LnxWrpFmDev->fmDevSettings.param.fmId == 0)
+        p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio =
+            !!(get_rcwsr(4) & 0x2); /* RCW[FM_MAC_RAT0] */
+    else
+        p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio =
+            !!(get_rcwsr(4) & 0x1); /* RCW[FM_MAC_RAT1] */
+
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
 
-- 
1.7.5.4

