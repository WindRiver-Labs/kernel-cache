From 8085fe0980115d43f92bbd0d67dc2182934b698f Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:08 +0000
Subject: [PATCH 230/518] Reserve a range of flow ID values for use outside of
 a DPA IPSec instance

Allow the upper layer to specify a range of of flow ID values, from
0 to base_flow_id, that should not be used by the DPA IPSec instance
for inbound post decryption SA lookup. Instead the DPA IPSec instance
will use flow ID values in the range base_flow_id to max_sa_pairs.

This change is important because the number of possible flow ID
values is limited and it is easier for the upper layer to manage
these values by reserving a predefined range for other applications
and leaving the rest to be managed internally by the DPA IPSec
instance.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   18 ++++++++++++++++--
 include/linux/fsl_dpa_ipsec.h               |    2 ++
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 28e0ec8..30c9ad1 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -278,7 +278,7 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
-	/* verify that it is an indexed table */
+	/* get post decryption table parameters */
 	err = dpa_classif_table_get_params(prms->post_sec_in_params.dpa_cls_td,
 					   &table_params);
 	if (err < 0) {
@@ -286,11 +286,22 @@ static int check_ipsec_params(const struct dpa_ipsec_params *prms)
 		return -EINVAL;
 	}
 
+	/* verify that it is an indexed table */
 	if (table_params.type != DPA_CLS_TBL_INDEXED) {
 		pr_err("Post decryption table must be of type INDEXED\n");
 		return -EINVAL;
 	}
 
+	/*
+	 * verify that it can hold a flow ID value for each possible IN SA plus
+	 * the reserved number of flow ID values (base_flow_id)
+	 */
+	if (table_params.indexed_params.entries_cnt <
+	    (prms->max_sa_pairs + prms->post_sec_in_params.base_flow_id)) {
+		pr_err("The post decryption table size is to small!\n");
+		return -EINVAL;
+	}
+
 	/* check pre decryption SA lookup tables */
 	valid_tables = 0;
 	pre_sec_in_prms = &prms->pre_sec_in_params;
@@ -511,6 +522,7 @@ static int put_inbound_flowid(struct dpa_ipsec *dpa_ipsec, uint16_t flowid)
 static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 {
 	void *cq;
+	uint16_t base_flow_id;
 	int i, err;
 
 	BUG_ON(!dpa_ipsec);
@@ -524,7 +536,9 @@ static int create_inbound_flowid_cq(struct dpa_ipsec *dpa_ipsec)
 	dpa_ipsec->sa_mng.inbound_flowid_cq = cq;
 
 	/* Populate the created CQ with flow ids */
-	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa / 2; i++) {
+	base_flow_id = dpa_ipsec->config.post_sec_in_params.base_flow_id;
+	for (i = base_flow_id;
+	     i < dpa_ipsec->sa_mng.max_num_sa / 2 + base_flow_id; i++) {
 		err = put_inbound_flowid(dpa_ipsec, (uint16_t) i);
 		if (err < 0) {
 			pr_err("Couldn't fill flow id management queue\n");
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 66ad985..3cd9fe1 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -163,6 +163,8 @@ struct dpa_ipsec_post_sec_in_params {
 	int use_ipv6_pol;    /* Activate support for IPv6 policies. Allows
 			      * better MURAM management. Relevant only if
 			      * do_pol_check = TRUE			      */
+	uint16_t base_flow_id; /* The start value of the range of flow ID values
+				* used by this instance in post decryption    */
 };
 
 /* DPA-IPSec Post-Sec-Inbound Parameters */
-- 
1.7.5.4

