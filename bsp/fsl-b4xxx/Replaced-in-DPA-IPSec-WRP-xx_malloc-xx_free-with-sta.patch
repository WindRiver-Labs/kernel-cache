From cea65b9dfc96396712a23b5f149a17a3c9c742e1 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 29 Jun 2012 16:16:23 +0000
Subject: [PATCH 218/518] Replaced in DPA IPSec WRP xx_malloc/xx_free with
 standard Linux functions

no more xx_ macros in the DPA IPSec Wrapper code.
replaced them with kmalloc/kzalloc/kfree

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c |   49 +++++++++++------------
 1 files changed, 24 insertions(+), 25 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 855b730..a3bf493 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -290,22 +290,22 @@ static void free_sa_params(struct dpa_ipsec_sa_params *prm)
 
 		sa_out_prm = &prm->sa_out_params;
 		if (sa_out_prm->init_vector) {
-			xx_free(sa_out_prm->init_vector->init_vector);
-			xx_free(sa_out_prm->init_vector);
+			kfree(sa_out_prm->init_vector->init_vector);
+			kfree(sa_out_prm->init_vector);
 		}
-		xx_free(sa_out_prm->outer_ip_header);
-		xx_free(sa_out_prm->outer_udp_header);
+		kfree(sa_out_prm->outer_ip_header);
+		kfree(sa_out_prm->outer_udp_header);
 	} else {
 		struct dpa_cls_tbl_action *sa_in_act;
 
 		sa_in_act = &prm->sa_in_params.post_ipsec_action;
 		if (sa_in_act->type == DPA_CLS_TBL_ACTION_ENQ)
-			xx_free(sa_in_act->enq_params.policer_params);
+			kfree(sa_in_act->enq_params.policer_params);
 	}
 
 	crypto_params = &prm->crypto_params;
-	xx_free(crypto_params->auth_key);
-	xx_free(crypto_params->cipher_key);
+	kfree(crypto_params->auth_key);
+	kfree(crypto_params->cipher_key);
 }
 
 /* handle any required memory transfers (US to K) when creating/rekeying a SA */
@@ -329,7 +329,8 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
 		sa_out_prm = &prm->sa_out_params;
 		if (sa_out_prm->outer_ip_header) {
-			out_ip_hdr = xx_malloc(sa_out_prm->ip_hdr_size);
+			out_ip_hdr = kmalloc(sa_out_prm->ip_hdr_size,
+					     GFP_KERNEL);
 			if (!out_ip_hdr) {
 				pr_err("Error - alloc SA out hdr");
 				return -ENOMEM;
@@ -344,7 +345,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 			sa_out_prm->outer_ip_header = out_ip_hdr;
 		}
 		if (sa_out_prm->outer_udp_header) {
-			out_udp_hdr = xx_malloc(UDP_HDR_SIZE);
+			out_udp_hdr = kmalloc(UDP_HDR_SIZE, GFP_KERNEL);
 			if (!out_udp_hdr) {
 				pr_err("Error - alloc SA out udp hdr");
 				err = -ENOMEM;
@@ -360,8 +361,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 			sa_out_prm->outer_udp_header = out_udp_hdr;
 		}
 		if (sa_out_prm->init_vector) {
-			sa_out_iv = (struct dpa_ipsec_init_vector *)
-						xx_malloc(sizeof(*sa_out_iv));
+			sa_out_iv = kmalloc(sizeof(*sa_out_iv), GFP_KERNEL);
 			if (!sa_out_iv) {
 				pr_err("Error - alloc SA out IV struct");
 				err = -ENOMEM;
@@ -391,7 +391,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 			if (!sa_out_iv->init_vector)
 				goto copy_crypto_keys;
 
-			iv_array = (uint8_t *)xx_malloc(sa_out_iv->length);
+			iv_array = kmalloc(sa_out_iv->length, GFP_KERNEL);
 			if (!iv_array) {
 				pr_err("Error - alloc SA out IV array");
 				err = -ENOMEM;
@@ -412,7 +412,7 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		cls_action = &prm->sa_in_params.post_ipsec_action;
 		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
 		    cls_action->enq_params.policer_params != NULL) {
-			policer_prm = xx_malloc(sizeof(*policer_prm));
+			policer_prm = kmalloc(sizeof(*policer_prm), GFP_KERNEL);
 			if (!policer_prm) {
 				pr_err("Error alloc CLS POL param");
 				return -ENOMEM;
@@ -435,7 +435,7 @@ copy_crypto_keys:
 	 */
 	crypto_params = &prm->crypto_params;
 	if (crypto_params->auth_key) {
-		auth_key = (uint8_t *)xx_malloc(crypto_params->auth_key_len);
+		auth_key = kmalloc(crypto_params->auth_key_len, GFP_KERNEL);
 		if (!auth_key) {
 			pr_err("Couldn't allocate memory for SA auth key");
 			err = -ENOMEM;
@@ -451,8 +451,7 @@ copy_crypto_keys:
 	}
 
 	if (crypto_params->cipher_key) {
-		cipher_key =
-			(uint8_t *)xx_malloc(crypto_params->cipher_key_len);
+		cipher_key = kmalloc(crypto_params->cipher_key_len, GFP_KERNEL);
 		if (!cipher_key) {
 			pr_err("Couldn't allocate memory for SA cipher key");
 			err = -ENOMEM;
@@ -470,17 +469,17 @@ copy_crypto_keys:
 	return 0;
 
 free_create_sa_keys_mem:
-	xx_free(auth_key);
-	xx_free(cipher_key);
+	kfree(auth_key);
+	kfree(cipher_key);
 
 free_create_copied_sa_mem:
 	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
-		xx_free(iv_array);
-		xx_free(sa_out_iv);
-		xx_free(out_ip_hdr);
-		xx_free(out_udp_hdr);
+		kfree(iv_array);
+		kfree(sa_out_iv);
+		kfree(out_ip_hdr);
+		kfree(out_udp_hdr);
 	} else
-		xx_free(policer_prm);
+		kfree(policer_prm);
 
 	return err;
 }
@@ -726,7 +725,7 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 		return -EINVAL;
 	}
 
-	policy_params =	xx_zalloc(num_pol * sizeof(*policy_params));
+	policy_params =	kzalloc(num_pol * sizeof(*policy_params), GFP_KERNEL);
 	if (!policy_params) {
 		pr_err("Could not allocate memory for policy array");
 		return -ENOMEM;
@@ -751,7 +750,7 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 	 */
 
 err_pol_cleanup:
-	xx_free(policy_params);
+	kfree(policy_params);
 
 	return err;
 }
-- 
1.7.5.4

