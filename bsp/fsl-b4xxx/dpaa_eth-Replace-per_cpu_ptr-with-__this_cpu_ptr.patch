From d0634de07f478658182658a87fbe8d751bbb2538 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 27 Feb 2013 02:37:29 +0200
Subject: [PATCH 499/518] dpaa_eth: Replace per_cpu_ptr with __this_cpu_ptr

In many contexts, per_cpu_ptr() was used with smp_processor_id(), which
made it a good candidate for replacement with this_cpu_ptr(). Of those,
some more contexts were non-migratable, further making them candidates
for replacement with __this_cpu_ptr().

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    |   11 +++++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   11 +++++++----
 2 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index c1b15a1..0840635 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -2158,7 +2158,8 @@ ingress_rx_default_dqrr(struct qman_portal		*portal,
 	net_dev = ((struct dpa_fq *)fq)->net_dev;
 	priv = netdev_priv(net_dev);
 
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	/* IRQ handler, non-migratable; safe to use __this_cpu_ptr here */
+	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
 	if (unlikely(dpaa_eth_napi_schedule(percpu_priv))) {
 		percpu_priv->in_interrupt++;
@@ -2208,7 +2209,8 @@ ingress_tx_default_dqrr(struct qman_portal		*portal,
 	net_dev = ((struct dpa_fq *)fq)->net_dev;
 	priv = netdev_priv(net_dev);
 
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	/* Non-migratable context, safe to use __this_cpu_ptr */
+	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
 	if (dpaa_eth_napi_schedule(percpu_priv)) {
 		percpu_priv->in_interrupt++;
@@ -2332,7 +2334,7 @@ static void shared_ern(struct qman_portal	*portal,
 
 	net_dev = dpa_fq->net_dev;
 	priv = netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	percpu_priv = per_cpu_ptr(priv->percpu_priv,  smp_processor_id());
 
 	dpa_fd_release(net_dev, &msg->ern.fd);
 
@@ -2353,7 +2355,8 @@ static void egress_ern(struct qman_portal	*portal,
 
 	net_dev = ((struct dpa_fq *)fq)->net_dev;
 	priv = netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	/* Non-migratable context, safe to use __this_cpu_ptr */
+	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
 	percpu_priv->stats.tx_dropped++;
 	percpu_priv->stats.tx_fifo_errors++;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index bba9c64..9f189db 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -50,7 +50,7 @@ static inline void dpa_bp_removed_one_page(struct dpa_bp *dpa_bp,
 {
 	int *count_ptr;
 
-	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	(*count_ptr)--;
 
 	dma_unmap_single(dpa_bp->dev, dma_addr, dpa_bp->size,
@@ -65,7 +65,7 @@ static void dpa_bp_add_page(struct dpa_bp *dpa_bp, unsigned long vaddr)
 	dma_addr_t addr;
 	int offset;
 
-	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 
 	/* Make sure we don't map beyond end of page */
 	offset = vaddr & (PAGE_SIZE - 1);
@@ -700,11 +700,14 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct dpa_priv_s	*priv;
 	struct qm_fd		 fd;
 	struct dpa_percpu_priv_s *percpu_priv;
+	struct net_device_stats *percpu_stats;
 	int queue_mapping;
 	int err;
 
 	priv = netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	/* Non-migratable context, safe to use __this_cpu_ptr */
+	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_stats = &percpu_priv->stats;
 
 	clear_fd(&fd);
 
@@ -718,7 +721,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	if (skb_is_nonlinear(skb)) {
 		/* Just create a S/G fd based on the skb */
-		err = skb_to_sg_fd(priv, percpu_priv, skb, &fd);
+		err = skb_to_sg_fd(priv, NULL, skb, &fd);
 		percpu_priv->tx_frag_skbuffs++;
 	} else {
 		/*
-- 
1.7.5.4

