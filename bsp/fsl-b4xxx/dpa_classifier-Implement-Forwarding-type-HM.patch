From 951a177048ea20f8f59034b1785cdb3b46420a98 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 29 Oct 2012 21:36:35 +0000
Subject: [PATCH 348/518] dpa_classifier: Implement Forwarding type HM

Added implementation for forwarding type header manipulation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  177 ++++++++++++++--------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   12 +--
 2 files changed, 118 insertions(+), 71 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 0b86a0e..19906a8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3074,6 +3074,13 @@ static int fwd_hm_check_params(const struct dpa_cls_hm_fwd_params *fwd_params)
 		return -ENOSYS;
 	}
 
+	if (fwd_params->ip_frag_params.mtu != 0) {
+		pr_err("ERROR: %s, %s (%d): Forwarding HM: IP fragmentation "
+			"is not supported yet.\n", __FILE__, __func__,
+			__LINE__);
+		return -ENOSYS;
+	}
+
 	return 0;
 }
 
@@ -4042,10 +4049,6 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	pr_err("ERROR: %s, %s (%d): Forwarding header manipulation is not "
-		"supported yet.\n", __FILE__, __func__, __LINE__);
-	return -ENOSYS;
-
 	err = fwd_hm_check_params(fwd_params);
 	if (err < 0) {
 		pr_err("ERROR: %s, %s (%d): Invalid forwarding HM parameters.\n",
@@ -4068,90 +4071,123 @@ int dpa_classif_set_fwd_hm(const struct dpa_cls_hm_fwd_params	*fwd_params,
 	/* Copy the NAT parameters locally */
 	memcpy(&pfwd_hm->fwd_params, fwd_params, sizeof(*fwd_params));
 
-	if (res)
-		/* Need to import */
-		err = import_fwd_hm(pfwd_hm, res);
-	else {
-		/* Need to create */
-		err = init_fwd_hm(pfwd_hm);
-		if (err) {
-			dpa_classif_free_hm(*hmd);
-			*hmd = DPA_OFFLD_DESC_NONE;
-			return err;
-		}
+	err = fwd_hm_prepare_nodes(pfwd_hm, res);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to acquire necessary HM "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		goto fwd_hm_error;
+	}
 
-		if (chain_head) {
-			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pfwd_hm->fwd_params.fm_pcd,
-				pfwd_hm->hm_chain, pfwd_hm->hm_chain);
-			if (err < 0)
-				pr_err("ERROR: %s, %s (%d): Failed to "
-					"initialize low level HM chain.\n",
-					__FILE__, __func__, __LINE__);
-		}
+	err = fwd_hm_update_params(pfwd_hm);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to update low level header "
+			"manipulation parameters.\n", __FILE__, __func__,
+			__LINE__);
+		goto fwd_hm_error;
 	}
 
-	if (err) {
-		dpa_classif_free_hm(*hmd);
-		*hmd = DPA_OFFLD_DESC_NONE;
+	if (chain_head) {
+		err = init_hm_chain(pfwd_hm->fwd_params.fm_pcd,
+				pfwd_hm->hm_chain,
+				pfwd_hm->hm_chain);
+		if (err < 0)
+			pr_err("ERROR: %s, %s (%d): Failed to initialize low "
+				"level HM chain.\n", __FILE__, __func__,
+				__LINE__);
 	}
 
 	return err;
+
+fwd_hm_error:
+
+	remove_hm_op(*hmd);
+
+	*hmd = DPA_OFFLD_DESC_NONE;
+
+	return err;
 }
 EXPORT_SYMBOL(dpa_classif_set_fwd_hm);
 
-static int import_fwd_hm(struct dpa_cls_hm *pfwd_hm,
+static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 				const struct dpa_cls_hm_fwd_resources *res)
 {
+	struct dpa_cls_hm_node *hm_node;
 	void * const *phm_nodes;
-	int err;
 
 	BUG_ON(!pfwd_hm);
-	BUG_ON(!res);
 
-	phm_nodes = &res->fwd_node;
+	pfwd_hm->num_nodes = 3;
 
-	err = import_hm_nodes_to_chain(phm_nodes, 3, pfwd_hm);
+	if (res) { /* Import HM nodes */
+		phm_nodes = &res->fwd_node;
 
-	/* Update here the hm nodes parameters */
+		return import_hm_nodes_to_chain(phm_nodes,
+					pfwd_hm->num_nodes,
+					pfwd_hm);
+	}
 
-	return err;
+	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+	if (!hm_node) {
+		pr_err("ERROR: %s, %s (%d): Not enough memory for header manip "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&hm_node->list_node);
+	pfwd_hm->hm_node[0]	= hm_node;
+
+	if (pfwd_hm->update_params.ip_frag_params.mtu) {
+		/* IP fragmentation option is enabled */
+		/* Create a header manip node: */
+		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+		if (!hm_node) {
+			pr_err("ERROR: %s, %s (%d): No more memory for header "
+				"manip nodes.\n", __FILE__, __func__, __LINE__);
+			return -ENOMEM;
+		}
+
+		INIT_LIST_HEAD(&hm_node->list_node);
+		pfwd_hm->hm_node[1] = hm_node;
+	}
+
+	add_local_hm_nodes_to_chain(pfwd_hm);
+
+	return 0;
 }
 
-static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
+static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 {
-	struct dpa_cls_hm_node *hm_node = NULL;
+	struct dpa_cls_hm_node *hm_node;
 	uint8_t size;
 	uint8_t *pdata;
 
 	BUG_ON(!pfwd_hm);
 
-	/* Create a forwarding node: */
-	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-	if (!hm_node) {
-		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
-			"nodes.\n", __FILE__, __func__, __LINE__);
-		return -ENOMEM;
+	if ((pfwd_hm->num_nodes < 1) || (!pfwd_hm->hm_node[0])) {
+		pr_err("ERROR: %s, %s (%d): Inconsistency between resources "
+			"and provided parameters.\n", __FILE__, __func__,
+			__LINE__);
+		return -EINVAL;
 	}
+	hm_node = pfwd_hm->hm_node[0];
 
-	BUG_ON(pfwd_hm->fwd_params.out_if_type == DPA_CLS_HM_IF_TYPE_PPPoE);
-
+	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	switch (pfwd_hm->fwd_params.out_if_type) {
 	case DPA_CLS_HM_IF_TYPE_ETHERNET:
 		/* Update Ethernet MACS */
-		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.insrt		= TRUE;
 		hm_node->params.u.hdr.insrtParams.type	=
 						e_FM_PCD_MANIP_INSRT_GENERIC;
 		hm_node->params.u.hdr.insrtParams.u.generic.replace = TRUE;
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		size = (uint8_t)(sizeof(struct ethhdr) - ETHERTYPE_SIZE);
 		pdata = kzalloc(size, GFP_KERNEL);
 		if (!pdata) {
-			pr_err("ERROR: %s, %s (%d): Not enough RAM for "
+			pr_err("ERROR: %s, %s (%d): Not enough memory for "
 				"forwarding HM.\n", __FILE__, __func__,
 				__LINE__);
-			kfree(hm_node);
 			return -ENOMEM;
 		}
 
@@ -4159,16 +4195,15 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 		memcpy(&pdata[ETH_ALEN], pfwd_hm->fwd_params.eth.macsa,
 			ETH_ALEN);
 
-		hm_node->params.u.hdr.insrtParams.u.generic.offset = 0;
-		hm_node->params.u.hdr.insrtParams.u.generic.size = size;
-		hm_node->params.u.hdr.insrtParams.u.generic.p_Data = pdata;
+		hm_node->params.u.hdr.insrtParams.u.generic.offset	= 0;
+		hm_node->params.u.hdr.insrtParams.u.generic.size	= size;
+		hm_node->params.u.hdr.insrtParams.u.generic.p_Data	= pdata;
 	case DPA_CLS_HM_IF_TYPE_PPPoE:
 		/* Update Ethernet MACS; insert PPPoE */
 		/* Insert PPPoE is not supported yet */
 		break;
 	case DPA_CLS_HM_IF_TYPE_PPP:
 		/* Remove Ethernet and VLANs; insert PPP */
-		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.rmv		= TRUE;
 		hm_node->params.u.hdr.rmvParams.type	=
 					e_FM_PCD_MANIP_RMV_BY_HDR;
@@ -4187,30 +4222,50 @@ static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm)
 			pr_err("ERROR: %s, %s (%d): Not enough memory for "
 				"forwarding HM.\n", __FILE__, __func__,
 				__LINE__);
-			kfree(hm_node);
 			return -ENOMEM;
 		}
 
 		memcpy(pdata, &pfwd_hm->fwd_params.ppp.ppp_pid,
 			PPP_HEADER_SIZE);
 
-		hm_node->params.u.hdr.insrtParams.u.generic.offset = 0;
-		hm_node->params.u.hdr.insrtParams.u.generic.size = size;
-		hm_node->params.u.hdr.insrtParams.u.generic.p_Data = pdata;
+		hm_node->params.u.hdr.insrtParams.u.generic.offset	= 0;
+		hm_node->params.u.hdr.insrtParams.u.generic.size	= size;
+		hm_node->params.u.hdr.insrtParams.u.generic.p_Data	= pdata;
 		break;
 	default:
 		pr_err("ERROR: %s, %s (%d): Forwarding HM: Unknown output port "
 			"type (%d).\n", __FILE__, __func__, __LINE__,
 			pfwd_hm->fwd_params.out_if_type);
-		kfree(hm_node);
 		return -EINVAL;
 	}
 
-	INIT_LIST_HEAD(&hm_node->list_node);
-	pfwd_hm->hm_node[0]	= hm_node;
-	pfwd_hm->num_nodes	= 1;
+	hm_node = pfwd_hm->hm_node[1];
+	if (pfwd_hm->fwd_params.ip_frag_params.mtu) {
+		/* IP fragmentation option is enabled */
+		BUG_ON(!hm_node);
 
-	add_local_hm_nodes_to_chain(pfwd_hm);
+		hm_node->params.type = e_FM_PCD_MANIP_FRAG;
+		hm_node->params.u.frag.hdr = HEADER_TYPE_IPv4;
+		hm_node->params.u.frag.u.ipFrag.sizeForFragmentation =
+				pfwd_hm->fwd_params.ip_frag_params.mtu;
+		hm_node->params.u.frag.u.ipFrag.scratchBpid =
+				pfwd_hm->fwd_params.ip_frag_params.
+					scratch_bpid;
+		switch (pfwd_hm->fwd_params.ip_frag_params.df_action) {
+		case DPA_CLS_HM_DF_ACTION_FRAG_ANYWAY:
+			hm_node->params.u.frag.u.ipFrag.dontFragAction =
+					e_FM_PCD_MANIP_FRAGMENT_PACKET;
+			break;
+		case DPA_CLS_HM_DF_ACTION_DONT_FRAG:
+			hm_node->params.u.frag.u.ipFrag.dontFragAction =
+					e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG;
+			break;
+		case DPA_CLS_HM_DF_ACTION_DROP:
+			hm_node->params.u.frag.u.ipFrag.dontFragAction =
+				e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET;
+			break;
+		}
+	}
 
 	return 0;
 }
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 2f9978a..26a08cd 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -435,18 +435,10 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm);
  */
 static int fwd_hm_check_params(const struct dpa_cls_hm_fwd_params *fwd_params);
 
-/*
- * Imports the low level header manipulation nodes for a Forwarding type
- * classifier header manipulation op.
- */
-static int import_fwd_hm(struct dpa_cls_hm *pfwd_hm,
+static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 				const struct dpa_cls_hm_fwd_resources *res);
 
-/*
- * Creates the low level header manipulation nodes for a Forwarding type
- * classifier header manipulation op.
- */
-static int init_fwd_hm(struct dpa_cls_hm *pfwd_hm);
+static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm);
 
 /*
  * Verifies that the parameters provided for a header remove header
-- 
1.7.5.4

