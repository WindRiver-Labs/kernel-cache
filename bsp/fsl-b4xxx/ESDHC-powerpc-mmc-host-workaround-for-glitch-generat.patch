From 9494bd94a9b838bd1dbaaa3950ba47a467844b49 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 21 Mar 2013 14:47:23 +0800
Subject: [PATCH 021/518] ESDHC-powerpc mmc:host workaround for glitch
 generated when clock changed

A-005055: SDHC: Glitch is generated on the card clock with software reset or
clock divider change.

A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.The Host and the SD card
are in a master-slave relationship. The Host provides clock and control
transfer across the interface. Therefore, any existing operation is discarded
when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when
there is a glitch in the clock line, and the glitch does not cause any issue.

This issue only exist on B4860 and T4240 board with Soc Rev 1.0 and will
be fixed in Soc Rev 2.0

Signed-off-by: Jerry Huang <Chang-Ming.Huang@freescale.com>
Signed-off-by: Haijun Zhang <Haijun.Zhang@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc.h    |   59 +++++++++++++++++++++++++++++++++++--
 drivers/mmc/host/sdhci-of-esdhc.c |   49 ++++++++++++++++++++++++++++++-
 2 files changed, 104 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index 3602074..36ced77 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -30,10 +30,12 @@
 #define ESDHC_CLOCK_MASK	0x0000fff0
 #define ESDHC_PREDIV_SHIFT	8
 #define ESDHC_DIVIDER_SHIFT	4
+#define ESDHC_CLOCK_ENABLE	0x00000008
 #define ESDHC_CLOCK_PEREN	0x00000004
 #define ESDHC_CLOCK_HCKEN	0x00000002
 #define ESDHC_CLOCK_IPGEN	0x00000001
 
+#define ESDHCI_CLOCK_STABLE	0x00000008
 /* pltfm-specific */
 #define ESDHC_HOST_CONTROL_LE	0x20
 
@@ -43,11 +45,33 @@
 
 #define ESDHC_HOST_CONTROL_RES	0x05
 
+static inline int esdhc_version_check(struct sdhci_host *host)
+{
+	unsigned int svr;
+
+	svr = mfspr(SPRN_SVR);
+
+	/*
+	 * Only T4240 and B4860 with Revision 1.0 had this issue and
+	 * it will be fixed in Revision 2.0.
+	 * T4240 SVR: 0x24, Revision: 0x10 (v1.0).
+	 * B4860 SVR: 0x68, Revision: 0x10 (v1.0).
+	 */
+
+	if (((((svr >> 20) & 0xFF) == 0x24) && ((svr & 0xFF) == 0x10)) ||
+		((((svr >> 20) & 0xFF) == 0x68) && ((svr & 0xFF) == 0x10)))
+		return 1;
+	else
+		return 0;
+}
+
 static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 {
 	int pre_div = 2;
 	int div = 1;
 	u32 temp;
+	u32 mask = 0;
+	u32 timeout;
 #ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	struct esdhc_platform_data *boarddata;
 
@@ -57,9 +81,14 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	if (clock == 0)
 		goto out;
 
-	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
-	temp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
+	mask = (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
 		| ESDHC_CLOCK_MASK);
+
+	if (esdhc_version_check(host))
+		mask |= ESDHC_CLOCK_ENABLE;
+
+	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+	temp &= ~mask;
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 
 	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
@@ -79,7 +108,31 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 		| (div << ESDHC_DIVIDER_SHIFT)
 		| (pre_div << ESDHC_PREDIV_SHIFT));
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
-	mdelay(1);
+
+	if (esdhc_version_check(host)) {
+
+		/* we are here because of these boards need to check
+		 * if the clock was stable, when clock was changed
+		 * or reset for all bit was changed.
+		 */
+
+		/* Wait max 20 ms */
+		timeout = 20;
+		mask = ESDHCI_CLOCK_STABLE;
+		while (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask)) {
+			if (timeout == 0) {
+				pr_err("%s: Internal clock never "
+					"stabilised.\n",
+					mmc_hostname(host->mmc));
+				return;
+			}
+			timeout--;
+			mdelay(1);
+		}
+
+		temp |= ESDHC_CLOCK_ENABLE;
+		sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+	}
 
 #ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	/* if there's board callback function
diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index b2c386f..a1e9d8b 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -22,7 +22,7 @@
 #include "sdhci-esdhc.h"
 
 #define VENDOR_V_22    0x12
-#define VENDOR_V_23    0x13
+#define VENDOR_V_23	0x13
 static u32 esdhc_readl(struct sdhci_host *host, int reg)
 {
 	u32 ret;
@@ -84,6 +84,12 @@ static u8 esdhc_readb(struct sdhci_host *host, int reg)
 		ret |= dma_bits;
 	}
 
+	if (reg == SDHCI_SOFTWARE_RESET) {
+		unsigned int temp;
+		temp = sdhci_be32bs_readl(host, ESDHC_SYSTEM_CONTROL);
+		ret = temp >> 24;
+	}
+
 	return ret;
 }
 
@@ -132,6 +138,17 @@ static void esdhc_writeb(struct sdhci_host *host, u8 val, int reg)
 	/* Prevent SDHCI core from writing reserved bits (e.g. HISPD). */
 	if (reg == SDHCI_HOST_CONTROL)
 		val &= ~ESDHC_HOST_CONTROL_RES;
+
+	if (reg == SDHCI_SOFTWARE_RESET) {
+		unsigned int temp;
+
+		temp = sdhci_be32bs_readl(host, ESDHC_SYSTEM_CONTROL);
+		temp |= val << 24;
+		sdhci_be32bs_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+
+		return;
+	}
+
 	sdhci_be32bs_writeb(host, val, reg);
 }
 
@@ -239,6 +256,34 @@ static int esdhc_of_get_cd(struct sdhci_host *host)
 	return present;
 }
 
+static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
+{
+	unsigned int temp;
+
+	if (!(mask & SDHCI_RESET_ALL))
+		return;
+
+	if (esdhc_version_check(host)) {
+		temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+		temp &= ~ESDHC_CLOCK_ENABLE;
+		sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+	}
+}
+
+static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
+{
+	unsigned int temp;
+
+	if (!(mask & SDHCI_RESET_ALL))
+		return;
+
+	if (esdhc_version_check(host)) {
+		temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+		temp |= ESDHC_CLOCK_ENABLE;
+		sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+	}
+}
+
 static struct sdhci_ops sdhci_esdhc_ops = {
 	.read_l = esdhc_readl,
 	.read_w = esdhc_readw,
@@ -251,6 +296,8 @@ static struct sdhci_ops sdhci_esdhc_ops = {
 	.enable_dma = esdhc_of_enable_dma,
 	.get_max_clock = esdhc_of_get_max_clock,
 	.get_min_clock = esdhc_of_get_min_clock,
+	.platform_reset_enter = esdhc_of_platform_reset_enter,
+	.platform_reset_exit = esdhc_of_platform_reset_exit,
 #ifdef CONFIG_PM
 	.platform_suspend = esdhc_of_suspend,
 	.platform_resume = esdhc_of_resume,
-- 
1.7.5.4

