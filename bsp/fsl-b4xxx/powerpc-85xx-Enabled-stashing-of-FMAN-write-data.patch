From 23a6bf8cea063037cd6949d2ead2ace1a61ad50c Mon Sep 17 00:00:00 2001
From: Vakul Garg <vakul@freescale.com>
Date: Fri, 1 Mar 2013 13:54:21 +0000
Subject: [PATCH 04/36] powerpc/85xx: Enabled stashing of FMAN write data.

This patch enables translation of FMAN write transactions into
write-with-stashing (to CPC) using IOMMU operation mapping mechanism.
This is required for USDPAA IPSEC application so that SEC is able to DMA
data faster and show better performance. On T4240, this patch shows up
20% performance gain for USDPAA IPSEC.

The stashing of FMAN write data is controllable with a kernel
configuration option.

Signed-off-by: Vakul Garg <vakul@freescale.com>
[Grabbed from the branch, LINUX_IR5.3.0_ALPHA, of
https://git.freescale.com/git-private/cgit.cgi/ppc/dpaa-offload/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/Kconfig           |    8 ++++++++
 arch/powerpc/sysdev/fsl_pamu.c |   38 +++++++++++++++++++++++++++++++++++++-
 2 files changed, 45 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 93aec85..248c694 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -736,6 +736,14 @@ config FSL_PAMU_ERRATUM_A_004510
 	  causing data corruption.  This option enables the PAMU portion of
 	  the work-around.
 
+config FSL_FMAN_CPC_STASH
+	bool "Enable stashing of FMAN write transactions for ethernet ports"
+	depends on FSL_PAMU
+	default n
+	help
+	  Select this option to enable stashing of incoming ethernet frames
+	  from FMAN ports into platform cache.
+
 config HAS_FSL_QBMAN
 	bool "Datapath Acceleration Queue and Buffer management"
 	help
diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index 6fb40c9..dc3517d 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -569,7 +569,7 @@ static void __init setup_omt(struct ome *omt)
 	/* Configure OMI_FMAN */
 	ome = &omt[OMI_FMAN];
 	ome->moe[IOE_READ_IDX]  = EOE_VALID | EOE_READI;
-	ome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;
+	ome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WWSA;
 
 	/* Configure OMI_QMAN private */
 	ome = &omt[OMI_QMAN_PRIV];
@@ -658,6 +658,30 @@ static u32 __init get_stash_id(unsigned int stash_dest_hint,
 	return ~(u32)0;
 }
 
+#ifdef CONFIG_FSL_FMAN_CPC_STASH
+static void __init enable_fman_io_stashing(struct device_node *dn)
+{
+	const u32 *prop;
+	struct ppaace *ppaace;
+	u32 cache_id;
+
+	prop = of_get_property(dn, "fsl,liodn", NULL);
+	if (prop) {
+		ppaace = &ppaact[*prop];
+		ppaace->otm = PAACE_OTM_INDEXED;
+		ppaace->domain_attr.to_host.coherency_required = 1;
+		ppaace->op_encode.index_ot.omi = OMI_FMAN;
+		cache_id = get_stash_id(3, NULL);
+		pr_debug("%s cache_stash_id = %d\n", dn->full_name, cache_id);
+		if (~cache_id != 0)
+			ppaace->impl_attr.cid = cache_id;
+	} else {
+		pr_err("fsl-pamu: missing fsl,liodn property in %s\n",
+			dn->full_name);
+	}
+}
+#endif
+
 static void __init setup_liodns(void)
 {
 	int i, len;
@@ -667,6 +691,9 @@ static void __init setup_liodns(void)
 	struct device_node *bman_dn;
 	const u32 *prop;
 	u32 cache_id, prop_cnt;
+#ifdef CONFIG_FSL_FMAN_CPC_STASH
+	struct device_node *port_dn;
+#endif
 
 	for (i = 0; i < PAACE_NUMBER_ENTRIES; i++) {
 		ppaace = &ppaact[i];
@@ -733,6 +760,15 @@ static void __init setup_liodns(void)
 		of_node_put(qman_dn);
 	}
 
+#ifdef CONFIG_FSL_FMAN_CPC_STASH
+	port_dn = NULL;
+	for_each_compatible_node(port_dn, NULL, "fsl,fman-port-10g-rx")
+		enable_fman_io_stashing(port_dn);
+
+	port_dn = NULL;
+	for_each_compatible_node(port_dn, NULL, "fsl,fman-port-1g-rx")
+		enable_fman_io_stashing(port_dn);
+#endif
 	/*
 	 * For liodn used by BMAN for its private memory accesses,
 	 * turn the 'coherency required' off. This saves snoops to cores.
-- 
1.7.5.4

