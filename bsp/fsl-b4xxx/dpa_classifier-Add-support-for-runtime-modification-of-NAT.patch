From f83e5d35da80f55cd5cbda76a9497314c3b6e4b4 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:10:15 +0000
Subject: [PATCH 1/7] dpa_classifier: Add support for runtime modification of NAT type header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  182 +++++++++++++++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    6 -
 2 files changed, 179 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 972244b..81a5ae0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -4079,6 +4079,8 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 	unsigned int ip_ver = 0;
 
 	BUG_ON(!pnat_hm);
+	BUG_ON(pnat_hm->num_nodes < 1);
+	BUG_ON(pnat_hm->num_nodes > 2);
 
 	if (pnat_hm->hm_node[0]) {
 		hm_node = pnat_hm->hm_node[0];
@@ -4224,9 +4226,183 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 int dpa_classif_modify_nat_hm(int hmd,
 	const struct dpa_cls_hm_nat_params *new_nat_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
-		__LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pnat_hm;
+	bool update[2] = { false, false };
+	t_Error error;
+	int ret = 0;
+	int i;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	/* Parameters sanity checks: */
+	if (!new_nat_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_nat_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	pnat_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pnat_hm->type != DPA_CLS_HM_TYPE_NAT) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an NAT type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	if (pnat_hm->nat_params.type == DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
+		if (modify_flags & DPA_CLS_HM_NAT_MOD_SIP) {
+			if (new_nat_params->nat.sip.version !=
+					pnat_hm->nat_params.nat.sip.version) {
+				pr_err("ERROR: %s, %s (%d): New SIP adress "
+					"version (%d) in NAT header "
+					"manipulation hmd=%d cannot be "
+					"different from the old one (%d).\n",
+					__FILE__, __func__, __LINE__,
+					new_nat_params->nat.sip.version, hmd,
+					pnat_hm->nat_params.nat.sip.version);
+				return -EINVAL;
+			}
+			update[0] = true;
+			memcpy(&pnat_hm->nat_params.nat.sip,
+				&new_nat_params->nat.sip,
+				sizeof(struct dpa_offload_ip_address));
+		}
+
+		if (modify_flags & DPA_CLS_HM_NAT_MOD_DIP) {
+			if (new_nat_params->nat.dip.version !=
+					pnat_hm->nat_params.nat.dip.version) {
+				pr_err("ERROR: %s, %s (%d): New DIP adress "
+					"version (%d) in NAT header "
+					"manipulation hmd=%d cannot be "
+					"different from the old one (%d).\n",
+					__FILE__, __func__, __LINE__,
+					new_nat_params->nat.dip.version, hmd,
+					pnat_hm->nat_params.nat.dip.version);
+				return -EINVAL;
+			}
+			update[0] = true;
+			memcpy(&pnat_hm->nat_params.nat.dip,
+				&new_nat_params->nat.dip,
+				sizeof(struct dpa_offload_ip_address));
+		}
+	} else { /* NAT-PT */
+		if (modify_flags & DPA_CLS_HM_NAT_MOD_IP_HDR) {
+			if (pnat_hm->nat_params.nat_pt.type ==
+					DPA_CLS_HM_NAT_PT_IPv6_TO_IPv4) {
+				memcpy(&pnat_hm->nat_params.nat_pt.new_header.
+					ipv4.header, &new_nat_params->nat_pt.
+					new_header.ipv4.header,
+					sizeof(struct iphdr));
+				/* Update IPv4 options */
+				kfree(pnat_hm->nat_params.nat_pt.new_header.
+								ipv4.options);
+				if (new_nat_params->nat_pt.new_header.ipv4.
+								options_size) {
+					pnat_hm->nat_params.nat_pt.new_header.
+						ipv4.options = kzalloc(
+						new_nat_params->nat_pt.
+						new_header.ipv4.options_size,
+						GFP_KERNEL);
+					if (!pnat_hm->update_params.replace.
+						new_ipv4_hdr.options) {
+						pnat_hm->nat_params.nat_pt.
+							new_header.ipv4.
+							options_size = 0;
+						pr_err("ERROR: %s, %s (%d): "
+							"Out of memory while "
+							"modifying IPv6 header "
+							"replace header "
+							"manipulation hmd=%d.\n",
+							__FILE__, __func__,
+							__LINE__, hmd);
+						return -EINVAL;
+					}
+				} else
+					pnat_hm->nat_params.nat_pt.new_header.
+						ipv4.options = NULL;
+				pnat_hm->nat_params.nat_pt.new_header.ipv4.
+					options_size = new_nat_params->nat_pt.
+					new_header.ipv4.options_size;
+			} else { /* DPA_CLS_HM_NAT_PT_IPv4_TO_IPv6 */
+				memcpy(&pnat_hm->nat_params.nat_pt.new_header.
+					ipv6, &new_nat_params->nat_pt.
+					new_header.ipv6,
+					sizeof(struct ipv6_header));
+			}
+			update[0] = true;
+		}
+	}
+
+	if ((modify_flags & DPA_CLS_HM_NAT_MOD_SPORT) &&
+			(new_nat_params->sport != pnat_hm->nat_params.sport)) {
+		update[1] = true;
+		pnat_hm->nat_params.sport = new_nat_params->sport;
+	}
+
+	if ((modify_flags & DPA_CLS_HM_NAT_MOD_DPORT) &&
+		(new_nat_params->dport != pnat_hm->nat_params.dport)) {
+		update[1] = true;
+		pnat_hm->nat_params.dport = new_nat_params->dport;
+	}
+
+	if ((modify_flags & DPA_CLS_HM_NAT_MOD_FLAGS) &&
+		(new_nat_params->flags != pnat_hm->nat_params.flags)) {
+		update[0] = true;
+		update[1] = true;
+		pnat_hm->nat_params.flags = new_nat_params->flags;
+	}
+
+	if (update[0] || update[1]) {
+		ret = nat_hm_update_params(pnat_hm);
+		if (ret == 0) {
+			t_FmPcdManipParams new_hm_node_params;
+
+			for (i = 0; i < 2; i++) {
+				if (!update[i])
+					continue;
+
+				hm_node = pnat_hm->hm_node[i];
+				memcpy(&new_hm_node_params,
+					&hm_node->params,
+					sizeof(t_FmPcdManipParams));
+				/*
+				 * Must make sure that h_NextManip is NULL
+				 * before calling FM_PCD_ManipNodeReplace
+				 */
+				new_hm_node_params.h_NextManip = NULL;
+
+				error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&hm_node->params);
+				if (error != E_OK) {
+					pr_err("ERROR: %s, %s (%d): FMan "
+						"driver call failed - "
+						"FM_PCD_ManipNodeReplace, "
+						"while trying to modify "
+						"hmd=%d, manip node "
+						"handle=0x%p (node #%d).\n",
+						__FILE__, __func__, __LINE__,
+						hmd, hm_node->node, i);
+					return -EBUSY;
+				}
+			}
+		}
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_nat_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 9d1d8c9..fc96d30 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1193,12 +1193,6 @@ static long do_ioctl_modify_nat_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d)\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.nat_params.fm_pcd = translate_fm_pcd_handle(kparam.nat_params.
-								fm_pcd);
-	if (!kparam.nat_params.fm_pcd)
-		return -EINVAL;
-
 	return dpa_classif_modify_nat_hm(kparam.hmd, &kparam.nat_params,
 					kparam.modify_flags);
 }
-- 
1.7.0.2

