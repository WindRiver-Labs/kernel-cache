From a05b7be78e5d2f627e67f6aae620485ce3ee838a Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 26 Oct 2012 18:55:03 +0000
Subject: [PATCH 363/518] dpa_ipsec: Add support for extended CAAM descriptors

DPA IPSec component is now supporting creation of
CAAM descriptors longer than 64 words.

This feature is used to support DSCP/ECN propagation and
lifetime statistics configured on a SA at the same time.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |   38 +-
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h      |   15 +-
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |  933 +++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    3 +
 4 files changed, 980 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index ff69e1c..590b1cf 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -766,6 +766,22 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		}
 		sa[i].sec_desc = PTR_ALIGN(sa[i].sec_desc_unaligned, 64);
 
+		/* Allocate space for extra material space in case when the
+		 * descriptor is greater than 64 words */
+		sa[i].sec_desc_extra_cmds_unaligned =
+			kzalloc(2 * MAX_EXTRA_DESC_COMMANDS + L1_CACHE_BYTES,
+				GFP_KERNEL);
+		if (!sa[i].sec_desc_extra_cmds_unaligned) {
+			pr_err("Allocation failed for CAAM extra commands\n");
+			return -ENOMEM;
+		}
+		sa[i].sec_desc_extra_cmds =
+				PTR_ALIGN(sa[i].sec_desc_extra_cmds_unaligned,
+					  L1_CACHE_BYTES);
+		if (sa[i].sec_desc_extra_cmds_unaligned ==
+		    sa[i].sec_desc_extra_cmds)
+			sa[i].sec_desc_extra_cmds += L1_CACHE_BYTES;
+
 		/* Initialize the policy parameter list which will hold all
 		 * inbound or outbound policy parameters which were use to
 		 * generate PCD entries */
@@ -897,6 +913,9 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 			kfree(sa_mng->sa[i].sec_desc_unaligned);
 			sa_mng->sa[i].sec_desc_unaligned = NULL;
 			sa_mng->sa[i].sec_desc = NULL;
+
+			kfree(sa_mng->sa[i].sec_desc_extra_cmds_unaligned);
+			sa_mng->sa[i].sec_desc_extra_cmds_unaligned = NULL;
 		}
 		kfree(sa_mng->sa);
 		sa_mng->sa = NULL;
@@ -1990,6 +2009,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->sa_wqid = sa_params->sa_wqid;
 	ip_addr_type = sa_params->sa_out_params.ip_ver;
 
+	sa->alg_suite = sa_params->crypto_params.alg_suite;
 	err = set_cipher_auth_alg(sa_params->crypto_params.alg_suite,
 				  &sa->cipher_data.cipher_type,
 				  &sa->auth_data.auth_type);
@@ -2029,6 +2049,9 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		sa->ecn_copy =
 			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_ECN;
 	}
+
+	sa->enable_dpovrd = true;
+
 	if (sa_params->use_ext_seq_num) {
 		sa->sec_desc->pdb_en.seq_num_ext_hi =
 			(sa_params->start_seq_num & SEQ_NUM_HI_MASK) >> 32;
@@ -2139,6 +2162,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	sa->sa_wqid = sa_params->sa_wqid;
 	sa->spi = sa_params->spi;
 
+	sa->alg_suite = sa_params->crypto_params.alg_suite;
 	err = set_cipher_auth_alg(sa_params->crypto_params.alg_suite,
 				  &sa->cipher_data.cipher_type,
 				  &sa->auth_data.auth_type);
@@ -2225,6 +2249,9 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_ECN;
 	}
 
+	/* Only for outbound */
+	sa->enable_dpovrd = false;
+
 	memcpy(&sa->src_addr,
 	       &sa_params->sa_in_params.src_addr,
 	       sizeof(struct dpa_offload_ip_address));
@@ -3186,7 +3213,7 @@ static int remove_outbound_sa(struct dpa_ipsec_sa *sa)
 	if (sa_is_parent(sa)) {
 		struct dpa_ipsec_sa_mng *sa_mng;
 
-		BUG_ON(sa->dpa_ipsec);
+		BUG_ON(!sa->dpa_ipsec);
 		sa_mng = &sa->dpa_ipsec->sa_mng;
 
 		child_sa = sa->child_sa;
@@ -4233,8 +4260,13 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 	}
 
 	desc = (uint32_t *)sa->sec_desc->desc;
-	sa_stats->packets_count = *(desc + sa->stats_offset / 4);
-	sa_stats->bytes_count = *(desc + sa->stats_offset / 4 + 1);
+	if (!sa->sec_desc_extended) {
+		sa_stats->packets_count = *(desc + sa->stats_offset / 4);
+		sa_stats->bytes_count = *(desc + sa->stats_offset / 4 + 1);
+	} else {
+		sa_stats->bytes_count = *(desc + sa->stats_offset / 4);
+		sa_stats->packets_count = *(desc + sa->stats_offset / 4 + 1);
+	}
 
 	mutex_unlock(&sa->lock);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index ea9837f..7dec1c9 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -188,6 +188,9 @@
 
 #define INVALID_INB_FLOW_ID	0xFFFF
 
+/* The maximum length (in bytes) for the CAAM extra commands */
+#define MAX_EXTRA_DESC_COMMANDS		(64 * sizeof(uint32_t))
+
 /*
  * calculate the size of the fields in the policy params structure that
  * are used to identify a policy
@@ -237,6 +240,7 @@ struct dpa_ipsec_sa {
 	struct dpa_ipsec *dpa_ipsec;	    /* Pointer to DPA_IPSEC           */
 	enum dpa_ipsec_direction sa_dir;    /* SA direction		      */
 	uint32_t id;			    /* Used to index in circular queue*/
+	enum dpa_ipsec_cipher_alg alg_suite; /* DPA IPSEC algorithm suite     */
 	struct cipher_params cipher_data;   /* Encryption parameters	      */
 	struct auth_params auth_data;	    /* Authentication key parameters  */
 	struct sec_descriptor *sec_desc_unaligned; /* Allocated at init time.
@@ -247,10 +251,19 @@ struct dpa_ipsec_sa {
 					  * computed the SEC 4.x descriptor
 					  * according to the SA information.
 					  * do not free this pointer!	      */
+	uint32_t *sec_desc_extra_cmds_unaligned;
+	uint32_t *sec_desc_extra_cmds; /* aligned to CORE cache line size     */
+	bool	 sec_desc_extended; /* true if SEC descriptor is extended     */
 	uint32_t stats_offset; /* Offset of the statistics (in bytes)	      */
-	bool	enable_stats; /* Enable counting packets and bytes processed  */
+	uint32_t stats_indx; /* Index of the lifetime counter in descriptor   */
+	uint32_t next_cmd_indx; /* Next command index after SHD header	      */
+	uint8_t  job_desc_len; /* Number of words CAAM Job Descriptor occupies
+				* form the CAAM Descriptor length
+				* MAX_CAAM_DESCSIZE			      */
+	bool enable_stats; /* Enable counting packets and bytes processed     */
 	bool dscp_copy; /* Enable DSCP propagation support		      */
 	bool ecn_copy; /* Enable DSCP propagation support		      */
+	bool enable_dpovrd; /* Enable DECO Protocol Override Register	      */
 	struct qman_fq *to_sec_fq; /*From this Frame Queue SEC consumes frames*/
 	struct qman_fq *from_sec_fq; /*In this Frame Queue SEC will enqueue the
 				encryption/decryption result (FD).            */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 5fa98f0..18d3cb5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -54,7 +54,9 @@
 /* relative offset where the input pointer should be updated in the descriptor*/
 #define IN_PTR_REL_OFF		4 /* words from current location */
 /* dummy pointer value */
-#define DUMMY_PTR_VAL		0xFFFFFF00
+#define DUMMY_PTR_VAL		0x00000000
+#define PTR_LEN			2	/* Descriptor is created only for 8 byte
+					 * pointer. PTR_LEN is in words. */
 
 static const struct of_device_id sec_match[] = {
 	{
@@ -133,6 +135,105 @@ static inline u32 get_ipsec_op_type(enum dpa_ipsec_direction sa_dir)
 					      OP_TYPE_ENCAP_PROTOCOL;
 }
 
+static inline int get_cipher_params(enum dpa_ipsec_cipher_alg cipher_alg,
+				    uint32_t *iv_length, uint32_t *icv_length,
+				    uint32_t *max_pad_length)
+{
+	switch (cipher_alg) {
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_MD5_128:
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_96_SHA_160:
+		*iv_length = 8;
+		*max_pad_length = 8;
+		*icv_length = 12;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_MD5_128:
+		*iv_length = 8;
+		*max_pad_length = 8;
+		*icv_length = 16;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_SHA_160:
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_SHA_256_128:
+		*iv_length = 8;
+		*max_pad_length = 8;
+		*icv_length = 20;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_SHA_384_192:
+		*iv_length = 8;
+		*max_pad_length = 8;
+		*icv_length = 24;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_3DES_CBC_HMAC_SHA_512_256:
+		*iv_length = 8;
+		*max_pad_length = 8;
+		*icv_length = 32;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_96_MD5_128:
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_96_SHA_160:
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_AES_XCBC_MAC_96:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 12;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_MD5_128:
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_SHA_256_128:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 16;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_SHA_160:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 20;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_SHA_384_192:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 24;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CBC_HMAC_SHA_512_256:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 32;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_96_MD5_128:
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_96_SHA_160:
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_AES_XCBC_MAC_96:
+		*iv_length = 16;
+		*max_pad_length = 16;
+		*icv_length = 12;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_MD5_128:
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_SHA_256_128:
+		*iv_length = 8;
+		*max_pad_length = 4;
+		*icv_length = 16;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_SHA_160:
+		*iv_length = 8;
+		*max_pad_length = 4;
+		*icv_length = 20;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_SHA_384_192:
+		*iv_length = 8;
+		*max_pad_length = 4;
+		*icv_length = 24;
+		break;
+	case DPA_IPSEC_CIPHER_ALG_AES_CTR_HMAC_SHA_512_256:
+		*iv_length = 8;
+		*max_pad_length = 4;
+		*icv_length = 32;
+		break;
+	default:
+		*iv_length = 0;
+		*icv_length = 0;
+		*max_pad_length = 0;
+		pr_err("Unsupported cipher suite %d\n", cipher_alg);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static inline void build_stats_descriptor_part(struct dpa_ipsec_sa *sa,
 					       size_t pdb_len)
 {
@@ -507,20 +608,810 @@ skip_byte_copy:
 		insert_ptr_copy_cmds(desc, copy_ptr_index,
 				     desc_len(desc), false);
 
+	if (desc_len(desc) >= MAX_CAAM_SHARED_DESCSIZE) {
+		if (sa->enable_stats)
+			memset((uint8_t *)desc + sa->stats_offset, 0,
+				MAX_CAAM_DESCSIZE * sizeof(u32) -
+				sa->stats_offset);
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+/* Move size should be set to 64 bytes */
+int built_encap_extra_material(struct dpa_ipsec_sa *sa,
+			       dma_addr_t auth_key_dma,
+			       dma_addr_t crypto_key_dma,
+			       unsigned int move_size)
+{
+	uint32_t *extra_cmds, *padding_jump, *key_jump_cmd;
+	uint32_t len, off_b, off_w, off, opt;
+	unsigned char job_desc_len, block_size;
+
+	/* sec_desc_extra_cmds is the address were the first SEC extra command
+	 * is located, from here SEC will overwrite Job descriptor part. Need
+	 * to insert a dummy command because the LINUX CAAM API uses first word
+	 * for storing the length of the descriptor. */
+	extra_cmds = sa->sec_desc_extra_cmds - 1;
+
+	/* Dummy command - will not be executed at all. Only for setting to 1
+	 * the length of the extra_cmds descriptor so that first extra material
+	 * command will be located exactly at sec_desc_extra_cmds address. */
+	append_cmd(extra_cmds, 0xdead0000);
+
+	/* Start Extra Material Group 1 */
+	/* Load from the input address 64 bytes into internal register */
+	/* load the data to be moved - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_load(extra_cmds, DUMMY_PTR_VAL, len, opt | off);
+
+	/* Wait to finish previous operation */
+	opt = JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT);
+	append_jump(extra_cmds, opt);
+
+	/* Store the data to the output FIFO - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_store(extra_cmds, DUMMY_PTR_VAL, len, opt | off);
+
+	/* Fix LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off = 0x80 << LDST_OFFSET_SHIFT; /* NON_SEQ LIODN */
+	append_cmd(extra_cmds, CMD_LOAD | opt | off);
+
+	/* MATH0 += 1 (packet counter) */
+	append_math_add(extra_cmds, REG0, REG0, ONE, MATH_LEN_8BYTE);
+
+	/* Overwrite the job-desc location (word 51 or 53) with the second
+	 * group (10 words) */
+	job_desc_len = sa->job_desc_len;
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_DESCBUF | MOVE_WAITCOMP;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = (10 * sizeof(uint32_t)) << MOVE_LEN_SHIFT;
+	append_move(extra_cmds, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Jump to the beginning of the JOB Descriptor to start executing
+	 * the extra material group 2 */
+	append_cmd(extra_cmds, 0xa00000f6);
+
+	/* End of Extra Material Group 1 */
+
+	/* Start Extra Material Group 2 */
+	/* MATH REG 2 = Sequence in length + 2; 2 for pad-len and NH field */
+	append_math_add_imm_u32(extra_cmds, REG2, SEQINLEN, IMM, 2);
+
+	switch (sa->cipher_data.cipher_type) {
+	case OP_PCL_IPSEC_3DES:
+		block_size = 8; /* block size in bytes */
+		break;
+	case OP_PCL_IPSEC_AES_CBC:
+	case OP_PCL_IPSEC_AES_CTR:
+	case OP_PCL_IPSEC_AES_XTS:
+	case OP_PCL_IPSEC_AES_CCM8:
+	case OP_PCL_IPSEC_AES_CCM12:
+	case OP_PCL_IPSEC_AES_CCM16:
+	case OP_PCL_IPSEC_AES_GCM8:
+	case OP_PCL_IPSEC_AES_GCM12:
+	case OP_PCL_IPSEC_AES_GCM16:
+		block_size = 16; /* block size in bytes */
+		break;
+	default:
+		pr_crit("Invalid cipher algorithm for SA %d\n", sa->id);
+		return -EINVAL;
+	}
+
+	/* Adding padding to byte counter */
+	append_math_and_imm_u32(extra_cmds, REG3, REG2, IMM, block_size - 1);
+
+	/* Previous operation result is 0 i.e padding added to bytes count */
+	padding_jump = append_jump(extra_cmds, CLASS_BOTH | JUMP_TEST_ALL |
+				   JUMP_COND_MATH_Z);
+
+	/* MATH REG 2 = MATH REG 2 + 1 */
+	append_math_add(extra_cmds, REG2, REG2, ONE, MATH_LEN_4BYTE);
+
+	/* jump back to adding padding i.e jump back 4 words */
+	off = (-4) & 0x000000FF;
+	append_jump(extra_cmds, (off << JUMP_OFFSET_SHIFT));
+
+	set_jump_tgt_here(extra_cmds, padding_jump);
+	/* Done adding padding to byte counter */
+
+	/*
+	 * Perform 32-bit left shift of DEST and concatenate with left 32 bits
+	 * of SRC1 i.e MATH REG 2 = 0x00bytecount_00000000
+	 */
+	append_math_ldshift(extra_cmds, REG2, REG0, REG2, MATH_LEN_8BYTE);
+
+	/* MATH REG 0  = MATH REG 0 + MATH REG 2 */
+	append_math_add(extra_cmds, REG0, REG0, REG2, MATH_LEN_8BYTE);
+
+	/* Overwrite the job-desc location (word 51 or 53) with the third
+	 * group (11 words) */
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_DESCBUF | MOVE_WAITCOMP;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = (11 * sizeof(uint32_t)) << MOVE_LEN_SHIFT;
+	append_move(extra_cmds, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Jump to the beginning of the JOB Descriptor to start executing
+	 * the extra material group 3. The command for jumping back is already
+	 * here from extra material group 1 */
+
+	/* End of Extra Material Group 2 */
+
+	/* Start Extra Material Group 3 */
+
+	if (sa->enable_stats) {
+		/* Store statistics in the CAAM internal descriptor */
+		off_b = sa->stats_indx * CAAM_CMD_SZ;
+		append_move(extra_cmds, MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF |
+			    (off_b << MOVE_OFFSET_SHIFT) |
+			    sizeof(uint64_t));
+	} else {
+		/* Statistics are disabled. Do not update descriptor counter */
+		append_cmd(extra_cmds, 0xA0000001); /* NOP for SEC */
+	}
+
+	/* Key jump */
+	key_jump_cmd = append_jump(extra_cmds, CLASS_BOTH | JUMP_TEST_ALL |
+				   JUMP_COND_SHRD);
+
+	/* check whether a split of a normal key is used */
+	if (sa->auth_data.split_key_len)
+		/* Append split authentication key */
+		append_key(extra_cmds, auth_key_dma,
+			   sa->auth_data.split_key_len,
+			   CLASS_2 | KEY_ENC | KEY_DEST_MDHA_SPLIT);
+	else
+		/* Append normal authentication key */
+		append_key(extra_cmds, auth_key_dma, sa->auth_data.auth_key_len,
+			   CLASS_2 | KEY_DEST_CLASS_REG);
+
+	/* Append cipher key */
+	append_key(extra_cmds, crypto_key_dma, sa->cipher_data.cipher_key_len,
+		   CLASS_1 | KEY_DEST_CLASS_REG);
+
+	set_jump_tgt_here(extra_cmds, key_jump_cmd);
+
+	/* Protocol specific operation */
+	append_operation(extra_cmds, OP_PCLID_IPSEC | OP_TYPE_ENCAP_PROTOCOL |
+			 sa->cipher_data.cipher_type | sa->auth_data.auth_type);
+
+	if (sa->enable_stats) {
+		/* Store command: in the case of the Descriptor Buffer the
+		 * length is specified in 4-byte words, but in all other cases
+		 * the length is specified in bytes. Offset in 4 byte words */
+		off_w = sa->stats_indx;
+		append_store(extra_cmds, 0, DPA_IPSEC_STATS_LEN,
+			     LDST_CLASS_DECO | (off_w << LDST_OFFSET_SHIFT) |
+			     LDST_SRCDST_WORD_DESCBUF_SHARED);
+	} else {
+		/* Do not store lifetime counter in external memory */
+		append_cmd(extra_cmds, 0xA0000001); /* NOP for SEC */
+	}
+
+	/* Jump with CALM to be sure previous operation was finished */
+	append_jump(extra_cmds, JUMP_TYPE_HALT_USER | JUMP_COND_CALM);
+
+	/* End of Extra Material Group 3 */
+
+	return 0;
+}
+
+/* Move size should be set to 64 bytes */
+int built_decap_extra_material(struct dpa_ipsec_sa *sa,
+			       dma_addr_t auth_key_dma,
+			       dma_addr_t crypto_key_dma)
+{
+	uint32_t *extra_cmds;
+	uint32_t off_b, off_w, data;
+
+	/* sec_desc_extra_cmds is the address were the first SEC extra command
+	 * is located, from here SEC will overwrite Job descriptor part. Need
+	 * to insert a dummy command because the LINUX CAAM API uses first word
+	 * for storing the length of the descriptor. */
+	extra_cmds = sa->sec_desc_extra_cmds - 1;
+
+	/* Dummy command - will not be executed at all. Only for setting to 1
+	 * the length of the extra_cmds descriptor so that first extra material
+	 * command will be located exactly at sec_desc_extra_cmds address. */
+	append_cmd(extra_cmds, 0xdead0000);
+
+	data = 16;
+	append_math_rshift_imm_u32(extra_cmds, REG2, REG2, IMM, data);
+
+	/* math: (math1 - math2)->math1 len=8 */
+	append_math_sub(extra_cmds, REG1, REG1, REG2, MATH_LEN_8BYTE);
+
+	/* math: (math0 + 1)->math0 len=8 */
+	append_math_add(extra_cmds, REG0, REG0, ONE, MATH_LEN_8BYTE);
+
+	append_math_ldshift(extra_cmds, REG1, REG0, REG1, MATH_LEN_8BYTE);
+
+	append_math_add(extra_cmds, REG0, REG0, REG1, MATH_LEN_8BYTE);
+
+	append_cmd(extra_cmds, 0x7883c824);
+
+	/* Store in the descriptor but not in external memory */
+	off_b = sa->stats_offset;
+	append_move(extra_cmds, MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF |
+		    MOVE_WAITCOMP | (off_b << MOVE_OFFSET_SHIFT) | sizeof(u64));
+
+	append_cmd(extra_cmds, 0xa70040fe);
+
+	append_cmd(extra_cmds, 0xa00000f7);
+
+	/* check whether a split of a normal key is used */
+	if (sa->auth_data.split_key_len)
+		/* Append split authentication key */
+		append_key(extra_cmds, auth_key_dma,
+			   sa->auth_data.split_key_len,
+			   CLASS_2 | KEY_ENC | KEY_DEST_MDHA_SPLIT);
+	else
+		/* Append normal authentication key */
+		append_key(extra_cmds, auth_key_dma, sa->auth_data.auth_key_len,
+			   CLASS_2 | KEY_DEST_CLASS_REG);
+
+	/* Append cipher key */
+	append_key(extra_cmds, crypto_key_dma, sa->cipher_data.cipher_key_len,
+		   CLASS_1 | KEY_DEST_CLASS_REG);
+
+	/* Protocol specific operation */
+	append_operation(extra_cmds, OP_PCLID_IPSEC | OP_TYPE_DECAP_PROTOCOL |
+			 sa->cipher_data.cipher_type | sa->auth_data.auth_type);
+
+	/* Store command: in the case of the Descriptor Buffer the length
+	 * is specified in 4-byte words, but in all other cases the length
+	 * is specified in bytes. Offset in 4 byte words */
+	off_w = sa->stats_indx;
+	append_store(extra_cmds, 0, DPA_IPSEC_STATS_LEN,
+		     LDST_CLASS_DECO | (off_w << LDST_OFFSET_SHIFT) |
+		     LDST_SRCDST_WORD_DESCBUF_SHARED);
+
+	append_jump(extra_cmds, JUMP_TYPE_HALT_USER | JUMP_COND_CALM);
+
+	return 0;
+}
+
+int build_extended_encap_shared_descriptor(struct dpa_ipsec_sa *sa,
+				     dma_addr_t auth_key_dma,
+				     dma_addr_t crypto_key_dma,
+				     uint8_t bytes_to_copy,
+				     int sec_era)
+{
+	uint32_t *desc, *no_sg_jump, *extra_cmds;
+	uint32_t len, off_b, off_w, opt, stats_off_b, sg_mask;
+	struct device *jrdev;
+	unsigned int extra_cmds_len;
+	unsigned char job_desc_len;
+	dma_addr_t dma_extra_cmds;
+	int ret;
+
+	desc = (uint32_t *)sa->sec_desc->desc;
+
+	sa->enable_dpovrd = TRUE;
+
+	if (sec_era == 2) {
+		if (sa->enable_stats)
+			sa->stats_indx = 29;
+		sa->next_cmd_indx = 31;
+	} else {
+		if (sa->enable_stats)
+			sa->stats_indx = 30 - 0;
+		sa->next_cmd_indx = 32 - 0;
+	}
+
+	/* This code only works when SEC is configured to use PTR on 64 bit
+	 * so the Job Descriptor length is 11 words long when DPOWRD is not
+	 * enabled and 13 words when this feature is present. */
+	job_desc_len = 11;
+	if (sa->enable_dpovrd) {
+		if (sa->enable_stats)
+			sa->stats_indx -= 2;
+		sa->next_cmd_indx -= 2;
+		job_desc_len = 13;
+	}
+
+	/* Set CAAM Job Descriptor length */
+	sa->job_desc_len = job_desc_len;
+
+	/* Set lifetime counter stats offset */
+	sa->stats_offset = sa->stats_indx * sizeof(uint32_t);
+
+	ret = built_encap_extra_material(sa, auth_key_dma, crypto_key_dma, 64);
+	if (ret < 0) {
+		pr_err("Failed to create extra CAAM commands\n");
+		return -EAGAIN;
+	}
+
+	extra_cmds = sa->sec_desc_extra_cmds - 1;
+	extra_cmds_len = desc_len(extra_cmds) - 1;
+
+	/* get the jr device  */
+	jrdev = get_jrdev();
+	if (!jrdev) {
+		pr_err("Failed to get the job ring device, check the dts\n");
+		return -EINVAL;
+	}
+
+	dma_extra_cmds = dma_map_single(jrdev, sa->sec_desc_extra_cmds,
+					extra_cmds_len * sizeof(uint32_t),
+					DMA_TO_DEVICE);
+	if (!dma_extra_cmds) {
+		pr_err("Could not DMA map extra CAAM commands\n");
+		return -ENXIO;
+	}
+
+	init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL,
+			 (sa->next_cmd_indx - 1) * sizeof(uint32_t));
+
+	if (sec_era == 2) {
+		/* disable iNFO FIFO entries for p4080rev2 & ??? */
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 * Offset refers to SRC
+		 */
+		opt   = MOVE_SRC_MATH3 | MOVE_DEST_CLASS1INFIFO;
+		off_b = 127 << MOVE_OFFSET_SHIFT;
+		len   = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off_b | len);
+
+		/*
+		 * L2 part 1
+		 * Load from input packet to INPUT DATA FIFO first bytes_to_copy
+		 * bytes.
+		 */
+		append_seq_fifo_load(desc, bytes_to_copy, FIFOLD_TYPE_MSG |
+				     FIFOLD_CLASS_BOTH | FIFOLD_TYPE_LAST1 |
+				     FIFOLD_TYPE_LAST2 | FIFOLD_TYPE_FLUSH1);
+
+		/*
+		 * Extra word part 1
+		 * Load extra words for this descriptor into the INPUT DATA FIFO
+		 */
+		append_fifo_load(desc, dma_extra_cmds,
+				 extra_cmds_len * sizeof(uint32_t),
+				 FIFOLD_TYPE_MSG | FIFOLD_CLASS_BOTH |
+				 FIFOLD_TYPE_LAST1 | FIFOLD_TYPE_LAST2 |
+				 FIFOLD_TYPE_FLUSH1);
+
+		/* enable iNFO FIFO entries */
+		append_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);
+	} else {
+		/* ????? */
+		opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | opt | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 */
+		opt   = MOVE_SRC_MATH3 | MOVE_DEST_INFIFO;
+		off_b = 127 << MOVE_OFFSET_SHIFT;
+		len   = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off_b | len);
+
+		/*
+		 * L2 part 1
+		 * Load from input packet to INPUT DATA FIFO first bytes_to_copy
+		 * bytes. No information FIFO entry even if automatic
+		 * iNformation FIFO entries are enabled.
+		 */
+		append_seq_fifo_load(desc, bytes_to_copy, FIFOLD_CLASS_BOTH |
+				     FIFOLD_TYPE_NOINFOFIFO);
+
+		/*
+		 * Extra word part 1
+		 * Load extra words for this descriptor into the INPUT DATA FIFO
+		 */
+		append_fifo_load(desc, dma_extra_cmds,
+				 extra_cmds_len * sizeof(uint32_t),
+				 FIFOLD_CLASS_BOTH | FIFOLD_TYPE_NOINFOFIFO);
+	}
+
+	/*
+	 * throw away the first part of the S/G table and keep only the buffer
+	 * address;
+	 * offset = undefined memory after MATH3; Refers to the destination.
+	 * len = 41 bytes to discard
+	 */
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_MATH3;
+	off_b = 8 << MOVE_OFFSET_SHIFT;
+	len   = 41 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off_b | len);
+
+	/* put the buffer address (still in the IN FIFO) in MATH2 */
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_MATH3;
+	off_b = 0 << MOVE_OFFSET_SHIFT;
+	len   = 8 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off_b | len);
+
+	/* copy 15 bytes starting at 4 bytes before the OUT-PTR-CMD in
+	 * the job-desc into math1
+	 * i.e. in the low-part of math1 we have the out-ptr-cmd and
+	 * in the math2 we will have the address of the out-ptr
+	 */
+	opt = MOVE_SRC_DESCBUF | MOVE_DEST_MATH1;
+	off_b = (MAX_CAAM_DESCSIZE - job_desc_len + PTR_LEN) * sizeof(uint32_t);
+	len = (8 + 4 * PTR_LEN - 1) << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Copy 7 bytes of the in-ptr into math0 */
+	opt   = MOVE_SRC_DESCBUF | MOVE_DEST_MATH0;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len + 1 + 3 + 2 * PTR_LEN;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * the SEQ OUT PTR command is now in math reg 1, so the SGF bit can be
+	 * checked using a math command;
+	 */
+	sg_mask = SEQ_OUT_PTR_SGF_MASK;
+	append_math_and_imm_u32(desc, NONE, REG1, IMM, sg_mask);
+
+	opt = CLASS_NONE | JUMP_TYPE_LOCAL | JUMP_COND_MATH_Z | JUMP_TEST_ALL;
+	no_sg_jump = append_jump(desc, opt);
+
+	append_math_add(desc, REG2, ZERO, REG3, MATH_LEN_8BYTE);
+
+	/* update no S/G jump location */
+	set_jump_tgt_here(desc, no_sg_jump);
+
+	/* seqfifostr: msgdata len=4 */
+	append_seq_fifo_store(desc, FIFOST_TYPE_MESSAGE_DATA, bytes_to_copy);
+
+	/* move: ififo->deco-alnblk -> ofifo, len=4 */
+	append_move(desc, MOVE_SRC_INFIFO | MOVE_DEST_OUTFIFO | bytes_to_copy);
+
+	/* Overwrite the job-desc location (word 51 or 53) with the first
+	 * group (11 words)*/
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_DESCBUF;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = (11 * sizeof(uint32_t)) << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * Copy the context of math0 (input address) to words 52+53 or 54+56
+	 * depending where the Job Descriptor starts.
+	 * They will be used later by the load command.
+	 */
+	opt = MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len + 1; /* 52 + 53 or 54 + 55 */
+	off_b = off_w * sizeof(uint32_t);
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * Copy the context of math2 (output address) to words 56+57 or 58+59
+	 * depending where the Job Descriptor starts.
+	 * They will be used later by the store command.
+	 */
+	opt = MOVE_SRC_MATH2 | MOVE_DEST_DESCBUF;
+	off_w = MAX_CAAM_DESCSIZE - job_desc_len + 5; /* 56 + 57 or 58 + 59 */
+	off_b = off_w * sizeof(uint32_t);
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Fix LIODN - OFFSET[0:1] - 01 = SEQ LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off_b = 0x40; /* SEQ LIODN */
+	append_cmd(desc, CMD_LOAD | opt | (off_b << LDST_OFFSET_SHIFT));
+
+	/* Copy the context of the counters from word 29 into math0 */
+	/* Copy from descriptor to MATH REG 0 the current statistics */
+	stats_off_b = sa->stats_indx * CAAM_CMD_SZ;
+	append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 |
+		    (stats_off_b << MOVE_OFFSET_SHIFT) | sizeof(uint64_t));
+
 	return 0;
 }
 
+int build_extended_decap_shared_descriptor(struct dpa_ipsec_sa *sa,
+					   dma_addr_t auth_key_dma,
+					   dma_addr_t crypto_key_dma,
+					   uint8_t bytes_to_copy,
+					   uint8_t move_size,
+					   int sec_era)
+{
+	uint32_t *desc, *no_sg_jump, *extra_cmds;
+	uint32_t len, off_b, off_w, opt, stats_off_b, sg_mask, extra_cmds_len,
+		 esp_length, iv_length, icv_length, max_pad, data;
+	dma_addr_t dma_extra_cmds;
+	struct device *jrdev;
+	int ret;
+
+	desc = (uint32_t *)sa->sec_desc->desc;
+
+	/* CAAM hdr cmd + PDB size in words */
+	sa->next_cmd_indx =
+		sizeof(struct ipsec_decap_pdb) / sizeof(uint32_t) + 1;
+	if (sa->enable_stats) {
+		sa->stats_indx = sa->next_cmd_indx;
+		sa->next_cmd_indx += 2;
+		if (sec_era != 2) {
+			sa->stats_indx += 1;
+			sa->next_cmd_indx += 1;
+		}
+	}
+
+	/* Set lifetime counter stats offset */
+	sa->stats_offset = sa->stats_indx * sizeof(uint32_t);
+
+	ret = built_decap_extra_material(sa, auth_key_dma, crypto_key_dma);
+	if (ret < 0) {
+		pr_err("Failed to create extra CAAM commands\n");
+		return -EAGAIN;
+	}
+
+	extra_cmds = sa->sec_desc_extra_cmds - 1;
+	extra_cmds_len = desc_len(extra_cmds) - 1;
+
+	/* get the jr device  */
+	jrdev = get_jrdev();
+	if (!jrdev) {
+		pr_err("Failed to get the job ring device, check the dts\n");
+		return -EINVAL;
+	}
+
+	dma_extra_cmds = dma_map_single(jrdev, sa->sec_desc_extra_cmds,
+					extra_cmds_len * sizeof(uint32_t),
+					DMA_TO_DEVICE);
+	if (!dma_extra_cmds) {
+		pr_err("Could not DMA map extra CAAM commands\n");
+		return -ENXIO;
+	}
+
+	init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL,
+			 (sa->next_cmd_indx - 1) * sizeof(uint32_t));
+
+	if (sec_era == 2) {
+		/* disable iNFO FIFO entries for p4080rev2 & ??? */
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 * Offset refers to SRC
+		 */
+		opt   = MOVE_SRC_MATH3 | MOVE_DEST_CLASS1INFIFO;
+		off_b = 127 << MOVE_OFFSET_SHIFT;
+		len   = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off_b | len);
+
+		/*
+		 * L2 part 1
+		 * Load from input packet to INPUT DATA FIFO first bytes_to_copy
+		 * bytes.
+		 */
+		append_seq_fifo_load(desc, bytes_to_copy, FIFOLD_TYPE_MSG |
+				     FIFOLD_CLASS_BOTH | FIFOLD_TYPE_LAST1 |
+				     FIFOLD_TYPE_LAST2 | FIFOLD_TYPE_FLUSH1);
+
+		/*
+		 * Extra word part 1
+		 * Load extra words for this descriptor into the INPUT DATA FIFO
+		 */
+		append_fifo_load(desc, dma_extra_cmds,
+				 extra_cmds_len * sizeof(uint32_t),
+				 FIFOLD_TYPE_MSG | FIFOLD_CLASS_BOTH |
+				 FIFOLD_TYPE_LAST1 | FIFOLD_TYPE_LAST2 |
+				 FIFOLD_TYPE_FLUSH1);
+
+		/* enable iNFO FIFO entries */
+		append_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);
+	} else {
+		/* ????? */
+		opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | opt | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 */
+		opt   = MOVE_SRC_MATH3 | MOVE_DEST_INFIFO;
+		off_b = 127 << MOVE_OFFSET_SHIFT;
+		len   = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off_b | len);
+
+		/*
+		 * L2 part 1
+		 * Load from input packet to INPUT DATA FIFO first bytes_to_copy
+		 * bytes. No information FIFO entry even if automatic
+		 * iNformation FIFO entries are enabled.
+		 */
+		append_seq_fifo_load(desc, bytes_to_copy, FIFOLD_CLASS_BOTH |
+				     FIFOLD_TYPE_NOINFOFIFO);
+
+		/*
+		 * Extra word part 1
+		 * Load extra words for this descriptor into the INPUT DATA FIFO
+		 */
+		append_fifo_load(desc, dma_extra_cmds,
+				 extra_cmds_len * sizeof(uint32_t),
+				 FIFOLD_CLASS_BOTH | FIFOLD_TYPE_NOINFOFIFO);
+	}
+
+	/*
+	 * throw away the first part of the S/G table and keep only the buffer
+	 * address;
+	 * offset = undefined memory after MATH3; Refers to the destination.
+	 * len = 41 bytes to discard
+	 */
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_MATH3;
+	off_b = 8 << MOVE_OFFSET_SHIFT;
+	len   = 41 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off_b | len);
+
+	/* put the buffer address (still in the IN FIFO) in MATH2 */
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_MATH3;
+	off_b = 0 << MOVE_OFFSET_SHIFT;
+	len   = 8 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off_b | len);
+
+	/*
+	 * Copy 15 bytes starting at 4 bytes before the OUT-PTR-CMD in
+	 * the job-desc into math1
+	 * i.e. in the low-part of math1 we have the out-ptr-cmd and
+	 * in the math2 we will have the address of the out-ptr
+	 */
+	opt = MOVE_SRC_DESCBUF | MOVE_DEST_MATH1;
+	off_b = (50 + 1 * PTR_LEN) * sizeof(uint32_t);
+	len = (8 + 4 * PTR_LEN - 1) << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Copy 7 bytes of the in-ptr into math0 */
+	opt   = MOVE_SRC_DESCBUF | MOVE_DEST_MATH0;
+	off_w = 50 + 1 + 3 + 2 * PTR_LEN;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * the SEQ OUT PTR command is now in math reg 1, so the SGF bit can be
+	 * checked using a math command;
+	 */
+	sg_mask = SEQ_OUT_PTR_SGF_MASK;
+	append_math_and_imm_u32(desc, NONE, REG1, IMM, sg_mask);
+
+	opt = CLASS_NONE | JUMP_TYPE_LOCAL | JUMP_COND_MATH_Z | JUMP_TEST_ALL;
+	no_sg_jump = append_jump(desc, opt);
+
+	append_math_add(desc, REG2, ZERO, REG3, MATH_LEN_8BYTE);
+
+	/* update no S/G jump location */
+	set_jump_tgt_here(desc, no_sg_jump);
+
+	/* seqfifostr: msgdata len=4 */
+	append_seq_fifo_store(desc, FIFOST_TYPE_MESSAGE_DATA, bytes_to_copy);
+
+	/* move: ififo->deco-alnblk -> ofifo, len=4 */
+	append_move(desc, MOVE_SRC_INFIFO | MOVE_DEST_OUTFIFO | bytes_to_copy);
+
+	/* Overwrite the job-desc location (word 50) with the first
+	 * group (10 words)*/
+	opt   = MOVE_SRC_INFIFO | MOVE_DEST_DESCBUF;
+	off_w = 50;
+	off_b = off_w * sizeof(uint32_t); /* calculate off in bytes */
+	len   = (10 * sizeof(uint32_t)) << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * Copy the context of math0 (input address) to words 32+33
+	 * They will be used later by the load command.
+	 */
+	opt = MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF;
+	off_w = 32;
+	off_b = off_w * sizeof(uint32_t);
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/*
+	 * Copy the context of math2 (output address) to words 56+57 or 58+59
+	 * depending where the Job Descriptor starts.
+	 * They will be used later by the store command.
+	 */
+	opt = MOVE_SRC_MATH2 | MOVE_DEST_DESCBUF | MOVE_WAITCOMP;
+	off_w = 36;
+	off_b = off_w * sizeof(uint32_t);
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | (off_b << MOVE_OFFSET_SHIFT) | len);
+
+	/* Fix LIODN - OFFSET[0:1] - 01 = SEQ LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off_b = 0x40; /* SEQ LIODN */
+	append_cmd(desc, CMD_LOAD | opt | (off_b << LDST_OFFSET_SHIFT));
+
+	/* Load from the input address 64 bytes into internal register */
+	/* load the data to be moved - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off_b = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_load(desc, DUMMY_PTR_VAL, len, opt | off_b);
+
+	/* Wait to finish previous operation */
+	opt = JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT);
+	append_jump(desc, opt);
+
+	/* Store the data to the output FIFO - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off_b = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_store(desc, DUMMY_PTR_VAL, len, opt | off_b);
+
+	/* Fix LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off_b = 0x80 << LDST_OFFSET_SHIFT; /* NON_SEQ LIODN */
+	append_cmd(desc, CMD_LOAD | opt | off_b);
+
+	/* Copy from descriptor to MATH REG 0 the current statistics */
+	stats_off_b = sa->stats_indx * CAAM_CMD_SZ;
+	append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | MOVE_WAITCOMP |
+		    (stats_off_b << MOVE_OFFSET_SHIFT) | sizeof(uint64_t));
+
+	/* Remove unnecessary headers
+	 * MATH1 = 0 - (esp_length + iv_length + icv_length) */
+	esp_length = 8; /* SPI + SEQ NUM */
+	get_cipher_params(sa->alg_suite, &iv_length, &icv_length, &max_pad);
+	data = (uint32_t) (esp_length + iv_length + icv_length);
+	append_math_sub_imm_u64_ifb(desc, REG1, ZERO, IMM, data);
+
+	/* MATH1 += SIL (bytes counter) */
+	append_math_add(desc, REG1, SEQINLEN, REG1, MATH_LEN_8BYTE);
+
+	/* data = outer IP header - should be read from DPOVRD register
+	 * MATH 2 = outer IP header length */
+	data = 20;
+	opt = LDST_CLASS_DECO | LDST_SRCDST_WORD_DECO_MATH2;
+	len = sizeof(data) << LDST_LEN_SHIFT;
+	append_load_as_imm(desc, &data, len, opt);
+
+	off_w = 7;
+	append_jump(desc, (off_w << JUMP_OFFSET_SHIFT));
+
+	/* jump: all-match[] always-jump offset=0 local->[00] */
+	append_jump(desc, (0 << JUMP_OFFSET_SHIFT));
+
+	/* jump: all-match[] always-jump offset=0 local->[00] */
+	append_jump(desc, (0 << JUMP_OFFSET_SHIFT));
+
+	data = 0x00ff0000;
+	append_math_and_imm_u64_ifb(desc, REG2, DPOVRD, IMM, data);
+
+	return 0;
+}
+
+
 int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 {
 	struct sec_descriptor *sec_desc;
 	struct device *jrdev;
 	dma_addr_t auth_key_dma;
 	dma_addr_t crypto_key_dma;
+	int ret = 0;
 
 	/* get the jr device  */
 	jrdev = get_jrdev();
 	if (!jrdev) {
-		pr_err("Failed to get the job ring devic, check the dts\n");
+		pr_err("Failed to get the job ring device, check the dts\n");
 		return -EINVAL;
 	}
 
@@ -546,10 +1437,42 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 		return -EINVAL;
 	}
 
-	/* build the shared descriptor */
-	build_shared_descriptor(sa, auth_key_dma, crypto_key_dma,
-				sa->l2_hdr_size);
+	/*
+	 * Build the shared descriptor and see if its length is less than
+	 * 64 words. If build_shared_descriptor returns -EPERM than it is
+	 * required to build the extended shared descriptor in order to have
+	 * all the SA features that were required.
+	 */
+	ret = build_shared_descriptor(sa, auth_key_dma, crypto_key_dma,
+				      sa->l2_hdr_size);
+	switch (ret) {
+	case 0:
+		sa->sec_desc_extended = false;
+		goto done_shared_desc;
+	case -EPERM:
+		sa->sec_desc_extended = true;
+		goto build_extended_shared_desc;
+	default:
+		pr_err("Failed to create SEC descriptor for SA %d\n", sa->id);
+		return -EFAULT;
+	}
+
+build_extended_shared_desc:
+	/* Build the extended shared descriptor */
+	if (sa->sa_dir == DPA_IPSEC_INBOUND)
+		ret = build_extended_decap_shared_descriptor(sa, auth_key_dma,
+				crypto_key_dma, sa->l2_hdr_size, 64,
+				sa->dpa_ipsec->sec_era);
+	else
+		ret = build_extended_encap_shared_descriptor(sa, auth_key_dma,
+				crypto_key_dma, sa->l2_hdr_size,
+				sa->dpa_ipsec->sec_era);
+	if (ret < 0) {
+		pr_err("Failed to create SEC descriptor for SA %d\n", sa->id);
+		return -EFAULT;
+	}
 
+done_shared_desc:
 	sec_desc = sa->sec_desc;
 	/* setup preheader */
 	sec_desc->preheader.hi.field.idlen = desc_len((u32 *) sec_desc->desc);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index bd1c11d..0d58dfe 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -37,6 +37,9 @@
 #include "desc_constr.h"
 
 #define DPA_IPSEC_STATS_LEN	2	/* length in words */
+#define MAX_CAAM_SHARED_DESCSIZE 50	/* If CAAM used with QI the maximum
+					 * shared descriptor length is 50 words
+					 */
 
 /* preheader */
 struct preheader {
-- 
1.7.5.4

