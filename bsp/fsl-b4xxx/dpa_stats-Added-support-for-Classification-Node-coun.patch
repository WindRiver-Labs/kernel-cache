From 2fc7829af95c1134a2acd40f82b4c1dbc74e3b03 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:57:11 +0000
Subject: [PATCH 257/518] dpa_stats: Added support for Classification Node
 counter

Added support for Classification Node single and class counter.
Application can use this counter to retrieve statistics for one
or multiple entries of a Classification node.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  158 +++++++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_stats.h |   10 ++
 include/linux/fsl_dpa_stats.h               |   44 ++++++++
 3 files changed, 212 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index b699877..504826b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -843,6 +843,62 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_classif_cb *cnt_ccnode_cb = &cnt_cb->ccnode_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_stats_cnt_classif_node classif = params->classif_node_params;
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t cnt_sel = classif.cnt_sel;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Classification Cc Node counter selection */
+	if ((cnt_sel == 0) ||  (cnt_sel > DPA_STATS_CNT_CLASSIF_RANGE10) ||
+		((cnt_sel >= DPA_STATS_CNT_CLASSIF_RANGE1) &&
+		(cnt_sel & DPA_STATS_CNT_CLASSIF_PACKETS))) {
+		pr_err("Invalid Classif_Node counter selection");
+		return -EINVAL;
+	}
+
+	/* Copy the key descriptor */
+	err = copy_key_descriptor(&classif.key, &cnt_ccnode_cb->keys[0]);
+	if (err != 0) {
+		pr_err("Unable to copy key descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Store CcNode handle and set number of keys to one */
+	cnt_ccnode_cb->cc_node = classif.cc_node;
+	cnt_ccnode_cb->keys_num = 1;
+
+	/* Check the Classifier Node counter parameters */
+	err = FM_PCD_MatchTableFindNGetKeyStatistics(
+			cnt_ccnode_cb->cc_node,
+			cnt_ccnode_cb->keys[0].size,
+			cnt_ccnode_cb->keys[0].byte,
+			cnt_ccnode_cb->keys[0].mask, &stats);
+	if (err != 0) {
+		pr_err("Invalid Classif Node counter parameters\n");
+		return -EINVAL;
+	}
+
+	/* Map Classif Node counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_ccnode_cb->info,
+		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+		(cnt_sel >> CLASSIF_STATS_SHIFT));
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_ccnode_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -1212,6 +1268,65 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_classif_cb *cnt_ccnode_cb = &cnt_cb->ccnode_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_stats_cls_cnt_classif_node prm = params->classif_node_params;
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t cnt_sel = prm.cnt_sel;
+	uint32_t i = 0;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Classification Cc Node counter selection */
+	if ((cnt_sel == 0) ||  (cnt_sel > DPA_STATS_CNT_CLASSIF_RANGE10) ||
+		((cnt_sel >= DPA_STATS_CNT_CLASSIF_RANGE1) &&
+		(cnt_sel & DPA_STATS_CNT_CLASSIF_PACKETS))) {
+		pr_err("Invalid Classif_Node counter selection");
+		return -EINVAL;
+	}
+
+	cnt_ccnode_cb->cc_node = prm.cc_node;
+	cnt_ccnode_cb->keys_num = params->class_members;
+
+	for (i = 0; i < params->class_members; i++) {
+		/* Copy the key descriptor */
+		err = copy_key_descriptor(&prm.keys[i],
+				&cnt_ccnode_cb->keys[i]);
+		if (err != 0) {
+			pr_err("Unable to copy key descriptor\n");
+			return -EINVAL;
+		}
+
+		/* Check the Classifier Node counter parameters */
+		err = FM_PCD_MatchTableFindNGetKeyStatistics(
+				cnt_ccnode_cb->cc_node,
+				cnt_ccnode_cb->keys[i].size,
+				cnt_ccnode_cb->keys[i].byte,
+				cnt_ccnode_cb->keys[i].mask, &stats);
+		if (err != 0) {
+			pr_err("Invalid Classif Node counter parameters\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Map Classif Node counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_ccnode_cb->info,
+		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+		(cnt_sel >> CLASSIF_STATS_SHIFT));
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_ccnode_cb->keys_num *
+			STATS_VAL_SIZE * cnt_ccnode_cb->info.stats_num;
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -1417,6 +1532,31 @@ static int get_cnt_cls_tbl_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	t_FmPcdCcKeyStatistics stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->ccnode_cb.keys_num; i++) {
+		err = FM_PCD_MatchTableFindNGetKeyStatistics(
+				cnt_cb->ccnode_cb.cc_node,
+				cnt_cb->ccnode_cb.keys[i].size,
+				cnt_cb->ccnode_cb.keys[i].byte,
+				cnt_cb->ccnode_cb.keys[i].mask, &stats);
+		if (err != 0) {
+			pr_err("Couldn't retrieve Classif Node statistics\n");
+			return -ENXIO;
+		}
+
+		get_cnt_32bit_stats(req_cb,
+				&cnt_cb->ccnode_cb.info, (void *)&stats, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -1552,6 +1692,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 		break;
+	case DPA_STATS_CNT_CLASSIF_NODE:
+		err = set_cnt_ccnode_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Classif Cc Node counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -1658,6 +1807,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_TBL;
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_stats;
 		break;
+	case DPA_STATS_CNT_CLASSIF_NODE:
+		err = set_cls_cnt_ccnode_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Classif Cc Node counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
+		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index 0d05627..9f155c7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -108,6 +108,15 @@ struct dpa_stats_cnt_classif_tbl_cb {
 	struct stats_info info; /* Counter's statistics information */
 };
 
+/* DPA Stats Classif Node control block */
+struct dpa_stats_cnt_classif_cb {
+	void *cc_node;  /* Handle of Cc Node the lookup keys belong to */
+	struct dpa_offload_lookup_key keys[MAX_NUM_OF_MEMBERS]; /* Array of
+			 key descriptors for which to provide statistics */
+	unsigned int keys_num; /* Number of keys descriptors */
+	struct stats_info info;  /* Counter's statistics information */
+};
+
 typedef int get_cnt_stats(struct dpa_stats_req_cb *req_cb,
 					struct dpa_stats_cnt_cb *cnt_cb);
 
@@ -121,6 +130,7 @@ struct dpa_stats_cnt_cb {
 	union {
 		struct dpa_stats_cnt_gen_cb gen_cb;
 		struct dpa_stats_cnt_classif_tbl_cb tbl_cb;
+		struct dpa_stats_cnt_classif_cb ccnode_cb;
 	};
 	get_cnt_stats *f_get_cnt_stats; /* Function used to retrieve the
 				statistics for a specific counter */
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 470f538..0991a44 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -347,6 +347,25 @@ struct dpa_stats_cnt_classif_tbl {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Classification Node parameters */
+struct dpa_stats_cnt_classif_node {
+	/*
+	 * Handle of the FMAN Cc node, more precisely handle of
+	 * the classification element previously created in the
+	 * distribution XML file
+	 */
+	void *cc_node;
+
+	/* Key to identify a specific entry */
+	struct dpa_offload_lookup_key key;
+
+	/*
+	 * Single or multiple selection of Classifier
+	 * counters from enum: dpa_stats_cnt_classif_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -368,6 +387,9 @@ struct dpa_stats_cnt_params {
 
 		/* Parameters for Classification Table counter */
 		struct dpa_stats_cnt_classif_tbl classif_tbl_params;
+
+		/* Parameters for Classification Node counter */
+		struct dpa_stats_cnt_classif_node classif_node_params;
 	};
 };
 
@@ -475,6 +497,25 @@ struct dpa_stats_cls_cnt_classif_tbl {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Classification Node class counter parameters */
+struct dpa_stats_cls_cnt_classif_node {
+	/*
+	 * Handle of the FMAN Cc node, more precisely handle of
+	 * the classification element previously created in the
+	 * distribution XML file
+	 */
+	void *cc_node;
+
+	/* Array of keys to identify specific entries */
+	struct dpa_offload_lookup_key *keys;
+
+	/*
+	 * Single or multiple selection of Classifier counters
+	 * from enum dpa_stats_cnt_classif_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -499,6 +540,9 @@ struct dpa_stats_cls_cnt_params {
 
 		/* Parameters for Classifier Table class counter */
 		struct dpa_stats_cls_cnt_classif_tbl classif_tbl_params;
+
+		/* Parameters for Classification Node class counter */
+		struct dpa_stats_cls_cnt_classif_node classif_node_params;
 	};
 };
 
-- 
1.7.5.4

