From 83552757e3e8edb62b1818bef6094b74bfe3b1b1 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 18 May 2012 20:52:02 +0000
Subject: [PATCH 169/518] Made dpa_ipsec_sa_rekeying function SMP safe

locking rule: always acquire parent SA before child SA
added validity check to see if the SA is not currently in
rekeying process
always add to the tail of rekeying list.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Acked-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   65 ++++++++++++++++++++++-----
 1 files changed, 53 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index f3ab773..97ad4c4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -3197,7 +3197,6 @@ static inline int sa_currently_in_rekeying(struct dpa_ipsec_sa *sa)
  *	- if both parent SA and child SA are in invalid state, some or none of
  *	  the old's policies were safely transfered to the child SA but some
  *	  policies remained offloaded through parent SA.
- *
  */
 int dpa_ipsec_sa_rekeying(int sa_id,
 			  struct dpa_ipsec_sa_params *sa_params,
@@ -3236,10 +3235,18 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		return -EINVAL;
 	}
 
+	/* Acquire parent SA's lock */
+	err = mutex_trylock(&old_sa->lock);
+	if (err == 0) {
+		xx_pr_err("SA %d is being used\n", old_sa->id);
+		return -EBUSY;
+	}
+
 	/* Check if SA is currently in rekeying process */
 	if (sa_currently_in_rekeying(old_sa)) {
 		xx_pr_err("SA with id %d is already in rekeying process\n",
 			  old_sa->id);
+		mutex_unlock(&old_sa->lock);
 		return -EEXIST;
 	}
 
@@ -3247,27 +3254,36 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	if (old_sa->sa_dir != sa_params->sa_dir) {
 		xx_pr_err("New SA parameters don't match the parent SA %d\n",
 			  old_sa->sa_dir);
+		mutex_unlock(&old_sa->lock);
 		return -EINVAL;
 	}
 
 	err = get_new_sa(dpa_ipsec, &new_sa, &id);
 	if (err < 0) {
 		xx_pr_err("Failed retrieving a preallocated SA\n");
+		mutex_unlock(&old_sa->lock);
 		return err;
 	}
 
 	/* Update the new SA structure */
+	mutex_lock(&new_sa->lock);
 	new_sa->dpa_ipsec = old_sa->dpa_ipsec;
 	new_sa->inbound_flowid = old_sa->inbound_flowid;
 	new_sa->inbound_indx_entry = -1;
 	new_sa->rekey_event_cb = rekey_event_cb;
-
-	/* Set its parent */
-	new_sa->parent_sa = old_sa;
-	new_sa->child_sa  = NULL;
-	/* AV's note TODO: acquire lock for old SA */
-	old_sa->child_sa  = new_sa;
-	/* release lock */
+	if (auto_rmv_old_sa) {
+		new_sa->parent_sa = old_sa;
+		new_sa->child_sa  = NULL;
+			new_sa->sa_rekeying_node.next = LIST_POISON1;
+			new_sa->sa_rekeying_node.prev = LIST_POISON2;
+		old_sa->child_sa  = new_sa;
+			old_sa->parent_sa = NULL;
+	} else {
+		new_sa->parent_sa = NULL;
+		new_sa->child_sa  = NULL;
+		old_sa->child_sa  = NULL;
+		old_sa->parent_sa = NULL;
+	}
 
 	/* Copy SA params into the internal SA structure */
 	if (old_sa->sa_dir == DPA_IPSEC_OUTBOUND)
@@ -3305,7 +3321,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	jiffies_to_wait = timeval_to_jiffies(&timeval);
 
 	/* AV's note: Since we have reused the FROM SEC FQ it is not needed to
-	 * make another entry in the PCD node of the post encryption OH PORT. */
+	 * make another entry in the table of the post SEC OH PORT. */
 	if (new_sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		INIT_LIST_HEAD(&new_sa->policy_headlist);
 
@@ -3321,6 +3337,17 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 				 * using remove_sa */
 				*new_sa_id = new_sa->id;
 				xx_pr_err("Could't modify outbound policy\n");
+				new_sa->parent_sa = NULL;
+				new_sa->child_sa  = NULL;
+				old_sa->child_sa  = NULL;
+				old_sa->parent_sa = NULL;
+				/*
+				 * AV's note TODO: investigate the removal of FQ
+				 * to SEC even is it has frames in it and is in
+				 * parked state
+				 */
+				mutex_unlock(&new_sa->lock);
+				mutex_unlock(&old_sa->lock);
 				return -EUSERS;
 			}
 			list_del(&policy_entry->node);
@@ -3330,8 +3357,12 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		/* Need to destroy the old SA. Have to wail until its TO SEC
 		 * FQ is empty. This is done in work queue, schedule it. */
 		sa_mng = &dpa_ipsec->sa_mng;
-		list_add(&new_sa->sa_rekeying_node,
+
+		mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+		list_add_tail(&new_sa->sa_rekeying_node,
 			 &sa_mng->sa_rekeying_headlist);
+		mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
+
 		queue_delayed_work(sa_mng->sa_rekeying_wq,
 				   &sa_mng->sa_rekeying_work,
 				   jiffies_to_wait);
@@ -3346,8 +3377,10 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		if (auto_rmv_old_sa) {
 			sa_mng = &dpa_ipsec->sa_mng;
 			/* Add new SA into the sa_rekeying_headlist */
-			list_add(&new_sa->sa_rekeying_node,
+			mutex_lock(&sa_mng->sa_rekeying_headlist_lock);
+			list_add_tail(&new_sa->sa_rekeying_node,
 				 &sa_mng->sa_rekeying_headlist);
+			mutex_unlock(&sa_mng->sa_rekeying_headlist_lock);
 
 			/* schedule inbound SA's rekeying */
 			queue_delayed_work(sa_mng->sa_rekeying_wq,
@@ -3362,13 +3395,18 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 			 * can be several seconds it is required to schedule the
 			 * TO SEC FQ of the new SA. */
 			err = qman_schedule_fq(new_sa->to_sec_fq);
-			if (err < 0)
+			if (err < 0) {
+				mutex_unlock(&new_sa->lock);
+				mutex_unlock(&old_sa->lock);
 				return err;
 		}
 	}
+	}
 
 	/* Rekeying done ok. */
 	*new_sa_id = new_sa->id;
+	mutex_unlock(&new_sa->lock);
+	mutex_unlock(&old_sa->lock);
 
 	return 0;
 
@@ -3387,6 +3425,9 @@ rekey_sa_err:
 	if (err_rb < 0)
 		*new_sa_id = new_sa->id;
 
+	mutex_unlock(&new_sa->lock);
+	mutex_unlock(&old_sa->lock);
+
 	return err;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_rekeying);
-- 
1.7.5.4

