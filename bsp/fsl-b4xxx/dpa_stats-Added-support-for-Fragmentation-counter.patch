From d407acead4fa2362f53183e54e7245a9dab220d7 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:55:04 +0000
Subject: [PATCH 254/518] dpa_stats: Added support for Fragmentation counter

Added support for Fragmentation single and class counter.
Application can use this counter to retrieve
statistics for the IP fragmentation mechanism

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  147 +++++++++++++++++++++++++++
 include/linux/fsl_dpa_stats.h               |   42 ++++++++
 2 files changed, 189 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 459c176..cc1f93b 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -382,6 +382,21 @@ static void create_cnt_reass_stats(struct dpa_stats *dpa_stats)
 			(void *)&stats;
 }
 
+static void create_cnt_frag_stats(struct dpa_stats *dpa_stats)
+{
+	struct t_FmPcdManipFragIpStats stats;
+
+	/* DPA_STATS_CNT_FRAG_TOTAL_FRAMES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_FRAG][0] =
+			(void *)&stats.totalFrames - (void *)&stats;
+	/* DPA_STATS_CNT_FRAG_FRAMES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_FRAG][1] =
+			(void *)&stats.fragmentedFrames - (void *)&stats;
+	/* DPA_STATS_CNT_FRAG_GEN_FRAGS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_FRAG][2] =
+			(void *)&stats.generatedFragments - (void *)&stats;
+}
+
 static t_Handle get_fman_ethernet_dev_node(
 		struct device_node *parent_dev_node, int port_id)
 {
@@ -581,6 +596,49 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	uint32_t cnt_sel = params->frag_params.cnt_sel;
+	struct t_FmPcdManipStats stats;
+	int err;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Fragmentation counter selection */
+	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_FRAG_ALL)) {
+		pr_err("Invalid Fragmentation counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs[0] = params->frag_params.frag;
+	cnt_gen_cb->objs_num = 1;
+
+	/* Check the user-provided fragmentation handle */
+	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
+	if (err < 0) {
+		pr_err("Invalid Fragmentation manip handle\n");
+		return -EINVAL;
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
+		cnt_sel -= 1;
+
+	/* Map Fragmentation counter selection to Manip statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -697,6 +755,53 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_gen_cb *cnt_gen_cb = &cnt_cb->gen_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct t_FmPcdManipStats stats;
+	uint32_t cnt_sel = params->frag_params.cnt_sel;
+	uint32_t i = 0;
+	int err;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Check Fragmentation counter selection */
+	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_FRAG_ALL)) {
+		pr_err("Invalid Fragmentation counter selection");
+		return -EINVAL;
+	}
+
+	cnt_gen_cb->objs_num = params->class_members;
+
+	for (i = 0; i < params->class_members; i++) {
+		cnt_gen_cb->objs[i] = params->frag_params.frag;
+
+		/* Check the user-provided fragmentation handle */
+		err = FM_PCD_ManipGetStatistics(cnt_gen_cb->objs[i], &stats);
+		if (err < 0) {
+			pr_err("Invalid Fragmentation manip handle\n");
+			return -EINVAL;
+		}
+	}
+
+	if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
+		cnt_sel -= 1;
+
+	/* Map Fragmentation counter selection to Manip statistics */
+	cnt_sel_to_stats(&cnt_gen_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_gen_cb->objs_num *
+				STATS_VAL_SIZE * cnt_gen_cb->info.stats_num;
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -808,6 +913,27 @@ static int get_cnt_reass_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct t_FmPcdManipStats stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->gen_cb.objs_num; i++) {
+		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
+		if (err < 0) {
+			pr_err("Couldn't retrieve Fragmentation statistics\n");
+			return -EINTR;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->gen_cb.info,
+				&stats.u.frag.u.ipFrag, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -851,6 +977,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map Reassembly counters to FMAN Reassembly statistics */
 	create_cnt_reass_stats(dpa_stats);
 
+	/* Map Fragmentation counters to FMAN Fragmentation statistics */
+	create_cnt_frag_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -907,6 +1036,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_REASS;
 		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
 		break;
+	case DPA_STATS_CNT_FRAG:
+		err = set_cnt_frag_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Fragmentation counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_FRAG;
+		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -986,6 +1124,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_REASS;
 		cnt_cb->f_get_cnt_stats = get_cnt_reass_stats;
 		break;
+	case DPA_STATS_CNT_FRAG:
+		err = set_cls_cnt_frag_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create Fragmentation counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_FRAG;
+		cnt_cb->f_get_cnt_stats = get_cnt_frag_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 764e37d..1c518f4 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -250,6 +250,30 @@ struct dpa_stats_cnt_reass {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats Fragmentation counters */
+enum dpa_stats_cnt_frag_sel {
+	/* Number of frames processed by fragmentation manipulation */
+	DPA_STATS_CNT_FRAG_TOTAL_FRAMES = 0x00000001,
+	/* Number of fragmented frames */
+	DPA_STATS_CNT_FRAG_FRAMES	= 0x00000002,
+	/* Number of generated fragments */
+	DPA_STATS_CNT_FRAG_GEN_FRAGS	= 0x00000004,
+	/* Select all counters from dpa_stats_cnt_frag_sel */
+	DPA_STATS_CNT_FRAG_ALL		= 0x00000008
+};
+
+/* DPA Stats Fragmentation counter parameters */
+struct dpa_stats_cnt_frag {
+	/* Pointer to the IP Fragmentation object*/
+	void	*frag;
+
+	/*
+	 * Single or multiple selection of Fragmentation
+	 * counters from enum dpa_stats_cnt_frag_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -262,6 +286,9 @@ struct dpa_stats_cnt_params {
 
 		/* Parameters for IP Reassembly counter */
 		struct dpa_stats_cnt_reass reass_params;
+
+		/* Parameters for IP Fragmentation counter */
+		struct dpa_stats_cnt_frag frag_params;
 	};
 };
 
@@ -287,6 +314,18 @@ struct dpa_stats_cls_cnt_reass {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats IP Fragmentation counter parameters */
+struct dpa_stats_cls_cnt_frag {
+	/* Array of pointers of IP Fragmentation objects */
+	void	**frag;
+
+	/*
+	 * Single or multiple selection of Fragmentation
+	 * counters from enum dpa_stats_cnt_frag_sel
+	 */
+	unsigned int cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -302,6 +341,9 @@ struct dpa_stats_cls_cnt_params {
 
 		/* Parameters for IP Reassembly class counter */
 		struct dpa_stats_cls_cnt_reass reass_params;
+
+		/* Parameters for IP Fragmentation class counter */
+		struct dpa_stats_cls_cnt_frag frag_params;
 	};
 };
 
-- 
1.7.5.4

