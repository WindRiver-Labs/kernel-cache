From 261f13dd8d772a75fcfd55a39f6008a5c3df167b Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:05 +0000
Subject: [PATCH 222/518] Add DSCP / ECN propagation support

Enable independent propagation of the DSCP and ECN bits into
the outer / inner header to the inner / outer header.

This feature can be used when using inner / outer headers with the
same IP version and also when the headers have different IP versions.

If both DCSP and ECN propagation is configured in the same time, the
whole DiffServ field will be copied between inner and outer headers,
like in the case when the DPA_IPSEC_HDR_COPY_TOS flag is set. The

difference is that using the DPA_IPSEC_HDR_COPY_TOS, the IP version of
the inner and outer header must be the same.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |  164 +++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h      |    5 +-
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |  197 +++++++++++++++++++++-
 include/linux/fsl_dpa_ipsec.h                    |   14 +-
 4 files changed, 324 insertions(+), 56 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 2d91316..5f6f78e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1037,43 +1037,47 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	return 0;
 }
 
-static int create_ipsec_manip(struct dpa_ipsec_sa *sa,
-			      struct dpa_cls_tbl_header_manip **hm)
+static int create_ipsec_manip(struct dpa_ipsec_sa *sa, void *next_manip,
+			      void **manip)
 {
-	t_FmPcdManipParams pcd_manip_params;
-	struct dpa_ipsec *dpa_ipsec;
+	t_FmPcdManipParams			pcd_manip_params;
+	t_FmPcdManipSpecialOffloadParams	*offld_params;
+	void					*ipsec_manip = NULL;
 
 	BUG_ON(!sa);
-	BUG_ON(!hm);
+	BUG_ON(!manip);
 
-	dpa_ipsec = sa->dpa_ipsec;
-	BUG_ON(!dpa_ipsec);
+	if (!sa->use_var_iphdr_len && !sa->dscp_copy && !sa->ecn_copy) {
+		/* no need to create a manipulation object */
+		*manip = NULL;
+		return 0;
+	}
 
 	memset(&pcd_manip_params, 0, sizeof(struct t_FmPcdManipParams));
 	pcd_manip_params.type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD;
-	pcd_manip_params.u.specialOffload.type =
-					e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC;
-	pcd_manip_params.u.specialOffload.u.ipsec.decryption = TRUE;
-	pcd_manip_params.u.specialOffload.u.ipsec.variableIpHdrLen =
-							sa->use_var_iphdr_len;
-	pcd_manip_params.u.specialOffload.u.ipsec.ecnCopy = FALSE;
-	pcd_manip_params.u.specialOffload.u.ipsec.dscpCopy = FALSE;
-
-	*hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
-	if (!*hm) {
-		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
+	offld_params = &pcd_manip_params.u.specialOffload;
+	offld_params->type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC;
+	if (sa->sa_dir == DPA_IPSEC_INBOUND)
+		offld_params->u.ipsec.decryption = true;
+	offld_params->u.ipsec.variableIpHdrLen = sa->use_var_iphdr_len;
+	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
+	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
+	pcd_manip_params.h_NextManip = next_manip;
+	ipsec_manip = FM_PCD_ManipNodeSet(sa->dpa_ipsec->config.fm_pcd,
+				     &pcd_manip_params);
+	if (!ipsec_manip) {
+		pr_err("%s: FM_PCD_ManipSetNode failed!\n", __func__);
 		return -EBUSY;
 	}
+	*manip = ipsec_manip;
 
 	return 0;
 }
 
-static int destroy_manip(struct dpa_ipsec *dpa_ipsec,
-			 struct dpa_cls_tbl_header_manip *hm)
+static int destroy_manip(void *hm)
 {
 	t_Error fmd_err;
 
-	BUG_ON(!dpa_ipsec);
 	BUG_ON(!hm);
 
 	fmd_err = FM_PCD_ManipNodeDelete((t_Handle)hm);
@@ -1220,13 +1224,22 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			}
 		}
 
+		/* Store the header manipulation into the policy entry */
+		policy_entry->hm = hm;
+
+		/* Init IPSec Manip. object (if required) for outbound policy */
+		err = create_ipsec_manip(sa, hm, &policy_entry->ipsec_manip);
+		if (err < 0) {
+			xx_pr_err("Could not create Manip obj for policy!\n");
+			return err;
+		}
+		if (policy_entry->ipsec_manip)
+			hm = policy_entry->ipsec_manip;
+
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
 				    qman_fq_fqid((sa->to_sec_fq)), hm);
 
-		/* Store the header manipulation into the policy entry */
-		policy_entry->hm = hm;
-
 		err = dpa_classif_table_insert_entry(table, &tbl_key,
 						&action, policy_entry->priority,
 						&policy_entry->entry_id);
@@ -1243,15 +1256,30 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			return err;
 		}
 
+		if (policy_entry->ipsec_manip) {
+			err = destroy_manip(policy_entry->ipsec_manip);
+			if (err < 0) {
+				xx_pr_err("Couldn't delete ipsec manip\n");
+				return err;
+			}
+			policy_entry->ipsec_manip = NULL;
+		}
+
 		if (policy_entry->hm) {
-			err = destroy_manip(dpa_ipsec, policy_entry->hm);
+			err = destroy_manip(policy_entry->hm);
 			if (err < 0) {
 				pr_err("Couldn't delete frag manip\n");
 				return err;
 			}
+			policy_entry->hm = NULL;
 		}
 		break;
 	case MNG_OP_MODIFY:
+		if (policy_entry->ipsec_manip)
+			hm = policy_entry->ipsec_manip;
+		else
+			hm = policy_entry->hm;
+
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
 				    qman_fq_fqid((sa->to_sec_fq)),
@@ -1284,7 +1312,6 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
 	struct dpa_cls_tbl_entry_mod_params mod_params;
-	struct dpa_cls_tbl_header_manip *hm = NULL;
 	uint8_t *key, *mask;
 
 	BUG_ON(!sa);
@@ -1356,22 +1383,10 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		 */
 		memset(mask, 0xFF, offset);
 
-		/* Configure support for variable IP header length */
-		if (sa->use_var_iphdr_len) {
-			err = create_ipsec_manip(sa, &hm);
-			if (err < 0) {
-				pr_err("Could not create Manip node !\n");
-				return -EAGAIN;
-			}
-		}
-
-		/* Store the header manipulation into the SA */
-		sa->hm = hm;
-
 		/* Complete the parameters for table insert function */
 		memset(&action, 0, sizeof(action));
 		fill_cls_action_enq(&action, FALSE,
-			qman_fq_fqid((sa->to_sec_fq)), sa->hm);
+			qman_fq_fqid((sa->to_sec_fq)), sa->ipsec_manip);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
 						     0, &entry_id);
@@ -1389,15 +1404,6 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 			pr_err("Could not remove key for inbound SA!\n");
 			return err;
 		}
-
-		if (sa->hm) {
-			err = destroy_manip(dpa_ipsec, sa->hm);
-			if (err < 0) {
-				pr_err("Couldn't delete ipsec manip\n");
-				return err;
-			}
-		}
-
 		sa->inbound_hash_entry = -1;
 		break;
 
@@ -1706,6 +1712,8 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 		sp_op = FM_SP_OP_IPSEC;
 		if (sa->sa_dir == DPA_IPSEC_OUTBOUND && sa->use_udp_encap)
 			sp_op |= FM_SP_OP_IPSEC_UPDATE_UDP_LEN;
+		if (sa->dscp_copy || sa->ecn_copy)
+			sp_op |= FM_SP_OP_IPSEC_MANIP | FM_SP_OP_RPD;
 
 		/* acquire fqid for 'FROM SEC' fq */
 		err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
@@ -1814,7 +1822,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 				       PDBOPTS_ESP_INCIPHDR |
 				       PDBOPTS_ESP_IPHDRSRC;
 	if (sa_params->hdr_upd_flags) {
-		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DSCP)
+		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_TOS)
 			sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_DIFFSERV;
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DF) {
 			if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv4)
@@ -1826,6 +1834,11 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_DEC_TTL)
 			sa->sec_desc->pdb_en.hmo_rsvd |=
 					PDBHMO_ESP_ENCAP_DEC_TTL;
+
+		sa->dscp_copy =
+			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DSCP;
+		sa->ecn_copy =
+			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_ECN;
 	}
 	if (sa_params->use_ext_seq_num) {
 		sa->sec_desc->pdb_en.seq_num_ext_hi =
@@ -2008,7 +2021,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_dec.hmo_ip_hdr_len += UDP_HEADER_LEN;
 
 	if (sa_params->hdr_upd_flags) {
-		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DSCP)
+		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_TOS)
 			sa->sec_desc->pdb_dec.hmo_ip_hdr_len |=
 					PDBHMO_ESP_DIFFSERV;
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_DEC_TTL)
@@ -2016,6 +2029,11 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 					PDBHMO_ESP_DECAP_DEC_TTL;
 		if (sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DF)
 			pr_info("Copy DF bit not supported for inbound SAs");
+
+		sa->dscp_copy =
+			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_DSCP;
+		sa->ecn_copy =
+			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_ECN;
 	}
 
 	memcpy(&sa->src_addr,
@@ -2443,6 +2461,16 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 	}
 	sa->inbound_hash_entry = -1;
 
+	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
+		err_rb = destroy_manip(sa->ipsec_manip);
+		if (err_rb < 0) {
+			xx_pr_err("Could not delete manip object!\n");
+			return err_rb;
+		}
+		sa->ipsec_manip = NULL;
+	}
+
+
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
 	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) &&
 	    (sa->inbound_indx_entry != -1)) {
@@ -2490,6 +2518,15 @@ static int rollback_rekeying_sa(struct dpa_ipsec_sa *sa)
 	}
 	sa->inbound_hash_entry = -1;
 
+	if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
+		err_rb = destroy_manip(sa->ipsec_manip);
+		if (err_rb < 0) {
+			xx_pr_err("Could not delete manip object!\n");
+			return err_rb;
+		}
+		sa->ipsec_manip = NULL;
+	}
+
 	err_rb = remove_sa_fq_pair(sa);
 	if (err_rb < 0) {
 		pr_err("Could not remove SA FQs.\n");
@@ -2637,6 +2674,15 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 		goto create_sa_err;
 	}
 
+	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
+	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
+		err = create_ipsec_manip(sa, NULL, &sa->ipsec_manip);
+		if (err < 0) {
+			xx_pr_err("Could not create Manip object for in SA!\n");
+			goto create_sa_err;
+		}
+	}
+
 	/* Generate the split key from the normal auth key */
 	err = generate_split_key(&sa->auth_data);
 	if (err < 0)
@@ -2782,6 +2828,15 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 				return err;
 		}
 
+		if (sa->sa_dir == DPA_IPSEC_INBOUND && sa->ipsec_manip) {
+			err = destroy_manip(sa->ipsec_manip);
+			if (err < 0) {
+				xx_pr_err("Could not delete manip object!\n");
+				return err;
+			}
+			sa->ipsec_manip = NULL;
+		}
+
 		err = wait_until_fq_empty(sa->to_sec_fq, timeout);
 		if (err < 0) {
 			pr_err("Waiting old SA's TO SEC FQ to get empty\n");
@@ -3299,6 +3354,15 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 		goto rekey_sa_err;
 	}
 
+	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
+	if (new_sa->sa_dir == DPA_IPSEC_INBOUND) {
+		err = create_ipsec_manip(new_sa, NULL, &new_sa->ipsec_manip);
+		if (err < 0) {
+			xx_pr_err("Could not create Manip object for in SA!\n");
+			goto rekey_sa_err;
+		}
+	}
+
 	/* Generate the split key from the normal auth key */
 	err = generate_split_key(&new_sa->auth_data);
 	if (err < 0)
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 1069496..787f9fb 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -229,6 +229,8 @@ struct dpa_ipsec_sa {
 					  * do not free this pointer!	      */
 	uint32_t stats_offset; /* Offset of the statistics (in bytes)	      */
 	bool	enable_stats; /* Enable counting packets and bytes processed  */
+	bool dscp_copy; /* Enable DSCP propagation support		      */
+	bool ecn_copy; /* Enable DSCP propagation support		      */
 	struct qman_fq *to_sec_fq; /*From this Frame Queue SEC consumes frames*/
 	struct qman_fq *from_sec_fq; /*In this Frame Queue SEC will enqueue the
 				encryption/decryption result (FD).            */
@@ -264,7 +266,7 @@ struct dpa_ipsec_sa {
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
 	int use_var_iphdr_len; /* Enable variable IP header length support    */
-	struct dpa_cls_tbl_header_manip *hm;	/* Header manipulation        */
+	void *ipsec_manip; /* Manip object for special IPSec functions     */
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 	uint8_t l2_hdr_size; /* Size of the Ethernet header, including any
 			      * VLAN information.			      */
@@ -338,6 +340,7 @@ struct dpa_ipsec_policy_entry {
 	int priority;		/* Policy priority                            */
 	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
 	struct dpa_cls_tbl_header_manip *hm;	/* Header manipulation        */
+	void *ipsec_manip; /* Manip obj used for special IPSec functions      */
 	struct list_head node;	/* Node in linked list			      */
 };
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 7aa080f..5fa98f0 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -43,6 +43,19 @@
 /* If SEC ERA is unknown default to this value */
 #define SEC_DEF_ERA	2 /* like in P4080 */
 
+/*
+ * to retrieve a 256 byte aligned buffer address from an address
+ * we need to copy only the first 7 bytes
+ */
+#define ALIGNED_PTR_ADDRESS_SZ	(CAAM_PTR_SZ - 1)
+
+#define JOB_DESC_HDR_LEN	CAAM_CMD_SZ
+#define SEQ_OUT_PTR_SGF_MASK	0x01000000;
+/* relative offset where the input pointer should be updated in the descriptor*/
+#define IN_PTR_REL_OFF		4 /* words from current location */
+/* dummy pointer value */
+#define DUMMY_PTR_VAL		0xFFFFFF00
+
 static const struct of_device_id sec_match[] = {
 	{
 	 .compatible = "fsl,sec-v4.0"
@@ -227,11 +240,181 @@ static inline void save_stats_in_external_mem(struct dpa_ipsec_sa *sa)
 	append_jump(desc, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
 }
 
+/* insert a cmd in the desc at a given index and optionally update desc len */
+static void insert_sec_cmd(uint32_t *desc, uint32_t index, uint32_t cmd,
+			  bool update_len)
+{
+	uint32_t *desc_cmd;
+
+	desc_cmd = desc + index;
+	*desc_cmd = cmd;
+
+	if (update_len)
+		(*desc)++;
+}
+
+/* insert cmds for SEQ_IN/OUT_PTR copy with specified offset (shr_desc_len) */
+static void insert_ptr_copy_cmds(uint32_t *desc, uint32_t index,
+				 uint32_t shr_desc_len, bool update_desc_len)
+{
+	uint32_t cmd, off, len;
+
+	/*
+	 * insert the commands at the specified index
+	 * if index == 0 insert at next position in desc
+	 */
+	if (!index)
+		index = desc_len(desc);
+
+	/*
+	 * move out ptr (from job desc) to math reg 1 & 2, except the last byte;
+	 * assuming all buffers are 256 bits aligned, setting the last address
+	 * byte to 0x00  will give the buffer address;
+	 */
+	off = CAAM_PTR_SZ;
+	off = (shr_desc_len * CAAM_CMD_SZ + off) << MOVE_OFFSET_SHIFT;
+	len = CAAM_CMD_SZ + JOB_DESC_HDR_LEN + ALIGNED_PTR_ADDRESS_SZ;
+	cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH1 | off | len;
+	insert_sec_cmd(desc, index, cmd, update_desc_len);
+
+	/*
+	 * move in ptr (from job desc) to math reg 0, except the last byte;
+	 * assuming all buffers are 256 bits aligned, setting the last address
+	 * byte to 0x00  will give the buffer address;
+	 */
+	off = JOB_DESC_HDR_LEN + 3 * CAAM_CMD_SZ + 2 * CAAM_PTR_SZ;
+	off = (shr_desc_len * CAAM_CMD_SZ + off) << MOVE_OFFSET_SHIFT;
+	len = ALIGNED_PTR_ADDRESS_SZ;
+	cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | off | len;
+	insert_sec_cmd(desc, ++index, cmd, update_desc_len);
+}
+
+/* build the command set for copying the frame meta data */
+static void build_meta_data_desc_cmds(struct dpa_ipsec_sa *sa,
+				      unsigned int sec_era,
+				      unsigned int move_size)
+{
+	uint32_t *desc, off, len, opt, *no_sg_jump;
+	uint32_t sg_mask = SEQ_OUT_PTR_SGF_MASK;
+
+	BUG_ON(!sa);
+
+	desc = (uint32_t *) sa->sec_desc->desc;
+
+	/* insert cmds to copy SEQ_IN/OUT_PTR - offset will be updated later */
+	insert_ptr_copy_cmds(desc, 0, 0, true);
+
+	/* detect & handle scatter / gather frames */
+
+	/*
+	 * the SEQ OUT PTR command is now in math reg 1, so the SGF bit can be
+	 * checked using a math command;
+	 */
+	append_math_and_imm_u32(desc, NONE, REG1, IMM, sg_mask);
+
+	opt = CLASS_NONE | JUMP_TYPE_LOCAL | JUMP_COND_MATH_Z | JUMP_TEST_ALL;
+	no_sg_jump = append_jump(desc, opt);
+
+	if (sec_era == 2) {
+		/* disable iNFO FIFO entries for p4080rev2 & ??? */
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 */
+		opt = MOVE_SRC_MATH3 | MOVE_DEST_CLASS1INFIFO;
+		off = 127 << MOVE_OFFSET_SHIFT;
+		len = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off | len);
+
+		/* enable iNFO FIFO entries */
+		append_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);
+	} else {
+		/* ????? */
+		opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+		len = 0x10 << LDST_LEN_SHIFT;
+		append_cmd(desc, CMD_LOAD | opt | len);
+
+		/*
+		 * load in IN FIFO the S/G Entry located in the 5th reg after
+		 * MATH3 -> offset = sizeof(GT_REG) * 4 + offset_math3_to_GT_REG
+		 * len = sizeof(S/G entry)
+		 */
+		opt = MOVE_SRC_MATH3 | MOVE_DEST_INFIFO;
+		off = 127 << MOVE_OFFSET_SHIFT;
+		len = 49 << MOVE_LEN_SHIFT;
+		append_move(desc, opt | off | len);
+	}
+
+	/*
+	 * throw away the first part of the S/G table and keep only the buffer
+	 * address;
+	 * offset = undefined memory after MATH3;
+	 * len =
+	 */
+	opt = MOVE_SRC_INFIFO | MOVE_DEST_MATH3;
+	off = 8 << MOVE_OFFSET_SHIFT;
+	len = 41 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off | len);
+
+	/* put the buffer address (still in the IN FIFO) in MATH2 */
+	opt = MOVE_SRC_INFIFO | MOVE_DEST_MATH2;
+	off = 0 << MOVE_OFFSET_SHIFT;
+	len = 8 << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off | len);
+
+	/* update no S/G jump location */
+	set_jump_tgt_here(desc, no_sg_jump);
+
+	/* save input pointer to predefined location in descriptor */
+	opt = MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF;
+	off = ((desc_len(desc) + IN_PTR_REL_OFF) << 2) << MOVE_OFFSET_SHIFT;
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off | len);
+
+	/* save output pointer to predefined location in descriptor */
+	opt = MOVE_WAITCOMP | MOVE_SRC_MATH2 | MOVE_DEST_DESCBUF;
+	off += (CAAM_PTR_SZ +  2 * CAAM_CMD_SZ) << MOVE_OFFSET_SHIFT;
+	len = ALIGNED_PTR_ADDRESS_SZ << MOVE_LEN_SHIFT;
+	append_move(desc, opt | off | len);
+
+	/* fix LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off = 0x40 << LDST_OFFSET_SHIFT; /* SEQ LIODN */
+	append_cmd(desc, CMD_LOAD | opt | off);
+
+	/* actual move commands - pointers will be updated at runtime */
+
+	/* load the data to be moved - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_load(desc, DUMMY_PTR_VAL, len, opt | off);
+
+	/* wait for completion */
+	opt = JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT);
+	append_jump(desc, opt);
+
+	/* store the data to the output fifo - insert dummy pointer */
+	opt = LDST_CLASS_2_CCB | LDST_SRCDST_WORD_CLASS_CTX;
+	off = 0 << LDST_OFFSET_SHIFT;
+	len = move_size << LDST_LEN_SHIFT;
+	append_store(desc, DUMMY_PTR_VAL, len, opt | off);
+
+	/* fix LIODN */
+	opt = LDST_IMM | LDST_CLASS_DECO | LDST_SRCDST_WORD_DECOCTRL;
+	off = 0x80 << LDST_OFFSET_SHIFT; /* NON_SEQ LIODN */
+	append_cmd(desc, CMD_LOAD | opt | off);
+}
+
 int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 			    dma_addr_t auth_key_dma,
 			    dma_addr_t crypto_key_dma, u8 bytes_to_copy)
 {
-	u32 *desc, *key_jump_cmd;
+	uint32_t *desc, *key_jump_cmd, copy_ptr_index = 0;
 	int opthdrsz;
 	size_t pdb_len = 0;
 
@@ -275,6 +458,13 @@ int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 
 	set_jump_tgt_here(desc, key_jump_cmd);
 
+	/* copy frame meta data (IC) to enable DSCP / ECN propagation */
+	if (sa->dscp_copy || sa->ecn_copy) {
+		/* save location of ptr copy commands to update offset later */
+		copy_ptr_index = desc_len(desc);
+		build_meta_data_desc_cmds(sa, sa->dpa_ipsec->sec_era, 64);
+	}
+
 	if (bytes_to_copy == 0)
 		goto skip_byte_copy;
 
@@ -312,6 +502,11 @@ skip_byte_copy:
 	if (sa->enable_stats)
 		save_stats_in_external_mem(sa);
 
+	if (sa->dscp_copy || sa->ecn_copy)
+		/* insert cmds to copy SEQ_IN/OUT_PTR - with updated offset */
+		insert_ptr_copy_cmds(desc, copy_ptr_index,
+				     desc_len(desc), false);
+
 	return 0;
 }
 
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 3ac6b98..c9ecbd2 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -75,13 +75,19 @@
 
 #define DPA_IPSEC_INVALID_SA_ID	-1
 
-#define DPA_IPSEC_HDR_COPY_DSCP		0x01 /* Copy DSCP bit from inner /
-					      * outer header to outer / inner
-					      * header                        */
+#define DPA_IPSEC_HDR_COPY_TOS		0x01 /* Copy TOS / DiffServ byte from
+					      * inner / outer header to outer /
+					      * inner header		      */
 #define	DPA_IPSEC_HDR_COPY_DF		0x02 /* Copy DF bit from outer header
-					      * to outer / inner header       */
+					      * to outer / inner header	      */
 #define DPA_IPSEC_HDR_DEC_TTL		0x04 /* Automatically decrment the TTL
 					      * value in the inner / outer hdr*/
+#define DPA_IPSEC_HDR_COPY_DSCP		0x08 /* Copy DSCP bits from inner /
+					      * outer header to outer / inner
+					      * header			      */
+#define DPA_IPSEC_HDR_COPY_ECN		0x10 /* Copy ECN bits from inner /
+					      * outer header to outer / inner
+					      * header			      */
 
 #define DPA_IPSEC_KEY_FIELD_SIP		0x01 /* Use source IP address in key  */
 #define DPA_IPSEC_KEY_FIELD_DIP		0x02 /* Use destination IP in key     */
-- 
1.7.5.4

