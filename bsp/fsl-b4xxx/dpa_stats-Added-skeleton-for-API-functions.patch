From 869fb74fb329c66182cc9aadfe3a318282368a71 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:49:46 +0000
Subject: [PATCH 251/518] dpa_stats: Added skeleton for API functions

Created skeleton for functions dpa_stats_create_counter,
dpa_stats_create_class_counter and dpa_stats_remove_counter function

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  160 +++++++++++++++++++++++++++
 include/linux/fsl_dpa_stats.h               |   53 +++++++++
 2 files changed, 213 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index cbd741c..f19b39d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -72,6 +72,45 @@ static int check_dpa_stats_params(const struct dpa_stats_params *params)
 	return 0;
 }
 
+static int get_new_cnt(struct dpa_stats *dpa_stats,
+		int *dpa_stats_cnt_id, struct dpa_stats_cnt_cb **cnt_cb)
+{
+	struct dpa_stats_cnt_cb *new_cnt;
+	uint32_t id;
+	int i;
+
+	/* Get an id for new Counter */
+	if (cq_get_4bytes(dpa_stats->cnt_id_cq, &id) < 0) {
+		pr_err("No more unused counter ids\n");
+		return -EDOM;
+	}
+
+	/* Use 'used_cnt_ids' array in order to store counter ids that are
+	 * 'in use' . Array can be further used to remove counters */
+	for (i = 0; i < dpa_stats->config.max_counters; i++)
+		if (dpa_stats->used_cnt_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID)
+			break;
+
+	if (i == dpa_stats->config.max_counters) {
+		pr_err("All counters have been used");
+		cq_put_4bytes(dpa_stats->cnt_id_cq, id);
+		return -EDOM;
+	}
+
+	/* Acquire a preallocated Counter Control Block  */
+	new_cnt = &(dpa_stats->cnts_cb[id]);
+	new_cnt->cnt_id = id;
+	new_cnt->cnt_index = i;
+
+	/* Store on the current position the counter id */
+	dpa_stats->used_cnt_ids[i] = id;
+
+	*dpa_stats_cnt_id = id;
+	*cnt_cb = new_cnt;
+
+	return 0;
+}
+
 static int put_cnt(struct dpa_stats *dpa_stats, struct dpa_stats_cnt_cb *cnt_cb)
 {
 	int err = 0;
@@ -238,6 +277,127 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 }
 EXPORT_SYMBOL(dpa_stats_init);
 
+int dpa_stats_create_counter(int dpa_stats_id,
+			const struct dpa_stats_cnt_params *params,
+			int *dpa_stats_cnt_id)
+{
+	struct dpa_stats *dpa_stats = NULL;
+	struct dpa_stats_cnt_cb *cnt_cb = NULL;
+	int err = 0;
+	uint32_t id;
+
+	/* multiple DPA Stats instances are not currently supported */
+	unused(dpa_stats_id);
+
+	if (!gbl_dpa_stats) {
+		pr_err("dpa_stats component is not initialized\n");
+		return -EPERM;
+	}
+
+	if (!dpa_stats_cnt_id) {
+		pr_err("dpa_stats_cnt_id can't be NULL\n");
+		return -EINVAL;
+	}
+	*dpa_stats_cnt_id = DPA_OFFLD_INVALID_OBJECT_ID;
+
+	dpa_stats = gbl_dpa_stats;
+
+	err = get_new_cnt(dpa_stats, &id, &cnt_cb);
+	if (err < 0) {
+		pr_err("Failed retrieving a preallocated counter\n");
+		return err;
+	}
+
+	/* Counter was created. Return the counter id */
+	*dpa_stats_cnt_id = id;
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_stats_create_counter);
+
+int dpa_stats_create_class_counter(int dpa_stats_id,
+			const struct dpa_stats_cls_cnt_params *params,
+			int *dpa_stats_cnt_id)
+{
+	struct dpa_stats *dpa_stats = NULL;
+	struct dpa_stats_cnt_cb *cnt_cb = NULL;
+	uint32_t id;
+	int err = 0;
+
+	/* multiple DPA Stats instances are not currently supported */
+	unused(dpa_stats_id);
+
+	if (!gbl_dpa_stats) {
+		pr_err("dpa_stats component is not initialized\n");
+		return -EPERM;
+	}
+
+	if (!dpa_stats_cnt_id) {
+		pr_err("dpa_stats_cnt_id can't be NULL\n");
+		return -EINVAL;
+	}
+	*dpa_stats_cnt_id = DPA_OFFLD_INVALID_OBJECT_ID;
+
+	if (params->class_members > DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS) {
+		pr_err("exceed maximum number of class members: %d\n",
+				DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS);
+		return -EINVAL;
+	}
+
+	dpa_stats = gbl_dpa_stats;
+
+	err = get_new_cnt(dpa_stats, &id, &cnt_cb);
+	if (err < 0) {
+		pr_err("Failed retrieving a preallocated counter\n");
+		return err;
+	}
+
+	/* Counter was created. Return the counter id */
+	*dpa_stats_cnt_id = id;
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_stats_create_class_counter);
+
+int dpa_stats_remove_counter(int dpa_stats_cnt_id)
+{
+	struct dpa_stats *dpa_stats = NULL;
+	struct dpa_stats_cnt_cb *cnt_cb = NULL;
+	int err = 0;
+
+	if (!gbl_dpa_stats) {
+		pr_err("dpa_stats component is not initialized\n");
+		return -EPERM;
+	}
+
+	dpa_stats = gbl_dpa_stats;
+
+	if ((dpa_stats_cnt_id < 0) ||
+			(dpa_stats_cnt_id > dpa_stats->config.max_counters)) {
+		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		return -EINVAL;
+	}
+
+	/* Get counter control block */
+	cnt_cb = &dpa_stats->cnts_cb[dpa_stats_cnt_id];
+
+	/* Validity check for this Counter */
+	if (cnt_cb->cnt_index == DPA_OFFLD_INVALID_OBJECT_ID) {
+		pr_err("Invalid Counter id %d provided\n", dpa_stats_cnt_id);
+		return -EINVAL;
+	}
+
+	/* Release the counter id in the Counter IDs circular queue */
+	err = put_cnt(dpa_stats, cnt_cb);
+	if (err < 0) {
+		pr_err("Failed to release a preallocated counter\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_stats_remove_counter);
+
 int dpa_stats_free(int dpa_stats_id)
 {
 	/* multiple DPA Stats instances are not currently supported */
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index d2382e3a..36634fd 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -43,6 +43,12 @@
 /* Other includes */
 #include <linux/types.h>
 
+/* Maximum number of single and class counters */
+#define DPA_STATS_MAX_NUM_OF_COUNTERS      128
+
+/* Maximum number of class counter members */
+#define DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS 256
+
 /* DPA Stats instance parameters */
 struct dpa_stats_params {
 
@@ -57,9 +63,56 @@ struct dpa_stats_params {
 	unsigned int storage_area_len;
 };
 
+/* DPA Stats counter types */
+enum dpa_stats_cnt_type {
+	DPA_STATS_CNT_ETH = 0,		/* Ethernet counter		*/
+	DPA_STATS_CNT_REASS,		/* IP Reassembly counter	*/
+	DPA_STATS_CNT_FRAG,		/* IP Fragmentation counter	*/
+	DPA_STATS_CNT_POLICER,		/* Policer counter		*/
+	DPA_STATS_CNT_CLASSIF_TBL,	/* Classification Table counter	*/
+	DPA_STATS_CNT_CLASSIF_NODE,	/* Classification Node counter	*/
+	DPA_STATS_CNT_IPSEC,		/* IPSec counter		*/
+	DPA_STATS_CNT_TRAFFIC_MNG,	/* Traffic Manager counter	*/
+#ifdef DPA_STATS_UNDER_CONSTRUCTION
+	DPA_STATS_CNT_RAPIDIO		/* RapidIO counter		*/
+#endif
+};
+
+/* DPA Stats counter parameters */
+struct dpa_stats_cnt_params {
+
+	/* The type of DPA Stats counter */
+	enum dpa_stats_cnt_type type;
+};
+
+/* DPA Stats class counter parameters */
+struct dpa_stats_cls_cnt_params {
+
+	/* Number of members the class can have */
+	unsigned int class_members;
+
+	/* The type of DPA Stats class counter */
+	enum dpa_stats_cnt_type type;
+};
+
 /* Creates and initializes a DPA Stats instance */
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id);
 
+/* Create and initialize a DPA Stats counter. The returned 'dpa_stats_cnt_id'
+ * will be further used to uniquely identify a counter */
+int dpa_stats_create_counter(int dpa_stats_id,
+			const struct dpa_stats_cnt_params *params,
+			int *dpa_stats_cnt_id);
+
+/* Creates and initializes a DPA Stats class counter. The returned
+ * 'dpa_stats_cnt_id' will be further used to uniquely identify a counter */
+int dpa_stats_create_class_counter(int dpa_stats_id,
+			const struct dpa_stats_cls_cnt_params *params,
+			int *dpa_stats_cnt_id);
+
+/* Remove a DPA Stats counter by releasing all associated resources */
+int dpa_stats_remove_counter(int dpa_stats_cnt_id);
+
 /*
  * Releases all resources associated with a DPA Stats instance
  * and destroys it.
-- 
1.7.5.4

