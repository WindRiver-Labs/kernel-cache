From 5fbb6ab8638c37b8d7e8474424d28d6f6db2f8b8 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:59:22 +0000
Subject: [PATCH 246/518] dpa_ipsec: Sync with updated dpa_classifier lookup
 key API

The dpa_classifier lookup key API was updated to support adding
entries w/o mask. The IPSec component is now synchronized with
this API change.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   48 +++++++++++++++++---------
 1 files changed, 31 insertions(+), 17 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 84ddc88..e6b82ee 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -967,9 +967,10 @@ static int set_ip_addr_mask(uint8_t *mask, uint8_t prefix_len,
 static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
-	struct dpa_cls_tbl_key tbl_key;
+	struct dpa_offload_lookup_key tbl_key;
 	struct dpa_cls_tbl_action *action;
 	int table, err;
+	uint8_t key_data;
 
 	BUG_ON(!sa);
 
@@ -977,8 +978,10 @@ static int set_in_sa_default_action(struct dpa_ipsec_sa *sa)
 	BUG_ON(!dpa_ipsec);
 
 	/* AV's note: TODO - case when inbound_flowid is greater than 255 */
-	memset(&tbl_key, 0, sizeof(tbl_key));
-	tbl_key.byte[0] = (uint8_t) sa->inbound_flowid;
+	key_data	= sa->inbound_flowid;
+	tbl_key.byte	= &key_data;
+	tbl_key.mask	= NULL;
+	tbl_key.size	= 1;
 
 	action = &sa->def_sa_action;
 	table = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
@@ -1238,7 +1241,9 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec_policy_params *pol_params;
 	uint8_t key_len;
 	struct dpa_cls_tbl_action *action;
-	struct dpa_cls_tbl_key tbl_key;
+	struct dpa_offload_lookup_key tbl_key;
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	int entry_id, err;
 
 	BUG_ON(!sa);
@@ -1255,7 +1260,8 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 
 	switch (op_type) {
 	case MNG_OP_ADD:
-		memset(&tbl_key, 0, sizeof(tbl_key));
+		tbl_key.byte = key_data;
+		tbl_key.mask = mask_data;
 
 		/* Key contains:
 		 * IP SRC ADDR	- from Policy handle
@@ -1272,6 +1278,8 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 		if (err < 0)
 			return err;
 
+		tbl_key.size = key_len;
+
 		if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT)
 			action = &pol_params->dir_params.in_action;
 		else
@@ -1311,11 +1319,13 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
 	struct dpa_ipsec_policy_params *pol_params;
 	uint8_t key_len, table_idx, key_fields;
-	struct dpa_cls_tbl_key tbl_key;
+	struct dpa_offload_lookup_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_entry_mod_params params;
 	int table, err;
 	int hmd;
+	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
+	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 
 	BUG_ON(!sa);
 	BUG_ON(!policy_entry);
@@ -1343,7 +1353,8 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 	switch (op_type) {
 	case MNG_OP_ADD:
-		memset(&tbl_key, 0, sizeof(tbl_key));
+		tbl_key.byte = key_data;
+		tbl_key.mask = mask_data;
 
 		/* Key may contain:
 		 * IP SRC ADDR  - from Policy handle
@@ -1357,6 +1368,8 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 		if (err < 0)
 			return err;
 
+		tbl_key.size = key_len;
+
 		/* Configure fragmentation */
 		if (pol_params->dir_params.type ==
 						DPA_IPSEC_POL_DIR_PARAMS_FRAG) {
@@ -1454,11 +1467,11 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 {
 	struct dpa_ipsec *dpa_ipsec;
 	int table, table_idx, entry_id, offset, err = 0, tbl_key_size = 0, i;
-	struct dpa_cls_tbl_key tbl_key;
+	struct dpa_offload_lookup_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_params tbl_params;
 	struct dpa_cls_tbl_entry_mod_params mod_params;
-	uint8_t *key, *mask;
+	uint8_t key[DPA_OFFLD_MAXENTRYKEYSIZE];
 
 	BUG_ON(!sa);
 
@@ -1483,9 +1496,9 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 		 * inserted*/
 		sa->inbound_hash_entry = -1;
 
-		memset(&tbl_key, 0, sizeof(tbl_key));
-		key = tbl_key.byte;
-		mask = tbl_key.mask;
+		tbl_key.byte = key;
+		/* Key masks are not supported by HASH tables*/
+		tbl_key.mask = NULL;
 
 		/* Key contains:
 		 * IP DST ADDR  - from SA handle
@@ -1535,10 +1548,7 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 			offset = tbl_key_size;
 		}
 
-		/* Fill the mask. All the key components are used.
-		 * Offset is now equal to key length
-		 */
-		memset(mask, 0xFF, offset);
+		tbl_key.size = offset;
 
 		/* Complete the parameters for table insert function */
 		memset(&action, 0, sizeof(action));
@@ -2891,7 +2901,8 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			int inbpol_td;
 			int inbindx_td;
 			struct dpa_cls_tbl_action action;
-			struct dpa_cls_tbl_key inbindx_key;
+			struct dpa_offload_lookup_key inbindx_key;
+			uint8_t key_data;
 
 			err = get_free_inbpol_tbl(dpa_ipsec, &inbpol_td);
 			if (err < 0) {
@@ -2906,6 +2917,9 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 				dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
 
 			/*TODO - case when flow id is greater than 255 */
+			inbindx_key.byte = &key_data;
+			inbindx_key.mask = NULL;
+			inbindx_key.size = 1;
 			inbindx_key.byte[0] = (uint8_t) sa->inbound_flowid;
 			memset(&action, 0, sizeof(action));
 			action.type = DPA_CLS_TBL_ACTION_NEXT_TABLE;
-- 
1.7.5.4

