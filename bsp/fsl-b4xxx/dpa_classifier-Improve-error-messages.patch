From 3ab55856b5a860b07e134364664dd765d20e3240 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:56:00 +0000
Subject: [PATCH 226/518] dpa_classifier: Improve error messages

Since the replacement of the "xx_pr_err" with the simpler "pr_err", all
the debugging information (such as the name of the source file, the
name of the function and the line of code where the error was detected)
that the "xx_pr_err" macro was automatically displaying was lost. It is
now needed to include this information in each error message.

Also implemented light optimisations in case of error situations.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  285 ++++++++++++--------
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  206 ++++++++-------
 2 files changed, 285 insertions(+), 206 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 9c249d3..bc7e4ae 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -85,7 +85,8 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 
 	ptable = kzalloc(sizeof(*ptable), GFP_KERNEL);
 	if (!ptable) {
-		pr_err("No more memory for DPA classifier table.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA classifier "
+			"table.\n", __FILE__, __func__, __LINE__);
 		err = -ENOMEM;
 		goto dpa_classif_table_create_error;
 	}
@@ -97,7 +98,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 		ptable->shadow_table =
 			kzalloc(sizeof(*ptable->shadow_table), GFP_KERNEL);
 		if (!ptable->shadow_table) {
-			pr_err("No more memory for DPA classifier shadow table.");
+			pr_err("ERROR: %s, %s (%d): No more memory for DPA "
+				"classifier shadow table.\n", __FILE__,
+				__func__, __LINE__);
 			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
 		}
@@ -153,7 +156,9 @@ int dpa_classif_table_create(const struct dpa_cls_tbl_params	*params,
 			kmalloc(ptable->shadow_table->size *
 				sizeof(struct list_head), GFP_KERNEL);
 		if (!ptable->shadow_table->shadow_entry) {
-			pr_err("No more memory for DPA Classifier shadow tables.");
+			pr_err("ERROR: %s, %s (%d): No more memory for DPA "
+				"Classifier shadow tables.\n", __FILE__,
+				__func__, __LINE__);
 			err = -ENOMEM;
 			goto dpa_classif_table_create_error;
 		}
@@ -259,7 +264,9 @@ int dpa_classif_table_modify_miss_action(int			td,
 	ptable = (struct dpa_cls_table *) table_array.object[td];
 
 	if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
-		pr_err("Miss Action for DPA Classifier Indexed Tables is not supported.");
+		pr_err("ERROR: %s, %s (%d): Miss Action for DPA Classifier "
+			"Indexed Tables is not supported.\n", __FILE__,
+			__func__, __LINE__);
 		return -ENOSYS;
 	}
 
@@ -278,8 +285,11 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 		int_cc_node[i].cc_node,	&miss_engine_params);
 	if (err != E_OK) {
-		pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine", __func__);
-		pr_err("FMan driver call failed.");
+		pr_err("ERROR: %s, %s (%d): "
+			"FM_PCD_MatchTableModifyMissNextEngine failed.\n",
+			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+			__FILE__, __func__, __LINE__);
 		return -EBUSY;
 	}
 }
@@ -287,9 +297,11 @@ for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
 		err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 			int_cc_node[0].cc_node, &miss_engine_params);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyMissNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyMissNextEngine "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	}
@@ -385,7 +397,9 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 
 	entry_id = key_to_entry_id(ptable, key);
 	if (entry_id < 0) {
-		pr_err("Unable to determine entry_id.");
+		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
+			"associated with this lookup key.\n", __FILE__,
+			__func__, __LINE__);
 		return entry_id;
 	}
 
@@ -450,9 +464,11 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -477,8 +493,11 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				key_data,
 				mask_data);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyKey\n", __func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyKey failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -510,9 +529,11 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 				ptable->params.exact_match_params.key_size,
 				&key_params);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyKeyAndNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyKeyAndNextEngine "
+				"failed.\n", __FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -594,7 +615,9 @@ int dpa_classif_table_delete_entry_by_key(int				td,
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 			table_array.object[td], key);
 	if (entry_id < 0) {
-		pr_err("Unable to determine entry_id.");
+		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
+			"associated with this lookup key.\n", __FILE__,
+			__func__, __LINE__);
 		return entry_id;
 	}
 
@@ -647,9 +670,11 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyNextEngine failed\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -659,8 +684,11 @@ int dpa_classif_table_delete_entry_by_ref(int td, int entry_id)
 		err = FM_PCD_MatchTableRemoveKey(cc_node,
 					entry_index);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableRemoveKey\n", __func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableRemoveKey failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -851,9 +879,13 @@ int dpa_classif_table_flush(int td)
 						index_entry->entry_index,
 						&next_engine_params);
 			if (err != E_OK) {
-				pr_err("%s:FM_PCD_MatchTableModifyNextEngine\n",
-					__func__);
-				pr_err("FMan driver call failed.");
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableModifyNextEngine "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
 				return -EBUSY;
 			}
 			index_entry->valid = 0;
@@ -899,9 +931,13 @@ int dpa_classif_table_flush(int td)
 			err = FM_PCD_MatchTableRemoveKey(cc_node,
 						index_entry->entry_index);
 			if (err != E_OK) {
-				pr_err("%s: FM_PCD_MatchTableRemoveKey\n",
-					__func__);
-				pr_err("FMan driver call failed.");
+				pr_err("ERROR: %s, %s (%d): "
+					"FM_PCD_MatchTableRemoveKey "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed.\n", __FILE__, __func__,
+					__LINE__);
 				return -EBUSY;
 			}
 
@@ -933,7 +969,9 @@ int dpa_classif_table_get_entry_stats_by_key(int			td,
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 					table_array.object[td], key);
 	if (entry_id < 0) {
-		pr_err("Unable to determine entry_id.");
+		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
+			"associated with this lookup key.\n", __FILE__,
+			__func__, __LINE__);
 		return entry_id;
 	}
 
@@ -1005,7 +1043,9 @@ int dpa_classif_table_reset_entry_stats_by_key(int			td,
 	entry_id = key_to_entry_id((struct dpa_cls_table *)
 					table_array.object[td], key);
 	if (entry_id < 0) {
-		pr_err("Unable to determine entry_id.");
+		pr_err("ERROR: %s, %s (%d): Unable to determine entry_id "
+			"associated with this lookup key.\n", __FILE__,
+			__func__, __LINE__);
 		return entry_id;
 	}
 
@@ -1073,7 +1113,8 @@ static int alloc_table_management(struct dpa_cls_table *cls_table)
 		kzalloc(cls_table->int_cc_nodes_count *
 			sizeof(*cls_table->int_cc_node), GFP_KERNEL);
 	if (!cls_table->int_cc_node) {
-		pr_err("No more memory for DPA Classifier table management.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"table management.\n", __FILE__, __func__, __LINE__);
 		err = -ENOMEM;
 		goto alloc_table_mgmt_error;
 	}
@@ -1127,9 +1168,11 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 						i,
 						&next_engine_params);
 		if (err != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	}
@@ -1140,7 +1183,9 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
 			GFP_KERNEL);
 	if (!cls_table->entry) {
-		pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"table index management.\n", __FILE__, __func__,
+			__LINE__);
 		cls_table->entries_cnt = 0;
 		return -ENOMEM;
 	}
@@ -1167,7 +1212,8 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 
 	hash_set_params = kzalloc(sizeof(*hash_set_params), GFP_KERNEL);
 	if (!hash_set_params) {
-		pr_err("No more memory for DPA Classifier hash table.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"hash table.\n", __FILE__, __func__, __LINE__);
 		err = -ENOMEM;
 		goto table_init_hash_error;
 	}
@@ -1204,8 +1250,11 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 			(void *)FM_PCD_MatchTableSet(fm_pcd,
 					hash_set_params);
 		if (cls_table->int_cc_node[i].cc_node == NULL) {
-			pr_err("%s: FM_PCD_MatchTableSet\n", __func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableSet failed.\n", __FILE__,
+				__func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1219,9 +1268,11 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 						(uint8_t)i,
 						&next_engine_params);
 		if (err_code != E_OK) {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n",
-				__func__);
-			pr_err("FMan driver call failed.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
@@ -1234,7 +1285,9 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
 			GFP_KERNEL);
 	if (!cls_table->entry) {
-		pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"table index management.\n", __FILE__, __func__,
+			__LINE__);
 		cls_table->entries_cnt	= 0;
 		err			= -ENOMEM;
 		goto table_init_hash_error;
@@ -1282,7 +1335,9 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 		kzalloc(cls_table->entries_cnt * sizeof(*cls_table->entry),
 			GFP_KERNEL);
 	if (!cls_table->entry) {
-		pr_err("No more memory for DPA Classifier table index management.");
+		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
+			"table index management.\n", __FILE__, __func__,
+			__LINE__);
 		cls_table->entries_cnt	= 0;
 		err			= -ENOMEM;
 		goto table_init_exact_match_error;
@@ -1332,10 +1387,13 @@ static void table_cleanup_hash(struct dpa_cls_table *cls_table)
 			FM_PCD_MatchTableDelete((t_Handle)cls_table->
 				int_cc_node[i].cc_node);
 		else {
-			pr_err("%s: FM_PCD_MatchTableModifyNextEngine",
-				__func__);
-			pr_err("FMan driver call failed.");
-			pr_warn("DPA Classifier failed to clean hash table.");
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_MatchTableModifyNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_warn("WARNING: DPA Classifier failed to clean up "
+				"hash table.\n");
 		}
 	}
 }
@@ -1375,7 +1433,9 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 
 		if (params->exact_match_params.key_size >
 				FM_PCD_MAX_SIZE_OF_KEY) {
-			pr_err("DPA Classifier exact match table key size (%d bytes) exceeds maximum (%d bytes).",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier exact match "
+				"table key size (%d bytes) exceeds maximum (%d "
+				"bytes).\n", __FILE__, __func__, __LINE__,
 				params->exact_match_params.key_size,
 				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
@@ -1384,7 +1444,9 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		break;
 	case DPA_CLS_TBL_HASH:
 		if (params->hash_params.num_sets > FM_PCD_MAX_NUM_OF_KEYS) {
-			pr_err("DPA Classifier hash table number of sets (%d) exceeds maximum (%d).",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier hash table "
+				"number of sets (%d) exceeds maximum (%d).\n",
+				__FILE__, __func__, __LINE__,
 				params->hash_params.num_sets,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1397,14 +1459,18 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		while (num_sets < params->hash_params.num_sets)
 			num_sets <<= 1;
 		if (num_sets != params->hash_params.num_sets) {
-			pr_err("DPA Classifier hash table number of sets (%d) must be a power of 2.",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier hash table "
+				"number of sets (%d) must be a power of 2.\n",
+				__FILE__, __func__, __LINE__,
 				params->hash_params.num_sets);
 			err = -EINVAL;
 			break;
 		}
 
 		if (params->hash_params.max_ways > FM_PCD_MAX_NUM_OF_KEYS) {
-			pr_err("DPA Classifier hash table number of ways (%d) exceeds maximum (%d).",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier hash table "
+				"number of ways (%d) exceeds maximum (%d).\n",
+				__FILE__, __func__, __LINE__,
 				params->hash_params.max_ways,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1412,7 +1478,9 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		}
 
 		if (params->hash_params.key_size > FM_PCD_MAX_SIZE_OF_KEY) {
-			pr_err("DPA Classifier hash table key size (%d bytes) exceeds maximum (%d bytes).",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier hash table "
+				"key size (%d bytes) exceeds maximum (%d "
+				"bytes).\n", __FILE__, __func__, __LINE__,
 				params->hash_params.key_size,
 				FM_PCD_MAX_SIZE_OF_KEY);
 			err = -EINVAL;
@@ -1422,7 +1490,9 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 	case DPA_CLS_TBL_INDEXED:
 		if (params->indexed_params.entries_cnt >
 				FM_PCD_MAX_NUM_OF_KEYS) {
-			pr_err("DPA Classifier indexed table size (%d entries) exceeds maximum (%d entries).",
+			pr_err("ERROR: %s, %s (%d): DPA Classifier indexed "
+				"table size (%d entries) exceeds maximum (%d "
+				"entries).\n", __FILE__, __func__, __LINE__,
 				params->indexed_params.entries_cnt,
 				FM_PCD_MAX_NUM_OF_KEYS);
 			err = -EINVAL;
@@ -1430,13 +1500,15 @@ static int verify_table_params(const struct dpa_cls_tbl_params *params)
 		}
 
 		if (params->indexed_params.entries_cnt == 0) {
-			pr_err("Indexed table size zero is invalid.");
+			pr_err("ERROR: %s, %s (%d): Indexed table size zero is "
+				"invalid.\n", __FILE__, __func__, __LINE__);
 			err = -EINVAL;
 			break;
 		}
 		break;
 	default:
-		pr_err("Unsupported DPA Classifier table type (%d).",
+		pr_err("ERROR: %s, %s (%d): Unsupported DPA Classifier table "
+			"type (%d).\n", __FILE__, __func__, __LINE__,
 			params->type);
 		err = -EINVAL;
 	}
@@ -1532,7 +1604,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	memset(&next_engine_params, 0 , sizeof(next_engine_params));
 	errno = action_to_next_engine_params(action, &next_engine_params);
 	if (errno < 0)
-		goto table_insert_entry_indexed_error;
+		return errno;
 
 	cc_node	= (t_Handle)cls_table->int_cc_node[0].cc_node;
 	/* Considering the index as the first byte in the key... */
@@ -1540,10 +1612,12 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 					key->byte[0],
 					&next_engine_params);
 	if (err != E_OK) {
-		pr_err("%s: FM_PCD_MatchTableModifyNextEngine\n", __func__);
-		pr_err("FMan driver call failed.");
-		errno = -EBUSY;
-		goto table_insert_entry_indexed_error;
+		pr_err("ERROR: %s, %s (%d): "
+			"FM_PCD_MatchTableModifyNextEngine failed.\n",
+			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
 	}
 
 	cls_table->int_cc_node[0].used++;
@@ -1552,9 +1626,10 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	if (cls_table->shadow_table) {
 		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
-			pr_err("No more memory for a new DPA Classifier table entry.");
-			errno = -ENOMEM;
-			goto table_insert_entry_indexed_error;
+			pr_err("ERROR: %s, %s (%d): No more memory for a new "
+				"DPA Classifier table entry.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
 		}
 
 		memcpy(&shadow_entry->action, action,
@@ -1582,12 +1657,7 @@ static int table_insert_entry_indexed(struct dpa_cls_table	*cls_table,
 	if (entry_id)
 		*entry_id = key->byte[0];
 
-	return errno;
-
-table_insert_entry_indexed_error:
-	kfree(shadow_entry);
-
-	return errno;
+	return 0;
 }
 
 static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
@@ -1630,7 +1700,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams);
 	if (errno < 0)
-		goto table_insert_entry_exact_match_error;
+		return errno;
 
 	if (cls_table->int_cc_node[0].used >=
 		cls_table->int_cc_node[0].table_size) {
@@ -1638,8 +1708,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		pr_err("ERROR: %s, %s (%d): DPA Classifier exact match table "
 			"is full. Unable to add a new entry.\n",
 			__FILE__, __func__, __LINE__);
-		errno = -ENOSPC;
-		goto table_insert_entry_exact_match_error;
+		return -ENOSPC;
 	}
 
 	/* Find an empty index management entry */
@@ -1705,10 +1774,11 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 		cls_table->params.exact_match_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		pr_err("%s: FM_PCD_MatchTableAddKey\n", __func__);
-		pr_err("FMan driver call failed.");
-		errno = -EBUSY;
-		goto table_insert_entry_exact_match_error;
+		pr_err("ERROR: %s, %s (%d): FM_PCD_MatchTableAddKey failed.\n",
+			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
 	}
 
 	/* Add the index entry to the index management list */
@@ -1736,9 +1806,10 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	if (cls_table->shadow_table) {
 		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
-			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
-			errno = -ENOMEM;
-			goto table_insert_entry_exact_match_error;
+			pr_err("ERROR: %s, %s (%d): No more RAM to add a "
+				"new DPA Classifier shadow table entry.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
 		}
 
 		memcpy(&shadow_entry->action, action,
@@ -1763,12 +1834,7 @@ static int table_insert_entry_exact_match(struct dpa_cls_table	*cls_table,
 	if (entry_id)
 		*entry_id = k;
 
-	return errno;
-
-table_insert_entry_exact_match_error:
-	kfree(shadow_entry);
-
-	return errno;
+	return 0;
 }
 
 static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
@@ -1806,7 +1872,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	errno = action_to_next_engine_params(action,
 				&key_params.ccNextEngineParams);
 	if (errno < 0)
-		goto table_insert_entry_hash_error;
+		return errno;
 
 	hash_set_index = crc64_init();
 	hash_set_index = crc64_compute(key_data,
@@ -1820,9 +1886,9 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	/* Check if there are entries still available in the selected set */
 	if (cls_table->int_cc_node[hash_set_index].used >=
 			cls_table->int_cc_node[hash_set_index].table_size) {
-		pr_err("Hash set is full. Unable to add this entry.");
-		errno = -ENOSPC;
-		goto table_insert_entry_hash_error;
+		pr_err("ERROR: %s, %s (%d): Hash set is full. Unable to add "
+			"this entry.\n", __FILE__, __func__, __LINE__);
+		return -ENOSPC;
 	}
 
 	/* Find an empty index entry */
@@ -1866,10 +1932,11 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 		cls_table->params.hash_params.key_size,
 		&key_params);
 	if (err != E_OK) {
-		pr_err("%s: FM_PCD_MatchTableAddKey\n", __func__);
-		pr_err("FMan driver call failed.");
-		errno = -EBUSY;
-		goto table_insert_entry_hash_error;
+		pr_err("ERROR: %s, %s (%d): FM_PCD_MatchTableAddKey failed.\n",
+			__FILE__, __func__, __LINE__);
+		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+			__FILE__, __func__, __LINE__);
+		return -EBUSY;
 	}
 
 	/* Add the index entry to the index management list */
@@ -1881,9 +1948,10 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if (cls_table->shadow_table) {
 		shadow_entry = kzalloc(sizeof(*shadow_entry), GFP_KERNEL);
 		if (!shadow_entry) {
-			pr_err("No more memory to add a new DPA Classifier shadow table entry.");
-			errno = -ENOMEM;
-			goto table_insert_entry_hash_error;
+			pr_err("ERROR: %s, %s (%d): No more memory to add a "
+				"new DPA Classifier shadow table entry.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
 		}
 
 		memcpy(&shadow_entry->action, action,
@@ -1906,12 +1974,7 @@ static int table_insert_entry_hash(struct dpa_cls_table		*cls_table,
 	if (entry_id)
 		*entry_id = j;
 
-	return errno;
-
-table_insert_entry_hash_error:
-	kfree(shadow_entry);
-
-	return errno;
+	return 0;
 }
 
 static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
@@ -1936,7 +1999,9 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 		break;
 	case DPA_CLS_TBL_ACTION_ENQ:
 		if (action->enq_params.policer_params != NULL) {
-			pr_err("Policing for DPA Classifier flows is not yet supported.");
+			pr_err("ERROR: %s, %s (%d): Policing for DPA "
+				"Classifier flows is not yet supported.\n",
+				__FILE__, __func__, __LINE__);
 			return -ENOSYS;
 		}
 
@@ -1974,7 +2039,8 @@ static int action_to_next_engine_params(const struct dpa_cls_tbl_action *action,
 
 		break;
 	default:
-		pr_err("Unsupported DPA Classifier action type (%d).",
+		pr_err("ERROR: %s, %s (%d): Unsupported DPA Classifier action "
+			"type (%d).\n", __FILE__, __func__, __LINE__,
 			action->type);
 		return -EINVAL;
 	}
@@ -1992,14 +2058,17 @@ static int key_to_entry_id(const struct dpa_cls_table *cls_table,
 		return (int)key->byte[0];
 
 	if (!cls_table->shadow_table) {
-		pr_err("Cannot use runtime functions based on key in a DPA_CLS_TBL_MANAGE_BY_REF table.");
+		pr_err("ERROR: %s, %s (%d): Cannot use runtime functions based "
+			"on key in a DPA_CLS_TBL_MANAGE_BY_REF table.\n",
+			__FILE__, __func__, __LINE__);
 		return -ENOSYS;
 	}
 
 	/* Find the shadow entry associated with this key */
 	shadow_list_entry = find_shadow_entry(cls_table, key);
 	if (shadow_list_entry == NULL) {
-		pr_err("DPA Classifier table entry not found.");
+		pr_err("ERROR: %s, %s (%d): DPA Classifier table entry not "
+			"found.\n", __FILE__, __func__, __LINE__);
 		return -ENODEV;
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 7dd3119..a8272ba 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -105,7 +105,8 @@ int	wrp_dpa_classif_init(void)
 					WRP_DPA_CLS_CDEVNAME,
 					&dpa_classif_fops);
 	if (dpa_cls_cdev_major < 0) {
-		pr_err("Could not register DPA Classifier Control Device.");
+		pr_err("ERROR: %s, %s (%d): Could not register DPA Classifier "
+			"Control Device.\n", __FILE__, __func__, __LINE__);
 		return -EBUSY;
 	}
 
@@ -252,9 +253,9 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_delete_entry_by_ref user "
-				"space args (#1)");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -320,9 +321,9 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_get_entry_stats_by_ref user "
-				"space args (#1)");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -336,9 +337,9 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			pr_err("Could not write "
+			pr_err("ERROR: %s, %s (%d): Write failed: "
 				"dpa_classif_table_get_entry_stats_by_ref "
-				"result");
+				"result.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -370,9 +371,10 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_reset_entry_stats_by_ref "
-				"user space args");
+				"user space args.\n", __FILE__, __func__,
+				__LINE__);
 			return -EBUSY;
 		}
 
@@ -391,9 +393,9 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Prepare arguments */
 		if (copy_from_user(&param, (void *) args, sizeof(param))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_lookup_by_key user space "
-				"args (#1)");
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -405,8 +407,9 @@ long wrp_dpa_classif_do_ioctl(
 
 		/* Return results to user space */
 		if (copy_to_user((void *) args, &param, sizeof(param))) {
-			pr_err("Could not write "
-				"dpa_classif_table_get_params result");
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_get_params result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -414,7 +417,8 @@ long wrp_dpa_classif_do_ioctl(
 	}
 
 	default:
-		pr_err("DPA Classifier ioctl command (0x%x) not suppoted",
+		pr_err("ERROR: %s, %s (%d): DPA Classifier ioctl command "
+			"(0x%x) not suppoted", __FILE__, __func__, __LINE__,
 			cmd);
 		return -EINVAL;
 	}
@@ -433,9 +437,10 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read dpa_classif_table_create "
-				"user space args");
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_create user space args.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -444,8 +449,9 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("Could not read dpa_classif_table_create "
-				"user space args");
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_create user space args.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -468,16 +474,18 @@ static long do_ioctl_table_create(unsigned long args, bool compat_mode)
 #ifdef CONFIG_COMPAT
 	if (compat_mode) {
 		uparam.td = kparam.td;
-		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			pr_err("Could not write dpa_classif_table_create "
-				"result");
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_create result.\n", __FILE__,
+				__func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("Could not write dpa_classif_table_create "
-				"result");
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_create result.\n", __FILE__,
+				__func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -493,10 +501,10 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_miss_action user "
-				"space args");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -506,9 +514,9 @@ static long do_ioctl_table_modify_miss_action(unsigned long	args,
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_miss_action user "
-				"space args");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -528,10 +536,10 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_insert_entry user space "
-				"args");
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -554,23 +562,22 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 	{
-		if (copy_from_user(&kparam, (void *) args,
-				    sizeof(kparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_insert_entry user space "
-				"args (#1)");
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
 		/* Check if we need to copy also the policer params */
 		if ((kparam.action.type == DPA_CLS_TBL_ACTION_ENQ) &&
-		(kparam.action.enq_params.policer_params != NULL)) {
+				(kparam.action.enq_params.policer_params)) {
 			if (copy_from_user(&policer_params,
 				kparam.action.enq_params.policer_params,
 				sizeof(policer_params))) {
-				pr_err("Could not read "
-					"dpa_classif_table_insert_entry user "
-					"space args (#2)");
+				pr_err("ERROR: %s, %s (%d): Read failed: "
+					"policer params.\n", __FILE__, __func__,
+					__LINE__);
 				return -EBUSY;
 			}
 		kparam.action.enq_params.policer_params = &policer_params;
@@ -591,18 +598,18 @@ static long do_ioctl_table_insert_entry(unsigned long args, bool compat_mode)
 	if (compat_mode) {
 		uparam.entry_id = kparam.entry_id;
 
-		if (copy_to_user(compat_ptr(args), &uparam,
-				sizeof(uparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_insert_entry result");
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_insert_entry result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
-		if (copy_to_user((void *) args, &kparam,
-				sizeof(kparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_insert_entry result");
+		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_insert_entry result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -622,11 +629,10 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args),
-				sizeof(uparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_entry_by_key user "
-				"space args (#1)");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -684,11 +690,10 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 	} else
 #endif /* CONFIG_COMPAT */
 	{
-		if (copy_from_user(&kparam, (void *) args,
-				sizeof(kparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_entry_by_key user "
-				"space args (#1)");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -709,9 +714,9 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 			if (copy_from_user(&action,
 				kparam.mod_params.action,
 				sizeof(struct dpa_cls_tbl_action))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_key "
-					"user space args (#3)");
+				pr_err("ERROR: %s, %s (%d): Read failed: "
+					"new action params.\n", __FILE__,
+					__func__, __LINE__);
 				return -EBUSY;
 			}
 			kparam.mod_params.action = &action;
@@ -726,9 +731,9 @@ static long do_ioctl_table_modify_entry_by_key(unsigned long	args,
 					action->enq_params.
 					policer_params,
 					sizeof(policer_params))) {
-					pr_err("Could not read "
-				"dpa_classif_table_modify_entry_by_key user "
-				"space args (#4)");
+					pr_err("ERROR: %s, %s (%d): Read "
+				"failed: new policer params.\n", __FILE__,
+				__func__, __LINE__);
 					return -EBUSY;
 				}
 				kparam.mod_params.action->enq_params.
@@ -758,10 +763,10 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_entry_by_ref user "
-				"space args");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -820,9 +825,9 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 #endif /* CONFIG_COMPAT */
 	{
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_modify_entry_by_ref user "
-				"space args (#1)");
+				"space args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -843,9 +848,9 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 			if (copy_from_user(&action,
 				kparam.mod_params.action,
 				sizeof(struct dpa_cls_tbl_action))) {
-				pr_err("Could not read "
-					"dpa_classif_table_modify_entry_by_ref "
-					"user space args (#3)");
+				pr_err("ERROR: %s, %s (%d): Read failed: "
+					"new action params.\n", __FILE__,
+					__func__, __LINE__);
 				return -EBUSY;
 			}
 			kparam.mod_params.action = &action;
@@ -860,9 +865,9 @@ static long do_ioctl_table_modify_entry_by_ref(unsigned long	args,
 					action->enq_params.
 					policer_params,
 					sizeof(policer_params))) {
-					pr_err("Could not read "
-				"dpa_classif_table_modify_entry_by_ref user "
-				"space args (#4)");
+					pr_err("ERROR: %s, %s (%d): Read "
+				"failed: new policer params.\n", __FILE__,
+				__func__, __LINE__);
 					return -EBUSY;
 				}
 				kparam.mod_params.action->enq_params.
@@ -887,10 +892,10 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read "
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_lookup_by_key user space "
-				"args");
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -900,9 +905,9 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-			pr_err("Could not read "
+			pr_err("ERROR: %s, %s (%d): Read failed: "
 				"dpa_classif_table_lookup_by_key user space "
-				"args (#1)");
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -926,16 +931,18 @@ static long do_ioctl_table_lookup_by_key(unsigned long args, bool compat_mode)
 		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
 			&kparam.action);
 
-		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_lookup_by_key result");
+		if (copy_to_user((void *) args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_lookup_by_key result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_lookup_by_key result");
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_lookup_by_key result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -951,9 +958,10 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 
 	/* Prepare arguments */
 	if (compat_mode) {
-		if (copy_from_user(&uparam, compat_ptr(args), sizeof(uparam))) {
-			pr_err("Could not read "
-				"dpa_classif_table_lookup_by_ref user space args");
+		if (copy_from_user(&uparam, (void *) args, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_lookup_by_ref user space "
+				"args.\n", __FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
@@ -962,13 +970,13 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 			&uparam);
 	} else
 #endif /* CONFIG_COMPAT */
-
-	/* Prepare arguments */
-	if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
-		pr_err("Could not read dpa_classif_table_lookup_by_ref user "
-			"space args (#1)");
-		return -EBUSY;
-	}
+		/* Prepare arguments */
+		if (copy_from_user(&kparam, (void *) args, sizeof(kparam))) {
+			pr_err("ERROR: %s, %s (%d): Read failed: "
+				"dpa_classif_table_lookup_by_ref user space "
+				"args.\n", __FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 
 	/* Call function */
 	ret = dpa_classif_table_lookup_by_ref(kparam.td,
@@ -990,16 +998,18 @@ static long do_ioctl_table_lookup_by_ref(unsigned long args, bool compat_mode)
 		dpa_cls_tbl_action_params_rcompatcpy(&uparam.action,
 			&kparam.action);
 
-		if (copy_to_user(compat_ptr(args), &uparam, sizeof(uparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_lookup_by_ref result");
+		if (copy_to_user((void *)args, &uparam, sizeof(uparam))) {
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_lookup_by_ref result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 	} else
 #endif /* CONFIG_COMPAT */
 		if (copy_to_user((void *) args, &kparam, sizeof(kparam))) {
-			pr_err("Could not write "
-				"dpa_classif_table_lookup_by_ref result");
+			pr_err("ERROR: %s, %s (%d): Write failed: "
+				"dpa_classif_table_lookup_by_ref result.\n",
+				__FILE__, __func__, __LINE__);
 			return -EBUSY;
 		}
 
-- 
1.7.5.4

