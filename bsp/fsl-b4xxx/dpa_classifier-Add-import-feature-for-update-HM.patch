From e6e608f732ea9f310c852cd95c69d3265c56d330 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Sep 2012 20:02:38 +0000
Subject: [PATCH 301/518] dpa_classifier: Add import feature for update HM

Implemented the import feature for the update header manipulation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  248 +++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |   12 +-
 2 files changed, 131 insertions(+), 129 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 927190d..eecdeb4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3831,12 +3831,6 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 
 	*hmd = DPA_OFFLD_DESC_NONE;
 
-	if (res) {
-		pr_err("ERROR: %s, %s (%d): Header manipulation import is not "
-			"yet supported.\n", __FILE__, __func__, __LINE__);
-		return -ENOSYS;
-	}
-
 	err = update_hm_check_params(update_params);
 	if (err < 0)
 		return err;
@@ -3854,117 +3848,153 @@ int dpa_classif_set_update_hm(const struct dpa_cls_hm_update_params
 	memcpy(&pupdate_hm->update_params, update_params,
 						sizeof(*update_params));
 
-	if (res)
-		err = import_update_hm(pupdate_hm, res);
-	else {
-		err = init_update_hm(pupdate_hm);
-		if (err) {
-			dpa_classif_free_hm(*hmd);
-			*hmd = DPA_OFFLD_DESC_NONE;
-			return err;
-		}
-
-		if (chain_head)
-			/* Initialize low level HM ops chain */
-			err = init_hm_chain(pupdate_hm->update_params.fm_pcd,
-				pupdate_hm->hm_chain, pupdate_hm->hm_chain);
+	err = update_hm_prepare_nodes(pupdate_hm, res);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to acquire necessary HM "
+			"nodes.\n", __FILE__, __func__, __LINE__);
+		goto update_hm_error;
 	}
 
-	if (err) {
-		dpa_classif_free_hm(*hmd);
-		*hmd = DPA_OFFLD_DESC_NONE;
+	err = update_hm_update_params(pupdate_hm);
+	if (err < 0) {
+		pr_err("ERROR: %s, %s (%d): Failed to update low level header "
+			"manipulation parameters.\n", __FILE__, __func__,
+			__LINE__);
+		goto update_hm_error;
 	}
 
+	if (chain_head)
+		err = init_hm_chain(pupdate_hm->update_params.fm_pcd,
+				pupdate_hm->hm_chain,
+				pupdate_hm->hm_chain);
+
+	return err;
+
+update_hm_error:
+
+	remove_hm_op(*hmd);
+
+	*hmd = DPA_OFFLD_DESC_NONE;
+
 	return err;
 }
 EXPORT_SYMBOL(dpa_classif_set_update_hm);
 
-static int import_update_hm(struct dpa_cls_hm *pupdate_hm,
+static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 				const struct dpa_cls_hm_update_resources *res)
 {
+	struct dpa_cls_hm_node *hm_node = NULL;
 	void * const *phm_nodes;
-	int err;
+	struct dpa_cls_hm *pnext_hm = NULL;
+	int update_ops, replace_ops;
+	int err = 0;
 
 	BUG_ON(!pupdate_hm);
-	BUG_ON(!res);
 
-	phm_nodes = &res->update_node;
+	pupdate_hm->num_nodes = 2;
 
-	err = import_hm_nodes_to_chain(phm_nodes, 1, pupdate_hm);
+	if (res) { /* Import HM nodes */
+		phm_nodes = &res->update_node;
 
-	/* Update here the hm nodes parameters */
+		return import_hm_nodes_to_chain(phm_nodes,
+					pupdate_hm->num_nodes,
+					pupdate_hm);
+	}
 
-	return err;
-}
+	update_ops = DPA_CLS_HM_UPDATE_IPv4_UPDATE |
+			DPA_CLS_HM_UPDATE_IPv6_UPDATE |
+			DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE;
 
-static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
-{
-	struct dpa_cls_hm_node *hm_node = NULL;
-	struct dpa_cls_hm *pnext_hm = NULL;
-	uint8_t size = 0;
-	int update_ops, replace_ops;
+	replace_ops = DPA_CLS_HM_REPLACE_IPv4_BY_IPv6 |
+			DPA_CLS_HM_REPLACE_IPv6_BY_IPv4;
 
-	BUG_ON(!pupdate_hm);
+	if ((pupdate_hm->update_params.op_flags & update_ops) ||
+		(pupdate_hm->update_params.op_flags & replace_ops)) {
+		/* Create HM nodes */
+		/* Check if we can attach to an existing update node */
+		if (!list_empty(&pupdate_hm->list_node)) {
+			pnext_hm = list_entry(pupdate_hm->list_node.next,
+					struct dpa_cls_hm,
+					list_node);
 
-	/* Check if we can attach to an existing update node */
-	if (!list_empty(&pupdate_hm->list_node)) {
-		pnext_hm = list_entry(pupdate_hm->list_node.next,
-				struct dpa_cls_hm,
-				list_node);
+			if (pupdate_hm->update_params.op_flags &
+				DPA_CLS_HM_UPDATE_IPv4_UPDATE)
+				/*
+				 * See if there is any other IPv4 update node
+				 * in this chain
+				 */
+				hm_node = find_compatible_hm_node(
+					DPA_CLS_HM_NODE_IPv4_HDR_UPDATE,
+					pnext_hm->hm_chain);
 
-		if (pupdate_hm->update_params.op_flags &
-			DPA_CLS_HM_UPDATE_IPv4_UPDATE)
-			/*
-			 * See if there is any other IPv4 update node in this
-			 * chain
-			 */
-			hm_node = find_compatible_hm_node(
-				DPA_CLS_HM_NODE_IPv4_HDR_UPDATE,
-				pnext_hm->hm_chain);
+			if (pupdate_hm->update_params.op_flags &
+				DPA_CLS_HM_UPDATE_IPv6_UPDATE)
+				/*
+				 * See if there is any other IPv6 update node
+				 * in this chain
+				 */
+				hm_node = find_compatible_hm_node(
+					DPA_CLS_HM_NODE_IPv6_HDR_UPDATE,
+					pnext_hm->hm_chain);
 
-		if (pupdate_hm->update_params.op_flags &
-			DPA_CLS_HM_UPDATE_IPv6_UPDATE)
-			/*
-			 * See if there is any other IPv6 update node in this
-			 * chain
-			 */
-			hm_node = find_compatible_hm_node(
-				DPA_CLS_HM_NODE_IPv6_HDR_UPDATE,
-				pnext_hm->hm_chain);
+			if (pupdate_hm->update_params.op_flags &
+				DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE)
+				/*
+				 * See if there is any other TCP/UDP header
+				 * update node in this chain
+				 */
+				hm_node = find_compatible_hm_node(
+					DPA_CLS_HM_NODE_TCPUDP_HDR_UPDATE,
+					pnext_hm->hm_chain);
+		}
 
-		if (pupdate_hm->update_params.op_flags &
-			DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE)
-			/*
-			 * See if there is any other TCP/UDP header update node
-			 * in this chain
-			 */
-			hm_node = find_compatible_hm_node(
-				DPA_CLS_HM_NODE_TCPUDP_HDR_UPDATE,
-				pnext_hm->hm_chain);
-	}
+		/*
+		 * If no compatible HM node was found for the header update
+		 * operations...
+		 */
+		if (!hm_node) {
+			/* Create a header manip node for this update: */
+			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
 
-	/*
-	 * If no compatible HM node was found for the header update
-	 * operations...
-	 */
-	if (!hm_node) {
-		/* Create a header manip node for this update: */
-		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-		size = (uint8_t)sizeof(*hm_node);
-	}
+			if (!hm_node) {
+				pr_err("ERROR: %s, %s (%d): No more memory for "
+					"header manip nodes.\n", __FILE__,
+					__func__, __LINE__);
+				return -ENOMEM;
+			}
 
-	if (!hm_node) {
-		pr_err("ERROR: %s, %s (%d): No more memory for header manip "
-			"nodes.\n", __FILE__, __func__, __LINE__);
-		return -ENOMEM;
+			INIT_LIST_HEAD(&hm_node->list_node);
+		}
+
+		pupdate_hm->hm_node[0] = hm_node;
 	}
 
-	pupdate_hm->num_nodes = 0;
-	if (size) {
-		hm_node->params.type = -1;
+	if (pupdate_hm->update_params.ip_frag_params.mtu) {
+		/* IP fragmentation option is enabled */
+		/* Create a header manip node: */
+		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+		if (!hm_node) {
+			pr_err("ERROR: %s, %s (%d): No more memory for header "
+				"manip nodes.\n", __FILE__, __func__, __LINE__);
+			return -ENOMEM;
+		}
+
 		INIT_LIST_HEAD(&hm_node->list_node);
+		pupdate_hm->hm_node[1] = hm_node;
 	}
 
+	add_local_hm_nodes_to_chain(pupdate_hm);
+
+	return err;
+}
+
+static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
+{
+	struct dpa_cls_hm_node *hm_node;
+	int update_ops, replace_ops;
+
+	BUG_ON(!pupdate_hm);
+
 	update_ops = DPA_CLS_HM_UPDATE_IPv4_UPDATE |
 			DPA_CLS_HM_UPDATE_IPv6_UPDATE |
 			DPA_CLS_HM_UPDATE_UDP_TCP_UPDATE;
@@ -3972,10 +4002,14 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 	replace_ops = DPA_CLS_HM_REPLACE_IPv4_BY_IPv6 |
 			DPA_CLS_HM_REPLACE_IPv6_BY_IPv4;
 
+	hm_node = pupdate_hm->hm_node[0];
+
 	if (pupdate_hm->update_params.op_flags & update_ops) {
+		BUG_ON(!hm_node);
 
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_IPv4_UPDATE) {
@@ -4115,11 +4149,13 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 	}
 
 	if (pupdate_hm->update_params.op_flags & replace_ops) {
+		BUG_ON(!hm_node);
 
 		hm_node->params.type		= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.custom	= TRUE;
 		hm_node->params.u.hdr.customParams.type =
 				e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE;
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_REPLACE_IPv4_BY_IPv6) {
@@ -4151,25 +4187,10 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 		}
 	}
 
-	if (hm_node->params.type != -1) {
-		pupdate_hm->hm_node[pupdate_hm->num_nodes++] = hm_node;
-		hm_node = NULL;
-	}
-
+	hm_node = pupdate_hm->hm_node[1];
 	if (pupdate_hm->update_params.ip_frag_params.mtu) {
 		/* IP fragmentation option is enabled */
-		/* Create a header manip node: */
-		if (!hm_node) {
-			hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
-			if (!hm_node) {
-				pr_err("ERROR: %s, %s (%d): No more memory for "
-					"header manip nodes.\n", __FILE__,
-					__func__, __LINE__);
-				return -ENOMEM;
-			}
-
-			INIT_LIST_HEAD(&hm_node->list_node);
-		}
+		BUG_ON(!hm_node);
 
 		hm_node->params.type = e_FM_PCD_MANIP_FRAG;
 		hm_node->params.u.frag.hdr = HEADER_TYPE_IPv4;
@@ -4192,12 +4213,8 @@ static int init_update_hm(struct dpa_cls_hm *pupdate_hm)
 				e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET;
 			break;
 		}
-
-		pupdate_hm->hm_node[pupdate_hm->num_nodes++] = hm_node;
 	}
 
-	add_local_hm_nodes_to_chain(pupdate_hm);
-
 	return 0;
 }
 
@@ -4205,8 +4222,8 @@ int dpa_classif_modify_update_hm(int hmd,
 	const struct dpa_cls_hm_update_params *new_update_params,
 	int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Update HM runtime modification not "
-		"supported yet.\n", __FILE__, __func__, __LINE__);
+	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
+		__LINE__);
 	return -ENOSYS;
 }
 EXPORT_SYMBOL(dpa_classif_modify_update_hm);
@@ -4687,24 +4704,17 @@ int dpa_classif_free_hm(int hmd)
 		/* Descriptor already free */
 		return 0;
 
-	if (!list_empty(&phm->list_node))
-		list_del(&phm->list_node);
-
 	if (phm->chain_head) {
 		/*
 		 * This is a header manip chain head, hence remove the entire
 		 * chain of low level ops
 		 */
-		if (remove_hm_chain(phm->hm_chain, phm->hm_chain)
-			< 0)
+		if (remove_hm_chain(phm->hm_chain, phm->hm_chain) < 0)
 			pr_warn("WARNING: Failed to remove HM nodes for chain "
 				"hmd=%d.\n", hmd);
 	}
 
-	kfree(phm);
-	hm_array.object[hmd] = NULL;
-
-	put_descriptor(&hm_array, hmd);
+	remove_hm_op(hmd);
 
 	return 0;
 }
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 7843e27..946ba90 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -477,18 +477,10 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm);
 static int update_hm_check_params(const struct dpa_cls_hm_update_params
 	*update_params);
 
-/*
- * Imports the low level header manipulation nodes for a header update
- * classifier header manipulation op.
- */
-static int import_update_hm(struct dpa_cls_hm *pupdate_hm,
+static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 				const struct dpa_cls_hm_update_resources *res);
 
-/*
- * Creates the low level header manipulation nodes for a header update
- * classifier header manipulation op.
- */
-static int init_update_hm(struct dpa_cls_hm *pupdate_hm);
+static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm);
 
 /*
  * Verifies that the parameters provided for a VLAN specific header
-- 
1.7.5.4

