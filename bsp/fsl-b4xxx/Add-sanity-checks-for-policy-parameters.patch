From d8923da1649a0c2c73e41db5e33e5c45dd9e7e71 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:15 +0000
Subject: [PATCH 237/518] Add sanity checks for policy parameters

When new policies are offloaded check policy parameters to prevent
invalid configurations like: source and destination IP adress types

differ, setting fragementation options for policies attached to
inbound SAs, setting post inbound policy verification action for
policies attached to outbound SAs & others.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c     |   46 ++++++++++++++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c |   57 ++++++++++++++++++++--
 2 files changed, 97 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index b7cacb6..68e3e0a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2201,6 +2201,46 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	return 0;
 }
 
+static int check_policy_params(struct dpa_ipsec_sa *sa,
+			       struct dpa_ipsec_policy_params *pol_params)
+{
+	BUG_ON(!sa);
+	BUG_ON(!pol_params);
+
+	/* check if both IP address are of the same type */
+	if (pol_params->src_addr.addr_type != pol_params->dest_addr.addr_type) {
+		pr_err("Src and dest IP address types must be the same!\n");
+		return -EINVAL;
+	}
+
+	/* check if fragmentation is enabled for inbound SAs */
+	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_FRAG &&
+	    sa->sa_dir == DPA_IPSEC_INBOUND) {
+		pr_err("Fragmentation can't be enabled for inbound policy!\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * check if post inbound policy verification action was configured for
+	 * outbound policies
+	 */
+	if (pol_params->dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT &&
+	    sa->sa_dir == DPA_IPSEC_OUTBOUND) {
+		pr_err("Action cannot be configured for outbound policy!\n");
+		return -EINVAL;
+	}
+
+	/* check if DF bit was set and an IPv6 policy is being offloaded */
+	if (sa->sa_dir == DPA_IPSEC_OUTBOUND &&
+	    sa->sec_desc->pdb_en.hmo_rsvd == PDBHMO_ESP_DFBIT &&
+	    pol_params->src_addr.addr_type == DPA_IPSEC_ADDR_T_IPv6) {
+		pr_err("Can't add IPv6 policy to IPv4 SA w/ DF bit copy set\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 				struct dpa_ipsec_policy_params *policy_params,
 				struct dpa_ipsec_policy_entry **policy_entry)
@@ -3266,6 +3306,12 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		return -EBUSY;
 	}
 
+	ret = check_policy_params(sa, policy_params);
+	if (ret < 0) {
+		mutex_unlock(&sa->lock);
+		return ret;
+	}
+
 	if (sa_is_parent(sa) && sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		pr_err("Illegal to set out policy - parent SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 2499b36..43fe02c 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -290,18 +290,42 @@ static void compat_copy_dpa_ipsec_add_rem_policy(
 						DPA_IPSEC_POL_DIR_PARAMS_FRAG)
 			prm->pol_params.dir_params.out_frag =
 				     compat_prm->pol_params.dir_params.out_frag;
-		else if (compat_prm->pol_params.dir_params.type) {
+		else if (compat_prm->pol_params.dir_params.type ==
+						 DPA_IPSEC_POL_DIR_PARAMS_ACT) {
 			dpa_cls_tbl_action_params_compatcpy(
 				  &prm->pol_params.dir_params.in_action,
 				  &compat_prm->pol_params.dir_params.in_action);
 		}
 		prm->pol_params.dir_params.type =
 					 compat_prm->pol_params.dir_params.type;
+	} else {
+		compat_prm->sa_id = prm->sa_id;
+		compat_prm->pol_params.src_addr = prm->pol_params.src_addr;
+		compat_prm->pol_params.src_prefix_len =
+						 prm->pol_params.src_prefix_len;
+		compat_prm->pol_params.dest_addr = prm->pol_params.src_addr;
+		compat_prm->pol_params.dest_prefix_len =
+						prm->pol_params.dest_prefix_len;
+		compat_prm->pol_params.protocol = prm->pol_params.protocol;
+		compat_prm->pol_params.masked_proto =
+						   prm->pol_params.masked_proto;
+		compat_prm->pol_params.l4 = prm->pol_params.l4;
+		memset(&compat_prm->pol_params.dir_params, 0,
+		       sizeof(compat_prm->pol_params.dir_params));
+		if (prm->pol_params.dir_params.type ==
+						DPA_IPSEC_POL_DIR_PARAMS_FRAG)
+			compat_prm->pol_params.dir_params.out_frag =
+					    prm->pol_params.dir_params.out_frag;
+		else if (prm->pol_params.dir_params.type ==
+						 DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+			dpa_cls_tbl_action_params_rcompatcpy(
+				  &compat_prm->pol_params.dir_params.in_action,
+				  &prm->pol_params.dir_params.in_action);
+		}
+		compat_prm->pol_params.dir_params.type =
+						prm->pol_params.dir_params.type;
 	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
+
 }
 
 static void compat_copy_dpa_ipsec_get_pols(
@@ -802,9 +826,11 @@ free_pol_memory:
 static int do_sa_get_policies_ioctl(void *args, bool compat)
 {
 	struct ioc_dpa_ipsec_get_policies prm;
-	struct dpa_ipsec_policy_params *policy_params;
+	struct dpa_ipsec_policy_params *policy_params = NULL;
 #ifdef CONFIG_COMPAT
 	struct ioc_compat_dpa_ipsec_get_policies compat_prm;
+	struct ioc_compat_policy_params *compat_pol_params = NULL;
+	int i;
 #endif
 	int sa_id, num_pol, err = 0;
 
@@ -873,11 +899,30 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 	} else if (err == -EAGAIN)
 		pr_err("Not all SA policies could be retrieved");
 
+#ifdef CONFIG_COMPAT
+	compat_pol_params = kzalloc(num_pol * sizeof(*compat_pol_params),
+				    GFP_KERNEL);
+	if (!compat_pol_params) {
+		pr_err("Could not allocate memory for compat policy array!\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_pol; i++)
+		compat_copy_dpa_ipsec_add_rem_policy(&policy_params[i],
+						     &compat_pol_params[i],
+						     COMPAT_K_TO_US);
+	if (copy_to_user(prm.policy_params, compat_pol_params,
+			 num_pol * sizeof(*compat_pol_params))) {
+		pr_err("Could not return policy parameters\n");
+		err = -EINVAL;
+	}
+#else
 	if (copy_to_user(prm.policy_params, policy_params,
 			 num_pol * sizeof(*policy_params))) {
 		pr_err("Could not return policy parameters\n");
 		err = -EINVAL;
 	}
+#endif
 	/*
 	 * None of the values of the members in the input structure have been
 	 * modified, so there is no need to copy the input structure back to the
-- 
1.7.5.4

