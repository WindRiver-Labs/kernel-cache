From 95f5183b2288d42778607fe3cd169b2d9b87c348 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Tue, 14 Feb 2012 23:19:35 +0000
Subject: [PATCH 098/518] Bug fixing in the DPA IPSec component

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Signed-off-by: Mihai Serb  <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  100 +++++++++++++++++---------
 1 files changed, 65 insertions(+), 35 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index b292b11..2219f9f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -621,10 +621,9 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 				return -ENOEXEC;
 			}
 			pol_table->cc_node = cc_node;
-
 			memset(&params, 0, sizeof(params));
 			params.fm_pcd = dpa_ipsec->config.fm_pcd;
-			params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_KEY;
+			params.entry_mgmt = DPA_CLS_TBL_MANAGE_BY_REF;
 			params.type = DPA_CLS_TBL_EXACT_MATCH;
 			params.exact_match_params.entries_cnt =
 						    DPA_IPSEC_MAX_IN_POL_PER_SA;
@@ -681,7 +680,7 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 		fmd_err = FM_PCD_CcDeleteNode(dpa_ipsec->config.fm_pcd,
 				pol_tbl->cc_node);
 		if (fmd_err != E_OK)
-			xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteTree");
+			xx_pr_fmd_err(fmd_err, "FM_PCD_CcDeleteNode");
 		xx_free(pol_tbl);
 	}
 
@@ -714,7 +713,7 @@ static void free_sa_mng(struct dpa_ipsec *dpa_ipsec)
 			sa_mng->sa[i].to_sec_fq = NULL;
 		}
 		if (sa_mng->sa[i].sec_desc) {
-			xx_free(sa_mng->sa[i].sec_desc);
+			xx_free_smart(sa_mng->sa[i].sec_desc);
 			sa_mng->sa[i].sec_desc = NULL;
 		}
 	}
@@ -1341,18 +1340,21 @@ static int remove_sa_sec_fq(struct qman_fq *sec_fq)
 static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 {
 	struct qman_fq *to_sec_fq, *from_sec_fq;
+	enum qman_fq_state state;
 	int err;
+	u32 flags;
 
 	to_sec_fq = sa->to_sec_fq;
 	from_sec_fq = sa->from_sec_fq;
 
+	qman_fq_state(to_sec_fq, &state, &flags);
 	if (qman_fq_fqid(to_sec_fq) != 0) {
 		err = remove_sa_sec_fq(to_sec_fq);
 		if (err < 0)
 			return err;
 	}
 
-	if (qman_fq_fqid(from_sec_fq) != 0) {
+	if (state != qman_fq_state_parked && qman_fq_fqid(from_sec_fq) != 0) {
 		err = remove_sa_sec_fq(from_sec_fq);
 		if (err < 0)
 			return err;
@@ -1731,7 +1733,8 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	/* Updated the offset to the point in frame were the encrypted
 	 * stuff starts.*/
-	sa->sec_desc->pdb_dec.hmo_ip_hdr_len = (uint16_t) sizeof(struct ip_header);
+	sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
+					(uint16_t) sizeof(struct ip_header);
 	if (sa->use_udp_encap)
 		sa->sec_desc->pdb_dec.hmo_ip_hdr_len += UDP_HEADER_LEN;
 
@@ -2306,7 +2309,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_sa_mng *sa_mng;
 	struct dpa_ipsec_sa *sa;
-	struct dpa_ipsec_policy_entry *policy_entry, *tmp_policy_entry;
+	struct dpa_ipsec_policy_entry *pol_entr, *tmp_pol_entr;
 	int timeout = 10000, err = 0;
 
 	if (!gbl_dpa_ipsec) {
@@ -2324,6 +2327,7 @@ int dpa_ipsec_remove_sa(int sa_id)
 	}
 
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
+		int td;
 		/* Remove the PCD entry that makes traffic to go to SEC
 		 * First check that we have a valid entry reference.
 		 * In case previous add/remove operations failed, this entry
@@ -2358,19 +2362,6 @@ int dpa_ipsec_remove_sa(int sa_id)
 			return -EBUSY;
 		}
 
-		/* Remove all the PCD entries from the offline port post SEC */
-		if (!list_empty(&sa->policy_headlist)) {
-			list_for_each_entry_safe(policy_entry,
-						 tmp_policy_entry,
-						 &sa->policy_headlist, node) {
-				err = remove_policy(sa, policy_entry);
-				if (err < 0) {
-					xx_pr_err(("Could not remove PCD entry for policy\n"));
-					return -EAGAIN;
-				}
-			}
-		}
-
 		/* Destroy the TO_SEC and FROM_SEC queues */
 		err = remove_sa_fq_pair(sa);
 		if (err != 0) {
@@ -2379,10 +2370,21 @@ int dpa_ipsec_remove_sa(int sa_id)
 		}
 
 		/* Free all memory used for this SA */
+		td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
 		if ((dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE)
 		    && (sa->inbound_indx_entry != -1)) {
-			int td;
-			td = dpa_ipsec->config.post_sec_in_params.dpa_cls_td;
+			/* Remove all the PCD entries from the offline port
+			 * post SEC */
+			if (!list_empty(&sa->policy_headlist)) {
+				list_for_each_entry_safe(pol_entr, tmp_pol_entr,
+						&sa->policy_headlist, node) {
+					err = remove_policy(sa, pol_entr);
+					if (err < 0) {
+						xx_pr_err(("Couldn't remove policy entry"));
+						return -EAGAIN;
+					}
+				}
+			}
 			err = dpa_classif_table_delete_entry_by_ref(td,
 							sa->inbound_indx_entry);
 			if (err < 0) {
@@ -2390,22 +2392,34 @@ int dpa_ipsec_remove_sa(int sa_id)
 				return -EAGAIN;
 			}
 			put_free_inbpol_tbl(dpa_ipsec, sa->em_inpol_td);
+		} else {
+			if (sa->inbound_indx_entry != -1) {
+				err = dpa_classif_table_delete_entry_by_ref(td,
+							sa->inbound_indx_entry);
+				if (err < 0) {
+					xx_pr_err(("Could not remove SA entry in indexed table\n"));
+					return -EAGAIN;
+				}
+			}
 		}
-		put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+
+		if (sa->inbound_indx_entry != -1)
+			put_inbound_flowid(dpa_ipsec, sa->inbound_flowid);
+		sa->inbound_indx_entry = -1;
 
 		/* Mark as free index in used sa ids vector of this dpa ipsec
 		 * instance */
 		dpa_ipsec->used_sa_ids[sa->used_sa_index] =
-		    DPA_IPSEC_INVALID_SA_ID;
+						DPA_IPSEC_INVALID_SA_ID;
 		dpa_ipsec->num_used_sas--;
 		cq_put_4bytes(sa_mng->sa_id_cq, sa->id);
 	} else {  /* DPA_IPSEC_OUTBOUND */
 		/* Remove the PCD entries that make traffic to go to SEC */
 		if (!list_empty(&sa->policy_headlist)) {
-			list_for_each_entry_safe(policy_entry,
-						 tmp_policy_entry,
+			list_for_each_entry_safe(pol_entr,
+						 tmp_pol_entr,
 						 &sa->policy_headlist, node) {
-				err = remove_policy(sa, policy_entry);
+				err = remove_policy(sa, pol_entr);
 				if (err < 0) {
 					xx_pr_err(("Could not remove policy PCD entry\n"));
 					return -EAGAIN;
@@ -2565,6 +2579,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	new_sa->used_sa_index = i;
 	new_sa->dpa_ipsec->used_sa_ids[i] = new_sa->id;
 	new_sa->dpa_ipsec->num_used_sas++;
+	new_sa->inbound_indx_entry = -1;
 
 	/* Copy SA params into the internal SA structure */
 	if (old_sa->sa_dir == DPA_IPSEC_OUTBOUND) {
@@ -2593,11 +2608,6 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	/* Exact match table will be reused by the new SA. */
 	new_sa->em_inpol_td = old_sa->em_inpol_td;
 
-	/* Link the entries of the policy list to the policy list on the new SA.
-	 * The policy list from the old SA becomes void.
-	 */
-	list_splice_init(&old_sa->policy_headlist, &new_sa->policy_headlist);
-
 	/* Call internal function to create SEC queues according to SA
 	 * parameters */
 	err = create_sa_fq_pair(new_sa, TRUE, TRUE);
@@ -2609,6 +2619,12 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	/* AV's note: Since we have reused the FROM SEC FQ it is not needed to
 	 * make another entry in the PCD node of the post encryption OH PORT. */
 	if (new_sa->sa_dir == DPA_IPSEC_OUTBOUND) {
+		/* Link the entries of the policy list to the policy
+		 * list on the new SA.
+		 * The policy list from the old SA becomes void.
+		 */
+		list_splice_init(&old_sa->policy_headlist,
+				 &new_sa->policy_headlist);
 		/* Need to update the outbound policy if we have policies */
 		if (!list_empty(&new_sa->policy_headlist)) {
 			list_for_each_entry_safe(policy_entry, tmp_policy_entry,
@@ -2655,9 +2671,6 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 			goto rekey_sa_err;
 		}
 
-		if (dpa_ipsec->config.post_sec_in_params.do_pol_check)
-			new_sa->inbound_indx_entry = old_sa->inbound_indx_entry;
-
 		/* Add new SA into the sa_rekeying_headlist */
 		list_add(&new_sa->sa_rekeying_node,
 			 &sa_mng->sa_rekeying_headlist);
@@ -2760,6 +2773,17 @@ void sa_rekeying_work_func(struct work_struct *work)
 			dpa_ipsec->used_sa_ids[old_sa->used_sa_index] =
 				DPA_IPSEC_INVALID_SA_ID;
 			dpa_ipsec->num_used_sas--;
+			/* Update the new SA with old SA's inbound indx entry */
+			if (dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+				new_sa->inbound_indx_entry =
+					old_sa->inbound_indx_entry;
+			/* Link the entries of the policy list to the policy
+			 * list on the new SA.
+			 * The policy list from the old SA becomes void.
+			 */
+				list_splice_init(&old_sa->policy_headlist,
+						 &new_sa->policy_headlist);
+			}
 			cq_put_4bytes(sa_mng->sa_id_cq, old_sa->id);
 
 			/*Remove the new SA from rekeying list*/
@@ -2795,6 +2819,7 @@ EXPORT_SYMBOL_GPL(dpa_ipsec_disable_sa);
 int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 {
 	struct dpa_ipsec *dpa_ipsec;
+	struct list_head *pos, *tmp;
 	uint32_t i, sa_id;
 	int err;
 
@@ -2807,6 +2832,11 @@ int dpa_ipsec_flush_all_sa(int dpa_ipsec_id)
 	}
 	dpa_ipsec = gbl_dpa_ipsec;
 
+	list_for_each_safe(pos, tmp, &dpa_ipsec->sa_mng.sa_rekeying_headlist)
+		list_del(pos);
+	INIT_LIST_HEAD(&dpa_ipsec->sa_mng.sa_rekeying_headlist);
+	flush_delayed_work(&dpa_ipsec->sa_mng.sa_rekeying_work);
+
 	for (i = 0; i < dpa_ipsec->sa_mng.max_num_sa; i++) {
 		sa_id = dpa_ipsec->used_sa_ids[i];
 		if (sa_id != DPA_IPSEC_INVALID_SA_ID) {
-- 
1.7.5.4

