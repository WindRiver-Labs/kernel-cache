From 6d88940db0389989e87c9a155d8ac7a8b2a9d803 Mon Sep 17 00:00:00 2001
From: Anca-Jeanina Floarea <anca.floarea@freescale.com>
Date: Fri, 3 Aug 2012 22:58:22 +0000
Subject: [PATCH 258/518] dpa_stats: Added support for IPSec counter

Added support for IPSec single and class counter. Application can
use this counter to retrieve statistics for one or multiple IPSec
security associations.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  171 +++++++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_stats.h |    9 ++
 include/linux/fsl_dpa_stats.h               |   42 +++++++
 3 files changed, 222 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 504826b..22f423a 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -462,6 +462,18 @@ static void create_classif_stats(struct dpa_stats *dpa_stats)
 			&stats.frameLengthRangeCount[9] - (void *)&stats;
 }
 
+static void create_cnt_ipsec_stats(struct dpa_stats *dpa_stats)
+{
+	struct dpa_ipsec_sa_stats stats;
+
+	/* DPA_STATS_CNT_NUM_OF_BYTES */
+	dpa_stats->stats_sel[DPA_STATS_CNT_IPSEC][0] = (void *)
+			&stats.bytes_count - (void *)&stats;
+	/* DPA_STATS_CNT_NUM_OF_PACKETS */
+	dpa_stats->stats_sel[DPA_STATS_CNT_IPSEC][1] = (void *)
+			&stats.packets_count - (void *)&stats;
+}
+
 static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 		struct dpa_offload_lookup_key *dst)
 {
@@ -899,6 +911,55 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cnt_params *params)
+{
+	struct dpa_stats_cnt_ipsec_cb *cnt_ipsec_cb = &cnt_cb->ipsec_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_ipsec_sa_stats stats;
+	uint32_t cnt_sel = params->ipsec_params.cnt_sel;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Map IPSec counter selection to statistics */
+	if (cnt_sel == DPA_STATS_CNT_NUM_OF_BYTES) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
+		cnt_ipsec_cb->info.stats_num = 1;
+	} else if (cnt_sel == DPA_STATS_CNT_NUM_OF_PACKETS) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
+		cnt_ipsec_cb->info.stats_num = 1;
+	} else if (cnt_sel == DPA_STATS_CNT_NUM_ALL) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
+		cnt_ipsec_cb->info.stats_off[1] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
+		cnt_ipsec_cb->info.stats_num = 2;
+	} else {
+		pr_err("Invalid IPSec counter selection");
+		return -EINVAL;
+	}
+
+	cnt_ipsec_cb->sa_id[0] = params->ipsec_params.sa_id;
+	cnt_ipsec_cb->sa_id_num = 1;
+
+	err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[0], &stats);
+	if (err < 0) {
+		pr_err("Invalid IPSec counter parameters\n");
+		return -EINVAL;
+	}
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_ipsec_cb->info.stats_num;
+
+	return 0;
+}
+
 static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		const struct dpa_stats_cls_cnt_params *params)
 {
@@ -1327,6 +1388,65 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
+static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
+		const struct dpa_stats_cls_cnt_params *params)
+{
+	struct dpa_stats_cnt_ipsec_cb *cnt_ipsec_cb = &cnt_cb->ipsec_cb;
+	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
+	struct dpa_ipsec_sa_stats stats;
+	uint32_t cnt_sel = params->ipsec_params.cnt_sel, i = 0;
+	int err = 0;
+
+	if (!dpa_stats) {
+		pr_err("Invalid argument: NULL DPA Stats instance\n");
+		return -EFAULT;
+	}
+
+	/* Map IPSec counter selection to statistics */
+	if (cnt_sel == DPA_STATS_CNT_NUM_OF_BYTES) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
+		cnt_ipsec_cb->info.stats_num = 1;
+	} else if (cnt_sel  == DPA_STATS_CNT_NUM_OF_PACKETS) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
+		cnt_ipsec_cb->info.stats_num = 1;
+	} else if (cnt_sel  == DPA_STATS_CNT_NUM_ALL) {
+		cnt_ipsec_cb->info.stats_off[0] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
+		cnt_ipsec_cb->info.stats_off[1] = dpa_stats->stats_sel[
+			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
+		cnt_ipsec_cb->info.stats_num = 2;
+	} else {
+		pr_err("Invalid IPSec counter selection");
+		return -EINVAL;
+	}
+
+	cnt_ipsec_cb->sa_id_num = params->class_members;
+
+	for (i = 0; i < params->class_members; i++) {
+		if (params->ipsec_params.sa_id[i] !=
+				DPA_OFFLD_INVALID_OBJECT_ID) {
+			cnt_ipsec_cb->sa_id[i] = params->ipsec_params.sa_id[i];
+			cnt_ipsec_cb->valid[i] = TRUE;
+
+			err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i],
+					&stats);
+			if (err < 0) {
+				pr_err("Invalid IPSec counter parameters\n");
+				return -EINVAL;
+			}
+		} else {
+			cnt_ipsec_cb->valid[i] = FALSE;
+		}
+	}
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_ipsec_cb->sa_id_num *
+			STATS_VAL_SIZE * cnt_ipsec_cb->info.stats_num;
+	return 0;
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 		struct stats_info *stats_info, void *stats, uint32_t idx)
 {
@@ -1557,6 +1677,36 @@ static int get_cnt_ccnode_stats(struct dpa_stats_req_cb *req_cb,
 	return 0;
 }
 
+static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
+		struct dpa_stats_cnt_cb *cnt_cb)
+{
+	struct dpa_ipsec_sa_stats stats;
+	uint32_t i = 0;
+	int err = 0;
+
+	for (i = 0; i < cnt_cb->ipsec_cb.sa_id_num; i++) {
+		if (!cnt_cb->ipsec_cb.valid[i]) {
+			/* Write the memory location */
+			*(uint32_t *)(req_cb->request_area) = 0;
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE;
+
+			continue;
+		}
+
+		err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i], &stats);
+		if (err < 0) {
+			pr_err("Couldn't retrieve IPSec statistics\n");
+			return -E2BIG;
+		}
+
+		get_cnt_32bit_stats(req_cb, &cnt_cb->ipsec_cb.info, &stats, i);
+	}
+
+	return 0;
+}
+
 int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 {
 	struct dpa_stats *dpa_stats = NULL;
@@ -1609,6 +1759,9 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Map Classifier counters to FMAN Classifier statistics */
 	create_classif_stats(dpa_stats);
 
+	/* Map IPSec counters  */
+	create_cnt_ipsec_stats(dpa_stats);
+
 	gbl_dpa_stats = dpa_stats;
 
 	return 0;
@@ -1701,6 +1854,15 @@ int dpa_stats_create_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
 		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 		break;
+	case DPA_STATS_CNT_IPSEC:
+		set_cnt_ipsec_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create IPSec counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_IPSEC;
+		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
@@ -1816,6 +1978,15 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 		cnt_cb->type = DPA_STATS_CNT_CLASSIF_NODE;
 		cnt_cb->f_get_cnt_stats = get_cnt_ccnode_stats;
 		break;
+	case DPA_STATS_CNT_IPSEC:
+		err = set_cls_cnt_ipsec_cb(cnt_cb, params);
+		if (err != 0) {
+			pr_err("Failed to create IPSec counter");
+			goto create_counter_err;
+		}
+		cnt_cb->type = DPA_STATS_CNT_IPSEC;
+		cnt_cb->f_get_cnt_stats = get_cnt_ipsec_stats;
+		break;
 	default:
 		pr_err("Invalid counter type\n");
 		return -EINVAL;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.h b/drivers/staging/fsl_dpa_offload/dpa_stats.h
index 9f155c7..5218dbe 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.h
@@ -117,6 +117,14 @@ struct dpa_stats_cnt_classif_cb {
 	struct stats_info info;  /* Counter's statistics information */
 };
 
+/* DPA Stats IPSec Counter control block */
+struct dpa_stats_cnt_ipsec_cb {
+	int sa_id[MAX_NUM_OF_MEMBERS]; /* Array of Security Association ids */
+	bool valid[MAX_NUM_OF_MEMBERS]; /* Security Association id is valid */
+	unsigned int sa_id_num; /* Number of SA ids to retrieve statistics for*/
+	struct stats_info info; /* Counter's statistics information */
+};
+
 typedef int get_cnt_stats(struct dpa_stats_req_cb *req_cb,
 					struct dpa_stats_cnt_cb *cnt_cb);
 
@@ -131,6 +139,7 @@ struct dpa_stats_cnt_cb {
 		struct dpa_stats_cnt_gen_cb gen_cb;
 		struct dpa_stats_cnt_classif_tbl_cb tbl_cb;
 		struct dpa_stats_cnt_classif_cb ccnode_cb;
+		struct dpa_stats_cnt_ipsec_cb ipsec_cb;
 	};
 	get_cnt_stats *f_get_cnt_stats; /* Function used to retrieve the
 				statistics for a specific counter */
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 0991a44..4b8861f 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -78,6 +78,16 @@ enum dpa_stats_cnt_type {
 #endif
 };
 
+/* DPA Stats counter selection */
+enum dpa_stats_cnt_sel {
+	/* Total number of bytes */
+	DPA_STATS_CNT_NUM_OF_BYTES = 0,
+	/* Total number of packets */
+	DPA_STATS_CNT_NUM_OF_PACKETS,
+	/* Total number of bytes and total number of packets */
+	DPA_STATS_CNT_NUM_ALL
+};
+
 /* DPA Stats Ethernet counter selection */
 enum dpa_stats_cnt_eth_sel {
 	/* Total number of dropped packets on receive */
@@ -366,6 +376,16 @@ struct dpa_stats_cnt_classif_node {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats IPSec counter parameters */
+struct dpa_stats_cnt_ipsec {
+
+	/* Security Association id */
+	int sa_id;
+
+	/* Select IPSec counter */
+	enum dpa_stats_cnt_sel cnt_sel;
+};
+
 /* DPA Stats counter parameters */
 struct dpa_stats_cnt_params {
 
@@ -390,6 +410,9 @@ struct dpa_stats_cnt_params {
 
 		/* Parameters for Classification Node counter */
 		struct dpa_stats_cnt_classif_node classif_node_params;
+
+		/* Parameters for IPSec counter */
+		struct dpa_stats_cnt_ipsec ipsec_params;
 	};
 };
 
@@ -516,6 +539,22 @@ struct dpa_stats_cls_cnt_classif_node {
 	unsigned int cnt_sel;
 };
 
+/* DPA Stats IPSec class counter parameters */
+struct dpa_stats_cls_cnt_ipsec {
+
+	/*
+	 * Array of security association IDs. Invalid security association
+	 * identifiers(DPA_OFFLD_INVALID_OBJECT_ID) can be provided during
+	 * class counter creation and the statistics values for such ids will
+	 * be 0. Function 'dpa_stats_modify_class_counter' can be further used
+	 * to modify a specific security association identifier.
+	 */
+	int *sa_id;
+
+	/* Select IPSec counter */
+	enum dpa_stats_cnt_sel cnt_sel;
+};
+
 /* DPA Stats class counter parameters */
 struct dpa_stats_cls_cnt_params {
 
@@ -543,6 +582,9 @@ struct dpa_stats_cls_cnt_params {
 
 		/* Parameters for Classification Node class counter */
 		struct dpa_stats_cls_cnt_classif_node classif_node_params;
+
+		/* Parameters for IPSec class counter */
+		struct dpa_stats_cls_cnt_ipsec ipsec_params;
 	};
 };
 
-- 
1.7.5.4

