From fccac7bce159839a52ba797158e9545c67bbd13f Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Fri, 7 Dec 2012 23:11:37 +0000
Subject: [PATCH 441/518] offload_use_case: Fix policy offloading issue

Policies could be offloaded multiple times due to delays that
appear when policy walking is done. To prevent this,
the  policy that is being offloaded is checked against all offloaded
policies for a specific SA using the dpa_ipsec_sa_get_policies
function. If a match is found the policy is not offloaded.

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   95 ++++++++++++++++++++
 1 files changed, 95 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index a9eb4e9..0ddeab5 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -430,6 +430,57 @@ static void work_func(struct work_struct *work)
 	kfree(this_work);
 }
 
+static int offloaded_pol(struct xfrm_selector *sel,
+			  struct dpa_ipsec_policy_params *policies,
+			  int pol_count, int dir)
+{
+	int i;
+	bool found = false;
+
+	for (i = 0; i < pol_count; i++) {
+		struct dpa_ipsec_policy_params pol;
+		memset(&pol, 0, sizeof(pol));
+		memcpy(&pol, &policies[i], sizeof(pol));
+		if (sel->family == AF_INET) {
+			if (pol.dest_addr.addr.ipv4.word == sel->daddr.a4 &&
+			    pol.src_addr.addr.ipv4.word == sel->saddr.a4 &&
+			    pol.protocol == sel->proto &&
+			    pol.src_prefix_len == sel->prefixlen_s &&
+			    pol.dest_prefix_len == sel->prefixlen_d &&
+			    pol.l4.dest_port == sel->dport &&
+			    pol.l4.src_port == sel->sport &&
+			    pol.l4.src_port_mask == sel->sport_mask &&
+			    pol.l4.dest_port_mask == sel->dport_mask) {
+				found = true;
+				return found;
+				}
+
+		} else if (sel->family == AF_INET6) {
+			int src_cmp, dst_cmp;
+			src_cmp = memcmp(pol.src_addr.addr.ipv6.byte,
+					 sel->saddr.a6,
+					 sizeof(sel->saddr.a6));
+			dst_cmp = memcmp(pol.dest_addr.addr.ipv6.byte,
+					 sel->daddr.a6,
+					 sizeof(sel->daddr.a6));
+			if (src_cmp == 0 && dst_cmp == 0 &&
+			    pol.protocol == sel->proto &&
+			    pol.src_prefix_len == sel->prefixlen_s &&
+			    pol.dest_prefix_len == sel->prefixlen_d &&
+			    pol.l4.dest_port == sel->dport &&
+			    pol.l4.src_port == sel->sport &&
+			    pol.l4.src_port_mask == sel->sport_mask &&
+			    pol.l4.dest_port_mask == sel->dport_mask) {
+				found = true;
+				return found;
+			}
+
+		}
+	}
+
+	return found;
+}
+
 static int offload_sa(int dpa_ipsec_id,
 		      struct dpa_ipsec_sa_params *sa_params,
 		      struct xfrm_state *x,
@@ -586,6 +637,48 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 {
 	int ret = 0;
 	struct dpa_cls_tbl_action policy_action;
+	struct dpa_ipsec_policy_params *pol_array = NULL;
+	int pol_count;
+	bool found_pol;
+
+	pol_count = 0;
+	found_pol = false;
+	/* Get num of sa policies */
+	ret = dpa_ipsec_sa_get_policies(sa_id, pol_array, &pol_count);
+	if (ret < 0) {
+		pr_err("%s:%d: Could not get policies for sa (%d)\n", __func__,
+			__LINE__, sa_id);
+		return ret;
+	}
+
+	if (pol_count) {
+		pol_array = kzalloc(pol_count *
+				    sizeof(struct dpa_ipsec_policy_params),
+				    GFP_KERNEL);
+		/* Get sa policies */
+		ret = dpa_ipsec_sa_get_policies(sa_id, pol_array, &pol_count);
+		if (ret < 0) {
+			pr_err("%s:%d: Could not get policies for sa (%d)\n",
+				__func__, __LINE__, sa_id);
+			return ret;
+		}
+
+		found_pol = offloaded_pol(sel, pol_array, pol_count, dir);
+	}
+
+	if (found_pol) {
+		if (dir == XFRM_POLICY_OUT)
+			pr_info("XFRM_POLICY_OUT policy was prevented "
+			      "from offloading twice\n");
+		else if (dir == XFRM_POLICY_IN)
+			pr_info("XFRM_POLICY_IN policy was prevented "
+			      "from offloading twice\n");
+		else
+			pr_info("Unknown policy was prevented "
+			      "from offloading twice\n");
+		kfree(pol_array);
+		goto no_offld_pol;
+	}
 
 	memset(pol_params, 0, sizeof(*pol_params));
 	if (dir == XFRM_POLICY_OUT) {
@@ -657,6 +750,8 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 	}
 
 	ret = dpa_ipsec_sa_add_policy(sa_id, pol_params);
+
+no_offld_pol:
 	return ret;
 }
 
-- 
1.7.5.4

