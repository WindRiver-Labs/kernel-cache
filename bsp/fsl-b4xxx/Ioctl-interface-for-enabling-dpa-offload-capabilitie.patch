From 074115c5c5931af59468b63b6de764ad9b804294 Mon Sep 17 00:00:00 2001
From: andrei varvara <andrei.varvara@freescale.com>
Date: Fri, 10 Feb 2012 00:43:38 +0000
Subject: [PATCH 093/518] Ioctl interface for enabling dpa offload
 capabilities in user space

* added ioctl support (wrappers) for dpa classifier and dpa ipsec which enables
          calling the functions from user space
        * added support for building dpa_offload module (tristate - built in, loadable module and not present)
        * removed UNDER_CONSTRUCTION define from fsl_dpa_ipsec.h

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Kconfig            |   13 +-
 drivers/staging/fsl_dpa_offload/Makefile           |   51 ++-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   88 +++
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h  |  122 ++++
 .../staging/fsl_dpa_offload/dpa_offload_module.c   |   88 +++
 .../staging/fsl_dpa_offload/dpa_offload_module.h   |   46 ++
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |  691 ++++++++++++++++++++
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.h   |   74 +++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c    |  310 +++++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h    |   53 ++
 10 files changed, 1526 insertions(+), 10 deletions(-)
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_offload_module.c
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_offload_module.h
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h

diff --git a/drivers/staging/fsl_dpa_offload/Kconfig b/drivers/staging/fsl_dpa_offload/Kconfig
index e17ee71..022848e 100644
--- a/drivers/staging/fsl_dpa_offload/Kconfig
+++ b/drivers/staging/fsl_dpa_offload/Kconfig
@@ -1,5 +1,16 @@
 
 config FSL_DPA_OFFLOAD
-	bool "Freescale Datapath Offloading Driver"
+	tristate "Freescale Datapath Offloading Driver"
 	depends on FSL_FMAN
 	default n
+	---help---
+		The driver supports DPAA offloading capabilities.
+		    * Classifier component makes possible the offloading of
+		      classification rules by configuring the onboard
+		      FMAN hardware.
+		    * Dpa IPSec component makes possible the offloading of
+		      security opperation (ESP) by configuring the onboard
+		      SEC 4.x.
+
+		To compile this driver as a module, choose M here. The module
+		will be called dpa_offload.
\ No newline at end of file
diff --git a/drivers/staging/fsl_dpa_offload/Makefile b/drivers/staging/fsl_dpa_offload/Makefile
index 0c2bf90..94352fd 100644
--- a/drivers/staging/fsl_dpa_offload/Makefile
+++ b/drivers/staging/fsl_dpa_offload/Makefile
@@ -1,17 +1,50 @@
+################################################################################
+#Copyright 2008-2012 Freescale Semiconductor, Inc.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#	* Redistributions of source code must retain the above copyright
+#	  notice, this list of conditions and the following disclaimer.
+#	* Redistributions in binary form must reproduce the above copyright
+#	  notice, this list of conditions and the following disclaimer in the
+#	  documentation and/or other materials provided with the distribution.
+#	  Neither the name of Freescale Semiconductor nor the
+#	  names of its contributors may be used to endorse or promote products
+#	  derived from this software without specific prior written permission.
+#
+# ALTERNATIVELY, this software may be distributed under the terms of the
+# GNU General Public License ("GPL") as published by the Free Software
+# Foundation, either version 2 of that License or (at your option) any
+# later version.
+#
+# THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+################################################################################
+
+#
+# Makefile for the DPA Offloading driver
+#
 
 #Include NetComm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
 
 
 EXTRA_CFLAGS += \
-	-Idrivers/staging/fsl_dpa_offload/integration \
-	-Idrivers/crypto/caam
+	-Idrivers/crypto/caam \
+	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper
+
+obj-$(CONFIG_FSL_IPACC_USECASES)   += usecases/
 
+obj-$(CONFIG_FSL_DPA_OFFLOAD) += dpa_offload.o
 
-obj-$(CONFIG_FSL_DPA_OFFLOAD) +=    \
-        crc8.o                      \
-        dpa_classifier.o            \
-        dpa_compat.o \
-        dpa_ipsec.o \
-        dpa_ipsec_desc.o \
-        cq.o
+dpa_offload-objs :=  crc8.o dpa_classifier.o dpa_compat.o dpa_ipsec.o \
+		     dpa_ipsec_desc.o cq.o wrp_dpa_classifier.o \
+		     wrp_dpa_ipsec.o dpa_offload_module.o
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
new file mode 100644
index 0000000..dbec4d3
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -0,0 +1,88 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Classifier Wrapper Application Programming Interface
+ */
+
+#ifndef __DPA_CLASSIFIER_IOCTL_H
+#define __DPA_CLASSIFIER_IOCTL_H
+
+
+/* Other includes */
+#include "linux/ioctl.h"
+
+
+#define DPA_CLS_IOC_MAGIC				0xbe
+
+
+#define DPA_CLS_IOC_TBL_CREATE	_IOWR(DPA_CLS_IOC_MAGIC, 0, unsigned char)
+
+#define DPA_CLS_IOC_TBL_FREE	_IOW(DPA_CLS_IOC_MAGIC, 1, unsigned char)
+
+#define DPA_CLS_IOC_TBL_MODIFY_MISS_ACTION		\
+				_IOW(DPA_CLS_IOC_MAGIC, 2, unsigned char)
+
+#define DPA_CLS_IOC_TBL_INSERT_ENTRY			\
+				_IOWR(DPA_CLS_IOC_MAGIC, 3, unsigned char)
+
+#define DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_KEY		\
+				_IOW(DPA_CLS_IOC_MAGIC, 4, unsigned char)
+
+#define DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_REF		\
+				_IOW(DPA_CLS_IOC_MAGIC, 5, unsigned char)
+
+#define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY		\
+				_IOW(DPA_CLS_IOC_MAGIC, 6, unsigned char)
+
+#define DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF		\
+				_IOW(DPA_CLS_IOC_MAGIC, 7, unsigned char)
+
+#define DPA_CLS_IOC_TBL_LOOKUP_BY_KEY			\
+				_IOR(DPA_CLS_IOC_MAGIC, 8, unsigned char)
+
+#define DPA_CLS_IOC_TBL_LOOKUP_BY_REF			\
+				_IOR(DPA_CLS_IOC_MAGIC, 9, unsigned char)
+
+#define DPA_CLS_IOC_TBL_FLUSH	_IOW(DPA_CLS_IOC_MAGIC, 10, unsigned char)
+
+#define DPA_CLS_IOC_TBL_GET_STATS_BY_KEY		\
+				_IOR(DPA_CLS_IOC_MAGIC, 11, unsigned char)
+
+#define DPA_CLS_IOC_TBL_GET_STATS_BY_REF		\
+				_IOR(DPA_CLS_IOC_MAGIC, 12, unsigned char)
+
+#define DPA_CLS_IOC_TBL_GET_PARAMS			\
+				_IOWR(DPA_CLS_IOC_MAGIC, 13, unsigned char)
+
+
+#endif /* __DPA_CLASSIFIER_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
new file mode 100644
index 0000000..4f30e5c
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -0,0 +1,122 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA IPsec Wrapper Application Programming Interface
+ */
+
+#ifndef __DPA_IPSEC_IOCTL_H
+#define __DPA_IPSEC_IOCTL_H
+
+#include "linux/ioctl.h"
+
+
+#define DPA_IPSEC_IOC_MAGIC	0xee
+
+
+struct ioc_dpa_ipsec_params {
+	struct dpa_ipsec_params dpa_ipsec_params;
+	int dpa_ipsec_id;
+};
+
+struct ioc_dpa_ipsec_sa_params {
+	int dpa_ipsec_id;
+	struct dpa_ipsec_sa_params sa_params;
+	int sa_id;
+};
+
+struct ioc_dpa_ipsec_add_rem_policy {
+	struct dpa_ipsec_policy_params pol_params;
+	int sa_id;
+};
+
+struct ioc_dpa_ipsec_sa_rekeying_prm {
+	struct dpa_ipsec_sa_params sa_params;
+	int sa_id;		/* old sa id */
+	int new_sa_id;		/* newly created sa id */
+};
+
+struct ioc_dpa_ipsec_sa_get_policies {
+	int sa_id;		/* sa id */
+	struct dpa_ipsec_policy_params *policy_params;
+	int *num_pol;		/* number of policies */
+};
+
+
+#define DPA_IPSEC_IOC_INIT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 0, struct ioc_dpa_ipsec_params)
+
+#define DPA_IPSEC_IOC_FREE \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 1, int)
+
+#define DPA_IPSEC_IOC_CREATE_SA \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 2, struct ioc_dpa_ipsec_sa_params)
+
+#define DPA_IPSEC_IOC_REMOVE_SA \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 3, int)
+
+#define DPA_IPSEC_IOC_ADD_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 4, struct ioc_dpa_ipsec_add_rem_policy)
+
+#define DPA_IPSEC_IOC_REMOVE_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_dpa_ipsec_add_rem_policy)
+
+#define DPA_IPSEC_IOC_SA_REKEYING \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_dpa_ipsec_sa_rekeying_prm)
+
+#define DPA_IPSEC_IOC_FLUSH_ALL_SA \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 7, int)
+
+#define DPA_IPSEC_IOC_GET_SA_POLICIES \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_dpa_ipsec_sa_get_policies)
+
+
+#ifdef DPA_IPSEC_RUNTIME_TESTING
+/*AV's note: Will be removed after validation */
+struct ioc_dpa_ipsec_testing_prm {
+	int out_entry_fq_id;
+	/* app created queue to enqueue frames for encrypt */
+	int out_exit_fq_id;
+	/* app created queue to dequeue frames after encrypt */
+
+	int in_exit_fq_id[2];
+	int policy_miss_fqid; /* id of the fq (inb policy verification miss) */
+};
+
+#define DPA_IPSEC_IOC_START_TESTING \
+		_IO(DPA_IPSEC_IOC_MAGIC, 100)
+#define DPA_IPSEC_IOC_GET_TESTING_PARAMS \
+		_IOR(DPA_IPSEC_IOC_MAGIC, 101, struct ioc_dpa_ipsec_testing_prm)
+#endif	/* DPA_IPSEC_RUNTIME_TESTING */
+
+
+#endif	/* __DPA_IPSEC_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_offload_module.c b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
new file mode 100644
index 0000000..754b46e
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_offload_module.c
@@ -0,0 +1,88 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Offloading driver implementation
+ */
+
+#include <linux/module.h>
+
+#include "dpa_compat.h"
+#include "dpa_offload_module.h"
+#include "wrp_dpa_classifier.h"
+#include "wrp_dpa_ipsec.h"
+
+static int __init dpa_offload_drv_init(void)
+{
+	int err;
+
+	/* Initialize DPA Classifier wrapper to listen to [ioctl] calls */
+	err = wrp_dpa_classif_init();
+	if (err == 0)
+		printk(KERN_INFO"DPA Classifier Driver initialized.\n");
+	else {
+		printk(KERN_ERR"DPA Classifier Driver failed to initialize.\n");
+		return err;
+	}
+
+	/* Initialize DPA IPSec wrapper to listen to [ioctl] calls */
+	err = wrp_dpa_ipsec_init();
+	if (err == 0)
+		printk(KERN_INFO"DPA IPSec Driver initialized.\n");
+	else {
+		printk(KERN_ERR"DPA IPSec Driver failed to initialize.\n");
+		return err;
+	}
+
+	return err;
+}
+module_init(dpa_offload_drv_init);
+
+static void __exit dpa_offload_drv_exit(void)
+{
+	/* Shut down DPA Classifier wrapper */
+	if (wrp_dpa_classif_exit() < 0)
+		printk(KERN_ERR"DPA Classifier Driver failed to unload.\n");
+	else
+		printk(KERN_INFO"DPA Classifier Driver unloaded.\n");
+
+	/* Shut down DPA IPSec wrapper */
+	if (wrp_dpa_ipsec_exit() < 0)
+		printk(KERN_ERR"DPA IPSec Driver failed to unload.\n");
+	else
+		printk(KERN_INFO"INFO: DPA IPSec Driver unloaded.\n");
+}
+module_exit(dpa_offload_drv_exit);
+
+MODULE_AUTHOR("Freescale, <freescale.com>");
+MODULE_DESCRIPTION("DPA Offloading Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_offload_module.h b/drivers/staging/fsl_dpa_offload/dpa_offload_module.h
new file mode 100644
index 0000000..e4f3ad1
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_offload_module.h
@@ -0,0 +1,46 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Offloading driver internal interface
+ */
+
+#ifndef __DPA_OFFLOAD_DRIVER_H
+#define __DPA_OFFLOAD_DRIVER_H
+
+#define DRV_VERSION "1.0"
+
+static int __init dpa_offload_drv_init(void);
+
+static void __exit dpa_offload_drv_exit(void);
+
+
+#endif /* __DPA_OFFLOAD_DRIVER_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
new file mode 100644
index 0000000..294e200
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -0,0 +1,691 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA Classifier Wrapper implementation.
+ */
+
+/* DPA offloading layer includes */
+#include <linux/fsl_dpa_classifier.h>
+#include "wrp_dpa_classifier.h"
+#include "dpa_classifier_ioctl.h"
+#include "dpa_compat.h"
+
+/* Other includes */
+#include <linux/uaccess.h>
+#include <linux/fdtable.h>
+#include "lnxwrp_fm.h"
+
+static const struct file_operations dpa_classif_fops = {
+	.owner			= THIS_MODULE,
+	.open			= wrp_dpa_classif_open,
+	.read			= wrp_dpa_classif_read,
+	.write			= wrp_dpa_classif_write,
+	.unlocked_ioctl	= wrp_dpa_classif_ioctl,
+	.release		= wrp_dpa_classif_release
+};
+
+static int dpa_cls_cdev_major = -1;
+
+
+int	wrp_dpa_classif_init(void)
+{
+	/* Cannot initialize the wrapper twice */
+	if (dpa_cls_cdev_major >= 0)
+		return 0;
+
+	dpa_cls_cdev_major = register_chrdev(
+					0,
+					WRP_DPA_CLS_CDEVNAME,
+					&dpa_classif_fops);
+	if (dpa_cls_cdev_major < 0) {
+		xx_pr_err(("Could not register DPA Classifier Control Device."));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+int wrp_dpa_classif_exit(void)
+{
+	if (dpa_cls_cdev_major < 0)
+		return 0;
+
+	unregister_chrdev(dpa_cls_cdev_major, WRP_DPA_CLS_CDEVNAME);
+
+	dpa_cls_cdev_major = -1;
+
+	return 0;
+}
+
+
+int wrp_dpa_classif_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+int wrp_dpa_classif_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+ssize_t wrp_dpa_classif_read(
+			struct file	*filp,
+			char __user	*buf,
+			size_t		len,
+			loff_t		*offp)
+{
+	return 0;
+}
+
+
+ssize_t wrp_dpa_classif_write(
+			struct file		*filp,
+			const char __user	*buf,
+			size_t			len,
+			loff_t			*offp)
+{
+	return 0;
+}
+
+
+long wrp_dpa_classif_ioctl(
+			struct file	*filp,
+			unsigned int	cmd,
+			unsigned long	args)
+{
+	long	ret = 0;
+
+
+	switch (cmd) {
+	case DPA_CLS_IOC_TBL_CREATE:
+	{
+		struct dpa_cls_tbl_params	*uparams, kparams;
+		int				*utd, ktd;
+		struct file			*fm_pcd_file;
+		t_LnxWrpFmDev			*fm_wrapper_dev;
+
+
+		/* Prepare arguments */
+		uparams = (struct dpa_cls_tbl_params *) args;
+		utd	= (int *)((void *)uparams +
+				sizeof(struct dpa_cls_tbl_params));
+
+		if (copy_from_user(
+				&kparams,
+				uparams,
+				sizeof(struct dpa_cls_tbl_params))) {
+			xx_pr_err(("Could not read dpa_classif_table_create user space args"));
+			return -EBUSY;
+		}
+
+		/* Translate FM_PCD file descriptor */
+		fm_pcd_file = fcheck((unsigned int)kparams.fm_pcd);
+		fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+		kparams.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+
+		/* Call function */
+		ret = dpa_classif_table_create(&kparams, &ktd);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(utd, &ktd, sizeof(int))) {
+			xx_pr_err(("Could not write dpa_classif_table_create result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_FREE:
+		ret = dpa_classif_table_free((int)args);
+		break;
+
+	case DPA_CLS_IOC_TBL_MODIFY_MISS_ACTION:
+	{
+		struct dpa_cls_tbl_action		*uaction, kaction;
+		int					*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd	= (int *)(args);
+		uaction = (struct dpa_cls_tbl_action *)((void *)utd +
+				sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_miss_action user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kaction,
+				uaction,
+				sizeof(struct dpa_cls_tbl_action))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_miss_action user space args (#2)"));
+			return -EBUSY;
+		}
+		/* Call function */
+		ret = dpa_classif_table_modify_miss_action(ktd, &kaction);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_INSERT_ENTRY:
+	{
+		struct dpa_cls_tbl_key		*ukey, kkey;
+		struct dpa_cls_tbl_action	*uaction, kaction;
+		int				*utd, ktd;
+		int				*uentry_id, *upriority;
+		int				kentry_id, kpriority;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		ukey		= (struct dpa_cls_tbl_key *)((void *)utd +
+					sizeof(int));
+		uaction		= (struct dpa_cls_tbl_action *)((void*)ukey +
+					sizeof(struct dpa_cls_tbl_key));
+		upriority	= (int *)((void *)uaction +
+					sizeof(struct dpa_cls_tbl_action));
+		uentry_id	= (int *)((void *)upriority + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_insert_entry user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kaction,
+				uaction,
+				sizeof(struct dpa_cls_tbl_action))) {
+			xx_pr_err(("Could not read dpa_classif_table_insert_entry user space args (#2)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(&kpriority, upriority, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_insert_entry user space args (#3)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kkey,
+				ukey,
+				sizeof(struct dpa_cls_tbl_key))) {
+			xx_pr_err(("Could not read dpa_classif_table_insert_entry user space args (#3)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_insert_entry(
+						ktd,
+						&kkey,
+						&kaction,
+						kpriority,
+						&kentry_id);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(uentry_id, &kentry_id, sizeof(int))) {
+			xx_pr_err(("Could not write dpa_classif_table_insert_entry result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_KEY:
+	{
+		struct dpa_cls_tbl_key			*ukey, kkey, knew_key;
+		struct dpa_cls_tbl_action		knew_action;
+		struct dpa_cls_tbl_entry_mod_params	*umod_params;
+		struct dpa_cls_tbl_entry_mod_params	kmod_params;
+		int					*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		ukey		= (struct dpa_cls_tbl_key *)((void *)utd +
+					sizeof(int));
+		umod_params	= (struct dpa_cls_tbl_entry_mod_params *)
+					((void *)ukey +
+					sizeof(struct dpa_cls_tbl_key));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kkey,
+				ukey,
+				sizeof(struct dpa_cls_tbl_key))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#2)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kmod_params,
+				umod_params,
+				sizeof(struct dpa_cls_tbl_entry_mod_params))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#3)"));
+			return -EBUSY;
+		}
+
+		if (((kmod_params.type == DPA_CLS_TBL_MODIFY_KEY) ||
+			(kmod_params.type ==
+				DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) &&
+			(kmod_params.key)) {
+			if (copy_from_user(
+					&knew_key,
+					kmod_params.key,
+					sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#3.1)"));
+				return -EBUSY;
+			}
+
+			kmod_params.key = &knew_key;
+		}
+
+		if (((kmod_params.type == DPA_CLS_TBL_MODIFY_ACTION) ||
+			(kmod_params.type ==
+				DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) &&
+			(kmod_params.action)) {
+			if (copy_from_user(
+					&knew_action,
+					kmod_params.action,
+					sizeof(struct dpa_cls_tbl_action))) {
+				xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_key user space args (#3.2)"));
+				return -EBUSY;
+			}
+
+			kmod_params.action = &knew_action;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_modify_entry_by_key(
+							ktd,
+							&kkey,
+							&kmod_params);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_MODIFY_ENTRY_BY_REF:
+	{
+		struct dpa_cls_tbl_key			knew_key;
+		struct dpa_cls_tbl_action		knew_action;
+		struct dpa_cls_tbl_entry_mod_params	*umod_params;
+		struct dpa_cls_tbl_entry_mod_params	kmod_params;
+		int					*utd, ktd;
+		int					*uentry_id, kentry_id;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		uentry_id	= (int *)((void *)utd + sizeof(int));
+		umod_params	= (struct dpa_cls_tbl_entry_mod_params *)
+					((void *)uentry_id + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(&kentry_id, uentry_id, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#2)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kmod_params,
+				umod_params,
+				sizeof(struct dpa_cls_tbl_entry_mod_params))) {
+			xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#3)"));
+			return -EBUSY;
+		}
+
+		if (((kmod_params.type == DPA_CLS_TBL_MODIFY_KEY) ||
+			(kmod_params.type ==
+				DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) &&
+			(kmod_params.key)) {
+			if (copy_from_user(
+					&knew_key,
+					kmod_params.key,
+					sizeof(struct dpa_cls_tbl_key))) {
+				xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#3.1)"));
+				return -EBUSY;
+			}
+
+			kmod_params.key = &knew_key;
+		}
+
+		if (((kmod_params.type == DPA_CLS_TBL_MODIFY_ACTION) ||
+			(kmod_params.type ==
+				DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) &&
+			(kmod_params.action)) {
+			if (copy_from_user(
+					&knew_action,
+					kmod_params.action,
+					sizeof(struct dpa_cls_tbl_action))) {
+				xx_pr_err(("Could not read dpa_classif_table_modify_entry_by_ref user space args (#3.2)"));
+				return -EBUSY;
+			}
+
+			kmod_params.action = &knew_action;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_modify_entry_by_ref(
+							ktd,
+							kentry_id,
+							&kmod_params);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_KEY:
+	{
+		struct dpa_cls_tbl_key		*ukey, kkey;
+		int				*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd	= (int *)(args);
+		ukey	= (struct dpa_cls_tbl_key *)(args + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_key user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kkey,
+				ukey,
+				sizeof(struct dpa_cls_tbl_key))) {
+			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_key user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_delete_entry_by_key(ktd, &kkey);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_DELETE_ENTRY_BY_REF:
+	{
+		int	*uentry_id, kentry_id;
+		int	*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		uentry_id	= (int *)(args + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_ref user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(&kentry_id, uentry_id, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_delete_entry_by_ref user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_delete_entry_by_ref(ktd, kentry_id);
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_LOOKUP_BY_KEY:
+	{
+		struct dpa_cls_tbl_key		*ukey, kkey;
+		struct dpa_cls_tbl_action	*uaction, kaction;
+		int				*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd	= (int *)(args);
+		ukey	= (struct dpa_cls_tbl_key *)((void *)utd + sizeof(int));
+		uaction	= (struct dpa_cls_tbl_action *)((void*)ukey +
+					sizeof(struct dpa_cls_tbl_key));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_lookup_by_key user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kkey,
+				ukey,
+				sizeof(struct dpa_cls_tbl_key))) {
+			xx_pr_err(("Could not read dpa_classif_table_lookup_by_key user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_lookup_by_key(ktd, &kkey, &kaction);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(
+				uaction,
+				&kaction,
+				sizeof(struct dpa_cls_tbl_action))) {
+			xx_pr_err(("Could not write dpa_classif_table_lookup_by_key result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_LOOKUP_BY_REF:
+	{
+		int				*uentry_id, kentry_id;
+		struct dpa_cls_tbl_action	*uaction, kaction;
+		int				*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		uentry_id	= (int *)((void *)utd + sizeof(int));
+		uaction		= (struct dpa_cls_tbl_action *)
+					((void *)uentry_id + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_lookup_by_ref user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(&kentry_id, uentry_id, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_lookup_by_ref user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_lookup_by_ref(ktd, kentry_id, &kaction);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(
+				uaction,
+				&kaction,
+				sizeof(struct dpa_cls_tbl_action))) {
+			xx_pr_err(("Could not write dpa_classif_table_lookup_by_ref result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_FLUSH:
+		ret = dpa_classif_table_flush((int)args);
+		break;
+
+	case DPA_CLS_IOC_TBL_GET_STATS_BY_KEY:
+	{
+		struct dpa_cls_tbl_key		*ukey, kkey;
+		int				*utd, ktd;
+		struct dpa_cls_tbl_entry_stats	*ustats, kstats;
+
+
+		/* Prepare arguments */
+		utd	= (int *)(args);
+		ukey	= (struct dpa_cls_tbl_key *)((void *)utd + sizeof(int));
+		ustats	= (struct dpa_cls_tbl_entry_stats *)((void*)ukey +
+						sizeof(struct dpa_cls_tbl_key));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(
+				&kkey,
+				ukey,
+				sizeof(struct dpa_cls_tbl_key))) {
+			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_key user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_get_entry_stats_by_key(
+							ktd,
+							&kkey,
+							&kstats);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(
+				ustats,
+				&kstats,
+				sizeof(struct dpa_cls_tbl_entry_stats))) {
+			xx_pr_err(("Could not write dpa_classif_table_get_entry_stats_by_key result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_GET_STATS_BY_REF:
+	{
+		int				*uentry_id, kentry_id;
+		int				*utd, ktd;
+		struct dpa_cls_tbl_entry_stats	*ustats, kstats;
+
+
+		/* Prepare arguments */
+		utd		= (int *)(args);
+		uentry_id	= (int *)((void *)utd + sizeof(int));
+		ustats		= (struct dpa_cls_tbl_entry_stats *)
+					((void *)uentry_id + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#1)"));
+			return -EBUSY;
+		}
+
+		if (copy_from_user(&kentry_id, uentry_id, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_get_entry_stats_by_ref user space args (#2)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_get_entry_stats_by_ref(
+							ktd,
+							kentry_id,
+							&kstats);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(
+				ustats,
+				&kstats,
+				sizeof(struct dpa_cls_tbl_entry_stats))) {
+			xx_pr_err(("Could not write dpa_classif_table_get_entry_stats_by_ref result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	case DPA_CLS_IOC_TBL_GET_PARAMS:
+	{
+		struct dpa_cls_tbl_params		*uparams, kparams;
+		int					*utd, ktd;
+
+
+		/* Prepare arguments */
+		utd	= (int *)(args);
+		uparams	= (struct dpa_cls_tbl_params *)
+				((void *)utd + sizeof(int));
+
+		if (copy_from_user(&ktd, utd, sizeof(int))) {
+			xx_pr_err(("Could not read dpa_classif_table_lookup_by_key user space args (#1)"));
+			return -EBUSY;
+		}
+
+		/* Call function */
+		ret = dpa_classif_table_get_params(ktd, &kparams);
+		if (ret < 0)
+			return ret;
+
+		/* Return results to user space */
+		if (copy_to_user(
+				uparams,
+				&kparams,
+				sizeof(struct dpa_cls_tbl_params))) {
+			xx_pr_err(("Could not write dpa_classif_table_get_params result"));
+			return -EBUSY;
+		}
+
+		break;
+	}
+
+	default:
+		xx_pr_err(("DPA Classifier ioctl command (%u) not suppoted",
+			cmd));
+		return -EINVAL;
+	}
+
+	return ret;
+}
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
new file mode 100644
index 0000000..4bcdc7f
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.h
@@ -0,0 +1,74 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Internal DPA Classifier Wrapper Application Programming Interface
+ */
+
+#ifndef __WRP_DPA_CLASSIFIER_H
+#define __WRP_DPA_CLASSIFIER_H
+
+
+/* Other includes */
+#include "linux/fs.h"
+
+
+#define WRP_DPA_CLS_CDEVNAME				"dpa_classifier"
+
+
+int	wrp_dpa_classif_init(void);
+
+int	wrp_dpa_classif_exit(void);
+
+int	wrp_dpa_classif_open(struct inode *inode, struct file *filp);
+
+int	wrp_dpa_classif_release(struct inode *inode, struct file *filp);
+
+ssize_t	wrp_dpa_classif_read(
+			struct file	*filp,
+			char __user	*buf,
+			size_t		len,
+			loff_t		*offp);
+
+ssize_t	wrp_dpa_classif_write(
+			struct file		*filp,
+			const char __user	*buf,
+			size_t			len,
+			loff_t			*offp);
+
+long	wrp_dpa_classif_ioctl(
+			struct file	*filp,
+			unsigned int	cmd,
+			unsigned long	args);
+
+
+#endif /* __WRP_DPA_CLASSIFIER_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
new file mode 100644
index 0000000..0ed11b7
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -0,0 +1,310 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA IPsec Wrapper implementation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/uaccess.h>
+
+#include "dpa_compat.h"
+#include <linux/fsl_dpa_ipsec.h>
+#include "dpa_ipsec_ioctl.h"
+#include "wrp_dpa_ipsec.h"
+
+static const struct file_operations dpa_ipsec_fops = {
+	.owner = THIS_MODULE,
+	.open = wrp_dpa_ipsec_open,
+	.read = NULL,
+	.write = NULL,
+	.unlocked_ioctl = wrp_dpa_ipsec_ioctl,
+	.release = wrp_dpa_ipsec_release
+};
+
+static int dpa_ipsec_cdev_major = -1;
+
+int wrp_dpa_ipsec_init(void)
+{
+	/* Cannot initialize the wrapper twice */
+	if (dpa_ipsec_cdev_major >= 0)
+		return -EBUSY;
+
+	dpa_ipsec_cdev_major =
+	    register_chrdev(0, DPA_IPSEC_CDEV, &dpa_ipsec_fops);
+	if (dpa_ipsec_cdev_major < 0) {
+		xx_pr_err(("Could not register Dpa Ipsec character device"));
+		return dpa_ipsec_cdev_major;
+	}
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_exit(void)
+{
+	if (dpa_ipsec_cdev_major < 0)
+		return 0;
+	unregister_chrdev(dpa_ipsec_cdev_major, DPA_IPSEC_CDEV);
+	dpa_ipsec_cdev_major = -1;
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args)
+{
+	long ret = 0;
+	int err = 0;
+
+	switch (cmd) {
+	case DPA_IPSEC_IOC_INIT: {
+			struct ioc_dpa_ipsec_params prm;
+			if (copy_from_user(&prm,
+					   (struct ioc_dpa_ipsec_params *) args,
+					    sizeof(prm))) {
+				xx_pr_err(("Could not copy parameters "));
+				return -EINVAL;
+			}
+			err = dpa_ipsec_init(&prm.dpa_ipsec_params,
+					     &prm.dpa_ipsec_id);
+			if (err < 0)
+				return err;
+
+			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+				xx_pr_err(("Could not copy to user the SA id"));
+				return -EINVAL;
+			}
+			break;
+		}
+
+	case DPA_IPSEC_IOC_FREE: {
+			int dpa_ipsec_id;
+			if (copy_from_user(&dpa_ipsec_id, (int *)args,
+					    sizeof(int))) {
+				xx_pr_err(("Could not copy parameters"));
+				return -EINVAL;
+			}
+			err = dpa_ipsec_free(dpa_ipsec_id);
+			if (err < 0)
+				return err;
+			break;
+		}
+
+	case DPA_IPSEC_IOC_CREATE_SA: {
+			struct ioc_dpa_ipsec_sa_params prm;
+			if (copy_from_user(&prm,
+					(struct ioc_dpa_ipsec_sa_params *) args,
+					 sizeof(prm))) {
+				xx_pr_err(("Could not copy parameters"));
+				return -EINVAL;
+			}
+			err = dpa_ipsec_create_sa(prm.dpa_ipsec_id,
+						  &prm.sa_params,
+						  &prm.sa_id);
+			if (err < 0)
+				return err;
+
+			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+				xx_pr_err(("Could not copy to user the SA id"));
+				return -EINVAL;
+			}
+			break;
+		}
+
+	case DPA_IPSEC_IOC_REMOVE_SA: {
+			int sa_id;
+			if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+				xx_pr_err(("Could not copy parameters"));
+				return -EINVAL;
+			}
+
+			err = dpa_ipsec_remove_sa(sa_id);
+			if (err < 0)
+				return err;
+			break;
+		}
+
+	case DPA_IPSEC_IOC_ADD_POLICY: {
+			struct ioc_dpa_ipsec_add_rem_policy pol;
+			if (copy_from_user(&pol,
+				   (struct ioc_dpa_ipsec_add_rem_policy *) args,
+				    sizeof(pol))) {
+				xx_pr_err(("Could not copy parameters"));
+				return -EINVAL;
+			}
+			err = dpa_ipsec_sa_add_policy(pol.sa_id,
+						      &pol.pol_params);
+			if (err < 0)
+				return err;
+			break;
+		}
+	case DPA_IPSEC_IOC_REMOVE_POLICY: {
+			struct ioc_dpa_ipsec_add_rem_policy pol;
+			if (copy_from_user(&pol,
+				   (struct ioc_dpa_ipsec_add_rem_policy *) args,
+				    sizeof(pol))) {
+				xx_pr_err(("Could not copy parameters\n"));
+				return -EINVAL;
+			}
+
+			err = dpa_ipsec_sa_remove_policy(pol.sa_id,
+							 &pol.pol_params);
+			if (err < 0)
+				return err;
+			break;
+		}
+
+	case DPA_IPSEC_IOC_SA_REKEYING: {
+			struct ioc_dpa_ipsec_sa_rekeying_prm prm;
+			int unused = 0;
+			if (copy_from_user(&prm,
+				  (struct ioc_dpa_ipsec_sa_rekeying_prm *) args,
+				   sizeof(prm))) {
+				xx_pr_err(("Could not copy parameters for rekeying"));
+				return -EINVAL;
+			}
+
+			err = dpa_ipsec_sa_rekeying(prm.sa_id,
+						    &prm.sa_params, NULL,
+						    unused, &prm.new_sa_id);
+			if (err < 0)
+				return err;
+
+			if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+				xx_pr_err(("Could not copy to user the SA id"));
+				return -EINVAL;
+			}
+			break;
+		}
+
+	case DPA_IPSEC_IOC_FLUSH_ALL_SA: {
+			int dpa_ipsec_id;
+
+			if (copy_from_user(&dpa_ipsec_id,
+					    (int *)args, sizeof(int))) {
+				xx_pr_err(("Could not copy parameters"));
+				return -EINVAL;
+			}
+
+			err = dpa_ipsec_flush_all_sa(dpa_ipsec_id);
+			if (err < 0)
+				return err;
+			break;
+		}
+
+	case DPA_IPSEC_IOC_GET_SA_POLICIES: {
+			struct ioc_dpa_ipsec_sa_get_policies prm, *in_prm;
+			int sa_id, num_pol;
+
+			in_prm = (struct ioc_dpa_ipsec_sa_get_policies *) args;
+			if (in_prm->sa_id < 0) {
+				xx_pr_err(("Invalid input sa id\n"));
+				return -EINVAL;
+			}
+
+			if (!in_prm->policy_params) {
+				if (!in_prm->num_pol) {
+					xx_pr_err(("Invalid parameters\n"));
+					return -EINVAL;
+				} else {
+					sa_id = in_prm->sa_id;
+					err = dpa_ipsec_sa_get_policies(sa_id,
+								NULL, &num_pol);
+					if (err < 0) {
+						xx_pr_err(("sa get policy count failed\n"));
+						return err;
+					}
+					if (copy_to_user(in_prm->num_pol,
+							 &num_pol,
+							 sizeof(int))) {
+						xx_pr_err(("Could not copy parameters\n"));
+						return -EINVAL;
+					}
+					return 0;
+				}
+			}
+
+			sa_id = in_prm->sa_id;
+			if (copy_from_user(&num_pol,
+					   in_prm->num_pol, sizeof(int))) {
+				xx_pr_err(("Could not copy user parameters\n"));
+				return -EINVAL;
+			}
+			if (num_pol <= 0) {
+				xx_pr_err(("Invalid number of policies for sa id %d\n", sa_id));
+				return -EINVAL;
+			}
+
+			prm.policy_params =
+				xx_malloc(num_pol * sizeof(*prm.policy_params));
+			if (!prm.policy_params) {
+				xx_pr_err(("No more memory"));
+				return -ENOMEM;
+			}
+			memset(prm.policy_params, 0,
+			       num_pol * sizeof(*prm.policy_params));
+
+			err = dpa_ipsec_sa_get_policies(sa_id,
+							prm.policy_params,
+							&num_pol);
+			if (err < 0) {
+				xx_pr_err(("Store policy failed"));
+				return err;
+			}
+
+			if (copy_to_user(in_prm->policy_params,
+					prm.policy_params,
+					num_pol * sizeof(*prm.policy_params))) {
+				xx_pr_err(("Could not copy parameters\n"));
+				return -EINVAL;
+			}
+			kfree(prm.policy_params);
+			break;
+		}
+	default:
+		xx_pr_err(("Invalid DPA IPsec ioctl\n"));
+		break;
+	}
+	return ret;
+}
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
new file mode 100644
index 0000000..2d2b4e8
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
@@ -0,0 +1,53 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WRP_DPA_IPSEC_H_
+#define WRP_DPA_IPSEC_H_
+
+#include <linux/fs.h>
+
+
+#define DPA_IPSEC_CDEV					"dpa_ipsec"
+
+
+int wrp_dpa_ipsec_init(void);
+
+int wrp_dpa_ipsec_exit(void);
+
+int wrp_dpa_ipsec_open(struct inode *inode, struct file *filp);
+
+int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp);
+
+long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args);
+
+#endif	/* WRP_DPA_IPSEC_H_ */
-- 
1.7.5.4

