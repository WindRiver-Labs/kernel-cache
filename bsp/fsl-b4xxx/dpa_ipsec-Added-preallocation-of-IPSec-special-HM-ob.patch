From 8e0460fc3c62ed3a2ea50d465bbb2ccc7a9b0926 Mon Sep 17 00:00:00 2001
From: Bulie Radu-Andrei-B37577 <radu.bulie@freescale.com>
Date: Sat, 10 Nov 2012 00:10:54 +0000
Subject: [PATCH 396/518] dpa_ipsec: Added preallocation of IPSec special HM
 obj during DPA IPSec initialization

Updated dpa_ipsec API with new param max_sa_manip_ops, maximum number
of special IPSec manipulation operations that can be enabled (e.g. DSCP/ECN
update, IP variable length).

Created a pool of DPA IPSec special manipulation operations used at
runtime for creating operations like DSCP/ECN update or IP variable length
or variable IP version.

The old mechanism without preallocation is working too, setting
max_sa_manip_ops equal to 0 for runtime allocation.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |  295 +++++++++++++++++++++++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |   23 ++
 include/linux/fsl_dpa_ipsec.h               |   14 ++
 3 files changed, 318 insertions(+), 14 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 34f56ff..66e15ee 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -48,6 +48,7 @@ struct ipsec_alg_suite ipsec_algs[] = IPSEC_ALGS;
 
 /* globally allocated because of performance constraints */
 static t_FmPcdCcNodeParams cc_node_prms;
+
 static t_FmPcdManipParams pcd_manip_params;
 
 /* Global dpa_ipsec component */
@@ -55,6 +56,7 @@ struct dpa_ipsec *gbl_dpa_ipsec;
 
 static int sa_flush_policies(struct dpa_ipsec_sa *sa);
 static int sa_rekeying_outbound(struct dpa_ipsec_sa *new_sa);
+static void *alloc_ipsec_manip(struct dpa_ipsec *dpa_ipsec);
 
 /* Debug support functions */
 
@@ -629,6 +631,115 @@ static void put_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int table_desc)
 	mutex_unlock(&dpa_ipsec->sa_mng.inpol_tables_lock);
 }
 
+static int get_free_ipsec_manip_node(struct dpa_ipsec *dpa_ipsec, void **hm)
+{
+	struct ipsec_manip_node *ipsec_manip_node;
+	struct list_head *head;
+	int ret = 0;
+
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!hm);
+
+	/*
+	 * Lock IPSec manip node list
+	 */
+	mutex_lock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+
+	head = &dpa_ipsec->sa_mng.ipsec_manip_node_list;
+
+	list_for_each_entry(ipsec_manip_node, head, ipsec_manip_node_list)
+		if (!ipsec_manip_node->used)
+			break;
+
+	if (!ipsec_manip_node->used) {
+		BUG_ON(!ipsec_manip_node->hm);
+		ipsec_manip_node->used = true;
+		*hm = ipsec_manip_node->hm;
+	} else {
+		pr_err("No more free IPSec manip nodes for special operations\n");
+		ret = -ENOMEM;
+	}
+
+	/*
+	 * Unlock IPSec manip node list
+	 */
+	mutex_unlock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+
+	return ret;
+}
+
+static void put_free_ipsec_manip_node(struct dpa_ipsec *dpa_ipsec, void *hm)
+{
+	struct ipsec_manip_node *ipsec_manip_node;
+	struct list_head *head;
+	bool found = false;
+
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!hm);
+
+	/*
+	 * Lock IPSec manip node list
+	 */
+	mutex_lock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+
+	head = &dpa_ipsec->sa_mng.ipsec_manip_node_list;
+
+	list_for_each_entry(ipsec_manip_node, head, ipsec_manip_node_list)
+		if (ipsec_manip_node->hm == hm) {
+			found = true;
+			break;
+		}
+
+	BUG_ON(!found);
+
+	if (ipsec_manip_node->used)
+		ipsec_manip_node->used = false;
+	else
+		pr_warn("IPSec manip node %p is not used\n", hm);
+
+	/*
+	 * Unlock IPSec manip node list
+	 */
+	mutex_unlock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+}
+
+static void replace_ipsec_manip_node(struct dpa_ipsec *dpa_ipsec, void *hm_old,
+				     void *hm_new)
+{
+	struct ipsec_manip_node *ipsec_manip_node;
+	struct list_head *head;
+	bool found = false;
+
+	BUG_ON(!dpa_ipsec);
+	BUG_ON(!hm_old);
+	BUG_ON(!hm_new);
+
+	/*
+	 * Lock IPSec manip node list
+	 */
+	mutex_lock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+
+	head = &dpa_ipsec->sa_mng.ipsec_manip_node_list;
+
+	list_for_each_entry(ipsec_manip_node, head, ipsec_manip_node_list)
+		if (ipsec_manip_node->hm == hm_old) {
+			found = true;
+			break;
+		}
+
+	BUG_ON(!found);
+
+	if (ipsec_manip_node->used)
+		ipsec_manip_node->hm = hm_new;
+	else
+		pr_warn("IPSec manip node %p is not used\n", hm_old);
+
+	/*
+	 * Unlock IPSec manip node list
+	 */
+	mutex_unlock(&dpa_ipsec->sa_mng.ipsec_manip_node_lock);
+}
+
 /* initialize fqid management CQ */
 static int create_fqid_cq(struct dpa_ipsec *dpa_ipsec)
 {
@@ -846,6 +957,41 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 		mutex_unlock(&sa_mng->inpol_tables_lock);
 	}
 
+	/*
+	 * Initialize the SA IPSec manip node list and its protective lock
+	 */
+	INIT_LIST_HEAD(&dpa_ipsec->sa_mng.ipsec_manip_node_list);
+	mutex_init(&sa_mng->ipsec_manip_node_lock);
+
+	/*
+	 * Populate the list of IPSec manip node
+	 */
+	mutex_lock(&sa_mng->ipsec_manip_node_lock);
+	for (i = 0; i < dpa_ipsec->config.max_sa_manip_ops; i++) {
+		struct ipsec_manip_node *node;
+
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (!node) {
+			pr_err("Could not allocate memory for IPSec manip node\n");
+			mutex_unlock(&sa_mng->ipsec_manip_node_lock);
+			return -ENOMEM;
+		}
+
+		node->hm = alloc_ipsec_manip(dpa_ipsec);
+		if (!node->hm) {
+			pr_err("Could not create IPSec manip node\n");
+			kfree(node);
+			mutex_unlock(&sa_mng->ipsec_manip_node_lock);
+			return -ENOMEM;
+		}
+
+		node->used = false;
+		list_add(&node->ipsec_manip_node_list,
+			 &dpa_ipsec->sa_mng.ipsec_manip_node_list);
+
+	}
+	mutex_unlock(&sa_mng->ipsec_manip_node_lock);
+
 	/* Initialize the SA rekeying list and its protective lock */
 	INIT_LIST_HEAD(&dpa_ipsec->sa_mng.sa_rekeying_headlist);
 	mutex_init(&sa_mng->sa_rekeying_headlist_lock);
@@ -1206,8 +1352,10 @@ static int create_frag_manip(struct dpa_ipsec *dpa_ipsec,
 	return err;
 }
 
-static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd,
-	int *hmd)
+/*
+ * Used at runtime when preallocation of IPSec manip node is not enabled
+ */
+static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
 {
 	t_FmPcdManipParams pcd_manip_params;
 	t_FmPcdManipSpecialOffloadParams *offld_params;
@@ -1239,12 +1387,13 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd,
 	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
 	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
 
-	pcd_manip_params.h_NextManip =
-			dpa_classif_get_static_hm_handle(next_hmd);
+	pcd_manip_params.h_NextManip = dpa_classif_hm_lock_chain(next_hmd);
+	dpa_classif_hm_release_chain(next_hmd);
+
 	hm = FM_PCD_ManipNodeSet(sa->dpa_ipsec->config.fm_pcd,
 				 &pcd_manip_params);
 	if (!hm) {
-		pr_err("%s: FM_PCD_ManipSetNode failed!\n", __func__);
+		pr_err("%s: FM_PCD_ManipNodeSet failed!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -1256,6 +1405,113 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd,
 	return err;
 }
 
+/*
+ * If preallocation of IPSec manip node(s) was specified the code is using this
+ * function to allocate and populate the list of IPSec manip objects
+ */
+static void *alloc_ipsec_manip(struct dpa_ipsec *dpa_ipsec)
+{
+	t_FmPcdManipParams pcd_manip_params;
+	t_FmPcdManipSpecialOffloadParams *offld_params;
+	t_Handle hm;
+
+	BUG_ON(!dpa_ipsec);
+
+	memset(&pcd_manip_params, 0, sizeof(struct t_FmPcdManipParams));
+	pcd_manip_params.type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD;
+	offld_params = &pcd_manip_params.u.specialOffload;
+	offld_params->type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC;
+	offld_params->u.ipsec.decryption = true;
+	offld_params->u.ipsec.variableIpHdrLen = false;
+	offld_params->u.ipsec.ecnCopy = false;
+	offld_params->u.ipsec.dscpCopy = false;
+	offld_params->u.ipsec.variableIpVersion = false;
+	offld_params->u.ipsec.outerIPHdrLen = 0;
+	pcd_manip_params.h_NextManip = NULL;
+
+	hm = FM_PCD_ManipNodeSet(dpa_ipsec->config.fm_pcd, &pcd_manip_params);
+	if (!hm) {
+		pr_err("%s: FM_PCD_ManipSetNode failed!\n", __func__);
+		return NULL;
+	}
+
+	return hm;
+}
+
+/*
+ * Used at runtime when preallocation of IPSec manip nodes was enabled
+ */
+static int update_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
+{
+	t_FmPcdManipParams pcd_manip_params;
+	t_FmPcdManipSpecialOffloadParams *offld_params;
+	t_Handle ipsec_hm = NULL, new_hm = NULL;
+	t_Error err;
+	int ret;
+
+	BUG_ON(!sa);
+	BUG_ON(!hmd);
+
+	if (!sa->use_var_iphdr_len && !sa->dscp_copy && !sa->ecn_copy &&
+	    !(sa->sa_dir == DPA_IPSEC_OUTBOUND && sa->enable_dpovrd)) {
+		/* no need to create a new manipulation objects chain */
+		*hmd = next_hmd;
+		return 0;
+	}
+
+	memset(&pcd_manip_params, 0, sizeof(struct t_FmPcdManipParams));
+	pcd_manip_params.type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD;
+	offld_params = &pcd_manip_params.u.specialOffload;
+	offld_params->type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC;
+	if (sa->sa_dir == DPA_IPSEC_INBOUND)
+		offld_params->u.ipsec.decryption = true;
+	offld_params->u.ipsec.variableIpHdrLen = sa->use_var_iphdr_len;
+	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
+	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
+	pcd_manip_params.h_NextManip = dpa_classif_hm_lock_chain(next_hmd);
+	dpa_classif_hm_release_chain(next_hmd);
+
+	ret = get_free_ipsec_manip_node(sa->dpa_ipsec, &ipsec_hm);
+	if (ret < 0) {
+		pr_err("%s: get_free_ipsec_manip_node failed for %s SA %d!\n",
+			__func__, sa->sa_dir == DPA_IPSEC_INBOUND ?
+			"inbound" : "outbound", sa->id);
+		return ret;
+	}
+	/*
+	 * Should not be NULL
+	 */
+	BUG_ON(!ipsec_hm);
+
+	new_hm = FM_PCD_ManipNodeSet(sa->dpa_ipsec->config.fm_pcd,
+				     &pcd_manip_params);
+	if (!new_hm) {
+		pr_err("%s: FM_PCD_ManipSetNode failed!\n", __func__);
+		put_free_ipsec_manip_node(sa->dpa_ipsec, ipsec_hm);
+		return -EBUSY;
+	}
+
+	replace_ipsec_manip_node(sa->dpa_ipsec, ipsec_hm, new_hm);
+
+	err = FM_PCD_ManipNodeDelete(ipsec_hm);
+	if (err != E_OK) {
+		pr_err("%s: FM_PCD_ManipNodeDelete failed for %s SA %d!\n",
+			__func__, sa->sa_dir == DPA_IPSEC_INBOUND ?
+			"inbound" : "outbound", sa->id);
+		put_free_ipsec_manip_node(sa->dpa_ipsec, new_hm);
+		return -EBUSY;
+	}
+
+	ret = dpa_classif_import_static_hm(new_hm, next_hmd, hmd);
+	if (ret < 0) {
+		pr_err("%s: Failed to import header manipulation into DPA "
+			"Classifier.\n", __func__);
+		put_free_ipsec_manip_node(sa->dpa_ipsec, new_hm);
+	}
+
+	return ret;
+}
+
 static int destroy_manip(int hmd)
 {
 	int err = 0;
@@ -1431,7 +1687,7 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 			}
 			pol_hmd = policy_entry->hmd;
 		} else {
-			if (sa->ipsec_hmd == DPA_OFFLD_DESC_NONE) {
+			if (sa->ipsec_hmd == DPA_OFFLD_DESC_NONE)
 				/*
 				 * need to create the IPSec Manip (per SA),
 				 * if it was not created earlier
@@ -1439,10 +1695,13 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 				err = create_ipsec_manip(sa,
 							 DPA_OFFLD_DESC_NONE,
 							 &sa->ipsec_hmd);
-				if (err < 0) {
-					pr_err("Couldn't create SA manip!\n");
-					return err;
-				}
+			else
+				err = update_ipsec_manip(sa,
+							 DPA_OFFLD_DESC_NONE,
+							 &sa->ipsec_hmd);
+			if (err < 0) {
+				pr_err("Couldn't create SA manip!\n");
+				return err;
 			}
 			pol_hmd = sa->ipsec_hmd;
 		}
@@ -2920,8 +3179,12 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 
 	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
 	if (sa->sa_dir == DPA_IPSEC_INBOUND) {
-		err = create_ipsec_manip(sa, DPA_OFFLD_DESC_NONE,
-			&sa->ipsec_hmd);
+		if (sa->dpa_ipsec->config.max_sa_manip_ops == 0)
+			err = create_ipsec_manip(sa, DPA_OFFLD_DESC_NONE,
+						 &sa->ipsec_hmd);
+		else
+			err = update_ipsec_manip(sa, DPA_OFFLD_DESC_NONE,
+						 &sa->ipsec_hmd);
 		if (err < 0) {
 			pr_err("Could not create Manip object for in SA!\n");
 			goto create_sa_err;
@@ -3615,8 +3878,12 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 
 	/* Initialize the IPSec Manip. object (if required) for inbound SAs */
 	if (new_sa->sa_dir == DPA_IPSEC_INBOUND) {
-		err = create_ipsec_manip(new_sa, DPA_OFFLD_DESC_NONE,
-			&new_sa->ipsec_hmd);
+		if (new_sa->dpa_ipsec->config.max_sa_manip_ops == 0)
+			err = create_ipsec_manip(new_sa, DPA_OFFLD_DESC_NONE,
+						 &new_sa->ipsec_hmd);
+		else
+			err = update_ipsec_manip(new_sa, DPA_OFFLD_DESC_NONE,
+						 &new_sa->ipsec_hmd);
 		if (err < 0) {
 			pr_err("Could not create Manip object for in SA!\n");
 			goto rekey_sa_err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 7dec1c9..1f107b3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -319,6 +319,19 @@ struct inpol_tbl {
 	struct list_head table_list;
 };
 
+/*
+ * Parameters for IPsec special manipulations eg. DSCP/ECN update
+ * Global list lock - ipsec_manip_node_lock from SA manager
+ */
+struct ipsec_manip_node {
+	/*
+	 * IPsec manip node handle; returned by FM_PCD_ManipNodeSet
+	 */
+	void *hm;
+	bool used;
+	struct list_head ipsec_manip_node_list;
+};
+
 /* DPA IPSEC - Security Associations Management */
 struct dpa_ipsec_sa_mng {
 	struct dpa_ipsec_sa *sa; /* Array of SAs. Use indexes from sa_id_cq   */
@@ -333,6 +346,16 @@ struct dpa_ipsec_sa_mng {
 		Populated only if inbound policy verification is enabled      */
 	struct mutex inpol_tables_lock; /* Lock for the inbound policy table
 					   list */
+
+	 /*
+	  * ipsec_manip_node head list
+	  */
+	struct list_head ipsec_manip_node_list;
+
+	/*
+	 * Lock for IPsec manip node list
+	 */
+	struct mutex ipsec_manip_node_lock;
 	struct delayed_work sa_rekeying_work;
 	struct workqueue_struct *sa_rekeying_wq; /* Single threaded work
 				queue used to defer the work to be done in the
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 785ac8e..b431453 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -69,6 +69,9 @@
 #define DPA_IPSEC_MAX_IN_POL_PER_SA  255  /* Maximum supported number of
 					   * inbound policies per SA	      */
 
+/*
+ * IPSec Special Operations
+ */
 #define DPA_IPSEC_HDR_COPY_TOS		0x01 /* Copy TOS / DiffServ byte from
 					      * inner / outer header to outer /
 					      * inner header		      */
@@ -185,6 +188,17 @@ struct dpa_ipsec_params {
 	uint16_t qm_sec_ch;	/* QMan channel# for the SEC		      */
 	uint16_t max_sa_pairs;	/* Maximum number of SA pairs
 				 * (1 SA Pair = 1 In SA + 1 Out SA)	      */
+
+	/*
+	 * Maximum number of special IPSec
+	 * manipulation operations that can be
+	 * enabled. eg DSCP/ECN update, IP variable
+	 * length. The max_sa_manip_ops
+	 * should be incremented with the number
+	 * of manipulations per every outbound
+	 * policy
+	 */
+	uint32_t max_sa_manip_ops;
 	struct dpa_ipsec_fqid_range *fqid_range; /* FQID range to be used by
 						  * DPA IPSec for allocating
 						  * FQIDs for internal FQs    */
-- 
1.7.5.4

