From f3098f14b2fbf16da9e6dd1ddd3243526f7fa0a9 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:10:52 +0000
Subject: [PATCH 4/7] dpa_classifier: Add support for runtime modification of Insert type header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |  216 +++++++++----------
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    6 -
 2 files changed, 102 insertions(+), 120 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 12f2dbf..d7015fe 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -5178,13 +5178,9 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	struct dpa_cls_hm_node *hm_node;
 
 	BUG_ON(!pinsert_hm);
+	BUG_ON(pinsert_hm->num_nodes != 1);
+	BUG_ON(!pinsert_hm->hm_node[0]);
 
-	if ((pinsert_hm->num_nodes < 1) || (!pinsert_hm->hm_node[0])) {
-		pr_err("ERROR: %s, %s (%d): Inconsistency between resources "
-			"and provided parameters.\n", __FILE__, __func__,
-			__LINE__);
-		return -EINVAL;
-	}
 	hm_node = pinsert_hm->hm_node[0];
 
 	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
@@ -5256,6 +5252,7 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	default:
 		/* Should never get here */
 		BUG_ON(1);
+		break;
 	}
 
 	hm_node->params.u.hdr.insrtParams.u.generic.offset	= offset;
@@ -5270,14 +5267,13 @@ int dpa_classif_modify_insert_hm(int hmd,
 	const struct dpa_cls_hm_insert_params *new_insert_params,
 	int modify_flags)
 {
-	struct dpa_cls_hm *pinsert_hm;
-	unsigned int size = 0;
-	uint8_t offset = 0;
-	uint8_t *pdata = NULL;
 	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pinsert_hm;
 	bool update = false;
-	int mask;
 	t_Error error;
+	int ret = 0;
+	int mask;
+	uint8_t *pdata;
 
 	if (!modify_flags)
 		/* Nothing to do */
@@ -5309,124 +5305,116 @@ int dpa_classif_modify_insert_hm(int hmd,
 		return -EINVAL;
 	}
 
-	BUG_ON(pinsert_hm->num_nodes < 1);
-	BUG_ON(!pinsert_hm->hm_node[0]);
-
-	hm_node = pinsert_hm->hm_node[0];
+	mask = DPA_CLS_HM_INS_MOD_ETH_HEADER |
+		DPA_CLS_HM_INS_MOD_QTAGS |
+		DPA_CLS_HM_INS_MOD_PPPoE_HEADER;
+	if ((modify_flags & mask) && (pinsert_hm->insert_params.type !=
+			DPA_CLS_HM_INSERT_ETHERNET)) {
+		pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't work on "
+			"hmd=%d. It only works on INSERT ETHERNET header "
+			"manipulations.\n", __FILE__, __func__, __LINE__,
+			modify_flags, hmd);
+		return -EINVAL;
+	}
 
-	switch (pinsert_hm->insert_params.type) {
-	case DPA_CLS_HM_INSERT_ETHERNET:
-		mask = DPA_CLS_HM_INS_MOD_ETH_HEADER |
-			DPA_CLS_HM_INS_MOD_NUM_QTAGS |
-			DPA_CLS_HM_INS_MOD_QTAGS_ARRAY |
-			DPA_CLS_HM_INS_MOD_PPPoE_HEADER;
-		if ((modify_flags & mask) == 0)
-			break;
-		if (modify_flags & DPA_CLS_HM_INS_MOD_NUM_QTAGS) {
-			if (new_insert_params->eth.num_tags >
-				pinsert_hm->insert_params.eth.num_tags) {
-				size = sizeof(struct ethhdr) +
-					(new_insert_params->eth.num_tags *
-					sizeof(struct vlan_header));
-				kfree(hm_node->params.u.hdr.insrtParams.u.
-							generic.p_Data);
-				pdata = kzalloc(size, GFP_KERNEL);
-				if (!pdata) {
-					pr_err("ERROR: %s, %s (%d): Not enough "
-						"memory for insert HM.\n",
-						__FILE__, __func__, __LINE__);
-					return -ENOMEM;
-				}
-				hm_node->params.u.hdr.insrtParams.u.generic.
-								p_Data = pdata;
-			}
+	mask = DPA_CLS_HM_INS_MOD_CUSTOM_OFFSET |
+		DPA_CLS_HM_INS_MOD_CUSTOM_DATA;
+	if ((modify_flags & mask) && (pinsert_hm->insert_params.type !=
+			DPA_CLS_HM_INSERT_CUSTOM)) {
+		pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't work on "
+			"hmd=%d. It only works on CUSTOM INSERT header "
+			"manipulations.\n", __FILE__, __func__, __LINE__,
+			modify_flags, hmd);
+		return -EINVAL;
+	}
 
-			pinsert_hm->insert_params.eth.num_tags =
-						new_insert_params->eth.num_tags;
+	if ((modify_flags & DPA_CLS_HM_INS_MOD_PPP_PID) &&
+		(pinsert_hm->insert_params.ppp_pid !=
+					new_insert_params->ppp_pid)) {
+		if (pinsert_hm->insert_params.type !=
+						DPA_CLS_HM_INSERT_PPP) {
+			pr_err("ERROR: %s, %s (%d): modify_flags=0x%x doesn't "
+				"work on hmd=%d. It only works on INSERT PPP "
+				"header manipulations.\n", __FILE__, __func__,
+				__LINE__, modify_flags, hmd);
+			return -EINVAL;
 		}
-		pdata = hm_node->params.u.hdr.insrtParams.u.generic.p_Data;
 
-		if (pinsert_hm->insert_params.eth.num_tags) {
-			/* Copy Ethernet header data except the EtherType */
-			memcpy(pdata,
-				&pinsert_hm->insert_params.eth.eth_header,
-				sizeof(struct ethhdr) - ETHERTYPE_SIZE);
-			offset += (uint8_t)(sizeof(struct ethhdr) -
-								ETHERTYPE_SIZE);
-			/* Copy the VLAN tags */
-			memcpy(&pdata[offset],
-				&pinsert_hm->insert_params.eth.qtag,
-				pinsert_hm->insert_params.eth.num_tags *
-				sizeof(struct vlan_header));
-			offset += (uint8_t) (pinsert_hm->insert_params.eth.
-				num_tags * sizeof(struct vlan_header));
-			/* Copy the EtherType */
-			memcpy(&pdata[offset],
-		&pinsert_hm->insert_params.eth.eth_header.h_proto,
-				ETHERTYPE_SIZE);
-		} else
-			/* Copy the entire Ethernet header */
-			memcpy(pdata,
-				&pinsert_hm->insert_params.eth.eth_header,
-				sizeof(struct ethhdr));
 		update = true;
-		break;
-	case DPA_CLS_HM_INSERT_PPP:
-		if ((modify_flags & DPA_CLS_HM_INS_MOD_PPP_PID) == 0)
-			break;
+		pinsert_hm->insert_params.ppp_pid = new_insert_params->ppp_pid;
+	}
 
-		/* Copy the PPP PID */
-		memcpy(hm_node->params.u.hdr.insrtParams.u.generic.p_Data,
-			&pinsert_hm->insert_params.ppp_pid,
-			PPP_HEADER_SIZE);
+	if ((modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_OFFSET) &&
+		(pinsert_hm->insert_params.custom.offset !=
+					new_insert_params->custom.offset)) {
 		update = true;
-		break;
-	case DPA_CLS_HM_INSERT_CUSTOM:
-		if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_OFFSET) {
-			hm_node->params.u.hdr.insrtParams.u.generic.offset =
-				new_insert_params->custom.offset;
-			update = true;
-		}
-		if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_DATA) {
-			if ((modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_SIZE) &&
-		(hm_node->params.u.hdr.insrtParams.u.generic.size <
-					new_insert_params->custom.size)) {
-				kfree(hm_node->params.u.hdr.insrtParams.u.
-								generic.p_Data);
-	hm_node->params.u.hdr.insrtParams.u.generic.p_Data =
-			kzalloc(new_insert_params->custom.size, GFP_KERNEL);
-	if (!hm_node->params.u.hdr.insrtParams.u.generic.p_Data) {
-		pr_err("ERROR: %s, %s (%d): Not enough memory for "
-			"insert HM.\n", __FILE__, __func__, __LINE__);
-		return -ENOMEM;
+		pinsert_hm->insert_params.custom.offset =
+					new_insert_params->custom.offset;
 	}
-	hm_node->params.u.hdr.insrtParams.u.generic.size =
-						new_insert_params->custom.size;
-			}
-	memcpy(hm_node->params.u.hdr.insrtParams.u.generic.p_Data,
-		pinsert_hm->insert_params.custom.data,
-		hm_node->params.u.hdr.insrtParams.u.generic.size);
-			update = true;
+
+	if ((modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_OFFSET) &&
+		(pinsert_hm->insert_params.custom.offset !=
+					new_insert_params->custom.offset)) {
+		update = true;
+		pinsert_hm->insert_params.custom.offset =
+					new_insert_params->custom.offset;
+	}
+
+	if (modify_flags & DPA_CLS_HM_INS_MOD_CUSTOM_DATA) {
+		update = true;
+		pdata = kzalloc(new_insert_params->custom.size, GFP_KERNEL);
+		if (!pdata) {
+			pr_err("ERROR: %s, %s (%d): Not enough memory to "
+				"adjust custom insert header manipulation.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
 		}
-		break;
-	default:
-		/* Should never get here */
-		BUG_ON(1);
+		/* Replace old data buffer with the new data buffer */
+		kfree(pinsert_hm->insert_params.custom.data);
+		pinsert_hm->insert_params.custom.data = pdata;
+
+		pinsert_hm->insert_params.custom.size =
+						new_insert_params->custom.size;
+		memcpy(pdata, new_insert_params->custom.data,
+					new_insert_params->custom.size);
+	}
+
+	if (modify_flags & DPA_CLS_HM_INS_MOD_QTAGS) {
+		update = true;
+		pinsert_hm->insert_params.eth.num_tags =
+					new_insert_params->eth.num_tags;
+		memcpy(pinsert_hm->insert_params.eth.qtag,
+			new_insert_params->eth.qtag,
+			pinsert_hm->insert_params.eth.num_tags *
+				sizeof(struct vlan_header));
+	}
+
+	if (modify_flags & DPA_CLS_HM_INS_MOD_ETH_HEADER) {
+		update = true;
+		memcpy(&pinsert_hm->insert_params.eth.eth_header,
+			&new_insert_params->eth.eth_header,
+			sizeof(struct ethhdr));
 	}
 
 	if (update) {
-		error = FM_PCD_ManipNodeReplace(hm_node->node,
-						&hm_node->params);
-		if (error != E_OK) {
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed - "
-				"FM_PCD_ManipNodeReplace, while trying to modify"
-				" hmd=%d, manip node handle=0x%p.\n", __FILE__,
-				__func__, __LINE__, hmd, hm_node->node);
-			return -EBUSY;
+		ret = insert_hm_update_params(pinsert_hm);
+		if (ret == 0) {
+			hm_node = pinsert_hm->hm_node[0];
+
+			error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&hm_node->params);
+			if (error != E_OK) {
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed - FM_PCD_ManipNodeReplace, "
+					"while trying to modify hmd=%d, manip "
+					"node handle=0x%p.\n", __FILE__,
+					__func__, __LINE__, hmd, hm_node->node);
+				return -EBUSY;
+			}
 		}
 	}
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_insert_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index bf7d426..7266898 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -945,12 +945,6 @@ static long do_ioctl_modify_insert_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d) -->\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.ins_params.fm_pcd = translate_fm_pcd_handle(kparam.ins_params.
-								fm_pcd);
-	if (!kparam.ins_params.fm_pcd)
-		return -EINVAL;
-
 	if (kparam.ins_params.type == DPA_CLS_HM_INSERT_CUSTOM) {
 		sz = kparam.ins_params.custom.size;
 		data =	kzalloc(sz * sizeof(*data), GFP_KERNEL);
-- 
1.7.0.2

