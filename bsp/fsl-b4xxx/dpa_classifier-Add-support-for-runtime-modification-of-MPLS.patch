From 98ae9a2f235bb2462d814800e9f74a356b0d9713 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Wed, 20 Feb 2013 20:11:26 +0000
Subject: [PATCH 7/7] dpa_classifier: Add support for runtime modification of MPLS specific header manipulations

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |   74 +++++++++++++++++++-
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    6 --
 2 files changed, 71 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 45a9542..61c6023 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -6584,9 +6584,77 @@ static int mpls_hm_update_params(struct dpa_cls_hm *pmpls_hm)
 int dpa_classif_modify_mpls_hm(int hmd,
 	const struct dpa_cls_hm_mpls_params *new_mpls_params, int modify_flags)
 {
-	pr_err("ERROR: %s, %s (%d): Not implemented yet.\n", __FILE__, __func__,
-		__LINE__);
-	return -ENOSYS;
+	struct dpa_cls_hm_node *hm_node;
+	struct dpa_cls_hm *pmpls_hm;
+	bool update = false;
+	t_Error error;
+	int ret = 0;
+
+	if (!modify_flags)
+		/* Nothing to do */
+		return 0;
+
+	/* Parameters sanity checks: */
+	if (!new_mpls_params) {
+		pr_err("ERROR: %s, %s (%d): \"new_mpls_params\" cannot be "
+			"NULL.\n", __FILE__, __func__, __LINE__);
+		return -EINVAL;
+	}
+	if ((hmd < 0) || (hmd >= hm_array.num_descriptors)) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d. "
+			"Should be between %d and %d.\n", __FILE__, __func__,
+			__LINE__, hmd, 0, hm_array.num_descriptors-1);
+		return -EINVAL;
+	}
+	if (!hm_array.object[hmd]) {
+		pr_err("ERROR: %s, %s (%d): Invalid HM descriptor hmd=%d.\n",
+			__FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	pmpls_hm = (struct dpa_cls_hm *)hm_array.object[hmd];
+
+	if (pmpls_hm->type != DPA_CLS_HM_TYPE_MPLS) {
+		pr_err("ERROR: %s, %s (%d): hmd=%d is not an MPLS type "
+			"header manip.\n", __FILE__, __func__, __LINE__, hmd);
+		return -EINVAL;
+	}
+
+	if ((modify_flags && DPA_CLS_HM_MPLS_MOD_NUM_LABELS) &&
+		(pmpls_hm->mpls_params.num_labels !=
+						new_mpls_params->num_labels)) {
+		update = true;
+		pmpls_hm->mpls_params.num_labels =
+					new_mpls_params->num_labels;
+	}
+
+	if (modify_flags && DPA_CLS_HM_MPLS_MOD_HDR_ARRAY) {
+		update = true;
+		memcpy(pmpls_hm->mpls_params.mpls_hdr,
+			new_mpls_params->mpls_hdr,
+			pmpls_hm->mpls_params.num_labels *
+				sizeof(struct mpls_header));
+	}
+
+	if (update) {
+		ret = mpls_hm_update_params(pmpls_hm);
+		if (ret == 0) {
+			hm_node = pmpls_hm->hm_node[0];
+
+			error = FM_PCD_ManipNodeReplace(hm_node->node,
+							&hm_node->params);
+			if (error != E_OK) {
+				pr_err("ERROR: %s, %s (%d): FMan driver call "
+					"failed - FM_PCD_ManipNodeReplace, "
+					"while trying to modify hmd=%d, manip "
+					"node handle=0x%p.\n", __FILE__,
+					__func__, __LINE__, hmd, hm_node->node);
+				return -EBUSY;
+			}
+		}
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL(dpa_classif_modify_mpls_hm);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 3c4c6dd..2642bc1 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -1490,12 +1490,6 @@ static long  do_ioctl_modify_mpls_hm(unsigned long args, bool compat_mode)
 	dpa_cls_wrp_dbg(("DEBUG: classifier_wrp %s (%d)\n", __func__,
 		__LINE__));
 
-	/* Translate FM_PCD file descriptor */
-	kparam.mpls_params.fm_pcd = translate_fm_pcd_handle(kparam.mpls_params.
-								fm_pcd);
-	if (!kparam.mpls_params.fm_pcd)
-		return -EINVAL;
-
 	return dpa_classif_modify_mpls_hm(kparam.hmd, &kparam.mpls_params,
 					kparam.modify_flags);
 }
-- 
1.7.0.2

