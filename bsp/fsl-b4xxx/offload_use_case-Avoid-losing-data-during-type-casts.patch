From e2a25a8e276f0e37b8deada54a20125601eb1813 Mon Sep 17 00:00:00 2001
From: Radu-Andrei BULIE <radu.bulie@freescale.com>
Date: Wed, 31 Oct 2012 22:39:18 +0000
Subject: [PATCH 371/518] offload_use_case: Avoid losing data during type
 casts

This patch solves the possible issue of losing data when
converting from int to uint_8 or uint_16

Signed-off-by: Radu-Andrei BULIE <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../staging/fsl_dpa_offload/usecases/genl_ctl.c    |    2 +-
 .../staging/fsl_dpa_offload/usecases/ipsec_init.c  |    8 ++--
 drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c |   38 +++++++++++--------
 3 files changed, 27 insertions(+), 21 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
index 6fd4af3..a6118f7 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/genl_ctl.c
@@ -103,7 +103,7 @@ static int policy_walk_func_fromsa(struct xfrm_policy *pol, int dir, int count,
 	if (dir == XFRM_POLICY_OUT || dir == XFRM_POLICY_IN) {
 		memset(&pol_id, 0, sizeof(pol_id));
 		pol_id.sel = pol->selector;
-		pol_id.dir = dir;
+		pol_id.dir = (uint8_t)dir;
 		pol_id.index = pol->index;
 		ret = nla_put(skb, XFRMA_POLICY, sizeof(pol_id), &pol_id);
 		if (ret) {
diff --git a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
index d4648f9..59912ef 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/ipsec_init.c
@@ -123,11 +123,11 @@ static int num_entries[DPA_IPSEC_MAX_SA_TYPE][2] = {
 					 DPA_IPSEC_KEY_FIELD_SPORT |	\
 					 DPA_IPSEC_KEY_FIELD_DPORT)
 
-static int inb_key_size[] = IPSEC_PRE_DEC_TBL_KEY_SIZE;
-static int outb_key_size[] = IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE;
+static uint8_t inb_key_size[] = IPSEC_PRE_DEC_TBL_KEY_SIZE;
+static uint8_t outb_key_size[] = IPSEC_OUT_PRE_ENC_TBL_KEY_SIZE;
 static int out_pol_cc_node_keys[] = IPSEC_OUT_POL_CC_NODE_KEYS;
 static int outb_post_enc_ccnode_num_entries[] = IPSEC_OUT_POST_ENC_NUM_ENTRIES;
-static int outb_post_enc_ccnode_key_size[] = IPSEC_OUT_POST_ENC_KEY_SIZE;
+static uint8_t outb_post_enc_ccnode_key_size[] = IPSEC_OUT_POST_ENC_KEY_SIZE;
 static struct dpa_ipsec_params ipsec_params;
 static int ipsec_initialized = 0;
 static int hmd_ins, hmd_rm, hmd_nat;
@@ -401,7 +401,7 @@ static int create_hm_outb_pre_enc(int *outb_hmd, struct ipsec_uparms *params)
 	nat_params.nat.dip.version = IPVERSION;
 	nat_params.nat.sip.addr.ipv4.word = params->ip_src_ob_nat;
 	nat_params.nat.dip.addr.ipv4.word = params->ip_dst_ob_nat;
-	nat_params.dport = params->udp_dport_ob_nat;
+	nat_params.dport = (uint16_t)params->udp_dport_ob_nat;
 
 	memset(&nat_res, 0, sizeof(struct dpa_cls_hm_nat_resources));
 
diff --git a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
index 37800c2..aff60d2 100644
--- a/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
+++ b/drivers/staging/fsl_dpa_offload/usecases/xfrm_km.c
@@ -293,14 +293,15 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 			if (p_state->props.family == AF_INET) {
 				tbl_desc =
 					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-				key.size = 2 * sizeof(u32);
+				key.size = (uint8_t)(2 * sizeof(u32));
 				*(u32 *)&key.byte[0] =
 						p_state->props.saddr.a4;
 				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
 			} else {
 				tbl_desc =
 					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-				key.size = 2 * sizeof(p_state->props.saddr.a6);
+				key.size = (uint8_t)(2 *
+					       sizeof(p_state->props.saddr.a6));
 				memcpy(&key.byte[0], p_state->props.saddr.a6,
 					sizeof(p_state->props.saddr.a6));
 				memcpy(&key.byte[16], p_state->id.daddr.a6,
@@ -369,7 +370,7 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 				if (p_state->props.family == AF_INET) {
 					tbl_desc =
 					outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-					key.size = 2 * sizeof(u32);
+					key.size = (uint8_t)(2 * sizeof(u32));
 					*(u32 *)&key.byte[0] =
 							p_state->props.saddr.a4;
 					*(u32 *)&key.byte[4] =
@@ -377,8 +378,8 @@ static int xfrm_km_state_notify(struct xfrm_state *x, const struct km_event *c)
 				} else {
 					tbl_desc =
 					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-					key.size = 2 *
-						sizeof(p_state->props.saddr.a6);
+					key.size = (uint8_t)(2 *
+					       sizeof(p_state->props.saddr.a6));
 					memcpy(&key.byte[0],
 					       p_state->props.saddr.a6,
 					       sizeof(p_state->props.saddr.a6));
@@ -448,9 +449,11 @@ static int offload_sa(int dpa_ipsec_id,
 		return -EINVAL;
 
 	sa_params->crypto_params.auth_key = x->aalg->alg_key;
-	sa_params->crypto_params.auth_key_len = x->aalg->alg_key_len / 8;
+	sa_params->crypto_params.auth_key_len =
+					(uint8_t)x->aalg->alg_key_len / 8;
 	sa_params->crypto_params.cipher_key = x->ealg->alg_key;
-	sa_params->crypto_params.cipher_key_len = x->ealg->alg_key_len / 8;
+	sa_params->crypto_params.cipher_key_len =
+					(uint8_t)x->ealg->alg_key_len / 8;
 
 	sa_params->spi = x->id.spi;
 	sa_params->sa_bpid = usr_params.sa_bpid;
@@ -468,23 +471,24 @@ static int offload_sa(int dpa_ipsec_id,
 		key.mask = NULL;
 		if (x->props.family == AF_INET) {
 			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-			key.size = 2 * sizeof(u32);
+			key.size = (uint8_t)(2 * sizeof(u32));
 			*(u32 *)&key.byte[0] = x->props.saddr.a4;
 			*(u32 *)&key.byte[4] = x->id.daddr.a4;
 			memset(&outer_iphdr, 0, sizeof(outer_iphdr));
 			outer_iphdr.version = IPVERSION;
-			outer_iphdr.ihl = sizeof(outer_iphdr) / sizeof(u32);
-			outer_iphdr.tot_len = sizeof(outer_iphdr);
+			outer_iphdr.ihl = (uint8_t)(sizeof(outer_iphdr) /
+						    sizeof(u32));
+			outer_iphdr.tot_len = (uint16_t)sizeof(outer_iphdr);
 			outer_iphdr.saddr = x->props.saddr.a4;
 			outer_iphdr.daddr = x->id.daddr.a4;
 			outer_iphdr.protocol = IPPROTO_ESP;
 			sa_params->sa_out_params.outer_ip_header = &outer_iphdr;
 			sa_params->sa_out_params.ip_ver = DPA_IPSEC_ADDR_T_IPv4;
 			sa_params->sa_out_params.ip_hdr_size =
-			    sizeof(outer_iphdr);
+			    (uint16_t)sizeof(outer_iphdr);
 		} else if (x->props.family == AF_INET6) {
 			tbl_desc = outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-			key.size = 2 * sizeof(x->props.saddr.a6);
+			key.size = (uint8_t)(2 * sizeof(x->props.saddr.a6));
 			memcpy(&key.byte[0], x->props.saddr.a6,
 				sizeof(x->props.saddr.a6));
 			memcpy(&key.byte[16], x->id.daddr.a6,
@@ -500,7 +504,7 @@ static int offload_sa(int dpa_ipsec_id,
 			sa_params->sa_out_params.outer_ip_header =
 			    &outer_ip6hdr;
 			sa_params->sa_out_params.ip_hdr_size =
-			    sizeof(outer_ip6hdr);
+			   (uint16_t)sizeof(outer_ip6hdr);
 			sa_params->sa_out_params.ip_ver = DPA_IPSEC_ADDR_T_IPv6;
 		}
 		sa_params->sa_out_params.outer_udp_header = NULL;
@@ -586,7 +590,8 @@ static inline int offload_policy(struct dpa_ipsec_policy_params *pol_params,
 	memset(pol_params, 0, sizeof(*pol_params));
 	if (dir == XFRM_POLICY_OUT) {
 		pol_params->dir_params.type = DPA_IPSEC_POL_DIR_PARAMS_FRAG;
-		pol_params->dir_params.out_frag.mtu = usr_params.mtu_pre_enc;
+		pol_params->dir_params.out_frag.mtu =
+					(uint16_t)usr_params.mtu_pre_enc;
 	}
 	if (sel->family == AF_INET) {
 		pol_params->src_addr.version = DPA_IPSEC_ADDR_T_IPv4;
@@ -878,13 +883,14 @@ void cleanup_xfrm_km(void)
 			if (p_state->props.family == AF_INET) {
 				tbl_desc =
 				outb_post_ipsec_td[OUTB_POST_ENC_IPv4];
-				key.size = 2 * sizeof(u32);
+				key.size = (uint8_t)(2 * sizeof(u32));
 				*(u32 *)&key.byte[0] = p_state->props.saddr.a4;
 				*(u32 *)&key.byte[4] = p_state->id.daddr.a4;
 			} else {
 				tbl_desc =
 					outb_post_ipsec_td[OUTB_POST_ENC_IPv6];
-				key.size = 2 * sizeof(p_state->props.saddr.a6);
+				key.size = (uint8_t)(2 *
+					       sizeof(p_state->props.saddr.a6));
 				memcpy(&key.byte[0], p_state->props.saddr.a6,
 				       sizeof(p_state->props.saddr.a6));
 				memcpy(&key.byte[16], p_state->id.daddr.a6,
-- 
1.7.5.4

