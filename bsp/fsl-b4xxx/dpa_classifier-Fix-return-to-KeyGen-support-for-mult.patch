From 5d3199368fb71f25624668b9453b6d02426dae4f Mon Sep 17 00:00:00 2001
From: Radu Bulie <radu.bulie@freescale.com>
Date: Wed, 20 Mar 2013 22:36:21 +0000
Subject: [PATCH 29/36] dpa_classifier: Fix return-to-KeyGen support for
 multicast component

Direct KeyGen scheme functionality allows dpa_classifier to continue the
classification process while retaining the fqid as the frame final
destination in the case of match instead of enqueing frames.
Next classification ("classification" parameter) is entered through
the distribution pointed by "distribution" parameter.

This patch updates the direct scheme support for multicast component.

Signed-off-by: Radu Bulie <radu.bulie@freescale.com>
[Grabbed from the branch, LINUX_IR5.3.0_ALPHA, of
https://git.freescale.com/git-private/cgit.cgi/ppc/dpaa-offload/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |   83 +++++++++++++++++++-
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |    1 +
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |    7 ++
 include/linux/fsl_dpa_classifier.h                 |    5 +
 4 files changed, 92 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index aacf8dc..3bb7ab5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -7492,11 +7492,49 @@ int dpa_classif_mcast_create_group(
 		replic_grp_params->numOfEntries = pgroup->num_members + 1;
 		next_engine_params = &replic_grp_params->nextEngineParams[0];
 
-		if (group_params->distribution) {
+		if (group_params->distribution &&
+		    group_params->classification) {
+			t_Handle classification, distribution;
+			t_FmPcdKgSchemeParams *scheme_params =
+					  kzalloc(sizeof(t_FmPcdKgSchemeParams),
+							GFP_KERNEL);
+			if (!scheme_params) {
+				pr_err("ERROR: %s, %s (%d): Failed "
+					 "to alocate direct scheme params.\n",
+					__FILE__, __func__, __LINE__);
+				return -ENOMEM;
+			}
+
+			classification = group_params->classification;
+			distribution = group_params->distribution;
+
+			memset(scheme_params, 0, sizeof(*scheme_params));
+			scheme_params->modify = true;
+			scheme_params->alwaysDirect = true;
+			scheme_params->bypassFqidGeneration = true;
+			scheme_params->id.h_Scheme = distribution;
+			scheme_params->nextEngine = e_FM_PCD_CC;
+			scheme_params->kgNextEngineParams.cc.h_CcTree =
+								 classification;
+			scheme_params->kgNextEngineParams.cc.grpId = 0;
+			scheme_params->keyExtractAndHashParams.
+					hashDistributionNumOfFqids = 1;
+
+			distribution = FM_PCD_KgSchemeSet(
+				((t_FmPcdCcTree *)classification)->h_FmPcd,
+				scheme_params);
+			kfree(scheme_params);
+			if (!distribution) {
+				pr_err("ERROR: %s, %s (%d): Failed "
+					"to set direct scheme.\n",
+					__FILE__, __func__, __LINE__);
+				return -EINVAL;
+			}
+
 			/* Redirect frames to KeyGen direct scheme */
 			next_engine_params->nextEngine = e_FM_PCD_KG;
 			next_engine_params->params.kgParams.h_DirectScheme =
-						group_params->distribution;
+								   distribution;
 			next_engine_params->params.kgParams.newFqid =
 						member_params->new_fqid;
 			next_engine_params->params.kgParams.overrideFqid =
@@ -7658,11 +7696,48 @@ int dpa_classif_mcast_add_member(int grpd,
 	replic_grp_params->maxNumOfEntries = max_members;
 	replic_grp_params->numOfEntries = pgroup->num_members;
 	next_engine_params = &replic_grp_params->nextEngineParams[0];
-	if (pgroup->group_params.distribution) {
+	if (pgroup->group_params.distribution &&
+	    pgroup->group_params.classification) {
+		t_Handle classification, distribution;
+		t_FmPcdKgSchemeParams *scheme_params =
+					  kzalloc(sizeof(t_FmPcdKgSchemeParams),
+							GFP_KERNEL);
+		if (!scheme_params) {
+			pr_err("ERROR: %s, %s (%d): Failed "
+				 "to alocate direct scheme params.\n",
+				__FILE__, __func__, __LINE__);
+			return -ENOMEM;
+		}
+
+		classification = pgroup->group_params.classification;
+		distribution = pgroup->group_params.distribution;
+
+		memset(scheme_params, 0, sizeof(*scheme_params));
+		scheme_params->modify = true;
+		scheme_params->alwaysDirect = true;
+		scheme_params->bypassFqidGeneration = true;
+		scheme_params->id.h_Scheme = distribution;
+		scheme_params->nextEngine = e_FM_PCD_CC;
+		scheme_params->kgNextEngineParams.cc.h_CcTree = classification;
+		scheme_params->kgNextEngineParams.cc.grpId = 0;
+		scheme_params->keyExtractAndHashParams.
+				hashDistributionNumOfFqids = 1;
+
+		distribution = FM_PCD_KgSchemeSet(
+			((t_FmPcdCcTree *)classification)->h_FmPcd,
+			scheme_params);
+		kfree(scheme_params);
+		if (!distribution) {
+			pr_err("ERROR: %s, %s (%d): Failed "
+				"to set direct scheme.\n",
+				__FILE__, __func__, __LINE__);
+			return -EINVAL;
+		}
+
 		/* Redirect frames to KeyGen direct scheme */
 		next_engine_params->nextEngine = e_FM_PCD_KG;
 		next_engine_params->params.kgParams.h_DirectScheme =
-					pgroup->group_params.distribution;
+								   distribution;
 		next_engine_params->params.kgParams.newFqid =
 					member_params->new_fqid;
 		next_engine_params->params.kgParams.overrideFqid =
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 85395ea..bf0ebd7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -490,6 +490,7 @@ struct dpa_cls_compat_mcast_group_params {
 	unsigned int prefilled_members;
 	compat_uptr_t group;
 	compat_uptr_t distribution;
+	compat_uptr_t classification;
 };
 
 struct compat_ioc_dpa_cls_mcast_group_params {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 1675aab..7597595 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -3021,6 +3021,13 @@ int dpa_cls_mcast_group_params_compatcpy(
 	else
 		kparam->mcast_grp_params.distribution = NULL;
 
+	if (compat_ptr(uparam->mcast_grp_params.classification))
+		kparam->mcast_grp_params.classification = compat_get_id2ptr(
+					uparam->mcast_grp_params.classification,
+					FM_MAP_TYPE_PCD_NODE);
+	else
+		kparam->mcast_grp_params.classification = NULL;
+
 	return 0;
 }
 
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index af64cd1..3b8717e 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -1519,6 +1519,11 @@ struct dpa_cls_mcast_group_params {
 	 * distribution.
 	 */
 	void		*distribution;
+
+	/*
+	 * Handle to a FMan classification to send frames after distribution
+	 */
+	void		*classification;
 };
 
 /*
-- 
1.7.5.4

