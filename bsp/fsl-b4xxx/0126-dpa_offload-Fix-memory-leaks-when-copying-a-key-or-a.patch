From 0ff730a4b68e047f4cf17c16294264ddb8ff2164 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 16:48:58 +0300
Subject: [PATCH 126/130] dpa_offload: Fix memory leaks when copying a key or
 a pair of keys

Fix the functions responsible of copying a key or a pair of keys
from user-space provided pointers to kernel allocated memory so
that they release the allocated memory in case of error.

Change-Id: I6ade94ea120667832d4ac49e39b24d17177caa24
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5443
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[This is a patch delivered from Freescale against fsl-sdk-v1.4.5,
 rebase on current context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   39 ++++++++++++++++-------
 1 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 1d10d82..cda1b2b 100755
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -671,7 +671,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_node_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_node_params.key);
 			return ret;
 		}
 	}
@@ -686,7 +685,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_tbl_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_tbl_params.key);
 			return ret;
 		}
 	}
@@ -1010,6 +1008,7 @@ create_cls_counter_cleanup:
 				kfree(tbl->keys[i]->mask);
 				kfree(tbl->keys[i]);
 			}
+			kfree(tbl->keys);
 			/* Restore user-space pointers */
 			tbl->keys = us_keys;
 		}
@@ -1024,15 +1023,16 @@ create_cls_counter_cleanup:
 					kfree(tbl->pairs[i]->first_key->mask);
 					kfree(tbl->pairs[i]->first_key);
 				}
-
 				if (tbl->pairs[i]->second_key) {
 					kfree(tbl->pairs[i]->second_key->byte);
 					kfree(tbl->pairs[i]->second_key->mask);
 					kfree(tbl->pairs[i]->second_key);
 				}
+				kfree(tbl->pairs[i]);
 			}
+			kfree(tbl->pairs);
 			/* Restore user-space pointers */
-			tbl->keys = us_keys;
+			tbl->pairs = us_pairs;
 		}
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
@@ -1046,13 +1046,13 @@ create_cls_counter_cleanup:
 			kfree(cnode->keys[i]->mask);
 			kfree(cnode->keys[i]);
 		}
+		kfree(cnode->keys);
 		/* Restore user-space pointers */
 		cnode->keys = us_keys;
 		break;
 	case DPA_STATS_CNT_IPSEC:
 		kfree(sa_ids);
 		break;
-
 	default:
 		break;
 	}
@@ -1171,6 +1171,8 @@ compat_create_cls_counter_cleanup:
 				&kprm_cls->classif_tbl_params;
 
 		if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+			if (!tbl->keys)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->keys[i])
 					continue;
@@ -1181,6 +1183,8 @@ compat_create_cls_counter_cleanup:
 			kfree(tbl->keys);
 
 		} else if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+			if (!tbl->pairs)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->pairs[i])
 					continue;
@@ -1201,6 +1205,8 @@ compat_create_cls_counter_cleanup:
 		break;
 	}
 	case DPA_STATS_CNT_CLASSIF_NODE:
+		if (!kprm_cls->classif_node_params.keys)
+			break;
 		for (i = 0; i < kprm_cls->class_members; i++) {
 			if (!kprm_cls->classif_node_params.keys[i])
 					continue;
@@ -1247,9 +1253,8 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_key_descriptor(us_key, &prm.params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
-
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
 		if (!prm.params.pair)
@@ -1262,7 +1267,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_pair_descriptor(us_pair, &prm.params.pair);
 		if (ret != 0) {
 			log_err("Could not copy the pair key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_SA_ID:
@@ -1273,7 +1278,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 
 	ret = dpa_stats_modify_class_counter(prm.cnt_id,
 					     &prm.params, prm.member_index);
-modify_counter_cleanup:
+
 	switch (prm.params.type) {
 	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
 		if (prm.params.key) {
@@ -1349,7 +1354,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 				uprm.params.key);
 		if (ret < 0) {
 			log_err("Cannot copy the key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
@@ -1367,10 +1372,9 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 		ret = copy_pair_descriptor_compatcpy(&kprm.params.pair, pair);
 		if (ret < 0) {
 			log_err("Cannot copy the pair key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
-
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		kprm.params.sa_id = uprm.params.sa_id;
 		break;
@@ -1911,6 +1915,7 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		if (!tmp->byte) {
 			log_err("Cannot allocate memory for key "
 				"descriptor byte\n");
+			kfree(tmp);
 			return -ENOMEM;
 		}
 
@@ -1975,6 +1980,10 @@ static int copy_pair_descriptor(struct dpa_offload_lookup_key_pair *src,
 		ret = copy_key_descriptor(src->second_key, &tmp->second_key);
 		if (ret != 0) {
 			log_err("Could not copy the second key descriptor\n");
+			if (tmp->first_key) {
+				kfree(tmp->first_key->byte);
+				kfree(tmp->first_key->mask);
+			}
 			kfree(tmp);
 			return ret;
 		}
@@ -2079,6 +2088,10 @@ static int copy_pair_descriptor_compatcpy(
 					&kpair->second_key, pair.second_key);
 		if (ret != 0) {
 			log_err("Cannot copy second key of the pair\n");
+			if (kpair->first_key) {
+				kfree(kpair->first_key->byte);
+				kfree(kpair->first_key->mask);
+			}
 			kfree(kpair);
 			return ret;
 		}
@@ -2409,12 +2422,14 @@ static long dpa_stats_tbl_cls_compatcpy(
 			if (!kprm->pairs[i]) {
 				log_err("Cannot allocate kernel memory for pair"
 					" descriptor\n");
+				kfree(us_keys);
 				return -ENOMEM;
 			}
 
 			if (copy_from_user(&pair, compat_ptr(us_keys[i]),
 					   (sizeof(pair)))) {
 				log_err("Cannot copy pair descriptor\n");
+				kfree(us_keys);
 				return -EBUSY;
 			}
 
-- 
1.7.5.4

