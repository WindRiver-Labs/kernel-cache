From 95d87f2ec956eb586af9199c635a321c644b1e7c Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 6 Aug 2012 15:57:21 +0000
Subject: [PATCH 227/518] dpa_classifier: Update implementation of HASH tables

The support for HASH tables has been recently implemented in the Frame
Manager driver. However, the implementation doesn't have all the features
supported by the DPA Classifier HASH table. Because of that we cannot
just replace the DPA CLassifier HASH table with the FMD HASH table. This
is a solution for IMPORTING the FMD HASH tables into DPA Classifier but
still managing them as DPA Classifier HASH tables.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c |  173 ++++------------------
 drivers/staging/fsl_dpa_offload/dpa_classifier.h |    9 -
 2 files changed, 30 insertions(+), 152 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index bc7e4ae..430d5f7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -219,7 +219,7 @@ int dpa_classif_table_free(int td)
 		kfree(ptable->shadow_table->shadow_entry);
 		kfree(ptable->shadow_table);
 	}
-
+#if 0
 	switch (ptable->params.type) {
 	case DPA_CLS_TBL_EXACT_MATCH:
 		table_cleanup_exact_match(ptable);
@@ -231,7 +231,7 @@ int dpa_classif_table_free(int td)
 		table_cleanup_hash(ptable);
 		break;
 	}
-
+#endif
 	/* Free entry index management */
 	kfree(ptable->entry);
 	ptable->entry		= NULL;
@@ -253,7 +253,6 @@ int dpa_classif_table_modify_miss_action(int			td,
 	int errno;
 	t_Error err;
 	t_FmPcdCcNextEngineParams miss_engine_params;
-	unsigned int i;
 	struct dpa_cls_table *ptable;
 
 	xx_sanity_check_return_value(((td >= 0) &&
@@ -276,23 +275,16 @@ int dpa_classif_table_modify_miss_action(int			td,
 		return errno;
 
 	if (ptable->params.type == DPA_CLS_TBL_HASH) {
-		/*
-		 * Set the next engine params for all the sets of the HASH
-		 * table
-		 */
-for (i = 0; i < ptable->params.hash_params.num_sets; i++) {
-
-	err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
-		int_cc_node[i].cc_node,	&miss_engine_params);
-	if (err != E_OK) {
-		pr_err("ERROR: %s, %s (%d): "
-			"FM_PCD_MatchTableModifyMissNextEngine failed.\n",
-			__FILE__, __func__, __LINE__);
-		pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-			__FILE__, __func__, __LINE__);
-		return -EBUSY;
-	}
-}
+		err = FM_PCD_HashTableModifyMissNextEngine(ptable->params.
+			cc_node, &miss_engine_params);
+		if (err != E_OK) {
+			pr_err("ERROR: %s, %s (%d): "
+				"FM_PCD_HashTableModifyMissNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
+			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
+				__FILE__, __func__, __LINE__);
+			return -EBUSY;
+		}
 	} else {
 		err = FM_PCD_MatchTableModifyMissNextEngine((t_Handle)ptable->
 			int_cc_node[0].cc_node, &miss_engine_params);
@@ -1196,12 +1188,10 @@ static int table_init_indexed(struct dpa_cls_table *cls_table)
 
 static int table_init_hash(struct dpa_cls_table *cls_table)
 {
-	t_FmPcdCcNodeParams *hash_set_params = NULL;
 	unsigned int i;
 	int err = 0;
 	t_FmPcdCcNextEngineParams next_engine_params;
-	t_Error err_code;
-	t_Handle fm_pcd, cc_node;
+	t_Handle cc_node;
 
 	BUG_ON(!cls_table);
 	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
@@ -1210,72 +1200,33 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 	if (err < 0)
 		return err;
 
-	hash_set_params = kzalloc(sizeof(*hash_set_params), GFP_KERNEL);
-	if (!hash_set_params) {
-		pr_err("ERROR: %s, %s (%d): No more memory for DPA Classifier "
-			"hash table.\n", __FILE__, __func__, __LINE__);
-		err = -ENOMEM;
-		goto table_init_hash_error;
-	}
-
-	hash_set_params->extractCcParams.type =
-		e_FM_PCD_EXTRACT_NON_HDR;
-	hash_set_params->extractCcParams.extractNonHdr.src =
-		e_FM_PCD_EXTRACT_FROM_KEY;
-	hash_set_params->extractCcParams.extractNonHdr.action =
-		e_FM_PCD_ACTION_EXACT_MATCH;
-	hash_set_params->extractCcParams.extractNonHdr.offset = 0;
-	hash_set_params->extractCcParams.extractNonHdr.size =
-		cls_table->params.hash_params.key_size;
-
-	hash_set_params->keysParams.numOfKeys = 0;
-	hash_set_params->keysParams.maxNumOfKeys = (uint16_t)
-		cls_table->params.hash_params.max_ways;
-	hash_set_params->keysParams.keySize =
-		cls_table->params.hash_params.key_size;
-	hash_set_params->keysParams.maskSupport = FALSE;
-	hash_set_params->keysParams.ccNextEngineParamsForMiss.nextEngine =
-		e_FM_PCD_DONE;
-	hash_set_params->keysParams.ccNextEngineParamsForMiss.params.
-		enqueueParams.action = e_FM_PCD_DROP_FRAME;
-
-	memset(&next_engine_params, 0, sizeof(next_engine_params));
-	next_engine_params.nextEngine = e_FM_PCD_CC;
-
-	fm_pcd	= (t_Handle)cls_table->params.fm_pcd;
 	cc_node	= (t_Handle)cls_table->params.cc_node;
 	for (i = 0; i < cls_table->params.hash_params.num_sets; i++) {
-		/* Create the HASH set */
-		cls_table->int_cc_node[i].cc_node =
-			(void *)FM_PCD_MatchTableSet(fm_pcd,
-					hash_set_params);
-		if (cls_table->int_cc_node[i].cc_node == NULL) {
+		/*
+		 * Acquire next engine parameters for each index entry in the
+		 * main HASH Cc node.
+		 */
+		if (FM_PCD_MatchTableGetNextEngine(cc_node,
+						i,
+						&next_engine_params) != E_OK) {
 			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableSet failed.\n", __FILE__,
-				__func__, __LINE__);
+				"FM_PCD_MatchTableGetNextEngine failed.\n",
+				__FILE__, __func__, __LINE__);
 			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
 				__FILE__, __func__, __LINE__);
 			err = -EBUSY;
 			goto table_init_hash_error;
 		}
+
+		/*
+		 * Store the HASH set handle into the internal Cc nodes data
+		 * structures.
+		 */
+		BUG_ON(next_engine_params.nextEngine != e_FM_PCD_CC);
+		cls_table->int_cc_node[i].cc_node =
+			next_engine_params.params.ccParams.h_CcNode;
 		cls_table->int_cc_node[i].table_size =
 			cls_table->params.hash_params.max_ways;
-
-		/* Link the HASH set into the initial Cc node */
-		next_engine_params.params.ccParams.h_CcNode =
-			(t_Handle)cls_table->int_cc_node[i].cc_node;
-		err_code = FM_PCD_MatchTableModifyNextEngine(cc_node,
-						(uint8_t)i,
-						&next_engine_params);
-		if (err_code != E_OK) {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
-			err = -EBUSY;
-			goto table_init_hash_error;
-		}
 	}
 
 	/* Allocate the index management array */
@@ -1298,15 +1249,9 @@ static int table_init_hash(struct dpa_cls_table *cls_table)
 		(uint64_t)(cls_table->params.hash_params.num_sets - 1) <<
 		(8 * (6 - cls_table->params.hash_params.hash_offs) + 4) ;
 
-	kfree(hash_set_params);
-
 	return err;
 
 table_init_hash_error:
-	kfree(hash_set_params);
-
-	table_cleanup_hash(cls_table);
-
 	free_table_management(cls_table);
 
 	return err;
@@ -1347,69 +1292,11 @@ static int table_init_exact_match(struct dpa_cls_table *cls_table)
 	return err;
 
 table_init_exact_match_error:
-	table_cleanup_exact_match(cls_table);
-
 	free_table_management(cls_table);
 
 	return err;
 }
 
-static void table_cleanup_hash(struct dpa_cls_table *cls_table)
-{
-	t_FmPcdCcNextEngineParams next_engine_params;
-	unsigned int i;
-	t_Error err;
-	t_Handle cc_node;
-
-	BUG_ON(!cls_table);
-	BUG_ON(cls_table->params.type != DPA_CLS_TBL_HASH);
-
-	cc_node = (t_Handle)cls_table->params.cc_node;
-	for (i = 0; (i < cls_table->int_cc_nodes_count) &&
-			(cls_table->int_cc_node[i].cc_node); i++) {
-		/*
-		 * Remove entry in the initial Cc node which points to the
-		 * current node
-		 */
-		memset(&next_engine_params, 0, sizeof(next_engine_params));
-		next_engine_params.nextEngine = e_FM_PCD_DONE;
-		next_engine_params.params.enqueueParams.action =
-			e_FM_PCD_DROP_FRAME;
-
-		/*
-		 * We can only delete nodes if the miss action of the initial
-		 * node doesn't point to the dynamic Cc node chain
-		 */
-		err = FM_PCD_MatchTableModifyNextEngine(cc_node,
-				(uint8_t)i,
-				&next_engine_params);
-		if (err == E_OK)
-			FM_PCD_MatchTableDelete((t_Handle)cls_table->
-				int_cc_node[i].cc_node);
-		else {
-			pr_err("ERROR: %s, %s (%d): "
-				"FM_PCD_MatchTableModifyNextEngine failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_err("ERROR: %s, %s (%d): FMan driver call failed.\n",
-				__FILE__, __func__, __LINE__);
-			pr_warn("WARNING: DPA Classifier failed to clean up "
-				"hash table.\n");
-		}
-	}
-}
-
-static void table_cleanup_indexed(struct dpa_cls_table *cls_table)
-{
-	/* Nothing to do in this case */
-	return;
-}
-
-static void table_cleanup_exact_match(struct dpa_cls_table *cls_table)
-{
-	/* Nothing special to do */
-	return;
-}
-
 static int verify_table_params(const struct dpa_cls_tbl_params *params)
 {
 	int err = 0;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.h b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
index 219eab3..ab68042 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.h
@@ -229,15 +229,6 @@ static int	table_init_hash(struct dpa_cls_table *cls_table);
 /* Initialize an exact match table. */
 static int	table_init_exact_match(struct dpa_cls_table *cls_table);
 
-/* Clean up an exact match table */
-static void	table_cleanup_exact_match(struct dpa_cls_table *cls_table);
-
-/* Clean up an indexed table */
-static void	table_cleanup_indexed(struct dpa_cls_table *cls_table);
-
-/* Clean up a hash table */
-static void	table_cleanup_hash(struct dpa_cls_table *cls_table);
-
 /*
  * Runs a verification of the table parameters against certain
  * ranges and limitations.
-- 
1.7.5.4

