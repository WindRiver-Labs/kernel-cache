From 19eb6080ae6b2003d48b3b00987319a1212e7d51 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Thu, 17 May 2012 20:35:34 +0000
Subject: [PATCH 149/518] Update internal FQ configuration / initialization
 code

To allow activation of certain advanced offload features, like
automatic Ethernet type fixing, automatic SEC error checking and
automatic UDP header length field update, certain codes (commands
for uCode) must be placed in the contextB of a FQ.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
Acked-by: Andrei Varvara <andrei.varvara@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/Makefile    |    2 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   56 ++++++++++++++++++++-------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    3 +-
 3 files changed, 45 insertions(+), 16 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/Makefile b/drivers/staging/fsl_dpa_offload/Makefile
index 7e5f46f..99d4a48 100644
--- a/drivers/staging/fsl_dpa_offload/Makefile
+++ b/drivers/staging/fsl_dpa_offload/Makefile
@@ -40,6 +40,8 @@ include $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
 EXTRA_CFLAGS += \
 	-Idrivers/crypto/caam \
 	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper \
+	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd \
+	-Idrivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc \
 	-DDPA_OFFLOAD_SANITY_CHECKS
 
 obj-$(CONFIG_FSL_IPACC_USECASES)   += usecases/
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index f387b81..7a5ea42 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -36,6 +36,9 @@
 #include "dpa_ipsec.h"
 #include "dpa_ipsec_desc.h"
 
+#include "fm_common.h"
+#include "fm_pcd.h"
+
 /* DPA IPsec Mapping between API DF bit action and FM PCD DF bit action */
 e_FmPcdManipDontFragAction pcd_df_action[] = PCD_DF_ACTION;
 
@@ -1714,7 +1717,8 @@ static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 
 static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 				  uint16_t wq_id, uint32_t ctx_a_hi,
-				  uint32_t ctx_a_lo, uint32_t ctxB, bool parked,
+				  uint32_t ctx_a_lo, uint32_t ctxB,
+				  uint32_t sp_op, void *fm_pcd, bool parked,
 				  struct qman_fq *fq)
 {
 	struct qm_mcc_initfq fq_opts;
@@ -1741,28 +1745,43 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 	 * input parameters. */
 	flags = (parked == TRUE) ? 0 : QMAN_INITFQ_FLAG_SCHED;
 	memset(&fq_opts, 0, sizeof(fq_opts));
-	fq_opts.we_mask = QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_CONTEXTA;
+	fq_opts.we_mask = QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_CONTEXTA |
+			  QM_INITFQ_WE_CONTEXTB;
 	if (ctx_a_lo) {
-		fq_opts.we_mask |= QM_INITFQ_WE_CONTEXTB;
 		fq_opts.fqd.context_a.hi = ctx_a_hi;
 		fq_opts.fqd.context_a.lo = ctx_a_lo;
 		fq_opts.fqd.context_b = ctxB;
 	} else {
-		uint32_t ctx_a_excl, ctx_a_len;
-		ctx_a_excl = (QM_STASHING_EXCL_DATA | QM_STASHING_EXCL_CTX);
-		ctx_a_len = (1 << 2) | 1;
-		fq_opts.fqd.context_a.hi =
-					(ctx_a_excl << 24) | (ctx_a_len << 16);
+		uint8_t sp_op_code = 0;
+		t_Error error;
 
 		/*
-		 * configure forwarding / flowID info:
+		 * configure uCode commands for handling flowID and other update
+		 * operations:
+		 * - retrieve special operation code (for IPSec and possibly
+		 *   other updates on UDP header fields)
 		 * - enable ctxB;
 		 * - set ctxA override;
-		 * - set in ctxB the FlowID.
+		 * - set in ctxB the FlowID and special operation code
 		 */
-		fq_opts.we_mask |= QM_INITFQ_WE_CONTEXTB;
-		fq_opts.fqd.context_a.hi |= (1 << 31);
-		FM_CONTEXTB_SET_FQID(&(fq_opts.fqd.context_b), ctxB);
+		if (sp_op) {
+			void *fm = NULL;
+
+			/* ugly hack to get FMan handle from the PCD handle*/
+			fm = ((t_FmPcd *)fm_pcd)->h_Fm;
+
+			error = FM_GetSpecialOperationCoding(fm, sp_op,
+							     &sp_op_code);
+			if (error != E_OK) {
+				xx_pr_fmd_err(error,
+					      "FM_GetSpecialOperationCoding");
+				xx_pr_err("Could not retrieve special op code");
+				goto create_sec_fq_err;
+			}
+		}
+		FM_CONTEXTA_SET_OVERRIDE(&fq_opts.fqd.context_a, TRUE);
+		FM_CONTEXTB_SET_FQID(&(fq_opts.fqd.context_b), ctxB |
+				     (sp_op_code << 20));
 	}
 
 	fq_opts.fqd.dest.wq = wq_id;
@@ -1823,6 +1842,12 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 	 */
 	if (!reuse_from_secfq) {
 		uint16_t chan, flow_id;
+		uint32_t sp_op = 0;
+
+		sp_op = FM_SP_OP_IPSEC;
+		if (sa->sa_dir == DPA_IPSEC_OUTBOUND && sa->use_udp_encap)
+			sp_op |= FM_SP_OP_IPSEC_UPDATE_UDP_LEN;
+
 		/* acquire fqid for 'FROM SEC' fq */
 		err = get_new_fqid(dpa_ipsec, &fqid_from_sec);
 		if (err < 0)
@@ -1839,6 +1864,8 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 		err = create_sec_frame_queue(fqid_from_sec,
 					     chan, sa->sa_wqid, 0, 0, /* ctxA */
 					     flow_id, /*ctxB forwarding info*/
+					     sp_op,
+					     sa->dpa_ipsec->config.fm_pcd,
 					     FALSE, sa->from_sec_fq);
 		if (err < 0) {
 			xx_pr_err("From SEC FQ couldn't be created\n");
@@ -1855,7 +1882,7 @@ static int create_sa_fq_pair(struct dpa_ipsec_sa *sa,
 			dpa_ipsec->config.qm_sec_ch,
 			sa->sa_wqid, ctxtA_hi, ctxtA_lo, /* ctxA */
 			qman_fq_fqid(sa->from_sec_fq), /*ctxB - output SEC fq*/
-			parked_to_secfq, sa->to_sec_fq);
+			0, NULL, parked_to_secfq, sa->to_sec_fq);
 	if (err < 0) {
 		xx_pr_err("%s FQ(to SEC) couldn't be created\n",
 				(sa->sa_dir == DPA_IPSEC_OUTBOUND) ? "Encrypt" :
@@ -1975,6 +2002,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		       UDP_HEADER_LEN);
 		sa->sec_desc->pdb_en.ip_hdr_len =
 			sa_params->sa_out_params.ip_hdr_size + UDP_HEADER_LEN;
+		sa->use_udp_encap = TRUE;
 	} else {
 		sa->sec_desc->pdb_en.ip_hdr_len =
 				sa_params->sa_out_params.ip_hdr_size;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 0b6e20c..eb9e1e2 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -230,8 +230,7 @@ struct dpa_ipsec_sa {
 	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
 	uint16_t outbound_flowid; /* Value used to classify frames encrypted
 				 with this SA				      */
-	bool use_udp_encap;   /* NAT-T is activated for this SA.
-				Only for inbound  SAs			      */
+	bool use_udp_encap;   /* NAT-T is activated for this SA.	      */
 	uint16_t udp_src_port;	/* Source UDP port (for UDP encapsulated ESP)
 				   Only for inbound  SAs.		      */
 	uint16_t udp_dest_port;	/* Destination UDP port (for UDP encap ESP)
-- 
1.7.5.4

