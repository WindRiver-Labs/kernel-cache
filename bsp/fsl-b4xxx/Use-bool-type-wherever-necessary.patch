From 53309c83aa2dfface33ede2d73b1ba100e772dd7 Mon Sep 17 00:00:00 2001
From: Mihai Serb <mihai.serb@freescale.com>
Date: Fri, 27 Jul 2012 22:26:16 +0000
Subject: [PATCH 238/518] Use bool type wherever necessary

Using bool variables instead of int increases code readability and
eliminates the need to define macros for TRUE and FALSE values.

Signed-off-by: Mihai Serb <mihai.serb@freescale.com>
[Grabbed from the branch, LINUX_IR5.2.0, of
https://git.freescale.com/git-private/cgit.cgi/ppc/alu-b4860/linux.git.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   24 ++++++++++++------------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |    2 +-
 include/linux/fsl_dpa_ipsec.h               |   14 +++++++-------
 3 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 68e3e0a..dfa2cc3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -481,7 +481,7 @@ static int create_inpol_cls_tbl(struct dpa_ipsec *dpa_ipsec,
 	params.type = DPA_CLS_TBL_EXACT_MATCH;
 	params.exact_match_params.entries_cnt = DPA_IPSEC_MAX_IN_POL_PER_SA;
 	params.exact_match_params.key_size = dpa_ipsec->sa_mng.inpol_key_size;
-	params.exact_match_params.use_priorities = TRUE;
+	params.exact_match_params.use_priorities = true;
 	params.cc_node = cc_node;
 	err = dpa_classif_table_create(&params, td);
 	if (err < 0) {
@@ -589,7 +589,7 @@ static int get_free_inbpol_tbl(struct dpa_ipsec *dpa_ipsec, int *table_desc)
 
 	if (!inpol_tbl->used) {
 		BUG_ON(inpol_tbl->td < 0);
-		inpol_tbl->used = TRUE;
+		inpol_tbl->used = true;
 		*table_desc = inpol_tbl->td;
 	} else {
 		pr_err("No more free EM tables for inbound policy verification\n");
@@ -782,7 +782,7 @@ static int init_sa_manager(struct dpa_ipsec *dpa_ipsec)
 
 	/* If policy check is enabled than for every possible inbound SA create
 	 * an Exact Match Table and link it to the Inbound Index Table */
-	if (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) {
+	if (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) {
 		struct inpol_tbl *pol_table;
 		void *cc_node;
 
@@ -1122,7 +1122,7 @@ static inline void fill_cls_action_enq(struct dpa_cls_tbl_action *action_prm,
 	action_prm->enable_statistics = en_stats;
 	if (new_fqid != 0) {
 		action_prm->enq_params.new_fqid = new_fqid;
-		action_prm->enq_params.override_fqid = TRUE;
+		action_prm->enq_params.override_fqid = true;
 	} else
 		action_prm->enq_params.override_fqid = FALSE;
 	action_prm->enq_params.policer_params = NULL;
@@ -1762,7 +1762,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 
 	/* generate a parked queue or a scheduled one depending on the function
 	 * input parameters. */
-	flags = (parked == TRUE) ? 0 : QMAN_INITFQ_FLAG_SCHED;
+	flags = (parked == true) ? 0 : QMAN_INITFQ_FLAG_SCHED;
 	memset(&fq_opts, 0, sizeof(fq_opts));
 	fq_opts.we_mask = QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_CONTEXTA |
 			  QM_INITFQ_WE_CONTEXTB;
@@ -1797,7 +1797,7 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 				goto create_sec_fq_err;
 			}
 		}
-		FM_CONTEXTA_SET_OVERRIDE(&fq_opts.fqd.context_a, TRUE);
+		FM_CONTEXTA_SET_OVERRIDE(&fq_opts.fqd.context_a, true);
 		FM_CONTEXTB_SET_FQID(&(fq_opts.fqd.context_b), ctxB |
 				     (sp_op_code << 20));
 	}
@@ -2023,7 +2023,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		       UDP_HEADER_LEN);
 		sa->sec_desc->pdb_en.ip_hdr_len =
 			sa_params->sa_out_params.ip_hdr_size + UDP_HEADER_LEN;
-		sa->use_udp_encap = TRUE;
+		sa->use_udp_encap = true;
 
 		/* disable UDP checksum calculation, because for now there is
 		 * no mechanism for UDP checksum update */
@@ -2633,7 +2633,7 @@ static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 
 
 	if ((sa->sa_dir == DPA_IPSEC_INBOUND) &&
-	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) &&
+	    (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) &&
 	    (sa->inbound_indx_entry != -1)) {
 		err_rb = dpa_classif_table_delete_entry_by_ref(
 				dpa_ipsec->config.post_sec_in_params.dpa_cls_td,
@@ -2869,7 +2869,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 			goto create_sa_err;
 		}
 
-		if (dpa_ipsec->config.post_sec_in_params.do_pol_check == TRUE) {
+		if (dpa_ipsec->config.post_sec_in_params.do_pol_check == true) {
 			int inbpol_td;
 			int inbindx_td;
 			struct dpa_cls_tbl_action action;
@@ -3422,7 +3422,7 @@ EXPORT_SYMBOL(dpa_ipsec_sa_remove_policy);
 int dpa_ipsec_sa_rekeying(int sa_id,
 			  struct dpa_ipsec_sa_params *sa_params,
 			  dpa_ipsec_rekey_event_cb rekey_event_cb,
-			  int auto_rmv_old_sa,
+			  bool auto_rmv_old_sa,
 			  int *new_sa_id)
 {
 	struct dpa_ipsec *dpa_ipsec = NULL;
@@ -3510,7 +3510,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	if (old_sa->sa_dir == DPA_IPSEC_OUTBOUND)
 		err = copy_sa_params_to_out_sa(new_sa, sa_params);
 	else
-		err = copy_sa_params_to_in_sa(new_sa, sa_params, TRUE);
+		err = copy_sa_params_to_in_sa(new_sa, sa_params, true);
 
 	if (err < 0) {
 		pr_err("Could not copy SA parameters into SA\n");
@@ -3540,7 +3540,7 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 	new_sa->em_inpol_td = old_sa->em_inpol_td;
 
 	/* Create SEC queues according to SA parameters */
-	err = create_sa_fq_pair(new_sa, TRUE, TRUE);
+	err = create_sa_fq_pair(new_sa, true, true);
 	if (err < 0) {
 		pr_err("Could not create SEC frame queues\n");
 		goto rekey_sa_err;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index b15fa29..9f4a804 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -286,7 +286,7 @@ struct dpa_ipsec_sa {
 	struct list_head sa_rekeying_node; /* For linking in SA rekeying list */
 	int used_sa_index; /* Index in the used_sa_ids vector of the dpa ipsec
 			      instance this SA is part of.		      */
-	int use_var_iphdr_len; /* Enable variable IP header length support    */
+	bool use_var_iphdr_len; /* Enable variable IP header length support   */
 	void *ipsec_manip; /* Manip object for special IPSec functions     */
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 	uint8_t l2_hdr_size; /* Size of the Ethernet header, including any
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 61f054e..592b5c9 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -159,11 +159,11 @@ struct dpa_ipsec_post_sec_in_params {
 	enum dpa_ipsec_data_off data_off;/*Data offset in the decrypted buffer*/
 	uint16_t qm_tx_ch;   /* QMan channel of the post decryption OH port   */
 	int dpa_cls_td;	     /* Index table descriptor			      */
-	int do_pol_check;    /* Enable inbound policy verification	      */
+	bool do_pol_check;   /* Enable inbound policy verification	      */
 	uint8_t key_fields;  /* Flags indicating policy key components.
 			      * (use DPA_IPSEC_KEY_FIELD* macros to configure)
 			      *  Relevant only if do_pol_check = TRUE	      */
-	int use_ipv6_pol;    /* Activate support for IPv6 policies. Allows
+	bool use_ipv6_pol;   /* Activate support for IPv6 policies. Allows
 			      * better MURAM management. Relevant only if
 			      * do_pol_check = TRUE			      */
 	uint16_t base_flow_id; /* The start value of the range of flow ID values
@@ -332,10 +332,10 @@ struct dpa_ipsec_sa_out_params {
 /* DPA-IPSec Security Association In Parameters */
 struct dpa_ipsec_sa_in_params {
 	enum dpa_ipsec_arw arw;	/* Anti replay window			      */
-	int use_var_iphdr_len; /* Enable variable IP header length support    */
+	bool use_var_iphdr_len; /* Enable variable IP header length support   */
 	struct dpa_ipsec_ip_address src_addr;	/* Source IP address	      */
 	struct dpa_ipsec_ip_address dest_addr;	/* Destination IP address     */
-	int use_udp_encap;	/* NAT-T is activated (UDP encapsulated ESP)  */
+	bool use_udp_encap;	/* NAT-T is activated (UDP encapsulated ESP)  */
 	uint16_t src_port;	/* Source UDP port (UDP encapsulated ESP)     */
 	uint16_t dest_port;	/* Destination UDP port (UDP encapsulated ESP)*/
 	struct dpa_cls_tbl_action policy_miss_action; /* Action for frames that
@@ -350,7 +350,7 @@ struct dpa_ipsec_sa_in_params {
 /* DPA-IPSec Security Association Parameters */
 struct dpa_ipsec_sa_params {
 	uint32_t spi;		/* IPSec Security parameter index	      */
-	int use_ext_seq_num;	/* Enable extended sequence number	      */
+	bool use_ext_seq_num;	/* Enable extended sequence number	      */
 	uint64_t start_seq_num;	/* Sequence number to start with	      */
 	uint32_t l2_hdr_size;	/* Size of the Ethernet header, including any
 				 * VLAN information.			      */
@@ -361,7 +361,7 @@ struct dpa_ipsec_sa_params {
 				 * to outer header and vice versa	      */
 	uint8_t sa_wqid;	/* Work queue Id for all the queues in this SA*/
 	uint8_t sa_bpid;	/* Buffer Pool ID to be used with this SA     */
-	int	enable_stats;	/* Enable counting packets and bytes processed*/
+	bool	enable_stats;	/* Enable counting packets and bytes processed*/
 	struct dpa_ipsec_sa_crypto_params crypto_params;/* IPSec crypto params*/
 	enum dpa_ipsec_direction sa_dir;  /* SA direction: Outbound/Inbound   */
 	union {
@@ -408,7 +408,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 int dpa_ipsec_sa_rekeying(int sa_id,
 			  struct dpa_ipsec_sa_params *sa_params,
 			  dpa_ipsec_rekey_event_cb rekey_event_cb,
-			  int auto_rmv_old_sa, int *new_sa_id);
+			  bool auto_rmv_old_sa, int *new_sa_id);
 
 /*
  * Disables a SA before removal (no more packets will be processed
-- 
1.7.5.4

