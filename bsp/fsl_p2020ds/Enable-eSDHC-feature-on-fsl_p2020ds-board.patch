From f1008169cf6ab876db21e1634a16477eb1f081c0 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Wed, 30 Dec 2009 16:12:50 +0800
Subject: [PATCH 6/7] Enable eSDHC feature on fsl_p2020ds board

Extracted from the FSL P2020DS_20091110_ltib.iso vendor drop.

Add sdhc support for P2020DS board.

Fixed AHB2MAG IRQ bypass hardware workaround

This patch implemnet the workaround that the bit DCR[DMA__AHB2MAG_IRQ_BYPASS]
cannot be set automatically when SoC reset.

[ Adjusted to apply cleanly to the WRS kernel. Functionality unchanged. ]

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/boot/dts/p2020ds.dts |    5 ++++-
 drivers/mmc/host/sdhci-of.c       |    4 ++++
 drivers/mmc/host/sdhci.c          |    8 ++++++++
 drivers/mmc/host/sdhci.h          |    3 +++
 4 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/boot/dts/p2020ds.dts b/arch/powerpc/boot/dts/p2020ds.dts
index be6e502..cabcae5 100644
--- a/arch/powerpc/boot/dts/p2020ds.dts
+++ b/arch/powerpc/boot/dts/p2020ds.dts
@@ -463,10 +463,13 @@
                };
 
                sdhci@2e000 {
-                       compatible = "fsl,mpc8536-esdhc";
+		       compatible = "fsl,p2020-esdhc", "fsl,esdhc";
                        reg = <0x2e000 0x1000>;
                        interrupts = <72 0x2>;
                        interrupt-parent = <&mpic>;
+		       fsl,sdhci-dma-broken;
+		       fsl,sdhci-ahb2mag-irq-bypass;
+		       fsl,sdhci-adjust-timeout;
                        /* Filled in by U-Boot */
                        clock-frequency = <0>;
                };
diff --git a/drivers/mmc/host/sdhci-of.c b/drivers/mmc/host/sdhci-of.c
index 34ce70f..119f40d 100644
--- a/drivers/mmc/host/sdhci-of.c
+++ b/drivers/mmc/host/sdhci-of.c
@@ -273,6 +273,9 @@ static int __devinit sdhci_of_probe(struct of_device *ofdev,
 	if (of_get_property(np, "fsl,sdhci-dma-broken", NULL))
 		host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
 
+	if (of_get_property(np, "fsl,sdhci-ahb2mag-irq-bypass", NULL))
+		host->quirks |= SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS;
+
 	if (of_get_property(np, "fsl,sdhci-adjust-timeout", NULL))
 		host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 
@@ -309,6 +312,7 @@ static int __devexit sdhci_of_remove(struct of_device *ofdev)
 static const struct of_device_id sdhci_of_match[] = {
 	{ .compatible = "fsl,mpc8379-esdhc", .data = &sdhci_esdhc, },
 	{ .compatible = "fsl,mpc8536-esdhc", .data = &sdhci_esdhc, },
+	{ .compatible = "fsl,p2020-esdhc", .data = &sdhci_esdhc, },
 	{ .compatible = "fsl,esdhc", .data = &sdhci_esdhc, },
 	{ .compatible = "generic-sdhci", },
 	{},
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 4e2596e..27e58a3 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -176,12 +176,20 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 
 static void sdhci_init(struct sdhci_host *host)
 {
+	u32 ctrl;
+
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
 	/* Enable cache snooping */
 	if (!(host->quirks & SDHCI_QUIRK_BROKEN_DMA))
 		sdhci_writel(host, SDHCI_CACHE_SNOOP, SDHCI_HOST_DMA_CONTROL);
 
+	if (host->quirks & SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS) {
+		ctrl = sdhci_readl(host, SDHCI_HOST_DMA_CONTROL);
+		ctrl |= SDHCI_AHB2MAG_IRQ_BYPASS;
+		sdhci_writel(host, ctrl, SDHCI_HOST_DMA_CONTROL);
+	}
+ 
 	sdhci_clear_set_irqs(host, SDHCI_INT_ALL_MASK,
 		SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index de9b534..05aa5b7 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -178,6 +178,7 @@
 
 /* 40C DMA control register*/
 #define SDHCI_HOST_DMA_CONTROL	0x40C
+#define SDHCI_AHB2MAG_IRQ_BYPASS	0x20
 #define SDHCI_CACHE_SNOOP	0x40
 
 struct sdhci_ops;
@@ -238,6 +239,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK_DELAY_AFTER_POWER			(1<<23)
 /* Controller uses SDCLK instead of TMCLK for data timeouts */
 #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
+/* Controller cannot set DCR[DMA__AHB2MAG_IRQ_BYPASS] automatically*/
+#define SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS		(1<<25)
 
 	int			irq;		/* Device IRQ */
 	void __iomem *		ioaddr;		/* Mapped address */
-- 
1.6.5.2

