From 0fec37162baed96a89bb06160cd820e0506c26f3 Mon Sep 17 00:00:00 2001
From: shuo.kang <shuo.kang@windriver.com>
Date: Fri, 25 Dec 2009 13:16:49 +0800
Subject: [PATCH 4/7] Merge the SPI initialization code into common file

Since both p2020ds and p2020rdb need the same SPI initialization code. A common
 SPI initialization function is extracted.

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/powerpc/platforms/85xx/mpc85xx_ds.c |  116 ------------------------
 arch/powerpc/sysdev/Makefile             |    1 +
 arch/powerpc/sysdev/mpc85xx_spi.c        |  142 ++++++++++++++++++++++++++++++
 3 files changed, 143 insertions(+), 116 deletions(-)
 create mode 100644 arch/powerpc/sysdev/mpc85xx_spi.c

diff --git a/arch/powerpc/platforms/85xx/mpc85xx_ds.c b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
index 6c874eb..27ab534 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
@@ -149,122 +149,6 @@ static int mpc85xx_exclude_device(struct pci_controller *hose,
 }
 #endif	/* CONFIG_PCI */
 
-#if defined(CONFIG_FSL_ESPI) || defined(CONFIG_FSL_ESPI_MODULE)
-static int __init mpc85xx_spi_init(void)
-{
-	struct device_node *np, *dp = NULL;
-	struct mtd_partition *parts;
-	struct flash_platform_data *spi_eeprom_pdata;
-	struct spi_board_info *mpc8536_spi_bdinfo;
-	const u32 *iprop;
-	char *sprop;
-	int i, nr_parts, bd_num = 0, n = -1;
-
-	np = of_find_compatible_node(NULL, NULL, "fsl,mpc8536-espi");
-
-	if (!np)
-		return 0;
-
-	while ((dp = of_get_next_child(np, dp)))
-		bd_num++;
-	of_node_put(np);
-
-	mpc8536_spi_bdinfo =
-		kzalloc(bd_num * sizeof(*mpc8536_spi_bdinfo), GFP_KERNEL);
-	if (mpc8536_spi_bdinfo == NULL){
-		printk(KERN_ERR "failed to allocate spi board info\n");
-		return 0;
-	}
-
-	for_each_compatible_node(np, NULL, "fsl,espi-flash") {
-		n++;
-		iprop = of_get_property(np, "reg", NULL);
-		(mpc8536_spi_bdinfo + n)->chip_select = *iprop;
-		iprop = of_get_property(np, "spi-max-frequency", NULL);
-		(mpc8536_spi_bdinfo + n)->max_speed_hz = *iprop;
-		/* use parent's bus_num as its own bus_num */
-		dp = of_get_parent(np);
-		iprop = of_get_property(dp, "reg", NULL);
-		(mpc8536_spi_bdinfo + n)->bus_num = *iprop;
-		/* Mode (clock phase/polarity/etc.) */
-		if (of_find_property(np, "spi,cpha", NULL))
-			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPHA;
-		if (of_find_property(np, "spi,cpol", NULL))
-			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPOL;
-		/* Select device driver */
-		sprop = (char *)of_get_property(np, "linux,modalias", NULL);
-		if (sprop)
-			strncpy((mpc8536_spi_bdinfo + n)->modalias,
-					sprop, sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
-		else
-			strncpy((mpc8536_spi_bdinfo + n)->modalias,
-					"spidev", sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
-
-		spi_eeprom_pdata =
-			kzalloc(sizeof(*spi_eeprom_pdata), GFP_KERNEL);
-		if (spi_eeprom_pdata == NULL)
-			continue;
-		spi_eeprom_pdata->name = kzalloc(10, GFP_KERNEL);
-		if (spi_eeprom_pdata->name == NULL) {
-			kfree(spi_eeprom_pdata);
-			continue;
-		}
-
-		(mpc8536_spi_bdinfo + n)->platform_data = spi_eeprom_pdata;
-		snprintf(spi_eeprom_pdata->name, 10, "SPIFLASH%d", n);
-
-		nr_parts = 0;
-		dp = NULL;
-		while ((dp = of_get_next_child(np, dp)))
-			nr_parts++;
-		if (nr_parts == 0)
-			continue;
-		parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
-		if (!parts)
-			continue;
-
-		i = 0;
-		while ((dp = of_get_next_child(np, dp))) {
-			const u32 *reg;
-			const char *partname;
-			int len;
-
-			reg = of_get_property(dp, "reg", &len);
-			if (!reg || (len != 2 * sizeof(u32))) {
-				of_node_put(dp);
-				kfree(parts);
-				parts = NULL;
-				break;
-			}
-			(parts + i)->offset = reg[0];
-			(parts + i)->size = reg[1];
-
-			partname = of_get_property(dp, "label", &len);
-			if (!partname)
-				partname = dp->name;
-			(parts + i)->name = (char *)partname;
-
-			if (of_get_property(dp, "read-only", &len))
-				(parts + i)->mask_flags = MTD_WRITEABLE;
-
-			i++;
-		}
-		spi_eeprom_pdata->parts = parts;
-		spi_eeprom_pdata->nr_parts = nr_parts;
-	}
-
-	fsl_spi_init(mpc8536_spi_bdinfo, bd_num, NULL, NULL);
-
-	/*
-	 * Only free "struct spi_board_info", because it will be discarded
-	 * after registered, but other info are still reserved.
-	 */
-	kfree(mpc8536_spi_bdinfo);
-	return 0;
-}
-
-device_initcall(mpc85xx_spi_init);
-#endif /* CONFIG_FSL_ESPI) || CONFIG_FSL_ESPI_MODULE */
 
 /*
  * Setup the architecture
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index 1bd4125..38a46d2 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_AXON_RAM)		+= axonram.o
 ifeq ($(CONFIG_MATH_EMULATION),y)
 obj-$(CONFIG_SPE)              += sigfpe_handler.o
 endif
+obj-$(CONFIG_PPC_85xx)		+= mpc85xx_spi.o
 
 obj-$(CONFIG_PPC_INDIRECT_PCI)	+= indirect_pci.o
 obj-$(CONFIG_PPC_I8259)		+= i8259.o
diff --git a/arch/powerpc/sysdev/mpc85xx_spi.c b/arch/powerpc/sysdev/mpc85xx_spi.c
new file mode 100644
index 0000000..ee94d3c
--- /dev/null
+++ b/arch/powerpc/sysdev/mpc85xx_spi.c
@@ -0,0 +1,142 @@
+/*
+ * MPC85xx SPI initialization.
+ *
+ * Copyright 2009 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include <sysdev/fsl_soc.h>
+
+#if defined(CONFIG_FSL_ESPI) || defined(CONFIG_FSL_ESPI_MODULE)
+static int __init mpc85xx_spi_init(void)
+{
+	struct device_node *np, *dp = NULL;
+	struct mtd_partition *parts;
+	struct flash_platform_data *spi_eeprom_pdata;
+	struct spi_board_info *mpc85xx_spi_bdinfo;
+	const u32 *iprop;
+	char *sprop;
+	int i, nr_parts, bd_num = 0, n = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc8536-espi");
+
+	if (!np)
+		return 0;
+
+	while ((dp = of_get_next_child(np, dp)))
+		bd_num++;
+	of_node_put(np);
+
+	mpc85xx_spi_bdinfo =
+		kzalloc(bd_num * sizeof(*mpc85xx_spi_bdinfo), GFP_KERNEL);
+	if (mpc85xx_spi_bdinfo == NULL){
+		printk(KERN_ERR "failed to allocate spi board info\n");
+		return 0;
+	}
+
+	for_each_compatible_node(np, NULL, "fsl,espi-flash") {
+		n++;
+		iprop = of_get_property(np, "reg", NULL);
+		(mpc85xx_spi_bdinfo + n)->chip_select = *iprop;
+		iprop = of_get_property(np, "spi-max-frequency", NULL);
+		(mpc85xx_spi_bdinfo + n)->max_speed_hz = *iprop;
+		/* use parent's bus_num as its own bus_num */
+		dp = of_get_parent(np);
+		iprop = of_get_property(dp, "reg", NULL);
+		(mpc85xx_spi_bdinfo + n)->bus_num = *iprop;
+		/* Mode (clock phase/polarity/etc.) */
+		if (of_find_property(np, "spi,cpha", NULL))
+			(mpc85xx_spi_bdinfo + n)->mode |= SPI_CPHA;
+		if (of_find_property(np, "spi,cpol", NULL))
+			(mpc85xx_spi_bdinfo + n)->mode |= SPI_CPOL;
+		/* Select device driver */
+		sprop = (char *)of_get_property(np, "linux,modalias", NULL);
+		if (sprop)
+			strncpy((mpc85xx_spi_bdinfo + n)->modalias,
+					sprop, sizeof((mpc85xx_spi_bdinfo + n)->modalias) - 1);
+		else
+			strncpy((mpc85xx_spi_bdinfo + n)->modalias,
+					"spidev", sizeof((mpc85xx_spi_bdinfo + n)->modalias) - 1);
+
+		spi_eeprom_pdata =
+			kzalloc(sizeof(*spi_eeprom_pdata), GFP_KERNEL);
+		if (spi_eeprom_pdata == NULL)
+			continue;
+		spi_eeprom_pdata->name = kzalloc(10, GFP_KERNEL);
+		if (spi_eeprom_pdata->name == NULL) {
+			kfree(spi_eeprom_pdata);
+			continue;
+		}
+
+		(mpc85xx_spi_bdinfo + n)->platform_data = spi_eeprom_pdata;
+		snprintf(spi_eeprom_pdata->name, 10, "SPIFLASH%d", n);
+
+		nr_parts = 0;
+		dp = NULL;
+		while ((dp = of_get_next_child(np, dp)))
+			nr_parts++;
+		if (nr_parts == 0)
+			continue;
+		parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
+		if (!parts)
+			continue;
+
+		i = 0;
+		while ((dp = of_get_next_child(np, dp))) {
+			const u32 *reg;
+			const char *partname;
+			int len;
+
+			reg = of_get_property(dp, "reg", &len);
+			if (!reg || (len != 2 * sizeof(u32))) {
+				of_node_put(dp);
+				kfree(parts);
+				parts = NULL;
+				break;
+			}
+			(parts + i)->offset = reg[0];
+			(parts + i)->size = reg[1];
+
+			partname = of_get_property(dp, "label", &len);
+			if (!partname)
+				partname = dp->name;
+			(parts + i)->name = (char *)partname;
+
+			if (of_get_property(dp, "read-only", &len))
+				(parts + i)->mask_flags = MTD_WRITEABLE;
+
+			i++;
+		}
+		spi_eeprom_pdata->parts = parts;
+		spi_eeprom_pdata->nr_parts = nr_parts;
+	}
+
+	fsl_spi_init(mpc85xx_spi_bdinfo, bd_num, NULL, NULL);
+
+	/*
+	 * Only free "struct spi_board_info", because it will be discarded
+	 * after registered, but other info are still reserved.
+	 */
+	kfree(mpc85xx_spi_bdinfo);
+	return 0;
+}
+
+device_initcall(mpc85xx_spi_init);
+#endif /* CONFIG_FSL_ESPI || CONFIG_FSL_ESPI_MODULE */
+
-- 
1.6.5.2

