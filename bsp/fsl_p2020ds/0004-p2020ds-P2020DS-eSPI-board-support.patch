From 0e545d37e4f61359784ddf2cec783ddee39f13f2 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Mon, 13 Jul 2009 15:08:40 +0800
Subject: [PATCH 04/15] p2020ds: P2020DS eSPI board support

Original patch taken from rev B.1 board support ISO image for MPC8536E.
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8536E

Add P2020DS eSPI interface in device tree and add init function for
the interface based on MPC8536DS eSPI patchset.

Signed-off-by: Chen Gong <g.chen@freescale.com>
[yshi: minor change to fit P2020DS dts file]
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 arch/powerpc/boot/dts/p2020ds.dts        |   28 +++++++-
 arch/powerpc/platforms/85xx/mpc85xx_ds.c |  115 ++++++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_soc.c            |   14 ++++-
 3 files changed, 155 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/boot/dts/p2020ds.dts b/arch/powerpc/boot/dts/p2020ds.dts
index 9cdfd60..375b5a8 100644
--- a/arch/powerpc/boot/dts/p2020ds.dts
+++ b/arch/powerpc/boot/dts/p2020ds.dts
@@ -228,10 +228,36 @@
                };
 
                spi@7000 {
-                       compatible = "fsl,espi";
+                       compatible = "fsl,mpc8536-espi", "fsl,espi";
+                       #address-cells = <1>;
+                       #size-cells = <0>;
                        reg = <0x7000 0x1000>;
                        interrupts = <59 0x2>;
                        interrupt-parent = <&mpic>;
+
+                       mode = "cpu";
+
+                       fsl_m25p80@0 {
+                               #address-cells = <1>;
+                               #size-cells = <1>;
+                               compatible = "fsl,espi-flash";
+                               reg = <0>;
+                               linux,modalias = "fsl_m25p80";
+                               spi-max-frequency = <50000000>; /* input clock freq */
+                               u-boot@0 {
+                                       label = "u-boot";
+                                       reg = <0x00000000 0x00100000>;
+                                       read-only;
+                               };
+                               kernel@100000 {
+                                       label = "kernel";
+                                       reg = <0x00100000 0x00500000>;
+                               };
+                               fs@600000 {
+                                       label = "fs";
+                                       reg = <0x00600000 0x00a00000>;
+                               };
+                       };
                };
 
                dma@c300 {
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_ds.c b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
index 4be1f24..ca7ec94 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
@@ -20,6 +20,10 @@
 #include <linux/seq_file.h>
 #include <linux/interrupt.h>
 #include <linux/of_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
 
 #include <asm/system.h>
 #include <asm/time.h>
@@ -136,6 +140,117 @@ static int mpc85xx_exclude_device(struct pci_controller *hose,
 }
 #endif	/* CONFIG_PCI */
 
+static int __init mpc85xx_spi_init(void)
+{
+	struct device_node *np, *dp = NULL;
+	struct mtd_partition *parts;
+	struct flash_platform_data *spi_eeprom_pdata;
+	struct spi_board_info *mpc8536_spi_bdinfo;
+	const u32 *iprop;
+	char *sprop;
+	int i, nr_parts, bd_num = 0, n = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc8536-espi");
+	while ((dp = of_get_next_child(np, dp)))
+		bd_num++;
+	of_node_put(np);
+
+	mpc8536_spi_bdinfo =
+		kzalloc(bd_num * sizeof(*mpc8536_spi_bdinfo), GFP_KERNEL);
+	if (mpc8536_spi_bdinfo == NULL){
+		printk(KERN_ERR "failed to allocate spi board info\n");
+		return 0;
+	}
+
+	for_each_compatible_node(np, NULL, "fsl,espi-flash") {
+		n++;
+		iprop = of_get_property(np, "reg", NULL);
+		(mpc8536_spi_bdinfo + n)->chip_select = *iprop;
+		iprop = of_get_property(np, "spi-max-frequency", NULL);
+		(mpc8536_spi_bdinfo + n)->max_speed_hz = *iprop;
+		/* use parent's bus_num as its own bus_num */
+		dp = of_get_parent(np);
+		iprop = of_get_property(dp, "reg", NULL);
+		(mpc8536_spi_bdinfo + n)->bus_num = *iprop;
+		/* Mode (clock phase/polarity/etc.) */
+		if (of_find_property(np, "spi,cpha", NULL))
+			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPHA;
+		if (of_find_property(np, "spi,cpol", NULL))
+			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPOL;
+		/* Select device driver */
+		sprop = (char *)of_get_property(np, "linux,modalias", NULL);
+		if (sprop)
+			strncpy((mpc8536_spi_bdinfo + n)->modalias,
+					sprop, sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
+		else
+			strncpy((mpc8536_spi_bdinfo + n)->modalias,
+					"spidev", sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
+
+		spi_eeprom_pdata =
+			kzalloc(sizeof(*spi_eeprom_pdata), GFP_KERNEL);
+		if (spi_eeprom_pdata == NULL)
+			continue;
+		spi_eeprom_pdata->name = kzalloc(10, GFP_KERNEL);
+		if (spi_eeprom_pdata->name == NULL) {
+			kfree(spi_eeprom_pdata);
+			continue;
+		}
+
+		(mpc8536_spi_bdinfo + n)->platform_data = spi_eeprom_pdata;
+		snprintf(spi_eeprom_pdata->name, 10, "SPIFLASH%d", n);
+
+		nr_parts = 0;
+		dp = NULL;
+		while ((dp = of_get_next_child(np, dp)))
+			nr_parts++;
+		if (nr_parts == 0)
+			continue;
+		parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
+		if (!parts)
+			continue;
+
+		i = 0;
+		while ((dp = of_get_next_child(np, dp))) {
+			const u32 *reg;
+			const char *partname;
+			int len;
+
+			reg = of_get_property(dp, "reg", &len);
+			if (!reg || (len != 2 * sizeof(u32))) {
+				of_node_put(dp);
+				kfree(parts);
+				parts = NULL;
+				break;
+			}
+			(parts + i)->offset = reg[0];
+			(parts + i)->size = reg[1];
+
+			partname = of_get_property(dp, "label", &len);
+			if (!partname)
+				partname = dp->name;
+			(parts + i)->name = (char *)partname;
+
+			if (of_get_property(dp, "read-only", &len))
+				(parts + i)->mask_flags = MTD_WRITEABLE;
+
+			i++;
+		}
+		spi_eeprom_pdata->parts = parts;
+		spi_eeprom_pdata->nr_parts = nr_parts;
+	}
+
+	fsl_spi_init(mpc8536_spi_bdinfo, bd_num, NULL, NULL);
+
+	/*
+	 * Only free "struct spi_board_info", because it will be discarded
+	 * after registered, but other info are still reserved.
+	 */
+	kfree(mpc8536_spi_bdinfo);
+	return 0;
+}
+
+device_initcall(mpc85xx_spi_init);
+
 /*
  * Setup the architecture
  */
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index dd1d7ed..40c6811 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -1,6 +1,8 @@
 /*
  * FSL SoC setup code
  *
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
  * Maintained by Kumar Gala (see MAINTAINERS for contact information)
  *
  * 2006 (c) MontaVista Software, Inc.
@@ -627,6 +629,13 @@ static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,
 {
 	struct device_node *np;
 	unsigned int i = 0;
+	char spi_name[32] = "mpc83xx_spi";
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,espi");
+	if (np != NULL) {
+		strcpy(spi_name, "fsl_espi");
+		of_node_put(np);
+	}
 
 	for_each_compatible_node(np, type, compatible) {
 		int ret;
@@ -672,7 +681,7 @@ static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,
 		if (ret == NO_IRQ)
 			goto err;
 
-		pdev = platform_device_alloc("mpc83xx_spi", i);
+		pdev = platform_device_alloc(spi_name, i);
 		if (!pdev)
 			goto err;
 
@@ -724,6 +733,9 @@ int __init fsl_spi_init(struct spi_board_info *board_infos,
 	if (!ret)
 		of_fsl_spi_probe("spi", "fsl_spi", sysclk, board_infos,
 				 num_board_infos, activate_cs, deactivate_cs);
+	if (!ret)
+		of_fsl_spi_probe(NULL, "fsl,espi", sysclk, board_infos,
+				 num_board_infos, activate_cs, deactivate_cs);
 
 	return spi_register_board_info(board_infos, num_board_infos);
 }
-- 
1.6.3.3

