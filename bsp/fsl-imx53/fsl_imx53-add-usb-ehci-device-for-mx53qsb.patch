From bfdd12fea85c5de7c4e1ac2690f735892cc12a5e Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Wed, 9 Jan 2013 17:46:36 +0800
Subject: [PATCH 08/23] fsl_imx53: add usb ehci device for mx53qsb

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add usb host1 device for mx53qsb.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-imx/usb.h    |    8 +++
 arch/arm/mach-imx/usb_h1.c |  147 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 155 insertions(+)
 create mode 100644 arch/arm/mach-imx/usb.h
 create mode 100644 arch/arm/mach-imx/usb_h1.c

diff --git a/arch/arm/mach-imx/usb.h b/arch/arm/mach-imx/usb.h
new file mode 100644
index 0000000..01a748b
--- /dev/null
+++ b/arch/arm/mach-imx/usb.h
@@ -0,0 +1,8 @@
+typedef void (*driver_vbus_func)(bool);
+extern void mx5_set_host1_vbus_func(driver_vbus_func);
+extern void __init mx5_usbh1_init(void);
+extern void __iomem *imx_otg_base;
+
+extern int clk_get_usecount(struct clk *clk);
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
diff --git a/arch/arm/mach-imx/usb_h1.c b/arch/arm/mach-imx/usb_h1.c
new file mode 100644
index 0000000..a1332b7
--- /dev/null
+++ b/arch/arm/mach-imx/usb_h1.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <asm/delay.h>
+#include <asm/mach-types.h>
+#include <mach/arc_otg.h>
+#include "devices-imx53.h"
+#include "usb.h"
+
+static struct clk *usb_phy2_clk;
+static struct clk *usb_oh3_clk;
+static struct clk *usb_ahb_clk;
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		USBCTRL |= UCTRL_H1WIE;
+	else {
+		USBCTRL &= ~UCTRL_H1WIE;
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata,
+				  bool enable)
+{
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		UH1_PORTSC1 |= PORTSC_PHCD;
+	else
+		UH1_PORTSC1 &= ~PORTSC_PHCD;
+}
+
+static void usbh1_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_ahb_clk);
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy2_clk);
+	} else {
+		clk_disable(usb_phy2_clk);
+		clk_disable(usb_oh3_clk);
+		clk_disable(usb_ahb_clk);
+	}
+}
+
+static enum
+usb_wakeup_event _is_usbh1_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USBCTRL & UCTRL_H1WIR;
+
+	if (wakeup_req)
+		return !WAKEUP_EVENT_INVALID;
+
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void h1_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+	pdata->wakeup_event = 1;
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+
+	/* the usb_ahb_clk will be enabled in usb_otg_init */
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_phy2_clk");
+	clk_enable(usb_clk);
+	usb_phy2_clk = usb_clk;
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret)
+		return ret;
+
+	/* disable remote wakeup irq */
+	USBCTRL &= ~UCTRL_H1WIE;
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+	clk_disable(usb_phy2_clk);
+	clk_put(usb_phy2_clk);
+
+	fsl_usb_host_uninit(pdata);
+	/* usb_ahb_clk will be disabled at usb_common.c */
+	clk_put(usb_ahb_clk);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.init = fsl_usb_host_init_ext,
+	.exit = fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbh1_clock_gate,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.is_wakeup_event = _is_usbh1_wakeup,
+	.wakeup_handler = h1_wakeup_handler,
+	.transceiver = "utmi",
+};
+
+void mx5_set_host1_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh1_config.platform_driver_vbus = driver_vbus;
+}
+
+void __init mx5_usbh1_init(void)
+{
+	imx53_add_mxc_ehci(1, &usbh1_config);
+}
-- 
1.7.9.7

