From 89e8eb18d10d18b81513c0e6f85c39dac1974a11 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Tue, 15 Jan 2013 10:12:28 +0800
Subject: [PATCH 15/23] fsl_imx53: add arm_pm_idle hook for mx53 platform

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add arm_pm_idle hook for mx53 platform, and dvfs is depended on it.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-imx/pm-imx5.c |   25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index e26a9cb..5caf31a 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -13,12 +13,14 @@
 #include <linux/io.h>
 #include <linux/err.h>
 #include <asm/cacheflush.h>
+#include <asm/system_misc.h>
 #include <asm/tlbflush.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
 #include "crm-regs-imx5.h"
 
 static struct clk *gpc_dvfs_clk;
+extern void __iomem *arm_plat_base;
 
 /*
  * set cpu low power mode before WFI instruction. This function is called
@@ -31,7 +33,7 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	int stop_mode = 0;
 
 	/* always allow platform to issue a deep sleep mode request */
-	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	plat_lpc = __raw_readl(arm_plat_base + MXC_CORTEXA8_PLAT_LPC_OFFSET) &
 	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
 	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
 	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
@@ -61,6 +63,8 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 			stop_mode = 1;
 		}
 		arm_srpgcr |= MXC_SRPGCR_PCR;
+		if (tzic_enable_wake() != 0)
+			return;
 		break;
 	case STOP_POWER_ON:
 		ccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;
@@ -70,7 +74,7 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		return;
 	}
 
-	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(plat_lpc, arm_plat_base + MXC_CORTEXA8_PLAT_LPC_OFFSET);
 	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
 	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
 
@@ -87,6 +91,21 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	}
 }
 
+static void imx5_idle(void)
+{
+	/* gpc clock is needed for SRPG */
+	if (gpc_dvfs_clk == NULL) {
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
+		if (IS_ERR(gpc_dvfs_clk))
+			return;
+	}
+
+	clk_enable(gpc_dvfs_clk);
+	mx5_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+	cpu_do_idle();
+	clk_disable(gpc_dvfs_clk);
+}
+
 static int mx5_suspend_prepare(void)
 {
 	return clk_prepare_enable(gpc_dvfs_clk);
@@ -148,6 +167,8 @@ static int __init mx5_pm_init(void)
 	} else
 		return -EPERM;
 
+	arm_pm_idle = imx5_idle;
+
 	return 0;
 }
 device_initcall(mx5_pm_init);
-- 
1.7.9.7

