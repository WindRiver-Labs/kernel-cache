From 709b0bdbcb5629f65b7f47a07650136aed131f47 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 10 Jan 2013 14:48:56 +0800
Subject: [PATCH 23/23] mxc/security: add security driver for mxc platforms

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add security(scc and sahara) driver for mxc platform.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/mxc/Kconfig                                |    1 +
 drivers/mxc/Makefile                               |    1 +
 drivers/mxc/security/Kconfig                       |   26 +
 drivers/mxc/security/Makefile                      |    8 +
 drivers/mxc/security/sahara2/Kconfig               |   35 +
 drivers/mxc/security/sahara2/Makefile              |   47 +
 drivers/mxc/security/sahara2/fsl_shw_auth.c        |  706 ++++++
 drivers/mxc/security/sahara2/fsl_shw_hash.c        |  186 ++
 drivers/mxc/security/sahara2/fsl_shw_hmac.c        |  266 +++
 drivers/mxc/security/sahara2/fsl_shw_keystore.c    |  837 +++++++
 drivers/mxc/security/sahara2/fsl_shw_rand.c        |   96 +
 drivers/mxc/security/sahara2/fsl_shw_sym.c         |  281 +++
 drivers/mxc/security/sahara2/fsl_shw_user.c        |  137 ++
 drivers/mxc/security/sahara2/fsl_shw_wrap.c        |  967 ++++++++
 drivers/mxc/security/sahara2/include/adaptor.h     |  113 +
 drivers/mxc/security/sahara2/include/diagnostic.h  |  116 +
 .../mxc/security/sahara2/include/fsl_platform.h    |  161 ++
 drivers/mxc/security/sahara2/include/fsl_shw.h     | 2515 ++++++++++++++++++++
 .../security/sahara2/include/fsl_shw_keystore.h    |  475 ++++
 drivers/mxc/security/sahara2/include/linux_port.h  | 1805 ++++++++++++++
 .../sahara2/include/platform_abstractions.h        |   15 +
 drivers/mxc/security/sahara2/include/portable_os.h | 1453 +++++++++++
 .../security/sahara2/include/sah_driver_common.h   |  102 +
 .../sahara2/include/sah_hardware_interface.h       |   99 +
 .../sahara2/include/sah_interrupt_handler.h        |   42 +
 drivers/mxc/security/sahara2/include/sah_kernel.h  |  113 +
 .../security/sahara2/include/sah_memory_mapper.h   |   79 +
 .../security/sahara2/include/sah_queue_manager.h   |   63 +
 .../security/sahara2/include/sah_status_manager.h  |  228 ++
 .../mxc/security/sahara2/include/sahara2_kernel.h  |   49 +
 drivers/mxc/security/sahara2/include/sf_util.h     |  466 ++++
 drivers/mxc/security/sahara2/km_adaptor.c          |  849 +++++++
 .../mxc/security/sahara2/sah_driver_interface.c    | 2197 +++++++++++++++++
 .../mxc/security/sahara2/sah_hardware_interface.c  |  808 +++++++
 .../mxc/security/sahara2/sah_interrupt_handler.c   |  216 ++
 drivers/mxc/security/sahara2/sah_memory_mapper.c   | 2367 ++++++++++++++++++
 drivers/mxc/security/sahara2/sah_queue.c           |  249 ++
 drivers/mxc/security/sahara2/sah_queue_manager.c   | 1076 +++++++++
 drivers/mxc/security/sahara2/sah_status_manager.c  |  714 ++++++
 drivers/mxc/security/sahara2/sf_util.c             | 1390 +++++++++++
 drivers/mxc/security/scc2_driver.c                 | 2396 +++++++++++++++++++
 drivers/mxc/security/scc2_internals.h              |  521 ++++
 include/linux/mxc_sahara.h                         | 2273 ++++++++++++++++++
 include/linux/mxc_scc2_driver.h                    |  975 ++++++++
 44 files changed, 27519 insertions(+)
 create mode 100644 drivers/mxc/security/Kconfig
 create mode 100644 drivers/mxc/security/Makefile
 create mode 100644 drivers/mxc/security/sahara2/Kconfig
 create mode 100644 drivers/mxc/security/sahara2/Makefile
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_auth.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_hash.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_hmac.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_keystore.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_rand.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_sym.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_user.c
 create mode 100644 drivers/mxc/security/sahara2/fsl_shw_wrap.c
 create mode 100644 drivers/mxc/security/sahara2/include/adaptor.h
 create mode 100644 drivers/mxc/security/sahara2/include/diagnostic.h
 create mode 100644 drivers/mxc/security/sahara2/include/fsl_platform.h
 create mode 100644 drivers/mxc/security/sahara2/include/fsl_shw.h
 create mode 100644 drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
 create mode 100644 drivers/mxc/security/sahara2/include/linux_port.h
 create mode 100644 drivers/mxc/security/sahara2/include/platform_abstractions.h
 create mode 100644 drivers/mxc/security/sahara2/include/portable_os.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_driver_common.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_hardware_interface.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_interrupt_handler.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_kernel.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_memory_mapper.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_queue_manager.h
 create mode 100644 drivers/mxc/security/sahara2/include/sah_status_manager.h
 create mode 100644 drivers/mxc/security/sahara2/include/sahara2_kernel.h
 create mode 100644 drivers/mxc/security/sahara2/include/sf_util.h
 create mode 100644 drivers/mxc/security/sahara2/km_adaptor.c
 create mode 100644 drivers/mxc/security/sahara2/sah_driver_interface.c
 create mode 100644 drivers/mxc/security/sahara2/sah_hardware_interface.c
 create mode 100644 drivers/mxc/security/sahara2/sah_interrupt_handler.c
 create mode 100644 drivers/mxc/security/sahara2/sah_memory_mapper.c
 create mode 100644 drivers/mxc/security/sahara2/sah_queue.c
 create mode 100644 drivers/mxc/security/sahara2/sah_queue_manager.c
 create mode 100644 drivers/mxc/security/sahara2/sah_status_manager.c
 create mode 100644 drivers/mxc/security/sahara2/sf_util.c
 create mode 100644 drivers/mxc/security/scc2_driver.c
 create mode 100644 drivers/mxc/security/scc2_internals.h
 create mode 100644 include/linux/mxc_sahara.h
 create mode 100644 include/linux/mxc_scc2_driver.h

diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index dc28115..d5e1877 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -22,6 +22,7 @@ source "drivers/mxc/gpu-viv/Kconfig"
 source "drivers/mxc/thermal/Kconfig"
 source "drivers/mxc/vpu/Kconfig"
 source "drivers/mxc/pmic/Kconfig"
+source "drivers/mxc/security/Kconfig"
 endmenu
 
 endif
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index 1404f064..bae7ebe 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_MXC_GPU_VIV)			+= gpu-viv/
 obj-$(CONFIG_ANATOP_THERMAL)			+= thermal/
 obj-$(CONFIG_MXC_VPU)				+= vpu/
 obj-$(CONFIG_MXC_PMIC)				+= pmic/
+obj-$(CONFIG_MXC_SECURITY)			+= security/
diff --git a/drivers/mxc/security/Kconfig b/drivers/mxc/security/Kconfig
new file mode 100644
index 0000000..c078449
--- /dev/null
+++ b/drivers/mxc/security/Kconfig
@@ -0,0 +1,26 @@
+menu "MXC Security Drivers"
+
+config MXC_SECURITY
+	tristate "MXC Security Driver"
+	default n
+
+config MXC_SECURITY_SCC2
+        tristate "MXC SCC2 Driver"
+        depends on ARCH_MX37 || ARCH_MX5
+        default n
+        ---help---
+          This module contains the core API's for accessing the SCC2 module.
+          If you are unsure about this, say N here.
+
+config SCC_DEBUG
+        bool "MXC SCC Module debugging"
+        depends on MXC_SECURITY_SCC || MXC_SECURITY_SCC2
+        ---help---
+        This is an option for use by developers; most people should
+        say N here.  This enables SCC module debugging.
+
+if (ARCH_MX37 || ARCH_MX5 || ARCH_MX27)
+source "drivers/mxc/security/sahara2/Kconfig"
+endif
+
+endmenu
diff --git a/drivers/mxc/security/Makefile b/drivers/mxc/security/Makefile
new file mode 100644
index 0000000..74c3818
--- /dev/null
+++ b/drivers/mxc/security/Makefile
@@ -0,0 +1,8 @@
+# Makefile for the Linux MXC Security API
+ifeq ($( SCC_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
+EXTRA_CFLAGS += -DMXC -DLINUX_KERNEL
+
+obj-$(CONFIG_MXC_SECURITY_SCC2) += scc2_driver.o
+obj-$(CONFIG_MXC_SAHARA) += sahara2/
diff --git a/drivers/mxc/security/sahara2/Kconfig b/drivers/mxc/security/sahara2/Kconfig
new file mode 100644
index 0000000..ab4e6fd
--- /dev/null
+++ b/drivers/mxc/security/sahara2/Kconfig
@@ -0,0 +1,35 @@
+menu "SAHARA2 Security Hardware Support"
+
+config MXC_SAHARA
+	tristate "Security Hardware Support (FSL SHW)"
+	---help---
+	  Provides driver and kernel mode API for using cryptographic
+	  accelerators.
+
+config MXC_SAHARA_USER_MODE
+	tristate "User Mode API for FSL SHW"
+	depends on MXC_SAHARA
+	---help---
+	  Provides kernel driver for User Mode API.
+
+config MXC_SAHARA_POLL_MODE
+	bool "Force driver to POLL for hardware completion."
+	depends on MXC_SAHARA
+	default n
+	---help---
+	  When this flag is yes, the driver will not use interrupts to
+	  determine when the hardware has completed a task, but instead
+	  will hold onto the CPU and continually poll the hardware until
+	  it completes.
+
+config MXC_SAHARA_POLL_MODE_TIMEOUT
+    hex "Poll loop timeout"
+    depends on MXC_SAHARA_POLL_MODE
+    default "0xFFFFFFFF"
+    help
+        To avoid infinite polling, a timeout is provided. Should the
+        timeout be reached, a fault is reported, indicating there must
+        be something wrong with SAHARA, and SAHARA is reset. The loop
+        will exit after the given number of iterations.
+
+endmenu
diff --git a/drivers/mxc/security/sahara2/Makefile b/drivers/mxc/security/sahara2/Makefile
new file mode 100644
index 0000000..b515709
--- /dev/null
+++ b/drivers/mxc/security/sahara2/Makefile
@@ -0,0 +1,47 @@
+# Makefile for the Linux Sahara2 driver
+#
+# This makefile works within a kernel driver tree
+
+# Need to augment this to support optionally building user-mode support
+API_SOURCES = fsl_shw_sym.c  fsl_shw_user.c  fsl_shw_hash.c  fsl_shw_auth.c \
+              fsl_shw_hmac.c  fsl_shw_rand.c  sf_util.c  km_adaptor.c  fsl_shw_keystore.c  \
+              fsl_shw_wrap.c \
+
+
+SOURCES = sah_driver_interface.c  sah_hardware_interface.c            \
+          sah_interrupt_handler.c  sah_queue.c  sah_queue_manager.c   \
+          sah_status_manager.c  sah_memory_mapper.c
+
+
+# Turn on for mostly full debugging
+# DIAGS = -DDIAG_DRV_STATUS -DDIAG_DRV_QUEUE -DDIAG_DRV_INTERRUPT -DDIAG_DRV_IF
+# DIAGS += -DDIAG_DURING_INTERRUPT
+
+# Turn on for lint-type checking
+#EXTRA_CFLAGS = -Wall -W -Wstrict-prototypes -Wmissing-prototypes
+EXTRA_CFLAGS += -DLINUX_KERNEL $(DIAGS)
+
+
+ifeq ($(CONFIG_MXC_SAHARA_POLL_MODE),y)
+EXTRA_CFLAGS += -DSAHARA_POLL_MODE
+EXTRA_CFLAGS += -DSAHARA_POLL_MODE_TIMEOUT=$(CONFIG_SAHARA_POLL_MODE_TIMEOUT)
+endif
+
+ifeq ($(CONFIG_MXC_SAHARA_USER_MODE),y)
+EXTRA_CFLAGS += -DSAHARA_USER_MODE
+SOURCES +=
+endif
+
+ifeq ($(CONFIG_PM),y)
+EXTRA_CFLAGS += -DSAHARA_POWER_MANAGMENT
+endif
+
+EXTRA_CFLAGS += -Idrivers/mxc/security/sahara2/include
+
+# handle buggy BSP -- uncomment if these are undefined during build
+#EXTRA_CFLAGS += -DSAHARA_BASE_ADDR=HAC_BASE_ADDR -DINT_SAHARA=INT_HAC_RTIC
+
+
+obj-$(CONFIG_MXC_SAHARA) += sahara.o
+
+sahara-objs := $(SOURCES:.c=.o) $(API_SOURCES:.c=.o)
diff --git a/drivers/mxc/security/sahara2/fsl_shw_auth.c b/drivers/mxc/security/sahara2/fsl_shw_auth.c
new file mode 100644
index 0000000..699fd5d
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_auth.c
@@ -0,0 +1,706 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file fsl_shw_auth.c
+ *
+ * This file contains the routines which do the combined encrypt+authentication
+ * functions.  For now, only AES-CCM is supported.
+ */
+
+#include <linux/mxc_sahara.h>
+#include "adaptor.h"
+#include "sf_util.h"
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_gen_encrypt);
+EXPORT_SYMBOL(fsl_shw_auth_decrypt);
+#endif
+
+
+/*! Size of buffer to repetively sink useless CBC output */
+#define CBC_BUF_LEN 4096
+
+/*!
+ * Compute the size, in bytes, of the encoded auth length
+ *
+ * @param l    The actual associated data length
+ *
+ * @return The encoded length
+ */
+#define COMPUTE_NIST_AUTH_LEN_SIZE(l)                                         \
+({                                                                            \
+    unsigned val;                                                             \
+    uint32_t len = l;                                                         \
+    if (len == 0) {                                                           \
+        val = 0;                                                              \
+    } else if (len < 65280) {                                                 \
+        val = 2;                                                              \
+    } else {                    /* cannot handle >= 2^32 */                   \
+        val = 6;                                                              \
+    }                                                                         \
+    val;                                                                      \
+})
+
+/*!
+ * Store the encoded Auth Length into the Auth Data
+ *
+ * @param l    The actual Auth Length
+ * @param p    Location to store encoding (must be uint8_t*)
+ *
+ * @return void
+ */
+#define STORE_NIST_AUTH_LEN(l, p)                                             \
+{                                                                             \
+    register uint32_t L = l;                                                  \
+    if ((uint32_t)(l) < 65280) {                                              \
+        (p)[1] = L & 0xff;                                                    \
+        L >>= 8;                                                              \
+        (p)[0] = L & 0xff;                                                    \
+    } else {                    /* cannot handle >= 2^32 */                   \
+        int i;                                                                \
+        for (i = 5; i > 1; i--) {                                             \
+            (p)[i] = L & 0xff;                                                \
+            L >>= 8;                                                          \
+        }                                                                     \
+        (p)[1] = 0xfe;  /* Markers */                                         \
+        (p)[0] = 0xff;                                                        \
+    }                                                                         \
+}
+
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)          \
+    || defined (USE_S2_CCM_ENCRYPT_CHAIN)
+/*! Buffer to repetively sink useless CBC output */
+static uint8_t cbc_buffer[CBC_BUF_LEN];
+#endif
+
+/*!
+ * Place to store useless output (while bumping CTR0 to CTR1, for instance.
+ * Must be maximum Symmetric block size
+ */
+static uint8_t garbage_output[16];
+
+/*!
+ * Block of zeroes which is maximum Symmetric block size, used for
+ * initializing context register, etc.
+ */
+static uint8_t block_zeros[16] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*!
+ * Append a descriptor chain which will compute CBC over the
+ * formatted associated data blocks.
+ *
+ * @param[in,out] link1       Where to append the new link
+ * @param[in,out] data_len    Location of current/updated auth-only data length
+ * @param         user_ctx    Info for acquiring memory
+ * @param         auth_ctx    Location of block0 value
+ * @param         auth_data   Unformatted associated data
+ * @param         auth_data_length Length in octets of @a auth_data
+ * @param[in,out] temp_buf    Location of in-process data.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static inline fsl_shw_return_t process_assoc_from_nist_params(sah_Link ** link1,
+							      uint32_t *
+							      data_len,
+							      fsl_shw_uco_t *
+							      user_ctx,
+							      fsl_shw_acco_t *
+							      auth_ctx,
+							      const uint8_t *
+							      auth_data,
+							      uint32_t
+							      auth_data_length,
+							      uint8_t **
+							      temp_buf)
+{
+	fsl_shw_return_t status;
+	uint32_t auth_size_length =
+	    COMPUTE_NIST_AUTH_LEN_SIZE(auth_data_length);
+	uint32_t auth_pad_length =
+	    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes -
+	    (auth_data_length +
+	     auth_size_length) %
+	    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes;
+
+	if (auth_pad_length ==
+	    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes) {
+		auth_pad_length = 0;
+	}
+
+	/* Put in Block0 */
+	status = sah_Create_Link(user_ctx->mem_util, link1,
+				 auth_ctx->auth_info.CCM_ctx_info.context,
+				 auth_ctx->auth_info.CCM_ctx_info.
+				 block_size_bytes, SAH_USES_LINK_DATA);
+
+	if (auth_data_length != 0) {
+		if (status == FSL_RETURN_OK_S) {
+			/* Add on length preamble to auth data */
+			STORE_NIST_AUTH_LEN(auth_data_length, *temp_buf);
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 *temp_buf, auth_size_length,
+						 SAH_OWNS_LINK_DATA);
+			*temp_buf += auth_size_length;	/* 2, 6, or 10 bytes */
+		}
+
+		if (status == FSL_RETURN_OK_S) {
+			/* Add in auth data */
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 (uint8_t *) auth_data,
+						 auth_data_length,
+						 SAH_USES_LINK_DATA);
+		}
+
+		if ((status == FSL_RETURN_OK_S) && (auth_pad_length > 0)) {
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 block_zeros, auth_pad_length,
+						 SAH_USES_LINK_DATA);
+		}
+	}
+	/* ... if auth_data_length != 0 */
+	*data_len = auth_ctx->auth_info.CCM_ctx_info.block_size_bytes +
+	    auth_data_length + auth_size_length + auth_pad_length;
+
+	return status;
+}				/* end fn process_assoc_from_nist_params */
+
+/*!
+ * Add a Descriptor which will process with CBC the NIST preamble data
+ *
+ * @param     desc_chain   Current chain
+ * @param     user_ctx     User's context
+ * @param     auth_ctx     Inf
+ * @pararm    encrypt      0 => decrypt, non-zero => encrypt
+ * @param     auth_data    Additional auth data for this call
+ * @param     auth_data_length   Length in bytes of @a auth_data
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static inline fsl_shw_return_t add_assoc_preamble(sah_Head_Desc ** desc_chain,
+						  fsl_shw_uco_t * user_ctx,
+						  fsl_shw_acco_t * auth_ctx,
+						  int encrypt,
+						  const uint8_t * auth_data,
+						  uint32_t auth_data_length)
+{
+	uint8_t *temp_buf;
+	sah_Link *link1 = NULL;
+	sah_Link *link2 = NULL;
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+	uint32_t cbc_data_length = 0;
+	/* Assume AES */
+	uint32_t header = SAH_HDR_SKHA_ENC_DEC;
+	uint32_t temp_buf_flag;
+	unsigned chain_s2 = 1;
+
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_DECRYPT_CHAIN)
+	if (!encrypt) {
+		chain_s2 = 0;
+	}
+#endif
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_ENCRYPT_CHAIN)
+	if (encrypt) {
+		chain_s2 = 0;
+	}
+#endif
+	/* Grab a block big enough for multiple uses so that only one allocate
+	 * request needs to be made.
+	 */
+	temp_buf =
+	    user_ctx->mem_util->mu_malloc(user_ctx->mem_util->mu_ref,
+					  3 *
+					  auth_ctx->auth_info.CCM_ctx_info.
+					  block_size_bytes);
+
+	if (temp_buf == NULL) {
+		status = FSL_RETURN_NO_RESOURCE_S;
+		goto out;
+	}
+
+	if (auth_ctx->flags & FSL_ACCO_NIST_CCM) {
+		status = process_assoc_from_nist_params(&link1,
+							&cbc_data_length,
+							user_ctx,
+							auth_ctx,
+							auth_data,
+							auth_data_length,
+							&temp_buf);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+		}
+		/* temp_buf has been referenced (and incremented).  Only 'own' it
+		 * once, at its first value.  Since the nist routine called above
+		 * bumps it...
+		 */
+		temp_buf_flag = SAH_USES_LINK_DATA;
+	} else {		/* if NIST */
+		status = sah_Create_Link(user_ctx->mem_util, &link1,
+					 (uint8_t *) auth_data,
+					 auth_data_length, SAH_USES_LINK_DATA);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+		}
+		/* for next/first use of temp_buf */
+		temp_buf_flag = SAH_OWNS_LINK_DATA;
+		cbc_data_length = auth_data_length;
+	}			/* else not NIST */
+
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_ENCRYPT_CHAIN)   \
+    || defined (USE_S2_CCM_DECRYPT_CHAIN)
+
+	if (!chain_s2) {
+		header = SAH_HDR_SKHA_CBC_ICV
+		    ^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
+		    ^ sah_insert_skha_encrypt;
+	} else {
+		/*
+		 * Auth data links have been created.  Now create link for the
+		 * useless output of the CBC calculation.
+		 */
+		status = sah_Create_Link(user_ctx->mem_util, &link2,
+					 temp_buf,
+					 auth_ctx->auth_info.CCM_ctx_info.
+					 block_size_bytes,
+					 temp_buf_flag | SAH_OUTPUT_LINK);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+		}
+
+		temp_buf += auth_ctx->auth_info.CCM_ctx_info.block_size_bytes;
+
+		cbc_data_length -=
+		    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes;
+		if (cbc_data_length != 0) {
+			while ((status == FSL_RETURN_OK_S)
+			       && (cbc_data_length != 0)) {
+				uint32_t linklen =
+				    (cbc_data_length >
+				     CBC_BUF_LEN) ? CBC_BUF_LEN :
+				    cbc_data_length;
+
+				status =
+				    sah_Append_Link(user_ctx->mem_util, link2,
+						    cbc_buffer, linklen,
+						    SAH_USES_LINK_DATA |
+						    SAH_OUTPUT_LINK);
+				if (status != FSL_RETURN_OK_S) {
+					goto out;
+				}
+				cbc_data_length -= linklen;
+			}
+		}
+	}
+#else
+	header = SAH_HDR_SKHA_CBC_ICV
+	    ^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
+	    ^ sah_insert_skha_encrypt;
+#endif
+	/* Crank through auth data */
+	status = sah_Append_Desc(user_ctx->mem_util, desc_chain,
+				 header, link1, link2);
+
+      out:
+	if (status != FSL_RETURN_OK_S) {
+		if (link1 != NULL) {
+			sah_Destroy_Link(user_ctx->mem_util, link1);
+		}
+		if (link2 != NULL) {
+			sah_Destroy_Link(user_ctx->mem_util, link2);
+		}
+	}
+
+	(void)encrypt;
+	return status;
+}				/* add_assoc_preamble() */
+
+#if SUPPORT_SSL
+/*!
+ * Generate an SSL value
+ *
+ * @param         user_ctx         Info for acquiring memory
+ * @param         auth_ctx         Info for CTR0, size of MAC
+ * @param         cipher_key_info
+ * @param         auth_key_info
+ * @param         auth_data_length
+ * @param         auth_data
+ * @param         payload_length
+ * @param         payload
+ * @param         ct
+ * @param         auth_value
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t do_ssl_gen(fsl_shw_uco_t * user_ctx,
+				   fsl_shw_acco_t * auth_ctx,
+				   fsl_shw_sko_t * cipher_key_info,
+				   fsl_shw_sko_t * auth_key_info,
+				   uint32_t auth_data_length,
+				   const uint8_t * auth_data,
+				   uint32_t payload_length,
+				   const uint8_t * payload,
+				   uint8_t * ct, uint8_t * auth_value)
+{
+	SAH_SF_DCLS;
+	uint8_t *ptr1 = NULL;
+
+	/* Assume one-shot init-finalize... no precomputes */
+	header = SAH_HDR_MDHA_SET_MODE_MD_KEY ^
+	    sah_insert_mdha_algorithm[auth_ctx->auth_info.hash_ctx_info.
+				      algorithm] ^ sah_insert_mdha_init ^
+	    sah_insert_mdha_ssl ^ sah_insert_mdha_pdata ^
+	    sah_insert_mdha_mac_full;
+
+	/* set up hmac */
+	DESC_IN_KEY(header, 0, NULL, auth_key_info);
+
+	/* This is wrong -- need to find 16 extra bytes of data from
+	 * somewhere */
+	DESC_IN_OUT(SAH_HDR_MDHA_HASH, payload_length, payload, 1, auth_value);
+
+	/* set up encrypt */
+	header = SAH_HDR_SKHA_SET_MODE_IV_KEY
+	    ^ sah_insert_skha_mode[auth_ctx->cipher_ctx_info.mode]
+	    ^ sah_insert_skha_encrypt
+	    ^ sah_insert_skha_algorithm[cipher_key_info->algorithm];
+
+	/* Honor 'no key parity checking' for DES and TDES */
+	if ((cipher_key_info->flags & FSL_SKO_KEY_IGNORE_PARITY) &&
+	    ((cipher_key_info->algorithm == FSL_KEY_ALG_DES) ||
+	     (cipher_key_info->algorithm == FSL_KEY_ALG_TDES))) {
+		header ^= sah_insert_skha_no_key_parity;
+	}
+
+	if (auth_ctx->cipher_ctx_info.mode == FSL_SYM_MODE_CTR) {
+		header ^=
+		    sah_insert_skha_modulus[auth_ctx->cipher_ctx_info.
+					    modulus_exp];
+	}
+
+	if ((auth_ctx->cipher_ctx_info.mode == FSL_SYM_MODE_ECB)
+	    || (auth_ctx->cipher_ctx_info.flags & FSL_SYM_CTX_INIT)) {
+		ptr1 = block_zeros;
+	} else {
+		ptr1 = auth_ctx->cipher_ctx_info.context;
+	}
+
+	DESC_IN_KEY(header, auth_ctx->cipher_ctx_info.block_size_bytes, ptr1,
+		    cipher_key_info);
+
+	/* This is wrong -- need to find 16 extra bytes of data from
+	 * somewhere...
+	 */
+	if (payload_length != 0) {
+		DESC_IN_OUT(SAH_HDR_SKHA_ENC_DEC,
+			    payload_length, payload, payload_length, ct);
+	}
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	/* Eliminate compiler warnings until full implementation... */
+	(void)auth_data;
+	(void)auth_data_length;
+
+	return ret;
+}				/* do_ssl_gen() */
+#endif
+
+/*!
+ * @brief Generate a (CCM) auth code and encrypt the payload.
+ *
+ * This is a very complicated function.  Seven (or eight) descriptors are
+ * required to perform a CCM calculation.
+ *
+ * First:  Load CTR0 and key.
+ *
+ * Second: Run an octet of data through to bump to CTR1.  (This could be
+ * done in software, but software will have to bump and later decrement -
+ * or copy and bump.
+ *
+ * Third: (in Virtio) Load a descriptor with data of zeros for CBC IV.
+ *
+ * Fourth: Run any (optional) "additional data" through the CBC-mode
+ * portion of the algorithm.
+ *
+ * Fifth: Run the payload through in CCM mode.
+ *
+ * Sixth: Extract the unencrypted MAC.
+ *
+ * Seventh: Load CTR0.
+ *
+ * Eighth: Encrypt the MAC.
+ *
+ * @param user_ctx         The user's context
+ * @param auth_ctx         Info on this Auth operation
+ * @param cipher_key_info  Key to encrypt payload
+ * @param auth_key_info    (unused - same key in CCM)
+ * @param auth_data_length Length in bytes of @a auth_data
+ * @param auth_data        Any auth-only data
+ * @param payload_length   Length in bytes of @a payload
+ * @param payload          The data to encrypt
+ * @param[out] ct          The location to store encrypted data
+ * @param[out] auth_value  The location to store authentication code
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_acco_t * auth_ctx,
+				     fsl_shw_sko_t * cipher_key_info,
+				     fsl_shw_sko_t * auth_key_info,
+				     uint32_t auth_data_length,
+				     const uint8_t * auth_data,
+				     uint32_t payload_length,
+				     const uint8_t * payload,
+				     uint8_t * ct, uint8_t * auth_value)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	if (auth_ctx->mode == FSL_ACC_MODE_SSL) {
+#if SUPPORT_SSL
+		ret = do_ssl_gen(user_ctx, auth_ctx, cipher_key_info,
+				 auth_key_info, auth_data_length, auth_data,
+				 payload_length, payload, ct, auth_value);
+#else
+		ret = FSL_RETURN_BAD_MODE_S;
+#endif
+		goto out;
+	}
+
+	if (auth_ctx->mode != FSL_ACC_MODE_CCM) {
+		ret = FSL_RETURN_BAD_MODE_S;
+		goto out;
+	}
+
+	/* Only support INIT and FINALIZE flags right now. */
+	if ((auth_ctx->flags & (FSL_ACCO_CTX_INIT | FSL_ACCO_CTX_LOAD |
+				FSL_ACCO_CTX_SAVE | FSL_ACCO_CTX_FINALIZE))
+	    != (FSL_ACCO_CTX_INIT | FSL_ACCO_CTX_FINALIZE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* Load CTR0 and Key */
+	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
+		  ^ sah_insert_skha_mode_ctr
+		  ^ sah_insert_skha_modulus_128 ^ sah_insert_skha_encrypt);
+	DESC_IN_KEY(header,
+		    auth_ctx->cipher_ctx_info.block_size_bytes,
+		    auth_ctx->cipher_ctx_info.context, cipher_key_info);
+
+	/* Encrypt dummy data to bump to CTR1 */
+	header = SAH_HDR_SKHA_ENC_DEC;
+	DESC_IN_OUT(header, auth_ctx->mac_length, garbage_output,
+		    auth_ctx->mac_length, garbage_output);
+
+#if defined(FSL_HAVE_SAHARA2) || defined(USE_S2_CCM_ENCRYPT_CHAIN)
+#ifndef NO_ZERO_IV_LOAD
+	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
+		  ^ sah_insert_skha_encrypt ^ sah_insert_skha_mode_cbc);
+	DESC_IN_IN(header,
+		   auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
+		   block_zeros, 0, NULL);
+#endif
+#endif
+
+	ret = add_assoc_preamble(&desc_chain, user_ctx,
+				 auth_ctx, 1, auth_data, auth_data_length);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Process the payload */
+	header = (SAH_HDR_SKHA_SET_MODE_ENC_DEC
+		  ^ sah_insert_skha_mode_ccm
+		  ^ sah_insert_skha_modulus_128 ^ sah_insert_skha_encrypt);
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_ENCRYPT_CHAIN)
+	header ^= sah_insert_skha_aux0;
+#endif
+	if (payload_length != 0) {
+		DESC_IN_OUT(header, payload_length, payload, payload_length,
+			    ct);
+	} else {
+		DESC_IN_OUT(header, 0, NULL, 0, NULL);
+	}			/* if payload_length */
+
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_ENCRYPT_CHAIN)
+	/* Pull out the CBC-MAC value. */
+	DESC_OUT_OUT(SAH_HDR_SKHA_READ_CONTEXT_IV, 0, NULL,
+		     auth_ctx->mac_length, auth_value);
+#else
+	/* Pull out the unencrypted CBC-MAC value. */
+	DESC_OUT_OUT(SAH_HDR_SKHA_READ_CONTEXT_IV,
+		     0, NULL, auth_ctx->mac_length, auth_ctx->unencrypted_mac);
+
+	/* Now load CTR0 in, and encrypt the MAC */
+	header = SAH_HDR_SKHA_SET_MODE_IV_KEY
+	    ^ sah_insert_skha_encrypt
+	    ^ sah_insert_skha_mode_ctr ^ sah_insert_skha_modulus_128;
+	DESC_IN_IN(header,
+		   auth_ctx->cipher_ctx_info.block_size_bytes,
+		   auth_ctx->cipher_ctx_info.context, 0, NULL);
+
+	header = SAH_HDR_SKHA_ENC_DEC;	/* Desc. #4 SKHA Enc/Dec */
+	DESC_IN_OUT(header,
+		    auth_ctx->mac_length, auth_ctx->unencrypted_mac,
+		    auth_ctx->mac_length, auth_value);
+#endif
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	(void)auth_key_info;
+	return ret;
+}				/* fsl_shw_gen_encrypt() */
+
+/*!
+ * @brief Authenticate and decrypt a (CCM) stream.
+ *
+ * @param user_ctx         The user's context
+ * @param auth_ctx         Info on this Auth operation
+ * @param cipher_key_info  Key to encrypt payload
+ * @param auth_key_info    (unused - same key in CCM)
+ * @param auth_data_length Length in bytes of @a auth_data
+ * @param auth_data        Any auth-only data
+ * @param payload_length   Length in bytes of @a payload
+ * @param ct               The encrypted data
+ * @param auth_value       The authentication code to validate
+ * @param[out] payload     The location to store decrypted data
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+				      fsl_shw_acco_t * auth_ctx,
+				      fsl_shw_sko_t * cipher_key_info,
+				      fsl_shw_sko_t * auth_key_info,
+				      uint32_t auth_data_length,
+				      const uint8_t * auth_data,
+				      uint32_t payload_length,
+				      const uint8_t * ct,
+				      const uint8_t * auth_value,
+				      uint8_t * payload)
+{
+	SAH_SF_DCLS;
+#if defined(FSL_HAVE_SAHARA2) || defined(USE_S2_CCM_DECRYPT_CHAIN)
+	uint8_t *calced_auth = NULL;
+	unsigned blocking = user_ctx->flags & FSL_UCO_BLOCKING_MODE;
+#endif
+
+	SAH_SF_USER_CHECK();
+
+	/* Only support CCM */
+	if (auth_ctx->mode != FSL_ACC_MODE_CCM) {
+		ret = FSL_RETURN_BAD_MODE_S;
+		goto out;
+	}
+	/* Only support INIT and FINALIZE flags right now. */
+	if ((auth_ctx->flags & (FSL_ACCO_CTX_INIT | FSL_ACCO_CTX_LOAD |
+				FSL_ACCO_CTX_SAVE | FSL_ACCO_CTX_FINALIZE))
+	    != (FSL_ACCO_CTX_INIT | FSL_ACCO_CTX_FINALIZE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* Load CTR0 and Key */
+	header = SAH_HDR_SKHA_SET_MODE_IV_KEY
+	    ^ sah_insert_skha_mode_ctr ^ sah_insert_skha_modulus_128;
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_DECRYPT_CHAIN)
+	header ^= sah_insert_skha_aux0;
+#endif
+	DESC_IN_KEY(header,
+		    auth_ctx->cipher_ctx_info.block_size_bytes,
+		    auth_ctx->cipher_ctx_info.context, cipher_key_info);
+
+	/* Decrypt the MAC which the user passed in */
+	header = SAH_HDR_SKHA_ENC_DEC;
+	DESC_IN_OUT(header,
+		    auth_ctx->mac_length, auth_value,
+		    auth_ctx->mac_length, auth_ctx->unencrypted_mac);
+
+#if defined(FSL_HAVE_SAHARA2) || defined(USE_S2_CCM_DECRYPT_CHAIN)
+#ifndef NO_ZERO_IV_LOAD
+	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
+		  ^ sah_insert_skha_encrypt ^ sah_insert_skha_mode_cbc);
+	DESC_IN_IN(header,
+		   auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
+		   block_zeros, 0, NULL);
+#endif
+#endif
+
+	ret = add_assoc_preamble(&desc_chain, user_ctx,
+				 auth_ctx, 0, auth_data, auth_data_length);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Process the payload */
+	header = (SAH_HDR_SKHA_SET_MODE_ENC_DEC
+		  ^ sah_insert_skha_mode_ccm ^ sah_insert_skha_modulus_128);
+#if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_DECRYPT_CHAIN)
+	header ^= sah_insert_skha_aux0;
+#endif
+	if (payload_length != 0) {
+		DESC_IN_OUT(header, payload_length, ct, payload_length,
+			    payload);
+	} else {
+		DESC_IN_OUT(header, 0, NULL, 0, NULL);
+	}
+
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
+	/* Now pull CBC context (unencrypted MAC) out for comparison. */
+	/* Need to allocate a place for it, to handle non-blocking mode
+	 * when this stack frame will disappear!
+	 */
+	calced_auth = DESC_TEMP_ALLOC(auth_ctx->mac_length);
+	header = SAH_HDR_SKHA_READ_CONTEXT_IV;
+	DESC_OUT_OUT(header, 0, NULL, auth_ctx->mac_length, calced_auth);
+	if (!blocking) {
+		/* get_results will need this for comparison */
+		desc_chain->out1_ptr = calced_auth;
+		desc_chain->out2_ptr = auth_ctx->unencrypted_mac;
+		desc_chain->out_len = auth_ctx->mac_length;
+	}
+#endif
+
+	SAH_SF_EXECUTE();
+
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
+	if (blocking && (ret == FSL_RETURN_OK_S)) {
+		unsigned i;
+		/* Validate the auth code */
+		for (i = 0; i < auth_ctx->mac_length; i++) {
+			if (calced_auth[i] != auth_ctx->unencrypted_mac[i]) {
+				ret = FSL_RETURN_AUTH_FAILED_S;
+				break;
+			}
+		}
+	}
+#endif
+
+      out:
+	SAH_SF_DESC_CLEAN();
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
+	DESC_TEMP_FREE(calced_auth);
+#endif
+
+	(void)auth_key_info;
+	return ret;
+}				/* fsl_shw_gen_decrypt() */
diff --git a/drivers/mxc/security/sahara2/fsl_shw_hash.c b/drivers/mxc/security/sahara2/fsl_shw_hash.c
new file mode 100644
index 0000000..7353b71
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_hash.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_hash.c
+ *
+ * This file implements Cryptographic Hashing functions of the FSL SHW API
+ * for Sahara.  This does not include HMAC.
+ */
+
+#include <linux/mxc_sahara.h>
+#include "sf_util.h"
+
+#ifdef LINUX_KERNEL
+EXPORT_SYMBOL(fsl_shw_hash);
+#endif
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+/*!
+ * Hash a stream of data with a cryptographic hash algorithm.
+ *
+ * The flags in the @a hash_ctx control the operation of this function.
+ *
+ * Hashing functions work on 64 octets of message at a time.  Therefore, when
+ * any partial hashing of a long message is performed, the message @a length of
+ * each segment must be a multiple of 64.  When ready to
+ * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+ *
+ * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+ * one-shot complete hash, including padding, will be performed.  The @a length
+ * may be any value.
+ *
+ * The first octets of a data stream can be hashed by setting the
+ * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+ * a multiple of 64.
+ *
+ * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+ * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+ * octets) 'middle sequence' of the data stream to be hashed with the
+ * beginning.  The @a length must again be a multiple of 64.
+ *
+ * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+ * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+ * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+ * stream.  The @a length may be any value.
+ *
+ * If the user program wants to do the padding for the hash, it can leave off
+ * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+ * 64 octets.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+ * @param      msg       Pointer to the data to be hashed.
+ * @param      length    Length, in octets, of the @a msg.
+ * @param[out] result    If not null, pointer to where to store the hash
+ *                       digest.
+ * @param      result_len Number of octets to store in @a result.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_hco_t * hash_ctx,
+			      const uint8_t * msg,
+			      uint32_t length,
+			      uint8_t * result, uint32_t result_len)
+{
+	SAH_SF_DCLS;
+	unsigned ctx_flags = (hash_ctx->flags & (FSL_HASH_FLAGS_INIT
+						 | FSL_HASH_FLAGS_LOAD
+						 | FSL_HASH_FLAGS_SAVE
+						 | FSL_HASH_FLAGS_FINALIZE));
+
+	SAH_SF_USER_CHECK();
+
+	/* Reset expectations if user gets overly zealous. */
+	if (result_len > hash_ctx->digest_length) {
+		result_len = hash_ctx->digest_length;
+	}
+
+	/* Validate hash ctx flags.
+	 * Need INIT or LOAD but not both.
+	 * Need SAVE or digest ptr (both is ok).
+	 */
+	if (((ctx_flags & (FSL_HASH_FLAGS_INIT | FSL_HASH_FLAGS_LOAD))
+	     == (FSL_HASH_FLAGS_INIT | FSL_HASH_FLAGS_LOAD))
+	    || ((ctx_flags & (FSL_HASH_FLAGS_INIT | FSL_HASH_FLAGS_LOAD)) == 0)
+	    || (!(ctx_flags & FSL_HASH_FLAGS_SAVE) && (result == NULL))) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	if (ctx_flags & FSL_HASH_FLAGS_INIT) {
+		sah_Oct_Str out_ptr;
+		unsigned out_len;
+
+		/* Create desc to perform the initial hashing operation */
+		/* Desc. #8 w/INIT and algorithm */
+		header = SAH_HDR_MDHA_SET_MODE_HASH
+		    ^ sah_insert_mdha_init
+		    ^ sah_insert_mdha_algorithm[hash_ctx->algorithm];
+
+		/* If user wants one-shot, set padding operation. */
+		if (ctx_flags & FSL_HASH_FLAGS_FINALIZE) {
+			header ^= sah_insert_mdha_pdata;
+		}
+
+		/* Determine where Digest will go - hash_ctx or result */
+		if (ctx_flags & FSL_HASH_FLAGS_SAVE) {
+			out_ptr = (sah_Oct_Str) hash_ctx->context;
+			out_len = hash_ctx->context_register_length;
+		} else {
+			out_ptr = result;
+			out_len = (result_len > hash_ctx->digest_length)
+			    ? hash_ctx->digest_length : result_len;
+		}
+
+		DESC_IN_OUT(header, length, (sah_Oct_Str) msg, out_len,
+			    out_ptr);
+	} else {		/* not doing hash INIT */
+		void *out_ptr;
+		unsigned out_len;
+
+		/*
+		 * Build two descriptors -- one to load in context/set mode, the
+		 * other to compute & retrieve hash/context value.
+		 *
+		 * First up - Desc. #6 to load context.
+		 */
+		/* Desc. #8 w/algorithm */
+		header = SAH_HDR_MDHA_SET_MODE_MD_KEY
+		    ^ sah_insert_mdha_algorithm[hash_ctx->algorithm];
+
+		if (ctx_flags & FSL_HASH_FLAGS_FINALIZE) {
+			header ^= sah_insert_mdha_pdata;
+		}
+
+		/* Message Digest (in) */
+		DESC_IN_IN(header,
+			   hash_ctx->context_register_length,
+			   (sah_Oct_Str) hash_ctx->context, 0, NULL);
+
+		if (ctx_flags & FSL_HASH_FLAGS_SAVE) {
+			out_ptr = hash_ctx->context;
+			out_len = hash_ctx->context_register_length;
+		} else {
+			out_ptr = result;
+			out_len = result_len;
+		}
+
+		/* Second -- run data through and retrieve ctx regs */
+		/* Desc. #10 - no mode register with this. */
+		header = SAH_HDR_MDHA_HASH;
+		DESC_IN_OUT(header, length, (sah_Oct_Str) msg, out_len,
+			    out_ptr);
+	}			/* else not INIT */
+
+	/* Now that execution is rejoined, we can append another descriptor
+	   to extract the digest/context a second time, into the result. */
+	if ((ctx_flags & FSL_HASH_FLAGS_SAVE)
+	    && (result != NULL) && (result_len != 0)) {
+
+		header = SAH_HDR_MDHA_STORE_DIGEST;
+
+		/* Message Digest (out) */
+		DESC_IN_OUT(header, 0, NULL,
+			    (result_len > hash_ctx->digest_length)
+			    ? hash_ctx->digest_length : result_len, result);
+	}
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}				/* fsl_shw_hash() */
diff --git a/drivers/mxc/security/sahara2/fsl_shw_hmac.c b/drivers/mxc/security/sahara2/fsl_shw_hmac.c
new file mode 100644
index 0000000..991a2b6
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_hmac.c
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_hmac.c
+ *
+ * This file implements Hashed Message Authentication Code functions of the FSL
+ * SHW API for Sahara.
+ */
+
+#include <linux/mxc_sahara.h>
+#include "sf_util.h"
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_hmac_precompute);
+EXPORT_SYMBOL(fsl_shw_hmac);
+#endif
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+/*!
+ * Get the precompute information
+ *
+ *
+ * @param   user_ctx
+ * @param   key_info
+ * @param   hmac_ctx
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 fsl_shw_hmco_t * hmac_ctx)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	if ((key_info->algorithm != FSL_KEY_ALG_HMAC) ||
+	    (key_info->key_length > 64)) {
+		return FSL_RETURN_BAD_ALGORITHM_S;
+	} else if (key_info->key_length == 0) {
+		return FSL_RETURN_BAD_KEY_LENGTH_S;
+	}
+
+	/* Set up to start the Inner Calculation */
+	/* Desc. #8 w/IPAD, & INIT */
+	header = SAH_HDR_MDHA_SET_MODE_HASH
+	    ^ sah_insert_mdha_ipad
+	    ^ sah_insert_mdha_init
+	    ^ sah_insert_mdha_algorithm[hmac_ctx->algorithm];
+
+	DESC_KEY_OUT(header, key_info,
+		     hmac_ctx->context_register_length,
+		     (uint8_t *) hmac_ctx->inner_precompute);
+
+	/* Set up for starting Outer calculation */
+	/* exchange IPAD bit for OPAD bit */
+	header ^= (sah_insert_mdha_ipad ^ sah_insert_mdha_opad);
+
+	/* Theoretically, we can leave this link out and use the key which is
+	 * already in the register... however, if we do, the resulting opad
+	 * hash does not have the correct value when using the model. */
+	DESC_KEY_OUT(header, key_info,
+		     hmac_ctx->context_register_length,
+		     (uint8_t *) hmac_ctx->outer_precompute);
+
+	SAH_SF_EXECUTE();
+	if (ret == FSL_RETURN_OK_S) {
+		/* flag that precomputes have been entered in this hco
+		 * assume it'll first be used for initilizing */
+		hmac_ctx->flags |= (FSL_HMAC_FLAGS_INIT |
+				    FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT);
+	}
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+/*!
+ * Get the hmac
+ *
+ *
+ * @param         user_ctx    Info for acquiring memory
+ * @param         key_info
+ * @param         hmac_ctx
+ * @param         msg
+ * @param         length
+ * @param         result
+ * @param         result_len
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_sko_t * key_info,
+			      fsl_shw_hmco_t * hmac_ctx,
+			      const uint8_t * msg,
+			      uint32_t length,
+			      uint8_t * result, uint32_t result_len)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	/* check flag consistency */
+	/* Note that Final, Init, and Save are an illegal combination when a key
+	 * is being used. Because of the logic flow of this routine, that is
+	 * taken care of without being explict */
+	if (
+		   /* nothing to work on */
+		   (((hmac_ctx->flags & FSL_HMAC_FLAGS_INIT) == 0) &&
+		    ((hmac_ctx->flags & FSL_HMAC_FLAGS_LOAD) == 0)) ||
+		   /* can't do both */
+		   ((hmac_ctx->flags & FSL_HMAC_FLAGS_INIT) &&
+		    (hmac_ctx->flags & FSL_HMAC_FLAGS_LOAD)) ||
+		   /* must be some output */
+		   (((hmac_ctx->flags & FSL_HMAC_FLAGS_SAVE) == 0) &&
+		    ((hmac_ctx->flags & FSL_HMAC_FLAGS_FINALIZE) == 0))) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* build descriptor #6 */
+
+	/* start building descriptor header */
+	header = SAH_HDR_MDHA_SET_MODE_MD_KEY ^
+	    sah_insert_mdha_algorithm[hmac_ctx->algorithm] ^
+	    sah_insert_mdha_init;
+
+	/* if this is to finalize the digest, mark to pad last block */
+	if (hmac_ctx->flags & FSL_HMAC_FLAGS_FINALIZE) {
+		header ^= sah_insert_mdha_pdata;
+	}
+
+	/* Check if this is a one shot */
+	if ((hmac_ctx->flags & FSL_HMAC_FLAGS_INIT) &&
+	    (hmac_ctx->flags & FSL_HMAC_FLAGS_FINALIZE)) {
+
+		header ^= sah_insert_mdha_hmac;
+
+		/* See if this uses Precomputes */
+		if (hmac_ctx->flags & FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT) {
+			DESC_IN_IN(header,
+				   hmac_ctx->context_register_length,
+				   (uint8_t *) hmac_ctx->inner_precompute,
+				   hmac_ctx->context_length,
+				   (uint8_t *) hmac_ctx->outer_precompute);
+		} else {	/* Precomputes not requested, try using Key */
+			if (key_info->key != NULL) {
+				/* first, validate the key fields and related flag */
+				if ((key_info->key_length == 0)
+				    || (key_info->key_length > 64)) {
+					ret = FSL_RETURN_BAD_KEY_LENGTH_S;
+					goto out;
+				} else {
+					if (key_info->algorithm !=
+					    FSL_KEY_ALG_HMAC) {
+						ret =
+						    FSL_RETURN_BAD_ALGORITHM_S;
+						goto out;
+					}
+				}
+
+				/* finish building descriptor header (Key specific) */
+				header ^= sah_insert_mdha_mac_full;
+				DESC_IN_KEY(header, 0, NULL, key_info);
+			} else {	/* not using Key or Precomputes, so die */
+				ret = FSL_RETURN_BAD_FLAG_S;
+				goto out;
+			}
+		}
+	} else {		/* it's not a one shot, must be multi-step */
+		/* this the last chunk? */
+		if (hmac_ctx->flags & FSL_HMAC_FLAGS_FINALIZE) {
+			header ^= sah_insert_mdha_hmac;
+			DESC_IN_IN(header,
+				   hmac_ctx->context_register_length,
+				   (uint8_t *) hmac_ctx->ongoing_context,
+				   hmac_ctx->context_length,
+				   (uint8_t *) hmac_ctx->outer_precompute);
+		} else {	/* not last chunk */
+			uint8_t *ptr1;
+
+			if (hmac_ctx->flags & FSL_HMAC_FLAGS_INIT) {
+				/* must be using precomputes, cannot 'chunk' message
+				 * starting with a key */
+				if (hmac_ctx->
+				    flags & FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT)
+				{
+					ptr1 =
+					    (uint8_t *) hmac_ctx->
+					    inner_precompute;
+				} else {
+					ret = FSL_RETURN_NO_RESOURCE_S;
+					goto out;
+				}
+			} else {
+				ptr1 = (uint8_t *) hmac_ctx->ongoing_context;
+			}
+
+			if (ret != FSL_RETURN_OK_S) {
+				goto out;
+			}
+			DESC_IN_IN(header,
+				   hmac_ctx->context_register_length, ptr1,
+				   0, NULL);
+		}
+	}			/* multi-step */
+
+	/* build descriptor #10 & maybe 11 */
+	header = SAH_HDR_MDHA_HASH;
+
+	if (hmac_ctx->flags & FSL_HMAC_FLAGS_FINALIZE) {
+		/* check that the results parameters seem reasonable */
+		if ((result_len != 0) && (result != NULL)) {
+			if (result_len > hmac_ctx->context_register_length) {
+				result_len = hmac_ctx->context_register_length;
+			}
+
+			/* message in / digest out (descriptor #10) */
+			DESC_IN_OUT(header, length, msg, result_len, result);
+
+			/* see if descriptor #11 needs to be built */
+			if (hmac_ctx->flags & FSL_HMAC_FLAGS_SAVE) {
+				header = SAH_HDR_MDHA_STORE_DIGEST;
+				/* nothing in / context out */
+				DESC_IN_IN(header, 0, NULL,
+					   hmac_ctx->context_register_length,
+					   (uint8_t *) hmac_ctx->
+					   ongoing_context);
+			}
+		} else {
+			/* something wrong with result or its length */
+			ret = FSL_RETURN_BAD_DATA_LENGTH_S;
+		}
+	} else {		/* finalize not set, so store in ongoing context field */
+		if ((length % 64) == 0) {	/* this will change for 384/512 support */
+			/* message in / context out */
+			DESC_IN_OUT(header, length, msg,
+				    hmac_ctx->context_register_length,
+				    (uint8_t *) hmac_ctx->ongoing_context);
+		} else {
+			/* not final data, and not multiple of block length */
+			ret = FSL_RETURN_BAD_DATA_LENGTH_S;
+		}
+	}
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}				/* fsl_shw_hmac() */
diff --git a/drivers/mxc/security/sahara2/fsl_shw_keystore.c b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
new file mode 100644
index 0000000..b45cda6
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
@@ -0,0 +1,837 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+ * @file fsl_shw_keystore.c
+ *
+ * File which implements a default keystore policy, for use as the system
+ * keystore.
+ */
+#include "fsl_platform.h"
+#include "fsl_shw.h"
+#include "fsl_shw_keystore.h"
+
+#if defined(DIAG_DRV_IF)
+#include <diagnostic.h>
+#endif
+
+#if !defined(FSL_HAVE_SCC2) && defined(__KERNEL__)
+#include <linux/mxc_scc_driver.h>
+#endif
+
+/* Define a semaphore to protect the keystore data */
+#ifdef __KERNEL__
+#define LOCK_INCLUDES os_lock_context_t context
+#define ACQUIRE_LOCK os_lock_save_context(keystore->lock, context)
+#define RELEASE_LOCK os_unlock_restore_context(keystore->lock, context);
+#else
+#define LOCK_INCLUDES
+#define ACQUIRE_LOCK
+#define RELEASE_LOCK
+#endif	/* __KERNEL__ */
+
+/*!
+ * Calculates the byte offset into a word
+ *  @param   bp  The byte (char*) pointer
+ *  @return      The offset (0, 1, 2, or 3)
+ */
+#define SCC_BYTE_OFFSET(bp) ((uint32_t)(bp) % sizeof(uint32_t))
+
+/*!
+ * Converts (by rounding down) a byte pointer into a word pointer
+ *  @param  bp  The byte (char*) pointer
+ *  @return     The word (uint32_t) as though it were an aligned (uint32_t*)
+ */
+#define SCC_WORD_PTR(bp) (((uint32_t)(bp)) & ~(sizeof(uint32_t)-1))
+
+/* Depending on the architecture, these functions should be defined
+ * differently.  On Platforms with SCC2, the functions use the secure
+ * partition interface and should be available in both user and kernel space.
+ * On platforms with SCC, they use the SCC keystore interface.  This is only
+ * available in kernel mode, so they should be stubbed out in user mode.
+ */
+#if defined(FSL_HAVE_SCC2) || (defined(FSL_HAVE_SCC) && defined(__KERNEL__))
+EXPORT_SYMBOL(fsl_shw_init_keystore);
+void fsl_shw_init_keystore(
+			    fsl_shw_kso_t *keystore,
+			    fsl_shw_return_t(*data_init) (fsl_shw_uco_t *user_ctx,
+							   void **user_data),
+			    void (*data_cleanup) (fsl_shw_uco_t *user_ctx,
+						   void **user_data),
+			    fsl_shw_return_t(*slot_alloc) (void *user_data,
+							    uint32_t size,
+							    uint64_t owner_id,
+							    uint32_t *slot),
+			    fsl_shw_return_t(*slot_dealloc) (void *user_data,
+							      uint64_t
+							      owner_id,
+							      uint32_t slot),
+			    fsl_shw_return_t(*slot_verify_access) (void
+								    *user_data,
+								    uint64_t
+								    owner_id,
+								    uint32_t
+								    slot),
+			    void *(*slot_get_address) (void *user_data,
+							uint32_t handle),
+			    uint32_t(*slot_get_base) (void *user_data,
+						       uint32_t handle),
+			    uint32_t(*slot_get_offset) (void *user_data,
+							 uint32_t handle),
+			    uint32_t(*slot_get_slot_size) (void *user_data,
+							    uint32_t handle))
+{
+	keystore->data_init = data_init;
+	keystore->data_cleanup = data_cleanup;
+	keystore->slot_alloc = slot_alloc;
+	keystore->slot_dealloc = slot_dealloc;
+	keystore->slot_verify_access = slot_verify_access;
+	keystore->slot_get_address = slot_get_address;
+	keystore->slot_get_base = slot_get_base;
+	keystore->slot_get_offset = slot_get_offset;
+	keystore->slot_get_slot_size = slot_get_slot_size;
+}
+
+EXPORT_SYMBOL(fsl_shw_init_keystore_default);
+void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore)
+{
+	keystore->data_init = shw_kso_init_data;
+	keystore->data_cleanup = shw_kso_cleanup_data;
+	keystore->slot_alloc = shw_slot_alloc;
+	keystore->slot_dealloc = shw_slot_dealloc;
+	keystore->slot_verify_access = shw_slot_verify_access;
+	keystore->slot_get_address = shw_slot_get_address;
+	keystore->slot_get_base = shw_slot_get_base;
+	keystore->slot_get_offset = shw_slot_get_offset;
+	keystore->slot_get_slot_size = shw_slot_get_slot_size;
+}
+
+/*!
+ * Do any keystore specific initializations
+ */
+EXPORT_SYMBOL(fsl_shw_establish_keystore);
+fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
+						fsl_shw_kso_t *keystore)
+{
+	if (keystore->data_init == NULL) {
+		return FSL_RETURN_ERROR_S;
+	}
+
+    /* Call the data_init function for any user setup */
+    return keystore->data_init(user_ctx, &(keystore->user_data));
+}
+
+EXPORT_SYMBOL(fsl_shw_release_keystore);
+void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
+				 fsl_shw_kso_t *keystore)
+{
+
+    /* Call the data_cleanup function for any keystore cleanup.
+	  * NOTE: The keystore doesn't have any way of telling which keys are using
+	  * it, so it is up to the user program to manage their key objects
+	  * correctly.
+	  */
+	 if ((keystore != NULL) && (keystore->data_cleanup != NULL)) {
+		keystore->data_cleanup(user_ctx, &(keystore->user_data));
+	}
+	return;
+}
+
+fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore, uint32_t size,
+				       uint64_t owner_id, uint32_t *slot)
+{
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG("In keystore_slot_alloc.");
+
+#endif
+	ACQUIRE_LOCK;
+	if ((keystore->slot_alloc == NULL) || (keystore->user_data == NULL)) {
+		goto out;
+	}
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG_ARGS("key length: %i, handle: %i\n", size, *slot);
+
+#endif
+retval = keystore->slot_alloc(keystore->user_data, size, owner_id, slot);
+out:RELEASE_LOCK;
+	return retval;
+}
+
+fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
+					 uint64_t owner_id, uint32_t slot)
+{
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	ACQUIRE_LOCK;
+	if ((keystore->slot_alloc == NULL) || (keystore->user_data == NULL)) {
+		goto out;
+	}
+	retval =
+	    keystore->slot_dealloc(keystore->user_data, owner_id, slot);
+out:RELEASE_LOCK;
+	return retval;
+}
+
+fsl_shw_return_t
+keystore_slot_load(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t * key_data, uint32_t key_length)
+{
+
+#ifdef FSL_HAVE_SCC2
+	    LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_size;
+	uint32_t i;
+	uint8_t * slot_location;
+	ACQUIRE_LOCK;
+	if ((keystore->slot_verify_access == NULL) ||
+	      (keystore->user_data == NULL))
+		goto out;
+	if (keystore->
+	      slot_verify_access(keystore->user_data, owner_id,
+				 slot) !=FSL_RETURN_OK_S) {
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		goto out;
+	}
+	slot_size = keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (key_length > slot_size) {
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		goto out;
+	}
+	slot_location = keystore->slot_get_address(keystore->user_data, slot);
+	for (i = 0; i < key_length; i++) {
+		slot_location[i] = key_data[i];
+	}
+	retval = FSL_RETURN_OK_S;
+out:RELEASE_LOCK;
+	return retval;
+
+#else	/* FSL_HAVE_SCC2 */
+	fsl_shw_return_t retval;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_load_slot(owner_id, slot, (uint8_t *) key_data, key_length);
+	switch (scc_ret) {
+	case SCC_RET_OK:
+		retval = FSL_RETURN_OK_S;
+		break;
+	case SCC_RET_VERIFICATION_FAILED:
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		break;
+	case SCC_RET_INSUFFICIENT_SPACE:
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		break;
+	default:
+		retval = FSL_RETURN_ERROR_S;
+	}
+	return retval;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data)
+{
+#ifdef FSL_HAVE_SCC2
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint8_t *slot_addr;
+	uint32_t slot_size;
+
+	slot_addr = keystore->slot_get_address(keystore->user_data, slot);
+	slot_size = keystore->slot_get_slot_size(keystore->user_data, slot);
+
+	if (key_length > slot_size) {
+		retval = FSL_RETURN_BAD_KEY_LENGTH_S;
+		goto out;
+	}
+
+	memcpy(key_data, slot_addr, key_length);
+	retval = FSL_RETURN_OK_S;
+
+      out:
+	return retval;
+
+#else				/* Have SCC2 */
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	scc_return_t scc_ret;
+	printk("keystore SCC \n");
+
+	scc_ret =
+	    scc_read_slot(owner_id, slot, key_length, (uint8_t *) key_data);
+	printk("keystore SCC Ret value: %d \n", scc_ret);
+	switch (scc_ret) {
+	case SCC_RET_OK:
+		retval = FSL_RETURN_OK_S;
+		break;
+	case SCC_RET_VERIFICATION_FAILED:
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		break;
+	case SCC_RET_INSUFFICIENT_SPACE:
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		break;
+	default:
+		retval = FSL_RETURN_ERROR_S;
+	}
+
+	return retval;
+
+#endif				/* FSL_HAVE_SCC2 */
+}/* end fn keystore_slot_read */
+
+fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      uint8_t *destination)
+{
+
+#ifdef FSL_HAVE_SCC2
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_length;
+	uint32_t IV[4];
+	uint32_t * iv_ptr = (uint32_t *) & (owner_id);
+
+	/* Build the IV */
+	IV[0] = iv_ptr[0];
+	IV[1] = iv_ptr[1];
+	IV[2] = 0;
+	IV[3] = 0;
+	ACQUIRE_LOCK;
+
+	/* Ensure that the data will fit in the key slot */
+	slot_length =
+	    keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (length > slot_length) {
+		goto out;
+	}
+
+	  /* Call scc encrypt function to encrypt the data. */
+	    retval = do_scc_encrypt_region(user_ctx,
+					   (void *)keystore->
+					   slot_get_base(keystore->user_data,
+							 slot),
+					   keystore->slot_get_offset(keystore->
+								      user_data,
+								      slot),
+					   length, destination, IV,
+					   FSL_SHW_CYPHER_MODE_CBC);
+	goto out;
+out:RELEASE_LOCK;
+	return retval;
+
+#else
+	scc_return_t retval;
+	retval = scc_encrypt_slot(owner_id, slot, length, destination);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+	return FSL_RETURN_ERROR_S;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      const uint8_t *source)
+{
+
+#ifdef FSL_HAVE_SCC2
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_length;
+	uint32_t IV[4];
+	uint32_t *iv_ptr = (uint32_t *) & (owner_id);
+
+    /* Build the IV */
+    IV[0] = iv_ptr[0];
+	IV[1] = iv_ptr[1];
+	IV[2] = 0;
+	IV[3] = 0;
+	ACQUIRE_LOCK;
+
+	/* Call scc decrypt function to decrypt the data. */
+
+	/* Ensure that the data will fit in the key slot */
+	    slot_length =
+	    keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (length > slot_length)
+		goto out;
+
+	/* Call scc decrypt function to encrypt the data. */
+	    retval = do_scc_decrypt_region(user_ctx,
+					   (void *)keystore->
+					   slot_get_base(keystore->user_data,
+							 slot),
+					   keystore->slot_get_offset(keystore->
+								      user_data,
+								      slot),
+					   length, source, IV,
+					   FSL_SHW_CYPHER_MODE_CBC);
+	goto out;
+out:RELEASE_LOCK;
+	return retval;
+
+#else
+	scc_return_t retval;
+	retval = scc_decrypt_slot(owner_id, slot, length, source);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+	return FSL_RETURN_ERROR_S;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+#else	/* SCC in userspace */
+void fsl_shw_init_keystore(
+			    fsl_shw_kso_t *keystore,
+			    fsl_shw_return_t(*data_init) (fsl_shw_uco_t *user_ctx,
+							   void **user_data),
+			    void (*data_cleanup) (fsl_shw_uco_t *user_ctx,
+						   void **user_data),
+			    fsl_shw_return_t(*slot_alloc) (void *user_data,
+							    uint32_t size,
+							    uint64_t owner_id,
+							    uint32_t *slot),
+			    fsl_shw_return_t(*slot_dealloc) (void *user_data,
+							      uint64_t
+							      owner_id,
+							      uint32_t slot),
+			    fsl_shw_return_t(*slot_verify_access) (void
+								    *user_data,
+								    uint64_t
+								    owner_id,
+								    uint32_t
+								    slot),
+			    void *(*slot_get_address) (void *user_data,
+							uint32_t handle),
+			    uint32_t(*slot_get_base) (void *user_data,
+						       uint32_t handle),
+			    uint32_t(*slot_get_offset) (void *user_data,
+							 uint32_t handle),
+			    uint32_t(*slot_get_slot_size) (void *user_data,
+							    uint32_t handle))
+{
+	(void)keystore;
+	(void)data_init;
+	(void)data_cleanup;
+	(void)slot_alloc;
+	(void)slot_dealloc;
+	(void)slot_verify_access;
+	(void)slot_get_address;
+	(void)slot_get_base;
+	(void)slot_get_offset;
+	(void)slot_get_slot_size;
+}
+
+void fsl_shw_init_keystore_default(fsl_shw_kso_t * keystore)
+{
+	(void)keystore;
+}
+fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
+						 fsl_shw_kso_t *keystore)
+{
+	(void)user_ctx;
+	(void)keystore;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
+				fsl_shw_kso_t *keystore)
+{
+	(void)user_ctx;
+	(void)keystore;
+	return;
+}
+
+fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore, uint32_t size,
+					uint64_t owner_id, uint32_t *slot)
+{
+	(void)keystore;
+	(void)size;
+	(void)owner_id;
+	(void)slot;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
+					 uint64_t owner_id, uint32_t slot)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_load(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t *key_data, uint32_t key_length)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)key_data;
+	(void)key_length;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)key_length;
+	(void)key_data;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      const uint8_t *source)
+{
+	(void)user_ctx;
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)length;
+	(void)source;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      uint8_t *destination)
+{
+	(void)user_ctx;
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)length;
+	(void)destination;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+
+#endif	/* FSL_HAVE_SCC2 */
+
+/***** Default keystore implementation **************************************/
+
+#ifdef FSL_HAVE_SCC2
+    fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t *user_ctx,
+					void **user_data)
+{
+	int retval = FSL_RETURN_ERROR_S;
+	keystore_data_t *keystore_data = NULL;
+	fsl_shw_pco_t *capabilities = fsl_shw_get_capabilities(user_ctx);
+	uint32_t partition_size;
+	uint32_t slot_count;
+	uint32_t keystore_data_size;
+	uint8_t UMID[16] = {
+	0x42, 0, 0, 0, 0x43, 0, 0, 0, 0x19, 0, 0, 0, 0x59, 0, 0, 0};
+	uint32_t permissions =
+	    FSL_PERM_TH_R | FSL_PERM_TH_W | FSL_PERM_HD_R | FSL_PERM_HD_W |
+	    FSL_PERM_HD_X;
+
+	/* Look up the size of a partition to see how big to make the keystore */
+	partition_size = fsl_shw_pco_get_spo_size_bytes(capabilities);
+
+	/* Calculate the required size of the keystore data structure, based on the
+	  * number of keys that can fit in the partition.
+	  */
+	slot_count = partition_size / KEYSTORE_SLOT_SIZE;
+	keystore_data_size =
+	    sizeof(keystore_data_t) +
+	    slot_count * sizeof(keystore_data_slot_info_t);
+
+#ifdef __KERNEL__
+	keystore_data = os_alloc_memory(keystore_data_size, GFP_KERNEL);
+
+#else
+	keystore_data = malloc(keystore_data_size);
+
+#endif
+	if (keystore_data == NULL) {
+		retval = FSL_RETURN_NO_RESOURCE_S;
+		goto out;
+	}
+
+    /* Clear the memory (effectively clear all key assignments) */
+    memset(keystore_data, 0, keystore_data_size);
+
+   /* Place the slot information structure directly after the keystore data
+	* structure.
+	*/
+	    keystore_data->slot =
+	    (keystore_data_slot_info_t *) (keystore_data + 1);
+	keystore_data->slot_count = slot_count;
+
+	/* Retrieve a secure partition to put the keystore in. */
+	keystore_data->base_address =
+	    fsl_shw_smalloc(user_ctx, partition_size, UMID, permissions);
+	if (keystore_data->base_address == NULL) {
+		retval = FSL_RETURN_NO_RESOURCE_S;
+		goto out;
+	}
+	*user_data = keystore_data;
+	retval = FSL_RETURN_OK_S;
+out:if (retval != FSL_RETURN_OK_S) {
+		if (keystore_data != NULL) {
+			if (keystore_data->base_address != NULL)
+				fsl_shw_sfree(NULL,
+					       keystore_data->base_address);
+
+#ifdef __KERNEL__
+			    os_free_memory(keystore_data);
+
+#else
+			    free(keystore_data);
+
+#endif
+		}
+	}
+	return retval;
+}
+void shw_kso_cleanup_data(fsl_shw_uco_t *user_ctx, void **user_data)
+{
+	if (user_data != NULL) {
+		keystore_data_t * keystore_data =
+		    (keystore_data_t *) (*user_data);
+		fsl_shw_sfree(user_ctx, keystore_data->base_address);
+
+#ifdef __KERNEL__
+		    os_free_memory(*user_data);
+
+#else
+		    free(*user_data);
+
+#endif
+	}
+	return;
+}
+
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+					  uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	if (data->slot[slot].owner == owner_id) {
+		return FSL_RETURN_OK_S;
+	} else {
+
+#ifdef DIAG_DRV_IF
+		    LOG_DIAG_ARGS("Access to slot %i fails.\n", slot);
+
+#endif
+		    return FSL_RETURN_AUTH_FAILED_S;
+	}
+}
+
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				   uint64_t owner_id, uint32_t *slot)
+{
+	keystore_data_t *data = user_data;
+	uint32_t i;
+	if (size > KEYSTORE_SLOT_SIZE)
+		return FSL_RETURN_BAD_KEY_LENGTH_S;
+	for (i = 0; i < data->slot_count; i++) {
+		if (data->slot[i].allocated == 0) {
+			data->slot[i].allocated = 1;
+			data->slot[i].owner = owner_id;
+			(*slot) = i;
+
+#ifdef DIAG_DRV_IF
+			    LOG_DIAG_ARGS("Keystore: allocated slot %i. Slot "
+					  "address: %p\n",
+					  (*slot),
+					  data->base_address +
+					  (*slot) * KEYSTORE_SLOT_SIZE);
+
+#endif
+			    return FSL_RETURN_OK_S;
+		}
+	}
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t shw_slot_dealloc(void *user_data, uint64_t owner_id,
+				    uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	(void)owner_id;
+	(void)slot;
+	if (slot >= data->slot_count)
+		return FSL_RETURN_ERROR_S;
+	if (data->slot[slot].allocated == 1) {
+		/* Forcibly remove the data from the keystore */
+		memset(shw_slot_get_address(user_data, slot), 0,
+		       KEYSTORE_SLOT_SIZE);
+		data->slot[slot].allocated = 0;
+		return FSL_RETURN_OK_S;
+	}
+	return FSL_RETURN_ERROR_S;
+}
+
+void *shw_slot_get_address(void *user_data, uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	if (slot >= data->slot_count)
+		return NULL;
+	return data->base_address + slot * KEYSTORE_SLOT_SIZE;
+}
+
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+
+	/* There could potentially be more than one secure partition object
+	  * associated with this keystore.  For now, there is just one.
+	  */
+	(void)slot;
+	return (uint32_t) (data->base_address);
+}
+
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot)
+{
+	keystore_data_t *data = user_data;
+	if (slot >= data->slot_count)
+		return FSL_RETURN_ERROR_S;
+	return (slot * KEYSTORE_SLOT_SIZE);
+}
+
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot)
+{
+	(void)user_data;
+	(void)slot;
+
+	/* All slots are the same size in the default implementation */
+	return KEYSTORE_SLOT_SIZE;
+}
+
+#else	/* FSL_HAVE_SCC2 */
+
+#ifdef __KERNEL__
+    fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t *user_ctx,
+					void **user_data)
+{
+
+   /* The SCC does its own initialization.  All that needs to be done here is
+	* make sure an SCC exists.
+	*/
+	*user_data = (void *)0xFEEDFEED;
+	return FSL_RETURN_OK_S;
+}
+void shw_kso_cleanup_data(fsl_shw_uco_t *user_ctx, void **user_data)
+{
+
+    /* The SCC does its own cleanup. */
+	*user_data = NULL;
+	return;
+}
+
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+					  uint32_t slot)
+{
+
+	/* Zero is used for the size because the newer interface does bounds
+	  * checking later.
+	  */
+	scc_return_t retval;
+	retval = scc_verify_slot_access(owner_id, slot, 0);
+	if (retval == SCC_RET_OK) {
+		return FSL_RETURN_OK_S;
+	}
+	return FSL_RETURN_AUTH_FAILED_S;
+}
+
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				   uint64_t owner_id, uint32_t *slot)
+{
+	scc_return_t retval;
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG_ARGS("key length: %i, handle: %i\n", size, *slot);
+
+#endif
+	retval = scc_alloc_slot(size, owner_id, slot);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t shw_slot_dealloc(void *user_data, uint64_t owner_id,
+				    uint32_t slot)
+{
+	scc_return_t retval;
+	retval = scc_dealloc_slot(owner_id, slot);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+
+	return FSL_RETURN_ERROR_S;
+}
+void *shw_slot_get_address(void *user_data, uint32_t slot)
+{
+	uint64_t owner_id = *((uint64_t *) user_data);
+	uint32_t address;
+	uint32_t value_size_bytes;
+	uint32_t slot_size_bytes;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_get_slot_info(owner_id, slot, &address, &value_size_bytes,
+			      &slot_size_bytes);
+	if (scc_ret == SCC_RET_OK) {
+		return (void *)address;
+	}
+	return NULL;
+}
+
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot)
+{
+	return 0;
+}
+
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot)
+{
+	return 0;
+}
+
+
+/* Return the size of the key slot, in octets */
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot)
+{
+	uint64_t owner_id = *((uint64_t *) user_data);
+	uint32_t address;
+	uint32_t value_size_bytes;
+	uint32_t slot_size_bytes;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_get_slot_info(owner_id, slot, &address, &value_size_bytes,
+			      &slot_size_bytes);
+	if (scc_ret == SCC_RET_OK)
+		return slot_size_bytes;
+	return 0;
+}
+
+
+#endif	/* __KERNEL__ */
+
+#endif	/* FSL_HAVE_SCC2 */
+
+/*****************************************************************************/
diff --git a/drivers/mxc/security/sahara2/fsl_shw_rand.c b/drivers/mxc/security/sahara2/fsl_shw_rand.c
new file mode 100644
index 0000000..600bd3b
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_rand.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_rand.c
+ *
+ * This file implements Random Number Generation functions of the FSL SHW API
+ * for Sahara.
+ */
+
+#include <linux/mxc_sahara.h>
+#include "sf_util.h"
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_get_random);
+#endif
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Get a random number
+ *
+ *
+ * @param    user_ctx
+ * @param    length
+ * @param    data
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+				    uint32_t length, uint8_t * data)
+{
+	SAH_SF_DCLS;
+
+	/* perform a sanity check on the uco */
+	ret = sah_validate_uco(user_ctx);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	header = SAH_HDR_RNG_GENERATE;	/* Desc. #18 */
+	DESC_OUT_OUT(header, length, data, 0, NULL);
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_add_entropy);
+#endif
+
+/*!
+ * Add entropy to a random number generator
+
+ * @param    user_ctx
+ * @param    length
+ * @param    data
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+				     uint32_t length, uint8_t * data)
+{
+	SAH_SF_DCLS;
+
+	/* perform a sanity check on the uco */
+	ret = sah_validate_uco(user_ctx);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	header = SAH_HDR_RNG_GENERATE;	/* Desc. #18 */
+
+	/* create descriptor #18. Generate random data */
+	DESC_IN_IN(header, 0, NULL, length, data)
+
+	    SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_sym.c b/drivers/mxc/security/sahara2/fsl_shw_sym.c
new file mode 100644
index 0000000..789958b
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_sym.c
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_sym.c
+ *
+ * This file implements Symmetric Cipher functions of the FSL SHW API for
+ * Sahara.  This does not include CCM.
+ */
+
+#include <linux/mxc_sahara.h>
+#include "fsl_platform.h"
+
+#include "sf_util.h"
+#include "adaptor.h"
+
+#ifdef LINUX_KERNEL
+EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
+EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
+#endif
+
+#if defined(NEED_CTR_WORKAROUND)
+/* CTR mode needs block-multiple data in/out */
+#define LENGTH_PATCH  (sym_ctx->block_size_bytes)
+#define LENGTH_PATCH_MASK  (sym_ctx->block_size_bytes-1)
+#else
+#define LENGTH_PATCH  0
+#define LENGTH_PATCH_MASK  0	/* du not use! */
+#endif
+
+/*!
+ * Block of zeroes which is maximum Symmetric block size, used for
+ * initializing context register, etc.
+ */
+static uint32_t block_zeros[4] = {
+	0, 0, 0, 0
+};
+
+typedef enum cipher_direction {
+	SYM_DECRYPT,
+	SYM_ENCRYPT
+} cipher_direction_t;
+
+/*!
+ * Create and run the chain for a symmetric-key operation.
+ *
+ * @param user_ctx    Who the user is
+ * @param key_info    What key is to be used
+ * @param sym_ctx     Info details about algorithm
+ * @param encrypt     0 = decrypt, non-zero = encrypt
+ * @param length      Number of octets at @a in and @a out
+ * @param in          Pointer to input data
+ * @param out         Location to store output data
+ *
+ * @return         The status of handing chain to driver,
+ *                 or an earlier argument/flag or allocation
+ *                 error.
+ */
+static fsl_shw_return_t do_symmetric(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     fsl_shw_scco_t * sym_ctx,
+				     cipher_direction_t encrypt,
+				     uint32_t length,
+				     const uint8_t * in, uint8_t * out)
+{
+	SAH_SF_DCLS;
+	uint8_t *sink = NULL;
+	sah_Link *link1 = NULL;
+	sah_Link *link2 = NULL;
+	sah_Oct_Str ptr1;
+	uint32_t size1 = sym_ctx->block_size_bytes;
+
+	SAH_SF_USER_CHECK();
+
+	/* Two different sets of chains, depending on algorithm */
+	if (key_info->algorithm == FSL_KEY_ALG_ARC4) {
+		if (sym_ctx->flags & FSL_SYM_CTX_INIT) {
+			/* Desc. #35 w/ARC4 - start from key */
+			header = SAH_HDR_ARC4_SET_MODE_KEY
+			    ^ sah_insert_skha_algorithm_arc4;
+
+			DESC_IN_KEY(header, 0, NULL, key_info);
+		} else {	/* load SBox */
+			/* Desc. #33 w/ARC4 and NO PERMUTE */
+			header = SAH_HDR_ARC4_SET_MODE_SBOX
+			    ^ sah_insert_skha_no_permute
+			    ^ sah_insert_skha_algorithm_arc4;
+			DESC_IN_IN(header, 256, sym_ctx->context,
+				   3, sym_ctx->context + 256);
+		}		/* load SBox */
+
+		/* Add in-out data descriptor to process the data */
+		if (length != 0) {
+			DESC_IN_OUT(SAH_HDR_SKHA_ENC_DEC, length, in, length,
+				    out);
+		}
+
+		/* Operation is done ... save what came out? */
+		if (sym_ctx->flags & FSL_SYM_CTX_SAVE) {
+			/* Desc. #34 - Read SBox, pointers */
+			header = SAH_HDR_ARC4_READ_SBOX;
+			DESC_OUT_OUT(header, 256, sym_ctx->context,
+				     3, sym_ctx->context + 256);
+		}
+	} else {		/* not ARC4 */
+		/* Doing 1- or 2- descriptor chain. */
+		/* Desc. #1 and algorithm and mode */
+		header = SAH_HDR_SKHA_SET_MODE_IV_KEY
+		    ^ sah_insert_skha_mode[sym_ctx->mode]
+		    ^ sah_insert_skha_algorithm[key_info->algorithm];
+
+		/* Honor 'no key parity checking' for DES and TDES */
+		if ((key_info->flags & FSL_SKO_KEY_IGNORE_PARITY) &&
+		    ((key_info->algorithm == FSL_KEY_ALG_DES) ||
+		     (key_info->algorithm == FSL_KEY_ALG_TDES))) {
+			header ^= sah_insert_skha_no_key_parity;
+		}
+
+		/* Header by default is decrypting, so... */
+		if (encrypt == SYM_ENCRYPT) {
+			header ^= sah_insert_skha_encrypt;
+		}
+
+		if (sym_ctx->mode == FSL_SYM_MODE_CTR) {
+			header ^= sah_insert_skha_modulus[sym_ctx->modulus_exp];
+		}
+
+		if (sym_ctx->mode == FSL_SYM_MODE_ECB) {
+			ptr1 = NULL;
+			size1 = 0;
+		} else if (sym_ctx->flags & FSL_SYM_CTX_INIT) {
+			ptr1 = (uint8_t *) block_zeros;
+		} else {
+			ptr1 = sym_ctx->context;
+		}
+
+		DESC_IN_KEY(header, sym_ctx->block_size_bytes, ptr1, key_info);
+
+		/* Add in-out data descriptor */
+		if (length != 0) {
+			header = SAH_HDR_SKHA_ENC_DEC;
+			if (LENGTH_PATCH && (sym_ctx->mode == FSL_SYM_MODE_CTR)
+			    && ((length & LENGTH_PATCH_MASK) != 0)) {
+				sink = DESC_TEMP_ALLOC(LENGTH_PATCH);
+				ret =
+				    sah_Create_Link(user_ctx->mem_util, &link1,
+						    (uint8_t *) in, length,
+						    SAH_USES_LINK_DATA);
+				ret =
+				    sah_Append_Link(user_ctx->mem_util, link1,
+						    (uint8_t *) sink,
+						    LENGTH_PATCH -
+						    (length &
+						     LENGTH_PATCH_MASK),
+						    SAH_USES_LINK_DATA);
+				if (ret != FSL_RETURN_OK_S) {
+					goto out;
+				}
+				ret =
+				    sah_Create_Link(user_ctx->mem_util, &link2,
+						    out, length,
+						    SAH_USES_LINK_DATA |
+						    SAH_OUTPUT_LINK);
+				if (ret != FSL_RETURN_OK_S) {
+					goto out;
+				}
+				ret = sah_Append_Link(user_ctx->mem_util, link2,
+						      sink,
+						      LENGTH_PATCH -
+						      (length &
+						       LENGTH_PATCH_MASK),
+						      SAH_USES_LINK_DATA);
+				if (ret != FSL_RETURN_OK_S) {
+					goto out;
+				}
+				ret =
+				    sah_Append_Desc(user_ctx->mem_util,
+						    &desc_chain, header, link1,
+						    link2);
+				if (ret != FSL_RETURN_OK_S) {
+					goto out;
+				}
+				link1 = link2 = NULL;
+			} else {
+				DESC_IN_OUT(header, length, in, length, out);
+			}
+		}
+
+		/* Unload any desired context */
+		if (sym_ctx->flags & FSL_SYM_CTX_SAVE) {
+			DESC_OUT_OUT(SAH_HDR_SKHA_READ_CONTEXT_IV, 0, NULL,
+				     sym_ctx->block_size_bytes,
+				     sym_ctx->context);
+		}
+
+	}			/* not ARC4 */
+
+	SAH_SF_EXECUTE();
+
+      out:
+	SAH_SF_DESC_CLEAN();
+	DESC_TEMP_FREE(sink);
+	if (LENGTH_PATCH) {
+		sah_Destroy_Link(user_ctx->mem_util, link1);
+		sah_Destroy_Link(user_ctx->mem_util, link2);
+	}
+
+	return ret;
+}
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+
+/*!
+ * Compute symmetric encryption
+ *
+ *
+ * @param    user_ctx
+ * @param    key_info
+ * @param    sym_ctx
+ * @param    length
+ * @param    pt
+ * @param    ct
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * pt, uint8_t * ct)
+{
+	fsl_shw_return_t ret;
+
+	ret = do_symmetric(user_ctx, key_info, sym_ctx, SYM_ENCRYPT,
+			   length, pt, ct);
+
+	return ret;
+}
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+
+/*!
+ * Compute symmetric decryption
+ *
+ *
+ * @param    user_ctx
+ * @param    key_info
+ * @param    sym_ctx
+ * @param    length
+ * @param    pt
+ * @param    ct
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * ct, uint8_t * pt)
+{
+	fsl_shw_return_t ret;
+
+	ret = do_symmetric(user_ctx, key_info, sym_ctx, SYM_DECRYPT,
+			   length, ct, pt);
+
+	return ret;
+}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_user.c b/drivers/mxc/security/sahara2/fsl_shw_user.c
new file mode 100644
index 0000000..529c527
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_user.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_user.c
+ *
+ * This file implements user and platform capabilities functions of the FSL SHW
+ * API for Sahara
+ */
+#include <linux/mxc_sahara.h>
+#include <adaptor.h>
+#include <sf_util.h>
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_get_capabilities);
+EXPORT_SYMBOL(fsl_shw_register_user);
+EXPORT_SYMBOL(fsl_shw_deregister_user);
+EXPORT_SYMBOL(fsl_shw_get_results);
+#endif				/* __KERNEL__ */
+
+struct cap_t {
+	unsigned populated;
+	union {
+		uint32_t buffer[sizeof(fsl_shw_pco_t)];
+		fsl_shw_pco_t pco;
+	};
+};
+
+static struct cap_t cap = {
+	0,
+	{}
+};
+
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+/*!
+ * Determine the hardware security capabilities of this platform.
+ *
+ * Though a user context object is passed into this function, it will always
+ * act in a non-blocking manner.
+ *
+ * @param  user_ctx   The user context which will be used for the query.
+ *
+ * @return  A pointer to the capabilities object.
+ */
+fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx)
+{
+	fsl_shw_pco_t *retval = NULL;
+
+	if (cap.populated) {
+		retval = &cap.pco;
+	} else {
+		if (get_capabilities(user_ctx, &cap.pco) == FSL_RETURN_OK_S) {
+			cap.populated = 1;
+			retval = &cap.pco;
+		}
+	}
+	return retval;
+}
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+
+/*!
+ * Create an association between the the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which will be used for this association.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx)
+{
+	return sah_register(user_ctx);
+}
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+
+/*!
+ * Destroy the association between the the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which is no longer needed.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx)
+{
+	return sah_deregister(user_ctx);
+}
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+
+/*!
+ * Retrieve results from earlier operations.
+ *
+ * @param         user_ctx     The user's context.
+ * @param         result_size  The number of array elements of @a results.
+ * @param[in,out] results      Pointer to first of the (array of) locations to
+ *                             store results.
+ * @param[out]    result_count Pointer to store the number of results which
+ *                             were returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+				     unsigned result_size,
+				     fsl_shw_result_t results[],
+				     unsigned *result_count)
+{
+	fsl_shw_return_t status;
+
+	/* perform a sanity check on the uco */
+	status = sah_validate_uco(user_ctx);
+
+	/* if uco appears ok, build structure and pass to get results */
+	if (status == FSL_RETURN_OK_S) {
+		sah_results arg;
+
+		/* if requested is zero, it's done before it started */
+		if (result_size > 0) {
+			arg.requested = result_size;
+			arg.actual = result_count;
+			arg.results = results;
+			/* get the results */
+			status = sah_get_results(&arg, user_ctx);
+		}
+	}
+
+	return status;
+}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_wrap.c b/drivers/mxc/security/sahara2/fsl_shw_wrap.c
new file mode 100644
index 0000000..37d1ed8
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_wrap.c
@@ -0,0 +1,967 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_wrap.c
+ *
+ * This file implements Key-Wrap (Black Key) functions of the FSL SHW API for
+ * Sahara.
+ *
+ * - Ownerid is an 8-byte, user-supplied, value to keep KEY confidential.
+ * - KEY is a 1-32 byte value which starts in SCC RED RAM before
+ *     wrapping, and ends up there on unwrap.  Length is limited because of
+ *    size of SCC1 RAM.
+ * - KEY' is the encrypted KEY
+ * - LEN is a 1-byte (for now) byte-length of KEY
+ * - ALG is a 1-byte value for the algorithm which which the key is
+ *    associated.  Values are defined by the FSL SHW API
+ * - Ownerid, LEN, and ALG come from the user's "key_info" object, as does the
+ *    slot number where KEY already is/will be.
+ * - T is a Nonce
+ * - T' is the encrypted T
+ * - KEK is a Key-Encryption Key for the user's Key
+ * - ICV is the "Integrity Check Value" for the wrapped key
+ * - Black Key is the string of bytes returned as the wrapped key
+<table>
+<tr><TD align="right">BLACK_KEY <TD width="3">=<TD>ICV | T' | LEN | ALG |
+     KEY'</td></tr>
+<tr><td>&nbsp;</td></tr>
+
+<tr><th>To Wrap</th></tr>
+<tr><TD align="right">T</td> <TD width="3">=</td> <TD>RND()<sub>16</sub>
+    </td></tr>
+<tr><TD align="right">KEK</td><TD width="3">=</td><TD>HASH<sub>sha256</sub>(T |
+     Ownerid)<sub>16</sub></td></tr>
+<tr><TD align="right">KEY'<TD width="3">=</td><TD>
+     AES<sub>ctr-enc</sub>(Key=KEK, CTR=0, Data=KEY)</td></tr>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
+     (Key=T, Data=Ownerid | LEN | ALG | KEY')<sub>16</sub></td></tr>
+<tr><TD align="right">T'</td><TD width="3">=</td><TD>TDES<sub>cbc-enc</sub>
+     (Key=SLID, IV=Ownerid, Data=T)</td></tr>
+
+<tr><td>&nbsp;</td></tr>
+
+<tr><th>To Unwrap</th></tr>
+<tr><TD align="right">T</td><TD width="3">=</td><TD>TDES<sub>ecb-dec</sub>
+    (Key=SLID, IV=Ownerid, Data=T')</sub></td></tr>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
+    (Key=T, Data=Ownerid | LEN | ALG | KEY')<sub>16</sub></td></tr>
+<tr><TD align="right">KEK</td><TD width="3">=</td><td>HASH<sub>sha256</sub>
+    (T | Ownerid)<sub>16</sub></td></tr>
+<tr><TD align="right">KEY<TD width="3">=</td><TD>AES<sub>ctr-dec</sub>
+    (Key=KEK, CTR=0, Data=KEY')</td></tr>
+</table>
+
+ */
+
+#include <linux/mxc_sahara.h>
+#include "fsl_platform.h"
+#include "fsl_shw_keystore.h"
+
+#include "sf_util.h"
+#include "adaptor.h"
+
+#if defined(DIAG_SECURITY_FUNC)
+#include <diagnostic.h>
+#endif
+
+#if defined(NEED_CTR_WORKAROUND)
+/* CTR mode needs block-multiple data in/out */
+#define LENGTH_PATCH  16
+#define LENGTH_PATCH_MASK  0xF
+#else
+#define LENGTH_PATCH  4
+#define LENGTH_PATCH_MASK  3
+#endif
+
+#if LENGTH_PATCH
+#define ROUND_LENGTH(len)                                                  \
+({                                                                         \
+    uint32_t orig_len = len;                                               \
+    uint32_t new_len;                                                      \
+                                                                           \
+   if ((orig_len & LENGTH_PATCH_MASK) != 0) {                              \
+       new_len = (orig_len + LENGTH_PATCH                                  \
+            - (orig_len & LENGTH_PATCH_MASK));                             \
+   }                                                                       \
+   else {                                                                  \
+       new_len = orig_len;                                                 \
+   }                                                                       \
+       new_len;                                                            \
+})
+#else
+#define ROUND_LENGTH(len) (len)
+#endif
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(fsl_shw_establish_key);
+EXPORT_SYMBOL(fsl_shw_extract_key);
+EXPORT_SYMBOL(fsl_shw_release_key);
+EXPORT_SYMBOL(fsl_shw_read_key);
+#endif
+
+#define ICV_LENGTH 16
+#define T_LENGTH 16
+#define KEK_LENGTH 16
+#define LENGTH_LENGTH 1
+#define ALGORITHM_LENGTH 1
+#define FLAGS_LENGTH 1
+
+/* ICV | T' | LEN | ALG | KEY' */
+#define ICV_OFFSET       0
+#define T_PRIME_OFFSET   (ICV_OFFSET + ICV_LENGTH)
+#define LENGTH_OFFSET    (T_PRIME_OFFSET + T_LENGTH)
+#define ALGORITHM_OFFSET (LENGTH_OFFSET + LENGTH_LENGTH)
+#define FLAGS_OFFSET     (ALGORITHM_OFFSET + ALGORITHM_LENGTH)
+#define KEY_PRIME_OFFSET (FLAGS_OFFSET + FLAGS_LENGTH)
+#define FLAGS_SW_KEY     0x01
+
+/*
+ * For testing of the algorithm implementation,, the DO_REPEATABLE_WRAP flag
+ * causes the T_block to go into the T field during a wrap operation.  This
+ * will make the black key value repeatable (for a given SCC secret key, or
+ * always if the default key is in use).
+ *
+ * Normally, a random sequence is used.
+ */
+#ifdef DO_REPEATABLE_WRAP
+/*!
+ * Block of zeroes which is maximum Symmetric block size, used for
+ * initializing context register, etc.
+ */
+static uint8_t T_block_[16] = {
+	0x42, 0, 0, 0x42, 0x42, 0, 0, 0x42,
+	0x42, 0, 0, 0x42, 0x42, 0, 0, 0x42
+};
+#endif
+
+/*!
+ * Insert descriptors to calculate ICV = HMAC(key=T, data=LEN|ALG|KEY')
+ *
+ * @param  user_ctx      User's context for this operation
+ * @param  desc_chain    Descriptor chain to append to
+ * @param  t_key_info    T's key object
+ * @param  black_key     Beginning of Black Key region
+ * @param  key_length    Number of bytes of key' there are in @c black_key
+ * @param[out] hmac      Location to store ICV.  Will be tagged "USES" so
+ *                       sf routines will not try to free it.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static inline fsl_shw_return_t create_icv_calc(fsl_shw_uco_t * user_ctx,
+					       sah_Head_Desc ** desc_chain,
+					       fsl_shw_sko_t * t_key_info,
+					       const uint8_t * black_key,
+					       uint32_t key_length,
+					       uint8_t * hmac)
+{
+	fsl_shw_return_t sah_code;
+	uint32_t header;
+	sah_Link *link1 = NULL;
+	sah_Link *link2 = NULL;
+
+	/* Load up T as key for the HMAC */
+	header = (SAH_HDR_MDHA_SET_MODE_MD_KEY	/* #6 */
+		  ^ sah_insert_mdha_algorithm_sha256
+		  ^ sah_insert_mdha_init ^ sah_insert_mdha_hmac ^
+		  sah_insert_mdha_pdata ^ sah_insert_mdha_mac_full);
+	sah_code = sah_add_in_key_desc(header, NULL, 0, t_key_info,	/* Reference T in RED */
+				       user_ctx->mem_util, desc_chain);
+	if (sah_code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Previous step loaded key; Now set up to hash the data */
+	header = SAH_HDR_MDHA_HASH;	/* #10 */
+
+	/* Input - start with ownerid */
+	sah_code = sah_Create_Link(user_ctx->mem_util, &link1,
+				   (void *)&t_key_info->userid,
+				   sizeof(t_key_info->userid),
+				   SAH_USES_LINK_DATA);
+	if (sah_code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Still input  - Append black-key fields len, alg, key' */
+	sah_code = sah_Append_Link(user_ctx->mem_util, link1,
+				   (void *)black_key + LENGTH_OFFSET,
+				   (LENGTH_LENGTH
+				    + ALGORITHM_LENGTH
+				    + key_length), SAH_USES_LINK_DATA);
+
+	if (sah_code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	/* Output - computed ICV/HMAC */
+	sah_code = sah_Create_Link(user_ctx->mem_util, &link2,
+				   hmac, ICV_LENGTH,
+				   SAH_USES_LINK_DATA | SAH_OUTPUT_LINK);
+	if (sah_code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	sah_code = sah_Append_Desc(user_ctx->mem_util, desc_chain,
+				   header, link1, link2);
+
+      out:
+	if (sah_code != FSL_RETURN_OK_S) {
+		(void)sah_Destroy_Link(user_ctx->mem_util, link1);
+		(void)sah_Destroy_Link(user_ctx->mem_util, link2);
+	}
+
+	return sah_code;
+}				/* create_icv_calc */
+
+/*!
+ * Perform unwrapping of a black key into a RED slot
+ *
+ * @param         user_ctx      A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be unwrapped... key length, slot info, etc.
+ * @param         black_key     Encrypted key
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t unwrap(fsl_shw_uco_t * user_ctx,
+			       fsl_shw_sko_t * key_info,
+			       const uint8_t * black_key)
+{
+	SAH_SF_DCLS;
+	uint8_t *hmac = NULL;
+	fsl_shw_sko_t t_key_info;
+	sah_Link *link1 = NULL;
+	sah_Link *link2 = NULL;
+	unsigned i;
+	unsigned rounded_key_length;
+	unsigned original_key_length = key_info->key_length;
+
+	hmac = DESC_TEMP_ALLOC(ICV_LENGTH);
+
+	/* Set up key_info for "T" - use same slot as eventual key */
+	fsl_shw_sko_init(&t_key_info, FSL_KEY_ALG_AES);
+	t_key_info.userid = key_info->userid;
+	t_key_info.handle = key_info->handle;
+	t_key_info.flags = key_info->flags;
+	t_key_info.key_length = T_LENGTH;
+	t_key_info.keystore = key_info->keystore;
+
+	/* Validate SW flags to prevent misuse */
+	if ((key_info->flags & FSL_SKO_KEY_SW_KEY)
+		&& !(black_key[FLAGS_OFFSET] & FLAGS_SW_KEY)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* Compute T = SLID_decrypt(T'); leave in RED slot */
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_decrypt(user_ctx,
+					key_info->userid,
+				    t_key_info.handle,
+				    T_LENGTH,
+				    black_key + T_PRIME_OFFSET);
+
+	} else {
+			/* Key goes in user keystore */
+			ret = keystore_slot_decrypt(user_ctx,
+							key_info->keystore,
+							key_info->userid,
+							t_key_info.handle,
+							T_LENGTH,
+						    black_key + T_PRIME_OFFSET);
+	}
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Compute ICV = HMAC(T, ownerid | len | alg | key' */
+	ret = create_icv_calc(user_ctx, &desc_chain, &t_key_info,
+			      black_key, original_key_length, hmac);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Creation of sah_Key_Link failed due to bad key"
+			 " flag!\n");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Validating MAC of wrapped key");
+#endif
+	SAH_SF_EXECUTE();
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	SAH_SF_DESC_CLEAN();
+
+	/* Check computed ICV against value in Black Key */
+	for (i = 0; i < ICV_LENGTH; i++) {
+		if (black_key[ICV_OFFSET + i] != hmac[i]) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS("computed ICV fails at offset %i\n", i);
+
+			{
+				char buff[300];
+				int a;
+				for (a = 0; a < ICV_LENGTH; a++)
+					sprintf(&(buff[a * 2]), "%02x",
+						black_key[ICV_OFFSET + a]);
+				buff[a * 2 + 1] = 0;
+				LOG_DIAG_ARGS("black key: %s", buff);
+
+				for (a = 0; a < ICV_LENGTH; a++)
+					sprintf(&(buff[a * 2]), "%02x",
+						hmac[a]);
+				buff[a * 2 + 1] = 0;
+				LOG_DIAG_ARGS("hmac:      %s", buff);
+			}
+#endif
+			ret = FSL_RETURN_AUTH_FAILED_S;
+			goto out;
+		}
+	}
+
+	/* This is no longer needed. */
+	DESC_TEMP_FREE(hmac);
+
+	/* Compute KEK = SHA256(T | ownerid).  Rewrite slot with value */
+	header = (SAH_HDR_MDHA_SET_MODE_HASH	/* #8 */
+		  ^ sah_insert_mdha_init
+		  ^ sah_insert_mdha_algorithm_sha256 ^ sah_insert_mdha_pdata);
+
+	/* Input - Start with T */
+	ret = sah_Create_Key_Link(user_ctx->mem_util, &link1, &t_key_info);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Still input - append ownerid */
+	ret = sah_Append_Link(user_ctx->mem_util, link1,
+			      (void *)&key_info->userid,
+			      sizeof(key_info->userid), SAH_USES_LINK_DATA);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Output - KEK goes into RED slot */
+	ret = sah_Create_Key_Link(user_ctx->mem_util, &link2, &t_key_info);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Put the Hash calculation into the chain. */
+	ret = sah_Append_Desc(user_ctx->mem_util, &desc_chain,
+			      header, link1, link2);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Compute KEY = AES-decrypt(KEK, KEY') */
+	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY	/* #1 */
+		  ^ sah_insert_skha_mode_ctr
+		  ^ sah_insert_skha_algorithm_aes
+		  ^ sah_insert_skha_modulus_128);
+	/* Load KEK in as the key to use */
+	DESC_IN_KEY(header, 0, NULL, &t_key_info);
+
+	rounded_key_length = ROUND_LENGTH(original_key_length);
+	key_info->key_length = rounded_key_length;
+
+	/* Now set up for computation.  Result in RED */
+	header = SAH_HDR_SKHA_ENC_DEC;	/* #4 */
+	DESC_IN_KEY(header, rounded_key_length, black_key + KEY_PRIME_OFFSET,
+		    key_info);
+
+	/* Perform the operation */
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Decrypting key with KEK");
+#endif
+	SAH_SF_EXECUTE();
+
+      out:
+	key_info->key_length = original_key_length;
+	SAH_SF_DESC_CLEAN();
+
+	DESC_TEMP_FREE(hmac);
+
+	/* Erase tracks */
+	t_key_info.userid = 0xdeadbeef;
+	t_key_info.handle = 0xdeadbeef;
+
+	return ret;
+}				/* unwrap */
+
+/*!
+ * Perform wrapping of a black key from a RED slot
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be wrapped... key length, slot info, etc.
+ * @param      black_key        Place to store encrypted key
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
+			     fsl_shw_sko_t * key_info, uint8_t * black_key)
+{
+	SAH_SF_DCLS;
+	unsigned slots_allocated = 0;	/* boolean */
+	fsl_shw_sko_t T_key_info;	/* for holding T */
+	fsl_shw_sko_t KEK_key_info;	/* for holding KEK */
+	unsigned original_key_length = key_info->key_length;
+	unsigned rounded_key_length;
+	sah_Link *link1;
+	sah_Link *link2;
+
+	black_key[LENGTH_OFFSET] = key_info->key_length;
+	black_key[ALGORITHM_OFFSET] = key_info->algorithm;
+
+	memcpy(&T_key_info, key_info, sizeof(T_key_info));
+	fsl_shw_sko_set_key_length(&T_key_info, T_LENGTH);
+	T_key_info.algorithm = FSL_KEY_ALG_HMAC;
+
+	memcpy(&KEK_key_info, &T_key_info, sizeof(KEK_key_info));
+	KEK_key_info.algorithm = FSL_KEY_ALG_AES;
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_alloc(user_ctx,
+				T_LENGTH, key_info->userid,
+			    &T_key_info.handle);
+
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_alloc(key_info->keystore,
+				  T_LENGTH,
+				  key_info->userid, &T_key_info.handle);
+	}
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_alloc(user_ctx,
+				KEK_LENGTH, key_info->userid,
+				&KEK_key_info.handle);
+
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_alloc(key_info->keystore,
+			  KEK_LENGTH,  key_info->userid,
+			  &KEK_key_info.handle);
+	}
+
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("do_scc_slot_alloc() failed");
+#endif
+		if (key_info->keystore == NULL) {
+			/* Key goes in system keystore */
+			(void)do_system_keystore_slot_dealloc(user_ctx,
+				key_info->userid, T_key_info.handle);
+
+		} else {
+			/* Key goes in user keystore */
+			(void)keystore_slot_dealloc(key_info->keystore,
+					key_info->userid, T_key_info.handle);
+		}
+	} else {
+		slots_allocated = 1;
+	}
+
+	/* Set up to compute everything except T' ... */
+#ifndef DO_REPEATABLE_WRAP
+	/* Compute T = RND() */
+	header = SAH_HDR_RNG_GENERATE;	/* Desc. #18 */
+	DESC_KEY_OUT(header, &T_key_info, 0, NULL);
+#else
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_load(user_ctx,
+			   T_key_info.userid,
+			   T_key_info.handle, T_block,
+			   T_key_info.key_length);
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_load(key_info->keystore,
+				 T_key_info.userid,
+				 T_key_info.handle,
+				 T_block, T_key_info.key_length);
+	}
+
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+#endif
+
+	/* Compute KEK = SHA256(T | Ownerid) */
+	header = (SAH_HDR_MDHA_SET_MODE_HASH	/* #8 */
+		  ^ sah_insert_mdha_init
+		  ^ sah_insert_mdha_algorithm[FSL_HASH_ALG_SHA256]
+		  ^ sah_insert_mdha_pdata);
+	/* Input - Start with T */
+	ret = sah_Create_Key_Link(user_ctx->mem_util, &link1, &T_key_info);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	/* Still input - append ownerid */
+	ret = sah_Append_Link(user_ctx->mem_util, link1,
+			      (void *)&key_info->userid,
+			      sizeof(key_info->userid), SAH_USES_LINK_DATA);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	/* Output - KEK goes into RED slot */
+	ret = sah_Create_Key_Link(user_ctx->mem_util, &link2, &KEK_key_info);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	/* Put the Hash calculation into the chain. */
+	ret = sah_Append_Desc(user_ctx->mem_util, &desc_chain,
+			      header, link1, link2);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+#if defined(NEED_CTR_WORKAROUND)
+	rounded_key_length = ROUND_LENGTH(original_key_length);
+	key_info->key_length = rounded_key_length;
+#else
+	rounded_key_length = original_key_length;
+#endif
+	/* Compute KEY' = AES-encrypt(KEK, KEY) */
+	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY	/* #1 */
+		  ^ sah_insert_skha_mode[FSL_SYM_MODE_CTR]
+		  ^ sah_insert_skha_algorithm[FSL_KEY_ALG_AES]
+		  ^ sah_insert_skha_modulus[FSL_CTR_MOD_128]);
+	/* Set up KEK as key to use */
+	DESC_IN_KEY(header, 0, NULL, &KEK_key_info);
+	header = SAH_HDR_SKHA_ENC_DEC;
+	DESC_KEY_OUT(header, key_info,
+		     key_info->key_length, black_key + KEY_PRIME_OFFSET);
+
+	/* Set up flags info */
+	black_key[FLAGS_OFFSET] = 0;
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		black_key[FLAGS_OFFSET] |= FLAGS_SW_KEY;
+	}
+
+	/* Compute and store ICV into Black Key */
+	ret = create_icv_calc(user_ctx, &desc_chain, &T_key_info,
+			      black_key, original_key_length,
+			      black_key + ICV_OFFSET);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Creation of sah_Key_Link failed due to bad key"
+			 " flag!\n");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+
+	/* Now get Sahara to do the work. */
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Encrypting key with KEK");
+#endif
+	SAH_SF_EXECUTE();
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("sah_Descriptor_Chain_Execute() failed");
+#endif
+		goto out;
+	}
+
+	/* Compute T' = SLID_encrypt(T); Result goes to Black Key */
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_encrypt(user_ctx,
+					T_key_info.userid,  T_key_info.handle,
+					T_LENGTH, black_key + T_PRIME_OFFSET);
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_encrypt(user_ctx,
+					    key_info->keystore,
+					    T_key_info.userid,
+					    T_key_info.handle,
+					    T_LENGTH,
+					    black_key + T_PRIME_OFFSET);
+	}
+
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("do_scc_slot_encrypt() failed");
+#endif
+		goto out;
+	}
+
+      out:
+	key_info->key_length = original_key_length;
+
+	SAH_SF_DESC_CLEAN();
+	if (slots_allocated) {
+		if (key_info->keystore == NULL) {
+			/* Key goes in system keystore */
+			(void)do_system_keystore_slot_dealloc(user_ctx,
+							      key_info->userid,
+							      T_key_info.
+							      handle);
+			(void)do_system_keystore_slot_dealloc(user_ctx,
+							      key_info->userid,
+							      KEK_key_info.
+							      handle);
+		} else {
+			/* Key goes in user keystore */
+			(void)keystore_slot_dealloc(key_info->keystore,
+						    key_info->userid,
+				    T_key_info.handle);
+			(void)keystore_slot_dealloc(key_info->keystore,
+				    key_info->userid,
+				    KEK_key_info.handle);
+	    }
+	}
+
+	return ret;
+}				/* wrap */
+
+/*!
+ * Place a key into a protected location for use only by cryptographic
+ * algorithms.
+ *
+ * This only needs to be used to a) unwrap a key, or b) set up a key which
+ * could be wrapped with a later call to #fsl_shw_extract_key().  Normal
+ * cleartext keys can simply be placed into #fsl_shw_sko_t key objects with
+ * #fsl_shw_sko_set_key() and used directly.
+ *
+ * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
+ * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
+ * key based on SHA-256.)  The key size is determined by the @a key_info.  The
+ * expected length of @a key can be determined by
+ * #fsl_shw_sko_calculate_wrapped_size()
+ *
+ * The protected key will not be available for use until this operation
+ * successfully completes.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be established.  In the create case, the key
+ *                              length must be set.
+ * @param      establish_type   How @a key will be interpreted to establish a
+ *                              key for use.
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ *                              this is the location of a wrapped key.  If
+ *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
+ *                              parameter can be @a NULL.  If @a establish_type
+ *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
+ *                              of a plaintext key.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+				       fsl_shw_sko_t * key_info,
+				       fsl_shw_key_wrap_t establish_type,
+				       const uint8_t * key)
+{
+	SAH_SF_DCLS;
+	unsigned original_key_length = key_info->key_length;
+	unsigned rounded_key_length;
+	unsigned slot_allocated = 0;
+	uint32_t old_flags;
+
+	header = SAH_HDR_RNG_GENERATE;	/* Desc. #18 for rand */
+
+	/* TODO: THIS STILL NEEDS TO BE REFACTORED */
+
+	/* Write operations into SCC memory require word-multiple number of
+	 * bytes.  For ACCEPT and CREATE functions, the key length may need
+	 * to be rounded up.  Calculate. */
+	if (LENGTH_PATCH && (original_key_length & LENGTH_PATCH_MASK) != 0) {
+		rounded_key_length = original_key_length + LENGTH_PATCH
+		    - (original_key_length & LENGTH_PATCH_MASK);
+	} else {
+		rounded_key_length = original_key_length;
+	}
+
+	SAH_SF_USER_CHECK();
+
+	if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+#ifdef DIAG_SECURITY_FUNC
+			ret = FSL_RETURN_BAD_FLAG_S;
+			LOG_DIAG("Key already established\n");
+#endif
+	}
+
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_alloc(user_ctx,
+						    key_info->key_length,
+						    key_info->userid,
+						    &(key_info->handle));
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS
+		    ("key length: %i, handle: %i, rounded key length: %i",
+		     key_info->key_length, key_info->handle,
+		     rounded_key_length);
+#endif
+
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_alloc(key_info->keystore,
+					  key_info->key_length,
+					  key_info->userid,
+					  &(key_info->handle));
+	}
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Slot allocation failed\n");
+#endif
+		goto out;
+	}
+	slot_allocated = 1;
+
+	key_info->flags |= FSL_SKO_KEY_ESTABLISHED;
+	switch (establish_type) {
+	case FSL_KEY_WRAP_CREATE:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Creating random key\n");
+#endif
+		/* Use safe version of key length */
+		key_info->key_length = rounded_key_length;
+		/* Generate descriptor to put random value into */
+		DESC_KEY_OUT(header, key_info, 0, NULL);
+		/* Restore actual, desired key length */
+		key_info->key_length = original_key_length;
+
+		old_flags = user_ctx->flags;
+		/* Now put random value into key */
+		SAH_SF_EXECUTE();
+		/* Restore user's old flag value */
+		user_ctx->flags = old_flags;
+#ifdef DIAG_SECURITY_FUNC
+		if (ret == FSL_RETURN_OK_S) {
+			LOG_DIAG("ret is ok");
+		} else {
+			LOG_DIAG("ret is not ok");
+		}
+#endif
+		break;
+
+	case FSL_KEY_WRAP_ACCEPT:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Accepting plaintext key\n");
+#endif
+		if (key == NULL) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG("ACCEPT:  Red Key is NULL");
+#endif
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+		/* Copy in safe number of bytes of Red key */
+		if (key_info->keystore == NULL) {
+			/* Key goes in system keystore */
+			ret = do_system_keystore_slot_load(user_ctx,
+						   key_info->userid,
+						   key_info->handle, key,
+						   rounded_key_length);
+		} else {
+			/* Key goes in user keystore */
+			ret = keystore_slot_load(key_info->keystore,
+								 key_info->userid,
+								 key_info->handle, key,
+								 key_info->key_length);
+		}
+		break;
+
+	case FSL_KEY_WRAP_UNWRAP:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Unwrapping wrapped key\n");
+#endif
+		/* For now, disallow non-blocking calls. */
+		if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+			ret = FSL_RETURN_BAD_FLAG_S;
+		} else if (key == NULL) {
+			ret = FSL_RETURN_ERROR_S;
+		} else {
+			ret = unwrap(user_ctx, key_info, key);
+		}
+		break;
+
+	default:
+		ret = FSL_RETURN_BAD_FLAG_S;
+		break;
+	}			/* switch */
+
+      out:
+	if (slot_allocated && (ret != FSL_RETURN_OK_S)) {
+		fsl_shw_return_t scc_err;
+
+		if (key_info->keystore == NULL) {
+			/* Key goes in system keystore */
+			scc_err = do_system_keystore_slot_dealloc(user_ctx,
+						  key_info->userid,
+						  key_info->handle);
+		} else {
+			/* Key goes in user keystore */
+			scc_err = keystore_slot_dealloc(key_info->keystore,
+						key_info->userid,  key_info->handle);
+		}
+
+		key_info->flags &= ~FSL_SKO_KEY_ESTABLISHED;
+	}
+
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}				/* fsl_shw_establish_key() */
+
+/*!
+ * Wrap a key and retrieve the wrapped value.
+ *
+ * A wrapped key is a key that has been cryptographically obscured.  It is
+ * only able to be used with #fsl_shw_establish_key().
+ *
+ * This function will also release the key (see #fsl_shw_release_key()) so
+ * that it must be re-established before reuse.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ * @param[out] covered_key      The location to store the 48-octet wrapped key.
+ *                              (This size is based upon the maximum key size
+ *                              of 32 octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     uint8_t * covered_key)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	/* For now, only blocking mode calls are supported */
+	if (user_ctx->flags & FSL_UCO_BLOCKING_MODE) {
+		if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+			ret = wrap(user_ctx, key_info, covered_key);
+			if (ret != FSL_RETURN_OK_S) {
+				goto out;
+			}
+
+			/* Verify that a SW key info really belongs to a SW key */
+			if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+			/*  ret = FSL_RETURN_BAD_FLAG_S;
+			  goto out;*/
+			}
+
+			/* Need to deallocate on successful extraction */
+			if (key_info->keystore == NULL) {
+				/* Key goes in system keystore */
+				ret = do_system_keystore_slot_dealloc(user_ctx,
+						key_info->userid, key_info->handle);
+			} else {
+				/* Key goes in user keystore */
+				ret = keystore_slot_dealloc(key_info->keystore,
+						key_info->userid, key_info->handle);
+			}
+			/* Mark key not available in the flags */
+			key_info->flags &=
+			    ~(FSL_SKO_KEY_ESTABLISHED | FSL_SKO_KEY_PRESENT);
+		}
+	}
+
+out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
+
+/*!
+ * De-establish a key so that it can no longer be accessed.
+ *
+ * The key will need to be re-established before it can again be used.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+		if (key_info->keystore == NULL) {
+			/* Key goes in system keystore */
+			do_system_keystore_slot_dealloc(user_ctx,
+							key_info->userid,
+							key_info->handle);
+		} else {
+			/* Key goes in user keystore */
+			keystore_slot_dealloc(key_info->keystore,
+						key_info->userid,
+						key_info->handle);
+		}
+		key_info->flags &= ~(FSL_SKO_KEY_ESTABLISHED |
+				     FSL_SKO_KEY_PRESENT);
+	}
+
+out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
+
+fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_sko_t * key_info, uint8_t * key)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	if (!(key_info->flags & FSL_SKO_KEY_ESTABLISHED)
+	    || !(key_info->flags & FSL_SKO_KEY_SW_KEY)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	if (key_info->keystore == NULL) {
+		/* Key lives in system keystore */
+		ret = do_system_keystore_slot_read(user_ctx,
+						   key_info->userid,
+						   key_info->handle,
+						   key_info->key_length, key);
+	} else {
+		/* Key lives in user keystore */
+		ret = keystore_slot_read(key_info->keystore,
+					 key_info->userid,
+					 key_info->handle,
+					 key_info->key_length, key);
+	}
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
diff --git a/drivers/mxc/security/sahara2/include/adaptor.h b/drivers/mxc/security/sahara2/include/adaptor.h
new file mode 100644
index 0000000..8fcce98
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/adaptor.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file adaptor.h
+*
+* @brief The Adaptor component provides an interface to the device
+* driver.
+*
+* Intended to be used by the FSL SHW API, this can also be called directly
+*/
+
+#ifndef ADAPTOR_H
+#define ADAPTOR_H
+
+#include <linux/mxc_sahara.h>
+
+/*!
+ * Structure passed during user ioctl() call to submit request.
+ */
+typedef struct sah_dar {
+	sah_Desc *desc_addr;	/*!< head of descriptor chain */
+	uint32_t uco_flags;	/*!< copy of fsl_shw_uco flags field */
+	uint32_t uco_user_ref;	/*!< copy of fsl_shw_uco user_ref */
+	uint32_t result;	/*!< result of descriptor chain request */
+	struct sah_dar *next;	/*!< for driver use */
+} sah_dar_t;
+
+/*!
+ * Structure passed during user ioctl() call to Register a user
+ */
+typedef struct sah_register {
+	uint32_t pool_size;	/*!< max number of outstanding requests possible */
+	uint32_t result;	/*!< result of registration request */
+} sah_register_t;
+
+/*!
+ * Structure passed during ioctl() call to request SCC operation
+ */
+typedef struct scc_data {
+	uint32_t length;	/*!< length of data */
+	uint8_t *in;		/*!< input data */
+	uint8_t *out;		/*!< output data */
+	unsigned direction;	/*!< encrypt or decrypt */
+	fsl_shw_sym_mode_t crypto_mode;	/*!< CBC or EBC */
+	uint8_t *init_vector;	/*!< initialization vector or NULL */
+} scc_data_t;
+
+/*!
+ * Structure passed during user ioctl() calls to manage stored keys and
+ * stored-key slots.
+ */
+typedef struct scc_slot_t {
+	uint64_t ownerid;	/*!< Owner's id to check/set permissions */
+	uint32_t key_length;	/*!< Length of key */
+	uint32_t slot;		/*!< Slot to operation on, or returned slot
+				   number. */
+	uint8_t *key;		/*!< User-memory pointer to key value */
+	fsl_shw_return_t code;	/*!< API return code from operation */
+} scc_slot_t;
+
+/*
+ * Structure passed during user ioctl() calls to manage data stored in secure
+ * partitions.
+ */
+typedef struct scc_region_t {
+    uint32_t partition_base;	/*!< User virtual address of the
+					   partition base. */
+	uint32_t offset;	/*!< Offset from the start of the
+				   partition where the cleartext data
+				   is located. */
+	uint32_t length;	/*!< Length of the region to be
+				   operated on */
+	uint8_t *black_data;	/*!< User virtual address of any black
+				   (encrypted) data. */
+	fsl_shw_cypher_mode_t cypher_mode;	/*!< Cypher mode to use in an encryt/
+						   decrypt operation. */
+	uint32_t IV[4];		/*!< Intialization vector to use in an
+				   encrypt/decrypt operation. */
+	fsl_shw_return_t code;	/*!< API return code from operation */
+} scc_region_t;
+
+/*
+ * Structure passed during user ioctl() calls to manage secure partitions.
+ */
+typedef struct scc_partition_info_t {
+    uint32_t user_base;            /**< Userspace pointer to base of partition */
+    uint32_t permissions;          /**< Permissions to give the partition (only
+                                        used in call to _DROP_PERMS) */
+	fsl_shw_partition_status_t status;	/*!< Status of the partition */
+} scc_partition_info_t;
+
+fsl_shw_return_t adaptor_Exec_Descriptor_Chain(sah_Head_Desc * dar,
+					       fsl_shw_uco_t * uco);
+fsl_shw_return_t sah_get_results(sah_results * arg, fsl_shw_uco_t * uco);
+fsl_shw_return_t sah_register(fsl_shw_uco_t * user_ctx);
+fsl_shw_return_t sah_deregister(fsl_shw_uco_t * user_ctx);
+fsl_shw_return_t get_capabilities(fsl_shw_uco_t * user_ctx,
+							fsl_shw_pco_t *capabilities);
+
+#endif				/* ADAPTOR_H */
+
+/* End of adaptor.h */
diff --git a/drivers/mxc/security/sahara2/include/diagnostic.h b/drivers/mxc/security/sahara2/include/diagnostic.h
new file mode 100644
index 0000000..94db9bf
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/diagnostic.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file    diagnostic.h
+*
+* @brief   Macros for outputting kernel and user space diagnostics.
+*/
+
+#ifndef DIAGNOSTIC_H
+#define DIAGNOSTIC_H
+
+#ifndef __KERNEL__		/* linux flag */
+#include <stdio.h>
+#endif
+#include "fsl_platform.h"
+
+#if defined(FSL_HAVE_SAHARA2) || defined(FSL_HAVE_SAHARA4)
+#define DEV_NAME "sahara"
+#elif defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGB) ||                     \
+      defined(FSL_HAVE_RNGC)
+#define DEV_NAME "shw"
+#endif
+
+/*!
+********************************************************************
+* @brief   This macro logs diagnostic messages to stderr.
+*
+* @param   diag  String that must be logged, char *.
+*
+* @return   void
+*
+*/
+//#if defined DIAG_SECURITY_FUNC || defined DIAG_ADAPTOR
+#define LOG_DIAG(diag)                                              \
+({                                                                  \
+    const char* fname = strrchr(__FILE__, '/');                           \
+                                                                    \
+     sah_Log_Diag(fname ? fname+1 : __FILE__, __LINE__, diag);     \
+})
+
+#ifdef __KERNEL__
+
+#define LOG_DIAG_ARGS(fmt, ...)                                               \
+({                                                                            \
+    const char* fname = strrchr(__FILE__, '/');                               \
+    os_printk(KERN_ALERT "%s:%i: " fmt "\n",                                  \
+              fname ? fname+1 : __FILE__,                                     \
+              __LINE__,                                                       \
+              __VA_ARGS__);                                                   \
+})
+
+#else
+
+#define LOG_DIAG_ARGS(fmt, ...)                                               \
+({                                                                            \
+    const char* fname = strrchr(__FILE__, '/');                               \
+    printf("%s:%i: " fmt "\n",                                                \
+           fname ? fname+1 : __FILE__,                                        \
+           __LINE__,                                                          \
+           __VA_ARGS__);                                                      \
+})
+
+#ifndef __KERNEL__
+void sah_Log_Diag(char *source_name, int source_line, char *diag);
+#endif
+#endif /* if define DIAG_SECURITY_FUNC ... */
+
+#ifdef __KERNEL__
+/*!
+********************************************************************
+* @brief   This macro logs kernel diagnostic  messages to the kernel
+*          log.
+*
+* @param   diag  String that must be logged, char *.
+*
+* @return  As for printf()
+*/
+#if 0
+#if defined(DIAG_DRV_IF) || defined(DIAG_DRV_QUEUE) ||                        \
+  defined(DIAG_DRV_STATUS) || defined(DIAG_DRV_INTERRUPT) ||                  \
+   defined(DIAG_MEM) || defined(DIAG_SECURITY_FUNC) || defined(DIAG_ADAPTOR)
+#endif
+#endif
+
+#define LOG_KDIAG_ARGS(fmt, ...)                                              \
+({                                                                            \
+    os_printk (KERN_ALERT "%s (%s:%i): " fmt "\n",                            \
+               DEV_NAME, strrchr(__FILE__, '/')+1, __LINE__, __VA_ARGS__);              \
+})
+
+#define LOG_KDIAG(diag)                                                       \
+    os_printk (KERN_ALERT "%s (%s:%i): %s\n",                             \
+               DEV_NAME, strrchr(__FILE__, '/')+1, __LINE__, diag);
+
+#define sah_Log_Diag(n, l, d)                                                 \
+    os_printk(KERN_ALERT "%s:%i: %s\n", n, l, d)
+
+#else				/* not KERNEL */
+
+#define sah_Log_Diag(n, l, d)                                                 \
+    printf("%s:%i: %s\n", n, l, d)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* DIAGNOSTIC_H */
diff --git a/drivers/mxc/security/sahara2/include/fsl_platform.h b/drivers/mxc/security/sahara2/include/fsl_platform.h
new file mode 100644
index 0000000..b55bd6c
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/fsl_platform.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_platform.h
+ *
+ * Header file to isolate code which might be platform-dependent
+ */
+
+#ifndef FSL_PLATFORM_H
+#define FSL_PLATFORM_H
+
+#ifdef __KERNEL__
+#include "portable_os.h"
+#endif
+
+#if defined(FSL_PLATFORM_OTHER)
+
+/* Have Makefile or other method of setting FSL_HAVE_* flags */
+
+#elif defined(CONFIG_ARCH_MX3)	/* i.MX31 */
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_RNGA
+
+#elif defined(CONFIG_ARCH_MX21)
+
+#define FSL_HAVE_HAC
+#define FSL_HAVE_RNGA
+#define FSL_HAVE_SCC
+
+#elif defined(CONFIG_ARCH_MX25)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGB
+#define FSL_HAVE_RTIC3
+#define FSL_HAVE_DRYICE
+
+#elif defined(CONFIG_ARCH_MX27)
+
+#define FSL_HAVE_SAHARA2
+#define SUBMIT_MULTIPLE_DARS
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define ALLOW_LLO_DESCRIPTORS
+
+#elif defined(CONFIG_ARCH_MX35)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC
+
+#elif defined(CONFIG_ARCH_MX37)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC2
+#define FSL_HAVE_SRTC
+
+#elif defined(CONFIG_ARCH_MX5)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_SAHARA4
+#define FSL_HAVE_RTIC3
+#define FSL_HAVE_SRTC
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+#define ALLOW_LLO_DESCRIPTORS
+
+#elif defined(CONFIG_ARCH_MXC91131)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_HAC
+
+#elif defined(CONFIG_ARCH_MXC91221)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC2
+
+#elif defined(CONFIG_ARCH_MXC91231)
+
+#define FSL_HAVE_SAHARA2
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define NO_OUTPUT_1K_CROSSING
+
+#elif defined(CONFIG_ARCH_MXC91311)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+
+#elif defined(CONFIG_ARCH_MXC91314)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_SAHAR4
+#define FSL_HAVE_RTIC3
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+#define ALLOW_LLO_DESCRIPTORS
+
+#elif defined(CONFIG_ARCH_MXC91321)
+
+#define FSL_HAVE_SAHARA2
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define SCC_CLOCK_NOT_GATED
+#define NO_OUTPUT_1K_CROSSING
+
+#elif defined(CONFIG_ARCH_MXC92323)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_SAHARA4
+#define FSL_HAVE_PKHA
+#define FSL_HAVE_RTIC2
+#define NO_1K_CROSSING
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+#define ALLOW_LLO_DESCRIPTORS
+
+
+#elif  defined(CONFIG_ARCH_MXC91331)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGA
+#define FSL_HAVE_HAC
+#define FSL_HAVE_RTIC
+
+#elif defined(CONFIG_8548)
+
+#define FSL_HAVE_SEC2x
+
+#elif defined(CONFIG_MPC8374)
+
+#define FSL_HAVE_SEC3x
+
+#else
+
+#error UNKNOWN_PLATFORM
+
+#endif				/* platform checks */
+
+#endif				/* FSL_PLATFORM_H */
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw.h b/drivers/mxc/security/sahara2/include/fsl_shw.h
new file mode 100644
index 0000000..b412076
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/fsl_shw.h
@@ -0,0 +1,2515 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * NOTE TO MAINTAINERS: Although this header file is *the* header file to be
+ * #include'd by FSL SHW programs, it does not itself make any definitions for
+ * the API.  Instead, it uses the fsl_platform.h file and / or compiler
+ * environment variables to determine which actual driver header file to
+ * include.  This allows different implementations to contain different
+ * implementations of the various objects, macros, etc., or even to change
+ * which functions are macros and which are not.
+ */
+
+/*!
+ * @file fsl_shw.h
+ *
+ * @brief Definition of the Freescale Security Hardware API.
+ *
+ * See @ref index for an overview of the API.
+ */
+
+/*!
+ * @if USE_MAINPAGE
+ * @mainpage Common API for Freescale Security Hardware (FSL SHW API)
+ * @endif
+ *
+ * @section intro_sec Introduction
+ *
+ * This is the interface definition for the Freescale Security Hardware API
+ * (FSL SHW API) for User Mode and Kernel Mode to access Freescale Security
+ * Hardware components for cryptographic acceleration. The API is intended to
+ * provide cross-platform access to security hardware components of Freescale.
+ *
+ * This documentation has not been approved, and should not be taken to
+ * mean anything definite about future direction.
+ *
+ * Some example code is provided to give some idea of usage of this API.
+ *
+ * Note: This first version has been defined around the capabilities of the
+ * Sahara2 cryptographic accelerator, and may be expanded in the future to
+ * provide support for other platforms.  The Platform Capabilities Object is
+ * intended as a way to allow programs to adapt to different platforms.
+ *
+ * The i.MX25 is an example of a platform without a SAHARA but yet has
+ * capabilities supported by this API.  These include #fsl_shw_get_random() and
+ * #fsl_shw_add_entropy(), and the use of Triple-DES (TDEA) cipher algorithm
+ * (with no checking of key parity supported) in ECB and CBC modes with @ref
+ * sym_sec.  See also the @ref di_sec for information on key handling, and @ref
+ * td_sec for detection of Tamper Events.  Only the random functions are
+ * available from user space on this platform.
+ *
+ * @section usr_ctx The User Context
+ *
+ * The User Context Object (#fsl_shw_uco_t) controls the interaction between
+ * the user program and the API.  It is initialized as part of user
+ * registration (#fsl_shw_register_user()), and is part of every interaction
+ * thereafter.
+ *
+ * @section pf_sec Platform Capabilities
+ *
+ * Since this API is not tied to one specific type of hardware or even one
+ * given version of a given type of hardware, the platform capabilities object
+ * could be used by a portable program to make choices about using software
+ * instead of hardware for certain operations.
+ *
+ * See the #fsl_shw_pco_t, returned by #fsl_shw_get_capabilities().
+ *
+ * @ref pcoops are provided to query its contents.
+ *
+ *
+ * @section sym_sec Symmetric-Key Encryption and Decryption
+ *
+ * Symmetric-Key encryption support is provided for the block cipher algorithms
+ * AES, DES, and Triple DES.  Modes supported are #FSL_SYM_MODE_ECB,
+ * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR, though not necessarily all modes
+ * for all algorithms.  There is also support for the stream cipher algorithm
+ * commonly known as ARC4.
+ *
+ * Encryption and decryption are performed by using the functions
+ * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt(), respectively.
+ * There are two objects which provide information about the operation of these
+ * functions.  They are the #fsl_shw_sko_t, to provide key and algorithm
+ * information; and the #fsl_shw_scco_t, to provide (and store) initial context
+ * or counter value information.
+ *
+ * CCM is not supported by these functions.  For information CCM support, see
+ * @ref cmb_sec.
+ *
+ *
+ * @section hash_sec Cryptographic Hashing
+ *
+ * Hashing is performed by fsl_shw_hash(). Control of the function is through
+ * flags in the #fsl_shw_hco_t.  The algorithms which are
+ * supported are listed in #fsl_shw_hash_alg_t.
+ *
+ * The hashing function works on octet streams.  If a user application needs to
+ * hash a bitstream, it will need to do its own padding of the last block.
+ *
+ *
+ * @section hmac_sec Hashed Message Authentication Codes
+ *
+ * An HMAC is a method of combining a hash and a key so that a message cannot
+ * be faked by a third party.
+ *
+ * The #fsl_shw_hmac() can be used by itself for one-shot or multi-step
+ * operations, or in combination with #fsl_shw_hmac_precompute() to provide the
+ * ability to compute and save the beginning hashes from a key one time, and
+ * then use #fsl_shw_hmac() to calculate an HMAC on each message as it is
+ * processed.
+ *
+ * The maximum key length which is directly supported by this API is 64 octets.
+ * If a longer key size is needed for HMAC, the user will have to hash the key
+ * and present the digest value as the key to be used by the HMAC functions.
+ *
+ *
+ * @section rnd_sec Random Numbers
+ *
+ * Support is available for acquiring random values from a
+ * cryptographically-strong random number generator.  See
+ * #fsl_shw_get_random().  The function #fsl_shw_add_entropy() may be used to
+ * add entropy to the random number generator.
+ *
+ *
+ * @section cmb_sec Combined Cipher and Authentication
+ *
+ * Some schemes require that messages be encrypted and that they also have an
+ * authentication code associated with the message. The function
+ * #fsl_shw_gen_encrypt() will generate the authentication code and encrypt the
+ * message.
+ *
+ * Upon receipt of such a message, the message must be decrypted and the
+ * authentication code validated.  The function
+ * #fsl_shw_auth_decrypt() will perform these steps.
+ *
+ * Only AES-CCM is supported.
+ *
+ *
+ * @section wrap_sec Wrapped Keys
+ *
+ * On platforms with a Secure Memory, the function #fsl_shw_establish_key() can
+ * be used to place a key into the System Keystore.  This key then can be used
+ * directly by the cryptographic hardware.  It later then be wrapped
+ * (cryptographically obscured) by #fsl_shw_extract_key() and stored for later
+ * use.  If a software key (#FSL_SKO_KEY_SW_KEY) was established, then its
+ * value can be retrieved with a call to #fsl_shw_read_key().
+ *
+ * The wrapping and unwrapping functions provide security against unauthorized
+ * use and detection of tampering.
+ *
+ * The functions can also be used with a User Keystore.
+ *
+ * @section smalloc_sec Secure Memory Allocation
+ *
+ * On platforms with multiple partitions of Secure Memory, the function
+ * #fsl_shw_smalloc() can be used to acquire a partition for private use.  The
+ * function #fsl_shw_diminish_perms() can then be used to revoke specific
+ * permissions on the partition, and #fsl_shw_sfree() can be used to release the
+ * partition.
+ *
+ * @section keystore_sec User Keystore
+ *
+ * User Keystore functionality is defined in fsl_shw_keystore.h.  See @ref
+ * user_keystore for details.  This is not supported on platforms without SCC2.
+ *
+ * @section di_sec Hardware key-select extensions - DryIce
+ *
+ * Some platforms have a component called DryIce which allows the software to
+ * control which key will be used by the secure memory encryption hardware.
+ * The choices are the secret per-chip Fused (IIM) Key, an unknown, hardware-
+ * generated Random Key, a software-written Programmed Key, or the IIM Key in
+ * combination with one of the others.  #fsl_shw_pco_check_pk_supported() can
+ * be used to determine whether this feature is available on the platform.
+ * The rest of this section will explain the symmetric ciphering and key
+ * operations which are available on such a platform.
+ *
+ * The function #fsl_shw_sko_init_pf_key() will set up a Secret Key Object to
+ * refer to one of the system's platform keys.  All keys which reference a
+ * platform key must use this initialization function, including a user-
+ * provided key value.  Keys which are intended for software encryption must
+ * use #fsl_shw_sko_init().
+ *
+ * To change the setting of the Programmed Key of the DryIce module,
+ * #fsl_shw_establish_key() must be called with a platform key object of type
+ * #FSL_SHW_PF_KEY_PRG or #FSL_SHW_PF_KEY_IIM_PRG.  The key will be go
+ * into the PK register of DryIce and not to the keystore.  Any symmetric
+ * operation which references either #FSL_SHW_PF_KEY_PRG or
+ * #FSL_SHW_PF_KEY_IIM_PRG will use the current PK value (possibly modified by
+ * the secret fused IIM key).  Before the Flatform Key can be changed, a call to
+ * #fsl_shw_release_key() or #fsl_shw_extract_key() must be made.  Neither
+ * function will change the value in the PK registers, and further ciphering
+ * can take place.
+ *
+ * When #fsl_shw_establish_key() is called to change the PK value, a plaintext
+ * key can be passed in with the #FSL_KEY_WRAP_ACCEPT argument or a previously
+ * wrapped key can be passed in with the #FSL_KEY_WRAP_UNWRAP argument.  If
+ * #FSL_KEY_WRAP_CREATE is passed in, then a random value will be loaded into
+ * the PK register.  The PK value can be wrapped by a call to
+ * #fsl_shw_extract_key() for later use with the #FSL_KEY_WRAP_UNWRAP argument.
+ *
+ * As an alternative to using only the fused key for @ref wrap_sec,
+ * #fsl_shw_uco_set_wrap_key() can be used to select either the random key or
+ * the random key with the fused key as the key which will be used to protect
+ * the one-time value used to wrap the key.  This allows for these
+ * wrapped keys to be dependent upon and therefore unrecoverable after a tamper
+ * event causes the erasure of the DryIce Random Key register.
+ *
+ * The software can request that the hardware generate a (new) Random Key for
+ * DryIce by calling #fsl_shw_gen_random_pf_key().
+ *
+ *
+ * @section td_sec Device Tamper-Detection
+ *
+ * Some platforms have a component which can detect certain types of tampering
+ * with the hardware.  #fsl_shw_read_tamper_event() API will allow the
+ * retrieval of the type of event which caused a tamper-detection failure.
+ *
+ */
+
+/*! @defgroup glossary Glossary
+ *
+ * @li @b AES - Advanced Encryption Standard - An NIST-created block cipher
+ *          originally knowns as Rijndael.
+ * @li @b ARC4 - ARCFOUR - An S-Box-based OFB mode stream cipher.
+ * @li @b CBC - Cipher-Block Chaining - Each encrypted block is XORed with the
+ *          result of the previous block's encryption.
+ * @li @b CCM - A way of combining CBC and CTR to perform cipher and
+ *        authentication.
+ * @li @b ciphertext - @a plaintext which has been encrypted in some fashion.
+ * @li @b context - Information on the state of a cryptographic operation,
+ *        excluding any key.  This could include IV, Counter Value, or SBox.
+ * @li @b CTR - A mode where a counter value is encrypted and then XORed with
+ *        the data.  After each block, the counter value is incremented.
+ * @li @b DES - Data Encryption Standard - An 8-octet-block cipher.
+ * @li @b ECB - Electronic Codebook - A straight encryption/decryption of the
+ *        data.
+ * @li @b hash - A cryptographically strong one-way function performed on data.
+ * @li @b HMAC - Hashed Message Authentication Code - A key-dependent one-way
+ *        hash result, used to verify authenticity of a message.  The equation
+ *        for an HMAC is hash((K + A) || hash((K + B) || msg)), where K is the
+ *        key, A is the constant for the outer hash, B is the constant for the
+ *        inner hash, and hash is the hashing function (MD5, SHA256, etc).
+ * @li @b IPAD - In an HMAC operation, the context generated by XORing the key
+ *        with a constant and then hashing that value as the first block of the
+ *        inner hash.
+ * @li @b IV - An "Initial Vector" or @a context for modes like CBC.
+ * @li @b MAC - A Message Authentication Code.  HMAC, hashing, and CCM all
+ *        produce a MAC.
+ * @li @b mode  - A way of using a cryptographic algorithm.  See ECB, CBC, etc.
+ * @li @b MD5 - Message Digest 5 - A one-way hash function.
+ * @li @b plaintext - Data which has not been encrypted, or has been decrypted
+ *        from @a ciphertext.
+ * @li @b OPAD - In an HMAC operation, the context generated by XORing the key
+ *        with a constant and then hashing that value as the first block of the
+ *        outer hash.
+ * @li @b SHA - Secure Hash Algorithm - A one-way hash function.
+ * @li @b TDES - AKA @b 3DES - Triple Data Encryption Standard - A method of
+ *        using two or three keys and DES to perform three operations (encrypt
+ *        decrypt encrypt) to create a new algorithm.
+ * @li @b XOR - Exclusive-OR.  A Boolean arithmetic function.
+ * @li @b Wrapped value - A (key) which has been encrypted into an opaque datum
+ *        which cannot be unwrapped (decrypted) for use except by an authorized
+ *        user.  Once created, the key is never visible, but may be used for
+ *        other cryptographic operations.
+ */
+
+#ifndef FSL_SHW_H
+#define FSL_SHW_H
+
+/* Set FSL_HAVE_* flags */
+
+#include "fsl_platform.h"
+
+#ifndef API_DOC
+
+#if defined(FSL_HAVE_SAHARA2) || defined(FSL_HAVE_SAHARA4)
+
+#include <linux/mxc_sahara.h>
+
+#else
+
+#if defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGB) || defined(FSL_HAVE_RNGC)
+
+#include "rng_driver.h"
+
+#else
+
+#error FSL_SHW_API_platform_not_recognized
+
+#endif
+
+#endif				/* HAVE SAHARA */
+
+#else				/* API_DOC */
+
+#include <inttypes.h>		/* for uint32_t, etc. */
+#include <stdio.h>		/* Mainly for definition of NULL !! */
+
+/* These groups will appear in the order in which they are defined. */
+
+/*!
+ * @defgroup strgrp Objects
+ *
+ * These objects are used to pass information into and out of the API.  Through
+ * flags and other settings, they control the behavior of the @ref opfuns.
+ *
+ * They are manipulated and queried by use of the various access functions.
+ * There are different sets defined for each object.  See @ref objman.
+ */
+
+/*!
+ * @defgroup consgrp Enumerations and other Constants
+ *
+ * This collection of symbols comprise the values which can be passed into
+ * various functions to control how the API will work.
+ */
+
+/*! @defgroup opfuns Operational Functions
+ *
+ * These functions request that the underlying hardware perform cryptographic
+ * operations.  They are the heart of the API.
+ */
+
+/******  Organization the Object Operations under one group ! **********/
+/*! @defgroup objman Object-Manipulation Operations
+ *
+ */
+/*! @addtogroup objman
+    @{ */
+/*!
+ * @defgroup pcoops Platform Context Object Operations
+ *
+ * The Platform Context object is "read-only", so only query operations are
+ * provided for it.  It is returned by the #fsl_shw_get_capabilities()
+ * function.
+ */
+
+/*! @defgroup ucoops User Context Operations
+ *
+ * These operations should be the only access to the #fsl_shw_uco_t
+ * type/struct, as the internal members of the object are subject to change.
+ * The #fsl_shw_uco_init() function must be called before any other use of the
+ * object.
+ */
+
+/*!
+ * @defgroup rops Result Object Operations
+ *
+ * As the Result Object contains the result of one of the @ref opfuns.  The
+ * manipulations provided are query-only.  No initialization is needed for this
+ * object.
+ */
+
+/*!
+ * @defgroup skoops Secret Key Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_sko_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup ksoops Keystore Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_kso_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup hcops Hash Context Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_hco_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup hmcops HMAC Context Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_hmco_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup sccops Symmetric Cipher Context Operations
+ *
+ * These operations should be the only access to the #fsl_shw_scco_t
+ * type/struct, as the internal members of that object are subject to change
+ */
+
+/*! @defgroup accoops Authentication-Cipher Context Object Operations
+ *
+ * These functions operate on a #fsl_shw_acco_t.  Their purpose is to set
+ * flags, fields, etc., in order to control the operation of
+ * #fsl_shw_gen_encrypt() and #fsl_shw_auth_decrypt().
+ */
+
+	 /* @} *//************ END GROUPING of Object Manipulations *****************/
+
+/*! @defgroup miscfuns Miscellaneous Functions
+ *
+ * These functions are neither @ref opfuns nor @ref objman.  Their behavior
+ * does not depend upon the flags in the #fsl_shw_uco_t, yet they may involve
+ * more interaction with the library and the kernel than simply querying an
+ * object.
+ */
+
+/******************************************************************************
+ * Enumerations
+ *****************************************************************************/
+/*! @addtogroup consgrp
+    @{ */
+
+/*!
+ * Flags for the state of the User Context Object (#fsl_shw_uco_t).
+ *
+ * These flags describe how the @ref opfuns will operate.
+ */
+typedef enum fsl_shw_user_ctx_flags_t {
+	/*!
+	 * API will block the caller until operation completes.  The result will be
+	 * available in the return code.  If this is not set, user will have to get
+	 * results using #fsl_shw_get_results().
+	 */
+	FSL_UCO_BLOCKING_MODE,
+	/*!
+	 * User wants callback (at the function specified with
+	 * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+	 * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+	 */
+	FSL_UCO_CALLBACK_MODE,
+	/*! Do not free descriptor chain after driver (adaptor) finishes */
+	FSL_UCO_SAVE_DESC_CHAIN,
+	/*!
+	 * User has made at least one request with callbacks requested, so API is
+	 * ready to handle others.
+	 */
+	FSL_UCO_CALLBACK_SETUP_COMPLETE,
+	/*!
+	 * (virtual) pointer to descriptor chain is completely linked with physical
+	 * (DMA) addresses, ready for the hardware.  This flag should not be used
+	 * by FSL SHW API programs.
+	 */
+	FSL_UCO_CHAIN_PREPHYSICALIZED,
+	/*!
+	 * The user has changed the context but the changes have not been copied to
+	 * the kernel driver.
+	 */
+	FSL_UCO_CONTEXT_CHANGED,
+	/*! Internal Use.  This context belongs to a user-mode API user. */
+	FSL_UCO_USERMODE_USER,
+} fsl_shw_user_ctx_flags_t;
+
+/*!
+ * Return code for FSL_SHW library.
+ *
+ * These codes may be returned from a function call.  In non-blocking mode,
+ * they will appear as the status in a Result Object.
+ */
+typedef enum fsl_shw_return_t {
+	/*!
+	 * No error.  As a function return code in Non-blocking mode, this may
+	 * simply mean that the operation was accepted for eventual execution.
+	 */
+	FSL_RETURN_OK_S = 0,
+	/*! Failure for non-specific reason. */
+	FSL_RETURN_ERROR_S,
+	/*!
+	 * Operation failed because some resource was not able to be allocated.
+	 */
+	FSL_RETURN_NO_RESOURCE_S,
+	/*! Crypto algorithm unrecognized or improper. */
+	FSL_RETURN_BAD_ALGORITHM_S,
+	/*! Crypto mode unrecognized or improper. */
+	FSL_RETURN_BAD_MODE_S,
+	/*! Flag setting unrecognized or inconsistent. */
+	FSL_RETURN_BAD_FLAG_S,
+	/*! Improper or unsupported key length for algorithm. */
+	FSL_RETURN_BAD_KEY_LENGTH_S,
+	/*! Improper parity in a (DES, TDES) key. */
+	FSL_RETURN_BAD_KEY_PARITY_S,
+	/*!
+	 * Improper or unsupported data length for algorithm or internal buffer.
+	 */
+	FSL_RETURN_BAD_DATA_LENGTH_S,
+	/*! Authentication / Integrity Check code check failed. */
+	FSL_RETURN_AUTH_FAILED_S,
+	/*! A memory error occurred. */
+	FSL_RETURN_MEMORY_ERROR_S,
+	/*! An error internal to the hardware occurred. */
+	FSL_RETURN_INTERNAL_ERROR_S,
+	/*! ECC detected Point at Infinity */
+	FSL_RETURN_POINT_AT_INFINITY_S,
+	/*! ECC detected No Point at Infinity */
+	FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+	/*! GCD is One */
+	FSL_RETURN_GCD_IS_ONE_S,
+	/*! GCD is not One */
+	FSL_RETURN_GCD_IS_NOT_ONE_S,
+	/*! Candidate is Prime */
+	FSL_RETURN_PRIME_S,
+	/*! Candidate is not Prime */
+	FSL_RETURN_NOT_PRIME_S,
+	/*! N register loaded improperly with even value */
+	FSL_RETURN_EVEN_MODULUS_ERROR_S,
+	/*! Divisor is zero. */
+	FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+	/*! Bad Exponent or Scalar value for Point Multiply */
+	FSL_RETURN_BAD_EXPONENT_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_OSCILLATOR_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_STATISTICS_ERROR_S,
+} fsl_shw_return_t;
+
+/*!
+ * Algorithm Identifier.
+ *
+ * Selection of algorithm will determine how large the block size of the
+ * algorithm is.   Context size is the same length unless otherwise specified.
+ * Selection of algorithm also affects the allowable key length.
+ */
+typedef enum fsl_shw_key_alg_t {
+	FSL_KEY_ALG_HMAC,	/*!< Key will be used to perform an HMAC.  Key
+				   size is 1 to 64 octets.  Block size is 64
+				   octets. */
+	FSL_KEY_ALG_AES,	/*!< Advanced Encryption Standard (Rijndael).
+				   Block size is 16 octets.  Key size is 16
+				   octets.  (The single choice of key size is a
+				   Sahara platform limitation.) */
+	FSL_KEY_ALG_DES,	/*!< Data Encryption Standard.  Block size is
+				   8 octets.  Key size is 8 octets. */
+	FSL_KEY_ALG_TDES,	/*!< 2- or 3-key Triple DES.  Block size is 8
+				   octets.  Key size is 16 octets for 2-key
+				   Triple DES, and 24 octets for 3-key. */
+	FSL_KEY_ALG_ARC4	/*!< ARC4.  No block size.  Context size is 259
+				   octets.  Allowed key size is 1-16 octets.
+				   (The choices for key size are a Sahara
+				   platform limitation.) */
+} fsl_shw_key_alg_t;
+
+/*!
+ * Mode selector for Symmetric Ciphers.
+ *
+ * The selection of mode determines how a cryptographic algorithm will be
+ * used to process the plaintext or ciphertext.
+ *
+ * For all modes which are run block-by-block (that is, all but
+ * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+ * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
+ * these block-by-block algorithms must also be passed a total number of octets
+ * which is a multiple of the block size.
+ *
+ * In modes which require that the total number of octets of data be a multiple
+ * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+ * has a total number of octets which are not a multiple of the block size, the
+ * user must perform any necessary padding to get to the correct data length.
+ */
+typedef enum fsl_shw_sym_mode_t {
+	/*!
+	 * Stream.  There is no associated block size.  Any request to process data
+	 * may be of any length.  This mode is only for ARC4 operations, and is
+	 * also the only mode used for ARC4.
+	 */
+	FSL_SYM_MODE_STREAM,
+
+	/*!
+	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+	 * length of the data stream must be a multiple of the block size.  This
+	 * mode may be used for DES, 3DES, and AES.  The block size is determined
+	 * by the algorithm.
+	 */
+	FSL_SYM_MODE_ECB,
+	/*!
+	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+	 * then "chained" with the previous block by an XOR function.  Requires
+	 * context to start the XOR (previous block).  This mode may be used for
+	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CBC,
+	/*!
+	 * Counter.  The counter is encrypted, then XORed with a block of data.
+	 * The counter is then incremented (using modulus arithmetic) for the next
+	 * block. The final operation may be non-multiple of block size.  This mode
+	 * may be used for AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CTR,
+} fsl_shw_sym_mode_t;
+
+/*!
+ * Algorithm selector for Cryptographic Hash functions.
+ *
+ * Selection of algorithm determines how large the context and digest will be.
+ * Context is the same size as the digest (resulting hash), unless otherwise
+ * specified.
+ */
+typedef enum fsl_shw_hash_alg_t {
+	FSL_HASH_ALG_MD5,	/*!< MD5 algorithm.  Digest is 16 octets. */
+	FSL_HASH_ALG_SHA1,	/*!< SHA-1 (aka SHA or SHA-160) algorithm.
+				   Digest is 20 octets. */
+	FSL_HASH_ALG_SHA224,	/*!< SHA-224 algorithm.  Digest is 28 octets,
+				   though context is 32 octets. */
+	FSL_HASH_ALG_SHA256	/*!< SHA-256 algorithm.  Digest is 32
+				   octets. */
+} fsl_shw_hash_alg_t;
+
+/*!
+ * The type of Authentication-Cipher function which will be performed.
+ */
+typedef enum fsl_shw_acc_mode_t {
+	/*!
+	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+	 * be non-multiple of block size.  This mode may be used for AES.
+	 */
+	FSL_ACC_MODE_CCM,
+	/*!
+	 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+	 * Needs one key object for encryption, another for the HMAC.  The usual
+	 * hashing and symmetric encryption algorithms are supported.
+	 */
+	FSL_ACC_MODE_SSL,
+} fsl_shw_acc_mode_t;
+
+/*!
+ * The operation which controls the behavior of #fsl_shw_establish_key().
+ *
+ * These values are passed to #fsl_shw_establish_key().
+ */
+typedef enum fsl_shw_key_wrap_t {
+	FSL_KEY_WRAP_CREATE,	/*!< Generate a key from random values. */
+	FSL_KEY_WRAP_ACCEPT,	/*!< Use the provided clear key. */
+	FSL_KEY_WRAP_UNWRAP	/*!< Unwrap a previously wrapped key. */
+} fsl_shw_key_wrap_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Flags which control a Hash operation.
+ *
+ *  These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
+ * and #fsl_shw_hco_clear_flags().
+ */
+typedef enum fsl_shw_hash_ctx_flags_t {
+	FSL_HASH_FLAGS_INIT = 1,	/*!< Context is empty.  Hash is started
+					   from scratch, with a message-processed
+					   count of zero. */
+	FSL_HASH_FLAGS_SAVE = 2,	/*!< Retrieve context from hardware after
+					   hashing.  If used with the
+					   #FSL_HASH_FLAGS_FINALIZE flag, the final
+					   digest value will be saved in the
+					   object. */
+	FSL_HASH_FLAGS_LOAD = 4,	/*!< Place context into hardware before
+					   hashing. */
+	FSL_HASH_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final digest
+					   operation.  If user message is
+					   pre-padded, this flag should not be
+					   used. */
+} fsl_shw_hash_ctx_flags_t;
+
+/*!
+ * Flags which control an HMAC operation.
+ *
+ * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+ * and #fsl_shw_hmco_clear_flags().
+ */
+typedef enum fsl_shw_hmac_ctx_flags_t {
+	FSL_HMAC_FLAGS_INIT = 1,	/*!< Message context is empty.  HMAC is
+					   started from scratch (with key) or from
+					   precompute of inner hash, depending on
+					   whether
+					   #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
+					   set. */
+	FSL_HMAC_FLAGS_SAVE = 2,	/*!< Retrieve ongoing context from hardware
+					   after hashing.  If used with the
+					   #FSL_HMAC_FLAGS_FINALIZE flag, the final
+					   digest value (HMAC) will be saved in the
+					   object. */
+	FSL_HMAC_FLAGS_LOAD = 4,	/*!< Place ongoing context into hardware
+					   before hashing. */
+	FSL_HMAC_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final HMAC
+					   operations of inner and outer hashes. */
+	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16	/*!< This means that the context
+						   contains precomputed inner and outer
+						   hash values. */
+} fsl_shw_hmac_ctx_flags_t;
+
+/*!
+ * Flags to control use of the #fsl_shw_scco_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+ */
+typedef enum fsl_shw_sym_ctx_flags_t {
+	/*!
+	 * Context is empty.  In ARC4, this means that the S-Box needs to be
+	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+	 * initial CTR value of zero is desired.
+	 */
+	FSL_SYM_CTX_INIT = 1,
+	/*!
+	 * Load context from object into hardware before running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_LOAD = 2,
+	/*!
+	 * Save context from hardware into object after running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_SAVE = 4,
+	/*!
+	 * Context (SBox) is to be unwrapped and wrapped on each use.
+	 * This flag is unsupported.
+	 * */
+	FSL_SYM_CTX_PROTECT = 8,
+} fsl_shw_sym_ctx_flags_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_sko_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+ */
+typedef enum fsl_shw_key_flags_t {
+	FSL_SKO_KEY_IGNORE_PARITY = 1,	/*!< If algorithm is DES or 3DES, do not
+					   validate the key parity bits. */
+	FSL_SKO_KEY_PRESENT = 2,	/*!< Clear key is present in the object. */
+	FSL_SKO_KEY_ESTABLISHED = 4,	/*!< Key has been established for use.  This
+					   feature is not available for all
+					   platforms, nor for all algorithms and
+					   modes. */
+	FSL_SKO_KEY_SW_KEY = 8,	/*!< This key is for software use, and can
+				   be copied out of a keystore by its owner.
+				   The default is that they key is available
+				   only for hardware (or security driver)
+				   use. */
+} fsl_shw_key_flags_t;
+
+/*!
+ * Type of value which is associated with an established key.
+ */
+typedef uint64_t key_userid_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_acco_t.
+ *
+ * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+ * together, provide for a one-shot operation.
+ */
+typedef enum fsl_shw_auth_ctx_flags_t {
+	FSL_ACCO_CTX_INIT = 1,	/*!< Initialize Context(s) */
+	FSL_ACCO_CTX_LOAD = 2,	/*!< Load intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_SAVE = 4,	/*!< Save intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_FINALIZE = 8,	/*!< Create MAC during this operation. */
+	FSL_ACCO_NIST_CCM = 16,	/*!< Formatting of CCM input data is
+				   performed by calls to
+				   #fsl_shw_ccm_nist_format_ctr_and_iv() and
+				   #fsl_shw_ccm_nist_update_ctr_and_iv().  */
+} fsl_shw_auth_ctx_flags_t;
+
+/*!
+ *  Modulus Selector for CTR modes.
+ *
+ * The incrementing of the Counter value may be modified by a modulus.  If no
+ * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+ */
+typedef enum fsl_shw_ctr_mod_t {
+	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
+	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
+	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
+	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
+	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
+	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
+	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
+	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
+	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
+	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
+	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
+	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
+	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
+	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
+	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
+	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
+} fsl_shw_ctr_mod_t;
+
+/*!
+ * Permissions flags for Secure Partitions
+ *
+ * They currently map directly to the SCC2 hardware values, but this is not
+ * guarinteed behavior.
+ */
+typedef enum fsl_shw_permission_t {
+/*! SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+	FSL_PERM_NO_ZEROIZE,
+/*! SCM Access Permission: Enforce trusted key read in  */
+	FSL_PERM_TRUSTED_KEY_READ,
+/*! SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+	FSL_PERM_HD_S,
+/*! SCM Access Permission: Allow Read Access to  Host Domain */
+	FSL_PERM_HD_R,
+/*! SCM Access Permission: Allow Write Access to  Host Domain */
+	FSL_PERM_HD_W,
+/*! SCM Access Permission: Allow Execute Access to  Host Domain */
+	FSL_PERM_HD_X,
+/*! SCM Access Permission: Allow Read Access to Trusted Host Domain */
+	FSL_PERM_TH_R,
+/*! SCM Access Permission: Allow Write Access to Trusted Host Domain */
+	FSL_PERM_TH_W,
+/*! SCM Access Permission: Allow Read Access to Other/World Domain */
+	FSL_PERM_OT_R,
+/*! SCM Access Permission: Allow Write Access to Other/World Domain */
+	FSL_PERM_OT_W,
+/*! SCM Access Permission: Allow Execute Access to Other/World Domain */
+	FSL_PERM_OT_X,
+} fsl_shw_permission_t;
+
+/*!
+ * Select the cypher mode to use for partition cover/uncover operations.
+ *
+ * They currently map directly to the values used in the SCC2 driver, but this
+ * is not guarinteed behavior.
+ */
+typedef enum fsl_shw_cypher_mode_t {
+	FSL_SHW_CYPHER_MODE_ECB,	/*!< ECB mode */
+	FSL_SHW_CYPHER_MODE_CBC,	/*!< CBC mode */
+} fsl_shw_cypher_mode_t;
+
+/*!
+ * Which platform key should be presented for cryptographic use.
+ */
+typedef enum fsl_shw_pf_key_t {
+	FSL_SHW_PF_KEY_IIM,	/*!< Present fused IIM key */
+	FSL_SHW_PF_KEY_PRG,	/*!< Present Program key */
+	FSL_SHW_PF_KEY_IIM_PRG,	/*!< Present IIM ^ Program key */
+	FSL_SHW_PF_KEY_IIM_RND,	/*!< Present Random key */
+	FSL_SHW_PF_KEY_RND,	/*!< Present IIM ^ Random key */
+} fsl_shw_pf_key_t;
+
+/*!
+ * The various security tamper events
+ */
+typedef enum fsl_shw_tamper_t {
+	FSL_SHW_TAMPER_NONE,	/*!< No error detected */
+	FSL_SHW_TAMPER_WTD,	/*!< wire-mesh tampering det */
+	FSL_SHW_TAMPER_ETBD,	/*!< ext tampering det: input B */
+	FSL_SHW_TAMPER_ETAD,	/*!< ext tampering det: input A */
+	FSL_SHW_TAMPER_EBD,	/*!< external boot detected */
+	FSL_SHW_TAMPER_SAD,	/*!< security alarm detected */
+	FSL_SHW_TAMPER_TTD,	/*!< temperature tampering det */
+	FSL_SHW_TAMPER_CTD,	/*!< clock tampering det */
+	FSL_SHW_TAMPER_VTD,	/*!< voltage tampering det */
+	FSL_SHW_TAMPER_MCO,	/*!< monotonic counter overflow */
+	FSL_SHW_TAMPER_TCO,	/*!< time counter overflow */
+} fsl_shw_tamper_t;
+
+/*! @} *//* consgrp */
+
+/******************************************************************************
+ * Data Structures
+ *****************************************************************************/
+/*! @addtogroup strgrp
+    @{ */
+
+/* REQ-S2LRD-PINTFC-COA-IBO-001 */
+/*!
+ * Application Initialization Object
+ *
+ * This object, the operations on it, and its interaction with the driver are
+ * TBD.
+ */
+typedef struct fsl_sho_ibo_t {
+} fsl_sho_ibo_t;
+
+/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+/*!
+ * User Context Object
+ *
+ * This object must be initialized by a call to #fsl_shw_uco_init().  It must
+ * then be passed to #fsl_shw_register_user() before it can be used in any
+ * calls besides those in @ref ucoops.
+ *
+ * It contains the user's configuration for the API, for instance whether an
+ * operation should block, or instead should call back the user upon completion
+ * of the operation.
+ *
+ * See @ref ucoops for further information.
+ */
+typedef struct fsl_shw_uco_t {	/* fsl_shw_user_context_object */
+} fsl_shw_uco_t;
+
+/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+/*!
+ * Result Object
+ *
+ * This object will contain success and failure information about a specific
+ * cryptographic request which has been made.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref rops.
+ */
+typedef struct fsl_shw_result_t {	/* fsl_shw_result */
+} fsl_shw_result_t;
+
+/*!
+ * Keystore Object
+ *
+ * This object holds the context of a user keystore, including the functions
+ * that define the interface and pointers to where the key data is stored.  The
+ * user must supply a set of functions to handle keystore management, including
+ * slot allocation, deallocation, etc.  A default keystore manager is provided
+ * as part of the API.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref ksoops.
+ */
+typedef struct fsl_shw_kso_t {	/* fsl_shw_keystore_object */
+} fsl_shw_kso_t;
+
+/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+/*!
+ * Secret Key Object
+ *
+ * This object contains a key for a cryptographic operation, and information
+ * about its current state, its intended usage, etc.  It may instead contain
+ * information about a protected key, or an indication to use a platform-
+ * specific secret key.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref skoops.
+ */
+typedef struct fsl_shw_sko_t {	/* fsl_shw_secret_key_object */
+} fsl_shw_sko_t;
+
+/* REQ-S2LRD-PINTFC-COA-CO-001 */
+/*!
+ * Platform Capabilities Object
+ *
+ * This object will contain information about the cryptographic features of the
+ * platform which the program is running on.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.
+ *
+ * See @ref pcoops.
+ */
+typedef struct fsl_shw_pco_t {	/* fsl_shw_platform_capabilities_object */
+} fsl_shw_pco_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Hash Context Object
+ *
+ * This object contains information to control hashing functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hcops.
+ */
+typedef struct fsl_shw_hco_t {	/* fsl_shw_hash_context_object */
+} fsl_shw_hco_t;
+
+/*!
+ * HMAC Context Object
+ *
+ * This object contains information to control HMAC functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hmcops.
+ */
+typedef struct fsl_shw_hmco_t {	/* fsl_shw_hmac_context_object */
+} fsl_shw_hmco_t;
+
+/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+/*!
+ * Symmetric Cipher Context Object
+ *
+ * This object contains information to control Symmetric Ciphering encrypt and
+ * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
+ * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
+ * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
+ * CCM mode is controlled with the #fsl_shw_acco_t object.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref sccops.
+ */
+typedef struct fsl_shw_scco_t {	/* fsl_shw_symmetric_cipher_context_object */
+} fsl_shw_scco_t;
+
+/*!
+ * Authenticate-Cipher Context Object
+
+ * An object for controlling the function of, and holding information about,
+ * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+ * #fsl_shw_auth_decrypt().
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref
+ * accoops.
+ */
+typedef struct fsl_shw_acco_t {	/* fsl_shw_authenticate_cipher_context_object */
+} fsl_shw_acco_t;
+	  /*! @} *//* strgrp */
+
+/******************************************************************************
+ * Access Macros for Objects
+ *****************************************************************************/
+/*! @addtogroup pcoops
+    @{ */
+
+/*!
+ * Get FSL SHW API version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the API is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the API is to be stored.
+ */
+void fsl_shw_pco_get_version(const fsl_shw_pco_t * pc_info,
+			     uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get underlying driver version.
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the driver is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the driver is to be stored.
+ */
+void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t * pc_info,
+				    uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get list of symmetric algorithms supported.
+ *
+ * @param pc_info   The Platform Capabilities Object to query.
+ * @param[out] algorithms A pointer to where to store the location of
+ *                        the list of algorithms.
+ * @param[out] algorithm_count A pointer to where to store the number of
+ *                             algorithms in the list at @a algorithms.
+ */
+void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t * algorithms[],
+				    uint8_t * algorithm_count);
+
+/*!
+ * Get list of symmetric modes supported.
+ *
+ * @param pc_info         The Platform Capabilities Object to query.
+ * @param[out] modes      A pointer to where to store the location of
+ *                        the list of modes.
+ * @param[out] mode_count A pointer to where to store the number of
+ *                        algorithms in the list at @a modes.
+ */
+void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t * pc_info,
+			       fsl_shw_sym_mode_t * modes[],
+			       uint8_t * mode_count);
+
+/*!
+ * Get list of hash algorithms supported.
+ *
+ * @param pc_info         The Platform Capabilities Object to query.
+ * @param[out] algorithms A pointer which will be set to the list of
+ *                        algorithms.
+ * @param[out] algorithm_count The number of algorithms in the list at @a
+ *                             algorithms.
+ */
+void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_hash_alg_t * algorithms[],
+				     uint8_t * algorithm_count);
+
+/*!
+ * Determine whether the combination of a given symmetric algorithm and a given
+ * mode is supported.
+ *
+ * @param pc_info    The Platform Capabilities Object to query.
+ * @param algorithm  A Symmetric Cipher algorithm.
+ * @param mode       A Symmetric Cipher mode.
+ *
+ * @return 0 if combination is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t algorithm,
+				    fsl_shw_sym_mode_t mode);
+
+/*!
+ * Determine whether a given Encryption-Authentication mode is supported.
+ *
+ * @param pc_info   The Platform Capabilities Object to query.
+ * @param mode       The Authentication mode.
+ *
+ * @return 0 if mode is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_acc_mode_t mode);
+
+/*!
+ * Determine whether Black Keys (key establishment / wrapping) is supported.
+ *
+ * @param pc_info  The Platform Capabilities Object to query.
+ *
+ * @return 0 if wrapping is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get FSL SHW SCC driver version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
+void fsl_shw_pco_get_scc_driver_version(const fsl_shw_pco_t * pc_info,
+					uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get SCM hardware version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The SCM hardware version
+ */
+uint32_t fsl_shw_pco_get_scm_version(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get SMN hardware version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The SMN hardware version
+ */
+uint32_t fsl_shw_pco_get_smn_version(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the size of an SCM block, in bytes
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
+uint32_t fsl_shw_pco_get_scm_block_size(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pc_info     The Platform Capabilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in
+ *                         blocks, is to be placed.
+ */
+void fsl_shw_pco_get_smn_size(const fsl_shw_pco_t * pc_info,
+			      uint32_t * black_size, uint32_t * red_size);
+
+/*!
+ * Determine whether Secure Partitions are supported
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return 0 if secure partitions are not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_spo_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the size of a Secure Partitions
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+ */
+uint32_t fsl_shw_pco_get_spo_size_bytes(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the number of Secure Partitions on this platform
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return Number of partitions. 0 if Secure Partitions not supported.  Note
+ *         that this returns the total number of partitions, though
+ *         not all may be available to the user.
+ */
+uint32_t fsl_shw_pco_get_spo_count(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Determine whether Platform Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Programmed Key features are available, otherwise zero.
+ */
+int fsl_shw_pco_check_pk_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+  * Determine whether Software Key features are available
+  *
+  * @param pc_info 		 The Platform Capabilities Object to query.
+  *
+  * @return  1 if Software key features are available, otherwise zero.
+  */
+int fsl_shw_pco_check_sw_keys_supported(const fsl_shw_pco_t * pc_info);
+
+/*! @} *//* pcoops */
+
+/*! @addtogroup ucoops
+    @{ */
+
+/*!
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param pool_size    The maximum number of operations which can be
+ *                     outstanding.
+ */
+void fsl_shw_uco_init(fsl_shw_uco_t * user_ctx, uint16_t pool_size);
+
+/*!
+ * Set the User Reference for the User Context.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param reference    A value which will be passed back with a result.
+ */
+void fsl_shw_uco_set_reference(fsl_shw_uco_t * user_ctx, uint32_t reference);
+
+/*!
+ * Set the callback routine for the User Context.
+ *
+ * Note that the callback routine may be called when no results are available,
+ * and possibly even when no requests are outstanding.
+ *
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param callback_fn  The function the API will invoke when an operation
+ *                     completes.
+ */
+void fsl_shw_uco_set_callback(fsl_shw_uco_t * user_ctx,
+			      void (*callback_fn) (fsl_shw_uco_t * uco));
+
+/*!
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_set_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_clear_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+/*!
+ * Select a key for the key-wrap key for key wrapping/unwrapping
+ *
+ * Without a call to this function, default is FSL_SHW_PF_KEY_IIM.  The wrap
+ * key is used to encrypt and decrypt the per-key random secret which is used
+ * to calculate the key which will encrypt/decrypt the user's key.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param pf_key       Which key to use.  Valid choices are
+ *                     #FSL_SHW_PF_KEY_IIM, #FSL_SHW_PF_KEY_RND, and
+ *                     #FSL_SHW_PF_KEY_IIM_RND.
+ */
+void fsl_shw_uco_set_wrap_key(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_pf_key_t pf_key);
+
+	  /*! @} *//* ucoops */
+
+/*! @addtogroup rops
+    @{ */
+
+/*!
+ * Retrieve the status code from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The status of the request.
+ */
+fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t * result);
+
+/*!
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t * result);
+
+	 /* @} *//* rops */
+
+/*! @addtogroup skoops
+    @{ */
+
+/*!
+ * Initialize a Secret Key Object.
+ *
+ * This function or #fsl_shw_sko_init_pf_key() must be called before performing
+ * any other operation with the Object.
+ *
+ * @param key_info  The Secret Key Object to be initialized.
+ * @param algorithm DES, AES, etc.
+ *
+ */
+void fsl_shw_sko_init(fsl_shw_sko_t * key_info, fsl_shw_key_alg_t algorithm);
+
+/*!
+ * Initialize a Secret Key Object to use a Platform Key register.
+ *
+ * This function or #fsl_shw_sko_init() must be called before performing any
+ * other operation with the Object.  #fsl_shw_sko_set_key() does not work on
+ * a key object initialized in this way.
+ *
+ * If this function is used to initialize the key object, but no key is
+ * established with the key object, then the object will refer strictly to the
+ * key value specified by the @c pf_key selection.
+ *
+ * If the pf key is #FSL_SHW_PF_KEY_PRG or #FSL_SHW_PF_KEY_IIM_PRG, then the
+ * key object may be used with #fsl_shw_establish_key() to change the Program
+ * Key value.  When the pf key is neither #FSL_SHW_PF_KEY_PRG nor
+ * #FSL_SHW_PF_KEY_IIM_PRG, it is an error to call #fsl_shw_establish_key().
+ *
+ * @param key_info     The Secret Key Object to be initialized.
+ * @param algorithm    DES, AES, etc.
+ * @param pf_key       Which platform key is referenced.
+ */
+void fsl_shw_sko_init_pf_key(fsl_shw_sko_t * key_info,
+			     fsl_shw_key_alg_t algorithm,
+			     fsl_shw_pf_key_t pf_key);
+
+/*!
+ * Store a cleartext key in the key object.
+ *
+ * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag. It should
+ * not be used if there is a key established with the key object.  If there is,
+ * a call to #fsl_shw_release_key() should be made first.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key          A pointer to the beginning of the key.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key(fsl_shw_sko_t * key_object,
+			 const uint8_t * key, uint16_t key_length);
+
+/*!
+ * Set a size for the key.
+ *
+ * This function would normally be used when the user wants the key to be
+ * generated from a random source.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key_length(fsl_shw_sko_t * key_object,
+				uint16_t key_length);
+
+/*!
+ * Set the User ID associated with the key.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to identify authorized users of the key.
+ */
+void fsl_shw_sko_set_user_id(fsl_shw_sko_t * key_object, key_userid_t userid);
+
+/*!
+ * Set the keystore that the key will be stored in.
+ *
+ * @param key_object    A variable of type #fsl_shw_sko_t.
+ * @param keystore      The keystore to place the key in.  This is a variable of
+ *                      type #fsl_shw_kso_t.
+ */
+void fsl_shw_sko_set_keystore(fsl_shw_sko_t * key_object,
+			      fsl_shw_kso_t * keystore);
+
+/*!
+ * Set the establish key handle into a key object.
+ *
+ * The @a userid field will be used to validate the access to the unwrapped
+ * key.  This feature is not available for all platforms, nor for all
+ * algorithms and modes.
+ *
+ * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
+ * flag will be cleared).
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to verify this user is an authorized user of
+ *                     the key.
+ * @param handle       A @a handle from #fsl_shw_sko_get_established_info.
+ */
+void fsl_shw_sko_set_established_info(fsl_shw_sko_t * key_object,
+				      key_userid_t userid, uint32_t handle);
+
+/*!
+ * Extract the algorithm from a key object.
+ *
+ * @param      key_info  The Key Object to be queried.
+ * @param[out] algorithm A pointer to the location to store the algorithm.
+ */
+void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t * key_info,
+			       fsl_shw_key_alg_t * algorithm);
+
+/*!
+ * Retrieve the cleartext key from a key object that is stored in a user
+ * keystore.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skkey        A pointer to the location to store the key.  NULL
+ *                          if the key is not stored in a user keystore.
+ */
+void fsl_shw_sko_get_key(const fsl_shw_sko_t * skobject, void *skkey);
+
+/*!
+ * Retrieve the established-key handle from a key object.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param handle       The location to store the @a handle of the unwrapped
+ *                     key.
+ */
+void fsl_shw_sko_get_established_info(fsl_shw_sko_t * key_object,
+				      uint32_t * handle);
+
+/*!
+ * Determine the size of a wrapped key based upon the cleartext key's length.
+ *
+ * This function can be used to calculate the number of octets that
+ * #fsl_shw_extract_key() will write into the location at @a covered_key.
+ *
+ * If zero is returned at @a length, this means that the key length in
+ * @a key_info is not supported.
+ *
+ * @param      key_info         Information about a key to be wrapped.
+ * @param      length           Location to store the length of a wrapped
+ *                              version of the key in @a key_info.
+ */
+void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t * key_info,
+					uint32_t * length);
+
+/*!
+ * Set some flags in the key object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                     are to be set.
+ */
+void fsl_shw_sko_set_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+/*!
+ * Clear some flags in the key object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                      are to be reset.
+ */
+void fsl_shw_sko_clear_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+	  /*! @} *//* end skoops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hcops
+    @{ */
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
+/*!
+ * Initialize a Hash Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the hash
+ * context object.
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hco_init(fsl_shw_hco_t * hash_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
+/*!
+ * Get the current hash value and message length from the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] digest    Pointer to the location of @a length octets where to
+ *                       store a copy of the current value of the digest.
+ * @param      length    Number of octets of hash value to copy.
+ * @param[out] msg_length Pointer to the location to store the number of octets
+ *                        already hashed.
+ */
+void fsl_shw_hco_get_digest(const fsl_shw_hco_t * hash_ctx, uint8_t * digest,
+			    uint8_t length, uint32_t * msg_length);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
+/*!
+ * Get the hash algorithm from the hash context object.
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] algorithm Pointer to where the algorithm is to be stored.
+ */
+void fsl_shw_hco_get_info(const fsl_shw_hco_t * hash_ctx,
+			  fsl_shw_hash_alg_t * algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
+/*!
+ * Set the current hash value and message length in the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      context   Pointer to buffer of appropriate length to copy into
+ *                       the hash context object.
+ * @param      msg_length The number of octets of the message which have
+ *                        already been hashed.
+ *
+ */
+void fsl_shw_hco_set_digest(fsl_shw_hco_t * hash_ctx, const uint8_t * context,
+			    uint32_t msg_length);
+
+/*!
+ * Set flags in a Hash Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_set_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in a Hash Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_clear_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+	  /*! @} *//* end hcops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hmcops
+    @{ */
+
+/*!
+ * Initialize an HMAC Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the HMAC
+ * context object.
+ *
+ * @param      hmac_ctx  The HMAC context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hmco_init(fsl_shw_hmco_t * hmac_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*!
+ * Set flags in an HMAC Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_set_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in an HMAC Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*! @} */
+
+/*****************************************************************************/
+
+/*! @addtogroup sccops
+    @{ */
+
+/*!
+ * Initialize a Symmetric Cipher Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  This will set the @a mode and @a algorithm and initialize the
+ * Object.
+ *
+ * @param sym_ctx   The context object to operate on.
+ * @param algorithm The cipher algorithm this context will be used with.
+ * @param mode      #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+ *
+ */
+void fsl_shw_scco_init(fsl_shw_scco_t * sym_ctx,
+		       fsl_shw_key_alg_t algorithm, fsl_shw_sym_mode_t mode);
+
+/*!
+ * Set the flags for a Symmetric Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_set_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Clear some flags in a Symmetric Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_clear_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Set the Context (IV) for a Symmetric Cipher Context.
+ *
+ * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+ * context (the S-Box and pointers) for ARC4.  The full context size will
+ * be copied.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param context  A pointer to the buffer which contains the context.
+ *
+ */
+void fsl_shw_scco_set_context(fsl_shw_scco_t * sym_ctx, uint8_t * context);
+
+/*!
+ * Get the Context for a Symmetric Cipher Context.
+ *
+ * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+ * retrieve context (the S-Box and pointers) for ARC4.  The full context
+ * will be copied.
+ *
+ * @param      sym_ctx  The context object to operate on.
+ * @param[out] context  Pointer to location where context will be stored.
+ */
+void fsl_shw_scco_get_context(const fsl_shw_scco_t * sym_ctx,
+			      uint8_t * context);
+
+/*!
+ * Set the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will set the Counter Value for CTR mode.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param counter  The starting counter value.  The number of octets.
+ *                 copied will be the block size for the algorithm.
+ * @param modulus  The modulus for controlling the incrementing of the counter.
+ *
+ */
+void fsl_shw_scco_set_counter_info(fsl_shw_scco_t * sym_ctx,
+				   const uint8_t * counter,
+				   fsl_shw_ctr_mod_t modulus);
+
+/*!
+ * Get the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will retrieve the Counter Value is for CTR mode.
+ *
+ * @param sym_ctx         The context object to query.
+ * @param[out] counter    Pointer to location to store the current counter
+ *                        value.  The number of octets copied will be the
+ *                        block size for the algorithm.
+ * @param[out] modulus    Pointer to location to store the modulus.
+ *
+ */
+void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t * sym_ctx,
+				   uint8_t * counter,
+				   fsl_shw_ctr_mod_t * modulus);
+
+	  /*! @} *//* end sccops */
+
+/*****************************************************************************/
+
+/*! @addtogroup accoops
+    @{ */
+
+/*!
+ * Initialize a Authentication-Cipher Context.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param mode         The mode for this object (only #FSL_ACC_MODE_CCM
+ *                     supported).
+ */
+void fsl_shw_acco_init(fsl_shw_acco_t * auth_object, fsl_shw_acc_mode_t mode);
+
+/*!
+ * Set the flags for a Authentication-Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to set (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_set_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Clear some flags in a Authentication-Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to reset (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_clear_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Set up the Authentication-Cipher Object for CCM mode.
+ *
+ * This will set the @a auth_object for CCM mode and save the @a ctr,
+ * and @a mac_length.  This function can be called instead of
+ * #fsl_shw_acco_init().
+ *
+ * The parameter @a ctr is Counter Block 0, (counter value 0), which is for the
+ * MAC.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param algorithm    Cipher algorithm.  Only AES is supported.
+ * @param ctr          The initial counter value.
+ * @param mac_length   The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ */
+void fsl_shw_acco_set_ccm(fsl_shw_acco_t * auth_object,
+			  fsl_shw_key_alg_t algorithm,
+			  const uint8_t * ctr, uint8_t mac_length);
+
+/*!
+ * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will also set the IV and CTR values per Appendix A of NIST
+ * Special Publication 800-38C (May 2004).  It will also perform the
+ * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+ * parameters.
+ *
+ * Note this function assumes the algorithm is AES.  It initializes the
+ * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+ * flags to be #FSL_ACCO_NIST_CCM.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param t_length     The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ * @param ad_length    Number of octets of Associated Data (may be zero).
+ * @param q_length     A value for the size of the length of @a q field.  Valid
+ *                     values are 1-8.
+ * @param n            The Nonce (packet number or other changing value). Must
+ *                     be (15 - @a q_length) octets long.
+ * @param q            The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					uint8_t t_length,
+					uint32_t ad_length,
+					uint8_t q_length,
+					const uint8_t * n, uint32_t q);
+
+/*!
+ * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will set the IV and CTR values per Appendix A of NIST Special
+ * Publication 800-38C (May 2004).
+ *
+ * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+ * previously been called on the @a auth_object.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param n             The Nonce (packet number or other changing value). Must
+ *                      be (15 - @a q_length) octets long.
+ * @param q             The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					const uint8_t * n, uint32_t q);
+
+	 /* @} *//* accoops */
+
+/******************************************************************************
+ * Library functions
+ *****************************************************************************/
+
+/*! @addtogroup miscfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+/*!
+ * Determine the hardware security capabilities of this platform.
+ *
+ * Though a user context object is passed into this function, it will always
+ * act in a non-blocking manner.
+ *
+ * @param  user_ctx   The user context which will be used for the query.
+ *
+ * @return  A pointer to the capabilities object.
+ */
+extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+/*!
+ * Create an association between the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which will be used for this association.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+/*!
+ * Destroy the association between the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which is no longer needed.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+/*!
+ * Retrieve results from earlier operations.
+ *
+ * @param         user_ctx     The user's context.
+ * @param         result_size  The number of array elements of @a results.
+ * @param[in,out] results      Pointer to first of the (array of) locations to
+ *                             store results.
+ * @param[out]    result_count Pointer to store the number of results which
+ *                             were returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+					    uint16_t result_size,
+					    fsl_shw_result_t results[],
+					    uint16_t * result_count);
+
+/*!
+ * Allocate a block of secure memory
+ *
+ * @param       user_ctx        User context
+ * @param       size            Memory size (octets).  Note: currently only
+ *                              supports only single-partition sized blocks.
+ * @param       UMID            User Mode ID to use when registering the
+ *                              partition.
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return                      Address of the allocated memory.  NULL if the
+ *                              call was not successful.
+ */
+extern void *fsl_shw_smalloc(fsl_shw_uco_t * user_ctx,
+			     uint32_t size,
+			     const uint8_t * UMID, uint32_t permissions);
+
+/*!
+ * Free a block of secure memory that was allocated with #fsl_shw_smalloc
+ *
+ * @param       user_ctx        User context
+ * @param       address         Address of the block of secure memory to be
+ *                              released.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t * user_ctx, void *address);
+
+/*!
+ * Diminish the permissions of a block of secure memory.  Note that permissions
+ * can only be revoked.
+ *
+ * @param       user_ctx        User context
+ * @param       address         Base address of the secure memory to work with
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t * user_ctx,
+					       void *address,
+					       uint32_t permissions);
+
+/*!
+ * @brief   Encrypt a region of secure memory using the hardware secret key
+ *
+ * @param       user_ctx        User context
+ * @param       partition_base  Base address of the partition
+ * @param       offset_bytes    Offset of data from the partition base
+ * @param       byte_count      Length of the data to encrypt
+ * @param       black_data      Location to store the encrypted data
+ * @param       IV              IV to use for the encryption routine
+ * @param       cypher_mode     Cyphering mode to use, specified by type
+ *                              #fsl_shw_cypher_mode_t
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+/*!
+ * @brief   Decrypt a region of secure memory using the hardware secret key
+ *
+ * @param       user_ctx        User context
+ * @param       partition_base  Base address of the partition
+ * @param       offset_bytes    Offset of data from the partition base
+ * @param       byte_count      Length of the data to encrypt
+ * @param       black_data      Location to store the encrypted data
+ * @param       IV              IV to use for the encryption routine
+ * @param       cypher_mode     Cyphering mode to use, specified by type
+ *                              #fsl_shw_cypher_mode_t
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, const uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+	  /*! @} *//* miscfuns */
+
+/*! @addtogroup opfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Encrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the init & save flags flags on in
+ * the @a sym_ctx.  Subsequent operations would then run as normal with the
+ * load and save flags.  Note that they key object is still required.
+ *
+ * @param         user_ctx  A user context from #fsl_shw_register_user().
+ * @param         key_info  Key and algorithm  being used for this operation.
+ * @param[in,out] sym_ctx   Info on cipher mode, state of the cipher.
+ * @param         length   Length, in octets, of the pt (and ct).
+ * @param         pt       pointer to plaintext to be encrypted.
+ * @param[out]    ct       pointer to where to store the resulting ciphertext.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * pt,
+						  uint8_t * ct);
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Decrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
+ * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
+ * then run as normal with the load & save flags.  Note that they key object is
+ * still required.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info The key and algorithm being used in this operation.
+ * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
+ * @param      length   Length, in octets, of the ct (and pt).
+ * @param      ct       pointer to ciphertext to be decrypted.
+ * @param[out] pt       pointer to where to store the resulting plaintext.
+ *
+ * @return    A return code of type #fsl_shw_return_t
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * ct,
+						  uint8_t * pt);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+/*!
+ * Hash a stream of data with a cryptographic hash algorithm.
+ *
+ * The flags in the @a hash_ctx control the operation of this function.
+ *
+ * Hashing functions work on 64 octets of message at a time.  Therefore, when
+ * any partial hashing of a long message is performed, the message @a length of
+ * each segment must be a multiple of 64.  When ready to
+ * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+ *
+ * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+ * one-shot complete hash, including padding, will be performed.  The @a length
+ * may be any value.
+ *
+ * The first octets of a data stream can be hashed by setting the
+ * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+ * a multiple of 64.
+ *
+ * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+ * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+ * octets) 'middle sequence' of the data stream to be hashed with the
+ * beginning.  The @a length must again be a multiple of 64.
+ *
+ * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+ * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+ * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+ * stream.  The @a length may be any value.
+ *
+ * If the user program wants to do the padding for the hash, it can leave off
+ * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+ * 64 octets.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+ * @param      msg       Pointer to the data to be hashed.
+ * @param      length    Length, in octets, of the @a msg.
+ * @param[out] result    If not null, pointer to where to store the hash
+ *                       digest.
+ * @param      result_len Number of octets to store in @a result.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_hco_t * hash_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+/*!
+ * Precompute the Key hashes for an HMAC operation.
+ *
+ * This function may be used to calculate the inner and outer precomputes,
+ * which are the hash contexts resulting from hashing the XORed key for the
+ * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
+ *
+ * After execution of this function, the @a hmac_ctx will contain the
+ * precomputed inner and outer contexts, so that they may be used by
+ * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
+ * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.  In addition, the
+ * #FSL_HMAC_FLAGS_INIT flag will be set.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info  The key being used in this operation.  Key must be
+ *                       1 to 64 octets long.
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                         algorithm, the operation of this function.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						fsl_shw_hmco_t * hmac_ctx);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+/*!
+ * Continue, finalize, or one-shot an HMAC operation.
+ *
+ * There are a number of ways to use this function.  The flags in the
+ * @a hmac_ctx object will determine what operations occur.
+ *
+ * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
+ * the @a key_info, or from the precomputed inner hash value in the
+ * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
+ *
+ * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
+ * from the ongoing inner hash computation in the @a hmac_ctx.
+ *
+ * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
+ * the outer hash will be performed, and the @a result will be generated.
+ *
+ * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
+ * value will be stored in the ongoing inner hash computation field of the @a
+ * hmac_ctx.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param key_info       If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
+ *                       this is the key being used in this operation, and the
+ *                       IPAD.  If #FSL_HMAC_FLAGS_INIT is set in the @a
+ *                       hmac_ctx and @a key_info is NULL, then
+ *                       #fsl_shw_hmac_precompute() has been used to populate
+ *                       the @a inner_precompute and @a outer_precompute
+ *                       contexts.  If #FSL_HMAC_FLAGS_INIT is not set, this
+ *                       parameter is ignored.
+
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                       algorithm, the operation of this function.
+ * @param      msg               Pointer to the message to be hashed.
+ * @param      length            Length, in octets, of the @a msg.
+ * @param[out] result            Pointer, of @a result_len octets, to where to
+ *                               store the HMAC.
+ * @param      result_len        Length of @a result buffer.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     fsl_shw_hmco_t * hmac_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Get random data.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    The number of octets of @a data being requested.
+ * @param[out] data      A pointer to a location of @a length octets to where
+ *                       random data will be returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+					   uint32_t length, uint8_t * data);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Add entropy to random number generator.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    Number of bytes at @a data.
+ * @param      data      Entropy to add to random number generator.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+					    uint32_t length, uint8_t * data);
+
+/*!
+ * Perform Generation-Encryption by doing a Cipher and a Hash.
+ *
+ * Generate the authentication value @a auth_value as well as encrypt the @a
+ * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
+ * the @a auth_data and the total message @a payload must passed in one call.
+ * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
+ * and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not encrypted.
+ * @param      payload_length   Length, in octets, of @a payload.
+ * @param      payload          Pointer to the plaintext to be encrypted.
+ * @param[out] ct               Pointer to the where the encrypted @a payload
+ *                              will be stored.  Must be @a payload_length
+ *                              octets long.
+ * @param[out] auth_value       Pointer to where the generated authentication
+ *                              field will be stored. Must be as many octets as
+ *                              indicated by MAC length in the @a function_ctx.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_acco_t * auth_ctx,
+					    fsl_shw_sko_t * cipher_key_info,
+					    fsl_shw_sko_t * auth_key_info,
+					    uint32_t auth_data_length,
+					    const uint8_t * auth_data,
+					    uint32_t payload_length,
+					    const uint8_t * payload,
+					    uint8_t * ct, uint8_t * auth_value);
+
+/*!
+ * Perform Authentication-Decryption in Cipher + Hash.
+ *
+ * This function will perform a one-shot decryption of a data stream as well as
+ * authenticate the authentication value.  This is a one-shot function, so all
+ * of the @a auth_data and the total message @a payload must passed in one
+ * call.  This also means that the flags in the @a auth_ctx must be
+ * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not decrypted.
+ * @param      payload_length   Length, in octets, of @a ct and @a pt.
+ * @param      ct               Pointer to the encrypted input stream.
+ * @param      auth_value       The (encrypted) authentication value which will
+ *                              be authenticated.  This is the same data as the
+ *                              (output) @a auth_value argument to
+ *                              #fsl_shw_gen_encrypt().
+ * @param[out] payload          Pointer to where the plaintext resulting from
+ *                              the decryption will be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+					     fsl_shw_acco_t * auth_ctx,
+					     fsl_shw_sko_t * cipher_key_info,
+					     fsl_shw_sko_t * auth_key_info,
+					     uint32_t auth_data_length,
+					     const uint8_t * auth_data,
+					     uint32_t payload_length,
+					     const uint8_t * ct,
+					     const uint8_t * auth_value,
+					     uint8_t * payload);
+
+/*!
+ * Establish the key in a protected location, which can be the system keystore,
+ * user keystore, or (on platforms that support it) as a Platform Key.
+ *
+ * By default, keys initialized with #fsl_shw_sko_init() will be placed into
+ * the system keystore.  The user can cause the key to be established in a
+ * user keystore by first calling #fsl_shw_sko_set_keystore() on the key.
+ * Normally, keys in the system keystore can only be used for hardware
+ * encrypt or decrypt operations, however if the #FSL_SKO_KEY_SW_KEY flag is
+ * applied using #fsl_shw_sko_set_flags(), the key will be established as a
+ * software key, which can then be read out using #fsl_shw_read_key().
+ *
+ * Keys initialized with #fsl_shw_sko_init_pf_key() are established as a
+ * Platform Key.  Their use is covered in @ref di_sec.
+ *
+ * This function only needs to be used when unwrapping a key, setting up a key
+ * which could be wrapped with a later call to #fsl_shw_extract_key(), or
+ * setting up a key as a Platform Key.  Normal cleartext keys can simply be
+ * placed into #fsl_shw_sko_t key objects with #fsl_shw_sko_set_key() and used
+ * directly.
+ *
+ * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
+ * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
+ * key based on SHA-256.)  The key size is determined by the @a key_info.  The
+ * expected length of @a key can be determined by
+ * #fsl_shw_sko_calculate_wrapped_size()
+ *
+ * The protected key will not be available for use until this operation
+ * successfully completes.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be established.  In the create case, the key
+ *                              length must be set.
+ * @param      establish_type   How @a key will be interpreted to establish a
+ *                              key for use.
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ *                              this is the location of a wrapped key.  If
+ *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
+ *                              parameter can be @a NULL.  If @a establish_type
+ *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
+ *                              of a plaintext key.
+ */
+extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+					      fsl_shw_sko_t * key_info,
+					      fsl_shw_key_wrap_t establish_type,
+					      const uint8_t * key);
+
+/*!
+ * Read the key value from a key object.
+ *
+ * Only a key marked as a software key (#FSL_SKO_KEY_SW_KEY) can be read with
+ * this call.  It has no effect on the status of the key store.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The referenced key.
+ * @param[out] key              The location to store the key value.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 uint8_t * key);
+
+/*!
+ * Wrap a key and retrieve the wrapped value.
+ *
+ * A wrapped key is a key that has been cryptographically obscured.  It is
+ * only able to be used with keys that have been established by
+ * #fsl_shw_establish_key().
+ *
+ * For keys established in the system or user keystore, this function will
+ * also release the key (see #fsl_shw_release_key()) so that it must be re-
+ * established before reuse.  This function will not release keys that are
+ * established as a Platform Key, so a call to #fsl_shw_release_key() is
+ * necessary to release those keys.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ * @param[out] covered_key      The location to store the wrapped key.
+ *                              (This size is based upon the maximum key size
+ *                              of 32 octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info,
+					    uint8_t * covered_key);
+
+/*!
+ * De-establish a key so that it can no longer be accessed.
+ *
+ * The key will need to be re-established before it can again be used.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info);
+
+/*!
+ * Cause the hardware to create a new random key for use by the secure memory
+ * encryption hardware.
+ *
+ * Have the hardware use the secure hardware random number generator to load a
+ * new secret key into the system's Random Key register.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t * user_ctx);
+
+/*!
+ * Retrieve the detected tamper event.
+ *
+ * Note that if more than one event was detected, this routine will only ever
+ * return one of them.
+ *
+ * @param[in]  user_ctx         A user context from #fsl_shw_register_user().
+ * @param[out] tamperp          Location to store the tamper information.
+ * @param[out] timestampp       Locate to store timestamp from hardwhare when
+ *                              an event was detected.
+ *
+ *
+ * @return    A return code of type #fsl_shw_return_t (for instance, if the platform
+ *            is not in a fail state.
+ */
+extern fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_tamper_t * tamperp,
+						  uint64_t * timestampp);
+
+/*! @} *//* opfuns */
+
+/* Insert example code into the API documentation. */
+
+/*!
+ * @example apitest.c
+ */
+
+/*!
+ * @example sym.c
+ */
+
+/*!
+ * @example rand.c
+ */
+
+/*!
+ * @example hash.c
+ */
+
+/*!
+ * @example hmac1.c
+ */
+
+/*!
+ * @example hmac2.c
+ */
+
+/*!
+ * @example gen_encrypt.c
+ */
+
+/*!
+ * @example auth_decrypt.c
+ */
+
+/*!
+ * @example wrapped_key.c
+ */
+
+/*!
+ * @example smalloc.c
+ */
+
+/*!
+ * @example user_keystore.c
+ */
+
+/*!
+ * @example dryice.c
+ */
+
+#endif				/* API_DOC */
+
+#endif				/* FSL_SHW_H */
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
new file mode 100644
index 0000000..4af6b78
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#ifndef FSL_SHW_KEYSTORE_H
+#define FSL_SHW_KEYSTORE_H
+
+/*!
+ * @file fsl_shw_keystore.h
+ *
+ * @brief Definition of the User Keystore API.
+ *
+ */
+
+/*! \page user_keystore User Keystore API
+ *
+ * Definition of the User Keystore API.
+ *
+ * On platforms with multiple partitions of Secure Memory, the Keystore Object
+ * (#fsl_shw_kso_t) is provided to allow users to manage a private keystore for
+ * use in software cryptographic routines.  The user can define a custom set of
+ * methods for managing their keystore, or use a default keystore handler.  The
+ * keystore is established by #fsl_shw_establish_keystore(), and released by
+ * #fsl_shw_release_keystore().  The intent of this design is to make the
+ * keystore implementation as flexible as possible.
+ *
+ * See @ref keystore_api for the generic keystore API, and @ref
+ * default_keystore for the default keystore implementation.
+ *
+ */
+
+/*!
+ * @defgroup keystore_api User Keystore API
+ *
+ * Keystore API
+ *
+ * These functions define the generic keystore API, which can be used in
+ * conjunction with a keystore implementation backend to support a user
+ * keystore.
+ */
+
+/*!
+ * @defgroup default_keystore Default Keystore Implementation
+ *
+ * Default Keystore Implementation
+ *
+ * These functions define the default keystore implementation, which is used
+ * for the system keystore and for user keystores initialized by
+ * #fsl_shw_init_keystore_default().  They can be used as-is or as a reference
+ * for creating a custom keystore handler.  It uses an entire Secure Memory
+ * partition, divided in to equal slots of length #KEYSTORE_SLOT_SIZE.  These
+ * functions are not intended to be used directly-  all user interaction with
+ * the keystore should be through the @ref keystore_api and the Wrapped Key
+ * interface.
+ *
+ * The current implementation is designed to work with both SCC and SCC2.
+ * Differences between the two versions are noted below.
+ */
+
+/*! @addtogroup keystore_api
+    @{ */
+
+#ifndef KEYSTORE_SLOT_SIZE
+/*! Size of each key slot, in octets.  This sets an upper bound on the size
+ * of a key that can placed in the keystore.
+ */
+#define KEYSTORE_SLOT_SIZE 32
+#endif
+
+/*!
+ * Initialize a Keystore Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object. It allows the user to associate a custom keystore interface by
+ * specifying the correct set of functions that will be used to perform actions
+ * on the keystore object.  To use the default keystore handler, the function
+ * #fsl_shw_init_keystore_default() can be used instead.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param data_init     Keystore initialization function.  This function is
+ *                      responsible for initializing the keystore.  A
+ *                      user-defined object can be assigned to the user_data
+ *                      pointer, and will be passed to any function acting on
+ *                      that keystore.  It is called during
+ *                      #fsl_shw_establish_keystore().
+ * @param data_cleanup  Keystore cleanup function.  This function cleans up
+ *                      any data structures associated with the keyboard.  It
+ *                      is called by #fsl_shw_release_keystore().
+ * @param slot_alloc    Slot allocation function.  This function allocates a
+ *                      key slot, potentially based on size and owner id.  It
+ *                      is called by #fsl_shw_establish_key().
+ * @param slot_dealloc  Slot deallocation function.
+ * @param slot_verify_access Function to verify that a given Owner ID
+ *                           credential matches the given slot.
+ * @param slot_get_address   For SCC2: Get the virtual address (kernel or
+ *                           userspace) of the data stored in the slot.
+ *                           For SCC: Get the physical address of the data
+ *                           stored in the slot.
+ * @param slot_get_base      For SCC2: Get the (virtual) base address of the
+ *                           partition that the slot is located on.
+ *                           For SCC: Not implemented.
+ * @param slot_get_offset    For SCC2: Get the offset from the start of the
+ *                           partition that the slot data is located at (in
+ *                           octets)
+ *                           For SCC: Not implemented.
+ * @param slot_get_slot_size Get the size of the key slot, in octets.
+ */
+extern void fsl_shw_init_keystore(fsl_shw_kso_t * keystore,
+				  fsl_shw_return_t(*data_init) (fsl_shw_uco_t *
+								user_ctx,
+								void
+								**user_data),
+				  void (*data_cleanup) (fsl_shw_uco_t *
+							user_ctx,
+							void **user_data),
+				  fsl_shw_return_t(*slot_alloc) (void
+								 *user_data,
+								 uint32_t size,
+								 uint64_t
+								 owner_id,
+								 uint32_t *
+								 slot),
+				  fsl_shw_return_t(*slot_dealloc) (void
+								   *user_data,
+								   uint64_t
+								   owner_id,
+								   uint32_t
+								   slot),
+				  fsl_shw_return_t(*slot_verify_access) (void
+									 *user_data,
+									 uint64_t
+									 owner_id,
+									 uint32_t
+									 slot),
+				  void *(*slot_get_address) (void *user_data,
+							     uint32_t handle),
+				  uint32_t(*slot_get_base) (void *user_data,
+							    uint32_t handle),
+				  uint32_t(*slot_get_offset) (void *user_data,
+							      uint32_t handle),
+				  uint32_t(*slot_get_slot_size) (void
+								 *user_data,
+								 uint32_t
+								 handle));
+
+/*!
+ * Initialize a Keystore Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object. It sets the user keystore object up to use the default keystore
+ * handler.  If a custom keystore handler is desired, the function
+ * #fsl_shw_init_keystore() can be used instead.
+ *
+ * @param keystore      The Keystore object to operate on.
+ */
+extern void fsl_shw_init_keystore_default(fsl_shw_kso_t * keystore);
+
+/*!
+ * Establish a Keystore Object.
+ *
+ * This function establishes a keystore object that has been set up by a call
+ * to #fsl_shw_init_keystore().  It is a wrapper for the user-defined
+ * data_init() function, which is specified during keystore initialization.
+ *
+ * @param user_ctx      The user context that this keystore should be attached
+ *                      to
+ * @param keystore      The Keystore object to operate on.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t * user_ctx,
+						   fsl_shw_kso_t * keystore);
+
+/*!
+ * Release a Keystore Object.
+ *
+ * This function releases an established keystore object.  It is a wrapper for
+ * the user-defined data_cleanup() function, which is specified during keystore
+ * initialization.
+ *
+ * @param user_ctx      The user context that this keystore should be attached
+ *                      to.
+ * @param keystore      The Keystore object to operate on.
+ */
+extern void fsl_shw_release_keystore(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_kso_t * keystore);
+
+/*!
+ * Allocate a slot in the Keystore.
+ *
+ * This function attempts to allocate a slot to hold a key in the keystore.  It
+ * is called by #fsl_shw_establish_key() when establishing a Secure Key Object,
+ * if the key has been flagged to be stored in a user keystore by the
+ * #fsl_shw_sko_set_keystore() function.  It is a wrapper for the
+ * implementation-specific function slot_alloc().
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] size      Size of the key to be stored (octets).
+ * @param[in] owner_id  ID of the key owner.
+ * @param[out] slot     If successful, assigned slot ID
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t * keystore,
+					    uint32_t size,
+					    uint64_t owner_id, uint32_t * slot);
+
+/*!
+ * Deallocate a slot in the Keystore.
+ *
+ * This function attempts to allocate a slot to hold a key in the keystore.
+ * It is called by #fsl_shw_extract_key() and #fsl_shw_release_key() when the
+ * key that it contains is to be released.  It is a wrapper for the
+ * implmentation-specific function slot_dealloc().
+
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot     If successful, assigned slot ID.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t * keystore,
+					      uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Load cleartext key data into a key slot
+ *
+ * This function loads a key slot with cleartext data.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      If successful, assigned slot ID.
+ * @param[in] key_data  Pointer to the location of the cleartext key data.
+ * @param[in] key_length Length of the key data (octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_load(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t * key_data, uint32_t key_length);
+
+/*!
+ * Read cleartext key data from a key slot
+ *
+ * This function returns the key in a key slot.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in]  owner_id   ID of the key owner.
+ * @param[in]  slot       ID of slot where key resides.
+ * @param[in]  key_length Length of the key data (octets).
+ * @param[out] key_data   Pointer to the location of the cleartext key data.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data);
+
+/*!
+ * Encrypt a keyslot
+ *
+ * This function encrypts a key using the hardware secret key.
+ *
+ * @param user_ctx      User context
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      Slot ID of the key to encrypt.
+ * @param[in] length    Length of the key
+ * @param[out] destination  Pointer to the location where the encrypted data
+ *                          is to be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t * user_ctx,
+		      fsl_shw_kso_t * keystore, uint64_t owner_id,
+		      uint32_t slot, uint32_t length, uint8_t * destination);
+
+/*!
+ * Decrypt a keyslot
+ *
+ * This function decrypts a key using the hardware secret key.
+ *
+ * @param user_ctx      User context
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      Slot ID of the key to encrypt.
+ * @param[in] length    Length of the key
+ * @param[in] source    Pointer to the location where the encrypted data
+ *                      is stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t * user_ctx,
+		      fsl_shw_kso_t * keystore, uint64_t owner_id,
+		      uint32_t slot, uint32_t length, const uint8_t * source);
+
+/* @} */
+
+/*! @addtogroup default_keystore
+    @{ */
+
+/*!
+ * Data structure to hold per-slot information
+ */
+typedef struct keystore_data_slot_info_t {
+	uint8_t allocated;	/*!< Track slot assignments */
+	uint64_t owner;		/*!< Owner IDs */
+	uint32_t key_length;	/*!< Size of the key */
+} keystore_data_slot_info_t;
+
+/*!
+ * Data structure to hold keystore information.
+ */
+typedef struct keystore_data_t {
+	void *base_address;	/*!< Base of the Secure Partition */
+	uint32_t slot_count;	/*!< Number of slots in the keystore */
+	struct keystore_data_slot_info_t *slot;	/*!< Per-slot information */
+} keystore_data_t;
+
+/*!
+ * Default keystore initialization routine.
+ *
+ * This function acquires a Secure Partition Object to store the keystore,
+ * divides it into slots of length #KEYSTORE_SLOT_SIZE, and builds a data
+ * structure to hold key information.
+ *
+ * @param user_ctx       User context
+ * @param[out] user_data Pointer to the location where the keystore data
+ *                       structure is to be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t * user_ctx, void **user_data);
+
+/*!
+ * Default keystore cleanup routine.
+ *
+ * This function releases the Secure Partition Object and the memory holding
+ * the keystore data structure, that obtained by the shw_kso_init_data
+ * function.
+ *
+ * @param user_ctx          User context
+ * @param[in,out] user_data Pointer to the location where the keystore data
+ *                          structure is stored.
+ */
+void shw_kso_cleanup_data(fsl_shw_uco_t * user_ctx, void **user_data);
+
+/*!
+ * Default keystore slot access verification
+ *
+ * This function compares the supplied Owner ID to the registered owner of
+ * the key slot, to see if the supplied ID is correct.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[in] slot      Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+					uint32_t slot);
+
+/*!
+ * Default keystore slot allocation
+ *
+ * This function first checks that the requested size is equal to or less than
+ * the maximum keystore slot size.  If so, it searches the keystore for a free
+ * key slot, and if found, marks it as used and returns a slot reference to the
+ * user.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] size      Size of the key data that will be stored in this slot
+ *                      (octets)
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[out] slot     Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				uint64_t owner_id, uint32_t * slot);
+
+/*!
+ * Default keystore slot deallocation
+ *
+ * This function releases the given key slot in the keystore, making it
+ * available to store a new key.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[in] slot      Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_dealloc(void *user_data,
+				  uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Default keystore slot address lookup
+ *
+ * This function calculates the address where the key data is stored.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Virtual address (kernel or userspace) of the key data.
+ *            SCC: Physical address of the key data.
+ */
+void *shw_slot_get_address(void *user_data, uint32_t slot);
+
+/*!
+ * Default keystore slot base address lookup
+ *
+ * This function calculates the base address of the Secure Partition on which
+ * the key data is located.  For the reference design, only one Secure
+ * Partition is used per Keystore, however in general, any number may be used.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Secure Partition virtual (kernel or userspace) base address.
+ *            SCC: Secure Partition physical base address.
+ */
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot);
+
+/*!
+ * Default keystore slot offset lookup
+ *
+ * This function calculates the offset from the base of the Secure Partition
+ * where the key data is located.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Key data offset (octets)
+ *            SCC: Not implemented
+ */
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot);
+
+/*!
+ * Default keystore slot offset lookup
+ *
+ * This function returns the size of the given key slot.  In the reference
+ * implementation, all key slots are of the same size, however in general,
+ * the keystore slot sizes can be made variable.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Keystore slot size.
+ *            SCC: Not implemented
+ */
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot);
+
+/* @} */
+
+#endif /* FSL_SHW_KEYSTORE_H */
diff --git a/drivers/mxc/security/sahara2/include/linux_port.h b/drivers/mxc/security/sahara2/include/linux_port.h
new file mode 100644
index 0000000..63efb83
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/linux_port.h
@@ -0,0 +1,1805 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file linux_port.h
+ *
+ * OS_PORT ported to Linux (2.6.9+ for now)
+ *
+ */
+
+ /*!
+  * @if USE_MAINPAGE
+  * @mainpage ==Linux version of== Generic OS API for STC Drivers
+  * @endif
+  *
+  * @section intro_sec Introduction
+  *
+  * This API / kernel programming environment blah blah.
+  *
+  * See @ref dkops "Driver-to-Kernel Operations" as a good place to start.
+  */
+
+#ifndef LINUX_PORT_H
+#define LINUX_PORT_H
+
+#define PORTABLE_OS_VERSION 101
+
+/* Linux Kernel Includes */
+#include <linux/version.h>	/* Current version Linux kernel */
+
+#if defined(CONFIG_MODVERSIONS) && ! defined(MODVERSIONS)
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+#include <linux/modversions.h>
+#endif
+#define MODVERSIONS
+#endif
+/*!
+ * __NO_VERSION__ defined due to Kernel module possibly spanning multiple
+ * files.
+ */
+#define __NO_VERSION__
+
+#include <linux/module.h>	/* Basic support for loadable modules,
+				   printk */
+#include <linux/init.h>		/* module_init, module_exit */
+#include <linux/kernel.h>	/* General kernel system calls */
+#include <linux/sched.h>	/* for interrupt.h */
+#include <linux/fs.h>		/* for inode */
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>		/* kmalloc */
+
+#include <stdarg.h>
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+#include <linux/device.h>  /* used in dynamic power management */
+#else
+#include <linux/platform_device.h>  /* used in dynamic power management */
+#endif
+
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/clk.h>         /* clock en/disable for DPM */
+
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/uaccess.h>            /* copy_to_user(), copy_from_user() */
+#include <asm/io.h>                 /* ioremap() */
+#include <asm/irq.h>
+#include <asm/cacheflush.h>
+
+#include <mach/hardware.h>
+
+#ifndef TRUE
+/*! Useful symbol for unsigned values used as flags. */
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+/*! Useful symbol for unsigned values used as flags. */
+#define FALSE 0
+#endif
+
+/* These symbols are defined in Linux 2.6 and later.  Include here for minimal
+ * support of 2.4 kernel.
+ **/
+#if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*!
+ * Symbol defined somewhere in 2.5/2.6.  It is the return signature of an ISR.
+ */
+#define irqreturn_t void
+/*! Possible return value of 'modern' ISR routine. */
+#define IRQ_HANDLED
+/*! Method of generating value of 'modern' ISR routine. */
+#define IRQ_RETVAL(x)
+#endif
+
+/*!
+ * Type used for registering and deregistering interrupts.
+ */
+typedef int os_interrupt_id_t;
+
+/*!
+ * Type used as handle for a process
+ *
+ * See #os_get_process_handle() and #os_send_signal().
+ */
+/*
+ * The following should be defined this way, but it gets compiler errors
+ * on the current tool chain.
+ *
+ * typedef task_t *os_process_handle_t;
+ */
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+typedef task_t *os_process_handle_t;
+#else
+typedef struct task_struct *os_process_handle_t;
+#endif
+
+/*!
+ * Generic return code for functions which need such a thing.
+ *
+ * No knowledge should be assumed of the value of any of these symbols except
+ * that @c OS_ERROR_OK_S is guaranteed to be zero.
+ */
+typedef enum {
+	OS_ERROR_OK_S = 0,	/*!< Success  */
+	OS_ERROR_FAIL_S = -EIO,	/*!< Generic driver failure */
+	OS_ERROR_NO_MEMORY_S = -ENOMEM,	/*!< Failure to acquire/use memory  */
+	OS_ERROR_BAD_ADDRESS_S = -EFAULT,	/*!< Bad address  */
+	OS_ERROR_BAD_ARG_S = -EINVAL,	/*!< Bad input argument  */
+} os_error_code;
+
+/*!
+ * Handle to a lock.
+ */
+#ifdef CONFIG_PREEMPT_RT
+typedef raw_spinlock_t *os_lock_t;
+#else
+typedef spinlock_t *os_lock_t;
+#endif
+
+/*!
+ * Context while locking.
+ */
+typedef unsigned long os_lock_context_t;
+
+/*!
+ * Declare a wait object for sleeping/waking processes.
+ */
+#define OS_WAIT_OBJECT(name)                                            \
+    DECLARE_WAIT_QUEUE_HEAD(name##_qh)
+
+/*!
+ * Driver registration handle
+ *
+ * Used with #os_driver_init_registration(), #os_driver_add_registration(),
+ * and #os_driver_complete_registration().
+ */
+typedef struct {
+	unsigned reg_complete;	/*!< TRUE if next inits succeeded. */
+	dev_t dev;		/*!< dev_t for register_chrdev() */
+	struct file_operations fops;	/*!< struct for register_chrdev() */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+	struct class_simple *cs;	/*!< results of class_simple_create() */
+#else
+	struct class *cs;	/*!< results of class_create() */
+#endif
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+	struct class_device *cd;	/*!< Result of class_device_create() */
+#else
+	struct device *cd;	/*!< Result of device_create() */
+#endif
+	unsigned power_complete;	/*!< TRUE if next inits succeeded */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	struct device_driver dd;	/*!< struct for register_driver() */
+#else
+	struct platform_driver dd;	/*!< struct for register_driver() */
+#endif
+	struct platform_device pd;	/*!< struct for platform_register_device() */
+} os_driver_reg_t;
+
+/*
+ *  Function types which can be associated with driver entry points.
+ *
+ *  Note that init and shutdown are absent.
+ */
+/*! @{ */
+/*! Keyword for registering open() operation handler. */
+#define OS_FN_OPEN open
+/*! Keyword for registering close() operation handler. */
+#define OS_FN_CLOSE release
+/*! Keyword for registering read() operation handler. */
+#define OS_FN_READ read
+/*! Keyword for registering write() operation handler. */
+#define OS_FN_WRITE write
+/*! Keyword for registering ioctl() operation handler. */
+#define OS_FN_IOCTL unlocked_ioctl
+/*! Keyword for registering mmap() operation handler. */
+#define OS_FN_MMAP mmap
+/*! @} */
+
+/*!
+ * Function signature for the portable interrupt handler
+ *
+ * While it would be nice to know which interrupt is being serviced, the
+ * Least Common Denominator rule says that no arguments get passed in.
+ *
+ * @return  Zero if not handled, non-zero if handled.
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+typedef int (*os_interrupt_handler_t) (int, void *, struct pt_regs *);
+#else
+typedef int (*os_interrupt_handler_t) (int, void *);
+#endif
+
+/*!
+ * @defgroup dkops Driver-to-Kernel Operations
+ *
+ * These are the operations which drivers should call to get the OS to perform
+ * services.
+ */
+
+/*! @addtogroup dkops */
+/*! @{ */
+
+/*!
+ * Register an interrupt handler.
+ *
+ * @param driver_name    The name of the driver
+ * @param interrupt_id   The interrupt line to monitor (type
+ *                       #os_interrupt_id_t)
+ * @param function       The function to be called to handle an interrupt
+ *
+ * @return #os_error_code
+ */
+#define os_register_interrupt(driver_name, interrupt_id, function)            \
+     request_irq(interrupt_id, function, 0, driver_name, NULL)
+
+/*!
+ * Deregister an interrupt handler.
+ *
+ * @param interrupt_id   The interrupt line to stop monitoring
+ *
+ * @return #os_error_code
+ */
+#define os_deregister_interrupt(interrupt_id)                                 \
+     free_irq(interrupt_id, NULL)
+
+/*!
+ * INTERNAL implementation of os_driver_init_registration()
+ *
+ * @return An os error code.
+ */
+inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
+{
+	memset(handle, 0, sizeof(*handle));
+	handle->fops.owner = THIS_MODULE;
+	handle->power_complete = FALSE;
+	handle->reg_complete = FALSE;
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	handle->dd.name = NULL;
+#else
+	handle->dd.driver.name = NULL;
+#endif
+
+	return OS_ERROR_OK_S;
+}
+
+/*!
+ * Initialize driver registration.
+ *
+ * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
+ * calls, then it needs to register their location with the kernel so that they
+ * get associated with the device.
+ *
+ * @param handle  The handle object to be used with this registration.  The
+ *                object must live (be in memory somewhere) at least until
+ *                os_driver_remove_registration() is called.
+ *
+ * @return A handle for further driver registration, or NULL if failed.
+ */
+#define os_driver_init_registration(handle)                                   \
+    os_drv_do_init_reg(&handle)
+
+/*!
+ * Add a function registration to driver registration.
+ *
+ * @param handle    A handle initialized by #os_driver_init_registration().
+ * @param name      Which function is being supported.
+ * @param function  The result of a call to a @c _REF version of one of the
+ *                  driver function signature macros
+ * @return void
+ */
+#define os_driver_add_registration(handle, name, function)                    \
+    do {handle.fops.name = (void*)(function); } while (0)
+
+/*!
+ * Record 'power suspend' function for the device.
+ *
+ * @param handle    A handle initialized by #os_driver_init_registration().
+ * @param function  Name of function to call on power suspend request
+ *
+ * Status: Provisional
+ *
+ * @return void
+ */
+#define os_driver_register_power_suspend(handle, function)                    \
+   handle.dd.suspend = function
+
+/*!
+ * Record 'power resume' function for the device.
+ *
+ * @param handle    A handle initialized by #os_driver_init_registration().
+ * @param function  Name of function to call on power resume request
+ *
+ * Status: Provisional
+ *
+ * @return void
+ */
+#define os_driver_register_resume(handle, function)                          \
+   handle.dd.resume = function
+
+/*!
+ * INTERNAL function of the Linux port of the OS API.   Implements the
+ * os_driver_complete_registration() function.
+ *
+ * @param handle    The handle used with #os_driver_init_registration().
+ * @param major      The major device number to be associated with the driver.
+ *                   If this value is zero, a major number may be assigned.
+ *                   See #os_driver_get_major() to determine final value.
+ *                   #os_driver_remove_registration().
+ * @param driver_name The driver name.  Can be used as part of 'device node'
+ *                   name on platforms which support such a feature.
+ *
+ * @return  An error code
+ */
+inline static int os_drv_do_reg(os_driver_reg_t * handle,
+				unsigned major, char *driver_name)
+{
+	os_error_code code = OS_ERROR_NO_MEMORY_S;
+	char *name = kmalloc(strlen(driver_name) + 1, 0);
+
+	if (name != NULL) {
+		memcpy(name, driver_name, strlen(driver_name) + 1);
+		code = OS_ERROR_OK_S;	/* OK so far */
+		/* If any chardev/POSIX routines were added, then do chrdev part */
+		if (handle->fops.open || handle->fops.release
+		    || handle->fops.read || handle->fops.write
+		    || handle->fops.unlocked_ioctl || handle->fops.mmap) {
+
+			printk("ioctl pointer: %p.  mmap pointer: %p\n",
+			       handle->fops.unlocked_ioctl, handle->fops.mmap);
+
+			/* this method is depricated, see:
+			 * http://lwn.net/Articles/126808/
+			 */
+			code =
+			    register_chrdev(major, driver_name, &handle->fops);
+
+			/* instead something like this: */
+#if 0
+			handle->dev = MKDEV(major, 0);
+			code =
+			    register_chrdev_region(handle->dev, 1, driver_name);
+			if (code < 0) {
+				code = OS_ERROR_FAIL_S;
+			} else {
+				cdev_init(&handle->cdev, &handle->fops);
+				code = cdev_add(&handle->cdev, major, 1);
+			}
+#endif
+
+			if (code < 0) {
+				code = OS_ERROR_FAIL_S;
+			} else {
+				if (code != 0) {
+					/* Zero was passed in for major; code is actual value */
+					handle->dev = MKDEV(code, 0);
+				} else {
+					handle->dev = MKDEV(major, 0);
+				}
+				code = OS_ERROR_OK_S;
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+				handle->cs =
+				    class_simple_create(THIS_MODULE,
+							driver_name);
+				if (IS_ERR(handle->cs)) {
+					code = (os_error_code) handle->cs;
+					handle->cs = NULL;
+				} else {
+					handle->cd =
+					    class_simple_device_add(handle->cs,
+								    handle->dev,
+								    NULL,
+								    driver_name);
+					if (IS_ERR(handle->cd)) {
+						class_simple_device_remove
+						    (handle->dev);
+						unregister_chrdev(MAJOR
+								  (handle->dev),
+								  driver_name);
+						code =
+						    (os_error_code) handle->cs;
+						handle->cs = NULL;
+					} else {
+						handle->reg_complete = TRUE;
+					}
+				}
+#else
+				handle->cs =
+				    class_create(THIS_MODULE, driver_name);
+				if (IS_ERR(handle->cs)) {
+					code = (os_error_code) handle->cs;
+					handle->cs = NULL;
+				} else {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+					handle->cd =
+					    class_device_create(handle->cs,
+								NULL,
+								handle->dev,
+								NULL,
+								driver_name);
+#else
+					handle->cd =
+					    device_create(handle->cs, NULL,
+							  handle->dev, NULL,
+							  driver_name);
+#endif
+					if (IS_ERR(handle->cd)) {
+						class_destroy(handle->cs);
+						unregister_chrdev(MAJOR
+								  (handle->dev),
+								  driver_name);
+						code =
+						    (os_error_code) handle->cs;
+						handle->cs = NULL;
+					} else {
+						handle->reg_complete = TRUE;
+					}
+				}
+#endif
+			}
+		}
+		/* ... fops routine registered */
+		/* Handle power management fns through separate interface */
+		if ((code == OS_ERROR_OK_S) &&
+		    (handle->dd.suspend || handle->dd.resume)) {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+			handle->dd.name = name;
+			handle->dd.bus = &platform_bus_type;
+			code = driver_register(&handle->dd);
+#else
+			handle->dd.driver.name = name;
+			handle->dd.driver.bus = &platform_bus_type;
+			code = driver_register(&handle->dd.driver);
+#endif
+			if (code == OS_ERROR_OK_S) {
+				handle->pd.name = name;
+				handle->pd.id = 0;
+				code = platform_device_register(&handle->pd);
+				if (code != OS_ERROR_OK_S) {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+					driver_unregister(&handle->dd);
+#else
+					driver_unregister(&handle->dd.driver);
+#endif
+				} else {
+					handle->power_complete = TRUE;
+				}
+			}
+		}		/* ... suspend or resume */
+	}			/* name != NULL */
+	return code;
+}
+
+/*!
+ * Finalize the driver registration with the kernel.
+ *
+ * Upon return from this call, the driver may begin receiving calls at the
+ * defined entry points.
+ *
+ * @param handle    The handle used with #os_driver_init_registration().
+ * @param major      The major device number to be associated with the driver.
+ *                   If this value is zero, a major number may be assigned.
+ *                   See #os_driver_get_major() to determine final value.
+ *                   #os_driver_remove_registration().
+ * @param driver_name The driver name.  Can be used as part of 'device node'
+ *                   name on platforms which support such a feature.
+ *
+ * @return  An error code
+ */
+#define os_driver_complete_registration(handle, major, driver_name)           \
+   os_drv_do_reg(&handle, major, driver_name)
+
+/*!
+ * Get driver Major Number from handle after a successful registration.
+ *
+ * @param   handle  A handle which has completed registration.
+ *
+ * @return The major number (if any) associated with the handle.
+ */
+#define os_driver_get_major(handle)                                           \
+    (handle.reg_complete ? MAJOR(handle.dev) : -1)
+
+/*!
+ * INTERNAL implemention of os_driver_remove_registration.
+ *
+ * @param handle    A handle initialized by #os_driver_init_registration().
+ *
+ * @return  An error code.
+ */
+inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
+{
+	if (handle->reg_complete) {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+		if (handle->cd != NULL) {
+			class_simple_device_remove(handle->dev);
+			handle->cd = NULL;
+		}
+		if (handle->cs != NULL) {
+			class_simple_destroy(handle->cs);
+			handle->cs = NULL;
+		}
+		unregister_chrdev(MAJOR(handle->dev), handle->dd.name);
+#else
+		if (handle->cd != NULL) {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+			class_device_destroy(handle->cs, handle->dev);
+#else
+			device_destroy(handle->cs, handle->dev);
+#endif
+			handle->cd = NULL;
+		}
+		if (handle->cs != NULL) {
+			class_destroy(handle->cs);
+			handle->cs = NULL;
+		}
+		unregister_chrdev(MAJOR(handle->dev), handle->dd.driver.name);
+#endif
+		handle->reg_complete = FALSE;
+	}
+	if (handle->power_complete) {
+		platform_device_unregister(&handle->pd);
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+		driver_unregister(&handle->dd);
+#else
+		driver_unregister(&handle->dd.driver);
+#endif
+		handle->power_complete = FALSE;
+	}
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	if (handle->dd.name != NULL) {
+		kfree(handle->dd.name);
+		handle->dd.name = NULL;
+	}
+#else
+	if (handle->dd.driver.name != NULL) {
+		kfree(handle->dd.driver.name);
+		handle->dd.driver.name = NULL;
+	}
+#endif
+	return OS_ERROR_OK_S;
+}
+
+/*!
+ * Remove the driver's registration with the kernel.
+ *
+ * Upon return from this call, the driver not receive any more calls at the
+ * defined entry points (other than ISR and shutdown).
+ *
+ * @param handle    A handle initialized by #os_driver_init_registration().
+ *
+ * @return  An error code.
+ */
+#define os_driver_remove_registration(handle)                                 \
+   os_drv_rmv_reg(&handle)
+
+/*!
+ * Register a driver with the Linux Device Model.
+ *
+ * @param   driver_information  The device_driver structure information
+ *
+ * @return  An error code.
+ *
+ * Status: denigrated in favor of #os_driver_complete_registration()
+ */
+#define os_register_to_driver(driver_information)                             \
+              driver_register(driver_information)
+
+/*!
+ * Unregister a driver from the Linux Device Model
+ *
+ * this routine unregisters from the Linux Device Model
+ *
+ * @param   driver_information  The device_driver structure information
+ *
+ * @return  An error code.
+ *
+ * Status: Denigrated. See #os_register_to_driver().
+ */
+#define os_unregister_from_driver(driver_information)                         \
+                driver_unregister(driver_information)
+
+/*!
+ * register a device to a driver
+ *
+ * this routine registers a drivers devices to the Linux Device Model
+ *
+ * @param   device_information  The platform_device structure information
+ *
+ * @return  An error code.
+ *
+ * Status: denigrated in favor of #os_driver_complete_registration()
+ */
+#define os_register_a_device(device_information)                              \
+    platform_device_register(device_information)
+
+/*!
+ * unregister a device from a driver
+ *
+ * this routine unregisters a drivers devices from the Linux Device Model
+ *
+ * @param   device_information  The platform_device structure information
+ *
+ * @return  An error code.
+ *
+ * Status: Denigrated.  See #os_register_a_device().
+ */
+#define os_unregister_a_device(device_information)                            \
+    platform_device_unregister(device_information)
+
+/*!
+ * Print a message to console / into log file.  After the @c msg argument a
+ * number of printf-style arguments may be added.  Types should be limited to
+ * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
+ * pointers, and floating point).
+ *
+ * @param  msg    The main text of the message to be logged
+ * @param  s      The printf-style arguments which go with msg, if any
+ *
+ * @return (void)
+ */
+#define os_printk(...)                                                        \
+    (void) printk(__VA_ARGS__)
+
+/*!
+ * Prepare a task to execute the given function.  This should only be done once
+ * per function,, during the driver's initialization routine.
+ *
+ * @param task_fn   Name of the OS_DEV_TASK() function to be created.
+ *
+ * @return an OS ERROR code.
+ */
+#define os_create_task(function_name)                                         \
+    OS_ERROR_OK_S
+
+/*!
+ * Schedule execution of a task.
+ *
+ * @param function_name   The function associated with the task.
+ *
+ * @return (void)
+ */
+#define os_dev_schedule_task(function_name)                                   \
+    tasklet_schedule(&(function_name ## let))
+
+/*!
+ * Make sure that task is no longer running and will no longer run.
+ *
+ * This function will not return until both are true.  This is useful when
+ * shutting down a driver.
+ */
+#define os_dev_stop_task(function_name)                                       \
+do {                                                                          \
+    tasklet_disable(&(function_name ## let));                                 \
+    tasklet_kill(&(function_name ## let));                                    \
+} while (0)
+
+/*!
+ * Allocate some kernel memory
+ *
+ * @param amount   Number of 8-bit bytes to allocate
+ * @param flags    Some indication of purpose of memory (needs definition)
+ *
+ * @return  Pointer to allocated memory, or NULL if failed.
+ */
+#define os_alloc_memory(amount, flags)                                        \
+    (void*)kmalloc(amount, flags)
+
+/*!
+ * Free some kernel memory
+ *
+ * @param location  The beginning of the region to be freed.
+ *
+ * Do some OSes have separate free() functions which should be
+ * distinguished by passing in @c flags here, too? Don't some also require the
+ * size of the buffer being freed?
+ */
+#define os_free_memory(location)                                              \
+    kfree(location)
+
+/*!
+ * Allocate cache-coherent memory
+ *
+ * @param       amount     Number of bytes to allocate
+ * @param[out]  dma_addrp  Location to store physical address of allocated
+ *                         memory.
+ * @param       flags      Some indication of purpose of memory (needs
+ *                         definition).
+ *
+ * @return (virtual space) pointer to allocated memory, or NULL if failed.
+ *
+ */
+#define os_alloc_coherent(amount, dma_addrp, flags)                           \
+    (void*)dma_alloc_coherent(NULL, amount, dma_addrp, flags)
+
+/*!
+ * Free cache-coherent memory
+ *
+ * @param       size       Number of bytes which were allocated.
+ * @param       virt_addr  Virtual(kernel) address of memory.to be freed, as
+ *                         returned by #os_alloc_coherent().
+ * @param       dma_addr   Physical address of memory.to be freed, as returned
+ *                         by #os_alloc_coherent().
+ *
+ * @return void
+ *
+ */
+#define os_free_coherent(size, virt_addr, dma_addr)                           \
+    dma_free_coherent(NULL, size, virt_addr, dma_addr
+
+/*!
+ * Map an I/O space into kernel memory space
+ *
+ * @param start       The starting address of the (physical / io space) region
+ * @param range_bytes The number of bytes to map
+ *
+ * @return A pointer to the mapped area, or NULL on failure
+ */
+#define os_map_device(start, range_bytes)                                     \
+    (void*)ioremap_nocache((start), range_bytes)
+
+/*!
+ * Unmap an I/O space from kernel memory space
+ *
+ * @param start       The starting address of the (virtual) region
+ * @param range_bytes The number of bytes to unmap
+ *
+ * @return None
+ */
+#define os_unmap_device(start, range_bytes)                                   \
+    iounmap((void*)(start))
+
+/*!
+ * Copy data from Kernel space to User space
+ *
+ * @param to   The target location in user memory
+ * @param from The source location in kernel memory
+ * @param size The number of bytes to be copied
+ *
+ * @return #os_error_code
+ */
+#define os_copy_to_user(to, from, size)                                       \
+    ((copy_to_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
+
+/*!
+ * Copy data from User space to Kernel space
+ *
+ * @param to   The target location in kernel memory
+ * @param from The source location in user memory
+ * @param size The number of bytes to be copied
+ *
+ * @return #os_error_code
+ */
+#define os_copy_from_user(to, from, size)                                     \
+    ((copy_from_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
+
+/*!
+ * Read a 8-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+#define os_read8(register_address)                                            \
+    __raw_readb(register_address)
+
+/*!
+ * Write a 8-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+#define os_write8(register_address, value)                                    \
+    __raw_writeb(value, register_address)
+
+/*!
+ * Read a 16-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+#define os_read16(register_address)                                           \
+    __raw_readw(register_address)
+
+/*!
+ * Write a 16-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+#define os_write16(register_address, value)                                   \
+    __raw_writew(value, (uint32_t*)(register_address))
+
+/*!
+ * Read a 32-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+#define os_read32(register_address)                                           \
+    __raw_readl((uint32_t*)(register_address))
+
+/*!
+ * Write a 32-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+#define os_write32(register_address, value)                                   \
+    __raw_writel(value, register_address)
+
+/*!
+ * Read a 64-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+#define os_read64(register_address)                                           \
+     ERROR_UNIMPLEMENTED
+
+/*!
+ * Write a 64-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+#define os_write64(register_address, value)                                   \
+    ERROR_UNIMPLEMENTED
+
+/*!
+ * Delay some number of microseconds
+ *
+ * Note that this is a busy-loop, not a suspension of the task/process.
+ *
+ * @param  msecs   The number of microseconds to delay
+ *
+ * @return void
+ */
+#define os_mdelay mdelay
+
+/*!
+ * Calculate virtual address from physical address
+ *
+ * @param pa    Physical address
+ *
+ * @return virtual address
+ *
+ * @note this assumes that addresses are 32 bits wide
+ */
+#define os_va __va
+
+/*!
+ * Calculate physical address from virtual address
+ *
+ *
+ * @param va    Virtual address
+ *
+ * @return physical address
+ *
+ * @note this assumes that addresses are 32 bits wide
+ */
+#define os_pa __pa
+
+#ifdef CONFIG_PREEMPT_RT
+/*!
+ * Allocate and initialize a lock, returning a lock handle.
+ *
+ * The lock state will be initialized to 'unlocked'.
+ *
+ * @return A lock handle, or NULL if an error occurred.
+ */
+inline static os_lock_t os_lock_alloc_init(void)
+{
+	raw_spinlock_t *lockp;
+	lockp = (raw_spinlock_t *) kmalloc(sizeof(raw_spinlock_t), 0);
+	if (lockp) {
+		_raw_spin_lock_init(lockp);
+	} else {
+		printk("OS: lock init failed\n");
+	}
+
+	return lockp;
+}
+#else
+/*!
+ * Allocate and initialize a lock, returning a lock handle.
+ *
+ * The lock state will be initialized to 'unlocked'.
+ *
+ * @return A lock handle, or NULL if an error occurred.
+ */
+inline static os_lock_t os_lock_alloc_init(void)
+{
+	spinlock_t *lockp;
+	lockp = (spinlock_t *) kmalloc(sizeof(spinlock_t), 0);
+	if (lockp) {
+		spin_lock_init(lockp);
+	} else {
+		printk("OS: lock init failed\n");
+	}
+
+	return lockp;
+}
+#endif				/* CONFIG_PREEMPT_RT */
+
+/*!
+ * Acquire a lock.
+ *
+ * This function should only be called from an interrupt service routine.
+ *
+ * @param   lock_handle  A handle to the lock to acquire.
+ *
+ * @return void
+ */
+#define os_lock(lock_handle)                                              \
+   spin_lock(lock_handle)
+
+/*!
+ * Unlock a lock.  Lock must have been acquired by #os_lock().
+ *
+ * @param   lock_handle  A handle to the lock to unlock.
+ *
+ * @return void
+ */
+#define os_unlock(lock_handle)                                            \
+   spin_unlock(lock_handle)
+
+/*!
+ * Acquire a lock in non-ISR context
+ *
+ * This function will spin until the lock is available.
+ *
+ * @param lock_handle  A handle of the lock to acquire.
+ * @param context      Place to save the before-lock context
+ *
+ * @return void
+ */
+#define os_lock_save_context(lock_handle, context)                        \
+    spin_lock_irqsave(lock_handle, context)
+
+/*!
+ * Release a lock in non-ISR context
+ *
+ * @param lock_handle  A handle of the lock to release.
+ * @param context      Place where before-lock context was saved.
+ *
+ * @return void
+ */
+#define os_unlock_restore_context(lock_handle, context)                  \
+    spin_unlock_irqrestore(lock_handle, context)
+
+/*!
+ * Deallocate a lock handle.
+ *
+ * @param lock_handle   An #os_lock_t that has been allocated.
+ *
+ * @return void
+ */
+#define os_lock_deallocate(lock_handle)                                   \
+    kfree(lock_handle)
+
+/*!
+ * Determine process handle
+ *
+ * The process handle of the current user is returned.
+ *
+ * @return   A handle on the current process.
+ */
+#define os_get_process_handle()                                           \
+    current
+
+/*!
+ * Send a signal to a process
+ *
+ * @param  proc   A handle to the target process.
+ * @param  sig    The POSIX signal to send to that process.
+ */
+#define os_send_signal(proc, sig)                                         \
+    send_sig(sig, proc, 0);
+
+/*!
+ * Get some random bytes
+ *
+ * @param buf    The location to store the random data.
+ * @param count  The number of bytes to store.
+ *
+ * @return  void
+ */
+#define os_get_random_bytes(buf, count)                                   \
+    get_random_bytes(buf, count)
+
+/*!
+ * Go to sleep on an object.
+ *
+ * @param object    The object on which to sleep
+ * @param condition An expression to check for sleep completion.  Must be
+ *                  coded so that it can be referenced more than once inside
+ *                  macro, i.e., no ++ or other modifying expressions.
+ * @param atomic    Non-zero if sleep must not return until condition.
+ *
+ * @return error code -- OK or sleep interrupted??
+ */
+#define os_sleep(object, condition, atomic)                             \
+({                                                                      \
+    DEFINE_WAIT(_waitentry_);                                           \
+    os_error_code code = OS_ERROR_OK_S;                                 \
+                                                                        \
+    while (!(condition)) {                                              \
+        prepare_to_wait(&(object##_qh), &_waitentry_,                   \
+                        atomic ? 0 : TASK_INTERRUPTIBLE);               \
+        if (!(condition)) {                                             \
+            schedule();                                                 \
+        }                                                               \
+                                                                        \
+        finish_wait(&(object##_qh), &_waitentry_);                      \
+                                                                        \
+        if (!atomic && signal_pending(current)) {                       \
+            code = OS_ERROR_FAIL_S; /* NEED SOMETHING BETTER */         \
+            break;                                                      \
+        }                                                               \
+    };                                                                  \
+                                                                        \
+    code;                                                               \
+})
+
+/*!
+ * Wake up whatever is sleeping on sleep object
+ *
+ * @param object  The object on which things might be sleeping
+ *
+ * @return none
+ */
+#define os_wake_sleepers(object)                                        \
+    wake_up_interruptible(&(object##_qh));
+
+	  /*! @} *//* dkops */
+
+/******************************************************************************
+ *  Function signature-generating macros
+ *****************************************************************************/
+
+/*!
+ * @defgroup drsigs Driver Signatures
+ *
+ * These macros will define the entry point signatures for interrupt handlers;
+ * driver initialization and shutdown; device open/close; etc.
+ *
+ * There are two versions of each macro for a given Driver Entry Point.  The
+ * first version is used to define a function and its implementation in the
+ * driver.c file, e.g. #OS_DEV_INIT().
+ *
+ * The second form is used whenever a forward declaration (prototype) is
+ * needed.  It has the letters @c _DCL appended to the name of the defintion
+ * function, and takes only the first two arguments (driver_name and
+ * function_name).  These are not otherwise mentioned in this documenation.
+ *
+ * There is a third form used when a reference to a function is required, for
+ * instance when passing the routine as a pointer to a function.  It has the
+ * letters @c _REF appended to it, and takes only the first two arguments
+ * (driver_name and function_name).  These functions are not otherwise
+ * mentioned in this documentation.
+ *
+ * (Note that these two extra forms are required because of the
+ * possibility/likelihood of having a 'wrapper function' which invokes the
+ * generic function with expected arguments.  An alternative would be to have a
+ * generic function which isn't able to get at any arguments directly, but
+ * would be equipped with macros which could get at information passed in.
+ *
+ * Example:
+ *
+ * (in a header file)
+ * @code
+ * OS_DEV_INIT_DCL(widget, widget_init);
+ * @endcode
+ *
+ * (in an implementation file)
+ * @code
+ * OS_DEV_INIT(widget, widget_init)
+ * {
+ *     os_dev_init_return(TRUE);
+ * }
+ * @endcode
+ *
+ */
+
+/*! @addtogroup drsigs */
+/*! @{ */
+
+/*!
+ * Define a function which will handle device initialization
+ *
+ * This is tne driver initialization routine.  This is normally where the
+ * part would be initialized; queues, locks, interrupts handlers defined;
+ * long-term dynamic memory allocated for driver use; etc.
+ *
+ * @param function_name   The name of the portable initialization function.
+ *
+ * @return  A call to #os_dev_init_return()
+ *
+ */
+#define OS_DEV_INIT(function_name)                                            \
+module_init(function_name);                                                   \
+static int __init function_name (void)
+
+/*! Make declaration for driver init function.
+ * @param function_name foo
+ */
+#define OS_DEV_INIT_DCL(function_name)                                        \
+static int __init function_name (void);
+
+/*!
+ * Generate a function reference to the driver's init function.
+ * @param function_name   Name of the OS_DEV_INIT() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_INIT_REF(function_name)                                        \
+function_name
+
+/*!
+ * Define a function which will handle device shutdown
+ *
+ * This is the inverse of the #OS_DEV_INIT() routine.
+ *
+ * @param function_name   The name of the portable driver shutdown routine.
+ *
+ * @return  A call to #os_dev_shutdown_return()
+ *
+ */
+#define OS_DEV_SHUTDOWN(function_name)                                        \
+module_exit(function_name);                                                   \
+static void function_name(void)
+
+/*!
+ * Generate a function reference to the driver's shutdown function.
+ * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_SHUTDOWN_DCL(function_name)                                    \
+static void function_name(void);
+
+/*!
+ * Generate a reference to driver's shutdown function
+ * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
+*/
+
+#define OS_DEV_SHUTDOWN_REF(function_name)                                    \
+function_name
+
+/*!
+ * Define a function which will open the device for a user.
+ *
+ * @param function_name The name of the driver open() function
+ *
+ * @return  A call to #os_dev_open_return()
+ */
+#define OS_DEV_OPEN(function_name)                                            \
+static int function_name(struct inode* inode_p_, struct file* file_p_)
+
+/*!
+ * Declare prototype for an open() function.
+ *
+ * @param function_name The name of the OS_DEV_OPEN() function.
+ */
+#define OS_DEV_OPEN_DCL(function_name)                                        \
+OS_DEV_OPEN(function_name);
+
+/*!
+ * Generate a function reference to the driver's open() function.
+ * @param function_name   Name of the OS_DEV_OPEN() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_OPEN_REF(function_name)                                        \
+function_name
+
+/*!
+ * Define a function which will handle a user's ioctl() request
+ *
+ * @param function_name The name of the driver ioctl() function
+ *
+ * @return A call to #os_dev_ioctl_return()
+ */
+#define OS_DEV_IOCTL(function_name)                                           \
+static int function_name(struct file *file_p_,                                 \
+                     unsigned int cmd_, unsigned long data_)
+
+/*! Boo. */
+#define OS_DEV_IOCTL_DCL(function_name)                                       \
+OS_DEV_IOCTL(function_name);
+
+/*!
+ * Generate a function reference to the driver's ioctl() function.
+ * @param function_name   Name of the OS_DEV_IOCTL() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_IOCTL_REF(function_name)                                       \
+function_name
+
+/*!
+ * Define a function which will handle a user's mmap() request
+ *
+ * @param function_name The name of the driver mmap() function
+ *
+ * @return A call to #os_dev_ioctl_return()
+ */
+#define OS_DEV_MMAP(function_name)                                            \
+int function_name(struct file* file_p_, struct vm_area_struct* vma_)
+
+#define OS_DEV_MMAP_DCL(function_name)                                        \
+OS_DEV_MMAP(function_name);
+
+#define OS_DEV_MMAP_REF(function_name)                                        \
+function_name
+
+/* Retrieve the context to the memory structure that is to be MMAPed */
+#define os_mmap_memory_ctx() (vma_)
+
+/* Determine the size of the requested MMAP region*/
+#define os_mmap_memory_size() (vma_->vm_end - vma_->vm_start)
+
+/* Determine the base address of the requested MMAP region*/
+#define os_mmap_user_base() (vma_->vm_start)
+
+/*!
+ * Declare prototype for an read() function.
+ *
+ * @param function_name The name of the driver read function.
+ */
+#define OS_DEV_READ_DCL(function_name)                                        \
+OS_DEV_READ(function_name);
+
+/*!
+ * Generate a function reference to the driver's read() routine
+ * @param function_name   Name of the OS_DEV_READ() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_READ_REF(function_name)                                        \
+function_name
+
+/*!
+ * Define a function which will handle a user's write() request
+ *
+ * @param function_name The name of the driver write() function
+ *
+ * @return A call to #os_dev_write_return()
+ */
+#define OS_DEV_WRITE(function_name)                                           \
+static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
+                     size_t count_bytes_, loff_t* file_position_)
+
+/*!
+ * Declare prototype for an write() function.
+ *
+ * @param function_name The name of the driver write function.
+ */
+#define OS_DEV_WRITE_DCL(function_name)                                       \
+OS_DEV_WRITE(function_name);
+
+/*!
+ * Generate a function reference to the driver's write() routine
+ * @param function_name   Name of the OS_DEV_WRITE() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_WRITE_REF(function_name)                                       \
+function_name
+
+/*!
+ * Define a function which will close the device - opposite of OS_DEV_OPEN()
+ *
+ * @param function_name The name of the driver close() function
+ *
+ * @return A call to #os_dev_close_return()
+ */
+#define OS_DEV_CLOSE(function_name)                                           \
+static int function_name(struct inode* inode_p_, struct file* file_p_)
+
+/*!
+ * Declare prototype for an close() function
+ *
+ * @param function_name The name of the driver close() function.
+ */
+#define OS_DEV_CLOSE_DCL(function_name)                                       \
+OS_DEV_CLOSE(function_name);
+
+/*!
+ * Generate a function reference to the driver's close function.
+ * @param function_name   Name of the OS_DEV_CLOSE() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_CLOSE_REF(function_name)                                       \
+function_name
+
+/*!
+ * Define a function which will handle an interrupt
+ *
+ * No arguments are available to the generic function.  It must not invoke any
+ * OS functions which are illegal in a ISR.  It gets no parameters, and must
+ * have a call to #os_dev_isr_return() instead of any/all return statements.
+ *
+ * Example:
+ * @code
+ * OS_DEV_ISR(widget)
+ * {
+ *     os_dev_isr_return(1);
+ * }
+ * @endcode
+ *
+ * @param function_name The name of the driver ISR function
+ *
+ * @return   A call to #os_dev_isr_return()
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define OS_DEV_ISR(function_name)                                             \
+static irqreturn_t function_name(int N1_, void* N2_, struct pt_regs* N3_)
+#else
+#define OS_DEV_ISR(function_name)                                             \
+static irqreturn_t function_name(int N1_, void* N2_)
+#endif
+
+/*!
+ * Declare prototype for an ISR function.
+ *
+ * @param function_name The name of the driver ISR function.
+ */
+#define OS_DEV_ISR_DCL(function_name)                                         \
+OS_DEV_ISR(function_name);
+
+/*!
+ * Generate a function reference to the driver's interrupt service routine
+ * @param function_name   Name of the OS_DEV_ISR() function.
+ *
+ * @return A function pointer.
+ */
+#define OS_DEV_ISR_REF(function_name)                                         \
+function_name
+
+/*!
+ * Define a function which will operate as a background task / bottom half.
+ *
+ * Tasklet stuff isn't strictly limited to 'Device drivers', but leave it
+ * this namespace anyway.
+ *
+ * @param function_name The name of this background task function
+ *
+ * @return A call to #os_dev_task_return()
+ */
+#define OS_DEV_TASK(function_name)                                            \
+static void function_name(unsigned long data_)
+
+/*!
+ * Declare prototype for a background task / bottom half function
+ *
+ * @param function_name The name of this background task function
+ */
+#define OS_DEV_TASK_DCL(function_name)                                        \
+OS_DEV_TASK(function_name);                                                   \
+DECLARE_TASKLET(function_name ## let, function_name, 0);
+
+/*!
+ * Generate a reference to an #OS_DEV_TASK() function
+ *
+ * @param function_name   The name of the task being referenced.
+ */
+#define OS_DEV_TASK_REF(function_name)                                        \
+    (function_name ## let)
+
+	  /*! @} *//* drsigs */
+
+/*****************************************************************************
+ *  Functions/Macros for returning values from Driver Signature routines
+ *****************************************************************************/
+
+/*!
+ * Return from the #OS_DEV_INIT() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_init_return(code)                                             \
+    return code
+
+/*!
+ * Return from the #OS_DEV_SHUTDOWN() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_shutdown_return(code)                                         \
+    return
+
+/*!
+ * Return from the #OS_DEV_ISR() function
+ *
+ * The function should verify that it really was supposed to be called,
+ * and that its device needed attention, in order to properly set the
+ * return code.
+ *
+ * @param code    non-zero if interrupt handled, zero otherwise.
+ *
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define os_dev_isr_return(code)                                              \
+do {                                                                         \
+    /* Unused warnings */                                                    \
+    (void)N1_;                                                               \
+    (void)N2_;                                                               \
+    (void)N3_;                                                               \
+                                                                             \
+    return IRQ_RETVAL(code);                                                 \
+} while (0)
+#else
+#define os_dev_isr_return(code)                                              \
+do {                                                                         \
+    /* Unused warnings */                                                    \
+    (void)N1_;                                                               \
+    (void)N2_;                                                               \
+                                                                             \
+    return IRQ_RETVAL(code);                                                 \
+} while (0)
+#endif
+
+/*!
+ * Return from the #OS_DEV_OPEN() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_open_return(code)                                             \
+do {                                                                         \
+    int retcode = code;                                                      \
+                                                                             \
+    /* get rid of 'unused parameter' warnings */                             \
+    (void)inode_p_;                                                          \
+    (void)file_p_;                                                           \
+                                                                             \
+    return retcode;                                                          \
+} while (0)
+
+/*!
+ * Return from the #OS_DEV_IOCTL() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_ioctl_return(code)                                            \
+do {                                                                         \
+    int retcode = code;                                                      \
+                                                                             \
+    /* get rid of 'unused parameter' warnings */                             \
+    (void)file_p_;                                                           \
+    (void)cmd_;                                                              \
+    (void)data_;                                                             \
+                                                                             \
+    return retcode;                                                          \
+} while (0)
+
+/*!
+ * Return from the #OS_DEV_READ() function
+ *
+ * @param code    Number of bytes read, or an error code to report failure.
+ *
+ */
+#define os_dev_read_return(code)                                             \
+do {                                                                         \
+    ssize_t retcode = code;                                                  \
+                                                                             \
+    /* get rid of 'unused parameter' warnings */                             \
+    (void)file_p_;                                                           \
+    (void)user_buffer_;                                                      \
+    (void)count_bytes_;                                                      \
+    (void)file_position_;                                                    \
+                                                                             \
+    return retcode;                                                          \
+} while (0)
+
+/*!
+ * Return from the #OS_DEV_WRITE() function
+ *
+ * @param code    Number of bytes written, or an error code to report failure.
+ *
+ */
+#define os_dev_write_return(code)                                            \
+do {                                                                         \
+    ssize_t retcode = code;                                                  \
+                                                                             \
+    /* get rid of 'unused parameter' warnings */                             \
+    (void)file_p_;                                                           \
+    (void)user_buffer_;                                                      \
+    (void)count_bytes_;                                                      \
+    (void)file_position_;                                                    \
+                                                                             \
+    return retcode;                                                          \
+} while (0)
+
+/*!
+ * Return from the #OS_DEV_CLOSE() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_close_return(code)                                            \
+do {                                                                         \
+    ssize_t retcode = code;                                                  \
+                                                                             \
+    /* get rid of 'unused parameter' warnings */                             \
+    (void)inode_p_;                                                          \
+    (void)file_p_;                                                           \
+                                                                             \
+    return retcode;                                                          \
+} while (0)
+
+/*!
+ * Start the #OS_DEV_TASK() function
+ *
+ * In some implementations, this could be turned into a label for
+ * the os_dev_task_return() call.
+ *
+ * @return none
+ */
+#define os_dev_task_begin()
+
+/*!
+ * Return from the #OS_DEV_TASK() function
+ *
+ * In some implementations, this could be turned into a sleep followed
+ * by a jump back to the os_dev_task_begin() call.
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+#define os_dev_task_return(code)                                             \
+do {                                                                         \
+    /* Unused warnings */                                                    \
+    (void)data_;                                                             \
+                                                                             \
+    return;                                                                  \
+} while (0)
+
+/*****************************************************************************
+ *  Functions/Macros for accessing arguments from Driver Signature routines
+ *****************************************************************************/
+
+/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
+ *
+ */
+/* @addtogroup @drsigargs */
+/*! @{ */
+/*!
+ * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
+ * #OS_DEV_WRITE() routines to check whether user is requesting read
+ * (permission)
+ */
+#define os_dev_is_flag_read()                                                 \
+   (file_p_->f_mode & FMODE_READ)
+
+/*!
+ * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
+ * #OS_DEV_WRITE() routines to check whether user is requesting write
+ * (permission)
+ */
+#define os_dev_is_flag_write()                                                \
+   (file_p_->f_mode & FMODE_WRITE)
+
+/*!
+ * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
+ * #OS_DEV_WRITE() routines to check whether user is requesting non-blocking
+ * I/O.
+ */
+#define os_dev_is_flag_nonblock()                                             \
+   (file_p_->f_flags & (O_NONBLOCK | O_NDELAY))
+
+/*!
+ * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine major device being
+ * accessed.
+ */
+#define os_dev_get_major()                                                    \
+    (imajor(inode_p_))
+
+/*!
+ * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine minor device being
+ * accessed.
+ */
+#define os_dev_get_minor()                                                    \
+    (iminor(inode_p_))
+
+/*!
+ * Used in #OS_DEV_IOCTL() to determine which operation the user wants
+ * performed.
+ *
+ * @return Value of the operation.
+ */
+#define os_dev_get_ioctl_op()                                                 \
+    (cmd_)
+
+/*!
+ * Used in #OS_DEV_IOCTL() to return the associated argument for the desired
+ * operation.
+ *
+ * @return    A value which can be cast to a struct pointer or used as
+ *            int/long.
+ */
+#define os_dev_get_ioctl_arg()                                                \
+    (data_)
+
+/*!
+ * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to access the requested
+ * byte count.
+ *
+ * @return  (unsigned) a count of bytes
+ */
+#define os_dev_get_count()                                                    \
+    ((unsigned)count_bytes_)
+
+/*!
+ * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to return the pointer
+ * byte count.
+ *
+ * @return   char* pointer to user buffer
+ */
+#define os_dev_get_user_buffer()                                              \
+    ((void*)user_buffer_)
+
+/*!
+ * Used in OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines to
+ * get the POSIX flags field for the associated open file).
+ *
+ * @return The flags associated with the file.
+ */
+#define os_dev_get_file_flags()                                               \
+    (file_p_->f_flags)
+
+/*!
+ * Set the driver's private structure associated with this file/open.
+ *
+ * Generally used during #OS_DEV_OPEN().  See #os_dev_get_user_private().
+ *
+ * @param  struct_p   The driver data structure to associate with this user.
+ */
+#define os_dev_set_user_private(struct_p)                                     \
+    file_p_->private_data = (void*)(struct_p)
+
+/*!
+ * Get the driver's private structure associated with this file.
+ *
+ * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
+ * #OS_DEV_IOCTL(), and #OS_DEV_CLOSE().  See #os_dev_set_user_private().
+ *
+ * @return   The driver data structure to associate with this user.
+ */
+#define os_dev_get_user_private()                                             \
+    ((void*)file_p_->private_data)
+
+/*!
+ * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
+ *
+ * @return  The IRQ (integer) interrupt number.
+ */
+#define os_dev_get_irq()                                                      \
+    N1_
+
+	   /*! @} *//* drsigargs */
+
+/*!
+ * @defgroup cacheops Cache Operations
+ *
+ * These functions are for synchronizing processor cache with RAM.
+ */
+/*! @addtogroup cacheops */
+/*! @{ */
+
+/*!
+ * Flush and invalidate all cache lines.
+ */
+#if 0
+#define os_flush_cache_all()                                              \
+    flush_cache_all()
+#else
+/* Call ARM fn directly, in case L2cache=on3 not set */
+#define os_flush_cache_all()                                              \
+    v6_flush_kern_cache_all_L2()
+
+/*!
+ * ARM-routine to flush all cache.  Defined here, because it exists in no
+ * easy-access header file.  ARM-11 with L210 cache only!
+ */
+extern void v6_flush_kern_cache_all_L2(void);
+#endif
+
+/*
+ *  These macros are using part of the Linux DMA API.  They rely on the
+ *  map function to do nothing more than the equivalent clean/inv/flush
+ *  operation at the time of the mapping, and do nothing at an unmapping
+ *  call, which the Sahara driver code will never invoke.
+ */
+
+/*!
+ * Clean a range of addresses from the cache.  That is, write updates back
+ * to (RAM, next layer).
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ *
+ * @return void
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_clean_range(start,len)                                   \
+    dma_map_single(NULL, (void*)start, len, DMA_TO_DEVICE)
+#else
+#define os_cache_clean_range(start,len)                                   \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_map_area(s, len, DMA_TO_DEVICE);                   \
+    outer_clean_range(__pa(s), __pa(e));                                  \
+}
+#endif
+
+/*!
+ * Invalidate a range of addresses in the cache
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ *
+ * @return void
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_inv_range(start,len)                                     \
+    dma_map_single(NULL, (void*)start, len, DMA_FROM_DEVICE)
+#else
+#define os_cache_inv_range(start,len)                                     \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_unmap_area(s, len, DMA_FROM_DEVICE);            \
+    outer_inv_range(__pa(s), __pa(e));                                    \
+}
+#endif
+
+/*!
+ * Flush a range of addresses from the cache.  That is, perform clean
+ * and invalidate
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ *
+ * @return void
+ */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_flush_range(start,len)                                   \
+    dma_map_single(NULL, (void*)start, len, DMA_BIDIRECTIONAL)
+#else
+#define os_cache_flush_range(start,len)                                   \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_flush_range(s, e);                                               \
+    outer_flush_range(__pa(s), __pa(e));                                  \
+}
+#endif
+
+	  /*! @} *//* cacheops */
+
+#endif				/* LINUX_PORT_H */
diff --git a/drivers/mxc/security/sahara2/include/platform_abstractions.h b/drivers/mxc/security/sahara2/include/platform_abstractions.h
new file mode 100644
index 0000000..5fc87cc
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/platform_abstractions.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file platform_abstractions.h
+ */
diff --git a/drivers/mxc/security/sahara2/include/portable_os.h b/drivers/mxc/security/sahara2/include/portable_os.h
new file mode 100644
index 0000000..445acd5
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/portable_os.h
@@ -0,0 +1,1453 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef PORTABLE_OS_H
+#define PORTABLE_OS_H
+
+/***************************************************************************/
+
+/*
+ * Add support for your target OS by checking appropriate flags and then
+ * including the appropriate file.  Don't forget to document the conditions
+ * in the later documentation section at the beginning of the
+ * DOXYGEN_PORTABLE_OS_DOC.
+ */
+
+#if defined(LINUX_KERNEL)
+
+#include "linux_port.h"
+
+#elif defined(PORTABLE_OS)
+
+#include "check_portability.h"
+
+#else
+
+#error Target OS unsupported or unspecified
+
+#endif
+
+
+/***************************************************************************/
+
+/*!
+ * @file portable_os.h
+ *
+ * This file should be included by portable driver code in order to gain access
+ * to the OS-specific header files.  It is the only OS-related header file that
+ * the writer of a portable driver should need.
+ *
+ * This file also contains the documentation for the common API.
+ *
+ * Begin reading the documentation for this file at the @ref index "main page".
+ *
+ */
+
+/*!
+ * @if USE_MAINPAGE
+ * @mainpage Generic OS API for STC Drivers
+ * @endif
+ *
+ * @section intro_sec Introduction
+ *
+ * This defines the API / kernel programming environment for portable drivers.
+ *
+ * This API is broken up into several functional areas.  It greatly limits the
+ * choices of a device-driver author, but at the same time should allow for
+ * greater portability of the resulting code.
+ *
+ * Each kernel-to-driver function (initialization function, interrupt service
+ * routine, etc.) has a 'portable signature' which must be used, and a specific
+ * function which must be called to generate the return statement.  There is
+ * one exception, a background task or "bottom half" routine, which instead has
+ * a specific structure which must be followed.  These signatures and function
+ * definitions are found in @ref drsigs.
+ *
+ * None of these kernel-to-driver functions seem to get any arguments passed to
+ * them.  Instead, there are @ref drsigargs which allow one of these functions
+ * to get at fairly generic parts of its calling arguments, if there are any.
+ *
+ * Almost every driver will have some need to call the operating system
+ * @ref dkops is the list of services which are available to the driver.
+ *
+ *
+ * @subsection warn_sec Warning
+ *
+ * The specifics of the types, values of the various enumerations
+ * (unless specifically stated, like = 0), etc., are only here for illustrative
+ * purposes.  No attempts should be made to make use of any specific knowledge
+ * gleaned from this documentation.  These types are only meant to be passed in
+ * and out of the API, and their contents are to be handled only by the
+ * provided OS-specific functions.
+ *
+ * Also, note that the function may be provided as macros in some
+ * implementations, or vice versa.
+ *
+ *
+ * @section dev_sec Writing a Portable Driver
+ *
+ * First off, writing a portable driver means calling no function in an OS
+ * except what is available through this header file.
+ *
+ * Secondly, all OS-called functions in your driver must be invoked and
+ * referenced through the signature routines.
+ *
+ * Thirdly, there might be some rules which you can get away with ignoring or
+ * violating on one OS, yet will cause your code not to be portable to a
+ * different OS.
+ *
+ *
+ * @section limit_sec Limitations
+ *
+ * This API is not expected to handle every type of driver which may be found
+ * in an operating system.  For example, it will not be able to handle the
+ * usual design for something like a UART driver, where there are multiple
+ * logical devices to access, because the design usually calls for some sort of
+ * indication to the #OS_DEV_TASK() function or OS_DEV_ISR() to indicate which
+ * channel is to be serviced by that instance of the task/function.  This sort
+ * of argument is missing in this API for functions like os_dev_schedule_task() and
+ * os_register_interrupt().
+ *
+ *
+ * @section port_guide Porting Guidelines
+ *
+ * This section is intended for a developer who needs to port the header file
+ * to an operating system which is not yet supported.
+ *
+ * This interface allows for a lot of flexibility when it comes to porting to
+ * an operating systems device driver interface.  There are three main areas to
+ * examine:  The use of Driver Routine Signatures, the use of Driver Argument
+ * Access functions, the Calls to Kernel Functions, and Data Types.
+ *
+ *
+ * @subsection port_sig Porting Driver Routine Signatures
+ *
+ * The three macros for each function (e.g. #OS_DEV_INIT(), #OS_DEV_INIT_DCL(),
+ * and #OS_DEV_INIT_REF()) allow the flexibility of having a 'wrapper' function
+ * with the OS-required signature, which would then call the user's function
+ * with some different signature.
+ *
+ * The first form would lay down the wrapper function, followed by the
+ * signature for the user function.  The second form would lay down just the
+ * signatures for both functions, and the last function would reference the
+ * wrapper function, since that is the interface function called by the OS.
+ *
+ * Note that the driver author has no visibility at all to the signature of the
+ * routines.  The author can access arguments only through a limited set of
+ * functions, and must return via another function.
+ *
+ * The Return Functions allow a lot of flexibility in converting the return
+ * value, or not returning a value at all.  These will likely be implemented as
+ * macros.
+ *
+ *
+ * @subsection port_arg Porting Driver Argument Access Functions
+ *
+ * The signatures defined by the guide will usually be replaced with macro
+ * definitions.
+ *
+ *
+ * @subsection port_dki Porting Calls to Kernel Functions
+ *
+ * The signatures defined by the guide may be replaced with macro definitions,
+ * if that makes more sense.
+ *
+ * Implementors are free to ignore arguments which are not applicable to their
+ * OS.
+ *
+ * @subsection port_datatypes Porting Data Types
+ *
+ *
+ */
+
+/***************************************************************************
+ * Compile flags
+ **************************************************************************/
+
+/*
+ * This compile flag should only be turned on when running doxygen to generate
+ * the API documentation.
+ */
+#ifdef DOXYGEN_PORTABLE_OS_DOC
+
+/*!
+ * @todo module_init()/module_cleanup() for Linux need to be added to OS
+ * abstractions.  Also need EXPORT_SYMBOL() equivalent??
+ *
+ */
+
+/* Drop OS differentation documentation here */
+
+/*!
+ * \#define this flag to build your driver as a Linux driver
+ */
+#define LINUX
+
+/* end OS differentation documentation */
+
+/*!
+ * Symbol to give version number of the implementation file.  Earliest
+ * definition is in version 1.1, with value 101 (to mean version 1.1)
+ */
+#define PORTABLE_OS_VERSION 101
+
+/*
+ * NOTICE: The following definitions (the rest of the file) are not meant ever
+ * to be compiled.  Instead, they are the documentation for the portable OS
+ * API, to be used by driver writers.
+ *
+ * Each individual OS port will define each of these types, functions, or
+ * macros as appropriate to the target OS. This is why they are under the
+ * DOXYGEN_PORTABLE_OS_DOC flag.
+ */
+
+/***************************************************************************
+ * Type definitions
+ **************************************************************************/
+
+/*!
+ * Type used for registering and deregistering interrupts.
+ *
+ * This is typically an interrupt channel number.
+ */
+typedef int os_interrupt_id_t;
+
+/*!
+ * Type used as handle for a process
+ *
+ * See #os_get_process_handle() and #os_send_signal().
+ */
+typedef int os_process_handle_t;
+
+/*!
+ * Generic return code for functions which need such a thing.
+ *
+ * No knowledge should be assumed of the value of any of these symbols except
+ * that @c OS_ERROR_OK_S is guaranteed to be zero.
+ *
+ * @todo Any other named values? What about (-EAGAIN?  -ERESTARTSYS? Are they
+ * too Linux/Unix-specific read()/write() return values) ?
+ */
+typedef enum {
+	OS_ERROR_OK_S = 0,	/*!< Success  */
+	OS_ERROR_FAIL_S,	/*!< Generic driver failure */
+	OS_ERROR_NO_MEMORY_S,	/*!< Failure to acquire/use memory  */
+	OS_ERROR_BAD_ADDRESS_S,	/*!< Bad address  */
+	OS_ERROR_BAD_ARG_S	/*!< Bad input argument */
+} os_error_code;
+
+/*!
+ * Handle to a lock.
+ */
+typedef int *os_lock_t;
+
+/*!
+ * Context while locking.
+ */
+typedef int os_lock_context_t;
+
+/*!
+ * An object which can be slept on and later used to wake any/all sleepers.
+ */
+typedef int os_sleep_object_t;
+
+/*!
+ * Driver registration handle
+ */
+typedef void *os_driver_reg_t;
+
+/*!
+ * Function signature for an #OS_DEV_INIT() function.
+ *
+ * @return  A call to os_dev_init_return() function.
+ */
+typedef void (*os_init_function_t) (void);
+
+/*!
+ * Function signature for an #OS_DEV_SHUTDOWN() function.
+ *
+ * @return  A call to os_dev_shutdown_return() function.
+ */
+typedef void (*os_shutdown_function_t) (void);
+
+/*!
+ * Function signature for a user-driver function.
+ *
+ * @return  A call to the appropriate os_dev_xxx_return() function.
+ */
+typedef void (*os_user_function_t) (void);
+
+/*!
+ * Function signature for the portable interrupt handler
+ *
+ * While it would be nice to know which interrupt is being serviced, the
+ * Least Common Denominator rule says that no arguments get passed in.
+ *
+ * @return  A call to #os_dev_isr_return()
+ */
+typedef void (*os_interrupt_handler_t) (void);
+
+/*!
+ * Function signature for a task function
+ *
+ * Many task function definitions get some sort of generic argument so that the
+ * same function can run across many (queues, channels, ...) as separate task
+ * instances.  This has been left out of this API.
+ *
+ * This function must be structured as documented by #OS_DEV_TASK().
+ *
+ */
+typedef void (*os_task_fn_t) (void);
+
+/*!
+ *  Function types which can be associated with driver entry points.  These are
+ *  used in os_driver_add_registration().
+ *
+ *  Note that init and shutdown are absent.
+ */
+typedef enum {
+	OS_FN_OPEN,		/*!< open() operation handler. */
+	OS_FN_CLOSE,		/*!< close() operation handler. */
+	OS_FN_READ,		/*!< read() operation handler. */
+	OS_FN_WRITE,		/*!< write() operation handler. */
+	OS_FN_IOCTL,		/*!< ioctl() operation handler. */
+	OS_FN_MMAP		/*!< mmap() operation handler. */
+} os_driver_fn_t;
+
+/***************************************************************************
+ * Driver-to-Kernel Operations
+ **************************************************************************/
+
+/*!
+ * @defgroup dkops Driver-to-Kernel Operations
+ *
+ * These are the operations which drivers should call to get the OS to perform
+ * services.
+ */
+
+/*! @addtogroup dkops */
+/*! @{ */
+
+/*!
+ * Register an interrupt handler.
+ *
+ * @param driver_name    The name of the driver
+ * @param interrupt_id   The interrupt line to monitor (type
+ *                       #os_interrupt_id_t)
+ * @param function       The function to be called to handle an interrupt
+ *
+ * @return #os_error_code
+ */
+os_error_code os_register_interrupt(char *driver_name,
+				    os_interrupt_id_t interrupt_id,
+				    os_interrupt_handler_t function);
+
+/*!
+ * Deregister an interrupt handler.
+ *
+ * @param interrupt_id   The interrupt line to stop monitoring
+ *
+ * @return #os_error_code
+ */
+os_error_code os_deregister_interrupt(os_interrupt_id_t interrupt_id);
+
+/*!
+ * Initialize driver registration.
+ *
+ * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
+ * calls, then it needs to register their location with the kernel so that they
+ * get associated with the device.
+ *
+ * @param handle  The handle object to be used with this registration.  The
+ *                object must live (be in memory somewhere) at least until
+ *                os_driver_remove_registration() is called.
+ *
+ * @return An os error code.
+ */
+os_error_code os_driver_init_registration(os_driver_reg_t handle);
+
+/*!
+ * Add a function registration to driver registration.
+ *
+ * @param handle    The handle used with #os_driver_init_registration().
+ * @param name      Which function is being supported.
+ * @param function  The result of a call to a @c _REF version of one of the
+ *                  driver function signature macros
+ *                  driver function signature macros
+ * @return void
+ */
+void os_driver_add_registration(os_driver_reg_t handle, os_driver_fn_t name,
+				void *function);
+
+/*!
+ * Finalize the driver registration with the kernel.
+ *
+ * Upon return from this call, the driver may begin receiving calls at the
+ * defined entry points.
+ *
+ * @param handle    The handle used with #os_driver_init_registration().
+ * @param major      The major device number to be associated with the driver.
+ *                   If this value is zero, a major number may be assigned.
+ *                   See #os_driver_get_major() to determine final value.
+ *                   #os_driver_remove_registration().
+ * @param driver_name The driver name.  Can be used as part of 'device node'
+ *                   name on platforms which support such a feature.
+ *
+ * @return  An error code
+ */
+os_error_code os_driver_complete_registration(os_driver_reg_t handle,
+					      int major, char *driver_name);
+
+/*!
+ * Get driver Major Number from handle after a successful registration.
+ *
+ * @param   handle  A handle which has completed registration.
+ *
+ * @return The major number (if any) associated with the handle.
+ */
+uint32_t os_driver_get_major(os_driver_reg_t handle);
+
+/*!
+ * Remove the driver's registration with the kernel.
+ *
+ * Upon return from this call, the driver not receive any more calls at the
+ * defined entry points (other than ISR and shutdown).
+ *
+ * @param major       The major device number to be associated with the driver.
+ * @param driver_name The driver name
+ *
+ * @return  An error code.
+ */
+os_error_code os_driver_remove_registration(int major, char *driver_name);
+
+/*!
+ * Print a message to console / into log file.  After the @c msg argument a
+ * number of printf-style arguments may be added.  Types should be limited to
+ * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
+ * pointers, and floating point).
+ *
+ * @param  msg  The message to print to console / system log
+ *
+ * @return (void)
+ */
+void os_printk(char *msg, ...);
+
+/*!
+ * Allocate some kernel memory
+ *
+ * @param amount   Number of 8-bit bytes to allocate
+ * @param flags    Some indication of purpose of memory (needs definition)
+ *
+ * @return  Pointer to allocated memory, or NULL if failed.
+ */
+void *os_alloc_memory(unsigned amount, int flags);
+
+/*!
+ * Free some kernel memory
+ *
+ * @param location  The beginning of the region to be freed.
+ *
+ * Do some OSes have separate free() functions which should be
+ * distinguished by passing in @c flags here, too? Don't some also require the
+ * size of the buffer being freed?  Perhaps separate routines for each
+ * alloc/free pair (DMAable, etc.)?
+ */
+void os_free_memory(void *location);
+
+/*!
+ * Allocate cache-coherent memory
+ *
+ * @param       amount     Number of bytes to allocate
+ * @param[out]  dma_addrp  Location to store physical address of allocated
+ *                         memory.
+ * @param       flags      Some indication of purpose of memory (needs
+ *                         definition).
+ *
+ * @return (virtual space) pointer to allocated memory, or NULL if failed.
+ *
+ */
+void *os_alloc_coherent(unsigned amount, uint32_t * dma_addrp, int flags);
+
+/*!
+ * Free cache-coherent memory
+ *
+ * @param       size       Number of bytes which were allocated.
+ * @param[out]  virt_addr  Virtual(kernel) address of memory.to be freed, as
+ *                         returned by #os_alloc_coherent().
+ * @param[out]  dma_addr   Physical address of memory.to be freed, as returned
+ *                         by #os_alloc_coherent().
+ *
+ * @return void
+ *
+ */
+void os_free_coherent(unsigned size, void *virt_addr, uint32_t dma_addr);
+
+/*!
+ * Map an I/O space into kernel memory space
+ *
+ * @param start       The starting address of the (physical / io space) region
+ * @param range_bytes The number of bytes to map
+ *
+ * @return A pointer to the mapped area, or NULL on failure
+ */
+void *os_map_device(uint32_t start, unsigned range_bytes);
+
+/*!
+ * Unmap an I/O space from kernel memory space
+ *
+ * @param start       The starting address of the (virtual) region
+ * @param range_bytes The number of bytes to unmap
+ *
+ * @return None
+ */
+void os_unmap_device(void *start, unsigned range_bytes);
+
+/*!
+ * Copy data from Kernel space to User space
+ *
+ * @param to   The target location in user memory
+ * @param from The source location in kernel memory
+ * @param size The number of bytes to be copied
+ *
+ * @return #os_error_code
+ */
+os_error_code os_copy_to_user(void *to, void *from, unsigned size);
+
+/*!
+ * Copy data from User space to Kernel space
+ *
+ * @param to   The target location in kernel memory
+ * @param from The source location in user memory
+ * @param size The number of bytes to be copied
+ *
+ * @return #os_error_code
+ */
+os_error_code os_copy_from_user(void *to, void *from, unsigned size);
+
+/*!
+ * Read an 8-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+uint8_t os_read8(uint8_t * register_address);
+
+/*!
+ * Write an 8-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+void os_write8(uint8_t * register_address, uint8_t value);
+
+/*!
+ * Read a 16-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+uint16_t os_read16(uint16_t * register_address);
+
+/*!
+ * Write a 16-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+void os_write16(uint16_t * register_address, uint16_t value);
+
+/*!
+ * Read a 32-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+uint32_t os_read32(uint32_t * register_address);
+
+/*!
+ * Write a 32-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+void os_write32(uint32_t * register_address, uint32_t value);
+
+/*!
+ * Read a 64-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @return                  The value in the register
+ */
+uint64_t os_read64(uint64_t * register_address);
+
+/*!
+ * Write a 64-bit device register
+ *
+ * @param register_address  The (bus) address of the register to write to
+ * @param value             The value to write into the register
+ */
+void os_write64(uint64_t * register_address, uint64_t value);
+
+/*!
+ * Prepare a task to execute the given function.  This should only be done once
+ * per task, during the driver's initialization routine.
+ *
+ * @param task_fn   Name of the OS_DEV_TASK() function to be created.
+ *
+ * @return an OS ERROR code.
+ */
+os_error os_create_task(os_task_fn_t * task_fn);
+
+/*!
+ * Run the task associated with an #OS_DEV_TASK() function
+ *
+ * The task will begin execution sometime after or during this call.
+ *
+ * @param task_fn   Name of the OS_DEV_TASK() function to be scheduled.
+ *
+ * @return void
+ */
+void os_dev_schedule_task(os_task_fn_t * task_fn);
+
+/*!
+ * Make sure that task is no longer running and will no longer run.
+ *
+ * This function will not return until both are true.  This is useful when
+ * shutting down a driver.
+ *
+ * @param task_fn   Name of the OS_DEV_TASK() funciton to be stopped.
+ *
+ */
+void os_stop_task(os_task_fn_t * task_fn);
+
+/*!
+ * Delay some number of microseconds
+ *
+ * Note that this is a busy-loop, not a suspension of the task/process.
+ *
+ * @param  msecs   The number of microseconds to delay
+ *
+ * @return void
+ */
+void os_mdelay(unsigned long msecs);
+
+/*!
+ * Calculate virtual address from physical address
+ *
+ * @param pa    Physical address
+ *
+ * @return virtual address
+ *
+ * @note this assumes that addresses are 32 bits wide
+ */
+void *os_va(uint32_t pa);
+
+/*!
+ * Calculate physical address from virtual address
+ *
+ *
+ * @param va    Virtual address
+ *
+ * @return physical address
+ *
+ * @note this assumes that addresses are 32 bits wide
+ */
+uint32_t os_pa(void *va);
+
+/*!
+ * Allocate and initialize a lock, returning a lock handle.
+ *
+ * The lock state will be initialized to 'unlocked'.
+ *
+ * @return A lock handle, or NULL if an error occurred.
+ */
+os_lock_t os_lock_alloc_init(void);
+
+/*!
+ * Acquire a lock.
+ *
+ * This function should only be called from an interrupt service routine.
+ *
+ * @param   lock_handle  A handle to the lock to acquire.
+ *
+ * @return void
+ */
+void os_lock(os_lock_t lock_handle);
+
+/*!
+ * Unlock a lock.  Lock must have been acquired by #os_lock().
+ *
+ * @param   lock_handle  A handle to the lock to unlock.
+ *
+ * @return void
+ */
+void os_unlock(os_lock_t lock_handle);
+
+/*!
+ * Acquire a lock in non-ISR context
+ *
+ * This function will spin until the lock is available.
+ *
+ * @param lock_handle  A handle of the lock to acquire.
+ * @param context      Place to save the before-lock context
+ *
+ * @return void
+ */
+void os_lock_save_context(os_lock_t lock_handle, os_lock_context_t context);
+
+/*!
+ * Release a lock in non-ISR context
+ *
+ * @param lock_handle  A handle of the lock to release.
+ * @param context      Place where before-lock context was saved.
+ *
+ * @return void
+ */
+void os_unlock_restore_context(os_lock_t lock_handle,
+			       os_lock_context_t context);
+
+/*!
+ * Deallocate a lock handle.
+ *
+ * @param lock_handle   An #os_lock_t that has been allocated.
+ *
+ * @return void
+ */
+void os_lock_deallocate(os_lock_t lock_handle);
+
+/*!
+ * Determine process handle
+ *
+ * The process handle of the current user is returned.
+ *
+ * @return   A handle on the current process.
+ */
+os_process_handle_t os_get_process_handle();
+
+/*!
+ * Send a signal to a process
+ *
+ * @param  proc   A handle to the target process.
+ * @param  sig    The POSIX signal to send to that process.
+ */
+void os_send_signal(os_process_handle_t proc, int sig);
+
+/*!
+ * Get some random bytes
+ *
+ * @param buf    The location to store the random data.
+ * @param count  The number of bytes to store.
+ *
+ * @return  void
+ */
+void os_get_random_bytes(void *buf, unsigned count);
+
+/*!
+ * Go to sleep on an object.
+ *
+ * Example: code = os_sleep(my_queue, available_count == 0, 0);
+ *
+ * @param object    The object on which to sleep
+ * @param condition An expression to check for sleep completion.  Must be
+ *                  coded so that it can be referenced more than once inside
+ *                  macro, i.e., no ++ or other modifying expressions.
+ * @param atomic    Non-zero if sleep must not return until condition.
+ *
+ * @return error code -- OK or sleep interrupted??
+ */
+os_error_code os_sleep(os_sleep_object_t object, unsigned condition,
+		       unsigned atomic);
+
+/*!
+ * Wake up whatever is sleeping on sleep object
+ *
+ * @param object  The object on which things might be sleeping
+ *
+ * @return none
+ */
+void os_wake_sleepers(os_sleep_object_t object);
+
+	  /*! @} *//* dkops */
+
+/*****************************************************************************
+ *  Function-signature-generating macros
+ *****************************************************************************/
+
+/*!
+ * @defgroup drsigs Driver Function Signatures
+ *
+ * These macros will define the entry point signatures for interrupt handlers;
+ * driver initialization and shutdown; device open/close; etc.  They are to be
+ * used whenever the Kernel will call into the Driver.  They are not
+ * appropriate for driver calls to other routines in the driver.
+ *
+ * There are three versions of each macro for a given Driver Entry Point.  The
+ * first version is used to define a function and its implementation in the
+ * driver.c file, e.g. #OS_DEV_INIT().
+ *
+ * The second form is used whenever a forward declaration (prototype) is
+ * needed.  It has the letters @c _DCL appended to the name of the definition
+ * function.  These are not otherwise mentioned in this documenation.
+ *
+ * There is a third form used when a reference to a function is required, for
+ * instance when passing the routine as a pointer to a function.  It has the
+ * letters @c _REF appended to the name of the definition function
+ * (e.g. DEV_IOCTL_REF).
+ *
+ * Note that these two extra forms are required because of the possibility of
+ * having an invisible 'wrapper function' created by the os-specific header
+ * file which would need to be invoked by the operating system, and which in
+ * turn would invoke the generic function.
+ *
+ * Example:
+ *
+ * (in a header file)
+ * @code
+ * OS_DEV_INIT_DCL(widget_init);
+ * OS_DEV_ISR_DCL(widget_isr);
+ * @endcode
+ *
+ * (in an implementation file)
+ * @code
+ * OS_DEV_INIT(widget, widget_init)
+ * {
+ *
+ *     os_register_interrupt("widget", WIDGET_IRQ, OS_DEV_ISR_REF(widget_isr));
+ *
+ *     os_dev_init_return(OS_RETURN_NO_ERROR_S);
+ * }
+ *
+ * OS_DEV_ISR(widget_isr)
+ * {
+ *     os_dev_isr_return(TRUE);
+ * }
+ * @endcode
+ */
+
+/*! @addtogroup drsigs */
+/*! @{ */
+
+/*!
+ * Define a function which will handle device initialization
+ *
+ * This is tne driver initialization routine.  This is normally where the
+ * part would be initialized; queues, locks, interrupts handlers defined;
+ * long-term dynamic memory allocated for driver use; etc.
+ *
+ * @param function_name   The name of the portable initialization function.
+ *
+ * @return  A call to #os_dev_init_return()
+ *
+ */
+#define OS_DEV_INIT(function_name)
+
+/*!
+ * Define a function which will handle device shutdown
+ *
+ * This is the reverse of the #OS_DEV_INIT() routine.
+ *
+ * @param function_name   The name of the portable driver shutdown routine.
+ *
+ * @return  A call to #os_dev_shutdown_return()
+ */
+#define OS_DEV_SHUTDOWN(function_name)
+
+/*!
+ * Define a function which will open the device for a user.
+ *
+ * @param function_name The name of the driver open() function
+ *
+ * @return A call to #os_dev_open_return()
+ */
+#define OS_DEV_OPEN(function_name)
+
+/*!
+ * Define a function which will handle a user's ioctl() request
+ *
+ * @param function_name The name of the driver ioctl() function
+ *
+ * @return A call to #os_dev_ioctl_return()
+ */
+#define OS_DEV_IOCTL(function_name)
+
+/*!
+ * Define a function which will handle a user's read() request
+ *
+ * @param function_name The name of the driver read() function
+ *
+ * @return A call to #os_dev_read_return()
+ */
+#define OS_DEV_READ(function_name)
+
+/*!
+ * Define a function which will handle a user's write() request
+ *
+ * @param function_name The name of the driver write() function
+ *
+ * @return A call to #os_dev_write_return()
+ */
+#define OS_DEV_WRITE(function_name)
+
+/*!
+ * Define a function which will handle a user's mmap() request
+ *
+ * The mmap() function requests the driver to map some memory into user space.
+ *
+ * @todo Determine what support functions are needed for mmap() handling.
+ *
+ * @param function_name The name of the driver mmap() function
+ *
+ * @return A call to #os_dev_mmap_return()
+ */
+#define OS_DEV_MMAP(function_name)
+
+/*!
+ * Define a function which will close the device - opposite of OS_DEV_OPEN()
+ *
+ * @param function_name The name of the driver close() function
+ *
+ * @return A call to #os_dev_close_return()
+ */
+#define OS_DEV_CLOSE(function_name)
+
+/*!
+ * Define a function which will handle an interrupt
+ *
+ * No arguments are available to the generic function.  It must not invoke any
+ * OS functions which are illegal in a ISR.  It gets no parameters, and must
+ * have a call to #os_dev_isr_return() instead of any/all return statements.
+ *
+ * Example:
+ * @code
+ * OS_DEV_ISR(widget, widget_isr, WIDGET_IRQ_NUMBER)
+ * {
+ *     os_dev_isr_return(1);
+ * }
+ * @endcode
+ *
+ * @param function_name The name of the driver ISR function
+ *
+ * @return   A call to #os_dev_isr_return()
+ */
+#define OS_DEV_ISR(function_name)
+
+/*!
+ * Define a function which will operate as a background task / bottom half.
+ *
+ * The function implementation must be structured in the following manner:
+ * @code
+ * OS_DEV_TASK(widget_task)
+ * {
+ *     OS_DEV_TASK_SETUP(widget_task);
+ *
+ *     while OS_DEV_TASK_CONDITION(widget_task) }
+ *
+ *     };
+ * }
+ * @endcode
+ *
+ * @todo In some systems the OS_DEV_TASK_CONDITION() will be an action which
+ * will cause the task to sleep on some event triggered by os_run_task().  In
+ * others, the macro will reference a variable laid down by
+ * OS_DEV_TASK_SETUP() to make sure that the loop is only performed once.
+ *
+ * @param function_name The name of this background task function
+ */
+#define OS_DEV_TASK(function_name)
+
+	  /*! @} *//* drsigs */
+
+/*! @defgroup dclsigs Routines to declare Driver Signature routines
+ *
+ * These macros drop prototypes suitable for forward-declaration of
+ * @ref drsigs "function signatures".
+ */
+
+/*! @addtogroup dclsigs */
+/*! @{ */
+
+/*!
+ * Declare prototype for the device initialization function
+ *
+ * @param function_name   The name of the portable initialization function.
+ */
+#define OS_DEV_INIT_DCL(function_name)
+
+/*!
+ * Declare prototype for the device shutdown function
+ *
+ * @param function_name   The name of the portable driver shutdown routine.
+ *
+ * @return  A call to #os_dev_shutdown_return()
+ */
+#define OS_DEV_SHUTDOWN_DCL(function_name)
+
+/*!
+ * Declare prototype for the open() function.
+ *
+ * @param function_name The name of the driver open() function
+ *
+ * @return A call to #os_dev_open_return()
+ */
+#define OS_DEV_OPEN_DCL(function_name)
+
+/*!
+ * Declare prototype for the user's ioctl() request function
+ *
+ * @param function_name The name of the driver ioctl() function
+ *
+ * @return A call to #os_dev_ioctl_return()
+ */
+#define OS_DEV_IOCTL_DCL(function_name)
+
+/*!
+ * Declare prototype for the function a user's read() request
+ *
+ * @param function_name The name of the driver read() function
+ */
+#define OS_DEV_READ_DCL(function_name)
+
+/*!
+ * Declare prototype for the user's write() request function
+ *
+ * @param function_name The name of the driver write() function
+ */
+#define OS_DEV_WRITE_DCL(function_name)
+
+/*!
+ * Declare prototype for the user's mmap() request function
+ *
+ * @param function_name The name of the driver mmap() function
+ */
+#define OS_DEV_MMAP_DCL(function_name)
+
+/*!
+ * Declare prototype for the close function
+ *
+ * @param function_name The name of the driver close() function
+ *
+ * @return A call to #os_dev_close_return()
+ */
+#define OS_DEV_CLOSE_DCL(function_name)
+
+/*!
+ * Declare prototype for the interrupt handling function
+ *
+ * @param function_name The name of the driver ISR function
+ */
+#define OS_DEV_ISR_DCL(function_name)
+
+/*!
+ * Declare prototype for a background task / bottom half function
+ *
+ * @param function_name The name of this background task function
+ */
+#define OS_DEV_TASK_DCL(function_name)
+
+	  /*! @} *//* dclsigs */
+
+/*****************************************************************************
+ *  Functions for Returning Values from Driver Signature routines
+ *****************************************************************************/
+
+/*!
+ * @defgroup retfns Functions to Return Values from Driver Signature routines
+ */
+
+/*! @addtogroup retfns */
+/*! @{ */
+
+/*!
+ * Return from the #OS_DEV_INIT() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_init_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_SHUTDOWN() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_shutdown_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_ISR() function
+ *
+ * The function should verify that it really was supposed to be called,
+ * and that its device needed attention, in order to properly set the
+ * return code.
+ *
+ * @param code    non-zero if interrupt handled, zero otherwise.
+ *
+ */
+void os_dev_isr_return(int code);
+
+/*!
+ * Return from the #OS_DEV_OPEN() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_open_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_IOCTL() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_ioctl_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_READ() function
+ *
+ * @param code    Number of bytes read, or an error code to report failure.
+ *
+ */
+void os_dev_read_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_WRITE() function
+ *
+ * @param code    Number of bytes written, or an error code to report failure.
+ *
+ */
+void os_dev_write_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_MMAP() function
+ *
+ * @param code    Number of bytes written, or an error code to report failure.
+ *
+ */
+void os_dev_mmap_return(os_error_code code);
+
+/*!
+ * Return from the #OS_DEV_CLOSE() function
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_close_return(os_error_code code);
+
+/*!
+ * Start the #OS_DEV_TASK() function
+ *
+ * In some implementations, this could be turned into a label for
+ * the os_dev_task_return() call.
+ *
+ * For a more portable interface, should this take the sleep object as an
+ * argument???
+ *
+ * @return none
+ */
+void os_dev_task_begin(void);
+
+/*!
+ * Return from the #OS_DEV_TASK() function
+ *
+ * In some implementations, this could be turned into a sleep followed
+ * by a jump back to the os_dev_task_begin() call.
+ *
+ * @param code    An error code to report success or failure.
+ *
+ */
+void os_dev_task_return(os_error_code code);
+
+	  /*! @} *//* retfns */
+
+/*****************************************************************************
+ *  Functions/Macros for accessing arguments from Driver Signature routines
+ *****************************************************************************/
+
+/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
+ *
+ */
+/* @addtogroup @drsigargs */
+/*! @{ */
+
+/*!
+ * Check whether user is requesting read (permission) on the file/device.
+ * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
+ * and #OS_DEV_WRITE() routines.
+ */
+int os_dev_is_flag_read(void);
+
+/*!
+ * Check whether user is requesting write (permission) on the file/device.
+ * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
+ * and #OS_DEV_WRITE() routines.
+ */
+int os_dev_is_flag_write(void);
+
+/*!
+ * Check whether user is requesting non-blocking I/O.  Usable in
+ * #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
+ * #OS_DEV_WRITE() routines.
+ *
+ * @todo Specify required behavior when nonblock is requested and (sufficient?)
+ * data are not available to fulfill the request.
+ *
+ */
+int os_dev_is_flag_nonblock(void);
+
+/*!
+ * Determine which major device is being accessed.  Usable in #OS_DEV_OPEN()
+ * and #OS_DEV_CLOSE().
+ */
+int os_dev_get_major(void);
+
+/*!
+ * Determine which minor device is being accessed.  Usable in #OS_DEV_OPEN()
+ * and #OS_DEV_CLOSE().
+ */
+int os_dev_get_minor(void);
+
+/*!
+ * Determine which operation the user wants performed.  Usable in
+ * #OS_DEV_IOCTL().
+ *
+ * @return  Value of the operation.
+ *
+ * @todo Define some generic way to define the individual operations.
+ */
+unsigned os_dev_get_ioctl_op(void);
+
+/*!
+ * Retrieve the associated argument for the desired operation.  Usable in
+ * #OS_DEV_IOCTL().
+ *
+ * @return    A value which can be cast to a struct pointer or used as
+ *            int/long.
+ */
+os_dev_ioctl_arg_t os_dev_get_ioctl_arg(void);
+
+/*!
+ * Determine the requested byte count. This should be the size of buffer at
+ * #os_dev_get_user_buffer(). Usable in OS_DEV_READ() and OS_DEV_WRITE()
+ * routines.
+ *
+ * @return   A count of bytes
+ */
+unsigned os_dev_get_count(void);
+
+/*!
+ * Get the pointer to the user's data buffer. Usable in OS_DEV_READ(),
+ * OS_DEV_WRITE(), and OS_DEV_MMAP() routines.
+ *
+ * @return   Pointer to user buffer (in user space).  See #os_copy_to_user()
+ *           and #os_copy_from_user().
+ */
+void *os_dev_get_user_buffer(void);
+
+/*!
+ * Get the POSIX flags field for the associated open file.  Usable in
+ * OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines.
+ *
+ * @return The flags associated with the file.
+ */
+unsigned os_dev_get_file_flags(void);
+
+/*!
+ * Set the driver's private structure associated with this file/open.
+ *
+ * Generally used during #OS_DEV_OPEN().  May also be used during
+ * #OS_DEV_READ(), #OS_DEV_WRITE(), #OS_DEV_IOCTL(), #OS_DEV_MMAP(), and
+ * #OS_DEV_CLOSE().  See also #os_dev_get_user_private().
+ *
+ * @param  struct_p   The driver data structure to associate with this user.
+ */
+void os_dev_set_user_private(void *struct_p);
+
+/*!
+ * Get the driver's private structure associated with this file.
+ *
+ * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
+ * #OS_DEV_IOCTL(), #OS_DEV_MMAP(), and #OS_DEV_CLOSE().  See
+ * also #os_dev_set_user_private().
+ *
+ * @return   The driver data structure to associate with this user.
+ */
+void *os_dev_get_user_private(void);
+
+/*!
+ * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
+ *
+ * @return  The IRQ (integer) interrupt number.
+ */
+int os_dev_get_irq(void);
+
+	  /*! @} *//* drsigargs */
+
+/*****************************************************************************
+ *  Functions for Generating References to Driver Routines
+ *****************************************************************************/
+
+/*!
+ * @defgroup drref Functions for Generating References to Driver Routines
+ *
+ * These functions will most likely be implemented as macros.  They are a
+ * necessary part of the portable API to guarantee portability.  The @c symbol
+ * type in here is the same symbol passed to the associated
+ * signature-generating macro.
+ *
+ * These macros must be used whenever referring to a
+ * @ref drsigs "driver signature function", for instance when storing or
+ * passing a pointer to the function.
+ */
+
+/*! @addtogroup drref */
+/*! @{ */
+
+/*!
+ * Generate a reference to an #OS_DEV_INIT() function
+ *
+ * @param function_name   The name of the init function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_init_function_t OS_DEV_INIT_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_SHUTDOWN() function
+ *
+ * @param function_name   The name of the shutdown function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_shutdown_function_t OS_DEV_SHUTDOWN_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_OPEN() function
+ *
+ * @param function_name   The name of the open function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_OPEN_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_CLOSE() function
+ *
+ * @param function_name   The name of the close function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_CLOSE_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_READ() function
+ *
+ * @param function_name   The name of the read function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_READ_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_WRITE() function
+ *
+ * @param function_name   The name of the write function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_WRITE_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_IOCTL() function
+ *
+ * @param function_name   The name of the ioctl function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_IOCTL_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_MMAP() function
+ *
+ * @param function_name   The name of the mmap function being referenced.
+ *
+ * @return A reference to the function
+ */
+os_user_function_t OS_DEV_MMAP_REF(symbol function_name);
+
+/*!
+ * Generate a reference to an #OS_DEV_ISR() function
+ *
+ * @param function_name   The name of the isr being referenced.
+ *
+ * @return a reference to the function
+ */
+os_interrupt_handler_t OS_DEV_ISR_REF(symbol function_name);
+
+	  /*! @} *//* drref */
+
+/*!
+ * Flush and invalidate all cache lines.
+ */
+void os_flush_cache_all(void);
+
+/*!
+ * Flush a range of addresses from the cache
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ */
+void os_cache_flush_range(void *start, uint32_t len);
+
+/*!
+ * Invalidate a range of addresses in the cache
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ */
+void os_cache_inv_range(void *start, uint32_t len);
+
+/*!
+ * Clean a range of addresses from the cache
+ *
+ * @param  start    Starting virtual address
+ * @param  len      Number of bytes to flush
+ */
+void os_cache_clean_range(void *start, uint32_t len);
+
+/*!
+  * @example widget.h
+  */
+
+/*!
+  * @example widget.c
+  */
+
+/*!
+  * @example rng_driver.h
+  */
+
+/*!
+  * @example rng_driver.c
+  */
+
+/*!
+  * @example shw_driver.h
+  */
+
+/*!
+  * @example shw_driver.c
+  */
+
+#endif				/* DOXYGEN_PORTABLE_OS_DOC */
+
+#endif				/* PORTABLE_OS_H */
diff --git a/drivers/mxc/security/sahara2/include/sah_driver_common.h b/drivers/mxc/security/sahara2/include/sah_driver_common.h
new file mode 100644
index 0000000..dffaf65
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_driver_common.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_driver_common.h
+*
+* @brief Provides types and defined values for use in the Driver Interface.
+*
+*/
+
+#ifndef SAH_DRIVER_COMMON_H
+#define SAH_DRIVER_COMMON_H
+
+#include "fsl_platform.h"
+#include <linux/mxc_sahara.h>
+#include <adaptor.h>
+
+/** This specifies the permissions for the device file. It is equivalent to
+ * chmod 666.
+ */
+#define SAHARA_DEVICE_MODE S_IFCHR | S_IRUGO | S_IWUGO
+
+/**
+* The status of entries in the Queue.
+*
+******************************************************************************/
+typedef enum
+{
+    /** This state indicates that the entry is in the queue and awaits
+     *  execution on SAHARA. */
+    SAH_STATE_PENDING,
+    /** This state indicates that the entry has been written to the SAHARA
+     *  DAR. */
+    SAH_STATE_ON_SAHARA,
+    /** This state indicates that the entry is off of SAHARA, and is awaiting
+        post-processing. */
+    SAH_STATE_OFF_SAHARA,
+    /** This state indicates that the entry is successfully executed on SAHARA,
+        and it is finished with post-processing. */
+    SAH_STATE_COMPLETE,
+    /** This state indicates that the entry caused an error or fault on SAHARA,
+     *  and it is finished with post-processing. */
+    SAH_STATE_FAILED,
+    /** This state indicates that the entry was reset via the Reset IO
+     *  Control, and it is finished with post-processing. */
+    SAH_STATE_RESET,
+    /** This state indicates that the entry was signalled from user-space and
+     *  either in the DAR, IDAR or has finished executing pending Bottom Half
+     *  processing. */
+   SAH_STATE_IGNORE,
+    /** This state indicates that the entry was signalled from user-space and
+     *  has been processed by the bottom half. */
+   SAH_STATE_IGNORED
+} sah_Queue_Status;
+
+/* any of these conditions being true indicates the descriptor's processing
+ * is complete */
+#define SAH_DESC_PROCESSED(status)                             \
+                        (((status) == SAH_STATE_COMPLETE) ||   \
+                         ((status) == SAH_STATE_FAILED  ) ||   \
+                         ((status) == SAH_STATE_RESET   ))
+
+extern os_lock_t desc_queue_lock;
+
+extern uint32_t dar_count;
+extern uint32_t interrupt_count;
+extern uint32_t done1done2_count;
+extern uint32_t done1busy2_count;
+extern uint32_t done1_count;
+
+#ifdef FSL_HAVE_SCC2
+extern void *lookup_user_partition(fsl_shw_uco_t * user_ctx,
+				   uint32_t user_base);
+#endif
+
+int sah_get_results_pointers(fsl_shw_uco_t* user_ctx, uint32_t arg);
+fsl_shw_return_t sah_get_results_from_pool(volatile fsl_shw_uco_t* user_ctx,
+                                           sah_results *arg);
+fsl_shw_return_t sah_handle_registration(fsl_shw_uco_t *user_cts);
+fsl_shw_return_t sah_handle_deregistration(fsl_shw_uco_t *user_cts);
+
+int sah_Queue_Manager_Count_Entries(int ignore_state, sah_Queue_Status state);
+unsigned long sah_Handle_Poll(sah_Head_Desc *entry);
+
+#ifdef DIAG_DRV_IF
+/******************************************************************************
+* Descriptor and Link dumping functions.
+******************************************************************************/
+void sah_Dump_Chain(const sah_Desc *chain, dma_addr_t addr);
+#endif /* DIAG_DRV_IF */
+
+#endif  /* SAH_DRIVER_COMMON_H */
diff --git a/drivers/mxc/security/sahara2/include/sah_hardware_interface.h b/drivers/mxc/security/sahara2/include/sah_hardware_interface.h
new file mode 100644
index 0000000..f507a83
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_hardware_interface.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_hardware_interface.h
+*
+* @brief Provides an interface to the SAHARA hardware registers.
+*
+*/
+
+#ifndef SAH_HARDWARE_INTERFACE_H
+#define SAH_HARDWARE_INTERFACE_H
+
+#include <sah_driver_common.h>
+#include <sah_status_manager.h>
+
+/* These values can be used with sah_HW_Write_Control(). */
+#ifdef SAHARA1
+/** Define platform as Little-Endian */
+#define CTRL_LITTLE_END     0x00000002
+/** Bit to cause endian change in transfers */
+#define CTRL_INT_EN         0x00000004
+/** Set High Assurance mode */
+#define CTRL_HA             0x00000008
+#else
+/** Bit to cause byte swapping in (data?) transfers */
+#define CTRL_BYTE_SWAP      0x00000001
+/** Bit to cause halfword swapping in (data?) transfers */
+#define CTRL_HALFWORD_SWAP  0x00000002
+/** Bit to cause endian change in (data?) transfers */
+#define CTRL_INT_EN         0x00000010
+/** Set High Assurance mode */
+#define CTRL_HA             0x00000020
+/** Disable High Assurance */
+#define CTRL_HA_DISABLE     0x00000040
+/** Reseed the RNG CHA */
+#define CTRL_RNG_RESEED     0x00000080
+#endif
+
+
+/* These values can be used with sah_HW_Write_Command(). */
+/** Reset the Sahara */
+#define CMD_RESET           0x00000001
+/** Set Sahara into Batch mode. */
+#define CMD_BATCH           0x00010000
+/** Clear the Sahara interrupt */
+#define CMD_CLR_INT_BIT     0x00000100
+/** Clear the Sahara error */
+#define CMD_CLR_ERROR_BIT   0x00000200
+
+
+/** error status register contains error */
+#define STATUS_ERROR 0x00000010
+
+/** Op status register contains op status */
+#define OP_STATUS 0x00000020
+
+
+/* High Level functions */
+int                sah_HW_Reset(void);
+fsl_shw_return_t   sah_HW_Set_HA(void);
+sah_Execute_Status sah_Wait_On_Sahara(void);
+
+/* Low Level functions */
+uint32_t    sah_HW_Read_Version(void);
+uint32_t    sah_HW_Read_Control(void);
+uint32_t    sah_HW_Read_Status(void);
+uint32_t    sah_HW_Read_Error_Status(void);
+uint32_t    sah_HW_Read_Op_Status(void);
+uint32_t    sah_HW_Read_DAR(void);
+uint32_t    sah_HW_Read_CDAR(void);
+uint32_t    sah_HW_Read_IDAR(void);
+uint32_t    sah_HW_Read_Fault_Address(void);
+uint32_t    sah_HW_Read_MM_Status(void);
+uint32_t    sah_HW_Read_Config(void);
+void        sah_HW_Write_Command(uint32_t command);
+void        sah_HW_Write_Control(uint32_t control);
+void        sah_HW_Write_DAR(uint32_t pointer);
+void        sah_HW_Write_Config(uint32_t configuration);
+
+#if defined DIAG_DRV_IF || defined(DO_DBG)
+
+void sah_Dump_Words(const char *prefix, const unsigned *data, dma_addr_t addr,
+		    unsigned length);
+#endif
+
+#endif  /* SAH_HARDWARE_INTERFACE_H */
+
+/* End of sah_hardware_interface.c */
diff --git a/drivers/mxc/security/sahara2/include/sah_interrupt_handler.h b/drivers/mxc/security/sahara2/include/sah_interrupt_handler.h
new file mode 100644
index 0000000..fc4d774
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_interrupt_handler.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_interrupt_handler.h
+*
+* @brief Provides a hardware interrupt handling mechanism for device driver.
+*
+*/
+/******************************************************************************
+*
+* CAUTION:
+*
+* MODIFICATION HISTORY:
+*
+* Date      Person     Change
+* 30/07/03  MW         Initial Creation
+*******************************************************************
+*/
+
+#ifndef SAH_INTERRUPT_HANDLER_H
+#define SAH_INTERRUPT_HANDLER_H
+
+#include <sah_driver_common.h>
+
+/******************************************************************************
+* External function declarations
+******************************************************************************/
+int sah_Intr_Init (wait_queue_head_t *wait_queue);
+void sah_Intr_Release (void);
+
+#endif  /* SAH_INTERRUPT_HANDLER_H */
diff --git a/drivers/mxc/security/sahara2/include/sah_kernel.h b/drivers/mxc/security/sahara2/include/sah_kernel.h
new file mode 100644
index 0000000..e39a61e
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_kernel.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+* @file sah_kernel.h
+*
+* @brief Provides definitions for items that user-space and kernel-space share.
+*/
+/******************************************************************************
+*
+* This file needs to be PORTED to a non-Linux platform
+*/
+
+#ifndef SAH_KERNEL_H
+#define SAH_KERNEL_H
+
+#if defined(__KERNEL__)
+
+#if defined(CONFIG_ARCH_MXC91321) || defined(CONFIG_ARCH_MXC91231)     \
+    || defined(CONFIG_ARCH_MX27)  || defined(CONFIG_ARCH_MXC92323)
+#include <mach/hardware.h>
+#define SAHA_BASE_ADDR SAHARA_BASE_ADDR
+#define SAHARA_IRQ     MXC_INT_SAHARA
+#elif defined(CONFIG_ARCH_MX5)
+#include <mach/hardware.h>
+#define SAHA_BASE_ADDR SAHARA_BASE_ADDR
+#define SAHARA_IRQ     MXC_INT_SAHARA_H0
+#else
+#include <mach/mx2.h>
+#endif
+
+#endif				/* KERNEL */
+
+/* IO Controls */
+/* The magic number 'k' is reserved for the SPARC architecture. (See <kernel
+ * source root>/Documentation/ioctl-number.txt.
+ *
+ * Note: Numbers 8-13 were used in a previous version of the API and should
+ *       be avoided.
+ */
+#define SAH_IOC_MAGIC        'k'
+#define SAHARA_HWRESET       _IO(SAH_IOC_MAGIC, 0)
+#define SAHARA_SET_HA        _IO(SAH_IOC_MAGIC, 1)
+#define SAHARA_CHK_TEST_MODE _IOR(SAH_IOC_MAGIC,2, int)
+#define SAHARA_DAR           _IO(SAH_IOC_MAGIC, 3)
+#define SAHARA_GET_RESULTS   _IO(SAH_IOC_MAGIC, 4)
+#define SAHARA_REGISTER      _IO(SAH_IOC_MAGIC, 5)
+#define SAHARA_DEREGISTER    _IO(SAH_IOC_MAGIC, 6)
+/*                                              7 */
+/*                                              8 */
+/*                                              9 */
+/*                                             10 */
+/*                                             11 */
+/*                                             12 */
+/*                                             13 */
+
+#define SAHARA_SCC_DROP_PERMS _IOWR(SAH_IOC_MAGIC, 14, scc_partition_info_t)
+#define SAHARA_SCC_SFREE     _IOWR(SAH_IOC_MAGIC, 15, scc_partition_info_t)
+
+#define SAHARA_SK_ALLOC     _IOWR(SAH_IOC_MAGIC, 16, scc_slot_t)
+#define SAHARA_SK_DEALLOC   _IOWR(SAH_IOC_MAGIC, 17, scc_slot_t)
+#define SAHARA_SK_LOAD      _IOWR(SAH_IOC_MAGIC, 18, scc_slot_t)
+#define SAHARA_SK_UNLOAD    _IOWR(SAH_IOC_MAGIC, 19, scc_slot_t)
+#define SAHARA_SK_SLOT_ENC  _IOWR(SAH_IOC_MAGIC, 20, scc_slot_t)
+#define SAHARA_SK_SLOT_DEC  _IOWR(SAH_IOC_MAGIC, 21, scc_slot_t)
+
+#define SAHARA_SCC_ENCRYPT  _IOWR(SAH_IOC_MAGIC, 22, scc_region_t)
+#define SAHARA_SCC_DECRYPT  _IOWR(SAH_IOC_MAGIC, 23, scc_region_t)
+#define SAHARA_GET_CAPS     _IOWR(SAH_IOC_MAGIC, 24, fsl_shw_pco_t)
+
+#define SAHARA_SCC_SSTATUS  _IOWR(SAH_IOC_MAGIC, 25, scc_partition_info_t)
+
+#define SAHARA_SK_READ      _IOWR(SAH_IOC_MAGIC, 29, scc_slot_t)
+
+/*! This is the name that will appear in /proc/interrupts */
+#define SAHARA_NAME         "SAHARA"
+
+/*!
+ * SAHARA IRQ number. See page 9-239 of TLICS - Motorola Semiconductors H.K.
+ * TAHITI-Lite IC Specification, Rev 1.1, Feb 2003.
+ *
+ * TAHITI has two blocks of 32 interrupts. The SAHARA IRQ is number 27
+ * in the second block. This means that the SAHARA IRQ is 27 + 32 = 59.
+ */
+#ifndef SAHARA_IRQ
+#define SAHARA_IRQ          (27+32)
+#endif
+
+/*!
+ * Device file definition. The #ifndef is here to support the unit test code
+ * by allowing it to specify a different test device.
+ */
+#ifndef SAHARA_DEVICE_SHORT
+#define SAHARA_DEVICE_SHORT "sahara"
+#endif
+
+#ifndef SAHARA_DEVICE
+#define SAHARA_DEVICE       "/dev/"SAHARA_DEVICE_SHORT
+#endif
+
+#endif				/* SAH_KERNEL_H */
+
+/* End of sah_kernel.h */
diff --git a/drivers/mxc/security/sahara2/include/sah_memory_mapper.h b/drivers/mxc/security/sahara2/include/sah_memory_mapper.h
new file mode 100644
index 0000000..ddf4a59
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_memory_mapper.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_memory_mapper.h
+*
+* @brief Re-creates SAHARA data structures in Kernel memory such that they are
+*       suitable for DMA.
+*
+*/
+
+#ifndef SAH_MEMORY_MAPPER_H
+#define SAH_MEMORY_MAPPER_H
+
+#include <sah_driver_common.h>
+#include <sah_queue_manager.h>
+
+
+/******************************************************************************
+* External function declarations
+******************************************************************************/
+sah_Head_Desc *sah_Copy_Descriptors(fsl_shw_uco_t * user_ctx,
+					sah_Head_Desc * desc);
+
+sah_Link *sah_Copy_Links(fsl_shw_uco_t * user_ctx, sah_Link * ptr);
+
+sah_Head_Desc *sah_Physicalise_Descriptors(sah_Head_Desc * desc);
+
+sah_Link *sah_Physicalise_Links (sah_Link *ptr);
+
+sah_Head_Desc *sah_DePhysicalise_Descriptors (sah_Head_Desc *desc);
+
+sah_Link *sah_DePhysicalise_Links (sah_Link *ptr);
+
+sah_Link *sah_Make_Links(fsl_shw_uco_t * user_ctx,
+			 sah_Link * ptr, sah_Link ** tail);
+
+
+void sah_Destroy_Descriptors (sah_Head_Desc *desc);
+
+void sah_Destroy_Links (sah_Link *link);
+
+void sah_Free_Chained_Descriptors (sah_Head_Desc *desc);
+
+void sah_Free_Chained_Links (sah_Link *link);
+
+int sah_Init_Mem_Map (void);
+
+void sah_Stop_Mem_Map (void);
+
+int sah_Block_Add_Page (int big);
+
+sah_Desc *sah_Alloc_Descriptor (void);
+sah_Head_Desc *sah_Alloc_Head_Descriptor (void);
+void sah_Free_Descriptor (sah_Desc *desc);
+void sah_Free_Head_Descriptor (sah_Head_Desc *desc);
+sah_Link *sah_Alloc_Link (void);
+void sah_Free_Link (sah_Link *link);
+
+void *wire_user_memory(void *address, uint32_t length, void **page_ctx);
+void unwire_user_memory(void **page_ctx);
+
+os_error_code map_user_memory(struct vm_area_struct *vma,
+			      uint32_t physical_addr, uint32_t size);
+os_error_code unmap_user_memory(uint32_t user_addr, uint32_t size);
+
+#endif  /* SAH_MEMORY_MAPPER_H */
+
+/* End of sah_memory_mapper.h */
diff --git a/drivers/mxc/security/sahara2/include/sah_queue_manager.h b/drivers/mxc/security/sahara2/include/sah_queue_manager.h
new file mode 100644
index 0000000..895006f
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_queue_manager.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_queue_manager.h
+*
+* @brief This file definitions for the Queue Manager.
+
+* The Queue Manager manages additions and removal from the queue and updates
+* the status of queue entries. It also calls sah_HW_* functions to interact
+* with the hardware.
+*
+*/
+
+#ifndef SAH_QUEUE_MANAGER_H
+#define SAH_QUEUE_MANAGER_H
+
+#include <sah_driver_common.h>
+#include <sah_status_manager.h>
+
+
+/*************************
+* Queue Manager Functions
+*************************/
+fsl_shw_return_t sah_Queue_Manager_Init(void);
+void             sah_Queue_Manager_Close(void);
+void             sah_Queue_Manager_Reset_Entries(void);
+void             sah_Queue_Manager_Append_Entry(sah_Head_Desc *entry);
+void             sah_Queue_Manager_Remove_Entry(sah_Head_Desc *entry);
+
+
+/*************************
+* Queue Functions
+*************************/
+sah_Queue *sah_Queue_Construct(void);
+void      sah_Queue_Destroy(sah_Queue *this);
+void      sah_Queue_Append_Entry(sah_Queue *this, sah_Head_Desc *entry);
+void      sah_Queue_Remove_Entry(sah_Queue *this);
+void      sah_Queue_Remove_Any_Entry(sah_Queue *this, sah_Head_Desc *entry);
+void      sah_postprocess_queue(unsigned long reset_flag);
+
+
+/*************************
+* Misc Releated Functions
+*************************/
+
+int              sah_blocking_mode(struct sah_Head_Desc *entry);
+fsl_shw_return_t sah_convert_error_status(uint32_t error_status);
+
+
+#endif  /* SAH_QUEUE_MANAGER_H */
+
+/* End of sah_queue_manager.h */
diff --git a/drivers/mxc/security/sahara2/include/sah_status_manager.h b/drivers/mxc/security/sahara2/include/sah_status_manager.h
new file mode 100644
index 0000000..e7a387f
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sah_status_manager.h
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sah_status_manager.h
+*
+* @brief SAHARA Status Manager Types and Function Prototypes
+*
+* @author Stuart Holloway (SH)
+*
+*/
+
+#ifndef STATUS_MANAGER_H
+#define STATUS_MANAGER_H
+#include "sah_driver_common.h"
+#include <linux/mxc_sahara.h>
+
+
+/******************************************************************************
+* User defined data types
+******************************************************************************/
+/**
+******************************************************************************
+* sah_Execute_Status
+* Types read from SAHARA Status Register, with additional state for Op Status
+******************************************************************************/
+typedef enum sah_Execute_Status
+{
+    /** Sahara is Idle. */
+    SAH_EXEC_IDLE = 0,
+    /** SAHARA is busy performing a resest or processing a decriptor chain. */
+    SAH_EXEC_BUSY = 1,
+    /** An error occurred while SAHARA executed the first descriptor. */
+    SAH_EXEC_ERROR1 = 2,
+    /** SAHARA has failed internally. */
+    SAH_EXEC_FAULT = 3,
+    /** SAHARA has finished processing a descriptor chain and is idle. */
+    SAH_EXEC_DONE1 = 4,
+    /** SAHARA has finished processing a descriptor chain, and is processing a
+     *   second chain.  */
+    SAH_EXEC_DONE1_BUSY2 = 5,
+    /** SAHARA has finished processing a descriptor chain, but has generated an
+     *   error while processing a second descriptor chain. */
+    SAH_EXEC_DONE1_ERROR2 = 6,
+    /** SAHARA has finished two descriptors. */
+    SAH_EXEC_DONE1_DONE2 = 7,
+    /** SAHARA has stopped, and first descriptor has Op Status, not Err  */
+    SAH_EXEC_OPSTAT1 = 0x20,
+} sah_Execute_Status;
+
+/**
+ * When this bit is on in a #sah_Execute_Status, it means that DONE1 is true.
+ */
+#define SAH_EXEC_DONE1_BIT  4
+
+/**
+ * Bits which make up the Sahara State
+ */
+#define SAH_EXEC_STATE_MASK 0x00000007
+
+/**
+*******************************************************************************
+* sah_Execute_Error
+* Types read from SAHARA Error Status Register
+******************************************************************************/
+typedef enum sah_Execute_Error
+{
+    /** No Error */
+    SAH_ERR_NONE = 0,
+    /** Header is not valid. */
+    SAH_ERR_HEADER = 1,
+    /** Descriptor length is not correct. */
+    SAH_ERR_DESC_LENGTH = 2,
+    /** Length or pointer field is zero while the other is non-zero.  */
+    SAH_ERR_DESC_POINTER = 3,
+    /** Length of the link is not a multiple of 4 and is not the last link */
+    SAH_ERR_LINK_LENGTH = 4,
+    /** The data pointer in a link is zero */
+    SAH_ERR_LINK_POINTER = 5,
+    /** Input Buffer reported an overflow */
+    SAH_ERR_INPUT_BUFFER = 6,
+    /** Output Buffer reported an underflow */
+    SAH_ERR_OUTPUT_BUFFER = 7,
+    /** Incorrect data in output buffer after CHA's has signalled 'done'. */
+    SAH_ERR_OUTPUT_BUFFER_STARVATION = 8,
+    /** Internal Hardware Failure. */
+    SAH_ERR_INTERNAL_STATE = 9,
+    /** Current Descriptor was not legal, but cause is unknown. */
+    SAH_ERR_GENERAL_DESCRIPTOR = 10,
+    /** Reserved pointer fields have been set to 1. */
+    SAH_ERR_RESERVED_FIELDS = 11,
+    /** Descriptor address error */
+    SAH_ERR_DESCRIPTOR_ADDRESS = 12,
+    /** Link address error */
+    SAH_ERR_LINK_ADDRESS = 13,
+    /** Processing error in CHA module */
+    SAH_ERR_CHA = 14,
+    /** Processing error during DMA */
+    SAH_ERR_DMA = 15
+} sah_Execute_Error;
+
+
+/**
+*******************************************************************************
+* sah_CHA_Error_Source
+* Types read from SAHARA Error Status Register for CHA Error Source
+*
+******************************************************************************/
+typedef enum sah_CHA_Error_Source
+{
+    /** No Error indicated in Source CHA Error. */
+    SAH_CHA_NO_ERROR = 0,
+    /** Error in SKHA module. */
+    SAH_CHA_SKHA_ERROR = 1,
+    /** Error in MDHA module. */
+    SAH_CHA_MDHA_ERROR = 2,
+    /** Error in RNG module.  */
+    SAH_CHA_RNG_ERROR = 3,
+    /** Error in PKHA module.  */
+    SAH_CHA_PKHA_ERROR = 4,
+} sah_CHA_Error_Source;
+
+/**
+******************************************************************************
+* sah_CHA_Error_Status
+* Types read from SAHARA Error Status Register for CHA Error Status
+*
+******************************************************************************/
+typedef enum sah_CHA_Error_Status
+{
+    /** No CHA error detected */
+    SAH_CHA_NO_ERR = 0x000,
+    /** Non-empty input buffer when complete. */
+    SAH_CHA_IP_BUF = 0x001,
+    /** Illegal Address Error. */
+    SAH_CHA_ADD_ERR = 0x002,
+    /** Illegal Mode Error.  */
+    SAH_CHA_MODE_ERR = 0x004,
+    /** Illegal Data Size Error. */
+    SAH_CHA_DATA_SIZE_ERR = 0x008,
+    /** Illegal Key Size Error. */
+    SAH_CHA_KEY_SIZE_ERR = 0x010,
+    /** Mode/Context/Key written during processing. */
+    SAH_CHA_PROC_ERR = 0x020,
+    /** Context Read During Processing. */
+    SAH_CHA_CTX_READ_ERR = 0x040,
+    /** Internal Hardware Error. */
+    SAH_CHA_INTERNAL_HW_ERR = 0x080,
+    /** Input Buffer not enabled or underflow. */
+    SAH_CHA_IP_BUFF_ERR = 0x100,
+    /** Output Buffer not enabled or overflow. */
+    SAH_CHA_OP_BUFF_ERR = 0x200,
+    /** DES key parity error (SKHA) */
+    SAH_CHA_DES_KEY_ERR = 0x400,
+    /** Reserved error code. */
+    SAH_CHA_RES = 0x800
+} sah_CHA_Error_Status;
+
+/**
+*****************************************************************************
+* sah_DMA_Error_Status
+* Types read from SAHARA Error Status Register for DMA Error Status
+******************************************************************************/
+typedef enum sah_DMA_Error_Status
+{
+    /** No DMA Error Code. */
+    SAH_DMA_NO_ERR = 0,
+    /** AHB terminated a bus cycle with an error. */
+    SAH_DMA_AHB_ERR = 2,
+    /** Internal IP bus cycle was terminated with an error termination. */
+    SAH_DMA_IP_ERR = 4,
+    /** Parity error detected on DMA command. */
+    SAH_DMA_PARITY_ERR = 6,
+    /** DMA was requested to cross a 256 byte internal address boundary. */
+    SAH_DMA_BOUNDRY_ERR = 8,
+    /** DMA controller is busy */
+    SAH_DMA_BUSY_ERR = 10,
+    /** Memory Bounds Error */
+    SAH_DMA_RESERVED_ERR = 12,
+    /** Internal DMA hardware error detected */
+    SAH_DMA_INT_ERR = 14
+} sah_DMA_Error_Status;
+
+/**
+*****************************************************************************
+* sah_DMA_Error_Size
+* Types read from SAHARA Error Status Register for DMA Error Size
+*
+******************************************************************************/
+typedef enum sah_DMA_Error_Size
+{
+    /** Error during Byte transfer.  */
+    SAH_DMA_SIZE_BYTE = 0,
+    /** Error during Half-word transfer. */
+    SAH_DMA_SIZE_HALF_WORD = 1,
+    /** Error during Word transfer. */
+    SAH_DMA_SIZE_WORD = 2,
+    /** Reserved DMA word size. */
+    SAH_DMA_SIZE_RES = 3
+} sah_DMA_Error_Size;
+
+
+
+
+extern bool sah_dpm_flag;
+
+/*************************
+* Status Manager Functions
+*************************/
+
+unsigned long sah_Handle_Interrupt(sah_Execute_Status hw_status);
+sah_Head_Desc *sah_Find_With_State (sah_Queue_Status status);
+int sah_dpm_init(void);
+void sah_dpm_close(void);
+void sah_Queue_Manager_Prime (sah_Head_Desc *entry);
+
+
+#endif  /* STATUS_MANAGER_H */
diff --git a/drivers/mxc/security/sahara2/include/sahara2_kernel.h b/drivers/mxc/security/sahara2/include/sahara2_kernel.h
new file mode 100644
index 0000000..bd2fae8
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sahara2_kernel.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#define DRIVER_NAME sahara2
+
+#define SAHARA_MAJOR_NODE 78
+
+#include "portable_os.h"
+
+#include "platform_abstractions.h"
+
+/* Forward-declare prototypes using signature macros */
+
+OS_DEV_ISR_DCL(sahara2_isr);
+
+OS_DEV_INIT_DCL(sahara2_init);
+
+OS_DEV_SHUTDOWN_DCL(sahara2_shutdown);
+
+OS_DEV_OPEN_DCL(sahara2_open);
+
+OS_DEV_CLOSE_DCL(sahara2_release);
+
+OS_DEV_IOCTL_DCL(sahara2_ioctl);
+
+struct sahara2_kernel_user {
+	void *command_ring[32];
+};
+
+struct sahara2_sym_arg {
+	char *key;
+	unsigned key_len;
+};
+
+/*! These need to be added to Linux / OS abstractions */
+/*
+module_init(OS_DEV_INIT_REF(sahara2_init));
+module_cleanup(OS_DEV_SHUTDOWN_REF(sahara2_shutdown));
+*/
diff --git a/drivers/mxc/security/sahara2/include/sf_util.h b/drivers/mxc/security/sahara2/include/sf_util.h
new file mode 100644
index 0000000..d5b2968
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/sf_util.h
@@ -0,0 +1,466 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sf_util.h
+*
+* @brief Header for Sahara Descriptor-chain building Functions
+*/
+#ifndef SF_UTIL_H
+#define SF_UTIL_H
+
+#include <fsl_platform.h>
+#include <linux/mxc_sahara.h>
+
+/*! Header value for Sahara Descriptor  1 */
+#define SAH_HDR_SKHA_SET_MODE_IV_KEY  0x10880000
+/*! Header value for Sahara Descriptor  2 */
+#define SAH_HDR_SKHA_SET_MODE_ENC_DEC 0x108D0000
+/*! Header value for Sahara Descriptor  4 */
+#define SAH_HDR_SKHA_ENC_DEC          0x90850000
+/*! Header value for Sahara Descriptor  5 */
+#define SAH_HDR_SKHA_READ_CONTEXT_IV  0x10820000
+/*! Header value for Sahara Descriptor  6 */
+#define SAH_HDR_MDHA_SET_MODE_MD_KEY  0x20880000
+/*! Header value for Sahara Descriptor  8 */
+#define SAH_HDR_MDHA_SET_MODE_HASH    0x208D0000
+/*! Header value for Sahara Descriptor  10 */
+#define SAH_HDR_MDHA_HASH             0xA0850000
+/*! Header value for Sahara Descriptor  11 */
+#define SAH_HDR_MDHA_STORE_DIGEST     0x20820000
+/*! Header value for Sahara Descriptor  18 */
+#define SAH_HDR_RNG_GENERATE          0x308C0000
+/*! Header value for Sahara Descriptor 19 */
+#define SAH_HDR_PKHA_LD_N_E           0xC0800000
+/*! Header value for Sahara Descriptor 20 */
+#define SAH_HDR_PKHA_LD_A_EX_ST_B     0x408D0000
+/*! Header value for Sahara Descriptor 21 */
+#define SAH_HDR_PKHA_LD_N_EX_ST_B     0x408E0000
+/*! Header value for Sahara Descriptor 22 */
+#define SAH_HDR_PKHA_LD_A_B           0xC0830000
+/*! Header value for Sahara Descriptor 23 */
+#define SAH_HDR_PKHA_LD_A0_A1         0x40840000
+/*! Header value for Sahara Descriptor 24 */
+#define SAH_HDR_PKHA_LD_A2_A3         0xC0850000
+/*! Header value for Sahara Descriptor 25 */
+#define SAH_HDR_PKHA_LD_B0_B1         0xC0860000
+/*! Header value for Sahara Descriptor 26 */
+#define SAH_HDR_PKHA_LD_B2_B3         0x40870000
+/*! Header value for Sahara Descriptor 27 */
+#define SAH_HDR_PKHA_ST_A_B           0x40820000
+/*! Header value for Sahara Descriptor 28 */
+#define SAH_HDR_PKHA_ST_A0_A1         0x40880000
+/*! Header value for Sahara Descriptor 29 */
+#define SAH_HDR_PKHA_ST_A2_A3         0xC0890000
+/*! Header value for Sahara Descriptor 30 */
+#define SAH_HDR_PKHA_ST_B0_B1         0xC08A0000
+/*! Header value for Sahara Descriptor 31 */
+#define SAH_HDR_PKHA_ST_B2_B3         0x408B0000
+/*! Header value for Sahara Descriptor 32 */
+#define SAH_HDR_PKHA_EX_ST_B1         0xC08C0000
+/*! Header value for Sahara Descriptor 33 */
+#define SAH_HDR_ARC4_SET_MODE_SBOX    0x90890000
+/*! Header value for Sahara Descriptor 34 */
+#define SAH_HDR_ARC4_READ_SBOX        0x90860000
+/*! Header value for Sahara Descriptor 35 */
+#define SAH_HDR_ARC4_SET_MODE_KEY     0x90830000
+/*! Header value for Sahara Descriptor 36 */
+#define SAH_HDR_PKHA_LD_A3_B0         0x40810000
+/*! Header value for Sahara Descriptor 37 */
+#define SAH_HDR_PKHA_ST_B1_B2         0xC08F0000
+/*! Header value for Sahara Descriptor 38 */
+#define SAH_HDR_SKHA_CBC_ICV          0x10840000
+/*! Header value for Sahara Descriptor 39 */
+#define SAH_HDR_MDHA_ICV_CHECK        0xA08A0000
+
+/*! Header bit indicating "Link-List optimization" */
+#define SAH_HDR_LLO                   0x01000000
+
+#define SAH_SF_DCLS                                                         \
+    fsl_shw_return_t ret;                                                   \
+    unsigned sf_executed = 0;                                               \
+    sah_Head_Desc* desc_chain = NULL;                                       \
+    uint32_t header
+
+#define SAH_SF_USER_CHECK()                                                 \
+do {                                                                        \
+    ret = sah_validate_uco(user_ctx);                                       \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+} while (0)
+
+#define SAH_SF_EXECUTE()                                                    \
+do {                                                                        \
+    sf_executed = 1;                                                        \
+    ret = sah_Descriptor_Chain_Execute(desc_chain, user_ctx);               \
+} while (0)
+
+#define SAH_SF_DESC_CLEAN()                                                 \
+do {                                                                        \
+    if (!sf_executed || (user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {        \
+        sah_Descriptor_Chain_Destroy(user_ctx->mem_util, &desc_chain);      \
+    }                                                                       \
+    (void) header;                                                          \
+} while (0)
+
+/*! Add Descriptor with two inputs */
+#define DESC_IN_IN(hdr, len1, ptr1, len2, ptr2)                             \
+{                                                                           \
+    ret = sah_add_two_in_desc(hdr, ptr1, len1, ptr2, len2,                  \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with two vectors */
+#define DESC_D_D(hdr, len1, ptr1, len2, ptr2)                               \
+{                                                                           \
+    ret = sah_add_two_d_desc(hdr, ptr1, len1, ptr2, len2,                   \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with input and a key */
+#define DESC_IN_KEY(hdr, len1, ptr1, key2)                                  \
+{                                                                           \
+    ret = sah_add_in_key_desc(hdr, ptr1, len1, key2,                        \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with input and an output */
+#define DESC_IN_OUT(hdr, len1, ptr1, len2, ptr2)                            \
+{                                                                           \
+    ret = sah_add_in_out_desc(hdr, ptr1, len1, ptr2, len2,                  \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with input and a key output */
+#define DESC_IN_KEYOUT(hdr, len1, ptr1, key2)                               \
+{                                                                           \
+    ret = sah_add_in_keyout_desc(hdr, ptr1, len1, key2,                     \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with a key and an output */
+#define DESC_KEY_OUT(hdr, key1, len2, ptr2)                                 \
+{                                                                           \
+    ret = sah_add_key_out_desc(hdr, key1, ptr2, len2,                       \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with two outputs */
+#define DESC_OUT_OUT(hdr, len1, ptr1, len2, ptr2)                           \
+{                                                                           \
+    ret = sah_add_two_out_desc(hdr, ptr1, len1, ptr2, len2,                 \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+/*! Add Descriptor with output then input pointers */
+#define DESC_OUT_IN(hdr, len1, ptr1, len2, ptr2)                            \
+{                                                                           \
+    ret = sah_add_out_in_desc(hdr, ptr1, len1, ptr2, len2,                  \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+
+#ifdef SAH_SF_DEBUG
+/*! Add Descriptor with two outputs */
+#define DBG_DESC(hdr, len1, ptr1, len2, ptr2)                               \
+{                                                                           \
+    ret = sah_add_two_out_desc(hdr, ptr1, len1, ptr2, len2,                 \
+                              user_ctx->mem_util, &desc_chain);             \
+    if (ret != FSL_RETURN_OK_S) {                                           \
+        goto out;                                                           \
+    }                                                                       \
+}
+#else
+#define DBG_DESC(hdr, len1, ptr1, len2, ptr2)
+#endif
+
+#ifdef __KERNEL__
+#define DESC_DBG_ON  ({console_loglevel = 8;})
+#define DESC_DBG_OFF ({console_loglevel = 7;})
+#else
+#define DESC_DBG_ON  system("echo 8 > /proc/sys/kernel/printk")
+#define DESC_DBG_OFF system("echo 7 > /proc/sys/kernel/printk")
+#endif
+
+#define DESC_TEMP_ALLOC(size)                                               \
+({                                                                          \
+    uint8_t* ptr;                                                           \
+    ptr = user_ctx->mem_util->mu_malloc(user_ctx->mem_util->mu_ref,         \
+                                                   size);                   \
+    if (ptr == NULL) {                                                      \
+        ret = FSL_RETURN_NO_RESOURCE_S;                                     \
+        goto out;                                                           \
+    }                                                                       \
+                                                                            \
+    ptr;                                                                    \
+})
+
+#define DESC_TEMP_FREE(ptr)                                                 \
+({                                                                          \
+    if ((ptr != NULL) &&                                                    \
+        (!sf_executed || (user_ctx->flags & FSL_UCO_BLOCKING_MODE))) {      \
+            user_ctx->mem_util->                                            \
+                mu_free(user_ctx->mem_util->mu_ref, ptr);                   \
+            ptr = NULL;                                                     \
+    }                                                                       \
+})
+
+/* Temporary implementation.  This needs to be in internal/secure RAM */
+#define DESC_TEMP_SECURE_ALLOC(size)                                        \
+({                                                                          \
+    uint8_t* ptr;                                                           \
+    ptr = user_ctx->mem_util->mu_malloc(user_ctx->mem_util->mu_ref,         \
+                                                   size);                   \
+    if (ptr == NULL) {                                                      \
+        ret = FSL_RETURN_NO_RESOURCE_S;                                     \
+        goto out;                                                           \
+    }                                                                       \
+                                                                            \
+    ptr;                                                                    \
+})
+
+#define DESC_TEMP_SECURE_FREE(ptr, size)                                    \
+({                                                                          \
+    if ((ptr != NULL) &&                                                    \
+        (!sf_executed || (user_ctx->flags & FSL_UCO_BLOCKING_MODE))) {      \
+            user_ctx->mem_util->mu_memset(user_ctx->mem_util->mu_ref,       \
+                                          ptr, 0, size);                    \
+                                                                            \
+            user_ctx->mem_util->                                            \
+                mu_free(user_ctx->mem_util->mu_ref, ptr);                   \
+            ptr = NULL;                                                     \
+    }                                                                       \
+})
+
+extern const uint32_t sah_insert_mdha_algorithm[];
+
+/*! @defgroup mdhaflags MDHA Mode Register Values
+ *
+ * These are bit fields and combinations of bit fields for setting the Mode
+ * Register portion of a Sahara Descriptor Header field.
+ *
+ * The parity bit has been set to ensure that these values have even parity,
+ * therefore using an Exclusive-OR operation against an existing header will
+ * preserve its parity.
+ *
+ * @addtogroup mdhaflags
+   @{
+ */
+#define sah_insert_mdha_icv_check 0x80001000
+#define sah_insert_mdha_ssl       0x80000400
+#define sah_insert_mdha_mac_full  0x80000200
+#define sah_insert_mdha_opad      0x80000080
+#define sah_insert_mdha_ipad      0x80000040
+#define sah_insert_mdha_init      0x80000020
+#define sah_insert_mdha_hmac      0x80000008
+#define sah_insert_mdha_pdata     0x80000004
+#define sah_insert_mdha_algorithm_sha224  0x00000003
+#define sah_insert_mdha_algorithm_sha256  0x80000002
+#define sah_insert_mdha_algorithm_md5     0x80000001
+#define sah_insert_mdha_algorithm_sha1    0x00000000
+/*! @} */
+
+extern const uint32_t sah_insert_skha_algorithm[];
+extern const uint32_t sah_insert_skha_mode[];
+extern const uint32_t sah_insert_skha_modulus[];
+
+/*! @defgroup skhaflags SKHA Mode Register Values
+ *
+ * These are bit fields and combinations of bit fields for setting the Mode
+ * Register portion of a Sahara Descriptor Header field.
+ *
+ * The parity bit has been set to ensure that these values have even parity,
+ * therefore using an Exclusive-OR operation against an existing header will
+ * preserve its parity.
+ *
+ * @addtogroup skhaflags
+   @{
+ */
+/*! */
+#define sah_insert_skha_modulus_128    0x00001e00
+#define sah_insert_skha_no_key_parity  0x80000100
+#define sah_insert_skha_ctr_last_block 0x80000020
+#define sah_insert_skha_suppress_cbc   0x80000020
+#define sah_insert_skha_no_permute     0x80000020
+#define sah_insert_skha_algorithm_arc4 0x00000003
+#define sah_insert_skha_algorithm_tdes 0x80000002
+#define sah_insert_skha_algorithm_des  0x80000001
+#define sah_insert_skha_algorithm_aes  0x00000000
+#define sah_insert_skha_aux0           0x80000020
+#define sah_insert_skha_mode_ctr       0x00000018
+#define sah_insert_skha_mode_ccm       0x80000010
+#define sah_insert_skha_mode_cbc       0x80000008
+#define sah_insert_skha_mode_ecb       0x00000000
+#define sah_insert_skha_encrypt        0x80000004
+#define sah_insert_skha_decrypt        0x00000000
+/*! @} */
+
+/*! @defgroup rngflags RNG Mode Register Values
+ *
+ */
+/*! */
+#define sah_insert_rng_gen_seed        0x80000001
+
+/*! @} */
+
+/*! @defgroup pkhaflags PKHA Mode Register Values
+ *
+ */
+/*! */
+#define sah_insert_pkha_soft_err_false         0x80000200
+#define sah_insert_pkha_soft_err_true          0x80000100
+
+#define sah_insert_pkha_rtn_clr_mem            0x80000001
+#define sah_insert_pkha_rtn_clr_eram           0x80000002
+#define sah_insert_pkha_rtn_mod_exp            0x00000003
+#define sah_insert_pkha_rtn_mod_r2modn         0x80000004
+#define sah_insert_pkha_rtn_mod_rrmodp         0x00000005
+#define sah_insert_pkha_rtn_ec_fp_aff_ptmul    0x00000006
+#define sah_insert_pkha_rtn_ec_f2m_aff_ptmul   0x80000007
+#define sah_insert_pkha_rtn_ec_fp_proj_ptmul   0x80000008
+#define sah_insert_pkha_rtn_ec_f2m_proj_ptmul  0x00000009
+#define sah_insert_pkha_rtn_ec_fp_add          0x0000000A
+#define sah_insert_pkha_rtn_ec_fp_double       0x8000000B
+#define sah_insert_pkha_rtn_ec_f2m_add         0x0000000C
+#define sah_insert_pkha_rtn_ec_f2m_double      0x8000000D
+#define sah_insert_pkha_rtn_f2m_r2modn         0x8000000E
+#define sah_insert_pkha_rtn_f2m_inv            0x0000000F
+#define sah_insert_pkha_rtn_mod_inv            0x80000010
+#define sah_insert_pkha_rtn_rsa_sstep          0x00000011
+#define sah_insert_pkha_rtn_mod_emodn          0x00000012
+#define sah_insert_pkha_rtn_f2m_emodn          0x80000013
+#define sah_insert_pkha_rtn_ec_fp_ptmul        0x00000014
+#define sah_insert_pkha_rtn_ec_f2m_ptmul       0x80000015
+#define sah_insert_pkha_rtn_f2m_gcd            0x80000016
+#define sah_insert_pkha_rtn_mod_gcd            0x00000017
+#define sah_insert_pkha_rtn_f2m_dbl_aff        0x00000018
+#define sah_insert_pkha_rtn_fp_dbl_aff         0x80000019
+#define sah_insert_pkha_rtn_f2m_add_aff        0x8000001A
+#define sah_insert_pkha_rtn_fp_add_aff         0x0000001B
+#define sah_insert_pkha_rtn_f2m_exp            0x8000001C
+#define sah_insert_pkha_rtn_mod_exp_teq        0x0000001D
+#define sah_insert_pkha_rtn_rsa_sstep_teq      0x0000001E
+#define sah_insert_pkha_rtn_f2m_multn          0x8000001F
+#define sah_insert_pkha_rtn_mod_multn          0x80000020
+#define sah_insert_pkha_rtn_mod_add            0x00000021
+#define sah_insert_pkha_rtn_mod_sub            0x00000022
+#define sah_insert_pkha_rtn_mod_mult1_mont     0x80000023
+#define sah_insert_pkha_rtn_mod_mult2_deconv   0x00000024
+#define sah_insert_pkha_rtn_f2m_add            0x80000025
+#define sah_insert_pkha_rtn_f2m_mult1_mont     0x80000026
+#define sah_insert_pkha_rtn_f2m_mult2_deconv   0x00000027
+#define sah_insert_pkha_rtn_miller_rabin       0x00000028
+#define sah_insert_pkha_rtn_mod_amodn          0x00000029
+#define sah_insert_pkha_rtn_f2m_amodn          0x8000002A
+/*! @} */
+
+/*! Add a descriptor with two input pointers */
+fsl_shw_return_t sah_add_two_in_desc(uint32_t header,
+				     const uint8_t * in1,
+				     uint32_t in1_length,
+				     const uint8_t * in2,
+				     uint32_t in2_length,
+				     const sah_Mem_Util * mu,
+				     sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with two 'data' pointers */
+fsl_shw_return_t sah_add_two_d_desc(uint32_t header,
+				    const uint8_t * in1,
+				    uint32_t in1_length,
+				    const uint8_t * in2,
+				    uint32_t in2_length,
+				    const sah_Mem_Util * mu,
+				    sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with an input and key pointer */
+fsl_shw_return_t sah_add_in_key_desc(uint32_t header,
+				     const uint8_t * in1,
+				     uint32_t in1_length,
+				     fsl_shw_sko_t * key_info,
+				     const sah_Mem_Util * mu,
+				     sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with two key pointers */
+fsl_shw_return_t sah_add_key_key_desc(uint32_t header,
+				      fsl_shw_sko_t * key_info1,
+				      fsl_shw_sko_t * key_info2,
+				      const sah_Mem_Util * mu,
+				      sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with two output pointers */
+fsl_shw_return_t sah_add_two_out_desc(uint32_t header,
+				      uint8_t * out1,
+				      uint32_t out1_length,
+				      uint8_t * out2,
+				      uint32_t out2_length,
+				      const sah_Mem_Util * mu,
+				      sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with an input and output pointer */
+fsl_shw_return_t sah_add_in_out_desc(uint32_t header,
+				     const uint8_t * in, uint32_t in_length,
+				     uint8_t * out, uint32_t out_length,
+				     const sah_Mem_Util * mu,
+				     sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with an input and key output pointer */
+fsl_shw_return_t sah_add_in_keyout_desc(uint32_t header,
+					const uint8_t * in, uint32_t in_length,
+					fsl_shw_sko_t * key_info,
+					const sah_Mem_Util * mu,
+					sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with a key and an output pointer */
+fsl_shw_return_t sah_add_key_out_desc(uint32_t header,
+					  const fsl_shw_sko_t * key_info,
+				      uint8_t * out, uint32_t out_length,
+				      const sah_Mem_Util * mu,
+				      sah_Head_Desc ** desc_chain);
+
+/*! Add a descriptor with an output and input pointer */
+fsl_shw_return_t sah_add_out_in_desc(uint32_t header,
+				     uint8_t * out, uint32_t out_length,
+				     const uint8_t * in, uint32_t in_length,
+				     const sah_Mem_Util * mu,
+				     sah_Head_Desc ** desc_chain);
+
+/*! Verify that supplied User Context Object is valid */
+fsl_shw_return_t sah_validate_uco(fsl_shw_uco_t * uco);
+
+#endif				/* SF_UTIL_H */
+
+/* End of sf_util.h */
diff --git a/drivers/mxc/security/sahara2/km_adaptor.c b/drivers/mxc/security/sahara2/km_adaptor.c
new file mode 100644
index 0000000..f2b7d56
--- /dev/null
+++ b/drivers/mxc/security/sahara2/km_adaptor.c
@@ -0,0 +1,849 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file km_adaptor.c
+*
+* @brief The Adaptor component provides an interface to the
+*        driver for a kernel user.
+*/
+
+#include <adaptor.h>
+#include <sf_util.h>
+#include <sah_queue_manager.h>
+#include <sah_memory_mapper.h>
+#include <fsl_shw_keystore.h>
+#ifdef FSL_HAVE_SCC
+#include <linux/mxc_scc_driver.h>
+#elif defined (FSL_HAVE_SCC2)
+#include <linux/mxc_scc2_driver.h>
+#endif
+
+
+EXPORT_SYMBOL(adaptor_Exec_Descriptor_Chain);
+EXPORT_SYMBOL(sah_register);
+EXPORT_SYMBOL(sah_deregister);
+EXPORT_SYMBOL(sah_get_results);
+EXPORT_SYMBOL(fsl_shw_smalloc);
+EXPORT_SYMBOL(fsl_shw_sfree);
+EXPORT_SYMBOL(fsl_shw_sstatus);
+EXPORT_SYMBOL(fsl_shw_diminish_perms);
+EXPORT_SYMBOL(do_scc_encrypt_region);
+EXPORT_SYMBOL(do_scc_decrypt_region);
+EXPORT_SYMBOL(do_system_keystore_slot_alloc);
+EXPORT_SYMBOL(do_system_keystore_slot_dealloc);
+EXPORT_SYMBOL(do_system_keystore_slot_load);
+EXPORT_SYMBOL(do_system_keystore_slot_read);
+EXPORT_SYMBOL(do_system_keystore_slot_encrypt);
+EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
+
+
+#if defined(DIAG_DRV_IF) || defined(DIAG_MEM) || defined(DIAG_ADAPTOR)
+#include <diagnostic.h>
+#endif
+
+#if defined(DIAG_DRV_IF) || defined(DIAG_MEM) || defined(DIAG_ADAPTOR)
+#define MAX_DUMP 16
+
+#define DIAG_MSG_SIZE   300
+static char Diag_msg[DIAG_MSG_SIZE];
+#endif
+
+/* This is the wait queue to this mode of driver */
+DECLARE_WAIT_QUEUE_HEAD(Wait_queue_km);
+
+/*! This matches Sahara2 capabilities... */
+fsl_shw_pco_t sahara2_capabilities = {
+	1, 3,			/* api version number - major & minor */
+	1, 6,			/* driver version number - major & minor */
+	{
+	 FSL_KEY_ALG_AES,
+	 FSL_KEY_ALG_DES,
+	 FSL_KEY_ALG_TDES,
+	 FSL_KEY_ALG_ARC4},
+	{
+	 FSL_SYM_MODE_STREAM,
+	 FSL_SYM_MODE_ECB,
+	 FSL_SYM_MODE_CBC,
+	 FSL_SYM_MODE_CTR},
+	{
+	 FSL_HASH_ALG_MD5,
+	 FSL_HASH_ALG_SHA1,
+	 FSL_HASH_ALG_SHA224,
+	 FSL_HASH_ALG_SHA256},
+	/*
+	 * The following table must be set to handle all values of key algorithm
+	 * and sym mode, and be in the correct order..
+	 */
+	{			/* Stream, ECB, CBC, CTR */
+	 {0, 0, 0, 0},		/* HMAC */
+	 {0, 1, 1, 1},		/* AES  */
+	 {0, 1, 1, 0},		/* DES */
+	 {0, 1, 1, 0},		/* 3DES */
+	 {1, 0, 0, 0}		/* ARC4 */
+	 },
+	0, 0,
+	0, 0, 0,
+	{{0, 0}}
+};
+
+#ifdef DIAG_ADAPTOR
+void km_Dump_Chain(const sah_Desc * chain);
+
+void km_Dump_Region(const char *prefix, const unsigned char *data,
+		    unsigned length);
+
+static void km_Dump_Link(const char *prefix, const sah_Link * link);
+
+void km_Dump_Words(const char *prefix, const unsigned *data, unsigned length);
+#endif
+
+/**** Memory routines ****/
+
+static void *my_malloc(void *ref, size_t n)
+{
+	register void *mem;
+
+#ifndef DIAG_MEM_ERRORS
+	mem = os_alloc_memory(n, GFP_KERNEL);
+
+#else
+	{
+		uint32_t rand;
+		/* are we feeling lucky ? */
+		os_get_random_bytes(&rand, sizeof(rand));
+		if ((rand % DIAG_MEM_CONST) == 0) {
+			mem = 0;
+		} else {
+			mem = os_alloc_memory(n, GFP_ATOMIC);
+		}
+	}
+#endif				/* DIAG_MEM_ERRORS */
+
+#ifdef DIAG_MEM
+	sprintf(Diag_msg, "API kmalloc: %p for %d\n", mem, n);
+	LOG_KDIAG(Diag_msg);
+#endif
+	ref = 0;		/* unused param warning */
+	return mem;
+}
+
+static sah_Head_Desc *my_alloc_head_desc(void *ref)
+{
+	register sah_Head_Desc *ptr;
+
+#ifndef DIAG_MEM_ERRORS
+	ptr = sah_Alloc_Head_Descriptor();
+
+#else
+	{
+		uint32_t rand;
+		/* are we feeling lucky ? */
+		os_get_random_bytes(&rand, sizeof(rand));
+		if ((rand % DIAG_MEM_CONST) == 0) {
+			ptr = 0;
+		} else {
+			ptr = sah_Alloc_Head_Descriptor();
+		}
+	}
+#endif
+	ref = 0;
+	return ptr;
+}
+
+static sah_Desc *my_alloc_desc(void *ref)
+{
+	register sah_Desc *ptr;
+
+#ifndef DIAG_MEM_ERRORS
+	ptr = sah_Alloc_Descriptor();
+
+#else
+	{
+		uint32_t rand;
+		/* are we feeling lucky ? */
+		os_get_random_bytes(&rand, sizeof(rand));
+		if ((rand % DIAG_MEM_CONST) == 0) {
+			ptr = 0;
+		} else {
+			ptr = sah_Alloc_Descriptor();
+		}
+	}
+#endif
+	ref = 0;
+	return ptr;
+}
+
+static sah_Link *my_alloc_link(void *ref)
+{
+	register sah_Link *ptr;
+
+#ifndef DIAG_MEM_ERRORS
+	ptr = sah_Alloc_Link();
+
+#else
+	{
+		uint32_t rand;
+		/* are we feeling lucky ? */
+		os_get_random_bytes(&rand, sizeof(rand));
+		if ((rand % DIAG_MEM_CONST) == 0) {
+			ptr = 0;
+		} else {
+			ptr = sah_Alloc_Link();
+		}
+	}
+#endif
+	ref = 0;
+	return ptr;
+}
+
+static void my_free(void *ref, void *ptr)
+{
+	ref = 0;		/* unused param warning */
+#ifdef DIAG_MEM
+	sprintf(Diag_msg, "API kfree: %p\n", ptr);
+	LOG_KDIAG(Diag_msg);
+#endif
+	os_free_memory(ptr);
+}
+
+static void my_free_head_desc(void *ref, sah_Head_Desc * ptr)
+{
+	sah_Free_Head_Descriptor(ptr);
+}
+
+static void my_free_desc(void *ref, sah_Desc * ptr)
+{
+	sah_Free_Descriptor(ptr);
+}
+
+static void my_free_link(void *ref, sah_Link * ptr)
+{
+	sah_Free_Link(ptr);
+}
+
+static void *my_memcpy(void *ref, void *dest, const void *src, size_t n)
+{
+	ref = 0;		/* unused param warning */
+	return memcpy(dest, src, n);
+}
+
+static void *my_memset(void *ref, void *ptr, int ch, size_t n)
+{
+	ref = 0;		/* unused param warning */
+	return memset(ptr, ch, n);
+}
+
+/*! Standard memory manipulation routines for kernel API. */
+static sah_Mem_Util std_kernelmode_mem_util = {
+	.mu_ref = 0,
+	.mu_malloc = my_malloc,
+	.mu_alloc_head_desc = my_alloc_head_desc,
+	.mu_alloc_desc = my_alloc_desc,
+	.mu_alloc_link = my_alloc_link,
+	.mu_free = my_free,
+	.mu_free_head_desc = my_free_head_desc,
+	.mu_free_desc = my_free_desc,
+	.mu_free_link = my_free_link,
+	.mu_memcpy = my_memcpy,
+	.mu_memset = my_memset
+};
+
+fsl_shw_return_t get_capabilities(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_pco_t * capabilities)
+{
+	scc_config_t *scc_capabilities;
+
+	/* Fill in the Sahara2 capabilities. */
+	memcpy(capabilities, &sahara2_capabilities, sizeof(fsl_shw_pco_t));
+
+	/* Fill in the SCC portion of the capabilities object */
+	scc_capabilities = scc_get_configuration();
+	capabilities->scc_driver_major = scc_capabilities->driver_major_version;
+	capabilities->scc_driver_minor = scc_capabilities->driver_minor_version;
+	capabilities->scm_version = scc_capabilities->scm_version;
+	capabilities->smn_version = scc_capabilities->smn_version;
+	capabilities->block_size_bytes = scc_capabilities->block_size_bytes;
+
+#ifdef FSL_HAVE_SCC
+	capabilities->scc_info.black_ram_size_blocks =
+	    scc_capabilities->black_ram_size_blocks;
+	capabilities->scc_info.red_ram_size_blocks =
+	    scc_capabilities->red_ram_size_blocks;
+#elif defined(FSL_HAVE_SCC2)
+	capabilities->scc2_info.partition_size_bytes =
+	    scc_capabilities->partition_size_bytes;
+	capabilities->scc2_info.partition_count =
+	    scc_capabilities->partition_count;
+#endif
+
+	return FSL_RETURN_OK_S;
+}
+
+/*!
+ * Sends a request to register this user
+ *
+ * @brief    Sends a request to register this user
+ *
+ * @param[in,out] user_ctx  part of the structure contains input parameters and
+ *                          part is filled in by the driver
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_register(fsl_shw_uco_t * user_ctx)
+{
+	fsl_shw_return_t status;
+
+	/* this field is used in user mode to indicate a file open has occured.
+	 * it is used here, in kernel mode, to indicate that the uco is registered
+	 */
+	user_ctx->sahara_openfd = 0;	/* set to 'registered' */
+	user_ctx->mem_util = &std_kernelmode_mem_util;
+
+	/* check that uco is valid */
+	status = sah_validate_uco(user_ctx);
+
+	/*  If life is good, register this user */
+	if (status == FSL_RETURN_OK_S) {
+		status = sah_handle_registration(user_ctx);
+	}
+
+	if (status != FSL_RETURN_OK_S) {
+		user_ctx->sahara_openfd = -1;	/* set to 'not registered' */
+	}
+
+	return status;
+}
+
+/*!
+ * Sends a request to deregister this user
+ *
+ * @brief    Sends a request to deregister this user
+ *
+ * @param[in,out]  user_ctx   Info on user being deregistered.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_deregister(fsl_shw_uco_t * user_ctx)
+{
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+
+	if (user_ctx->sahara_openfd == 0) {
+		status = sah_handle_deregistration(user_ctx);
+		user_ctx->sahara_openfd = -1;	/* set to 'no registered */
+	}
+
+	return status;
+}
+
+/*!
+ * Sends a request to get results for this user
+ *
+ * @brief    Sends a request to get results for this user
+ *
+ * @param[in,out] arg      Pointer to structure to collect results
+ * @param         uco      User's context
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_get_results(sah_results * arg, fsl_shw_uco_t * uco)
+{
+	fsl_shw_return_t code = sah_get_results_from_pool(uco, arg);
+
+	if ((code == FSL_RETURN_OK_S) && (arg->actual != 0)) {
+		sah_Postprocess_Results(uco, arg);
+	}
+
+	return code;
+}
+
+/*!
+ * This function writes the Descriptor Chain to the kernel driver.
+ *
+ * @brief    Writes the Descriptor Chain to the kernel driver.
+ *
+ * @param    dar   A pointer to a Descriptor Chain of type sah_Head_Desc
+ * @param    uco   The user context object
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t adaptor_Exec_Descriptor_Chain(sah_Head_Desc * dar,
+					       fsl_shw_uco_t * uco)
+{
+	sah_Head_Desc *kernel_space_desc = NULL;
+	fsl_shw_return_t code = FSL_RETURN_OK_S;
+	int os_error_code = 0;
+	unsigned blocking_mode = dar->uco_flags & FSL_UCO_BLOCKING_MODE;
+
+#ifdef DIAG_ADAPTOR
+	km_Dump_Chain(&dar->desc);
+#endif
+
+	dar->user_info = uco;
+	dar->user_desc = dar;
+
+	/* This code has been shamelessly copied from sah_driver_interface.c */
+	/* It needs to be moved somewhere common ... */
+	kernel_space_desc = sah_Physicalise_Descriptors(dar);
+
+	if (kernel_space_desc == NULL) {
+		/* We may have failed due to a -EFAULT as well, but we will return
+		 * -ENOMEM since either way it is a memory related failure. */
+		code = FSL_RETURN_NO_RESOURCE_S;
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("sah_Physicalise_Descriptors() failed\n");
+#endif
+	} else {
+		if (blocking_mode) {
+#ifdef SAHARA_POLL_MODE
+			os_error_code = sah_Handle_Poll(dar);
+#else
+			os_error_code = sah_blocking_mode(dar);
+#endif
+			if (os_error_code != 0) {
+				code = FSL_RETURN_ERROR_S;
+			} else {	/* status of actual operation */
+				code = dar->result;
+			}
+		} else {
+#ifdef SAHARA_POLL_MODE
+			sah_Handle_Poll(dar);
+#else
+			/* just put someting in the DAR */
+			sah_Queue_Manager_Append_Entry(dar);
+#endif				/* SAHARA_POLL_MODE */
+		}
+	}
+
+	return code;
+}
+
+
+/* System keystore context, defined in sah_driver_interface.c */
+extern fsl_shw_kso_t system_keystore;
+
+fsl_shw_return_t do_system_keystore_slot_alloc(fsl_shw_uco_t * user_ctx,
+					       uint32_t key_length,
+					       uint64_t ownerid,
+					       uint32_t * slot)
+{
+	(void)user_ctx;
+	return keystore_slot_alloc(&system_keystore, key_length, ownerid, slot);
+}
+
+fsl_shw_return_t do_system_keystore_slot_dealloc(fsl_shw_uco_t * user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot)
+{
+	(void)user_ctx;
+	return keystore_slot_dealloc(&system_keystore, ownerid, slot);
+}
+
+fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t * user_ctx,
+					      uint64_t ownerid,
+					      uint32_t slot,
+					      const uint8_t * key,
+					      uint32_t key_length)
+{
+	(void)user_ctx;
+	return keystore_slot_load(&system_keystore, ownerid, slot,
+				  (void *)key, key_length);
+}
+
+fsl_shw_return_t do_system_keystore_slot_read(fsl_shw_uco_t * user_ctx,
+					      uint64_t ownerid,
+					      uint32_t slot,
+					      uint32_t key_length,
+					      const uint8_t * key)
+{
+	(void)user_ctx;
+	return keystore_slot_read(&system_keystore, ownerid, slot,
+				  key_length, (void *)key);
+}
+
+fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t * user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot,
+						 uint32_t key_length,
+						 uint8_t * black_data)
+{
+	(void)user_ctx;
+	return keystore_slot_encrypt(NULL, &system_keystore, ownerid,
+				     slot, key_length, black_data);
+}
+
+fsl_shw_return_t do_system_keystore_slot_decrypt(fsl_shw_uco_t * user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot,
+						 uint32_t key_length,
+						 const uint8_t * black_data)
+{
+	(void)user_ctx;
+	return keystore_slot_decrypt(NULL, &system_keystore, ownerid,
+				     slot, key_length, black_data);
+}
+
+void *fsl_shw_smalloc(fsl_shw_uco_t * user_ctx,
+		      uint32_t size, const uint8_t * UMID, uint32_t permissions)
+{
+#ifdef FSL_HAVE_SCC2
+	int part_no;
+	void *part_base;
+	uint32_t part_phys;
+	scc_config_t *scc_configuration;
+
+	/* Check that the memory size requested is correct */
+	scc_configuration = scc_get_configuration();
+	if (size != scc_configuration->partition_size_bytes) {
+		return NULL;
+	}
+
+	/* Attempt to grab a partition. */
+	if (scc_allocate_partition(0, &part_no, &part_base, &part_phys)
+	    != SCC_RET_OK) {
+		return NULL;
+	}
+	printk(KERN_ALERT "In fsh_shw_smalloc (km): partition_base:%p "
+	       "partition_base_phys: %p\n", part_base, (void *)part_phys);
+
+	/* these bits should be in a separate function */
+	printk(KERN_ALERT "writing UMID and MAP to secure the partition\n");
+
+	scc_engage_partition(part_base, UMID, permissions);
+
+	(void)user_ctx;		/* unused param warning */
+
+	return part_base;
+#else				/* FSL_HAVE_SCC2 */
+	(void)user_ctx;
+	(void)size;
+	(void)UMID;
+	(void)permissions;
+	return NULL;
+#endif				/* FSL_HAVE_SCC2 */
+
+}
+
+fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t * user_ctx, void *address)
+{
+	(void)user_ctx;
+
+#ifdef FSL_HAVE_SCC2
+	if (scc_release_partition(address) == SCC_RET_OK) {
+		return FSL_RETURN_OK_S;
+	}
+#endif
+
+	return FSL_RETURN_ERROR_S;
+}
+
+fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t * user_ctx,
+				 void *address,
+				 fsl_shw_partition_status_t * status)
+{
+	(void)user_ctx;
+
+#ifdef FSL_HAVE_SCC2
+	*status = scc_partition_status(address);
+	return FSL_RETURN_OK_S;
+#endif
+
+	return FSL_RETURN_ERROR_S;
+}
+
+/* Diminish permissions on some secure memory */
+fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t * user_ctx,
+					void *address, uint32_t permissions)
+{
+
+	(void)user_ctx;		/* unused parameter warning */
+
+#ifdef FSL_HAVE_SCC2
+	if (scc_diminish_permissions(address, permissions) == SCC_RET_OK) {
+		return FSL_RETURN_OK_S;
+	}
+#endif
+	return FSL_RETURN_ERROR_S;
+}
+
+/*
+ * partition_base - physical address of the partition
+ * offset - offset, in blocks, of the data from the start of the partition
+ * length - length, in bytes, of the data to be encrypted (multiple of 4)
+ * black_data - virtual address that the encrypted data should be stored at
+ * Note that this virtual address must be translatable using the __virt_to_phys
+ * macro; ie, it can't be a specially mapped address.  To do encryption with those
+ * addresses, use the scc_encrypt_region function directly.  This is to make
+ * this function compatible with the user mode declaration, which does not know
+ * the physical addresses of the data it is using.
+ */
+fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode)
+{
+	scc_return_t scc_ret;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+
+#ifdef FSL_HAVE_SCC2
+
+#ifdef DIAG_ADAPTOR
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
+
+	LOG_KDIAG_ARGS
+	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
+	     partition_base, offset_bytes, byte_count, (void *)black_data);
+#endif
+	(void)user_ctx;
+
+	os_cache_flush_range(black_data, byte_count);
+
+	scc_ret =
+	    scc_encrypt_region((uint32_t) partition_base, offset_bytes,
+			       byte_count, __virt_to_phys(black_data), IV,
+			       cypher_mode);
+
+	if (scc_ret == SCC_RET_OK) {
+		retval = FSL_RETURN_OK_S;
+	} else {
+		retval = FSL_RETURN_ERROR_S;
+	}
+
+	/* The SCC2 DMA engine should have written to the black ram, so we need to
+	 * invalidate that region of memory.  Note that the red ram is not an
+	 * because it is mapped with the cache disabled.
+	 */
+	os_cache_inv_range(black_data, byte_count);
+
+#else
+	(void)scc_ret;
+#endif				/* FSL_HAVE_SCC2 */
+
+	return retval;
+}
+
+/*!
+ * Call the proper function to decrypt a region of encrypted secure memory
+ *
+ * @brief
+ *
+ * @param   user_ctx        User context of the partition owner (NULL in kernel)
+ * @param   partition_base  Base address (physical) of the partition
+ * @param   offset_bytes    Offset from base address that the decrypted data
+ *                          shall be placed
+ * @param   byte_count      Length of the message (bytes)
+ * @param   black_data      Pointer to where the encrypted data is stored
+ * @param   owner_id
+ *
+ * @return  status
+ */
+
+fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, const uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode)
+{
+	scc_return_t scc_ret;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+
+#ifdef FSL_HAVE_SCC2
+
+#ifdef DIAG_ADAPTOR
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
+
+	LOG_KDIAG_ARGS
+	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
+	     partition_base, offset_bytes, byte_count, (void *)black_data);
+#endif
+
+	(void)user_ctx;
+
+	/* The SCC2 DMA engine will be reading from the black ram, so we need to
+	 * make sure that the data is pushed out of the cache.  Note that the red
+	 * ram is not an issue because it is mapped with the cache disabled.
+	 */
+	os_cache_flush_range(black_data, byte_count);
+
+	scc_ret =
+	    scc_decrypt_region((uint32_t) partition_base, offset_bytes,
+			       byte_count,
+			       (uint8_t *) __virt_to_phys(black_data), IV,
+			       cypher_mode);
+
+	if (scc_ret == SCC_RET_OK) {
+		retval = FSL_RETURN_OK_S;
+	} else {
+		retval = FSL_RETURN_ERROR_S;
+	}
+
+#else
+	(void)scc_ret;
+#endif				/* FSL_HAVE_SCC2 */
+
+	return retval;
+}
+
+#ifdef DIAG_ADAPTOR
+/*!
+ * Dump chain of descriptors to the log.
+ *
+ * @brief Dump descriptor chain
+ *
+ * @param    chain     Kernel virtual address of start of chain of descriptors
+ *
+ * @return   void
+ */
+void km_Dump_Chain(const sah_Desc * chain)
+{
+	while (chain != NULL) {
+		km_Dump_Words("Desc", (unsigned *)chain,
+			      6 /*sizeof(*chain)/sizeof(unsigned) */ );
+		/* place this definition elsewhere */
+		if (chain->ptr1) {
+			if (chain->header & SAH_HDR_LLO) {
+				km_Dump_Region(" Data1", chain->ptr1,
+					       chain->len1);
+			} else {
+				km_Dump_Link(" Link1", chain->ptr1);
+			}
+		}
+		if (chain->ptr2) {
+			if (chain->header & SAH_HDR_LLO) {
+				km_Dump_Region(" Data2", chain->ptr2,
+					       chain->len2);
+			} else {
+				km_Dump_Link(" Link2", chain->ptr2);
+			}
+		}
+
+		chain = chain->next;
+	}
+}
+
+/*!
+ * Dump chain of links to the log.
+ *
+ * @brief Dump chain of links
+ *
+ * @param    prefix    Text to put in front of dumped data
+ * @param    link      Kernel virtual address of start of chain of links
+ *
+ * @return   void
+ */
+static void km_Dump_Link(const char *prefix, const sah_Link * link)
+{
+	while (link != NULL) {
+		km_Dump_Words(prefix, (unsigned *)link,
+			      3 /* # words in h/w link */ );
+		if (link->flags & SAH_STORED_KEY_INFO) {
+#ifdef CAN_DUMP_SCC_DATA
+			uint32_t len;
+#endif
+
+#ifdef CAN_DUMP_SCC_DATA
+			{
+				char buf[50];
+
+				scc_get_slot_info(link->ownerid, link->slot, (uint32_t *) & link->data,	/* RED key address */
+						  &len);	/* key length */
+				sprintf(buf, "  SCC slot %d: ", link->slot);
+				km_Dump_Words(buf,
+					      (void *)IO_ADDRESS((uint32_t)
+								 link->data),
+					      link->len / 4);
+			}
+#else
+			sprintf(Diag_msg, "  SCC slot %d", link->slot);
+			LOG_KDIAG(Diag_msg);
+#endif
+		} else if (link->data != NULL) {
+			km_Dump_Region("  Data", link->data, link->len);
+		}
+
+		link = link->next;
+	}
+}
+
+/*!
+ * Dump given region of data to the log.
+ *
+ * @brief Dump data
+ *
+ * @param    prefix    Text to put in front of dumped data
+ * @param    data      Kernel virtual address of start of region to dump
+ * @param    length    Amount of data to dump
+ *
+ * @return   void
+*/
+void km_Dump_Region(const char *prefix, const unsigned char *data,
+		    unsigned length)
+{
+	unsigned count;
+	char *output;
+	unsigned data_len;
+
+	sprintf(Diag_msg, "%s (%08X,%u):", prefix, (uint32_t) data, length);
+
+	/* Restrict amount of data to dump */
+	if (length > MAX_DUMP) {
+		data_len = MAX_DUMP;
+	} else {
+		data_len = length;
+	}
+
+	/* We've already printed some text in output buffer, skip over it */
+	output = Diag_msg + strlen(Diag_msg);
+
+	for (count = 0; count < data_len; count++) {
+		if (count % 4 == 0) {
+			*output++ = ' ';
+		}
+		sprintf(output, "%02X", *data++);
+		output += 2;
+	}
+
+	LOG_KDIAG(Diag_msg);
+}
+
+/*!
+ * Dump given wors of data to the log.
+ *
+ * @brief Dump data
+ *
+ * @param    prefix       Text to put in front of dumped data
+ * @param    data         Kernel virtual address of start of region to dump
+ * @param    word_count   Amount of data to dump
+ *
+ * @return   void
+*/
+void km_Dump_Words(const char *prefix, const unsigned *data,
+		   unsigned word_count)
+{
+	char *output;
+
+	sprintf(Diag_msg, "%s (%08X,%uw): ", prefix, (uint32_t) data,
+		word_count);
+
+	/* We've already printed some text in output buffer, skip over it */
+	output = Diag_msg + strlen(Diag_msg);
+
+	while (word_count--) {
+		sprintf(output, "%08X ", *data++);
+		output += 9;
+	}
+
+	LOG_KDIAG(Diag_msg);
+}
+#endif
diff --git a/drivers/mxc/security/sahara2/sah_driver_interface.c b/drivers/mxc/security/sahara2/sah_driver_interface.c
new file mode 100644
index 0000000..dae0fd5
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_driver_interface.c
@@ -0,0 +1,2197 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sah_driver_interface.c
+*
+* @brief Provides a Linux Kernel Module interface to the SAHARA h/w device.
+*
+*/
+
+/* SAHARA Includes */
+#include <sah_driver_common.h>
+#include <sah_kernel.h>
+#include <sah_memory_mapper.h>
+#include <sah_queue_manager.h>
+#include <sah_status_manager.h>
+#include <sah_interrupt_handler.h>
+#include <sah_hardware_interface.h>
+#include <fsl_shw_keystore.h>
+#include <adaptor.h>
+#ifdef FSL_HAVE_SCC
+#include <linux/mxc_scc_driver.h>
+#else
+#include <linux/mxc_scc2_driver.h>
+#endif
+
+#ifdef DIAG_DRV_IF
+#include <diagnostic.h>
+#endif
+
+#if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#include <linux/devfs_fs_kernel.h>
+#else
+#include <linux/proc_fs.h>
+#endif
+
+#ifdef PERF_TEST
+#define interruptible_sleep_on(x) sah_Handle_Interrupt()
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_DESCRIPTION("Device Driver for SAHARA2 crypto hw block");
+
+#define TEST_MODE_OFF 1
+#define TEST_MODE_ON 2
+
+/*! Version register on first deployments */
+#define SAHARA_VERSION2  2
+/*! Version register on MX27 */
+#define SAHARA_VERSION3  3
+/*! Version register on MXC92323 */
+#define SAHARA_VERSION4  4
+
+/******************************************************************************
+* Module function declarations
+******************************************************************************/
+
+OS_DEV_INIT_DCL(sah_init);
+OS_DEV_SHUTDOWN_DCL(sah_cleanup);
+OS_DEV_OPEN_DCL(sah_open);
+OS_DEV_CLOSE_DCL(sah_release);
+OS_DEV_IOCTL_DCL(sah_ioctl);
+OS_DEV_MMAP_DCL(sah_mmap);
+
+static os_error_code sah_handle_get_capabilities(fsl_shw_uco_t* user_ctx,
+                                                 uint32_t info);
+
+static void sah_user_callback(fsl_shw_uco_t * user_ctx);
+static os_error_code sah_handle_scc_sfree(fsl_shw_uco_t* user_ctx,
+                                          uint32_t info);
+static os_error_code sah_handle_scc_sstatus(fsl_shw_uco_t* user_ctx,
+                                          uint32_t info);
+static os_error_code sah_handle_scc_drop_perms(fsl_shw_uco_t* user_ctx,
+                                               uint32_t info);
+static os_error_code sah_handle_scc_encrypt(fsl_shw_uco_t* user_ctx,
+                                            uint32_t info);
+static os_error_code sah_handle_scc_decrypt(fsl_shw_uco_t* user_ctx,
+                                            uint32_t info);
+
+#ifdef FSL_HAVE_SCC2
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
+						uint32_t user_base,
+						void *kernel_base);
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
+						  uint32_t user_base);
+#endif
+
+static os_error_code sah_handle_sk_slot_alloc(uint32_t info);
+static os_error_code sah_handle_sk_slot_dealloc(uint32_t info);
+static os_error_code sah_handle_sk_slot_load(uint32_t info);
+static os_error_code sah_handle_sk_slot_read(uint32_t info);
+static os_error_code sah_handle_sk_slot_decrypt(uint32_t info);
+static os_error_code sah_handle_sk_slot_encrypt(uint32_t info);
+
+/*! Boolean flag for whether interrupt handler needs to be released on exit */
+static unsigned interrupt_registered;
+
+static int handle_sah_ioctl_dar(fsl_shw_uco_t * filp, uint32_t user_space_desc);
+
+#if !defined(CONFIG_DEVFS_FS) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+static int sah_read_procfs(char *buf,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data);
+
+static int sah_write_procfs(struct file *file, const char __user * buffer,
+			    unsigned long count, void *data);
+#endif
+
+#if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+
+/* This is a handle to the sahara DEVFS entry. */
+static devfs_handle_t Sahara_devfs_handle;
+
+#else
+
+/* Major number assigned to our device driver */
+static int Major;
+
+/* This is a handle to the sahara PROCFS entry */
+static struct proc_dir_entry *Sahara_procfs_handle;
+
+#endif
+
+uint32_t sah_hw_version;
+extern void *sah_virt_base;
+
+/* Mutex to prevent usage of the ioctl function by more than 1 user at a time */
+DEFINE_MUTEX(sahara_ioctl_mutex);
+
+/* This is the wait queue to this driver.  Linux declaration. */
+DECLARE_WAIT_QUEUE_HEAD(Wait_queue);
+
+/* This is a global variable that is used to track how many times the device
+ * has been opened simultaneously. */
+#ifdef DIAG_DRV_IF
+static int Device_in_use = 0;
+#endif
+
+/* This is the system keystore object */
+fsl_shw_kso_t system_keystore;
+
+/*!
+ * OS-dependent handle used for registering user interface of a driver.
+ */
+static os_driver_reg_t reg_handle;
+
+#ifdef DIAG_DRV_IF
+/* This is for sprintf() to use when constructing output. */
+#define DIAG_MSG_SIZE   1024
+static char Diag_msg[DIAG_MSG_SIZE];
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18))
+/** Pointer to Sahara clock information.  Initialized during os_dev_init(). */
+static struct clk *sah_clk;
+#endif
+
+/*!
+*******************************************************************************
+* This function gets called when the module is inserted (insmod) into  the
+* running kernel.
+*
+* @brief     SAHARA device initialisation function.
+*
+* @return   0 on success
+* @return   -EBUSY if the device or proc file entry cannot be created.
+* @return   OS_ERROR_NO_MEMORY_S if kernel memory could not be allocated.
+* @return   OS_ERROR_FAIL_S if initialisation of proc entry failed
+*/
+OS_DEV_INIT(sah_init)
+{
+	/* Status variable */
+	int os_error_code = 0;
+	uint32_t sah_phys_base = SAHARA_BASE_ADDR;
+
+
+	interrupt_registered = 0;
+
+	/* Enable the SAHARA Clocks */
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG("SAHARA : Enabling the IPG and AHB clocks\n")
+#endif				/*DIAG_DRV_IF */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+	    mxc_clks_enable(SAHARA2_CLK);
+#else
+	{
+		sah_clk = clk_get(NULL, "sahara_clk");
+		if (IS_ERR(sah_clk))
+			os_error_code = PTR_ERR(sah_clk);
+		else
+			clk_enable(sah_clk);
+	}
+#endif
+	
+	sah_virt_base = (void *)ioremap(sah_phys_base, SZ_16K);
+	if (sah_virt_base == NULL) {
+		os_printk(KERN_ERR
+			  "SAHARA: Register mapping failed\n");
+		os_error_code = OS_ERROR_FAIL_S;
+	}
+
+	if (os_error_code == OS_ERROR_OK_S) {
+		sah_hw_version = sah_HW_Read_Version();
+		os_printk("Sahara HW Version is 0x%08x\n", sah_hw_version);
+
+		/* verify code and hardware are version compatible */
+		if ((sah_hw_version != SAHARA_VERSION2)
+		    && (sah_hw_version != SAHARA_VERSION3)) {
+			if (((sah_hw_version >> 8) & 0xff) != SAHARA_VERSION4) {
+				os_printk
+				    ("Sahara HW Version was not expected value.\n");
+				os_error_code = OS_ERROR_FAIL_S;
+			}
+		}
+	}
+
+	if (os_error_code == OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("Calling sah_Init_Mem_Map to initialise "
+			  "memory subsystem.");
+#endif
+		/* Do any memory-routine initialization */
+		os_error_code = sah_Init_Mem_Map();
+	}
+
+	if (os_error_code == OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("Calling sah_HW_Reset() to Initialise the Hardware.");
+#endif
+		/* Initialise the hardware */
+		os_error_code = sah_HW_Reset();
+		if (os_error_code != OS_ERROR_OK_S) {
+			os_printk
+			    ("sah_HW_Reset() failed to Initialise the Hardware.\n");
+		}
+
+	}
+
+	if (os_error_code == OS_ERROR_OK_S) {
+#if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+		/* Register the DEVFS entry */
+		Sahara_devfs_handle = devfs_register(NULL,
+						     SAHARA_DEVICE_SHORT,
+						     DEVFS_FL_AUTO_DEVNUM,
+						     0, 0,
+						     SAHARA_DEVICE_MODE,
+						     &Fops, NULL);
+		if (Sahara_devfs_handle == NULL) {
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG
+			    ("Registering the DEVFS character device failed.");
+#endif				/* DIAG_DRV_IF */
+			os_error_code = -EBUSY;
+		}
+#else				/* CONFIG_DEVFS_FS */
+		/* Create the PROCFS entry. This is used to report the assigned device
+		 * major number back to user-space. */
+#if 1
+		Sahara_procfs_handle = create_proc_entry(SAHARA_DEVICE_SHORT, 0700,	/* default mode */
+							 NULL);	/* parent dir */
+		if (Sahara_procfs_handle == NULL) {
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("Registering the PROCFS interface failed.");
+#endif				/* DIAG_DRV_IF */
+			os_error_code = OS_ERROR_FAIL_S;
+		} else {
+			Sahara_procfs_handle->nlink = 1;
+			Sahara_procfs_handle->data = 0;
+			Sahara_procfs_handle->read_proc = sah_read_procfs;
+			Sahara_procfs_handle->write_proc = sah_write_procfs;
+		}
+#endif				/* #if 1 */
+	}
+
+	if (os_error_code == OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG
+		    ("Calling sah_Queue_Manager_Init() to Initialise the Queue "
+		     "Manager.");
+#endif
+		/* Initialise the Queue Manager */
+		if (sah_Queue_Manager_Init() != FSL_RETURN_OK_S) {
+			os_error_code = -ENOMEM;
+		}
+	}
+#ifndef SAHARA_POLL_MODE
+	if (os_error_code == OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("Calling sah_Intr_Init() to Initialise the Interrupt "
+			  "Handler.");
+#endif
+		/* Initialise the Interrupt Handler */
+		os_error_code = sah_Intr_Init(&Wait_queue);
+		if (os_error_code == OS_ERROR_OK_S) {
+			interrupt_registered = 1;
+		}
+	}
+#endif				/* ifndef SAHARA_POLL_MODE */
+
+#ifdef SAHARA_POWER_MANAGEMENT
+	if (os_error_code == OS_ERROR_OK_S) {
+		/* set up dynamic power management (dmp) */
+		os_error_code = sah_dpm_init();
+	}
+#endif
+
+	if (os_error_code == OS_ERROR_OK_S) {
+		os_driver_init_registration(reg_handle);
+		os_driver_add_registration(reg_handle, OS_FN_OPEN,
+					   OS_DEV_OPEN_REF(sah_open));
+		os_driver_add_registration(reg_handle, OS_FN_IOCTL,
+					   OS_DEV_IOCTL_REF(sah_ioctl));
+		os_driver_add_registration(reg_handle, OS_FN_CLOSE,
+					   OS_DEV_CLOSE_REF(sah_release));
+		os_driver_add_registration(reg_handle, OS_FN_MMAP,
+					   OS_DEV_MMAP_REF(sah_mmap));
+
+		os_error_code =
+		    os_driver_complete_registration(reg_handle, Major,
+						    "sahara");
+
+		if (os_error_code < OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+			snprintf(Diag_msg, DIAG_MSG_SIZE,
+				 "Registering the regular "
+				 "character device failed with error code: %d\n",
+				 os_error_code);
+			LOG_KDIAG(Diag_msg);
+#endif
+		}
+	}
+#endif				/* CONFIG_DEVFS_FS */
+
+	if (os_error_code == OS_ERROR_OK_S) {
+		/* set up the system keystore, using the default keystore handler */
+		fsl_shw_init_keystore_default(&system_keystore);
+
+		if (fsl_shw_establish_keystore(NULL, &system_keystore)
+		    == FSL_RETURN_OK_S) {
+			os_error_code = OS_ERROR_OK_S;
+		} else {
+			os_error_code = OS_ERROR_FAIL_S;
+		}
+
+		if (os_error_code != OS_ERROR_OK_S) {
+#ifdef DIAG_DRV_IF
+			snprintf(Diag_msg, DIAG_MSG_SIZE,
+				 "Registering the system keystore "
+				 "failed with error code: %d\n", os_error_code);
+			LOG_KDIAG(Diag_msg);
+#endif
+		}
+	}
+
+	if (os_error_code != OS_ERROR_OK_S) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+		cleanup_module();
+#else
+		sah_cleanup();
+#endif
+	}
+#ifdef DIAG_DRV_IF
+	else {
+		LOG_KDIAG_ARGS("Sahara major node is %d\n", Major);
+	}
+#endif
+
+/* Disabling the Clock after the driver has been registered fine.
+    This is done to save power when Sahara is not in use.*/
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG("SAHARA : Disabling the clocks\n")
+#endif				/* DIAG_DRV_IF */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+		mxc_clks_disable(SAHARA2_CLK);
+#else
+	{
+		if (IS_ERR(sah_clk))
+			os_error_code = PTR_ERR(sah_clk);
+		else
+			clk_disable(sah_clk);
+	}
+#endif
+
+	os_dev_init_return(os_error_code);
+}
+
+/*!
+*******************************************************************************
+* This function gets called when the module is removed (rmmod) from the running
+* kernel.
+*
+* @brief     SAHARA device clean-up function.
+*
+* @return   void
+*/
+OS_DEV_SHUTDOWN(sah_cleanup)
+{
+	int ret_val = 0;
+
+	printk(KERN_ALERT "Sahara going into cleanup\n");
+
+	/* clear out the system keystore */
+	fsl_shw_release_keystore(NULL, &system_keystore);
+
+	/* Unregister the device */
+#if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+	devfs_unregister(Sahara_devfs_handle);
+#else
+
+	if (Sahara_procfs_handle != NULL) {
+		remove_proc_entry(SAHARA_DEVICE_SHORT, NULL);
+	}
+
+	if (Major >= 0) {
+		ret_val = os_driver_remove_registration(reg_handle);
+	}
+#ifdef DIAG_DRV_IF
+	if (ret_val < 0) {
+		snprintf(Diag_msg, DIAG_MSG_SIZE, "Error while attempting to "
+			 "unregister the device: %d\n", ret_val);
+		LOG_KDIAG(Diag_msg);
+	}
+#endif
+
+#endif				/* CONFIG_DEVFS_FS */
+	sah_Queue_Manager_Close();
+
+#ifndef SAHARA_POLL_MODE
+	if (interrupt_registered) {
+		sah_Intr_Release();
+		interrupt_registered = 0;
+	}
+#endif
+	sah_Stop_Mem_Map();
+#ifdef SAHARA_POWER_MANAGEMENT
+	sah_dpm_close();
+#endif
+
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG("SAHARA : Disabling the clocks\n")
+#endif				/* DIAG_DRV_IF */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+	    mxc_clks_disable(SAHARA2_CLK);
+#else
+	{
+		if (IS_ERR(sah_clk))
+			ret_val = PTR_ERR(sah_clk);
+		else
+			clk_disable(sah_clk);
+		clk_put(sah_clk);
+	}
+#endif
+
+	os_dev_shutdown_return(ret_val);
+}
+
+/*!
+*******************************************************************************
+* This function simply increments the module usage count.
+*
+* @brief     SAHARA device open function.
+*
+* @param    inode Part of the kernel prototype.
+* @param    file Part of the kernel prototype.
+*
+* @return   0 - Always returns 0 since any number of calls to this function are
+*               allowed.
+*
+*/
+OS_DEV_OPEN(sah_open)
+{
+
+#if defined(LINUX_VERSION) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10))
+	MOD_INC_USE_COUNT;
+#endif
+
+#ifdef DIAG_DRV_IF
+	Device_in_use++;
+	snprintf(Diag_msg, DIAG_MSG_SIZE,
+		 "Incrementing module use count to: %d ", Device_in_use);
+	LOG_KDIAG(Diag_msg);
+#endif
+
+	os_dev_set_user_private(NULL);
+
+	/* Return 0 to indicate success */
+	os_dev_open_return(0);
+}
+
+/*!
+*******************************************************************************
+* This function simply decrements the module usage count.
+*
+* @brief     SAHARA device release function.
+*
+* @param    inode   Part of the kernel prototype.
+* @param    file    Part of the kernel prototype.
+*
+* @return   0 - Always returns 0 since this function does not fail.
+*/
+OS_DEV_CLOSE(sah_release)
+{
+	fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+#if defined(LINUX_VERSION) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10))
+	MOD_DEC_USE_COUNT;
+#endif
+
+#ifdef DIAG_DRV_IF
+	Device_in_use--;
+	snprintf(Diag_msg, DIAG_MSG_SIZE,
+		 "Decrementing module use count to: %d ", Device_in_use);
+	LOG_KDIAG(Diag_msg);
+#endif
+
+	if (user_ctx != NULL) {
+		sah_handle_deregistration(user_ctx);
+		os_free_memory(user_ctx);
+		os_dev_set_user_private(NULL);
+	}
+
+	/* Return 0 to indicate success */
+	os_dev_close_return(OS_ERROR_OK_S);
+}
+
+/*!
+*******************************************************************************
+* This function provides the IO Controls for the SAHARA driver. Three IO
+* Controls are supported:
+*
+*   SAHARA_HWRESET and
+*   SAHARA_SET_HA
+*   SAHARA_CHK_TEST_MODE
+*
+* @brief SAHARA device IO Control function.
+*
+* @param    inode   Part of the kernel prototype.
+* @param    filp    Part of the kernel prototype.
+* @param    cmd     Part of the kernel prototype.
+* @param    arg     Part of the kernel prototype.
+*
+* @return   0 on success
+* @return   -EBUSY if the HA bit could not be set due to busy hardware.
+* @return   -ENOTTY if an unsupported IOCTL was attempted on the device.
+* @return   -EFAULT if put_user() fails
+*/
+OS_DEV_IOCTL(sah_ioctl)
+{
+	int status = 0;
+	int test_mode;
+
+	mutex_lock(&sahara_ioctl_mutex);
+
+	switch (os_dev_get_ioctl_op()) {
+	case SAHARA_HWRESET:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_HWRESET IOCTL.");
+#endif
+		/* We need to reset the hardware. */
+		sah_HW_Reset();
+
+		/* Mark all the entries in the Queue Manager's queue with state
+		 * SAH_STATE_RESET.
+		 */
+		sah_Queue_Manager_Reset_Entries();
+
+		/* Wake up all sleeping write() calls. */
+		wake_up_interruptible(&Wait_queue);
+		break;
+#ifdef SAHARA_HA_ENABLED
+	case SAHARA_SET_HA:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SET_HA IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		if (sah_HW_Set_HA() == ERR_INTERNAL) {
+			status = -EBUSY;
+		}
+		break;
+#endif				/* SAHARA_HA_ENABLED */
+
+	case SAHARA_CHK_TEST_MODE:
+		/* load test_mode */
+		test_mode = TEST_MODE_OFF;
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_CHECK_TEST_MODE IOCTL.");
+		test_mode = TEST_MODE_ON;
+#endif				/* DIAG_DRV_IF */
+#if defined(KERNEL_TEST) || defined(PERF_TEST)
+		test_mode = TEST_MODE_ON;
+#endif				/* KERNEL_TEST || PERF_TEST */
+		/* copy test_mode back to user space.  put_user() is Linux fn */
+		/* compiler warning `register': no problem found so ignored */
+		status = put_user(test_mode, (int *)os_dev_get_ioctl_arg());
+		break;
+
+	case SAHARA_DAR:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_DAR IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			if (user_ctx != NULL) {
+				status =
+				    handle_sah_ioctl_dar(user_ctx,
+							 os_dev_get_ioctl_arg
+							 ());
+			} else {
+				status = OS_ERROR_FAIL_S;
+			}
+
+		}
+		break;
+
+	case SAHARA_GET_RESULTS:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_GET_RESULTS IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			if (user_ctx != NULL) {
+				status =
+				    sah_get_results_pointers(user_ctx,
+							     os_dev_get_ioctl_arg
+							     ());
+			} else {
+				status = OS_ERROR_FAIL_S;
+			}
+		}
+		break;
+
+	case SAHARA_REGISTER:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_REGISTER IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			if (user_ctx != NULL) {
+				status = OS_ERROR_FAIL_S;	/* already registered */
+			} else {
+				user_ctx =
+				    os_alloc_memory(sizeof(fsl_shw_uco_t),
+						    GFP_KERNEL);
+				if (user_ctx == NULL) {
+					status = OS_ERROR_NO_MEMORY_S;
+				} else {
+					/* Copy UCO from user, but only as big as the common UCO */
+					if (os_copy_from_user(user_ctx,
+							      (void *)
+							      os_dev_get_ioctl_arg
+							      (),
+							      offsetof
+							      (fsl_shw_uco_t,
+							       result_pool))) {
+						status = OS_ERROR_FAIL_S;
+					} else {
+						os_dev_set_user_private
+						    (user_ctx);
+						status =
+						    sah_handle_registration
+						    (user_ctx);
+					}
+				}
+			}
+		}
+		break;
+
+		/* This ioctl cmd should disappear in favor of a close() routine.  */
+	case SAHARA_DEREGISTER:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_DEREGISTER IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			if (user_ctx == NULL) {
+				status = OS_ERROR_FAIL_S;
+			} else {
+				status = sah_handle_deregistration(user_ctx);
+				os_free_memory(user_ctx);
+				os_dev_set_user_private(NULL);
+			}
+		}
+		break;
+	case SAHARA_SCC_DROP_PERMS:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SCC_DROP_PERMS IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			/* drop permissions on the specified partition */
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_drop_perms(user_ctx,
+						      os_dev_get_ioctl_arg());
+		}
+		break;
+
+	case SAHARA_SCC_SFREE:
+		/* Unmap the specified partition from the users space, and then
+		 * free it for use by someone else.
+		 */
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SCC_SFREE IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_sfree(user_ctx,
+						 os_dev_get_ioctl_arg());
+		}
+		break;
+
+	case SAHARA_SCC_SSTATUS:
+		/* Unmap the specified partition from the users space, and then
+		 * free it for use by someone else.
+		 */
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SCC_SSTATUS IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_sstatus(user_ctx,
+						   os_dev_get_ioctl_arg());
+		}
+		break;
+
+	case SAHARA_SCC_ENCRYPT:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SCC_ENCRYPT IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_encrypt(user_ctx,
+						   os_dev_get_ioctl_arg());
+		}
+		break;
+
+	case SAHARA_SCC_DECRYPT:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SCC_DECRYPT IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_decrypt(user_ctx,
+						   os_dev_get_ioctl_arg());
+		}
+		break;
+
+	case SAHARA_SK_ALLOC:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SK_ALLOC IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = sah_handle_sk_slot_alloc(os_dev_get_ioctl_arg());
+		break;
+
+	case SAHARA_SK_DEALLOC:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SK_DEALLOC IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = sah_handle_sk_slot_dealloc(os_dev_get_ioctl_arg());
+		break;
+
+	case SAHARA_SK_LOAD:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SK_LOAD IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = sah_handle_sk_slot_load(os_dev_get_ioctl_arg());
+		break;
+	case SAHARA_SK_READ:
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("SAHARA_SK_READ IOCTL.");
+#endif				/* DIAG_DRV_IF */
+				status = sah_handle_sk_slot_read(os_dev_get_ioctl_arg());
+				break;
+
+	case SAHARA_SK_SLOT_DEC:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SK_SLOT_DECRYPT IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = sah_handle_sk_slot_decrypt(os_dev_get_ioctl_arg());
+		break;
+
+	case SAHARA_SK_SLOT_ENC:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_SK_SLOT_ENCRYPT IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = sah_handle_sk_slot_encrypt(os_dev_get_ioctl_arg());
+		break;
+	case SAHARA_GET_CAPS:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA_GET_CAPS IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_get_capabilities(user_ctx,
+							os_dev_get_ioctl_arg());
+		}
+		break;
+
+	default:
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("Unknown SAHARA IOCTL.");
+#endif				/* DIAG_DRV_IF */
+		status = OS_ERROR_FAIL_S;
+	}
+
+	mutex_unlock(&sahara_ioctl_mutex);
+	os_dev_ioctl_return(status);
+}
+
+/* Fill in the user's capabilities structure */
+static os_error_code sah_handle_get_capabilities(fsl_shw_uco_t * user_ctx,
+						 uint32_t info)
+{
+	os_error_code status = OS_ERROR_FAIL_S;
+	fsl_shw_pco_t capabilities;
+
+	status = os_copy_from_user(&capabilities, (void *)info,
+				   sizeof(fsl_shw_pco_t));
+
+	if (status != OS_ERROR_OK_S) {
+		goto out;
+	}
+
+	if (get_capabilities(user_ctx, &capabilities) == FSL_RETURN_OK_S) {
+		status = os_copy_to_user((void *)info, &capabilities,
+					 sizeof(fsl_shw_pco_t));
+	}
+
+      out:
+	return status;
+}
+
+#ifdef FSL_HAVE_SCC2
+
+/* Find the kernel-mode address of the partition.
+ * This can then be passed to the SCC functions.
+ */
+void *lookup_user_partition(fsl_shw_uco_t * user_ctx, uint32_t user_base)
+{
+	/* search through the partition chain to find one that matches the user base
+	 * address.
+	 */
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base) {
+			return curr->kernel_base;
+		}
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+	return NULL;
+}
+
+/* user_base: userspace base address of the partition
+ * kernel_base: kernel mode base address of the partition
+ */
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
+						uint32_t user_base,
+						void *kernel_base)
+{
+	fsl_shw_spo_t *partition_info;
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	if (user_ctx == NULL) {
+		goto out;
+	}
+
+	partition_info = os_alloc_memory(sizeof(fsl_shw_spo_t), GFP_KERNEL);
+
+	if (partition_info == NULL) {
+		goto out;
+	}
+
+	/* stuff the partition info, then put it at the front of the chain */
+	partition_info->user_base = user_base;
+	partition_info->kernel_base = kernel_base;
+	partition_info->next = user_ctx->partition;
+
+	user_ctx->partition = (struct fsl_shw_spo_t *)partition_info;
+
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG_ARGS
+	    ("partition with user_base=%p, kernel_base=%p registered.",
+	     (void *)user_base, kernel_base);
+#endif
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+
+	return ret;
+}
+
+/* if the partition is in the users list, remove it */
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
+						  uint32_t user_base)
+{
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+	fsl_shw_spo_t *last = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base) {
+
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG_ARGS
+			    ("deregister_user_partition: partition with "
+			     "user_base=%p, kernel_base=%p deregistered.\n",
+			     (void *)curr->user_base, curr->kernel_base);
+#endif
+
+			if (last == curr) {
+				user_ctx->partition = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			} else {
+				last->next = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			}
+		}
+		last = curr;
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+
+	return FSL_RETURN_ERROR_S;
+}
+
+#endif				/* FSL_HAVE_SCC2 */
+
+static os_error_code sah_handle_scc_drop_perms(fsl_shw_uco_t * user_ctx,
+					       uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	scc_return_t scc_ret;
+	scc_partition_info_t partition_info;
+	void *kernel_base;
+
+	status =
+	    os_copy_from_user(&partition_info, (void *)info,
+			      sizeof(partition_info));
+
+	if (status != OS_ERROR_OK_S) {
+		goto out;
+	}
+
+	/* validate that the user owns this partition, and look up its handle */
+	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
+
+	if (kernel_base == NULL) {
+		status = OS_ERROR_FAIL_S;
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("_scc_drop_perms(): failed to find partition\n");
+#endif
+		goto out;
+	}
+
+	/* call scc driver to perform the drop */
+	scc_ret = scc_diminish_permissions(kernel_base,
+					   partition_info.permissions);
+	if (scc_ret == SCC_RET_OK) {
+		status = OS_ERROR_OK_S;
+	} else {
+		status = OS_ERROR_FAIL_S;
+	}
+
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code sah_handle_scc_sfree(fsl_shw_uco_t * user_ctx,
+					  uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		scc_partition_info_t partition_info;
+		void *kernel_base;
+		int ret;
+
+		status =
+		    os_copy_from_user(&partition_info, (void *)info,
+				      sizeof(partition_info));
+
+		/* check that the copy was successful */
+		if (status != OS_ERROR_OK_S) {
+			goto out;
+		}
+
+		/* validate that the user owns this partition, and look up its handle */
+		kernel_base =
+		    lookup_user_partition(user_ctx, partition_info.user_base);
+
+		if (kernel_base == NULL) {
+			status = OS_ERROR_FAIL_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("failed to find partition\n");
+#endif				/*DIAG_DRV_IF */
+			goto out;
+		}
+
+		/* Unmap the memory region (see sys_munmap in mmap.c) */
+		ret = unmap_user_memory(partition_info.user_base, 8192);
+
+		/* If the memory was successfully released */
+		if (ret == OS_ERROR_OK_S) {
+
+			/* release the partition */
+			scc_release_partition(kernel_base);
+
+			/* and remove it from the users context */
+			deregister_user_partition(user_ctx,
+						  partition_info.user_base);
+
+			status = OS_ERROR_OK_S;
+		}
+	}
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code sah_handle_scc_sstatus(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		scc_partition_info_t partition_info;
+		void *kernel_base;
+
+		status =
+		    os_copy_from_user(&partition_info, (void *)info,
+				      sizeof(partition_info));
+
+		/* check that the copy was successful */
+		if (status != OS_ERROR_OK_S) {
+			goto out;
+		}
+
+		/* validate that the user owns this partition, and look up its handle */
+		kernel_base =
+		    lookup_user_partition(user_ctx, partition_info.user_base);
+
+		if (kernel_base == NULL) {
+			status = OS_ERROR_FAIL_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("failed to find partition\n");
+#endif				/*DIAG_DRV_IF */
+			goto out;
+		}
+
+		partition_info.status = scc_partition_status(kernel_base);
+
+		status =
+		    os_copy_to_user((void *)info, &partition_info,
+				    sizeof(partition_info));
+	}
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code sah_handle_scc_encrypt(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
+{
+	os_error_code os_err = OS_ERROR_FAIL_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr = NULL;
+		void *partition_base = NULL;
+		scc_config_t *scc_configuration;
+
+		os_err =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
+
+		if (os_err != OS_ERROR_OK_S) {
+			goto out;
+		}
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG_ARGS
+		    ("partition_base: %p, offset: %i, length: %i, black data: %p",
+		     (void *)region_info.partition_base, region_info.offset,
+		     region_info.length, (void *)region_info.black_data);
+#endif
+
+		/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
+
+		if (partition_base == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("failed to find secure partition\n");
+#endif
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		/* wire down black data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
+
+		if (black_addr == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_encrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+
+	      out:
+		if (os_err == OS_ERROR_OK_S) {
+			/* Return error code */
+			region_info.code = retval;
+			os_err =
+			    os_copy_to_user((void *)info, &region_info,
+					    sizeof(region_info));
+		}
+	}
+
+#endif
+	return os_err;
+}
+
+static os_error_code sah_handle_scc_decrypt(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
+{
+	os_error_code os_err = OS_ERROR_FAIL_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr;
+		void *partition_base;
+		scc_config_t *scc_configuration;
+
+		os_err =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
+
+		if (os_err != OS_ERROR_OK_S) {
+			goto out;
+		}
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG_ARGS
+		    ("partition_base: %p, offset: %i, length: %i, black data: %p",
+		     (void *)region_info.partition_base, region_info.offset,
+		     region_info.length, (void *)region_info.black_data);
+#endif
+
+		/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
+
+		if (partition_base == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("failed to find partition\n");
+#endif
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		/* wire down black data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
+
+		if (black_addr == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_decrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+
+	      out:
+		if (os_err == OS_ERROR_OK_S) {
+			/* Return error code */
+			region_info.code = retval;
+			os_err =
+			    os_copy_to_user((void *)info, &region_info,
+					    sizeof(region_info));
+		}
+	}
+
+#endif				/* FSL_HAVE_SCC2 */
+	return os_err;
+}
+
+/*****************************************************************************/
+/* fn get_user_smid()                                                        */
+/*****************************************************************************/
+uint32_t get_user_smid(void *proc)
+{
+	/*
+	 * A real implementation would have some way to handle signed applications
+	 * which wouild be assigned distinct SMIDs.  For the reference
+	 * implementation, we show where this would be determined (here), but
+	 * always provide a fixed answer, thus not separating users at all.
+	 */
+
+	return 0x42eaae42;
+}
+
+/*!
+*******************************************************************************
+* This function implements the smalloc() function for userspace programs, by
+* making a call to the SCC2 mmap() function that acquires a region of secure
+* memory on behalf of the user, and then maps it into the users memory space.
+* Currently, the only memory size supported is that of a single SCC2 partition.
+* Requests for other sized memory regions will fail.
+*/
+OS_DEV_MMAP(sah_mmap)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+
+#ifdef FSL_HAVE_SCC2
+	{
+		scc_return_t scc_ret;
+		fsl_shw_return_t fsl_ret;
+		uint32_t partition_registered = FALSE;
+
+		uint32_t user_base;
+		void *partition_base;
+		uint32_t smid;
+		scc_config_t *scc_configuration;
+
+		int part_no = -1;
+		uint32_t part_phys;
+
+		fsl_shw_uco_t *user_ctx =
+		    (fsl_shw_uco_t *) os_dev_get_user_private();
+
+		/* Make sure that the user context is valid */
+		if (user_ctx == NULL) {
+			user_ctx =
+			    os_alloc_memory(sizeof(*user_ctx), GFP_KERNEL);
+
+			if (user_ctx == NULL) {
+				status = OS_ERROR_NO_MEMORY_S;
+				goto out;
+			}
+
+			sah_handle_registration(user_ctx);
+			os_dev_set_user_private(user_ctx);
+		}
+
+		/* Determine the size of a secure partition */
+		scc_configuration = scc_get_configuration();
+
+		/* Check that the memory size requested is equal to the partition
+		 * size, and that the requested destination is on a page boundary.
+		 */
+		if (((os_mmap_user_base() % PAGE_SIZE) != 0) ||
+		    (os_mmap_memory_size() !=
+		     scc_configuration->partition_size_bytes)) {
+			status = OS_ERROR_BAD_ARG_S;
+			goto out;
+		}
+
+		/* Retrieve the SMID associated with the user */
+		smid = get_user_smid(user_ctx->process);
+
+		/* Attempt to allocate a secure partition */
+		scc_ret =
+		    scc_allocate_partition(smid, &part_no, &partition_base,
+					   &part_phys);
+		if (scc_ret != SCC_RET_OK) {
+			pr_debug
+			    ("SCC mmap() request failed to allocate partition;"
+			     " error %d\n", status);
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		pr_debug("scc_mmap() acquired partition %d at %08x\n",
+			 part_no, part_phys);
+
+		/* Record partition info in the user context */
+		user_base = os_mmap_user_base();
+		fsl_ret =
+		    register_user_partition(user_ctx, user_base,
+					    partition_base);
+
+		if (fsl_ret != FSL_RETURN_OK_S) {
+			pr_debug
+			    ("SCC mmap() request failed to register partition with user"
+			     " context, error: %d\n", fsl_ret);
+			status = OS_ERROR_FAIL_S;
+		}
+
+		partition_registered = TRUE;
+
+		status = map_user_memory(os_mmap_memory_ctx(), part_phys,
+					 os_mmap_memory_size());
+
+#ifdef SHW_DEBUG
+		if (status == OS_ERROR_OK_S) {
+			LOG_KDIAG_ARGS
+			    ("Partition allocated: user_base=%p, partition_base=%p.",
+			     (void *)user_base, partition_base);
+		}
+#endif
+
+	      out:
+		/* If there is an error it has to be handled here */
+		if (status != OS_ERROR_OK_S) {
+			/* if the partition was registered with the user, unregister it. */
+			if (partition_registered == TRUE) {
+				deregister_user_partition(user_ctx, user_base);
+			}
+
+			/* if the partition was allocated, deallocate it */
+			if (partition_base != NULL) {
+				scc_release_partition(partition_base);
+			}
+		}
+	}
+#endif				/* FSL_HAVE_SCC2 */
+
+	return status;
+}
+
+/* Find the physical address of a key stored in the system keystore */
+fsl_shw_return_t
+system_keystore_get_slot_info(uint64_t owner_id, uint32_t slot,
+			      uint32_t * address, uint32_t * slot_size_bytes)
+{
+	fsl_shw_return_t retval;
+	void *kernel_address;
+
+	/* First verify that the key access is valid */
+	retval = system_keystore.slot_verify_access(system_keystore.user_data,
+						    owner_id, slot);
+
+	if (retval != FSL_RETURN_OK_S) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("verification failed");
+#endif
+		return retval;
+	}
+
+	if (address != NULL) {
+#ifdef FSL_HAVE_SCC2
+		kernel_address =
+		    system_keystore.slot_get_address(system_keystore.user_data,
+						     slot);
+		(*address) = scc_virt_to_phys(kernel_address);
+#else
+		kernel_address =
+		    system_keystore.slot_get_address((void *)&owner_id, slot);
+		(*address) = (uint32_t) kernel_address;
+#endif
+	}
+
+	if (slot_size_bytes != NULL) {
+#ifdef FSL_HAVE_SCC2
+		*slot_size_bytes =
+		    system_keystore.slot_get_slot_size(system_keystore.
+						       user_data, slot);
+#else
+		*slot_size_bytes =
+		    system_keystore.slot_get_slot_size((void *)&owner_id, slot);
+#endif
+	}
+
+	return retval;
+}
+
+static os_error_code sah_handle_sk_slot_alloc(uint32_t info)
+{
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	scc_return_t scc_ret;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+	if (os_err == OS_ERROR_OK_S) {
+		scc_ret = keystore_slot_alloc(&system_keystore,
+					      slot_info.key_length,
+					      slot_info.ownerid,
+					      &slot_info.slot);
+		if (scc_ret == SCC_RET_OK) {
+			slot_info.code = FSL_RETURN_OK_S;
+		} else if (scc_ret == SCC_RET_INSUFFICIENT_SPACE) {
+			slot_info.code = FSL_RETURN_NO_RESOURCE_S;
+		} else {
+			slot_info.code = FSL_RETURN_ERROR_S;
+		}
+
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG_ARGS("key length: %i, handle: %i\n",
+			       slot_info.key_length, slot_info.slot);
+#endif
+
+		/* Return error code and slot info */
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+
+		if (os_err != OS_ERROR_OK_S) {
+			(void)keystore_slot_dealloc(&system_keystore,
+						    slot_info.ownerid,
+						    slot_info.slot);
+		}
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_dealloc(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	scc_return_t scc_ret;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+		scc_ret = keystore_slot_dealloc(&system_keystore,
+						slot_info.ownerid,
+						slot_info.slot);
+
+		if (scc_ret == SCC_RET_OK) {
+			ret = FSL_RETURN_OK_S;
+		} else {
+			ret = FSL_RETURN_ERROR_S;
+		}
+		slot_info.code = ret;
+
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_load(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	uint8_t *key = NULL;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+		/* Allow slop in alloc in case we are rounding up to word multiple */
+		key = os_alloc_memory(slot_info.key_length + 3, GFP_KERNEL);
+		if (key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+			os_err = OS_ERROR_NO_MEMORY_S;
+		} else {
+			os_err = os_copy_from_user(key, slot_info.key,
+						   slot_info.key_length);
+		}
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		unsigned key_length = slot_info.key_length;
+
+		/* Round up if necessary, as SCC call wants a multiple of 32-bit
+		 * values for the full object being loaded. */
+		if ((key_length & 3) != 0) {
+			key_length += 4 - (key_length & 3);
+		}
+		ret = keystore_slot_load(&system_keystore,
+					 slot_info.ownerid, slot_info.slot, key,
+					 key_length);
+
+		slot_info.code = ret;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+	}
+
+	if (key != NULL) {
+		memset(key, 0, slot_info.key_length);
+		os_free_memory(key);
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_read(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	uint8_t *key = NULL;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+
+		/* This operation is not allowed for user keys */
+		slot_info.code = FSL_RETURN_NO_RESOURCE_S;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+
+		return os_err;
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		/* Allow slop in alloc in case we are rounding up to word multiple */
+		key = os_alloc_memory(slot_info.key_length + 3, GFP_KERNEL);
+		if (key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+			os_err = OS_ERROR_NO_MEMORY_S;
+		}
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		unsigned key_length = slot_info.key_length;
+
+		/* @bug Do some PERMISSIONS checking - make sure this is SW key */
+
+		/* Round up if necessary, as SCC call wants a multiple of 32-bit
+		 * values for the full object being loaded. */
+		if ((key_length & 3) != 0) {
+			key_length += 4 - (key_length & 3);
+		}
+		ret = keystore_slot_read(&system_keystore,
+					 slot_info.ownerid, slot_info.slot,
+					 key_length, key);
+
+		/* @bug do some error checking */
+
+		/* Send key back to user */
+		os_err = os_copy_to_user(slot_info.key, key,
+					 slot_info.key_length);
+
+		slot_info.code = ret;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+	}
+
+	if (key != NULL) {
+		memset(key, 0, slot_info.key_length);
+		os_free_memory(key);
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_encrypt(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	scc_return_t scc_ret;
+	uint8_t *key = NULL;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+		key = os_alloc_memory(slot_info.key_length, GFP_KERNEL);
+		if (key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+		}
+	}
+
+	if (key != NULL) {
+
+		scc_ret = keystore_slot_encrypt(NULL, &system_keystore,
+						slot_info.ownerid,
+						slot_info.slot,
+						slot_info.key_length, key);
+
+		if (scc_ret != SCC_RET_OK) {
+			ret = FSL_RETURN_ERROR_S;
+		} else {
+			os_err =
+			    os_copy_to_user(slot_info.key, key,
+					    slot_info.key_length);
+			if (os_err != OS_ERROR_OK_S) {
+				ret = FSL_RETURN_INTERNAL_ERROR_S;
+			} else {
+				ret = FSL_RETURN_OK_S;
+			}
+		}
+
+		slot_info.code = ret;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+
+		memset(key, 0, slot_info.key_length);
+		os_free_memory(key);
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_decrypt(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;	/*!< decrypt request fields */
+	os_error_code os_err;
+	scc_return_t scc_ret;
+	uint8_t *key = NULL;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+		key = os_alloc_memory(slot_info.key_length, GFP_KERNEL);
+		if (key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+			os_err = OS_ERROR_OK_S;
+		} else {
+			os_err = os_copy_from_user(key, slot_info.key,
+						   slot_info.key_length);
+		}
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		scc_ret = keystore_slot_decrypt(NULL, &system_keystore,
+						slot_info.ownerid,
+						slot_info.slot,
+						slot_info.key_length, key);
+		if (scc_ret == SCC_RET_OK) {
+			ret = FSL_RETURN_OK_S;
+		} else {
+			ret = FSL_RETURN_ERROR_S;
+		}
+
+		slot_info.code = ret;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+	}
+
+	if (key != NULL) {
+		memset(key, 0, slot_info.key_length);
+		os_free_memory(key);
+	}
+
+	return os_err;
+}
+
+/*!
+ * Register a user
+ *
+ * @brief Register a user
+  *
+ * @param  user_ctx  information about this user
+ *
+ * @return   status code
+ */
+fsl_shw_return_t sah_handle_registration(fsl_shw_uco_t * user_ctx)
+{
+	/* Initialize the user's result pool (like sah_Queue_Construct() */
+	user_ctx->result_pool.head = NULL;
+	user_ctx->result_pool.tail = NULL;
+	user_ctx->result_pool.count = 0;
+
+	/* initialize the user's partition chain */
+	user_ctx->partition = NULL;
+
+	return FSL_RETURN_OK_S;
+}
+
+/*!
+ * Deregister a user
+ *
+ * @brief Deregister a user
+ *
+ * @param  user_ctx  information about this user
+ *
+ * @return   status code
+ */
+fsl_shw_return_t sah_handle_deregistration(fsl_shw_uco_t * user_ctx)
+{
+	/* NOTE:
+	 * This will release any secure partitions that are held by the user.
+	 * Encryption keys that were placed in the system keystore by the user
+	 * should not be removed here, because they might have been shared with
+	 * another process.  The user must be careful to release any that are no
+	 * longer in use.
+	 */
+	fsl_shw_return_t ret = FSL_RETURN_OK_S;
+
+#ifdef FSL_HAVE_SCC2
+	fsl_shw_spo_t *partition;
+	struct mm_struct *mm = current->mm;
+
+	while ((user_ctx->partition != NULL) && (ret == FSL_RETURN_OK_S)) {
+
+		partition = user_ctx->partition;
+
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG_ARGS
+		    ("Found an abandoned secure partition at %p, releasing",
+		     partition);
+#endif
+
+		/* It appears that current->mm is not valid if this is called from a
+		 * close routine (perhaps only if the program raised an exception that
+		 * caused it to close?)  If that is the case, then still free the
+		 * partition, but do not remove it from the memory space (dangerous?)
+		 */
+
+		if (mm == NULL) {
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG
+			    ("Warning: no mm structure found, not unmapping "
+			     "partition from user memory\n");
+#endif
+		} else {
+			/* Unmap the memory region (see sys_munmap in mmap.c) */
+			/* Note that this assumes a single memory partition */
+			unmap_user_memory(partition->user_base, 8192);
+		}
+
+		/* If the memory was successfully released */
+		if (ret == OS_ERROR_OK_S) {
+			/* release the partition */
+			scc_release_partition(partition->kernel_base);
+
+			/* and remove it from the users context */
+			deregister_user_partition(user_ctx,
+						  partition->user_base);
+
+			ret = FSL_RETURN_OK_S;
+		} else {
+			ret = FSL_RETURN_ERROR_S;
+
+			goto out;
+		}
+	}
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+
+	return ret;
+}
+
+/*!
+ * Sets up memory to extract results from results pool
+ *
+ * @brief Sets up memory to extract results from results pool
+ *
+ * @param  user_ctx  information about this user
+ * @param[in,out]   arg contains input parameters and fields that the driver
+ *                   fills in
+ *
+ * @return   os error code or 0 on success
+ */
+int sah_get_results_pointers(fsl_shw_uco_t * user_ctx, uint32_t arg)
+{
+	sah_results results_arg;	/* kernel mode usable version of 'arg' */
+	fsl_shw_result_t *user_results;	/* user mode address of results */
+	unsigned *user_actual;	/* user mode address of actual number of results */
+	unsigned actual;	/* local memory of actual number of results */
+	int ret_val = OS_ERROR_FAIL_S;
+	sah_Head_Desc *finished_request;
+	unsigned int loop;
+
+	/* copy structure from user to kernel space */
+	if (!os_copy_from_user(&results_arg, (void *)arg, sizeof(sah_results))) {
+		/* save user space pointers */
+		user_actual = results_arg.actual;	/* where count goes */
+		user_results = results_arg.results;	/* where results goe */
+
+		/* Set pointer for actual value to temporary kernel memory location */
+		results_arg.actual = &actual;
+
+		/* Allocate kernel memory to hold temporary copy of the results */
+		results_arg.results =
+		    os_alloc_memory(sizeof(fsl_shw_result_t) *
+				    results_arg.requested, GFP_KERNEL);
+
+		/* if memory allocated, continue */
+		if (results_arg.results == NULL) {
+			ret_val = OS_ERROR_NO_MEMORY_S;
+		} else {
+			fsl_shw_return_t get_status;
+
+			/* get the results */
+			get_status =
+			    sah_get_results_from_pool(user_ctx, &results_arg);
+
+			/* free the copy of the user space descriptor chain */
+			for (loop = 0; loop < actual; ++loop) {
+				/* get sah_Head_Desc from results and put user address into
+				 * the return structure */
+				finished_request =
+				    results_arg.results[loop].user_desc;
+				results_arg.results[loop].user_desc =
+				    finished_request->user_desc;
+				/* return the descriptor chain memory to the block free pool */
+				sah_Free_Chained_Descriptors(finished_request);
+			}
+
+			/* if no errors, copy results and then the actual number of results
+			 * back to user space
+			 */
+			if (get_status == FSL_RETURN_OK_S) {
+				if (os_copy_to_user
+				    (user_results, results_arg.results,
+				     actual * sizeof(fsl_shw_result_t))
+				    || os_copy_to_user(user_actual, &actual,
+						       sizeof(user_actual))) {
+					ret_val = OS_ERROR_FAIL_S;
+				} else {
+					ret_val = 0;	/* no error */
+				}
+			}
+			/* free the allocated memory */
+			os_free_memory(results_arg.results);
+		}
+	}
+
+	return ret_val;
+}
+
+/*!
+ * Extracts results from results pool
+ *
+ * @brief Extract results from results pool
+ *
+ * @param           user_ctx  information about this user
+ * @param[in,out]   arg       contains input parameters and fields that the
+ *                            driver fills in
+ *
+ * @return   status code
+ */
+fsl_shw_return_t sah_get_results_from_pool(volatile fsl_shw_uco_t * user_ctx,
+					   sah_results * arg)
+{
+	sah_Head_Desc *finished_request;
+	unsigned int loop = 0;
+	os_lock_context_t int_flags;
+
+	/* Get the number of results requested, up to total number of results
+	 * available
+	 */
+	do {
+		/* Protect state of user's result pool until we have retrieved and
+		 * remove the first entry, or determined that the pool is empty. */
+		os_lock_save_context(desc_queue_lock, int_flags);
+		finished_request = user_ctx->result_pool.head;
+
+		if (finished_request != NULL) {
+			sah_Queue_Remove_Entry((sah_Queue *) & user_ctx->
+					       result_pool);
+			os_unlock_restore_context(desc_queue_lock, int_flags);
+
+			/* Prepare to free. */
+			(void)sah_DePhysicalise_Descriptors(finished_request);
+
+			arg->results[loop].user_ref =
+			    finished_request->user_ref;
+			arg->results[loop].code = finished_request->result;
+			arg->results[loop].detail1 =
+			    finished_request->fault_address;
+			arg->results[loop].detail2 = 0;
+			arg->results[loop].user_desc = finished_request;
+
+			loop++;
+		} else {	/* finished_request is NULL */
+			/* pool is empty */
+			os_unlock_restore_context(desc_queue_lock, int_flags);
+		}
+
+	} while ((loop < arg->requested) && (finished_request != NULL));
+
+	/* record number of results actually obtained */
+	*arg->actual = loop;
+
+	return FSL_RETURN_OK_S;
+}
+
+/*!
+ * Converts descriptor chain to kernel space (from user space) and submits
+ * chain to Sahara for processing
+ *
+ * @brief Submits converted descriptor chain to sahara
+ *
+ * @param  user_ctx        Pointer to Kernel version of user's ctx
+ * @param  user_space_desc user space address of descriptor chain that is
+ *                         in user space
+ *
+ * @return   OS status code
+ */
+static int handle_sah_ioctl_dar(fsl_shw_uco_t * user_ctx,
+				uint32_t user_space_desc)
+{
+	int os_error_code = OS_ERROR_FAIL_S;
+	sah_Head_Desc *desc_chain_head;	/* chain in kernel - virtual address */
+
+	/* This will re-create the linked list so that the SAHARA hardware can
+	 * DMA on it.
+	 */
+	desc_chain_head = sah_Copy_Descriptors(user_ctx,
+					       (sah_Head_Desc *)
+					       user_space_desc);
+
+	if (desc_chain_head == NULL) {
+		/* We may have failed due to a -EFAULT as well, but we will return
+		 * OS_ERROR_NO_MEMORY_S since either way it is a memory related
+		 * failure.
+		 */
+		os_error_code = OS_ERROR_NO_MEMORY_S;
+	} else {
+		fsl_shw_return_t stat;
+
+		desc_chain_head->user_info = user_ctx;
+		desc_chain_head->user_desc = (sah_Head_Desc *) user_space_desc;
+
+		if (desc_chain_head->uco_flags & FSL_UCO_BLOCKING_MODE) {
+#ifdef SAHARA_POLL_MODE
+			sah_Handle_Poll(desc_chain_head);
+#else
+			sah_blocking_mode(desc_chain_head);
+#endif
+			stat = desc_chain_head->result;
+			/* return the descriptor chain memory to the block free pool */
+			sah_Free_Chained_Descriptors(desc_chain_head);
+			/* Tell user how the call turned out */
+
+			/* Copy 'result' back up to the result member.
+			 *
+			 * The dereference of the different member will cause correct the
+			 * arithmetic to occur on the user-space address because of the
+			 * missing dma/bus locations in the user mode version of the
+			 * sah_Desc structure. */
+			os_error_code =
+			    os_copy_to_user((void *)(user_space_desc
+						     + offsetof(sah_Head_Desc,
+								uco_flags)),
+					    &stat, sizeof(fsl_shw_return_t));
+
+		} else {	/* not blocking mode - queue and forget */
+
+			if (desc_chain_head->uco_flags & FSL_UCO_CALLBACK_MODE) {
+				user_ctx->process = os_get_process_handle();
+				user_ctx->callback = sah_user_callback;
+			}
+#ifdef SAHARA_POLL_MODE
+			/* will put results in result pool */
+			sah_Handle_Poll(desc_chain_head);
+#else
+			/* just put someting in the DAR */
+			sah_Queue_Manager_Append_Entry(desc_chain_head);
+#endif
+			/* assume all went well */
+			os_error_code = OS_ERROR_OK_S;
+		}
+	}
+
+	return os_error_code;
+}
+
+static void sah_user_callback(fsl_shw_uco_t * user_ctx)
+{
+	os_send_signal(user_ctx->process, SIGUSR2);
+}
+
+/*!
+ * This function is called when a thread attempts to read from the /proc/sahara
+ * file.  Upon read, statistics and information about the state of the driver
+ * are returned in nthe supplied buffer.
+ *
+ * @brief     SAHARA PROCFS read function.
+ *
+ * @param    buf     Anything written to this buffer will be returned to the
+ *                   user-space process that is reading from this proc entry.
+ * @param    start   Part of the kernel prototype.
+ * @param    offset  Part of the kernel prototype.
+ * @param    count   The size of the buf argument.
+ * @param    eof     An integer which is set to one to tell the user-space
+ *                   process that there is no more data to read.
+ * @param    data    Part of the kernel prototype.
+ *
+ * @return   The number of bytes written to the proc entry.
+ */
+#if !defined(CONFIG_DEVFS_FS) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+static int sah_read_procfs(char *buf,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	int output_bytes = 0;
+	int in_queue_count = 0;
+	os_lock_context_t lock_context;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+	clk_enable(sah_clk);
+#endif
+	os_lock_save_context(desc_queue_lock, lock_context);
+	in_queue_count = sah_Queue_Manager_Count_Entries(TRUE, 0);
+	os_unlock_restore_context(desc_queue_lock, lock_context);
+	output_bytes += snprintf(buf, count - output_bytes, "queued: %d\n",
+				 in_queue_count);
+	output_bytes += snprintf(buf + output_bytes, count - output_bytes,
+				 "Descriptors: %d, "
+				 "Interrupts %d (%d Done1Done2, %d Done1Busy2, "
+				 " %d Done1)\n",
+				 dar_count, interrupt_count, done1done2_count,
+				 done1busy2_count, done1_count);
+	output_bytes += snprintf(buf + output_bytes, count - output_bytes,
+				 "Control: %08x\n", sah_HW_Read_Control());
+#if !defined(FSL_HAVE_SAHARA4) || defined(SAHARA4_NO_USE_SQUIB)
+	output_bytes += snprintf(buf + output_bytes, count - output_bytes,
+				 "IDAR: %08x; CDAR: %08x\n",
+				 sah_HW_Read_IDAR(), sah_HW_Read_CDAR());
+#endif
+#ifdef DIAG_DRV_STATUS
+	output_bytes += snprintf(buf + output_bytes, count - output_bytes,
+				 "Status: %08x; Error Status: %08x; Op Status: %08x\n",
+				 sah_HW_Read_Status(),
+				 sah_HW_Read_Error_Status(),
+				 sah_HW_Read_Op_Status());
+#endif
+#ifdef FSL_HAVE_SAHARA4
+	output_bytes += snprintf(buf + output_bytes, count - output_bytes,
+				 "MMStat: %08x; Config: %08x\n",
+				 sah_HW_Read_MM_Status(), sah_HW_Read_Config());
+#endif
+
+	/* Signal the end of the file */
+	*eof = 1;
+
+	/* To get rid of the unused parameter warnings */
+	(void)start;
+	(void)data;
+	(void)offset;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+	clk_enable(sah_clk);
+#endif
+	return output_bytes;
+}
+
+static int sah_write_procfs(struct file *file, const char __user * buffer,
+			    unsigned long count, void *data)
+{
+
+	/* Any write to this file will reset all counts. */
+	dar_count = interrupt_count = done1done2_count =
+	    done1busy2_count = done1_count = 0;
+
+	(void)file;
+	(void)buffer;
+	(void)data;
+
+	return count;
+}
+
+#endif
+
+#ifndef SAHARA_POLL_MODE
+/*!
+ * Block user call until processing is complete.
+ *
+ * @param entry    The user's request.
+ *
+ * @return   An OS error code, or 0 if no error
+ */
+int sah_blocking_mode(sah_Head_Desc * entry)
+{
+	int os_error_code = 0;
+	sah_Queue_Status status;
+
+	/* queue entry, put something in the DAR, if nothing is there currently */
+	sah_Queue_Manager_Append_Entry(entry);
+
+	/* get this descriptor chain's current status */
+	status = ((volatile sah_Head_Desc *)entry)->status;
+
+	while (!SAH_DESC_PROCESSED(status)) {
+		extern sah_Queue *main_queue;
+
+		DEFINE_WAIT(sahara_wait);	/* create a wait queue entry. Linux */
+
+		/* enter the wait queue entry into the queue */
+		prepare_to_wait(&Wait_queue, &sahara_wait, TASK_INTERRUPTIBLE);
+
+		/* check if this entry has been processed */
+		status = ((volatile sah_Head_Desc *)entry)->status;
+
+		if (!SAH_DESC_PROCESSED(status)) {
+			/* go to sleep - Linux */
+			schedule();
+		}
+
+		/* un-queue the 'prepare to wait' queue? - Linux */
+		finish_wait(&Wait_queue, &sahara_wait);
+
+		/* signal belongs to this thread? */
+		if (signal_pending(current)) {	/* Linux */
+			os_lock_context_t lock_flags;
+
+			/* don't allow access during this check and operation */
+			os_lock_save_context(desc_queue_lock, lock_flags);
+			status = ((volatile sah_Head_Desc *)entry)->status;
+			if (status == SAH_STATE_PENDING) {
+				sah_Queue_Remove_Any_Entry(main_queue, entry);
+				entry->result = FSL_RETURN_INTERNAL_ERROR_S;
+				((volatile sah_Head_Desc *)entry)->status =
+				    SAH_STATE_FAILED;
+			}
+			os_unlock_restore_context(desc_queue_lock, lock_flags);
+		}
+
+		status = ((volatile sah_Head_Desc *)entry)->status;
+	}			/* while ... */
+
+	/* Do this so that caller can free */
+	(void)sah_DePhysicalise_Descriptors(entry);
+
+	return os_error_code;
+}
+
+/*!
+ * If interrupt does not return in a reasonable time, time out, trigger
+ * interrupt, and continue with process
+ *
+ * @param    data   ignored
+ */
+void sahara_timeout_handler(unsigned long data)
+{
+	/* Sahara has not issuing an interrupt, so timed out */
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG("Sahara HW did not respond.  Resetting.\n");
+#endif
+	/* assume hardware needs resetting */
+	sah_Handle_Interrupt(SAH_EXEC_FAULT);
+	/* wake up sleeping thread to try again */
+	wake_up_interruptible(&Wait_queue);
+}
+
+#endif				/* ifndef SAHARA_POLL_MODE */
+
+/* End of sah_driver_interface.c */
diff --git a/drivers/mxc/security/sahara2/sah_hardware_interface.c b/drivers/mxc/security/sahara2/sah_hardware_interface.c
new file mode 100644
index 0000000..ff3cb98
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_hardware_interface.c
@@ -0,0 +1,808 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sah_hardware_interface.c
+ *
+ * @brief Provides an interface to the SAHARA hardware registers.
+ *
+ */
+
+/* SAHARA Includes */
+#include <sah_driver_common.h>
+#include <sah_hardware_interface.h>
+#include <sah_memory_mapper.h>
+#include <sah_kernel.h>
+
+#if defined DIAG_DRV_IF || defined(DO_DBG)
+#include <diagnostic.h>
+#ifndef LOG_KDIAG
+#define LOG_KDIAG(x) os_printk("%s\n", x)
+#endif
+
+static void sah_Dump_Link(const char *prefix, const sah_Link * link,
+			  dma_addr_t addr);
+
+/* This is for sprintf() to use when constructing output. */
+#define DIAG_MSG_SIZE   1024
+/* was 200 */
+#define MAX_DUMP        200
+static char Diag_msg[DIAG_MSG_SIZE];
+
+#endif				/* DIAG_DRV_IF */
+
+/*!
+ * Number of descriptors sent to Sahara.  This value should only be updated
+ * with the main queue lock held.
+ */
+uint32_t dar_count;
+
+/* sahara virtual base address */
+void *sah_virt_base;
+
+/*! The "link-list optimize" bit in the Header of a Descriptor */
+#define SAH_HDR_LLO 0x01000000
+
+#define SAHARA_VERSION_REGISTER_OFFSET  0x000
+#define SAHARA_DAR_REGISTER_OFFSET      0x004
+#define SAHARA_CONTROL_REGISTER_OFFSET  0x008
+#define SAHARA_COMMAND_REGISTER_OFFSET  0x00C
+#define SAHARA_STATUS_REGISTER_OFFSET   0x010
+#define SAHARA_ESTATUS_REGISTER_OFFSET  0x014
+#define SAHARA_FLT_ADD_REGISTER_OFFSET  0x018
+#define SAHARA_CDAR_REGISTER_OFFSET     0x01C
+#define SAHARA_IDAR_REGISTER_OFFSET     0x020
+#define SAHARA_OSTATUS_REGISTER_OFFSET  0x028
+#define SAHARA_CONFIG_REGISTER_OFFSET   0x02C
+#define SAHARA_MM_STAT_REGISTER_OFFSET  0x030
+
+
+/* Local Functions */
+#if defined DIAG_DRV_IF || defined DO_DBG
+void sah_Dump_Region(const char *prefix, const unsigned char *data,
+		     dma_addr_t addr, unsigned length);
+
+#endif				/* DIAG_DRV_IF */
+
+/* time out value when polling SAHARA status register for completion */
+static uint32_t sah_poll_timeout = 0xFFFFFFFF;
+
+/*!
+ * Polls Sahara to determine when its current operation is complete
+ *
+ * @return   last value found in Sahara's status register
+ */
+sah_Execute_Status sah_Wait_On_Sahara()
+{
+	uint32_t count = 0;	/* ensure we don't get stuck in the loop forever */
+	sah_Execute_Status status;	/* Sahara's status register */
+	uint32_t stat_reg;
+
+	pr_debug("Entered sah_Wait_On_Sahara\n");
+
+	do {
+		/* get current status register from Sahara */
+		stat_reg = sah_HW_Read_Status();
+		status = stat_reg & SAH_EXEC_STATE_MASK;
+
+		/* timeout if SAHARA takes too long to complete */
+		if (++count == sah_poll_timeout) {
+			status = SAH_EXEC_FAULT;
+			printk("sah_Wait_On_Sahara timed out\n");
+		}
+
+		/* stay in loop as long as Sahara is still busy */
+	} while ((status == SAH_EXEC_BUSY) || (status == SAH_EXEC_DONE1_BUSY2));
+
+	if (status == SAH_EXEC_ERROR1) {
+		if (stat_reg & OP_STATUS) {
+			status = SAH_EXEC_OPSTAT1;
+		}
+	}
+
+	return status;
+}				/* sah_Wait_on_Sahara() */
+
+/*!
+ * This function resets the SAHARA hardware. The following operations are
+ * performed:
+ *   1. Resets SAHARA.
+ *   2. Requests BATCH mode.
+ *   3. Enables interrupts.
+ *   4. Requests Little Endian mode.
+ *
+ * @brief     SAHARA hardware reset function.
+ *
+ * @return   void
+ */
+int sah_HW_Reset(void)
+{
+	sah_Execute_Status sah_state;
+	int status;		/* this is the value to return to the calling routine */
+	uint32_t saha_control = 0;
+
+#ifndef USE_3WORD_BURST
+#ifdef FSL_HAVE_SAHARA2
+	saha_control |= (8 << 16);	/* Allow 8-word burst */
+#endif
+#else
+/***************** HARDWARE BUG WORK AROUND ******************/
+/* A burst size of > 4 can cause Sahara DMA to issue invalid AHB transactions
+ * when crossing 1KB boundaries.  By limiting the 'burst size' to 3, these
+ * invalid transactions will not be generated, but Sahara will still transfer
+ * data more efficiently than if the burst size were set to 1.
+ */
+	saha_control |= (3 << 16);	/* Limit DMA burst size. For versions 2/3 */
+#endif				/* USE_3WORD_BURST */
+
+#ifdef DIAG_DRV_IF
+	snprintf(Diag_msg, DIAG_MSG_SIZE,
+		 "Address of sah_virt_base = 0x%08x\n",
+		 sah_virt_base);
+	LOG_KDIAG(Diag_msg);
+	snprintf(Diag_msg, DIAG_MSG_SIZE,
+		 "Sahara Status register before reset: %08x",
+		 sah_HW_Read_Status());
+	LOG_KDIAG(Diag_msg);
+#endif
+
+	/* Write the Reset & BATCH mode command to the SAHARA Command register. */
+	sah_HW_Write_Command(CMD_BATCH | CMD_RESET);
+#ifdef SAHARA4_NO_USE_SQUIB
+	{
+		uint32_t cfg = sah_HW_Read_Config();
+		cfg &= ~0x10000;
+		sah_HW_Write_Config(cfg);
+	}
+#endif
+
+	sah_poll_timeout = 0x0FFFFFFF;
+	sah_state = sah_Wait_On_Sahara();
+#ifdef DIAG_DRV_IF
+	snprintf(Diag_msg, DIAG_MSG_SIZE,
+		 "Sahara Status register after reset: %08x",
+		 sah_HW_Read_Status());
+	LOG_KDIAG(Diag_msg);
+#endif
+	/* on reset completion, check that Sahara is in the idle state */
+	status = (sah_state == SAH_EXEC_IDLE) ? 0 : OS_ERROR_FAIL_S;
+
+	/* Set initial value out of reset */
+	sah_HW_Write_Control(saha_control);
+
+#ifndef NO_RESEED_WORKAROUND
+/***************** HARDWARE BUG WORK AROUND ******************/
+/* In order to set the 'auto reseed' bit, must first acquire a random value. */
+	/*
+	 * to solve a hardware bug, a random number must be generated before
+	 * the 'RNG Auto Reseed' bit can be set. So this generates a random
+	 * number that is thrown away.
+	 *
+	 * Note that the interrupt bit has not been set at this point so
+	 * the result can be polled.
+	 */
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG("Create and submit Random Number Descriptor");
+#endif
+
+	if (status == OS_ERROR_OK_S) {
+		/* place to put random number */
+		volatile uint32_t *random_data_ptr;
+		sah_Head_Desc *random_desc;
+		dma_addr_t desc_dma;
+		dma_addr_t rand_dma;
+		const int rnd_cnt = 3;	/* how many random 32-bit values to get */
+
+		/* Get space for data -- assume at least 32-bit aligned! */
+		random_data_ptr = os_alloc_memory(rnd_cnt * sizeof(uint32_t),
+						  GFP_ATOMIC);
+
+		random_desc = sah_Alloc_Head_Descriptor();
+
+		if ((random_data_ptr == NULL) || (random_desc == NULL)) {
+			status = OS_ERROR_FAIL_S;
+		} else {
+			int i;
+
+			/* Clear out values */
+			for (i = 0; i < rnd_cnt; i++) {
+				random_data_ptr[i] = 0;
+			}
+
+			rand_dma = os_pa(random_data_ptr);
+
+			random_desc->desc.header = 0xB18C0000;	/* LLO get random number */
+			random_desc->desc.len1 =
+			    rnd_cnt * sizeof(*random_data_ptr);
+			random_desc->desc.ptr1 = (void *)rand_dma;
+			random_desc->desc.original_ptr1 =
+			    (void *)random_data_ptr;
+
+			random_desc->desc.len2 = 0;	/* not used */
+			random_desc->desc.ptr2 = 0;	/* not used */
+
+			random_desc->desc.next = 0;	/* chain terminates here */
+			random_desc->desc.original_next = 0;	/* chain terminates here */
+
+			desc_dma = random_desc->desc.dma_addr;
+
+			/* Force in-cache data out to RAM */
+			os_cache_clean_range(random_data_ptr,
+					     rnd_cnt *
+					     sizeof(*random_data_ptr));
+
+			/* pass descriptor to Sahara */
+			sah_HW_Write_DAR(desc_dma);
+
+			/*
+			 * Wait for RNG to complete (interrupts are disabled at this point
+			 * due to sahara being reset previously) then check for error
+			 */
+			sah_state = sah_Wait_On_Sahara();
+			/* Force CPU to ignore in-cache and reload from RAM */
+			os_cache_inv_range(random_data_ptr,
+					   rnd_cnt * sizeof(*random_data_ptr));
+
+			/* if it didn't move to done state, an error occured */
+			if (
+#ifndef SUBMIT_MULTIPLE_DARS
+				   (sah_state != SAH_EXEC_IDLE) &&
+#endif
+				   (sah_state != SAH_EXEC_DONE1)
+			    ) {
+				status = OS_ERROR_FAIL_S;
+				os_printk
+				    ("(sahara) Failure: state is %08x; random_data is"
+				     " %08x\n", sah_state, *random_data_ptr);
+				os_printk
+				    ("(sahara) CDAR: %08x, IDAR: %08x, FADR: %08x,"
+				     " ESTAT: %08x\n", sah_HW_Read_CDAR(),
+				     sah_HW_Read_IDAR(),
+				     sah_HW_Read_Fault_Address(),
+				     sah_HW_Read_Error_Status());
+			} else {
+				int i;
+				int seen_rand = 0;
+
+				for (i = 0; i < rnd_cnt; i++) {
+					if (*random_data_ptr != 0) {
+						seen_rand = 1;
+						break;
+					}
+				}
+				if (!seen_rand) {
+					status = OS_ERROR_FAIL_S;
+					os_printk
+					    ("(sahara) Error:  Random number is zero!\n");
+				}
+			}
+		}
+
+		if (random_data_ptr) {
+			os_free_memory((void *)random_data_ptr);
+		}
+		if (random_desc) {
+			sah_Free_Head_Descriptor(random_desc);
+		}
+	}
+/***************** END HARDWARE BUG WORK AROUND ******************/
+#endif
+
+	if (status == 0) {
+#ifdef FSL_HAVE_SAHARA2
+		saha_control |= CTRL_RNG_RESEED;
+#endif
+
+#ifndef SAHARA_POLL_MODE
+		saha_control |= CTRL_INT_EN;	/* enable interrupts */
+#else
+		sah_poll_timeout = SAHARA_POLL_MODE_TIMEOUT;
+#endif
+
+#ifdef DIAG_DRV_IF
+		snprintf(Diag_msg, DIAG_MSG_SIZE,
+			 "Setting up Sahara's Control Register: %08x\n",
+			 saha_control);
+		LOG_KDIAG(Diag_msg);
+#endif
+
+		/* Rewrite the setup to the SAHARA Control register */
+		sah_HW_Write_Control(saha_control);
+#ifdef DIAG_DRV_IF
+		snprintf(Diag_msg, DIAG_MSG_SIZE,
+			 "Sahara Status register after control write: %08x",
+			 sah_HW_Read_Status());
+		LOG_KDIAG(Diag_msg);
+#endif
+
+#ifdef FSL_HAVE_SAHARA4
+		{
+			uint32_t cfg = sah_HW_Read_Config();
+			sah_HW_Write_Config(cfg | 0x100);	/* Add RNG auto-reseed */
+		}
+#endif
+	} else {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("Reset failed\n");
+#endif
+	}
+
+	return status;
+}				/* sah_HW_Reset() */
+
+/*!
+ * This function enables High Assurance mode.
+ *
+ * @brief     SAHARA hardware enable High Assurance mode.
+ *
+ * @return   FSL_RETURN_OK_S             - if HA was set successfully
+ * @return   FSL_RETURN_INTERNAL_ERROR_S - if HA was not set due to SAHARA
+ *                                         being busy.
+ */
+fsl_shw_return_t sah_HW_Set_HA(void)
+{
+	/* This is the value to write to the register */
+	uint32_t value;
+
+	/* Read from the control register. */
+	value = sah_HW_Read_Control();
+
+	/* Set the HA bit */
+	value |= CTRL_HA;
+
+	/* Write to the control register. */
+	sah_HW_Write_Control(value);
+
+	/* Read from the control register. */
+	value = sah_HW_Read_Control();
+
+	return (value & CTRL_HA) ? FSL_RETURN_OK_S :
+	    FSL_RETURN_INTERNAL_ERROR_S;
+}
+
+/*!
+ * This function reads the SAHARA hardware Version Register.
+ *
+ * @brief     Read SAHARA hardware Version Register.
+ *
+ * @return   uint32_t Register value.
+ */
+uint32_t sah_HW_Read_Version(void)
+{
+	return os_read32(sah_virt_base + SAHARA_VERSION_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Control Register.
+ *
+ * @brief     Read SAHARA hardware Control Register.
+ *
+ * @return   uint32_t Register value.
+ */
+uint32_t sah_HW_Read_Control(void)
+{
+	return os_read32(sah_virt_base + SAHARA_CONTROL_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Status Register.
+ *
+ * @brief     Read SAHARA hardware Status Register.
+ *
+ * @return   uint32_t Register value.
+ */
+uint32_t sah_HW_Read_Status(void)
+{
+	return os_read32(sah_virt_base + SAHARA_STATUS_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Error Status Register.
+ *
+ * @brief     Read SAHARA hardware Error Status Register.
+ *
+ * @return   uint32_t Error Status value.
+ */
+uint32_t sah_HW_Read_Error_Status(void)
+{
+	return os_read32(sah_virt_base + SAHARA_ESTATUS_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Op Status Register.
+ *
+ * @brief     Read SAHARA hardware Op Status Register.
+ *
+ * @return   uint32_t Op Status value.
+ */
+uint32_t sah_HW_Read_Op_Status(void)
+{
+	return os_read32(sah_virt_base + SAHARA_OSTATUS_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Descriptor Address Register.
+ *
+ * @brief     Read SAHARA hardware DAR Register.
+ *
+ * @return   uint32_t DAR value.
+ */
+uint32_t sah_HW_Read_DAR(void)
+{
+	return os_read32(sah_virt_base + SAHARA_DAR_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Current Descriptor Address Register.
+ *
+ * @brief     Read SAHARA hardware CDAR Register.
+ *
+ * @return   uint32_t CDAR value.
+ */
+uint32_t sah_HW_Read_CDAR(void)
+{
+	return os_read32(sah_virt_base + SAHARA_CDAR_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Initial Descriptor Address Register.
+ *
+ * @brief     Read SAHARA hardware IDAR Register.
+ *
+ * @return   uint32_t IDAR value.
+ */
+uint32_t sah_HW_Read_IDAR(void)
+{
+	return os_read32(sah_virt_base + SAHARA_IDAR_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Fault Address Register.
+ *
+ * @brief     Read SAHARA Fault Address Register.
+ *
+ * @return   uint32_t Fault Address value.
+ */
+uint32_t sah_HW_Read_Fault_Address(void)
+{
+	return os_read32(sah_virt_base + SAHARA_FLT_ADD_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Multiple Master Status Register.
+ *
+ * @brief     Read SAHARA hardware MM Stat Register.
+ *
+ * @return   uint32_t MM Stat value.
+ */
+uint32_t sah_HW_Read_MM_Status(void)
+{
+	return os_read32(sah_virt_base + SAHARA_MM_STAT_REGISTER_OFFSET);
+}
+
+/*!
+ * This function reads the SAHARA hardware Configuration Register.
+ *
+ * @brief     Read SAHARA Configuration Register.
+ *
+ * @return   uint32_t Configuration value.
+ */
+uint32_t sah_HW_Read_Config(void)
+{
+	return os_read32(sah_virt_base + SAHARA_CONFIG_REGISTER_OFFSET);
+}
+
+/*!
+ * This function writes a command to the SAHARA hardware Command Register.
+ *
+ * @brief     Write to SAHARA hardware Command Register.
+ *
+ * @param    command     An unsigned 32bit command value.
+ *
+ * @return   void
+ */
+void sah_HW_Write_Command(uint32_t command)
+{
+	os_write32(sah_virt_base + SAHARA_COMMAND_REGISTER_OFFSET, command);
+}
+
+/*!
+ * This function writes a control value to the SAHARA hardware Control
+ * Register.
+ *
+ * @brief     Write to SAHARA hardware Control Register.
+ *
+ * @param    control     An unsigned 32bit control value.
+ *
+ * @return   void
+ */
+void sah_HW_Write_Control(uint32_t control)
+{
+	os_write32(sah_virt_base + SAHARA_CONTROL_REGISTER_OFFSET, control);
+}
+
+/*!
+ * This function writes a configuration value to the SAHARA hardware Configuration
+ * Register.
+ *
+ * @brief     Write to SAHARA hardware Configuration Register.
+ *
+ * @param    configuration     An unsigned 32bit configuration value.
+ *
+ * @return   void
+ */
+void sah_HW_Write_Config(uint32_t configuration)
+{
+	os_write32(sah_virt_base + SAHARA_CONFIG_REGISTER_OFFSET,
+		configuration);
+}
+
+/*!
+ * This function writes a descriptor address to the SAHARA Descriptor Address
+ * Register.
+ *
+ * @brief     Write to SAHARA Descriptor Address Register.
+ *
+ * @param    pointer     An unsigned 32bit descriptor address value.
+ *
+ * @return   void
+ */
+void sah_HW_Write_DAR(uint32_t pointer)
+{
+	os_write32(sah_virt_base + SAHARA_DAR_REGISTER_OFFSET, pointer);
+	dar_count++;
+}
+
+#if defined DIAG_DRV_IF || defined DO_DBG
+
+static char *interpret_header(uint32_t header)
+{
+	unsigned desc_type = ((header >> 24) & 0x70) | ((header >> 16) & 0xF);
+
+	switch (desc_type) {
+	case 0x12:
+		return "5/SKHA_ST_CTX";
+	case 0x13:
+		return "35/SKHA_LD_MODE_KEY";
+	case 0x14:
+		return "38/SKHA_LD_MODE_IN_CPHR_ST_CTX";
+	case 0x15:
+		return "4/SKHA_IN_CPHR_OUT";
+	case 0x16:
+		return "34/SKHA_ST_SBOX";
+	case 0x18:
+		return "1/SKHA_LD_MODE_IV_KEY";
+	case 0x19:
+		return "33/SKHA_ST_SBOX";
+	case 0x1D:
+		return "2/SKHA_LD_MODE_IN_CPHR_OUT";
+	case 0x22:
+		return "11/MDHA_ST_MD";
+	case 0x25:
+		return "10/MDHA_HASH_ST_MD";
+	case 0x28:
+		return "6/MDHA_LD_MODE_MD_KEY";
+	case 0x2A:
+		return "39/MDHA_ICV";
+	case 0x2D:
+		return "8/MDHA_LD_MODE_HASH_ST_MD";
+	case 0x3C:
+		return "18/RNG_GEN";
+	case 0x40:
+		return "19/PKHA_LD_N_E";
+	case 0x41:
+		return "36/PKHA_LD_A3_B0";
+	case 0x42:
+		return "27/PKHA_ST_A_B";
+	case 0x43:
+		return "22/PKHA_LD_A_B";
+	case 0x44:
+		return "23/PKHA_LD_A0_A1";
+	case 0x45:
+		return "24/PKHA_LD_A2_A3";
+	case 0x46:
+		return "25/PKHA_LD_B0_B1";
+	case 0x47:
+		return "26/PKHA_LD_B2_B3";
+	case 0x48:
+		return "28/PKHA_ST_A0_A1";
+	case 0x49:
+		return "29/PKHA_ST_A2_A3";
+	case 0x4A:
+		return "30/PKHA_ST_B0_B1";
+	case 0x4B:
+		return "31/PKHA_ST_B2_B3";
+	case 0x4C:
+		return "32/PKHA_EX_ST_B1";
+	case 0x4D:
+		return "20/PKHA_LD_A_EX_ST_B";
+	case 0x4E:
+		return "21/PKHA_LD_N_EX_ST_B";
+	case 0x4F:
+		return "37/PKHA_ST_B1_B2";
+	default:
+		return "??/UNKNOWN";
+	}
+}				/* cvt_desc_name() */
+
+/*!
+ * Dump chain of descriptors to the log.
+ *
+ * @brief Dump descriptor chain
+ *
+ * @param    chain     Kernel virtual address of start of chain of descriptors
+ *
+ * @return   void
+ */
+void sah_Dump_Chain(const sah_Desc * chain, dma_addr_t addr)
+{
+	int desc_no = 1;
+
+	pr_debug("Chain for Sahara\n");
+
+	while (chain != NULL) {
+		char desc_name[50];
+
+		sprintf(desc_name, "Desc %02d (%s)\n" KERN_DEBUG "Desc  ",
+			desc_no++, interpret_header(chain->header));
+
+		sah_Dump_Words(desc_name, (unsigned *)chain, addr,
+			       6 /* #words in h/w link */ );
+		if (chain->original_ptr1) {
+			if (chain->header & SAH_HDR_LLO) {
+				sah_Dump_Region(" Data1",
+						(unsigned char *)chain->
+						original_ptr1,
+						(dma_addr_t) chain->ptr1,
+						chain->len1);
+			} else {
+				sah_Dump_Link(" Link1", chain->original_ptr1,
+					      (dma_addr_t) chain->ptr1);
+			}
+		}
+		if (chain->ptr2) {
+			if (chain->header & SAH_HDR_LLO) {
+				sah_Dump_Region(" Data2",
+						(unsigned char *)chain->
+						original_ptr2,
+						(dma_addr_t) chain->ptr2,
+						chain->len2);
+			} else {
+				sah_Dump_Link(" Link2", chain->original_ptr2,
+					      (dma_addr_t) chain->ptr2);
+			}
+		}
+
+		addr = (dma_addr_t) chain->next;
+		chain = (chain->next) ? (chain->original_next) : NULL;
+	}
+}
+
+/*!
+ * Dump chain of links to the log.
+ *
+ * @brief Dump chain of links
+ *
+ * @param    prefix    Text to put in front of dumped data
+ * @param    link      Kernel virtual address of start of chain of links
+ *
+ * @return   void
+ */
+static void sah_Dump_Link(const char *prefix, const sah_Link * link,
+			  dma_addr_t addr)
+{
+#ifdef DUMP_SCC_DATA
+	extern uint8_t *sahara_partition_base;
+	extern dma_addr_t sahara_partition_phys;
+#endif
+
+	while (link != NULL) {
+		sah_Dump_Words(prefix, (unsigned *)link, addr,
+			       3 /* # words in h/w link */ );
+		if (link->flags & SAH_STORED_KEY_INFO) {
+#ifdef SAH_DUMP_DATA
+#ifdef DUMP_SCC_DATA
+			sah_Dump_Region("  Data",
+					(uint8_t *) link->data -
+					(uint8_t *) sahara_partition_phys +
+					sahara_partition_base,
+					(dma_addr_t) link->data, link->len);
+#else
+			pr_debug("  Key Slot %d\n", link->slot);
+#endif
+#endif
+		} else {
+#ifdef SAH_DUMP_DATA
+			sah_Dump_Region("  Data", link->original_data,
+					(dma_addr_t) link->data, link->len);
+#endif
+		}
+		addr = (dma_addr_t) link->next;
+		link = link->original_next;
+	}
+}
+
+/*!
+ * Dump given region of data to the log.
+ *
+ * @brief Dump data
+ *
+ * @param    prefix    Text to put in front of dumped data
+ * @param    data      Kernel virtual address of start of region to dump
+ * @param    length    Amount of data to dump
+ *
+ * @return   void
+ */
+void sah_Dump_Region(const char *prefix, const unsigned char *data,
+		     dma_addr_t addr, unsigned length)
+{
+	unsigned count;
+	char *output;
+	unsigned data_len;
+
+	sprintf(Diag_msg, "%s (%08X,%u):", prefix, addr, length);
+
+	/* Restrict amount of data to dump */
+	if (length > MAX_DUMP) {
+		data_len = MAX_DUMP;
+	} else {
+		data_len = length;
+	}
+
+	/* We've already printed some text in output buffer, skip over it */
+	output = Diag_msg + strlen(Diag_msg);
+
+	for (count = 0; count < data_len; count++) {
+		if ((count % 4) == 0) {
+			*output++ = ' ';
+		}
+		sprintf(output, "%02X", *data++);
+		output += 2;
+	}
+
+	pr_debug("%s\n", Diag_msg);
+}
+
+/*!
+ * Dump given word of data to the log.
+ *
+ * @brief Dump data
+ *
+ * @param    prefix       Text to put in front of dumped data
+ * @param    data         Kernel virtual address of start of region to dump
+ * @param    word_count   Amount of data to dump
+ *
+ * @return   void
+ */
+void sah_Dump_Words(const char *prefix, const unsigned *data, dma_addr_t addr,
+		    unsigned word_count)
+{
+	char *output;
+
+	sprintf(Diag_msg, "%s (%08X,%uw): ", prefix, addr, word_count);
+
+	/* We've already printed some text in output buffer, skip over it */
+	output = Diag_msg + strlen(Diag_msg);
+
+	while (word_count--) {
+		sprintf(output, "%08X ", *data++);
+		output += 9;
+	}
+
+	pr_debug("%s\n", Diag_msg);
+
+}
+
+#endif				/* DIAG_DRV_IF */
+
+/* End of sah_hardware_interface.c */
diff --git a/drivers/mxc/security/sahara2/sah_interrupt_handler.c b/drivers/mxc/security/sahara2/sah_interrupt_handler.c
new file mode 100644
index 0000000..959c3d8
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_interrupt_handler.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sah_interrupt_handler.c
+*
+* @brief Provides a hardware interrupt handling mechanism for device driver.
+*
+* This file needs to be ported for a non-Linux OS.
+*
+* It gets a call at #sah_Intr_Init() during initialization.
+*
+* #sah_Intr_Top_Half() is intended to be the Interrupt Service Routine.  It
+* calls a portable function in another file to process the Sahara status.
+*
+* #sah_Intr_Bottom_Half() is a 'background' task scheduled by the top half to
+* take care of the expensive tasks of the interrupt processing.
+*
+* The driver shutdown code calls #sah_Intr_Release().
+*
+*/
+
+#include <portable_os.h>
+
+/* SAHARA Includes */
+#include <sah_kernel.h>
+#include <sah_interrupt_handler.h>
+#include <sah_status_manager.h>
+#include <sah_hardware_interface.h>
+#include <sah_queue_manager.h>
+
+/*Enable this flag for debugging*/
+#if 0
+#define DIAG_DRV_INTERRUPT
+#endif
+
+#ifdef DIAG_DRV_INTERRUPT
+#include <diagnostic.h>
+#endif
+
+/*!
+ * Number of interrupts received.  This value should only be updated during
+ * interrupt processing.
+ */
+uint32_t interrupt_count;
+
+#ifndef SAHARA_POLL_MODE
+
+#if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define irqreturn_t void
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+
+/* Internal Prototypes */
+static irqreturn_t sah_Intr_Top_Half(int irq, void *dev_id);
+
+#ifdef KERNEL_TEST
+extern void (*SAHARA_INT_PTR) (int, void *);
+#endif
+
+unsigned long reset_flag;
+static void sah_Intr_Bottom_Half(unsigned long reset_flag);
+
+/* This is the Bottom Half Task, (reset flag set to false) */
+DECLARE_TASKLET(BH_task, sah_Intr_Bottom_Half, (unsigned long)&reset_flag);
+
+/*! This is set by the Initialisation function */
+wait_queue_head_t *int_queue = NULL;
+
+/*!
+*******************************************************************************
+* This function registers the Top Half of the interrupt handler with the Kernel
+* and the SAHARA IRQ number.
+*
+* @brief     SAHARA Interrupt Handler Initialisation
+*
+* @param    wait_queue Pointer to the wait queue used by driver interface
+*
+* @return   int A return of Zero indicates successful initialisation.
+*/
+/******************************************************************************
+*
+* CAUTION: NONE
+*
+* MODIFICATION HISTORY:
+*
+* Date         Person     Change
+* 30/07/2003   MW         Initial Creation
+******************************************************************************/
+int sah_Intr_Init(wait_queue_head_t * wait_queue)
+{
+
+#ifdef DIAG_DRV_INTERRUPT
+	char err_string[200];
+#endif
+
+	int result;
+
+#ifdef KERNEL_TEST
+	SAHARA_INT_PTR = sah_Intr_Top_Half;
+#endif
+
+	/* Set queue used by the interrupt handler to match the driver interface */
+	int_queue = wait_queue;
+
+	/* Request use of the Interrupt line. */
+	result = request_irq(SAHARA_IRQ,
+			     sah_Intr_Top_Half, 0, SAHARA_NAME, NULL);
+
+#ifdef DIAG_DRV_INTERRUPT
+	if (result != 0) {
+		sprintf(err_string, "Cannot use SAHARA interrupt line %d. "
+			"request_irq() return code is %i.", SAHARA_IRQ, result);
+		LOG_KDIAG(err_string);
+	} else {
+		sprintf(err_string,
+			"SAHARA driver registered for interrupt %d. ",
+			SAHARA_IRQ);
+		LOG_KDIAG(err_string);
+	}
+#endif
+
+	return result;
+}
+
+/*!
+*******************************************************************************
+* This function releases the Top Half of the interrupt handler. The driver will
+* not receive any more interrupts after calling this functions.
+*
+* @brief     SAHARA Interrupt Handler Release
+*
+* @return   void
+*/
+/******************************************************************************
+*
+* CAUTION: NONE
+*
+* MODIFICATION HISTORY:
+*
+* Date         Person     Change
+* 30/07/2003   MW         Initial Creation
+******************************************************************************/
+void sah_Intr_Release(void)
+{
+	/* Release the Interrupt. */
+	free_irq(SAHARA_IRQ, NULL);
+}
+
+/*!
+*******************************************************************************
+* This function is the Top Half of the interrupt handler.  It updates the
+* status of any finished descriptor chains and then tries to add any pending
+* requests into the hardware.  It then queues the bottom half to complete
+* operations on the finished chains.
+*
+* @brief     SAHARA Interrupt Handler Top Half
+*
+* @param    irq     Part of the kernel prototype.
+* @param    dev_id  Part of the kernel prototype.
+*
+* @return   An IRQ_RETVAL() -- non-zero to that function means 'handled'
+*/
+static irqreturn_t sah_Intr_Top_Half(int irq, void *dev_id)
+{
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+	LOG_KDIAG("Top half of Sahara's interrupt handler called.");
+#endif
+
+	interrupt_count++;
+	reset_flag = sah_Handle_Interrupt(sah_HW_Read_Status());
+
+	/* Schedule the Bottom Half of the Interrupt. */
+	tasklet_schedule(&BH_task);
+
+	/* To get rid of the unused parameter warnings. */
+	irq = 0;
+	dev_id = NULL;
+	return IRQ_RETVAL(1);
+}
+
+/*!
+*******************************************************************************
+* This function is the Bottom Half of the interrupt handler.  It calls
+* #sah_postprocess_queue() to complete the processing of the Descriptor Chains
+* which were finished by the hardware.
+*
+* @brief     SAHARA Interrupt Handler Bottom Half
+*
+* @param    data   Part of the kernel prototype.
+*
+* @return   void
+*/
+static void sah_Intr_Bottom_Half(unsigned long reset_flag)
+{
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+	LOG_KDIAG("Bottom half of Sahara's interrupt handler called.");
+#endif
+	sah_postprocess_queue(*(unsigned long *)reset_flag);
+
+	return;
+}
+
+/* end of sah_interrupt_handler.c */
+#endif				/* ifndef SAHARA_POLL_MODE */
diff --git a/drivers/mxc/security/sahara2/sah_memory_mapper.c b/drivers/mxc/security/sahara2/sah_memory_mapper.c
new file mode 100644
index 0000000..f863b03
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_memory_mapper.c
@@ -0,0 +1,2367 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sah_memory_mapper.c
+*
+* @brief Re-creates SAHARA data structures in Kernel memory such that they are
+*       suitable for DMA.  Provides support for kernel API.
+*
+* This file needs to be ported.
+*
+* The memory mapper gets a call at #sah_Init_Mem_Map() during driver
+* initialization.
+*
+* The routine #sah_Copy_Descriptors() is used to bring descriptor chains from
+* user memory down to kernel memory, relink using physical addresses, and make
+* sure that all user data will be accessible by the Sahara DMA.
+* #sah_Destroy_Descriptors() does the inverse.
+*
+* The #sah_Alloc_Block(), #sah_Free_Block(), and #sah_Block_Add_Page() routines
+* implement a cache of free blocks used when allocating descriptors and links
+* within the kernel.
+*
+* The memory mapper gets a call at #sah_Stop_Mem_Map() during driver shutdown.
+*
+*/
+
+#include <sah_driver_common.h>
+#include <sah_kernel.h>
+#include <sah_queue_manager.h>
+#include <sah_memory_mapper.h>
+#ifdef FSL_HAVE_SCC2
+#include <linux/mxc_scc2_driver.h>
+#else
+#include <linux/mxc_scc_driver.h>
+#endif
+
+#if defined(DIAG_DRV_IF) || defined(DIAG_MEM) || defined(DO_DBG)
+#include <diagnostic.h>
+#include <sah_hardware_interface.h>
+#endif
+
+#include <linux/mm.h>		/* get_user_pages() */
+#include <linux/pagemap.h>
+#include <linux/dmapool.h>
+
+#include <linux/slab.h>
+#include <linux/highmem.h>
+
+#if defined(DIAG_MEM) || defined(DIAG_DRV_IF)
+#define DIAG_MSG_SIZE   1024
+static char Diag_msg[DIAG_MSG_SIZE];
+#endif
+
+#ifdef LINUX_VERSION_CODE
+#define FLUSH_SPECIFIC_DATA_ONLY
+#else
+#define SELF_MANAGED_POOL
+#endif
+
+#if defined(LINUX_VERSION_CODE)
+EXPORT_SYMBOL(sah_Alloc_Link);
+EXPORT_SYMBOL(sah_Free_Link);
+EXPORT_SYMBOL(sah_Alloc_Descriptor);
+EXPORT_SYMBOL(sah_Free_Descriptor);
+EXPORT_SYMBOL(sah_Alloc_Head_Descriptor);
+EXPORT_SYMBOL(sah_Free_Head_Descriptor);
+EXPORT_SYMBOL(sah_Physicalise_Descriptors);
+EXPORT_SYMBOL(sah_DePhysicalise_Descriptors);
+#endif
+
+/* Determine if L2 cache support should be built in. */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21))
+#ifdef CONFIG_OUTER_CACHE
+#define HAS_L2_CACHE
+#endif
+#else
+#ifdef CONFIG_CPU_CACHE_L210
+#define HAS_L2_CACHE
+#endif
+#endif
+
+/* Number of bytes the hardware uses out of sah_Link and sah_*Desc structs */
+#define SAH_HW_LINK_LEN  1
+#define SAH_HW_DESC_LEN  24
+
+/* Macros for Descriptors */
+#define SAH_LLO_BIT 0x01000000
+#define sah_Desc_Get_LLO(desc)          (desc->header & SAH_LLO_BIT)
+#define sah_Desc_Set_Header(desc, h)    (desc->header = (h))
+
+#define sah_Desc_Get_Next(desc)     (desc->next)
+#define sah_Desc_Set_Next(desc, n)  (desc->next = (n))
+
+#define sah_Desc_Get_Ptr1(desc)     (desc->ptr1)
+#define sah_Desc_Get_Ptr2(desc)     (desc->ptr2)
+#define sah_Desc_Set_Ptr1(desc,p1)  (desc->ptr1 = (p1))
+#define sah_Desc_Set_Ptr2(desc,p2)  (desc->ptr2 = (p2))
+
+#define sah_Desc_Get_Len1(desc)     (desc->len1)
+#define sah_Desc_Get_Len2(desc)     (desc->len2)
+#define sah_Desc_Set_Len1(desc,l1)  (desc->len1 = (l1))
+#define sah_Desc_Set_Len2(desc,l2)  (desc->len2 = (l2))
+
+/* Macros for Links */
+#define sah_Link_Get_Next(link)     (link->next)
+#define sah_Link_Set_Next(link, n)  (link->next = (n))
+
+#define sah_Link_Get_Data(link)     (link->data)
+#define sah_Link_Set_Data(link,d)   (link->data = (d))
+
+#define sah_Link_Get_Len(link)      (link->len)
+#define sah_Link_Set_Len(link, l)   (link->len = (l))
+
+#define sah_Link_Get_Flags(link)    (link->flags)
+
+/* Memory block defines */
+/* Warning!  This assumes that kernel version of sah_Link
+ * is larger than kernel version of sah_Desc.
+ */
+#define MEM_BLOCK_SIZE sizeof(sah_Link)
+
+/*! Structure for  link/descriptor memory blocks in internal pool */
+typedef struct mem_block {
+	uint8_t data[MEM_BLOCK_SIZE];	/*!< the actual buffer area  */
+	struct mem_block *next;	/*!< next block when in free chain */
+	dma_addr_t dma_addr;	/*!< physical address of @a data  */
+} Mem_Block;
+
+#define MEM_BLOCK_ENTRIES  (PAGE_SIZE / sizeof(Mem_Block))
+
+#define MEM_BIG_BLOCK_SIZE     sizeof(sah_Head_Desc)
+
+/*! Structure for head descriptor memory blocks in internal pool */
+typedef struct mem_big_block {
+	uint8_t data[MEM_BIG_BLOCK_SIZE];	/*!< the actual buffer area  */
+	struct mem_big_block *next;	/*!< next block when in free chain */
+	uint32_t dma_addr;	/*!< physical address of @a data  */
+} Mem_Big_Block;
+
+#define MEM_BIG_BLOCK_ENTRIES  (PAGE_SIZE / sizeof(Mem_Big_Block))
+
+/* Shared variables */
+
+/*!
+ * Lock to protect the memory chain composed of #block_free_head and
+ * #block_free_tail.
+ */
+static os_lock_t mem_lock;
+
+#ifndef SELF_MANAGED_POOL
+static struct dma_pool *big_dma_pool = NULL;
+static struct dma_pool *small_dma_pool = NULL;
+#endif
+
+#ifdef SELF_MANAGED_POOL
+/*!
+ * Memory block free pool - pointer to first block.  Chain is protected by
+ * #mem_lock.
+ */
+static Mem_Block *block_free_head = NULL;
+/*!
+ * Memory block free pool - pointer to last block.  Chain is protected by
+ * #mem_lock.
+ */
+static Mem_Block *block_free_tail = NULL;
+/*!
+ * Memory block free pool - pointer to first block.  Chain is protected by
+ * #mem_lock.
+ */
+static Mem_Big_Block *big_block_free_head = NULL;
+/*!
+ * Memory block free pool - pointer to last block.  Chain is protected by
+ * #mem_lock.
+a */
+static Mem_Big_Block *big_block_free_tail = NULL;
+#endif				/* SELF_MANAGED_POOL */
+
+static Mem_Block *sah_Alloc_Block(void);
+static void sah_Free_Block(Mem_Block * block);
+static Mem_Big_Block *sah_Alloc_Big_Block(void);
+static void sah_Free_Big_Block(Mem_Big_Block * block);
+#ifdef SELF_MANAGED_POOL
+static void sah_Append_Block(Mem_Block * block);
+static void sah_Append_Big_Block(Mem_Big_Block * block);
+#endif				/* SELF_MANAGED_POOL */
+
+/* Page context structure.  Used by wire_user_memory and unwire_user_memory */
+typedef struct page_ctx_t {
+	uint32_t count;
+	struct page **local_pages;
+} page_ctx_t;
+
+/*!
+*******************************************************************************
+* Map and wire down a region of user memory.
+*
+*
+* @param    address     Userspace address of the memory to wire
+* @param    length      Length of the memory region to wire
+* @param    page_ctx    Page context, to be passed to unwire_user_memory
+*
+* @return   (if successful) Kernel virtual address of the wired pages
+*/
+void *wire_user_memory(void *address, uint32_t length, void **page_ctx)
+{
+	void *kernel_black_addr = NULL;
+	int result = -1;
+	int page_index = 0;
+	page_ctx_t *page_context;
+	int nr_pages = 0;
+	unsigned long start_page;
+	fsl_shw_return_t status;
+
+	/* Determine the number of pages being used for this link */
+	nr_pages = (((unsigned long)(address) & ~PAGE_MASK)
+		    + length + ~PAGE_MASK) >> PAGE_SHIFT;
+
+	start_page = (unsigned long)(address) & PAGE_MASK;
+
+	/* Allocate some memory to keep track of the wired user pages, so that
+	 * they can be deallocated later.  The block of memory will contain both
+	 * the structure and the array of pages.
+	 */
+	page_context = kmalloc(sizeof(page_ctx_t)
+			       + nr_pages * sizeof(struct page *), GFP_KERNEL);
+
+	if (page_context == NULL) {
+		status = FSL_RETURN_NO_RESOURCE_S;	/* no memory! */
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("kmalloc() failed.");
+#endif
+		return NULL;
+	}
+
+	/* Set the page pointer to point to the allocated region of memory */
+	page_context->local_pages = (void *)page_context + sizeof(page_ctx_t);
+
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG_ARGS("page_context at: %p, local_pages at: %p",
+		       (void *)page_context,
+		       (void *)(page_context->local_pages));
+#endif
+
+	/* Wire down the pages from user space */
+	down_read(&current->mm->mmap_sem);
+	result = get_user_pages(current, current->mm,
+				start_page, nr_pages, WRITE, 0 /* noforce */ ,
+				(page_context->local_pages), NULL);
+	up_read(&current->mm->mmap_sem);
+
+	if (result < nr_pages) {
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("get_user_pages() failed.");
+#endif
+		if (result > 0) {
+			for (page_index = 0; page_index < result; page_index++) {
+				page_cache_release((page_context->
+						    local_pages[page_index]));
+			}
+
+			kfree(page_context);
+		}
+		return NULL;
+	}
+
+	kernel_black_addr = page_address(page_context->local_pages[0]) +
+	    ((unsigned long)address & ~PAGE_MASK);
+
+	page_context->count = nr_pages;
+	*page_ctx = page_context;
+
+	return kernel_black_addr;
+}
+
+/*!
+*******************************************************************************
+* Release and unmap a region of user memory.
+*
+* @param    page_ctx    Page context from wire_user_memory
+*/
+void unwire_user_memory(void **page_ctx)
+{
+	int page_index = 0;
+	struct page_ctx_t *page_context = *page_ctx;
+
+#ifdef DIAG_DRV_IF
+	LOG_KDIAG_ARGS("page_context at: %p, first page at:%p, count: %i",
+		       (void *)page_context,
+		       (void *)(page_context->local_pages),
+		       page_context->count);
+#endif
+
+	if ((page_context != NULL) && (page_context->local_pages != NULL)) {
+		for (page_index = 0; page_index < page_context->count;
+		     page_index++) {
+			page_cache_release(page_context->
+					   local_pages[page_index]);
+		}
+
+		kfree(page_context);
+		*page_ctx = NULL;
+	}
+}
+
+/*!
+*******************************************************************************
+* Map some physical memory into a users memory space
+*
+* @param    vma             Memory structure to map to
+* @param    physical_addr   Physical address of the memory to be mapped in
+* @param    size            Size of the memory to map (bytes)
+*
+* @return
+*/
+os_error_code
+map_user_memory(struct vm_area_struct *vma, uint32_t physical_addr,
+		uint32_t size)
+{
+	os_error_code retval;
+
+	/* Map the acquired partition into the user's memory space */
+	vma->vm_end = vma->vm_start + size;
+
+	/* set cache policy to uncached so that each write of the UMID and
+	 * permissions get directly to the SCC2 in order to engage it
+	 * properly.  Once the permissions have been written, it may be
+	 * useful to provide a service for the user to request a different
+	 * cache policy
+	 */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	/* Make sure that the user cannot fork() a child which will inherit
+	 * this mapping, as it creates a security hole.  Likewise, do not
+	 * allow the user to 'expand' his mapping beyond this partition.
+	 */
+	vma->vm_flags |= VM_IO | VM_RESERVED | VM_DONTCOPY | VM_DONTEXPAND;
+
+	retval = remap_pfn_range(vma,
+				 vma->vm_start,
+				 __phys_to_pfn(physical_addr),
+				 size, vma->vm_page_prot);
+
+	return retval;
+}
+
+/*!
+*******************************************************************************
+* Remove some memory from a user's memory space
+*
+* @param    user_addr       Userspace address of the memory to be unmapped
+* @param    size            Size of the memory to map (bytes)
+*
+* @return
+*/
+os_error_code unmap_user_memory(uint32_t user_addr, uint32_t size)
+{
+	os_error_code retval;
+	struct mm_struct *mm = current->mm;
+
+	/* Unmap the memory region (see sys_munmap in mmap.c) */
+	down_write(&mm->mmap_sem);
+	retval = do_munmap(mm, (unsigned long)user_addr, size);
+	up_write(&mm->mmap_sem);
+
+	return retval;
+}
+
+/*!
+*******************************************************************************
+* Free descriptor back to free pool
+*
+* @brief Free descriptor
+*
+* @param    desc        A descriptor allocated with sah_Alloc_Descriptor().
+*
+* @return none
+*
+*/
+void sah_Free_Descriptor(sah_Desc * desc)
+{
+	memset(desc, 0x45, sizeof(*desc));
+	sah_Free_Block((Mem_Block *) desc);
+}
+
+/*!
+*******************************************************************************
+* Free Head descriptor back to free pool
+*
+* @brief Free Head descriptor
+*
+* @param    desc  A Head descriptor allocated with sah_Alloc_Head_Descriptor().
+*
+* @return none
+*
+*/
+void sah_Free_Head_Descriptor(sah_Head_Desc * desc)
+{
+	memset(desc, 0x43, sizeof(*desc));
+	sah_Free_Big_Block((Mem_Big_Block *) desc);
+}
+
+/*!
+*******************************************************************************
+* Free link back to free pool
+*
+* @brief Free link
+*
+* @param    link        A link allocated with sah_Alloc_Link().
+*
+* @return none
+*
+*/
+void sah_Free_Link(sah_Link * link)
+{
+	memset(link, 0x41, sizeof(*link));
+	sah_Free_Block((Mem_Block *) link);
+}
+
+/*!
+*******************************************************************************
+* This function runs through a descriptor chain pointed to by a user-space
+* address. It duplicates each descriptor in Kernel space memory and calls
+* sah_Copy_Links() to handle any links attached to the descriptors. This
+* function cleans-up everything that it created in the case of a failure.
+*
+* @brief Kernel Descriptor Chain Copier
+*
+* @param    fsl_shw_uco_t  The user context to act under
+* @param    user_head_desc A Head Descriptor pointer from user-space.
+*
+* @return   sah_Head_Desc *  - A virtual address of the first descriptor in the
+*                              chain.
+* @return   NULL        - If there was some error.
+*
+*/
+sah_Head_Desc *sah_Copy_Descriptors(fsl_shw_uco_t * user_ctx,
+				sah_Head_Desc * user_head_desc)
+{
+	sah_Desc *curr_desc = NULL;
+	sah_Desc *prev_desc = NULL;
+	sah_Desc *next_desc = NULL;
+	sah_Head_Desc *head_desc = NULL;
+	sah_Desc *user_desc = NULL;
+	unsigned long result;
+
+	/* Internal status variable to be used in this function */
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+	sah_Head_Desc *ret_val = NULL;
+
+	/* This will be set to True when we have finished processing our
+	 * descriptor chain.
+	 */
+	int drv_if_done = FALSE;
+	int is_this_the_head = TRUE;
+
+	do {
+		/* Allocate memory for this descriptor */
+		if (is_this_the_head) {
+			head_desc =
+			    (sah_Head_Desc *) sah_Alloc_Head_Descriptor();
+
+#ifdef DIAG_MEM
+			sprintf(Diag_msg,
+				"Alloc_Head_Descriptor returned %p\n",
+				head_desc);
+			LOG_KDIAG(Diag_msg);
+#endif
+			if (head_desc == NULL) {
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG
+				    ("sah_Alloc_Head_Descriptor() failed.");
+#endif
+				drv_if_done = TRUE;
+				status = FSL_RETURN_NO_RESOURCE_S;
+			} else {
+				void *virt_addr = head_desc->desc.virt_addr;
+				dma_addr_t dma_addr = head_desc->desc.dma_addr;
+
+				/* Copy the head descriptor from user-space */
+				/* Instead of copying the whole structure,
+				 * unneeded bits at the end are left off.
+				 * The user space version is missing virt/dma addrs, which
+				 * means that the copy will be off for flags... */
+				result = copy_from_user(head_desc,
+							user_head_desc,
+							(sizeof(*head_desc) -
+							 sizeof(head_desc->desc.
+								dma_addr) -
+							 sizeof(head_desc->desc.
+								virt_addr) -
+							 sizeof(head_desc->desc.
+								original_ptr1) -
+/*                                sizeof(head_desc->desc.original_ptr2) -
+                                sizeof(head_desc->status) -
+                                sizeof(head_desc->error_status) -
+                                sizeof(head_desc->fault_address) -
+                                sizeof(head_desc->current_dar) -
+                                sizeof(head_desc->result) -
+                                sizeof(head_desc->next) -
+                                sizeof(head_desc->prev) -
+                                sizeof(head_desc->user_desc) -
+*/ sizeof(head_desc->out1_ptr) -
+							 sizeof(head_desc->
+								out2_ptr) -
+							 sizeof(head_desc->
+								out_len)));
+				/* there really isn't a 'next' descriptor at this point, so
+				 * set that pointer to NULL, but remember it for if/when there
+				 * is a next */
+				next_desc = head_desc->desc.next;
+				head_desc->desc.next = NULL;
+
+				if (result != 0) {
+#ifdef DIAG_DRV_IF
+					LOG_KDIAG("copy_from_user() failed.");
+#endif
+					drv_if_done = TRUE;
+					status = FSL_RETURN_INTERNAL_ERROR_S;
+					/* when destroying the descriptor, skip these links.
+					 * They've not been copied down, so don't exist */
+					head_desc->desc.ptr1 = NULL;
+					head_desc->desc.ptr2 = NULL;
+
+				} else {
+					/* The kernel DESC has five more words than user DESC, so
+					 * the missing values are in the middle of the HEAD DESC,
+					 * causing values after the missing ones to be at different
+					 * offsets in kernel and user space.
+					 *
+					 * Patch up the problem by moving field two spots.
+					 * This assumes sizeof(pointer) == sizeof(uint32_t).
+					 * Note that 'user_info' is not needed, so not copied.
+					 */
+					head_desc->user_ref =
+					    (uint32_t) head_desc->desc.dma_addr;
+					head_desc->uco_flags =
+					    (uint32_t) head_desc->desc.
+					    original_ptr1;
+#ifdef DIAG_DRV_IF
+					LOG_KDIAG_ARGS(
+						"User flags: %x; User Reference: %x",
+						head_desc->uco_flags,
+						head_desc->user_ref);
+#endif
+					/* These values were destroyed by the copy. */
+					head_desc->desc.virt_addr = virt_addr;
+					head_desc->desc.dma_addr = dma_addr;
+
+					/* ensure that the save descriptor chain bit is not set.
+					 * the copy of the user space descriptor chain should
+					 * always be deleted */
+					head_desc->uco_flags &=
+					    ~FSL_UCO_SAVE_DESC_CHAIN;
+
+					curr_desc = (sah_Desc *) head_desc;
+					is_this_the_head = FALSE;
+				}
+			}
+		} else {	/* not head */
+			curr_desc = sah_Alloc_Descriptor();
+#ifdef DIAG_MEM
+			LOG_KDIAG_ARGS("Alloc_Descriptor returned %p\n",
+				curr_desc);
+#endif
+			if (curr_desc == NULL) {
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("sah_Alloc_Descriptor() failed.");
+#endif
+				drv_if_done = TRUE;
+				status = FSL_RETURN_NO_RESOURCE_S;
+			} else {
+				/* need to update the previous descriptors' next field to
+				 * pointer to the current descriptor. */
+				prev_desc->original_next = curr_desc;
+				prev_desc->next =
+				    (sah_Desc *) curr_desc->dma_addr;
+
+				/* Copy the current descriptor from user-space */
+				/* The virtual address and DMA address part of the sah_Desc
+				 * struct are not copied to user space */
+				result = copy_from_user(curr_desc, user_desc, (sizeof(sah_Desc) - sizeof(dma_addr_t) -	/* dma_addr */
+									       sizeof(uint32_t) -	/* virt_addr */
+									       sizeof(void *) -	/* original_ptr1 */
+									       sizeof(void *) -	/* original_ptr2 */
+									       sizeof(sah_Desc **)));	/* original_next */
+				/* there really isn't a 'next' descriptor at this point, so
+				 * set that pointer to NULL, but remember it for if/when there
+				 * is a next */
+				next_desc = curr_desc->next;
+				curr_desc->next = NULL;
+				curr_desc->original_next = NULL;
+
+				if (result != 0) {
+#ifdef DIAG_DRV_IF
+					LOG_KDIAG("copy_from_user() failed.");
+#endif
+					drv_if_done = TRUE;
+					status = FSL_RETURN_INTERNAL_ERROR_S;
+					/* when destroying the descriptor chain, skip these links.
+					 * They've not been copied down, so don't exist */
+					curr_desc->ptr1 = NULL;
+					curr_desc->ptr2 = NULL;
+				}
+			}
+		}		/* end if (is_this_the_head) */
+
+		if (status == FSL_RETURN_OK_S) {
+			if (!(curr_desc->header & SAH_LLO_BIT)) {
+				/* One or both pointer fields being NULL is a valid
+				 * configuration. */
+				if (curr_desc->ptr1 == NULL) {
+					curr_desc->original_ptr1 = NULL;
+				} else {
+					/* pointer fields point to sah_Link structures */
+					curr_desc->original_ptr1 =
+					    sah_Copy_Links(user_ctx, curr_desc->ptr1);
+					if (curr_desc->original_ptr1 == NULL) {
+						/* This descriptor and any links created successfully
+						 * are cleaned-up at the bottom of this function. */
+						drv_if_done = TRUE;
+						status =
+						    FSL_RETURN_INTERNAL_ERROR_S;
+						/* mark that link 2 doesn't exist */
+						curr_desc->ptr2 = NULL;
+#ifdef DIAG_DRV_IF
+						LOG_KDIAG
+						    ("sah_Copy_Links() failed.");
+#endif
+					} else {
+						curr_desc->ptr1 = (void *)
+						    ((sah_Link *) curr_desc->
+						     original_ptr1)->dma_addr;
+					}
+				}
+
+				if (status == FSL_RETURN_OK_S) {
+					if (curr_desc->ptr2 == NULL) {
+						curr_desc->original_ptr2 = NULL;
+					} else {
+						/* pointer fields point to sah_Link structures */
+						curr_desc->original_ptr2 =
+						    sah_Copy_Links(user_ctx, curr_desc->ptr2);
+						if (curr_desc->original_ptr2 ==
+						    NULL) {
+							/* This descriptor and any links created
+							 * successfully are cleaned-up at the bottom of
+							 * this function. */
+							drv_if_done = TRUE;
+							status =
+							    FSL_RETURN_INTERNAL_ERROR_S;
+#ifdef DIAG_DRV_IF
+							LOG_KDIAG
+							    ("sah_Copy_Links() failed.");
+#endif
+						} else {
+							curr_desc->ptr2 =
+							    (void
+							     *)(((sah_Link *)
+								 curr_desc->
+								 original_ptr2)
+								->dma_addr);
+						}
+					}
+				}
+			} else {
+				/* Pointer fields point directly to user buffers. We don't
+				 * support this mode.
+				 */
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG
+				    ("The LLO bit in the Descriptor Header field was "
+				     "set. This an invalid configuration.");
+#endif
+				drv_if_done = TRUE;
+				status = FSL_RETURN_INTERNAL_ERROR_S;
+			}
+		}
+
+		if (status == FSL_RETURN_OK_S) {
+			user_desc = next_desc;
+			prev_desc = curr_desc;
+			if (user_desc == NULL) {
+				/* We have reached the end our our descriptor chain */
+				drv_if_done = TRUE;
+			}
+		}
+
+	} while (drv_if_done == FALSE);
+
+	if (status != FSL_RETURN_OK_S) {
+		/* Clean-up if failed */
+		if (head_desc != NULL) {
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("Error!  Calling destroy descriptors!\n");
+#endif
+			sah_Destroy_Descriptors(head_desc);
+		}
+		ret_val = NULL;
+	} else {
+		/* Flush the caches */
+#ifndef FLUSH_SPECIFIC_DATA_ONLY
+		os_flush_cache_all();
+#endif
+
+		/* Success. Return the DMA'able head descriptor. */
+		ret_val = head_desc;
+
+	}
+
+	return ret_val;
+}				/* sah_Copy_Descriptors() */
+
+/*!
+*******************************************************************************
+* This function runs through a sah_Link chain pointed to by a kernel-space
+* address.  It computes the physical address for each pointer, and converts
+* the chain to use these physical addresses.
+*
+******
+*   This function needs to return some indication that the chain could not be
+*   converted.  It also needs to back out any conversion already taken place on
+*   this chain of links.
+*
+*   Then, of course, sah_Physicalise_Descriptors() will need to recognize that
+*   an error occured, and then be able to back out any physicalization of the
+*   chain which had taken place up to that point!
+******
+*
+* @brief Convert kernel Link chain
+*
+* @param    first_link   A sah_Link pointer from kernel space; must not be
+*                        NULL, so error case can be distinguished.
+*
+* @return   sah_Link *   A dma'able address of the first descriptor in the
+*                         chain.
+* @return   NULL         If Link chain could not be physicalised, i.e. ERROR
+*
+*/
+sah_Link *sah_Physicalise_Links(sah_Link * first_link)
+{
+	sah_Link *link = first_link;
+	struct page *pg;
+
+	while (link != NULL) {
+#ifdef DO_DBG
+		sah_Dump_Words("Link", (unsigned *)link, link->dma_addr, 3);
+#endif
+		link->vm_info = NULL;
+
+		/* need to retrieve stored key? */
+		if (link->flags & SAH_STORED_KEY_INFO) {
+			uint32_t max_len = 0;	/* max slot length */
+			fsl_shw_return_t ret_status;
+
+			/* get length and physical address of stored key */
+			ret_status = system_keystore_get_slot_info(link->ownerid, link->slot, (uint32_t *) & link->data,	/* RED key address */
+						       &max_len);
+			if ((ret_status != FSL_RETURN_OK_S) || (link->len > max_len)) {
+				/* trying to illegally/incorrectly access a key. Cause the
+				 * error status register to show a Link Length Error by
+				 * putting a zero in the links length. */
+				link->len = 0;	/* Cause error.  Somebody is up to no good. */
+			}
+		} else if (link->flags & SAH_IN_USER_KEYSTORE) {
+
+#ifdef FSL_HAVE_SCC2
+			/* The data field points to the virtual address of the key.  Convert
+			 * this to a physical address by modifying the address based
+			 * on where the secure memory was mapped to the kernel.  Note: In
+			 * kernel mode, no attempt is made to track or control who owns what
+			 * memory partition.
+			 */
+			link->data = (uint8_t *) scc_virt_to_phys(link->data);
+
+			/* Do bounds checking to ensure that the user is not overstepping
+			 * the bounds of their partition.  This is a simple implementation
+			 * that assumes the user only owns one partition.  It only checks
+			 * to see if the address of the last byte of data steps over a
+			 * page boundary.
+			 */
+
+#ifdef DO_DBG
+			LOG_KDIAG_ARGS("start page: %08x, end page: %08x"
+				       "first addr: %p, last addr: %p, len; %i",
+				       ((uint32_t) (link->data) >> PAGE_SHIFT),
+				       (((uint32_t) link->data +
+					 link->len) >> PAGE_SHIFT), link->data,
+				       link->data + link->len, link->len);
+#endif
+
+			if ((((uint32_t) link->data +
+			      link->len) >> PAGE_SHIFT) !=
+			    ((uint32_t) link->data >> PAGE_SHIFT)) {
+				link->len = 0;	/* Cause error.  Somebody is up to no good. */
+			}
+#else				/* FSL_HAVE_SCC2 */
+
+			/* User keystores are not valid on non-SCC2 platforms */
+			link->len = 0;	/* Cause error.  Somebody is up to no good. */
+
+#endif				/* FSL_HAVE_SCC2 */
+
+		} else {
+			if (!(link->flags & SAH_PREPHYS_DATA)) {
+				link->original_data = link->data;
+
+				/* if the data buffer is not in kernel direct-
+				  * mapped region, find the physical addr
+				  * via other means.
+				  */
+				if (!virt_addr_valid(link->data)) {
+					pg = vmalloc_to_page(link->data);
+					link->data = (uint8_t *) (
+						page_to_phys(pg) +
+						(((unsigned int) link->data) &
+							~PAGE_MASK));
+				} else
+					link->data = (void *)os_pa(link->data);
+#ifdef DO_DBG
+				os_printk("%sput: %p (%d)\n",
+					  (link->
+					   flags & SAH_OUTPUT_LINK) ? "out" :
+					  "in", link->data, link->len);
+#endif
+
+				if (link->flags & SAH_OUTPUT_LINK) {
+					/* clean and invalidate */
+					os_cache_flush_range(link->
+							     original_data,
+							     link->len);
+				} else {
+					os_cache_clean_range(link->original_data,
+							     link->len);
+				}
+			}	/* not prephys */
+		}		/* else not key reference */
+
+#if defined(NO_OUTPUT_1K_CROSSING) || defined(NO_1K_CROSSING)
+		if (
+#ifdef NO_OUTPUT_1K_CROSSING
+			   /* Insert extra link if 1k boundary on output pointer
+			    * crossed not at an 8-word boundary */
+			   (link->flags & SAH_OUTPUT_LINK) &&
+			   (((uint32_t) link->data % 32) != 0) &&
+#endif
+			   ((((uint32_t) link->data & 1023) + link->len) >
+			    1024)) {
+			uint32_t full_length = link->len;
+			sah_Link *new_link = sah_Alloc_Link();
+			link->len = 1024 - ((uint32_t) link->data % 1024);
+			new_link->len = full_length - link->len;
+			new_link->data = link->data + link->len;
+			new_link->original_data =
+			    link->original_data + link->len;
+			new_link->flags = link->flags & ~(SAH_OWNS_LINK_DATA);
+			new_link->flags |= SAH_LINK_INSERTED_LINK;
+			new_link->next = link->next;
+
+			link->next = (sah_Link *) new_link->dma_addr;
+			link->original_next = new_link;
+			link = new_link;
+		}
+#endif				/* ALLOW_OUTPUT_1K_CROSSING */
+
+		link->original_next = link->next;
+		if (link->next != NULL) {
+			link->next = (sah_Link *) link->next->dma_addr;
+		}
+#ifdef DO_DBG
+		sah_Dump_Words("Link", link, link->dma_addr, 3);
+#endif
+
+		link = link->original_next;
+	}
+
+	return (sah_Link *) first_link->dma_addr;
+}				/* sah_Physicalise_Links */
+
+/*!
+ * Run through descriptors and links created by KM-API and set the
+ * dma addresses and 'do not free' flags.
+ *
+ * @param first_desc  KERNEL VIRTUAL address of first descriptor in chain.
+ *
+ * Warning!  This ONLY works without LLO flags in headers!!!
+ *
+ * @return Virtual address of @a first_desc.
+ * @return NULL if Descriptor Chain could not be physicalised
+ */
+sah_Head_Desc *sah_Physicalise_Descriptors(sah_Head_Desc * first_desc)
+{
+	sah_Desc *desc = &first_desc->desc;
+
+	if (!(first_desc->uco_flags & FSL_UCO_CHAIN_PREPHYSICALIZED)) {
+		while (desc != NULL) {
+			sah_Desc *next_desc;
+
+#ifdef DO_DBG
+
+			sah_Dump_Words("Desc", (unsigned *)desc, desc->dma_addr, 6);
+#endif
+
+			desc->original_ptr1 = desc->ptr1;
+			if (desc->ptr1 != NULL) {
+				if ((desc->ptr1 =
+				     sah_Physicalise_Links(desc->ptr1)) ==
+				    NULL) {
+					/* Clean up ... */
+					sah_DePhysicalise_Descriptors
+					    (first_desc);
+					first_desc = NULL;
+					break;
+				}
+			}
+			desc->original_ptr2 = desc->ptr2;
+			if (desc->ptr2 != NULL) {
+				if ((desc->ptr2 =
+				     sah_Physicalise_Links(desc->ptr2)) ==
+				    NULL) {
+					/* Clean up ... */
+					sah_DePhysicalise_Descriptors
+					    (first_desc);
+					first_desc = NULL;
+					break;
+				}
+			}
+
+			desc->original_next = desc->next;
+			next_desc = desc->next;	/* save for bottom of while loop */
+			if (desc->next != NULL) {
+				desc->next = (sah_Desc *) desc->next->dma_addr;
+			}
+
+			desc = next_desc;
+		}
+	}
+	/* not prephysicalized */
+#ifdef DO_DBG
+	os_printk("Physicalise finished\n");
+#endif
+
+	return first_desc;
+}				/* sah_Physicalise_Descriptors() */
+
+/*!
+*******************************************************************************
+* This function runs through a sah_Link chain pointed to by a physical address.
+* It computes the virtual address for each pointer
+*
+* @brief Convert physical Link chain
+*
+* @param    first_link   A kernel address of a sah_Link
+*
+* @return   sah_Link *  A kernal address for the link chain of @c first_link
+* @return   NULL        If there was some error.
+*
+* @post  All links will be chained together by original virtual addresses,
+*        data pointers will point to virtual addresses.  Appropriate cache
+*        lines will be flushed, memory unwired, etc.
+*/
+sah_Link *sah_DePhysicalise_Links(sah_Link * first_link)
+{
+	sah_Link *link = first_link;
+	sah_Link *prev_link = NULL;
+
+	/* Loop on virtual link pointer */
+	while (link != NULL) {
+
+#ifdef DO_DBG
+		sah_Dump_Words("Link", (unsigned *)link, link->dma_addr, 3);
+#endif
+
+		/* if this references stored keys, don't want to dephysicalize them */
+		if (!(link->flags & SAH_STORED_KEY_INFO)
+		    && !(link->flags & SAH_PREPHYS_DATA)
+		    && !(link->flags & SAH_IN_USER_KEYSTORE)) {
+
+			/* */
+			if (link->flags & SAH_OUTPUT_LINK) {
+				os_cache_inv_range(link->original_data,
+						   link->len);
+			}
+
+			/* determine if there is a page in user space associated with this
+			 * link */
+			if (link->vm_info != NULL) {
+				/* check that this isn't reserved and contains output */
+				if (!PageReserved(link->vm_info) &&
+				    (link->flags & SAH_OUTPUT_LINK)) {
+
+					/* Mark to force page eventually to backing store */
+					SetPageDirty(link->vm_info);
+				}
+
+				/* Untie this page from physical memory */
+				page_cache_release(link->vm_info);
+			} else {
+				/* kernel-mode data */
+#ifdef DO_DBG
+				os_printk("%sput: %p (%d)\n",
+					  (link->
+					   flags & SAH_OUTPUT_LINK) ? "out" :
+					  "in", link->original_data, link->len);
+#endif
+			}
+			link->data = link->original_data;
+		}
+#ifndef ALLOW_OUTPUT_1K_CROSSING
+		if (link->flags & SAH_LINK_INSERTED_LINK) {
+			/* Reconsolidate data by merging this link with previous */
+			prev_link->len += link->len;
+			prev_link->next = link->next;
+			prev_link->original_next = link->original_next;
+			sah_Free_Link(link);
+			link = prev_link;
+
+		}
+#endif
+
+		if (link->next != NULL) {
+			link->next = link->original_next;
+		}
+		prev_link = link;
+		link = link->next;
+	}
+
+	return first_link;
+}				/* sah_DePhysicalise_Links() */
+
+/*!
+ * Run through descriptors and links that have been Physicalised
+ * (sah_Physicalise_Descriptors function) and set the dma addresses back
+ * to KM virtual addresses
+ *
+ * @param first_desc Kernel virtual address of first descriptor in chain.
+ *
+ * Warning!  This ONLY works without LLO flags in headers!!!
+ */
+sah_Head_Desc *sah_DePhysicalise_Descriptors(sah_Head_Desc * first_desc)
+{
+	sah_Desc *desc = &first_desc->desc;
+
+	if (!(first_desc->uco_flags & FSL_UCO_CHAIN_PREPHYSICALIZED)) {
+		while (desc != NULL) {
+#ifdef DO_DBG
+			sah_Dump_Words("Desc", (unsigned *)desc, desc->dma_addr, 6);
+#endif
+
+			if (desc->ptr1 != NULL) {
+				desc->ptr1 =
+				    sah_DePhysicalise_Links(desc->
+							    original_ptr1);
+			}
+			if (desc->ptr2 != NULL) {
+				desc->ptr2 =
+				    sah_DePhysicalise_Links(desc->
+							    original_ptr2);
+			}
+			if (desc->next != NULL) {
+				desc->next = desc->original_next;
+			}
+			desc = desc->next;
+		}
+	}
+	/* not prephysicalized */
+	return first_desc;
+}				/* sah_DePhysicalise_Descriptors() */
+
+/*!
+*******************************************************************************
+* This walks through a SAHARA descriptor chain and free()'s everything
+* that is not NULL. Finally it also unmaps all of the physical memory and
+* frees the kiobuf_list Queue.
+*
+* @brief Kernel Descriptor Chain Destructor
+*
+* @param    head_desc   A Descriptor pointer from kernel-space.
+*
+* @return   void
+*
+*/
+void sah_Free_Chained_Descriptors(sah_Head_Desc * head_desc)
+{
+	sah_Desc *desc = NULL;
+	sah_Desc *next_desc = NULL;
+	int this_is_head = 1;
+
+	desc = &head_desc->desc;
+
+	while (desc != NULL) {
+
+		sah_Free_Chained_Links(desc->ptr1);
+		sah_Free_Chained_Links(desc->ptr2);
+
+		/* Get a bus pointer to the next Descriptor */
+		next_desc = desc->next;
+
+		/* Zero the header and Length fields for security reasons. */
+		desc->header = 0;
+		desc->len1 = 0;
+		desc->len2 = 0;
+
+		if (this_is_head) {
+			sah_Free_Head_Descriptor(head_desc);
+			this_is_head = 0;
+#ifdef DIAG_MEM
+			sprintf(Diag_msg, "Free_Head_Descriptor: %p\n",
+				head_desc);
+			LOG_KDIAG(Diag_msg);
+#endif
+		} else {
+			/* free this descriptor */
+			sah_Free_Descriptor(desc);
+#ifdef DIAG_MEM
+			sprintf(Diag_msg, "Free_Descriptor: %p\n", desc);
+			LOG_KDIAG(Diag_msg);
+#endif
+		}
+
+		/* Look at the next Descriptor */
+		desc = next_desc;
+	}
+}				/* sah_Free_Chained_Descriptors() */
+
+/*!
+*******************************************************************************
+* This walks through a SAHARA link chain and frees everything that is
+* not NULL, excluding user-space buffers.
+*
+* @brief Kernel Link Chain Destructor
+*
+* @param    link    A Link pointer from kernel-space. This is in bus address
+*                   space.
+*
+* @return   void
+*
+*/
+void sah_Free_Chained_Links(sah_Link * link)
+{
+	sah_Link *next_link = NULL;
+
+	while (link != NULL) {
+		/* Get a bus pointer to the next Link */
+		next_link = link->next;
+
+		/* Zero some fields for security reasons. */
+		link->data = NULL;
+		link->len = 0;
+		link->ownerid = 0;
+
+		/* Free this Link */
+#ifdef DIAG_MEM
+		sprintf(Diag_msg, "Free_Link: %p(->%p)\n", link, link->next);
+		LOG_KDIAG(Diag_msg);
+#endif
+		sah_Free_Link(link);
+
+		/* Move on to the next Link */
+		link = next_link;
+	}
+}
+
+/*!
+*******************************************************************************
+* This function runs through a link chain pointed to by a user-space
+* address. It makes a temporary kernel-space copy of each link in the
+* chain and calls sah_Make_Links() to create a set of kernel-side links
+* to replace it.
+*
+* @brief Kernel Link Chain Copier
+*
+* @param    ptr         A link pointer from user-space.
+*
+* @return   sah_Link *  - The virtual address of the first link in the
+*                         chain.
+* @return   NULL        - If there was some error.
+*/
+sah_Link *sah_Copy_Links(fsl_shw_uco_t * user_ctx, sah_Link * ptr)
+{
+	sah_Link *head_link = NULL;
+	sah_Link *new_head_link = NULL;
+	sah_Link *new_tail_link = NULL;
+	sah_Link *prev_tail_link = NULL;
+	sah_Link *user_link = ptr;
+	sah_Link link_copy;
+	int link_data_length = 0;
+
+	/* Internal status variable to be used in this function */
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+	sah_Link *ret_val = NULL;
+
+	/* This will be set to True when we have finished processing our
+	 * link chain. */
+	int drv_if_done = FALSE;
+	int is_this_the_head = TRUE;
+	int result;
+
+	/* transfer all links, on this link chain, from user space */
+	while (drv_if_done == FALSE) {
+		/* Copy the current link from user-space. The virtual address, DMA
+		 * address, and vm_info fields of the sah_Link struct are not part
+		 * of the user-space structure. They must be the last elements and
+		 * should not be copied. */
+		result = copy_from_user(&link_copy,
+					user_link, (sizeof(sah_Link) -
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+						    sizeof(struct page *) -	/* vm_info */
+#endif
+						    sizeof(dma_addr_t) -	/* dma_addr */
+						    sizeof(uint32_t) -	/* virt_addr */
+						    sizeof(uint8_t *) -	/* original_data */
+						    sizeof(sah_Link *)));	/* original_next */
+
+		if (result != 0) {
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("copy_from_user() failed.");
+#endif
+			drv_if_done = TRUE;
+			status = FSL_RETURN_INTERNAL_ERROR_S;
+		}
+
+		if (status == FSL_RETURN_OK_S) {
+			/* This will create new links which can be used to replace tmp_link
+			 * in the chain. This will return a new head and tail link. */
+			link_data_length = link_data_length + link_copy.len;
+			new_head_link =
+			    sah_Make_Links(user_ctx, &link_copy, &new_tail_link);
+
+			if (new_head_link == NULL) {
+				/* If we ran out of memory or a user pointer was invalid */
+				drv_if_done = TRUE;
+				status = FSL_RETURN_INTERNAL_ERROR_S;
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("sah_Make_Links() failed.");
+#endif
+			} else {
+				if (is_this_the_head == TRUE) {
+					/* Keep a reference to the head link */
+					head_link = new_head_link;
+					is_this_the_head = FALSE;
+				} else {
+					/* Need to update the previous links' next field to point
+					 * to the current link. */
+					prev_tail_link->next =
+					    (void *)new_head_link->dma_addr;
+					prev_tail_link->original_next =
+					    new_head_link;
+				}
+			}
+		}
+
+		if (status == FSL_RETURN_OK_S) {
+			/* Get to the next link in the chain. */
+			user_link = link_copy.next;
+			prev_tail_link = new_tail_link;
+
+			/* Check if the end of the link chain was reached (TRUE) or if
+			 * there is another linked to this one (FALSE) */
+			drv_if_done = (user_link == NULL) ? TRUE : FALSE;
+		}
+	}			/* end while */
+
+	if (status != FSL_RETURN_OK_S) {
+		ret_val = NULL;
+		/* There could be clean-up to do here because we may have made some
+		 * successful iterations through the while loop and as a result, the
+		 * links created by sah_Make_Links() need to be destroyed.
+		 */
+		if (head_link != NULL) {
+			/* Failed somewhere in the while loop and need to clean-up. */
+			sah_Destroy_Links(head_link);
+		}
+	} else {
+		/* Success. Return the head link. */
+		ret_val = head_link;
+	}
+
+	return ret_val;
+}				/* sah_Copy_Links() */
+
+/*!
+*******************************************************************************
+* This function takes an input link pointed to by a user-space address
+* and returns a chain of links that span the physical pages pointed
+* to by the input link.
+*
+* @brief Kernel Link Chain Constructor
+*
+* @param    ptr         A link pointer from user-space.
+* @param    tail        The address of a link pointer. This is used to return
+*                       the tail link created by this function.
+*
+* @return   sah_Link *  - A virtual address of the first link in the
+*                         chain.
+* @return   NULL        - If there was some error.
+*
+*/
+sah_Link *sah_Make_Links(fsl_shw_uco_t * user_ctx,
+							sah_Link * ptr, sah_Link ** tail)
+{
+	int result = -1;
+	int page_index = 0;
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+	int is_this_the_head = TRUE;
+	void *buffer_start = NULL;
+	sah_Link *link = NULL;
+	sah_Link *prev_link = NULL;
+	sah_Link *head_link = NULL;
+	sah_Link *ret_val = NULL;
+	int buffer_length = 0;
+	struct page **local_pages = NULL;
+	int nr_pages = 0;
+	int write = (sah_Link_Get_Flags(ptr) & SAH_OUTPUT_LINK) ? WRITE : READ;
+	dma_addr_t phys_addr;
+
+	/* need to retrieve stored key? */
+	if (ptr->flags & SAH_STORED_KEY_INFO) {
+		fsl_shw_return_t ret_status;
+
+		/* allocate space for this link */
+		link = sah_Alloc_Link();
+#ifdef DIAG_MEM
+		sprintf(Diag_msg, "Alloc_Link returned %p/%p\n", link,
+			(void *)link->dma_addr);
+		LOG_KDIAG(Diag_msg);
+#endif
+
+		if (link == NULL) {
+			status = FSL_RETURN_NO_RESOURCE_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("sah_Alloc_Link() failed!");
+#endif
+			return link;
+		} else {
+			uint32_t max_len = 0;	/* max slot length */
+
+			/* get length and physical address of stored key */
+			ret_status = system_keystore_get_slot_info(ptr->ownerid, ptr->slot, (uint32_t *) & link->data,	/* RED key address */
+						      &max_len);
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG_ARGS
+			("ret_status==SCC_RET_OK? %s.  slot: %i. data: %p"
+			 ". len: %i, key length: %i",
+			(ret_status == FSL_RETURN_OK_S ? "yes" : "no"),
+			 ptr->slot, link->data, max_len, ptr->len);
+#endif
+
+			if ((ret_status == FSL_RETURN_OK_S) && (ptr->len <= max_len)) {
+				/* finish populating the link */
+				link->len = ptr->len;
+				link->flags = ptr->flags & ~SAH_PREPHYS_DATA;
+				*tail = link;
+			} else {
+#ifdef DIAG_DRV_IF
+				if (ret_status == FSL_RETURN_OK_S) {
+					LOG_KDIAG
+					    ("SCC sah_Link key slot reference is too long");
+				} else {
+					LOG_KDIAG
+					    ("SCC sah_Link slot slot reference is invalid");
+				}
+#endif
+				sah_Free_Link(link);
+				status = FSL_RETURN_INTERNAL_ERROR_S;
+				return NULL;
+			}
+			return link;
+		}
+	}	else if (ptr->flags & SAH_IN_USER_KEYSTORE) {
+
+#ifdef FSL_HAVE_SCC2
+
+		void *kernel_base;
+
+		/* allocate space for this link */
+		link = sah_Alloc_Link();
+#ifdef DIAG_MEM
+		sprintf(Diag_msg, "Alloc_Link returned %p/%p\n", link,
+			(void *)link->dma_addr);
+		LOG_KDIAG(Diag_msg);
+#endif				/* DIAG_MEM */
+
+		if (link == NULL) {
+			status = FSL_RETURN_NO_RESOURCE_S;
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("sah_Alloc_Link() failed!");
+#endif
+			return link;
+		} else {
+			/* link->data points to the virtual address of the key data, however
+			 * this memory does not need to be locked down.
+			 */
+			kernel_base = lookup_user_partition(user_ctx,
+							    (uint32_t) ptr->
+							    data & PAGE_MASK);
+
+			link->data = (uint8_t *) scc_virt_to_phys(kernel_base +
+								  ((unsigned
+								    long)ptr->
+								   data &
+								   ~PAGE_MASK));
+
+			/* Do bounds checking to ensure that the user is not overstepping
+			 * the bounds of their partition.  This is a simple implementation
+			 * that assumes the user only owns one partition.  It only checks
+			 * to see if the address of the last byte of data steps over a
+			 * page boundary.
+			 */
+			if ((kernel_base != NULL) &&
+			    ((((uint32_t) link->data +
+			       link->len) >> PAGE_SHIFT) ==
+			     ((uint32_t) link->data >> PAGE_SHIFT))) {
+				/* finish populating the link */
+				link->len = ptr->len;
+				link->flags = ptr->flags & ~SAH_PREPHYS_DATA;
+				*tail = link;
+			} else {
+#ifdef DIAG_DRV_IF
+				if (kernel_base != NULL) {
+					LOG_KDIAG
+					    ("SCC sah_Link key slot reference is too long");
+				} else {
+					LOG_KDIAG
+					    ("SCC sah_Link slot slot reference is invalid");
+				}
+#endif
+				sah_Free_Link(link);
+				status = FSL_RETURN_INTERNAL_ERROR_S;
+				return NULL;
+			}
+			return link;
+		}
+
+#else				/* FSL_HAVE_SCC2 */
+
+		return NULL;
+
+#endif				/* FSL_HAVE_SCC2 */
+	}
+
+	if (ptr->data == NULL) {
+		/* The user buffer must not be NULL because map_user_kiobuf() cannot
+		 * handle NULL pointer input.
+		 */
+		status = FSL_RETURN_BAD_DATA_LENGTH_S;
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("sah_Link data pointer is NULL.");
+#endif
+	}
+
+	if (status == FSL_RETURN_OK_S) {
+		unsigned long start_page = (unsigned long)ptr->data & PAGE_MASK;
+
+		/* determine number of pages being used for this link */
+		nr_pages = (((unsigned long)(ptr->data) & ~PAGE_MASK)
+			    + ptr->len + ~PAGE_MASK) >> PAGE_SHIFT;
+
+		/* ptr contains all the 'user space' information, add the pages
+		 * to it also just so everything is in one place */
+		local_pages =
+		    kmalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);
+
+		if (local_pages == NULL) {
+			status = FSL_RETURN_NO_RESOURCE_S;	/* no memory! */
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("kmalloc() failed.");
+#endif
+		} else {
+			/* get the actual pages being used in 'user space' */
+
+			down_read(&current->mm->mmap_sem);
+			result = get_user_pages(current, current->mm,
+						start_page, nr_pages,
+						write, 0 /* noforce */ ,
+						local_pages, NULL);
+			up_read(&current->mm->mmap_sem);
+
+			if (result < nr_pages) {
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("get_user_pages() failed.");
+#endif
+				if (result > 0) {
+					for (page_index = 0;
+					     page_index < result;
+					     page_index++) {
+						page_cache_release(local_pages
+								   [page_index]);
+					}
+				}
+				status = FSL_RETURN_INTERNAL_ERROR_S;
+			}
+		}
+	}
+
+	/* Now we can walk through the list of pages in the buffer */
+	if (status == FSL_RETURN_OK_S) {
+
+#if defined(FLUSH_SPECIFIC_DATA_ONLY) && !defined(HAS_L2_CACHE)
+		/*
+		 * Now that pages are wired, clear user data from cache lines.  When
+		 * there is just an L1 cache, clean based on user virtual for ARM.
+		 */
+		if (write == WRITE) {
+			os_cache_flush_range(ptr->data, ptr->len);
+		} else {
+			os_cache_clean_range(ptr->data, ptr->len);
+		}
+#endif
+
+		for (page_index = 0; page_index < nr_pages; page_index++) {
+			/* Allocate a new link structure */
+			link = sah_Alloc_Link();
+#ifdef DIAG_MEM
+			sprintf(Diag_msg, "Alloc_Link returned %p/%p\n", link,
+				(void *)link->dma_addr);
+			LOG_KDIAG(Diag_msg);
+#endif
+			if (link == NULL) {
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("sah_Alloc_Link() failed.");
+#endif
+				status = FSL_RETURN_NO_RESOURCE_S;
+
+				/* need to free the rest of the pages. Destroy_Links will take
+				 * care of the ones already assigned to a link */
+				for (; page_index < nr_pages; page_index++) {
+					page_cache_release(local_pages
+							   [page_index]);
+				}
+				break;	/* exit 'for page_index' loop */
+			}
+
+			if (status == FSL_RETURN_OK_S) {
+				if (is_this_the_head == TRUE) {
+					/* keep a reference to the head link */
+					head_link = link;
+					/* remember that we have seen the head link */
+					is_this_the_head = FALSE;
+				} else {
+					/* If this is not the head link then set the previous
+					 * link's next pointer to point to this link */
+					prev_link->original_next = link;
+					prev_link->next =
+					    (sah_Link *) link->dma_addr;
+				}
+
+				buffer_start =
+				    page_address(local_pages[page_index]);
+
+				phys_addr =
+					page_to_phys(local_pages[page_index]);
+
+				if (page_index == 0) {
+					/* If this is the first page, there might be an
+					 * offset. We need to increment the address by this offset
+					 * so we don't just get the start of the page.
+					 */
+					buffer_start +=
+					    (unsigned long)
+					    sah_Link_Get_Data(ptr)
+					    & ~PAGE_MASK;
+					phys_addr +=
+					    (unsigned long)
+					    sah_Link_Get_Data(ptr)
+					    & ~PAGE_MASK;
+					buffer_length = PAGE_SIZE
+					    -
+					    ((unsigned long)
+					     sah_Link_Get_Data(ptr)
+					     & ~PAGE_MASK);
+				} else {
+					buffer_length = PAGE_SIZE;
+				}
+
+				if (page_index == nr_pages - 1) {
+					/* if this is the last page, we need to adjust
+					 * the buffer_length to account for the last page being
+					 * partially used.
+					 */
+					buffer_length -=
+					    nr_pages * PAGE_SIZE -
+					    sah_Link_Get_Len(ptr) -
+					    ((unsigned long)
+					     sah_Link_Get_Data(ptr) &
+					     ~PAGE_MASK);
+				}
+#if defined(FLUSH_SPECIFIC_DATA_ONLY) && defined(HAS_L2_CACHE)
+				/*
+				 * When there is an L2 cache, clean based on kernel
+				 * virtual..
+				 */
+				if (write == WRITE) {
+					os_cache_flush_range(buffer_start,
+							     buffer_length);
+				} else {
+					os_cache_clean_range(buffer_start,
+							     buffer_length);
+				}
+#endif
+
+				/* Fill in link information */
+				link->len = buffer_length;
+#if !defined(HAS_L2_CACHE)
+				/* use original virtual */
+				link->original_data = ptr->data;
+#else
+				/* use kernel virtual */
+				link->original_data = buffer_start;
+#endif
+				link->data = (void *)phys_addr;
+				link->flags = ptr->flags & ~SAH_PREPHYS_DATA;
+				link->vm_info = local_pages[page_index];
+				prev_link = link;
+
+#if defined(NO_OUTPUT_1K_CROSSING) || defined(NO_1K_CROSSING)
+				if (
+#ifdef NO_OUTPUT_1K_CROSSING
+					   /* Insert extra link if 1k boundary on output pointer
+					    * crossed not at an 8-word boundary */
+					   (link->flags & SAH_OUTPUT_LINK) &&
+					   (((uint32_t) buffer_start % 32) != 0)
+					   &&
+#endif
+					   ((((uint32_t) buffer_start & 1023) +
+					     buffer_length) > 1024)) {
+
+					/* Shorten current link to 1k boundary */
+					link->len =
+					    1024 -
+					    ((uint32_t) buffer_start % 1024);
+
+					/* Get new link to follow it */
+					link = sah_Alloc_Link();
+					prev_link->len =
+					    1024 -
+					    ((uint32_t) buffer_start % 1024);
+					prev_link->original_next = link;
+					prev_link->next =
+					    (sah_Link *) link->dma_addr;
+					buffer_length -= prev_link->len;
+					buffer_start += prev_link->len;
+
+#if !defined(HAS_L2_CACHE)
+					/* use original virtual */
+					link->original_data = ptr->data;
+#else
+					/* use kernel virtual */
+					link->original_data = buffer_start;
+#endif
+					link->data = (void *)phys_addr;
+					link->vm_info = prev_link->vm_info;
+					prev_link->vm_info = NULL;	/* delay release */
+					link->flags = ptr->flags;
+					link->len = buffer_length;
+					prev_link = link;
+				}	/* while link would cross 1K boundary */
+#endif				/* 1K_CROSSING */
+			}
+		}		/* for each page */
+	}
+
+	if (local_pages != NULL) {
+		kfree(local_pages);
+	}
+
+	if (status != FSL_RETURN_OK_S) {
+		/* De-allocated any links created, this routine first looks if
+		 * head_link is NULL */
+		sah_Destroy_Links(head_link);
+
+		/* Clean-up of the KIOBUF will occur in the * sah_Copy_Descriptors()
+		 * function.
+		 * Clean-up of the Queue entry must occur in the function called
+		 * sah_Copy_Descriptors().
+		 */
+	} else {
+
+		/* Success. Return the head link. */
+		ret_val = head_link;
+		link->original_next = NULL;
+		/* return the tail link as well */
+		*tail = link;
+	}
+
+	return ret_val;
+}				/* sah_Make_Links() */
+
+/*!
+*******************************************************************************
+* This walks through a SAHARA descriptor chain and frees everything
+* that is not NULL. Finally it also unmaps all of the physical memory and
+* frees the kiobuf_list Queue.
+*
+* @brief Kernel Descriptor Chain Destructor
+*
+* @param    desc        A Descriptor pointer from kernel-space. This should be
+*                       in bus address space.
+*
+* @return   void
+*
+*/
+void sah_Destroy_Descriptors(sah_Head_Desc * head_desc)
+{
+	sah_Desc *this_desc = (sah_Desc *) head_desc;
+	sah_Desc *next_desc = NULL;
+	int this_is_head = 1;
+
+	/*
+	 * Flush the D-cache. This flush is here because the hardware has finished
+	 * processing this descriptor and probably has changed the contents of
+	 * some linked user buffers as a result.  This flush will enable
+	 * user-space applications to see the correct data rather than the
+	 * out-of-date cached version.
+	 */
+#ifndef FLUSH_SPECIFIC_DATA_ONLY
+	os_flush_cache_all();
+#endif
+
+	head_desc = (sah_Head_Desc *) this_desc->virt_addr;
+
+	while (this_desc != NULL) {
+		if (this_desc->ptr1 != NULL) {
+			sah_Destroy_Links(this_desc->original_ptr1
+					  ? this_desc->
+					  original_ptr1 : this_desc->ptr1);
+		}
+		if (this_desc->ptr2 != NULL) {
+			sah_Destroy_Links(this_desc->original_ptr2
+					  ? this_desc->
+					  original_ptr2 : this_desc->ptr2);
+		}
+
+		/* Get a bus pointer to the next Descriptor */
+		next_desc = (this_desc->original_next
+			     ? this_desc->original_next : this_desc->next);
+
+		/* Zero the header and Length fields for security reasons. */
+		this_desc->header = 0;
+		this_desc->len1 = 0;
+		this_desc->len2 = 0;
+
+		if (this_is_head) {
+			sah_Free_Head_Descriptor(head_desc);
+#ifdef DIAG_MEM
+			sprintf(Diag_msg, "Free_Head_Descriptor: %p\n",
+				head_desc);
+			LOG_KDIAG(Diag_msg);
+#endif
+			this_is_head = 0;
+		} else {
+			/* free this descriptor */
+			sah_Free_Descriptor(this_desc);
+#ifdef DIAG_MEM
+			sprintf(Diag_msg, "Free_Descriptor: %p\n", this_desc);
+			LOG_KDIAG(Diag_msg);
+#endif
+		}
+
+		/* Set up for next round. */
+		this_desc = (sah_Desc *) next_desc;
+	}
+}
+
+/*!
+*******************************************************************************
+* This walks through a SAHARA link chain and frees everything that is
+* not NULL excluding user-space buffers.
+*
+* @brief Kernel Link Chain Destructor
+*
+* @param    link    A Link pointer from kernel-space.
+*
+* @return   void
+*
+*/
+void sah_Destroy_Links(sah_Link * link)
+{
+	sah_Link *this_link = link;
+	sah_Link *next_link = NULL;
+
+	while (this_link != NULL) {
+
+		/* if this link indicates an associated page, process it */
+		if (this_link->vm_info != NULL) {
+			/* since this function is only called from the routine that
+			 * creates a kernel copy of the user space descriptor chain,
+			 * there are no pages to dirty. All that is needed is to release
+			 * the page from cache */
+			page_cache_release(this_link->vm_info);
+		}
+
+		/* Get a bus pointer to the next Link */
+		next_link = (this_link->original_next
+			     ? this_link->original_next : this_link->next);
+
+		/* Zero the Pointer and Length fields for security reasons. */
+		this_link->data = NULL;
+		this_link->len = 0;
+
+		/* Free this Link */
+		sah_Free_Link(this_link);
+#ifdef DIAG_MEM
+		sprintf(Diag_msg, "Free_Link: %p\n", this_link);
+		LOG_KDIAG(Diag_msg);
+#endif
+
+		/* Look at the next Link */
+		this_link = next_link;
+	}
+}
+
+/*!
+*******************************************************************************
+* @brief Initialize memory manager/mapper.
+*
+* In 2.4, this function also allocates a kiovec to be used when mapping user
+* data to kernel space
+*
+* @return 0 for success, OS error code on failure
+*
+*/
+int sah_Init_Mem_Map(void)
+{
+	int ret = OS_ERROR_FAIL_S;
+
+	mem_lock = os_lock_alloc_init();
+
+	/*
+	 * If one of these fails, change the calculation in the #define earlier in
+	 * the file to be the other one.
+	 */
+	if (sizeof(sah_Link) > MEM_BLOCK_SIZE) {
+		os_printk("Sahara Driver: sah_Link structure is too large\n");
+	} else if (sizeof(sah_Desc) > MEM_BLOCK_SIZE) {
+		os_printk("Sahara Driver: sah_Desc structure is too large\n");
+	} else {
+		ret = OS_ERROR_OK_S;
+	}
+
+#ifndef SELF_MANAGED_POOL
+
+	big_dma_pool = dma_pool_create("sah_big_blocks", NULL,
+				       sizeof(Mem_Big_Block), sizeof(uint32_t),
+				       PAGE_SIZE);
+	small_dma_pool = dma_pool_create("sah_small_blocks", NULL,
+					 sizeof(Mem_Block), sizeof(uint32_t),
+					 PAGE_SIZE);
+#else
+
+#endif
+	return ret;
+}
+
+/*!
+*******************************************************************************
+* @brief Clean up memory manager/mapper.
+*
+* In 2.4, this function also frees the kiovec used when mapping user data to
+* kernel space.
+*
+* @return none
+*
+*/
+void sah_Stop_Mem_Map(void)
+{
+	os_lock_deallocate(mem_lock);
+
+#ifndef SELF_MANAGED_POOL
+	if (big_dma_pool != NULL) {
+		dma_pool_destroy(big_dma_pool);
+	}
+	if (small_dma_pool != NULL) {
+		dma_pool_destroy(small_dma_pool);
+	}
+#endif
+}
+
+/*!
+*******************************************************************************
+* Allocate Head descriptor from free pool.
+*
+* @brief Allocate Head descriptor
+*
+* @return sah_Head_Desc Free descriptor, NULL if no free descriptors available.
+*
+*/
+sah_Head_Desc *sah_Alloc_Head_Descriptor(void)
+{
+	Mem_Big_Block *block;
+	sah_Head_Desc *desc;
+
+	block = sah_Alloc_Big_Block();
+	if (block != NULL) {
+		/* initialize everything */
+		desc = (sah_Head_Desc *) block->data;
+
+		desc->desc.virt_addr = (sah_Desc *) desc;
+		desc->desc.dma_addr = block->dma_addr;
+		desc->desc.original_ptr1 = NULL;
+		desc->desc.original_ptr2 = NULL;
+		desc->desc.original_next = NULL;
+
+		desc->desc.ptr1 = NULL;
+		desc->desc.ptr2 = NULL;
+		desc->desc.next = NULL;
+	} else {
+		desc = NULL;
+	}
+
+	return desc;
+}
+
+/*!
+*******************************************************************************
+* Allocate descriptor from free pool.
+*
+* @brief Allocate descriptor
+*
+* @return sah_Desc Free descriptor, NULL if no free descriptors available.
+*
+*/
+sah_Desc *sah_Alloc_Descriptor(void)
+{
+	Mem_Block *block;
+	sah_Desc *desc;
+
+	block = sah_Alloc_Block();
+	if (block != NULL) {
+		/* initialize everything */
+		desc = (sah_Desc *) block->data;
+
+		desc->virt_addr = desc;
+		desc->dma_addr = block->dma_addr;
+		desc->original_ptr1 = NULL;
+		desc->original_ptr2 = NULL;
+		desc->original_next = NULL;
+
+		desc->ptr1 = NULL;
+		desc->ptr2 = NULL;
+		desc->next = NULL;
+	} else {
+		desc = NULL;
+	}
+
+	return (desc);
+}
+
+/*!
+*******************************************************************************
+* Allocate link from free pool.
+*
+* @brief Allocate link
+*
+* @return sah_Link Free link, NULL if no free links available.
+*
+*/
+sah_Link *sah_Alloc_Link(void)
+{
+	Mem_Block *block;
+	sah_Link *link;
+
+	block = sah_Alloc_Block();
+	if (block != NULL) {
+		/* initialize everything */
+		link = (sah_Link *) block->data;
+
+		link->virt_addr = link;
+		link->original_next = NULL;
+		link->original_data = NULL;
+		/* information found in allocated block */
+		link->dma_addr = block->dma_addr;
+
+		/* Sahara link fields */
+		link->len = 0;
+		link->data = NULL;
+		link->next = NULL;
+
+		/* driver required fields */
+		link->flags = 0;
+		link->vm_info = NULL;
+	} else {
+		link = NULL;
+	}
+
+	return link;
+}
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Add a new page to end of block free pool. This will allocate one page and
+* fill the pool with entries, appending to the end.
+*
+* @brief Add page of blocks to block free pool.
+*
+* @pre This function must be called with the #mem_lock held.
+*
+* @param   big    0        - make blocks big enough for sah_Desc
+*                 non-zero - make blocks big enough for sah_Head_Desc
+*
+* @return int TRUE if blocks added succeesfully, FALSE otherwise
+*
+*/
+int sah_Block_Add_Page(int big)
+{
+	void *page;
+	int success;
+	dma_addr_t dma_addr;
+	unsigned block_index;
+	uint32_t dma_offset;
+	unsigned block_entries =
+	    big ? MEM_BIG_BLOCK_ENTRIES : MEM_BLOCK_ENTRIES;
+	unsigned block_size = big ? sizeof(Mem_Big_Block) : sizeof(Mem_Block);
+	void *block;
+
+	/* Allocate page of memory */
+#ifndef USE_COHERENT_MEMORY
+	page = os_alloc_memory(PAGE_SIZE, GFP_ATOMIC | __GFP_DMA);
+	dma_addr = os_pa(page);
+#else
+	page = os_alloc_coherent(PAGE_SIZE, &dma_addr, GFP_ATOMIC);
+#endif
+	if (page != NULL) {
+		/*
+		 * Find the difference between the virtual address and the DMA
+		 * address of the page. This is used later to determine the DMA
+		 * address of each individual block.
+		 */
+		dma_offset = page - (void *)dma_addr;
+
+		/* Split page into blocks and add to free pool */
+		block = page;
+		for (block_index = 0; block_index < block_entries;
+		     block_index++) {
+			if (big) {
+				register Mem_Big_Block *blockp = block;
+				blockp->dma_addr =
+				    (uint32_t) (block - dma_offset);
+				sah_Append_Big_Block(blockp);
+			} else {
+				register Mem_Block *blockp = block;
+				blockp->dma_addr =
+				    (uint32_t) (block - dma_offset);
+				/* sah_Append_Block must be protected with spin locks. This is
+				 * done in sah_Alloc_Block(), which calls
+				 * sah_Block_Add_Page() */
+				sah_Append_Block(blockp);
+			}
+			block += block_size;
+		}
+		success = TRUE;
+#ifdef DIAG_MEM
+		LOG_KDIAG("Succeeded in allocating new page");
+#endif
+	} else {
+		success = FALSE;
+#ifdef DIAG_MEM
+		LOG_KDIAG("Failed in allocating new page");
+#endif
+	}
+
+	return success;
+}
+#endif				/* SELF_MANAGED_POOL */
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Allocate block from free pool. A block is large enough to fit either a link
+* or descriptor.
+*
+* @brief Allocate memory block
+*
+* @return Mem_Block Free block, NULL if no free blocks available.
+*
+*/
+static Mem_Big_Block *sah_Alloc_Big_Block(void)
+{
+	Mem_Big_Block *block;
+	os_lock_context_t lock_flags;
+
+	os_lock_save_context(mem_lock, lock_flags);
+
+	/* If the pool is empty, try to allocate more entries */
+	if (big_block_free_head == NULL) {
+		(void)sah_Block_Add_Page(1);
+	}
+
+	/* Check that the pool now has some free entries */
+	if (big_block_free_head != NULL) {
+		/* Return the head of the free pool */
+		block = big_block_free_head;
+
+		big_block_free_head = big_block_free_head->next;
+		if (big_block_free_head == NULL) {
+			/* Allocated last entry in pool */
+			big_block_free_tail = NULL;
+		}
+	} else {
+		block = NULL;
+	}
+	os_unlock_restore_context(mem_lock, lock_flags);
+
+	return block;
+}
+#else
+/*!
+*******************************************************************************
+* Allocate block from free pool. A block is large enough to fit either a link
+* or descriptor.
+*
+* @brief Allocate memory block
+*
+* @return Mem_Block Free block, NULL if no free blocks available.
+*
+*/
+static Mem_Big_Block *sah_Alloc_Big_Block(void)
+{
+	dma_addr_t dma_addr;
+	Mem_Big_Block *block =
+	    dma_pool_alloc(big_dma_pool, GFP_ATOMIC, &dma_addr);
+
+	if (block == NULL) {
+	} else {
+		block->dma_addr = dma_addr;
+	}
+
+	return block;
+}
+#endif
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Allocate block from free pool. A block is large enough to fit either a link
+* or descriptor.
+*
+* @brief Allocate memory block
+*
+* @return Mem_Block Free block, NULL if no free blocks available.
+*
+*/
+/******************************************************************************
+*
+* MODIFICATION HISTORY:
+*
+* Date         Person     Change
+* 31/10/2003   RWK        PR52734 - Implement functions to allocate
+*                                   descriptors and links. Replace
+*                                   consistent_alloc() calls. Initial creation.
+*
+******************************************************************************/
+static Mem_Block *sah_Alloc_Block(void)
+{
+	Mem_Block *block;
+	os_lock_context_t lock_flags;
+
+	os_lock_save_context(mem_lock, lock_flags);
+
+	/* If the pool is empty, try to allocate more entries */
+	if (block_free_head == NULL) {
+		(void)sah_Block_Add_Page(0);
+	}
+
+	/* Check that the pool now has some free entries */
+	if (block_free_head != NULL) {
+		/* Return the head of the free pool */
+		block = block_free_head;
+
+		block_free_head = block_free_head->next;
+		if (block_free_head == NULL) {
+			/* Allocated last entry in pool */
+			block_free_tail = NULL;
+		}
+	} else {
+		block = NULL;
+	}
+	os_unlock_restore_context(mem_lock, lock_flags);
+
+	return block;
+}
+#else
+/*!
+*******************************************************************************
+* Allocate block from free pool. A block is large enough to fit either a link
+* or descriptor.
+*
+* @brief Allocate memory block
+*
+* @return Mem_Block Free block, NULL if no free blocks available.
+*
+*/
+/******************************************************************************
+*
+* MODIFICATION HISTORY:
+*
+* Date         Person     Change
+* 31/10/2003   RWK        PR52734 - Implement functions to allocate
+*                                   descriptors and links. Replace
+*                                   consistent_alloc() calls. Initial creation.
+*
+******************************************************************************/
+static Mem_Block *sah_Alloc_Block(void)
+{
+
+	dma_addr_t dma_addr;
+	Mem_Block *block =
+	    dma_pool_alloc(small_dma_pool, GFP_ATOMIC, &dma_addr);
+
+	if (block == NULL) {
+	} else {
+		block->dma_addr = dma_addr;
+	}
+
+	return block;
+}
+#endif
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Free memory block back to free pool
+*
+* @brief Free memory block
+*
+* @param    block       A block allocated with sah_Alloc_Block().
+*
+* @return none
+*
+*/
+static void sah_Free_Block(Mem_Block * block)
+{
+	os_lock_context_t lock_flags;
+
+	os_lock_save_context(mem_lock, lock_flags);
+	sah_Append_Block(block);
+	os_unlock_restore_context(mem_lock, lock_flags);
+}
+#else
+/*!
+*******************************************************************************
+* Free memory block back to free pool
+*
+* @brief Free memory block
+*
+* @param    block       A block allocated with sah_Alloc_Block().
+*
+* @return none
+*
+*/
+static void sah_Free_Block(Mem_Block * block)
+{
+	dma_pool_free(small_dma_pool, block, block->dma_addr);
+}
+#endif
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Free memory block back to free pool
+*
+* @brief Free memory block
+*
+* @param    block       A block allocated with sah_Alloc_Block().
+*
+* @return none
+*
+*/
+static void sah_Free_Big_Block(Mem_Big_Block * block)
+{
+	os_lock_context_t lock_flags;
+
+	os_lock_save_context(mem_lock, lock_flags);
+	sah_Append_Big_Block(block);
+	os_unlock_restore_context(mem_lock, lock_flags);
+}
+#else
+/*!
+*******************************************************************************
+* Free memory block back to free pool
+*
+* @brief Free memory block
+*
+* @param    block       A block allocated with sah_Alloc_Block().
+*
+* @return none
+*
+*/
+static void sah_Free_Big_Block(Mem_Big_Block * block)
+{
+	dma_pool_free(big_dma_pool, block, block->dma_addr);
+}
+#endif
+
+#ifdef SELF_MANAGED_POOL
+/*!
+*******************************************************************************
+* Append memory block to end of free pool.
+*
+* @param    block       A block entry
+*
+* @return none
+*
+* @pre This function must be called with the #mem_lock held.
+*
+* @brief Append memory block to free pool
+*/
+static void sah_Append_Big_Block(Mem_Big_Block * block)
+{
+
+	/* Initialise block */
+	block->next = NULL;
+
+	/* Remember that block may be the first in the pool */
+	if (big_block_free_tail != NULL) {
+		big_block_free_tail->next = block;
+	} else {
+		/* Pool is empty */
+		big_block_free_head = block;
+	}
+
+	big_block_free_tail = block;
+}
+
+/*!
+*******************************************************************************
+* Append memory block to end of free pool.
+*
+* @brief Append memory block to free pool
+*
+* @param    block       A block entry
+*
+* @return none
+*
+* @pre #mem_lock must be held
+*
+*/
+static void sah_Append_Block(Mem_Block * block)
+{
+
+	/* Initialise block */
+	block->next = NULL;
+
+	/* Remember that block may be the first in the pool */
+	if (block_free_tail != NULL) {
+		block_free_tail->next = block;
+	} else {
+		/* Pool is empty */
+		block_free_head = block;
+	}
+
+	block_free_tail = block;
+}
+#endif				/* SELF_MANAGED_POOL */
+
+/* End of sah_memory_mapper.c */
diff --git a/drivers/mxc/security/sahara2/sah_queue.c b/drivers/mxc/security/sahara2/sah_queue.c
new file mode 100644
index 0000000..317a60b
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_queue.c
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sah_queue.c
+*
+* @brief This file provides a FIFO Queue implementation.
+*
+*/
+/******************************************************************************
+*
+* CAUTION:
+*******************************************************************
+*/
+
+/* SAHARA Includes */
+#include <sah_queue_manager.h>
+#ifdef DIAG_DRV_QUEUE
+#include <diagnostic.h>
+#endif
+
+/******************************************************************************
+* Queue Functions
+******************************************************************************/
+
+/*!
+*******************************************************************************
+* This function constructs a new sah_Queue.
+*
+* @brief     sah_Queue Constructor
+*
+* @return   A pointer to a newly allocated sah_Queue.
+* @return   NULL if allocation of memory failed.
+*/
+/******************************************************************************
+*
+* CAUTION:  This function may sleep in low-memory situations, as it uses
+*           kmalloc ( ..., GFP_KERNEL).
+******************************************************************************/
+sah_Queue *sah_Queue_Construct(void)
+{
+	sah_Queue *q = (sah_Queue *) os_alloc_memory(sizeof(sah_Queue),
+						     GFP_KERNEL);
+
+	if (q != NULL) {
+		/* Initialise the queue to an empty state. */
+		q->head = NULL;
+		q->tail = NULL;
+		q->count = 0;
+	}
+#ifdef DIAG_DRV_QUEUE
+	else {
+		LOG_KDIAG("kmalloc() failed.");
+	}
+#endif
+
+	return q;
+}
+
+/*!
+*******************************************************************************
+* This function destroys a sah_Queue.
+*
+* @brief     sah_Queue Destructor
+*
+* @param    q    A pointer to a sah_Queue.
+*
+* @return   void
+*/
+/******************************************************************************
+*
+* CAUTION:  This function does not free any queue entries.
+*
+******************************************************************************/
+void sah_Queue_Destroy(sah_Queue * q)
+{
+#ifdef DIAG_DRV_QUEUE
+	if (q == NULL) {
+		LOG_KDIAG("Trying to kfree() a NULL pointer.");
+	} else {
+		if (q->count != 0) {
+			LOG_KDIAG
+			    ("Trying to destroy a queue that is not empty.");
+		}
+	}
+#endif
+
+	if (q != NULL) {
+		os_free_memory(q);
+		q = NULL;
+	}
+}
+
+/*!
+*******************************************************************************
+* This function appends a sah_Head_Desc to the tail of a sah_Queue.
+*
+* @brief     Appends a sah_Head_Desc to a sah_Queue.
+*
+* @param    q       A pointer to a sah_Queue to append to.
+* @param    entry   A pointer to a sah_Head_Desc to append.
+*
+* @pre   The #desc_queue_lock must be held before calling this function.
+*
+* @return   void
+*/
+/******************************************************************************
+*
+* CAUTION: NONE
+******************************************************************************/
+void sah_Queue_Append_Entry(sah_Queue * q, sah_Head_Desc * entry)
+{
+	sah_Head_Desc *tail_entry = NULL;
+
+	if ((q == NULL) || (entry == NULL)) {
+#ifdef DIAG_DRV_QUEUE
+		LOG_KDIAG("Null pointer input.");
+#endif
+		return;
+	}
+
+	if (q->count == 0) {
+		/* The queue is empty */
+		q->head = entry;
+		q->tail = entry;
+		entry->next = NULL;
+		entry->prev = NULL;
+	} else {
+		/* The queue is not empty */
+		tail_entry = q->tail;
+		tail_entry->next = entry;
+		entry->next = NULL;
+		entry->prev = tail_entry;
+		q->tail = entry;
+	}
+	q->count++;
+}
+
+/*!
+*******************************************************************************
+* This function a removes a sah_Head_Desc from the head of a sah_Queue.
+*
+* @brief     Removes a sah_Head_Desc from a the head of a sah_Queue.
+*
+* @param    q    A pointer to a sah_Queue to remove from.
+*
+* @pre   The #desc_queue_lock must be held before calling this function.
+*
+* @return   void
+*/
+/******************************************************************************
+*
+* CAUTION:  This does not kfree() the entry.
+******************************************************************************/
+void sah_Queue_Remove_Entry(sah_Queue * q)
+{
+	sah_Queue_Remove_Any_Entry(q, q->head);
+}
+
+/*!
+*******************************************************************************
+* This function a removes a sah_Head_Desc from anywhere in a sah_Queue.
+*
+* @brief     Removes a sah_Head_Desc from anywhere in a sah_Queue.
+*
+* @param    qq      A pointer to a sah_Queue to remove from.
+* @param    entry   A pointer to a sah_Head_Desc to remove.
+*
+* @pre   The #desc_queue_lock must be held before calling this function.
+*
+* @return   void
+*/
+/******************************************************************************
+*
+* CAUTION:  This does not kfree() the entry. Does not check to see if the entry
+*           actually belongs to the queue.
+******************************************************************************/
+void sah_Queue_Remove_Any_Entry(sah_Queue * q, sah_Head_Desc * entry)
+{
+	sah_Head_Desc *prev_entry = NULL;
+	sah_Head_Desc *next_entry = NULL;
+
+	if ((q == NULL) || (entry == NULL)) {
+#if defined DIAG_DRV_QUEUE && defined DIAG_DURING_INTERRUPT
+		LOG_KDIAG("Null pointer input.");
+#endif
+		return;
+	}
+
+	if (q->count == 1) {
+		/* If q is the only entry in the queue. */
+		q->tail = NULL;
+		q->head = NULL;
+		q->count = 0;
+	} else if (q->count > 1) {
+		/* There are 2 or more entries in the queue. */
+
+#if defined DIAG_DRV_QUEUE && defined DIAG_DURING_INTERRUPT
+		if ((entry->next == NULL) && (entry->prev == NULL)) {
+			LOG_KDIAG
+			    ("Queue is not empty yet both next and prev pointers"
+			     " are NULL");
+		}
+#endif
+
+		if (entry->next == NULL) {
+			/* If this is the end of the queue */
+			prev_entry = entry->prev;
+			prev_entry->next = NULL;
+			q->tail = prev_entry;
+		} else if (entry->prev == NULL) {
+			/* If this is the head of the queue */
+			next_entry = entry->next;
+			next_entry->prev = NULL;
+			q->head = next_entry;
+		} else {
+			/* If this is somewhere in the middle of the queue */
+			prev_entry = entry->prev;
+			next_entry = entry->next;
+			prev_entry->next = next_entry;
+			next_entry->prev = prev_entry;
+		}
+		q->count--;
+	}
+	/*
+	 * Otherwise we are removing an entry from an empty queue.
+	 * Don't do anything in the product code
+	 */
+#if defined DIAG_DRV_QUEUE && defined DIAG_DURING_INTERRUPT
+	else {
+		LOG_KDIAG("Trying to remove an entry from an empty queue.");
+	}
+#endif
+
+	entry->next = NULL;
+	entry->prev = NULL;
+}
+
+/* End of sah_queue.c */
diff --git a/drivers/mxc/security/sahara2/sah_queue_manager.c b/drivers/mxc/security/sahara2/sah_queue_manager.c
new file mode 100644
index 0000000..78de354
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_queue_manager.c
@@ -0,0 +1,1076 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sah_queue_manager.c
+ *
+ * @brief This file provides a Queue Manager implementation.
+ *
+ * The Queue Manager manages additions and removal from the queue and updates
+ * the status of queue entries. It also calls sah_HW_* functions to interract
+ * with the hardware.
+*/
+
+#include "portable_os.h"
+
+/* SAHARA Includes */
+#include <sah_driver_common.h>
+#include <sah_queue_manager.h>
+#include <sah_status_manager.h>
+#include <sah_hardware_interface.h>
+#if defined(DIAG_DRV_QUEUE) || defined(DIAG_DRV_STATUS)
+#include <diagnostic.h>
+#endif
+#include <sah_memory_mapper.h>
+
+#ifdef DIAG_DRV_STATUS
+
+#define FSL_INVALID_RETURN 13
+#define MAX_RETURN_STRING_LEN 22
+#endif
+
+/* Defines for parsing value from Error Status register */
+#define SAH_STATUS_MASK 0x07
+#define SAH_ERROR_MASK 0x0F
+#define SAH_CHA_ERR_SOURCE_MASK 0x07
+#define SAH_CHA_ERR_STATUS_MASK 0x0FFF
+#define SAH_DMA_ERR_STATUS_MASK 0x0F
+#define SAH_DMA_ERR_SIZE_MASK 0x03
+#define SAH_DMA_ERR_DIR_MASK 0x01
+
+#define SHA_ERROR_STATUS_CONTINUE 0xFFFFFFFF
+#define SHA_CHA_ERROR_STATUS_DONE 0xFFFFFFFF
+
+/* this maps the error status register's error source 4 bit field to the API
+ * return values. A 0xFFFFFFFF indicates additional fields must be checked to
+ * determine an appropriate return value */
+static sah_Execute_Error sah_Execute_Error_Array[] = {
+	FSL_RETURN_ERROR_S,	/* SAH_ERR_NONE */
+	FSL_RETURN_BAD_FLAG_S,	/* SAH_ERR_HEADER */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_ERR_DESC_LENGTH */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_ERR_DESC_POINTER */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_ERR_LINK_LENGTH */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_ERR_LINK_POINTER */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_ERR_INPUT_BUFFER */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_ERR_OUTPUT_BUFFER */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_ERR_OUTPUT_BUFFER_STARVATION */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_ERR_INTERNAL_STATE */
+	FSL_RETURN_ERROR_S,	/* SAH_ERR_GENERAL_DESCRIPTOR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_ERR_RESERVED_FIELDS */
+	FSL_RETURN_MEMORY_ERROR_S,	/* SAH_ERR_DESCRIPTOR_ADDRESS */
+	FSL_RETURN_MEMORY_ERROR_S,	/* SAH_ERR_LINK_ADDRESS */
+	SHA_ERROR_STATUS_CONTINUE,	/* SAH_ERR_CHA */
+	SHA_ERROR_STATUS_CONTINUE	/* SAH_ERR_DMA */
+};
+
+static sah_DMA_Error_Status sah_DMA_Error_Status_Array[] = {
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_NO_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_AHB_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_IP_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_PARITY_ERR */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_DMA_BOUNDRY_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_BUSY_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_DMA_RESERVED_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S	/* SAH_DMA_INT_ERR */
+};
+
+static sah_CHA_Error_Status sah_CHA_Error_Status_Array[] = {
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_CHA_NO_ERR */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_CHA_IP_BUF */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_CHA_ADD_ERR */
+	FSL_RETURN_BAD_MODE_S,	/* SAH_CHA_MODE_ERR */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/* SAH_CHA_DATA_SIZE_ERR */
+	FSL_RETURN_BAD_KEY_LENGTH_S,	/* SAH_CHA_KEY_SIZE_ERR */
+	FSL_RETURN_BAD_MODE_S,	/* SAH_CHA_PROC_ERR */
+	FSL_RETURN_ERROR_S,	/* SAH_CHA_CTX_READ_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_CHA_INTERNAL_HW_ERR */
+	FSL_RETURN_MEMORY_ERROR_S,	/* SAH_CHA_IP_BUFF_ERR */
+	FSL_RETURN_MEMORY_ERROR_S,	/* SAH_CHA_OP_BUFF_ERR */
+	FSL_RETURN_BAD_KEY_PARITY_S,	/* SAH_CHA_DES_KEY_ERR */
+	FSL_RETURN_INTERNAL_ERROR_S,	/* SAH_CHA_RES */
+};
+
+#ifdef DIAG_DRV_STATUS
+
+char sah_return_text[FSL_INVALID_RETURN][MAX_RETURN_STRING_LEN] = {
+	"No error",		/* FSL_RETURN_OK_S */
+	"Error",		/* FSL_RETURN_ERROR_S */
+	"No resource",		/* FSL_RETURN_NO_RESOURCE_S */
+	"Bad algorithm",	/* FSL_RETURN_BAD_ALGORITHM_S */
+	"Bad mode",		/* FSL_RETURN_BAD_MODE_S */
+	"Bad flag",		/* FSL_RETURN_BAD_FLAG_S */
+	"Bad key length",	/* FSL_RETURN_BAD_KEY_LENGTH_S */
+	"Bad key parity",	/* FSL_RETURN_BAD_KEY_PARITY_S */
+	"Bad data length",	/* FSL_RETURN_BAD_DATA_LENGTH_S */
+	"Authentication failed",	/* FSL_RETURN_AUTH_FAILED_S */
+	"Memory error",		/* FSL_RETURN_MEMORY_ERROR_S */
+	"Internal error",	/* FSL_RETURN_INTERNAL_ERROR_S */
+	"unknown value",	/* default */
+};
+
+#endif				/* DIAG_DRV_STATUS */
+
+/*!
+ * This lock must be held while performing any queuing or unqueuing functions,
+ * including reading the first pointer on the queue.  It also protects reading
+ * and writing the Sahara DAR register.  It must be held during a read-write
+ * operation on the DAR so that the 'test-and-set' is atomic.
+ */
+os_lock_t desc_queue_lock;
+
+/*! This is the main queue for the driver. This is shared between all threads
+ * and is not protected by mutexes since the kernel is non-preemptable. */
+sah_Queue *main_queue = NULL;
+
+/* Internal Prototypes */
+sah_Head_Desc *sah_Find_With_State(sah_Queue_Status state);
+
+#ifdef DIAG_DRV_STATUS
+void sah_Log_Error(uint32_t descriptor, uint32_t error, uint32_t fault_address);
+#endif
+
+extern wait_queue_head_t *int_queue;
+
+/*!
+ * This function initialises the Queue Manager
+ *
+ * @brief     Initialise the Queue Manager
+ *
+ * @return   FSL_RETURN_OK_S on success; FSL_RETURN_MEMORY_ERROR_S if not
+ */
+fsl_shw_return_t sah_Queue_Manager_Init(void)
+{
+	fsl_shw_return_t ret_val = FSL_RETURN_OK_S;
+
+	desc_queue_lock = os_lock_alloc_init();
+
+	if (main_queue == NULL) {
+		/* Construct the main queue. */
+		main_queue = sah_Queue_Construct();
+
+		if (main_queue == NULL) {
+			ret_val = FSL_RETURN_MEMORY_ERROR_S;
+		}
+	} else {
+#ifdef DIAG_DRV_QUEUE
+		LOG_KDIAG
+		    ("Trying to initialise the queue manager more than once.");
+#endif
+	}
+
+	return ret_val;
+}
+
+/*!
+ * This function closes the Queue Manager
+ *
+ * @brief     Close the Queue Manager
+ *
+ * @return   void
+ */
+void sah_Queue_Manager_Close(void)
+{
+#ifdef DIAG_DRV_QUEUE
+	if (main_queue && main_queue->count != 0) {
+		LOG_KDIAG
+		    ("Trying to close the main queue when it is not empty.");
+	}
+#endif
+
+	if (main_queue) {
+		/* There is no error checking here because there is no way to handle
+		   it. */
+		sah_Queue_Destroy(main_queue);
+		main_queue = NULL;
+	}
+}
+
+/*!
+ * Count the number of entries on the Queue Manager's queue
+ *
+ * @param ignore_state  If non-zero, the @a state parameter is ignored.
+ *                      If zero, only entries matching @a state are counted.
+ * @param state         State of entry to match for counting.
+ *
+ * @return        Number of entries which matched criteria
+ */
+int sah_Queue_Manager_Count_Entries(int ignore_state, sah_Queue_Status state)
+{
+	int count = 0;
+	sah_Head_Desc *current_entry;
+
+	/* Start at the head */
+	current_entry = main_queue->head;
+	while (current_entry != NULL) {
+		if (ignore_state || (current_entry->status == state)) {
+			count++;
+		}
+		/* Jump to the next entry. */
+		current_entry = current_entry->next;
+	}
+
+	return count;
+}
+
+/*!
+ * This function removes an entry from the Queue Manager's queue. The entry to
+ * be removed can be anywhere in the queue.
+ *
+ * @brief     Remove an entry from the Queue Manager's queue.
+ *
+ * @param    entry   A pointer to a sah_Head_Desc to remove from the Queue
+ *                   Manager's queue.
+ *
+ * @pre   The #desc_queue_lock must be held before calling this function.
+ *
+ * @return   void
+ */
+void sah_Queue_Manager_Remove_Entry(sah_Head_Desc * entry)
+{
+	if (entry == NULL) {
+#ifdef DIAG_DRV_QUEUE
+		LOG_KDIAG("NULL pointer input.");
+#endif
+	} else {
+		sah_Queue_Remove_Any_Entry(main_queue, entry);
+	}
+}
+
+/*!
+ * This function appends an entry to the Queue Managers queue. It primes SAHARA
+ * if this entry is the first PENDING entry in the Queue Manager's Queue.
+ *
+ * @brief     Appends an entry to the Queue Manager's queue.
+ *
+ * @param    entry   A pointer to a sah_Head_Desc to append to the Queue
+ *                   Manager's queue.
+ *
+ * @pre   The #desc_queue_lock may not may be held when calling this function.
+ *
+ * @return   void
+ */
+void sah_Queue_Manager_Append_Entry(sah_Head_Desc * entry)
+{
+	sah_Head_Desc *current_entry;
+	os_lock_context_t int_flags;
+
+#ifdef DIAG_DRV_QUEUE
+	if (entry == NULL) {
+		LOG_KDIAG("NULL pointer input.");
+	}
+#endif
+	entry->status = SAH_STATE_PENDING;
+	os_lock_save_context(desc_queue_lock, int_flags);
+	sah_Queue_Append_Entry(main_queue, entry);
+
+	/* Prime SAHARA if the operation that was just appended is the only PENDING
+	 * operation in the queue.
+	 */
+	current_entry = sah_Find_With_State(SAH_STATE_PENDING);
+	if (current_entry != NULL) {
+		if (current_entry == entry) {
+			sah_Queue_Manager_Prime(entry);
+		}
+	}
+
+	os_unlock_restore_context(desc_queue_lock, int_flags);
+}
+
+/*!
+ * This function marks all entries in the Queue Manager's queue with state
+ * SAH_STATE_RESET.
+ *
+ * @brief     Mark all entries with state SAH_STATE_RESET
+ *
+ * @return   void
+ *
+ * @note This feature needs re-visiting
+ */
+void sah_Queue_Manager_Reset_Entries(void)
+{
+	sah_Head_Desc *current_entry = NULL;
+
+	/* Start at the head */
+	current_entry = main_queue->head;
+
+	while (current_entry != NULL) {
+		/* Set the state. */
+		current_entry->status = SAH_STATE_RESET;
+		/* Jump to the next entry. */
+		current_entry = current_entry->next;
+	}
+}
+
+/*!
+ * This function primes SAHARA for the first time or after the queue becomes
+ * empty. Queue lock must have been set by the caller of this routine.
+ *
+ * @brief    Prime SAHARA.
+ *
+ * @param    entry   A pointer to a sah_Head_Desc to Prime SAHARA with.
+ *
+ * @return   void
+ */
+void sah_Queue_Manager_Prime(sah_Head_Desc * entry)
+{
+#ifdef DIAG_DRV_QUEUE
+	LOG_KDIAG("Priming SAHARA");
+	if (entry == NULL) {
+		LOG_KDIAG("Trying to prime SAHARA with a NULL entry pointer.");
+	}
+#endif
+
+#ifndef SUBMIT_MULTIPLE_DARS
+	/* BUG FIX: state machine can transition from Done1 Busy2 directly
+	 * to Idle. To fix that problem, only one DAR is being allowed on
+	 * SAHARA at a time */
+	if (sah_Find_With_State(SAH_STATE_ON_SAHARA) != NULL) {
+		return;
+	}
+#endif
+
+#ifdef SAHARA_POWER_MANAGEMENT
+	/* check that dynamic power management is not asserted */
+    if (!sah_dpm_flag) {
+#endif
+
+	/* Enable the SAHARA Clocks */
+#ifdef DIAG_DRV_IF
+			LOG_KDIAG("SAHARA : Enabling the IPG and AHB clocks\n")
+#endif				/*DIAG_DRV_IF */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+		mxc_clks_enable(SAHARA2_CLK);
+#else
+		{
+			struct clk *clk = clk_get(NULL, "sahara_clk");
+			if (!IS_ERR(clk))
+				clk_enable(clk);
+			clk_put(clk);
+		}
+#endif
+
+		/* Make sure nothing is in the DAR */
+		if (sah_HW_Read_DAR() == 0) {
+#if defined(DIAG_DRV_IF)
+			sah_Dump_Chain(&entry->desc, entry->desc.dma_addr);
+#endif				/* DIAG_DRV_IF */
+
+			sah_HW_Write_DAR((entry->desc.dma_addr));
+			entry->status = SAH_STATE_ON_SAHARA;
+		}
+#ifdef DIAG_DRV_QUEUE
+		else {
+			LOG_KDIAG("DAR should be empty when Priming SAHARA");
+		}
+#endif
+#ifdef SAHARA_POWER_MANAGEMENT
+	}
+#endif
+}
+
+#ifndef SAHARA_POLL_MODE
+
+/*!
+ * Reset SAHARA, then load the next descriptor on it, if one exists
+ */
+void sah_reset_sahara_request(void)
+{
+	sah_Head_Desc *desc;
+	os_lock_context_t lock_flags;
+
+#ifdef DIAG_DRV_STATUS
+	LOG_KDIAG("Sahara required reset from tasklet, replace chip");
+#endif
+	sah_HW_Reset();
+
+	/* Now stick in a waiting request */
+	os_lock_save_context(desc_queue_lock, lock_flags);
+	if ((desc = sah_Find_With_State(SAH_STATE_PENDING))) {
+		sah_Queue_Manager_Prime(desc);
+	}
+	os_unlock_restore_context(desc_queue_lock, lock_flags);
+}
+
+/*!
+ * Post-process a descriptor chain after the hardware has finished with it.
+ *
+ * The status of the descriptor could also be checked.  (for FATAL or IGNORED).
+ *
+ * @param     desc_head   The finished chain
+ * @param     error       A boolean to mark whether hardware reported error
+ *
+ * @pre   The #desc_queue_lock may not be held when calling this function.
+ */
+void sah_process_finished_request(sah_Head_Desc * desc_head, unsigned error)
+{
+	os_lock_context_t lock_flags;
+
+	if (!error) {
+		desc_head->result = FSL_RETURN_OK_S;
+	} else if (desc_head->error_status == -1) {
+		/* Disaster!  Sahara has faulted */
+		desc_head->result = FSL_RETURN_ERROR_S;
+	} else {
+		/* translate from SAHARA error status to fsl_shw return values */
+		desc_head->result =
+		    sah_convert_error_status(desc_head->error_status);
+#ifdef DIAG_DRV_STATUS
+		sah_Log_Error(desc_head->desc.dma_addr, desc_head->error_status,
+			      desc_head->fault_address);
+#endif
+	}
+
+	/* Show that the request has been processd */
+	desc_head->status = error ? SAH_STATE_FAILED : SAH_STATE_COMPLETE;
+
+	if (desc_head->uco_flags & FSL_UCO_BLOCKING_MODE) {
+
+		/* Wake up all processes on Sahara queue */
+		wake_up_interruptible(int_queue);
+
+	} else {
+		os_lock_save_context(desc_queue_lock, lock_flags);
+		sah_Queue_Append_Entry(&desc_head->user_info->result_pool,
+				       desc_head);
+		os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+		/* perform callback */
+		if (desc_head->uco_flags & FSL_UCO_CALLBACK_MODE) {
+			desc_head->user_info->callback(desc_head->user_info);
+		}
+	}
+}				/* sah_process_finished_request */
+
+/*! Called from bottom half.
+ *
+ * @pre   The #desc_queue_lock may not be held when calling this function.
+ */
+void sah_postprocess_queue(unsigned long reset_flag)
+{
+
+	sah_Head_Desc *first_entry;
+	os_lock_context_t lock_flags;
+
+    /* Disabling Sahara Clock only if the hardware is in idle state and
+	    the DAR queue is empty.*/
+	os_lock_save_context(desc_queue_lock, lock_flags);
+	first_entry = sah_Find_With_State(SAH_STATE_ON_SAHARA);
+	os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+	if ((first_entry == NULL) && (sah_HW_Read_Status() == SAH_EXEC_IDLE)) {
+
+#ifdef DIAG_DRV_IF
+		LOG_KDIAG("SAHARA : Disabling the clocks\n")
+#endif				/* DIAG_DRV_IF */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+		mxc_clks_disable(SAHARA2_CLK);
+#else
+		{
+			struct clk *clk = clk_get(NULL, "sahara_clk");
+			if (!IS_ERR(clk))
+				clk_disable(clk);
+			clk_put(clk);
+		}
+#endif
+
+	}
+
+
+	/* if SAHARA needs to be reset, do it here. This starts a descriptor chain
+	 * if one is ready also */
+	if (reset_flag) {
+		sah_reset_sahara_request();
+	}
+
+	/* now handle the descriptor chain(s) that has/have completed */
+	do {
+
+		os_lock_save_context(desc_queue_lock, lock_flags);
+
+		first_entry = main_queue->head;
+		if ((first_entry != NULL) &&
+		    (first_entry->status == SAH_STATE_OFF_SAHARA)) {
+			sah_Queue_Remove_Entry(main_queue);
+			os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+			sah_process_finished_request(first_entry,
+						     (first_entry->
+						      error_status != 0));
+		} else {
+			os_unlock_restore_context(desc_queue_lock, lock_flags);
+			break;
+		}
+	} while (1);
+
+	return;
+}
+
+#endif				/* ifndef SAHARA_POLL_MODE */
+
+/*!
+ * This is a helper function for Queue Manager. This function finds the first
+ * entry in the Queue Manager's queue whose state matches the given input
+ * state. This function starts at the head of the queue and works towards the
+ * tail. If a matching entry was found, the address of the entry is returned.
+ *
+ * @brief     Handle the IDLE state.
+ *
+ * @param    state   A sah_Queue_Status value.
+ *
+ * @pre   The #desc_queue_lock must be held before calling this function.
+ *
+ * @return   A pointer to a sah_Head_Desc that matches the given state.
+ * @return   NULL otherwise.
+ */
+sah_Head_Desc *sah_Find_With_State(sah_Queue_Status state)
+{
+	sah_Head_Desc *current_entry = NULL;
+	sah_Head_Desc *ret_val = NULL;
+	int done_looping = FALSE;
+
+	/* Start at the head */
+	current_entry = main_queue->head;
+
+	while ((current_entry != NULL) && (done_looping == FALSE)) {
+		if (current_entry->status == state) {
+			done_looping = TRUE;
+			ret_val = current_entry;
+		}
+		/* Jump to the next entry. */
+		current_entry = current_entry->next;
+	}
+
+	return ret_val;
+}				/* sah_postprocess_queue */
+
+/*!
+ * Process the value from the Sahara error status register and convert it into
+ * an FSL SHW API error code.
+ *
+ * Warning, this routine must only be called if an error exists.
+ *
+ * @param error_status   The value from the error status register.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_convert_error_status(uint32_t error_status)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;	/* catchall */
+	uint8_t error_source;
+	uint8_t DMA_error_status;
+	uint8_t DMA_error_size;
+
+	/* get the error source from the error status register */
+	error_source = error_status & SAH_ERROR_MASK;
+
+	/* array size is maximum allowed by mask, so no boundary checking is
+	 * needed here */
+	ret = sah_Execute_Error_Array[error_source];
+
+	/* is this one that needs additional fields checked to determine the
+	 * error condition? */
+	if (ret == SHA_ERROR_STATUS_CONTINUE) {
+		/* check the DMA fields */
+		if (error_source == SAH_ERR_DMA) {
+			/* get the DMA transfer error size. If this indicates that no
+			 * error was detected, something is seriously wrong */
+			DMA_error_size =
+			    (error_status >> 9) & SAH_DMA_ERR_SIZE_MASK;
+			if (DMA_error_size == SAH_DMA_NO_ERR) {
+				ret = FSL_RETURN_INTERNAL_ERROR_S;
+			} else {
+				/* get DMA error status */
+				DMA_error_status = (error_status >> 12) &
+				    SAH_DMA_ERR_STATUS_MASK;
+
+				/* the DMA error bits cover all the even numbers. By dividing
+				 * by 2 it can be used as an index into the error array */
+				ret =
+				    sah_DMA_Error_Status_Array[DMA_error_status
+							       >> 1];
+			}
+		} else {	/* not SAH_ERR_DMA, so must be SAH_ERR_CHA */
+			uint16_t CHA_error_status;
+			uint8_t CHA_error_source;
+
+			/* get CHA Error Source. If this indicates that no error was
+			 * detected, something is seriously wrong */
+			CHA_error_source =
+			    (error_status >> 28) & SAH_CHA_ERR_SOURCE_MASK;
+			if (CHA_error_source == SAH_CHA_NO_ERROR) {
+				ret = FSL_RETURN_INTERNAL_ERROR_S;
+			} else {
+				uint32_t mask = 1;
+				uint32_t count = 0;
+
+				/* get CHA Error Status */
+				CHA_error_status = (error_status >> 16) &
+				    SAH_CHA_ERR_STATUS_MASK;
+
+				/* If more than one bit is set (which shouldn't happen), only
+				 * the first will be captured */
+				if (CHA_error_status != 0) {
+					count = 1;
+					while (CHA_error_status != mask) {
+						++count;
+						mask <<= 1;
+					}
+				}
+
+				ret = sah_CHA_Error_Status_Array[count];
+			}
+		}
+	}
+
+	return ret;
+}
+
+fsl_shw_return_t sah_convert_op_status(uint32_t op_status)
+{
+	unsigned op_source = (op_status >> 28) & 0x7;
+	unsigned op_detail = op_status & 0x3f;
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	switch (op_source) {
+	case 1:		/* SKHA */
+		/* Can't this have "ICV" error from CCM ?? */
+		break;
+	case 2:		/* MDHA */
+		if (op_detail == 1) {
+			ret = FSL_RETURN_AUTH_FAILED_S;
+		}
+		break;
+	case 3:		/* RNGA */
+		/* Self-test and Compare errors... what to do? */
+		break;
+	case 4:		/* PKHA */
+		switch (op_detail) {
+		case 0x01:
+			ret = FSL_RETURN_PRIME_S;
+			break;
+		case 0x02:
+			ret = FSL_RETURN_NOT_PRIME_S;
+			break;
+		case 0x04:
+			ret = FSL_RETURN_POINT_AT_INFINITY_S;
+			break;
+		case 0x08:
+			ret = FSL_RETURN_POINT_NOT_AT_INFINITY_S;
+			break;
+		case 0x10:
+			ret = FSL_RETURN_GCD_IS_ONE_S;
+			break;
+		case 0x20:
+			ret = FSL_RETURN_GCD_IS_NOT_ONE_S;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+#ifdef DIAG_DRV_STATUS
+
+/*!
+ * This function logs the diagnostic information for the given error and
+ * descriptor address.  Only used for diagnostic purposes.
+ *
+ * @brief    (debug only) Log a description of hardware-detected error.
+ *
+ * @param    descriptor    The descriptor address that caused the error
+ * @param    error         The SAHARA error code
+ * @param    fault_address Value from the Fault address register
+ *
+ * @return   void
+ */
+void sah_Log_Error(uint32_t descriptor, uint32_t error, uint32_t fault_address)
+{
+	char *source_text;	/* verbose error source from register */
+	char *address;		/* string buffer for descriptor address */
+	char *error_log;	/* the complete logging message */
+	char *cha_log = NULL;	/* string buffer for descriptor address */
+	char *dma_log = NULL;	/* string buffer for descriptor address */
+
+	uint16_t cha_error = 0;
+	uint16_t dma_error = 0;
+
+	uint8_t error_source;
+	sah_Execute_Error return_code;
+
+	/* log error code and descriptor address */
+	error_source = error & SAH_ERROR_MASK;
+	return_code = sah_Execute_Error_Array[error_source];
+
+	source_text = os_alloc_memory(64, GFP_KERNEL);
+
+	switch (error_source) {
+	case SAH_ERR_HEADER:
+		sprintf(source_text, "%s", "Header is not valid");
+		break;
+
+	case SAH_ERR_DESC_LENGTH:
+		sprintf(source_text, "%s",
+			"Descriptor length not equal to sum of link lengths");
+		break;
+
+	case SAH_ERR_DESC_POINTER:
+		sprintf(source_text, "%s", "Length or pointer "
+			"field is zero while the other is non-zero");
+		break;
+
+	case SAH_ERR_LINK_LENGTH:
+		/* note that the Sahara Block Guide 2.7 has an invalid explaination
+		 * of this. It only happens when a link length is zero */
+		sprintf(source_text, "%s", "A data length is a link is zero");
+		break;
+
+	case SAH_ERR_LINK_POINTER:
+		sprintf(source_text, "%s",
+			"The data pointer in a link is zero");
+		break;
+
+	case SAH_ERR_INPUT_BUFFER:
+		sprintf(source_text, "%s", "Input Buffer reported an overflow");
+		break;
+
+	case SAH_ERR_OUTPUT_BUFFER:
+		sprintf(source_text, "%s",
+			"Output Buffer reported an underflow");
+		break;
+
+	case SAH_ERR_OUTPUT_BUFFER_STARVATION:
+		sprintf(source_text, "%s", "Incorrect data in output "
+			"buffer after CHA has signalled 'done'");
+		break;
+
+	case SAH_ERR_INTERNAL_STATE:
+		sprintf(source_text, "%s", "Internal Hardware Failure");
+		break;
+
+	case SAH_ERR_GENERAL_DESCRIPTOR:
+		sprintf(source_text, "%s",
+			"Current Descriptor was not legal, but cause is unknown");
+		break;
+
+	case SAH_ERR_RESERVED_FIELDS:
+		sprintf(source_text, "%s",
+			"Reserved pointer field is non-zero");
+		break;
+
+	case SAH_ERR_DESCRIPTOR_ADDRESS:
+		sprintf(source_text, "%s",
+			"Descriptor address not word aligned");
+		break;
+
+	case SAH_ERR_LINK_ADDRESS:
+		sprintf(source_text, "%s", "Link address not word aligned");
+		break;
+
+	case SAH_ERR_CHA:
+		sprintf(source_text, "%s", "CHA Error");
+		{
+			char *cha_module = os_alloc_memory(5, GFP_KERNEL);
+			char *cha_text = os_alloc_memory(45, GFP_KERNEL);
+
+			cha_error = (error >> 28) & SAH_CHA_ERR_SOURCE_MASK;
+
+			switch (cha_error) {
+			case SAH_CHA_SKHA_ERROR:
+				sprintf(cha_module, "%s", "SKHA");
+				break;
+
+			case SAH_CHA_MDHA_ERROR:
+				sprintf(cha_module, "%s", "MDHA");
+				break;
+
+			case SAH_CHA_RNG_ERROR:
+				sprintf(cha_module, "%s", "RNG ");
+				break;
+
+			case SAH_CHA_PKHA_ERROR:
+				sprintf(cha_module, "%s", "PKHA");
+				break;
+
+			case SAH_CHA_NO_ERROR:
+				/* can't happen */
+				/* no break */
+			default:
+				sprintf(cha_module, "%s", "????");
+				break;
+			}
+
+			cha_error = (error >> 16) & SAH_CHA_ERR_STATUS_MASK;
+
+			/* Log CHA Error Status */
+			switch (cha_error) {
+			case SAH_CHA_IP_BUF:
+				sprintf(cha_text, "%s",
+					"Non-empty input buffer when done");
+				break;
+
+			case SAH_CHA_ADD_ERR:
+				sprintf(cha_text, "%s", "Illegal address");
+				break;
+
+			case SAH_CHA_MODE_ERR:
+				sprintf(cha_text, "%s", "Illegal mode");
+				break;
+
+			case SAH_CHA_DATA_SIZE_ERR:
+				sprintf(cha_text, "%s", "Illegal data size");
+				break;
+
+			case SAH_CHA_KEY_SIZE_ERR:
+				sprintf(cha_text, "%s", "Illegal key size");
+				break;
+
+			case SAH_CHA_PROC_ERR:
+				sprintf(cha_text, "%s",
+					"Mode/Context/Key written during processing");
+				break;
+
+			case SAH_CHA_CTX_READ_ERR:
+				sprintf(cha_text, "%s",
+					"Context read during processing");
+				break;
+
+			case SAH_CHA_INTERNAL_HW_ERR:
+				sprintf(cha_text, "%s", "Internal hardware");
+				break;
+
+			case SAH_CHA_IP_BUFF_ERR:
+				sprintf(cha_text, "%s",
+					"Input buffer not enabled or underflow");
+				break;
+
+			case SAH_CHA_OP_BUFF_ERR:
+				sprintf(cha_text, "%s",
+					"Output buffer not enabled or overflow");
+				break;
+
+			case SAH_CHA_DES_KEY_ERR:
+				sprintf(cha_text, "%s", "DES key parity error");
+				break;
+
+			case SAH_CHA_RES:
+				sprintf(cha_text, "%s", "Reserved");
+				break;
+
+			case SAH_CHA_NO_ERR:
+				/* can't happen */
+				/* no break */
+			default:
+				sprintf(cha_text, "%s", "Unknown error");
+				break;
+			}
+
+			cha_log = os_alloc_memory(90, GFP_KERNEL);
+			sprintf(cha_log,
+				"  Module %s encountered the error: %s.",
+				cha_module, cha_text);
+
+			os_free_memory(cha_module);
+			os_free_memory(cha_text);
+
+			{
+				uint32_t mask = 1;
+				uint32_t count = 0;
+
+				if (cha_error != 0) {
+					count = 1;
+					while (cha_error != mask) {
+						++count;
+						mask <<= 1;
+					}
+				}
+
+				return_code = sah_CHA_Error_Status_Array[count];
+			}
+			cha_error = 1;
+		}
+		break;
+
+	case SAH_ERR_DMA:
+		sprintf(source_text, "%s", "DMA Error");
+		{
+			char *dma_direction = os_alloc_memory(6, GFP_KERNEL);
+			char *dma_size = os_alloc_memory(14, GFP_KERNEL);
+			char *dma_text = os_alloc_memory(250, GFP_KERNEL);
+
+			if ((dma_direction == NULL) || (dma_size == NULL) ||
+			    (dma_text == NULL)) {
+				LOG_KDIAG
+				    ("No memory allocated for DMA debug messages\n");
+			}
+
+			/* log DMA error direction */
+			sprintf(dma_direction, "%s",
+				(((error >> 8) & SAH_DMA_ERR_DIR_MASK) == 1) ?
+				"read" : "write");
+
+			/* log the size of the DMA transfer error */
+			dma_error = (error >> 9) & SAH_DMA_ERR_SIZE_MASK;
+			switch (dma_error) {
+			case SAH_DMA_SIZE_BYTE:
+				sprintf(dma_size, "%s", "byte");
+				break;
+
+			case SAH_DMA_SIZE_HALF_WORD:
+				sprintf(dma_size, "%s", "half-word");
+				break;
+
+			case SAH_DMA_SIZE_WORD:
+				sprintf(dma_size, "%s", "word");
+				break;
+
+			case SAH_DMA_SIZE_RES:
+				sprintf(dma_size, "%s", "reserved size");
+				break;
+
+			default:
+				sprintf(dma_size, "%s", "unknown size");
+				break;
+			}
+
+			/* log DMA error status */
+			dma_error = (error >> 12) & SAH_DMA_ERR_STATUS_MASK;
+			switch (dma_error) {
+			case SAH_DMA_NO_ERR:
+				sprintf(dma_text, "%s", "No DMA Error Code");
+				break;
+
+			case SAH_DMA_AHB_ERR:
+				sprintf(dma_text, "%s",
+					"AHB terminated a bus cycle with an error");
+				break;
+
+			case SAH_DMA_IP_ERR:
+				sprintf(dma_text, "%s",
+					"Internal IP bus cycle was terminated with an "
+					"error termination. This would likely be "
+					"caused by a descriptor length being too "
+					"large, and thus accessing an illegal "
+					"internal address. Verify the length field "
+					"of the current descriptor");
+				break;
+
+			case SAH_DMA_PARITY_ERR:
+				sprintf(dma_text, "%s",
+					"Parity error detected on DMA command from "
+					"Descriptor Decoder. Cause is likely to be "
+					"internal hardware fault");
+				break;
+
+			case SAH_DMA_BOUNDRY_ERR:
+				sprintf(dma_text, "%s",
+					"DMA was requested to cross a 256 byte "
+					"internal address boundary. Cause is likely a "
+					"descriptor length being too large, thus "
+					"accessing two different internal hardware "
+					"blocks");
+				break;
+
+			case SAH_DMA_BUSY_ERR:
+				sprintf(dma_text, "%s",
+					"Descriptor Decoder has made a DMA request "
+					"while the DMA controller is busy. Cause is "
+					"likely due to hardware fault");
+				break;
+
+			case SAH_DMA_RESERVED_ERR:
+				sprintf(dma_text, "%s", "Reserved");
+				break;
+
+			case SAH_DMA_INT_ERR:
+				sprintf(dma_text, "%s",
+					"Internal DMA hardware error detected. The "
+					"DMA controller has detected an internal "
+					"condition which should never occur");
+				break;
+
+			default:
+				sprintf(dma_text, "%s",
+					"Unknown DMA Error Status Code");
+				break;
+			}
+
+			return_code =
+			    sah_DMA_Error_Status_Array[dma_error >> 1];
+			dma_error = 1;
+
+			dma_log = os_alloc_memory(320, GFP_KERNEL);
+			sprintf(dma_log,
+				"  Occurred during a %s operation of a %s transfer: %s.",
+				dma_direction, dma_size, dma_text);
+
+			os_free_memory(dma_direction);
+			os_free_memory(dma_size);
+			os_free_memory(dma_text);
+		}
+		break;
+
+	case SAH_ERR_NONE:
+	default:
+		sprintf(source_text, "%s", "Unknown Error Code");
+		break;
+	}
+
+	address = os_alloc_memory(35, GFP_KERNEL);
+
+	/* convert error & descriptor address to strings */
+	if (dma_error) {
+		sprintf(address, "Fault address is 0x%08x", fault_address);
+	} else {
+		sprintf(address, "Descriptor bus address is 0x%08x",
+			descriptor);
+	}
+
+	if (return_code > FSL_INVALID_RETURN) {
+		return_code = FSL_INVALID_RETURN;
+	}
+
+	error_log = os_alloc_memory(250, GFP_KERNEL);
+
+	/* construct final log message */
+	sprintf(error_log, "Error source = 0x%08x. Return = %s. %s. %s.",
+		error, sah_return_text[return_code], address, source_text);
+
+	os_free_memory(source_text);
+	os_free_memory(address);
+
+	/* log standard messages */
+	LOG_KDIAG(error_log);
+	os_free_memory(error_log);
+
+	/* add additional information if available */
+	if (cha_error) {
+		LOG_KDIAG(cha_log);
+		os_free_memory(cha_log);
+	}
+
+	if (dma_error) {
+		LOG_KDIAG(dma_log);
+		os_free_memory(dma_log);
+	}
+
+	return;
+}				/* sah_Log_Error */
+
+#endif				/* DIAG_DRV_STATUS */
+
+/* End of sah_queue_manager.c */
diff --git a/drivers/mxc/security/sahara2/sah_status_manager.c b/drivers/mxc/security/sahara2/sah_status_manager.c
new file mode 100644
index 0000000..f881b47
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sah_status_manager.c
@@ -0,0 +1,714 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+* @file sah_status_manager.c
+*
+* @brief Status Manager Function
+*
+* This file contains the function which processes the Sahara status register
+* during an interrupt.
+*
+* This file does not need porting.
+*/
+
+#include "portable_os.h"
+
+#include <sah_status_manager.h>
+#include <sah_hardware_interface.h>
+#include <sah_queue_manager.h>
+#include <sah_memory_mapper.h>
+#include <sah_kernel.h>
+
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+#include <diagnostic.h>
+#endif
+
+/*! Compile-time flag to count various interrupt types. */
+#define DIAG_INT_COUNT
+
+/*!
+ * Number of interrupts processed with Done1Done2 status.  Updates to this
+ * value should only be done in interrupt processing.
+ */
+uint32_t done1_count;
+
+/*!
+ * Number of interrupts processed with Done1Busy2 status.  Updates to this
+ * value should only be done in interrupt processing.
+ */
+uint32_t done1busy2_count;
+
+/*!
+ * Number of interrupts processed with Done1Done2 status.  Updates to this
+ * value should only be done in interrupt processing.
+ */
+uint32_t done1done2_count;
+
+/*!
+ * the dynameic power management flag is false when power management is not
+ * asserted and true when dpm is.
+ */
+#ifdef SAHARA_POWER_MANAGEMENT
+bool sah_dpm_flag = FALSE;
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int sah_dpm_suspend(struct device *dev, uint32_t state, uint32_t level);
+static int sah_dpm_resume(struct device *dev, uint32_t level);
+#else
+static int sah_dpm_suspend(struct platform_device *dev, pm_message_t state);
+static int sah_dpm_resume(struct platform_device *dev);
+#endif
+#endif
+
+#ifndef SAHARA_POLL_MODE
+/*!
+*******************************************************************************
+* This functionx processes the status register of the Sahara, updates the state
+* of the finished queue entry, and then tries to find more work for Sahara to
+* do.
+*
+* @brief    The bulk of the interrupt handling code.
+*
+* @param   hw_status     The status register of Sahara at time of interrupt.
+*                        The Clear interrupt bit is already handled by this
+*                        register read prior to entry into this function.
+* @return   void
+*/
+unsigned long sah_Handle_Interrupt(sah_Execute_Status hw_status)
+{
+	unsigned long reset_flag = 0;	/* assume no SAHARA reset needed */
+	os_lock_context_t lock_flags;
+	sah_Head_Desc *current_entry;
+
+	/* HW status at time of interrupt */
+	sah_Execute_Status state = hw_status & SAH_EXEC_STATE_MASK;
+
+	do {
+		uint32_t dar;
+
+#ifdef DIAG_INT_COUNT
+		if (state == SAH_EXEC_DONE1) {
+			done1_count++;
+		} else if (state == SAH_EXEC_DONE1_BUSY2) {
+			done1busy2_count++;
+		} else if (state == SAH_EXEC_DONE1_DONE2) {
+			done1done2_count++;
+		}
+#endif
+
+		/* if the first entry on sahara has completed... */
+		if ((state & SAH_EXEC_DONE1_BIT) ||
+		    (state == SAH_EXEC_ERROR1)) {
+			/* lock queue while searching */
+			os_lock_save_context(desc_queue_lock, lock_flags);
+			current_entry =
+			    sah_Find_With_State(SAH_STATE_ON_SAHARA);
+			os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+			/* an active descriptor was not found */
+			if (current_entry == NULL) {
+				/* change state to avoid an infinite loop (possible if
+				 * state is SAH_EXEC_DONE1_BUSY2 first time into loop) */
+				hw_status = SAH_EXEC_IDLE;
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+				LOG_KDIAG
+				    ("Interrupt received with nothing on queue.");
+#endif
+			} else {
+				/* SAHARA has completed its work on this descriptor chain */
+				current_entry->status = SAH_STATE_OFF_SAHARA;
+
+				if (state == SAH_EXEC_ERROR1) {
+				   if (hw_status & STATUS_ERROR) {
+					  /* Gather extra diagnostic information */
+					  current_entry->fault_address =
+					    sah_HW_Read_Fault_Address();
+					  /* Read this last - it clears the error */
+					  current_entry->error_status =
+					    sah_HW_Read_Error_Status();
+					  current_entry->op_status = 0;
+#ifdef FSL_HAVE_SAHARA4
+				   } else {
+					  current_entry->op_status =
+							sah_HW_Read_Op_Status();
+					  current_entry->error_status = 0;
+#endif
+				   }
+
+				} else {
+					/* indicate that no errors were found with descriptor
+					 * chain 1 */
+					current_entry->error_status = 0;
+					current_entry->op_status = 0;
+
+					/* is there a second, successfully, completed descriptor
+					 * chain? (done1/error2 processing is handled later) */
+					if (state == SAH_EXEC_DONE1_DONE2) {
+						os_lock_save_context
+						    (desc_queue_lock,
+						     lock_flags);
+						current_entry =
+						    sah_Find_With_State
+						    (SAH_STATE_ON_SAHARA);
+						os_unlock_restore_context
+						    (desc_queue_lock,
+						     lock_flags);
+
+						if (current_entry == NULL) {
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+							LOG_KDIAG
+							    ("Done1_Done2 Interrupt received with "
+							     "one entry on queue.");
+#endif
+						} else {
+							/* indicate no errors in descriptor chain 2 */
+							current_entry->
+							    error_status = 0;
+							current_entry->status =
+							    SAH_STATE_OFF_SAHARA;
+						}
+					}
+				}
+			}
+
+#ifdef SAHARA_POWER_MANAGEMENT
+			/* check dynamic power management is not asserted */
+			if (!sah_dpm_flag) {
+#endif
+				do {
+					/* protect DAR and main_queue */
+					os_lock_save_context(desc_queue_lock,
+							     lock_flags);
+					dar = sah_HW_Read_DAR();
+					/* check if SAHARA has space for another descriptor. SAHARA
+					 * only accepts up to the DAR queue size number of DAR
+					 * entries, after that 'dar' will not be zero until the
+					 * pending interrupt is serviced */
+					if (dar == 0) {
+						current_entry =
+						    sah_Find_With_State
+						    (SAH_STATE_PENDING);
+						if (current_entry != NULL) {
+#ifndef SUBMIT_MULTIPLE_DARS
+							/* BUG FIX: state machine can transition from Done1
+							 * Busy2 directly to Idle. To fix that problem,
+							 * only one DAR is being allowed on SAHARA at a
+							 * time.  If a high level interrupt has happened,
+							 * there could * be an active descriptor chain */
+							if (sah_Find_With_State
+							    (SAH_STATE_ON_SAHARA)
+							    == NULL) {
+#endif
+#if defined(DIAG_DRV_IF) && defined(DIAG_DURING_INTERRUPT)
+								sah_Dump_Chain
+								    (&current_entry->
+								     desc,
+								     current_entry->
+								     desc.
+								     dma_addr);
+#endif				/* DIAG_DRV_IF */
+								sah_HW_Write_DAR
+								    (current_entry->
+								     desc.
+								     dma_addr);
+								current_entry->
+								    status =
+								    SAH_STATE_ON_SAHARA;
+#ifndef SUBMIT_MULTIPLE_DARS
+							}
+							current_entry = NULL;	/* exit loop */
+#endif
+						}
+					}
+					os_unlock_restore_context
+					    (desc_queue_lock, lock_flags);
+				} while ((dar == 0) && (current_entry != NULL));
+#ifdef SAHARA_POWER_MANAGEMENT
+			}	/* sah_device_power_manager */
+#endif
+		} else {
+			if (state == SAH_EXEC_FAULT) {
+				sah_Head_Desc *previous_entry;	/* point to chain 1 */
+				/* Address of request when fault occured */
+				uint32_t bad_dar = sah_HW_Read_IDAR();
+
+				reset_flag = 1;	/* SAHARA needs to be reset */
+
+				/* get first of possible two descriptor chain that was
+				 * on SAHARA */
+				os_lock_save_context(desc_queue_lock,
+						     lock_flags);
+				previous_entry =
+				    sah_Find_With_State(SAH_STATE_ON_SAHARA);
+				os_unlock_restore_context(desc_queue_lock,
+							  lock_flags);
+
+				/* if it exists, continue processing the fault */
+				if (previous_entry) {
+					/* assume this chain didn't complete correctly */
+					previous_entry->error_status = -1;
+					previous_entry->status =
+					    SAH_STATE_OFF_SAHARA;
+
+					/* get the second descriptor chain */
+					os_lock_save_context(desc_queue_lock,
+							     lock_flags);
+					current_entry =
+					    sah_Find_With_State
+					    (SAH_STATE_ON_SAHARA);
+					os_unlock_restore_context
+					    (desc_queue_lock, lock_flags);
+
+					/* if it exists, continue processing both chains */
+					if (current_entry) {
+						/* assume this chain didn't complete correctly */
+						current_entry->error_status =
+						    -1;
+						current_entry->status =
+						    SAH_STATE_OFF_SAHARA;
+
+						/* now see if either can be identified as the one
+						 * in progress when the fault occured */
+						if (current_entry->desc.
+						    dma_addr == bad_dar) {
+							/* the second descriptor chain was active when the
+							 * fault occured, so the first descriptor chain
+							 * was successfull */
+							previous_entry->
+							    error_status = 0;
+						} else {
+							if (previous_entry->
+							    desc.dma_addr ==
+							    bad_dar) {
+								/* if the first chain was in progress when the
+								 * fault occured, the second has not yet been
+								 * touched, so reset it to PENDING */
+								current_entry->
+								    status =
+								    SAH_STATE_PENDING;
+							}
+						}
+					}
+				}
+#if defined(DIAG_DRV_INTERRUPT) && defined(DIAG_DURING_INTERRUPT)
+			} else {
+				/* shouldn't ever get here */
+				if (state == SAH_EXEC_BUSY) {
+					LOG_KDIAG
+					    ("Got Sahara interrupt in Busy state");
+				} else {
+					if (state == SAH_EXEC_IDLE) {
+						LOG_KDIAG
+						    ("Got Sahara interrupt in Idle state");
+					} else {
+						LOG_KDIAG
+						    ("Got Sahara interrupt in unknown state");
+					}
+				}
+#endif
+			}
+		}
+
+		/* haven't handled the done1/error2 (the error 2 part), so setup to
+		 * do that now. Otherwise, exit loop */
+		state = (state == SAH_EXEC_DONE1_ERROR2) ?
+		    SAH_EXEC_ERROR1 : SAH_EXEC_IDLE;
+
+		/* Keep going while further status is available. */
+	} while (state == SAH_EXEC_ERROR1);
+
+	return reset_flag;
+}
+
+#endif				/* ifndef SAHARA_POLL_MODE */
+
+#ifdef SAHARA_POLL_MODE
+/*!
+*******************************************************************************
+* Submits descriptor chain to SAHARA, polls on SAHARA for completion, process
+* results, and dephysicalizes chain
+*
+* @brief     Handle poll mode.
+*
+* @param    entry   Virtual address of a physicalized chain
+*
+* @return   0      this function is always successful
+*/
+
+unsigned long sah_Handle_Poll(sah_Head_Desc * entry)
+{
+	sah_Execute_Status hw_status;	/* Sahara's status register */
+	os_lock_context_t lock_flags;
+
+	/* lock SARAHA */
+	os_lock_save_context(desc_queue_lock, lock_flags);
+
+#ifdef SAHARA_POWER_MANAGEMENT
+	/* check if the dynamic power management is asserted */
+	if (sah_dpm_flag) {
+		/* return that request failed to be processed */
+		entry->result = FSL_RETURN_ERROR_S;
+		entry->fault_address = 0xBAD;
+		entry->op_status= 0xBAD;
+		entry->error_status = 0xBAD;
+	} else {
+#endif				/* SAHARA_POWER_MANAGEMENT */
+
+#if defined(DIAG_DRV_IF)
+		sah_Dump_Chain(&entry->desc, entry->desc.dma_addr);
+#endif				/* DIAG_DRV_IF */
+		/* Nothing can be in the dar if we got the lock */
+		sah_HW_Write_DAR((uint32_t) (entry->desc.dma_addr));
+
+		/* Wait for SAHARA to finish with this entry */
+		hw_status = sah_Wait_On_Sahara();
+
+		/* if entry completed successfully, mark it as such */
+	/**** HARDWARE ERROR WORK AROUND (hw_status == SAH_EXEC_IDLE) *****/
+		if (
+#ifndef SUBMIT_MULTIPLE_DARS
+			   (hw_status == SAH_EXEC_IDLE) || (hw_status == SAH_EXEC_DONE1_BUSY2) ||	/* should not happen */
+#endif
+			   (hw_status == SAH_EXEC_DONE1)
+		    ) {
+			entry->error_status = 0;
+			entry->result = FSL_RETURN_OK_S;
+		} else {
+			/* SAHARA is reporting an error with entry */
+			if (hw_status == SAH_EXEC_ERROR1) {
+				/* Gather extra diagnostic information */
+				entry->fault_address =
+				    sah_HW_Read_Fault_Address();
+				/* Read this register last - it clears the error */
+				entry->error_status =
+				    sah_HW_Read_Error_Status();
+				entry->op_status = 0;
+				/* translate from SAHARA error status to fsl_shw return values */
+				entry->result =
+				    sah_convert_error_status(entry->
+							     error_status);
+#ifdef DIAG_DRV_STATUS
+				sah_Log_Error(entry->op_status,
+					      entry->error_status,
+					      entry->fault_address);
+#endif
+			} else if (hw_status == SAH_EXEC_OPSTAT1) {
+				entry->op_status = sah_HW_Read_Op_Status();
+				entry->error_status = 0;
+				entry->result =
+				    sah_convert_op_status(op_status);
+			} else {
+				/* SAHARA entered FAULT state (or something bazaar has
+				 * happened) */
+				pr_debug
+					("Sahara: hw_status = 0x%x; Stat: 0x%08x; IDAR: 0x%08x; "
+					 "CDAR: 0x%08x; FltAdr: 0x%08x; Estat: 0x%08x\n",
+					 hw_status, sah_HW_Read_Status(),
+					 sah_HW_Read_IDAR(), sah_HW_Read_CDAR(),
+					 sah_HW_Read_Fault_Address(),
+					 sah_HW_Read_Error_Status());
+#ifdef DIAG_DRV_IF
+				{
+					int old_level = console_loglevel;
+					console_loglevel = 8;
+					sah_Dump_Chain(&(entry->desc),
+							   entry->desc.dma_addr);
+					console_loglevel = old_level;
+				}
+#endif
+
+				entry->error_status = -1;
+				entry->result = FSL_RETURN_ERROR_S;
+				sah_HW_Reset();
+			}
+		}
+#ifdef SAHARA_POWER_MANAGEMENT
+	}
+#endif
+
+	if (!(entry->uco_flags & FSL_UCO_BLOCKING_MODE)) {
+		/* put it in results pool to allow get_results to work */
+		sah_Queue_Append_Entry(&entry->user_info->result_pool, entry);
+		if (entry->uco_flags & FSL_UCO_CALLBACK_MODE) {
+			/* invoke callback */
+			entry->user_info->callback(entry->user_info);
+		}
+	} else {
+		/* convert the descriptor link back to virtual memory, mark dirty pages
+		 * if they are from user mode, and release the page cache for user
+		 * pages
+		 */
+		entry = sah_DePhysicalise_Descriptors(entry);
+	}
+
+	os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+	return 0;
+}
+
+#endif				/* SAHARA_POLL_MODE */
+
+/******************************************************************************
+* The following is the implementation of the Dynamic Power Management
+* functionality.
+******************************************************************************/
+#ifdef SAHARA_POWER_MANAGEMENT
+
+static bool sah_dpm_init_flag;
+
+/* dynamic power management information for the sahara driver */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static struct device_driver sah_dpm_driver = {
+	.name = "sahara_",
+	.bus = &platform_bus_type,
+#else
+static struct platform_driver sah_dpm_driver = {
+	.driver.name = "sahara_",
+	.driver.bus = &platform_bus_type,
+#endif
+	.suspend = sah_dpm_suspend,
+	.resume = sah_dpm_resume
+};
+
+/* dynamic power management information for the sahara HW device */
+static struct platform_device sah_dpm_device = {
+	.name = "sahara_",
+	.id = 1,
+};
+
+/*!
+*******************************************************************************
+* Initilaizes the dynamic power managment functionality
+*
+* @brief    Initialization of the Dynamic Power Management functionality
+*
+* @return   0 = success; failed otherwise
+*/
+int sah_dpm_init()
+{
+	int status;
+
+	/* dpm is not asserted */
+	sah_dpm_flag = FALSE;
+
+	/* register the driver to the kernel */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	status = os_register_to_driver(&sah_dpm_driver);
+#else
+	status = os_register_to_driver(&sah_dpm_driver.driver);
+#endif
+
+	if (status == 0) {
+		/* register a single sahara chip */
+		/*status = platform_device_register(&sah_dpm_device); */
+		status = os_register_a_device(&sah_dpm_device);
+
+		/* if something went awry, unregister the driver */
+		if (status != 0) {
+			/*driver_unregister(&sah_dpm_driver); */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+			os_unregister_from_driver(&sah_dpm_driver);
+#else
+			os_unregister_from_driver(&sah_dpm_driver.driver);
+#endif
+			sah_dpm_init_flag = FALSE;
+		} else {
+			/* if everything went okay, flag that life is good */
+			sah_dpm_init_flag = TRUE;
+		}
+	}
+
+	/* let the kernel know how it went */
+	return status;
+
+}
+
+/*!
+*******************************************************************************
+* Unregister the dynamic power managment functionality
+*
+* @brief    Unregister the Dynamic Power Management functionality
+*
+*/
+void sah_dpm_close()
+{
+	/* if dynamic power management was initilaized, kill it */
+	if (sah_dpm_init_flag == TRUE) {
+		/*driver_unregister(&sah_dpm_driver); */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+		os_unregister_from_driver(&sah_dpm_driver);
+#else
+		os_unregister_from_driver(&sah_dpm_driver.driver);
+#endif
+		/*platform_device_register(&sah_dpm_device); */
+		os_unregister_a_device(&sah_dpm_device);
+	}
+}
+
+/*!
+*******************************************************************************
+* Callback routine defined by the Linux Device Model / Dynamic Power management
+* extension. It sets a global flag to disallow the driver to enter queued items
+* into Sahara's DAR.
+*
+* It allows the current active descriptor chains to complete before it returns
+*
+* @brief   Suspends the driver
+*
+* @param   dev   contains device information
+* @param   state contains state information
+* @param   level  level of shutdown
+*
+* @return   0 = success; failed otherwise
+*/
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int sah_dpm_suspend(struct device *dev, uint32_t state, uint32_t level)
+#else
+static int sah_dpm_suspend(struct platform_device *dev, pm_message_t state)
+#endif
+{
+	sah_Head_Desc *entry = NULL;
+	os_lock_context_t lock_flags;
+	int error_code = 0;
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	switch (level) {
+	case SUSPEND_DISABLE:
+		/* Assert dynamic power management. This stops the driver from
+		 * entering queued requests to Sahara */
+		sah_dpm_flag = TRUE;
+		break;
+
+	case SUSPEND_SAVE_STATE:
+		break;
+
+	case SUSPEND_POWER_DOWN:
+		/* hopefully between the DISABLE call and this one, the outstanding
+		 * work Sahara was doing complete. this checks (and waits) for
+		 * those entries that were already active on Sahara to complete */
+		/* lock queue while searching */
+		os_lock_save_context(desc_queue_lock, lock_flags);
+		do {
+			entry = sah_Find_With_State(SAH_STATE_ON_SAHARA);
+		} while (entry != NULL);
+		os_unlock_restore_context(desc_queue_lock, lock_flags);
+
+		/* now we kill the clock so the control circuitry isn't sucking
+		 * any power */
+		mxc_clks_disable(SAHARA2_CLK);
+		break;
+	}
+#else
+	/* Assert dynamic power management. This stops the driver from
+	 * entering queued requests to Sahara */
+	sah_dpm_flag = TRUE;
+
+	/* Now wait for any outstanding work Sahara was doing to complete.
+	 * this checks (and waits) for
+	 * those entries that were already active on Sahara to complete */
+	do {
+		/* lock queue while searching */
+		os_lock_save_context(desc_queue_lock, lock_flags);
+		entry = sah_Find_With_State(SAH_STATE_ON_SAHARA);
+		os_unlock_restore_context(desc_queue_lock, lock_flags);
+	} while (entry != NULL);
+
+	/* now we kill the clock so the control circuitry isn't sucking
+	 * any power */
+	{
+		struct clk *clk = clk_get(NULL, "sahara_clk");
+		if (IS_ERR(clk))
+			error_code = PTR_ERR(clk);
+		else
+			clk_disable(clk);
+	}
+#endif
+
+	return error_code;
+}
+
+/*!
+*******************************************************************************
+* Callback routine defined by the Linux Device Model / Dynamic Power management
+* extension. It cleears a global flag to allow the driver to enter queued items
+* into Sahara's DAR.
+*
+* It primes the mechanism to start depleting the queue
+*
+* @brief   Resumes the driver
+*
+* @param   dev    contains device information
+* @param   level  level of resumption
+*
+* @return   0 = success; failed otherwise
+*/
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int sah_dpm_resume(struct device *dev, uint32_t level)
+#else
+static int sah_dpm_resume(struct platform_device *dev)
+#endif
+{
+	sah_Head_Desc *entry = NULL;
+	os_lock_context_t lock_flags;
+	int error_code = 0;
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	switch (level) {
+	case RESUME_POWER_ON:
+		/* enable Sahara's clock */
+		mxc_clks_enable(SAHARA2_CLK);
+		break;
+
+	case RESUME_RESTORE_STATE:
+		break;
+
+	case RESUME_ENABLE:
+		/* Disable dynamic power managment. This allows the driver to put
+		 * entries into Sahara's DAR */
+		sah_dpm_flag = FALSE;
+
+		/* find a pending entry to prime the pump */
+		os_lock_save_context(desc_queue_lock, lock_flags);
+		entry = sah_Find_With_State(SAH_STATE_PENDING);
+		if (entry != NULL) {
+			sah_Queue_Manager_Prime(entry);
+		}
+		os_unlock_restore_context(desc_queue_lock, lock_flags);
+		break;
+	}
+#else
+	{
+		/* enable Sahara's clock */
+		struct clk *clk = clk_get(NULL, "sahara_clk");
+
+		if (IS_ERR(clk))
+			error_code = PTR_ERR(clk);
+		else
+			clk_disable(clk);
+	}
+	sah_dpm_flag = FALSE;
+
+	/* find a pending entry to prime the pump */
+	os_lock_save_context(desc_queue_lock, lock_flags);
+	entry = sah_Find_With_State(SAH_STATE_PENDING);
+	if (entry != NULL) {
+		sah_Queue_Manager_Prime(entry);
+	}
+	os_unlock_restore_context(desc_queue_lock, lock_flags);
+#endif
+	return error_code;
+}
+
+#endif				/* SAHARA_POWER_MANAGEMENT */
diff --git a/drivers/mxc/security/sahara2/sf_util.c b/drivers/mxc/security/sahara2/sf_util.c
new file mode 100644
index 0000000..12cc016
--- /dev/null
+++ b/drivers/mxc/security/sahara2/sf_util.c
@@ -0,0 +1,1390 @@
+/*
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+* @file sf_util.c
+*
+* @brief Security Functions component API - Utility functions
+*
+* These are the 'Sahara api' functions which are used by the higher-level
+* FSL SHW API to build and then execute descriptor chains.
+*/
+
+
+#include "sf_util.h"
+#include <adaptor.h>
+
+#ifdef DIAG_SECURITY_FUNC
+#include <diagnostic.h>
+#endif /*DIAG_SECURITY_FUNC*/
+
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(sah_Append_Desc);
+EXPORT_SYMBOL(sah_Append_Link);
+EXPORT_SYMBOL(sah_Create_Link);
+EXPORT_SYMBOL(sah_Create_Key_Link);
+EXPORT_SYMBOL(sah_Destroy_Link);
+EXPORT_SYMBOL(sah_Descriptor_Chain_Execute);
+EXPORT_SYMBOL(sah_insert_mdha_algorithm);
+EXPORT_SYMBOL(sah_insert_skha_algorithm);
+EXPORT_SYMBOL(sah_insert_skha_mode);
+EXPORT_SYMBOL(sah_insert_skha_modulus);
+EXPORT_SYMBOL(sah_Descriptor_Chain_Destroy);
+EXPORT_SYMBOL(sah_add_two_in_desc);
+EXPORT_SYMBOL(sah_add_in_key_desc);
+EXPORT_SYMBOL(sah_add_two_out_desc);
+EXPORT_SYMBOL(sah_add_in_out_desc);
+EXPORT_SYMBOL(sah_add_key_out_desc);
+#endif
+
+#ifdef DEBUG_REWORK
+#ifndef __KERNEL__
+#include <stdio.h>
+#define os_printk printf
+#endif
+#endif
+
+/**
+ * Convert fsl_shw_hash_alg_t to mdha mode bits.
+ *
+ * Index must be maintained in order of fsl_shw_hash_alg_t enumeration!!!
+ */
+const uint32_t sah_insert_mdha_algorithm[] =
+{
+    [FSL_HASH_ALG_MD5] = sah_insert_mdha_algorithm_md5,
+    [FSL_HASH_ALG_SHA1] = sah_insert_mdha_algorithm_sha1,
+    [FSL_HASH_ALG_SHA224] = sah_insert_mdha_algorithm_sha224,
+    [FSL_HASH_ALG_SHA256] = sah_insert_mdha_algorithm_sha256,
+};
+
+/**
+ * Header bits for Algorithm field of SKHA header
+ *
+ * Index value must be kept in sync with fsl_shw_key_alg_t
+ */
+const uint32_t sah_insert_skha_algorithm[] =
+{
+    [FSL_KEY_ALG_HMAC] = 0x00000040,
+    [FSL_KEY_ALG_AES] = sah_insert_skha_algorithm_aes,
+    [FSL_KEY_ALG_DES] = sah_insert_skha_algorithm_des,
+    [FSL_KEY_ALG_TDES] = sah_insert_skha_algorithm_tdes,
+    [FSL_KEY_ALG_ARC4] = sah_insert_skha_algorithm_arc4,
+};
+
+
+/**
+ * Header bits for MODE field of SKHA header
+ *
+ * Index value must be kept in sync with fsl_shw_sym_mod_t
+ */
+const uint32_t sah_insert_skha_mode[] =
+{
+    [FSL_SYM_MODE_STREAM] = sah_insert_skha_mode_ecb,
+    [FSL_SYM_MODE_ECB] = sah_insert_skha_mode_ecb,
+    [FSL_SYM_MODE_CBC] = sah_insert_skha_mode_cbc,
+    [FSL_SYM_MODE_CTR] = sah_insert_skha_mode_ctr,
+};
+
+
+/**
+ * Header bits to set CTR modulus size.  These have parity
+ * included to allow XOR insertion of values.
+ *
+ * @note Must be kept in sync with fsl_shw_ctr_mod_t
+ */
+const uint32_t sah_insert_skha_modulus[] =
+{
+    [FSL_CTR_MOD_8] = 0x00000000, /**< 2**8 */
+    [FSL_CTR_MOD_16] = 0x80000200, /**< 2**16 */
+    [FSL_CTR_MOD_24] = 0x80000400, /**< 2**24 */
+    [FSL_CTR_MOD_32] = 0x00000600, /**< 2**32 */
+    [FSL_CTR_MOD_40] = 0x80000800, /**< 2**40 */
+    [FSL_CTR_MOD_48] = 0x00000a00, /**< 2**48 */
+    [FSL_CTR_MOD_56] = 0x00000c00, /**< 2**56 */
+    [FSL_CTR_MOD_64] = 0x80000e00, /**< 2**64 */
+    [FSL_CTR_MOD_72] = 0x80001000, /**< 2**72 */
+    [FSL_CTR_MOD_80] = 0x00001200, /**< 2**80 */
+    [FSL_CTR_MOD_88] = 0x00001400, /**< 2**88 */
+    [FSL_CTR_MOD_96] = 0x80001600, /**< 2**96 */
+    [FSL_CTR_MOD_104] = 0x00001800, /**< 2**104 */
+    [FSL_CTR_MOD_112] = 0x80001a00, /**< 2**112 */
+    [FSL_CTR_MOD_120] = 0x80001c00, /**< 2**120 */
+    [FSL_CTR_MOD_128] = 0x00001e00 /**< 2**128 */
+};
+
+
+/******************************************************************************
+* Internal function declarations
+******************************************************************************/
+static fsl_shw_return_t sah_Create_Desc(
+    const sah_Mem_Util *mu,
+    sah_Desc ** desc,
+    int head,
+    uint32_t header,
+    sah_Link * link1,
+    sah_Link * link2);
+
+
+/**
+ * Create a descriptor chain using the the header and links passed in as
+ * parameters. The newly created descriptor will be added to the end of
+ * the descriptor chain passed.
+ *
+ * If @a desc_head points to a NULL value, then a sah_Head_Desc will be created
+ * as the first descriptor.  Otherwise a sah_Desc will be created and appended.
+ *
+ * @pre
+ *
+ * - None
+ *
+ * @post
+ *
+ * - A descriptor has been created from the header, link1 and link2.
+ *
+ * - The newly created descriptor has been appended to the end of
+ *   desc_head, or its location stored into the location pointed to by
+ *   @a desc_head.
+ *
+ * - On allocation failure, @a link1 and @a link2 will be destroyed., and
+ *   @a desc_head will be untouched.
+ *
+ * @brief   Create and append descriptor chain, inserting header and links
+ *          pointing to link1 and link2
+ *
+ * @param  mu Memory functions
+ * @param  header Value of descriptor header to be added
+ * @param  desc_head Pointer to head of descriptor chain to append new desc
+ * @param  link1 Pointer to sah_Link 1 (or NULL)
+ * @param  link2 Pointer to sah_Link 2 (or NULL)
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_Append_Desc(
+    const sah_Mem_Util *mu,
+    sah_Head_Desc **desc_head,
+    const uint32_t header,
+    sah_Link *link1,
+    sah_Link *link2)
+{
+    fsl_shw_return_t status;
+    sah_Desc         *desc;
+    sah_Desc         *desc_ptr;
+
+
+    status = sah_Create_Desc(mu, (sah_Desc**)&desc, (*desc_head == NULL),
+                             header, link1, link2);
+    /* append newly created descriptor to end of current chain */
+    if (status == FSL_RETURN_OK_S) {
+        if (*desc_head == NULL) {
+            (*desc_head) = (sah_Head_Desc*)desc;
+            (*desc_head)->out1_ptr = NULL;
+            (*desc_head)->out2_ptr = NULL;
+
+        } else {
+            desc_ptr = (sah_Desc*)*desc_head;
+            while (desc_ptr->next != NULL) {
+                desc_ptr = desc_ptr->next;
+            }
+            desc_ptr->next = desc;
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Releases the memory allocated by the Security Function library for
+ * descriptors, links and any internally allocated memory referenced in the
+ * given chain. Note that memory allocated by user applications is not
+ * released.
+ *
+ * @post The @a desc_head pointer will be set to NULL to prevent further use.
+ *
+ * @brief   Destroy a descriptor chain and free memory of associated links
+ *
+ * @param  mu Memory functions
+ * @param  desc_head Pointer to head of descriptor chain to be freed
+ *
+ * @return none
+ */
+void sah_Descriptor_Chain_Destroy (
+    const sah_Mem_Util *mu,
+    sah_Head_Desc **desc_head)
+{
+    sah_Desc *desc_ptr = &(*desc_head)->desc;
+    sah_Head_Desc *desc_head_ptr = (sah_Head_Desc *)desc_ptr;
+
+    while (desc_ptr != NULL) {
+        register sah_Desc *next_desc_ptr;
+
+        if (desc_ptr->ptr1 != NULL) {
+            sah_Destroy_Link(mu, desc_ptr->ptr1);
+        }
+        if (desc_ptr->ptr2 != NULL) {
+            sah_Destroy_Link(mu, desc_ptr->ptr2);
+        }
+
+        next_desc_ptr = desc_ptr->next;
+
+        /* Be sure to free head descriptor as such */
+        if (desc_ptr == (sah_Desc*)desc_head_ptr) {
+            mu->mu_free_head_desc(mu->mu_ref, desc_head_ptr);
+        } else {
+            mu->mu_free_desc(mu->mu_ref, desc_ptr);
+        }
+
+        desc_ptr = next_desc_ptr;
+    }
+
+    *desc_head = NULL;
+}
+
+
+#ifndef NO_INPUT_WORKAROUND
+/**
+ * Reworks the link chain
+ *
+ * @brief   Reworks the link chain
+ *
+ * @param  mu    Memory functions
+ * @param  link  Pointer to head of link chain to be reworked
+ *
+ * @return none
+ */
+static fsl_shw_return_t sah_rework_link_chain(
+        const sah_Mem_Util *mu,
+        sah_Link* link)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    int found_potential_problem = 0;
+    uint32_t total_data = 0;
+#ifdef DEBUG_REWORK
+    sah_Link* first_link = link;
+#endif
+
+    if ((link->flags & SAH_OUTPUT_LINK)) {
+        return status;
+    }
+
+    while (link != NULL) {
+        total_data += link->len;
+
+    /* Only non-key Input Links are affected by the DMA flush-to-FIFO
+     * problem */
+
+        /* If have seen problem and at end of chain... */
+        if (found_potential_problem && (link->next == NULL) &&
+                                         (total_data > 16)) {
+            /* insert new 1-byte link */
+            sah_Link* new_tail_link = mu->mu_alloc_link(mu->mu_ref);
+            if (new_tail_link == NULL) {
+                status = FSL_RETURN_NO_RESOURCE_S;
+            } else {
+#ifdef DEBUG_REWORK
+                sah_Link* dump_link = first_link;
+                while (dump_link != NULL) {
+                    uint32_t i;
+                    unsigned bytes_to_dump = (dump_link->len > 32) ?
+                                              32 : dump_link->len;
+                    os_printk("(rework)Link %p: %p/%u/%p\n", dump_link,
+                              dump_link->data, dump_link->len,
+                              dump_link->next);
+                    if (!(dump_link->flags & SAH_STORED_KEY_INFO)) {
+                        os_printk("(rework)Data %p: ", dump_link->data);
+                        for (i = 0; i < bytes_to_dump; i++) {
+                            os_printk("%02X ", dump_link->data[i]);
+                        }
+                        os_printk("\n");
+                    }
+                    else {
+                        os_printk("rework)Data %p: Red key data\n", dump_link);
+                    }
+                    dump_link = dump_link->next;
+                }
+#endif
+                link->len--;
+                link->next = new_tail_link;
+                new_tail_link->len = 1;
+                new_tail_link->data = link->data+link->len;
+                new_tail_link->flags = link->flags & ~(SAH_OWNS_LINK_DATA);
+                new_tail_link->next = NULL;
+                link = new_tail_link;
+#ifdef DEBUG_REWORK
+                os_printk("(rework)New link chain:\n");
+                dump_link = first_link;
+                while (dump_link != NULL) {
+                    uint32_t i;
+                    unsigned bytes_to_dump = (dump_link->len > 32) ?
+                                              32 : dump_link->len;
+
+                    os_printk("Link %p: %p/%u/%p\n", dump_link,
+                              dump_link->data, dump_link->len,
+                              dump_link->next);
+                    if (!(dump_link->flags & SAH_STORED_KEY_INFO)) {
+                        os_printk("Data %p: ", dump_link->data);
+                        for (i = 0; i < bytes_to_dump; i++) {
+                            os_printk("%02X ", dump_link->data[i]);
+                        }
+                        os_printk("\n");
+                    }
+                    else {
+                        os_printk("Data %p: Red key data\n", dump_link);
+                    }
+                    dump_link = dump_link->next;
+                }
+#endif
+            }
+        } else if ((link->len % 4) || ((uint32_t)link->data % 4)) {
+            found_potential_problem = 1;
+        }
+
+        link = link->next;
+    }
+
+    return status;
+}
+
+
+/**
+ * Rework links to avoid H/W bug
+ *
+ * @param head   Beginning of descriptor chain
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t sah_rework_links(
+        const sah_Mem_Util *mu,
+        sah_Head_Desc *head)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Desc* desc = &head->desc;
+
+    while ((status == FSL_RETURN_OK_S) && (desc != NULL)) {
+        if (desc->header & SAH_HDR_LLO) {
+            status = FSL_RETURN_ERROR_S;
+            break;
+        }
+        if (desc->ptr1 != NULL) {
+            status = sah_rework_link_chain(mu, desc->ptr1);
+        }
+        if ((status == FSL_RETURN_OK_S) && (desc->ptr2 != NULL)) {
+            status = sah_rework_link_chain(mu, desc->ptr2);
+        }
+        desc = desc->next;
+    }
+
+    return status;
+}
+#endif /* NO_INPUT_WORKAROUND */
+
+
+/**
+ * Send a descriptor chain to the SAHARA driver for processing.
+ *
+ * Note that SAHARA will read the input data from and write the output data
+ * directly to the locations indicated during construction of the chain.
+ *
+ * @pre
+ *
+ * - None
+ *
+ * @post
+ *
+ * - @a head will have been executed on SAHARA
+ * - @a head Will be freed unless a SAVE flag is set
+ *
+ * @brief   Execute a descriptor chain
+ *
+ * @param  head      Pointer to head of descriptor chain to be executed
+ * @param  user_ctx  The user context on which to execute the descriptor chain.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_Descriptor_Chain_Execute(
+    sah_Head_Desc *head,
+    fsl_shw_uco_t *user_ctx)
+{
+    fsl_shw_return_t status;
+
+	/* Check for null pointer or non-multiple-of-four value */
+    if ((head == NULL) || ((uint32_t)head & 0x3)) {
+        status = FSL_RETURN_ERROR_S;
+        goto out;
+    }
+
+#ifndef NO_INPUT_WORKAROUND
+    status = sah_rework_links(user_ctx->mem_util, head);
+    if (status != FSL_RETURN_OK_S) {
+        goto out;
+    }
+#endif
+
+    /* complete the information in the descriptor chain head node */
+    head->user_ref = user_ctx->user_ref;
+    head->uco_flags = user_ctx->flags;
+    head->next = NULL; /* driver will use this to link chain heads */
+
+    status = adaptor_Exec_Descriptor_Chain(head, user_ctx);
+
+#ifdef DIAG_SECURITY_FUNC
+	 if (status == FSL_RETURN_OK_S)
+		 LOG_DIAG("after exec desc chain: status is ok\n");
+	 else
+		 LOG_DIAG("after exec desc chain: status is not ok\n");
+#endif
+
+ out:
+    return status;
+}
+
+
+/**
+ * Create Link
+ *
+ * @brief   Allocate Memory for Link structure and populate using input
+ *          parameters
+ *
+ * @post    On allocation failure, @a p will be freed if #SAH_OWNS_LINK_DATA is
+ *          p set in @a flags.
+
+ * @param  mu Memory functions
+ * @param  link Pointer to link to be created
+ * @param  p Pointer to data to use in link
+ * @param  length Length of buffer 'p' in bytes
+ * @param  flags Indicates whether memory has been allocated by the calling
+ *         function or the security function
+ *
+ * @return FSL_RETURN_OK_S or FSL_RETURN_NO_RESOURCE_S
+ */
+fsl_shw_return_t sah_Create_Link(
+    const sah_Mem_Util *mu,
+    sah_Link **link,
+    uint8_t *p,
+    const size_t length,
+    const sah_Link_Flags flags)
+{
+
+#ifdef DIAG_SECURITY_FUNC
+
+    char diag[50];
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+    fsl_shw_return_t status = FSL_RETURN_NO_RESOURCE_S;
+
+
+    *link = mu->mu_alloc_link(mu->mu_ref);
+
+    /* populate link if memory allocation successful */
+    if (*link != NULL) {
+        (*link)->len = length;
+        (*link)->data = p;
+        (*link)->next = NULL;
+        (*link)->flags = flags;
+        status = FSL_RETURN_OK_S;
+
+#ifdef DIAG_SECURITY_FUNC
+
+        LOG_DIAG("Created Link");
+        LOG_DIAG("------------");
+        sprintf(diag," address       = 0x%x", (int) *link);
+        LOG_DIAG(diag);
+        sprintf(diag," link->len     = %d",(*link)->len);
+        LOG_DIAG(diag);
+        sprintf(diag," link->data    = 0x%x",(int) (*link)->data);
+        LOG_DIAG(diag);
+        sprintf(diag," link->flags   = 0x%x",(*link)->flags);
+        LOG_DIAG(diag);
+        LOG_DIAG(" link->next    = NULL");
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+
+    } else {
+#ifdef DIAG_SECURITY_FUNC
+        LOG_DIAG("Allocation of memory for sah_Link failed!\n");
+#endif /*DIAG_SECURITY_FUNC*/
+
+        /* Free memory previously allocated by the security function layer for
+        link data. Note that the memory being pointed to will be zeroed before
+        being freed, for security reasons. */
+        if (flags & SAH_OWNS_LINK_DATA) {
+            mu->mu_memset(mu->mu_ref, p, 0x00, length);
+            mu->mu_free(mu->mu_ref, p);
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Create Key Link
+ *
+ * @brief   Allocate Memory for Link structure and populate using key info
+ *          object
+ *
+ * @param  mu Memory functions
+ * @param  link Pointer to store address of link to be created
+ * @param  key_info Pointer to Key Info object to be referenced
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_Create_Key_Link(
+    const sah_Mem_Util *mu,
+    sah_Link **link,
+    fsl_shw_sko_t *key_info)
+{
+#ifdef DIAG_SECURITY_FUNC_UGLY
+    char diag[50];
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+    fsl_shw_return_t status = FSL_RETURN_NO_RESOURCE_S;
+    sah_Link_Flags flags = 0;
+
+
+    *link = mu->mu_alloc_link(mu->mu_ref);
+
+    /* populate link if memory allocation successful */
+    if (*link != NULL) {
+        (*link)->len = key_info->key_length;
+
+        if (key_info->flags & FSL_SKO_KEY_PRESENT) {
+            (*link)->data = key_info->key;
+            status = FSL_RETURN_OK_S;
+        } else {
+            if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+
+				if (key_info->keystore == NULL) {
+					/* System Keystore */
+			(*link)->slot = key_info->handle;
+			(*link)->ownerid = key_info->userid;
+			(*link)->data = 0;
+			flags |= SAH_STORED_KEY_INFO;
+			status = FSL_RETURN_OK_S;
+				} else {
+#ifdef FSL_HAVE_SCC2
+					/* User Keystore */
+					fsl_shw_kso_t *keystore = key_info->keystore;
+					/* Note: the key data is stored here, but the address has to
+					 * be converted to a partition and offset in the kernel.
+					 * This will be calculated in kernel space, based on the
+					 * list of partitions held by the users context.
+					 */
+					(*link)->data =
+						keystore->slot_get_address(keystore->user_data,
+												 key_info->handle);
+
+					flags |= SAH_IN_USER_KEYSTORE;
+					status = FSL_RETURN_OK_S;
+#else
+					/* User keystores only supported in SCC2 */
+					status = FSL_RETURN_BAD_FLAG_S;
+#endif				/* FSL_HAVE_SCC2 */
+
+				}
+            } else {
+                /* the flag is bad. Should never get here */
+                status = FSL_RETURN_BAD_FLAG_S;
+            }
+        }
+
+        (*link)->next = NULL;
+        (*link)->flags = flags;
+
+#ifdef DIAG_SECURITY_FUNC_UGLY
+        if (status == FSL_RETURN_OK_S) {
+            LOG_DIAG("Created Link");
+            LOG_DIAG("------------");
+            sprintf(diag," address       = 0x%x", (int) *link);
+            LOG_DIAG(diag);
+            sprintf(diag," link->len     = %d", (*link)->len);
+            LOG_DIAG(diag);
+            if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+                sprintf(diag," link->slot    = 0x%x", (*link)->slot);
+                LOG_DIAG(diag);
+            } else {
+                sprintf(diag," link->data    = 0x%x", (int)(*link)->data);
+                LOG_DIAG(diag);
+            }
+            sprintf(diag," link->flags   = 0x%x", (*link)->flags);
+            LOG_DIAG(diag);
+            LOG_DIAG(" link->next    = NULL");
+        }
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+
+        if (status == FSL_RETURN_BAD_FLAG_S) {
+            mu->mu_free_link(mu->mu_ref, *link);
+            *link = NULL;
+#ifdef DIAG_SECURITY_FUNC
+            LOG_DIAG("Creation of sah_Key_Link failed due to bad key flag!\n");
+#endif /*DIAG_SECURITY_FUNC*/
+        }
+
+    } else {
+#ifdef DIAG_SECURITY_FUNC
+        LOG_DIAG("Allocation of memory for sah_Key_Link failed!\n");
+#endif /*DIAG_SECURITY_FUNC*/
+    }
+
+    return status;
+}
+
+
+/**
+ * Append Link
+ *
+ * @brief   Allocate Memory for Link structure and append it to the end of
+ *          the link chain.
+ *
+ * @post    On allocation failure, @a p will be freed if #SAH_OWNS_LINK_DATA is
+ *          p set in @a flags.
+ *
+ * @param  mu Memory functions
+ * @param  link_head Pointer to (head of) existing link chain
+ * @param  p Pointer to data to use in link
+ * @param  length Length of buffer 'p' in bytes
+ * @param  flags Indicates whether memory has been allocated by the calling
+ *         function or the security function
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_Append_Link(
+    const sah_Mem_Util *mu,
+    sah_Link *link_head,
+    uint8_t *p,
+    const size_t length,
+    const sah_Link_Flags flags)
+{
+    sah_Link* new_link;
+    fsl_shw_return_t status;
+
+
+    status = sah_Create_Link(mu, &new_link, p, length, flags);
+
+    if (status == FSL_RETURN_OK_S) {
+        /* chase for the tail */
+        while (link_head->next != NULL) {
+            link_head = link_head->next;
+        }
+
+        /* and add new tail */
+        link_head->next = new_link;
+    }
+
+    return status;
+}
+
+
+/**
+ * Create and populate a single descriptor
+ *
+ * The pointer and length fields will be be set based on the chains passed in
+ * as @a link1 and @a link2.
+ *
+ * @param  mu         Memory utility suite
+ * @param  desc       Location to store pointer of new descriptor
+ * @param  head_desc  Non-zero if this will be first in chain; zero otherwise
+ * @param  header     The Sahara header value to store in the descriptor
+ * @param  link1      A value (or NULL) for the first ptr
+ * @param  link2      A value (or NULL) for the second ptr
+ *
+ * @post  If allocation succeeded, the @a link1 and @link2 will be linked into
+ *        the descriptor.  If allocation failed, those link structues will be
+ *        freed, and the @a desc will be unchanged.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t sah_Create_Desc(
+    const sah_Mem_Util *mu,
+    sah_Desc ** desc,
+    int head_desc,
+    uint32_t header,
+    sah_Link * link1,
+    sah_Link * link2)
+{
+    fsl_shw_return_t status = FSL_RETURN_NO_RESOURCE_S;
+#ifdef DIAG_SECURITY_FUNC_UGLY
+    char diag[50];
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+
+
+    if (head_desc != 0) {
+        *desc = (sah_Desc *)mu->mu_alloc_head_desc(mu->mu_ref);
+    } else {
+        *desc = mu->mu_alloc_desc(mu->mu_ref);
+    }
+
+    /* populate descriptor if memory allocation successful */
+    if ((*desc) != NULL) {
+        sah_Link* temp_link;
+
+        status = FSL_RETURN_OK_S;
+        (*desc)->header = header;
+
+        temp_link = (*desc)->ptr1 = link1;
+        (*desc)->len1 = 0;
+        while (temp_link != NULL) {
+            (*desc)->len1 += temp_link->len;
+            temp_link = temp_link->next;
+        }
+
+        temp_link = (*desc)->ptr2 = link2;
+        (*desc)->len2 = 0;
+        while (temp_link != NULL) {
+            (*desc)->len2 += temp_link->len;
+            temp_link = temp_link->next;
+        }
+
+        (*desc)->next = NULL;
+
+#ifdef DIAG_SECURITY_FUNC_UGLY
+        LOG_DIAG("Created Desc");
+        LOG_DIAG("------------");
+        sprintf(diag," address       = 0x%x",(int) *desc);
+        LOG_DIAG(diag);
+        sprintf(diag," desc->header  = 0x%x",(*desc)->header);
+        LOG_DIAG(diag);
+        sprintf(diag," desc->len1    = %d",(*desc)->len1);
+        LOG_DIAG(diag);
+        sprintf(diag," desc->ptr1    = 0x%x",(int) ((*desc)->ptr1));
+        LOG_DIAG(diag);
+        sprintf(diag," desc->len2    = %d",(*desc)->len2);
+        LOG_DIAG(diag);
+        sprintf(diag," desc->ptr2    = 0x%x",(int) ((*desc)->ptr2));
+        LOG_DIAG(diag);
+        sprintf(diag," desc->next    = 0x%x",(int) ((*desc)->next));
+        LOG_DIAG(diag);
+#endif /*DIAG_SECURITY_FUNC_UGLY*/
+    } else {
+#ifdef DIAG_SECURITY_FUNC
+        LOG_DIAG("Allocation of memory for sah_Desc failed!\n");
+#endif /*DIAG_SECURITY_FUNC*/
+
+        /* Destroy the links, otherwise the memory allocated by the Security
+        Function layer for the links (and possibly the data within the links)
+        will be lost */
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Destroy a link (chain) and free memory
+ *
+ * @param mu   memory utility suite
+ * @param link The Link to destroy
+ *
+ * @return none
+ */
+void sah_Destroy_Link(
+    const sah_Mem_Util *mu,
+    sah_Link * link)
+{
+
+    while (link != NULL) {
+        sah_Link * next_link = link->next;
+
+        if (link->flags & SAH_OWNS_LINK_DATA) {
+            /* zero data for security purposes */
+            mu->mu_memset(mu->mu_ref, link->data, 0x00, link->len);
+            mu->mu_free(mu->mu_ref, link->data);
+        }
+
+        link->data = NULL;
+        link->next = NULL;
+        mu->mu_free_link(mu->mu_ref, link);
+
+        link = next_link;
+    }
+}
+
+
+/**
+ * Add descriptor where both links are inputs.
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in1        The first input buffer (or NULL)
+ * @param         in1_length Size of @a in1
+ * @param[out]    in2        The second input buffer (or NULL)
+ * @param         in2_length Size of @a in2
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_two_in_desc(uint32_t header,
+                                 const uint8_t* in1,
+                                 uint32_t in1_length,
+                                 const uint8_t* in2,
+                                 uint32_t in2_length,
+                                 const sah_Mem_Util* mu,
+                                 sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link* link1 = NULL;
+    sah_Link* link2 = NULL;
+
+	if (in1 != NULL) {
+		status = sah_Create_Link(mu, &link1,
+			(sah_Oct_Str) in1, in1_length, SAH_USES_LINK_DATA);
+    }
+
+    if ( (in2 != NULL) && (status == FSL_RETURN_OK_S) ) {
+        status = sah_Create_Link(mu, &link2,
+                                 (sah_Oct_Str) in2, in2_length,
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    } else {
+        status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+    }
+
+    return status;
+}
+
+/*!
+ * Add descriptor where neither link needs sync
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in1        The first input buffer (or NULL)
+ * @param         in1_length Size of @a in1
+ * @param[out]    in2        The second input buffer (or NULL)
+ * @param         in2_length Size of @a in2
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_two_d_desc(uint32_t header,
+				    const uint8_t * in1,
+				    uint32_t in1_length,
+				    const uint8_t * in2,
+				    uint32_t in2_length,
+				    const sah_Mem_Util * mu,
+				    sah_Head_Desc ** desc_chain)
+{
+	fsl_shw_return_t status = FSL_RETURN_OK_S;
+	sah_Link *link1 = NULL;
+	sah_Link *link2 = NULL;
+
+	printk("Entering sah_add_two_d_desc \n");
+
+	if (in1 != NULL) {
+		status = sah_Create_Link(mu, &link1,
+					 (sah_Oct_Str) in1, in1_length,
+					 SAH_USES_LINK_DATA);
+	}
+
+	if ((in2 != NULL) && (status == FSL_RETURN_OK_S)) {
+		status = sah_Create_Link(mu, &link2,
+					 (sah_Oct_Str) in2, in2_length,
+					 SAH_USES_LINK_DATA);
+	}
+
+	if (status != FSL_RETURN_OK_S) {
+		if (link1 != NULL) {
+			sah_Destroy_Link(mu, link1);
+		}
+		if (link2 != NULL) {
+			sah_Destroy_Link(mu, link2);
+		}
+	} else {
+		status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+	}
+
+	return status;
+}				/* sah_add_two_d_desc() */
+
+/**
+ * Add descriptor where both links are inputs, the second one being a key.
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in1        The first input buffer (or NULL)
+ * @param         in1_length Size of @a in1
+ * @param[out]    in2        The second input buffer (or NULL)
+ * @param         in2_length Size of @a in2
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_in_key_desc(uint32_t header,
+                                 const uint8_t* in1,
+                                 uint32_t in1_length,
+                                 fsl_shw_sko_t* key_info,
+                                 const sah_Mem_Util* mu,
+                                 sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+	if (in1 != NULL) {
+        status = sah_Create_Link(mu, &link1,
+                                 (sah_Oct_Str) in1, in1_length,
+                                 SAH_USES_LINK_DATA);
+    }
+
+	if (status != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+    status = sah_Create_Key_Link(mu, &link2, key_info);
+
+
+	if (status != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+
+out:
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Create two links using keys allocated in the scc
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in1        The first input buffer (or NULL)
+ * @param         in1_length Size of @a in1
+ * @param[out]    in2        The second input buffer (or NULL)
+ * @param         in2_length Size of @a in2
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_key_key_desc(uint32_t header,
+                                  fsl_shw_sko_t *key_info1,
+                                  fsl_shw_sko_t *key_info2,
+                                  const sah_Mem_Util *mu,
+                                  sah_Head_Desc **desc_chain)
+{
+    fsl_shw_return_t status;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+
+    status = sah_Create_Key_Link(mu, &link1, key_info1);
+
+    if (status == FSL_RETURN_OK_S) {
+        status = sah_Create_Key_Link(mu, &link2, key_info2);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    } else {
+        status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+    }
+
+    return status;
+}
+
+
+/**
+ * Add descriptor where first link is input, the second is a changing key
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in1        The first input buffer (or NULL)
+ * @param         in1_length Size of @a in1
+ * @param[out]    in2        The key for output
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_in_keyout_desc(uint32_t header,
+                                 const uint8_t* in1,
+                                 uint32_t in1_length,
+                                 fsl_shw_sko_t* key_info,
+                                 const sah_Mem_Util* mu,
+                                 sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+	if (in1 != NULL) {
+        status = sah_Create_Link(mu, &link1,
+                                 (sah_Oct_Str) in1, in1_length,
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+		goto out;
+    }
+
+	status = sah_Create_Key_Link(mu, &link2, key_info);
+
+	if (status != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+link2->flags |= SAH_OUTPUT_LINK;	/* mark key for output */
+status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+
+out:
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    }
+
+    return status;
+}
+
+/**
+ * Add descriptor where both links are outputs.
+ *
+ * @param         header      The Sahara header value for the descriptor.
+ * @param         out1        The first output buffer (or NULL)
+ * @param         out1_length Size of @a out1
+ * @param[out]    out2        The second output buffer (or NULL)
+ * @param         out2_length Size of @a out2
+ * @param         mu          Memory functions
+ * @param[in,out] desc_chain  Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_two_out_desc(uint32_t header,
+                                      uint8_t* out1,
+                                      uint32_t out1_length,
+                                      uint8_t* out2,
+                                      uint32_t out2_length,
+                                      const sah_Mem_Util* mu,
+                                      sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+
+	if (out1 != NULL) {
+		status = sah_Create_Link(mu, &link1,
+			(sah_Oct_Str) out1, out1_length,
+			SAH_OUTPUT_LINK | SAH_USES_LINK_DATA);
+    }
+
+    if ( (out2 != NULL) && (status == FSL_RETURN_OK_S) ) {
+        status = sah_Create_Link(mu, &link2,
+                                 (sah_Oct_Str) out2, out2_length,
+                                 SAH_OUTPUT_LINK |
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    } else {
+        status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+    }
+
+    return status;
+}
+
+
+/**
+ * Add descriptor where first link is output, second is output
+ *
+ * @param         header      The Sahara header value for the descriptor.
+ * @param         out1        The first output buffer (or NULL)
+ * @param         out1_length Size of @a out1
+ * @param[out]    in2         The input buffer (or NULL)
+ * @param         in2_length  Size of @a in2
+ * @param         mu          Memory functions
+ * @param[in,out] desc_chain  Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_out_in_desc(uint32_t header,
+                                     uint8_t* out1,
+                                     uint32_t out1_length,
+                                     const uint8_t* in2,
+                                     uint32_t in2_length,
+                                     const sah_Mem_Util* mu,
+                                     sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+
+    if (out1 != NULL) {
+        status = sah_Create_Link(mu, &link1,
+                                 (sah_Oct_Str) out1, out1_length,
+                                 SAH_OUTPUT_LINK |
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if ( (in2 != NULL) && (status == FSL_RETURN_OK_S) ) {
+        status = sah_Create_Link(mu, &link2,
+                                 (sah_Oct_Str) in2, in2_length,
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    } else {
+        status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+    }
+
+    return status;
+}
+
+
+/**
+ * Add descriptor where link1 is input buffer, link2 is output buffer.
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         in         The input buffer
+ * @param         in_length  Size of the input buffer
+ * @param[out]    out        The output buffer
+ * @param         out_length Size of the output buffer
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_in_out_desc(uint32_t header,
+                                 const uint8_t* in, uint32_t in_length,
+                                 uint8_t* out, uint32_t out_length,
+                                 const sah_Mem_Util* mu,
+                                 sah_Head_Desc** desc_chain)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+	if (in != NULL) {
+        status = sah_Create_Link(mu, &link1,
+                                 (sah_Oct_Str) in, in_length,
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if ((status == FSL_RETURN_OK_S) && (out != NULL))  {
+        status = sah_Create_Link(mu, &link2,
+                                 (sah_Oct_Str) out, out_length,
+                                 SAH_OUTPUT_LINK |
+                                 SAH_USES_LINK_DATA);
+    }
+
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    } else {
+        status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+    }
+
+    return status;
+}
+
+
+/**
+ * Add descriptor where link1 is a key, link2 is output buffer.
+ *
+ * @param         header     The Sahara header value for the descriptor.
+ * @param         key_info   Key information
+ * @param[out]    out        The output buffer
+ * @param         out_length Size of the output buffer
+ * @param         mu         Memory functions
+ * @param[in,out] desc_chain Chain to start or append to
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_add_key_out_desc(uint32_t header,
+								  const fsl_shw_sko_t *key_info,
+                                  uint8_t* out, uint32_t out_length,
+                                  const sah_Mem_Util *mu,
+                                  sah_Head_Desc **desc_chain)
+{
+    fsl_shw_return_t status;
+    sah_Link         *link1 = NULL;
+    sah_Link         *link2 = NULL;
+
+	status = sah_Create_Key_Link(mu, &link1, (fsl_shw_sko_t *) key_info);
+	if (status != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+
+    if (out != NULL)  {
+        status = sah_Create_Link(mu, &link2,
+                                 (sah_Oct_Str) out, out_length,
+                                 SAH_OUTPUT_LINK |
+                                 SAH_USES_LINK_DATA);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+	   }
+    }
+status = sah_Append_Desc(mu, desc_chain, header, link1, link2);
+
+out:
+    if (status != FSL_RETURN_OK_S) {
+        if (link1 != NULL) {
+            sah_Destroy_Link(mu, link1);
+        }
+        if (link2 != NULL) {
+            sah_Destroy_Link(mu, link2);
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Sanity checks the user context object fields to ensure that they make some
+ * sense before passing the uco as a parameter
+ *
+ * @brief Verify the user context object
+ *
+ * @param  uco  user context object
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t sah_validate_uco(fsl_shw_uco_t *uco)
+{
+    fsl_shw_return_t status = FSL_RETURN_OK_S;
+
+
+    /* check if file is opened */
+    if (uco->sahara_openfd < 0) {
+        status = FSL_RETURN_NO_RESOURCE_S;
+    } else {
+        /* check flag combination: the only invalid setting of the
+         * blocking and callback flags is blocking with callback. So check
+         * for that
+         */
+        if ((uco->flags & (FSL_UCO_BLOCKING_MODE | FSL_UCO_CALLBACK_MODE)) ==
+                         (FSL_UCO_BLOCKING_MODE | FSL_UCO_CALLBACK_MODE)) {
+            status = FSL_RETURN_BAD_FLAG_S;
+        } else {
+            /* check that memory utilities have been attached */
+            if (uco->mem_util == NULL) {
+                status = FSL_RETURN_MEMORY_ERROR_S;
+            } else {
+                /* must have pool of at least 1, even for blocking mode */
+                if (uco->pool_size == 0) {
+                    status = FSL_RETURN_ERROR_S;
+                } else {
+                    /* if callback flag is set, it better have a callback
+                     * routine */
+                    if (uco->flags & FSL_UCO_CALLBACK_MODE) {
+                        if (uco->callback == NULL) {
+                            status = FSL_RETURN_INTERNAL_ERROR_S;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return status;
+}
+
+
+/**
+ * Perform any post-processing on non-blocking results.
+ *
+ * For instance, free descriptor chains, compare authentication codes, ...
+ *
+ * @param  user_ctx     User context object
+ * @param  result_info  A set of results
+ */
+void sah_Postprocess_Results(fsl_shw_uco_t* user_ctx, sah_results* result_info)
+{
+    unsigned i;
+
+    /* for each result returned */
+    for (i = 0; i < *result_info->actual; i++) {
+        sah_Head_Desc* desc = result_info->results[i].user_desc;
+        uint8_t* out1 = desc->out1_ptr;
+        uint8_t* out2 = desc->out2_ptr;
+        uint32_t len = desc->out_len;
+
+        /*
+         * For now, tne only post-processing besides freeing the
+         * chain is the need to check the auth code for fsl_shw_auth_decrypt().
+         *
+         * If other uses are required in the future, this code will probably
+         * need a flag in the sah_Head_Desc (or a function pointer!) to
+         * determine what needs to be done.
+         */
+        if ((out1 != NULL) && (out2 != NULL)) {
+            unsigned j;
+            for (j = 0; j < len; j++) {
+                if (out1[j] != out2[j]) {
+                    /* Problem detected.  Change result. */
+                    result_info->results[i].code = FSL_RETURN_AUTH_FAILED_S;
+                    break;
+                }
+            }
+            /* free allocated 'calced_auth' */
+            user_ctx->mem_util->
+                mu_free(user_ctx->mem_util->mu_ref, out1);
+        }
+
+        /* Free the API-created chain, unless tagged as not-from-API */
+        if (! (desc->uco_flags & FSL_UCO_SAVE_DESC_CHAIN)) {
+            sah_Descriptor_Chain_Destroy(user_ctx->mem_util, &desc);
+        }
+    }
+}
+
+
+/* End of sf_util.c */
diff --git a/drivers/mxc/security/scc2_driver.c b/drivers/mxc/security/scc2_driver.c
new file mode 100644
index 0000000..9083237
--- /dev/null
+++ b/drivers/mxc/security/scc2_driver.c
@@ -0,0 +1,2396 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*! @file scc2_driver.c
+ *
+ * This is the driver code for the Security Controller version 2 (SCC2).  It's
+ * interaction with the Linux kernel is from calls to #scc_init() when the
+ * driver is loaded, and #scc_cleanup() should the driver be unloaded.  The
+ * driver uses locking and (task-sleep/task-wakeup) functions from the kernel.
+ * It also registers itself to handle the interrupt line(s) from the SCC.  New
+ * to this version of the driver is an interface providing access to the secure
+ * partitions.  This is in turn exposed to the API user through the
+ * fsl_shw_smalloc() series of functions.  Other drivers in the kernel may use
+ * the remaining API functions to get at the services of the SCC.  The main
+ * service provided is the Secure Memory, which allows encoding and decoding of
+ * secrets with a per-chip secret key.
+ *
+ * The SCC is single-threaded, and so is this module.  When the scc_crypt()
+ * routine is called, it will lock out other accesses to the function.  If
+ * another task is already in the module, the subsequent caller will spin on a
+ * lock waiting for the other access to finish.
+ *
+ * Note that long crypto operations could cause a task to spin for a while,
+ * preventing other kernel work (other than interrupt processing) to get done.
+ *
+ * The external (kernel module) interface is through the following functions:
+ * @li scc_get_configuration() @li scc_crypt() @li scc_zeroize_memories() @li
+ * scc_monitor_security_failure() @li scc_stop_monitoring_security_failure()
+ * @li scc_set_sw_alarm() @li scc_read_register() @li scc_write_register() @li
+ * scc_allocate_partition() @li scc_initialize_partition @li
+ * scc_release_partition() @li scc_diminish_permissions @li
+ * scc_encrypt_region() @li scc_decrypt_region() @li scc_virt_to_phys
+ *
+ * All other functions are internal to the driver.
+ */
+
+#include "sahara2/include/portable_os.h"
+#include "scc2_internals.h"
+#include <linux/delay.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+
+#include <linux/device.h>
+#include <mach/clock.h>
+#include <linux/device.h>
+
+#else
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#endif
+
+#include <linux/dmapool.h>
+
+/**
+ * This is the set of errors which signal that access to the SCM RAM has
+ * failed or will fail.
+ */
+#define SCM_ACCESS_ERRORS                                                  \
+       (SCM_ERRSTAT_ILM | SCM_ERRSTAT_SUP | SCM_ERRSTAT_ERC_MASK)
+
+/******************************************************************************
+ *
+ *  Global / Static Variables
+ *
+ *****************************************************************************/
+
+#ifdef SCC_REGISTER_DEBUG
+
+#define REG_PRINT_BUFFER_SIZE 200
+
+static char reg_print_buffer[REG_PRINT_BUFFER_SIZE];
+
+typedef char *(*reg_print_routine_t) (uint32_t value, char *print_buffer,
+				      int buf_size);
+
+#endif
+
+/**
+ * This is type void* so that a) it cannot directly be dereferenced,
+ * and b) pointer arithmetic on it will function in a 'normal way' for
+ * the offsets in scc_defines.h
+ *
+ * scc_base is the location in the iomap where the SCC's registers
+ * (and memory) start.
+ *
+ * The referenced data is declared volatile so that the compiler will
+ * not make any assumptions about the value of registers in the SCC,
+ * and thus will always reload the register into CPU memory before
+ * using it (i.e. wherever it is referenced in the driver).
+ *
+ * This value should only be referenced by the #SCC_READ_REGISTER and
+ * #SCC_WRITE_REGISTER macros and their ilk.  All dereferences must be
+ * 32 bits wide.
+ */
+static volatile void *scc_base;
+uint32_t scc_phys_base;
+
+/** Array to hold function pointers registered by
+    #scc_monitor_security_failure() and processed by
+    #scc_perform_callbacks() */
+static void (*scc_callbacks[SCC_CALLBACK_SIZE]) (void);
+/*SCC need IRAM's base address but use only the partitions allocated for it.*/
+uint32_t scm_ram_phys_base;
+
+void *scm_ram_base = NULL;
+
+/** Calculated once for quick reference to size of the unreserved space in
+ *  RAM in SCM.
+ */
+uint32_t scm_memory_size_bytes;
+
+/** Structure returned by #scc_get_configuration() */
+static scc_config_t scc_configuration = {
+	.driver_major_version = SCC_DRIVER_MAJOR_VERSION,
+	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_2,
+	.scm_version = -1,
+	.smn_version = -1,
+	.block_size_bytes = -1,
+	.partition_size_bytes = -1,
+	.partition_count = -1,
+};
+
+/** Internal flag to know whether SCC is in Failed state (and thus many
+ *  registers are unavailable).  Once it goes failed, it never leaves it. */
+static volatile enum scc_status scc_availability = SCC_STATUS_INITIAL;
+
+/** Flag to say whether interrupt handler has been registered for
+ * SMN interrupt */
+static int smn_irq_set = 0;
+
+/** Flag to say whether interrupt handler has been registered for
+ * SCM interrupt */
+static int scm_irq_set = 0;
+
+/** This lock protects the #scc_callbacks list as well as the @c
+ * callbacks_performed flag in #scc_perform_callbacks.  Since the data this
+ * protects may be read or written from either interrupt or base level, all
+ * operations should use the irqsave/irqrestore or similar to make sure that
+ * interrupts are inhibited when locking from base level.
+ */
+static os_lock_t scc_callbacks_lock = NULL;
+
+/**
+ * Ownership of this lock prevents conflicts on the crypto operation in the
+ * SCC.
+ */
+static os_lock_t scc_crypto_lock = NULL;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))
+/** Pointer to SCC's clock information.  Initialized during scc_init(). */
+static struct clk *scc_clk = NULL;
+#endif
+
+/** The lookup table for an 8-bit value.  Calculated once
+ * by #scc_init_ccitt_crc().
+ */
+static uint16_t scc_crc_lookup_table[256];
+
+/******************************************************************************
+ *
+ *  Function Implementations - Externally Accessible
+ *
+ *****************************************************************************/
+
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode access.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return
+ */
+scc_return_t scc_allocate_partition(uint32_t smid_value,
+				    int *part_no,
+				    void **part_base, uint32_t *part_phys)
+{
+	uint32_t i;
+	os_lock_context_t irq_flags = 0;	/* for IRQ save/restore */
+	int local_part;
+	scc_return_t retval = SCC_RET_FAIL;
+	void *base_addr = NULL;
+	uint32_t reg_value;
+
+	local_part = -1;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+	if (scc_availability == SCC_STATUS_UNIMPLEMENTED) {
+		goto out;
+	}
+
+	/* ACQUIRE LOCK to prevent others from using crypto or acquiring a
+	 * partition.  Note that crypto operations could take a long time, so the
+	 * calling process could potentially spin for some time.
+	 */
+	os_lock_save_context(scc_crypto_lock, irq_flags);
+
+	do {
+		/* Find current state of partition ownership */
+		reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+
+		/* Search for a free one */
+		for (i = 0; i < scc_configuration.partition_count; i++) {
+			if (((reg_value >> (SCM_POWN_SHIFT * i))
+			     & SCM_POWN_MASK) == SCM_POWN_PART_FREE) {
+				break;	/* found a free one */
+			}
+		}
+		if (i == local_part) {
+			/* found this one last time, and failed to allocated it */
+			pr_debug(KERN_ERR "Partition %d cannot be allocated\n",
+				 i);
+			goto out;
+		}
+		if (i >= scc_configuration.partition_count) {
+			retval = SCC_RET_INSUFFICIENT_SPACE;	/* all used up */
+			goto out;
+		}
+
+		pr_debug
+		    ("SCC2: Attempting to allocate partition %i, owners:%08x\n",
+		     i, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+		local_part = i;
+		/* Store SMID to grab a partition */
+		SCC_WRITE_REGISTER(SCM_SMID0_REG +
+				   SCM_SMID_WIDTH * (local_part), smid_value);
+		mdelay(2);
+
+		/* Now make sure it is ours... ? */
+		reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+
+		if (((reg_value >> (SCM_POWN_SHIFT * (local_part)))
+		     & SCM_POWN_MASK) != SCM_POWN_PART_OWNED) {
+			continue;	/* try for another */
+		}
+		base_addr = scm_ram_base +
+		    (local_part * scc_configuration.partition_size_bytes);
+		break;
+	} while (1);
+
+out:
+
+	/* Free the lock */
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
+
+	/* If the base address was assigned, then a partition was successfully
+	 * acquired.
+	 */
+	if (base_addr != NULL) {
+		pr_debug("SCC2 Part owners: %08x, engaged: %08x\n",
+			 reg_value, SCC_READ_REGISTER(SCM_PART_ENGAGED_REG));
+		pr_debug("SCC2 MAP for part %d: %08x\n",
+			 local_part,
+			 SCC_READ_REGISTER(SCM_ACC0_REG + 8 * local_part));
+
+		/* Copy the partition information to the data structures passed by the
+		 * user.
+		 */
+		*part_no = local_part;
+		*part_base = base_addr;
+		*part_phys = (uint32_t) scm_ram_phys_base
+		    + (local_part * scc_configuration.partition_size_bytes);
+		retval = SCC_RET_OK;
+
+		pr_debug
+		    ("SCC2 partition engaged.  Kernel address: %p.  Physical "
+		     "address: %p, pfn: %08x\n", *part_base, (void *)*part_phys,
+		     __phys_to_pfn(*part_phys));
+	}
+
+	return retval;
+}				/* allocate_partition() */
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t scc_release_partition(void *part_base)
+{
+	uint32_t partition_no;
+
+	if (part_base == NULL) {
+		return SCC_RET_FAIL;
+	}
+
+	/* Ensure that this is a proper partition location */
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	pr_debug("SCC2: Attempting to release partition %i, owners:%08x\n",
+		 partition_no, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+	/* check that the partition is ours to de-establish */
+	if (!host_owns_partition(partition_no)) {
+		return SCC_RET_FAIL;
+	}
+
+	/* TODO: The state of the zeroize engine (SRS field in the Command Status
+	 * Register) should be examined before issuing the zeroize command here.
+	 * To make the driver thread-safe, a lock should be taken out before
+	 * issuing the check and released after the zeroize command has been
+	 * issued.
+	 */
+
+	/* Zero the partition to release it */
+	scc_write_register(SCM_ZCMD_REG,
+			   (partition_no << SCM_ZCMD_PART_SHIFT) |
+			   (ZCMD_DEALLOC_PART << SCM_ZCMD_CCMD_SHIFT));
+	mdelay(2);
+
+	pr_debug("SCC2: done releasing partition %i, owners:%08x\n",
+		 partition_no, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+	/* Check that the de-assignment went correctly */
+	if (host_owns_partition(partition_no)) {
+		return SCC_RET_FAIL;
+	}
+
+	return SCC_RET_OK;
+}
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param   part_base     Kernel virtual address of the partition.
+ * @param   permissions   ORed values of the type SCM_PERM_* which will be used as
+ *                        initial partition permissions.  SHW API users should use
+ *                        the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t scc_diminish_permissions(void *part_base, uint32_t permissions)
+{
+	uint32_t partition_no;
+	uint32_t permissions_requested;
+	permissions_requested = permissions;
+
+	/* ensure that this is a proper partition location */
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	/* invert the permissions, masking out unused bits */
+	permissions = (~permissions) & SCM_PERM_MASK;
+
+	/* attempt to diminish the permissions */
+	scc_write_register(SCM_ACC0_REG + 8 * partition_no, permissions);
+	mdelay(2);
+
+	/* Reading it back puts it into the original form */
+	permissions = SCC_READ_REGISTER(SCM_ACC0_REG + 8 * partition_no);
+	if (permissions == permissions_requested) {
+		pr_debug("scc_partition_diminish_perms: successful\n");
+		pr_debug("scc_partition_diminish_perms: successful\n");
+		return SCC_RET_OK;
+	}
+	pr_debug("scc_partition_diminish_perms: not successful\n");
+
+	return SCC_RET_FAIL;
+}
+
+scc_partition_status_t scc_partition_status(void *part_base)
+{
+	uint32_t part_no;
+	uint32_t part_owner;
+
+	/* Determine the partition number from the address */
+	part_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	/* Check if the partition is implemented */
+	if (part_no >= scc_configuration.partition_count) {
+		return SCC_PART_S_UNUSABLE;
+	}
+
+	/* Determine the value of the partition owners register */
+	part_owner = (SCC_READ_REGISTER(SCM_PART_OWNERS_REG)
+		      >> (part_no * SCM_POWN_SHIFT)) & SCM_POWN_MASK;
+
+	switch (part_owner) {
+	case SCM_POWN_PART_OTHER:
+		return SCC_PART_S_UNAVAILABLE;
+		break;
+	case SCM_POWN_PART_FREE:
+		return SCC_PART_S_AVAILABLE;
+		break;
+	case SCM_POWN_PART_OWNED:
+		/* could be allocated or engaged*/
+		if (partition_engaged(part_no)) {
+			return SCC_PART_S_ENGAGED;
+		} else {
+			return SCC_PART_S_ALLOCATED;
+		}
+		break;
+	case SCM_POWN_PART_UNUSABLE:
+	default:
+		return SCC_PART_S_UNUSABLE;
+		break;
+	}
+}
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ *
+ * @param   address Kernel virtual address of data in an Secure Partition.
+ * @return  Physical address of said data.
+ */
+uint32_t scc_virt_to_phys(void *address)
+{
+	return (uint32_t) address - (uint32_t) scm_ram_base
+	    + (uint32_t) scm_ram_phys_base;
+}
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values from fsl_shw_permission_t which
+ * will be used as initial partiition permissions.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+
+scc_return_t
+scc_engage_partition(void *part_base,
+		     const uint8_t *UMID, uint32_t permissions)
+{
+	uint32_t partition_no;
+	uint8_t *UMID_base = part_base + 0x10;
+	uint32_t *MAP_base = part_base;
+	uint8_t i;
+
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	if (!host_owns_partition(partition_no) ||
+	    partition_engaged(partition_no) ||
+	    !(SCC_READ_REGISTER(SCM_SMID0_REG + (partition_no * 8)) == 0)) {
+
+		return SCC_RET_FAIL;
+	}
+
+	if (UMID != NULL) {
+		for (i = 0; i < 16; i++) {
+			UMID_base[i] = UMID[i];
+		}
+	}
+
+	MAP_base[0] = permissions;
+
+	udelay(20);
+
+	/* Check that the partition was engaged correctly, and that it has the
+	 * proper permissions.
+	 */
+
+	if ((!partition_engaged(partition_no)) ||
+	    (permissions !=
+	     SCC_READ_REGISTER(SCM_ACC0_REG + 8 * partition_no))) {
+		return SCC_RET_FAIL;
+	}
+
+	return SCC_RET_OK;
+}
+
+/*****************************************************************************/
+/* fn scc_init()                                                             */
+/*****************************************************************************/
+/**
+ *  Initialize the driver at boot time or module load time.
+ *
+ *  Register with the kernel as the interrupt handler for the SCC interrupt
+ *  line(s).
+ *
+ *  Map the SCC's register space into the driver's memory space.
+ *
+ *  Query the SCC for its configuration and status.  Save the configuration in
+ *  #scc_configuration and save the status in #scc_availability.  Called by the
+ *  kernel.
+ *
+ *  Do any locking/wait queue initialization which may be necessary.
+ *
+ *  The availability fuse may be checked, depending on platform.
+ */
+static int scc_init(void)
+{
+	uint32_t smn_status;
+	int i;
+	int return_value = -EIO;	/* assume error */
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+
+		/* Set this until we get an initial reading */
+		scc_availability = SCC_STATUS_CHECKING;
+
+		/* Initialize the constant for the CRC function */
+		scc_init_ccitt_crc();
+
+		/* initialize the callback table */
+		for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
+			scc_callbacks[i] = 0;
+		}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+		mxc_clks_enable(SCC_CLK);
+#else
+		if (IS_ERR(scc_clk)) {
+			return_value = PTR_ERR(scc_clk);
+			goto out;
+		} else
+			clk_enable(scc_clk);
+#endif
+
+		/* Set up the hardware access locks */
+		scc_callbacks_lock = os_lock_alloc_init();
+		scc_crypto_lock = os_lock_alloc_init();
+		if (scc_callbacks_lock == NULL || scc_crypto_lock == NULL) {
+			os_printk(KERN_ERR
+				  "SCC2: Failed to allocate context locks.  Exiting.\n");
+			goto out;
+		}
+
+		/* See whether there is an SCC available */
+		if (0 && !SCC_ENABLED()) {
+			os_printk(KERN_ERR
+				  "SCC2: Fuse for SCC is set to disabled.  Exiting.\n");
+			goto out;
+		}
+		/* Map the SCC (SCM and SMN) memory on the internal bus into
+		   kernel address space */
+		scc_base = (void *)ioremap(scc_phys_base, SZ_4K);
+		if (scc_base == NULL) {
+			os_printk(KERN_ERR
+				  "SCC2: Register mapping failed.  Exiting.\n");
+			goto out;
+		}
+
+		/* If that worked, we can try to use the SCC */
+		/* Get SCM into 'clean' condition w/interrupts cleared &
+		   disabled */
+		SCC_WRITE_REGISTER(SCM_INT_CTL_REG, 0);
+
+		/* Clear error status register */
+		(void)SCC_READ_REGISTER(SCM_ERR_STATUS_REG);
+
+		/*
+		 * There is an SCC.  Determine its current state.  Side effect
+		 * is to populate scc_config and scc_availability
+		 */
+		smn_status = scc_grab_config_values();
+
+		/* Try to set up interrupt handler(s) */
+		if (scc_availability != SCC_STATUS_OK) {
+			goto out;
+		}
+
+		scm_ram_base = (void *)ioremap_nocache(scm_ram_phys_base,
+						       scc_configuration.
+						       partition_count *
+						       scc_configuration.
+						       partition_size_bytes);
+		if (scm_ram_base == NULL) {
+			os_printk(KERN_ERR
+				  "SCC2: RAM failed to remap: %p for %d bytes\n",
+				  (void *)scm_ram_phys_base,
+				  scc_configuration.partition_count *
+				  scc_configuration.partition_size_bytes);
+			goto out;
+		}
+		pr_debug("SCC2: RAM at Physical %p / Virtual %p\n",
+			 (void *)scm_ram_phys_base, scm_ram_base);
+
+		pr_debug("Secure Partition Table: Found %i partitions\n",
+			 scc_configuration.partition_count);
+
+		if (setup_interrupt_handling() != 0) {
+			unsigned err_cond;
+	    /**
+		* The error could be only that the SCM interrupt was
+		* not set up.  This interrupt is always masked, so
+		* that is not an issue.
+		* The SMN's interrupt may be shared on that line, it
+		* may be separate, or it may not be wired.  Do what
+		* is necessary to check its status.
+		* Although the driver is coded for possibility of not
+		* having SMN interrupt, the fact that there is one
+		* means it should be available and used.
+		*/
+#ifdef USE_SMN_INTERRUPT
+			err_cond = !smn_irq_set;	/* Separate. Check SMN binding */
+#elif !defined(NO_SMN_INTERRUPT)
+			err_cond = !scm_irq_set;	/* Shared. Check SCM binding */
+#else
+			err_cond = FALSE;	/*  SMN not wired at all.  Ignore. */
+#endif
+			if (err_cond) {
+				/* setup was not able to set up SMN interrupt */
+				scc_availability = SCC_STATUS_UNIMPLEMENTED;
+				goto out;
+			}
+		}
+
+		/* interrupt handling returned non-zero */
+		/* Get SMN into 'clean' condition w/interrupts cleared &
+		   enabled */
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_CLEAR_INTERRUPT
+				   | SMN_COMMAND_ENABLE_INTERRUPT);
+
+	      out:
+		/*
+		 * If status is SCC_STATUS_UNIMPLEMENTED or is still
+		 * SCC_STATUS_CHECKING, could be leaving here with the driver partially
+		 * initialized.  In either case, cleanup (which will mark the SCC as
+		 * UNIMPLEMENTED).
+		 */
+		if (scc_availability == SCC_STATUS_CHECKING ||
+		    scc_availability == SCC_STATUS_UNIMPLEMENTED) {
+			scc_cleanup();
+		} else {
+			return_value = 0;	/* All is well */
+		}
+	}
+	/* ! STATUS_INITIAL */
+	os_printk(KERN_ALERT "SCC2: Driver Status is %s\n",
+		  (scc_availability == SCC_STATUS_INITIAL) ? "INITIAL" :
+		  (scc_availability == SCC_STATUS_CHECKING) ? "CHECKING" :
+		  (scc_availability ==
+		   SCC_STATUS_UNIMPLEMENTED) ? "UNIMPLEMENTED"
+		  : (scc_availability ==
+		     SCC_STATUS_OK) ? "OK" : (scc_availability ==
+					      SCC_STATUS_FAILED) ? "FAILED" :
+		  "UNKNOWN");
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+			mxc_clks_disable(SCC_CLK);
+#else
+			if (!IS_ERR(scc_clk))
+				clk_disable(scc_clk);
+#endif
+
+	return return_value;
+}				/* scc_init */
+
+/*****************************************************************************/
+/* fn scc_cleanup()                                                          */
+/*****************************************************************************/
+/**
+ * Perform cleanup before driver/module is unloaded by setting the machine
+ * state close to what it was when the driver was loaded.  This function is
+ * called when the kernel is shutting down or when this driver is being
+ * unloaded.
+ *
+ * A driver like this should probably never be unloaded, especially if there
+ * are other module relying upon the callback feature for monitoring the SCC
+ * status.
+ *
+ * In any case, cleanup the callback table (by clearing out all of the
+ * pointers).  Deregister the interrupt handler(s).  Unmap SCC registers.
+ *
+ * Note that this will not release any partitions that have been allocated.
+ *
+ */
+static void scc_cleanup(void)
+{
+	int i;
+
+    /******************************************************/
+
+	/* Mark the driver / SCC as unusable. */
+	scc_availability = SCC_STATUS_UNIMPLEMENTED;
+
+	/* Clear out callback table */
+	for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
+		scc_callbacks[i] = 0;
+	}
+
+	/* If SCC has been mapped in, clean it up and unmap it */
+	if (scc_base) {
+		/* For the SCM, disable interrupts. */
+		SCC_WRITE_REGISTER(SCM_INT_CTL_REG, 0);
+
+		/* For the SMN, clear and disable interrupts */
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_CLEAR_INTERRUPT);
+	}
+
+	/* Now that interrupts cannot occur, disassociate driver from the interrupt
+	 * lines.
+	 */
+
+	/* Deregister SCM interrupt handler */
+	if (scm_irq_set) {
+		os_deregister_interrupt(INT_SCC_SCM);
+	}
+
+	/* Deregister SMN interrupt handler */
+	if (smn_irq_set) {
+#ifdef USE_SMN_INTERRUPT
+		os_deregister_interrupt(INT_SCC_SMN);
+#endif
+	}
+
+	/* Finally, release the mapped memory */
+	iounmap(scm_ram_base);
+
+	if (scc_callbacks_lock != NULL)
+		os_lock_deallocate(scc_callbacks_lock);
+
+	if (scc_crypto_lock != NULL)
+		os_lock_deallocate(scc_crypto_lock);
+
+    /*Disabling SCC Clock*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+			mxc_clks_disable(SCC_CLK);
+#else
+			if (!IS_ERR(scc_clk))
+				clk_disable(scc_clk);
+			clk_put(scc_clk);
+#endif
+	pr_debug("SCC2 driver cleaned up.\n");
+
+}				/* scc_cleanup */
+
+/*****************************************************************************/
+/* fn scc_get_configuration()                                                */
+/*****************************************************************************/
+scc_config_t *scc_get_configuration(void)
+{
+	/*
+	 * If some other driver calls scc before the kernel does, make sure that
+	 * this driver's initialization is performed.
+	 */
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+    /**
+     * If there is no SCC, yet the driver exists, the value -1 will be in
+     * the #scc_config_t fields for other than the driver versions.
+     */
+	return &scc_configuration;
+}				/* scc_get_configuration */
+
+/*****************************************************************************/
+/* fn scc_zeroize_memories()                                                 */
+/*****************************************************************************/
+scc_return_t scc_zeroize_memories(void)
+{
+	scc_return_t return_status = SCC_RET_FAIL;
+
+	return return_status;
+}				/* scc_zeroize_memories */
+
+/*****************************************************************************/
+/* fn scc_set_sw_alarm()                                                     */
+/*****************************************************************************/
+void scc_set_sw_alarm(void)
+{
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+	/* Update scc_availability based on current SMN status.  This might
+	 * perform callbacks.
+	 */
+	(void)scc_update_state();
+
+	/* if everything is OK, make it fail */
+	if (scc_availability == SCC_STATUS_OK) {
+
+		/* sound the alarm (and disable SMN interrupts */
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_SET_SOFTWARE_ALARM);
+
+		scc_availability = SCC_STATUS_FAILED;	/* Remember what we've done */
+
+		/* In case SMN interrupt is not available, tell the world */
+		scc_perform_callbacks();
+	}
+
+	return;
+}				/* scc_set_sw_alarm */
+
+/*****************************************************************************/
+/* fn scc_monitor_security_failure()                                         */
+/*****************************************************************************/
+scc_return_t scc_monitor_security_failure(void callback_func(void))
+{
+	int i;
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	scc_return_t return_status = SCC_RET_TOO_MANY_FUNCTIONS;
+	int function_stored = FALSE;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
+	 * routine were just called from base (not interrupt) level
+	 */
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
+
+	/* Search through table looking for empty slot */
+	for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
+		if (scc_callbacks[i] == callback_func) {
+			if (function_stored) {
+				/* Saved duplicate earlier.  Clear this later one. */
+				scc_callbacks[i] = NULL;
+			}
+			/* Exactly one copy is now stored */
+			return_status = SCC_RET_OK;
+			break;
+		} else if (scc_callbacks[i] == NULL && !function_stored) {
+			/* Found open slot.  Save it and remember */
+			scc_callbacks[i] = callback_func;
+			return_status = SCC_RET_OK;
+			function_stored = TRUE;
+		}
+	}
+
+	/* Free the lock */
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
+
+	return return_status;
+}				/* scc_monitor_security_failure */
+
+/*****************************************************************************/
+/* fn scc_stop_monitoring_security_failure()                                 */
+/*****************************************************************************/
+void scc_stop_monitoring_security_failure(void callback_func(void))
+{
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	int i;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
+	 * routine were just called from base (not interrupt) level
+	 */
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
+
+	/* Search every entry of the table for this function */
+	for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
+		if (scc_callbacks[i] == callback_func) {
+			scc_callbacks[i] = NULL;	/* found instance - clear it out */
+			break;
+		}
+	}
+
+	/* Free the lock */
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
+
+	return;
+}				/* scc_stop_monitoring_security_failure */
+
+/*****************************************************************************/
+/* fn scc_read_register()                                                    */
+/*****************************************************************************/
+scc_return_t scc_read_register(int register_offset, uint32_t * value)
+{
+	scc_return_t return_status = SCC_RET_FAIL;
+	uint32_t smn_status;
+	uint32_t scm_status;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+	/* First layer of protection -- completely unaccessible SCC */
+	if (scc_availability != SCC_STATUS_UNIMPLEMENTED) {
+
+		/* Second layer -- that offset is valid */
+		if (register_offset != SMN_BB_DEC_REG &&	/* write only! */
+		    check_register_offset(register_offset) == SCC_RET_OK) {
+
+			/* Get current status / update local state */
+			smn_status = scc_update_state();
+			scm_status = SCC_READ_REGISTER(SCM_STATUS_REG);
+
+			/*
+			 * Third layer - verify that the register being requested is
+			 * available in the current state of the SCC.
+			 */
+			if ((return_status =
+			     check_register_accessible(register_offset,
+						       smn_status,
+						       scm_status)) ==
+			    SCC_RET_OK) {
+				*value = SCC_READ_REGISTER(register_offset);
+			}
+		}
+	}
+
+	return return_status;
+}				/* scc_read_register */
+
+/*****************************************************************************/
+/* fn scc_write_register()                                                   */
+/*****************************************************************************/
+scc_return_t scc_write_register(int register_offset, uint32_t value)
+{
+	scc_return_t return_status = SCC_RET_FAIL;
+	uint32_t smn_status;
+	uint32_t scm_status;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+
+	/* First layer of protection -- completely unaccessible SCC */
+	if (scc_availability != SCC_STATUS_UNIMPLEMENTED) {
+
+		/* Second layer -- that offset is valid */
+		if (!((register_offset == SCM_STATUS_REG) ||	/* These registers are */
+		      (register_offset == SCM_VERSION_REG) ||	/*  Read Only */
+		      (register_offset == SMN_BB_CNT_REG) ||
+		      (register_offset == SMN_TIMER_REG)) &&
+		    check_register_offset(register_offset) == SCC_RET_OK) {
+
+			/* Get current status / update local state */
+			smn_status = scc_update_state();
+			scm_status = SCC_READ_REGISTER(SCM_STATUS_REG);
+
+			/*
+			 * Third layer - verify that the register being requested is
+			 * available in the current state of the SCC.
+			 */
+			if (check_register_accessible
+			    (register_offset, smn_status, scm_status) == 0) {
+				SCC_WRITE_REGISTER(register_offset, value);
+				return_status = SCC_RET_OK;
+			}
+		}
+	}
+
+	return return_status;
+}				/* scc_write_register() */
+
+/******************************************************************************
+ *
+ *  Function Implementations - Internal
+ *
+ *****************************************************************************/
+
+/*****************************************************************************/
+/* fn scc_irq()                                                              */
+/*****************************************************************************/
+/**
+ * This is the interrupt handler for the SCC.
+ *
+ * This function checks the SMN Status register to see whether it
+ * generated the interrupt, then it checks the SCM Status register to
+ * see whether it needs attention.
+ *
+ * If an SMN Interrupt is active, then the SCC state set to failure, and
+ * #scc_perform_callbacks() is invoked to notify any interested parties.
+ *
+ * The SCM Interrupt should be masked, as this driver uses polling to determine
+ * when the SCM has completed a crypto or zeroing operation.  Therefore, if the
+ * interrupt is active, the driver will just clear the interrupt and (re)mask.
+ */
+OS_DEV_ISR(scc_irq)
+{
+	uint32_t smn_status;
+	uint32_t scm_status;
+	int handled = 0;	/* assume interrupt isn't from SMN */
+#if defined(USE_SMN_INTERRUPT)
+	int smn_irq = INT_SCC_SMN;	/* SMN interrupt is on a line by itself */
+#elif defined (NO_SMN_INTERRUPT)
+	int smn_irq = -1;	/* not wired to CPU at all */
+#else
+	int smn_irq = INT_SCC_SCM;	/* SMN interrupt shares a line with SCM */
+#endif
+
+	/* Update current state... This will perform callbacks... */
+	smn_status = scc_update_state();
+
+	/* SMN is on its own interrupt line.  Verify the IRQ was triggered
+	 * before clearing the interrupt and marking it handled.  */
+	if ((os_dev_get_irq() == smn_irq) &&
+	    (smn_status & SMN_STATUS_SMN_STATUS_IRQ)) {
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_CLEAR_INTERRUPT);
+		handled++;	/* tell kernel that interrupt was handled */
+	}
+
+	/* Check on the health of the SCM */
+	scm_status = SCC_READ_REGISTER(SCM_STATUS_REG);
+
+	/* The driver masks interrupts, so this should never happen. */
+	if (os_dev_get_irq() == INT_SCC_SCM) {
+		/* but if it does, try to prevent it in the future */
+		SCC_WRITE_REGISTER(SCM_INT_CTL_REG, 0);
+		handled++;
+	}
+
+	/* Any non-zero value of handled lets kernel know we got something */
+	os_dev_isr_return(handled);
+}
+
+/*****************************************************************************/
+/* fn scc_perform_callbacks()                                                */
+/*****************************************************************************/
+/** Perform callbacks registered by #scc_monitor_security_failure().
+ *
+ *  Make sure callbacks only happen once...  Since there may be some reason why
+ *  the interrupt isn't generated, this routine could be called from base(task)
+ *  level.
+ *
+ *  One at a time, go through #scc_callbacks[] and call any non-null pointers.
+ */
+static void scc_perform_callbacks(void)
+{
+	static int callbacks_performed = 0;
+	unsigned long irq_flags;	/* for IRQ save/restore */
+	int i;
+
+	/* Acquire lock of callbacks table and callbacks_performed flag */
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
+
+	if (!callbacks_performed) {
+		callbacks_performed = 1;
+
+		/* Loop over all of the entries in the table */
+		for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
+			/* If not null, ... */
+			if (scc_callbacks[i]) {
+				scc_callbacks[i] ();	/* invoke the callback routine */
+			}
+		}
+	}
+
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
+
+	return;
+}
+
+/*****************************************************************************/
+/* fn scc_update_state()                                                     */
+/*****************************************************************************/
+/**
+ * Make certain SCC is still running.
+ *
+ * Side effect is to update #scc_availability and, if the state goes to failed,
+ * run #scc_perform_callbacks().
+ *
+ * (If #SCC_BRINGUP is defined, bring SCC to secure state if it is found to be
+ * in health check state)
+ *
+ * @return Current value of #SMN_STATUS_REG register.
+ */
+static uint32_t scc_update_state(void)
+{
+	uint32_t smn_status_register = SMN_STATE_FAIL;
+	int smn_state;
+
+	/* if FAIL or UNIMPLEMENTED, don't bother */
+	if (scc_availability == SCC_STATUS_CHECKING ||
+	    scc_availability == SCC_STATUS_OK) {
+
+		smn_status_register = SCC_READ_REGISTER(SMN_STATUS_REG);
+		smn_state = smn_status_register & SMN_STATUS_STATE_MASK;
+
+#ifdef SCC_BRINGUP
+		/* If in Health Check while booting, try to 'bringup' to Secure mode */
+		if (scc_availability == SCC_STATUS_CHECKING &&
+		    smn_state == SMN_STATE_HEALTH_CHECK) {
+			/* Code up a simple algorithm for the ASC */
+			SCC_WRITE_REGISTER(SMN_SEQ_START_REG, 0xaaaa);
+			SCC_WRITE_REGISTER(SMN_SEQ_END_REG, 0x5555);
+			SCC_WRITE_REGISTER(SMN_SEQ_CHECK_REG, 0x5555);
+			/* State should be SECURE now */
+			smn_status_register = SCC_READ_REGISTER(SMN_STATUS);
+			smn_state = smn_status_register & SMN_STATUS_STATE_MASK;
+		}
+#endif
+
+		/*
+		 * State should be SECURE or NON_SECURE for operation of the part.  If
+		 * FAIL, mark failed (i.e. limited access to registers).  Any other
+		 * state, mark unimplemented, as the SCC is unuseable.
+		 */
+		if (smn_state == SMN_STATE_SECURE
+		    || smn_state == SMN_STATE_NON_SECURE) {
+			/* Healthy */
+			scc_availability = SCC_STATUS_OK;
+		} else if (smn_state == SMN_STATE_FAIL) {
+			scc_availability = SCC_STATUS_FAILED;	/* uh oh - unhealthy */
+			scc_perform_callbacks();
+			os_printk(KERN_ERR "SCC2: SCC went into FAILED mode\n");
+		} else {
+			/* START, ZEROIZE RAM, HEALTH CHECK, or unknown */
+			scc_availability = SCC_STATUS_UNIMPLEMENTED;	/* unuseable */
+			os_printk(KERN_ERR
+				  "SCC2: SCC declared UNIMPLEMENTED\n");
+		}
+	}
+	/* if availability is initial or ok */
+	return smn_status_register;
+}
+
+/*****************************************************************************/
+/* fn scc_init_ccitt_crc()                                                   */
+/*****************************************************************************/
+/**
+ * Populate the partial CRC lookup table.
+ *
+ * @return   none
+ *
+ */
+static void scc_init_ccitt_crc(void)
+{
+	int dividend;		/* index for lookup table */
+	uint16_t remainder;	/* partial value for a given dividend */
+	int bit;		/* index into bits of a byte */
+
+	/*
+	 * Compute the remainder of each possible dividend.
+	 */
+	for (dividend = 0; dividend < 256; ++dividend) {
+		/*
+		 * Start with the dividend followed by zeros.
+		 */
+		remainder = dividend << (8);
+
+		/*
+		 * Perform modulo-2 division, a bit at a time.
+		 */
+		for (bit = 8; bit > 0; --bit) {
+			/*
+			 * Try to divide the current data bit.
+			 */
+			if (remainder & 0x8000) {
+				remainder = (remainder << 1) ^ CRC_POLYNOMIAL;
+			} else {
+				remainder = (remainder << 1);
+			}
+		}
+
+		/*
+		 * Store the result into the table.
+		 */
+		scc_crc_lookup_table[dividend] = remainder;
+	}
+
+}				/* scc_init_ccitt_crc() */
+
+/*****************************************************************************/
+/* fn grab_config_values()                                                   */
+/*****************************************************************************/
+/**
+ * grab_config_values() will read the SCM Configuration and SMN Status
+ * registers and store away version and size information for later use.
+ *
+ * @return The current value of the SMN Status register.
+ */
+static uint32_t scc_grab_config_values(void)
+{
+	uint32_t scm_version_register;
+	uint32_t smn_status_register = SMN_STATE_FAIL;
+
+	if (scc_availability != SCC_STATUS_CHECKING) {
+		goto out;
+	}
+	scm_version_register = SCC_READ_REGISTER(SCM_VERSION_REG);
+
+	/* Get SMN status and update scc_availability */
+	smn_status_register = scc_update_state();
+
+	/* save sizes and versions information for later use */
+	scc_configuration.block_size_bytes = 16;	/* BPCP ? */
+	scc_configuration.partition_count =
+	    1 + ((scm_version_register & SCM_VER_NP_MASK) >> SCM_VER_NP_SHIFT);
+	scc_configuration.partition_size_bytes =
+	    1 << ((scm_version_register & SCM_VER_BPP_MASK) >>
+		  SCM_VER_BPP_SHIFT);
+	scc_configuration.scm_version =
+	    (scm_version_register & SCM_VER_MAJ_MASK) >> SCM_VER_MAJ_SHIFT;
+	scc_configuration.smn_version =
+	    (smn_status_register & SMN_STATUS_VERSION_ID_MASK)
+	    >> SMN_STATUS_VERSION_ID_SHIFT;
+	if (scc_configuration.scm_version != SCM_MAJOR_VERSION_2) {
+		scc_availability = SCC_STATUS_UNIMPLEMENTED;	/* Unknown version */
+	}
+
+      out:
+	return smn_status_register;
+}				/* grab_config_values */
+
+/*****************************************************************************/
+/* fn setup_interrupt_handling()                                             */
+/*****************************************************************************/
+/**
+ * Register the SCM and SMN interrupt handlers.
+ *
+ * Called from #scc_init()
+ *
+ * @return 0 on success
+ */
+static int setup_interrupt_handling(void)
+{
+	int smn_error_code = -1;
+	int scm_error_code = -1;
+
+	/* Disnable SCM interrupts */
+	SCC_WRITE_REGISTER(SCM_INT_CTL_REG, 0);
+
+#ifdef USE_SMN_INTERRUPT
+	/* Install interrupt service routine for SMN. */
+	smn_error_code = os_register_interrupt(SCC_DRIVER_NAME,
+					       INT_SCC_SMN, scc_irq);
+	if (smn_error_code != 0) {
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SMN Interrupt Handler: %d\n",
+			  smn_error_code);
+	} else {
+		smn_irq_set = 1;	/* remember this for cleanup */
+		/* Enable SMN interrupts */
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_CLEAR_INTERRUPT |
+				   SMN_COMMAND_ENABLE_INTERRUPT);
+	}
+#else
+	smn_error_code = 0;	/* no problems... will handle later */
+#endif
+
+	/*
+	 * Install interrupt service routine for SCM (or both together).
+	 */
+	scm_error_code = os_register_interrupt(SCC_DRIVER_NAME,
+					       INT_SCC_SCM, scc_irq);
+	if (scm_error_code != 0) {
+#ifndef MXC
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SCM Interrupt Handler: %d\n",
+			  scm_error_code);
+#else
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SCC Interrupt Handler: %d\n",
+			  scm_error_code);
+#endif
+	} else {
+		scm_irq_set = 1;	/* remember this for cleanup */
+#if defined(USE_SMN_INTERRUPT) && !defined(NO_SMN_INTERRUPT)
+		/* Enable SMN interrupts */
+		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
+				   SMN_COMMAND_CLEAR_INTERRUPT |
+				   SMN_COMMAND_ENABLE_INTERRUPT);
+#endif
+	}
+
+	/* Return an error if one was encountered */
+	return scm_error_code ? scm_error_code : smn_error_code;
+}				/* setup_interrupt_handling */
+
+/*****************************************************************************/
+/* fn scc_do_crypto()                                                        */
+/*****************************************************************************/
+/** Have the SCM perform the crypto function.
+ *
+ * Set up length register, and the store @c scm_control into control register
+ * to kick off the operation.  Wait for completion, gather status, clear
+ * interrupt / status.
+ *
+ * @param byte_count  number of bytes to perform in this operation
+ * @param scm_command Bit values to be set in @c SCM_CCMD_REG register
+ *
+ * @return 0 on success, value of #SCM_ERR_STATUS_REG on failure
+ */
+static uint32_t scc_do_crypto(int byte_count, uint32_t scm_command)
+{
+	int block_count = byte_count / SCC_BLOCK_SIZE_BYTES();
+	uint32_t crypto_status;
+	scc_return_t ret;
+
+	/* This seems to be necessary in order to allow subsequent cipher
+	 * operations to succeed when a partition is deallocated/reallocated!
+	 */
+	(void)SCC_READ_REGISTER(SCM_STATUS_REG);
+
+	/* In length register, 0 means 1, etc. */
+	scm_command |= (block_count - 1) << SCM_CCMD_LENGTH_SHIFT;
+
+	/* set modes and kick off the operation */
+	SCC_WRITE_REGISTER(SCM_CCMD_REG, scm_command);
+
+	ret = scc_wait_completion(&crypto_status);
+
+	/* Only done bit should be on */
+	if (crypto_status & SCM_STATUS_ERR) {
+		/* Replace with error status instead */
+		crypto_status = SCC_READ_REGISTER(SCM_ERR_STATUS_REG);
+		pr_debug("SCM Failure: 0x%x\n", crypto_status);
+		if (crypto_status == 0) {
+			/* That came up 0.  Turn on arbitrary bit to signal error. */
+			crypto_status = SCM_ERRSTAT_ILM;
+		}
+	} else {
+		crypto_status = 0;
+	}
+	pr_debug("SCC2: Done waiting.\n");
+
+	return crypto_status;
+}
+
+/**
+ * Encrypt a region of secure memory.
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the IV.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t
+scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+		   uint32_t byte_count, uint8_t *black_data,
+		   uint32_t *IV, scc_cypher_mode_t cypher_mode)
+{
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	scc_return_t status = SCC_RET_OK;
+	uint32_t crypto_status;
+	uint32_t scm_command;
+	int offset_blocks = offset_bytes / SCC_BLOCK_SIZE_BYTES();
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+				mxc_clks_enable(SCC_CLK);
+#else
+		if (IS_ERR(scc_clk)) {
+			status = SCC_RET_FAIL;
+			goto out;
+		} else
+			clk_enable(scc_clk);
+#endif
+
+	scm_command = ((offset_blocks << SCM_CCMD_OFFSET_SHIFT) |
+		       (SCM_PART_NUMBER(part_base) << SCM_CCMD_PART_SHIFT));
+
+	switch (cypher_mode) {
+	case SCC_CYPHER_MODE_CBC:
+		scm_command |= SCM_CCMD_AES_ENC_CBC;
+		break;
+	case SCC_CYPHER_MODE_ECB:
+		scm_command |= SCM_CCMD_AES_ENC_ECB;
+		break;
+	default:
+		status = SCC_RET_FAIL;
+		break;
+	}
+
+	pr_debug("Received encrypt request.  SCM_C_BLACK_ST_REG: %p, "
+		 "scm_Command: %08x, length: %i (part_base: %08x, "
+		 "offset: %i)\n",
+		 black_data, scm_command, byte_count, part_base, offset_blocks);
+
+	if (status != SCC_RET_OK)
+		goto out;
+
+	/* ACQUIRE LOCK to prevent others from using crypto or releasing slot */
+	os_lock_save_context(scc_crypto_lock, irq_flags);
+
+	if (status == SCC_RET_OK) {
+		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, (uint32_t) black_data);
+
+		/* Only write the IV if it will actually be used */
+		if (cypher_mode == SCC_CYPHER_MODE_CBC) {
+			/* Write the IV register */
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG, *(IV));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG, *(IV + 1));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, *(IV + 2));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, *(IV + 3));
+		}
+
+		/* Set modes and kick off the encryption */
+		crypto_status = scc_do_crypto(byte_count, scm_command);
+
+		if (crypto_status != 0) {
+			pr_debug("SCM encrypt red crypto failure: 0x%x\n",
+				 crypto_status);
+		} else {
+			status = SCC_RET_OK;
+			pr_debug("SCC2: Encrypted %d bytes\n", byte_count);
+		}
+	}
+
+	os_unlock_restore_context(scc_crypto_lock, irq_flags);
+
+out:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+					mxc_clks_disable(SCC_CLK);
+#else
+					if (!IS_ERR(scc_clk))
+						clk_disable(scc_clk);
+#endif
+
+	return status;
+}
+
+/* Decrypt a region into secure memory
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_counts  Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the IV.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t
+scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+		   uint32_t byte_count, uint8_t *black_data,
+		   uint32_t *IV, scc_cypher_mode_t cypher_mode)
+{
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	scc_return_t status = SCC_RET_OK;
+	uint32_t crypto_status;
+	uint32_t scm_command;
+	int offset_blocks = offset_bytes / SCC_BLOCK_SIZE_BYTES();
+
+    /*Enabling SCC clock.*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+			mxc_clks_enable(SCC_CLK);
+#else
+		if (IS_ERR(scc_clk)) {
+			status = SCC_RET_FAIL;
+			goto out;
+		} else
+			clk_enable(scc_clk);
+#endif
+	scm_command = ((offset_blocks << SCM_CCMD_OFFSET_SHIFT) |
+		       (SCM_PART_NUMBER(part_base) << SCM_CCMD_PART_SHIFT));
+
+	switch (cypher_mode) {
+	case SCC_CYPHER_MODE_CBC:
+		scm_command |= SCM_CCMD_AES_DEC_CBC;
+		break;
+	case SCC_CYPHER_MODE_ECB:
+		scm_command |= SCM_CCMD_AES_DEC_ECB;
+		break;
+	default:
+		status = SCC_RET_FAIL;
+		break;
+	}
+
+	pr_debug("Received decrypt request.  SCM_C_BLACK_ST_REG: %p, "
+		 "scm_Command: %08x, length: %i (part_base: %08x, "
+		 "offset: %i)\n",
+		 black_data, scm_command, byte_count, part_base, offset_blocks);
+
+	if (status != SCC_RET_OK)
+		goto out;
+
+	/* ACQUIRE LOCK to prevent others from using crypto or releasing slot */
+	os_lock_save_context(scc_crypto_lock, irq_flags);
+
+	if (status == SCC_RET_OK) {
+		status = SCC_RET_FAIL;	/* reset expectations */
+		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, (uint32_t) black_data);
+
+		/* Write the IV register */
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG, *(IV));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG, *(IV + 1));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, *(IV + 2));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, *(IV + 3));
+
+		/* Set modes and kick off the decryption */
+		crypto_status = scc_do_crypto(byte_count, scm_command);
+
+		if (crypto_status != 0) {
+			pr_debug("SCM decrypt black crypto failure: 0x%x\n",
+				 crypto_status);
+		} else {
+			status = SCC_RET_OK;
+			pr_debug("SCC2: Decrypted %d bytes\n", byte_count);
+		}
+	}
+
+	os_unlock_restore_context(scc_crypto_lock, irq_flags);
+out:
+    /*Disabling the Clock when the driver is not in use.*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+			mxc_clks_disable(SCC_CLK);
+#else
+			if (!IS_ERR(scc_clk))
+				clk_disable(scc_clk);
+#endif
+	return status;
+}
+
+/*****************************************************************************/
+/* fn host_owns_partition()                                                  */
+/*****************************************************************************/
+/**
+ * Determine if the host owns a given partition.
+ *
+ * @internal
+ *
+ * @param part_no       Partition number to query
+ *
+ * @return TRUE if the host owns the partition, FALSE otherwise.
+ */
+
+static uint32_t host_owns_partition(uint32_t part_no)
+{
+	uint32_t value;
+
+	if (part_no < scc_configuration.partition_count) {
+
+		/* Check the partition owners register */
+		value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+		if (((value >> (part_no * SCM_POWN_SHIFT)) & SCM_POWN_MASK)
+		    == SCM_POWN_PART_OWNED)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+/* fn partition_engaged()                                                    */
+/*****************************************************************************/
+/**
+ * Determine if the given partition is engaged.
+ *
+ * @internal
+ *
+ * @param part_no       Partition number to query
+ *
+ * @return TRUE if the partition is engaged, FALSE otherwise.
+ */
+
+static uint32_t partition_engaged(uint32_t part_no)
+{
+	uint32_t value;
+
+	if (part_no < scc_configuration.partition_count) {
+
+		/* Check the partition engaged register */
+		value = SCC_READ_REGISTER(SCM_PART_ENGAGED_REG);
+		if (((value >> (part_no * SCM_PENG_SHIFT)) & 0x1)
+		    == SCM_PENG_ENGAGED)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+/* fn scc_wait_completion()                                                  */
+/*****************************************************************************/
+/**
+ * Poll looking for end-of-cipher indication. Only used
+ * if @c SCC_SCM_SLEEP is not defined.
+ *
+ * @internal
+ *
+ * On a Tahiti, crypto under 230 or so bytes is done after the first loop, all
+ * the way up to five sets of spins for 1024 bytes.  (8- and 16-byte functions
+ * are done when we first look.  Zeroizing takes one pass around.
+ *
+ * @param   scm_status      Address of the SCM_STATUS register
+ *
+ * @return  A return code of type #scc_return_t
+ */
+static scc_return_t scc_wait_completion(uint32_t * scm_status)
+{
+	scc_return_t ret;
+	int done;
+	int i = 0;
+
+	/* check for completion by polling */
+	do {
+		done = is_cipher_done(scm_status);
+		if (done)
+			break;
+		/* TODO: shorten this delay */
+		udelay(1000);
+	} while (i++ < SCC_CIPHER_MAX_POLL_COUNT);
+
+	pr_debug("SCC2: Polled DONE %d times\n", i);
+	if (!done) {
+		ret = SCC_RET_FAIL;
+	}
+
+	return ret;
+}				/* scc_wait_completion() */
+
+/*****************************************************************************/
+/* fn is_cipher_done()                                                       */
+/*****************************************************************************/
+/**
+ * This function returns non-zero if SCM Status register indicates
+ * that a cipher has terminated or some other interrupt-generating
+ * condition has occurred.
+ *
+ * @param scm_status    Address of the SCM STATUS register
+ *
+ * @return  0 if cipher operations are finished
+ */
+static int is_cipher_done(uint32_t * scm_status)
+{
+	register unsigned status;
+	register int cipher_done;
+
+	*scm_status = SCC_READ_REGISTER(SCM_STATUS_REG);
+	status = (*scm_status & SCM_STATUS_SRS_MASK) >> SCM_STATUS_SRS_SHIFT;
+
+	/*
+	 * Done when SCM is not in 'currently performing a function' states.
+	 */
+	cipher_done = ((status != SCM_STATUS_SRS_ZBUSY)
+		       && (status != SCM_STATUS_SRS_CBUSY)
+		       && (status != SCM_STATUS_SRS_ABUSY));
+
+	return cipher_done;
+}				/* is_cipher_done() */
+
+/*****************************************************************************/
+/* fn offset_within_smn()                                                    */
+/*****************************************************************************/
+/*!
+ *  Check that the offset is with the bounds of the SMN register set.
+ *
+ *  @param[in]  register_offset    register offset of SMN.
+ *
+ *  @return   1 if true, 0 if false (not within SMN)
+ */
+static inline int offset_within_smn(uint32_t register_offset)
+{
+	return ((register_offset >= SMN_STATUS_REG)
+		&& (register_offset <= SMN_HAC_REG));
+}
+
+/*****************************************************************************/
+/* fn offset_within_scm()                                                    */
+/*****************************************************************************/
+/*!
+ *  Check that the offset is with the bounds of the SCM register set.
+ *
+ *  @param[in]  register_offset    Register offset of SCM
+ *
+ *  @return   1 if true, 0 if false (not within SCM)
+ */
+static inline int offset_within_scm(uint32_t register_offset)
+{
+	return 1;		/* (register_offset >= SCM_RED_START)
+				   && (register_offset < scm_highest_memory_address); */
+/* Although this would cause trouble for zeroize testing, this change would
+ * close a security hole which currently allows any kernel program to access
+ * any location in RED RAM.  Perhaps enforce in non-SCC_DEBUG compiles?
+ && (register_offset <= SCM_INIT_VECTOR_1); */
+}
+
+/*****************************************************************************/
+/* fn check_register_accessible()                                            */
+/*****************************************************************************/
+/**
+ *  Given the current SCM and SMN status, verify that access to the requested
+ *  register should be OK.
+ *
+ *  @param[in]   register_offset  register offset within SCC
+ *  @param[in]   smn_status  recent value from #SMN_STATUS_REG
+ *  @param[in]   scm_status  recent value from #SCM_STATUS_REG
+ *
+ *  @return   #SCC_RET_OK if ok, #SCC_RET_FAIL if not
+ */
+static scc_return_t
+check_register_accessible(uint32_t register_offset, uint32_t smn_status,
+			  uint32_t scm_status)
+{
+	int error_code = SCC_RET_FAIL;
+
+	/* Verify that the register offset passed in is not among the verboten set
+	 * if the SMN is in Fail mode.
+	 */
+	if (offset_within_smn(register_offset)) {
+		if ((smn_status & SMN_STATUS_STATE_MASK) == SMN_STATE_FAIL) {
+			if (!((register_offset == SMN_STATUS_REG) ||
+			      (register_offset == SMN_COMMAND_REG) ||
+			      (register_offset == SMN_SEC_VIO_REG))) {
+				pr_debug
+				    ("SCC2 Driver: Note: Security State is in FAIL state.\n");
+			} /* register not a safe one */
+			else {
+				/* SMN is in  FAIL, but register is a safe one */
+				error_code = SCC_RET_OK;
+			}
+		} /* State is FAIL */
+		else {
+			/* State is not fail.  All registers accessible. */
+			error_code = SCC_RET_OK;
+		}
+	}
+	/* offset within SMN */
+	/*  Not SCM register.  Check for SCM busy. */
+	else if (offset_within_scm(register_offset)) {
+		/* This is the 'cannot access' condition in the SCM */
+		if (0		/* (scm_status & SCM_STATUS_BUSY) */
+		    /* these are always available  - rest fail on busy */
+		    && !((register_offset == SCM_STATUS_REG) ||
+			 (register_offset == SCM_ERR_STATUS_REG) ||
+			 (register_offset == SCM_INT_CTL_REG) ||
+			 (register_offset == SCM_VERSION_REG))) {
+			pr_debug
+			    ("SCC2 Driver: Note: Secure Memory is in BUSY state.\n");
+		} /* status is busy & register inaccessible */
+		else {
+			error_code = SCC_RET_OK;
+		}
+	}
+	/* offset within SCM */
+	return error_code;
+
+}				/* check_register_accessible() */
+
+/*****************************************************************************/
+/* fn check_register_offset()                                                */
+/*****************************************************************************/
+/**
+ *  Check that the offset is with the bounds of the SCC register set.
+ *
+ *  @param[in]  register_offset    register offset of SMN.
+ *
+ * #SCC_RET_OK if ok, #SCC_RET_FAIL if not
+ */
+static scc_return_t check_register_offset(uint32_t register_offset)
+{
+	int return_value = SCC_RET_FAIL;
+
+	/* Is it valid word offset ? */
+	if (SCC_BYTE_OFFSET(register_offset) == 0) {
+		/* Yes. Is register within SCM? */
+		if (offset_within_scm(register_offset)) {
+			return_value = SCC_RET_OK;	/* yes, all ok */
+		}
+		/* Not in SCM.  Now look within the SMN */
+		else if (offset_within_smn(register_offset)) {
+			return_value = SCC_RET_OK;	/* yes, all ok */
+		}
+	}
+
+	return return_value;
+}
+
+#ifdef SCC_REGISTER_DEBUG
+
+/**
+ * Names of the SCC Registers, indexed by register number
+ */
+static char *scc_regnames[] = {
+	"SCM_VERSION_REG",
+	"0x04",
+	"SCM_INT_CTL_REG",
+	"SCM_STATUS_REG",
+	"SCM_ERR_STATUS_REG",
+	"SCM_FAULT_ADR_REG",
+	"SCM_PART_OWNERS_REG",
+	"SCM_PART_ENGAGED_REG",
+	"SCM_UNIQUE_ID0_REG",
+	"SCM_UNIQUE_ID1_REG",
+	"SCM_UNIQUE_ID2_REG",
+	"SCM_UNIQUE_ID3_REG",
+	"0x30",
+	"0x34",
+	"0x38",
+	"0x3C",
+	"0x40",
+	"0x44",
+	"0x48",
+	"0x4C",
+	"SCM_ZCMD_REG",
+	"SCM_CCMD_REG",
+	"SCM_C_BLACK_ST_REG",
+	"SCM_DBG_STATUS_REG",
+	"SCM_AES_CBC_IV0_REG",
+	"SCM_AES_CBC_IV1_REG",
+	"SCM_AES_CBC_IV2_REG",
+	"SCM_AES_CBC_IV3_REG",
+	"0x70",
+	"0x74",
+	"0x78",
+	"0x7C",
+	"SCM_SMID0_REG",
+	"SCM_ACC0_REG",
+	"SCM_SMID1_REG",
+	"SCM_ACC1_REG",
+	"SCM_SMID2_REG",
+	"SCM_ACC2_REG",
+	"SCM_SMID3_REG",
+	"SCM_ACC3_REG",
+	"SCM_SMID4_REG",
+	"SCM_ACC4_REG",
+	"SCM_SMID5_REG",
+	"SCM_ACC5_REG",
+	"SCM_SMID6_REG",
+	"SCM_ACC6_REG",
+	"SCM_SMID7_REG",
+	"SCM_ACC7_REG",
+	"SCM_SMID8_REG",
+	"SCM_ACC8_REG",
+	"SCM_SMID9_REG",
+	"SCM_ACC9_REG",
+	"SCM_SMID10_REG",
+	"SCM_ACC10_REG",
+	"SCM_SMID11_REG",
+	"SCM_ACC11_REG",
+	"SCM_SMID12_REG",
+	"SCM_ACC12_REG",
+	"SCM_SMID13_REG",
+	"SCM_ACC13_REG",
+	"SCM_SMID14_REG",
+	"SCM_ACC14_REG",
+	"SCM_SMID15_REG",
+	"SCM_ACC15_REG",
+	"SMN_STATUS_REG",
+	"SMN_COMMAND_REG",
+	"SMN_SEQ_START_REG",
+	"SMN_SEQ_END_REG",
+	"SMN_SEQ_CHECK_REG",
+	"SMN_BB_CNT_REG",
+	"SMN_BB_INC_REG",
+	"SMN_BB_DEC_REG",
+	"SMN_COMPARE_REG",
+	"SMN_PT_CHK_REG",
+	"SMN_CT_CHK_REG",
+	"SMN_TIMER_IV_REG",
+	"SMN_TIMER_CTL_REG",
+	"SMN_SEC_VIO_REG",
+	"SMN_TIMER_REG",
+	"SMN_HAC_REG"
+};
+
+/**
+ * Names of the Secure RAM States
+ */
+static char *srs_names[] = {
+	"SRS_Reset",
+	"SRS_All_Ready",
+	"SRS_ZeroizeBusy",
+	"SRS_CipherBusy",
+	"SRS_AllBusy",
+	"SRS_ZeroizeDoneCipherReady",
+	"SRS_CipherDoneZeroizeReady",
+	"SRS_ZeroizeDoneCipherBusy",
+	"SRS_CipherDoneZeroizeBusy",
+	"SRS_UNKNOWN_STATE_9",
+	"SRS_TransitionalA",
+	"SRS_TransitionalB",
+	"SRS_TransitionalC",
+	"SRS_TransitionalD",
+	"SRS_AllDone",
+	"SRS_UNKNOWN_STATE_E",
+	"SRS_FAIL"
+};
+
+/**
+ * Create a text interpretation of the SCM Version Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_version_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	snprintf(print_buffer, buf_size,
+		 "Bpp: %u, Bpcb: %u, np: %u, maj: %u, min: %u",
+		 (value & SCM_VER_BPP_MASK) >> SCM_VER_BPP_SHIFT,
+		 ((value & SCM_VER_BPCB_MASK) >> SCM_VER_BPCB_SHIFT) + 1,
+		 ((value & SCM_VER_NP_MASK) >> SCM_VER_NP_SHIFT) + 1,
+		 (value & SCM_VER_MAJ_MASK) >> SCM_VER_MAJ_SHIFT,
+		 (value & SCM_VER_MIN_MASK) >> SCM_VER_MIN_SHIFT);
+
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of the SCM Status Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_status_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+
+	snprintf(print_buffer, buf_size, "%s%s%s%s%s%s%s%s%s%s%s%s%s",
+		 (value & SCM_STATUS_KST_DEFAULT_KEY) ? "KST_DefaultKey " : "",
+		 /* reserved */
+		 (value & SCM_STATUS_KST_WRONG_KEY) ? "KST_WrongKey " : "",
+		 (value & SCM_STATUS_KST_BAD_KEY) ? "KST_BadKey " : "",
+		 (value & SCM_STATUS_ERR) ? "Error " : "",
+		 (value & SCM_STATUS_MSS_FAIL) ? "MSS_FailState " : "",
+		 (value & SCM_STATUS_MSS_SEC) ? "MSS_SecureState " : "",
+		 (value & SCM_STATUS_RSS_FAIL) ? "RSS_FailState " : "",
+		 (value & SCM_STATUS_RSS_SEC) ? "RSS_SecureState " : "",
+		 (value & SCM_STATUS_RSS_INIT) ? "RSS_Initializing " : "",
+		 (value & SCM_STATUS_UNV) ? "UID_Invalid " : "",
+		 (value & SCM_STATUS_BIG) ? "BigEndian " : "",
+		 (value & SCM_STATUS_USK) ? "SecretKey " : "",
+		 srs_names[(value & SCM_STATUS_SRS_MASK) >>
+			   SCM_STATUS_SRS_SHIFT]);
+
+	return print_buffer;
+}
+
+/**
+ * Names of the SCM Error Codes
+ */
+static
+char *scm_err_code[] = {
+	"Unknown_0",
+	"UnknownAddress",
+	"UnknownCommand",
+	"ReadPermErr",
+	"WritePermErr",
+	"DMAErr",
+	"EncBlockLenOvfl",
+	"KeyNotEngaged",
+	"ZeroizeCmdQOvfl",
+	"CipherCmdQOvfl",
+	"ProcessIntr",
+	"WrongKey",
+	"DeviceBusy",
+	"DMAUnalignedAddr",
+	"Unknown_E",
+	"Unknown_F",
+};
+
+/**
+ * Names of the SMN States
+ */
+static char *smn_state_name[] = {
+	"Start",
+	"Invalid_01",
+	"Invalid_02",
+	"Invalid_03",
+	"Zeroizing_04",
+	"Zeroizing",
+	"HealthCheck",
+	"HealthCheck_07",
+	"Invalid_08",
+	"Fail",
+	"Secure",
+	"Invalid_0B",
+	"NonSecure",
+	"Invalid_0D",
+	"Invalid_0E",
+	"Invalid_0F",
+	"Invalid_10",
+	"Invalid_11",
+	"Invalid_12",
+	"Invalid_13",
+	"Invalid_14",
+	"Invalid_15",
+	"Invalid_16",
+	"Invalid_17",
+	"Invalid_18",
+	"FailHard",
+	"Invalid_1A",
+	"Invalid_1B",
+	"Invalid_1C",
+	"Invalid_1D",
+	"Invalid_1E",
+	"Invalid_1F"
+};
+
+/**
+ * Create a text interpretation of the SCM Error Status Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_err_status_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	snprintf(print_buffer, buf_size,
+		 "MID: 0x%x, %s%s ErrorCode: %s, SMSState: %s, SCMState: %s",
+		 (value & SCM_ERRSTAT_MID_MASK) >> SCM_ERRSTAT_MID_SHIFT,
+		 (value & SCM_ERRSTAT_ILM) ? "ILM, " : "",
+		 (value & SCM_ERRSTAT_SUP) ? "SUP, " : "",
+		 scm_err_code[(value & SCM_ERRSTAT_ERC_MASK) >>
+			      SCM_ERRSTAT_ERC_SHIFT],
+		 smn_state_name[(value & SCM_ERRSTAT_SMS_MASK) >>
+				SCM_ERRSTAT_SMS_SHIFT],
+		 srs_names[(value & SCM_ERRSTAT_SRS_MASK) >>
+			   SCM_ERRSTAT_SRS_SHIFT]);
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of the SCM Zeroize Command Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_zcmd_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	unsigned cmd = (value & SCM_ZCMD_CCMD_MASK) >> SCM_CCMD_CCMD_SHIFT;
+
+	snprintf(print_buffer, buf_size, "%s %u",
+		 (cmd ==
+		  ZCMD_DEALLOC_PART) ? "DeallocPartition" :
+		 "(unknown function)",
+		 (value & SCM_ZCMD_PART_MASK) >> SCM_ZCMD_PART_SHIFT);
+
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of the SCM Cipher Command Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_ccmd_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	unsigned cmd = (value & SCM_CCMD_CCMD_MASK) >> SCM_CCMD_CCMD_SHIFT;
+
+	snprintf(print_buffer, buf_size,
+		 "%s %u bytes, %s offset 0x%x, in partition %u",
+		 (cmd == SCM_CCMD_AES_DEC_ECB) ? "ECB Decrypt" : (cmd ==
+								  SCM_CCMD_AES_ENC_ECB)
+		 ? "ECB Encrypt" : (cmd ==
+				    SCM_CCMD_AES_DEC_CBC) ? "CBC Decrypt" : (cmd
+									     ==
+									     SCM_CCMD_AES_ENC_CBC)
+		 ? "CBC Encrypt" : "(unknown function)",
+		 16 +
+		 16 * ((value & SCM_CCMD_LENGTH_MASK) >> SCM_CCMD_LENGTH_SHIFT),
+		 ((cmd == SCM_CCMD_AES_ENC_CBC)
+		  || (cmd == SCM_CCMD_AES_ENC_ECB)) ? "at" : "to",
+		 16 * ((value & SCM_CCMD_OFFSET_MASK) >> SCM_CCMD_OFFSET_SHIFT),
+		 (value & SCM_CCMD_PART_MASK) >> SCM_CCMD_PART_SHIFT);
+
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of an SCM Access Permissions Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_acc_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	snprintf(print_buffer, buf_size, "%s%s%s%s%s%s%s%s%s%s",
+		 (value & SCM_PERM_NO_ZEROIZE) ? "NO_ZERO " : "",
+		 (value & SCM_PERM_HD_SUP_DISABLE) ? "SUP_DIS " : "",
+		 (value & SCM_PERM_HD_READ) ? "HD_RD " : "",
+		 (value & SCM_PERM_HD_WRITE) ? "HD_WR " : "",
+		 (value & SCM_PERM_HD_EXECUTE) ? "HD_EX " : "",
+		 (value & SCM_PERM_TH_READ) ? "TH_RD " : "",
+		 (value & SCM_PERM_TH_WRITE) ? "TH_WR " : "",
+		 (value & SCM_PERM_OT_READ) ? "OT_RD " : "",
+		 (value & SCM_PERM_OT_WRITE) ? "OT_WR " : "",
+		 (value & SCM_PERM_OT_EXECUTE) ? "OT_EX" : "");
+
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of the SCM Partitions Engaged Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *scm_print_part_eng_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	snprintf(print_buffer, buf_size, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+		 (value & 0x8000) ? "15 " : "",
+		 (value & 0x4000) ? "14 " : "",
+		 (value & 0x2000) ? "13 " : "",
+		 (value & 0x1000) ? "12 " : "",
+		 (value & 0x0800) ? "11 " : "",
+		 (value & 0x0400) ? "10 " : "",
+		 (value & 0x0200) ? "9 " : "",
+		 (value & 0x0100) ? "8 " : "",
+		 (value & 0x0080) ? "7 " : "",
+		 (value & 0x0040) ? "6 " : "",
+		 (value & 0x0020) ? "5 " : "",
+		 (value & 0x0010) ? "4 " : "",
+		 (value & 0x0008) ? "3 " : "",
+		 (value & 0x0004) ? "2 " : "",
+		 (value & 0x0002) ? "1 " : "", (value & 0x0001) ? "0" : "");
+
+	return print_buffer;
+}
+
+/**
+ * Create a text interpretation of the SMN Status Register
+ *
+ * @param      value        The value of the register
+ * @param[out] print_buffer Place to store the interpretation
+ * @param      buf_size     Number of bytes available at print_buffer
+ *
+ * @return The print_buffer
+ */
+static
+char *smn_print_status_reg(uint32_t value, char *print_buffer, int buf_size)
+{
+	snprintf(print_buffer, buf_size,
+		 "Version %d %s%s%s%s%s%s%s%s%s%s%s%s%s",
+		 (value & SMN_STATUS_VERSION_ID_MASK) >>
+		 SMN_STATUS_VERSION_ID_SHIFT,
+		 (value & SMN_STATUS_ILLEGAL_MASTER) ? "IllMaster " : "",
+		 (value & SMN_STATUS_SCAN_EXIT) ? "ScanExit " : "",
+		 (value & SMN_STATUS_PERIP_INIT) ? "PeripInit " : "",
+		 (value & SMN_STATUS_SMN_ERROR) ? "SMNError " : "",
+		 (value & SMN_STATUS_SOFTWARE_ALARM) ? "SWAlarm " : "",
+		 (value & SMN_STATUS_TIMER_ERROR) ? "TimerErr " : "",
+		 (value & SMN_STATUS_PC_ERROR) ? "PTCTErr " : "",
+		 (value & SMN_STATUS_BITBANK_ERROR) ? "BitbankErr " : "",
+		 (value & SMN_STATUS_ASC_ERROR) ? "ASCErr " : "",
+		 (value & SMN_STATUS_SECURITY_POLICY_ERROR) ? "SecPlcyErr " :
+		 "",
+		 (value & SMN_STATUS_SEC_VIO_ACTIVE_ERROR) ? "SecVioAct " : "",
+		 (value & SMN_STATUS_INTERNAL_BOOT) ? "IntBoot " : "",
+		 smn_state_name[(value & SMN_STATUS_STATE_MASK) >>
+				SMN_STATUS_STATE_SHIFT]);
+
+	return print_buffer;
+}
+
+/**
+ * The array, indexed by register number (byte-offset / 4), of print routines
+ * for the SCC (SCM and SMN) registers.
+ */
+static reg_print_routine_t reg_printers[] = {
+	scm_print_version_reg,
+	NULL,			/* 0x04 */
+	NULL,			/* SCM_INT_CTL_REG */
+	scm_print_status_reg,
+	scm_print_err_status_reg,
+	NULL,			/* SCM_FAULT_ADR_REG */
+	NULL,			/* SCM_PART_OWNERS_REG */
+	scm_print_part_eng_reg,
+	NULL,			/* SCM_UNIQUE_ID0_REG */
+	NULL,			/* SCM_UNIQUE_ID1_REG */
+	NULL,			/* SCM_UNIQUE_ID2_REG */
+	NULL,			/* SCM_UNIQUE_ID3_REG */
+	NULL,			/* 0x30 */
+	NULL,			/* 0x34 */
+	NULL,			/* 0x38 */
+	NULL,			/* 0x3C */
+	NULL,			/* 0x40 */
+	NULL,			/* 0x44 */
+	NULL,			/* 0x48 */
+	NULL,			/* 0x4C */
+	scm_print_zcmd_reg,
+	scm_print_ccmd_reg,
+	NULL,			/* SCM_C_BLACK_ST_REG */
+	NULL,			/* SCM_DBG_STATUS_REG */
+	NULL,			/* SCM_AES_CBC_IV0_REG */
+	NULL,			/* SCM_AES_CBC_IV1_REG */
+	NULL,			/* SCM_AES_CBC_IV2_REG */
+	NULL,			/* SCM_AES_CBC_IV3_REG */
+	NULL,			/* 0x70 */
+	NULL,			/* 0x74 */
+	NULL,			/* 0x78 */
+	NULL,			/* 0x7C */
+	NULL,			/* SCM_SMID0_REG */
+	scm_print_acc_reg,	/* ACC0 */
+	NULL,			/* SCM_SMID1_REG */
+	scm_print_acc_reg,	/* ACC1 */
+	NULL,			/* SCM_SMID2_REG */
+	scm_print_acc_reg,	/* ACC2 */
+	NULL,			/* SCM_SMID3_REG */
+	scm_print_acc_reg,	/* ACC3 */
+	NULL,			/* SCM_SMID4_REG */
+	scm_print_acc_reg,	/* ACC4 */
+	NULL,			/* SCM_SMID5_REG */
+	scm_print_acc_reg,	/* ACC5 */
+	NULL,			/* SCM_SMID6_REG */
+	scm_print_acc_reg,	/* ACC6 */
+	NULL,			/* SCM_SMID7_REG */
+	scm_print_acc_reg,	/* ACC7 */
+	NULL,			/* SCM_SMID8_REG */
+	scm_print_acc_reg,	/* ACC8 */
+	NULL,			/* SCM_SMID9_REG */
+	scm_print_acc_reg,	/* ACC9 */
+	NULL,			/* SCM_SMID10_REG */
+	scm_print_acc_reg,	/* ACC10 */
+	NULL,			/* SCM_SMID11_REG */
+	scm_print_acc_reg,	/* ACC11 */
+	NULL,			/* SCM_SMID12_REG */
+	scm_print_acc_reg,	/* ACC12 */
+	NULL,			/* SCM_SMID13_REG */
+	scm_print_acc_reg,	/* ACC13 */
+	NULL,			/* SCM_SMID14_REG */
+	scm_print_acc_reg,	/* ACC14 */
+	NULL,			/* SCM_SMID15_REG */
+	scm_print_acc_reg,	/* ACC15 */
+	smn_print_status_reg,
+	NULL,			/* SMN_COMMAND_REG */
+	NULL,			/* SMN_SEQ_START_REG */
+	NULL,			/* SMN_SEQ_END_REG */
+	NULL,			/* SMN_SEQ_CHECK_REG */
+	NULL,			/* SMN_BB_CNT_REG */
+	NULL,			/* SMN_BB_INC_REG */
+	NULL,			/* SMN_BB_DEC_REG */
+	NULL,			/* SMN_COMPARE_REG */
+	NULL,			/* SMN_PT_CHK_REG */
+	NULL,			/* SMN_CT_CHK_REG */
+	NULL,			/* SMN_TIMER_IV_REG */
+	NULL,			/* SMN_TIMER_CTL_REG */
+	NULL,			/* SMN_SEC_VIO_REG */
+	NULL,			/* SMN_TIMER_REG */
+	NULL,			/* SMN_HAC_REG */
+};
+
+/*****************************************************************************/
+/* fn dbg_scc_read_register()                                                */
+/*****************************************************************************/
+/**
+ * Noisily read a 32-bit value to an SCC register.
+ * @param offset        The address of the register to read.
+ *
+ * @return  The register value
+ * */
+uint32_t dbg_scc_read_register(uint32_t offset)
+{
+	uint32_t value;
+	char *regname = scc_regnames[offset / 4];
+
+	value = __raw_readl(scc_base + offset);
+	pr_debug("SCC2 RD: 0x%03x : 0x%08x (%s) %s\n", offset, value, regname,
+		 reg_printers[offset / 4]
+		 ? reg_printers[offset / 4] (value, reg_print_buffer,
+					     REG_PRINT_BUFFER_SIZE)
+		 : "");
+
+	return value;
+}
+
+/*****************************************************************************/
+/* fn dbg_scc_write_register()                                               */
+/*****************************************************************************/
+/*
+ * Noisily read a 32-bit value to an SCC register.
+ * @param offset        The address of the register to written.
+ *
+ * @param value         The new register value
+ */
+void dbg_scc_write_register(uint32_t offset, uint32_t value)
+{
+	char *regname = scc_regnames[offset / 4];
+
+	pr_debug("SCC2 WR: 0x%03x : 0x%08x (%s) %s\n", offset, value, regname,
+		 reg_printers[offset / 4]
+		 ? reg_printers[offset / 4] (value, reg_print_buffer,
+					     REG_PRINT_BUFFER_SIZE)
+		 : "");
+	(void)__raw_writel(value, scc_base + offset);
+
+}
+
+#endif				/* SCC_REGISTER_DEBUG */
+
+static int scc_dev_probe(struct platform_device *pdev)
+{
+	struct resource *r;
+	int ret = 0;
+
+	/* get the scc registers base address */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "can't get IORESOURCE_MEM (0)\n");
+		ret = -ENXIO;
+		goto exit;
+	}
+
+	scc_phys_base = r->start;
+
+
+	/* get the scc ram base address */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!r) {
+		dev_err(&pdev->dev, "can't get IORESOURCE_MEM (1)\n");
+		ret = -ENXIO;
+		goto exit;
+	}
+
+	scm_ram_phys_base = r->start;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))
+	scc_clk = clk_get(&pdev->dev, "scc_clk");
+#endif
+
+	/* now initialize the SCC */
+	ret = scc_init();
+
+exit:
+	return ret;
+}
+
+static int scc_dev_remove(struct platform_device *pdev)
+{
+	scc_cleanup();
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int scc_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	return 0;
+}
+
+static int scc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define scc_suspend	NULL
+#define	scc_resume	NULL
+#endif
+
+/*! Linux Driver definition
+ *
+ */
+static struct platform_driver mxcscc_driver = {
+	.driver = {
+		   .name = SCC_DRIVER_NAME,
+		   },
+	.probe = scc_dev_probe,
+	.remove = scc_dev_remove,
+	.suspend = scc_suspend,
+	.resume = scc_resume,
+};
+
+static int __init scc_driver_init(void)
+{
+	return platform_driver_register(&mxcscc_driver);
+}
+
+module_init(scc_driver_init);
+
+static void __exit scc_driver_exit(void)
+{
+	platform_driver_unregister(&mxcscc_driver);
+}
+
+module_exit(scc_driver_exit);
diff --git a/drivers/mxc/security/scc2_internals.h b/drivers/mxc/security/scc2_internals.h
new file mode 100644
index 0000000..c1a4e4c
--- /dev/null
+++ b/drivers/mxc/security/scc2_internals.h
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef SCC_INTERNALS_H
+#define SCC_INTERNALS_H
+
+/** @file scc2_internals.h
+ *
+ * @brief This is intended to be the file which contains most or all of the
+ * code or changes need to port the driver.  It also includes other definitions
+ * needed by the driver.
+ *
+ *  This header file should only ever be included by scc2_driver.c
+ *
+ *  Compile-time flags minimally needed:
+ *
+ *  @li Some sort of platform flag.  Currently TAHITI and MXC are understood.
+ *  @li Some start-of-SCC consideration, such as SCC_BASE_ADDR
+ *
+ *  Some changes which could be made when porting this driver:
+ *  #SCC_SPIN_COUNT
+ *
+ */
+
+#include <linux/version.h>          /* Current version Linux kernel */
+#include <linux/module.h>           /* Basic support for loadable modules,
+                                       printk */
+#include <linux/init.h>             /* module_init, module_exit */
+#include <linux/kernel.h>           /* General kernel system calls */
+#include <linux/sched.h>            /* for interrupt.h */
+#include <linux/spinlock.h>
+
+#include <linux/io.h>               /* ioremap() */
+#include <linux/interrupt.h>        /* IRQ / interrupt definitions */
+
+
+#include <linux/mxc_scc2_driver.h>
+
+#if defined(MXC)
+
+#include <mach/iim.h>
+#include <mach/mxc_scc.h>
+
+
+/**
+ * This macro is used to determine whether the SCC is enabled/available
+ * on the platform.  This macro may need to be ported.
+ */
+#define SCC_FUSE __raw_readl(IO_ADDRESS(IIM_BASE_ADDR + MXC_IIMHWV1))
+#define SCC_ENABLED() ((SCC_FUSE & MXC_IIMHWV1_SCC_DISABLE) == 0)
+
+#else  /* neither TAHITI nor MXC */
+
+#error Do not understand target architecture
+
+#endif /* TAHITI */
+/**
+ * Define the number of Stored Keys which the SCC driver will make available.
+ * Value shall be from 0 to 20.  Default is zero (0).
+ */
+/*#define SCC_KEY_SLOTS   20*/
+
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/** @addtogroup scccompileflags */
+/** @{ */
+
+
+/** @def NO_SMN_INTERRUPT
+ * The SMN interrupt is not wired to the CPU at all.
+ */
+#define NO_SMN_INTERRUPT
+
+
+/**
+ * Register an interrupt handler for the SMN as well as
+ * the SCM.  In some implementations, the SMN is not connected at all (see
+ * #NO_SMN_INTERRUPT), and in others, it is on the same interrupt line as the
+ * SCM.  When defining this flag, the SMN interrupt should be on a separate
+ * line from the SCM interrupt.
+ */
+
+#define USE_SMN_INTERRUPT
+
+
+/**
+ * Turn on generation of run-time operational, debug, and error messages
+ */
+#define SCC_DEBUG
+
+
+/**
+ * Turn on generation of run-time logging of access to the SCM and SMN
+ * registers.
+ */
+#define SCC_REGISTER_DEBUG
+
+
+/**
+ * Turn on generation of run-time logging of access to the SCM Red and
+ * Black memories.  Will only work if #SCC_REGISTER_DEBUG is also defined.
+ */
+#define SCC_RAM_DEBUG
+
+
+/**
+ *  If the driver finds the SCC in HEALTH_CHECK state, go ahead and
+ *  run a quick ASC to bring it to SECURE state.
+ */
+#define SCC_BRINGUP
+
+
+/**
+ * Expected to come from platform header files or compile command line.
+ * This symbol must be the address of the SCC
+ */
+#define SCC_BASE
+
+/**
+ *  This must be the interrupt line number of the SCM interrupt.
+ */
+#define INT_SCM
+
+/**
+ *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
+ *  the SMN interrupt.
+ */
+#define INT_SMN
+
+/**
+ * Define the number of Stored Keys which the SCC driver will make available.
+ * Value shall be from 0 to 20.  Default is zero (0).
+ */
+#define SCC_KEY_SLOTS
+
+/**
+ * Make sure that this flag is defined if compiling for a Little-Endian
+ * platform.  Linux Kernel builds provide this flag.
+ */
+#define __LITTLE_ENDIAN
+
+/**
+ * Make sure that this flag is defined if compiling for a Big-Endian platform.
+ * Linux Kernel builds provide this flag.
+ */
+#define __BIG_ENDIAN
+
+/**
+ * Read a 32-bit register value from a 'peripheral'.  Standard Linux/Unix
+ * macro.
+ *
+ * @param offset   Bus address of register to be read
+ *
+ * @return The value of the register
+ */
+#define readl(offset)
+
+
+/**
+ * Write a 32-bit value to a register in a 'peripheral'.  Standard Linux/Unix
+ * macro.
+ *
+ * @param value    The 32-bit value to store
+ * @param offset   Bus address of register to be written
+ *
+ * return (none)
+ */
+#define writel(value,offset)
+
+
+/** @} */  /* end group scccompileflags */
+
+#endif  /* DOXYGEN_HACK */
+
+
+#ifndef SCC_KEY_SLOTS
+#define SCC_KEY_SLOTS 0
+
+#else
+
+#if (SCC_KEY_SLOTS < 0) || (SCC_KEY_SLOTS > 20)
+#error Bad value for SCC_KEY_SLOTS
+#endif
+
+#endif
+
+
+/**
+ * Maximum length of key/secret value which can be stored in SCC.
+ */
+#define SCC_MAX_KEY_SIZE 256
+
+
+/**
+ * This is the size, in bytes, of each key slot, and therefore the maximum size
+ * of the wrapped key.
+ */
+#define SCC_KEY_SLOT_SIZE 32
+
+
+/* These come for free with Linux, but may need to be set in a port. */
+#ifndef __BIG_ENDIAN
+#ifndef __LITTLE_ENDIAN
+#error One of __LITTLE_ENDIAN or __BIG_ENDIAN must be #defined
+#endif
+#else
+#ifdef __LITTLE_ENDIAN
+#error Exactly one of __LITTLE_ENDIAN or __BIG_ENDIAN must be #defined
+#endif
+#endif
+
+
+#ifndef SCC_CALLBACK_SIZE
+/** The number of function pointers which can be stored in #scc_callbacks.
+ *  Defaults to 4, can be overridden with compile-line argument.
+ */
+#define SCC_CALLBACK_SIZE 4
+#endif
+
+
+/** Initial CRC value for CCITT-CRC calculation. */
+#define CRC_CCITT_START 0xFFFF
+
+
+#ifdef TAHITI
+
+/**
+ * The SCC_BASE has to be SMN_BASE_ADDR on TAHITI, as the banks of
+ * registers are swapped in place.
+ */
+#define SCC_BASE       SMN_BASE_ADDR
+
+
+/** The interrupt number for the SCC (SCM only!) on Tahiti */
+#define INT_SCC_SCM       62
+
+
+/** Tahiti does not have the SMN interrupt wired to the CPU.  */
+#define NO_SMN_INTERRUPT
+
+
+#endif /* TAHITI */
+
+
+/** Number of times to spin between polling of SCC while waiting for cipher
+ *  or zeroizing function to complete. See also #SCC_CIPHER_MAX_POLL_COUNT. */
+#define SCC_SPIN_COUNT 1000
+
+
+/** Number of times to polling SCC while waiting for cipher
+ *  or zeroizing function to complete.  See also #SCC_SPIN_COUNT.  */
+#define SCC_CIPHER_MAX_POLL_COUNT 100
+
+
+/**
+ * @def SCC_READ_REGISTER
+ * Read a 32-bit value from an SCC register.  Macro which depends upon
+ * #scc_base.  Linux readl()/writel() macros operate on 32-bit quantities, as
+ * do SCC register reads/writes.
+ *
+ * @param     offset  Register offset within SCC.
+ *
+ * @return    The value from the SCC's register.
+ */
+#ifndef SCC_REGISTER_DEBUG
+#define SCC_READ_REGISTER(offset) __raw_readl(scc_base+(offset))
+#else
+#define SCC_READ_REGISTER(offset) dbg_scc_read_register(offset)
+#endif
+
+
+/**
+ * Write a 32-bit value to an SCC register.  Macro depends upon #scc_base.
+ * Linux readl()/writel() macros operate on 32-bit quantities, as do SCC
+ * register reads/writes.
+ *
+ * @param   offset  Register offset within SCC.
+ * @param   value   32-bit value to store into the register
+ *
+ * @return   (void)
+ */
+#ifndef SCC_REGISTER_DEBUG
+#define SCC_WRITE_REGISTER(offset,value) \
+	(void)__raw_writel(value, scc_base+(offset))
+#else
+#define SCC_WRITE_REGISTER(offset,value) \
+	dbg_scc_write_register(offset, value)
+#endif
+
+/**
+ * Calculate the kernel virtual address of a partition from the partition number.
+ */
+#define SCM_PART_ADDRESS(part)                                          \
+ (scm_ram_base + (part*scc_configuration.partition_size_bytes))
+
+/**
+ * Calculate the partition number from the kernel virtual address.
+ */
+#define SCM_PART_NUMBER(address)                                        \
+ ((address - (uint32_t)scm_ram_base)/scc_configuration.partition_size_bytes)
+
+/**
+ * Calculates the byte offset into a word
+ *  @param   bp  The byte (char*) pointer
+ *  @return      The offset (0, 1, 2, or 3)
+ */
+#define SCC_BYTE_OFFSET(bp) ((uint32_t)(bp) % sizeof(uint32_t))
+
+
+/**
+ * Converts (by rounding down) a byte pointer into a word pointer
+ *  @param  bp  The byte (char*) pointer
+ *  @return     The word (uint32_t) as though it were an aligned (uint32_t*)
+ */
+#define SCC_WORD_PTR(bp) (((uint32_t)(bp)) & ~(sizeof(uint32_t)-1))
+
+
+/**
+ * Determine number of bytes in an SCC block
+ *
+ * @return Bytes / block
+ */
+#define SCC_BLOCK_SIZE_BYTES() scc_configuration.block_size_bytes
+
+
+/**
+ * Maximum number of additional bytes which may be added in CRC+padding mode.
+ */
+#define PADDING_BUFFER_MAX_BYTES (CRC_SIZE_BYTES + sizeof(scc_block_padding))
+
+/**
+ *  Shorthand (clearer, anyway) for number of bytes in a CRC.
+ */
+#define CRC_SIZE_BYTES (sizeof(crc_t))
+
+/**
+ * The polynomial used in CCITT-CRC calculation
+ */
+#define CRC_POLYNOMIAL 0x1021
+
+/**
+ * Calculate CRC on one byte of data
+ *
+ * @param[in,out] running_crc  A value of type crc_t where CRC is kept. This
+ *                             must be an rvalue and an lvalue.
+ * @param[in]     byte_value   The byte (uint8_t, char) to be put in the CRC
+ *
+ * @return      none
+ */
+#define CALC_CRC(byte_value,running_crc)  {                                  \
+    uint8_t data;                                                            \
+    data = (0xff&(byte_value)) ^ (running_crc >> 8);                         \
+    running_crc = scc_crc_lookup_table[data] ^ (running_crc << 8);           \
+}
+
+/** Value of 'beginning of padding' marker in driver-provided padding */
+#define SCC_DRIVER_PAD_CHAR  0x80
+
+
+/** Name of the driver.  Used (on Linux, anyway) when registering interrupts */
+#define SCC_DRIVER_NAME "mxc_scc"
+
+
+/* Port -- these symbols are defined in Linux 2.6 and later.  They are defined
+ * here for backwards compatibility because this started life as a 2.4
+ * driver, and as a guide to portation to other platforms.
+ */
+
+#if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define irqreturn_t void        /* Return type of an interrupt handler */
+
+#define IRQ_HANDLED /* Would be '1' for handled -- as in return IRQ_HANDLED; */
+
+#define IRQ_NONE   /* would be '0' for not handled -- as in return IRQ_NONE; */
+
+#define IRQ_RETVAL(x) /* Return x==0 (not handled) or non-zero (handled) */
+
+#endif /* LINUX earlier than 2.5 */
+
+
+/* These are nice to have around */
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+
+/** Provide a typedef for the CRC which can be used in encrypt/decrypt */
+typedef uint16_t crc_t;
+
+
+/** Gives high-level view of state of the SCC */
+enum scc_status {
+    SCC_STATUS_INITIAL,         /**< State of driver before ever checking */
+    SCC_STATUS_CHECKING,        /**< Transient state while driver loading  */
+    SCC_STATUS_UNIMPLEMENTED,   /**< SCC is non-existent or unuseable  */
+    SCC_STATUS_OK,              /**< SCC is in Secure or Default state  */
+    SCC_STATUS_FAILED           /**< In Failed state */
+};
+
+/**
+ * Information about a key slot.
+ */
+struct scc_key_slot
+{
+    uint64_t   owner_id;        /**< Access control value. */
+    uint32_t   length;          /**< Length of value in slot. */
+    uint32_t   offset;          /**< Offset of value from start of RAM. */
+    uint32_t   status;          /**< 0 = unassigned, 1 = assigned. */
+    uint32_t   part_ctl;        /**< for the CCMD register  */
+};
+
+/* Forward-declare a number routines which are not part of user api */
+static int scc_init(void);
+static void scc_cleanup(void);
+static int __init scc_driver_init(void);
+static void __exit scc_driver_exit(void);
+
+/* Forward defines of internal functions */
+OS_DEV_ISR(scc_irq);
+/*static irqreturn_t scc_irq(int irq, void *dev_id);*/
+/** Perform callbacks registered by #scc_monitor_security_failure().
+ *
+ *  Make sure callbacks only happen once...  Since there may be some reason why
+ *  the interrupt isn't generated, this routine could be called from base(task)
+ *  level.
+ *
+ *  One at a time, go through #scc_callbacks[] and call any non-null pointers.
+ */
+static void scc_perform_callbacks(void);
+/*static uint32_t copy_to_scc(const uint8_t* from, uint32_t to, unsigned long count_bytes, uint16_t* crc);
+static uint32_t copy_from_scc(const uint32_t from, uint8_t* to,unsigned long count_bytes, uint16_t* crc);
+static scc_return_t scc_strip_padding(uint8_t* from,unsigned* count_bytes_stripped);*/
+static uint32_t scc_update_state(void);
+static void scc_init_ccitt_crc(void);
+static uint32_t scc_grab_config_values(void);
+static int setup_interrupt_handling(void);
+/**
+ * Perform an encryption on the input.  If @c verify_crc is true, a CRC must be
+ * calculated on the plaintext, and appended, with padding, before computing
+ * the ciphertext.
+ *
+ * @param[in]     count_in_bytes  Count of bytes of plaintext
+ * @param[in]     data_in         Pointer to the plaintext
+ * @param[in]     scm_control     Bit values for the SCM_CONTROL register
+ * @param[in,out] data_out        Pointer for storing ciphertext
+ * @param[in]     add_crc         Flag for computing CRC - 0 no, else yes
+ * @param[in,out] count_out_bytes Number of bytes available at @c data_out
+ */
+/*static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t* data_in, uint32_t scm_control, uint8_t* data_out,int add_crc, unsigned long* count_out_bytes);*/
+/**
+ * Perform a decryption on the input.  If @c verify_crc is true, the last block
+ * (maybe the two last blocks) is special - it should contain a CRC and
+ * padding.  These must be stripped and verified.
+ *
+ * @param[in]     count_in_bytes  Count of bytes of ciphertext
+ * @param[in]     data_in         Pointer to the ciphertext
+ * @param[in]     scm_control     Bit values for the SCM_CONTROL register
+ * @param[in,out] data_out        Pointer for storing plaintext
+ * @param[in]     verify_crc      Flag for running CRC - 0 no, else yes
+ * @param[in,out] count_out_bytes Number of bytes available at @c data_out
+
+ */
+/*static scc_return_t scc_decrypt(uint32_t count_in_bytes, uint8_t* data_in, uint32_t scm_control, uint8_t* data_out, int verify_crc, unsigned long* count_out_bytes);*/
+static uint32_t host_owns_partition(uint32_t part_no);
+static uint32_t partition_engaged(uint32_t part_no);
+
+static scc_return_t scc_wait_completion(uint32_t* scm_status);
+static int is_cipher_done(uint32_t* scm_status);
+static scc_return_t check_register_accessible (uint32_t offset,
+                                               uint32_t smn_status,
+                                               uint32_t scm_status);
+static scc_return_t check_register_offset(uint32_t offset);
+/*uint8_t make_vpu_partition(void);*/
+
+#ifdef SCC_REGISTER_DEBUG
+static uint32_t dbg_scc_read_register(uint32_t offset);
+static void dbg_scc_write_register(uint32_t offset, uint32_t value);
+#endif
+
+
+/* For Linux kernel, export the API functions to other kernel modules */
+EXPORT_SYMBOL(scc_get_configuration);
+EXPORT_SYMBOL(scc_zeroize_memories);
+/*EXPORT_SYMBOL(scc_crypt);*/
+EXPORT_SYMBOL(scc_set_sw_alarm);
+EXPORT_SYMBOL(scc_monitor_security_failure);
+EXPORT_SYMBOL(scc_stop_monitoring_security_failure);
+EXPORT_SYMBOL(scc_read_register);
+EXPORT_SYMBOL(scc_write_register);
+EXPORT_SYMBOL(scc_allocate_partition);
+EXPORT_SYMBOL(scc_engage_partition);
+EXPORT_SYMBOL(scc_release_partition);
+EXPORT_SYMBOL(scc_diminish_permissions);
+EXPORT_SYMBOL(scc_encrypt_region);
+EXPORT_SYMBOL(scc_decrypt_region);
+EXPORT_SYMBOL(scc_partition_status);
+EXPORT_SYMBOL(scc_virt_to_phys);
+/*EXPORT_SYMBOL(make_vpu_partition);*/
+
+
+/* Tell Linux this is not GPL code */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Device Driver for SCC (SMN/SCM)");
+
+
+#endif /* SCC_INTERNALS_H */
diff --git a/include/linux/mxc_sahara.h b/include/linux/mxc_sahara.h
new file mode 100644
index 0000000..244d692
--- /dev/null
+++ b/include/linux/mxc_sahara.h
@@ -0,0 +1,2273 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sahara.h
+ *
+ * File which implements the FSL_SHW API when used on Sahara
+ */
+/*!
+ * @if USE_MAINPAGE
+ * @mainpage Sahara2 implemtation of FSL Security Hardware API
+ * @endif
+ *
+ */
+
+#define _DIAG_DRV_IF
+#define _DIAG_SECURITY_FUNC
+#define _DIAG_ADAPTOR
+
+#ifndef SAHARA2_API_H
+#define SAHARA2_API_H
+
+#ifdef DIAG_SECURITY_FUNC
+#include <diagnostic.h>
+#endif				/* DIAG_SECURITY_FUNC */
+
+/* This is a Linux flag... ? */
+#ifndef __KERNEL__
+#include <inttypes.h>
+#include <stdlib.h>
+#include <memory.h>
+#else
+#include "portable_os.h"
+#endif
+
+/* This definition may need a new name, and needs to go somewhere which
+ * can determine platform, kernel vs. user, os, etc.
+ */
+#define copy_bytes(out, in, len) memcpy(out, in, len)
+
+/* Does this belong here? */
+#ifndef SAHARA_DEVICE
+#define SAHARA_DEVICE "/dev/sahara"
+#endif
+
+/*!
+*******************************************************************************
+* @defgroup lnkflags Link Flags
+*
+* @brief Flags to show information about link data and link segments
+*
+******************************************************************************/
+/*! @addtogroup lnkflags
+ * @{
+ */
+
+/*!
+*******************************************************************************
+* This flag indicates that the data in a link is owned by the security
+* function component and this memory will be freed by the security function
+* component. To be used as part of the flag field of the sah_Link structure.
+******************************************************************************/
+#define SAH_OWNS_LINK_DATA          0x01
+
+/*!
+*******************************************************************************
+* The data in a link is not owned by the security function component and
+* therefore it will not attempt to free this memory. To be used as part of the
+* flag field of the sah_Link structure.
+******************************************************************************/
+#define SAH_USES_LINK_DATA          0x02
+
+/*!
+*******************************************************************************
+* The data in this link will change when the descriptor gets executed.
+******************************************************************************/
+#define SAH_OUTPUT_LINK             0x04
+
+/*!
+*******************************************************************************
+* The ptr and length in this link are really 'established key' info.  They
+* are to be converted to ptr/length before putting on request queue.
+******************************************************************************/
+#define SAH_KEY_IS_HIDDEN           0x08
+
+/*!
+*******************************************************************************
+* The link structure has been appended to the previous one by the driver.  It
+* needs to be removed before leaving the driver (and returning to API).
+******************************************************************************/
+#define SAH_REWORKED_LINK           0x10
+
+/*!
+*******************************************************************************
+* The length and data fields of this link contain the slot and user id
+* used to access the SCC stored key
+******************************************************************************/
+#define SAH_STORED_KEY_INFO         0x20
+
+/*!
+*******************************************************************************
+* The Data field points to a physical address, and does not need to be
+* processed by the driver.  Honored only in Kernel API.
+******************************************************************************/
+#define SAH_PREPHYS_DATA            0x40
+
+/*!
+*******************************************************************************
+* The link was inserted during the Physicalise procedure.  It is tagged so
+* it can be removed during DePhysicalise, thereby returning to the caller an
+* intact chain.
+******************************************************************************/
+#define SAH_LINK_INSERTED_LINK      0x80
+
+/*!
+*******************************************************************************
+* The Data field points to the location of the key, which is in a secure
+* partition held by the user.  The memory address needs to be converted to
+* kernel space manually, by looking through the partitions that the user holds.
+******************************************************************************/
+#define SAH_IN_USER_KEYSTORE       0x100
+
+/*!
+*******************************************************************************
+* sah_Link_Flags
+*
+* Type to be used for flags associated with a Link in security function.
+* These flags are used internally by the security function component only.
+*
+* Values defined at @ref lnkflags
+*
+* @brief typedef for flags field of sah_Link
+******************************************************************************/
+typedef uint32_t sah_Link_Flags;
+
+/*
+*******************************************************************************
+* Security Parameters Related Structures
+*
+* All of structures associated with API parameters
+*
+******************************************************************************/
+
+/*
+*******************************************************************************
+* Common Types
+*
+* All of structures used across several classes of crytography
+******************************************************************************/
+
+/*!
+*******************************************************************************
+* @brief Indefinite precision integer used for security operations on SAHARA
+* accelerator. The data will always be in little Endian format.
+******************************************************************************/
+typedef uint8_t *sah_Int;
+
+/*!
+*******************************************************************************
+* @brief Byte array used for block cipher and hash digest/MAC operations on
+* SAHARA accelerator. The Endian format will be as specified by the function
+* using the sah_Oct_Str.
+******************************************************************************/
+typedef uint8_t *sah_Oct_Str;
+
+/*!
+ * A queue of descriptor heads -- used to hold requests waiting for user to
+ * pick up the results. */
+typedef struct sah_Queue {
+	int count;		/*!< # entries in queue  */
+	struct sah_Head_Desc *head;	/*!< first entry in queue  */
+	struct sah_Head_Desc *tail;	/*!< last entry in queue   */
+} sah_Queue;
+
+/******************************************************************************
+ * Enumerations
+ *****************************************************************************/
+/*!
+ * Flags for the state of the User Context Object (#fsl_shw_uco_t).
+ */
+typedef enum fsl_shw_user_ctx_flags_t {
+	/*!
+	 * API will block the caller until operation completes.  The result will be
+	 * available in the return code.  If this is not set, user will have to get
+	 * results using #fsl_shw_get_results().
+	 */
+	FSL_UCO_BLOCKING_MODE = 0x01,
+	/*!
+	 * User wants callback (at the function specified with
+	 * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+	 * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+	 */
+	FSL_UCO_CALLBACK_MODE = 0x02,
+	/*! Do not free descriptor chain after driver (adaptor) finishes */
+	FSL_UCO_SAVE_DESC_CHAIN = 0x04,
+	/*!
+	 * User has made at least one request with callbacks requested, so API is
+	 * ready to handle others.
+	 */
+	FSL_UCO_CALLBACK_SETUP_COMPLETE = 0x08,
+	/*!
+	 * (virtual) pointer to descriptor chain is completely linked with physical
+	 * (DMA) addresses, ready for the hardware.  This flag should not be used
+	 * by FSL SHW API programs.
+	 */
+	FSL_UCO_CHAIN_PREPHYSICALIZED = 0x10,
+	/*!
+	 * The user has changed the context but the changes have not been copied to
+	 * the kernel driver.
+	 */
+	FSL_UCO_CONTEXT_CHANGED = 0x20,
+	/*! Internal Use.  This context belongs to a user-mode API user. */
+	FSL_UCO_USERMODE_USER = 0x40,
+} fsl_shw_user_ctx_flags_t;
+
+/*!
+ * Return code for FSL_SHW library.
+ *
+ * These codes may be returned from a function call.  In non-blocking mode,
+ * they will appear as the status in a Result Object.
+ */
+typedef enum fsl_shw_return_t {
+	/*!
+	 * No error.  As a function return code in Non-blocking mode, this may
+	 * simply mean that the operation was accepted for eventual execution.
+	 */
+	FSL_RETURN_OK_S = 0,
+	/*! Failure for non-specific reason. */
+	FSL_RETURN_ERROR_S,
+	/*!
+	 * Operation failed because some resource was not able to be allocated.
+	 */
+	FSL_RETURN_NO_RESOURCE_S,
+	/*! Crypto algorithm unrecognized or improper. */
+	FSL_RETURN_BAD_ALGORITHM_S,
+	/*! Crypto mode unrecognized or improper. */
+	FSL_RETURN_BAD_MODE_S,
+	/*! Flag setting unrecognized or inconsistent. */
+	FSL_RETURN_BAD_FLAG_S,
+	/*! Improper or unsupported key length for algorithm. */
+	FSL_RETURN_BAD_KEY_LENGTH_S,
+	/*! Improper parity in a (DES, TDES) key. */
+	FSL_RETURN_BAD_KEY_PARITY_S,
+	/*!
+	 * Improper or unsupported data length for algorithm or internal buffer.
+	 */
+	FSL_RETURN_BAD_DATA_LENGTH_S,
+	/*! Authentication / Integrity Check code check failed. */
+	FSL_RETURN_AUTH_FAILED_S,
+	/*! A memory error occurred. */
+	FSL_RETURN_MEMORY_ERROR_S,
+	/*! An error internal to the hardware occurred. */
+	FSL_RETURN_INTERNAL_ERROR_S,
+	/*! ECC detected Point at Infinity */
+	FSL_RETURN_POINT_AT_INFINITY_S,
+	/*! ECC detected No Point at Infinity */
+	FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+	/*! GCD is One */
+	FSL_RETURN_GCD_IS_ONE_S,
+	/*! GCD is not One */
+	FSL_RETURN_GCD_IS_NOT_ONE_S,
+	/*! Candidate is Prime */
+	FSL_RETURN_PRIME_S,
+	/*! Candidate is not Prime */
+	FSL_RETURN_NOT_PRIME_S,
+	/*! N register loaded improperly with even value */
+	FSL_RETURN_EVEN_MODULUS_ERROR_S,
+	/*! Divisor is zero. */
+	FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+	/*! Bad Exponent or Scalar value for Point Multiply */
+	FSL_RETURN_BAD_EXPONENT_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_OSCILLATOR_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_STATISTICS_ERROR_S,
+} fsl_shw_return_t;
+
+/*!
+ * Algorithm Identifier.
+ *
+ * Selection of algorithm will determine how large the block size of the
+ * algorithm is.   Context size is the same length unless otherwise specified.
+ * Selection of algorithm also affects the allowable key length.
+ */
+typedef enum fsl_shw_key_alg_t {
+	/*!
+	 * Key will be used to perform an HMAC.  Key size is 1 to 64 octets.  Block
+	 * size is 64 octets.
+	 */
+	FSL_KEY_ALG_HMAC,
+	/*!
+	 * Advanced Encryption Standard (Rijndael).  Block size is 16 octets.  Key
+	 * size is 16 octets.  (The single choice of key size is a Sahara platform
+	 * limitation.)
+	 */
+	FSL_KEY_ALG_AES,
+	/*!
+	 * Data Encryption Standard.  Block size is 8 octets.  Key size is 8
+	 * octets.
+	 */
+	FSL_KEY_ALG_DES,
+	/*!
+	 * 2- or 3-key Triple DES.  Block size is 8 octets.  Key size is 16 octets
+	 * for 2-key Triple DES, and 24 octets for 3-key.
+	 */
+	FSL_KEY_ALG_TDES,
+	/*!
+	 * ARC4.  No block size.  Context size is 259 octets.  Allowed key size is
+	 * 1-16 octets.  (The choices for key size are a Sahara platform
+	 * limitation.)
+	 */
+	FSL_KEY_ALG_ARC4,
+	/*!
+	 * Private key of a public-private key-pair.  Max is 512 bits...
+	 */
+	FSL_KEY_PK_PRIVATE,
+} fsl_shw_key_alg_t;
+
+/*!
+ * Mode selector for Symmetric Ciphers.
+ *
+ * The selection of mode determines how a cryptographic algorithm will be
+ * used to process the plaintext or ciphertext.
+ *
+ * For all modes which are run block-by-block (that is, all but
+ * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+ * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
+ * these block-by-block algorithms must also be passed a total number of octets
+ * which is a multiple of the block size.
+ *
+ * In modes which require that the total number of octets of data be a multiple
+ * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+ * has a total number of octets which are not a multiple of the block size, the
+ * user must perform any necessary padding to get to the correct data length.
+ */
+typedef enum fsl_shw_sym_mode_t {
+	/*!
+	 * Stream.  There is no associated block size.  Any request to process data
+	 * may be of any length.  This mode is only for ARC4 operations, and is
+	 * also the only mode used for ARC4.
+	 */
+	FSL_SYM_MODE_STREAM,
+
+	/*!
+	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+	 * length of the data stream must be a multiple of the block size.  This
+	 * mode may be used for DES, 3DES, and AES.  The block size is determined
+	 * by the algorithm.
+	 */
+	FSL_SYM_MODE_ECB,
+	/*!
+	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+	 * then "chained" with the previous block by an XOR function.  Requires
+	 * context to start the XOR (previous block).  This mode may be used for
+	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CBC,
+	/*!
+	 * Counter.  The counter is encrypted, then XORed with a block of data.
+	 * The counter is then incremented (using modulus arithmetic) for the next
+	 * block. The final operation may be non-multiple of block size.  This mode
+	 * may be used for AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CTR,
+} fsl_shw_sym_mode_t;
+
+/*!
+ * Algorithm selector for Cryptographic Hash functions.
+ *
+ * Selection of algorithm determines how large the context and digest will be.
+ * Context is the same size as the digest (resulting hash), unless otherwise
+ * specified.
+ */
+typedef enum fsl_shw_hash_alg_t {
+	/*! MD5 algorithm.  Digest is 16 octets. */
+	FSL_HASH_ALG_MD5,
+	/*! SHA-1 (aka SHA or SHA-160) algorithm. Digest is 20 octets. */
+	FSL_HASH_ALG_SHA1,
+	/*!
+	 * SHA-224 algorithm.  Digest is 28 octets, though context is 32 octets.
+	 */
+	FSL_HASH_ALG_SHA224,
+	/*! SHA-256 algorithm.  Digest is 32 octets. */
+	FSL_HASH_ALG_SHA256
+} fsl_shw_hash_alg_t;
+
+/*!
+ * The type of Authentication-Cipher function which will be performed.
+ */
+typedef enum fsl_shw_acc_mode_t {
+	/*!
+	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+	 * be non-multiple of block size.  This mode may be used for AES.
+	 */
+	FSL_ACC_MODE_CCM,
+	/*!
+	 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+	 * Needs one key object for encryption, another for the HMAC.  The usual
+	 * hashing and symmetric encryption algorithms are supported.
+	 */
+	FSL_ACC_MODE_SSL,
+} fsl_shw_acc_mode_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Flags which control a Hash operation.
+ */
+typedef enum fsl_shw_hash_ctx_flags_t {
+	/*!
+	 * Context is empty.  Hash is started from scratch, with a
+	 * message-processed count of zero.
+	 */
+	FSL_HASH_FLAGS_INIT = 0x01,
+	/*!
+	 *  Retrieve context from hardware after hashing.  If used with the
+	 *  #FSL_HASH_FLAGS_FINALIZE flag, the final digest value will be saved in
+	 *  the object.
+	 */
+	FSL_HASH_FLAGS_SAVE = 0x02,
+	/*! Place context into hardware before hashing. */
+	FSL_HASH_FLAGS_LOAD = 0x04,
+	/*!
+	 * PAD message and perform final digest operation.  If user message is
+	 * pre-padded, this flag should not be used.
+	 */
+	FSL_HASH_FLAGS_FINALIZE = 0x08,
+} fsl_shw_hash_ctx_flags_t;
+
+/*!
+ * Flags which control an HMAC operation.
+ *
+ * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+ * and #fsl_shw_hmco_clear_flags().
+ */
+typedef enum fsl_shw_hmac_ctx_flags_t {
+	/*!
+	 * Message context is empty.  HMAC is started from scratch (with key) or
+	 * from precompute of inner hash, depending on whether
+	 * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is set.
+	 */
+	FSL_HMAC_FLAGS_INIT = 1,
+	/*!
+	 * Retrieve ongoing context from hardware after hashing.  If used with the
+	 * #FSL_HMAC_FLAGS_FINALIZE flag, the final digest value (HMAC) will be
+	 * saved in the object.
+	 */
+	FSL_HMAC_FLAGS_SAVE = 2,
+	/*! Place ongoing context into hardware before hashing. */
+	FSL_HMAC_FLAGS_LOAD = 4,
+	/*!
+	 * PAD message and perform final HMAC operations of inner and outer
+	 * hashes.
+	 */
+	FSL_HMAC_FLAGS_FINALIZE = 8,
+	/*!
+	 * This means that the context contains precomputed inner and outer hash
+	 * values.
+	 */
+	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16,
+} fsl_shw_hmac_ctx_flags_t;
+
+/*!
+ * Flags to control use of the #fsl_shw_scco_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+ */
+typedef enum fsl_shw_sym_ctx_flags_t {
+	/*!
+	 * Context is empty.  In ARC4, this means that the S-Box needs to be
+	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+	 * initial CTR value of zero is desired.
+	 */
+	FSL_SYM_CTX_INIT = 1,
+	/*!
+	 * Load context from object into hardware before running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_LOAD = 2,
+	/*!
+	 * Save context from hardware into object after running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_SAVE = 4,
+	/*!
+	 * Context (SBox) is to be unwrapped and wrapped on each use.
+	 * This flag is unsupported.
+	 * */
+	FSL_SYM_CTX_PROTECT = 8,
+} fsl_shw_sym_ctx_flags_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_sko_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+ */
+typedef enum fsl_shw_key_flags_t {
+	/*! If algorithm is DES or 3DES, do not validate the key parity bits. */
+	FSL_SKO_KEY_IGNORE_PARITY = 1,
+	/*! Clear key is present in the object. */
+	FSL_SKO_KEY_PRESENT = 2,
+	/*!
+	 * Key has been established for use.  This feature is not available for all
+	 * platforms, nor for all algorithms and modes.
+	 */
+	FSL_SKO_KEY_ESTABLISHED = 4,
+	/*!
+	 * Key intended for user (software) use; can be read cleartext from the
+	 * keystore.
+	 */
+	FSL_SKO_KEY_SW_KEY = 8,
+} fsl_shw_key_flags_t;
+
+/*!
+ * Type of value which is associated with an established key.
+ */
+typedef uint64_t key_userid_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_acco_t.
+ *
+ * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+ * together, provide for a one-shot operation.
+ */
+typedef enum fsl_shw_auth_ctx_flags_t {
+	/*! Initialize Context(s) */
+	FSL_ACCO_CTX_INIT = 1,
+	/*! Load intermediate context(s). This flag is unsupported. */
+	FSL_ACCO_CTX_LOAD = 2,
+	/*! Save intermediate context(s). This flag is unsupported. */
+	FSL_ACCO_CTX_SAVE = 4,
+	/*! Create MAC during this operation. */
+	FSL_ACCO_CTX_FINALIZE = 8,
+	/*!
+	 * Formatting of CCM input data is performed by calls to
+	 * #fsl_shw_ccm_nist_format_ctr_and_iv() and
+	 * #fsl_shw_ccm_nist_update_ctr_and_iv().
+	 */
+	FSL_ACCO_NIST_CCM = 0x10,
+} fsl_shw_auth_ctx_flags_t;
+
+/*!
+ * The operation which controls the behavior of #fsl_shw_establish_key().
+ *
+ * These values are passed to #fsl_shw_establish_key().
+ */
+typedef enum fsl_shw_key_wrap_t {
+	/*! Generate a key from random values. */
+	FSL_KEY_WRAP_CREATE,
+	/*! Use the provided clear key. */
+	FSL_KEY_WRAP_ACCEPT,
+	/*! Unwrap a previously wrapped key. */
+	FSL_KEY_WRAP_UNWRAP
+} fsl_shw_key_wrap_t;
+
+/*!
+ *  Modulus Selector for CTR modes.
+ *
+ * The incrementing of the Counter value may be modified by a modulus.  If no
+ * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+ */
+typedef enum fsl_shw_ctr_mod_t {
+	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
+	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
+	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
+	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
+	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
+	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
+	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
+	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
+	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
+	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
+	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
+	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
+	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
+	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
+	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
+	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
+} fsl_shw_ctr_mod_t;
+
+/*!
+ * Permissions flags for Secure Partitions
+ */
+typedef enum fsl_shw_permission_t {
+/*! SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+	FSL_PERM_NO_ZEROIZE = 0x80000000,
+/*! SCM Access Permission: Enforce trusted key read in  */
+	FSL_PERM_TRUSTED_KEY_READ = 0x40000000,
+/*! SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+	FSL_PERM_HD_S = 0x00000800,
+/*! SCM Access Permission: Allow Read Access to  Host Domain */
+	FSL_PERM_HD_R = 0x00000400,
+/*! SCM Access Permission: Allow Write Access to  Host Domain */
+	FSL_PERM_HD_W = 0x00000200,
+/*! SCM Access Permission: Allow Execute Access to  Host Domain */
+	FSL_PERM_HD_X = 0x00000100,
+/*! SCM Access Permission: Allow Read Access to Trusted Host Domain */
+	FSL_PERM_TH_R = 0x00000040,
+/*! SCM Access Permission: Allow Write Access to Trusted Host Domain */
+	FSL_PERM_TH_W = 0x00000020,
+/*! SCM Access Permission: Allow Read Access to Other/World Domain */
+	FSL_PERM_OT_R = 0x00000004,
+/*! SCM Access Permission: Allow Write Access to Other/World Domain */
+	FSL_PERM_OT_W = 0x00000002,
+/*! SCM Access Permission: Allow Execute Access to Other/World Domain */
+	FSL_PERM_OT_X = 0x00000001,
+} fsl_shw_permission_t;
+
+typedef enum fsl_shw_cypher_mode_t {
+	FSL_SHW_CYPHER_MODE_ECB = 1,	/*!< ECB mode */
+	FSL_SHW_CYPHER_MODE_CBC = 2,	/*!< CBC mode */
+} fsl_shw_cypher_mode_t;
+
+typedef enum fsl_shw_pf_key_t {
+	FSL_SHW_PF_KEY_IIM,	/*!< Present fused IIM key */
+	FSL_SHW_PF_KEY_PRG,	/*!< Present Program key */
+	FSL_SHW_PF_KEY_IIM_PRG,	/*!< Present IIM ^ Program key */
+	FSL_SHW_PF_KEY_IIM_RND,	/*!< Present Random key */
+	FSL_SHW_PF_KEY_RND,	/*!< Present IIM ^ Random key */
+} fsl_shw_pf_key_t;
+
+typedef enum fsl_shw_tamper_t {
+	FSL_SHW_TAMPER_NONE,	/*!< No error detected */
+	FSL_SHW_TAMPER_WTD,	/*!< wire-mesh tampering det */
+	FSL_SHW_TAMPER_ETBD,	/*!< ext tampering det: input B */
+	FSL_SHW_TAMPER_ETAD,	/*!< ext tampering det: input A */
+	FSL_SHW_TAMPER_EBD,	/*!< external boot detected */
+	FSL_SHW_TAMPER_SAD,	/*!< security alarm detected */
+	FSL_SHW_TAMPER_TTD,	/*!< temperature tampering det */
+	FSL_SHW_TAMPER_CTD,	/*!< clock tampering det */
+	FSL_SHW_TAMPER_VTD,	/*!< voltage tampering det */
+	FSL_SHW_TAMPER_MCO,	/*!< monotonic counter overflow */
+	FSL_SHW_TAMPER_TCO,	/*!< time counter overflow */
+} fsl_shw_tamper_t;
+
+/******************************************************************************
+ * Data Structures
+ *****************************************************************************/
+
+/*!
+ *
+ * @brief Structure type for descriptors
+ *
+ * The first five fields are passed to the hardware.
+ *
+ *****************************************************************************/
+#ifndef USE_NEW_PTRS		/* Experimental */
+
+typedef struct sah_Desc {
+	uint32_t header;	/*!< descriptor header value */
+	uint32_t len1;		/*!< number of data bytes in 'ptr1' buffer */
+	void *ptr1;		/*!< pointer to first sah_Link structure */
+	uint32_t len2;		/*!< number of data bytes in 'ptr2' buffer */
+	void *ptr2;		/*!< pointer to second sah_Link structure */
+	struct sah_Desc *next;	/*!< pointer to next descriptor */
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two must be last.  See sah_Copy_Descriptors */
+	struct sah_Desc *virt_addr;	/*!< Virtual (kernel) address of this
+					   descriptor. */
+	dma_addr_t dma_addr;	/*!< Physical (bus) address of this
+				   descriptor.  */
+	void *original_ptr1;	/*!< user's pointer to ptr1 */
+	void *original_ptr2;	/*!< user's pointer to ptr2 */
+	struct sah_Desc *original_next;	/*!< user's pointer to next */
+#endif
+} sah_Desc;
+
+#else
+
+typedef struct sah_Desc {
+	uint32_t header;	/*!< descriptor header value */
+	uint32_t len1;		/*!< number of data bytes in 'ptr1' buffer */
+	uint32_t hw_ptr1;	/*!< pointer to first sah_Link structure */
+	uint32_t len2;		/*!< number of data bytes in 'ptr2' buffer */
+	uint32_t hw_ptr2;	/*!< pointer to second sah_Link structure */
+	uint32_t hw_next;	/*!< pointer to next descriptor */
+	struct sah_Link *ptr1;	/*!< (virtual) pointer to first sah_Link structure */
+	struct sah_Link *ptr2;	/*!< (virtual) pointer to first sah_Link structure */
+	struct sah_Desc *next;	/*!< (virtual) pointer to next descriptor */
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two must be last.  See sah_Copy_Descriptors */
+	struct sah_Desc *virt_addr;	/*!< Virtual (kernel) address of this
+					   descriptor. */
+	dma_addr_t dma_addr;	/*!< Physical (bus) address of this
+				   descriptor.  */
+#endif
+} sah_Desc;
+
+#endif
+
+/*!
+*******************************************************************************
+* @brief The first descriptor in a chain
+******************************************************************************/
+typedef struct sah_Head_Desc {
+	sah_Desc desc;		/*!< whole struct - must be first */
+	struct fsl_shw_uco_t *user_info;	/*!< where result pool lives */
+	uint32_t user_ref;	/*!< at time of request */
+	uint32_t uco_flags;	/*!< at time of request */
+	uint32_t status;	/*!<  Status of queue entry */
+	uint32_t error_status;	/*!< If error, register from Sahara */
+	uint32_t fault_address;	/*!< If error, register from Sahara */
+	uint32_t op_status;	/*!< If error, register from Sahara */
+	fsl_shw_return_t result;	/*!< Result of running descriptor  */
+	struct sah_Head_Desc *next;	/*!< Next in queue  */
+	struct sah_Head_Desc *prev;	/*!< previous in queue  */
+	struct sah_Head_Desc *user_desc;	/*!< For API async get_results */
+	void *out1_ptr;		/*!< For async post-processing  */
+	void *out2_ptr;		/*!< For async post-processing  */
+	uint32_t out_len;	/*!< For async post-processing  */
+} sah_Head_Desc;
+
+/*!
+ * @brief Structure type for links
+ *
+ * The first three fields are used by hardware.
+ *****************************************************************************/
+#ifndef USE_NEW_PTRS
+
+typedef struct sah_Link {
+	size_t len;		/*!< len of 'data' buffer in bytes */
+	uint8_t *data;		/*!< buffer to store data */
+	struct sah_Link *next;	/*!< pointer to the next sah_Link storing
+				 * data */
+	sah_Link_Flags flags;	/*!< indicates the component that created the
+				 * data buffer. Security Function internal
+				 * information */
+	key_userid_t ownerid;	/*!< Auth code for established key */
+	uint32_t slot;		/*!< Location of the the established key */
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two elements must be last.  See sah_Copy_Links() */
+	struct sah_Link *virt_addr;
+	dma_addr_t dma_addr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+	struct page *vm_info;
+#endif
+	uint8_t *original_data;	/*!< user's version of data pointer */
+	struct sah_Link *original_next;	/*!< user's version of next pointer */
+#ifdef SAH_COPY_DATA
+	uint8_t *copy_data;	/*!< Virtual address of acquired buffer */
+#endif
+#endif				/* kernel-only */
+} sah_Link;
+
+#else
+
+typedef struct sah_Link {
+	/*! len of 'data' buffer in bytes */
+	size_t len;
+	/*! buffer to store data */
+	uint32_t hw_data;
+	/*! Physical address */
+	uint32_t hw_next;
+	/*!
+	 * indicates the component that created the data buffer. Security Function
+	 * internal information
+	 */
+	sah_Link_Flags flags;
+	/*! (virtual) pointer to data */
+	uint8_t *data;
+	/*! (virtual) pointer to the next sah_Link storing data */
+	struct sah_Link *next;
+	/*! Auth code for established key */
+	key_userid_t ownerid;
+	/*! Location of the the established key */
+	uint32_t slot;
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two elements must be last.  See sah_Copy_Links() */
+	struct sah_Link *virt_addr;
+	dma_addr_t dma_addr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+	struct page *vm_info;
+#endif
+#endif				/* kernel-only */
+} sah_Link;
+
+#endif
+
+/*!
+ * Initialization Object
+ */
+typedef struct fsl_sho_ibo_t {
+} fsl_sho_ibo_t;
+
+/* Imported from Sahara1 driver -- is it needed forever? */
+/*!
+*******************************************************************************
+* FIELDS
+*
+*   void * ref - parameter to be passed into the memory function calls
+*
+*   void * (*malloc)(void *ref, size_t n) - pointer to user's malloc function
+*
+*   void   (*free)(void *ref, void *ptr)  - pointer to user's free function
+*
+*   void * (*memcpy)(void *ref, void *dest, const void *src, size_t n) -
+*                                         pointer to user's memcpy function
+*
+*   void * (*memset)(void *ref, void *ptr, int ch, size_t n) - pointer to
+*                                         user's memset function
+*
+* @brief Structure for API memory utilities
+******************************************************************************/
+typedef struct sah_Mem_Util {
+	/*! Who knows.  Vestigial. */
+	void *mu_ref;
+	/*! Acquire buffer of size n bytes */
+	void *(*mu_malloc) (void *ref, size_t n);
+	/*! Acquire a sah_Head_Desc */
+	sah_Head_Desc *(*mu_alloc_head_desc) (void *ref);
+	/* Acquire a sah_Desc */
+	sah_Desc *(*mu_alloc_desc) (void *ref);
+	/* Acquire a sah_Link */
+	sah_Link *(*mu_alloc_link) (void *ref);
+	/*! Free buffer at ptr */
+	void (*mu_free) (void *ref, void *ptr);
+	/*! Free sah_Head_Desc at ptr */
+	void (*mu_free_head_desc) (void *ref, sah_Head_Desc * ptr);
+	/*! Free sah_Desc at ptr */
+	void (*mu_free_desc) (void *ref, sah_Desc * ptr);
+	/*! Free sah_Link at ptr */
+	void (*mu_free_link) (void *ref, sah_Link * ptr);
+	/*! Funciton which will copy n bytes from src to dest  */
+	void *(*mu_memcpy) (void *ref, void *dest, const void *src, size_t n);
+	/*! Set all n bytes of ptr to ch */
+	void *(*mu_memset) (void *ref, void *ptr, int ch, size_t n);
+} sah_Mem_Util;
+
+/*!
+ * Secure Partition information
+ *
+ * This holds the context to a single secure partition owned by the user.  It
+ * is only available in the kernel version of the User Context Object.
+ */
+typedef struct fsl_shw_spo_t {
+	uint32_t user_base;	/*!< Base address (user virtual) */
+	void *kernel_base;	/*!< Base address (kernel virtual) */
+	struct fsl_shw_spo_t *next;	/*!< Pointer to the next partition
+					   owned by the user.  NULL if this
+					   is the last partition. */
+} fsl_shw_spo_t;
+
+/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+/*!
+ * User Context Object
+ */
+typedef struct fsl_shw_uco_t {
+	int sahara_openfd;	/*!< this should be kernel-only?? */
+	sah_Mem_Util *mem_util;	/*!< Memory utility fns  */
+	uint32_t user_ref;	/*!< User's reference */
+	void (*callback) (struct fsl_shw_uco_t * uco);	/*!< User's callback fn  */
+	uint32_t flags;		/*!< from fsl_shw_user_ctx_flags_t */
+	unsigned pool_size;	/*!< maximum size of user pool */
+#ifdef __KERNEL__
+	sah_Queue result_pool;	/*!< where non-blocking results go */
+	os_process_handle_t process;	/*!< remember for signalling User mode */
+	fsl_shw_spo_t *partition;	/*!< chain of secure partitions owned by
+					   the user */
+#else
+	struct fsl_shw_uco_t *next;	/*!< To allow user-mode chaining of contexts,
+					   for signalling.  */
+#endif
+} fsl_shw_uco_t;
+
+/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+/*!
+ * Result object
+ */
+typedef struct fsl_shw_result_t {
+	uint32_t user_ref;
+	fsl_shw_return_t code;
+	uint32_t detail1;
+	uint32_t detail2;
+	sah_Head_Desc *user_desc;
+} fsl_shw_result_t;
+
+/*!
+ * Keystore Object
+ */
+typedef struct fsl_shw_kso_t {
+#ifdef __KERNEL__
+	os_lock_t lock;		/*!< Pointer to lock that controls access to
+				   the keystore. */
+#endif
+	void *user_data;	/*!< Pointer to user structure that handles
+				   the internals of the keystore. */
+	 fsl_shw_return_t(*data_init) (fsl_shw_uco_t * user_ctx,
+				       void **user_data);
+	void (*data_cleanup) (fsl_shw_uco_t * user_ctx, void **user_data);
+	 fsl_shw_return_t(*slot_verify_access) (void *user_data,
+						uint64_t owner_id,
+						uint32_t slot);
+	 fsl_shw_return_t(*slot_alloc) (void *user_data, uint32_t size_bytes,
+					uint64_t owner_id, uint32_t * slot);
+	 fsl_shw_return_t(*slot_dealloc) (void *user_data, uint64_t owner_id,
+					  uint32_t slot);
+	void *(*slot_get_address) (void *user_data, uint32_t slot);
+	 uint32_t(*slot_get_base) (void *user_data, uint32_t slot);
+	 uint32_t(*slot_get_offset) (void *user_data, uint32_t slot);
+	 uint32_t(*slot_get_slot_size) (void *user_data, uint32_t slot);
+} fsl_shw_kso_t;
+
+/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+/*!
+ * Secret Key Context Object
+ */
+typedef struct fsl_shw_sko_t {
+	uint32_t flags;
+	fsl_shw_key_alg_t algorithm;
+	key_userid_t userid;
+	uint32_t handle;
+	uint16_t key_length;
+	uint8_t key[64];
+	struct fsl_shw_kso_t *keystore;	/*!< If present, key is in keystore */
+} fsl_shw_sko_t;
+
+/* REQ-S2LRD-PINTFC-COA-CO-001 */
+/*!
+ * @brief Platform Capability Object
+ */
+typedef struct fsl_shw_pco_t {	/* Consider turning these constants into symbols */
+	int api_major;
+	int api_minor;
+	int driver_major;
+	int driver_minor;
+	fsl_shw_key_alg_t sym_algorithms[4];
+	fsl_shw_sym_mode_t sym_modes[4];
+	fsl_shw_hash_alg_t hash_algorithms[4];
+	uint8_t sym_support[5][4];	/* indexed by key alg then mode */
+
+	int scc_driver_major;
+	int scc_driver_minor;
+	int scm_version;	/*!< Version from SCM Configuration register */
+	int smn_version;	/*!< Version from SMN Status register */
+	int block_size_bytes;	/*!< Number of bytes per block of RAM; also
+				   block size of the crypto algorithm. */
+	union {
+		struct {
+			int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
+			int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
+		} scc_info;
+		struct {
+			int partition_size_bytes;	/*!< Number of bytes in each partition */
+			int partition_count;	/*!< Number of partitions on this platform */
+		} scc2_info;
+	};
+} fsl_shw_pco_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Hash Context Object
+ */
+typedef struct fsl_shw_hco_t {	/* fsl_shw_hash_context_object */
+	fsl_shw_hash_alg_t algorithm;
+	uint32_t flags;
+	uint8_t digest_length;	/* in bytes */
+	uint8_t context_length;	/* in bytes */
+	uint8_t context_register_length;	/* in bytes */
+	/* ensure following HW buffers not cached with surrounding fields */
+	uint8_t cache_front_pad[64]; /* fill out cache line */
+	uint32_t context[9];  /* largest digest + msg size */
+	uint8_t cache_back_pad[64]; /* fill out cache line */
+} fsl_shw_hco_t;
+
+/*!
+ * HMAC Context Object
+ */
+typedef struct fsl_shw_hmco_t {	/* fsl_shw_hmac_context_object */
+	fsl_shw_hash_alg_t algorithm;
+	uint32_t flags;
+	uint8_t digest_length;	/*!< in bytes */
+	uint8_t context_length;	/*!< in bytes */
+	uint8_t context_register_length;	/*!< in bytes */
+	/* ensure following HW buffers not cached with surrounding fields */
+	uint8_t cache_front_pad[64]; /* fill out cache line */
+	uint32_t ongoing_context[9]; /**< largest digest + msg size */
+	uint32_t inner_precompute[9]; /**< largest digest + msg size */
+	uint32_t outer_precompute[9]; /**< largest digest + msg size */
+	uint8_t cache_back_pad[64]; /* fill out cache line */
+} fsl_shw_hmco_t;
+
+/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+/*!
+ * Symmetric Crypto Context Object Context Object
+ */
+typedef struct fsl_shw_scco_t {
+	uint32_t flags;
+	unsigned block_size_bytes;	/* double duty block&ctx size */
+	fsl_shw_sym_mode_t mode;
+	/* Could put modulus plus 16-octet context in union with arc4
+	   sbox+ptrs... */
+	fsl_shw_ctr_mod_t modulus_exp;
+	/* ensure following HW buffers not cached with surrounding fields */
+	uint8_t cache_front_pad[64]; /* fill out cache line */
+	uint8_t context[259];
+	uint8_t cache_back_pad[64]; /* fill out cache line */
+} fsl_shw_scco_t;
+
+/*!
+ * Authenticate-Cipher Context Object
+
+ * An object for controlling the function of, and holding information about,
+ * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+ * #fsl_shw_auth_decrypt().
+ */
+typedef struct fsl_shw_acco_t {
+	uint32_t flags;		/*!< See #fsl_shw_auth_ctx_flags_t for
+				   meanings */
+	fsl_shw_acc_mode_t mode;	/*!< CCM only */
+	uint8_t mac_length;	/*!< User's value for length  */
+	unsigned q_length;	/*!< NIST parameter - */
+	fsl_shw_scco_t cipher_ctx_info;	/*!< For running
+					   encrypt/decrypt. */
+	union {
+		fsl_shw_scco_t CCM_ctx_info;	/*!< For running the CBC in
+						   AES-CCM.  */
+		fsl_shw_hco_t hash_ctx_info;	/*!< For running the hash */
+	} auth_info;		/*!< "auth" info struct  */
+	uint8_t unencrypted_mac[16];	/*!< max block size... */
+	/* ensure above HW buffer not cached with any following variables */
+	uint8_t cache_back_pad[64]; /* fill out cache line */
+} fsl_shw_acco_t;
+
+/*!
+ *  Used by Sahara API to retrieve completed non-blocking results.
+ */
+typedef struct sah_results {
+	unsigned requested;	/*!< number of results requested */
+	unsigned *actual;	/*!< number of results obtained */
+	fsl_shw_result_t *results;	/*!< pointer to memory to hold results */
+} sah_results;
+
+/*!
+ * @typedef scc_partition_status_t
+ */
+/*! Partition status information. */
+typedef enum fsl_shw_partition_status_t {
+	FSL_PART_S_UNUSABLE,	/*!< Partition not implemented */
+	FSL_PART_S_UNAVAILABLE,	/*!< Partition owned by other host */
+	FSL_PART_S_AVAILABLE,	/*!< Partition available */
+	FSL_PART_S_ALLOCATED,	/*!< Partition owned by host but not engaged
+				 */
+	FSL_PART_S_ENGAGED,	/*!< Partition owned by host and engaged */
+} fsl_shw_partition_status_t;
+
+/******************************************************************************
+ * Access Macros for Objects
+ *****************************************************************************/
+/*!
+ * Get FSL SHW API version
+ *
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the API is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the API is to be stored.
+ */
+#define fsl_shw_pco_get_version(pcobject, pcmajor, pcminor)                   \
+{                                                                             \
+    *(pcmajor) = (pcobject)->api_major;                                       \
+    *(pcminor) = (pcobject)->api_minor;                                       \
+}
+
+/*!
+ * Get underlying driver version.
+ *
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the driver is to be stored.
+ */
+#define fsl_shw_pco_get_driver_version(pcobject, pcmajor, pcminor)            \
+{                                                                             \
+    *(pcmajor) = (pcobject)->driver_major;                                    \
+    *(pcminor) = (pcobject)->driver_minor;                                    \
+}
+
+/*!
+ * Get list of symmetric algorithms supported.
+ *
+ * @param pcobject           The Platform Capababilities Object to query.
+ * @param[out] pcalgorithms  A pointer to where to store the location of
+ *                           the list of algorithms.
+ * @param[out] pcacount      A pointer to where to store the number of
+ *                           algorithms in the list at @a algorithms.
+ */
+#define fsl_shw_pco_get_sym_algorithms(pcobject, pcalgorithms, pcacount)      \
+{                                                                             \
+    *(pcalgorithms) = (pcobject)->sym_algorithms;                             \
+    *(pcacount) = sizeof((pcobject)->sym_algorithms)/4;                       \
+}
+
+/*!
+ * Get list of symmetric modes supported.
+ *
+ * @param pcobject        The Platform Capababilities Object to query.
+ * @param[out] gsmodes    A pointer to where to store the location of
+ *                        the list of modes.
+ * @param[out] gsacount   A pointer to where to store the number of
+ *                        algorithms in the list at @a modes.
+ */
+#define fsl_shw_pco_get_sym_modes(pcobject, gsmodes, gsacount)                \
+{                                                                             \
+    *(gsmodes) = (pcobject)->sym_modes;                                       \
+    *(gsacount) = sizeof((pcobject)->sym_modes)/4;                            \
+}
+
+/*!
+ * Get list of hash algorithms supported.
+ *
+ * @param pcobject           The Platform Capababilities Object to query.
+ * @param[out] gsalgorithms  A pointer which will be set to the list of
+ *                           algorithms.
+ * @param[out] gsacount      The number of algorithms in the list at @a
+ *                           algorithms.
+ */
+#define fsl_shw_pco_get_hash_algorithms(pcobject, gsalgorithms, gsacount)     \
+{                                                                             \
+    *(gsalgorithms) = (pcobject)->hash_algorithms;                            \
+    *(gsacount) = sizeof((pcobject)->hash_algorithms)/4;                      \
+}
+
+/*!
+ * Determine whether the combination of a given symmetric algorithm and a given
+ * mode is supported.
+ *
+ * @param pcobject   The Platform Capababilities Object to query.
+ * @param pcalg      A Symmetric Cipher algorithm.
+ * @param pcmode     A Symmetric Cipher mode.
+ *
+ * @return 0 if combination is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_sym_supported(pcobject, pcalg, pcmode)              \
+    ((pcobject)->sym_support[pcalg][pcmode])
+
+/*!
+ * Determine whether a given Encryption-Authentication mode is supported.
+ *
+ * @param pcobject  The Platform Capababilities Object to query.
+ * @param pcmode    The Authentication mode.
+ *
+ * @return 0 if mode is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_auth_supported(pcobject, pcmode)                    \
+    ((pcmode == FSL_ACC_MODE_CCM) ? 1 : 0)
+
+/*!
+ * Determine whether Black Keys (key establishment / wrapping) is supported.
+ *
+ * @param pcobject  The Platform Capababilities Object to query.
+ *
+ * @return 0 if wrapping is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_black_key_supported(pcobject)                     \
+    1
+
+/*!
+ * Determine whether Programmed Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Programmed Key features are available, otherwise zero.
+ */
+#define fsl_shw_pco_check_pk_supported(pcobject)        \
+    0
+
+/*!
+ * Determine whether Software Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Software key features are available, otherwise zero.
+ */
+#define fsl_shw_pco_check_sw_keys_supported(pcobject)        \
+    0
+
+/*!
+ * Get FSL SHW SCC driver version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
+#define fsl_shw_pco_get_scc_driver_version(pcobject, pcmajor, pcminor)        \
+{                                                                             \
+    *(pcmajor) = (pcobject)->scc_driver_major;                                \
+    *(pcminor) = (pcobject)->scc_driver_minor;                                \
+}
+
+/*!
+ * Get SCM hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SCM hardware version
+ */
+#define fsl_shw_pco_get_scm_version(pcobject)                                 \
+    ((pcobject)->scm_version)
+
+/*!
+ * Get SMN hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SMN hardware version
+ */
+#define fsl_shw_pco_get_smn_version(pcobject)                                 \
+    ((pcobject)->smn_version)
+
+/*!
+ * Get the size of an SCM block, in bytes
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
+#define fsl_shw_pco_get_scm_block_size(pcobject)                              \
+    ((pcobject)->block_size_bytes)
+
+/*!
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pcobject    The Platform Capabilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in
+ *                         blocks, is to be placed.
+ */
+#define fsl_shw_pco_get_smn_size(pcobject, black_size, red_size)              \
+{                                                                             \
+    if ((pcobject)->scm_version == 1) {                                       \
+        *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;           \
+        *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;             \
+    } else {                                                                  \
+        *(black_size) = 0;                                                    \
+        *(red_size)   = 0;                                                    \
+    }                                                                         \
+}
+
+/*!
+ * Determine whether Secure Partitions are supported
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return 0 if secure partitions are not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_spo_supported(pcobject)                           \
+    ((pcobject)->scm_version == 2)
+
+/*!
+ * Get the size of a Secure Partitions
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+ */
+#define fsl_shw_pco_get_spo_size_bytes(pcobject)                            \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_size_bytes) : 0 )
+
+/*!
+ * Get the number of Secure Partitions on this platform
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return Number of partitions. 0 if Secure Paritions not supported.  Note
+ *         that this returns the total number of partitions, not all may be
+ *         available to the user.
+ */
+#define fsl_shw_pco_get_spo_count(pcobject)                                 \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_count) : 0 )
+
+/*!
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param usize        The maximum number of operations which can be
+ *                     outstanding.
+ */
+#ifdef __KERNEL__
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+{                                                                             \
+      (ucontext)->pool_size = usize;                                          \
+      (ucontext)->flags = FSL_UCO_BLOCKING_MODE;                              \
+      (ucontext)->sahara_openfd = -1;                                         \
+      (ucontext)->mem_util = NULL;                                            \
+      (ucontext)->partition = NULL;                                           \
+      (ucontext)->callback = NULL;                                            \
+}
+#else
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+{                                                                             \
+      (ucontext)->pool_size = usize;                                          \
+      (ucontext)->flags = FSL_UCO_BLOCKING_MODE;                              \
+      (ucontext)->sahara_openfd = -1;                                         \
+      (ucontext)->mem_util = NULL;                                            \
+      (ucontext)->callback = NULL;                                            \
+}
+#endif
+
+/*!
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uref         A value which will be passed back with a result.
+ */
+#define fsl_shw_uco_set_reference(ucontext, uref)                             \
+      (ucontext)->user_ref = uref
+
+/*!
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param ucallback    The function the API will invoke when an operation
+ *                     completes.
+ */
+#define fsl_shw_uco_set_callback(ucontext, ucallback)                         \
+      (ucontext)->callback = ucallback
+
+/*!
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_set_flags(ucontext, uflags)                               \
+      (ucontext)->flags |= (uflags)
+
+/*!
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_clear_flags(ucontext, uflags)                             \
+      (ucontext)->flags &= ~(uflags)
+
+/*!
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+#define fsl_shw_ro_get_reference(robject)                                    \
+       (robject)->user_ref
+
+/*!
+ * Retrieve the status code from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The status of the request.
+ */
+#define fsl_shw_ro_get_status(robject)                                       \
+       (robject)->code
+
+/*!
+ * Initialize a Secret Key Object.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.
+ *
+ * @param skobject     The Secret Key Object to be initialized.
+ * @param skalgorithm  DES, AES, etc.
+ *
+ */
+#define fsl_shw_sko_init(skobject,skalgorithm)                               \
+{                                                                            \
+       (skobject)->algorithm = skalgorithm;                                  \
+       (skobject)->flags = 0;                                                \
+       (skobject)->keystore = NULL;                                          \
+}
+
+/*!
+ * Initialize a Secret Key Object to use a Platform Key register.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.  INVALID on this platform.
+ *
+ * @param skobject     The Secret Key Object to be initialized.
+ * @param skalgorithm  DES, AES, etc.
+ * @param skhwkey      one of the fsl_shw_pf_key_t values.
+ *
+ */
+#define fsl_shw_sko_init_pf_key(skobject,skalgorithm,skhwkey)       \
+{                                                                   \
+    (skobject)->algorithm = -1;                                         \
+    (skobject)->flags = -1;                                             \
+    (skobject)->keystore = NULL;                                        \
+}
+
+/*!
+ * Store a cleartext key in the key object.
+ *
+ * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
+ * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
+ *
+ * @param skobject     A variable of type #fsl_shw_sko_t.
+ * @param skkey        A pointer to the beginning of the key.
+ * @param skkeylen     The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+#define fsl_shw_sko_set_key(skobject, skkey, skkeylen)                       \
+{                                                                            \
+       (skobject)->key_length = skkeylen;                                    \
+       copy_bytes((skobject)->key, skkey, skkeylen);                         \
+       (skobject)->flags |= FSL_SKO_KEY_PRESENT;                             \
+       (skobject)->flags &= ~FSL_SKO_KEY_ESTABLISHED;                        \
+}
+
+/*!
+ * Set a size for the key.
+ *
+ * This function would normally be used when the user wants the key to be
+ * generated from a random source.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skkeylen   The length, in octets, of the key.  The value should be
+ *                   appropriate to the key size supported by the algorithm.
+ *                   64 octets is the absolute maximum value allowed for this
+ *                   call.
+ */
+#define fsl_shw_sko_set_key_length(skobject, skkeylen)                       \
+       (skobject)->key_length = skkeylen;
+
+/*!
+ * Set the User ID associated with the key.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skuserid   The User ID to identify authorized users of the key.
+ */
+#define fsl_shw_sko_set_user_id(skobject, skuserid)                           \
+       (skobject)->userid = (skuserid)
+
+/*!
+ * Establish a user Keystore to hold the key.
+ */
+#define fsl_shw_sko_set_keystore(skobject, user_keystore)                     \
+       (skobject)->keystore = (user_keystore)
+
+/*!
+ * Set the establish key handle into a key object.
+ *
+ * The @a userid field will be used to validate the access to the unwrapped
+ * key.  This feature is not available for all platforms, nor for all
+ * algorithms and modes.
+ *
+ * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT flag
+ * will be cleared).
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skuserid   The User ID to verify this user is an authorized user of
+ *                   the key.
+ * @param skhandle   A @a handle from #fsl_shw_sko_get_established_info.
+ */
+#define fsl_shw_sko_set_established_info(skobject, skuserid, skhandle)        \
+{                                                                             \
+       (skobject)->userid = (skuserid);                                       \
+       (skobject)->handle = (skhandle);                                       \
+       (skobject)->flags |= FSL_SKO_KEY_ESTABLISHED;                          \
+       (skobject)->flags &=                                                   \
+                       ~(FSL_SKO_KEY_PRESENT);   \
+}
+
+/*!
+ * Retrieve the established-key handle from a key object.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skhandle   The location to store the @a handle of the unwrapped
+ *                   key.
+ */
+#define fsl_shw_sko_get_established_info(skobject, skhandle)                  \
+       *(skhandle) = (skobject)->handle
+
+/*!
+ * Extract the algorithm from a key object.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skalgorithm  A pointer to the location to store the algorithm.
+ */
+#define fsl_shw_sko_get_algorithm(skobject, skalgorithm)                      \
+       *(skalgorithm) = (skobject)->algorithm
+
+/*!
+ * Retrieve the cleartext key from a key object that is stored in a user
+ * keystore.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skkey        A pointer to the location to store the key.  NULL
+ *                          if the key is not stored in a user keystore.
+ */
+#define fsl_shw_sko_get_key(skobject, skkey)                                  \
+{                                                                             \
+    fsl_shw_kso_t* keystore = (skobject)->keystore;                           \
+    if (keystore != NULL) {                                                   \
+        *(skkey) = keystore->slot_get_address(keystore->user_data,            \
+                                              (skobject)->handle);            \
+    } else {                                                                  \
+        *(skkey) = NULL;                                                      \
+    }                                                                         \
+}
+
+/*!
+ * Determine the size of a wrapped key based upon the cleartext key's length.
+ *
+ * This function can be used to calculate the number of octets that
+ * #fsl_shw_extract_key() will write into the location at @a covered_key.
+ *
+ * If zero is returned at @a length, this means that the key length in
+ * @a key_info is not supported.
+ *
+ * @param      wkeyinfo         Information about a key to be wrapped.
+ * @param      wkeylen          Location to store the length of a wrapped
+ *                              version of the key in @a key_info.
+ */
+#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)           \
+{                                                                       \
+    register fsl_shw_sko_t* kp = wkeyinfo;                              \
+    register uint32_t kl = kp->key_length;                              \
+    int key_blocks = (kl + 15) / 16;                                    \
+    int base_size = 35; /* ICV + T' + ALG + LEN + FLAGS */              \
+                                                                        \
+    *(wkeylen) = base_size + 16 * key_blocks;                           \
+}
+
+/*!
+ * Set some flags in the key object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param skobject     A variable of type #fsl_shw_sko_t.
+ * @param skflags      (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                     are to be set.
+ */
+#define fsl_shw_sko_set_flags(skobject, skflags)                              \
+      (skobject)->flags |= (skflags)
+
+/*!
+ * Clear some flags in the key object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param skobject      A variable of type #fsl_shw_sko_t.
+ * @param skflags       (One or more) ORed members of #fsl_shw_key_flags_t
+ *                      which are to be reset.
+ */
+#define fsl_shw_sko_clear_flags(skobject, skflags)                            \
+      (skobject)->flags &= ~(skflags)
+
+/*!
+ * Initialize a Hash Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the hash
+ * context object.
+ *
+ * @param      hcobject    The hash context to operate upon.
+ * @param      hcalgorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                         #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+#define fsl_shw_hco_init(hcobject, hcalgorithm)                               \
+{                                                                             \
+     (hcobject)->algorithm = hcalgorithm;                                     \
+     (hcobject)->flags = 0;                                                   \
+     switch (hcalgorithm) {                                                   \
+     case FSL_HASH_ALG_MD5:                                                   \
+         (hcobject)->digest_length = 16;                                      \
+         (hcobject)->context_length = 16;                                     \
+         (hcobject)->context_register_length = 24;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA1:                                                  \
+         (hcobject)->digest_length = 20;                                      \
+         (hcobject)->context_length = 20;                                     \
+         (hcobject)->context_register_length = 24;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA224:                                                \
+         (hcobject)->digest_length = 28;                                      \
+         (hcobject)->context_length = 32;                                     \
+         (hcobject)->context_register_length = 36;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA256:                                                \
+         (hcobject)->digest_length = 32;                                      \
+         (hcobject)->context_length = 32;                                     \
+         (hcobject)->context_register_length = 36;                            \
+         break;                                                               \
+     default:                                                                 \
+         /* error ! */                                                        \
+         (hcobject)->digest_length = 1;                                       \
+         (hcobject)->context_length = 1;                                      \
+         (hcobject)->context_register_length = 1;                             \
+         break;                                                               \
+     }                                                                        \
+}
+
+/*!
+ * Get the current hash value and message length from the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hcobject   The hash context to query.
+ * @param[out] hccontext  Pointer to the location of @a length octets where to
+ *                        store a copy of the current value of the digest.
+ * @param      hcclength  Number of octets of hash value to copy.
+ * @param[out] hcmsglen   Pointer to the location to store the number of octets
+ *                        already hashed.
+ */
+#define fsl_shw_hco_get_digest(hcobject, hccontext, hcclength, hcmsglen)      \
+{                                                                             \
+     copy_bytes(hccontext, (hcobject)->context, hcclength);                   \
+         if ((hcobject)->algorithm == FSL_HASH_ALG_SHA224                     \
+             || (hcobject)->algorithm == FSL_HASH_ALG_SHA256) {               \
+             *(hcmsglen) = (hcobject)->context[8];                            \
+         } else {                                                             \
+             *(hcmsglen) = (hcobject)->context[5];                            \
+         }                                                                    \
+}
+
+/*!
+ * Get the hash algorithm from the hash context object.
+ *
+ * @param      hcobject    The hash context to query.
+ * @param[out] hcalgorithm Pointer to where the algorithm is to be stored.
+ */
+#define fsl_shw_hco_get_info(hcobject, hcalgorithm)                           \
+{                                                                             \
+     *(hcalgorithm) = (hcobject)->algorithm;                                  \
+}
+
+/*!
+ * Set the current hash value and message length in the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hcobject  The hash context to operate upon.
+ * @param      hccontext Pointer to buffer of appropriate length to copy into
+ *                       the hash context object.
+ * @param      hcmsglen  The number of octets of the message which have
+ *                        already been hashed.
+ *
+ */
+#define fsl_shw_hco_set_digest(hcobject, hccontext, hcmsglen)                 \
+{                                                                             \
+     copy_bytes((hcobject)->context, hccontext, (hcobject)->context_length);  \
+     if (((hcobject)->algorithm == FSL_HASH_ALG_SHA224)                       \
+         || ((hcobject)->algorithm == FSL_HASH_ALG_SHA256)) {                 \
+         (hcobject)->context[8] = hcmsglen;                                   \
+     } else {                                                                 \
+         (hcobject)->context[5] = hcmsglen;                                   \
+     }                                                                        \
+}
+
+/*!
+ * Set flags in a Hash Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The hash context to be operated on.
+ * @param hcflags    The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+#define fsl_shw_hco_set_flags(hcobject, hcflags)                              \
+      (hcobject)->flags |= (hcflags)
+
+/*!
+ * Clear flags in a Hash Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The hash context to be operated on.
+ * @param hcflags    The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+#define fsl_shw_hco_clear_flags(hcobject, hcflags)                            \
+      (hcobject)->flags &= ~(hcflags)
+
+/*!
+ * Initialize an HMAC Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the HMAC
+ * context object.
+ *
+ * @param      hcobject    The HMAC context to operate upon.
+ * @param      hcalgorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                         #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+#define fsl_shw_hmco_init(hcobject, hcalgorithm)                              \
+    fsl_shw_hco_init(hcobject, hcalgorithm)
+
+/*!
+ * Set flags in an HMAC Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The HMAC context to be operated on.
+ * @param hcflags    The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+#define fsl_shw_hmco_set_flags(hcobject, hcflags)                             \
+      (hcobject)->flags |= (hcflags)
+
+/*!
+ * Clear flags in an HMAC Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The HMAC context to be operated on.
+ * @param hcflags    The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+#define fsl_shw_hmco_clear_flags(hcobject, hcflags)                           \
+      (hcobject)->flags &= ~(hcflags)
+
+/*!
+ * Initialize a Symmetric Cipher Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  This will set the @a mode and @a algorithm and initialize the
+ * Object.
+ *
+ * @param scobject  The context object to operate on.
+ * @param scalg     The cipher algorithm this context will be used with.
+ * @param scmode    #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+ *
+ */
+#define fsl_shw_scco_init(scobject, scalg, scmode)                            \
+{                                                                             \
+      register uint32_t bsb;   /* block-size bytes */                         \
+                                                                              \
+      switch (scalg) {                                                        \
+      case FSL_KEY_ALG_AES:                                                   \
+          bsb = 16;                                                           \
+          break;                                                              \
+      case FSL_KEY_ALG_DES:                                                   \
+          /* fall through */                                                  \
+      case FSL_KEY_ALG_TDES:                                                  \
+          bsb = 8;                                                            \
+          break;                                                              \
+      case FSL_KEY_ALG_ARC4:                                                  \
+          bsb = 259;                                                          \
+          break;                                                              \
+      case FSL_KEY_ALG_HMAC:                                                  \
+          bsb = 1;  /* meaningless */                                         \
+          break;                                                              \
+      default:                                                                \
+          bsb = 00;                                                           \
+      }                                                                       \
+      (scobject)->block_size_bytes = bsb;                                     \
+      (scobject)->mode = scmode;                                              \
+      (scobject)->flags = 0;                                                  \
+}
+
+/*!
+ * Set the flags for a Symmetric Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param scobject The context object to operate on.
+ * @param scflags  The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_scco_set_flags(scobject, scflags)                             \
+       (scobject)->flags |= (scflags)
+
+/*!
+ * Clear some flags in a Symmetric Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param scobject The context object to operate on.
+ * @param scflags  The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_scco_clear_flags(scobject, scflags)                           \
+       (scobject)->flags &= ~(scflags)
+
+/*!
+ * Set the Context (IV) for a Symmetric Cipher Context.
+ *
+ * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+ * context (the S-Box and pointers) for ARC4.  The full context size will
+ * be copied.
+ *
+ * @param scobject  The context object to operate on.
+ * @param sccontext A pointer to the buffer which contains the context.
+ *
+ */
+#define fsl_shw_scco_set_context(scobject, sccontext)                         \
+       copy_bytes((scobject)->context, sccontext,                             \
+                  (scobject)->block_size_bytes)
+
+/*!
+ * Get the Context for a Symmetric Cipher Context.
+ *
+ * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+ * retrieve context (the S-Box and pointers) for ARC4.  The full context
+ * will be copied.
+ *
+ * @param      scobject  The context object to operate on.
+ * @param[out] sccontext Pointer to location where context will be stored.
+ */
+#define fsl_shw_scco_get_context(scobject, sccontext)                         \
+       copy_bytes(sccontext, (scobject)->context, (scobject)->block_size_bytes)
+
+/*!
+ * Set the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will set the Counter Value for CTR mode.
+ *
+ * @param scobject  The context object to operate on.
+ * @param sccounter The starting counter value.  The number of octets.
+ *                  copied will be the block size for the algorithm.
+ * @param scmodulus The modulus for controlling the incrementing of the
+ *                  counter.
+ *
+ */
+#define fsl_shw_scco_set_counter_info(scobject, sccounter, scmodulus)        \
+       {                                                                     \
+           if ((sccounter) != NULL) {                                        \
+               copy_bytes((scobject)->context, sccounter,                    \
+                          (scobject)->block_size_bytes);                     \
+           }                                                                 \
+           (scobject)->modulus_exp = scmodulus;                              \
+       }
+
+/*!
+ * Get the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will retrieve the Counter Value is for CTR mode.
+ *
+ * @param     scobject    The context object to query.
+ * @param[out] sccounter  Pointer to location to store the current counter
+ *                        value.  The number of octets copied will be the
+ *                        block size for the algorithm.
+ * @param[out] scmodulus  Pointer to location to store the modulus.
+ *
+ */
+#define fsl_shw_scco_get_counter_info(scobject, sccounter, scmodulus)        \
+       {                                                                     \
+           if ((sccounter) != NULL) {                                        \
+               copy_bytes(sccounter, (scobject)->context,                    \
+                          (scobject)->block_size_bytes);                     \
+           }                                                                 \
+           if ((scmodulus) != NULL) {                                        \
+               *(scmodulus) = (scobject)->modulus_exp;                       \
+           }                                                                 \
+       }
+
+/*!
+ * Initialize a Authentication-Cipher Context.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acmode    The mode for this object (only #FSL_ACC_MODE_CCM
+ *                  supported).
+ */
+#define fsl_shw_acco_init(acobject, acmode)                                   \
+   {                                                                          \
+       (acobject)->flags = 0;                                                 \
+       (acobject)->mode = (acmode);                                           \
+   }
+
+/*!
+ * Set the flags for a Authentication-Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acflags   The flags to set (one or more from
+ *                  #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_acco_set_flags(acobject, acflags)                             \
+       (acobject)->flags |= (acflags)
+
+/*!
+ * Clear some flags in a Authentication-Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acflags   The flags to reset (one or more from
+ *                  #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_acco_clear_flags(acobject, acflags)                           \
+       (acobject)->flags &= ~(acflags)
+
+/*!
+ * Set up the Authentication-Cipher Object for CCM mode.
+ *
+ * This will set the @a auth_object for CCM mode and save the @a ctr,
+ * and @a mac_length.  This function can be called instead of
+ * #fsl_shw_acco_init().
+ *
+ * The paramater @a ctr is Counter Block 0, (counter value 0), which is for the
+ * MAC.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acalg     Cipher algorithm.  Only AES is supported.
+ * @param accounter The initial counter value.
+ * @param acmaclen  The number of octets used for the MAC.  Valid values are
+ *                  4, 6, 8, 10, 12, 14, and 16.
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_acco_set_ccm(acobject, acalg, accounter, acmaclen)            \
+{                                                                             \
+      (acobject)->flags = 0;                                                  \
+      (acobject)->mode = FSL_ACC_MODE_CCM;                                    \
+      (acobject)->auth_info.CCM_ctx_info.block_size_bytes = 16;               \
+      (acobject)->cipher_ctx_info.block_size_bytes = 16;                      \
+      (acobject)->mac_length = acmaclen;                                      \
+      fsl_shw_scco_set_counter_info(&(acobject)->cipher_ctx_info, accounter,  \
+            FSL_CTR_MOD_128);                                                 \
+}
+
+/*!
+ * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will also set the IV and CTR values per Appendix A of NIST
+ * Special Publication 800-38C (May 2004).  It will also perform the
+ * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+ * parameters.
+ *
+ * Note this function assumes the algorithm is AES.  It initializes the
+ * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+ * flags to be #FSL_ACCO_NIST_CCM.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param act       The number of octets used for the MAC.  Valid values are
+ *                  4, 6, 8, 10, 12, 14, and 16.
+ * @param acad      Number of octets of Associated Data (may be zero).
+ * @param acq       A value for the size of the length of @a q field.  Valid
+ *                  values are 1-8.
+ * @param acN       The Nonce (packet number or other changing value). Must
+ *                  be (15 - @a q_length) octets long.
+ * @param acQ       The value of Q (size of the payload in octets).
+ *
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_ccm_nist_format_ctr_and_iv(acobject, act, acad, acq, acN, acQ)\
+    {                                                                         \
+        uint64_t Q = acQ;                                                     \
+        uint8_t bflag = ((acad)?0x40:0) | ((((act)-2)/2)<<3) | ((acq)-1);     \
+        unsigned i;                                                           \
+        uint8_t* qptr = (acobject)->auth_info.CCM_ctx_info.context + 15;      \
+        (acobject)->auth_info.CCM_ctx_info.block_size_bytes = 16;             \
+        (acobject)->cipher_ctx_info.block_size_bytes = 16;                    \
+        (acobject)->mode = FSL_ACC_MODE_CCM;                                  \
+        (acobject)->flags  = FSL_ACCO_NIST_CCM;                               \
+                                                                              \
+        /* Store away the MAC length (after calculating actual value */       \
+        (acobject)->mac_length = (act);                                       \
+        /* Set Flag field in Block 0 */                                       \
+        *((acobject)->auth_info.CCM_ctx_info.context) = bflag;                \
+        /* Set Nonce field in Block 0 */                                      \
+        copy_bytes((acobject)->auth_info.CCM_ctx_info.context+1, acN,         \
+                   15-(acq));                                                 \
+        /* Set Flag field in ctr */                                           \
+        *((acobject)->cipher_ctx_info.context) = (acq)-1;                     \
+        /* Update the Q (payload length) field of Block0 */                   \
+        (acobject)->q_length = acq;                                           \
+        for (i = 0; i < (acq); i++) {                                         \
+            *qptr-- = Q & 0xFF;                                               \
+            Q >>= 8;                                                          \
+        }                                                                     \
+        /* Set the Nonce field of the ctr */                                  \
+        copy_bytes((acobject)->cipher_ctx_info.context+1, acN, 15-(acq));     \
+        /* Clear the block counter field of the ctr */                        \
+        memset((acobject)->cipher_ctx_info.context+16-(acq), 0, (acq)+1);     \
+     }
+
+/*!
+ * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will set the IV and CTR values per Appendix A of NIST Special
+ * Publication 800-38C (May 2004).
+ *
+ * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+ * previously been called on the @a auth_object.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acN       The Nonce (packet number or other changing value). Must
+ *                  be (15 - @a q_length) octets long.
+ * @param acQ       The value of Q (size of the payload in octets).
+ *
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_ccm_nist_update_ctr_and_iv(acobject, acN, acQ)                \
+     {                                                                        \
+        uint64_t Q = acQ;                                                     \
+        unsigned i;                                                           \
+        uint8_t* qptr = (acobject)->auth_info.CCM_ctx_info.context + 15;      \
+                                                                              \
+        /* Update the Nonce field field of Block0 */                          \
+        copy_bytes((acobject)->auth_info.CCM_ctx_info.context+1, acN,         \
+               15 - (acobject)->q_length);                                    \
+        /* Update the Q (payload length) field of Block0 */                   \
+        for (i = 0; i < (acobject)->q_length; i++) {                          \
+            *qptr-- = Q & 0xFF;                                               \
+            Q >>= 8;                                                          \
+        }                                                                     \
+        /* Update the Nonce field of the ctr */                               \
+        copy_bytes((acobject)->cipher_ctx_info.context+1, acN,                \
+               15 - (acobject)->q_length);                                    \
+     }
+
+/******************************************************************************
+ * Library functions
+ *****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+					    unsigned result_size,
+					    fsl_shw_result_t results[],
+					    unsigned *result_count);
+
+extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+					      fsl_shw_sko_t * key_info,
+					      fsl_shw_key_wrap_t establish_type,
+					      const uint8_t * key);
+
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info,
+					    uint8_t * covered_key);
+
+extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info);
+
+extern void *fsl_shw_smalloc(fsl_shw_uco_t * user_ctx,
+			     uint32_t size,
+			     const uint8_t * UMID, uint32_t permissions);
+
+extern fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t * user_ctx, void *address);
+
+extern fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t * user_ctx,
+					void *address,
+					fsl_shw_partition_status_t * status);
+
+extern fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t * user_ctx,
+					       void *address,
+					       uint32_t permissions);
+
+extern fsl_shw_return_t do_scc_engage_partition(fsl_shw_uco_t * user_ctx,
+						void *address,
+						const uint8_t * UMID,
+						uint32_t permissions);
+
+extern fsl_shw_return_t do_system_keystore_slot_alloc(fsl_shw_uco_t * user_ctx,
+						      uint32_t key_lenth,
+						      uint64_t ownerid,
+						      uint32_t * slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_dealloc(fsl_shw_uco_t *
+							user_ctx,
+							uint64_t ownerid,
+							uint32_t slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t * user_ctx,
+						     uint64_t ownerid,
+						     uint32_t slot,
+						     const uint8_t * key,
+						     uint32_t key_length);
+
+extern fsl_shw_return_t do_system_keystore_slot_read(fsl_shw_uco_t * user_ctx,
+						     uint64_t ownerid,
+						     uint32_t slot,
+						     uint32_t key_length,
+						     const uint8_t * key);
+
+extern fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t *
+							user_ctx,
+							uint64_t ownerid,
+							uint32_t slot,
+							uint32_t key_length,
+							uint8_t * black_data);
+
+extern fsl_shw_return_t do_system_keystore_slot_decrypt(fsl_shw_uco_t *
+							user_ctx,
+							uint64_t ownerid,
+							uint32_t slot,
+							uint32_t key_length,
+							const uint8_t *
+							black_data);
+
+extern fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+extern fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, const uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+extern fsl_shw_return_t
+system_keystore_get_slot_info(uint64_t owner_id, uint32_t slot,
+			      uint32_t * address, uint32_t * slot_size_bytes);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * pt,
+						  uint8_t * ct);
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * ct,
+						  uint8_t * pt);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_hco_t * hash_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						fsl_shw_hmco_t * hmac_ctx);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     fsl_shw_hmco_t * hmac_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+					   uint32_t length, uint8_t * data);
+
+extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+					    uint32_t length, uint8_t * data);
+
+extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_acco_t * auth_ctx,
+					    fsl_shw_sko_t * cipher_key_info,
+					    fsl_shw_sko_t * auth_key_info,
+					    uint32_t auth_data_length,
+					    const uint8_t * auth_data,
+					    uint32_t payload_length,
+					    const uint8_t * payload,
+					    uint8_t * ct, uint8_t * auth_value);
+
+extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+					     fsl_shw_acco_t * auth_ctx,
+					     fsl_shw_sko_t * cipher_key_info,
+					     fsl_shw_sko_t * auth_key_info,
+					     uint32_t auth_data_length,
+					     const uint8_t * auth_data,
+					     uint32_t payload_length,
+					     const uint8_t * ct,
+					     const uint8_t * auth_value,
+					     uint8_t * payload);
+
+extern fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						uint8_t * key);
+
+static inline fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t *
+							 user_ctx)
+{
+	(void)user_ctx;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+static inline fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t *
+							 user_ctx,
+							 fsl_shw_tamper_t *
+							 tamperp,
+							 uint64_t * timestampp)
+{
+	(void)user_ctx;
+	(void)tamperp;
+	(void)timestampp;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t sah_Append_Desc(const sah_Mem_Util * mu,
+				 sah_Head_Desc ** desc_head,
+				 const uint32_t header,
+				 sah_Link * link1, sah_Link * link2);
+
+/* Utility Function leftover from sahara1 API */
+void sah_Descriptor_Chain_Destroy(const sah_Mem_Util * mu,
+				  sah_Head_Desc ** desc_chain);
+
+/* Utility Function leftover from sahara1 API */
+fsl_shw_return_t sah_Descriptor_Chain_Execute(sah_Head_Desc * desc_chain,
+					      fsl_shw_uco_t * user_ctx);
+
+fsl_shw_return_t sah_Append_Link(const sah_Mem_Util * mu,
+				 sah_Link * link,
+				 uint8_t * p,
+				 const size_t length,
+				 const sah_Link_Flags flags);
+
+fsl_shw_return_t sah_Create_Link(const sah_Mem_Util * mu,
+				 sah_Link ** link,
+				 uint8_t * p,
+				 const size_t length,
+				 const sah_Link_Flags flags);
+
+fsl_shw_return_t sah_Create_Key_Link(const sah_Mem_Util * mu,
+				     sah_Link ** link,
+				     fsl_shw_sko_t * key_info);
+
+void sah_Destroy_Link(const sah_Mem_Util * mu, sah_Link * link);
+
+void sah_Postprocess_Results(fsl_shw_uco_t * user_ctx,
+			     sah_results * result_info);
+
+#endif				/* SAHARA2_API_H */
diff --git a/include/linux/mxc_scc2_driver.h b/include/linux/mxc_scc2_driver.h
new file mode 100644
index 0000000..fc8f055
--- /dev/null
+++ b/include/linux/mxc_scc2_driver.h
@@ -0,0 +1,975 @@
+
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef SCC_DRIVER_H
+#define SCC_DRIVER_H
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*! @file mxc_scc2_driver.h
+ *
+ * @brief (Header file to use the SCC2 driver.)
+ *
+ * The SCC2 driver is available to other kernel modules directly.  Secure
+ * Partition functionality is extended to users through the SHW API.  Other
+ * functionality of the SCC2 is limited to kernel-space users.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work with secure partitions: #scc_allocate_partition()
+ *     #scc_engage_partition() #scc_diminish_permissions()
+ *     #scc_release_partition()
+ * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
+ *     #scc_decrypt_region()
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The SCC2 encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC2 is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC2 driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/** @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/** @addtogroup scccompileflags */
+
+/** @{ */
+/**
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/** @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION    2
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0    0
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_2    2
+
+
+/*!
+ *  Interrupt line number of SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  Interrupt line number of the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+/**
+ * @typedef scc_return_t
+ */
+/** Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	 /**< Function succeeded  */
+		SCC_RET_FAIL,	 /**< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,
+				 /**< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,
+				 /**< At maximum registered functions */
+		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
+		/**< Encryption or decryption failed because@c count_out_bytes
+			says that @c data_out is too small to hold the value. */
+		SCC_RET_INSUFFICIENT_SPACE,
+	} scc_return_t;
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+	typedef enum scc_partition_status_t {
+		SCC_PART_S_UNUSABLE,
+				  /**< Partition not implemented */
+		SCC_PART_S_UNAVAILABLE,
+				  /**< Partition owned by other host */
+		SCC_PART_S_AVAILABLE,
+				  /**< Partition available */
+		SCC_PART_S_ALLOCATED,
+				  /**< Partition owned by host but not engaged*/
+		SCC_PART_S_ENGAGED,
+				  /**< Partition owned by host and engaged */
+	} scc_partition_status_t;
+
+/**
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;
+				/**< Major version of the SCC driver code  */
+		int driver_minor_version;
+				/**< Minor version of the SCC driver code  */
+		int scm_version; /**< Version from SCM Configuration register */
+		int smn_version; /**< Version from SMN Status register */
+		/**< Number of bytes per block of RAM; also
+			block size of the crypto algorithm. */
+		int block_size_bytes;
+		int partition_size_bytes;
+				/**< Number of bytes in each partition */
+		int partition_count;
+				/**< Number of partitions on this platform */
+	} scc_config_t;
+
+/**
+ * @typedef scc_enc_dec_t
+ */
+/**
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/**
+ * @typedef scc_verify_t
+ */
+/**
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+    /** No verification value added or checked.  Input plaintext data must be
+     *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
+		will be padded to a multiple of the blocksize, adding 3-10 bytes
+		to the resulting output ciphertext.  Upon decryption, this padding
+		will be stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/**
+ * @typedef scc_cypher_mode_t
+ */
+/**
+ * Select the cypher mode to use for partition cover/uncover operations.
+ */
+
+	typedef enum scc_cypher_mode_t {
+		SCC_CYPHER_MODE_ECB = 1,
+				   /**< ECB mode */
+		SCC_CYPHER_MODE_CBC = 2,
+				   /**< CBC mode */
+	} scc_cypher_mode_t;
+
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode ownership.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return      SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_allocate_partition(uint32_t smid_value,
+				   int *part_no,
+				   void **part_base, uint32_t *part_phys);
+
+/* Note: This function has to be run in the same context (userspace or kernel
+ * mode) as the process that will be using the partition.  Because the SCC2 API
+ * is not accessible in user mode, this function is also provided as a macro in
+ * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
+ * version of the function without having to include the whole SHW API.  If the
+ * macro definition was defined before we got here, un-define it so this
+ * version will be used instead.
+ */
+
+#ifdef scc_engage_partition
+#undef scc_engage_partition
+#endif
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_engage_partition(void *part_base,
+				 const uint8_t *UMID, uint32_t permissions);
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t scc_release_partition(void *part_base);
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_diminish_permissions(void *part_base, uint32_t permissions);
+
+/**
+ * Query the status of a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_partition_status_t scc_partition_status(void *part_base);
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ */
+	extern uint32_t scc_virt_to_phys(void *address);
+/*scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
+
+
+/**
+ * Encrypt a region of secure memory.
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Decrypt a region into secure memory
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/**
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/**
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/**
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/**
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/**
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried.  See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t *value);
+
+/**
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified.  See
+ *                              @ref scmregs and @ref smnregs
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/**
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup scmregs */
+/** @{ */
+/** Offset of SCM Version ID Register */
+#define SCM_VERSION_REG		0x000
+/** Offset of SCM Interrupt Control Register */
+#define SCM_INT_CTL_REG		0x008
+/** Offset of SCM Status Register */
+#define SCM_STATUS_REG		0x00c
+/** Offset of SCM Error Status Register */
+#define SCM_ERR_STATUS_REG	0x010
+/** Offset of SCM Fault Address Register */
+#define SCM_FAULT_ADR_REG	0x014
+/** Offset of SCM Partition Owners Register */
+#define SCM_PART_OWNERS_REG	0x018
+/** Offset of SCM Partitions Engaged Register */
+#define SCM_PART_ENGAGED_REG	0x01c
+/** Offset of SCM Unique Number 0 Register */
+#define SCM_UNIQUE_ID0_REG	0x020
+/** Offset of SCM Unique Number 1 Register */
+#define SCM_UNIQUE_ID1_REG	0x024
+/** Offset of SCM Unique Number 2 Register */
+#define SCM_UNIQUE_ID2_REG	0x028
+/** Offset of SCM Unique Number 3 Register */
+#define SCM_UNIQUE_ID3_REG	0x02c
+/** Offset of SCM Zeroize Command Register */
+#define SCM_ZCMD_REG		0x050
+/** Offset of SCM Cipher Command Register */
+#define SCM_CCMD_REG		0x054
+/** Offset of SCM Cipher Black RAM Start Address Register */
+#define SCM_C_BLACK_ST_REG	0x058
+/** Offset of SCM Internal Debug Register */
+#define SCM_DBG_STATUS_REG	0x05c
+/** Offset of SCM Cipher IV 0 Register */
+#define SCM_AES_CBC_IV0_REG	0x060
+/** Offset of SCM Cipher IV 1 Register */
+#define SCM_AES_CBC_IV1_REG	0x064
+/** Offset of SCM Cipher IV 2 Register */
+#define SCM_AES_CBC_IV2_REG	0x068
+/** Offset of SCM Cipher IV 3 Register */
+#define SCM_AES_CBC_IV3_REG	0x06c
+/** Offset of SCM SMID Partition 0 Register */
+#define SCM_SMID0_REG		0x080
+/** Offset of SCM Partition 0 Access Permissions Register */
+#define SCM_ACC0_REG		0x084
+/** Offset of SCM SMID Partition 1 Register */
+#define SCM_SMID1_REG		0x088
+/** Offset of SCM Partition 1 Access Permissions Register */
+#define SCM_ACC1_REG		0x08c
+/** Offset of SCM SMID Partition 2 Register */
+#define SCM_SMID2_REG		0x090
+/** Offset of SCM Partition 2 Access Permissions Register */
+#define SCM_ACC2_REG		0x094
+/** Offset of SCM SMID Partition 3 Register */
+#define SCM_SMID3_REG		0x098
+/** Offset of SCM Partition 3 Access Permissions Register */
+#define SCM_ACC3_REG		0x09c
+/** Offset of SCM SMID Partition 4 Register */
+#define SCM_SMID4_REG		0x0a0
+/** Offset of SCM Partition 4 Access Permissions Register */
+#define SCM_ACC4_REG		0x0a4
+/** Offset of SCM SMID Partition 5 Register */
+#define SCM_SMID5_REG		0x0a8
+/** Offset of SCM Partition 5 Access Permissions Register */
+#define SCM_ACC5_REG		0x0ac
+/** Offset of SCM SMID Partition 6 Register */
+#define SCM_SMID6_REG		0x0b0
+/** Offset of SCM Partition 6 Access Permissions Register */
+#define SCM_ACC6_REG		0x0b4
+/** Offset of SCM SMID Partition 7 Register */
+#define SCM_SMID7_REG		0x0b8
+/** Offset of SCM Partition 7 Access Permissions Register */
+#define SCM_ACC7_REG		0x0bc
+/** Offset of SCM SMID Partition 8 Register */
+#define SCM_SMID8_REG		0x0c0
+/** Offset of SCM Partition 8 Access Permissions Register */
+#define SCM_ACC8_REG		0x0c4
+/** Offset of SCM SMID Partition 9 Register */
+#define SCM_SMID9_REG		0x0c8
+/** Offset of SCM Partition 9 Access Permissions Register */
+#define SCM_ACC9_REG		0x0cc
+/** Offset of SCM SMID Partition 10 Register */
+#define SCM_SMID10_REG		0x0d0
+/** Offset of SCM Partition 10 Access Permissions Register */
+#define SCM_ACC10_REG		0x0d4
+/** Offset of SCM SMID Partition 11 Register */
+#define SCM_SMID11_REG		0x0d8
+/** Offset of SCM Partition 11 Access Permissions Register */
+#define SCM_ACC11_REG		0x0dc
+/** Offset of SCM SMID Partition 12 Register */
+#define SCM_SMID12_REG		0x0e0
+/** Offset of SCM Partition 12 Access Permissions Register */
+#define SCM_ACC12_REG		0x0e4
+/** Offset of SCM SMID Partition 13 Register */
+#define SCM_SMID13_REG		0x0e8
+/** Offset of SCM Partition 13 Access Permissions Register */
+#define SCM_ACC13_REG		0x0ec
+/** Offset of SCM SMID Partition 14 Register */
+#define SCM_SMID14_REG		0x0f0
+/** Offset of SCM Partition 14 Access Permissions Register */
+#define SCM_ACC14_REG		0x0f4
+/** Offset of SCM SMID Partition 15 Register */
+#define SCM_SMID15_REG		0x0f8
+/** Offset of SCM Partition 15 Access Permissions Register */
+#define SCM_ACC15_REG		0x0fc
+/** @} */
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Offset of the SMN registers */
+#define SMN_ADDR_OFFSET		0x100
+
+/**
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup smnregs */
+/** @{ */
+/** Offset of SMN Status Register */
+#define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
+/** Offset of SMH Command Register */
+#define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
+/** Offset of SMH Sequence Start Register */
+#define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
+/** Offset of SMH Sequence End Register */
+#define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
+/** Offset of SMH Sequence Check Register */
+#define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
+/** Offset of SMH BitBank Count Register */
+#define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
+/** Offset of SMH BitBank Increment Register */
+#define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
+/** Offset of SMH BitBank Decrement Register */
+#define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
+/** Offset of SMH Compare Register */
+#define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
+/** Offset of SMH Plaintext Check Register */
+#define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
+/** Offset of SMH Ciphertext Check Register */
+#define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
+/** Offset of SMH Timer Initial Value Register */
+#define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
+/** Offset of SMH Timer Control Register */
+#define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
+/** Offset of SMH Security Violation Register */
+#define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
+/** Offset of SMH Timer Register */
+#define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
+/** Offset of SMH High-Assurance Control Register */
+#define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
+/** Number of bytes allocated to the SMN registers */
+#define SMN_REG_BANK_SIZE	0x40
+/** @} */
+
+/** Number of bytes of total register space for the SCC. */
+#define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
+
+/**
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/** @addtogroup smnstatusregdefs */
+/** @{ */
+/** SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       28
+/** Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/** Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/** Some security peripheral is initializing */
+#define SMN_STATUS_PERIP_INIT             0x00010000
+/** Internal error detected in SMN. */
+#define SMN_STATUS_SMN_ERROR              0x00004000
+/** SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/** Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/** Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/** Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/** Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/** Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/** Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/** Security Violation Active error. */
+#define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
+/** Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/** SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/** @} */
+
+/**
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/** @addtogroup sccscmstates */
+/** @{ */
+/** This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/** The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/** SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/** SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/** Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/** @} */
+
+/** @{ */
+/** SCM Status bit: Key Status is Default Key in Use */
+#define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
+/** SCM Status bit: Key Status is (reserved) */
+#define SCM_STATUS_KST_RESERVED1	0x40000000
+/** SCM Status bit: Key status is Wrong Key */
+#define SCM_STATUS_KST_WRONG_KEY	0x20000000
+/** SCM Status bit: Bad Key detected */
+#define SCM_STATUS_KST_BAD_KEY	0x10000000
+/** SCM Status bit: Error has occurred */
+#define SCM_STATUS_ERR		0x00008000
+/** SCM Status bit: Monitor State is Failed */
+#define SCM_STATUS_MSS_FAIL	0x00004000
+/** SCM Status bit: Monitor State is Secure */
+#define SCM_STATUS_MSS_SEC	0x00002000
+/** SCM Status bit: Secure Storage is Failed */
+#define SCM_STATUS_RSS_FAIL	0x00000400
+/** SCM Status bit: Secure Storage is Secure */
+#define SCM_STATUS_RSS_SEC	0x00000200
+/** SCM Status bit: Secure Storage is Initializing */
+#define SCM_STATUS_RSS_INIT	0x00000100
+/** SCM Status bit: Unique Number Valid */
+#define SCM_STATUS_UNV		0x00000080
+/** SCM Status bit: Big Endian mode */
+#define SCM_STATUS_BIG		0x00000040
+/** SCM Status bit: Using Secret Key */
+#define SCM_STATUS_USK		0x00000020
+/** SCM Status bit: Ram is being blocked */
+#define SCM_STATUS_BAR		0x00000010
+/** Bit mask of SRS */
+#define SCM_STATUS_SRS_MASK	0x0000000F
+/** Number of bits to shift SRS to/from MSb */
+#define SCM_STATUS_SRS_SHIFT	0
+/** @} */
+
+#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
+#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
+#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
+#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
+#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
+#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
+#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
+#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
+#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
+#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
+#define SCM_STATUS_SRS_FAIL	    0xF	/**< Fail State */
+
+
+/* Format of the SCM VERSION ID REGISTER */
+#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
+#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
+#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
+#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
+#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
+#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
+#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
+#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
+#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
+#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
+
+/**< SCC Hardware version supported by this driver */
+#define SCM_MAJOR_VERSION_2 2
+
+/* Format of the SCM ERROR STATUS REGISTER */
+#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
+#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
+#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
+#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
+#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
+#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
+#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
+#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
+#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
+#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
+
+/* SCM ERROR STATUS REGISTER ERROR CODES */
+#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
+#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
+#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
+#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
+#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
+#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
+#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
+#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
+#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
+#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
+#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
+#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
+#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
+
+/* Format of the CIPHER COMMAND REGISTER */
+#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
+#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
+#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
+#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
+#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
+#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
+#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
+#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
+
+/* Values for SCM_CCMD_CCMD field */
+#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
+#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
+
+#define SCM_CCMD_AES     1     /**< Use AES Mode */
+#define SCM_CCMD_DEC     0     /**< Decrypt */
+#define SCM_CCMD_ENC     2     /**< Encrypt */
+#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
+#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
+
+/* Format of the ZEROIZE COMMAND REGISTER */
+#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
+#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
+#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
+#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
+
+/* MASTER ACCESS PERMISSIONS REGISTER */
+/* Note that API users should use the FSL_PERM_ defines instead of these */
+/** SCM Access Permission: Do not zeroize/deallocate partition
+	on SMN Fail state */
+#define SCM_PERM_NO_ZEROIZE	0x10000000
+/** SCM Access Permission: Ignore Supervisor/User mode
+	in permission determination */
+#define SCM_PERM_HD_SUP_DISABLE	0x00000800
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+#define SCM_PERM_HD_READ	0x00000400
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+#define SCM_PERM_HD_WRITE	0x00000200
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+#define SCM_PERM_HD_EXECUTE	0x00000100
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+#define SCM_PERM_TH_READ	0x00000040
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+#define SCM_PERM_TH_WRITE	0x00000020
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+#define SCM_PERM_OT_READ	0x00000004
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+#define SCM_PERM_OT_WRITE	0x00000002
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+#define SCM_PERM_OT_EXECUTE	0x00000001
+/**< Valid bits that can be set in the Permissions register */
+#define SCM_PERM_MASK 0xC0000F67
+
+/* Zeroize Command register definitions */
+#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
+#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
+
+/**
+ * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
+ */
+/** @addtogroup scmpartitionownersregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_POWN_SHIFT   2
+/** Mask for a field once the register has been shifted. */
+#define SCM_POWN_MASK    3
+/** Partition is free */
+#define SCM_POWN_PART_FREE       0
+/** Partition is unable to be allocated */
+#define SCM_POWN_PART_UNUSABLE   1
+/** Partition is owned by another master */
+#define SCM_POWN_PART_OTHER      2
+/** Partition is owned by this master */
+#define SCM_POWN_PART_OWNED      3
+/** @} */
+
+/**
+ * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
+ */
+/** @addtogroup smnpartitionsengagedregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_PENG_SHIFT   1
+/** Engaged value for a field once the register has been shifted. */
+#define SCM_PENG_ENGAGED    1
+/** @} */
+
+/** Number of bytes between each subsequent SMID register */
+#define SCM_SMID_WIDTH      8
+
+/**
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
+ */
+/** @addtogroup smncommandregdefs */
+/** @{ */
+
+/** These bits are unimplemented or reserved */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
+/** @} */
+
+/**
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/** @addtogroup smntimercontroldefs */
+/** @{ */
+/** These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/** Load the timer from #SMN_TIMER_IV_REG */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/** Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/** Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/** @} */
+
+/**
+ * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmchainmodedefs */
+/** @{ */
+#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
+#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
+/** @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/**
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmciphermodedefs */
+/** @{ */
+#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
+/** @} */
+
+/**
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ */
+/** @addtogroup smndbgdetdefs */
+/** @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
+/** @} */
+
+/** Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQ_START_REG) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQ_END_REG) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/** Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQ_CHECK_REG) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Bit Counter Register
+    (#SMN_BB_CNT_REG) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BB_INC_REG) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BB_DEC_REG) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/** Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_REG) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/*! @} */
+
+#endif				/* SCC_DRIVER_H */
-- 
1.7.9.7

