From 59b6af9180624ca13b6cc950b56621042af421cd Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 28 Aug 2009 16:36:16 +0800
Subject: [PATCH 12/38] usb/otg: fix the dependancy between otg and host, client driver

For OTG to function properly we need the OTG probe to complete before
hcd and gadget do their probes. We create and register the host and
client platform device in the otg probe function to make sure of this
order. Also module_get in host and client driver, so we can't remove
the otg module while host or client driver is in using.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/sysdev/fsl_soc.c     |   12 -----
 drivers/usb/gadget/fsl_usb2_udc.c |   13 ++++--
 drivers/usb/host/ehci-fsl.c       |    3 +
 drivers/usb/otg/fsl_otg.c         |   88 +++++++++++++++++++++++++++++++++++++
 drivers/usb/otg/fsl_otg.h         |    2 +
 include/linux/usb/otg.h           |    2 +
 6 files changed, 104 insertions(+), 16 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 9aeb692..0e7ce13 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -569,18 +569,6 @@ static int __init fsl_usb_of_init(void)
 				ret = PTR_ERR(usb_dev_dr_otg);
 				goto unreg_dr;
 			}
-			usb_dev_dr_host = platform_device_register_simple(
-					"fsl-ehci", i, r, 2);
-			if (IS_ERR(usb_dev_dr_host)) {
-				ret = PTR_ERR(usb_dev_dr_host);
-				goto err;
-			}
-			usb_dev_dr_client = platform_device_register_simple(
-					"fsl-usb2-udc", i, r, 2);
-			if (IS_ERR(usb_dev_dr_client)) {
-				ret = PTR_ERR(usb_dev_dr_client);
-				goto err;
-			}
 		} else {
 			ret = -EINVAL;
 			goto err;
diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 3b18888..bbf20e0 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -2201,7 +2201,7 @@ static void fsl_udc_release(struct device *dev)
  * init resource for globle controller
  * Return the udc handle on success or NULL on failure
  ------------------------------------------------------------------*/
-static int __init struct_udc_setup(struct fsl_udc *udc,
+static int struct_udc_setup(struct fsl_udc *udc,
 		struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata;
@@ -2257,7 +2257,7 @@ static int __init struct_udc_setup(struct fsl_udc *udc,
  * ep0out is not used so do nothing here
  * ep0in should be taken care
  *--------------------------------------------------------------*/
-static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
+static int struct_ep_setup(struct fsl_udc *udc, unsigned char index,
 		char *name, int link)
 {
 	struct fsl_ep *ep = &udc->eps[index];
@@ -2290,7 +2290,7 @@ static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
  * all intialization operations implemented here except enabling usb_intr reg
  * board setup should have been done in the platform code
  */
-static int __init fsl_udc_probe(struct platform_device *pdev)
+static int fsl_udc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	int ret = -ENODEV;
@@ -2322,6 +2322,9 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		DBG("resource not registered!\n");
 		return -ENODEV;
 	}
+
+	try_module_get(udc_controller->transceiver->owner);
+
 #else
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2480,6 +2483,7 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	iounmap(dr_regs);
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
 	cancel_work_sync(&udc_controller->resume_work);
+	module_put(udc_controller->transceiver->owner);
 	res = otg_get_resources();
 #else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2549,6 +2553,7 @@ static int fsl_udc_resume(struct device *dev)
 --------------------------------------------------------------------------*/
 
 static struct platform_driver udc_driver = {
+	.probe = fsl_udc_probe,
 	.remove  = __exit_p(fsl_udc_remove),
 	/* these suspend and resume are not usb suspend and resume */
 	.driver  = {
@@ -2562,7 +2567,7 @@ static struct platform_driver udc_driver = {
 static int __init udc_init(void)
 {
 	printk(KERN_INFO "%s (%s)\n", driver_desc, DRIVER_VERSION);
-	return platform_driver_probe(&udc_driver, fsl_udc_probe);
+	return platform_driver_register(&udc_driver);
 }
 
 module_init(udc_init);
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index f474915..d2dcd95 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -243,6 +243,8 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		goto err4;
 	}
 
+	try_module_get(ehci->transceiver->owner);
+
 #else
 	/* Set to Host mode */
 	temp = in_le32(hcd->regs + 0x1a8);
@@ -428,6 +430,7 @@ static int ehci_fsl_drv_remove(struct platform_device *pdev)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 	cancel_work_sync(&ehci->change_hcd_work);
+	module_put(ehci->transceiver->owner);
 	kfree(usb_ehci_regs);
 #endif
 	/* FIXME we only want one one remove() not two */
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
index 94f0c24..03c8bb7 100644
--- a/drivers/usb/otg/fsl_otg.c
+++ b/drivers/usb/otg/fsl_otg.c
@@ -43,6 +43,7 @@
 #include <linux/workqueue.h>
 #include <linux/time.h>
 #include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -716,6 +717,7 @@ int fsl_otg_config(void)
 	fsl_otg_tc->otg.start_hnp = fsl_otg_start_hnp;
 	fsl_otg_tc->otg.start_srp = fsl_otg_start_srp;
 	otg_set_transceiver(&fsl_otg_tc->otg);
+	fsl_otg_tc->otg.owner = THIS_MODULE;
 	/* Create work queue used by gadget and host suspend/resume */
 	fsl_otg_tc->otg.otg_wq = create_singlethread_workqueue("usb-otg");
 	if (!fsl_otg_tc->otg.otg_wq) {
@@ -727,6 +729,70 @@ int fsl_otg_config(void)
 	return 0;
 }
 
+static struct platform_device *fsl_otg_add_platform_device(char *name,
+						int id,
+						struct platform_device *pdev)
+{
+	int ret;
+	struct platform_device *dev;
+
+	dev = platform_device_alloc(name, id);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	dev->dev.coherent_dma_mask = 0xffffffffUL;
+	dev->dev.dma_mask = &dev->dev.coherent_dma_mask;
+	ret = platform_device_add_data(dev, pdev->dev.platform_data,
+				sizeof(struct fsl_usb2_platform_data));
+	if (ret)
+		goto free_dev;
+
+	ret = platform_device_add(dev);
+	if (ret)
+		goto free_dev;
+
+	return dev;
+
+free_dev:
+	platform_device_put(dev);
+	return ERR_PTR(ret);
+}
+
+static void fsl_otg_add_host_client_device(struct work_struct *work)
+{
+	struct platform_device *pdev, *tmp;
+	struct resource *r;
+	struct fsl_otg *otg;
+	struct otg_transceiver *trans = otg_get_transceiver();
+
+	otg = container_of(trans, struct fsl_otg, otg);
+
+	pdev = otg->dev;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_WARNING "Can't get resource for usb host and" \
+					" device\n");
+		return;
+	}
+
+	tmp = fsl_otg_add_platform_device("fsl-ehci", pdev->id, pdev);
+	if (IS_ERR(tmp)) {
+		printk(KERN_WARNING "Can't add usb host device\n");
+		return;
+	}
+	otg->host_dev = tmp;
+
+	tmp = fsl_otg_add_platform_device("fsl-usb2-udc", pdev->id, pdev);
+	if (IS_ERR(tmp)) {
+		printk(KERN_WARNING "Can't add usb device\n");
+		return;
+	}
+	otg->client_dev = tmp;
+
+	return;
+}
+
 /* OTG Initialization*/
 int usb_otg_start(struct platform_device *pdev)
 {
@@ -741,6 +807,8 @@ int usb_otg_start(struct platform_device *pdev)
 	p_otg = container_of(otg_trans, struct fsl_otg, otg);
 	fsm = &p_otg->fsm;
 
+	p_otg->dev = pdev;
+
 	/* Initialize the state machine structure with default values */
 	SET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);
 	fsm->transceiver = &p_otg->otg;
@@ -772,6 +840,10 @@ int usb_otg_start(struct platform_device *pdev)
 	/* Export DR controller resources */
 	otg_set_resources(pdev->resource);
 
+	/* Add host and gadget device, wait a minute for usb-otg workqueue up */
+	INIT_DELAYED_WORK(&p_otg->add_device_work, fsl_otg_add_host_client_device);
+	schedule_delayed_work(&p_otg->add_device_work, HZ);
+
 	/* stop the controller */
 	temp = readl(&p_otg->dr_mem_map->usbcmd);
 	temp &= ~USB_CMD_RUN_STOP;
@@ -1063,12 +1135,28 @@ static int __init fsl_otg_probe(struct platform_device *pdev)
 	return status;
 }
 
+static void __exit fsl_otg_rm_host_client_device(void)
+{
+	struct fsl_otg *otg;
+	struct otg_transceiver *trans = otg_get_transceiver();
+
+	otg = container_of(trans, struct fsl_otg, otg);
+
+	cancel_delayed_work(&otg->add_device_work);
+	platform_device_unregister(otg->host_dev);
+	platform_device_unregister(otg->client_dev);
+
+	return;
+}
+
 static int __exit fsl_otg_remove(struct platform_device *pdev)
 {
 	struct resource *res;
 
 	destroy_workqueue(fsl_otg_dev->otg.otg_wq);
 
+	fsl_otg_rm_host_client_device();
+
 	otg_set_transceiver(NULL);
 	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
 
diff --git a/drivers/usb/otg/fsl_otg.h b/drivers/usb/otg/fsl_otg.h
index a996ef5..e169b73 100644
--- a/drivers/usb/otg/fsl_otg.h
+++ b/drivers/usb/otg/fsl_otg.h
@@ -378,9 +378,11 @@ struct fsl_otg{
 
 	/*used for usb host*/
 	struct work_struct work_wq;
+	struct delayed_work add_device_work;
 	u8	host_working;
 
 	int irq;
+	struct platform_device *dev, *host_dev, *client_dev;
 };
 
 struct fsl_otg_config{
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 25bd853..975577e 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -55,6 +55,8 @@ struct otg_transceiver {
 
 	/* execute hcd and gadget suspend/resume function */
 	struct workqueue_struct *otg_wq;
+	/* the otg module */
+	struct module *owner;
 
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct otg_transceiver *otg,
-- 
1.6.3.3

