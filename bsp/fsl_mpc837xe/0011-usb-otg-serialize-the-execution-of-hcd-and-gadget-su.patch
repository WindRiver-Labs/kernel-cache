From 22fa52add9ff16c9b6c5d635a1051026549e45f6 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 28 Aug 2009 16:36:15 +0800
Subject: [PATCH 11/38] usb/otg: serialize the execution of hcd and gadget suspend/resume function

We need the hcd and gadget suspend/resume function to execute in order.
Such as hcd suspend, then gadget resume. But hcd suspend/resume are
invoked through workqueue, and gadget suspend/resume are invoked in an
isr. If we suspend the hcd and resume the gadget, the hcd suspend will
execute after gadget resume. This will mess up the usb controller. So
create a single thread workqueue and invoke the suspend and resume in
order, this will make sure that these functions also be executed in
order.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/usb/gadget/fsl_usb2_udc.c |   29 +++++++++++++++++++++++++++++
 drivers/usb/gadget/fsl_usb2_udc.h |    3 +++
 drivers/usb/host/ehci-fsl.c       |   12 ++++++++++--
 drivers/usb/otg/fsl_otg.c         |    7 +++++++
 include/linux/usb/otg.h           |    3 +++
 5 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 67b5184..3b18888 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -41,6 +41,7 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/dmapool.h>
+#include <linux/workqueue.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -82,6 +83,7 @@ static void fsl_ep_fifo_flush(struct usb_ep *_ep);
 
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
 /* Get platform resource from OTG driver */
+static void udc_resume_work(struct work_struct *work);
 extern struct resource *otg_get_resources(void);
 #endif
 
@@ -2305,7 +2307,9 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ERR("malloc udc failed\n");
 		return -ENOMEM;
 	}
+
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	INIT_WORK(&udc_controller->resume_work, udc_resume_work);
 	/* Memory and interrupt resources will be passed from OTG */
 	udc_controller->transceiver = otg_get_transceiver();
 	if (!udc_controller->transceiver) {
@@ -2475,6 +2479,7 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	free_irq(udc_controller->irq, udc_controller);
 	iounmap(dr_regs);
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	cancel_work_sync(&udc_controller->resume_work);
 	res = otg_get_resources();
 #else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2498,6 +2503,21 @@ static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 	return 0;
 }
 
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+static void udc_resume_work(struct work_struct *work)
+{
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
+	}
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	return;
+}
+#endif
+
 /*-----------------------------------------------------------------
  * Invoked on USB resume. May be called in_interrupt.
  * Here we start the DR controller and enable the irq
@@ -2505,6 +2525,14 @@ static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 static int fsl_udc_resume(struct device *dev)
 {
 	/* Enable DR irq reg and set controller Run */
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct workqueue_struct *wq = udc_controller->transceiver->otg_wq;
+
+	if (!wq)
+		return 0;
+
+	queue_work(wq, &udc_controller->resume_work);
+#else
 	if (udc_controller->stopped) {
 		dr_controller_setup(udc_controller);
 		dr_controller_run(udc_controller);
@@ -2512,6 +2540,7 @@ static int fsl_udc_resume(struct device *dev)
 	udc_controller->usb_state = USB_STATE_ATTACHED;
 	udc_controller->ep0_state = WAIT_FOR_SETUP;
 	udc_controller->ep0_dir = 0;
+#endif
 	return 0;
 }
 
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index 6131752..419fe17 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -506,6 +506,9 @@ struct fsl_udc {
 	u8 device_address;	/* Device USB address */
 
 	struct completion *done;	/* to make sure release() is done */
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct work_struct resume_work;
+#endif
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 619b07b..f474915 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -425,6 +425,9 @@ static int ehci_fsl_drv_remove(struct platform_device *pdev)
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	cancel_work_sync(&ehci->change_hcd_work);
 	kfree(usb_ehci_regs);
 #endif
 	/* FIXME we only want one one remove() not two */
@@ -437,10 +440,14 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev, pm_message_t messa
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct workqueue_struct *wq = ehci->transceiver->otg_wq;
+
+	if (!wq)
+		return 0;
 
 	/* remove hcd */
 	hcd_add = 0;
-	schedule_work(&ehci->change_hcd_work);
+	queue_work(wq, &ehci->change_hcd_work);
 
 #endif
 	hcd->state = HC_STATE_SUSPENDED;
@@ -457,10 +464,11 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 #if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct workqueue_struct *wq = ehci->transceiver->otg_wq;
 
 	/* add hcd */
 	hcd_add = 1;
-	schedule_work(&ehci->change_hcd_work);
+	queue_work(wq, &ehci->change_hcd_work);
 
 #endif
 /* FIXME: USB PM not working now */
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
index d9a111f..94f0c24 100644
--- a/drivers/usb/otg/fsl_otg.c
+++ b/drivers/usb/otg/fsl_otg.c
@@ -716,6 +716,11 @@ int fsl_otg_config(void)
 	fsl_otg_tc->otg.start_hnp = fsl_otg_start_hnp;
 	fsl_otg_tc->otg.start_srp = fsl_otg_start_srp;
 	otg_set_transceiver(&fsl_otg_tc->otg);
+	/* Create work queue used by gadget and host suspend/resume */
+	fsl_otg_tc->otg.otg_wq = create_singlethread_workqueue("usb-otg");
+	if (!fsl_otg_tc->otg.otg_wq) {
+		return -ENOMEM;
+	}
 
 	fsl_otg_dev = fsl_otg_tc;
 
@@ -1062,6 +1067,8 @@ static int __exit fsl_otg_remove(struct platform_device *pdev)
 {
 	struct resource *res;
 
+	destroy_workqueue(fsl_otg_dev->otg.otg_wq);
+
 	otg_set_transceiver(NULL);
 	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
 
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 1db25d1..25bd853 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -53,6 +53,9 @@ struct otg_transceiver {
 	u16			port_status;
 	u16			port_change;
 
+	/* execute hcd and gadget suspend/resume function */
+	struct workqueue_struct *otg_wq;
+
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct otg_transceiver *otg,
 				struct usb_bus *host);
-- 
1.6.3.3

