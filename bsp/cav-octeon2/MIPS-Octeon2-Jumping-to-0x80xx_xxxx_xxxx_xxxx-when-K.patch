From 22e61205a81a0a740d542e4d54decac8815ef8f7 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Tue, 26 Mar 2013 16:47:01 +0800
Subject: [PATCH 09/17] MIPS: Octeon2 : Jumping to 0x80xx_xxxx_xxxx_xxxx when
 KEXEC/KDUMP

When KEXEC/KDUMP, the 1st kernel would relocate some code segments
and then jump to them, which address is 0xa8xx_xxxx_xxxx_xxxx. That
works well for OCTEON and OCTEON plus (CN58XX/CN38XX, CN56XX/CN57XX),
while for OCTEON2 CN63XX the relocated codes couldn't be executed.
By debugging, I found that after relocating the codes to
0xa8xx_xxxx_xxxx_xxxx, jumping to 0x80xx_xxxx_xxxx_xxxx can fix this
issue. That 2 addresses are directly mapped to the same physical
address(don't pass the TLB).

Signed-off-by: Tian Le <le.tian@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/include/asm/kexec.h      |    5 +++++
 arch/mips/kernel/machine_kexec.c   |    5 +++--
 arch/mips/kernel/relocate_kernel.S |    8 ++++++++
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index ee25ebb..1f2bdcd 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -40,6 +40,11 @@ extern int (*_machine_kexec_prepare)(struct kimage *);
 extern void (*_machine_kexec_shutdown)(void);
 extern void (*_machine_crash_shutdown)(struct pt_regs *regs);
 extern void default_machine_crash_shutdown(struct pt_regs *regs);
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define OCTEON_KEXEC_OFFSET	(0x2800000000000000)
+#else
+#define OCTEON_KEXEC_OFFSET	(0)
+#endif
 #ifdef CONFIG_SMP
 extern const unsigned char kexec_smp_wait[];
 extern unsigned long secondary_kexec_args[4];
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index 992e184..3f45cbe 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -102,9 +102,10 @@ machine_kexec(struct kimage *image)
 #ifdef CONFIG_SMP
 	/* All secondary cpus now may jump to kexec_wait cycle */
 	relocated_kexec_smp_wait = reboot_code_buffer +
-		(void *)(kexec_smp_wait - relocate_new_kernel);
+		(void *)(kexec_smp_wait - relocate_new_kernel)
+		- OCTEON_KEXEC_OFFSET;
 	smp_wmb();
 	atomic_set(&kexec_ready_to_reboot, 1);
 #endif
-	((noretfun_t) reboot_code_buffer)();
+	((noretfun_t) (reboot_code_buffer - OCTEON_KEXEC_OFFSET))();
 }
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index e4142c5..6bec27b 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -14,6 +14,12 @@
 #include <asm/stackframe.h>
 #include <asm/addrspace.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define OCTEON_KEXEC_OFFSET	(0x2800000000000000)
+#else
+#define OCTEON_KEXEC_OFFSET	(0)
+#endif
+
 LEAF(relocate_new_kernel)
 	PTR_L a0,	arg0
 	PTR_L a1,	arg1
@@ -22,6 +28,7 @@ LEAF(relocate_new_kernel)
 
 	PTR_L		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
+	LONG_SUB	s1, OCTEON_KEXEC_OFFSET
 
 process_entry:
 	PTR_L		s2, (s0)
@@ -106,6 +113,7 @@ LEAF(kexec_smp_wait)
 	PTR_L		a2, s_arg2
 	PTR_L		a3, s_arg3
 	PTR_L		s1, kexec_start_address
+	LONG_SUB	s1, OCTEON_KEXEC_OFFSET
 
 	/* Non-relocated address works for args and kexec_start_address ( old
 	 * kernel is not overwritten). But we need relocated address of
-- 
1.7.5.4

