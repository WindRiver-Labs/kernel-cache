From 5232abbf42ce6dc32be2975edfc31deb561c65c7 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Tue, 7 May 2013 12:53:18 +0800
Subject: [PATCH] modules: don't hand 0 to vmalloc.

commit: 82fab442f5322b016f72891c0db2436c6a6c20b7 upstream

In commit d0a21265dfb5fa8a David Rientjes unified various archs'
module_alloc implementation (including x86) and removed the graduitous
shortcut for size == 0.

Then, in commit de7d2b567d040e3b, Joe Perches added a warning for
zero-length vmallocs, which can happen without kallsyms on modules
with no init sections (eg. zlib_deflate).

Fix this once and for all; the module code has to handle zero length
anyway, so get it right at the caller and remove the now-gratuitous
checks within the arch-specific module_alloc implementations.

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=42608
Reported-by: Conrad Kostecki <ConiKost@gmx.de>
Cc: David Rientjes <rientjes@google.com>
Cc: Joe Perches <joe@perches.com>
Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/cris/kernel/module.c      |    2 --
 arch/parisc/kernel/module.c    |    2 --
 arch/sparc/kernel/module.c     |    4 ----
 arch/tile/kernel/module.c      |    2 --
 arch/unicore32/kernel/module.c |    3 ---
 kernel/module.c                |   33 ++++++++++++++++++---------------
 6 files changed, 18 insertions(+), 28 deletions(-)

diff --git a/arch/cris/kernel/module.c b/arch/cris/kernel/module.c
index 37400f5..51123f9 100644
--- a/arch/cris/kernel/module.c
+++ b/arch/cris/kernel/module.c
@@ -32,8 +32,6 @@
 #ifdef CONFIG_ETRAX_KMALLOCED_MODULES
 void *module_alloc(unsigned long size)
 {
-	if (size == 0)
-		return NULL;
 	return kmalloc(size, GFP_KERNEL);
 }
 
diff --git a/arch/parisc/kernel/module.c b/arch/parisc/kernel/module.c
index 672bc9c..9908930 100644
--- a/arch/parisc/kernel/module.c
+++ b/arch/parisc/kernel/module.c
@@ -236,8 +236,6 @@ static inline int reassemble_22(int as22)
 
 void *module_alloc(unsigned long size)
 {
-	if (size == 0)
-		return NULL;
 	/* using RWX means less protection for modules, but it's
 	 * easier than trying to map the text, data, init_text and
 	 * init_data correctly */
diff --git a/arch/sparc/kernel/module.c b/arch/sparc/kernel/module.c
index 276359e..9c4356a 100644
--- a/arch/sparc/kernel/module.c
+++ b/arch/sparc/kernel/module.c
@@ -58,10 +58,6 @@ void *module_alloc(unsigned long size)
 {
 	void *ret;
 
-	/* We handle the zero case fine, unlike vmalloc */
-	if (size == 0)
-		return NULL;
-
 	ret = module_map(size);
 	if (!ret)
 		ret = ERR_PTR(-ENOMEM);
diff --git a/arch/tile/kernel/module.c b/arch/tile/kernel/module.c
index 98d4769..16f874f 100644
--- a/arch/tile/kernel/module.c
+++ b/arch/tile/kernel/module.c
@@ -52,8 +52,6 @@ void *module_alloc(unsigned long size)
 	int i = 0;
 	int npages;
 
-	if (size == 0)
-		return NULL;
 	npages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
 	pages = kmalloc(npages * sizeof(struct page *), GFP_KERNEL);
 	if (pages == NULL)
diff --git a/arch/unicore32/kernel/module.c b/arch/unicore32/kernel/module.c
index 8fbe857..16bd149 100644
--- a/arch/unicore32/kernel/module.c
+++ b/arch/unicore32/kernel/module.c
@@ -27,9 +27,6 @@ void *module_alloc(unsigned long size)
 	struct vm_struct *area;
 
 	size = PAGE_ALIGN(size);
-	if (!size)
-		return NULL;
-
 	area = __get_vm_area(size, VM_ALLOC, MODULES_VADDR, MODULES_END);
 	if (!area)
 		return NULL;
diff --git a/kernel/module.c b/kernel/module.c
index 5083a25..829ce3e 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2400,7 +2400,7 @@ static void dynamic_debug_remove(struct _ddebug *debug)
 
 void * __weak module_alloc(unsigned long size)
 {
-	return size == 0 ? NULL : vmalloc_exec(size);
+	return vmalloc_exec(size);
 }
 
 static void *module_alloc_update_bounds_rw(unsigned long size)
@@ -2753,20 +2753,23 @@ static int move_module(struct module *mod, struct load_info *info)
 	memset(ptr, 0, mod->core_size_rw);
 	mod->module_core_rw = ptr;
 
-	ptr = module_alloc_update_bounds_rw(mod->init_size_rw);
-	/*
-	 * The pointer to this block is stored in the module structure
-	 * which is inside the block. This block doesn't need to be
-	 * scanned as it contains data and code that will be freed
-	 * after the module is initialized.
-	 */
-	kmemleak_not_leak(ptr);
-	if (!ptr && mod->init_size_rw) {
-		module_free(mod, mod->module_core_rw);
-		return -ENOMEM;
-	}
-	memset(ptr, 0, mod->init_size_rw);
-	mod->module_init_rw = ptr;
+	if (mod->init_size_rw) {
+		ptr = module_alloc_update_bounds_rw(mod->init_size_rw);
+		/*
+		 * The pointer to this block is stored in the module structure
+		 * which is inside the block. This block doesn't need to be
+		 * scanned as it contains data and code that will be freed
+		 * after the module is initialized.
+		 */
+		kmemleak_ignore(ptr);
+		if (!ptr) {
+			module_free(mod, mod->module_core_rw);
+			return -ENOMEM;
+		}
+		memset(ptr, 0, mod->init_size_rw);
+		mod->module_init_rw = ptr;
+	} else
+		mod->module_init_rw = NULL;
 
 	ptr = module_alloc_update_bounds_rx(mod->core_size_rx);
 	kmemleak_not_leak(ptr);
-- 
1.7.10.4

