From 97590f3499ec138d697f5872f452852d2162a963 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Thu, 11 Apr 2013 11:26:49 +0800
Subject: [PATCH 05/17] Cavium: SDK2.0 Enable Octeon Oprofile support

Source: SDK 2.0.0-366

Octeon has two PMR pairs and the counter registers are 64 bits.  Add
Octeon specifc read/write counter registers macros since MIPSR2
performance counters registers are 32 bits.  Add Octeon specific op
model file for arch-dependent Oprofile interfaces.

Signed-off-by: ltian <le.tian@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/oprofile/common.c                 |    6 ++-
 arch/mips/oprofile/op_model_cavium_octeon.c |   63 ++++++++++++++------------
 2 files changed, 38 insertions(+), 31 deletions(-)

diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index 39b3a27..7e987f8 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -18,7 +18,7 @@
 extern struct op_mips_model op_model_mipsxx_ops __weak;
 extern struct op_mips_model op_model_rm9000_ops __weak;
 extern struct op_mips_model op_model_loongson2_ops __weak;
-extern struct op_mips_model op_model_octeon_ops __weak;
+extern struct op_mips_model op_model_octeon __weak;
 
 static struct op_mips_model *model;
 
@@ -99,9 +99,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_LOONGSON2:
 		lmodel = &op_model_loongson2_ops;
 		break;
+
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
-		lmodel = &op_model_octeon_ops;
+	case CPU_CAVIUM_OCTEON2:
+		lmodel = &op_model_octeon;
 		break;
 	};
 
diff --git a/arch/mips/oprofile/op_model_cavium_octeon.c b/arch/mips/oprofile/op_model_cavium_octeon.c
index 0c9a309..473e815 100644
--- a/arch/mips/oprofile/op_model_cavium_octeon.c
+++ b/arch/mips/oprofile/op_model_cavium_octeon.c
@@ -8,10 +8,11 @@
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
-#include <asm/mipsregs.h>
 
 #include "op_impl.h"
 
+#define OCTEON_PERFCNT_IRQ   (cp0_perfcount_irq + MIPS_CPU_IRQ_BASE)
+
 /**
  * Bit description of the core counters control register
  */
@@ -59,8 +60,8 @@ static void octeon_reg_setup(struct op_counter_config *ctr)
 
 static void octeon_cpu_setup(void *args)
 {
-	write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
-	write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+	__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
+	__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
 }
 
 static void octeon_cpu_start(void *args)
@@ -69,13 +70,22 @@ static void octeon_cpu_start(void *args)
 
 	/* Disable the issue and exec conditional clock support so we get
 		better results */
-	cvmctl = read_c0_cvmctl();
+	cvmctl = __read_64bit_c0_register($9, 7);
 	cvmctl |= 3 << 16;
-	write_c0_cvmctl(cvmctl);
+	__write_64bit_c0_register($9, 7, cvmctl);
+
+	/* Check CvmCtl[IPPCI] bit to make sure it is set with
+	 * irq cached by cp0_perfcount_irq
+	 */
+	cvmctl = __read_64bit_c0_register($9, 7);
+	if (cp0_perfcount_irq != ((cvmctl >> 7) & 7)) {
+		printk(KERN_INFO "oprofile perf irq is not mapped to %d, on core %d \n",
+			cp0_perfcount_irq,  smp_processor_id());
+	}
 
 	/* Start all counters on current CPU */
-	write_c0_perfctrl0(octeon_config.control[0].u32);
-	write_c0_perfctrl1(octeon_config.control[1].u32);
+	__write_32bit_c0_register($25, 0, octeon_config.control[0].u32);
+	__write_32bit_c0_register($25, 2, octeon_config.control[1].u32);
 }
 
 static void octeon_cpu_stop(void *args)
@@ -83,30 +93,30 @@ static void octeon_cpu_stop(void *args)
 	uint64_t cvmctl;
 
 	/* Stop all counters on current CPU */
-	write_c0_perfctrl0(0);
-	write_c0_perfctrl1(0);
+	__write_32bit_c0_register($25, 0, 0);
+	__write_32bit_c0_register($25, 2, 0);
 
 	/* Enable the issue and exec conditional clock support so we use
 		less power */
-	cvmctl = read_c0_cvmctl();
+	cvmctl = __read_64bit_c0_register($9, 7);
 	cvmctl &= ~(3 << 16);
-	write_c0_cvmctl(cvmctl);
+	__write_64bit_c0_register($9, 7, cvmctl);
 }
 
 static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
 {
 	uint64_t counter;
 
-	counter = read_octeon_c0_perfcntr0();
+	counter = __read_64bit_c0_register($25, 1);
 	if (counter & (1ull << 63)) {
 		oprofile_add_sample(get_irq_regs(), 0);
-		write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
+		__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
 	}
 
-	counter = read_octeon_c0_perfcntr1();
+	counter = __read_64bit_c0_register($25, 3);
 	if (counter & (1ull << 63)) {
 		oprofile_add_sample(get_irq_regs(), 1);
-		write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+		__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
 	}
 
 	return IRQ_HANDLED;
@@ -114,21 +124,16 @@ static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
 
 static int octeon_init(void)
 {
-	unsigned long irq_flags;
-	int result;
-#ifdef CONFIG_PREEMPT_HARDIRQS
-	irq_flags = IRQF_NO_THREAD;
-#else
-	irq_flags = IRQF_SHARED;
-#endif 
-	result =
-		request_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler, irq_flags,
+	int result =
+		request_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler,
+			    IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING,
 			    "Perfcounter", octeon_perfcount_handler);
 #ifdef CONFIG_SMP
 	if (result == 0) {
-		struct irq_desc *desc = irq_desc + OCTEON_IRQ_PERF;
-		smp_call_function((void (*)(void *)) desc->chip->enable,
-				  (void *) (long) OCTEON_IRQ_PERF, 1);
+		struct irq_desc *desc = irq_desc + OCTEON_PERFCNT_IRQ;
+		struct irq_chip *chip = irq_desc_get_chip(desc);
+		smp_call_function((void (*)(void *))chip->irq_enable,
+				  (void *) irq_desc_get_irq_data(desc), 1);
 	}
 #endif
 	return result;
@@ -136,10 +141,10 @@ static int octeon_init(void)
 
 static void octeon_exit(void)
 {
-	free_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler);
+	free_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler);
 }
 
-struct op_mips_model op_model_octeon_ops = {
+struct op_mips_model op_model_octeon = {
 	.reg_setup = octeon_reg_setup,
 	.cpu_setup = octeon_cpu_setup,
 	.init = octeon_init,
-- 
1.7.5.4

