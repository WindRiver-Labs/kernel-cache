From 09a473fbab52b26a0805a1912093c2544fc241fa Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Tue, 23 Apr 2013 10:45:05 +0800
Subject: [PATCH 11/17] Cavium: kexec: fix crash kernel boot failing on 58xx

Source: Internal Development

First, fix on-SoC POW-driven-device reset sequence by methods
from SDK 2.0.0-366, include:

 - Obtain device work from POW from pow_work_request_sync() API
   to drain the rx queues
 - Shutdown RX/TX on devices
 - Clear possible pending interrupts from first kernel in POW
 - Add handling of SGMII and XAUI interface modes

Second, handle bootmem allocation differently for crash kernel.
Previous implementation tried to free bootmem then reallocate it.
In fact, this is superfluous, since the memory has already been
allocated by the bootloader to the first kernel. The crash kernel
will run from inside some of that memory. Simply bypass the
reallocation if running a crash kernel.

Third, remove a forgotten debugging printk().

Signed-off-by: Tian Le <le.tian@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c                |   19 ++++++++-
 drivers/net/ethernet/octeon/ethernet.c         |    1 -
 drivers/net/ethernet/octeon/octeon-kexec-net.c |   55 +++++++++++------------
 3 files changed, 44 insertions(+), 31 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 0fefc1a..dd8634f 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -797,6 +797,7 @@ void __init prom_init(void)
 	argc = octeon_boot_desc_ptr->argc;
 	for (i = 0; i < argc; i++) {
 		const char *arg = phys_to_virt(octeon_boot_desc_ptr->argv[i]);
+#ifndef CONFIG_CRASH_DUMP
 		if (strncmp(arg, "mem=block:", 10) == 0) {
 			const char *pos = arg + 10;
 			int j;
@@ -835,7 +836,9 @@ void __init prom_init(void)
 			strncpy(rd_name, arg + 8, sizeof(rd_name));
 			rd_name[sizeof(rd_name) - 1] = 0;
 			goto append_arg;
-		} else if (strcmp(arg, "ecc_verbose") == 0) {
+		} else
+#endif /* CONFIG_CRASH_DUMP */
+		if (strcmp(arg, "ecc_verbose") == 0) {
 #ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC
 			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
 			pr_notice("Reporting of single bit ECC errors is "
@@ -900,6 +903,7 @@ append_arg:
 #define OCTEON_DDR1_SIZE    (0x010000000ULL)
 #define OCTEON_LINUX_RESERVED_MEM_NAME    "__tmp_reserved_linux"
 
+#ifndef CONFIG_CRASH_DUMP
 void cleanup_phy_mem(void)
 {
 	/* Ensure all memory is cleaned up.
@@ -960,6 +964,12 @@ void cleanup_phy_mem(void)
 		}
 	}
 }
+#else
+void cleanup_phy_mem(void)
+{
+	/* do nothing */
+}
+#endif /* CONFIG_CRASH_DUMP */
 
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2
 static int __init octeon_l2_cache_lock(void)
@@ -1009,6 +1019,7 @@ static int __init octeon_l2_cache_lock(void)
 late_initcall(octeon_l2_cache_lock);
 #endif
 
+#ifndef CONFIG_CRASH_DUMP
 /* Exclude a single page from the regions obtained in plat_mem_setup. */
 static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 {
@@ -1024,6 +1035,7 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 		*size -= PAGE_SIZE;
 	}
 }
+#endif
 
 void __init plat_mem_setup(void)
 {
@@ -1083,6 +1095,10 @@ void __init plat_mem_setup(void)
 	if (mem_alloc_size > MAX_MEMORY)
 		mem_alloc_size = MAX_MEMORY;
 
+	/* only allocate from bootmem when not a crash dump kernel (memory
+	 * layout is defined by mem= by kexec in that case)
+	 */
+#ifndef CONFIG_CRASH_DUMP
 	/*
 	 * When allocating memory, we want incrementing addresses from
 	 * bootmem_alloc so the code in add_memory_region can merge
@@ -1133,6 +1149,7 @@ void __init plat_mem_setup(void)
 		}
 	}
 	cvmx_bootmem_unlock();
+#endif
 
 mem_alloc_done:
 
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 2bd1f87..7cede86 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -872,7 +872,6 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 	struct device_node *pip;
 
 #ifdef CONFIG_KEXEC
-	printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
 	if (reset_devices)
 		octeon_shutdown_network_hw();
 #endif
diff --git a/drivers/net/ethernet/octeon/octeon-kexec-net.c b/drivers/net/ethernet/octeon/octeon-kexec-net.c
index 847ec5d..72225ae 100644
--- a/drivers/net/ethernet/octeon/octeon-kexec-net.c
+++ b/drivers/net/ethernet/octeon/octeon-kexec-net.c
@@ -12,12 +12,12 @@
 #include <asm/octeon/cvmx-pko-defs.h>
 #include <asm/octeon/cvmx-smix-defs.h>
 #include <asm/octeon/cvmx-pow.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
 
 void octeon_shutdown_network_hw(void)
 {
-	cvmx_helper_link_info_t link_info;
 	cvmx_wqe_t *work = NULL;
-	int ipd_port = 0;
 	int num_ints = 0;
 	int interface = 0;
 	int num_ports = 0;
@@ -27,47 +27,44 @@ void octeon_shutdown_network_hw(void)
 	union cvmx_smix_en smix_en;
 	union cvmx_ipd_ctl_status ipd_ctl_status;
 	union cvmx_pip_sft_rst pip_sft_rst;
-
-	/* free up the work queue associated with this core */
-	work = cvmx_pow_get_current_wqp();
-	if (NULL != work) {
-		/* drain the work queue and free it */
-		cvmx_helper_free_packet_data(work);
-		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
-	}
+	union cvmx_pow_wq_int wq_int;
 
 	/* halt the interfaces */
 	num_ints = cvmx_helper_get_number_of_interfaces();
-	if (num_ints > 2)
-		num_ints = 2;
 
 	/* Check to see what interface and ports we should use */
 	for (interface = 0; interface < num_ints; interface++) {
-		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
-			cvmx_helper_interface_get_mode(interface)) ||
-			(CVMX_HELPER_INTERFACE_MODE_GMII ==
-				cvmx_helper_interface_get_mode(interface))) {
-			/* get the ports for this interface */
-			cvmx_helper_interface_probe(interface);
-			num_ports = cvmx_helper_ports_on_interface(interface);
+		cvmx_helper_interface_mode_t mode =
+			cvmx_helper_interface_get_mode(interface);
+		int xGMII_mode = (CVMX_HELPER_INTERFACE_MODE_RGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_SGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_GMII  == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_XAUI  == mode);
 
+		if (xGMII_mode) {
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			if (num_ports > 4)
+				num_ports = 4;
 			for (port = 0; port < num_ports; port++) {
-				ipd_port = cvmx_helper_get_ipd_port(interface, port);
-
-				link_info = cvmx_helper_link_get(ipd_port);
-				link_info.s.link_up = 0;
-				cvmx_helper_link_set(ipd_port, link_info);
+				union cvmx_gmxx_prtx_cfg gmx_cfg;
+				gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(port, interface));
+				gmx_cfg.s.en = 0;
+				cvmx_write_csr(CVMX_GMXX_PRTX_CFG(port, interface), gmx_cfg.u64);
 			}
 		}
 	}
 
-	/* disable the SMI */
-	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
-	if (smix_en.s.en) {
-		smix_en.s.en = 0;
-		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
+	/* drain the work queue and free it */
+	while ((work = cvmx_pow_work_request_sync(CVMX_POW_WAIT))) {
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
 	}
 
+	/* clear possible pending interrupt */
+	wq_int.u64 = 0;
+	wq_int.s.wq_int = 1 << 15;
+	cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
+
 	/* Newer chips actually have two SMI/MDIO interfaces */
 	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
 		!OCTEON_IS_MODEL(OCTEON_CN58XX) &&
-- 
1.7.5.4

