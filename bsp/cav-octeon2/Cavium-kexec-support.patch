From 812984bdb55a72ac24bd6284c0dfe6212b27fb29 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Mon, 22 Apr 2013 16:52:42 +0800
Subject: [PATCH 10/17] Cavium: kexec support

Support following features:
- Network interface reset
- SMP CPU takedown
- Cavium Physical memory cleanup upon reboot
- Newer mgmt port driver resets interface on restart, kexec-specific
  support has been dropped.
- mem= did not take multipliers into account, always assuming M: add
  support for K since kexec adds a mem=<crashkernel size>K to the
  boot line

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Signed-off-by: ltian <le.tian@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c                |  335 +++++++++++++++++++++---
 arch/mips/include/asm/octeon/cvmx-bootmem.h    |    5 +
 drivers/net/ethernet/octeon/Makefile           |    1 +
 drivers/net/ethernet/octeon/ethernet.c         |    9 +
 drivers/net/ethernet/octeon/octeon-kexec-net.c |  114 ++++++++
 5 files changed, 423 insertions(+), 41 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/octeon-kexec-net.c

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 6fdd30a..0fefc1a 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -44,6 +44,11 @@
 
 #include <asm/octeon/cvmx-qlm.h>
 
+#ifdef CONFIG_KEXEC
+#include <linux/kexec.h>
+#include <linux/slab.h>
+#endif
+
 extern struct plat_smp_ops octeon_smp_ops;
 
 static unsigned long long MAX_MEMORY = 512ull << 20;
@@ -76,39 +81,6 @@ static void octeon_kexec_smp_down(void *ignored)
 }
 #endif
 
-static int octeon_kexec_prepare(struct kimage *image)
-{
-	int i;
-	char *bootloader = "kexec";
-
-	octeon_boot_desc_ptr->argc = 0;
-	for (i = 0; i < image->nr_segments; i++) {
-		if (!strncmp(bootloader, (char *)image->segment[i].buf,
-				strlen(bootloader))) {
-			/*
-			 * convert command line string to array
-			 * of parameters (as bootloader does).
-			 */
-			int argc = 0, offt;
-			char *str = (char *)image->segment[i].buf;
-			char *ptr = strchr(str, ' ');
-			while (ptr && (OCTEON_ARGV_MAX_ARGS > argc)) {
-				*ptr = '\0';
-				if (ptr[1] != ' ') {
-					offt = (int)(ptr - str + 1);
-					octeon_boot_desc_ptr->argv[argc] =
-						image->segment[i].mem + offt;
-					argc++;
-				}
-				ptr = strchr(ptr + 1, ' ');
-			}
-			octeon_boot_desc_ptr->argc = argc;
-			break;
-		}
-	}
-	return 0;
-}
-
 static void octeon_generic_shutdown(void)
 {
 #ifdef CONFIG_SMP
@@ -138,12 +110,6 @@ static void octeon_shutdown(void)
 #endif
 }
 
-static void octeon_crash_shutdown(struct pt_regs *regs)
-{
-	octeon_generic_shutdown();
-	default_machine_crash_shutdown(regs);
-}
-
 #endif /* CONFIG_KEXEC */
 
 #if CONFIG_CAVIUM_RESERVE32 > 0
@@ -151,6 +117,31 @@ uint64_t octeon_reserve32_memory;
 EXPORT_SYMBOL(octeon_reserve32_memory);
 #endif
 
+#ifdef CONFIG_KEXEC
+/* machine-specific function pointers for kexec */
+extern int (*_machine_kexec_prepare)(struct kimage *);
+extern void (*_machine_kexec_shutdown)(void);
+extern void (*_machine_crash_shutdown)(struct pt_regs *);
+/* utility functions */
+extern void octeon_shutdown_network_hw(void);
+/*
+ * Perform any setup actions necessary to setup this unit for kexec
+ * Currently this primarily means registering the cavium-specific targets
+ * for the kexec functions
+ */
+
+static void octeon_kexec_shutdown(void);
+static int octeon_kexec_prepare(struct kimage *kimage);
+static void octeon_crash_shutdown(struct pt_regs *regs);
+
+static void octeon_kexec_setup(void)
+{
+	_machine_kexec_shutdown = &octeon_kexec_shutdown;
+	_machine_kexec_prepare = &octeon_kexec_prepare;
+	_machine_crash_shutdown = &octeon_crash_shutdown;
+}
+#endif
+
 static int octeon_uart;
 
 extern asmlinkage void handle_int(void);
@@ -683,7 +674,7 @@ void __init prom_init(void)
 
 	sysinfo = cvmx_sysinfo_get();
 	memset(sysinfo, 0, sizeof(*sysinfo));
-	sysinfo->system_dram_size = octeon_bootinfo->dram_size << 20;
+	sysinfo->system_dram_size = (uint64_t)octeon_bootinfo->dram_size << 20;
 	sysinfo->phy_mem_desc_addr = (u64)phys_to_virt(octeon_bootinfo->phy_mem_desc_addr);
 	sysinfo->core_mask = octeon_bootinfo->core_mask;
 	sysinfo->exception_base_addr = octeon_bootinfo->exception_base_addr;
@@ -759,10 +750,19 @@ void __init prom_init(void)
 	octeon_uart = octeon_get_boot_uart();
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("CrashSMP");
+#else
 	octeon_write_lcd("LinuxSMP");
+#endif
+#else
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("Crash");
 #else
 	octeon_write_lcd("Linux");
 #endif
+#endif
+
 
 #ifdef CONFIG_CAVIUM_GDB
 	/*
@@ -889,6 +889,76 @@ append_arg:
 	if (labi->labi_signature == LABI_SIGNATURE)
 		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
 
+#ifdef CONFIG_KEXEC
+	octeon_kexec_setup();
+#endif
+}
+
+/* constants for memory initialization */
+#define OCTEON_DDR0_BASE    (0x0ULL)
+#define OCTEON_DDR0_SIZE    (0x010000000ULL)
+#define OCTEON_DDR1_SIZE    (0x010000000ULL)
+#define OCTEON_LINUX_RESERVED_MEM_NAME    "__tmp_reserved_linux"
+
+void cleanup_phy_mem(void)
+{
+	/* Ensure all memory is cleaned up.
+	 * Assume nothing has been put before the kernel
+	 * and assume that the kernel lands in the DDR0 region
+	 */
+	uint64_t freemem;
+	struct cvmx_sysinfo *sysinfo;
+	uint64_t memory;
+	uint64_t kernel_size;
+	uint64_t delta;
+	uint64_t curr_addr;
+
+	/* get the amount of DRAM on the board */
+	sysinfo = cvmx_sysinfo_get();
+	memory = sysinfo->system_dram_size;
+
+	/* do a few calculations */
+	kernel_size = (uint64_t)__bss_stop - (uint64_t)_text;
+	freemem = cvmx_bootmem_phy_available_mem(0x100000);
+	delta = (memory > freemem ? (memory - freemem) : (freemem - memory));
+
+	if (delta < MAX_MEMORY) {
+		/* we haven't allocated any memory yet = no need to
+		 * continue free'ing
+		 */
+		printk(KERN_NOTICE "...no need to free any memory\n");
+		return;
+	}
+
+	/* calculate the current address which is the next address after
+	 * the end of the kernel, on a boundary of 0x100000 (1MB)
+	 * the shift needs to match the value used in plat_mem_setup()
+	 */
+	curr_addr = (uint64_t)__bss_stop;
+	curr_addr &= 0x7fffffffULL;
+	curr_addr = curr_addr >> 20;
+	curr_addr += 1;
+	curr_addr = curr_addr << 20;
+
+	memory -= kernel_size;
+
+	if (memory <= (OCTEON_DDR0_SIZE - curr_addr)) {
+		__cvmx_bootmem_phy_free(curr_addr, memory, 0);
+	} else {
+		__cvmx_bootmem_phy_free(curr_addr,
+			OCTEON_DDR0_SIZE - curr_addr, 0);
+
+		memory -= (OCTEON_DDR0_SIZE);
+
+		if (memory > OCTEON_DDR1_SIZE) {
+			__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE,
+				OCTEON_DDR1_SIZE, 0);
+			__cvmx_bootmem_phy_free(OCTEON_DDR2_BASE,
+				memory - OCTEON_DDR1_SIZE, 0);
+		} else {
+			__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, memory, 0);
+		}
+	}
 }
 
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2
@@ -976,6 +1046,8 @@ void __init plat_mem_setup(void)
 	}
 #endif
 
+	cleanup_phy_mem();
+
 	if (named_memory_blocks[0][0]) {
 		/* Memory from named blocks only */
 		int i;
@@ -1018,7 +1090,7 @@ void __init plat_mem_setup(void)
 	 */
 	cvmx_bootmem_lock();
 	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
-		&& (total < MAX_MEMORY)) {
+		&& (total <= OCTEON_MAX_PHY_MEM_SIZE)) {
 #if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
 						__pa_symbol(&__init_end), -1,
@@ -1131,6 +1203,187 @@ void prom_free_prom_memory(void)
 	}
 }
 
+#ifdef CONFIG_KEXEC
+#ifdef CONFIG_SMP
+static cpumask_t kexec_cpus = CPU_MASK_NONE;
+
+static void octeon_kexec_shutdown_other_cpus(void *ignore)
+{
+	/* for each CPU except CPU0 go into a loop until we've relocated
+	 * the kernel and then jump to that page
+	 */
+	int cpu = smp_processor_id();
+	if (!cpu_online(cpu))
+		return;
+
+	local_irq_disable();
+
+	crash_save_cpu(task_pt_regs(current), cpu);
+
+	cpu_set(cpu, kexec_cpus);
+
+	while (!atomic_read(&kexec_ready_to_reboot)) {
+		cpu_relax();
+	}
+	relocated_kexec_smp_wait(NULL);
+}
+#endif /* CONFIG_SMP */
+
+/* USB shutdown hooks, overriden in octeon_usb_module_init() if
+ * CAVIUM_OCTEON_USB is configured in or when module is loaded */
+static void __shutdown_usb_ports(void) { /* do nothing */ }
+static void (*kexec_octeon_shutdown_usb_ports)(void) = __shutdown_usb_ports;
+void kexec_octeon_register_shutdown_usb_ports(void(*fn)(void))
+{
+	kexec_octeon_shutdown_usb_ports = fn;
+}
+void kexec_octeon_unregister_shutdown_usb_ports(void)
+{
+	kexec_octeon_shutdown_usb_ports = __shutdown_usb_ports;
+}
+
+static void octeon_kexec_shutdown(void)
+{
+#ifdef CONFIG_SMP
+	unsigned int msecs;
+	unsigned int ncpus;
+
+	/* proceed to shutdown the other CPUs */
+	ncpus = num_online_cpus() - 1; /* exclude this CPU */
+	cpus_clear(kexec_cpus);
+
+	printk(KERN_EMERG "Sending IPI to other cpus...\n");
+	if (smp_call_function(&octeon_kexec_shutdown_other_cpus, NULL, 0))
+		printk(KERN_EMERG "failed to send IPI\n");
+	smp_wmb();
+
+	msecs = 10000;
+	while ((cpus_weight(kexec_cpus) < ncpus) && (--msecs > 0)) {
+		cpu_relax();
+		mdelay(1);
+	}
+#endif /* CONFIG_SMP */
+
+	kexec_octeon_shutdown_usb_ports();
+}
+
+static void octeon_crash_shutdown(struct pt_regs *regs)
+{
+	crash_save_cpu(regs, smp_processor_id());
+#ifdef CONFIG_SMP
+	/* just use the normal shutdown() mechanism */
+	octeon_kexec_shutdown();
+#endif /* CONFIG_SMP */
+}
+
+/*
+ * the arguments passed into the new kernel
+ * kexec_args[0] = register a0 = argc
+ * kexec_args[1] = register a1 = argv at a kseg0 compatible address
+ * kexec_args[2] = register a2 = 1 if init core, zero otherwise
+ * kexec_args[3] = register a3 = address of boot descriptor block
+ */
+extern unsigned long kexec_args[4];
+#ifdef CONFIG_SMP
+extern unsigned long secondary_kexec_args[4];
+#endif /* CONFIG_SMP */
+
+static int octeon_kexec_prepare(struct kimage *kimage)
+{
+	unsigned long argv = 0;
+	int i = 0;
+	char *kbuf = NULL;
+	const unsigned long KBUF_SIZE = 1024;
+	int buflen = 0;
+	void *userbuf = NULL;
+	char *kexec = "kexec";
+
+	/* setup the boot descriptor pointer */
+	for (i = 0; i < OCTEON_ARGV_MAX_ARGS; i++) {
+		/* invalidate all entries in the boot ptr */
+		octeon_boot_desc_ptr->argv[i] = 0;
+	}
+	octeon_boot_desc_ptr->argc = 0;
+
+	/* get the argc and argv */
+	/* search through the source pages looking for a page that starts
+	 * with the string "kexec"
+	 */
+	kbuf = kmalloc(KBUF_SIZE, GFP_KERNEL);
+
+	/* find the cmdline buffer in the kimage */
+	for (i = 0; (!argv) && (i < kimage->nr_segments); i++) {
+		memset(kbuf, 0, KBUF_SIZE);
+		copy_from_user(kbuf, kimage->segment[i].buf,
+			(kimage->segment[i].bufsz > KBUF_SIZE ?
+			KBUF_SIZE :  kimage->segment[i].bufsz));
+
+		/* see if this buffer starts with "kexec" */
+		if (memcmp(kbuf, kexec, 5) == 0) {
+			/* this is the buffer */
+			userbuf = kimage->segment[i].buf;
+			argv = (unsigned long)kimage->segment[i].mem;
+		}
+	}
+
+	if (argv) {
+		char *p = kbuf;
+		int looking_for_space = 0;
+		/* argv is the location of argv at a kseg0 address */
+		kexec_args[1] = argv;
+
+		/* parse the buffer and copy into the boot descriptor */
+		while (*p) {
+			if (1 == looking_for_space) {
+				if (*p == ' ') {
+					looking_for_space = 0;
+					*p = '\0';
+				}
+			} else {
+				if (*p != ' ') {
+					/* found another token */
+					octeon_boot_desc_ptr->argv[(octeon_boot_desc_ptr->argc)++] = argv;
+					looking_for_space = 1;
+				} else {
+					*p = '\0';
+				}
+			}
+			p++;
+			argv++;
+		}
+
+		buflen = (int)(p - kbuf);
+		kexec_args[0] = octeon_boot_desc_ptr->argc;
+	}
+
+	/* now copy the modified cmdline buffer back to userspace */
+	copy_to_user(userbuf, kbuf, buflen);
+
+	if (kbuf)
+		kfree(kbuf);
+
+	/* setup the rest of the args */
+	kexec_args[2] = 1;
+	kexec_args[3] = (unsigned long)octeon_boot_desc_ptr;
+
+#ifdef CONFIG_SMP
+	/* copy the kexec_args to the secondary_args for the secondary
+	 * CPUs
+	 */
+	secondary_kexec_args[0] = kexec_args[0];
+	secondary_kexec_args[1] = kexec_args[1];
+	secondary_kexec_args[2] = 0; /* this is NOT the init core */
+	secondary_kexec_args[3] = kexec_args[3];
+#endif /* CONFIG_SMP */
+
+	return 0;
+}
+
+EXPORT_SYMBOL(kexec_octeon_register_shutdown_usb_ports);
+EXPORT_SYMBOL(kexec_octeon_unregister_shutdown_usb_ports);
+
+#endif /* CONFIG_KEXEC */
+
 int octeon_prune_device_tree(void);
 
 extern const char __dtb_octeon_3xxx_begin;
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 89f1672..3f18297 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -535,6 +535,11 @@ void cvmx_bootmem_lock(void);
 void cvmx_bootmem_unlock(void);
 
 /**
+ * Queries the available physical memory from the bootmem allocator
+ */
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size);
+
+/**
  * Internal use function to get the current descriptor pointer */
 void *__cvmx_bootmem_internal_get_desc_ptr(void);
 
diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 8c19cfd..d5c3bae 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
 obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
 obj-${CONFIG_OCTEON_ETHERNET} +=  octeon-ethernet.o
 obj-${CONFIG_OCTEON_ETHERNET_MEM} += ethernet-mem.o
+obj-${CONFIG_KEXEC} +=  octeon-kexec-net.o
 
 octeon-ethernet-objs := ethernet.o
 octeon-ethernet-objs += ethernet-mdio.o
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index c86b943..2bd1f87 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -859,6 +859,10 @@ static struct device_node * __devinit cvm_oct_node_for_port(struct device_node *
 	return np;
 }
 
+#ifdef CONFIG_KEXEC
+extern void octeon_shutdown_network_hw(void);
+#endif
+
 static int __devinit cvm_oct_probe(struct platform_device *pdev)
 {
 	int num_interfaces;
@@ -867,6 +871,11 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 	int qos, r;
 	struct device_node *pip;
 
+#ifdef CONFIG_KEXEC
+	printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
+	if (reset_devices)
+		octeon_shutdown_network_hw();
+#endif
 	octeon_mdiobus_force_mod_depencency();
 	pr_notice("octeon-ethernet %s\n", OCTEON_ETHERNET_VERSION);
 
diff --git a/drivers/net/ethernet/octeon/octeon-kexec-net.c b/drivers/net/ethernet/octeon/octeon-kexec-net.c
new file mode 100644
index 0000000..847ec5d
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-kexec-net.c
@@ -0,0 +1,114 @@
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon-model.h>
+#include <asm/octeon/cvmx-agl-defs.h>
+#include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-mixx-defs.h>
+#include <linux/netdevice.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-config.h>
+#include <asm/octeon/cvmx-fpa-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-pow.h>
+
+void octeon_shutdown_network_hw(void)
+{
+	cvmx_helper_link_info_t link_info;
+	cvmx_wqe_t *work = NULL;
+	int ipd_port = 0;
+	int num_ints = 0;
+	int interface = 0;
+	int num_ports = 0;
+	int port = 0;
+	union cvmx_pko_reg_flags pko_reg_flags;
+	union cvmx_fpa_ctl_status fpa_status;
+	union cvmx_smix_en smix_en;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+	union cvmx_pip_sft_rst pip_sft_rst;
+
+	/* free up the work queue associated with this core */
+	work = cvmx_pow_get_current_wqp();
+	if (NULL != work) {
+		/* drain the work queue and free it */
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* halt the interfaces */
+	num_ints = cvmx_helper_get_number_of_interfaces();
+	if (num_ints > 2)
+		num_ints = 2;
+
+	/* Check to see what interface and ports we should use */
+	for (interface = 0; interface < num_ints; interface++) {
+		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
+			cvmx_helper_interface_get_mode(interface)) ||
+			(CVMX_HELPER_INTERFACE_MODE_GMII ==
+				cvmx_helper_interface_get_mode(interface))) {
+			/* get the ports for this interface */
+			cvmx_helper_interface_probe(interface);
+			num_ports = cvmx_helper_ports_on_interface(interface);
+
+			for (port = 0; port < num_ports; port++) {
+				ipd_port = cvmx_helper_get_ipd_port(interface, port);
+
+				link_info = cvmx_helper_link_get(ipd_port);
+				link_info.s.link_up = 0;
+				cvmx_helper_link_set(ipd_port, link_info);
+			}
+		}
+	}
+
+	/* disable the SMI */
+	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
+	if (smix_en.s.en) {
+		smix_en.s.en = 0;
+		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
+	}
+
+	/* Newer chips actually have two SMI/MDIO interfaces */
+	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN58XX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
+		if (smix_en.s.en) {
+			smix_en.s.en = 0;
+			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
+		}
+	}
+
+	/* Reset the IPD to get all buffers out of it */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.reset = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	/* Reset the PIP */
+	pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
+	pip_sft_rst.s.rst = 1;
+	cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
+
+	/* disable the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.ena_pko = 0;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* reset the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.reset = 1;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* disable the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.enb = 0;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* reset the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.reset = 1;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* free the cvmx_cmd_queues from bootmemory */
+	cvmx_bootmem_free_named("cvmx_cmd_queues");
+}
-- 
1.7.5.4

