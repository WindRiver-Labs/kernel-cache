From 4fdb0bbb170d2320c6e82d230a5e3fdda9ad5705 Mon Sep 17 00:00:00 2001
From: Arnaud Blanchard <arnaud.blanchard@windriver.com>
Date: Fri, 4 Jul 2014 09:38:47 +0200
Subject: [PATCH] gpio-nct6776.ko kernel module Add support of GPIO on BCM
 NI255 board GPIO block 7 are exported on this Motherboard
 (connector JDI01).

NCT6776 is a SuperIO chip in IO space responsible of lot of features
(fan, Voltage control, serial, LPT, etc...) and some GPIO could be exported for user.
Once the driver loaded it can be used as any GPIO, using sys/class/gpio sysfs folders
if GPIO_SYSFS option is enabled in Kernel.

Signed-off-by: Arnaud Blanchard <arnaud.blanchard@windriver.com>
---
 drivers/gpio/Kconfig        |    6 +
 drivers/gpio/Makefile       |    1 +
 drivers/gpio/gpio-nct6776.c |  446 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 453 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpio/gpio-nct6776.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 09d82d4..530b445 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -91,6 +91,12 @@ config GPIO_IT8761E
 	help
 	  Say yes here to support GPIO functionality of IT8761E super I/O chip.
 
+config GPIO_NCT6776
+	tristate "NCT6776 GPIO support"
+	depends on X86  # unconditional access to IO space.
+	help
+	  Say yes here to support GPIO functionality of NCT6776 super I/O chip.
+
 config GPIO_EM
 	tristate "Emma Mobile GPIO"
 	depends on ARM
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 20d4c45..add02f6 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -69,3 +69,4 @@ obj-$(CONFIG_GPIO_WM831X)	+= gpio-wm831x.o
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
+obj-$(CONFIG_GPIO_NCT6776)	+= gpio-nct6776.o
diff --git a/drivers/gpio/gpio-nct6776.c b/drivers/gpio/gpio-nct6776.c
new file mode 100644
index 0000000..987c5d4
--- /dev/null
+++ b/drivers/gpio/gpio-nct6776.c
@@ -0,0 +1,446 @@
+/*
+ * GPIO driver for NCT6776
+ *
+ * Copyright (C) 2014 Wind River
+ *
+ * Author: Arnaud Blanchard <arnaud.blanchard@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+
+#define DRVNAME "gpio-nct6776"
+
+/*
+ * Super-I/O registers
+ */
+#define SIO_LDSEL		0x07	/* Logical device select */
+#define SIO_DEVID		0x20	/* Device ID (2 bytes) */
+
+
+#define SIO_LD_GPIO		0x07    /* GPIO logical device */
+
+
+#define SIO_UNLOCK_KEY		0x87	/* Key to enable Super-I/O */
+#define SIO_LOCK_KEY		0xAA	/* Key to disable Super-I/O */
+
+#define SIO_NCT6776		0xC333
+
+enum chips { nct6776 };
+
+static const char * const nct6776_names[] = {
+	"nct6776",
+};
+
+struct nct6776_sio {
+	int addr;
+	enum chips type;
+};
+
+struct nct6776_gpio_bank {
+	struct gpio_chip chip;
+	unsigned int regbase;
+	struct nct6776_gpio_data *data;
+};
+
+struct nct6776_gpio_data {
+	struct nct6776_sio *sio;
+	int nr_bank;
+	struct nct6776_gpio_bank *bank;
+};
+
+/*
+ * Super-I/O functions.
+ */
+
+static inline int superio_inb(int base, int reg)
+{
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static int superio_inw(int base, int reg)
+{
+	int val;
+
+	outb(reg++, base);
+	val = inb(base + 1) << 8;
+	outb(reg, base);
+	val |= inb(base + 1);
+
+	return val;
+}
+
+static inline void superio_outb(int base, int reg, int val)
+{
+	outb(reg, base);
+	outb(val, base + 1);
+}
+
+static inline int superio_enter(int base)
+{
+	/* Don't step on other drivers' I/O space by accident. */
+	if (!request_muxed_region(base, 2, DRVNAME)) {
+		pr_err(DRVNAME "I/O address 0x%04x already in use\n", base);
+		return -EBUSY;
+	}
+
+	outb(SIO_UNLOCK_KEY, base);
+	outb(SIO_UNLOCK_KEY, base);
+
+	return 0;
+}
+
+static inline void superio_select(int base, int ld)
+{
+	printk(KERN_INFO "superio_select(int 0x%x, int 0x%x)\n", base, ld);
+	outb(SIO_LDSEL, base);
+	outb(ld, base + 1);
+}
+
+static inline void superio_exit(int base)
+{
+	outb(SIO_LOCK_KEY, base);
+	outb(0x02, base);
+	outb(0x02, base+1);
+	release_region(base, 2);
+}
+
+/*
+ * GPIO chip.
+ */
+
+static int nct6776_gpio_direction_in(struct gpio_chip *chip, unsigned offset);
+static int nct6776_gpio_get(struct gpio_chip *chip, unsigned offset);
+static int nct6776_gpio_direction_out(struct gpio_chip *chip,
+				      unsigned offset, int value);
+static void nct6776_gpio_set(struct gpio_chip *chip,
+			     unsigned offset, int value);
+
+#define NCT6776_GPIO_BANK(_base, _ngpio, _regbase)			\
+	{								\
+		.chip = {						\
+			.label            = DRVNAME,			\
+			.owner            = THIS_MODULE,		\
+			.direction_input  = nct6776_gpio_direction_in,	\
+			.get              = nct6776_gpio_get,		\
+			.direction_output = nct6776_gpio_direction_out,	\
+			.set              = nct6776_gpio_set,		\
+			.base             = _base,			\
+			.ngpio            = _ngpio,			\
+		},							\
+		.regbase = _regbase,					\
+	}
+
+#define gpio_dir(base) (base + 0)
+#define gpio_data_out(base) (base + 1)
+#define gpio_data_in(base) (base + 1)
+
+/* NCT6776 need to be active Cr27[6] Cr27[6] to be set */
+/* Logical DEvice 9 : Cr30[7] to be set */
+/* But it's done by Bios */
+static struct nct6776_gpio_bank nct6776_gpio_bank[] = {
+	NCT6776_GPIO_BANK(0 , 8, 0xE0),
+};
+
+static int nct6776_gpio_direction_in(struct gpio_chip *chip, unsigned offset)
+{
+	int err;
+	struct nct6776_gpio_bank *bank =
+		container_of(chip, struct nct6776_gpio_bank, chip);
+	struct nct6776_sio *sio = bank->data->sio;
+	u8 dir;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return err;
+	superio_select(sio->addr, SIO_LD_GPIO);
+
+	dir = superio_inb(sio->addr, gpio_dir(bank->regbase));
+	dir &= ~(1 << offset);
+	superio_outb(sio->addr, gpio_dir(bank->regbase), dir);
+
+	superio_exit(sio->addr);
+
+	return 0;
+}
+
+static int nct6776_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int err;
+	struct nct6776_gpio_bank *bank =
+		container_of(chip, struct nct6776_gpio_bank, chip);
+	struct nct6776_sio *sio = bank->data->sio;
+	u8 dir, data;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return err;
+	superio_select(sio->addr, SIO_LD_GPIO);
+
+	dir = superio_inb(sio->addr, gpio_dir(bank->regbase));
+	dir = !!(dir & (1 << offset));
+	if (dir)
+		data = superio_inb(sio->addr, gpio_data_out(bank->regbase));
+	else
+		data = superio_inb(sio->addr, gpio_data_in(bank->regbase));
+
+	superio_exit(sio->addr);
+
+	return !!(data & 1 << offset);
+}
+
+static int nct6776_gpio_direction_out(struct gpio_chip *chip,
+				     unsigned offset, int value)
+{
+	int err;
+	struct nct6776_gpio_bank *bank =
+		container_of(chip, struct nct6776_gpio_bank, chip);
+	struct nct6776_sio *sio = bank->data->sio;
+	u8 dir, data_out;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return err;
+	superio_select(sio->addr, SIO_LD_GPIO);
+
+	data_out = superio_inb(sio->addr, gpio_data_out(bank->regbase));
+	if (value)
+		data_out |= (1 << offset);
+	else
+		data_out &= ~(1 << offset);
+	superio_outb(sio->addr, gpio_data_out(bank->regbase), data_out);
+
+	dir = superio_inb(sio->addr, gpio_dir(bank->regbase));
+	dir |= (1 << offset);
+	superio_outb(sio->addr, gpio_dir(bank->regbase), dir);
+
+	superio_exit(sio->addr);
+
+	return 0;
+}
+
+static void nct6776_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	int err;
+	struct nct6776_gpio_bank *bank =
+		container_of(chip, struct nct6776_gpio_bank, chip);
+	struct nct6776_sio *sio = bank->data->sio;
+	u8 data_out;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return;
+	superio_select(sio->addr, SIO_LD_GPIO);
+
+	data_out = superio_inb(sio->addr, gpio_data_out(bank->regbase));
+	if (value)
+		data_out |= (1 << offset);
+	else
+		data_out &= ~(1 << offset);
+	superio_outb(sio->addr, gpio_data_out(bank->regbase), data_out);
+
+	superio_exit(sio->addr);
+}
+
+/*
+ * Platform device and driver.
+ */
+
+static int nct6776_gpio_probe(struct platform_device *pdev)
+{
+	int err;
+	int i;
+	struct nct6776_sio *sio = pdev->dev.platform_data;
+	struct nct6776_gpio_data *data;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	switch (sio->type) {
+	case nct6776:
+		data->nr_bank = ARRAY_SIZE(nct6776_gpio_bank);
+		data->bank = nct6776_gpio_bank;
+		break;
+	default:
+		return -ENODEV;
+	}
+	data->sio = sio;
+
+	platform_set_drvdata(pdev, data);
+
+	/* For each GPIO bank, register a GPIO chip. */
+	for (i = 0; i < data->nr_bank; i++) {
+		struct nct6776_gpio_bank *bank = &data->bank[i];
+
+		bank->chip.dev = &pdev->dev;
+		bank->data = data;
+
+		err = gpiochip_add(&bank->chip);
+		if (err) {
+			dev_err(&pdev->dev,
+				"Failed to register gpiochip %d: %d\n",
+				i, err);
+			goto err_gpiochip;
+		}
+	}
+
+	return 0;
+
+err_gpiochip:
+	for (i = i - 1; i >= 0; i--) {
+		struct nct6776_gpio_bank *bank = &data->bank[i];
+		int tmp;
+
+		tmp = gpiochip_remove(&bank->chip);
+		if (tmp < 0)
+			dev_err(&pdev->dev,
+				"Failed to remove gpiochip %d: %d\n",
+				i, tmp);
+	}
+
+	return err;
+}
+
+static int nct6776_gpio_remove(struct platform_device *pdev)
+{
+	int err;
+	int i;
+	struct nct6776_gpio_data *data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < data->nr_bank; i++) {
+		struct nct6776_gpio_bank *bank = &data->bank[i];
+
+		err = gpiochip_remove(&bank->chip);
+		if (err) {
+			dev_err(&pdev->dev,
+				"Failed to remove GPIO gpiochip %d: %d\n",
+				i, err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int __init nct6776_find(int addr, struct nct6776_sio *sio)
+{
+	int err;
+	u16 devid;
+
+	err = superio_enter(addr);
+	if (err)
+		return err;
+
+	err = -ENODEV;
+
+	devid = superio_inw(addr, SIO_DEVID);
+
+	switch (devid) {
+	case SIO_NCT6776:
+		sio->type = nct6776;
+		break;
+
+	default:
+		pr_info(DRVNAME ": Unsupported NCT device 0x%04x\n", devid);
+		goto err;
+	}
+	sio->addr = addr;
+	err = 0;
+
+	pr_info(DRVNAME ": Found %s at %#x\n",
+		nct6776_names[sio->type],
+		(unsigned int) addr);
+
+err:
+	superio_exit(addr);
+	return err;
+}
+
+static struct platform_device *nct6776_gpio_pdev;
+
+static int __init
+nct6776_gpio_device_add(const struct nct6776_sio *sio)
+{
+	int err;
+
+	nct6776_gpio_pdev = platform_device_alloc(DRVNAME, -1);
+	if (!nct6776_gpio_pdev)
+		return -ENOMEM;
+
+	err = platform_device_add_data(nct6776_gpio_pdev,
+				       sio, sizeof(*sio));
+	if (err) {
+		pr_err(DRVNAME "Platform data allocation failed\n");
+		goto err;
+	}
+
+	err = platform_device_add(nct6776_gpio_pdev);
+	if (err) {
+		pr_err(DRVNAME "Device addition failed\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	platform_device_put(nct6776_gpio_pdev);
+
+	return err;
+}
+
+/*
+ * Try to match a supported NCT device by reading the (hard-wired)
+ * configuration I/O ports. If available, then register both the platform
+ * device and driver to support the GPIOs.
+ */
+
+static struct platform_driver nct6776_gpio_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= DRVNAME,
+	},
+	.probe		= nct6776_gpio_probe,
+	.remove		= nct6776_gpio_remove,
+};
+
+static int __init nct6776_gpio_init(void)
+{
+	int err;
+	struct nct6776_sio sio;
+
+	if (nct6776_find(0x2E, &sio) &&
+	    nct6776_find(0x44, &sio))
+		return -ENODEV;
+
+	err = platform_driver_register(&nct6776_gpio_driver);
+	if (!err) {
+		err = nct6776_gpio_device_add(&sio);
+		if (err)
+			platform_driver_unregister(&nct6776_gpio_driver);
+	}
+
+	return err;
+}
+subsys_initcall(nct6776_gpio_init);
+
+static void __exit nct6776_gpio_exit(void)
+{
+	platform_device_unregister(nct6776_gpio_pdev);
+	platform_driver_unregister(&nct6776_gpio_driver);
+}
+module_exit(nct6776_gpio_exit);
+
+MODULE_DESCRIPTION("GPIO driver for Super-I/O chips NCT6776F");
+MODULE_AUTHOR("Arnaud Blanchard <arnaud.blanchard@windriver.com>");
+MODULE_LICENSE("GPL");
+
-- 
1.7.5.4

