From 4c3dcaef7283ce8cd386e4de95bbc52190b3f3ab Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Thu, 8 Aug 2013 10:33:40 +0800
Subject: [PATCH 101/134] ACPI / scan: Make namespace scanning and trimming
 mutually exclusive

upstream: c511cc1990bbc263c3f8a2ef4d7d613a3b40ffe2

There is no guarantee that acpi_bus_scan() and acpi_bus_trim() will
not be run in parallel for the same scope of the ACPI namespace,
which may lead to a great deal of confusion, so introduce a new mutex
to prevent that from happening.
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/scan.c |   49 ++++++++++++++++++++++++++++---------------------
 1 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5f01427..c0443dfc 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -41,6 +41,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
+static DEFINE_MUTEX(acpi_scan_lock);
 DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
@@ -1489,28 +1490,21 @@ static acpi_status acpi_bus_probe_start(acpi_handle handle, u32 lvl,
 int acpi_bus_scan(acpi_handle handle)
 {
 	void *device = NULL;
-	acpi_status status;
-	int ret = -ENODEV;
+	int error = 0;
 
-	status = acpi_bus_check_add(handle, 0, ops, &device);
-	if (ACPI_SUCCESS(status))
+	mutex_lock(&acpi_scan_lock);
+	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_check_add, NULL, ops, &device);
+				    acpi_bus_check_add, NULL, NULL, &device);
 
 	if (!device)
-		goto out;
-
-	ret = 0;
-	status = acpi_bus_probe_start(handle, 0, ops, NULL);
-	if (ACPI_SUCCESS(status))
+		error = -ENODEV;
+	else if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_probe_start, NULL, ops, NULL);
+				    acpi_bus_device_attach, NULL, NULL, NULL);
 
- out:
-	if (child)
-		*child = device;
-
-	return ret;
+	mutex_unlock(&acpi_scan_lock);
+	return error;
 }
 EXPORT_SYMBOL(acpi_bus_scan);
 
@@ -1548,6 +1542,8 @@ static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 
 void acpi_bus_trim(struct acpi_device *start)
 {
+	mutex_lock(&acpi_scan_lock);
+
 	/*
 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
 	 * all ACPI drivers from the device nodes being removed.
@@ -1562,6 +1558,8 @@ void acpi_bus_trim(struct acpi_device *start)
 	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 			    acpi_bus_remove, NULL, NULL);
 	acpi_bus_remove(start->handle, 0, NULL, NULL);
+
+	mutex_unlock(&acpi_scan_lock);
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
@@ -1602,18 +1600,27 @@ int __init acpi_scan_init(void)
 
 	acpi_csrt_init();
 
+	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
 	result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+	if (result)
+		goto out;
 
-	if (!result)
-		result = acpi_bus_scan_fixed();
-
+	result = acpi_bus_get_device(ACPI_ROOT_OBJECT, &acpi_root);
 	if (result)
+		goto out;
+
+	result = acpi_bus_scan_fixed();
+	if (result) {
 		acpi_device_unregister(acpi_root);
-	else
-		acpi_update_all_gpes();
+		goto out;
+	}
 
+	acpi_update_all_gpes();
+
+ out:
+	mutex_unlock(&acpi_scan_lock);
 	return result;
 }
-- 
1.7.5.4

