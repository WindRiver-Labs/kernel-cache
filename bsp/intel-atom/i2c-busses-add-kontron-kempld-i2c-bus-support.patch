From e946402fbb6e29203c41002eb9a4e113ce09dc20 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Tue, 5 Jun 2012 10:23:23 +0800
Subject: [PATCH 03/11] i2c/busses: add kontron kempld i2c bus support

Source: SDK 1.6 for Kontron M2M Smart Services Developer Kit

The I2C bus interface on some ETX/ETXexpress modules for kbc_m2m806.

Signed-off-by: Michael Brunner <michael.brunner@kontron.com>
Integrated-by: Yang Wei <wei.yang@windriver.com>
---
 drivers/i2c/busses/Kconfig      |   10 +
 drivers/i2c/busses/Makefile     |    1 +
 drivers/i2c/busses/i2c-kempld.c |  398 +++++++++++++++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-kempld.h |   79 ++++++++
 include/linux/i2c/pca953x.h     |    4 +
 5 files changed, 492 insertions(+)
 create mode 100644 drivers/i2c/busses/i2c-kempld.c
 create mode 100644 drivers/i2c/busses/i2c-kempld.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 87d683e..3548e2f 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -7,6 +7,16 @@ menu "I2C Hardware Bus support"
 comment "PC SMBus host controller drivers"
 	depends on PCI
 
+config I2C_KEMPLD
+       tristate "Kontron COM I2C"
+       depends on MFD_KEMPLD
+       help
+         This enables support for the I2C bus interface on some ETX/ETXexpress
+         modules.
+
+         This driver can also be built as a module. If so, the module
+         will be called i2c-kempld.
+
 config I2C_ALI1535
 	tristate "ALI 1535"
 	depends on PCI
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index f76625e..7121a11 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -5,6 +5,7 @@
 # ACPI drivers
 obj-$(CONFIG_I2C_SCMI)		+= i2c-scmi.o
 
+obj-$(CONFIG_I2C_KEMPLD)	+= i2c-kempld.o
 # PC SMBus host controller drivers
 obj-$(CONFIG_I2C_ALI1535)	+= i2c-ali1535.o
 obj-$(CONFIG_I2C_ALI1563)	+= i2c-ali1563.o
diff --git a/drivers/i2c/busses/i2c-kempld.c b/drivers/i2c/busses/i2c-kempld.c
new file mode 100644
index 0000000..ca1f5ee
--- /dev/null
+++ b/drivers/i2c/busses/i2c-kempld.c
@@ -0,0 +1,398 @@
+/*
+ *  i2c-kempld.c: I2C bus driver for Kontron COM modules
+ *
+ *  Copyright (c) 2010 Kontron Embedded Modules GmbH
+ *  Author: Michael Brunner <michael.brunner@kontron.com>
+ *
+ *  The driver is based on the i2c-ocores driver by Peter Korsgaard.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/mfd/kempld.h>
+
+#include "i2c-kempld.h"
+
+static int scl_frequency;	/* 0 = don't change */
+module_param(scl_frequency, int, 0);
+MODULE_PARM_DESC(scl_frequency,
+		 "Set I2C SCL frequency (0=don't change, otherwise kHz, "
+		 "default=0)");
+static int i2c_mx_bus = -1;
+module_param(i2c_mx_bus, int, 0);
+MODULE_PARM_DESC(i2c_mx_bus, "Set I2C MX bus (0-16, default=-1 (FW default))");
+
+static int kempld_i2c_process(struct kempld_i2c_data *i2c)
+{
+	struct kempld_device_data *pld = i2c->pld;
+	struct i2c_msg *msg = i2c->msg;
+	u8 stat = kempld_read8(pld, KEMPLD_I2C_STATUS);
+
+	/* ready? */
+	if (stat & OCI2C_STAT_TIP)
+		return -EBUSY;
+
+	if ((i2c->state == STATE_DONE) || (i2c->state == STATE_ERROR)) {
+		/* stop has been sent */
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_IACK);
+		return -EIO;
+	}
+
+	/* error? */
+	if (stat & OCI2C_STAT_ARBLOST) {
+		i2c->state = STATE_ERROR;
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_STOP);
+		return -EAGAIN;
+	}
+
+	if (i2c->state == STATE_INIT) {
+		/* check if bus is free */
+		if (stat & OCI2C_STAT_BUSY)
+			return -EBUSY;
+
+		i2c->state = STATE_ADDR;
+	}
+
+	if (i2c->state == STATE_ADDR) {
+		u8 addr;
+		/* 10 bit address? */
+		if (i2c->msg->flags & I2C_M_TEN) {
+			addr = 0xf0 | ((i2c->msg->addr >> 7) & 0x6);
+			i2c->state = STATE_ADDR10;
+		} else {
+			addr = (i2c->msg->addr << 1);
+			i2c->state = STATE_START;
+		}
+
+		/* set read bit if necessary */
+		addr |= (i2c->msg->flags & I2C_M_RD) ? 1 : 0;
+
+		kempld_write8(pld, KEMPLD_I2C_DATA, addr);
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_START);
+
+		return 0;
+	}
+
+	/* second part of 10 bit addressing */
+	if (i2c->state == STATE_ADDR10) {
+		kempld_write8(pld, KEMPLD_I2C_DATA, i2c->msg->addr & 0xff);
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_WRITE);
+
+		i2c->state = STATE_START;
+		return 0;
+	}
+
+	if ((i2c->state == STATE_START) || (i2c->state == STATE_WRITE)) {
+		i2c->state = (msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;
+
+		if (stat & OCI2C_STAT_NACK) {
+			i2c->state = STATE_ERROR;
+			kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_STOP);
+			return -ENXIO;
+		}
+	} else
+		msg->buf[i2c->pos++] = kempld_read8(pld, KEMPLD_I2C_DATA);
+
+	/* end of msg? */
+	if (i2c->pos >= msg->len) {
+		i2c->nmsgs--;
+		i2c->msg++;
+		i2c->pos = 0;
+		msg = i2c->msg;
+
+		if (i2c->nmsgs) {	/* end? */
+			/* send start? */
+			if (!(msg->flags & I2C_M_NOSTART)) {
+				i2c->state = STATE_ADDR;
+				return 0;
+			} else
+				i2c->state = (msg->flags & I2C_M_RD)
+				    ? STATE_READ : STATE_WRITE;
+		} else {
+			i2c->state = STATE_DONE;
+			kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_STOP);
+			return 0;
+		}
+	}
+
+	if (i2c->state == STATE_READ) {
+		kempld_write8(pld, KEMPLD_I2C_CMD, i2c->pos == (msg->len - 1) ?
+			      OCI2C_CMD_READ_NACK : OCI2C_CMD_READ_ACK);
+	} else {
+		kempld_write8(pld, KEMPLD_I2C_DATA, msg->buf[i2c->pos++]);
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_WRITE);
+	}
+
+	return 0;
+}
+
+static int kempld_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+			   int num)
+{
+	struct kempld_i2c_data *i2c = i2c_get_adapdata(adap);
+	struct kempld_device_data *pld = i2c->pld;
+	unsigned long timeout = jiffies + HZ;
+	int ret;
+
+	i2c->msg = msgs;
+	i2c->pos = 0;
+	i2c->nmsgs = num;
+	i2c->state = STATE_INIT;
+
+	/* handle the transfer */
+	while (time_before(jiffies, timeout)) {
+		kempld_get_mutex_set_index(pld, KEMPLD_I2C_STATUS);
+		ret = kempld_i2c_process(i2c);
+		kempld_release_mutex(pld);
+
+		if ((i2c->state == STATE_DONE)
+		    || (i2c->state == STATE_ERROR)) {
+			return (i2c->state == STATE_DONE) ? i2c->nmsgs : ret;
+		}
+
+		if (ret == 0)
+			timeout = jiffies + HZ;
+
+		udelay(10);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void kempld_i2c_device_init(struct kempld_i2c_data *i2c)
+{
+	struct kempld_device_data *pld = i2c->pld;
+	u16 prescale;
+	u8 ctrl;
+	u8 stat;
+	u8 mx;
+
+	kempld_get_mutex_set_index(pld, KEMPLD_I2C_CONTROL);
+
+	ctrl = kempld_read8(pld, KEMPLD_I2C_CONTROL);
+	if (ctrl & OCI2C_CTRL_EN)
+		i2c->was_active = 1;
+
+	/* set bus frequency */
+	if (scl_frequency > 0) {
+		/* make sure the device is disabled */
+		ctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);
+		kempld_write8(pld, KEMPLD_I2C_CONTROL, ctrl);
+
+		prescale = (pld->pld_clock / (scl_frequency * 5000)) - 1;
+
+		kempld_write8(pld, KEMPLD_I2C_PRELOW, prescale & 0xff);
+		kempld_write8(pld, KEMPLD_I2C_PREHIGH, prescale >> 8);
+	}
+
+	/* enable the device */
+	kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_IACK);
+	ctrl |= OCI2C_CTRL_EN;
+	kempld_write8(pld, KEMPLD_I2C_CONTROL, ctrl);
+
+	/* If bus is busy send a STOP signal to be sure the controller is
+	 * not hanging... */
+	stat = kempld_read8(pld, KEMPLD_I2C_STATUS);
+	if (stat & OCI2C_STAT_BUSY) {
+		dev_warn(pld->dev, "I2C bus is busy - generating stop signal");
+		kempld_write8(pld, KEMPLD_I2C_CMD, OCI2C_CMD_STOP);
+	}
+
+	/* Check which MX setting should be set */
+	if (i2c_mx_bus == -1) {
+		i2c->mx = kempld_read8(pld, KEMPLD_I2C_MX)
+		    & KEMPLD_I2C_MX_MASK;
+		kempld_write8(pld, KEMPLD_I2C_MX, i2c->mx);
+	} else {
+		i2c->mx = i2c_mx_bus;
+	}
+
+	/* Connect the controller to the choosen bus output */
+	mx = kempld_read8(pld, KEMPLD_I2C_MX) & ~KEMPLD_I2C_MX_MASK;
+	kempld_write8(pld, KEMPLD_I2C_MX, mx | i2c->mx);
+
+	kempld_release_mutex(pld);
+}
+
+static u32 kempld_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm kempld_i2c_algorithm = {
+	.master_xfer = kempld_i2c_xfer,
+	.functionality = kempld_i2c_func,
+};
+
+static struct i2c_adapter kempld_i2c_adapter = {
+	.owner = THIS_MODULE,
+	.name = "i2c-kempld",
+	.class = I2C_CLASS_HWMON | I2C_CLASS_SPD,
+	.algo = &kempld_i2c_algorithm,
+};
+
+static int kempld_i2c_get_scl_frequency(struct kempld_i2c_data *i2c)
+{
+	struct kempld_device_data *pld = i2c->pld;
+	int frequency;
+	u16 prescale;
+
+	kempld_get_mutex_set_index(pld, KEMPLD_I2C_PRELOW);
+
+	prescale = kempld_read8(pld, KEMPLD_I2C_PRELOW)
+	    | kempld_read8(pld, KEMPLD_I2C_PREHIGH) << 8;
+
+	kempld_release_mutex(pld);
+
+	frequency = (pld->pld_clock / (prescale + 1)) / 5000;
+
+	return frequency;
+}
+
+static int __devinit kempld_i2c_probe(struct platform_device *pdev)
+{
+	struct kempld_i2c_data *i2c;
+	struct kempld_device_data *pld;
+	int ret;
+
+	pld = dev_get_drvdata(pdev->dev.parent);
+
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	i2c->pld = pld;
+
+	kempld_i2c_device_init(i2c);
+
+	/* hook up driver to tree */
+	platform_set_drvdata(pdev, i2c);
+	i2c->adap = kempld_i2c_adapter;
+	i2c_set_adapdata(&i2c->adap, i2c);
+	i2c->adap.dev.parent = &pdev->dev;
+
+	/* add i2c adapter to i2c tree */
+	ret = i2c_add_adapter(&i2c->adap);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add adapter");
+		goto add_adapter_failed;
+	}
+
+	dev_info(pld->dev, "I2C bus initialized with %d kHz SCL frequency and "
+		 "controller connected to bus %d",
+		 kempld_i2c_get_scl_frequency(i2c), i2c->mx);
+
+	return 0;
+
+add_adapter_failed:
+	kfree(i2c);
+
+	return ret;
+}
+
+static int __devexit kempld_i2c_remove(struct platform_device *pdev)
+{
+	struct kempld_i2c_data *i2c = platform_get_drvdata(pdev);
+	struct kempld_device_data *pld = i2c->pld;
+	u8 ctrl;
+
+	if (!i2c->was_active) {
+		/* disable i2c logic if it was not activated before the
+		 * driver loaded */
+		kempld_get_mutex_set_index(pld, KEMPLD_I2C_CONTROL);
+		ctrl = kempld_read8(pld, KEMPLD_I2C_CONTROL);
+		ctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);
+		kempld_write8(pld, KEMPLD_I2C_CONTROL, ctrl);
+		kempld_release_mutex(pld);
+	}
+
+	/* remove adapter & data */
+	i2c_del_adapter(&i2c->adap);
+	platform_set_drvdata(pdev, NULL);
+
+	kfree(i2c);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int kempld_i2c_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct kempld_i2c_data *i2c = platform_get_drvdata(pdev);
+	struct kempld_device_data *pld = i2c->pld;
+	u8 ctrl;
+
+	/* make sure the device is disabled */
+	kempld_get_mutex_set_index(pld, KEMPLD_I2C_CONTROL);
+	ctrl = kempld_read8(pld, KEMPLD_I2C_CONTROL);
+	ctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);
+	kempld_write8(pld, KEMPLD_I2C_CONTROL, ctrl);
+	kempld_release_mutex(pld);
+
+	return 0;
+}
+
+static int kempld_i2c_resume(struct platform_device *pdev)
+{
+	struct kempld_i2c_data *i2c = platform_get_drvdata(pdev);
+
+	kempld_i2c_device_init(i2c);
+
+	return 0;
+}
+#else
+#define kempld_i2c_suspend	NULL
+#define kempld_i2c_resume	NULL
+#endif
+
+static struct platform_driver kempld_i2c_driver = {
+	.driver = {
+		   .name = "kempld-i2c",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = kempld_i2c_probe,
+	.remove = __devexit_p(kempld_i2c_remove),
+	.suspend = kempld_i2c_suspend,
+	.resume = kempld_i2c_resume,
+};
+
+static int __init kempld_i2c_init(void)
+{
+	/* Check if a valid value for the i2c_mx_bus parameter is provided */
+	if ((i2c_mx_bus != -1) && (i2c_mx_bus & ~KEMPLD_I2C_MX_MASK))
+		return -EINVAL;
+
+	return platform_driver_register(&kempld_i2c_driver);
+}
+
+static void __exit kempld_i2c_exit(void)
+{
+	platform_driver_unregister(&kempld_i2c_driver);
+}
+
+module_init(kempld_i2c_init);
+module_exit(kempld_i2c_exit);
+
+MODULE_DESCRIPTION("KEM PLD I2C Driver");
+MODULE_AUTHOR("Michael Brunner <michael.brunner@kontron.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:kempld_i2c");
diff --git a/drivers/i2c/busses/i2c-kempld.h b/drivers/i2c/busses/i2c-kempld.h
new file mode 100644
index 0000000..5c066bd
--- /dev/null
+++ b/drivers/i2c/busses/i2c-kempld.h
@@ -0,0 +1,79 @@
+/*
+ *  i2c-kempld.h - Kontron PLD I2C driver definitions
+ *
+ *  Copyright (c) 2010 Kontron Embedded Modules GmbH
+ *  Author: Michael Brunner <michael.brunner@kontron.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _KEMPLD_I2C_H_
+#define _KEMPLD_I2C_H_
+
+struct kempld_i2c_data {
+	struct i2c_adapter adap;
+	struct i2c_msg *msg;
+	int pos;
+	int nmsgs;
+	int state;		/* see STATE_ */
+	int was_active;
+	int mx;
+	struct kempld_device_data *pld;
+};
+
+/* I2C register definitions */
+#define KEMPLD_I2C_PRELOW	0x0b
+#define KEMPLD_I2C_PREHIGH	0x0c
+#define KEMPLD_I2C_CONTROL	0x0d
+#define KEMPLD_I2C_DATA		0x0e
+#define KEMPLD_I2C_CMD		0x0f	/* write only */
+#define		KEMPLD_I2C_CMD_STA	0x80
+#define		KEMPLD_I2C_CMD_STO	0x40
+#define		KEMPLD_I2C_CMD_RD	0x20
+#define		KEMPLD_I2C_CMD_WR	0x10
+#define		KEMPLD_I2C_CMD_NACK	0x08
+#define		KEMPLD_I2C_CMD_IACK	0x01
+#define KEMPLD_I2C_STATUS	0x0f	/* read only, same address as
+					   KEMPLD_I2C_CMD */
+#define KEMPLD_I2C_MX		0x15
+#define KEMPLD_I2C_MX_MASK	0x0f
+
+#define STATE_DONE		0
+#define STATE_INIT		1
+#define STATE_ADDR		2
+#define STATE_ADDR10		3
+#define STATE_START		4
+#define STATE_WRITE		5
+#define STATE_READ		6
+#define STATE_ERROR		7
+
+/* defines taken from i2c-ocores */
+#define OCI2C_CTRL_IEN		0x40
+#define OCI2C_CTRL_EN		0x80
+
+#define OCI2C_CMD_START		0x91
+#define OCI2C_CMD_STOP		0x41
+#define OCI2C_CMD_READ		0x21
+#define OCI2C_CMD_WRITE		0x11
+#define OCI2C_CMD_READ_ACK	0x21
+#define OCI2C_CMD_READ_NACK	0x29
+#define OCI2C_CMD_IACK		0x01
+
+#define OCI2C_STAT_IF		0x01
+#define OCI2C_STAT_TIP		0x02
+#define OCI2C_STAT_ARBLOST	0x20
+#define OCI2C_STAT_BUSY		0x40
+#define OCI2C_STAT_NACK		0x80
+
+#endif /* _KEMPLD_I2C_H_ */
diff --git a/include/linux/i2c/pca953x.h b/include/linux/i2c/pca953x.h
index 139ba52..72ab3eb 100644
--- a/include/linux/i2c/pca953x.h
+++ b/include/linux/i2c/pca953x.h
@@ -27,4 +27,8 @@ struct pca953x_platform_data {
 	const char	*const *names;
 };
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+extern int fri2_get_revision(void);
+#endif
+
 #endif /* _LINUX_PCA953X_H */
-- 
1.7.9.7

