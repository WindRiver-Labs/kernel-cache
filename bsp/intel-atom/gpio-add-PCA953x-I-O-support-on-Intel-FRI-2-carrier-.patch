From b85e149e919fe8a00b04664c38b5eb623bbbc903 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Mon, 4 Jun 2012 18:01:33 +0800
Subject: [PATCH 02/11] gpio: add PCA953x I/O support on Intel FRI 2 carrier
 board

Source: SDK 1.6 for Kontron M2M Smart Services Developer Kit

Add GPIO initlization. The GPIO depend on kempld-core and i2c-kempld

Signed-off-by: Michael Brunner <michael.brunner@kontron.com>
Integrated-by: Yang Wei <wei.yang@windriver.com>
---
 drivers/gpio/Kconfig        |    6 +
 drivers/gpio/gpio-pca953x.c |  366 ++++++++++++++++++++++++++++++++++++-------
 2 files changed, 316 insertions(+), 56 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 79ddacf..e2392f9 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -271,6 +271,12 @@ config GPIO_PCA953X_IRQ
 	  Say yes here to enable the pca953x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
 
+config GPIO_PCA9555_FRI2
+	bool "PCA9555 I/O support on Intel FRI 2 carrier board"
+	depends on GPIO_PCA953X
+	help
+	  Say yes here to enable the FRI2 specific initialization of pca9555.
+
 config GPIO_PCF857X
 	tristate "PCF857x, PCA{85,96}7x, and MAX732[89] I2C GPIO expanders"
 	depends on I2C
diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index d3f3e8f..ad32959 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
  *  Copyright (C) 2007 Marvell International Ltd.
+ *  Copyright (c) 2011 Kontron Global Software Center
  *
  *  Derived from drivers/i2c/chips/pca9539.c
  *
@@ -18,11 +19,14 @@
 #include <linux/irq.h>
 #include <linux/i2c.h>
 #include <linux/i2c/pca953x.h>
+#include <linux/kthread.h>
 #include <linux/slab.h>
 #ifdef CONFIG_OF_GPIO
 #include <linux/of_platform.h>
 #endif
 
+#include <linux/io.h>
+#include <linux/acpi.h>
 #define PCA953X_INPUT		0
 #define PCA953X_OUTPUT		1
 #define PCA953X_INVERT		2
@@ -43,29 +47,30 @@
 #define PCA957X_TYPE		0x2000
 
 static const struct i2c_device_id pca953x_id[] = {
-	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9535", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9536", 4  | PCA953X_TYPE, },
-	{ "pca9537", 4  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9538", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9539", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9554", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9555", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9556", 8  | PCA953X_TYPE, },
-	{ "pca9557", 8  | PCA953X_TYPE, },
-	{ "pca9574", 8  | PCA957X_TYPE | PCA_INT, },
-	{ "pca9575", 16 | PCA957X_TYPE | PCA_INT, },
-
-	{ "max7310", 8  | PCA953X_TYPE, },
-	{ "max7312", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "max7313", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "max7315", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca6107", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "tca6408", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "tca6416", 16 | PCA953X_TYPE | PCA_INT, },
+	{"pca9534", 8 | PCA953X_TYPE | PCA_INT,},
+	{"pca9535", 16 | PCA953X_TYPE | PCA_INT,},
+	{"pca9536", 4 | PCA953X_TYPE,},
+	{"pca9537", 4 | PCA953X_TYPE | PCA_INT,},
+	{"pca9538", 8 | PCA953X_TYPE | PCA_INT,},
+	{"pca9539", 16 | PCA953X_TYPE | PCA_INT,},
+	{"pca9554", 8 | PCA953X_TYPE | PCA_INT,},
+	{"pca9555", 16 | PCA953X_TYPE | PCA_INT,},
+	{"pca9556", 8 | PCA953X_TYPE,},
+	{"pca9557", 8 | PCA953X_TYPE,},
+	{"pca9574", 8 | PCA957X_TYPE | PCA_INT,},
+	{"pca9575", 16 | PCA957X_TYPE | PCA_INT,},
+
+	{"max7310", 8 | PCA953X_TYPE,},
+	{"max7312", 16 | PCA953X_TYPE | PCA_INT,},
+	{"max7313", 16 | PCA953X_TYPE | PCA_INT,},
+	{"max7315", 8 | PCA953X_TYPE | PCA_INT,},
+	{"pca6107", 8 | PCA953X_TYPE | PCA_INT,},
+	{"tca6408", 8 | PCA953X_TYPE | PCA_INT,},
+	{"tca6416", 16 | PCA953X_TYPE | PCA_INT,},
 	/* NYET:  { "tca6424", 24, }, */
-	{ }
+	{}
 };
+
 MODULE_DEVICE_TABLE(i2c, pca953x_id);
 
 struct pca953x_chip {
@@ -80,15 +85,111 @@ struct pca953x_chip {
 	uint16_t irq_stat;
 	uint16_t irq_trig_raise;
 	uint16_t irq_trig_fall;
-	int	 irq_base;
+	int irq_base;
 #endif
 
 	struct i2c_client *client;
 	struct gpio_chip gpio_chip;
 	const char *const *names;
-	int	chip_type;
+	int chip_type;
 };
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+
+#define GPIO_GPE	0x0B	/* SMB_ALERT GPE number on FRI2 */
+#define GPEC		0x18	/* GPE Control register (used to reset GPE) */
+#define	FRI2_GPIO_IRQ_BASE	32
+
+/*
+  Board revision:
+  0x11 - MP1 or older
+  0x10 - MP2 or newer (default)
+*/
+static int fri2_revision = 0x10;
+
+int fri2_get_revision(void)
+{
+	return fri2_revision;
+}
+EXPORT_SYMBOL_GPL(fri2_get_revision);
+
+/* We can install only _one_ handler for SMB_ALERT GPE, but there are
+ * _two_ pca9555 chips on FRI2.
+ * so we need a way to test all GPIOs in one handler. fri2_chips should
+ * contain info about both pca9555.
+ */
+static struct pca953x_chip *fri2_chips[] = { NULL, NULL };
+
+static int fri2_chip_count;
+
+/* only pins 0 1 3 4 6 and 15 are allowed to write on FRI2 */
+
+#define EXP_A_1_0 1
+#define EXP_A_1_1 (1<<1)
+#define EXP_A_1_3 (1<<3)
+#define EXP_A_1_4 (1<<4)
+#define EXP_A_1_6 (1<<6)
+#define EXP_A_1_15 (1<<15)
+
+#define FRI2_OUT_MASK (EXP_A_1_0 |\
+EXP_A_1_1 | EXP_A_1_3 | EXP_A_1_4 | EXP_A_1_6 | EXP_A_1_15)
+
+/* use i2c device 0x18 to access accelerometer (workaround -
+ * accelerometer holds SMB_ALERT low) 0x20 and 0x21 are pca9555
+ * chips
+ */
+static const unsigned short normal_i2c[] = { 0x18, 0x20, 0x21, I2C_CLIENT_END };
+
+static struct pca953x_platform_data fri2_gpio_expander_a_info = {
+	.gpio_base = 0,
+	.irq_base = FRI2_GPIO_IRQ_BASE,
+	.invert = 0,
+};
+
+static struct pca953x_platform_data fri2_gpio_expander_b_info = {
+	.gpio_base = 16,
+	.irq_base = FRI2_GPIO_IRQ_BASE + 16,
+	.invert = 0,
+};
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int pca953x_i2c_detect(struct i2c_client *client,
+			      struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
+		return -ENODEV;
+
+	if (client->addr == 0x20) {
+		/* IO Expander A */
+		info->platform_data = &fri2_gpio_expander_a_info;
+	} else if (client->addr == 0x21) {
+		/* IO expander B */
+		int val;
+		info->platform_data = &fri2_gpio_expander_b_info;
+		val = i2c_smbus_read_word_data(client, PCA953X_INPUT << 1);
+		if (val >= 0)
+			fri2_revision = (val >> 14) & 0x3;
+	} else if (client->addr == 0x18) {
+		/* Hack !! set accelerometer to not pull smb_alert */
+		int val;
+		val = i2c_smbus_read_byte_data(client, 0x22);
+		printk(KERN_INFO "PCA95xx: Set accelerometer to not pull \
+			SMB_ALERT. pca953x_i2c_detect should return -ENODEV.");
+		i2c_smbus_write_byte_data(client, 0x22, 0x40);
+		/* always return error - we're not using accelerometer here. */
+		return -ENODEV;
+	}
+	strlcpy(info->type, "pca9555", I2C_NAME_SIZE);
+	return 0;
+}
+
+#endif
+
 static int pca953x_write_reg(struct pca953x_chip *chip, int reg, uint16_t val)
 {
 	int ret = 0;
@@ -135,7 +236,7 @@ static int pca953x_read_reg(struct pca953x_chip *chip, int reg, uint16_t *val)
 		return ret;
 	}
 
-	*val = (uint16_t)ret;
+	*val = (uint16_t) ret;
 	return 0;
 }
 
@@ -170,7 +271,7 @@ exit:
 }
 
 static int pca953x_gpio_direction_output(struct gpio_chip *gc,
-		unsigned off, int val)
+					 unsigned off, int val)
 {
 	struct pca953x_chip *chip;
 	uint16_t reg_val;
@@ -179,6 +280,11 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
 
 	mutex_lock(&chip->i2c_lock);
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	if (!(FRI2_OUT_MASK & (1 << (chip->gpio_start + off))))
+		return -EINVAL;
+#endif
+
 	/* set output level */
 	if (val)
 		reg_val = chip->reg_output | (1u << off);
@@ -287,7 +393,7 @@ static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 
 	gc = &chip->gpio_chip;
 
-	gc->direction_input  = pca953x_gpio_direction_input;
+	gc->direction_input = pca953x_gpio_direction_input;
 	gc->direction_output = pca953x_gpio_direction_output;
 	gc->get = pca953x_gpio_get_value;
 	gc->set = pca953x_gpio_set_value;
@@ -376,12 +482,12 @@ static int pca953x_irq_set_type(struct irq_data *d, unsigned int type)
 }
 
 static struct irq_chip pca953x_irq_chip = {
-	.name			= "pca953x",
-	.irq_mask		= pca953x_irq_mask,
-	.irq_unmask		= pca953x_irq_unmask,
-	.irq_bus_lock		= pca953x_irq_bus_lock,
-	.irq_bus_sync_unlock	= pca953x_irq_bus_sync_unlock,
-	.irq_set_type		= pca953x_irq_set_type,
+	.name = "pca953x",
+	.irq_mask = pca953x_irq_mask,
+	.irq_unmask = pca953x_irq_unmask,
+	.irq_bus_lock = pca953x_irq_bus_lock,
+	.irq_bus_sync_unlock = pca953x_irq_bus_sync_unlock,
+	.irq_set_type = pca953x_irq_set_type,
 };
 
 static uint16_t pca953x_irq_pending(struct pca953x_chip *chip)
@@ -416,12 +522,14 @@ static uint16_t pca953x_irq_pending(struct pca953x_chip *chip)
 	chip->irq_stat = cur_stat;
 
 	pending = (old_stat & chip->irq_trig_fall) |
-		  (cur_stat & chip->irq_trig_raise);
+	    (cur_stat & chip->irq_trig_raise);
 	pending &= trigger;
 
 	return pending;
 }
 
+#ifndef CONFIG_GPIO_PCA9555_FRI2
+
 static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 {
 	struct pca953x_chip *chip = devid;
@@ -443,15 +551,98 @@ static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
+#else
+
+static struct task_struct *pca95xx_irq_thread;
+
+static void pca95xx_gpe_test_chip(struct pca953x_chip *chip)
+{
+	uint16_t pending;
+	uint16_t level;
+
+	pending = pca953x_irq_pending(chip);
+	if (!pending)
+		return;
+
+	do {
+		level = __ffs(pending);
+		handle_nested_irq(level + chip->irq_base);
+		pending &= ~(1 << level);
+	} while (pending);
+
+}
+
+static unsigned long flgs;
+enum {
+	FLGS_RUNTHREAD,
+	FLGS_DIED
+};
+
+static int pca95xx_wait_for_gpe(void)
+{
+	struct sched_param param = {.sched_priority = MAX_USER_RT_PRIO / 2, };
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (test_and_clear_bit(FLGS_RUNTHREAD, &flgs)) {
+			__set_current_state(TASK_RUNNING);
+			return 0;
+		}
+		schedule();
+	}
+	return -1;
+}
+
+static int pca95xx_gpe_test_chips(void *data)
+{
+	int i;
+
+	while (!pca95xx_wait_for_gpe()) {
+		for (i = 0; i < fri2_chip_count; i++)
+			pca95xx_gpe_test_chip(fri2_chips[i]);
+	}
+
+	return 0;
+}
+
+static int pca95xx_irq_thread_setup(void)
+{
+	pca95xx_irq_thread = kthread_create(pca95xx_gpe_test_chips,
+					    fri2_chips, "pca95xx-irq");
+	if (IS_ERR(pca95xx_irq_thread))
+		return PTR_ERR(pca95xx_irq_thread);
+	else
+		return 0;
+}
+
+/*
+ * one GPE handler for BOTH pca9555 chips. call pca95xx_gpe_test_chip
+ * for each chip.
+ */
+static u32 pca95xx_gpe_handler(void *context)
+{
+
+	inb(acpi_gbl_FADT.gpe0_block + GPEC);
+	outb(0, acpi_gbl_FADT.gpe0_block + GPEC);
+	set_bit(FLGS_RUNTHREAD, &flgs);
+	wake_up_process(pca95xx_irq_thread);
+
+	return ACPI_INTERRUPT_HANDLED;
+
+}
+
+#endif
+
 static int pca953x_irq_setup(struct pca953x_chip *chip,
-			     const struct i2c_device_id *id,
-			     int irq_base)
+			     const struct i2c_device_id *id, int irq_base)
 {
 	struct i2c_client *client = chip->client;
 	int ret, offset = 0;
 
-	if (irq_base != -1
-			&& (id->driver_data & PCA_INT)) {
+	if (irq_base != -1 && (id->driver_data & PCA_INT)) {
 		int lvl;
 
 		switch (chip->chip_type) {
@@ -474,7 +665,8 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 		chip->irq_stat &= chip->reg_direction;
 		mutex_init(&chip->irq_lock);
 
-		chip->irq_base = irq_alloc_descs(-1, irq_base, chip->gpio_chip.ngpio, -1);
+		chip->irq_base =
+		    irq_alloc_descs(-1, irq_base, chip->gpio_chip.ngpio, -1);
 		if (chip->irq_base < 0)
 			goto out_failed;
 
@@ -492,6 +684,7 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 #endif
 		}
 
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 		ret = request_threaded_irq(client->irq,
 					   NULL,
 					   pca953x_irq_handler,
@@ -502,6 +695,31 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 				client->irq);
 			goto out_failed;
 		}
+#else
+		/* install handler only once - for te first pca9555 chip. */
+		if (fri2_chip_count == 1) {
+			ret = pca95xx_irq_thread_setup();
+			if (ret) {
+				printk(KERN_WARNING
+				       "pca95xx: unable to create GPE thread\n");
+				goto out_failed;
+			}
+
+			ret = acpi_install_gpe_handler(NULL,
+						       GPIO_GPE,
+						       ACPI_GPE_EDGE_TRIGGERED,
+						       &pca95xx_gpe_handler,
+						       &fri2_chips);
+			if (ret != AE_OK) {
+				printk(KERN_WARNING
+				       "pca95xx: unable to claim ACPI GPE %d\n",
+				       GPIO_GPE);
+				goto out_failed;
+			} else {
+				printk("  Using ACPI GPE %d\n", GPIO_GPE);
+			}
+		}
+#endif
 
 		chip->gpio_chip.to_irq = pca953x_gpio_to_irq;
 	}
@@ -509,21 +727,38 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 	return 0;
 
 out_failed:
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	if (pca95xx_irq_thread) {
+		kthread_stop(pca95xx_irq_thread);
+		kfree(pca95xx_irq_thread);
+		pca95xx_irq_thread = 0;
+	}
+#endif
 	chip->irq_base = -1;
 	return ret;
 }
 
 static void pca953x_irq_teardown(struct pca953x_chip *chip)
 {
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 	if (chip->irq_base != -1) {
 		irq_free_descs(chip->irq_base, chip->gpio_chip.ngpio);
 		free_irq(chip->client->irq, chip);
 	}
+#else
+	if (fri2_chip_count-- == 0) {
+		acpi_remove_gpe_handler(NULL, GPIO_GPE, &pca95xx_gpe_handler);
+		if (pca95xx_irq_thread) {
+			kthread_stop(pca95xx_irq_thread);
+			kfree(pca95xx_irq_thread);
+			pca95xx_irq_thread = 0;
+		}
+	}
+#endif
 }
 #else /* CONFIG_GPIO_PCA953X_IRQ */
 static int pca953x_irq_setup(struct pca953x_chip *chip,
-			     const struct i2c_device_id *id,
-			     int irq_base)
+			     const struct i2c_device_id *id, int irq_base)
 {
 	struct i2c_client *client = chip->client;
 
@@ -559,7 +794,8 @@ pca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, int *invert)
 
 	*gpio_base = -1;
 	val = of_get_property(node, "linux,gpio-base", &size);
-	WARN(val, "%s: device-tree property 'linux,gpio-base' is deprecated!", __func__);
+	WARN(val, "%s: device-tree property 'linux,gpio-base' is deprecated!",
+	     __func__);
 	if (val) {
 		if (size != sizeof(*val))
 			dev_warn(&client->dev, "%s: wrong linux,gpio-base\n",
@@ -569,7 +805,8 @@ pca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, int *invert)
 	}
 
 	val = of_get_property(node, "polarity", NULL);
-	WARN(val, "%s: device-tree property 'polarity' is deprecated!", __func__);
+	WARN(val, "%s: device-tree property 'polarity' is deprecated!",
+	     __func__);
 	if (val)
 		*invert = *val;
 }
@@ -589,8 +826,7 @@ static int __devinit device_pca953x_init(struct pca953x_chip *chip, int invert)
 	if (ret)
 		goto out;
 
-	ret = pca953x_read_reg(chip, PCA953X_DIRECTION,
-			       &chip->reg_direction);
+	ret = pca953x_read_reg(chip, PCA953X_DIRECTION, &chip->reg_direction);
 	if (ret)
 		goto out;
 
@@ -636,13 +872,16 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 {
 	struct pca953x_platform_data *pdata;
 	struct pca953x_chip *chip;
-	int irq_base=0, invert=0;
+	int irq_base = 0, invert = 0;
 	int ret;
 
 	chip = kzalloc(sizeof(struct pca953x_chip), GFP_KERNEL);
 	if (chip == NULL)
 		return -ENOMEM;
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	fri2_chips[fri2_chip_count++] = chip;
+#endif
 	pdata = client->dev.platform_data;
 	if (pdata) {
 		irq_base = pdata->irq_base;
@@ -653,7 +892,8 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 		pca953x_get_alt_pdata(client, &chip->gpio_start, &invert);
 #ifdef CONFIG_OF_GPIO
 		/* If I2C node has no interrupts property, disable GPIO interrupts */
-		if (of_find_property(client->dev.of_node, "interrupts", NULL) == NULL)
+		if (of_find_property(client->dev.of_node, "interrupts", NULL) ==
+		    NULL)
 			irq_base = -1;
 #endif
 	}
@@ -677,6 +917,7 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 		goto out_failed;
 
 	ret = pca953x_irq_setup(chip, id, irq_base);
+	printk(KERN_INFO "chip->irq_base is %d\n", chip->irq_base);
 	if (ret)
 		goto out_failed;
 
@@ -686,7 +927,7 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 
 	if (pdata && pdata->setup) {
 		ret = pdata->setup(client, chip->gpio_chip.base,
-				chip->gpio_chip.ngpio, pdata->context);
+				   chip->gpio_chip.ngpio, pdata->context);
 		if (ret < 0)
 			dev_warn(&client->dev, "setup failed, %d\n", ret);
 	}
@@ -709,10 +950,10 @@ static int pca953x_remove(struct i2c_client *client)
 
 	if (pdata && pdata->teardown) {
 		ret = pdata->teardown(client, chip->gpio_chip.base,
-				chip->gpio_chip.ngpio, pdata->context);
+				      chip->gpio_chip.ngpio, pdata->context);
 		if (ret < 0) {
 			dev_err(&client->dev, "%s failed, %d\n",
-					"teardown", ret);
+				"teardown", ret);
 			return ret;
 		}
 	}
@@ -720,7 +961,7 @@ static int pca953x_remove(struct i2c_client *client)
 	ret = gpiochip_remove(&chip->gpio_chip);
 	if (ret) {
 		dev_err(&client->dev, "%s failed, %d\n",
-				"gpiochip_remove()", ret);
+			"gpiochip_remove()", ret);
 		return ret;
 	}
 
@@ -731,26 +972,39 @@ static int pca953x_remove(struct i2c_client *client)
 
 static struct i2c_driver pca953x_driver = {
 	.driver = {
-		.name	= "pca953x",
-	},
-	.probe		= pca953x_probe,
-	.remove		= pca953x_remove,
-	.id_table	= pca953x_id,
+		   .name = "pca953x",
+		   },
+	.probe = pca953x_probe,
+	.remove = pca953x_remove,
+	.id_table = pca953x_id,
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	.class = I2C_CLASS_HWMON,
+	.detect = pca953x_i2c_detect,
+	.address_list = normal_i2c,
+#endif
 };
 
 static int __init pca953x_init(void)
 {
 	return i2c_add_driver(&pca953x_driver);
 }
+
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 /* register after i2c postcore initcall and before
  * subsys initcalls that may rely on these GPIOs
  */
 subsys_initcall(pca953x_init);
-
+#else
+/* on FRI2 we can init gpio _after_ kontron CPLD
+ * drivers kempld-core and i2c-kempld
+ */
+module_init(pca953x_init);
+#endif
 static void __exit pca953x_exit(void)
 {
 	i2c_del_driver(&pca953x_driver);
 }
+
 module_exit(pca953x_exit);
 
 MODULE_AUTHOR("eric miao <eric.miao@marvell.com>");
-- 
1.7.9.7

