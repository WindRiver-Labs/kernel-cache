From 09931afe51581dd276df9a9824e1ebbbfeac1e0f Mon Sep 17 00:00:00 2001
From: fli <fupan.li@windriver.com>
Date: Wed, 10 Jul 2013 14:25:16 +0800
Subject: [PATCH 2/7] Add a Kconfig option to select applying silicon issue
 fix patch

A silicon issue exists with the engineering samples (ES0 and ES1) of the Avoton/Rangeley SoC
which affects the way the GbE configuration registers are accessed when issuing downstream writes to
PCI configuration space. This Linux patch resolves this issue by forcing a memory map cycle that will
properly initialize the access method. In order to minimize this patch's effection, add a kernel option
to limit it only for Avoton/Rangeley Boards!

Signed-off-by: fli <fupan.li@windriver.com>
---
 arch/x86/Kconfig      |   12 ++++++++++++
 arch/x86/pci/common.c |   18 ++++++++++++++++++
 2 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 297542d..a21eee5 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1960,6 +1960,18 @@ config PCI_MMCONFIG
 	def_bool y
 	depends on X86_32 && PCI && (ACPI || SFI) && (PCI_GOMMCONFIG || PCI_GOANY)
 
+config PCI_AVOTONFIX
+	bool "Don't use cf8/cfc for the first 256 bytes of config space if MMCFG is available"
+	default n
+	depends on PCI_MMCONFIG
+	---help---
+	  A silicon issue exists with the engineering samples (ES0 and ES1) 
+	  of the Avoton/Rangeley SoC which affects the way the GbE configuration 
+	  registers are accessed when issuing downstream writes to PCI configuration 
+	  space. A Linux kernel patch has been identified. The included Linux patch 
+	  resolves this issue by forcing a memory map cycle that will properly initialize 
+	  the access method.
+
 config PCI_OLPC
 	def_bool y
 	depends on PCI && OLPC && (PCI_GOOLPC || PCI_GOANY)
diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c
index 323481e..b68c189 100644
--- a/arch/x86/pci/common.c
+++ b/arch/x86/pci/common.c
@@ -39,20 +39,38 @@ const struct pci_raw_ops *__read_mostly raw_pci_ext_ops;
 int raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,
 						int reg, int len, u32 *val)
 {
+#ifndef CONFIG_PCI_AVOTONFIX
 	if (domain == 0 && reg < 256 && raw_pci_ops)
 		return raw_pci_ops->read(domain, bus, devfn, reg, len, val);
+#endif
+
 	if (raw_pci_ext_ops)
 		return raw_pci_ext_ops->read(domain, bus, devfn, reg, len, val);
+
+#ifdef CONFIG_PCI_AVOTONFIX
+        if (domain == 0 && reg < 256 && raw_pci_ops)
+                return raw_pci_ops->read(domain, bus, devfn, reg, len, val);
+#endif
+
 	return -EINVAL;
 }
 
 int raw_pci_write(unsigned int domain, unsigned int bus, unsigned int devfn,
 						int reg, int len, u32 val)
 {
+#ifndef CONFIG_PCI_AVOTONFIX
 	if (domain == 0 && reg < 256 && raw_pci_ops)
 		return raw_pci_ops->write(domain, bus, devfn, reg, len, val);
+#endif
+
 	if (raw_pci_ext_ops)
 		return raw_pci_ext_ops->write(domain, bus, devfn, reg, len, val);
+
+#ifdef CONFIG_PCI_AVOTONFIX
+        if (domain == 0 && reg < 256 && raw_pci_ops)
+                return raw_pci_ops->write(domain, bus, devfn, reg, len, val);
+#endif
+
 	return -EINVAL;
 }
 
-- 
1.7.5.4

