From d7e6d33a5f9cd96758b7b2bfc5e683a7bd7f1509 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 2 Sep 2013 14:47:05 +0800
Subject: [PATCH 8/8] gpio/gpio-ich: add Avoton/Rengeley GPIO support.

Beside the infrastructure used to support GPIO on Avoton/Rengeley, 2
things make the changes looking complex:

1) The location of control/access register set for Core-well and SUS-well
GPIOs is discontinuous. We hope to give user space an impression that
the two sets of GPIOs are continuous, though the 31 Core-well GPIOs are
handled separatly from the 28 SUS-well ones. To make it, it is required
to hook necessary callbacks from gpiochip. Thus, the benefit is we have
59 GPIOs rather than other amounts.
2) The first group of LVL register in Avoton/Rengeley resides GBASE+0x8
rather than GBASE+0xc, which causes the related callbacks from gpiochip
require hooks to fixup accessing to LVL register for Avoton/Rengeley.

This patch is validated on Mohon Peak:

# modprobe gpio-ich gpiobase=0
# echo 15 > export
# echo 17 > export
# echo 34 > export
# cat gpio*/value
0
0
1

where 15, 17 and 34 are used to identify CRBs based on Avoton/Rengeley SoC.
Mohon Peak is assigned 0x4 for board identification.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
Signed-off-by: fli <fupan.li@windriver.com>
---
 drivers/gpio/gpio-ich.c     |  110 ++++++++++++++++++++++++++++++++++++++----
 include/linux/mfd/lpc_ich.h |    1 +
 2 files changed, 100 insertions(+), 11 deletions(-)

diff --git a/drivers/gpio/gpio-ich.c b/drivers/gpio/gpio-ich.c
index ec2a29a..439e32f 100644
--- a/drivers/gpio/gpio-ich.c
+++ b/drivers/gpio/gpio-ich.c
@@ -40,17 +40,19 @@
 enum GPIO_REG {
 	GPIO_USE_SEL = 0,
 	GPIO_IO_SEL,
+	GPIO_AVN_LVL,		/* Avoton has a different LVL offset */
 	GPIO_LVL,
 };
 
-static const u8 ichx_regs[3][3] = {
-	{0x00, 0x30, 0x40},	/* USE_SEL[1-3] offsets */
-	{0x04, 0x34, 0x44},	/* IO_SEL[1-3] offsets */
-	{0x0c, 0x38, 0x48},	/* LVL[1-3] offsets */
+static const u8 ichx_regs[4][4] = {
+	{0x00, 0x30, 0x40, 0x80},	/* USE_SEL[1-4] offsets */
+	{0x04, 0x34, 0x44, 0x84},	/* IO_SEL[1-4] offsets */
+	{0x08, 0x38, 0x48, 0x88},	/* LVL[1-4] offsets for Avoton */
+	{0x0c, 0x38, 0x48, 0x88},	/* LVL[1-4] offsets */
 };
 
-static const u8 ichx_reglen[3] = {
-	0x30, 0x10, 0x10,
+static const u8 ichx_reglen[4] = {
+	0x30, 0x10, 0x10, 0x1c
 };
 
 #define ICHX_WRITE(val, reg, base_res)	outl(val, (reg) + (base_res)->start)
@@ -64,11 +66,14 @@ struct ichx_desc {
 	bool uses_gpe0;
 
 	/* USE_SEL is bogus on some chipsets, eg 3100 */
-	u32 use_sel_ignore[3];
+	u32 use_sel_ignore[4];
 
 	/* Some chipsets have quirks, let these use their own request/get */
 	int (*request)(struct gpio_chip *chip, unsigned offset);
 	int (*get)(struct gpio_chip *chip, unsigned offset);
+	void (*set)(struct gpio_chip *chip, unsigned offset, int value);
+	int (*direction_output)(struct gpio_chip *chip, unsigned offset, int value);
+	int (*direction_input)(struct gpio_chip *chip, unsigned offset);
 };
 
 static struct {
@@ -148,6 +153,14 @@ static int ichx_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)
 	return 0;
 }
 
+static int ich_avn_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)
+{
+	if (nr >= 32)
+		nr += 64;
+
+	return ichx_gpio_direction_input(gpio, nr);
+}
+
 static int ichx_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,
 					int val)
 {
@@ -167,6 +180,25 @@ static int ichx_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,
 	return 0;
 }
 
+static int ich_avn_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,
+						int val)
+{
+	if (nr >= 32)
+		nr += 64;
+
+	/* Set GPIO output value. */
+	ichx_write_bit(GPIO_AVN_LVL, nr, val, 0);
+
+	/*
+	 * Try setting pin as an output and verify it worked since many pins
+	 * are input-only.
+	 */
+	if (ichx_write_bit(GPIO_IO_SEL, nr, 0, 1))
+		return -EINVAL;
+
+	return 0;
+}
+
 static int ichx_gpio_get(struct gpio_chip *chip, unsigned nr)
 {
 	if (!ichx_gpio_check_available(chip, nr))
@@ -205,6 +237,14 @@ static int ich6_gpio_get(struct gpio_chip *chip, unsigned nr)
 	}
 }
 
+static int ich_avn_gpio_get(struct gpio_chip *chip, unsigned nr)
+{
+	if (nr >= 32)
+		nr += 64;
+
+	return ichx_read_bit(GPIO_AVN_LVL, nr);
+}
+
 static int ichx_gpio_request(struct gpio_chip *chip, unsigned nr)
 {
 	/*
@@ -233,11 +273,34 @@ static int ich6_gpio_request(struct gpio_chip *chip, unsigned nr)
 	return ichx_gpio_request(chip, nr);
 }
 
+static int ich_avn_gpio_request(struct gpio_chip *chip, unsigned nr)
+{
+	/*
+	 * Avoton/Rangeley doesn't have GPIO control/access registers
+	 * beginning with GBASE+0x30 and GBASE+0x40. We also cannot trust
+	 * the returned values from USE_SEL for them. It is intended
+	 * to forward the access to SUS-well GPIOs to registers
+	 * beginning with GBASE+0x80.
+	 */
+	if (nr >= 32)
+		nr += 64;
+
+	return ichx_gpio_request(chip, nr);
+}
+
 static void ichx_gpio_set(struct gpio_chip *chip, unsigned nr, int val)
 {
 	ichx_write_bit(GPIO_LVL, nr, val, 0);
 }
 
+static void ich_avn_gpio_set(struct gpio_chip *chip, unsigned nr, int val)
+{
+	if (nr >= 32)
+		nr += 64;
+
+	ichx_write_bit(GPIO_AVN_LVL, nr, val, 0);
+}
+
 static void __devinit ichx_gpiolib_setup(struct gpio_chip *chip)
 {
 	chip->owner = THIS_MODULE;
@@ -249,10 +312,13 @@ static void __devinit ichx_gpiolib_setup(struct gpio_chip *chip)
 		ichx_priv.desc->request : ichx_gpio_request;
 	chip->get = ichx_priv.desc->get ?
 		ichx_priv.desc->get : ichx_gpio_get;
+	chip->set = ichx_priv.desc->set ?
+		ichx_priv.desc->set : ichx_gpio_set;
+	chip->direction_output = ichx_priv.desc->direction_output ?
+		ichx_priv.desc->direction_output : ichx_gpio_direction_output;
+	chip->direction_input = ichx_priv.desc->direction_input ?
+		ichx_priv.desc->direction_input : ichx_gpio_direction_input;
 
-	chip->set = ichx_gpio_set;
-	chip->direction_input = ichx_gpio_direction_input;
-	chip->direction_output = ichx_gpio_direction_output;
 	chip->base = modparam_gpiobase;
 	chip->ngpio = ichx_priv.desc->ngpio;
 	chip->can_sleep = 0;
@@ -278,7 +344,7 @@ static struct ichx_desc i3100_desc = {
 	 * the Intel 3100.  See "Table 712. GPIO Summary Table" of 3100
 	 * Datasheet for more info.
 	 */
-	.use_sel_ignore = {0x00130000, 0x00010000, 0x0},
+	.use_sel_ignore = {0x00130000, 0x00010000, 0x0, 0x0},
 
 	/* The 3100 needs fixups for GPIO 0 - 17 */
 	.request = ich6_gpio_request,
@@ -313,6 +379,25 @@ static struct ichx_desc intel5_desc = {
 	.ngpio = 76,
 };
 
+/* Intel Rangeley/Avoton */
+static struct ichx_desc ich_avn_desc = {
+	/*
+	 * Rangeley/Avoton has 2 separate sets of GPIO control/access
+	 * registers. The 31 Core-well GPIOs are handled separatly from
+	 * the 28 SUS-well ones. See "Section 25.3.1" of Avoton SoC
+	 * Datasheet and "Section 26.3.1" of Rangeley SoC Datasheet for
+	 * more info.
+	 */
+	.ngpio = 59,
+	.request = ich_avn_gpio_request,
+	.direction_input = ich_avn_gpio_direction_input,
+
+	/* The Avoton needs fixups for accessing to LVL register */
+	.get = ich_avn_gpio_get,
+	.set = ich_avn_gpio_set,
+	.direction_output = ich_avn_gpio_direction_output,
+};
+
 static int __devinit ichx_gpio_request_regions(struct resource *res_base,
 						const char *name, u8 use_gpio)
 {
@@ -386,6 +471,9 @@ static int __devinit ichx_gpio_probe(struct platform_device *pdev)
 	case ICH_V10CONS_GPIO:
 		ichx_priv.desc = &ich10_cons_desc;
 		break;
+	case ICH_AVN_GPIO:
+		ichx_priv.desc = &ich_avn_desc;
+		break;
 	default:
 		return -ENODEV;
 	}
diff --git a/include/linux/mfd/lpc_ich.h b/include/linux/mfd/lpc_ich.h
index 3e1df64..f22bc4e 100644
--- a/include/linux/mfd/lpc_ich.h
+++ b/include/linux/mfd/lpc_ich.h
@@ -38,6 +38,7 @@
 #define ICH_V9_GPIO		0x801
 #define ICH_V10CORP_GPIO	0xa01
 #define ICH_V10CONS_GPIO	0xa11
+#define ICH_AVN_GPIO		0xa12
 
 struct lpc_ich_info {
 	char name[32];
-- 
1.7.5.4

