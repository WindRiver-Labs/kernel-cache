From adf869c2675d466774ae8768f4432d713e0a48c9 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 16:57:34 +0800
Subject: [PATCH 065/134] ACPI: Drop power resources driver

upstream: 781d737c7466845035e5ce02885c7436b5278b90

The ACPI power resources driver is not very useful, because the only
thing it really does is to restore the state of the power resources
that were "on" before system suspend or hibernation, but that may be
achieved in a different way.

Drop the ACPI power resources driver entirely and add
acpi_resume_power_resources() that will walk the list of all
registered power resources during system resume and turn on the ones
that were "on" before the preceding system suspend or hibernation.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/power.c |   90 ++++++++++++++++++++++---------------------------
 drivers/acpi/scan.c  |    1 -
 drivers/acpi/sleep.c |    1 +
 drivers/acpi/sleep.h |    2 +
 4 files changed, 43 insertions(+), 51 deletions(-)

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0e9e5ca..735c157 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -58,22 +58,6 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-static inline int acpi_power_add(struct acpi_device *device) { return 0; }
-static int acpi_power_resume(struct acpi_device *device);
-
-static const struct acpi_device_id power_device_ids[] = {
-	{ACPI_POWER_HID, 0},
-	{"", 0},
-};
-MODULE_DEVICE_TABLE(acpi, power_device_ids);
-
-static struct acpi_driver acpi_power_driver = {
-	.name = "power",
-	.class = ACPI_POWER_CLASS,
-	.ids = power_device_ids,
-	.ops.add = acpi_power_add,
-};
-
 struct acpi_power_dependent_device {
 	struct list_head node;
 	struct acpi_device *adev;
@@ -82,6 +66,7 @@ struct acpi_power_dependent_device {
 
 struct acpi_power_resource {
 	struct acpi_device device;
+	struct list_head list_node;
 	struct list_head dependent;
 	char *name;
 	u32 system_level;
@@ -90,7 +75,9 @@ struct acpi_power_resource {
 	struct mutex resource_lock;
 };
 
-static struct list_head acpi_power_resource_list;
+
+static LIST_HEAD(acpi_power_resource_list);
+static DEFINE_MUTEX(power_resource_list_lock);
 
 /* --------------------------------------------------------------------------
                              Power Resource Management
@@ -631,8 +618,13 @@ static void acpi_release_power_resource(struct device *dev)
 	struct acpi_device *device = to_acpi_device(dev);
 	struct acpi_power_resource *resource;
 
-	acpi_free_ids(device);
 	resource = container_of(device, struct acpi_power_resource, device);
+
+	mutex_lock(&power_resource_list_lock);
+	list_del(&resource->list_node);
+	mutex_unlock(&power_resource_list_lock);
+
+	acpi_free_ids(device);
 	kfree(resource);
 }
 
@@ -665,14 +657,14 @@ void acpi_add_power_resource(acpi_handle handle)
 	/* Evalute the object to get the system level and resource order. */
 	status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
 	if (ACPI_FAILURE(status))
-		goto out;
+		goto err;
 
 	resource->system_level = acpi_object.power_resource.system_level;
 	resource->order = acpi_object.power_resource.resource_order;
 
 	result = acpi_power_get_state(handle, &state);
 	if (result)
-		goto out;
+		goto err;
 
 	switch (state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
@@ -690,47 +682,45 @@ void acpi_add_power_resource(acpi_handle handle)
 
 	device->flags.match_driver = true;
 	result = acpi_device_register(device, acpi_release_power_resource);
-
- out:
 	if (result)
-		acpi_release_power_resource(&device->dev);
+		goto err;
 
-	return;
+	mutex_lock(&power_resource_list_lock);
+	list_add(&resource->list_node, &acpi_power_resource_list);
+	mutex_unlock(&power_resource_list_lock);
+ err:
+	acpi_release_power_resource(&device->dev);
 }
 
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int acpi_power_resume(struct acpi_device *device)
+#ifdef CONFIG_ACPI_SLEEP
+void acpi_resume_power_resources(void)
 {
-	int result = 0, state;
 	struct acpi_power_resource *resource;
 
-	if (!device)
-		return -EINVAL;
-
-	resource = acpi_driver_data(device);
-	if (!resource)
-		return -EINVAL;
+	mutex_lock(&power_resource_list_lock);
 
-	mutex_lock(&resource->resource_lock);
+	list_for_each_entry(resource, &acpi_power_resource_list, list_node) {
+		int result, state;
 
-	result = acpi_power_get_state(device->handle, &state);
-	if (result)
-		goto unlock;
+		mutex_lock(&resource->resource_lock);
 
-	if (state == ACPI_POWER_RESOURCE_STATE_OFF && resource->ref_count)
-		result = __acpi_power_on(resource);
+		result = acpi_power_get_state(resource->device.handle, &state);
+		if (result)
+			continue;
 
- unlock:
-	mutex_unlock(&resource->resource_lock);
+		if (state == ACPI_POWER_RESOURCE_STATE_OFF
+		    && resource->ref_count) {
+			dev_info(&resource->device.dev, "Turning ON\n");
+			__acpi_power_on(resource);
+		} else if (state == ACPI_POWER_RESOURCE_STATE_ON
+		    && !resource->ref_count) {
+			dev_info(&resource->device.dev, "Turning OFF\n");
+			__acpi_power_off(resource);
+		}
 
-	return result;
-}
+		mutex_unlock(&resource->resource_lock);
+	}
 
-int __init acpi_power_init(void)
-{
-	INIT_LIST_HEAD(&acpi_power_resource_list);
-	return acpi_bus_register_driver(&acpi_power_driver);
+	mutex_unlock(&power_resource_list_lock);
 }
+#endif
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c726a9f..28760be 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1559,7 +1559,6 @@ int __init acpi_scan_init(void)
 		printk(KERN_ERR PREFIX "Could not register bus type\n");
 	}
 
-	acpi_power_init();
 
 	/*
 	 * Enumerate devices in the ACPI namespace.
diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 940433a..bea0261 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -397,6 +397,7 @@ static void acpi_pm_finish(void)
 	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
 
 	acpi_target_sleep_state = ACPI_STATE_S0;
+	acpi_resume_power_resources();
 }
 
 /**
diff --git a/drivers/acpi/sleep.h b/drivers/acpi/sleep.h
index 74d59c8..0143540 100644
--- a/drivers/acpi/sleep.h
+++ b/drivers/acpi/sleep.h
@@ -6,3 +6,5 @@ extern void acpi_disable_wakeup_devices(u8 sleep_state);
 
 extern struct list_head acpi_wakeup_device_list;
 extern struct mutex acpi_device_lock;
+
+extern void acpi_resume_power_resources(void);
-- 
1.7.5.4

