From 88762301c222a1d67e87218e1c9a96ec5d33b536 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Wed, 6 Jun 2012 12:53:05 +0800
Subject: [PATCH 10/11] pch_gbe: Fix the checksum fill to the error location

Due to some hardware limitations the pch_gbe hardware cannot
calculate checksums when the length of network package is less
than 64 bytes, If a smaller than 64 byte packet is processed, the
destination IP address will be incorrectly modified.

When forwarding network packages at the network layer the IP packages
won't be relayed to the upper transport layer and analyzed there,
consequently, skb->transport_header pointer will be mistakenly remained
the same as that of skb->network_header, resulting in TCP checksum wrongly
filled into the field of destination IP in IP header.

We can fix this issue by manually calculate the offset of the TCP checksum
 and update it accordingly.

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
Integrated-by: Yang Wei <wei.yang@windriver.com>
---
 .../net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c   |   14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
index f8ec23b..3e14402 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
@@ -1173,21 +1173,22 @@ static void pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,
 	 * when the received data size is less than 64 bytes.
 	 */
 	if (skb->len < PCH_GBE_SHORT_PKT && skb->ip_summed != CHECKSUM_NONE) {
+		struct iphdr *iph = ip_hdr(skb);
 		frame_ctrl |= PCH_GBE_TXD_CTRL_APAD |
 			      PCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;
 		if (skb->protocol == htons(ETH_P_IP)) {
-			struct iphdr *iph = ip_hdr(skb);
 			unsigned int offset;
+			offset = (unsigned char *)((u8 *)iph + iph->ihl * 4) - skb->data;
 			iph->check = 0;
 			iph->check = ip_fast_csum((u8 *) iph, iph->ihl);
-			offset = skb_transport_offset(skb);
 			if (iph->protocol == IPPROTO_TCP &&
 						!(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET))) {
+				struct tcphdr *tcphdr_point = (struct tcphdr *)((u8 *)iph + iph->ihl * 4);
 				skb->csum = 0;
-				tcp_hdr(skb)->check = 0;
+				tcphdr_point->check = 0;
 				skb->csum = skb_checksum(skb, offset,
 							 skb->len - offset, 0);
-				tcp_hdr(skb)->check =
+				tcphdr_point->check =
 					csum_tcpudp_magic(iph->saddr,
 							  iph->daddr,
 							  skb->len - offset,
@@ -1195,12 +1196,13 @@ static void pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,
 							  skb->csum);
 			} else if (iph->protocol == IPPROTO_UDP &&
 						!(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET))) {
+				struct udphdr *udphdr_point = (struct udphdr *)((u8 *)iph + iph->ihl * 4);
 				skb->csum = 0;
-				udp_hdr(skb)->check = 0;
+				udphdr_point->check = 0;
 				skb->csum =
 					skb_checksum(skb, offset,
 						     skb->len - offset, 0);
-				udp_hdr(skb)->check =
+				udphdr_point->check =
 					csum_tcpudp_magic(iph->saddr,
 							  iph->daddr,
 							  skb->len - offset,
-- 
1.7.9.7

