From 0a7b6bf8f134f7a7fc2641a0d0e725f5b55228f5 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 17:14:23 +0800
Subject: [PATCH 069/134] ACPI / scan: Move power state initialization to a
 separate routine

upstream: f33ce568366ab61b5685bae07306e40f17beb943

To reduce indentation level and improve code readability, move the
initialization code related to device power states from
acpi_bus_get_power_flags() to a new routine,
acpi_bus_init_power_state().

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/scan.c |   87 +++++++++++++++++++++++++++------------------------
 1 files changed, 46 insertions(+), 41 deletions(-)

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 45a45ec..a7f7b54 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -937,6 +937,50 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 				"error in _DSW or _PSW evaluation\n"));
 }
 
+static void acpi_bus_init_power_state(struct acpi_device *device, int state)
+{
+	struct acpi_device_power_state *ps = &device->power.states[state];
+	char object_name[5] = { '_', 'P', 'R', '0' + state, '\0' };
+	struct acpi_handle_list resources;
+	acpi_handle handle;
+	acpi_status status;
+
+	INIT_LIST_HEAD(&ps->resources);
+
+	/* Evaluate "_PRx" to se if power resources are referenced */
+	acpi_evaluate_reference(device->handle, object_name, NULL, &resources);
+	if (resources.count) {
+		int j;
+
+		device->power.flags.power_resources = 1;
+		for (j = 0; j < resources.count; j++) {
+			acpi_handle rhandle = resources.handles[j];
+
+			acpi_add_power_resource(rhandle);
+			acpi_power_resources_list_add(rhandle, &ps->resources);
+		}
+	}
+
+	/* Evaluate "_PSx" to see if we can do explicit sets */
+	object_name[2] = 'S';
+	status = acpi_get_handle(device->handle, object_name, &handle);
+	if (ACPI_SUCCESS(status))
+		ps->flags.explicit_set = 1;
+
+	/*
+	 * State is valid if there are means to put the device into it.
+	 * D3hot is only valid if _PR3 present.
+	 */
+	if (resources.count
+	    || (ps->flags.explicit_set && state < ACPI_STATE_D3_HOT)) {
+		ps->flags.valid = 1;
+		ps->flags.os_accessible = 1;
+	}
+
+	ps->power = -1;		/* Unknown - driver assigned */
+	ps->latency = -1;	/* Unknown - driver assigned */
+}
+
 static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
@@ -966,47 +1010,8 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 	/*
 	 * Enumerate supported power management states
 	 */
-	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
-		struct acpi_device_power_state *ps = &device->power.states[i];
-		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
-		struct acpi_handle_list resources;
-
-		INIT_LIST_HEAD(&ps->resources);
-		/* Evaluate "_PRx" to se if power resources are referenced */
-		acpi_evaluate_reference(device->handle, object_name, NULL,
-					&resources);
-		if (resources.count) {
-			int j;
-
-			device->power.flags.power_resources = 1;
-			for (j = 0; j < resources.count; j++) {
-				acpi_handle rhandle = resources.handles[j];
-
-				acpi_add_power_resource(rhandle);
-				acpi_power_resources_list_add(rhandle,
-							      &ps->resources);
-			}
-		}
-
-		/* Evaluate "_PSx" to see if we can do explicit sets */
-		object_name[2] = 'S';
-		status = acpi_get_handle(device->handle, object_name, &handle);
-		if (ACPI_SUCCESS(status))
-			ps->flags.explicit_set = 1;
-
-		/*
-		 * State is valid if there are means to put the device into it.
-		 * D3hot is only valid if _PR3 present.
-		 */
-		if (resources.count ||
-		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT)) {
-			ps->flags.valid = 1;
-			ps->flags.os_accessible = 1;
-		}
-
-		ps->power = -1;	/* Unknown - driver assigned */
-		ps->latency = -1;	/* Unknown - driver assigned */
-	}
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++)
+		acpi_bus_init_power_state(device, i);
 
 	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
 
-- 
1.7.5.4

