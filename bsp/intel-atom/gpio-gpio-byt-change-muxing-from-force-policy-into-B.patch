From 431b19b5c4f9c31bfe1fc39155d174aedbb758cf Mon Sep 17 00:00:00 2001
From: fli <fupan.li@windriver.com>
Date: Mon, 30 Dec 2013 13:41:06 +0800
Subject: [PATCH 063/142] gpio: gpio-byt: change muxing from force-policy into
 BIOS policy

User will need to use BIOS or Bootloader to have pin
changes between non-GPIO and GPIO.

Signed-off-by: Chew, Kean Ho <kean.ho.chew@intel.com>
Signed-off-by: Chang, Rebecca Swee Fun <rebecca.swee.fun.chang@intel.com>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/gpio/gpio-byt.c |   23 ++++++++++++-----------
 1 files changed, 12 insertions(+), 11 deletions(-)

diff --git a/drivers/gpio/gpio-byt.c b/drivers/gpio/gpio-byt.c
index d1822c7..f50cfe2 100644
--- a/drivers/gpio/gpio-byt.c
+++ b/drivers/gpio/gpio-byt.c
@@ -48,7 +48,7 @@
 #define BYT_TRIG_POS		BIT(25)
 #define BYT_TRIG_LVL		BIT(24)
 #define BYT_PIN_MUX		0x07
-#define BYT_GPIO_FUNC		0x01
+#define BYT_GPIO_FUNC		(BIT(0) | BIT(1) | BIT(2))
 
 /* BYT_VAL_REG register bits */
 #define BYT_INPUT_EN		BIT(2)  /*(active low)*/
@@ -160,15 +160,22 @@ static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)
 
 	value =	readl(reg);
 	if (!strcmp(chip->label, "byt_gpio.2") && offset >= 11 && offset <= 21){
-		writel(value | BYT_GPIO_FUNC, reg);
+		if ((value & BYT_GPIO_FUNC) != 1)
+			goto not_gpio;
 	} else {
-		writel(value & ~BYT_GPIO_FUNC, reg);
+		if (value & BYT_GPIO_FUNC)
+			goto not_gpio;
 	}
 
 	pm_runtime_get(&vg->pdev->dev);
 	return 0;
+
+not_gpio:
+	dev_err(&vg->pdev->dev, "GPIO %d is not a GPIO pin.\n", (int)offset);
+	return -EINVAL;
+
 /*
- * Current Implemntation: Option 2
+ * Current Implemntation: Option 1
  *
  * Policy about what should be done when requesting a gpio is unclear.
  * In most cases PIN MUX 000 means gpio function, with the exception of SUS
@@ -199,11 +206,6 @@ static void byt_gpio_free(struct gpio_chip *chip, unsigned offset)
 	value = readl(reg);
 	value &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);
 
-	if (!strcmp(chip->label, "byt_gpio.2") && offset >= 11 && offset <= 21){
-                writel(value & ~BYT_GPIO_FUNC, reg);
-        } else {
-                writel(value | BYT_GPIO_FUNC, reg);
-        }
 	writel(value, reg);
 	virq = irq_find_mapping(vg->domain, offset);
 	irq_dispose_mapping(virq);
@@ -457,8 +459,7 @@ static int byt_gpio_irq_enable(unsigned hwirq, struct platform_device *pdev)
 	 */
 	irq_attr.ioapic = mp_find_ioapic(hwirq);
 	if(irq_attr.ioapic<0){
-		printk(KERN_ERR "ERROR: No IOAPIC for IRQ=%d DID=0x%x \n",
-						hwirq, (unsigned int) dev);
+		dev_err(&pdev->dev, "No IOAPIC for IRQ=%d \n", hwirq);
 		return irq_attr.ioapic;
 	}
 	irq_attr.ioapic_pin = hwirq;
-- 
1.7.5.4

