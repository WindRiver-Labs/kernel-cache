From a8a545a89fe15c0c12b08974289fe2fa02cbcd84 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 18:29:03 +0800
Subject: [PATCH 091/134] ACPI / PM: Fix consistency check for power resources
 during resume

upstream: 660b1113e0f33a476952cb2cbcb5c9831e7ff4cd

During system resume we check if there are power resources that have
been turned off by the BIOS, but our reference counters for them
are nonzero (they need to be turned on then).  It turns out, however,
that we also need to check the opposite, i.e. if there are power
resources that have been turned on by the BIOS, but our reference
counters for them are zero (which means that no devices are going
to need them any time soon) and we should turn them off.

Make the power resources resume code do the additional check and
turn off the unused power resources as appropriate.

This change has been tested on HP nx6325.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/power.c |   28 ++++++++++++++++++----------
 1 files changed, 18 insertions(+), 10 deletions(-)

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 962fc2a..0bc4335 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -300,9 +300,22 @@ static int acpi_power_on(struct acpi_power_resource *resource)
 	return result;
 }
 
+static int __acpi_power_off(struct acpi_power_resource *resource)
+{
+	acpi_status status;
+
+	status = acpi_evaluate_object(resource->device.handle, "_OFF",
+				      NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned off\n",
+			  resource->name));
+	return 0;
+}
+
 static int acpi_power_off(struct acpi_power_resource *resource)
 {
-	acpi_status status = AE_OK;
 	int result = 0;
 
 	mutex_lock(&resource->resource_lock);
@@ -318,17 +331,12 @@ static int acpi_power_off(struct acpi_power_resource *resource)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] still in use\n",
 				  resource->name));
-		goto unlock;
+	} else {
+		result = __acpi_power_off(resource);
+		if (result)
+			resource->ref_count++;
 	}
 
-	status = acpi_evaluate_object(resource->device.handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		result = -ENODEV;
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Power resource [%s] turned off\n",
-				  resource->name));
-
  unlock:
 	mutex_unlock(&resource->resource_lock);
 
-- 
1.7.5.4

