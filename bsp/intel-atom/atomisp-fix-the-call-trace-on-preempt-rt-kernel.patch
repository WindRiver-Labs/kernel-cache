From d7d51cb49ac7396fad9fde40eec3b4892bd363d2 Mon Sep 17 00:00:00 2001
From: fli <fupan.li@windriver.com>
Date: Tue, 14 Jan 2014 15:53:46 +0800
Subject: [PATCH] atomisp: fix the call trace on preempt-rt kernel

on preempt-rt kernel, the atomisp driver will cause the following
call trace:

BUG: sleeping function called from invalid context at /home/jagalind/windriver/linux-windriver/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Pid: 0, comm: swapper/0 Not tainted 3.4.43-rt56-WR5.0.1.0_preempt-rt+ #1
Call Trace:
 [<c105a6ee>] __might_sleep+0xce/0x100
 [<c170acec>] rt_spin_lock+0x1c/0x40
 [<f95c0870>] atomisp_css2_hw_load_32+0x20/0x40 [atomisp]
 [<f95e9e8e>] device_load_uint32+0xe/0x10 [atomisp]
 [<f95e2acb>] irq_reg_load+0x4b/0xa0 [atomisp]
 [<c106696a>] ? enqueue_pushable_task+0x6a/0x90
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95e3500>] virq_get_channel_id+0x20/0x190 [atomisp]
 [<c105af0c>] ? resched_task+0x3c/0x70
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95c47a0>] ia_css_irq_translate+0x30/0x1f0 [atomisp]
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95af310>] atomisp_isr+0x20/0x3d0 [atomisp]
 [<c170af97>] ? _raw_spin_unlock_irqrestore+0x17/0x40
 [<c101fc82>] ? assign_irq_vector+0x42/0x60
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<c10983ca>] handle_irq_event_percpu+0x7a/0x330
 [<c1020401>] ? msi_set_affinity+0x61/0x70
 [<c13621de>] ? acpi_idle_enter_c1+0x9f/0xc1
 [<c1325baf>] ? msi_set_mask_bit+0x6f/0x80
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<c10986c2>] handle_irq_event+0x42/0x60
 [<c109a9f6>] handle_edge_irq+0x66/0x120
 <IRQ>  [<c1711c78>] ? do_IRQ+0x48/0xc0
 [<c10654dc>] ? idle_balance+0x14c/0x170
 [<c1711ba9>] ? common_interrupt+0x29/0x30
 [<c103007b>] ? update_console_cmdline+0x1b/0x90
 [<c13621de>] ? acpi_idle_enter_c1+0x9f/0xc1
 [<c157fabb>] ? cpuidle_enter+0x1b/0x30
 [<c1580070>] ? cpuidle_idle_call+0xa0/0x310
 [<c1009e7a>] ? cpu_idle+0x5a/0xd0
 [<c16e3f90>] ? rest_init+0x6c/0x7c
 [<c1a12714>] ? start_kernel+0x31b/0x322
 [<c1a12231>] ? repair_env_string+0x51/0x51
 [<c1a12078>] ? i386_start_kernel+0x78/0x7d

Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/media/atomisp2/atomisp_cmd.c             |   16 +++++-----
 drivers/media/atomisp2/atomisp_internal.h        |    2 +-
 drivers/media/atomisp2/atomisp_ioctl.c           |    8 ++--
 drivers/media/atomisp2/atomisp_v4l2.c            |    8 ++--
 drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c |   34 +++++++++++-----------
 drivers/media/v4l2-core/v4l2-dev.c               |    2 +-
 drivers/media/v4l2-core/v4l2-event.c             |   28 +++++++++---------
 drivers/media/v4l2-core/v4l2-fh.c                |   12 ++++----
 include/media/v4l2-dev.h                         |    2 +-
 9 files changed, 56 insertions(+), 56 deletions(-)

diff --git a/drivers/media/atomisp2/atomisp_cmd.c b/drivers/media/atomisp2/atomisp_cmd.c
index e70d860..522717a 100644
--- a/drivers/media/atomisp2/atomisp_cmd.c
+++ b/drivers/media/atomisp2/atomisp_cmd.c
@@ -593,7 +593,7 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 	msg_ret |= 1 << INTR_IIR;
 	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
@@ -639,12 +639,12 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 		/* TODO: handle SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN */
 	}
 
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_WAKE_THREAD;
 
 out_nowake:
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -1506,11 +1506,11 @@ irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 	memset(css_pipe_done, 0, sizeof(css_pipe_done));
 	mutex_lock(&isp->mutex);
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
 		    ATOMISP_DEVICE_STREAMING_ENABLED;
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 	if (!streaming)
 		goto out;
 
@@ -2708,12 +2708,12 @@ int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
 		return -EINVAL;
 
 	/* isp needs to be streaming to get DIS statistics */
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
-		spin_unlock_irqrestore(&isp->lock, flags);
+		raw_spin_unlock_irqrestore(&isp->lock, flags);
 		return -EINVAL;
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!isp_subdev->params.video_dis_en)
 		return -EINVAL;
diff --git a/drivers/media/atomisp2/atomisp_internal.h b/drivers/media/atomisp2/atomisp_internal.h
index 6a5e2b0..ec13260 100644
--- a/drivers/media/atomisp2/atomisp_internal.h
+++ b/drivers/media/atomisp2/atomisp_internal.h
@@ -279,7 +279,7 @@ struct atomisp_device {
 	atomic_t sequence;      /* Sequence value that is assigned to buffer. */
 	atomic_t sequence_temp;
 
-	spinlock_t lock; /* Just for streaming below */
+	raw_spinlock_t lock; /* Just for streaming below */
 
 	bool need_gfx_throttle;
 
diff --git a/drivers/media/atomisp2/atomisp_ioctl.c b/drivers/media/atomisp2/atomisp_ioctl.c
index c7d711c..0a24759 100644
--- a/drivers/media/atomisp2/atomisp_ioctl.c
+++ b/drivers/media/atomisp2/atomisp_ioctl.c
@@ -1565,13 +1565,13 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 		return 0;
 
 	atomisp_clear_frame_counters(isp_subdev);
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
 	    || isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STARTING) {
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
 		first_streamoff = true;
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (first_streamoff) {
 		mutex_unlock(&isp->mutex);
@@ -1593,10 +1593,10 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 		atomisp_acc_unload_extensions(isp);
 	}
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (atomisp_streaming_count(isp_subdev) <= 1)
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!first_streamoff) {
 		ret = vb2_ioctl_streamoff(file, fh,  type);
diff --git a/drivers/media/atomisp2/atomisp_v4l2.c b/drivers/media/atomisp2/atomisp_v4l2.c
index a27778b..26a1f89 100644
--- a/drivers/media/atomisp2/atomisp_v4l2.c
+++ b/drivers/media/atomisp2/atomisp_v4l2.c
@@ -461,16 +461,16 @@ static int atomisp_suspend(struct device *dev)
 	if (atomisp_dev_users(isp))
 		return -EBUSY;
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	for(i=0;i<isp->num_of_streams;i++)
 	{
 		if (isp->isp_subdev[i].streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
-			spin_unlock_irqrestore(&isp->lock, flags);
+			raw_spin_unlock_irqrestore(&isp->lock, flags);
 			v4l2_err(&atomisp_dev,
 				    "atomisp cannot suspend at this time.\n");
 			return -EINVAL;
 		}
-		spin_unlock_irqrestore(&isp->lock, flags);
+		raw_spin_unlock_irqrestore(&isp->lock, flags);
 	}
 
 	/* Prepare for MRFLD IUNIT power down */
@@ -1046,7 +1046,7 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	mutex_init(&isp->mutex);
 	mutex_init(&isp->streamoff_mutex);
 	mutex_init(&isp->vb2mutex);
-	spin_lock_init(&isp->lock);
+	raw_spin_lock_init(&isp->lock);
 	init_completion(&isp->init_done);
 
 	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
index ceaa074..56e9c0b 100644
--- a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
@@ -37,7 +37,7 @@ static unsigned init_done;
  * to serialize MMIO access , this is due to ISP2400 silicon issue Sighting
  * #4684168, if concurrency access happened, system may hard hang. Sighting #4600742 also points to system hard hang upon access to IUNIT MMIO.
  */
-static DEFINE_SPINLOCK(mmio_lock);
+static DEFINE_RAW_SPINLOCK(mmio_lock);
 
 void hrt_isp_css_mm_init(void)
 {
@@ -270,34 +270,34 @@ void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	_hrt_master_port_store_8(addr, data);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 }
 void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	_hrt_master_port_store_16(addr, data);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 }
 void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	_hrt_master_port_store_32(addr, data);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 }
 uint8_t atomisp_css2_hw_load_8(hrt_address addr)
 {
 	unsigned long flags;
 	uint8_t ret;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	ret = _hrt_master_port_load_8(addr);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 	return ret;
 }
 uint16_t atomisp_css2_hw_load_16(hrt_address addr)
@@ -305,9 +305,9 @@ uint16_t atomisp_css2_hw_load_16(hrt_address addr)
 	unsigned long flags;
 	uint16_t ret;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	ret = _hrt_master_port_load_16(addr);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 	return ret;
 }
 uint32_t atomisp_css2_hw_load_32(hrt_address addr)
@@ -315,9 +315,9 @@ uint32_t atomisp_css2_hw_load_32(hrt_address addr)
 	unsigned long flags;
 	uint32_t ret;
 
-	spin_lock_irqsave(&mmio_lock, flags);
+	raw_spin_lock_irqsave(&mmio_lock, flags);
 	ret = _hrt_master_port_load_32(addr);
-	spin_unlock_irqrestore(&mmio_lock, flags);
+	raw_spin_unlock_irqrestore(&mmio_lock, flags);
 	return ret;
 }
 
@@ -329,9 +329,9 @@ void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n)
 	const char *_from = (const char *)from;
 	for (i = 0; i < n; i++, _to++, _from++)
 	{
-		spin_lock_irqsave(&mmio_lock, flags);
+		raw_spin_lock_irqsave(&mmio_lock, flags);
 		_hrt_master_port_store_8(_to , *_from);
-		spin_unlock_irqrestore(&mmio_lock, flags);
+		raw_spin_unlock_irqrestore(&mmio_lock, flags);
 	}
 }
 
@@ -343,9 +343,9 @@ void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)
 	unsigned int _from = (unsigned int)addr;
 	for (i = 0; i < n; i++, _to++, _from++)
 	{
-		spin_lock_irqsave(&mmio_lock, flags);
+		raw_spin_lock_irqsave(&mmio_lock, flags);
 		*_to = _hrt_master_port_load_8(_from);
-		spin_unlock_irqrestore(&mmio_lock, flags);
+		raw_spin_unlock_irqrestore(&mmio_lock, flags);
 	}
 }
 #endif
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index 98dcad9..0ea1d8a 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -782,7 +782,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 		return -EINVAL;
 
 	/* v4l2_fh support */
-	spin_lock_init(&vdev->fh_lock);
+	raw_spin_lock_init(&vdev->fh_lock);
 	INIT_LIST_HEAD(&vdev->fh_list);
 
 	/* Part 1: check device type */
diff --git a/drivers/media/v4l2-core/v4l2-event.c b/drivers/media/v4l2-core/v4l2-event.c
index ef2a33c..f23770a 100644
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -41,10 +41,10 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	struct v4l2_kevent *kev;
 	unsigned long flags;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	if (list_empty(&fh->available)) {
-		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		return -ENOENT;
 	}
 
@@ -59,7 +59,7 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	kev->sev->first = sev_pos(kev->sev, 1);
 	kev->sev->in_use--;
 
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	return 0;
 }
@@ -98,7 +98,7 @@ static struct v4l2_subscribed_event *v4l2_event_subscribed(
 {
 	struct v4l2_subscribed_event *sev;
 
-	assert_spin_locked(&fh->vdev->fh_lock);
+	assert_raw_spin_locked(&fh->vdev->fh_lock);
 
 	list_for_each_entry(sev, &fh->subscribed, list)
 		if (sev->type == type && sev->id == id)
@@ -174,12 +174,12 @@ void v4l2_event_queue(struct video_device *vdev, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	spin_lock_irqsave(&vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&vdev->fh_lock, flags);
 
 	list_for_each_entry(fh, &vdev->fh_list, list)
 		__v4l2_event_queue_fh(fh, ev, &timestamp);
 
-	spin_unlock_irqrestore(&vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue);
 
@@ -190,9 +190,9 @@ void v4l2_event_queue_fh(struct v4l2_fh *fh, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	__v4l2_event_queue_fh(fh, ev, &timestamp);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue_fh);
 
@@ -227,11 +227,11 @@ int v4l2_event_subscribe(struct v4l2_fh *fh,
 	sev->fh = fh;
 	sev->ops = ops;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (!found_ev)
 		list_add(&sev->list, &fh->subscribed);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (found_ev) {
 		kfree(sev);
@@ -263,14 +263,14 @@ void v4l2_event_unsubscribe_all(struct v4l2_fh *fh)
 	do {
 		sev = NULL;
 
-		spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+		raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 		if (!list_empty(&fh->subscribed)) {
 			sev = list_first_entry(&fh->subscribed,
 					struct v4l2_subscribed_event, list);
 			sub.type = sev->type;
 			sub.id = sev->id;
 		}
-		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		if (sev)
 			v4l2_event_unsubscribe(fh, &sub);
 	} while (sev);
@@ -289,7 +289,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		return 0;
 	}
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	sev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (sev != NULL) {
@@ -301,7 +301,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		list_del(&sev->list);
 	}
 
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (sev && sev->ops && sev->ops->del)
 		sev->ops->del(sev);
diff --git a/drivers/media/v4l2-core/v4l2-fh.c b/drivers/media/v4l2-core/v4l2-fh.c
index 9e3fc04..80d90da 100644
--- a/drivers/media/v4l2-core/v4l2-fh.c
+++ b/drivers/media/v4l2-core/v4l2-fh.c
@@ -51,9 +51,9 @@ void v4l2_fh_add(struct v4l2_fh *fh)
 
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_open(fh->vdev->prio, &fh->prio);
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_add(&fh->list, &fh->vdev->fh_list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_add);
 
@@ -75,9 +75,9 @@ void v4l2_fh_del(struct v4l2_fh *fh)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_del_init(&fh->list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_close(fh->vdev->prio, fh->prio);
 }
@@ -112,9 +112,9 @@ int v4l2_fh_is_singular(struct v4l2_fh *fh)
 
 	if (fh == NULL || fh->vdev == NULL)
 		return 0;
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	is_singular = list_is_singular(&fh->list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	return is_singular;
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_is_singular);
diff --git a/include/media/v4l2-dev.h b/include/media/v4l2-dev.h
index 95d1c91..8aa2913 100644
--- a/include/media/v4l2-dev.h
+++ b/include/media/v4l2-dev.h
@@ -122,7 +122,7 @@ struct video_device
 	int index;
 
 	/* V4L2 file handles */
-	spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
+	raw_spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
 	struct list_head	fh_list; /* List of struct v4l2_fh */
 
 	int debug;			/* Activates debug level*/
-- 
1.7.5.4

