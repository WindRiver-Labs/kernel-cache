From 41ded564e0d9ed66ca249b40871173ee0c2326c3 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 29 Jun 2012 13:06:46 +0800
Subject: [PATCH 1/8] gpio: fix interupt handler of accelerometer not to be
 executed

* add two addition parameters, gpe_device and gpe_number since a new
  GPE handler callback is definited
typedef
u32 (*acpi_gpe_handler) (acpi_handle gpe_device, u32 gpe_number,
			void *context);

* The return value of a GPE handler installed by pca953x needs to add
  ACPI_REENABLE_GPE flag to reenable corresponding GPE.

* The GPE is not enabled after invoking acpi_install_gpe_handler to
  install gpe handler. Therefore, it needs to call acpi_enable_gpe to
  enable corresponding GPE.

Signed-off-by: Yang Wei <wei.yang@windriver.com>
---
 drivers/gpio/gpio-pca953x.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index ad32959..bf4fe77 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -622,7 +622,7 @@ static int pca95xx_irq_thread_setup(void)
  * one GPE handler for BOTH pca9555 chips. call pca95xx_gpe_test_chip
  * for each chip.
  */
-static u32 pca95xx_gpe_handler(void *context)
+static u32 pca95xx_gpe_handler(acpi_handle gpe_device, u32 gpe_number, void *context)
 {
 
 	inb(acpi_gbl_FADT.gpe0_block + GPEC);
@@ -630,7 +630,7 @@ static u32 pca95xx_gpe_handler(void *context)
 	set_bit(FLGS_RUNTHREAD, &flgs);
 	wake_up_process(pca95xx_irq_thread);
 
-	return ACPI_INTERRUPT_HANDLED;
+	return ACPI_INTERRUPT_HANDLED | ACPI_REENABLE_GPE;
 
 }
 
@@ -716,6 +716,7 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 				       GPIO_GPE);
 				goto out_failed;
 			} else {
+				acpi_enable_gpe(NULL, GPIO_GPE);
 				printk("  Using ACPI GPE %d\n", GPIO_GPE);
 			}
 		}
-- 
1.7.7

