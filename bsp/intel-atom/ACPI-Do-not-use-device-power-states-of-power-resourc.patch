From 77ef4ebded03360f1780184b8771ff6a9ee2da55 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 16:59:23 +0800
Subject: [PATCH 066/134] ACPI: Do not use device power states of power
 resources

upstream: 722c929f32616943d2b67332068f09c08e81eec8

ACPI power resource objects have struct acpi_device components, but
they are only used for registering those resources in the device
hierarchy.  In particular, power state information stored in them is
completely useless (amnong other things, because the power resources
"devices" are not power manageable), so there is no reason for the
power resources management code to keep it up to date.

Remove the code updating device power states of power resources from
drivers/acpi/power.c.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/power.c |   23 +++--------------------
 1 files changed, 3 insertions(+), 20 deletions(-)

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 735c157..3f0594d 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -194,9 +194,6 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	/* Update the power resource's _device_ power state */
-	resource->device.power.state = ACPI_STATE_D0;
-
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
 
@@ -262,16 +259,12 @@ static int acpi_power_off(acpi_handle handle)
 	}
 
 	status = acpi_evaluate_object(resource->device.handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status)) {
+	if (ACPI_FAILURE(status))
 		result = -ENODEV;
-	} else {
-		/* Update the power resource's _device_ power state */
-		resource->device.power.state = ACPI_STATE_D3;
-
+	else
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] turned off\n",
 				  resource->name));
-	}
 
  unlock:
 	mutex_unlock(&resource->resource_lock);
@@ -653,6 +646,7 @@ void acpi_add_power_resource(acpi_handle handle)
 	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
+	device->power.state = ACPI_STATE_UNKNOWN;
 
 	/* Evalute the object to get the system level and resource order. */
 	status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
@@ -666,17 +660,6 @@ void acpi_add_power_resource(acpi_handle handle)
 	if (result)
 		goto err;
 
-	switch (state) {
-	case ACPI_POWER_RESOURCE_STATE_ON:
-		device->power.state = ACPI_STATE_D0;
-		break;
-	case ACPI_POWER_RESOURCE_STATE_OFF:
-		device->power.state = ACPI_STATE_D3;
-		break;
-	default:
-		device->power.state = ACPI_STATE_UNKNOWN;
-	}
-
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
 	       acpi_device_bid(device), state ? "on" : "off");
 
-- 
1.7.5.4

