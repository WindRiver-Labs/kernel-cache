From 15acbfbe6c87bf7b786b38813ca05f27665b2654 Mon Sep 17 00:00:00 2001
From: fli <fupan.li@windriver.com>
Date: Thu, 19 Dec 2013 14:35:37 +0800
Subject: [PATCH 001/252] add the BayTrail ATOMISP driver

This patch is the refactor of the Intel ATOMISP Gold 2.1 Package

Signed-off-by: fli <fupan.li@windriver.com>
---
 arch/x86/platform/Makefile                         |    1 +
 arch/x86/platform/intel-atom/Makefile              |    7 +
 arch/x86/platform/intel-atom/board_anvl.c          |  246 +
 arch/x86/platform/intel-atom/board_anvl.h          |   49 +
 arch/x86/platform/intel-atom/byt_plat_clock.c      |  181 +
 arch/x86/platform/intel-atom/platform_camera.c     |  316 +
 arch/x86/platform/intel-atom/platform_camera.h     |   50 +
 arch/x86/platform/intel-atom/platform_mt9m114.c    |  231 +
 arch/x86/platform/intel-atom/platform_mt9m114.h    |   18 +
 arch/x86/platform/intel-atom/platform_ov5640_1.c   |  117 +
 arch/x86/platform/intel-atom/platform_ov5640_1.h   |   17 +
 arch/x86/platform/intel-atom/platform_ov5640_2.c   |  122 +
 arch/x86/platform/intel-atom/platform_ov5640_2.h   |   18 +
 drivers/media/Kconfig                              |    5 +
 drivers/media/Makefile                             |    4 +
 drivers/media/atomisp2/Kconfig                     |   19 +
 drivers/media/atomisp2/Makefile                    |  103 +
 drivers/media/atomisp2/atomisp-regs.h              |  147 +
 drivers/media/atomisp2/atomisp_acc.c               | 1106 +++
 drivers/media/atomisp2/atomisp_acc.h               |  115 +
 drivers/media/atomisp2/atomisp_cmd.c               | 4924 +++++++++++
 drivers/media/atomisp2/atomisp_cmd.h               |  334 +
 drivers/media/atomisp2/atomisp_common.h            |   80 +
 drivers/media/atomisp2/atomisp_compat.c            |  870 ++
 drivers/media/atomisp2/atomisp_compat.h            |  129 +
 drivers/media/atomisp2/atomisp_csi2.c              |  387 +
 drivers/media/atomisp2/atomisp_csi2.h              |   55 +
 drivers/media/atomisp2/atomisp_file.c              |  351 +
 drivers/media/atomisp2/atomisp_file.h              |   51 +
 drivers/media/atomisp2/atomisp_fops.c              | 1024 +++
 drivers/media/atomisp2/atomisp_fops.h              |   69 +
 drivers/media/atomisp2/atomisp_fw.h                |   68 +
 drivers/media/atomisp2/atomisp_helper.h            |   33 +
 drivers/media/atomisp2/atomisp_internal.h          |  326 +
 drivers/media/atomisp2/atomisp_ioctl.c             | 2512 ++++++
 drivers/media/atomisp2/atomisp_ioctl.h             |   72 +
 drivers/media/atomisp2/atomisp_subdev.c            | 1026 +++
 drivers/media/atomisp2/atomisp_subdev.h            |  299 +
 drivers/media/atomisp2/atomisp_tables.h            |  327 +
 drivers/media/atomisp2/atomisp_tpg.c               |  247 +
 drivers/media/atomisp2/atomisp_tpg.h               |   42 +
 drivers/media/atomisp2/atomisp_v4l2.c              | 1227 +++
 drivers/media/atomisp2/atomisp_v4l2.h              |   35 +
 .../hive_isp_css_2400_system/debug_global.h        |   60 +
 .../css2400/hive_isp_css_2400_system/dma_global.h  |  266 +
 .../hive_isp_css_2400_system/event_global.h        |    6 +
 .../hive_isp_css_2400_system/fifo_monitor_global.h |   18 +
 .../css2400/hive_isp_css_2400_system/gdc_global.h  |   70 +
 .../hive_isp_css_2400_system/gp_device_global.h    |   71 +
 .../css2400/hive_isp_css_2400_system/gpio_global.h |   31 +
 .../css2400/hive_isp_css_2400_system/hmem_global.h |   35 +
 .../css2400/hive_isp_css_2400_system/host/debug.c  |   64 +
 .../hive_isp_css_2400_system/host/debug_local.h    |    7 +
 .../hive_isp_css_2400_system/host/debug_private.h  |   88 +
 .../css2400/hive_isp_css_2400_system/host/dma.c    |  269 +
 .../hive_isp_css_2400_system/host/dma_local.h      |  193 +
 .../hive_isp_css_2400_system/host/dma_private.h    |   30 +
 .../css2400/hive_isp_css_2400_system/host/event.c  |    6 +
 .../hive_isp_css_2400_system/host/event_local.h    |   43 +
 .../hive_isp_css_2400_system/host/event_private.h  |   69 +
 .../hive_isp_css_2400_system/host/fifo_monitor.c   |  556 ++
 .../host/fifo_monitor_local.h                      |   88 +
 .../host/fifo_monitor_private.h                    |   63 +
 .../css2400/hive_isp_css_2400_system/host/gdc.c    |   81 +
 .../hive_isp_css_2400_system/host/gdc_local.h      |    6 +
 .../hive_isp_css_2400_system/host/gdc_private.h    |    6 +
 .../hive_isp_css_2400_system/host/gp_device.c      |   93 +
 .../host/gp_device_local.h                         |  128 +
 .../host/gp_device_private.h                       |   32 +
 .../hive_isp_css_2400_system/host/gpio_local.h     |    6 +
 .../hive_isp_css_2400_system/host/gpio_private.h   |   30 +
 .../host/hive_isp_css_ddr_hrt_modified.h           |  134 +
 .../host/hive_isp_css_hrt_modified.h               |   84 +
 .../css2400/hive_isp_css_2400_system/host/hmem.c   |    6 +
 .../hive_isp_css_2400_system/host/hmem_local.h     |    6 +
 .../hive_isp_css_2400_system/host/hmem_private.h   |   16 +
 .../host/input_formatter.c                         |  204 +
 .../host/input_formatter_local.h                   |  109 +
 .../host/input_formatter_private.h                 |   32 +
 .../hive_isp_css_2400_system/host/input_system.c   | 1811 +++++
 .../host/input_system_local.h                      |  537 ++
 .../host/input_system_private.h                    |  102 +
 .../css2400/hive_isp_css_2400_system/host/irq.c    |  436 +
 .../hive_isp_css_2400_system/host/irq_local.h      |  122 +
 .../hive_isp_css_2400_system/host/irq_private.h    |   30 +
 .../css2400/hive_isp_css_2400_system/host/isp.c    |   70 +
 .../hive_isp_css_2400_system/host/isp_local.h      |   41 +
 .../hive_isp_css_2400_system/host/isp_private.h    |  248 +
 .../css2400/hive_isp_css_2400_system/host/mmu.c    |   29 +
 .../hive_isp_css_2400_system/host/mmu_local.h      |    8 +
 .../hive_isp_css_2400_system/host/mmu_private.h    |   30 +
 .../css2400/hive_isp_css_2400_system/host/sp.c     |   63 +
 .../hive_isp_css_2400_system/host/sp_local.h       |   95 +
 .../hive_isp_css_2400_system/host/sp_private.h     |  178 +
 .../hive_isp_css_2400_system/host/system_local.h   |  285 +
 .../hive_isp_css_2400_system/host/timed_ctrl.c     |   63 +
 .../host/timed_ctrl_local.h                        |    6 +
 .../host/timed_ctrl_private.h                      |   21 +
 .../hive_isp_css_2400_system/host/vamem_local.h    |    6 +
 .../input_formatter_global.h                       |   99 +
 .../hive_isp_css_2400_system/input_system_global.h |  145 +
 .../css2400/hive_isp_css_2400_system/irq_global.h  |   29 +
 .../css2400/hive_isp_css_2400_system/isp_global.h  |   86 +
 .../css2400/hive_isp_css_2400_system/mmu_global.h  |    8 +
 .../program_load/program_load.c                    |    1 +
 .../hive_isp_css_2400_system/resource_global.h     |   21 +
 .../css2400/hive_isp_css_2400_system/sp_global.h   |   80 +
 .../hive_isp_css_2400_system/system_global.h       |  286 +
 .../hive_isp_css_2400_system/timed_ctrl_global.h   |   37 +
 .../hive_isp_css_2400_system/vamem_global.h        |   24 +
 .../css2400/hive_isp_css_include/addr_support.h    |   15 +
 .../css2400/hive_isp_css_include/assert_support.h  |   51 +
 .../css2400/hive_isp_css_include/csc_kernel.h      |   36 +
 .../atomisp2/css2400/hive_isp_css_include/debug.h  |   34 +
 .../device_access/device_access.h                  |  171 +
 .../atomisp2/css2400/hive_isp_css_include/dma.h    |   34 +
 .../atomisp2/css2400/hive_isp_css_include/event.h  |   33 +
 .../css2400/hive_isp_css_include/fifo_monitor.h    |   33 +
 .../css2400/hive_isp_css_include/gdc_device.h      |   35 +
 .../css2400/hive_isp_css_include/gp_device.h       |   33 +
 .../atomisp2/css2400/hive_isp_css_include/gpio.h   |   33 +
 .../atomisp2/css2400/hive_isp_css_include/hmem.h   |   33 +
 .../hive_isp_css_include/host/debug_public.h       |   88 +
 .../css2400/hive_isp_css_include/host/dma_public.h |   44 +
 .../hive_isp_css_include/host/event_public.h       |   68 +
 .../host/fifo_monitor_public.h                     |   96 +
 .../css2400/hive_isp_css_include/host/gdc_public.h |   35 +
 .../hive_isp_css_include/host/gp_device_public.h   |   44 +
 .../hive_isp_css_include/host/gpio_public.h        |   31 +
 .../hive_isp_css_include/host/hmem_public.h        |   18 +
 .../host/ia_css_i_rmgr_public.h                    |    8 +
 .../host/ia_css_i_rmgr_vbuf_public.h               |   17 +
 .../host/input_formatter_public.h                  |  104 +
 .../host/input_system_public.h                     |  360 +
 .../css2400/hive_isp_css_include/host/irq_public.h |  176 +
 .../css2400/hive_isp_css_include/host/isp_public.h |  262 +
 .../css2400/hive_isp_css_include/host/mmu_public.h |   62 +
 .../hive_isp_css_include/host/pipeline_public.h    |    4 +
 .../hive_isp_css_include/host/queue_public.h       |   98 +
 .../css2400/hive_isp_css_include/host/sp_public.h  |  216 +
 .../hive_isp_css_include/host/sw_event_public.h    |   34 +
 .../css2400/hive_isp_css_include/host/tag_public.h |   27 +
 .../hive_isp_css_include/host/timed_ctrl_public.h  |   47 +
 .../hive_isp_css_include/host/vamem_public.h       |    6 +
 .../css2400/hive_isp_css_include/ia_css_i_rmgr.h   |   59 +
 .../css2400/hive_isp_css_include/input_formatter.h |   33 +
 .../css2400/hive_isp_css_include/input_system.h    |   33 +
 .../atomisp2/css2400/hive_isp_css_include/irq.h    |   33 +
 .../atomisp2/css2400/hive_isp_css_include/isp.h    |   33 +
 .../css2400/hive_isp_css_include/math_support.h    |  367 +
 .../memory_access/memory_access.h                  |  269 +
 .../css2400/hive_isp_css_include/mmu_device.h      |   35 +
 .../css2400/hive_isp_css_include/pipeline.h        |   40 +
 .../hive_isp_css_include/platform_support.h        |   56 +
 .../css2400/hive_isp_css_include/print_support.h   |   28 +
 .../program_load/program_load.h                    |   11 +
 .../atomisp2/css2400/hive_isp_css_include/queue.h  |   32 +
 .../css2400/hive_isp_css_include/resource.h        |   34 +
 .../atomisp2/css2400/hive_isp_css_include/sp.h     |   33 +
 .../css2400/hive_isp_css_include/storage_class.h   |   14 +
 .../css2400/hive_isp_css_include/sw_event.h        |   43 +
 .../css2400/hive_isp_css_include/system_types.h    |    6 +
 .../atomisp2/css2400/hive_isp_css_include/tag.h    |   32 +
 .../css2400/hive_isp_css_include/timed_ctrl.h      |   33 +
 .../atomisp2/css2400/hive_isp_css_include/vamem.h  |   33 +
 .../css2400/hive_isp_css_include/vector_func.h     |   18 +
 .../css2400/hive_isp_css_include/vector_ops.h      |   18 +
 .../hive_isp_css_kernel/csc/csc_kernel_global.h    |   32 +
 .../csc/host/csc_kernel_local.h                    |    6 +
 .../pipeline/host/pipeline_local.h                 |    6 +
 .../hive_isp_css_kernel/pipeline/pipeline_global.h |  262 +
 .../host/ia_css_i_host_rmgr_gen_shared.c           |  389 +
 .../host/ia_css_i_host_rmgr_gen_shared.h           |   47 +
 .../host/ia_css_i_rmgr_gen_shared.c                |  265 +
 .../host/ia_css_i_rmgr_shared.c                    |   23 +
 .../host/ia_css_i_rmgr_vbuf_shared.c               |  245 +
 .../host/ia_css_i_rmgr_vbuf_shared.h               |   34 +
 .../css2400/hive_isp_css_shared/host/queue.c       |  696 ++
 .../css2400/hive_isp_css_shared/host/queue_local.h |    6 +
 .../hive_isp_css_shared/host/queue_private.h       |    4 +
 .../css2400/hive_isp_css_shared/host/sw_event.c    |   70 +
 .../hive_isp_css_shared/host/sw_event_local.h      |   16 +
 .../hive_isp_css_shared/host/sw_event_private.h    |   14 +
 .../css2400/hive_isp_css_shared/host/tag.c         |   78 +
 .../css2400/hive_isp_css_shared/host/tag_local.h   |    8 +
 .../css2400/hive_isp_css_shared/host/tag_private.h |    4 +
 .../css2400/hive_isp_css_shared/queue_global.h     |    5 +
 .../css2400/hive_isp_css_shared/sw_event_global.h  |   47 +
 .../css2400/hive_isp_css_shared/tag_global.h       |   42 +
 drivers/media/atomisp2/css2400/hrt/bits.h          |  113 +
 drivers/media/atomisp2/css2400/hrt/cell_params.h   |   51 +
 .../css2400/hrt/css_receiver_2400_common_defs.h    |  209 +
 .../atomisp2/css2400/hrt/css_receiver_2400_defs.h  |  267 +
 drivers/media/atomisp2/css2400/hrt/defs.h          |   45 +
 drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h   |  208 +
 drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h   |  179 +
 drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h  |   31 +
 .../media/atomisp2/css2400/hrt/gpio_block_defs.h   |   51 +
 .../media/atomisp2/css2400/hrt/hive_isp_css_defs.h |  441 +
 .../css2400/hrt/hive_isp_css_host_ids_hrt.h        |   95 +
 .../css2400/hrt/hive_isp_css_irq_types_hrt.h       |   81 +
 .../hrt/hive_isp_css_streaming_to_mipi_types_hrt.h |   35 +
 drivers/media/atomisp2/css2400/hrt/hive_types.h    |  137 +
 drivers/media/atomisp2/css2400/hrt/if_defs.h       |   31 +
 .../css2400/hrt/input_formatter_subsystem_defs.h   |   62 +
 .../atomisp2/css2400/hrt/input_selector_defs.h     |   98 +
 .../atomisp2/css2400/hrt/input_switch_2400_defs.h  |   39 +
 .../atomisp2/css2400/hrt/input_system_ctrl_defs.h  |  263 +
 .../media/atomisp2/css2400/hrt/input_system_defs.h |  135 +
 .../atomisp2/css2400/hrt/irq_controller_defs.h     |   37 +
 .../css2400/hrt/isp2400A0_mamoiada_params.h        |  267 +
 .../atomisp2/css2400/hrt/isp2400_mamoiada_params.h |  267 +
 .../atomisp2/css2400/hrt/isp_acquisition_defs.h    |  243 +
 .../media/atomisp2/css2400/hrt/isp_capture_defs.h  |  319 +
 drivers/media/atomisp2/css2400/hrt/mmu_defs.h      |   32 +
 .../css2400/hrt/scalar_processor_2400_params.h     |   29 +
 drivers/media/atomisp2/css2400/hrt/sp_hrt.h        |   31 +
 drivers/media/atomisp2/css2400/hrt/str2mem_defs.h  |   48 +
 .../atomisp2/css2400/hrt/streaming_to_mipi_defs.h  |   37 +
 .../atomisp2/css2400/hrt/timed_controller_defs.h   |   31 +
 drivers/media/atomisp2/css2400/hrt/var.h           |  106 +
 drivers/media/atomisp2/css2400/hrt/version.h       |   29 +
 drivers/media/atomisp2/css2400/ia_css.h            | 1653 ++++
 drivers/media/atomisp2/css2400/ia_css_acc.h        |  108 +
 drivers/media/atomisp2/css2400/ia_css_acc_types.h  |  438 +
 drivers/media/atomisp2/css2400/ia_css_acc_v1.h     |   70 +
 drivers/media/atomisp2/css2400/ia_css_accelerate.h |  106 +
 .../media/atomisp2/css2400/ia_css_device_access.c  |   75 +
 .../media/atomisp2/css2400/ia_css_device_access.h  |    9 +
 .../media/atomisp2/css2400/ia_css_memory_access.c  |   73 +
 .../media/atomisp2/css2400/ia_css_memory_access.h  |   10 +
 drivers/media/atomisp2/css2400/ia_css_stream.h     |   77 +
 drivers/media/atomisp2/css2400/ia_css_types.h      |  684 ++
 drivers/media/atomisp2/css2400/input_system_init.c |   68 +
 drivers/media/atomisp2/css2400/input_system_init.h |   11 +
 drivers/media/atomisp2/css2400/sh_css.c            | 8572 ++++++++++++++++++++
 drivers/media/atomisp2/css2400/sh_css_accelerate.c |  257 +
 drivers/media/atomisp2/css2400/sh_css_binary.c     |  857 ++
 drivers/media/atomisp2/css2400/sh_css_binary.h     |  194 +
 drivers/media/atomisp2/css2400/sh_css_debug.c      | 2452 ++++++
 drivers/media/atomisp2/css2400/sh_css_debug.h      |  292 +
 .../media/atomisp2/css2400/sh_css_debug_internal.h |   67 +
 drivers/media/atomisp2/css2400/sh_css_defs.h       |  423 +
 drivers/media/atomisp2/css2400/sh_css_firmware.c   |  159 +
 drivers/media/atomisp2/css2400/sh_css_firmware.h   |   56 +
 drivers/media/atomisp2/css2400/sh_css_hrt.c        |  623 ++
 drivers/media/atomisp2/css2400/sh_css_hrt.h        |   66 +
 drivers/media/atomisp2/css2400/sh_css_internal.h   |  928 +++
 drivers/media/atomisp2/css2400/sh_css_legacy.h     |  119 +
 drivers/media/atomisp2/css2400/sh_css_metrics.c    |  180 +
 drivers/media/atomisp2/css2400/sh_css_metrics.h    |   89 +
 drivers/media/atomisp2/css2400/sh_css_param_dvs.c  |  226 +
 drivers/media/atomisp2/css2400/sh_css_param_dvs.h  |   73 +
 .../media/atomisp2/css2400/sh_css_param_shading.c  |  279 +
 .../media/atomisp2/css2400/sh_css_param_shading.h  |   36 +
 drivers/media/atomisp2/css2400/sh_css_params.c     | 6685 +++++++++++++++
 drivers/media/atomisp2/css2400/sh_css_params.h     |  127 +
 .../atomisp2/css2400/sh_css_params_internal.h      |   30 +
 drivers/media/atomisp2/css2400/sh_css_refcount.c   |  239 +
 drivers/media/atomisp2/css2400/sh_css_refcount.h   |   50 +
 drivers/media/atomisp2/css2400/sh_css_rx.c         |  498 ++
 drivers/media/atomisp2/css2400/sh_css_rx.h         |   57 +
 drivers/media/atomisp2/css2400/sh_css_sp.c         | 1516 ++++
 drivers/media/atomisp2/css2400/sh_css_sp.h         |  253 +
 drivers/media/atomisp2/css2400/sh_css_sp_start.c   |  127 +
 drivers/media/atomisp2/css2400/sh_css_sp_start.h   |   60 +
 drivers/media/atomisp2/css2400/spmem_dump.c        | 3092 +++++++
 drivers/media/atomisp2/css2400/spmem_dumpA0.c      | 3015 +++++++
 drivers/media/atomisp2/hmm/hmm.c                   |  490 ++
 drivers/media/atomisp2/hmm/hmm_bo.c                | 1268 +++
 drivers/media/atomisp2/hmm/hmm_bo_dev.c            |  309 +
 drivers/media/atomisp2/hmm/hmm_dynamic_pool.c      |  228 +
 drivers/media/atomisp2/hmm/hmm_reserved_pool.c     |  245 +
 drivers/media/atomisp2/hmm/hmm_vm.c                |  220 +
 drivers/media/atomisp2/hrt/device_access.c         |  128 +
 .../atomisp2/hrt/hive_isp_css_custom_host_hrt.h    |  110 +
 drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c   |  351 +
 drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h   |  114 +
 drivers/media/atomisp2/hrt/memory_access.c         |  372 +
 drivers/media/atomisp2/include/hmm/hmm.h           |   83 +
 drivers/media/atomisp2/include/hmm/hmm_bo.h        |  310 +
 drivers/media/atomisp2/include/hmm/hmm_bo_dev.h    |  119 +
 drivers/media/atomisp2/include/hmm/hmm_common.h    |   81 +
 drivers/media/atomisp2/include/hmm/hmm_pool.h      |  119 +
 drivers/media/atomisp2/include/hmm/hmm_vm.h        |   68 +
 drivers/media/atomisp2/include/mmu/isp_mmu.h       |  177 +
 drivers/media/atomisp2/include/mmu/sh_mmu.h        |   76 +
 drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h   |   28 +
 drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h  |   28 +
 drivers/media/atomisp2/mmu/isp_mmu.c               |  578 ++
 drivers/media/atomisp2/mmu/sh_mmu_mfld.c           |   82 +
 drivers/media/atomisp2/mmu/sh_mmu_mrfld.c          |   92 +
 drivers/media/video/Kconfig                        |   14 +
 drivers/media/video/Makefile                       |    8 +
 drivers/media/video/mt9m114.c                      | 1632 ++++
 drivers/media/video/mt9m114.h                      | 2030 +++++
 drivers/media/video/ov5640_1.c                     | 2377 ++++++
 drivers/media/video/ov5640_1.h                     | 3492 ++++++++
 drivers/media/video/ov5640_2.c                     | 2382 ++++++
 drivers/media/video/ov5640_2.h                     | 3487 ++++++++
 include/linux/atomisp.h                            |  901 ++
 include/linux/atomisp_platform.h                   |  141 +
 302 files changed, 92607 insertions(+), 0 deletions(-)
 create mode 100644 arch/x86/platform/intel-atom/Makefile
 create mode 100644 arch/x86/platform/intel-atom/board_anvl.c
 create mode 100644 arch/x86/platform/intel-atom/board_anvl.h
 create mode 100644 arch/x86/platform/intel-atom/byt_plat_clock.c
 create mode 100644 arch/x86/platform/intel-atom/platform_camera.c
 create mode 100644 arch/x86/platform/intel-atom/platform_camera.h
 create mode 100644 arch/x86/platform/intel-atom/platform_mt9m114.c
 create mode 100644 arch/x86/platform/intel-atom/platform_mt9m114.h
 create mode 100644 arch/x86/platform/intel-atom/platform_ov5640_1.c
 create mode 100644 arch/x86/platform/intel-atom/platform_ov5640_1.h
 create mode 100644 arch/x86/platform/intel-atom/platform_ov5640_2.c
 create mode 100644 arch/x86/platform/intel-atom/platform_ov5640_2.h
 create mode 100644 drivers/media/atomisp2/Kconfig
 create mode 100644 drivers/media/atomisp2/Makefile
 create mode 100644 drivers/media/atomisp2/atomisp-regs.h
 create mode 100644 drivers/media/atomisp2/atomisp_acc.c
 create mode 100644 drivers/media/atomisp2/atomisp_acc.h
 create mode 100644 drivers/media/atomisp2/atomisp_cmd.c
 create mode 100644 drivers/media/atomisp2/atomisp_cmd.h
 create mode 100644 drivers/media/atomisp2/atomisp_common.h
 create mode 100644 drivers/media/atomisp2/atomisp_compat.c
 create mode 100644 drivers/media/atomisp2/atomisp_compat.h
 create mode 100644 drivers/media/atomisp2/atomisp_csi2.c
 create mode 100644 drivers/media/atomisp2/atomisp_csi2.h
 create mode 100644 drivers/media/atomisp2/atomisp_file.c
 create mode 100644 drivers/media/atomisp2/atomisp_file.h
 create mode 100644 drivers/media/atomisp2/atomisp_fops.c
 create mode 100644 drivers/media/atomisp2/atomisp_fops.h
 create mode 100644 drivers/media/atomisp2/atomisp_fw.h
 create mode 100644 drivers/media/atomisp2/atomisp_helper.h
 create mode 100644 drivers/media/atomisp2/atomisp_internal.h
 create mode 100644 drivers/media/atomisp2/atomisp_ioctl.c
 create mode 100644 drivers/media/atomisp2/atomisp_ioctl.h
 create mode 100644 drivers/media/atomisp2/atomisp_subdev.c
 create mode 100644 drivers/media/atomisp2/atomisp_subdev.h
 create mode 100644 drivers/media/atomisp2/atomisp_tables.h
 create mode 100644 drivers/media/atomisp2/atomisp_tpg.c
 create mode 100644 drivers/media/atomisp2/atomisp_tpg.h
 create mode 100644 drivers/media/atomisp2/atomisp_v4l2.c
 create mode 100644 drivers/media/atomisp2/atomisp_v4l2.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/program_load/program_load.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/addr_support.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/csc_kernel.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/event.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/queue_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/sw_event_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/ia_css_i_rmgr.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/pipeline.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/program_load/program_load.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/sw_event.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/csc_kernel_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/host/csc_kernel_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/host/pipeline_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/pipeline_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_gen_shared.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/bits.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/cell_params.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/hive_types.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/if_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/input_selector_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/input_system_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/isp2400A0_mamoiada_params.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/mmu_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/sp_hrt.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/str2mem_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/var.h
 create mode 100644 drivers/media/atomisp2/css2400/hrt/version.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_acc.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_acc_types.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_acc_v1.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_accelerate.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_device_access.c
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_device_access.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_memory_access.c
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_memory_access.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_stream.h
 create mode 100644 drivers/media/atomisp2/css2400/ia_css_types.h
 create mode 100644 drivers/media/atomisp2/css2400/input_system_init.c
 create mode 100644 drivers/media/atomisp2/css2400/input_system_init.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_accelerate.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_binary.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_binary.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_debug.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_debug.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_debug_internal.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_defs.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_firmware.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_firmware.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_hrt.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_hrt.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_internal.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_legacy.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_metrics.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_metrics.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_param_dvs.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_param_dvs.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_param_shading.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_param_shading.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_params.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_params.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_params_internal.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_refcount.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_refcount.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_rx.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_rx.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_sp.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_sp.h
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_sp_start.c
 create mode 100644 drivers/media/atomisp2/css2400/sh_css_sp_start.h
 create mode 100644 drivers/media/atomisp2/css2400/spmem_dump.c
 create mode 100644 drivers/media/atomisp2/css2400/spmem_dumpA0.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm_bo.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm_bo_dev.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm_dynamic_pool.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm_reserved_pool.c
 create mode 100644 drivers/media/atomisp2/hmm/hmm_vm.c
 create mode 100644 drivers/media/atomisp2/hrt/device_access.c
 create mode 100644 drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h
 create mode 100644 drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
 create mode 100644 drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h
 create mode 100644 drivers/media/atomisp2/hrt/memory_access.c
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm.h
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm_bo.h
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm_bo_dev.h
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm_common.h
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm_pool.h
 create mode 100644 drivers/media/atomisp2/include/hmm/hmm_vm.h
 create mode 100644 drivers/media/atomisp2/include/mmu/isp_mmu.h
 create mode 100644 drivers/media/atomisp2/include/mmu/sh_mmu.h
 create mode 100644 drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h
 create mode 100644 drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h
 create mode 100644 drivers/media/atomisp2/mmu/isp_mmu.c
 create mode 100644 drivers/media/atomisp2/mmu/sh_mmu_mfld.c
 create mode 100644 drivers/media/atomisp2/mmu/sh_mmu_mrfld.c
 create mode 100644 drivers/media/video/mt9m114.c
 create mode 100644 drivers/media/video/mt9m114.h
 create mode 100644 drivers/media/video/ov5640_1.c
 create mode 100644 drivers/media/video/ov5640_1.h
 create mode 100644 drivers/media/video/ov5640_2.c
 create mode 100644 drivers/media/video/ov5640_2.h
 create mode 100644 include/linux/atomisp.h
 create mode 100644 include/linux/atomisp_platform.h

diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index 8d87439..e170272 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -2,6 +2,7 @@
 obj-y	+= ce4100/
 obj-y	+= efi/
 obj-y	+= geode/
+obj-y	+= intel-atom/
 obj-y	+= iris/
 obj-y	+= mrst/
 obj-y	+= olpc/
diff --git a/arch/x86/platform/intel-atom/Makefile b/arch/x86/platform/intel-atom/Makefile
new file mode 100644
index 0000000..683b044
--- /dev/null
+++ b/arch/x86/platform/intel-atom/Makefile
@@ -0,0 +1,7 @@
+
+# BOARD files
+obj-y	+= platform_mt9m114.o
+obj-y 	+= platform_ov5640_2.o
+obj-y 	+= platform_ov5640_1.o
+obj-y	+= platform_camera.o
+obj-y	+= byt_plat_clock.o
diff --git a/arch/x86/platform/intel-atom/board_anvl.c b/arch/x86/platform/intel-atom/board_anvl.c
new file mode 100644
index 0000000..417476d
--- /dev/null
+++ b/arch/x86/platform/intel-atom/board_anvl.c
@@ -0,0 +1,246 @@
+/*
+ * Annvile board configuration v4l2_cam_anvl.h
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/atomisp.h>
+#include <linux/atomisp_platform.h>
+#include "platform_camera.h"
+#include "platform_ov5640.h"
+#include "platform_mt9m114.h"
+
+ 
+  /* 2MP camera */
+#define ATOMISP_ANVL_GPIO_CAM2_PWDN 22		
+#define ATOMISP_ANVL_GPIO_CAM2_RST 	25		
+#define ATOMISP_ANVL_GPIO_CAM2_CLK 	96
+#define ATOMISP_ANVL_I2C_BUS_NUM 	3
+ 
+#define ATOMISP_GPIO_CAM1_PWDN		21
+#define ATOMISP_GPIO_CAM1_RST 		24
+#define ATOMISP_GPIO_CAM3_PWDN 		ATOMISP_GPIO_CAM1_PWDN
+#define ATOMISP_GPIO_CAM3_RST 		26
+  
+#define ATOMISP_ANVL_I2C_BUS_NUM	3
+  
+#define ATOMISP_GPIO_I2C_SDA		84
+#define ATOMISP_GPIO_I2C_SCL		85
+ 
+  
+
+#if 0 
+ static void __init sfi_handle_i2c_dev(struct sfi_device_table_entry *pentry,
+					 struct devs_id *dev)
+ {
+	 struct i2c_board_info i2c_info;
+	 void *pdata = NULL;
+ 
+	 memset(&i2c_info, 0, sizeof(i2c_info));
+	 strncpy(i2c_info.type, pentry->name, SFI_NAME_LEN);
+	 i2c_info.irq = ((pentry->irq == (u8)0xff) ? 0 : pentry->irq);
+	 i2c_info.addr = pentry->addr;
+	 pr_info("I2C bus = %d, name = %16.16s, "
+		 "irq = 0x%2x, addr = 0x%x\n",
+		 pentry->host_num,
+		 i2c_info.type,
+		 i2c_info.irq,
+		 i2c_info.addr);
+	 pdata = dev->get_platform_data(&i2c_info);
+	 i2c_info.platform_data = pdata;
+ 
+	 if (dev->delay)
+		 intel_scu_i2c_device_register(pentry->host_num, &i2c_info);
+	 else
+		 i2c_register_board_info(pentry->host_num, &i2c_info, 1);
+ }
+ 
+struct devs_id __initconst device_ids[] = {
+	/*
+	 * I2C devices for camera image subsystem which will not be load into
+	 * I2C core while initialize
+	 */
+	{"mt9m114", SFI_DEV_TYPE_I2C, 0, &mt9m114_platform_data,
+				 &intel_ignore_i2c_device_register},
+	{"ov5640-1", SFI_DEV_TYPE_I2C, 0, &ov5640_platform_data,
+				 &intel_ignore_i2c_device_register},
+	{"ov5640-2", SFI_DEV_TYPE_I2C, 0, &ov5640_platform_data,
+					 &intel_ignore_i2c_device_register},
+ 	{},
+};
+
+
+static void __init sfi_handle_sd_dev(struct sfi_device_table_entry *pentry,
+					struct devs_id *dev)
+{
+	struct sd_board_info sd_info;
+	void *pdata = NULL;
+
+	memset(&sd_info, 0, sizeof(sd_info));
+	strncpy(sd_info.name, pentry->name, 16);
+	sd_info.bus_num = pentry->host_num;
+	sd_info.board_ref_clock = pentry->max_freq;
+	sd_info.addr = pentry->addr;
+	pr_info("SDIO bus = %d, name = %16.16s, "
+			"ref_clock = %d, addr =0x%x\n",
+			sd_info.bus_num,
+			sd_info.name,
+			sd_info.board_ref_clock,
+			sd_info.addr);
+	pdata = dev->get_platform_data(&sd_info);
+	sd_info.platform_data = pdata;
+}
+
+struct devs_id *get_device_id(u8 type, char *name)
+{
+	const struct devs_id *dev = device_ids;
+
+	if (device_ids == NULL)
+		return NULL;
+
+	while (dev->name[0]) {
+		if (dev->type == type &&
+			!strncmp(dev->name, name, SFI_NAME_LEN)) {
+			return dev;
+		}
+		dev++;
+	}
+
+	return NULL;
+}
+
+static int __init sfi_parse_devs(struct sfi_table_header *table)
+{
+	struct sfi_table_simple *sb;
+	struct sfi_device_table_entry *pentry;
+	struct devs_id *dev = NULL;
+	int num, i;
+	int ioapic;
+	struct io_apic_irq_attr irq_attr;
+
+	sb = (struct sfi_table_simple *)table;
+	num = SFI_GET_NUM_ENTRIES(sb, struct sfi_device_table_entry);
+	pentry = (struct sfi_device_table_entry *)sb->pentry;
+
+	for (i = 0; i < num; i++, pentry++) {
+		int irq = pentry->irq;
+
+		if (irq != (u8)0xff) { /* native RTE case */
+			/* these SPI2 devices are not exposed to system as PCI
+			 * devices, but they have separate RTE entry in IOAPIC
+			 * so we have to enable them one by one here
+			 */
+			ioapic = mp_find_ioapic(irq);
+			if (ioapic >= 0) {
+
+				irq_attr.ioapic = ioapic;
+				irq_attr.ioapic_pin = irq;
+				irq_attr.trigger = 1;
+#ifdef CONFIG_X86_MRFLD
+				irq_attr.polarity = 0; /* Active high */
+#else
+				irq_attr.polarity = 1; /* Active low */
+#endif
+				io_apic_set_pci_routing(NULL, irq, &irq_attr);
+			} else
+				printk(KERN_INFO "APIC entry not found for: name=%s, irq=%d, ioapic=%d",
+					pentry->name, irq, ioapic);
+		}
+
+		dev = get_device_id(pentry->type, pentry->name);
+
+		if ((dev == NULL) || (dev->get_platform_data == NULL))
+			continue;
+
+		if (dev->device_handler) {
+			dev->device_handler(pentry, dev);
+		} else {
+			switch (pentry->type) {
+			case SFI_DEV_TYPE_IPC:
+				sfi_handle_ipc_dev(pentry, dev);
+				break;
+			case SFI_DEV_TYPE_SPI:
+				sfi_handle_spi_dev(pentry, dev);
+				break;
+			case SFI_DEV_TYPE_I2C:
+				sfi_handle_i2c_dev(pentry, dev);
+				break;
+			case SFI_DEV_TYPE_SD:
+				sfi_handle_sd_dev(pentry, dev);
+				break;
+			case SFI_DEV_TYPE_HSI:
+#ifndef CONFIG_HSI_NO_MODEM
+				sfi_handle_hsi_dev(pentry, dev);
+#endif
+				break;
+			case SFI_DEV_TYPE_UART:
+			default:
+				;
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static struct i2c_board_info i2c_board_mt9m114[] = {
+	{
+		I2C_BOARD_INFO("mt9m114",0x90),
+	},
+}; 
+
+static struct i2c_board_info i2c_board_ov5640_1[] = {
+	{
+		I2C_BOARD_INFO("ov5640-1",0x78),
+	},
+};
+
+
+static struct i2c_board_info i2c_board_ov5640_2[] = {
+	{
+		I2C_BOARD_INFO("ov5640-2",0x80),
+	},
+};
+
+
+
+static int __init platform_init(void)
+{
+	static struct camera_sensor_platform_data *sensor_platform_data;	
+
+	sensor_platform_data = (struct camera_sensor_platform_data *)ov5640_platform_data();
+	i2c_board_ov5640_1[0].platform_data = sensor_platform_data;
+	sensor_platform_data = (struct camera_sensor_platform_data *)ov5640_platform_data();
+	i2c_board_ov5640_2[0].platform_data = sensor_platform_data;
+
+	sensor_platform_data = (struct camera_sensor_platform_data *)mt9m114_platform_data();
+	i2c_board_mt9m114[0].platform_data = sensor_platform_data;
+	
+	
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_mt9m114);
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_1);
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_2);
+
+	return 0;
+}
+arch_initcall(platform_init);
+
+ 
+ 
diff --git a/arch/x86/platform/intel-atom/board_anvl.h b/arch/x86/platform/intel-atom/board_anvl.h
new file mode 100644
index 0000000..3b04ce0
--- /dev/null
+++ b/arch/x86/platform/intel-atom/board_anvl.h
@@ -0,0 +1,49 @@
+/*
+ * Annvile board configuration v4l2_cam_anvl.h
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _BOARD_ANVL_H
+#define _BOARD_ANVL_H
+
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/atomisp_platform.h>
+
+
+ 
+#define ATOMISP_ANVL_I2C_BUS_NUM	3
+ 
+#define ATOMISP_GPIO_I2C_SDA		84
+#define ATOMISP_GPIO_I2C_SCL		85
+
+ 
+static const struct intel_v4l2_subdev_id v4l2_ids[] = {
+	 {"mt9m114", SOC_CAMERA, ATOMISP_CAMERA_PORT_SECONDARY},
+	 {"ov5640-1", SOC_CAMERA, ATOMISP_CAMERA_PORT_PRIMARY},
+	 {"ov5640-2", SOC_CAMERA, ATOMISP_CAMERA_PORT_THIRD},
+ };
+
+
+
+
+
+
+#endif
+
diff --git a/arch/x86/platform/intel-atom/byt_plat_clock.c b/arch/x86/platform/intel-atom/byt_plat_clock.c
new file mode 100644
index 0000000..7c811c2
--- /dev/null
+++ b/arch/x86/platform/intel-atom/byt_plat_clock.c
@@ -0,0 +1,181 @@
+/*
+ * byt_plat_clock.c - VLV2 platform clock driver
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Author: Asutosh Pathak <asutosh.pathak@intel.com>
+ * Author: Chandra Sekhar Anagani <chandra.sekhar.anagani@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/atomisp_platform.h>
+
+
+/* Helper macros to manipulate bitfields */
+#define REG_MASK(n)		(((1 << (n##_BIT_LEN)) - 1) << (n##_BIT_POS))
+#define REG_SET_FIELD(r, n, v)	(((r) & ~REG_MASK(n)) | \
+				 (((v) << (n##_BIT_POS)) & REG_MASK(n)))
+#define REG_GET_FIELD(r, n)	(((r) & REG_MASK(n)) >> n##_BIT_POS)
+/*
+ * vlv2 platform has 6 platform clocks, controlled by 4 byte registers
+ * Total size required for mapping is 6*4 = 24 bytes
+ */
+#define PMC_MAP_SIZE			24
+
+static DEFINE_MUTEX(clk_mutex);
+static void __iomem *pmc_base;
+
+/*
+ * byt_plat_set_clock_freq - Set clock frequency to a specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ * @freq_type: Clock frequency (0-25 MHz(XTAL), 1-19.2 MHz(PLL) )
+ */
+int byt_plat_set_clock_freq(int clk_num, int freq_type)
+{
+	void __iomem *addr;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (freq_type != CLK_FREQ_TYPE_XTAL &&
+	    freq_type != CLK_FREQ_TYPE_PLL) {
+		pr_err("wrong clock type\n");
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	addr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);
+
+	mutex_lock(&clk_mutex);
+	writel(REG_SET_FIELD(readl(addr), CLK_FREQ_TYPE, freq_type), addr);
+	mutex_unlock(&clk_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_set_clock_freq);
+
+/*
+ * byt_plat_get_clock_freq - Get the status of specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ *
+ * Returns 0 for 25 MHz(XTAL) and 1 for 19.2 MHz(PLL)
+ */
+int byt_plat_get_clock_freq(int clk_num)
+{
+	u32 ret;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&clk_mutex);
+	ret = REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),
+			    CLK_FREQ_TYPE);
+	mutex_unlock(&clk_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(byt_plat_get_clock_freq);
+
+/*
+ * byt_plat_configure_clock - Configure the specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ * @conf:      Clock gating:
+ *		0   - Clock gated on D3 state
+ *		1   - Force on
+ *		2,3 - Force off
+ */
+int byt_plat_configure_clock(int clk_num, u32 conf)
+{
+	void __iomem *addr;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (conf != CLK_CONFG_D3_GATED &&
+	    conf != CLK_CONFG_FORCE_ON &&
+	    conf != CLK_CONFG_FORCE_OFF) {
+		pr_err("Invalid clock configuration requested\n");
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	addr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);
+
+	mutex_lock(&clk_mutex);
+	writel(REG_SET_FIELD(readl(addr), CLK_CONFG, conf), addr);
+	mutex_unlock(&clk_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_configure_clock);
+
+/*
+ * byt_plat_get_clock_status - Get the status of specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ *
+ * Returns 1 - On, 0 - Off
+ */
+int byt_plat_get_clock_status(int clk_num)
+{
+	int ret;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&clk_mutex);
+	ret = (int)REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),
+				 CLK_CONFG);
+	mutex_unlock(&clk_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(byt_plat_get_clock_status);
+
+int byt_plat_clk_init(void)
+{
+        pmc_base = ioremap_nocache(VLV2_PMC_CLK_BASE_ADDRESS, PMC_MAP_SIZE);
+        if (!pmc_base) {
+                return -ENOMEM;
+        }
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_clk_init);
+
diff --git a/arch/x86/platform/intel-atom/platform_camera.c b/arch/x86/platform/intel-atom/platform_camera.c
new file mode 100644
index 0000000..b7301ce
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_camera.c
@@ -0,0 +1,316 @@
+/*
+ * platform_camera.c: Camera platform library file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/atomisp_platform.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_mt9m114.h"
+#include "platform_ov5640_1.h"
+#include "platform_ov5640_2.h"
+
+
+static const struct intel_v4l2_subdev_id v4l2_ids[] = {
+	 {"mt9m114", SOC_CAMERA, ATOMISP_CAMERA_PORT_SECONDARY, 1},
+	 {"ov5640-2", SOC_CAMERA, ATOMISP_CAMERA_PORT_THIRD, 2},
+	 {"ov5640-1", SOC_CAMERA, ATOMISP_CAMERA_PORT_PRIMARY, 2},
+	{},
+ };
+ 
+
+#define GPIO_NAME_LEN 16
+struct gpio_table_entry {
+	int	pin_no;
+	char	pin_name[GPIO_NAME_LEN];
+};
+
+static const struct gpio_table_entry gpio_table[] = {
+	{ANVL_GPIO_CAM2_PWDN_NUM, ANVL_GPIO_CAM2_PWDN},
+	{ANVL_GPIO_CAM2_RST_NUM, ANVL_GPIO_CAM2_RST},
+	{ANVL_GPIO_CAM1_PWDN_NUM, ANVL_GPIO_CAM1_PWDN},
+	{ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST},
+	{ANVL_GPIO_CAM3_PWDN_NUM, ANVL_GPIO_CAM3_PWDN},
+	{ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST},
+	{}
+};			
+
+static int __gpio_direction_output(int pin, int value)
+{
+	volatile void __iomem *gpio_base = NULL;
+	int GPIO_OFFSET = 0;
+	int temp = 0;
+	switch(pin)
+	{
+	  case 21:
+	    GPIO_OFFSET = GPIONC_21_OFFSET;
+	    break;
+	  case 22:
+	    GPIO_OFFSET = GPIONC_22_OFFSET;
+	    break;
+	  case 24:
+	    GPIO_OFFSET = GPIONC_24_OFFSET;
+	    break;
+	  case 25:
+	    GPIO_OFFSET = GPIONC_25_OFFSET;
+	    break;
+	  case 26:
+	    GPIO_OFFSET = GPIONC_26_OFFSET;
+	    break;
+	  default:
+	    printk("Wrong GPIO pin assignment\n");
+	    return -EINVAL;
+	}
+	
+	gpio_base = ioremap_nocache(IOBASEADDR+GPIO_OFFSET,0xF);
+	if(gpio_base == NULL)
+	{
+	  printk("gpio_base = NULL!\n");
+	  return -EINVAL;
+	}
+	
+	//configure the pin to output pin
+	temp=readl(gpio_base+8);
+	temp = 0x2;
+
+	writel(temp,gpio_base+8);
+
+
+	temp=readl(gpio_base);
+	
+	if(value)
+	  temp=temp|0x00000080; //set it high
+	else
+	  temp=temp|0x00000100;	//set it low
+
+	writel(temp,gpio_base);
+
+	  
+	iounmap(gpio_base);
+	  
+	return 0; 
+}
+
+static int get_gpio_by_name(const char *name)
+{
+	const struct gpio_table_entry *pentry = gpio_table;
+	int i;
+	int arraysize = sizeof(gpio_table)/sizeof(gpio_table[0]);
+
+	if (!pentry)
+		return -1;
+	for (i = 0; i < arraysize; i++, pentry++) {
+		if (!strncmp(name, pentry->pin_name, GPIO_NAME_LEN))
+			return pentry->pin_no;
+	}
+	return -1;
+}
+
+/*
+ * One-time gpio initialization.
+ * @name: gpio name: coded in SFI table
+ * @gpio: gpio pin number (bypass @name)
+ * @dir: GPIOF_DIR_IN or GPIOF_DIR_OUT
+ * @value: if dir = GPIOF_DIR_OUT, this is the init value for output pin
+ * if dir = GPIOF_DIR_IN, this argument is ignored
+ * return: a positive pin number if succeeds, otherwise a negative value
+ */
+int camera_sensor_gpio(int gpio, char *name, int dir, int value)
+{
+	int ret, pin;
+	TIMING_ENTER	
+	if (gpio == -1) {
+		pin = get_gpio_by_name(name);
+		if (pin == -1) {
+			pr_err("%s: failed to get gpio(name: %s)\n",
+						__func__, name);
+			return -EINVAL;
+		}
+	} else {
+		pin = gpio;
+	}
+	printk("pin number=%d\n",pin);
+	if (dir == GPIOF_DIR_OUT)
+		ret = __gpio_direction_output(pin, value);
+	else
+		ret = gpio_direction_input(pin);
+
+	if (ret) {
+		pr_err("%s: failed to set gpio(pin %d) direction\n",
+							__func__, pin);
+		gpio_free(pin);
+	}
+	TIMING_END
+	return ret ? ret : pin;
+}
+
+/*
+ * Configure MIPI CSI physical parameters.
+ * @port: ATOMISP_CAMERA_PORT_PRIMARY or ATOMISP_CAMERA_PORT_SECONDARY
+ * @lanes: for ATOMISP_CAMERA_PORT_PRIMARY, there could be 2 or 4 lanes
+ * for ATOMISP_CAMERA_PORT_SECONDARY, there is only one lane.
+ * @format: MIPI CSI pixel format, see include/linux/atomisp_platform.h
+ * @bayer_order: MIPI CSI bayer order, see include/linux/atomisp_platform.h
+ */
+int camera_sensor_csi(struct v4l2_subdev *sd, int port,
+			int lanes, int format, int bayer_order, int flag)
+{
+	struct i2c_client *client;
+	struct camera_mipi_info *csi = NULL;
+	TIMING_ENTER
+
+	client = v4l2_get_subdevdata(sd);
+	if (flag) {
+		csi = kzalloc(sizeof(*csi), GFP_KERNEL);
+		if (!csi) {
+			dev_err(&client->dev, "out of memory\n");
+			return -ENOMEM;
+		}
+		csi->port = port;
+		csi->num_lanes = lanes;
+		csi->input_format = format;
+		csi->raw_bayer_order = bayer_order;
+		v4l2_set_subdev_hostdata(sd, (void *)csi);
+	} else {
+		csi = v4l2_get_subdev_hostdata(sd);
+		kfree(csi);
+	}
+	TIMING_END
+	return 0;
+}
+
+
+
+static struct atomisp_platform_data *v4l2_subdev_table_head;
+
+static void intel_ignore_i2c_device_register(int bus,
+					     struct i2c_board_info *idev)
+{
+	const struct intel_v4l2_subdev_id *vdev = v4l2_ids;
+	struct intel_v4l2_subdev_i2c_board_info *info;
+	static struct intel_v4l2_subdev_table *subdev_table;
+	enum intel_v4l2_subdev_type type = 0;
+	enum atomisp_camera_port port;
+	int num_lanes;
+	static int i;
+
+	while (vdev->name[0]) {
+		if (!strncmp(vdev->name, idev->type, 16)) {
+			/* compare name */
+			type = vdev->type;
+			port = vdev->port;
+			num_lanes = vdev->num_lanes;
+			break;
+		}
+		vdev++;
+	}
+
+	if (!type) /* not found */
+		return;
+
+	info = kzalloc(sizeof(struct intel_v4l2_subdev_i2c_board_info),
+		       GFP_KERNEL);
+	if (!info) {
+		pr_err("fail to alloc mem for ignored i2c dev %s\n",
+		       idev->type);
+		return;
+	}
+
+	info->i2c_adapter_id = bus;
+	/* set platform data */
+	memcpy(&info->board_info, idev, sizeof(*idev));
+
+	if (v4l2_subdev_table_head == NULL) {
+		subdev_table = kzalloc(sizeof(struct intel_v4l2_subdev_table)
+			* ARRAY_SIZE(v4l2_ids), GFP_KERNEL);
+
+		if (!subdev_table) {
+			pr_err("fail to alloc mem for v4l2_subdev_table %s\n",
+			       idev->type);
+			kfree(info);
+			return;
+		}
+
+		v4l2_subdev_table_head = kzalloc(
+			sizeof(struct atomisp_platform_data), GFP_KERNEL);
+		if (!v4l2_subdev_table_head) {
+			pr_err("fail to alloc mem for v4l2_subdev_table %s\n",
+			       idev->type);
+			kfree(info);
+			kfree(subdev_table);
+			return;
+		}
+		v4l2_subdev_table_head->subdevs = subdev_table;
+	}
+
+	memcpy(&subdev_table[i].v4l2_subdev, info, sizeof(*info));
+	subdev_table[i].type = type;
+	subdev_table[i].port = port;
+	subdev_table[i].num_lanes = num_lanes;
+	
+	i++;
+	return;
+}
+
+
+struct atomisp_platform_data *__intel_get_v4l2_subdev_table(void)
+{
+	if (v4l2_subdev_table_head)
+		return v4l2_subdev_table_head;
+	else {
+		pr_err("no camera device in the table\n");
+		return NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(__intel_get_v4l2_subdev_table);
+
+
+static struct i2c_board_info i2c_board_mt9m114[] = {
+	{
+		I2C_BOARD_INFO("mt9m114",0x48),
+	},
+}; 
+
+static struct i2c_board_info i2c_board_ov5640_1[] = {
+	{
+		I2C_BOARD_INFO("ov5640-1",0x32),
+	},
+};
+
+static struct i2c_board_info i2c_board_ov5640_2[] = {
+	{
+		I2C_BOARD_INFO("ov5640-2",0x34),
+	},
+};
+
+
+
+static int __init platform_init(void)
+{
+
+	i2c_board_mt9m114[0].platform_data = mt9m114_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_mt9m114);
+	
+	i2c_board_ov5640_2[0].platform_data = ov5640_2_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_2);
+
+	i2c_board_ov5640_1[0].platform_data = ov5640_1_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_1);
+
+	return 0;
+}
+arch_initcall(platform_init);
+
+MODULE_LICENSE("GPL");
+
+
diff --git a/arch/x86/platform/intel-atom/platform_camera.h b/arch/x86/platform/intel-atom/platform_camera.h
new file mode 100644
index 0000000..1cc1e0c
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_camera.h
@@ -0,0 +1,50 @@
+/*
+ * platform_camera.h: CAMERA platform library header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_CAMERA_H_
+#define _PLATFORM_CAMERA_H_
+
+#include <linux/atomisp_platform.h>
+
+/*extern const struct intel_v4l2_subdev_id v4l2_ids[] __attribute__((weak));*/
+
+/* MFLD iCDK camera sensor GPIOs */
+
+
+#define ANVL_GPIO_CAM2_PWDN 		"cam_mt_power"  //Power down signal for J3 ov5640 sensor
+#define ANVL_GPIO_CAM2_RST			"cam_mt_reset"  //Power reset signal for 1.2MP sensor
+#define ANVL_GPIO_CAM1_PWDN			"cam_ov1_power" //Power down signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM1_RST 			"cam_ov1_reset" //Power reset signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM3_PWDN 		"cam_ov2_power"
+#define ANVL_GPIO_CAM3_RST 			"cam_ov2_reset" //Power reset signal for J3 ov5640 sensor
+ 
+#define ANVL_GPIO_CAM2_RST_NUM 		25		//Power reset signal for 1.2MP sensor
+#define ANVL_GPIO_CAM2_PWDN_NUM 	22		//Power down signal for J3 ov5640 sensor
+#define ANVL_GPIO_CAM1_PWDN_NUM		21		//Power down signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM1_RST_NUM 		24		//Power reset signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM3_PWDN_NUM 	21
+#define ANVL_GPIO_CAM3_RST_NUM 		26		//Power reset signal for J3 ov5640 sensor
+
+#define ANVL_I2C_BUS_NUM 		3
+#define IOBASEADDR				0xFED0C000 
+#define GPIONC_21_OFFSET		0x1060		//Power down signal for J2 ov5640 sensor
+#define GPIONC_22_OFFSET		0x10A0		//Power down signal for J3 ov5640 sensor
+#define GPIONC_24_OFFSET		0x1020		//Power reset signal for J2 ov5640 sensor
+#define GPIONC_25_OFFSET		0x1050		//Power reset signal for 1.2MP sensor
+#define GPIONC_26_OFFSET		0x1090		//Power reset signal for J3 ov5640 sensor
+
+extern int camera_sensor_gpio(int gpio, char *name, int dir, int value);
+extern int camera_sensor_csi(struct v4l2_subdev *sd, int port,
+			int lanes, int format, int bayer_order, int flag);
+
+extern struct atomisp_platform_data *intel_get_v4l2_subdev_table(void)  __attribute__((weak));;
+
+#endif
diff --git a/arch/x86/platform/intel-atom/platform_mt9m114.c b/arch/x86/platform/intel-atom/platform_mt9m114.c
new file mode 100644
index 0000000..9f4a716
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_mt9m114.c
@@ -0,0 +1,231 @@
+/*
+ * platform_mt9m114.c: mt9m114 platform data initilization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define SCU_CLK_WORKING 0
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#if SCU_CLK_WORKING
+#include <asm/intel_scu_ipcutil.h>
+#endif
+
+#include <media/v4l2-subdev.h>
+#include <linux/regulator/consumer.h>
+#include "platform_camera.h"
+#include "platform_mt9m114.h"
+
+
+#define VPROG1_VAL 2800000
+static int camera_reset;
+static int camera_power_down;
+static int camera_vprog1_on;
+
+#ifdef CONFIG_BOARD_CTP
+static struct regulator *vprog1_reg;
+#endif
+
+/*
+ * MFLD PR2 secondary camera sensor - MT9M114 platform data
+ */
+static int mt9m114_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	TIMING_ENTER
+	ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+				 GPIOF_DIR_OUT, 1);
+	if (ret < 0)
+		return ret;
+
+	if (flag) {
+		//Reset the camera sensor
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 0);
+		msleep(60);
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+	} else
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+	TIMING_END
+	return 0;
+}
+
+static int mt9m114_flisclk_ctrl(struct v4l2_subdev *sd, int flag)
+{
+#if SCU_CLK_WORKING
+	static const unsigned int clock_khz = 19200;
+	return intel_scu_ipc_osc_clk(OSC_CLK_CAM1, flag ? clock_khz : 0);
+#else
+	return 0;
+#endif
+}
+
+static int mt9e013_reset_value;
+static int mt9m114_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	//Do nothing for now
+#ifdef CONFIG_BOARD_CTP
+	int reg_err;
+	return 0;
+#endif
+#ifndef CONFIG_BOARD_CTP
+	int ret;
+	return 0;
+	/* Note here, there maybe a workaround to avoid I2C SDA issue */
+	if (camera_power_down < 0) {
+		ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_PWDN,
+					GPIOF_DIR_OUT, 1);
+#ifndef CONFIG_BOARD_REDRIDGE
+		if (ret < 0)
+			return ret;
+#endif
+		camera_power_down = ret;
+	}
+
+	if (camera_reset < 0) {
+		ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+		if (ret < 0)
+			return ret;
+		camera_reset = ret;
+	}
+#endif
+	if (flag) {
+#ifndef CONFIG_BOARD_CTP
+#if 0
+		if (!mt9e013_reset_value) {
+			if (mt9e013_reset)
+				mt9e013_reset(sd);
+			mt9e013_reset_value = 1;
+		}
+#endif
+#ifdef CONFIG_BOARD_REDRIDGE
+		gpio_direction_output(camera_reset, 0);
+#endif
+		gpio_set_value(camera_reset, 0);
+#endif
+		if (!camera_vprog1_on) {
+			camera_vprog1_on = 1;
+#ifdef CONFIG_BOARD_CTP
+			reg_err = regulator_enable(vprog1_reg);
+			if (reg_err) {
+				printk(KERN_ALERT "Failed to enable regulator vprog1\n");
+				return reg_err;
+			}
+#else
+#if SCU_CLK_WORKING
+            intel_scu_ipc_msic_vprog1(1);
+#endif
+#endif
+		}
+#ifndef CONFIG_BOARD_CTP
+#ifdef CONFIG_BOARD_REDRIDGE
+		if (camera_power_down >= 0)
+			gpio_set_value(camera_power_down, 1);
+#else
+		gpio_set_value(camera_power_down, 1);
+#endif
+#endif
+	} else {
+		if (camera_vprog1_on) {
+			camera_vprog1_on = 0;
+#ifdef CONFIG_BOARD_CTP
+			reg_err = regulator_disable(vprog1_reg);
+			if (reg_err) {
+				printk(KERN_ALERT "Failed to disable regulator vprog1\n");
+				return reg_err;
+			}
+#else
+
+#if SCU_CLK_WORKING
+			intel_scu_ipc_msic_vprog1(0);
+#endif
+
+#endif
+		}
+#ifndef CONFIG_BOARD_CTP
+#ifdef CONFIG_BOARD_REDRIDGE
+		if (camera_power_down >= 0)
+			gpio_set_value(camera_power_down, 0);
+#else
+		gpio_set_value(camera_power_down, 0);
+#endif
+
+		mt9e013_reset_value = 0;
+#endif
+	}
+
+	return 0;
+}
+
+static int mt9m114_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	/* soc sensor, there is no raw bayer order (set to -1) */
+	TIMING_ENTER
+	ret = camera_sensor_csi(sd, ATOMISP_CAMERA_PORT_SECONDARY, 1,
+		ATOMISP_INPUT_FORMAT_YUV422_8, -1, flag);
+	TIMING_END;
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_CTP
+static int mt9m114_platform_init(struct i2c_client *client)
+{
+	int ret;
+
+	vprog1_reg = regulator_get(&client->dev, "vprog1");
+	if (IS_ERR(vprog1_reg)) {
+		dev_err(&client->dev, "regulator_get failed\n");
+		return PTR_ERR(vprog1_reg);
+	}
+	ret = regulator_set_voltage(vprog1_reg, VPROG1_VAL, VPROG1_VAL);
+	if (ret) {
+		dev_err(&client->dev, "regulator voltage set failed\n");
+		regulator_put(vprog1_reg);
+	}
+	return ret;
+}
+
+static int mt9m114_platform_deinit(void)
+{
+	regulator_put(vprog1_reg);
+	return 0;
+}
+#endif
+
+static struct camera_sensor_platform_data mt9m114_sensor_platform_data = {
+	.gpio_ctrl	= mt9m114_gpio_ctrl,
+	.flisclk_ctrl	= mt9m114_flisclk_ctrl,
+	.power_ctrl	= mt9m114_power_ctrl,
+	.csi_cfg	= mt9m114_csi_configure,
+#ifdef CONFIG_BOARD_CTP
+	.platform_init = mt9m114_platform_init,
+	.platform_deinit = mt9m114_platform_deinit,
+#endif
+};
+
+
+void *mt9m114_platform_data(void)
+{
+	camera_reset = -1;
+	camera_power_down = -1;
+
+	return &mt9m114_sensor_platform_data;
+}
+
+
+
diff --git a/arch/x86/platform/intel-atom/platform_mt9m114.h b/arch/x86/platform/intel-atom/platform_mt9m114.h
new file mode 100644
index 0000000..4c2caf5
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_mt9m114.h
@@ -0,0 +1,18 @@
+/*
+ * platform_mt9m114.h: mt9m114 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MT9M114_H_
+#define _PLATFORM_MT9M114_H_
+
+
+void *mt9m114_platform_data(void);
+ 
+#endif
diff --git a/arch/x86/platform/intel-atom/platform_ov5640_1.c b/arch/x86/platform/intel-atom/platform_ov5640_1.c
new file mode 100644
index 0000000..8af0b84
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_ov5640_1.c
@@ -0,0 +1,117 @@
+/*
+ * platform_ov5640_1.c: ov5640_1 platform data initilization file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#define SCU_CLK_WORKING 0
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#if SCU_CLK_WORKING
+#include <asm/intel_scu_ipcutil.h>
+#endif
+#include <asm/io.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_ov5640_1.h"
+
+
+static int camera_reset;
+static int camera_power_down;
+
+/*
+ * GRACELAND DV1 primary camera sensor - OV5640_1 platform data
+ */
+
+static int ov5640_1_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+
+	if (flag) {
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+	  msleep(20);
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 1);
+	} else 
+	{
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+	}
+
+	return 0;
+}
+
+static int ov5640_1_flisclk_ctrl(struct v4l2_subdev *sd, int flag)
+{
+#if SCU_CLK_WORKING
+    static const unsigned int clock_khz = 19200;
+    return intel_scu_ipc_osc_clk(OSC_CLK_CAM0, flag ? clock_khz : 0);
+#else
+    return 0;
+#endif
+}
+
+static int ov5640_1_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+
+	if (flag) {
+	  if (camera_power_down < 0) {
+               ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM1_PWDN,
+                                       GPIOF_DIR_OUT, 1);
+		printk("ov5640_1 - gpio power down to up  ov5640_1 - primary\n");
+		camera_power_down = ret;
+	  }
+	  if (camera_reset < 0) {
+               ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM1_RST,
+                                        GPIOF_DIR_OUT, 1);
+		printk("ov5640_1 - gpio power reset  ov5640_1-primary\n");
+            	camera_reset = ret;
+	  }
+#if SCU_CLK_WORKING
+	  intel_scu_ipc_msic_vprog1(1);
+#endif
+            /* delay 20ms to wait sensor power up stable.*/
+	  msleep(20);
+	} 
+	else 
+	{
+
+#if SCU_CLK_WORKING
+	  intel_scu_ipc_msic_vprog1(0);
+#endif
+	
+	}	
+
+	return 0;
+}
+
+static int ov5640_1_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	ret =  camera_sensor_csi(sd, ATOMISP_CAMERA_PORT_PRIMARY, 2,
+		ATOMISP_INPUT_FORMAT_YUV422_8, -1, flag);
+	if (ret != 0) {
+		printk("Error in configure camera csi  - OV5640_1-primary\n");
+		return ret;
+	}
+	return ret;
+}
+
+static struct camera_sensor_platform_data ov5640_1_sensor_platform_data = {
+	.gpio_ctrl      = ov5640_1_gpio_ctrl,
+	.flisclk_ctrl   = ov5640_1_flisclk_ctrl,
+	.power_ctrl     = ov5640_1_power_ctrl,
+	.csi_cfg        = ov5640_1_csi_configure,
+};
+
+void *ov5640_1_platform_data(void)
+{
+	camera_reset = -1;
+	camera_power_down = -1;
+	return &ov5640_1_sensor_platform_data;
+}
diff --git a/arch/x86/platform/intel-atom/platform_ov5640_1.h b/arch/x86/platform/intel-atom/platform_ov5640_1.h
new file mode 100644
index 0000000..268f411
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_ov5640_1.h
@@ -0,0 +1,17 @@
+/*
+ * platform_ov5640_1.h: ov5640_1 platform data header file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_OV5640_1_H_
+#define _PLATFORM_OV5660_1_H_
+
+void *ov5640_1_platform_data(void);
+ 
+#endif
diff --git a/arch/x86/platform/intel-atom/platform_ov5640_2.c b/arch/x86/platform/intel-atom/platform_ov5640_2.c
new file mode 100644
index 0000000..b832627
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_ov5640_2.c
@@ -0,0 +1,122 @@
+/*
+ * platform_ov5640_2.c: ov5640_2 platform data initilization file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#define SCU_CLK_WORKING 0
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#if SCU_CLK_WORKING
+#include <asm/intel_scu_ipcutil.h>
+#endif
+#include <asm/io.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_ov5640_2.h"
+
+
+static int camera_2_reset;
+static int camera_2_power_down;
+
+/*
+ * GRACELAND DV1 primary camera sensor - OV5640 platform data
+ */
+
+void ov5640_2_powerdown_camera_1(void)
+{
+	camera_sensor_gpio(-1, ANVL_GPIO_CAM1_PWDN,GPIOF_DIR_OUT, 0);
+        camera_sensor_gpio(-1, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+}
+static int ov5640_2_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+
+	if (flag) 
+	{
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 0);
+	  msleep(20);
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 1);
+	} 
+	else {
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 0);
+	}
+
+	return 0;
+}
+
+static int ov5640_2_flisclk_ctrl(struct v4l2_subdev *sd, int flag)
+{
+#if SCU_CLK_WORKING
+    static const unsigned int clock_khz = 19200;
+    return intel_scu_ipc_osc_clk(OSC_CLK_CAM0, flag ? clock_khz : 0);
+#else
+    return 0;
+#endif
+}
+
+static int ov5640_2_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+
+	if (flag) {
+	  if (camera_2_power_down < 0) {
+	    ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM3_PWDN,
+                                       GPIOF_DIR_OUT, 1);
+	    printk("ov5640_2 - gpio power down to up  ov5640_2\n");
+	    camera_2_power_down = ret;
+	  }
+	  if (camera_2_reset < 0) {
+	    ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM3_RST,
+                                        GPIOF_DIR_OUT, 1);
+	    printk("ov5640_2 - gpio power reset  ov5640_2\n");
+            camera_2_reset = ret;
+	  }
+#if SCU_CLK_WORKING
+          intel_scu_ipc_msic_vprog1(1);
+#endif
+
+            /*delay 20ms to wait sensor power up stable.*/
+	  msleep(20);
+	} 
+	else {
+
+#if SCU_CLK_WORKING
+	    intel_scu_ipc_msic_vprog1(0);
+#endif	
+	}
+
+	return 0;
+}
+
+static int ov5640_2_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	ret =  camera_sensor_csi(sd, ATOMISP_CAMERA_PORT_THIRD, 2,
+		ATOMISP_INPUT_FORMAT_YUV422_8, -1, flag);
+	if (ret != 0) {
+		printk("Error in configure camera csi  - OV5640-THIRD\n");
+		return ret;
+	}
+	return ret;
+}
+
+static struct camera_sensor_platform_data ov5640_2_sensor_platform_data = {
+	.gpio_ctrl      = ov5640_2_gpio_ctrl,
+	.flisclk_ctrl   = ov5640_2_flisclk_ctrl,
+	.power_ctrl     = ov5640_2_power_ctrl,
+	.csi_cfg        = ov5640_2_csi_configure,
+};
+
+void *ov5640_2_platform_data(void)
+{
+	camera_2_reset = -1;
+	camera_2_power_down = -1;
+	return &ov5640_2_sensor_platform_data;
+}
diff --git a/arch/x86/platform/intel-atom/platform_ov5640_2.h b/arch/x86/platform/intel-atom/platform_ov5640_2.h
new file mode 100644
index 0000000..09c9fd6
--- /dev/null
+++ b/arch/x86/platform/intel-atom/platform_ov5640_2.h
@@ -0,0 +1,18 @@
+/*
+ * platform_ov5640.h: ov5640 platform data header file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_OV5460_2_H_
+#define _PLATFORM_OV5460_2_H_
+
+void *ov5640_2_platform_data(void);
+void ov5640_2_powerdown_camera_1(void);
+ 
+#endif
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index 9575db4..75b02fa 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -32,6 +32,7 @@ config MEDIA_CONTROLLER
 
 config VIDEO_DEV
 	tristate "Video For Linux"
+	select X86_MRFLD
 	---help---
 	  V4L core support for video capture and overlay devices, webcams and
 	  AM/FM radio cards.
@@ -48,6 +49,9 @@ config VIDEO_DEV
 	  To compile this driver as a module, choose M here: the
 	  module will be called videodev.
 
+config X86_MRFLD
+	tristate
+
 config VIDEO_V4L2_COMMON
 	tristate
 	depends on (I2C || I2C=n) && VIDEO_DEV
@@ -110,6 +114,7 @@ source "drivers/media/rc/Kconfig"
 # Tuner drivers for DVB and V4L
 #
 
+source "drivers/media/atomisp2/Kconfig"
 source "drivers/media/common/tuners/Kconfig"
 
 #
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index 64755c9..d6821ef 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -12,3 +12,7 @@ obj-y += common/ rc/ video/
 
 obj-$(CONFIG_VIDEO_DEV) += radio/
 obj-$(CONFIG_DVB_CORE)  += dvb/
+
+# Atomisp driver
+obj-$(CONFIG_VIDEO_ATOMISP) += atomisp2/
+
diff --git a/drivers/media/atomisp2/Kconfig b/drivers/media/atomisp2/Kconfig
new file mode 100644
index 0000000..63e52ae
--- /dev/null
+++ b/drivers/media/atomisp2/Kconfig
@@ -0,0 +1,19 @@
+config VIDEO_ATOMISP
+	tristate "Intel Atom Image Signal Processor CSS2.0 Driver"
+	depends on MEDIA_SUPPORT && VIDEO_V4L2
+	default n
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEO_MT9M114
+	select VIDEO_OV5640
+	select VIDEOBUF2_CORE
+	select DMA_SHARED_BUFFER
+	select VIDEOBUF2_MEMOPS
+	select VIDEOBUF2_DMA_CONTIG
+	select PM_RUNTIME
+
+	---help---
+	  Say Y here if your platform support camera imaging subsystem on
+	  the Intel Atom SoC platform.
+	  To compile this driver as a module, choose M here: the
+	  module will be called atomisp.
diff --git a/drivers/media/atomisp2/Makefile b/drivers/media/atomisp2/Makefile
new file mode 100644
index 0000000..dfccfeb
--- /dev/null
+++ b/drivers/media/atomisp2/Makefile
@@ -0,0 +1,103 @@
+css_folder = css2400
+css_platform_folder = hive_isp_css_2400_system
+
+atomisp-objs := \
+		atomisp_compat.o \
+		atomisp_ioctl.o \
+		atomisp_cmd.o \
+		atomisp_fops.o \
+		atomisp_subdev.o \
+		atomisp_csi2.o \
+		atomisp_tpg.o \
+		atomisp_file.o \
+		atomisp_v4l2.o \
+		atomisp_acc.o \
+		mmu/isp_mmu.o \
+		mmu/sh_mmu_mrfld.o \
+		mmu/sh_mmu_mfld.o \
+		hmm/hmm.o \
+		hmm/hmm_bo.o \
+		hmm/hmm_bo_dev.o \
+		hmm/hmm_vm.o \
+		hrt/hive_isp_css_mm_hrt.o \
+		hmm/hmm_reserved_pool.o \
+		hmm/hmm_dynamic_pool.o 
+	#	hrt/device_access.o \
+		hrt/memory_access.o \
+
+atomisp-objs += \
+		$(css_folder)/sh_css.o \
+		$(css_folder)/sh_css_binary.o \
+		$(css_folder)/sh_css_debug.o  \
+		$(css_folder)/sh_css_hrt.o  \
+		$(css_folder)/sh_css_params.o \
+		$(css_folder)/sh_css_sp.o \
+		$(css_folder)/sh_css_rx.o \
+		$(css_folder)/sh_css_sp_start.o \
+		$(css_folder)/sh_css_metrics.o \
+		$(css_folder)/sh_css_firmware.o \
+		$(css_folder)/sh_css_accelerate.o \
+		$(css_folder)/sh_css_refcount.o \
+		$(css_folder)/sh_css_param_shading.o \
+		$(css_folder)/$(css_platform_folder)/host/gdc.o \
+		$(css_folder)/$(css_platform_folder)/host/irq.o \
+		$(css_folder)/$(css_platform_folder)/host/mmu.o \
+		$(css_folder)/$(css_platform_folder)/host/dma.o \
+		$(css_folder)/$(css_platform_folder)/host/sp.o \
+		$(css_folder)/$(css_platform_folder)/host/isp.o \
+		$(css_folder)/hive_isp_css_shared/host/queue.o \
+		$(css_folder)/hive_isp_css_shared/host/ia_css_i_rmgr_shared.o \
+		$(css_folder)/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.o \
+		$(css_folder)/hive_isp_css_shared/host/tag.o \
+		$(css_folder)/hive_isp_css_shared/host/sw_event.o \
+		$(css_folder)/$(css_platform_folder)/host/fifo_monitor.o \
+		$(css_folder)/$(css_platform_folder)/host/gp_device.o \
+		$(css_folder)/$(css_platform_folder)/host/input_formatter.o \
+	#	$(css_folder)/sh_css_pipeline.o \
+
+atomisp-objs += $(css_folder)/$(css_platform_folder)/host/input_system.o \
+		$(css_folder)/input_system_init.o \
+		$(css_folder)/ia_css_memory_access.o \
+		$(css_folder)/ia_css_device_access.o \
+		$(css_folder)/sh_css_param_dvs.o \
+		#$(css_folder)/$(css_platform_folder)/device_access/device_access.o \
+		$(css_folder)/$(css_platform_folder)/memory_access/memory_access.o
+
+obj-$(CONFIG_VIDEO_ATOMISP) = atomisp.o
+
+INCLUDES := -I$(srctree)/$(src)/include \
+	    -I$(srctree)/$(src)/ \
+	    -I$(src) \
+	    -I$(src)/hrt \
+	    -I$(srctree)/drivers/staging/intel_media/bc_video
+
+INCLUDES += -I$(src)/$(css_folder) \
+	    -I$(srctree)/$(src)/$(css_folder)/hrt \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/stdint \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/stdbool \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/host \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/device_access \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/memory_access \
+	    -I$(srctree)/$(src)/$(css_folder)/$(css_platform_folder) \
+	    -I$(srctree)/$(src)/$(css_folder)/$(css_platform_folder)/host \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_shared \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_kernel/pipeline \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_kernel/pipeline/host \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_kernel/csc \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_kernel/csc/host \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_shared/host
+
+DEFINES := -DHRT_HW -DHRT_ISP_CSS_CUSTOM_HOST -DHRT_USE_VIR_ADDRS -DHRT_KERNEL -D__HOST__
+DEFINES += -DUSE_DYNAMIC_BIN
+DEFINES += -DISP_POWER_GATING
+DEFINES += -DUSE_INTERRUPTS
+#DEFINES += -DUSE_SSSE3
+DEFINES += -DPUNIT_CAMERA_BUSY
+DEFINES += -DUSE_KMEM_CACHE
+DEFINES += -DCSS_2
+DEFINES += -DSYSTEM_hive_isp_css_2400_system
+DEFINES += -DATOMISP_FASTBOOT
+#DEFINES += -DON_DEMAND_LOAD
+
+EXTRA_CFLAGS := $(INCLUDES) $(DEFINES) -fno-common #-Werror
diff --git a/drivers/media/atomisp2/atomisp-regs.h b/drivers/media/atomisp2/atomisp-regs.h
new file mode 100644
index 0000000..2698215
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp-regs.h
@@ -0,0 +1,147 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef ATOMISP_REGS_H
+#define ATOMISP_REGS_H
+
+/* common register definitions */
+#define PUNIT_PORT		0x04
+
+#define PCICMDSTS		0x01
+#define INTR			0x0f
+#define MSI_CAPID		0x24
+#define MSI_ADDRESS		0x25
+#define MSI_DATA		0x26
+#define INTR_CTL		0x27
+
+#define PCI_MSI_CAPID		0x90
+#define PCI_MSI_ADDR		0x94
+#define PCI_MSI_DATA		0x98
+#define PCI_INTERRUPT_CTRL	0x9C
+#define PCI_I_CONTROL		0xfc
+
+/* MFLD specific register definitions */
+#define MFLD_IUNITPHY_PORT	0x09
+
+#define MFLD_CSI_RCOMP		0x00
+#define MFLD_CSI_AFE		0x02
+#define MFLD_CSI_CONTROL	0x03
+#define MFLD_CG_DIS		0x36
+#define MFLD_OR1		0x72
+
+#define MFLD_PCI_PMCS		0xd4
+#define MFLD_PCI_CG_DIS		0xd8
+
+/*
+ * Enables the combining of adjacent 32-byte read requests to the same
+ * cache line. When cleared, each 32-byte read request is sent as a
+ * separate request on the IB interface.
+ */
+#define MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	BIT(16)
+
+/*
+ * Enables the combining of adjacent 32-byte write requests to the same
+ * cache line. When cleared, each 32-byte write request is sent as a
+ * separate request on the IB interface.
+ */
+#define MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	BIT(17)
+
+/* Ensure the correct bits are set for the clock gating disable regster */
+#define MFLD_PCI_CG_DIS_DISABLED_ISPCLK		BIT(0)
+#define MFLD_PCI_CG_DIS_DISABLED_PERF_MON	BIT(2)
+#define MFLD_PCI_CG_DIS_DISABLED_NOA_MON	BIT(3)
+
+/* The MIPI1 and MIPI4 interface and lanes configuration */
+#define MFLD_CSI_CONTROL_DIS_MIPI1_IF	BIT(8)
+#define MFLD_CSI_CONTROL_DIS_MIPI4_IF	BIT(9)
+#define MFLD_CSI_CONTROL_EN_MIPI1_LANE	BIT(10)
+#define MFLD_CSI_CONTROL_EN_MIPI4_LANE	(BIT(11) | BIT(12) | BIT(13) | BIT(14))
+
+#define MFLD_MAX_ZOOM_FACTOR	64
+
+/* MRFLD specific register definitions */
+#define MRFLD_CSI_AFE		0x39
+#define MRFLD_CSI_CONTROL	0x3a
+#define MRFLD_CSI_RCOMP		0x3d
+
+#define MRFLD_PCI_PMCS		0x84
+#define MRFLD_PCI_CSI_ACCESS_CTRL_VIOL	0xd4
+#define MRFLD_PCI_CSI_AFE_HS_CONTROL	0xdc
+#define MRFLD_PCI_CSI_AFE_RCOMP_CONTROL	0xe0
+#define MRFLD_PCI_CSI_CONTROL		0xe8
+#define MRFLD_PCI_CSI_AFE_TRIM_CONTROL	0xe4
+#define MRFLD_PCI_CSI_DEADLINE_CONTROL	0xec
+#define MRFLD_PCI_CSI_RCOMP_CONTROL	0xf4
+
+/*
+ * Enables the combining of adjacent 32-byte read requests to the same
+ * cache line. When cleared, each 32-byte read request is sent as a
+ * separate request on the IB interface.
+ */
+#define MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	0x1
+
+/*
+ * Enables the combining of adjacent 32-byte write requests to the same
+ * cache line. When cleared, each 32-byte write request is sent as a
+ * separate request on the IB interface.
+ */
+#define MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	0x2
+
+#define MRFLD_CSI_RECEIVER_SELECTION_REG       0x8081c
+
+#define MRFLD_MAX_ZOOM_FACTOR	1024
+
+/* MRFLD ISP POWER related */
+#define MRFLD_ISPSSPM0         0x39
+#define MRFLD_ISPSSPM0_ISPSSC_OFFSET   0
+#define MRFLD_ISPSSPM0_ISPSSS_OFFSET   24
+#define MRFLD_ISPSSPM0_ISPSSC_MASK 0x3
+#define MRFLD_ISPSSPM0_IUNIT_POWER_ON  0
+#define MRFLD_ISPSSPM0_IUNIT_POWER_OFF 0x3
+
+/* MRFLD CSI lane configuration related */
+#define MRFLD_PORT_CONFIG_NUM  8
+#define MRFLD_PORT_NUM         3
+#define MRFLD_PORT3_ENABLE_SHIFT       2
+#define MRFLD_PORT1_LANES_SHIFT        3
+#define MRFLD_PORT2_LANES_SHIFT        7
+#define MRFLD_PORT3_LANES_SHIFT        8
+#define MRFLD_PORT_CONFIGCODE_SHIFT    16
+#define MRFLD_PORT_CONFIG_MASK 0x000f03ff
+#define MRFLD_ALL_CSI_PORTS_OFF_MASK   0x7
+
+#define ISPSSPM1				0x3a
+#define ISP_FREQ_STAT_MASK			(0x1f << ISP_FREQ_STAT_OFFSET)
+#define ISP_REQ_FREQ_MASK			0x1f
+#define ISP_FREQ_VALID_MASK			(0x1 << ISP_FREQ_VALID_OFFSET)
+#define ISP_FREQ_STAT_OFFSET			0x18
+#define ISP_REQ_GUAR_FREQ_OFFSET		0x8
+#define ISP_REQ_FREQ_OFFSET			0x0
+#define ISP_FREQ_VALID_OFFSET			0x7
+#define ISP_FREQ_RULE_ANY			0x0
+
+#define ISP_FREQ_400MHZ				0x190
+#define ISP_FREQ_320MHZ				0x140
+#define ISP_FREQ_266MHZ				0x10a
+#define ISP_FREQ_200MHZ				0xc8
+#define HPLL_FREQ				0x640
+
+#endif /* ATOMISP_REGS_H */
diff --git a/drivers/media/atomisp2/atomisp_acc.c b/drivers/media/atomisp2/atomisp_acc.c
new file mode 100644
index 0000000..38907f48
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_acc.c
@@ -0,0 +1,1106 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/*
+ * This file implements loadable acceleration firmware API,
+ * including ioctls to map and unmap acceleration parameters and buffers.
+ */
+
+#include <linux/init.h>
+
+#include "atomisp_acc.h"
+#include "atomisp_internal.h"
+#include "atomisp_compat.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+#include "memory_access/memory_access.h"
+#include "ia_css.h"
+#include "ia_css_accelerate.h"
+
+/* Assume max number of ACC stages */
+#define MAX_ACC_STAGES	20
+
+/*-------------------- DIRECTVP ACCESS   -------------------------------------*/
+static
+struct atomisp_acc_fw * acc_get_fw(struct atomisp_device *isp, unsigned int handle);
+
+/* firmware: pre-defined offsets and values for directVP */
+static const int DMEM_DBG_LEN = 128 * sizeof(unsigned long);
+static const int DMEM_ISP_ACC_DONE_FLAG = 0xCAFFEE00;
+static const int DMEM_DBG_OUT_DISABLED = 0x099;
+static const int DMEM_ACC_DONE_ADDR = 0x0000;
+static const int DMEM_DBG_INFO_ADDR = 0x0004;
+
+/* Binary name follows header immediately */
+#define ISP_PROG_NAME(f) ((const unsigned char *)(f)+sizeof(*f))
+static const unsigned int HMEM_LEN = 4096;
+
+typedef struct {
+	enum ia_css_isp_memories m;
+	vamem_ID_t id;
+} vamem_map_t;
+
+vamem_map_t vamem_map [N_VAMEM_ID] = {
+	{IA_CSS_ISP_VAMEM0, VAMEM0_ID},
+	{IA_CSS_ISP_VAMEM1, VAMEM1_ID},
+	{IA_CSS_ISP_VAMEM2, VAMEM2_ID},
+};
+
+static inline void dump_isp_debug_info(void)
+{
+	unsigned long *p;
+	int i;
+
+	p = kmalloc(DMEM_DBG_LEN, GFP_KERNEL);
+	if (p == NULL)
+		return;
+
+	isp_dmem_load(ISP0_ID, DMEM_DBG_INFO_ADDR, p, DMEM_DBG_LEN);
+	if (p[0] == DMEM_DBG_OUT_DISABLED)
+		goto done;
+	printk(KERN_INFO "ISP DMEM (read dmem debug): \n");
+	for (i = 0; i < DMEM_DBG_LEN/sizeof(*p); i++) {
+		if (!p[i])
+			continue;
+		printk(KERN_INFO " -debug[%03d]= 0x%04lx\n", i, p[i]);
+	}
+
+	done:
+	kfree(p);
+}
+
+static inline void dump_dmem_params(struct atomisp_acc_fw *acc_fw)
+{
+	unsigned long *p, dmem;
+	size_t len;
+	int i;
+
+	dmem = acc_fw->fw->info.isp.mem_initializers[IA_CSS_ISP_DMEM0].address;
+	len = acc_fw->fw->info.isp.mem_initializers[IA_CSS_ISP_DMEM0].size;
+
+	p = kmalloc(len, GFP_KERNEL);
+	if (p == NULL)
+		return;
+
+	isp_dmem_load(ISP0_ID, dmem, p, len);
+	printk(KERN_INFO "ISP DMEM (read dmem params): \n");
+	for (i = 0; i < len / sizeof(unsigned long); i++) {
+		if (!p[i])
+			continue;
+		printk(KERN_INFO " -dmem[0x%lx]= 0x%04lX\n",
+		       dmem + i * sizeof(unsigned long) , p[i]);
+	}
+	kfree(p);
+}
+
+static inline void dump_vamem_info(const unsigned int words, vamem_map_t m)
+{
+	unsigned int bytes;
+	unsigned short *p;
+	int i;
+
+	bytes = words * sizeof(*p);
+	p = kmalloc(bytes, GFP_KERNEL);
+	if (p == NULL)
+		return;
+
+	isp_vamem_load(m.id, 0x00, p, bytes);
+	printk(KERN_INFO "ISP VAMEM%d : \n", (unsigned int) m.id);
+	for (i = 0; i < words; i++)
+		printk(KERN_INFO " -vamem%d[%02d]= 0x%04X\n",(unsigned int) m.id,
+		       i * sizeof(*p) , p[i]);
+	kfree(p);
+}
+
+static void atomisp_acc_firmware_debug(struct atomisp_acc_fw *acc_fw)
+{
+	const unsigned int vamem_dbg_cnt = 4;
+	unsigned long usecs;
+	ktime_t start, end;
+	int i;
+
+	start = ktime_get();
+	dump_dmem_params(acc_fw);
+	dump_isp_debug_info();
+	for (i = 0; i < sizeof(vamem_map)/sizeof(vamem_map[0]); i++)
+		dump_vamem_info(vamem_dbg_cnt, vamem_map[i]);
+	end = ktime_get();
+	usecs = (unsigned long) ktime_us_delta(end, start);
+	printk(KERN_INFO "%s-trace DONE: %ld usecs \n", __FUNCTION__, usecs );
+}
+
+static int atomisp_directvp_wait(void)
+{
+	unsigned int loop = 5000, t = 1000;
+	unsigned long flag = 0, usecs;
+	ktime_t start, end;
+
+	start = ktime_get();
+
+	isp_dmem_load(ISP0_ID, DMEM_ACC_DONE_ADDR, &flag, sizeof(unsigned long));
+
+	while (loop-- && flag != DMEM_ISP_ACC_DONE_FLAG) {
+		isp_dmem_load(ISP0_ID, DMEM_ACC_DONE_ADDR, &flag, sizeof(unsigned long));
+		usleep_range(900, 950);
+	}
+
+	end = ktime_get();
+	usecs = (unsigned long) ktime_us_delta(end, start);
+
+	if (flag != DMEM_ISP_ACC_DONE_FLAG) {
+		printk(KERN_ERR "\n\natomisp firmware timed out \n\n");
+		return -1;
+	}
+
+	while (!isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT) && t) {
+		t--;
+		usleep_range(10, 20);
+	}
+
+	if (!t)
+		printk(KERN_WARNING "isp didnt go idle \n");
+
+	printk(KERN_INFO "%s DONE: %ld usecs, loops: %d, idle loops: %d \n\n",
+	       __FUNCTION__, usecs, 5000 - loop, 1000 - t );
+
+	return 0;
+}
+
+static int atomisp_acc_write_hmem(struct atomisp_acc_fw* acc_fw)
+{
+	unsigned int *p = NULL, *q = NULL;
+	unsigned char hmem[4] = {
+		ATOMISP_ACC_MEMORY_HMEM0,
+		ATOMISP_ACC_MEMORY_HMEM1,
+		ATOMISP_ACC_MEMORY_HMEM2,
+		ATOMISP_ACC_MEMORY_HMEM3
+	};
+	int i, j, len, ret = 0;
+	const int hmem_len = HMEM_LEN/4;
+
+	for (i = 0; i < sizeof(hmem)/sizeof(hmem[0]); i++) {
+
+		len = acc_fw->args[hmem[i]].length;
+		q =  (void *) acc_fw->args[hmem[i]].css_ptr;
+
+		if (len == 0 || len > hmem_len) {
+			printk(KERN_INFO "acc hmem %d length %d \n", hmem[i], len);
+			continue;
+		}
+
+		if (!access_ok(VERIFY_WRITE ,q ,len)) {
+			printk(KERN_ERR "acc hmem pointer error \n");
+			continue;
+		}
+
+		if (p == NULL) {
+			p = kmalloc(hmem_len, GFP_KERNEL);
+			if (p == NULL)
+				return -ENOMEM;
+		}
+
+		isp_hmem_load(HMEM0_ID, i * hmem_len, p, len);
+		ret = copy_to_user(q, p, len);
+		if (!ret) {
+			printk(KERN_INFO "read acc hmem: ptr %p mem %d length %d \n",
+			       q, hmem[i], len);
+
+			printk(KERN_INFO "ISP HMEM%d \n", i);
+			for (j = 0; j < 6; j++)
+				printk(KERN_INFO " -bin[%3d] = 0x%x \n",
+				       j * 50,
+				       p[j * 50]);
+		}
+	}
+	if (p)
+		kfree(p);
+
+	return ret;
+}
+
+static inline int atomisp_program_params(struct atomisp_acc_fw *acc_fw)
+{
+	unsigned long p_src, p_dst = 0;
+	unsigned long *p;
+	int i, len, ret;
+
+	for (i = 0; i < N_IA_CSS_ISP_MEMORIES; i++) {
+
+		p_dst = acc_fw->fw->info.isp.mem_initializers[i].address;
+		p_src = acc_fw->args[i].usr_ptr;
+		len = acc_fw->args[i].length;
+
+		if (p_src == 0 || len == 0) {
+			printk (KERN_INFO "no params for memory %d \n", i );
+			continue;
+
+		}
+		if (len != acc_fw->fw->info.isp.mem_initializers[i].size) {
+			/* VAMEM params are not in the header */
+			if (i != IA_CSS_ISP_VAMEM0 &&
+			    i != IA_CSS_ISP_VAMEM1 &&
+			    i != IA_CSS_ISP_VAMEM2) {
+				printk(KERN_ERR "firmware header mismatch with client \n");
+				printk(KERN_ERR " memory=%d, args %d != firmware %d \n", i, len,
+				       acc_fw->fw->info.isp.mem_initializers[i].size);
+				continue;
+			}
+		}
+
+		if (!access_ok(VERIFY_READ, p_src, len)) {
+			printk(KERN_ERR "acc pointer error \n");
+			continue;
+		}
+
+		p = kmalloc(len, GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+
+		ret = copy_from_user(p, (const void __user *) p_src, len);
+		if (ret) {
+			printk(KERN_ERR "couldnt copy user parameters \n");
+			kfree(p);
+			continue;
+		}
+
+		switch (i) {
+		case IA_CSS_ISP_DMEM0:
+			if (p_dst) {
+				isp_dmem_store(ISP0_ID, p_dst, p, len);
+				printk(KERN_INFO "params: 0x%lx to DMEM offset 0x%lx bytes %d\n",
+				       p_src, p_dst, len);
+			}
+			else
+				printk(KERN_ERR "couldnt read DMEM param destination "
+				       "from firmware !\n");
+			break;
+		case IA_CSS_ISP_VAMEM0:
+			isp_vamem_store(VAMEM0_ID, 0x00, p, len);
+			printk(KERN_INFO "params: 0x%lx to VAMEM0 offset 0x00 bytes %d\n",
+			       p_src, len);
+			break;
+		case IA_CSS_ISP_VAMEM1:
+			isp_vamem_store(VAMEM1_ID, 0x00, p, len);
+			printk(KERN_INFO "params: 0x%lx to VAMEM1 offset 0x00 bytes %d\n",
+			       p_src, len);
+			break;
+		case IA_CSS_ISP_VAMEM2:
+			isp_vamem_store(VAMEM2_ID, 0x00, p, len);
+			printk(KERN_INFO "params: 0x%lx to VAMEM2 offset 0x00 bytes %d\n",
+			       p_src, len);
+			break;
+		default:
+			printk(KERN_ERR "attemp to program params to wrong region \n");
+		}
+
+		kfree(p);
+	}
+
+	return 0;
+}
+
+static inline int atomisp_write_firmware(struct atomisp_acc_fw *acc_fw)
+{
+	struct ia_css_fw_info *firmware = acc_fw->fw;
+	unsigned int blob_len = firmware->blob.size;
+	static unsigned char loaded_fw_name[128];
+	static unsigned int loaded_fw_len;
+	const unsigned char *blob;
+	const unsigned char *name;
+	unsigned long usecs;
+	ktime_t start, end;
+
+	name = (const unsigned char *)(ISP_PROG_NAME(firmware));
+	blob = name + strlen((const char *)name) + 1;
+	if (loaded_fw_len != blob_len) {
+		printk(KERN_INFO "atomisp: loading firmware due to len difference "
+		       "loaded = %d, requested = %d\n", loaded_fw_len, blob_len);
+		goto load;
+	}
+
+	if (memcmp(name, loaded_fw_name, strlen((const char *)name)) != 0) {
+		printk(KERN_INFO "atomisp: loading firmware due to name difference \n");
+		goto load;
+	}
+
+	printk(KERN_INFO "atomisp: running firmware %s size: %d \n", name, blob_len);
+
+#if 0
+	/*
+	 * This functionality doesnt work with CSS 2.0 and B2.2 silicon
+	 * so I need to disable it
+	 *
+	 */
+
+	/* no need to reload firmware since it is already there */
+	return 0;
+#endif
+
+	load:
+	start = ktime_get();
+
+	loaded_fw_len = blob_len;
+	memcpy(loaded_fw_name, name, strlen((const char *)name) + 1);
+	isp_pmem_store(ISP0_ID, 0x00, (void *) blob, blob_len);
+	end = ktime_get();
+	usecs = (unsigned long) ktime_us_delta(end, start);
+	printk(KERN_INFO "atomisp: firmware %s written in %ld usecs (size %d) \n",
+	       name, usecs, blob_len);
+
+	return 0;
+}
+
+static int atomisp_directvp_start(struct atomisp_acc_fw *acc_fw)
+{
+	unsigned long usecs;
+	ktime_t start, end;
+	int ret;
+
+	start = ktime_get();
+
+	if (!acc_fw->fw->info.isp.enable.params) {
+		printk(KERN_ERR "firmware not compiled for directvp \n");
+		return -EFAULT;
+	}
+
+	/* do not remove this code */
+	wbinvd();
+
+	printk(KERN_INFO "atomisp setting params \n");
+	ret = atomisp_program_params(acc_fw);
+	if (ret)
+		return -EFAULT;
+
+	printk(KERN_INFO "atomisp writing firmware \n");
+	ret = atomisp_write_firmware(acc_fw);
+	if (ret)
+		return -EFAULT;
+
+	/* start the ISP */
+	isp_ctrl_setbit(ISP0_ID, ISP_SC_REG, ISP_RUN_BIT);
+	isp_ctrl_setbit(ISP0_ID, ISP_SC_REG, ISP_START_BIT);
+
+	end = ktime_get();
+	usecs = (unsigned long) ktime_us_delta(end, start);
+	printk(KERN_INFO "%s: %ld usecs \n", __FUNCTION__, usecs );
+
+	return 0;
+}
+
+int atomisp_acc_clear_hmem(struct atomisp_device *isp, unsigned int *handle)
+{
+	void *p;
+
+	p = kmalloc(HMEM_LEN, GFP_KERNEL);
+	if (p == NULL)
+		return -ENOMEM;
+
+	memset(p, 0x00, HMEM_LEN);
+	isp_hmem_store(HMEM0_ID, 0x00, p, HMEM_LEN);
+	printk(KERN_INFO "atomisp: histogram memory set to 0x00 - (cleared) \n");
+	kfree(p);
+
+	return 0;
+}
+
+int atomisp_acc_start(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw = NULL;
+
+	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
+		if (*handle != 0 && *handle != acc_fw->handle)
+			continue;
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
+			continue;
+		printk(KERN_INFO "atomisp: start firmare now \n");
+		return atomisp_directvp_start(acc_fw);
+	}
+
+	return -EFAULT;
+}
+
+int atomisp_acc_wait(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+	int i, ret = 0;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	if (*handle == 0)
+		return -EINVAL;
+
+	acc_fw = acc_get_fw(isp, *handle);
+	if (acc_fw == NULL)
+		return -EINVAL;
+
+	ret = atomisp_directvp_wait();
+	if (ret) {
+		isp_ctrl_clearbit(ISP0_ID, ISP_SC_REG, ISP_RUN_BIT);
+		isp_ctrl_clearbit(ISP0_ID, ISP_SC_REG, ISP_START_BIT);
+		return -EIO;
+	}
+
+	atomisp_acc_write_hmem(acc_fw);
+	atomisp_acc_firmware_debug(acc_fw);
+
+	for (i = 0; i < ATOMISP_ACC_NR_MEMORY; i++) {
+		acc_fw->args[i].length = 0;
+		acc_fw->args[i].css_ptr = 0;
+		acc_fw->args[i].usr_ptr = 0;
+	}
+
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+
+static const struct {
+	unsigned int flag;
+	enum ia_css_pipe_id pipe_id;
+} acc_flag_to_pipe[] = {
+	{ ATOMISP_ACC_FW_LOAD_FL_PREVIEW, IA_CSS_PIPE_ID_PREVIEW },
+	{ ATOMISP_ACC_FW_LOAD_FL_COPY, IA_CSS_PIPE_ID_COPY},
+	{ ATOMISP_ACC_FW_LOAD_FL_VIDEO, IA_CSS_PIPE_ID_VIDEO},
+	{ ATOMISP_ACC_FW_LOAD_FL_CAPTURE, IA_CSS_PIPE_ID_CAPTURE}
+};
+
+/*
+ * Allocate struct atomisp_acc_fw along with space for firmware.
+ * The returned struct atomisp_acc_fw is cleared (firmware region is not).
+ */
+static struct atomisp_acc_fw *acc_alloc_fw(unsigned int fw_size) {
+	struct atomisp_acc_fw *acc_fw;
+	/*struct atomisp_acc_fw *acc_fw;*/
+	acc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);
+	if (!acc_fw)
+		return NULL;
+
+	acc_fw->fw = vmalloc(fw_size);
+	if (!acc_fw->fw) {
+		kfree(acc_fw);
+		return NULL;
+	}
+	/*acc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);*/
+	return acc_fw;
+}
+
+static void acc_free_fw(struct atomisp_acc_fw *acc_fw)
+{
+	vfree(acc_fw->fw);
+	kfree(acc_fw);
+}
+
+static struct atomisp_acc_fw *
+acc_get_fw(struct atomisp_device *isp, unsigned int handle) {
+	struct atomisp_acc_fw *acc_fw;
+	/*struct atomisp_acc_fw *acc_fw;*/
+	list_for_each_entry(acc_fw, &isp->acc.fw, list)
+	if (acc_fw->handle == handle)
+		return acc_fw;
+
+	return NULL;
+}
+
+static struct atomisp_map *acc_get_map(struct atomisp_device *isp,
+				       unsigned long css_ptr, size_t length) {
+	struct atomisp_map *atomisp_map;
+	/*struct atomisp_map *atomisp_map;*/
+	list_for_each_entry(       atomisp_map,        &isp->acc.memory_maps,        list)        {
+		if (atomisp_map->ptr == css_ptr &&
+		    atomisp_map->length == length)
+			return atomisp_map;
+	}
+	return NULL;
+}
+
+static int acc_stop_acceleration(struct atomisp_device *isp)
+{
+	void *acc_stages;
+	/*list_for_each_entry(atomisp_map, &isp->acc.memory_maps, list) {*/
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	/*if (atomisp_map->ptr == css_ptr &&*/
+	/*atomisp_map->length == length)*/
+	dev_dbg(isp->dev, ">%s\n", __func__);
+	if (!isp->acc.pipeline) {
+		dev_dbg(isp->dev, "<%s: no acc pipe to stop\n", __func__);
+		return -ENOENT;
+	}
+	/*return atomisp_map;*/
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
+		dev_dbg(isp->dev, "<%s: acc stream not started\n", __func__);
+		return -ENOENT;
+	}
+	/*}*/
+	/*return NULL;*/
+
+	mutex_unlock(&isp->mutex);
+	if (wait_for_completion_interruptible(&isp->acc.acc_done) != 0) {
+		dev_err(isp->dev, "<%s: completion interrupted\n", __func__);
+		mutex_lock(&isp->mutex);
+		return -ERESTARTSYS;
+	}
+	mutex_lock(&isp->mutex);
+
+	dev_dbg(isp->dev, "wait for acc pipeline done finished\n");
+	/*if (ia_css_acceleration_stop() != IA_CSS_SUCCESS)*/
+	del_timer_sync(&isp->wdt);
+	cancel_work_sync(&isp->wdt_work);
+	/*dev_err(isp->dev, "cannot stop acceleration pipeline\n");*/
+	/*
+	 * back up the acc stages pointer and release the memory
+	 * after css stop.
+	 */
+	acc_stages =
+	isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_ACC].
+	acc_stages;
+	ia_css_stop(isp_subdev, false);
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
+	kfree(acc_stages);
+
+	isp->acc.pipeline = NULL;
+	dev_dbg(isp->dev, "<%s\n", __func__);
+	return 0;
+}
+
+void atomisp_acc_init(struct atomisp_device *isp)
+{
+	INIT_LIST_HEAD(&isp->acc.fw);
+	INIT_LIST_HEAD(&isp->acc.memory_maps);
+	ida_init(&isp->acc.ida);
+}
+
+void atomisp_acc_cleanup(struct atomisp_device *isp)
+{
+	ida_destroy(&isp->acc.ida);
+}
+
+void atomisp_acc_release(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw, *ta;
+	struct atomisp_map *atomisp_map, *tm;
+
+	/* Stop acceleration if already running */
+	if (isp->acc.pipeline)
+		acc_stop_acceleration(isp);
+
+	/* Unload all loaded acceleration binaries */
+	list_for_each_entry_safe(acc_fw, ta, &isp->acc.fw, list) {
+		list_del(&acc_fw->list);
+		ida_remove(&isp->acc.ida, acc_fw->handle);
+		acc_free_fw(acc_fw);
+	}
+
+	/* Free all mapped memory blocks */
+	list_for_each_entry_safe(atomisp_map, tm, &isp->acc.memory_maps, list) {
+		list_del(&atomisp_map->list);
+		mmgr_free(atomisp_map->ptr);
+		kfree(atomisp_map);
+	}
+}
+
+int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
+			     struct atomisp_acc_fw_load_to_pipe *user_fw)
+{
+	static const unsigned int pipeline_flags =
+	ATOMISP_ACC_FW_LOAD_FL_PREVIEW |
+	ATOMISP_ACC_FW_LOAD_FL_COPY |
+	ATOMISP_ACC_FW_LOAD_FL_VIDEO |
+	ATOMISP_ACC_FW_LOAD_FL_CAPTURE |
+	ATOMISP_ACC_FW_LOAD_FL_ACC;
+
+	struct atomisp_acc_fw *acc_fw;
+	int handle;
+
+	if (!user_fw->data || user_fw->size == 0)
+		return -EINVAL;
+
+	/* Binary has to be enabled at least for one pipeline */
+	if (!(user_fw->flags & pipeline_flags))
+		return -EINVAL;
+
+	/* We do not support other flags yet */
+	if (user_fw->flags & ~pipeline_flags)
+		return -EINVAL;
+
+	if (user_fw->type < ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT ||
+	    user_fw->type > ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
+		return -EINVAL;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	acc_fw = acc_alloc_fw(user_fw->size);
+	if (!acc_fw)
+		return -ENOMEM;
+
+	if (copy_from_user(acc_fw->fw, user_fw->data, user_fw->size)) {
+		acc_free_fw(acc_fw);
+		return -EFAULT;
+	}
+
+	if (!ida_pre_get(&isp->acc.ida, GFP_KERNEL) ||
+	    ida_get_new_above(&isp->acc.ida, 1, &handle)) {
+		acc_free_fw(acc_fw);
+		return -ENOSPC;
+	}
+
+	user_fw->fw_handle = handle;
+	acc_fw->handle = handle;
+	acc_fw->flags = user_fw->flags;
+	acc_fw->type = user_fw->type;
+	/*
+	 * correct isp firmware type in order ISP firmware can be appended
+	 * to correct pipe properly
+	 */
+	if (acc_fw->fw->type == ia_css_isp_firmware) {
+		switch (acc_fw->type) {
+		case ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_OUTPUT;
+			break;
+
+		case ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_VIEWFINDER;
+			break;
+
+		case ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_STANDALONE;
+			break;
+		}
+	}
+
+	list_add_tail(&acc_fw->list, &isp->acc.fw);
+	return 0;
+}
+
+int atomisp_acc_load(struct atomisp_device *isp,
+		     struct atomisp_acc_fw_load *user_fw)
+{
+	struct atomisp_acc_fw_load_to_pipe ltp;
+	int r;
+
+	memset(&ltp, 0, sizeof(ltp));
+	ltp.flags = ATOMISP_ACC_FW_LOAD_FL_ACC;
+	ltp.type = ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE;
+	ltp.size = user_fw->size;
+	ltp.data = user_fw->data;
+	r = atomisp_acc_load_to_pipe(isp, &ltp);
+	user_fw->fw_handle = ltp.fw_handle;
+
+	return r;
+}
+
+int atomisp_acc_unload(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	acc_fw = acc_get_fw(isp, *handle);
+	if (!acc_fw)
+		return -EINVAL;
+
+	list_del(&acc_fw->list);
+	ida_remove(&isp->acc.ida, acc_fw->handle);
+	acc_free_fw(acc_fw);
+
+	return 0;
+}
+
+static int acc_set_parameters(struct atomisp_acc_fw *acc_fw)
+{
+	enum ia_css_isp_memories mem;
+
+	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
+		if (acc_fw->args[mem].length == 0)
+			continue;
+		acc_fw->fw->mem_initializers[mem].address = acc_fw->args[mem].css_ptr;
+		acc_fw->fw->mem_initializers[mem].size = acc_fw->args[mem].length;
+	}
+
+	return 0;
+}
+
+int atomisp_acc_map(struct atomisp_device *isp, struct atomisp_acc_map *map)
+{
+	int pgnr;
+	hrt_vaddress cssptr;
+	struct atomisp_map *atomisp_map;
+
+	if (map->flags || !map->user_ptr || map->css_ptr)
+		return -EINVAL;
+
+	if (isp->acc.pipeline)
+		return -EBUSY;
+
+	pgnr = DIV_ROUND_UP(map->length, PAGE_SIZE);
+	cssptr = (hrt_vaddress)hrt_isp_css_mm_alloc_user_ptr(
+							    map->length, (unsigned int)map->user_ptr,
+							    pgnr, HRT_USR_PTR, NULL, false);
+	if (!cssptr)
+		return -ENOMEM;
+
+	atomisp_map = kmalloc(sizeof(*atomisp_map), GFP_KERNEL);
+	if (!atomisp_map) {
+		mmgr_free(cssptr);
+		return -ENOMEM;
+	}
+	atomisp_map->usr_ptr = (unsigned long) map->user_ptr;
+	atomisp_map->ptr = cssptr;
+	atomisp_map->length = map->length;
+	list_add(&atomisp_map->list, &isp->acc.memory_maps);
+
+	dev_dbg(isp->dev, "%s: userptr 0x%x, css_address 0x%x, size %d\n",
+		__func__, (unsigned int)map->user_ptr, cssptr, map->length);
+	map->css_ptr = cssptr;
+	printk(KERN_INFO "acc map: usr_ptr 0x%08lx, css_ptr 0x%08lx, len %08d \n",
+	       atomisp_map->usr_ptr, (unsigned long) atomisp_map->ptr, atomisp_map->length);
+	return 0;
+}
+
+int atomisp_acc_unmap(struct atomisp_device *isp, struct atomisp_acc_map *map)
+{
+	struct atomisp_map *atomisp_map;
+
+	if (map->flags)
+		return -EINVAL;
+
+	if (isp->acc.pipeline)
+		return -EBUSY;
+
+	atomisp_map = acc_get_map(isp, map->css_ptr, map->length);
+	if (!atomisp_map)
+		return -EINVAL;
+
+	list_del(&atomisp_map->list);
+	printk(KERN_INFO "acc unmap: usr_ptr 0x%08lx, css_ptr 0x%08lx, len %08d \n",
+	       atomisp_map->usr_ptr, (unsigned long) atomisp_map->ptr, atomisp_map->length);
+	mmgr_free(atomisp_map->ptr);
+	kfree(atomisp_map);
+
+	return 0;
+}
+
+int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
+			     struct atomisp_acc_s_mapped_arg *arg)
+{
+	struct atomisp_acc_fw *acc_fw;
+	struct atomisp_map *map = NULL;
+	unsigned long usr_ptr;
+
+	if (arg->memory >= ATOMISP_ACC_NR_MEMORY) {
+		printk(KERN_ERR "memory out of bound \n");
+		return -EINVAL;
+	}
+
+	if (isp->acc.pipeline) {
+		printk(KERN_ERR "pipeline already running \n");
+		return -EBUSY;
+	}
+
+	acc_fw = acc_get_fw(isp, arg->fw_handle);
+	if (!acc_fw) {
+		printk(KERN_ERR "no firmware \n");
+		return -EINVAL;
+	}
+
+	/* hack: if the memory is one of the HMEM, css_ptr is actually
+	 * userspace memory mapped in the kernel
+	 *
+	 */
+	if (arg->memory == ATOMISP_ACC_MEMORY_HMEM0 ||
+	    arg->memory == ATOMISP_ACC_MEMORY_HMEM1 ||
+	    arg->memory == ATOMISP_ACC_MEMORY_HMEM2 ||
+	    arg->memory == ATOMISP_ACC_MEMORY_HMEM3) {
+		printk(KERN_INFO "requested hmem %d  len %d \n",
+		       arg->memory, arg->length);
+		goto done;
+	}
+
+	if (arg->css_ptr != 0 || arg->length != 0) {
+		/* Unless the parameter is cleared, check that it exists */
+
+		map = acc_get_map(isp, arg->css_ptr, arg->length);
+		if (map == NULL)
+			return -EINVAL;
+
+	}
+	done:
+	acc_fw->args[arg->memory].length = arg->length;
+	acc_fw->args[arg->memory].css_ptr = arg->css_ptr;
+	if (map)
+		usr_ptr = map->usr_ptr;
+	else
+		usr_ptr	= arg->css_ptr;
+	acc_fw->args[arg->memory].usr_ptr = usr_ptr;
+
+	printk(KERN_INFO "argument map: ptr %p memory %d, length %d \n",
+	       (void *) arg->css_ptr,
+	       arg->memory,
+	       arg->length);
+
+	return 0;
+}
+
+/*
+ * Appends the loaded acceleration binary extensions to the
+ * current ISP mode. Must be called just before ia_css_start().
+ */
+int atomisp_acc_load_extensions(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/* FIXME: Function should take isp_subdev as parameter */
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	bool ext_loaded = false;
+
+	int ret = 0, i;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	/* Invalidate caches. FIXME: should flush only necessary buffers */
+	wbinvd();
+
+	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(acc_flag_to_pipe); i++) {
+			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
+				unsigned int pipe_id =
+				acc_flag_to_pipe[i].pipe_id;
+				struct ia_css_pipe_config *pipe_cfg =
+				&isp_subdev->css2_basis.
+				pipe_configs[pipe_id];
+				/* Add the binary into the pipeline */
+				pipe_cfg->acc_extension = acc_fw->fw;
+				isp_subdev->css2_basis.update_pipe[pipe_id] =
+				true;
+				ext_loaded = true;
+			}
+		}
+
+		ret = acc_set_parameters(acc_fw);
+		if (ret < 0)
+			goto error;
+	}
+
+	if (!ext_loaded)
+		return ret;
+
+	if (ia_css_update_stream(isp_subdev) != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: update stream failed.\n", __func__);
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	isp->acc.extension_mode = true;
+	return 0;
+
+	error:
+	list_for_each_entry_continue_reverse(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
+			unsigned int pipe_id =
+			acc_flag_to_pipe[i].pipe_id;
+			struct ia_css_pipe_config *pipe_cfg =
+			&isp_subdev->css2_basis.pipe_configs[pipe_id];
+
+			if (acc_fw->flags & acc_flag_to_pipe[i].flag)
+				pipe_cfg->acc_extension = NULL;
+		}
+	}
+	return ret;
+}
+
+void atomisp_acc_unload_extensions(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/* FIXME: Function should take isp_subdev as parameter */
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+
+	int i;
+
+	if (!isp->acc.extension_mode)
+		return;
+
+	list_for_each_entry_reverse(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
+			unsigned int pipe_id =
+			acc_flag_to_pipe[i].pipe_id;
+			struct ia_css_pipe_config *pipe_cfg =
+			&isp_subdev->css2_basis.pipe_configs[pipe_id];
+			/* Remove the binary from the pipeline */
+			if (acc_fw->flags & acc_flag_to_pipe[i].flag)
+				pipe_cfg->acc_extension = NULL;
+		}
+	}
+
+	isp->acc.extension_mode = false;
+}
+
+#if 0
+
+int atomisp_acc_start(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+	enum ia_css_err err;
+	struct ia_css_pipe_config *pipe_config;
+
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	const struct ia_css_stream_config *s_config =
+	&isp_subdev->css2_basis.stream_config;
+	int ret = 0;
+
+	dev_dbg(isp->dev, ">%s\n", __func__);
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	/* Invalidate caches. FIXME: should flush only necessary buffers */
+	wbinvd();
+
+	if (isp_subdev->css2_basis.stream) {
+		dev_dbg(isp->dev, "%s: destroy basis stream\n", __func__);
+		if (isp_subdev->css2_basis.stream_state ==
+		    CSS2_STREAM_STARTED) {
+			ret = ia_css_stream_stop(isp_subdev->css2_basis.stream);
+			if (ret != IA_CSS_SUCCESS) {
+				dev_err(isp->dev, "stop stream failed.\n");
+				return -EBUSY;
+			}
+		}
+
+		ret = ia_css_stream_destroy(isp_subdev->css2_basis.stream);
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp->dev, "destroy stream failed.\n");
+			return -EBUSY;
+		}
+		isp_subdev->css2_basis.stream = NULL;
+	}
+
+	pipe_config = &isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_ACC];
+	ia_css_pipe_config_defaults(pipe_config);
+	pipe_config->acc_stages = kzalloc(MAX_ACC_STAGES *
+					  sizeof(struct ia_css_fw_info *), GFP_KERNEL);
+	if (!pipe_config->acc_stages)
+		return -ENOMEM;
+	pipe_config->mode = IA_CSS_PIPE_MODE_ACC;
+	pipe_config->num_acc_stages = 0;
+
+	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
+		if (*handle != 0 && *handle != acc_fw->handle)
+			continue;
+
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
+			continue;
+
+		/* Add the binary into the pipeline */
+		pipe_config->acc_stages[pipe_config->num_acc_stages++] =
+		acc_fw->fw;
+		if (acc_set_parameters(acc_fw)) {
+			dev_err(isp->dev, "acc_set_parameters failed\n");
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+	/* Refuse creating pipelines with no binaries */
+	if (pipe_config->num_acc_stages < 1) {
+		/* Refuse creating pipelines with no binaries */
+		dev_err(isp->dev, "%s: no acc binary available\n", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	err = ia_css_pipe_create(pipe_config,
+				 &isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC]);
+	if (err) {
+		dev_err(isp->dev, "%s: ia_css_pipe_create failed %d\n",
+			__func__, err);
+		ret = -EBADE;
+		goto err;
+	}
+
+	memset(&isp_subdev->css2_basis.stream_config, 0,
+	       sizeof(struct ia_css_stream_config));
+	err = ia_css_stream_create(s_config, 1,
+				   &isp_subdev->css2_basis.
+				   pipes[IA_CSS_PIPE_ID_ACC],
+				   &isp_subdev->css2_basis.stream);
+	if (err != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: create stream error %d.\n",
+			__func__, err);
+		ia_css_pipe_destroy(isp_subdev->css2_basis.
+				    pipes[IA_CSS_PIPE_ID_ACC]);
+		isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC] = NULL;
+		err = -EINVAL;
+		goto err;
+	}
+
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
+	init_completion(&isp->acc.acc_done);
+	atomic_set(&isp->wdt_count, 0);
+	mod_timer(&isp->wdt, jiffies + ATOMISP_ISP_TIMEOUT_DURATION);
+	isp->fr_status = ATOMISP_FRAME_STATUS_OK;
+	isp->sw_contex.invalid_frame = false;
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp->acc.pipeline = isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC];
+
+	dev_dbg(isp->dev, ">ia_css_start\n");
+	err = ia_css_start(isp_subdev, false);
+	if (err != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: start css error %d.\n", __func__, err);
+		ret = ia_css_stream_destroy(isp_subdev->css2_basis.stream);
+		isp_subdev->css2_basis.stream = NULL;
+		ia_css_pipe_destroy(isp_subdev->css2_basis.
+				    pipes[IA_CSS_PIPE_ID_ACC]);
+		isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC] = NULL;
+		err = -EINVAL;
+		goto err;
+	}
+	dev_dbg(isp->dev, "<ia_css_start\n");
+	dev_dbg(isp->dev, "<%s\n", __func__);
+	return 0;
+	err:
+	kfree(pipe_config->acc_stages);
+	dev_dbg(isp->dev, "<%s err %d\n", __func__, ret);
+	return ret;
+}
+
+
+int atomisp_acc_wait(struct atomisp_device *isp, unsigned int *handle)
+{
+	if (*handle && !acc_get_fw(isp, *handle))
+		return -EINVAL;
+
+	return acc_stop_acceleration(isp);
+}
+
+#endif
+
diff --git a/drivers/media/atomisp2/atomisp_acc.h b/drivers/media/atomisp2/atomisp_acc.h
new file mode 100644
index 0000000..765e273
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_acc.h
@@ -0,0 +1,115 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_ACC_H__
+#define __ATOMISP_ACC_H__
+
+#include <linux/atomisp.h>
+#include "ia_css_types.h"
+#include "atomisp_internal.h"
+
+/*
+ * Interface functions for AtomISP driver acceleration API implementation.
+ */
+
+struct atomisp_device;
+
+/*
+ * Initialize acceleration interface.
+ * Must be called once when the driver is loaded.
+ */
+void atomisp_acc_init(struct atomisp_device *isp);
+
+void atomisp_acc_cleanup(struct atomisp_device *isp);
+
+/*
+ * Free up any allocated resources.
+ * Must be called each time when the device is closed.
+ * Note that there isn't corresponding open() call;
+ * this function may be called sequentially multiple times.
+ * Must be called to free up resources before driver is unloaded.
+ */
+void atomisp_acc_release(struct atomisp_device *isp);
+
+/* Load acceleration binary. DEPRECATED. */
+int atomisp_acc_load(struct atomisp_device *isp,
+		     struct atomisp_acc_fw_load *fw);
+
+/* Load acceleration binary with specified properties */
+int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
+			     struct atomisp_acc_fw_load_to_pipe *fw);
+
+/* Unload specified acceleration binary */
+int atomisp_acc_unload(struct atomisp_device *isp,
+		       unsigned int *handle);
+
+/*
+ * Map a memory region into ISP memory space.
+ */
+int atomisp_acc_map(struct atomisp_device *isp,
+		    struct atomisp_acc_map *map);
+
+/*
+ * Unmap a mapped memory region.
+ */
+int atomisp_acc_unmap(struct atomisp_device *isp,
+		      struct atomisp_acc_map *map);
+
+/*
+ * Set acceleration binary argument to a previously mapped memory region.
+ */
+int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
+			     struct atomisp_acc_s_mapped_arg *arg);
+
+/*
+ * Clear the whole histogram memory
+ */
+int atomisp_acc_clear_hmem(struct atomisp_device *isp, unsigned int *handle);
+
+/*
+ * Start acceleration.
+ * Return immediately, acceleration is left running in background.
+ * Specify either acceleration binary or pipeline which to start.
+ */
+int atomisp_acc_start(struct atomisp_device *isp,
+		      unsigned int *handle);
+
+/*
+ * Wait until acceleration finishes.
+ * This MUST be called after each acceleration has been started.
+ * Specify either acceleration binary or pipeline handle.
+ */
+int atomisp_acc_wait(struct atomisp_device *isp,
+		     unsigned int *handle);
+
+/*
+ * Appends the loaded acceleration binary extensions to the
+ * current ISP mode. Must be called just before sh_css_start().
+ */
+int atomisp_acc_load_extensions(struct atomisp_device *isp);
+
+/*
+ * Must be called after streaming is stopped:
+ * unloads any loaded acceleration extensions.
+ */
+void atomisp_acc_unload_extensions(struct atomisp_device *isp);
+
+#endif /* __ATOMISP_ACC_H__ */
diff --git a/drivers/media/atomisp2/atomisp_cmd.c b/drivers/media/atomisp2/atomisp_cmd.c
new file mode 100644
index 0000000..e70d860
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_cmd.c
@@ -0,0 +1,4924 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/firmware.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/pm_runtime.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+
+#include <media/v4l2-event.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp-regs.h"
+#include "atomisp_tables.h"
+#include "atomisp_acc.h"
+#include "atomisp_compat.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+
+#include "sh_css_debug.h"
+#include "sh_css_hrt.h"
+#include "ia_css_accelerate.h"
+#include "sh_css_defs.h"
+#include "system_global.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"
+#include "gp_device.h"
+#include "device_access.h"
+#include "irq.h"
+
+#ifdef CSS_2
+#include "ia_css_types.h"
+#else
+#include "sh_css.h"
+#include "sh_css_types.h"
+#endif
+
+#include "hrt/bits.h"
+
+/* We should never need to run the flash for more than 2 frames.
+ * At 15fps this means 133ms. We set the timeout a bit longer.
+ * Each flash driver is supposed to set its own timeout, but
+ * just in case someone else changed the timeout, we set it
+ * here to make sure we don't damage the flash hardware. */
+#define FLASH_TIMEOUT 800 /* ms */
+
+union host {
+	struct {
+		void *kernel_ptr;
+		void __user *user_ptr;
+		int size;
+	} scalar;
+	struct {
+		void *hmm_ptr;
+	} ptr;
+};
+
+/*
+ * atomisp_kernel_malloc: chooses whether kmalloc() or vmalloc() is preferable.
+ *
+ * It is also a wrap functions to pass into css framework.
+ */
+void *atomisp_kernel_malloc(size_t bytes)
+{
+	/* vmalloc() is preferable if allocating more than 1 page */
+	if (bytes > PAGE_SIZE)
+		return vmalloc(bytes);
+
+	return kmalloc(bytes, GFP_KERNEL);
+}
+
+/*
+ * atomisp_kernel_zalloc: chooses whether set 0 to the allocated memory.
+ *
+ * It is also a wrap functions to pass into css framework.
+ */
+void *atomisp_kernel_zalloc(size_t bytes, bool zero_mem)
+{
+	void *ptr = atomisp_kernel_malloc(bytes);
+/* Free buffer allocated with atomisp_kernel_malloc() helper */
+	if (ptr && zero_mem)
+		memset(ptr, 0, bytes);
+
+	return ptr;
+}
+
+/*
+ * Free buffer allocated with atomisp_kernel_malloc()/atomisp_kernel_zalloc
+ * helper
+ */
+void atomisp_kernel_free(void *ptr)
+{
+	/* Verify if buffer was allocated by vmalloc() or kmalloc() */
+	if (is_vmalloc_addr(ptr))
+		vfree(ptr);
+	else
+		kfree(ptr);
+}
+
+/*
+ * get sensor:dis71430/ov2720 related info from v4l2_subdev->priv data field.
+ * subdev->priv is set in mrst.c
+ */
+struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd)
+{
+	return (struct camera_mipi_info *)v4l2_get_subdev_hostdata(sd);
+}
+
+/*
+ * get struct atomisp_video_pipe from v4l2 video_device
+ */
+struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev)
+{
+	return (struct atomisp_video_pipe *)
+	    container_of(dev, struct atomisp_video_pipe, vdev);
+}
+
+/*
+ * get struct atomisp_sub_device from atomisp_video_pipe
+ */
+struct atomisp_sub_device *atomisp_to_sub_device(struct atomisp_video_pipe
+						 *atomisp_pipe)
+{
+	return atomisp_pipe->isp_subdev;
+}
+
+/* This is just a draft rules, should be tuned when sensor is ready*/
+static struct atomisp_freq_scaling_rule dfs_rules[] = {
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.fps = 60,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+	{
+		.width = 4192,
+		.height = 3104,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 4096,
+		.height = 3072,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 3648,
+		.height = 2736,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.fps = 60,
+		.isp_freq = ISP_FREQ_320MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+};
+
+#define ISP_FREQ_RULE_MAX (ARRAY_SIZE(dfs_rules))
+
+static unsigned short atomisp_get_sensor_fps(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_subdev_frame_interval frame_interval;
+	unsigned short fps;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+		video, g_frame_interval, &frame_interval)) {
+		fps = 0;
+	} else {
+		if (frame_interval.interval.numerator)
+			fps = frame_interval.interval.denominator /
+			    frame_interval.interval.numerator;
+		else
+			fps = 0;
+	}
+	return fps;
+}
+/*
+ * DFS progress is shown as follows:
+ * 1. Target frequency is calculated according to FPS/Resolution/ISP running
+ * mode.
+ * 2. Ratio is calucated in formula: 2 * (HPLL / target frequency) - 1
+ * 3. Set ratio to ISPFREQ40, 1 to FREQVALID and ISPFREQGUAR40
+ *    to 200MHz in ISPSSPM1.
+ * 4. Wait for FREQVALID to be cleared by P-Unit.
+ * 5. Wait for field ISPFREQSTAT40 in ISPSSPM1 turn to ratio set in 3.
+ */
+static int write_target_freq_to_hw(int new_freq)
+{
+	int ratio, timeout;
+	u32 isp_sspm1 = 0;
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	if (isp_sspm1 & ISP_FREQ_VALID_MASK) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			  "clearing ISPSSPM1 valid bit.\n");
+		intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
+				    isp_sspm1 & ~(1 << ISP_FREQ_VALID_OFFSET));
+	}
+
+	ratio = 2 * (HPLL_FREQ / new_freq) - 1;
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	isp_sspm1 &= ~(0x1F << ISP_REQ_FREQ_OFFSET);
+	intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
+				   isp_sspm1
+				   | ratio << ISP_REQ_FREQ_OFFSET
+				   | 1 << ISP_FREQ_VALID_OFFSET
+				   | 0xF << ISP_REQ_GUAR_FREQ_OFFSET);
+
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	timeout = 10;
+	while ((isp_sspm1 & ISP_FREQ_VALID_MASK) && timeout) {
+		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			"waiting for ISPSSPM1 valid bit to be 0.\n");
+		udelay(100);
+		timeout--;
+	}
+	if (timeout == 0) {
+		v4l2_err(&atomisp_dev, "DFS failed due to HW error.\n");
+		return -EINVAL;
+	}
+
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	timeout = 10;
+	while (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {
+		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+				"waiting for ISPSSPM1 status bit to be 0x%x.\n",
+				 new_freq);
+		udelay(100);
+		timeout--;
+	}
+	if (timeout == 0) {
+		v4l2_err(&atomisp_dev, "DFS target freq is rejected by HW.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+int atomisp_freq_scaling(struct atomisp_device *isp, enum atomisp_dfs_mode mode)
+{
+	unsigned int new_freq;
+	struct atomisp_freq_scaling_rule curr_rules;
+	int i, ret;
+	unsigned short fps = 0;
+	struct atomisp_sub_device *isp_subdev = NULL;
+
+	if (isp->sw_contex.power_state != ATOM_ISP_POWER_UP) {
+		v4l2_err(&atomisp_dev, "DFS cannot proceed due to no power.\n");
+		return -EINVAL;
+	}
+
+	/* ISP will run at full speed in multi stream mode */
+	if (atomisp_subdev_streaming_count(isp) > 1) {
+		new_freq = ISP_FREQ_400MHZ;
+		goto done;
+	}
+
+	if (mode == ATOMISP_DFS_MODE_LOW) {
+		new_freq = ISP_FREQ_200MHZ;
+		goto done;
+	}
+
+	if (mode == ATOMISP_DFS_MODE_MAX) {
+		new_freq = ISP_FREQ_400MHZ;
+		goto done;
+	}
+
+	/* check which stream is enabled */
+	for (i = 0; i < isp->num_of_streams; i++)
+		if (isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED) {
+			isp_subdev = &isp->isp_subdev[i];
+			break;
+		}
+
+	if (!isp_subdev) {
+		dev_err(isp->dev,
+			"DFS auto mode can not be done due to no streaming.\n");
+		return -EINVAL;
+	}
+
+	fps = atomisp_get_sensor_fps(isp_subdev);
+	if (fps == 0)
+		return -EINVAL;
+
+	curr_rules.width = isp_subdev->fmt[isp_subdev->capture_pad].fmt.width;
+	curr_rules.height = isp_subdev->fmt[isp_subdev->capture_pad].fmt.height;
+	curr_rules.fps = fps;
+	curr_rules.run_mode = isp_subdev->run_mode->val;
+	/*
+	 * For continuous vf mode, we need to make the capture setting applied
+	 * since preview mode, because there is no chance to do this when
+	 * starting image capture.
+	 */
+	
+	if (isp_subdev->params.continuous_vf)
+		curr_rules.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
+
+	/* search for the target frequency by looping freq rules*/
+	for (i = 0; i < ISP_FREQ_RULE_MAX; i++) {
+		if (curr_rules.width != dfs_rules[i].width
+			&& dfs_rules[i].width != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.height != dfs_rules[i].height
+			&& dfs_rules[i].height != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.fps != dfs_rules[i].fps
+			&& dfs_rules[i].fps != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.run_mode != dfs_rules[i].run_mode
+			&& dfs_rules[i].run_mode != ISP_FREQ_RULE_ANY)
+			continue;
+		break;
+	}
+	if (i == ISP_FREQ_RULE_MAX)
+		new_freq = ISP_FREQ_320MHZ;
+	else
+		new_freq = dfs_rules[i].isp_freq;
+
+done:
+	/* workround to get isp works at 400Mhz for byt due to perf issue */
+	if (IS_MRFLD)
+		new_freq = ISP_FREQ_400MHZ;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "DFS target frequency=%d.\n", new_freq);
+	if (new_freq == isp->sw_contex.running_freq) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "ignoring DFS target freq.\n");
+		return 0;
+	}
+	ret = write_target_freq_to_hw(new_freq);
+	if (!ret)
+		isp->sw_contex.running_freq = new_freq;
+	return ret;
+}
+extern struct ia_css_env css_env;
+/*
+ * reset and restore ISP
+ */
+int atomisp_reset(struct atomisp_device *isp)
+{
+	/* Reset ISP by power-cycling it */
+	int ret = 0, mmu_base_addr = -1;
+	v4l2_dbg(2, dbg_level, &atomisp_dev, "%s\n",__func__);
+
+	ia_css_uninit();
+	ret = pm_runtime_put_sync(isp->dev);
+
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "can not disable ISP power\n");
+	} else {
+		ret = pm_runtime_get_sync(isp->dev);
+		if (ret < 0)
+			v4l2_err(&atomisp_dev, "can not enable ISP power\n");
+	}
+
+	mmu_base_addr = hrt_isp_get_mmu_base_address();
+	if (mmu_base_addr < 0) {
+		v4l2_err(&atomisp_dev, "get base address error.\n");
+	}
+
+	if (ia_css_init(&css_env,
+			&isp->css_fw,
+			(uint32_t)mmu_base_addr,
+			IA_CSS_IRQ_TYPE_PULSE)) {
+		v4l2_err(&atomisp_dev, "re-init css failed.\n");
+	}
+
+	return ret;
+}
+
+#ifdef ISP_IRQ_HELPER
+/*
+ * interrupt enable/disable functions
+ */
+static void enable_isp_irq(enum hrt_isp_css_irq irq, bool enable)
+{
+	if (enable) {
+		irq_enable_channel(IRQ0_ID, irq);
+		/*sh_css_hrt_irq_enable(irq, true, false);*/
+		switch (irq) { /*We only have sp interrupt right now*/
+		case hrt_isp_css_irq_sp:
+			/*sh_css_hrt_irq_enable_sp(true);*/
+			cnd_sp_irq_enable(SP0_ID, true);
+			break;
+		default:
+			break;
+		}
+
+	} else {
+		/*sh_css_hrt_irq_disable(irq);*/
+		irq_disable_channel(IRQ0_ID, irq);
+		switch (irq) {
+		case hrt_isp_css_irq_sp:
+			/*sh_css_hrt_irq_enable_sp(false);*/
+			cnd_sp_irq_enable(SP0_ID, false);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/*
+ * interrupt clean function
+ */
+static void clear_isp_irq(enum hrt_isp_css_irq irq)
+{
+	irq_clear_all(IRQ0_ID);
+}
+#endif
+
+void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev)
+{
+	u32 msg32;
+	u16 msg16;
+
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
+	msg32 |= 1 << MSI_ENABLE_BIT;
+	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
+
+	msg32 = (1 << INTR_IER) | (1 << INTR_IIR);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
+
+	pci_read_config_word(dev, PCI_COMMAND, &msg16);
+	msg16 |= (PCI_COMMAND_MEMORY |
+		  PCI_COMMAND_MASTER |
+		  PCI_COMMAND_INTX_DISABLE);
+	pci_write_config_word(dev, PCI_COMMAND, msg16);
+}
+
+void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev)
+{
+	u32 msg32;
+	u16 msg16;
+
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
+	msg32 &=  ~(1 << MSI_ENABLE_BIT);
+	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
+
+	msg32 = 0x0;
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
+
+	pci_read_config_word(dev, PCI_COMMAND, &msg16);
+	msg16 &= ~(PCI_COMMAND_MASTER |
+		   PCI_COMMAND_INTX_DISABLE);
+	pci_write_config_word(dev, PCI_COMMAND, msg16);
+}
+
+static void atomisp_sof_event(struct atomisp_device *isp)
+{
+	struct v4l2_event event;
+	struct atomisp_sub_device *isp_subdev;
+
+	int i;
+	memset(&event, 0, sizeof(event));
+
+	/*
+	 * Disable SOF in multiple stream mode due to HW limitation.
+	 *
+	 * As we only have one MIPI Backend to generate SOF/EOF IRQs. In multi
+	 * stream mode, we can not differentiate which sensor generate the SOF
+	 */
+	if (atomisp_subdev_streaming_count(isp) != 1)
+		return;
+
+	event.type = V4L2_EVENT_FRAME_SYNC;
+	event.u.frame_sync.frame_sequence = atomic_read(&isp->sof_count);
+
+	for(i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED)
+			v4l2_event_queue(isp_subdev->subdev.devnode, &event);
+	}
+}
+
+static void atomisp_3a_stats_ready_event(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_event event = {0};
+
+	event.type = V4L2_EVENT_ATOMISP_3A_STATS_READY;
+	event.u.frame_sync.frame_sequence =
+	    atomic_read(&isp_subdev->isp->sequence);
+
+	v4l2_event_queue(isp_subdev->subdev.devnode, &event);
+}
+
+static void print_csi_rx_errors(struct atomisp_device *isp)
+{
+	u32 infos = 0;
+
+	ia_css_rx_get_irq_info(&infos);
+
+	dev_err(isp->dev, "CSI Receiver errors:\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		dev_err(isp->dev, "  buffer overrun");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		dev_err(isp->dev, "  start-of-transmission error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		dev_err(isp->dev, "  start-of-transmission sync error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		dev_err(isp->dev, "  control error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		dev_err(isp->dev, "  2 or more ECC errors");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		dev_err(isp->dev, "  CRC mismatch");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		dev_err(isp->dev, "  unknown error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		dev_err(isp->dev, "  frame sync error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		dev_err(isp->dev, "  frame data error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		dev_err(isp->dev, "  data timeout");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		dev_err(isp->dev, "  unknown escape command entry");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		dev_err(isp->dev, "  line sync error");
+}
+
+/* interrupt handling function*/
+irqreturn_t atomisp_isr(int irq, void *dev)
+{
+	u32 msg_ret;
+	struct atomisp_device *isp = (struct atomisp_device *)dev;
+	unsigned int irq_infos = 0;
+	unsigned long flags;
+	int err;
+	int i, streaming;
+
+	err = ia_css_irq_translate(&irq_infos);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "ENTER atomisp_isr, irq:0x%x\n", irq_infos);
+
+	if (err != IA_CSS_SUCCESS) {
+		v4l2_warn(&atomisp_dev, "%s:failed to translate irq (err = %d,"
+			  " infos = %d)\n", __func__, err, irq_infos);
+		printk("ERROR ia_css_irq_translate failed\n");
+		return IRQ_NONE;
+	}
+
+	/* Clear irq reg at PENWELL B0 */
+	pci_read_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, &msg_ret);
+	msg_ret |= 1 << INTR_IIR;
+	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
+
+	spin_lock_irqsave(&isp->lock, flags);
+
+	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
+		streaming += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+	if (!streaming)
+ 		goto out_nowake;
+
+	if (irq_infos & IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF) {
+		atomic_inc(&isp->sof_count);
+		atomisp_sof_event(isp);
+
+		/* If sequence_temp and sequence are the same
+		 * there where no frames lost so we can increase sequence_temp.
+		 * If not then processing of frame is still in progress and
+		 * driver needs to keep old sequence_temp value.
+		 * NOTE: There is assumption here that ISP will not start
+		 * processing next frame from sensor before old one is
+		 * completely done. */
+		if (atomic_read(&isp->sequence) == atomic_read(
+					&isp->sequence_temp))
+			atomic_set(&isp->sequence_temp,
+					atomic_read(&isp->sof_count));
+		
+		/* signal streamon after delayed init is done */
+		if (isp->delayed_init == ATOMISP_DELAYED_INIT_WORK_DONE) {
+			isp->delayed_init = ATOMISP_DELAYED_INIT_DONE;
+			complete(&isp->init_done);
+		}
+	}
+
+	if (irq_infos & IA_CSS_IRQ_INFO_EVENTS_READY)
+		atomic_set(&isp->sequence,
+				atomic_read(&isp->sequence_temp));
+
+	if ((irq_infos & IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||
+		(irq_infos & IA_CSS_IRQ_INFO_IF_ERROR)) {
+		/* handle mipi receiver error */
+		u32 rx_infos;
+
+		print_csi_rx_errors(isp);
+		ia_css_rx_get_irq_info(&rx_infos);
+		ia_css_rx_clear_irq_info(rx_infos);
+		/* TODO: handle SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN */
+	}
+
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	return IRQ_WAKE_THREAD;
+
+out_nowake:
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Background:
+ * The IUNITPHY register CSI_CONTROL bit definition was changed since PNW C0.
+ * For PNW A0 and B0, CSI4_TERM_EN_COUNT is bit 23:20 (4 bits).
+ * Starting from PWN C0, including all CLV and CLV+ steppings,
+ * CSI4_TERM_EN_COUNT is bit 30:24 (7 bits).
+ *
+ * ------------------------------------------
+ * Silicon	Stepping	PCI revision
+ * Penwell	A0		0x00
+ * Penwell	B0		0x04
+ * Penwell	C0		0x06
+ * Penwell	D0		0x06
+ * Penwell	D1		0x06
+ * Penwell	D2		0x06
+ * Cloverview	A0		0x06
+ * Cloverview	B0		0x05
+ * Cloverview	C0		0x04
+ * Cloverview+	A0		0x08
+ * Cloverview+	B0		0x0C
+ *
+ */
+
+#define TERM_EN_COUNT_1LANE_OFFSET		16	/* bit 22:16 */
+#define TERM_EN_COUNT_1LANE_MASK		0x7f0000
+#define TERM_EN_COUNT_4LANE_OFFSET		24	/* bit 30:24 */
+#define TERM_EN_COUNT_4LANE_MASK		0x7f000000
+#define TERM_EN_COUNT_4LANE_PWN_B0_OFFSET	20	/* bit 23:20 */
+#define TERM_EN_COUNT_4LANE_PWN_B0_MASK		0xf00000
+
+void atomisp_set_term_en_count(struct atomisp_device *isp)
+{
+	uint32_t val;
+	int pwn_b0 = 0;
+
+	/* For MRFLD, there is no Tescape-clock cycles control. */
+	if (IS_MRFLD)
+		return;
+
+	/*if (isp->pdev->device == 0x0148 && isp->pdev->revision < 0x6 &&
+		IS_MRFLD)
+		pwn_b0 = 1;*/
+
+	val = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
+
+	/* set TERM_EN_COUNT_1LANE to 0xf */
+	val &= ~TERM_EN_COUNT_1LANE_MASK;
+	val |= 0xf << TERM_EN_COUNT_1LANE_OFFSET;
+
+	/* set TERM_EN_COUNT_4LANE to 0xf */
+	val &= pwn_b0 ? ~TERM_EN_COUNT_4LANE_PWN_B0_MASK :
+				~TERM_EN_COUNT_4LANE_MASK;
+	val |= 0xf << (pwn_b0 ? TERM_EN_COUNT_4LANE_PWN_B0_OFFSET :
+				TERM_EN_COUNT_4LANE_OFFSET);
+
+	intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL, val);
+}
+
+void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *isp_subdev)
+{
+	memset(isp_subdev->s3a_bufs_in_css, 0, sizeof(isp_subdev->s3a_bufs_in_css));
+	isp_subdev->dis_bufs_in_css = 0;
+	isp_subdev->video_out_capture.buffers_in_css = 0;
+	isp_subdev->video_out_vf.buffers_in_css = 0;
+	isp_subdev->video_out_preview.buffers_in_css = 0;
+}
+
+void atomisp_clear_frame_counters(struct atomisp_sub_device *isp_subdev)
+{
+        isp_subdev->video_out_capture.field_sequence = 0;
+        isp_subdev->video_out_vf.field_sequence = 0;
+        isp_subdev->video_out_preview.field_sequence = 0;
+        isp_subdev->video_out_capture.previous_frame_exp_id = 0;
+        isp_subdev->video_out_vf.previous_frame_exp_id = 0;
+        isp_subdev->video_out_preview.previous_frame_exp_id = 0;
+}
+
+/* return total number of buffers in css */
+static int __buffers_in_css(struct atomisp_sub_device *isp_subdev)
+{
+	int i;
+	int sum = 0;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		sum += isp_subdev->s3a_bufs_in_css[i];
+
+	sum += isp_subdev->dis_bufs_in_css;
+	sum += isp_subdev->video_out_capture.buffers_in_css;
+	sum += isp_subdev->video_out_vf.buffers_in_css;
+	sum += isp_subdev->video_out_preview.buffers_in_css;
+
+	return sum;
+}
+
+bool atomisp_buffers_queued(struct atomisp_sub_device *isp_subdev)
+{
+	return isp_subdev->video_out_capture.buffers_in_css ||
+		isp_subdev->video_out_vf.buffers_in_css ||
+		isp_subdev->video_out_preview.buffers_in_css ?
+		    true : false;
+}
+
+/* 0x100000 is the start of dmem inside SP */
+#define SP_DMEM_BASE	0x100000
+#if 0
+void dump_sp_dmem(unsigned int addr, unsigned int size)
+{
+	unsigned int data = 0;
+	unsigned int size32 = (size + (sizeof(u32) - 1)) / sizeof(u32);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "atomisp_io_base:0x%x\n",(unsigned int)atomisp_io_base);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "%s, addr:0x%x, size: %d, size32: %d\n",
+		 __func__, addr, size, size32);
+	if (size32 * 4 + addr > 0x4000) {
+		v4l2_err(&atomisp_dev,
+			 "illegal size (%d) or addr (0x%x)\n",
+			 size32, addr);
+		return;
+	}
+	addr += SP_DMEM_BASE;
+	do {
+		data = _hrt_master_port_uload_32(addr);
+
+		/* printk/dtrace */
+#if 1
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "%s, \t [0x%x]:0x%x\n",
+			 __func__, addr, data);
+#else
+		atomisp_dtrace(2,"%s, \t [0x%x]:0x%x\n",
+				__func__, addr, data);
+#endif
+		addr += sizeof(unsigned int);
+		size32 -= 1;
+	} while(size32 > 0);
+}
+#endif
+
+static bool is_NTSC_format(struct ia_css_frame *frame)
+{
+	return frame->info.res.height==240?true:false;
+}
+
+static enum v4l2_field get_field_type(struct ia_css_frame *frame)
+{
+	if(frame->frame_nr == 1)
+		return is_NTSC_format(frame)?V4L2_FIELD_BOTTOM:V4L2_FIELD_TOP;
+	else if(frame->frame_nr == 2)
+		return is_NTSC_format(frame)?V4L2_FIELD_TOP:V4L2_FIELD_BOTTOM;
+	return V4L2_FIELD_NONE;
+}
+
+static struct atomisp_vb2 *atomisp_css_frame_to_vb2(
+	struct atomisp_video_pipe *pipe, struct ia_css_frame *frame)
+{
+	struct atomisp_vb2 *buf;
+	int i;
+
+	for (i = 0; pipe->vb2q.bufs[i]; i++) {
+		buf = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		if (buf->cssframe == frame){
+			if (pipe->pix.field ==V4L2_FIELD_ALTERNATE){
+				buf->vb.v4l2_buf.field = get_field_type(frame);
+				if ((buf->vb.v4l2_buf.field == V4L2_FIELD_TOP && !is_NTSC_format(frame)) || (buf->vb.v4l2_buf.field == V4L2_FIELD_BOTTOM && is_NTSC_format(frame))){
+                                                buf->vb.v4l2_buf.sequence = ++pipe->field_sequence;
+				}
+				else if ((buf->vb.v4l2_buf.field == V4L2_FIELD_BOTTOM && !is_NTSC_format(frame)) || (buf->vb.v4l2_buf.field == V4L2_FIELD_TOP && is_NTSC_format(frame))){
+					int exp_id_diff = frame->exp_id - pipe->previous_frame_exp_id - 1;
+					if( exp_id_diff == 0 || exp_id_diff == -EXP_ID_WRAPAROUND)
+						buf->vb.v4l2_buf.sequence = pipe->field_sequence;
+					else
+						buf->vb.v4l2_buf.sequence = pipe->field_sequence + exp_id_diff>0?exp_id_diff:(exp_id_diff + EXP_ID_WRAPAROUND);
+				}
+				pipe->previous_frame_exp_id = frame->exp_id;
+				v4l2_dbg(4, dbg_level, &atomisp_dev, "Buffer sequence = %d, Buffer exp_id = %d, Buffer field = %d\n", buf->vb.v4l2_buf.sequence, frame->exp_id, buf->vb.v4l2_buf.field);
+			}
+			return buf;
+		}
+	}
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA ERROR return NULL from atomisp_css_frame_to_vb2\n");
+	return NULL;
+}
+
+static void get_buf_timestamp(struct timeval *tv)
+{
+	/* This function is duplicated from v4l2_get_timestamp */
+	struct timespec ts;
+	ktime_get_ts(&ts);
+	tv->tv_sec = ts.tv_sec;
+	tv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;
+}
+
+/* Returns queued buffers back to video-core */
+void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *isp_subdev)
+{
+}
+
+
+/* find atomisp_video_pipe with css pipe id, buffer type and atomisp run_mode */
+static struct atomisp_video_pipe *__atomisp_get_pipe(struct atomisp_sub_device *isp_subdev,
+		enum ia_css_pipe_id css_pipe_id,
+		enum ia_css_buffer_type buf_type)
+{
+	/* video is same in online as in continuouscapture mode */
+	if (!isp_subdev->enable_vfpp->val) {
+		return &isp_subdev->video_out_capture;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+			return &isp_subdev->video_out_capture;
+		return &isp_subdev->video_out_preview;
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {
+		if (css_pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			return &isp_subdev->video_out_preview;
+		return &isp_subdev->video_out_capture;
+	/* statistic buffers are needed only in css capture & preview pipes */
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS ||
+		   buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS) {
+		if (css_pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			return &isp_subdev->video_out_preview;
+		return &isp_subdev->video_out_capture;
+	}
+	return &isp_subdev->video_out_vf;
+}
+
+static void atomisp_buf_done(struct atomisp_sub_device *isp_subdev, int error,
+			enum ia_css_buffer_type buf_type,
+			enum ia_css_pipe_id css_pipe_id, bool q_buffers)
+{
+	struct atomisp_vb2 *vb2 = NULL;
+	struct atomisp_video_pipe *pipe = NULL;
+	struct ia_css_buffer buffer;
+	bool requeue = false;
+	int err, pipe_index;
+	struct ia_css_frame *frame = NULL;
+	struct atomisp_device *isp = isp_subdev->isp;
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA ENTER atomisp_buf_done\n");
+
+	if (buf_type != IA_CSS_BUFFER_TYPE_3A_STATISTICS &&
+	    buf_type != IA_CSS_BUFFER_TYPE_DIS_STATISTICS &&
+	    buf_type != IA_CSS_BUFFER_TYPE_OUTPUT_FRAME &&
+	    buf_type != IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&
+	    buf_type != IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
+		v4l2_err(&atomisp_dev,
+			"%s, unsupported buffer type: %d\n",
+			__func__, buf_type);
+		return;
+	}
+
+	memset(&buffer, 0, sizeof(struct ia_css_buffer));
+	buffer.type = buf_type;
+	pipe_index = (unsigned int)css_pipe_id;
+	err = ia_css_pipe_dequeue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer);
+	if (err){
+		v4l2_err(&atomisp_dev,
+			"sh_css_dequeue_buffer failed: 0x%x\n",
+			err);
+		return;
+	}
+
+	/* need to know the atomisp pipe for frame buffers */
+	pipe = __atomisp_get_pipe(isp_subdev, css_pipe_id,
+				  buffer.type);
+	if (pipe == NULL) {
+		dev_err(isp->dev, "error getting atomisp pipe\n");
+		return;
+	}
+
+	switch (buf_type) {
+	case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
+		/* ignore error in case of 3a statistics for now */
+		if (isp->sw_contex.invalid_s3a) {
+			requeue = true;
+			isp->sw_contex.invalid_s3a = 0;
+			break;
+		}
+		/* update the 3A data to ISP context */
+		if (isp_subdev->params.s3a_user_stat &&
+			isp_subdev->params.s3a_output_bytes && !error) {
+			/* To avoid racing with atomisp_3a_stat() */
+			ia_css_get_3a_statistics(isp_subdev->params.s3a_user_stat,
+						 buffer.data.stats_3a);
+			isp_subdev->params.s3a_buf_data_valid = true;
+		}
+		isp_subdev->s3a_bufs_in_css[css_pipe_id]--;
+		atomisp_3a_stats_ready_event(isp_subdev);
+		break;
+	case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
+		/* ignore error in case of dis statistics for now */
+		if (isp->sw_contex.invalid_dis) {
+			requeue = true;
+			isp->sw_contex.invalid_dis = 0;
+			break;
+		}
+		if (isp_subdev->params.dvs_stat && !error) {
+			/* To avoid racing with atomisp_get_dis_stat()*/
+			ia_css_get_dvs_statistics(isp_subdev->params.dvs_stat,
+						  buffer.data.stats_dvs);
+
+			isp_subdev->params.dvs_proj_data_valid = true;
+		}
+		isp_subdev->dis_bufs_in_css--;
+		break;
+	case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
+		if (!buffer.data.frame->valid) {
+			error = true;
+			/*isp->sw_contex.invalid_vf_frame = 0;*/
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "%s css has marked this vf frame as invalid\n",
+				 __func__);
+		}
+
+		pipe->buffers_in_css--;
+		frame = buffer.data.frame;
+		if (isp_subdev->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == IA_CSS_FRAME_FLASH_STATE_PARTIAL)
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb partially flashed\n", __func__);
+			else if (frame->flash_state
+				 == IA_CSS_FRAME_FLASH_STATE_FULL)
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb completely flashed\n", __func__);
+			else
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb no flash in this frame\n", __func__);
+		}
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, about to call atomisp_css_frame_to_vb2\n");
+		vb2 = atomisp_css_frame_to_vb2(pipe, buffer.data.frame);
+		if (!vb2)
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR dequeued frame unknown!");
+		break;
+	case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
+		if (!buffer.data.frame->valid) {
+			error = true;
+			/*isp->sw_contex.invalid_frame = 0;*/
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "%s css has marked this frame as invalid\n",
+				 __func__);
+		}
+		pipe->buffers_in_css--;
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA CSS_BUFFER_TYPE_OUTPUT, buffers_in_css--=%d, about to call atomisp_css_frame_to_vb2\n", pipe->buffers_in_css);
+		vb2 = atomisp_css_frame_to_vb2(pipe, buffer.data.frame);
+		frame = buffer.data.frame;
+		if (!vb2) {
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR dequeued output frame NULL!");
+			break;
+		}
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "setting isp->frame_status to OK\n");	
+		if (isp_subdev->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == IA_CSS_FRAME_FLASH_STATE_PARTIAL) {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_FLASH_PARTIAL;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s partially flashed\n",
+					 __func__);
+			} else if (frame->flash_state
+				   == IA_CSS_FRAME_FLASH_STATE_FULL) {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
+				isp_subdev->params.num_flash_frames--;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s completely flashed\n",
+					 __func__);
+			} else {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_OK;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s no flash in this frame\n",
+					 __func__);
+			}
+
+			/* Check if flashing sequence is done */
+			if (isp_subdev->frame_status[vb2->vb.v4l2_buf.index] == ATOMISP_FRAME_STATUS_FLASH_EXPOSED)
+				isp_subdev->params.flash_state = ATOMISP_FLASH_DONE;
+		} else {
+			isp_subdev->frame_status[vb2->vb.v4l2_buf.index] = ATOMISP_FRAME_STATUS_OK;
+		}
+
+		if (!vb2)
+			v4l2_err(&atomisp_dev, "dequeued frame unknown!");
+		else
+			isp_subdev->params.last_frame_status = isp_subdev->frame_status[vb2->vb.v4l2_buf.index];
+		break;
+	default:
+		break;
+	}
+
+	if (vb2) {
+		get_buf_timestamp(&vb2->vb.v4l2_buf.timestamp);
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA calling vb2_buffer_done, buf index=%d, fd=%d, VB2_BUF_STATE=%d (should be active=3), vaddr=%X, length=%u\n", vb2->vb.v4l2_buf.index,vb2->vb.v4l2_buf.m.fd, vb2->vb.state, vb2->cssframe->data, vb2->cssframe->data_bytes);
+		vb2_buffer_done(&vb2->vb, VB2_BUF_STATE_DONE);	
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA Finished, now VB2_BUF_STATE=%d (should be DONE=4)\n", vb2->vb.state);
+	}	else {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "ERROR atomisp_buf_done vb2 is NULL\n");
+	}
+
+	/*
+	 * Requeue should only be done for 3a and dis buffers.
+	 * Queue/dequeue order will change if driver recycles image buffers.
+	 */
+	if (requeue) {
+		err = ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index], &buffer);
+		if (err)
+			v4l2_err(&atomisp_dev,"%s, q to css fails: %d\n",
+					__func__, err);
+		return;
+	}
+	if (!error && q_buffers){
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA End of atomisp_buf_done, About to call atomisp_qbuffers_to_css\n");
+		atomisp_qbuffers_to_css(isp_subdev, false);
+	}
+}
+
+void atomisp_delayed_init_work(struct work_struct *work)
+{
+	struct atomisp_device *isp = container_of(work,
+						  struct atomisp_device,
+						  delayed_init_work);
+	isp->delayed_init = ATOMISP_DELAYED_INIT_DONE;
+}
+
+void atomisp_wdt_work(struct work_struct *work)
+{
+	struct atomisp_device *isp = container_of(work, struct atomisp_device,
+						  wdt_work);
+	char debug_context[64];
+	enum ia_css_pipe_id css_pipe_id;
+	int ret = 0, i;
+	struct atomisp_sub_device *isp_subdev = NULL;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA WARNING: timer not reset, entering atomisp_wdt_work\n");
+
+	dev_err(isp->dev, "timeout %d of %d\n",
+		atomic_read(&isp->wdt_count) + 1,
+		ATOMISP_ISP_MAX_TIMEOUT_COUNT);
+
+	mutex_lock(&isp->mutex);
+	if (!atomisp_subdev_streaming_count(isp)) {
+		mutex_unlock(&isp->mutex);
+		return;
+	}
+
+	switch (atomic_inc_return(&isp->wdt_count)) {
+	case ATOMISP_ISP_MAX_TIMEOUT_COUNT:
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "atomisp_wdt_work: ATOMISP_ISP_MAX_TIMEOUT_COUNT\n");
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming ==
+			    ATOMISP_DEVICE_STREAMING_ENABLED) {
+				atomisp_clear_css_buffer_counters(isp_subdev);
+				atomisp_flush_bufs_and_wakeup(isp_subdev);
+			}
+		}
+
+		atomic_set(&isp->wdt_count, 0);
+		isp->isp_fatal_error = true;
+		complete(&isp->init_done);
+	
+		break;
+	default:
+		sh_css_dump_sp_sw_debug_info();
+		sh_css_dump_debug_info(debug_context);
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming ==
+		    		ATOMISP_DEVICE_STREAMING_ENABLED) {
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_capture.pipe_type,
+					isp_subdev->video_out_capture.buffers_in_css);
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_vf.pipe_type,
+					isp_subdev->video_out_vf.buffers_in_css);
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_preview.pipe_type,
+					isp_subdev->video_out_preview.buffers_in_css);
+				dev_err(isp->dev, "%s, s3a buffers in css preview pipe: %d\n",
+					__func__,
+					isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_PREVIEW]);
+				dev_err(isp->dev, "%s, s3a buffers in css capture pipe: %d\n",
+					__func__,
+					isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_CAPTURE]);
+				dev_err(isp->dev, "%s, s3a buffers in css video pipe: %d\n",
+					__func__, isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_VIDEO]);
+				dev_err(isp->dev, "%s, dis buffers in css: %d\n",
+					__func__, isp_subdev->dis_bufs_in_css);
+			}
+		}
+		sh_css_dump_sp_state();
+		sh_css_dump_isp_state();
+
+		if (!isp->sw_contex.file_input)
+			ia_css_irq_enable(
+				IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);
+
+		if (isp->delayed_init == ATOMISP_DELAYED_INIT_QUEUED)
+			cancel_work_sync(&isp->delayed_init_work);
+
+		complete(&isp->init_done);
+		isp->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+
+		css_pipe_id = atomisp_get_css_pipe_id(isp_subdev);
+
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming ==
+			    ATOMISP_DEVICE_STREAMING_ENABLED) {
+				isp_subdev->streaming =
+				    ATOMISP_DEVICE_STREAMING_STOPPING;
+
+				if (ia_css_stop(isp_subdev, true))
+					v4l2_warn(&atomisp_dev,
+						  "stop css failed, reset may"
+						  "be failed.\n");
+
+				/* stream off sensor */
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].
+					camera, video, s_stream, 0);
+				if (ret)
+					dev_warn(isp->dev,
+						 "can't stop streaming"
+						 "on sensor!\n");
+
+				atomisp_clear_css_buffer_counters(isp_subdev);
+				isp_subdev->streaming =
+				    ATOMISP_DEVICE_STREAMING_STARTING;
+			}
+		}
+ 
+		atomisp_acc_unload_extensions(isp);
+
+		/* clear irq */
+		/*enable_isp_irq(hrt_isp_css_irq_sp, false);*/
+		/*clear_isp_irq(hrt_isp_css_irq_sp);*/
+
+		/* reset ISP and restore its state */
+		isp->isp_timeout = true;
+		atomisp_reset(isp);
+		isp->isp_timeout = false;
+
+		if (atomisp_acc_load_extensions(isp) < 0)
+			dev_err(isp->dev, "acc extension failed to reload\n");
+
+
+		for( i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming !=
+			    ATOMISP_DEVICE_STREAMING_STARTING)
+					continue;
+
+				ia_css_input_set_mode(isp_subdev,
+				      get_input_mode(isp->inputs[isp_subdev->input_curr].type));
+
+				if (ia_css_start(isp_subdev, true) !=
+				    IA_CSS_SUCCESS)
+					v4l2_warn(&atomisp_dev,
+					  "re-start css failed, reset may be"
+					  "failed.\n");
+				else
+					isp_subdev->streaming =
+					    ATOMISP_DEVICE_STREAMING_ENABLED;
+		}
+
+		if (!isp->sw_contex.file_input) {
+			atomisp_control_irq_sof(isp);
+
+			atomisp_set_term_en_count(isp);
+
+			if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		} else {
+			if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		}
+
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming !=
+			    ATOMISP_DEVICE_STREAMING_ENABLED) 
+					continue;
+
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].
+					camera, video, s_stream, 1);
+				if (ret)
+					dev_warn(isp->dev,
+						 "can't start streaming on"
+						 "sensor!\n");
+				/*
+				 * FIXME!
+				 * only one stream on continous mode now
+				 */
+				if (isp_subdev->params.continuous_vf &&
+				 isp_subdev->run_mode->val !=
+				    ATOMISP_RUN_MODE_VIDEO &&
+				    isp->delayed_init ==
+				    ATOMISP_DELAYED_INIT_NOT_QUEUED) {
+					INIT_COMPLETION(isp->init_done);
+					isp->delayed_init =
+					    ATOMISP_DELAYED_INIT_QUEUED;
+					queue_work(isp->delayed_init_workq,
+						   &isp->delayed_init_work);
+				}
+				/*
+				 * dequeueing buffers is not needed. CSS will
+				 * recycle buffers that it has.
+				 */
+				atomisp_flush_bufs_and_wakeup(isp_subdev);
+			}
+			dev_err(isp->dev, "timeout recovery handling done\n");
+	}
+
+	mutex_unlock(&isp->mutex);
+}
+
+void atomisp_wdt(unsigned long isp_addr)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)isp_addr;
+
+	queue_work(isp->wdt_work_queue, &isp->wdt_work);
+}
+
+void atomisp_setup_flash(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (isp_subdev->params.flash_state != ATOMISP_FLASH_REQUESTED &&
+	    isp_subdev->params.flash_state != ATOMISP_FLASH_DONE)
+		return;
+
+	if (isp_subdev->params.num_flash_frames) {
+		struct v4l2_control ctrl;
+
+		/* make sure the timeout is set before setting flash mode */
+		ctrl.id = V4L2_CID_FLASH_TIMEOUT;
+		ctrl.value = FLASH_TIMEOUT;
+
+		if (v4l2_subdev_call(isp->flash, core, s_ctrl, &ctrl)) {
+			v4l2_err(&atomisp_dev, "flash timeout configure failed\n");
+			return;
+		}
+		ia_css_stream_request_flash(isp_subdev->css2_basis.stream);
+		isp_subdev->params.flash_state = ATOMISP_FLASH_ONGOING;
+	} else {
+		/* Flashing all frames is done */
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+	}
+}
+void atomisp_ISP_parameters_clean_up(struct atomisp_sub_device *isp_subdev,
+				     struct ia_css_isp_config *config)
+{
+	if (config->wb_config) {
+		memset(isp_subdev->params.config.wb_config, 0 ,
+		       sizeof(struct ia_css_wb_config));
+		config->wb_config = NULL;
+	}
+	if (config->cc_config) {
+		memset(isp_subdev->params.config.cc_config, 0 ,
+		       sizeof(struct ia_css_cc_config));
+		config->cc_config = NULL;
+	}
+	if (config->tnr_config) {
+		memset(isp_subdev->params.config.tnr_config, 0 ,
+		       sizeof(struct ia_css_tnr_config));
+		config->tnr_config = NULL;
+	}
+	if (config->ob_config) {
+		memset(isp_subdev->params.config.ob_config, 0 ,
+		       sizeof(struct ia_css_ob_config));
+		config->ob_config = NULL;
+	}
+	if (config->nr_config) {
+		memset(isp_subdev->params.config.nr_config, 0 ,
+		       sizeof(struct ia_css_nr_config));
+		config->nr_config = NULL;
+	}
+	if (config->ee_config) {
+		memset(isp_subdev->params.config.ee_config, 0 ,
+		       sizeof(struct ia_css_ee_config));
+		config->ee_config = NULL;
+	}
+	if (config->de_config) {
+		memset(isp_subdev->params.config.de_config, 0 ,
+		       sizeof(struct ia_css_de_config));
+		config->de_config = NULL;
+	}
+	if (config->gc_config) {
+		memset(isp_subdev->params.config.gc_config, 0 ,
+		       sizeof(struct ia_css_gc_config));
+		config->gc_config = NULL;
+	}
+	if (config->ecd_config) {
+		memset(isp_subdev->params.config.ecd_config, 0 ,
+		       sizeof(struct ia_css_ecd_config));
+		config->ecd_config = NULL;
+	}
+	if (config->ynr_config) {
+		memset(isp_subdev->params.config.ynr_config, 0 ,
+		       sizeof(struct ia_css_ynr_config));
+		config->ynr_config = NULL;
+	}
+	if (config->fc_config) {
+		memset(isp_subdev->params.config.fc_config, 0 ,
+		       sizeof(struct ia_css_fc_config));
+		config->fc_config = NULL;
+	}
+	if (config->cnr_config) {
+		memset(isp_subdev->params.config.cnr_config, 0 ,
+		       sizeof(struct ia_css_cnr_config));
+		config->cnr_config = NULL;
+	}
+	if (config->macc_config) {
+		memset(isp_subdev->params.config.macc_config, 0 ,
+		       sizeof(struct ia_css_macc_config));
+		config->macc_config = NULL;
+	}
+	if (config->ctc_config) {
+		memset(isp_subdev->params.config.ctc_config, 0 ,
+		       sizeof(struct ia_css_ctc_config));
+		config->ctc_config = NULL;
+	}
+	if (config->aa_config) {
+		memset(isp_subdev->params.config.aa_config, 0 ,
+		       sizeof(struct ia_css_aa_config));
+		config->aa_config = NULL;
+	}
+	if (config->ce_config) {
+		memset(isp_subdev->params.config.ce_config, 0 ,
+		       sizeof(struct ia_css_ce_config));
+		config->ce_config = NULL;
+	}
+	if (config->dvs_6axis_config) {
+		config->dvs_6axis_config = NULL;
+	}
+	if (config->yuv2rgb_cc_config) {
+		memset(isp_subdev->params.config.yuv2rgb_cc_config, 0 ,
+		       sizeof(struct ia_css_yuv2rgb_cc_config));
+		config->yuv2rgb_cc_config = NULL;
+	}
+	if (config->rgb2yuv_cc_config) {
+		memset(isp_subdev->params.config.rgb2yuv_cc_config, 0 ,
+		       sizeof(struct ia_css_rgb2yuv_cc_config));
+		config->rgb2yuv_cc_config = NULL;
+	}
+	if (config->anr_config) {
+		memset(isp_subdev->params.config.anr_config, 0 ,
+		       sizeof(struct ia_css_anr_config));
+		config->anr_config = NULL;
+	}
+	if (config->s3a_config) {
+		memset(isp_subdev->params.config.s3a_config, 0 ,
+		       sizeof(struct ia_css_3a_config));
+		config->s3a_config = NULL;
+	}
+	if (config->macc_table) {
+		memset(isp_subdev->params.config.macc_table, 0 ,
+		       sizeof(struct ia_css_macc_table));
+		config->macc_table = NULL;
+	}
+	if (config->gamma_table) {
+		memset(isp_subdev->params.config.gamma_table, 0 ,
+		       sizeof(struct ia_css_gamma_table));
+		config->gamma_table = NULL;
+	}
+	if (config->ctc_table) {
+		memset(isp_subdev->params.config.ctc_table, 0 ,
+		       sizeof(struct ia_css_ctc_table));
+		config->ctc_table = NULL;
+	}
+	if (config->xnr_table) {
+		memset(isp_subdev->params.config.xnr_table, 0 ,
+		       sizeof(struct ia_css_xnr_table));
+		config->xnr_table = NULL;
+	}
+	if (config->r_gamma_table) {
+		memset(isp_subdev->params.config.r_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->r_gamma_table = NULL;
+	}
+	if (config->g_gamma_table) {
+		memset(isp_subdev->params.config.g_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->g_gamma_table = NULL;
+	}
+	if (config->b_gamma_table) {
+		memset(isp_subdev->params.config.b_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->b_gamma_table = NULL;
+	}
+	if (config->dz_config) {
+		memset(isp_subdev->params.config.dz_config, 0 ,
+		       sizeof(struct ia_css_dz_config));
+		config->dz_config = NULL;
+	}
+	if (config->motion_vector) {
+		memset(isp_subdev->params.config.motion_vector, 0 ,
+		       sizeof(struct ia_css_vector));
+		config->motion_vector = NULL;
+	}
+	if (config->shading_table) {
+		ia_css_shading_table_free(config->shading_table);
+		config->shading_table = NULL;
+	}
+	if (config->morph_table) {
+		ia_css_morph_table_free(config->morph_table);
+		config->morph_table = NULL;
+	}
+	if (config->dvs_coefs) {
+		config->dvs_coefs = NULL;
+	}
+}
+//DIFFERENT - EXTRA
+static struct atomisp_sub_device *__get_atomisp_subdev(
+					struct ia_css_pipe *css_pipe,
+					struct atomisp_device *isp) {
+	int i, j;
+	struct atomisp_sub_device *isp_subdev;
+
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming !=
+		    ATOMISP_DEVICE_STREAMING_DISABLED) {
+			for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++)
+				if (isp_subdev->css2_basis.pipes[j] &&
+				    isp_subdev->css2_basis.pipes[j] == css_pipe)
+					return isp_subdev;
+		}
+	}
+
+	return NULL;
+}
+
+irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
+{
+	struct atomisp_device *isp = isp_ptr;
+	struct atomisp_css_event current_event;
+	unsigned long flags;
+	bool frame_done_found[isp->num_of_streams];
+	bool css_pipe_done[isp->num_of_streams];
+	bool reset_wdt_timer = false;
+	struct atomisp_sub_device *isp_subdev;
+	int i, streaming;
+	DEFINE_KFIFO(events, struct atomisp_css_event, ATOMISP_CSS_EVENTS_MAX);
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "ENTER DMA atomisp_isr_thread\n");
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s\n", __func__);
+	memset(frame_done_found, 0, sizeof(frame_done_found));
+	memset(css_pipe_done, 0, sizeof(css_pipe_done));
+	mutex_lock(&isp->mutex);
+
+	spin_lock_irqsave(&isp->lock, flags);
+	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
+		streaming += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+	spin_unlock_irqrestore(&isp->lock, flags);
+	if (!streaming)
+		goto out;
+
+	while (ia_css_dequeue_event(&current_event.event)
+				 == IA_CSS_SUCCESS) {
+		enum  ia_css_pipe_id temp_id;
+		ia_css_temp_pipe_to_pipe_id(current_event.event.pipe, &temp_id);
+		isp_subdev = __get_atomisp_subdev(current_event.event.pipe, isp);
+
+		if (!isp_subdev) {
+			/* EOF Event does not have the css_pipe returned */
+			if (current_event.event.type !=
+			    IA_CSS_EVENT_TYPE_PORT_EOF) {
+				v4l2_err(&atomisp_dev, "%s:no subdev. event:%d",
+					 __func__, current_event.event.type);
+				goto out;
+			}
+		}
+
+		switch (current_event.event.type) {
+		case IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE:
+			v4l2_dbg(6, dbg_level, &atomisp_dev, "IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE, frame_done_found=true, about to call atomisp_buf_done\n");
+			frame_done_found[isp_subdev->index] = true;
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+					 temp_id,
+					 true);
+			reset_wdt_timer = true;
+			break;
+		case IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_3A_STATISTICS,
+					 temp_id,
+					 css_pipe_done[isp_subdev->index]);
+			break;
+		case IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+					 temp_id,
+					 true);
+			reset_wdt_timer = true;
+			break;
+		case IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
+					 temp_id,
+					 css_pipe_done[isp_subdev->index]);
+			break;
+		case IA_CSS_EVENT_TYPE_PIPELINE_DONE:
+			css_pipe_done[isp_subdev->index] = true;
+		case IA_CSS_EVENT_TYPE_PORT_EOF:
+		case IA_CSS_EVENT_TYPE_FRAME_TAGGED:
+			break;
+		default:
+			dev_err(isp->dev, "unhandled css stored event: 0x%x\n",
+					current_event.event.type);
+			break;
+		}
+	}
+
+	/*
+	 * css2.0 bug: no buffer flush mechanism for css buffer queue, but
+	 * need to ensure there is no buffer in css after stream off
+	 *
+	 * before calling ia_css_stream_stop(), we will wait all the buffers are
+	 * dequeued from css, then call ia_css_stream_destroy()
+	 */
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING
+		    && !__buffers_in_css(isp_subdev))
+			complete(&isp_subdev->buf_done);
+	}
+
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
+			if (frame_done_found[isp_subdev->index] &&
+			    isp_subdev->params.css_update_params_needed) {
+				ia_css_stream_set_isp_config(isp_subdev->
+							     css2_basis.stream,&isp_subdev->params.config);
+				atomisp_ISP_parameters_clean_up(isp_subdev, &isp_subdev->params.config);
+				isp_subdev->params.css_update_params_needed = false;
+				frame_done_found[isp_subdev->index] = false;
+			}
+
+			atomisp_setup_flash(isp_subdev);
+			/*
+		 	* If there are no buffers queued
+		 	* then delete wdt timer.
+		 	*/
+			if (!atomisp_buffers_queued(isp_subdev)) {
+				del_timer(&isp->wdt);
+			} else {
+				/* SOF irq should not reset wdt timer. */
+				if (reset_wdt_timer) {
+					mod_timer(&isp->wdt, jiffies +
+					  isp->wdt_duration);
+					atomic_set(&isp->wdt_count, 0);
+				}
+			}
+		}
+	}
+
+out:
+	mutex_unlock(&isp->mutex);
+
+	/* s_stream will be called later outside of this thread */
+	/* Calling s_stream now causes RGB FIFO to fail */
+	if(!isp->sw_contex.file_input){
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
+				&& css_pipe_done[isp_subdev->index]
+				&& isp->sw_contex.file_input)
+				v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].
+						 camera, video, s_stream, 1);
+ 		}
+	}
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * utils for buffer allocation/free
+ */
+
+int atomisp_get_frame_pgnr(const struct ia_css_frame *frame, u32 *p_pgnr)
+{
+	if (!frame) {
+		v4l2_err(&atomisp_dev,
+			    "%s: NULL frame pointer ERROR.\n",
+			    __func__);
+		return -EINVAL;
+	}
+
+	*p_pgnr = DIV_ROUND_UP(frame->data_bytes, PAGE_SIZE);
+	return 0;
+}
+
+/*
+ * Get internal fmt according to V4L2 fmt
+ */
+static enum ia_css_frame_format v4l2_fmt_to_sh_fmt(u32 fmt)
+{
+	switch (fmt) {
+	case V4L2_PIX_FMT_YUV420:
+		return IA_CSS_FRAME_FORMAT_YUV420;
+	case V4L2_PIX_FMT_YVU420:
+		return IA_CSS_FRAME_FORMAT_YV12;
+	case V4L2_PIX_FMT_YUV422P:
+		return IA_CSS_FRAME_FORMAT_YUV422;
+	case V4L2_PIX_FMT_YUV444:
+		return IA_CSS_FRAME_FORMAT_YUV444;
+	case V4L2_PIX_FMT_NV12:
+		return IA_CSS_FRAME_FORMAT_NV12;
+	case V4L2_PIX_FMT_NV21:
+		return IA_CSS_FRAME_FORMAT_NV21;
+	case V4L2_PIX_FMT_NV16:
+		return IA_CSS_FRAME_FORMAT_NV16;
+	case V4L2_PIX_FMT_NV61:
+		return IA_CSS_FRAME_FORMAT_NV61;
+	case V4L2_PIX_FMT_UYVY:
+		return IA_CSS_FRAME_FORMAT_UYVY;
+	case V4L2_PIX_FMT_YUYV:
+		return IA_CSS_FRAME_FORMAT_YUYV;
+	case V4L2_PIX_FMT_RGB24:
+		return IA_CSS_FRAME_FORMAT_RGBA888;
+	case V4L2_PIX_FMT_RGB32:
+		return IA_CSS_FRAME_FORMAT_RGBA888;
+	case V4L2_PIX_FMT_RGB565:
+		return IA_CSS_FRAME_FORMAT_RGB565;
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return IA_CSS_FRAME_FORMAT_RAW;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * raw format match between SH format and V4L2 format
+ */
+static int raw_output_format_match_input(u32 input, u32 output)
+{
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_12) &&
+	    ((output == V4L2_PIX_FMT_SRGGB12) ||
+	     (output == V4L2_PIX_FMT_SGRBG12) ||
+	     (output == V4L2_PIX_FMT_SBGGR12) ||
+	     (output == V4L2_PIX_FMT_SGBRG12)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_10) &&
+	    ((output == V4L2_PIX_FMT_SRGGB10) ||
+	     (output == V4L2_PIX_FMT_SGRBG10) ||
+	     (output == V4L2_PIX_FMT_SBGGR10) ||
+	     (output == V4L2_PIX_FMT_SGBRG10)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_8) &&
+	    ((output == V4L2_PIX_FMT_SRGGB8) ||
+	     (output == V4L2_PIX_FMT_SGRBG8) ||
+	     (output == V4L2_PIX_FMT_SBGGR8) ||
+	     (output == V4L2_PIX_FMT_SGBRG8)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_16) &&
+	    (output == V4L2_PIX_FMT_SBGGR16))
+		return 0;
+
+	return -EINVAL;
+}
+
+static u32 get_pixel_depth(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YVU420:
+		return 12;
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+		return 16;
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_YUV444:
+		return 24;
+	case V4L2_PIX_FMT_RGB32:
+		return 32;
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return 8;
+	default:
+		return 8 * 2;	/* raw type now */
+	}
+}
+
+static int is_pixelformat_raw(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int atomisp_is_mbuscode_raw(uint32_t code)
+{
+	const struct atomisp_format_bridge *b =
+		atomisp_get_format_bridge_from_mbus(code);
+
+	BUG_ON(!b);
+
+	return is_pixelformat_raw(b->pixelformat);
+}
+
+static int get_sh_input_format(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+		return IA_CSS_STREAM_FORMAT_YUV420_8;
+
+	case V4L2_PIX_FMT_YUV422P:
+		return IA_CSS_STREAM_FORMAT_YUV422_8;
+
+	case V4L2_PIX_FMT_RGB565:
+		return IA_CSS_STREAM_FORMAT_RGB_565;
+	case V4L2_PIX_FMT_RGB24:
+		return IA_CSS_STREAM_FORMAT_RGB_888;
+	case V4L2_PIX_FMT_BGR666:
+		return IA_CSS_STREAM_FORMAT_RGB_666;
+
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return IA_CSS_STREAM_FORMAT_RAW_8;
+
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+		return IA_CSS_STREAM_FORMAT_RAW_10;
+
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+		return IA_CSS_STREAM_FORMAT_RAW_12;
+
+	case V4L2_PIX_FMT_SBGGR16:
+		return IA_CSS_STREAM_FORMAT_RAW_16;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * ISP features control function
+ */
+
+/*
+ * Set ISP capture mode based on current settings
+ */
+static void atomisp_update_capture_mode(struct atomisp_sub_device *isp_subdev)
+{
+	struct ia_css_isp_config isp_config;
+	enum ia_css_capture_mode capture_mode;
+
+	if (!isp_subdev->css2_basis.stream) {
+		v4l2_err(&atomisp_dev,
+			 "%s called after streamoff, skipping.\n",
+			 __func__);
+		return;
+	}
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	isp_config.capture_config = &isp_subdev->params.capture_config;
+	ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+	if (isp_subdev->params.low_light)
+		capture_mode = IA_CSS_CAPTURE_MODE_LOW_LIGHT;
+	else if (isp_subdev->params.gdc_cac_en)
+		capture_mode = IA_CSS_CAPTURE_MODE_ADVANCED;
+	else
+		capture_mode = IA_CSS_CAPTURE_MODE_PRIMARY;
+	if (capture_mode != isp_subdev->params.capture_config.mode) {
+		isp_subdev->params.capture_config.mode = capture_mode;
+		isp_subdev->params.config.capture_config = &isp_subdev->params.capture_config;
+	}
+}
+
+/*
+ * Function to enable/disable lens geometry distortion correction (GDC) and
+ * chromatic aberration correction (CAC)
+ */
+int atomisp_gdc_cac(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	if (flag == 0) {
+		*value = isp_subdev->params.gdc_cac_en;
+		return 0;
+	}
+
+	isp_subdev->params.gdc_cac_en = !!*value;
+	if (isp_subdev->params.gdc_cac_en) {
+		isp_subdev->params.config.morph_table = isp->inputs[isp_subdev->input_curr].morph_table;
+		isp_subdev->params.css_update_params_needed = true;
+		atomisp_update_capture_mode(isp_subdev);
+	}
+	return 0;
+}
+
+/*
+ * Function to enable/disable low light mode including ANR
+ */
+int atomisp_low_light(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	if (flag == 0) {
+		*value = isp_subdev->params.low_light;
+		return 0;
+	}
+
+	isp_subdev->params.low_light = (*value != 0);
+	atomisp_update_capture_mode(isp_subdev);
+	return 0;
+}
+
+/*
+ * Function to enable/disable extra noise reduction (XNR) in low light
+ * condition
+ */
+int atomisp_xnr(struct atomisp_sub_device *isp_subdev, int flag, int *xnr_enable)
+{
+	struct ia_css_isp_config isp_config;
+	if (!xnr_enable)
+		return 0;
+
+	if (flag == 0) {
+		*xnr_enable = isp_subdev->params.xnr_en;
+		return 0;
+	}
+
+	if (!isp_subdev->css2_basis.stream) {
+		v4l2_err(&atomisp_dev,
+			 "%s called after streamoff, skipping.\n",
+			 __func__);
+		return -EINVAL;
+	}
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	isp_config.capture_config = &isp_subdev->params.capture_config;
+	ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+	if (isp_subdev->params.capture_config.enable_xnr != !!*xnr_enable)
+		isp_subdev->params.capture_config.enable_xnr = !!*xnr_enable;
+
+	return 0;
+}
+
+/*
+ * Function to configure bayer noise reduction
+ */
+int atomisp_nr(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_nr_config *arg)
+{
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (sizeof(*arg) != sizeof(isp_subdev->params.config.nr_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_nr_config nr_config;
+		struct ia_css_isp_config isp_config;
+
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&nr_config, 0, sizeof(struct ia_css_nr_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+
+		/* Get nr config from current setup */
+		isp_config.nr_config = &nr_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(arg, &nr_config, sizeof(*arg));
+	} else {
+		/* Set nr config to isp parameters */
+		if (!isp_subdev->params.config.nr_config)
+			isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+		memcpy(isp_subdev->params.config.nr_config, arg,
+			sizeof(struct ia_css_nr_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+	return 0;
+}
+
+/*
+ * Function to configure temporal noise reduction (TNR)
+ */
+int atomisp_tnr(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_tnr_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.tnr_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+
+	/* Get tnr config from current setup */
+	if (flag == 0) {
+		struct ia_css_tnr_config tnr_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tnr_config, 0, sizeof(struct ia_css_tnr_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.tnr_config = &tnr_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+		/* Get tnr config from current setup */
+		memcpy(config, &isp_config.tnr_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.tnr_config)
+			isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+		/* Set tnr config to isp parameters */
+		memcpy(isp_subdev->params.config.tnr_config, config,
+			sizeof(struct ia_css_tnr_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to get histogram data for image frame
+ */
+int atomisp_histogram(struct atomisp_sub_device *isp_subdev, int flag, void *config)
+{
+#if defined(CONFIG_CSS_ONE)
+	struct atomisp_histogram *arg = (struct atomisp_histogram *)config;
+	struct ia_css_histogram *histogram;
+	int ret = 0;
+	unsigned int *buffer;
+
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (sizeof(*arg) != sizeof(*histogram)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		buffer = kzalloc(2048 * sizeof(unsigned int), GFP_KERNEL);
+		if (buffer == NULL) {
+			v4l2_err(&atomisp_dev,
+					"buffer allocate error\n");
+			return -ENOMEM;
+		}
+
+		ret = ia_css_histogram_allocate(2048, &histogram);
+		if (ret != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+					"ia_css_histogram_allocate failed\n");
+			goto buffer_free;
+		}
+
+		if (isp->vf_frame == NULL) {
+			v4l2_err(&atomisp_dev,
+					"No frame for histogram\n");
+			ret = -EINVAL;
+			goto histogram_free;
+		}
+
+		ret = ia_css_histogram_start(isp_subdev->vf_frame, histogram);
+		if (ret != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+					"ia_css_get_y_histogram failed\n");
+			goto histogram_free;
+		}
+		ia_css_wait_for_completion();
+
+		ret = hmm_load(histogram->data, buffer,
+			histogram->num_elements * sizeof(unsigned int));
+		if (ret) {
+			v4l2_err(&atomisp_dev, "hmm_load failed\n");
+			goto histogram_free;
+		}
+
+		ret = copy_to_user(arg->data, buffer,
+			histogram->num_elements * sizeof(unsigned int));
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+					"copy to user failed\n");
+			ret = -EFAULT;
+			goto histogram_free;
+		}
+
+		ret = 0;
+		arg->num_elements = histogram->num_elements;
+
+histogram_free:
+		ia_css_histogram_free(histogram);
+buffer_free:
+		kfree(buffer);
+
+		return ret;
+	}
+
+	isp_subdev->params.config.histogram_elenum = arg->num_elements;
+#endif
+	return 0;
+}
+
+/*
+ * Function to configure black level compensation
+ */
+int atomisp_black_level(struct atomisp_sub_device *isp_subdev, int flag,
+			struct atomisp_ob_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ob_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ob_config ob_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&ob_config, 0, sizeof(struct ia_css_ob_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.ob_config = &ob_config;
+		/* Get ob config from current setup */
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &ob_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ob_config)
+			isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+		/* Set ob config to isp parameters */
+		memcpy(isp_subdev->params.config.ob_config, config,
+			sizeof(struct ia_css_ob_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to configure edge enhancement
+ */
+int atomisp_ee(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_ee_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ee_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ee_config ee_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&ee_config, 0, sizeof(struct ia_css_ee_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get ee config from current setup */
+		isp_config.ee_config = &ee_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &ee_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ee_config)
+			isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+		/* Set ee config to isp parameters */
+		memcpy(isp_subdev->params.config.ee_config, config,
+		       sizeof(isp_subdev->params.config.ee_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update Gamma table for gamma, brightness and contrast config
+ */
+int atomisp_gamma(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_gamma_table *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.gamma_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_gamma_table tab;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tab, 0, sizeof(struct ia_css_gamma_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get gamma table from current setup */
+		isp_config.gamma_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &tab, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.gamma_table)
+			isp_subdev->params.config.gamma_table = &isp_subdev->params.gamma_table;
+		/* Set gamma table to isp parameters */
+		memcpy(isp_subdev->params.config.gamma_table, config,
+		       sizeof(isp_subdev->params.config.gamma_table));
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update Ctc table for Chroma Enhancement
+ */
+int atomisp_ctc(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_ctc_table *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ctc_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ctc_table tab;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tab, 0, sizeof(struct ia_css_ctc_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get ctc table from current setup */
+		isp_config.ctc_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &tab, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ctc_table)
+			isp_subdev->params.config.ctc_table = &isp_subdev->params.ctc_table;
+		/* Set ctc table to isp parameters */
+		memcpy(isp_subdev->params.config.ctc_table, config,
+			sizeof(isp_subdev->params.config.ctc_table));
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update gamma correction parameters
+ */
+int atomisp_gamma_correction(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_gc_config *config)
+{
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.gc_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_gc_config gc_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&gc_config, 0, sizeof(struct ia_css_gc_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.gc_config = &gc_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get gamma correction params from current setup */
+		memcpy(config, &gc_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.gc_config)
+			isp_subdev->params.config.gc_config = &isp_subdev->params.gc_config;
+		/* Set gamma correction params to isp parameters */
+		memcpy(isp_subdev->params.config.gc_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+void atomisp_free_internal_buffers(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct ia_css_morph_table *tab;
+
+	tab = isp->inputs[isp_subdev->input_curr].morph_table;
+	if (tab) {
+		ia_css_morph_table_free(tab);
+		isp->inputs[isp_subdev->input_curr].morph_table = NULL;
+	}
+
+	if (isp_subdev->raw_output_frame) {
+		ia_css_frame_free(isp_subdev->raw_output_frame);
+		isp_subdev->raw_output_frame = NULL;
+	}
+}
+
+void atomisp_free_3a_dvs_buffers(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_s3a_buf *s3a_buf, *_s3a_buf;
+	struct atomisp_dvs_buf *dvs_buf, *_dvs_buf;
+
+	/* 3A statistics use vmalloc, DIS use kmalloc */
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+		ia_css_dvs_coefficients_free(isp_subdev->params.dvs_coeff);
+		ia_css_dvs_statistics_free(isp_subdev->params.dvs_stat);
+		isp_subdev->params.dvs_coeff = NULL;
+		isp_subdev->params.dvs_stat = NULL;
+		isp_subdev->params.dvs_hor_proj_bytes = 0;
+		isp_subdev->params.dvs_ver_proj_bytes = 0;
+		isp_subdev->params.dvs_hor_coef_bytes = 0;
+		isp_subdev->params.dvs_ver_coef_bytes = 0;
+		isp_subdev->params.dvs_proj_data_valid = false;
+		list_for_each_entry_safe(dvs_buf, _dvs_buf,
+					 &isp_subdev->dvs_stats, list) {
+			ia_css_isp_dvs_statistics_free(dvs_buf->dvs_stat);
+			list_del(&dvs_buf->list);
+			kfree(dvs_buf);
+		}
+	}
+	if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+		ia_css_3a_statistics_free(isp_subdev->params.s3a_user_stat);
+		isp_subdev->params.s3a_user_stat = NULL;
+		isp_subdev->params.s3a_buf_data_valid = false;
+		isp_subdev->params.s3a_output_bytes = 0;
+		list_for_each_entry_safe(s3a_buf, _s3a_buf,
+					 &isp_subdev->s3a_stats, list) {
+			ia_css_isp_3a_statistics_free(s3a_buf->s3a_stat);
+			list_del(&s3a_buf->list);
+			kfree(s3a_buf);
+		}
+	}
+}
+
+static void atomisp_update_grid_info(struct atomisp_sub_device *isp_subdev)
+{
+	int err;
+	struct ia_css_pipe_info p_info;
+	struct ia_css_grid_info old_info;
+
+	memset(&p_info, 0, sizeof(struct ia_css_pipe_info));
+	memset(&old_info, 0, sizeof(struct ia_css_grid_info));
+	ia_css_pipe_get_info(isp_subdev->css2_basis.pipes[isp_subdev->css2_basis.curr_pipe],
+			     &p_info);
+	memcpy(&old_info,&isp_subdev->params.curr_grid_info,sizeof(struct ia_css_grid_info));
+	memcpy(&isp_subdev->params.curr_grid_info, &p_info.grid_info,
+	       		sizeof(struct ia_css_grid_info));
+
+	/* If the grid info has not changed and the buffers for 3A and
+	 * DIS statistics buffers are allocated or buffer size would be zero
+	 * then no need to do anything. */
+	if ((!memcmp(&old_info, &isp_subdev->params.curr_grid_info,
+		     sizeof(old_info)) &&
+	    isp_subdev->params.s3a_user_stat && isp_subdev->params.dvs_stat) ||
+		isp_subdev->params.curr_grid_info.s3a_grid.width == 0 ||
+		isp_subdev->params.curr_grid_info.s3a_grid.height == 0)
+		return;
+
+	/* We must free all buffers because they no longer match
+	   the grid size. */
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "grid info changed. re-allocate status buffer.\n");
+	err = atomisp_alloc_css_stat_bufs(isp_subdev);
+	if (err) {
+		v4l2_err(&atomisp_dev,
+			 "stat_buf allocate error\n");
+		goto err_3a;
+	}
+
+	isp_subdev->params.s3a_user_stat =
+	    ia_css_3a_statistics_allocate(&isp_subdev->params.curr_grid_info.s3a_grid);
+	if (!isp_subdev->params.s3a_user_stat)
+		goto err_3a;
+
+	/* 3A statistics. These can be big, so we use vmalloc. */
+	isp_subdev->params.s3a_output_bytes =
+	    isp_subdev->params.curr_grid_info.s3a_grid.width *
+	    isp_subdev->params.curr_grid_info.s3a_grid.height *
+	    sizeof(*isp_subdev->params.s3a_user_stat->data);
+
+	isp_subdev->params.s3a_buf_data_valid = false;
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+		/* DIS coefficients. */
+		isp_subdev->params.dvs_coeff =
+		    ia_css_dvs_coefficients_allocate(
+				&isp_subdev->params.curr_grid_info.dvs_grid);
+		if (!isp_subdev->params.dvs_coeff)
+			goto err_dvs;
+
+		isp_subdev->params.dvs_hor_coef_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.num_hor_coefs*
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_coeff->hor_coefs);
+
+		isp_subdev->params.dvs_ver_coef_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.num_ver_coefs *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_coeff->ver_coefs);
+
+		/* DIS projections. */
+		isp_subdev->params.dvs_proj_data_valid = false;
+		isp_subdev->params.dvs_stat = ia_css_dvs_statistics_allocate(&isp_subdev->params.curr_grid_info.dvs_grid);
+		if (!isp_subdev->params.dvs_stat)
+			goto err_dvs;
+		isp_subdev->params.dvs_hor_proj_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.aligned_height *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_stat->hor_proj);
+
+		isp_subdev->params.dvs_ver_proj_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.aligned_width *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_stat->ver_proj);
+	}
+	return;
+
+	/* Failure for 3A buffers does not influence DIS buffers */
+err_3a:
+	if (isp_subdev->params.s3a_output_bytes != 0) {
+		/* For SOC sensor happens s3a_output_bytes == 0,
+		 *  using if condition to exclude false error log */
+		v4l2_err(&atomisp_dev, "Failed allocate memory for 3A statistics\n");
+	}
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+	return;
+
+err_dvs:
+	v4l2_err(&atomisp_dev, "Failed allocate memory for DIS statistics\n");
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+}
+
+static void atomisp_curr_user_grid_info(struct atomisp_sub_device *isp_subdev,
+				    struct atomisp_grid_info *info)
+{
+#ifndef ATOMISP_CSS2
+	info->isp_in_width          =
+	    isp_subdev->params.curr_grid_info.isp_in_width;
+	info->isp_in_height         =
+	    isp_subdev->params.curr_grid_info.isp_in_height;
+	info->s3a_width             =
+	    isp_subdev->params.curr_grid_info.s3a_grid.width;
+	info->s3a_height            =
+		isp_subdev->params.curr_grid_info.s3a_grid.height;
+	info->s3a_bqs_per_grid_cell =
+		isp_subdev->params.curr_grid_info.s3a_grid.bqs_per_grid_cell;
+
+	info->dis_width          =
+	    isp_subdev->params.curr_grid_info.dvs_grid.width;
+	info->dis_aligned_width  =
+		isp_subdev->params.curr_grid_info.dvs_grid.aligned_width;
+	info->dis_height         =
+	    isp_subdev->params.curr_grid_info.dvs_grid.height;
+	info->dis_aligned_height =
+		isp_subdev->params.curr_grid_info.dvs_grid.aligned_height;
+	info->dis_bqs_per_grid_cell =
+		isp_subdev->params.curr_grid_info.dvs_grid.bqs_per_grid_cell;
+	info->dis_hor_coef_num      =
+		isp_subdev->params.curr_grid_info.dvs_grid.num_hor_coefs;
+	info->dis_ver_coef_num      =
+		isp_subdev->params.curr_grid_info.dvs_grid.num_ver_coefs;
+#else
+	memcpy(info, &isp_subdev->params.curr_grid_info.s3a_grid,
+	       sizeof(struct ia_css_3a_grid_info));
+
+#endif
+}
+
+static int atomisp_compare_grid(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_grid_info *atomgrid)
+{
+	struct atomisp_grid_info tmp = {0};
+
+	atomisp_curr_user_grid_info(isp_subdev, &tmp);
+	return memcmp(atomgrid, &tmp, sizeof(tmp));
+}
+
+/*
+ * Function to update Gdc table for gdc
+ */
+int atomisp_gdc_cac_table(struct atomisp_sub_device *isp_subdev, int flag,
+			  struct atomisp_morph_table *config)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	int ret;
+	int i;
+
+	if (flag == 0) {
+		struct ia_css_morph_table tab;
+		struct ia_css_isp_config isp_config;
+		memset(&tab, 0, sizeof(struct ia_css_morph_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		/* Get gdc table from current setup */
+		isp_subdev->params.config.morph_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_subdev->params.config);
+
+		config->width = tab.width;
+		config->height = tab.height;
+
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			ret = copy_to_user(config->coordinates_x[i],
+				tab.coordinates_x[i], tab.height *
+				tab.width * sizeof(*tab.coordinates_x[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"Failed to copy to User for x\n");
+				return -EFAULT;
+			}
+			ret = copy_to_user(config->coordinates_y[i],
+				tab.coordinates_y[i], tab.height *
+				tab.width * sizeof(*tab.coordinates_y[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"Failed to copy to User for y\n");
+				return -EFAULT;
+			}
+		}
+	} else {
+		struct ia_css_morph_table *table =
+			isp->inputs[isp_subdev->input_curr].morph_table;
+
+		/* free first if we have one */
+		if (table) {
+			ia_css_morph_table_free(table);
+			isp->inputs[isp_subdev->input_curr].morph_table = NULL;
+		}
+
+		/* allocate new one */
+		table = ia_css_morph_table_allocate(config->width,
+						  config->height);
+
+		if (!table) {
+			v4l2_err(&atomisp_dev, "out of memory\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			ret = copy_from_user(table->coordinates_x[i],
+				config->coordinates_x[i],
+				config->height * config->width *
+				sizeof(*config->coordinates_x[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+				"Failed to copy from User for x, ret %d\n",
+				ret);
+				ia_css_morph_table_free(table);
+				return -EFAULT;
+			}
+			ret = copy_from_user(table->coordinates_y[i],
+				config->coordinates_y[i],
+				config->height * config->width *
+				sizeof(*config->coordinates_y[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+				"Failed to copy from User for y, ret is %d\n",
+				ret);
+				ia_css_morph_table_free(table);
+				return -EFAULT;
+			}
+		}
+		isp->inputs[isp_subdev->input_curr].morph_table = table;
+		if (isp_subdev->params.gdc_cac_en)
+			isp_subdev->params.config.morph_table = table;
+	}
+
+	return 0;
+}
+
+int atomisp_macc_table(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_macc_config *config)
+{
+	struct ia_css_macc_table *macc_table;
+	struct ia_css_macc_table tmp_macc_table;
+	struct ia_css_isp_config isp_config;
+
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(config->table) != sizeof(*macc_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+	memset(&tmp_macc_table, 0, sizeof(struct ia_css_macc_table));
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	switch (config->color_effect) {
+	case V4L2_COLORFX_NONE:
+		macc_table = NULL;
+		return 0;
+	case V4L2_COLORFX_SKY_BLUE:
+		macc_table = &blue_macc_table;
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		macc_table = &green_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_LOW:
+		macc_table = &skin_low_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		macc_table = &skin_medium_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
+		macc_table = &skin_high_macc_table;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		/* Get macc table from current setup */
+		memcpy(&config->table, macc_table,
+		       sizeof(struct ia_css_macc_table));
+	} else {
+		memcpy(macc_table, &config->table,
+		       sizeof(struct ia_css_macc_table));
+		if (config->color_effect == isp_subdev->params.color_effect)
+			isp_subdev->params.config.macc_table = macc_table;
+	}
+
+	return 0;
+}
+
+int atomisp_set_dis_vector(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_dis_vector *vector)
+{
+	if (!isp_subdev->params.config.motion_vector)
+		isp_subdev->params.config.motion_vector =
+			&isp_subdev->params.motion_vector;
+
+	memset(isp_subdev->params.config.motion_vector,
+	       		0, sizeof(struct ia_css_vector));
+	isp_subdev->params.motion_vector.x = vector->x;
+	isp_subdev->params.motion_vector.y = vector->y;
+
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp_subdev->params.css_update_params_needed = true;
+	return 0;
+}
+
+/*
+ * Function to set/get image stablization statistics
+ */
+int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_dis_statistics *stats)
+{
+	unsigned long flags;
+	int error;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (stats->vertical_projections   == NULL ||
+	    stats->horizontal_projections == NULL ||
+	    isp_subdev->params.dvs_stat->hor_proj == NULL ||
+	    isp_subdev->params.dvs_stat->ver_proj == NULL)
+		return -EINVAL;
+
+	/* isp needs to be streaming to get DIS statistics */
+	spin_lock_irqsave(&isp->lock, flags);
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
+		spin_unlock_irqrestore(&isp->lock, flags);
+		return -EINVAL;
+	}
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (!isp_subdev->params.video_dis_en)
+		return -EINVAL;
+
+	if (atomisp_compare_grid(isp_subdev, &stats->grid_info) != 0)
+		/* If the grid info in the argument differs from the current
+		   grid info, we tell the caller to reset the grid size and
+		   try again. */
+		return -EAGAIN;
+
+	if (!isp_subdev->params.dvs_proj_data_valid)
+		return -EBUSY;
+
+	error = copy_to_user(stats->vertical_projections,
+			     isp_subdev->params.dvs_stat->ver_proj,
+			     isp_subdev->params.dvs_ver_proj_bytes);
+
+	error |= copy_to_user(stats->horizontal_projections,
+			     isp_subdev->params.dvs_stat->hor_proj,
+			     isp_subdev->params.dvs_hor_proj_bytes);
+
+	if (error)
+		return -EFAULT;
+
+	return 0;
+}
+
+int atomisp_set_dis_coefs(struct atomisp_sub_device *isp_subdev,
+			  struct atomisp_dis_coefficients *coefs)
+{
+	int error;
+
+	if (coefs->horizontal_coefficients == NULL ||
+	    coefs->vertical_coefficients   == NULL ||
+	    isp_subdev->params.dvs_coeff->hor_coefs == NULL ||
+	    isp_subdev->params.dvs_coeff->ver_coefs == NULL)
+		return -EINVAL;
+
+	error = copy_from_user(isp_subdev->params.dvs_coeff->hor_coefs,
+			       coefs->horizontal_coefficients,
+			       isp_subdev->params.dvs_hor_coef_bytes);
+	if (error)
+		return -EFAULT;
+	error = copy_from_user(isp_subdev->params.dvs_coeff->ver_coefs,
+			       coefs->vertical_coefficients,
+			       isp_subdev->params.dvs_ver_coef_bytes);
+	if (error)
+		return -EFAULT;
+	isp_subdev->params.config.dvs_coefs = isp_subdev->params.dvs_coeff;
+	isp_subdev->params.dvs_proj_data_valid = false;
+
+	return 0;
+}
+
+/*
+ * Function to set/get 3A stat from isp
+ */
+int atomisp_3a_stat(struct atomisp_sub_device *isp_subdev, int flag,
+		    struct atomisp_3a_statistics *config)
+{
+	unsigned long ret;
+
+	if (flag != 0)
+		return -EINVAL;
+
+	/* sanity check to avoid writing into unallocated memory. */
+	if (isp_subdev->params.s3a_output_bytes == 0)
+		return -EINVAL;
+
+	if (atomisp_compare_grid(isp_subdev, &config->grid_info) != 0) {
+		/* If the grid info in the argument differs from the current
+		   grid info, we tell the caller to reset the grid size and
+		   try again. */
+		return -EAGAIN;
+	}
+
+	/* This is done in the atomisp_s3a_buf_done() */
+	if(!isp_subdev->params.s3a_buf_data_valid) {
+		v4l2_err(&atomisp_dev, "3a statistics is not valid.\n");
+		return -EAGAIN;
+	}
+
+	ret = copy_to_user(config->data,
+			   isp_subdev->params.s3a_user_stat->data,
+			   isp_subdev->params.s3a_output_bytes);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "copy to user failed: copied %lu bytes\n", ret);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int __atomisp_set_general_isp_parameters(struct atomisp_sub_device *isp_subdev,
+					struct atomisp_parameters *arg)
+{
+	if (arg->wb_config) {
+		if (!isp_subdev->params.config.wb_config)
+			isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+		memset(isp_subdev->params.config.wb_config, 0 , sizeof(struct ia_css_wb_config));
+		if (copy_from_user(isp_subdev->params.config.wb_config, arg->wb_config,
+				   sizeof(struct ia_css_wb_config))) {
+			isp_subdev->params.config.wb_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ob_config) {
+		if (!isp_subdev->params.config.ob_config)
+			isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+		memset(isp_subdev->params.config.ob_config, 0 , sizeof(struct ia_css_ob_config));
+		if (copy_from_user(isp_subdev->params.config.ob_config, arg->ob_config,
+				   sizeof(struct ia_css_ob_config))) {
+			isp_subdev->params.config.ob_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->dp_config) {
+		if (!isp_subdev->params.config.dp_config)
+			isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+		memset(isp_subdev->params.config.dp_config, 0 , sizeof(struct ia_css_dp_config));
+		if (copy_from_user(isp_subdev->params.config.dp_config, arg->dp_config,
+				   sizeof(struct ia_css_dp_config))) {
+			isp_subdev->params.config.dp_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->de_config) {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		memset(isp_subdev->params.config.de_config, 0 , sizeof(struct ia_css_de_config));
+		if (copy_from_user(isp_subdev->params.config.de_config, arg->de_config,
+				   sizeof(struct ia_css_de_config))) {
+			isp_subdev->params.config.de_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ce_config) {
+		if (!isp_subdev->params.config.ce_config)
+			isp_subdev->params.config.ce_config = &isp_subdev->params.ce_config;
+		memset(isp_subdev->params.config.ce_config, 0 , sizeof(struct ia_css_ce_config));
+		if (copy_from_user(isp_subdev->params.config.ce_config, arg->ce_config,
+				   sizeof(struct ia_css_ce_config))) {
+			isp_subdev->params.config.ce_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->nr_config) {
+		if (!isp_subdev->params.config.nr_config)
+			isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+		memset(isp_subdev->params.config.nr_config, 0 , sizeof(struct ia_css_nr_config));
+		if (copy_from_user(isp_subdev->params.config.nr_config, arg->nr_config,
+				   sizeof(struct ia_css_nr_config))) {
+			isp_subdev->params.config.nr_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ee_config) {
+		if (!isp_subdev->params.config.ee_config)
+			isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+		memset(isp_subdev->params.config.ee_config, 0 , sizeof(struct ia_css_ee_config));
+		if (copy_from_user(isp_subdev->params.config.ee_config, arg->ee_config,
+				   sizeof(struct ia_css_ee_config))) {
+			isp_subdev->params.config.ee_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->tnr_config) {
+		if (!isp_subdev->params.config.tnr_config)
+			isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+		memset(isp_subdev->params.config.tnr_config, 0 , sizeof(struct ia_css_tnr_config));
+		if (copy_from_user(isp_subdev->params.config.tnr_config, arg->tnr_config,
+				   sizeof(struct ia_css_tnr_config))) {
+			isp_subdev->params.config.tnr_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->cc_config) {
+		if (!isp_subdev->params.config.cc_config)
+				isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+		memset(isp_subdev->params.config.cc_config, 0 , sizeof(struct ia_css_cc_config));
+		if (copy_from_user(isp_subdev->params.config.cc_config, arg->cc_config, sizeof(struct ia_css_cc_config))) {
+			isp_subdev->params.config.cc_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->macc_config) {
+		if (!isp_subdev->params.config.macc_table)
+				isp_subdev->params.config.macc_table = &isp_subdev->params.macc_table;
+		memset(isp_subdev->params.config.macc_table, 0 , sizeof(struct ia_css_macc_table));
+		if (copy_from_user(isp_subdev->params.config.macc_table,
+				   &arg->macc_config->table,
+				   sizeof(struct ia_css_macc_table))) {
+			isp_subdev->params.config.macc_table = NULL;
+			return -EFAULT;
+		}
+		isp_subdev->params.color_effect = arg->macc_config->color_effect;
+	}
+
+	if (arg->gc_config) {
+		if (!isp_subdev->params.config.gc_config)
+			isp_subdev->params.config.gc_config = &isp_subdev->params.gc_config;
+		memset(isp_subdev->params.config.gc_config, 0 , sizeof(struct ia_css_gc_config));
+		if (copy_from_user(isp_subdev->params.config.gc_config, arg->gc_config,
+				   sizeof(*arg->gc_config))) {
+			isp_subdev->params.config.gc_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->a3a_config) {
+		if (!isp_subdev->params.config.s3a_config)
+			isp_subdev->params.config.s3a_config = &isp_subdev->params.s3a_config;
+		memset(isp_subdev->params.config.s3a_config, 0 , sizeof(struct ia_css_3a_config));
+		if (copy_from_user(isp_subdev->params.config.s3a_config, arg->a3a_config,
+				   sizeof(*arg->a3a_config))) {
+			isp_subdev->params.config.s3a_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE
+	    && isp_subdev->params.css_update_params_needed) {
+		ia_css_stream_set_isp_config(isp_subdev->css2_basis.stream, &isp_subdev->params.config);
+		atomisp_ISP_parameters_clean_up(isp_subdev, &isp_subdev->params.config);
+		isp_subdev->params.css_update_params_needed = false;
+	}
+
+	return 0;
+}
+
+static int __atomisp_set_lsc_table(struct atomisp_sub_device *isp_subdev,
+			struct atomisp_shading_table *user_st)
+{
+	unsigned int i;
+	unsigned int len_table;
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_shading_table *old_shading_table;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (!user_st)
+		return 0;
+
+	old_shading_table = isp->inputs[isp_subdev->input_curr].shading_table;
+
+	/* user config is to disable the shading table. */
+	if (!user_st->enable) {
+		shading_table = NULL;
+		goto set_lsc;
+	}
+
+	/* Setting a new table. Validate first - all tables must be set */
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (!user_st->data[i])
+			return -EINVAL;
+	}
+
+	/* Shading table size per color */
+	if (user_st->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
+		user_st->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
+		return -EINVAL;
+
+	shading_table = ia_css_shading_table_alloc(user_st->width,
+			user_st->height);
+	if (!shading_table)
+			return -ENOMEM;
+
+	len_table = user_st->width * user_st->height * ATOMISP_SC_TYPE_SIZE;
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (copy_from_user(shading_table->data[i],
+			user_st->data[i], len_table)) {
+			ia_css_shading_table_free(shading_table);
+			return -EFAULT;
+		}
+
+	}
+	shading_table->sensor_width = user_st->sensor_width;
+	shading_table->sensor_height = user_st->sensor_height;
+	shading_table->fraction_bits = user_st->fraction_bits;
+
+set_lsc:
+	/* set LSC to CSS */
+	isp->inputs[isp_subdev->input_curr].shading_table = shading_table;
+	isp_subdev->params.config.shading_table = shading_table;
+	isp_subdev->params.sc_en = shading_table != NULL;
+
+	if (old_shading_table)
+		ia_css_shading_table_free(old_shading_table);
+
+	return 0;
+}
+
+static int __atomisp_set_morph_table(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_morph_table *user_morph_table)
+{
+	int ret = -EFAULT;
+	unsigned int i;
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct ia_css_morph_table *morph_table;
+	struct ia_css_morph_table *old_morph_table;
+
+	if (!user_morph_table)
+		return 0;
+
+	old_morph_table = isp->inputs[isp_subdev->input_curr].morph_table;
+
+	morph_table = ia_css_morph_table_allocate(user_morph_table->width,
+				user_morph_table->height);
+	if (!morph_table)
+		return -ENOMEM;
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		if (copy_from_user(morph_table->coordinates_x[i],
+			user_morph_table->coordinates_x[i],
+			user_morph_table->height * user_morph_table->width *
+			sizeof(*user_morph_table->coordinates_x[i])))
+			goto error;
+
+		if (copy_from_user(morph_table->coordinates_y[i],
+			user_morph_table->coordinates_y[i],
+			user_morph_table->height * user_morph_table->width *
+			sizeof(*user_morph_table->coordinates_y[i])))
+			goto error;
+	}
+
+	isp->inputs[isp_subdev->input_curr].morph_table = morph_table;
+	if (isp_subdev->params.gdc_cac_en)
+		isp_subdev->params.config.morph_table = morph_table;
+
+	if (old_morph_table)
+		ia_css_morph_table_free(old_morph_table);
+
+	return 0;
+
+error:
+	if (morph_table)
+		ia_css_morph_table_free(morph_table);
+	return ret;
+}
+
+/*
+* Function to configure ISP parameters
+*/
+int atomisp_set_parameters(struct atomisp_sub_device *isp_subdev,
+			struct atomisp_parameters *arg)
+{
+	int ret;
+
+	ret = __atomisp_set_general_isp_parameters(isp_subdev, arg);
+	if (ret)
+		return ret;
+
+	ret = __atomisp_set_lsc_table(isp_subdev, arg->shading_table);
+	if (ret)
+		return ret;
+
+	ret = __atomisp_set_morph_table(isp_subdev, arg->morph_table);
+	if (ret)
+		return ret;
+
+	/* indicate to CSS that we have parametes to be updated */
+	isp_subdev->params.css_update_params_needed = true;
+
+	return 0;
+}
+
+/*
+ * Function to set/get isp parameters to isp
+ */
+int atomisp_param(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_parm *config)
+{
+	/* Read parameter for 3A bianry info */
+	if (flag == 0) {
+		if (&config->info == NULL) {
+			v4l2_err(&atomisp_dev,
+				    "ERROR: NULL pointer in grid_info\n");
+			return -EINVAL;
+		}
+		atomisp_curr_user_grid_info(isp_subdev, &config->info);
+		return 0;
+	}
+
+	if (sizeof(config->wb_config) != sizeof(isp_subdev->params.config.wb_config))
+		goto INVALID_PARM;
+	if (sizeof(config->cc_config) != sizeof(isp_subdev->params.config.cc_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ob_config) != sizeof(isp_subdev->params.config.ob_config))
+		goto INVALID_PARM;
+	if (sizeof(config->de_config) != sizeof(isp_subdev->params.config.de_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ce_config) != sizeof(isp_subdev->params.config.ce_config))
+		goto INVALID_PARM;
+	if (sizeof(config->dp_config) != sizeof(isp_subdev->params.config.dp_config))
+		goto INVALID_PARM;
+	if (sizeof(config->nr_config) != sizeof(isp_subdev->params.config.nr_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ee_config) != sizeof(isp_subdev->params.config.ee_config))
+		goto INVALID_PARM;
+	if (sizeof(config->tnr_config) != sizeof(isp_subdev->params.config.tnr_config))
+		goto INVALID_PARM;
+
+	memcpy(&isp_subdev->params.wb_config, &config->wb_config,
+	       sizeof(struct ia_css_wb_config));
+	memcpy(&isp_subdev->params.cc_config, &config->cc_config,
+	       sizeof(struct ia_css_cc_config));
+	memcpy(&isp_subdev->params.ob_config, &config->ob_config,
+	       sizeof(struct ia_css_ob_config));
+	memcpy(&isp_subdev->params.dp_config, &config->dp_config,
+	       sizeof(struct ia_css_dp_config));
+	memcpy(&isp_subdev->params.de_config, &config->de_config,
+	       sizeof(struct ia_css_de_config));
+	memcpy(&isp_subdev->params.ce_config, &config->ce_config,
+	       sizeof(struct ia_css_ce_config));
+	memcpy(&isp_subdev->params.nr_config, &config->nr_config,
+	       sizeof(struct ia_css_nr_config));
+	memcpy(&isp_subdev->params.ee_config, &config->ee_config,
+	       sizeof(struct ia_css_ee_config));
+	memcpy(&isp_subdev->params.tnr_config, &config->tnr_config,
+	       sizeof(struct ia_css_tnr_config));
+
+	isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+	isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+	isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+	isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+	isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+	isp_subdev->params.config.ce_config = &isp_subdev->params.ce_config;
+	isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+	isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+	isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+
+	if (isp_subdev->params.color_effect == V4L2_COLORFX_NEGATIVE) {
+		config->cc_config.matrix[3] = -config->cc_config.matrix[3];
+		config->cc_config.matrix[4] = -config->cc_config.matrix[4];
+		config->cc_config.matrix[5] = -config->cc_config.matrix[5];
+		config->cc_config.matrix[6] = -config->cc_config.matrix[6];
+		config->cc_config.matrix[7] = -config->cc_config.matrix[7];
+		config->cc_config.matrix[8] = -config->cc_config.matrix[8];
+	}
+
+	if (isp_subdev->params.color_effect != V4L2_COLORFX_SEPIA &&
+	    isp_subdev->params.color_effect != V4L2_COLORFX_BW) {
+		memcpy(&isp_subdev->params.cc_config, &config->cc_config,
+		       sizeof(struct ia_css_cc_config));
+		isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+	}
+
+	isp_subdev->params.css_update_params_needed = true;
+
+	return 0;
+
+INVALID_PARM:
+	v4l2_err(&atomisp_dev,
+		"%s: incompatible param.\n", __func__);
+	return -EINVAL;
+}
+
+/*
+ * Function to configure color effect of the image
+ */
+int atomisp_color_effect(struct atomisp_sub_device *isp_subdev, int flag, __s32 *effect)
+{
+	struct ia_css_cc_config *cc_config = NULL;
+	struct ia_css_macc_table *macc_table = NULL;
+	struct ia_css_ctc_table *ctc_table = NULL;
+	int ret = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_control control;
+
+	if (flag == 0) {
+		*effect = isp_subdev->params.color_effect;
+		return 0;
+	}
+
+
+	control.id = V4L2_CID_COLORFX;
+	control.value = *effect;
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, s_ctrl, &control);
+	/*
+	 * if set color effect to sensor successfully, return
+	 * 0 directly.
+	 */
+	if (!ret) {
+		isp_subdev->params.color_effect = (u32)*effect;
+		return 0;
+	}
+
+	if (*effect == isp_subdev->params.color_effect)
+		return 0;
+
+	/*
+	 * set macc enable to false by default:
+	 * when change from macc to sepia/mono,
+	 * isp_subdev->params.macc_en should be set to false.
+	 */
+	isp_subdev->params.macc_en = false;
+
+	switch (*effect) {
+	case V4L2_COLORFX_NONE:
+		macc_table = NULL;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SEPIA:
+		cc_config = &sepia_cc_config;
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		cc_config = &nega_cc_config;
+		break;
+	case V4L2_COLORFX_BW:
+		cc_config = &mono_cc_config;
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		macc_table = &blue_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		macc_table = &green_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_LOW:
+		macc_table = &skin_low_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		macc_table = &skin_medium_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
+		macc_table = &skin_high_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_VIVID:
+		ctc_table = &vivid_ctc_table;
+		break;
+	default:
+		return -EINVAL;
+	}
+	atomisp_update_capture_mode(isp_subdev);
+
+	if (cc_config)
+		isp_subdev->params.config.cc_config = cc_config;
+	if (macc_table)
+		isp_subdev->params.config.macc_table = macc_table;
+	if (ctc_table)
+		isp_subdev->params.config.ctc_table = ctc_table;
+	isp_subdev->params.color_effect = (u32)*effect;
+	isp_subdev->params.css_update_params_needed = true;
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction
+ */
+int atomisp_bad_pixel(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+
+	if (flag == 0) {
+		*value = isp_subdev->params.bad_pixel_en;
+		return 0;
+	}
+	isp_subdev->params.bad_pixel_en = !!*value;
+
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_bad_pixel_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_dp_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.dp_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_dp_config dp_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&dp_config, 0, sizeof(struct ia_css_dp_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.dp_config = &dp_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get bad pixel from current setup */
+		memcpy(config, isp_subdev->params.config.dp_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.dp_config)
+			isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+		/* Set bad pixel to isp parameters */
+		memcpy(isp_subdev->params.config.dp_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to enable/disable video image stablization
+ */
+int atomisp_video_stable(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	if (flag == 0)
+		*value = isp_subdev->params.video_dis_en;
+	else
+		isp_subdev->params.video_dis_en = !!*value;
+
+	return 0;
+}
+
+/*
+ * Function to configure fixed pattern noise
+ */
+int atomisp_fixed_pattern(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+
+	if (flag == 0) {
+		*value = isp_subdev->params.fpn_en;
+		return 0;
+	}
+
+	if (*value == 0) {
+		isp_subdev->params.fpn_en = 0;
+		return 0;
+	}
+
+	/* Add function to get black from from sensor with shutter off */
+	return 0;
+}
+
+static unsigned int
+atomisp_bytesperline_to_padded_width(unsigned int bytesperline,
+				     enum ia_css_frame_format format)
+{
+	switch (format) {
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		return bytesperline/2;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		return bytesperline/4;
+	/* The following cases could be removed, but we leave them
+	   in to document the formats that are included. */
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+	default:
+		return bytesperline;
+	}
+}
+
+static int
+atomisp_v4l2_framebuffer_to_ia_css_frame(const struct v4l2_framebuffer *arg,
+					 struct ia_css_frame **result)
+{
+	struct ia_css_frame *res;
+	unsigned int padded_width;
+	enum ia_css_frame_format sh_format;
+	char *tmp_buf = NULL;
+	int ret = 0;
+
+	sh_format = v4l2_fmt_to_sh_fmt(arg->fmt.pixelformat);
+	padded_width = atomisp_bytesperline_to_padded_width(
+					arg->fmt.bytesperline, sh_format);
+
+	/* Note: the padded width on an ia_css_frame is in elements, not in
+	   bytes. The RAW frame we use here should always be a 16bit RAW
+	   frame. This is why we bytesperline/2 is equal to the padded with */
+	if (ia_css_frame_allocate(&res, arg->fmt.width, arg->fmt.height,
+				  sh_format, padded_width, 0)) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	tmp_buf = vmalloc(arg->fmt.sizeimage);
+	if (!tmp_buf) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	if (copy_from_user(tmp_buf, (void __user __force *)arg->base,
+			   arg->fmt.sizeimage)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (hmm_store((void *)res->data, tmp_buf, arg->fmt.sizeimage)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+err:
+	if (ret && res)
+		ia_css_frame_free(res);
+	if (tmp_buf)
+		vfree(tmp_buf);
+	if (ret == 0)
+		*result = res;
+	return ret;
+}
+
+/*
+ * Function to configure fixed pattern noise table
+ */
+int atomisp_fixed_pattern_table(struct atomisp_sub_device *isp_subdev,
+				struct v4l2_framebuffer *arg)
+{
+	struct ia_css_frame *raw_black_frame = NULL;
+	int ret;
+
+	if (arg == NULL)
+		return -EINVAL;
+
+	ret = atomisp_v4l2_framebuffer_to_ia_css_frame(arg, &raw_black_frame);
+	if (ret)
+		return ret;
+
+	if (sh_css_set_black_frame(isp_subdev->css2_basis.stream, raw_black_frame) != IA_CSS_SUCCESS)
+		ret = -ENOMEM;
+
+	ia_css_frame_free(raw_black_frame);
+	return ret;
+}
+
+/*
+ * Function to configure false color correction
+ */
+int atomisp_false_color(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+	/* Get nr config from current setup */
+	if (flag == 0) {
+		*value = isp_subdev->params.false_color;
+		return 0;
+	}
+
+	/* Set nr config to isp parameters */
+	if (*value) {
+		isp_subdev->params.config.de_config = NULL;
+	} else {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		isp_subdev->params.config.de_config->pixelnoise = 0;
+	}
+	isp_subdev->params.css_update_params_needed = true;
+	isp_subdev->params.false_color = *value;
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_false_color_param(struct atomisp_sub_device *isp_subdev, int flag,
+			      struct atomisp_de_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.de_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_de_config de_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&de_config, 0, sizeof(struct ia_css_de_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.de_config = &de_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get false color from current setup */
+		memcpy(config, &de_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		/* Set false color to isp parameters */
+		memcpy(isp_subdev->params.config.de_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to configure white balance params
+ */
+int atomisp_white_balance_param(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_wb_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.wb_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_wb_config wb_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&wb_config, 0, sizeof(struct ia_css_wb_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.wb_config = &wb_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get white balance from current setup */
+		memcpy(config, &wb_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.wb_config)
+			isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+		/* Set white balance to isp parameters */
+		memcpy(isp_subdev->params.config.wb_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+int atomisp_3a_config_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_3a_config *config)
+{
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s %d\n", __func__, flag);
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.s3a_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_3a_config s3a_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&s3a_config, 0, sizeof(struct ia_css_3a_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.s3a_config = &s3a_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get white balance from current setup */
+		memcpy(config, &s3a_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.s3a_config)
+			isp_subdev->params.config.s3a_config = &isp_subdev->params.s3a_config;
+		/* Set white balance to isp parameters */
+		memcpy(isp_subdev->params.config.s3a_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+		/* isp_subdev->params.s3a_buf_data_valid = false; */
+	}
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s %d\n", __func__, flag);
+	return 0;
+}
+
+/*
+ * Function to enable/disable lens shading correction
+ */
+int atomisp_shading_correction(struct atomisp_sub_device *isp_subdev, int flag,
+				       __s32 *value)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	if (flag == 0) {
+		*value = isp_subdev->params.sc_en;
+		return 0;
+	}
+
+	if (*value == 0)
+		isp_subdev->params.config.shading_table = NULL;
+	else
+		isp_subdev->params.config.shading_table =
+		    isp->inputs[isp_subdev->input_curr].shading_table;
+
+	isp_subdev->params.sc_en = *value;
+
+	return 0;
+}
+
+/*
+ * Function to setup digital zoom
+ */
+int atomisp_digital_zoom(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+	u32 zoom;
+	unsigned int max_zoom =
+		IS_MRFLD ? MRFLD_MAX_ZOOM_FACTOR : MFLD_MAX_ZOOM_FACTOR;
+
+	if (flag == 0) {
+		struct ia_css_dz_config dz_config;  /**< Digital Zoom */
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&dz_config, 0, sizeof(struct ia_css_dz_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.dz_config = &dz_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		*value = max_zoom - dz_config.dx;
+	} else {
+		if (*value < 0)
+			return -EINVAL;
+
+		zoom = max_zoom - min_t(u32, max_zoom, (*value));
+
+		if (!isp_subdev->params.config.dz_config)
+			isp_subdev->params.config.dz_config = &isp_subdev->params.dz_config;
+
+		if (zoom == isp_subdev->params.config.dz_config->dx &&
+			 zoom == isp_subdev->params.config.dz_config->dy) {
+			v4l2_dbg(3, dbg_level, &atomisp_dev, "same zoom scale. skipped.\n");
+			return 0;
+		}
+
+		memset(isp_subdev->params.config.dz_config, 0, sizeof(struct ia_css_dz_config));
+		isp_subdev->params.dz_config.dx = zoom;
+		isp_subdev->params.dz_config.dy = zoom;
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "%s, zoom: %d\n",
+			 __func__, zoom);
+
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to get sensor specific info for current resolution,
+ * which will be used for auto exposure conversion.
+ */
+int atomisp_get_sensor_mode_data(struct atomisp_sub_device *isp_subdev,
+				 struct atomisp_sensor_mode_data *config)
+{
+	struct camera_mipi_info *mipi_info;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	mipi_info = atomisp_to_sensor_mipi_info(
+		isp->inputs[isp_subdev->input_curr].camera);
+	if (mipi_info == NULL)
+		return -EINVAL;
+
+	memcpy(config, &mipi_info->data, sizeof(*config));
+	return 0;
+}
+
+int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f)
+{
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+			    "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	memset(f, 0, sizeof(struct v4l2_format));
+	f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	/* VIDIOC_S_FMT already called,*/
+	/* return fmt set by app */
+	if (pipe->pix.width != 0) {
+		memcpy(&f->fmt.pix, &pipe->pix,
+			sizeof(struct v4l2_pix_format));
+	} else {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "Pipe width was 0, setting default 640x480\n");
+		f->fmt.pix.width = 640;
+		f->fmt.pix.height = 480;
+		f->fmt.pix.pixelformat = atomisp_output_fmts[0].pixelformat;
+		f->fmt.pix.bytesperline =
+			get_pixel_depth(f->fmt.pix.pixelformat) *
+						f->fmt.pix.width;
+		f->fmt.pix.sizeimage = f->fmt.pix.height *
+						f->fmt.pix.bytesperline;
+		f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+	}
+
+	return 0;
+}
+
+
+/* This function looks up the closest available resolution. */
+int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
+						bool *res_overflow)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct v4l2_mbus_framefmt snr_mbus_fmt;
+	const struct atomisp_format_bridge *fmt;
+	int ret;
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	if (isp->inputs[isp_subdev->input_curr].camera == NULL)
+		return -EINVAL;
+
+	fmt = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
+	if (fmt == NULL) {
+		v4l2_err(&atomisp_dev, "unsupported pixelformat!\n");
+		fmt = atomisp_output_fmts;
+	}
+
+	if (isp->inputs[isp_subdev->input_curr].type == TEST_PATTERN)
+		return 0;
+
+	snr_mbus_fmt.code = fmt->mbus_code;
+	snr_mbus_fmt.width = f->fmt.pix.width;
+	snr_mbus_fmt.height = f->fmt.pix.height;
+
+	dev_dbg(isp->dev, "try_mbus_fmt: asking for %ux%u\n",
+		snr_mbus_fmt.width, snr_mbus_fmt.height);
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			video, try_mbus_fmt, &snr_mbus_fmt);
+	if (ret)
+		return ret;
+
+	dev_dbg(isp->dev, "try_mbus_fmt: got %ux%u\n",
+		snr_mbus_fmt.width, snr_mbus_fmt.height);
+
+	fmt = atomisp_get_format_bridge_from_mbus(snr_mbus_fmt.code);
+	if (fmt == NULL)
+		v4l2_err(&atomisp_dev, "unknown sensor format.\n");
+	else
+		f->fmt.pix.pixelformat = fmt->pixelformat;
+
+	if (snr_mbus_fmt.width < f->fmt.pix.width
+	    && snr_mbus_fmt.height < f->fmt.pix.height) {
+		f->fmt.pix.width = snr_mbus_fmt.width;
+		f->fmt.pix.height = snr_mbus_fmt.width;
+		/* Set the flag when resolution requested is
+		 * beyond the max value supported by sensor
+		 */
+		if (res_overflow != NULL)
+			*res_overflow = true;
+	}
+
+	/* app vs isp */
+	f->fmt.pix.width = rounddown(
+		clamp_t(u32, f->fmt.pix.width, ATOM_ISP_MIN_WIDTH,
+			ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
+	f->fmt.pix.height = rounddown(
+		clamp_t(u32, f->fmt.pix.height, ATOM_ISP_MIN_HEIGHT,
+			ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
+
+	return 0;
+}
+
+static int
+atomisp_try_fmt_file(struct atomisp_device *isp, struct v4l2_format *f)
+{
+	u32 width = f->fmt.pix.width;
+	u32 height = f->fmt.pix.height;
+	u32 pixelformat = f->fmt.pix.pixelformat;
+	enum v4l2_field field = f->fmt.pix.field;
+	u32 depth;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	if (!atomisp_get_format_bridge(pixelformat)) {
+		v4l2_err(&atomisp_dev, "Wrong output pixelformat\n");
+		return -EINVAL;
+	}
+
+	depth = get_pixel_depth(pixelformat);
+
+	if (!field || field == V4L2_FIELD_ANY)
+		field = V4L2_FIELD_NONE;
+	else if (field != V4L2_FIELD_NONE) {
+		v4l2_err(&atomisp_dev, "Wrong output field\n");
+		return -EINVAL;
+	}
+
+	f->fmt.pix.field = field;
+	f->fmt.pix.width = clamp_t(u32,
+				   rounddown(width, (u32)ATOM_ISP_STEP_WIDTH),
+				   ATOM_ISP_MIN_WIDTH, ATOM_ISP_MAX_WIDTH);
+	f->fmt.pix.height = clamp_t(u32, rounddown(height,
+						   (u32)ATOM_ISP_STEP_HEIGHT),
+				    ATOM_ISP_MIN_HEIGHT, ATOM_ISP_MAX_HEIGHT);
+	f->fmt.pix.bytesperline = (width * depth) >> 3;
+
+	return 0;
+}
+
+static mipi_port_ID_t __get_mipi_port(enum atomisp_camera_port port)
+{
+	switch (port) {
+	case ATOMISP_CAMERA_PORT_PRIMARY:
+		return MIPI_PORT0_ID;
+	case ATOMISP_CAMERA_PORT_SECONDARY:
+		return MIPI_PORT1_ID;
+	case ATOMISP_CAMERA_PORT_THIRD:
+		if (MIPI_PORT1_ID + 1 != N_MIPI_PORT_ID)
+			return MIPI_PORT1_ID + 1;
+		/* go through down for else case */
+	default:
+		v4l2_err(&atomisp_dev, "unsupported port: %d\n", port);
+		return MIPI_PORT0_ID;
+	}
+}
+
+static inline void
+atomisp_set_sensor_mipi_to_isp(struct camera_mipi_info *mipi_info,
+			       struct ia_css_stream_config *stream_config)
+{
+	struct ia_css_input_port *config = &stream_config->source.port;
+	if (mipi_info->input_format != -1) {
+		stream_config->bayer_order =
+		    (enum ia_css_bayer_order)mipi_info->raw_bayer_order;
+		stream_config->format =
+		    (enum ia_css_stream_format)mipi_info->input_format;
+		config->port = __get_mipi_port(mipi_info->port);
+		config->num_lanes = mipi_info->num_lanes;
+	} else {
+		stream_config->bayer_order = IA_CSS_BAYER_ORDER_GRBG;
+		stream_config->format = IA_CSS_STREAM_FORMAT_RAW_10;
+		config->port = __get_mipi_port(ATOMISP_CAMERA_PORT_PRIMARY);
+		config->num_lanes = 2;
+	}
+		config->timeout = 0xffff4;
+		config->compression.type = IA_CSS_CSI2_COMPRESSION_TYPE_NONE;
+}
+static void __enable_continuous_vf(struct atomisp_sub_device *isp_subdev, bool enable)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_PRIMARY);
+	ia_css_capture_enable_online(isp_subdev, !enable);
+	ia_css_preview_enable_online(isp_subdev, !enable);
+	ia_css_enable_continuous(isp_subdev, enable);
+
+	sh_css_enable_cont_capt(enable, enable);
+	if (!enable) {
+		ia_css_enable_raw_binning(isp_subdev, false);
+		ia_css_input_set_two_pixels_per_clock(isp_subdev, false);
+	}
+
+	ia_css_input_set_mode(isp_subdev, get_input_mode(isp->inputs[isp_subdev->input_curr].type));
+
+	atomisp_update_run_mode(isp_subdev);
+}
+
+static enum ia_css_err configure_pp_input_nop(struct atomisp_sub_device *isp_subdev,
+					      unsigned int width,
+					      unsigned int height)
+{
+	return 0;
+}
+static int atomisp_set_fmt_to_isp(struct video_device *vdev,
+				   struct ia_css_frame_info *output_info,
+				   struct ia_css_frame_info *raw_output_info,
+				   int width, int height,
+				  unsigned int pixelformat,
+				  unsigned int source_pad)
+{
+	struct camera_mipi_info *mipi_info;
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	const struct atomisp_format_bridge *format;
+	struct v4l2_rect *isp_sink_crop;
+	enum ia_css_err (*configure_output)(struct atomisp_sub_device *isp_subdev,
+					    unsigned int width,
+					    unsigned int height,
+					    enum ia_css_frame_format sh_fmt);
+	enum ia_css_err (*get_frame_info)(struct atomisp_sub_device *isp_subdev,
+					  struct ia_css_frame_info *finfo);
+	enum ia_css_err (*configure_pp_input)(struct atomisp_sub_device *isp_subdev,
+					      unsigned int width,
+					      unsigned int height) =
+		configure_pp_input_nop;
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	int ret;
+	int raw_override = 0;
+	enum ia_css_stream_format sh_input_format = IA_CSS_STREAM_FORMAT_YUV422_8;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER atomisp_set_fmt_to_isp\n");
+
+	isp_sink_crop = atomisp_subdev_get_rect(
+		&isp_subdev->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
+		ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);
+
+	format = atomisp_get_format_bridge(pixelformat);
+	if (format == NULL)
+		return -EINVAL;
+
+	if (isp->inputs[isp_subdev->input_curr].type != TEST_PATTERN &&
+		isp->inputs[isp_subdev->input_curr].type != FILE_INPUT) {
+		mipi_info = atomisp_to_sensor_mipi_info(
+			isp->inputs[isp_subdev->input_curr].camera);
+		if (!mipi_info) {
+			dev_err(isp->dev, "mipi_info is NULL\n");
+			return -EINVAL;
+		}
+		atomisp_set_sensor_mipi_to_isp(mipi_info, &isp_subdev->css2_basis.stream_config);
+
+		if ((format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW) &&
+		     raw_output_format_match_input(
+			mipi_info->input_format, pixelformat))
+			return -EINVAL;
+	}
+
+	/*
+	 * Configure viewfinder also if enable_vfpp is disabled: the
+	 * CSS still requires viewfinder configuration.
+	 */
+	if (isp_subdev->fmt_auto->val
+	    || !isp_subdev->enable_vfpp->val) {
+		struct v4l2_rect vf_size;
+		struct v4l2_mbus_framefmt vf_ffmt;
+
+		memset(&vf_size, 0, sizeof(vf_size));
+		if (width < 640 || height < 480) {
+			vf_size.width = width;
+			vf_size.height = height;
+		} else {
+			vf_size.width = 640;
+			vf_size.height = 480;
+		}
+
+		memset(&vf_ffmt, 0, sizeof(vf_ffmt));
+		/* FIXME: proper format name for this one. See
+		   atomisp_output_fmts[] in atomisp_v4l2.c */
+		vf_ffmt.code = 0x8001;
+
+		atomisp_subdev_set_selection(&isp_subdev->subdev, NULL,
+					     V4L2_SUBDEV_FORMAT_ACTIVE,
+					     ATOMISP_SUBDEV_PAD_SOURCE_VF,
+					     V4L2_SEL_TGT_COMPOSE, 0, &vf_size);
+		atomisp_subdev_set_ffmt(&isp_subdev->subdev, NULL,
+					V4L2_SUBDEV_FORMAT_ACTIVE,
+					ATOMISP_SUBDEV_PAD_SOURCE_VF, &vf_ffmt);
+
+		isp_subdev->video_out_vf.sh_fmt = IA_CSS_FRAME_FORMAT_YUV420;
+
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+		    || !isp_subdev->enable_vfpp->val)
+			ia_css_video_configure_viewfinder(isp_subdev,
+				vf_size.width, vf_size.height,
+				isp_subdev->video_out_vf.sh_fmt);
+		else if (source_pad != ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW)
+			ia_css_capture_configure_viewfinder(isp_subdev,
+				vf_size.width, vf_size.height,
+				isp_subdev->video_out_vf.sh_fmt);
+	}
+
+	/* get input format */
+	sh_input_format = isp_subdev->css2_basis.stream_config.format;
+
+	if (isp_subdev->params.continuous_vf) {
+		if (isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+			__enable_continuous_vf(isp_subdev, true);
+			/* enable only if resolution is equal or above 5M */
+			if (width >= 2576 || height >= 1936) {
+				ia_css_enable_raw_binning(isp_subdev, true);
+				ia_css_input_set_two_pixels_per_clock(isp_subdev, false);
+			}
+		} else {
+			__enable_continuous_vf(isp_subdev, false);
+		}
+	}
+	else if (sh_input_format == IA_CSS_STREAM_FORMAT_RGB_565
+		|| sh_input_format == IA_CSS_STREAM_FORMAT_RGB_888) {
+		/* make sure it sets the right configurations for RGB passthrough FIFO */
+		__enable_continuous_vf(isp_subdev, false);
+		raw_override = 1;
+	}
+
+	ia_css_disable_vf_pp(isp_subdev, !isp_subdev->enable_vfpp->val);
+
+	/* video same in continuouscapture and online modes */
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+	    || !isp_subdev->enable_vfpp->val) {
+		configure_output = ia_css_video_configure_output;
+		get_frame_info = ia_css_video_get_output_frame_info;
+	} else if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW) {
+		configure_output = ia_css_preview_configure_output;
+		get_frame_info = ia_css_preview_get_output_frame_info;
+		configure_pp_input = ia_css_preview_configure_pp_input;
+	} else {
+		if (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW || raw_override) {
+			ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_RAW);
+		}  else {
+			ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_PRIMARY);
+		} 
+		if (!isp_subdev->params.continuous_vf)
+			ia_css_capture_enable_online(isp_subdev,
+					isp_subdev->params.online_process);
+
+		configure_output = ia_css_capture_configure_output;
+		get_frame_info = ia_css_capture_get_output_frame_info;
+		configure_pp_input = ia_css_capture_configure_pp_input;
+
+		if (!isp_subdev->params.online_process && !isp_subdev->params.continuous_vf)
+			if (ia_css_capture_get_output_raw_frame_info(isp_subdev,
+						raw_output_info))
+				return -EINVAL;
+		if (!isp_subdev->params.continuous_vf &&
+		    isp_subdev->run_mode->val
+		    != ATOMISP_RUN_MODE_STILL_CAPTURE) {
+			v4l2_err(&atomisp_dev,
+				    "Need to set the running mode first\n");
+			isp_subdev->run_mode->val =
+				ATOMISP_RUN_MODE_STILL_CAPTURE;
+		}
+	}
+
+	ret = configure_output(isp_subdev, width, height, format->sh_fmt);
+	if (ret) {
+		dev_err(isp->dev, "configure_output %ux%u, format %8.8x\n",
+			width, height, format->sh_fmt);
+		return -EINVAL;
+	}
+	ret = configure_pp_input(isp_subdev, isp_sink_crop->width,
+				 isp_sink_crop->height);
+	if (ret) {
+		dev_err(isp->dev, "configure_pp_input %ux%u\n",
+			isp_sink_crop->width, isp_sink_crop->height);
+		return -EINVAL;
+	}
+	ret = get_frame_info(isp_subdev, output_info);
+	if (ret) {
+		dev_err(isp->dev, "get_frame_info %ux%u\n", width, height);
+		return -EINVAL;
+	}
+
+	atomisp_update_grid_info(isp_subdev);
+
+	/* Free the raw_dump buffer first */
+	ia_css_frame_free(isp_subdev->raw_output_frame);
+	isp_subdev->raw_output_frame = NULL;
+
+	if (!isp_subdev->params.continuous_vf && !isp_subdev->params.online_process &&
+	    !isp->sw_contex.file_input &&
+	    ia_css_frame_allocate_from_info(&isp_subdev->raw_output_frame,
+					       raw_output_info))
+		return -ENOMEM;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "EXIT atomisp_set_fmt_to_isp\n");
+	return 0;
+}
+
+static void atomisp_get_dis_envelop(struct atomisp_sub_device *isp_subdev,
+			    unsigned int width, unsigned int height,
+			    unsigned int *dvs_env_w,
+			    unsigned int *dvs_env_h)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	/* if subdev type is SOC camera,we do not need to set DVS */
+	if (isp->inputs[isp_subdev->input_curr].type == SOC_CAMERA)
+		isp_subdev->params.video_dis_en = 0;
+
+	if (isp_subdev->params.video_dis_en &&
+	    isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		/* envelope is 20% of the output resolution */
+		/*
+		 * dvs envelope cannot be round up.
+		 * it would cause ISP timeout and color switch issue
+		 */
+		*dvs_env_w = rounddown(width / 5, ATOM_ISP_STEP_WIDTH);
+		*dvs_env_h = rounddown(height / 5, ATOM_ISP_STEP_HEIGHT);
+	}
+
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp_subdev->params.css_update_params_needed = true;
+}
+
+static int atomisp_set_fmt_to_snr(struct atomisp_sub_device *isp_subdev,
+			  struct v4l2_format *f, unsigned int pixelformat,
+			  unsigned int padding_w, unsigned int padding_h,
+			  unsigned int dvs_env_w, unsigned int dvs_env_h)
+{
+	const struct atomisp_format_bridge *format;
+	struct v4l2_mbus_framefmt ffmt;
+	int ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	format = atomisp_get_format_bridge(pixelformat);
+	if (format == NULL) {
+		trace_printk("atomisp_get_format_bridge failed");
+		return -EINVAL;
+	}
+
+	if (!isp->sw_contex.file_input) {
+	v4l2_fill_mbus_format(&ffmt, &f->fmt.pix, format->mbus_code);
+	ffmt.height += padding_h + dvs_env_h;
+	ffmt.width += padding_w + dvs_env_w;
+
+	dev_dbg(isp->dev, "s_mbus_fmt: ask %ux%u (padding %ux%u, dvs %ux%u)\n",
+		ffmt.width, ffmt.height, padding_w, padding_h,
+		dvs_env_w, dvs_env_h);
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, video,
+			       s_mbus_fmt, &ffmt);
+	if (ret) {
+		trace_printk("v4l2_subdev_call s_mbus_fmt failed");
+		return ret;
+	}
+
+	dev_dbg(isp->dev, "sensor width: %d, height: %d\n",
+			ffmt.width, ffmt.height);
+	}
+	else {	/* file input case */
+		ffmt.width = f->fmt.pix.width;
+		ffmt.height = f->fmt.pix.height;
+		ffmt.code = format->mbus_code;
+	}
+
+	if (ffmt.width < ATOM_ISP_STEP_WIDTH ||
+	    ffmt.height < ATOM_ISP_STEP_HEIGHT)
+			return -EINVAL;
+
+	return atomisp_subdev_set_ffmt(&isp_subdev->subdev, NULL,
+				       V4L2_SUBDEV_FORMAT_ACTIVE,
+				       ATOMISP_SUBDEV_PAD_SINK, &ffmt);
+}
+
+int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	const struct atomisp_format_bridge *format_bridge;
+	struct ia_css_frame_info output_info, raw_output_info;
+	struct v4l2_format snr_fmt = *f;
+	unsigned int dvs_env_w = 0,
+		     dvs_env_h = 0;
+	unsigned int padding_w = pad_w,
+		     padding_h = pad_h;
+	bool res_overflow = false;
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+	struct v4l2_mbus_framefmt isp_source_fmt;
+	struct v4l2_rect isp_sink_crop;
+	enum ia_css_stream_format css_fmt;
+		struct camera_mipi_info *mipi_info;
+		enum ia_css_frame_format frame_format;
+		struct v4l2_mbus_framefmt snr_mbus_fmt;
+	uint16_t source_pad;
+	int ret;
+
+	trace_printk("ENTER DMA atomisp_set_fmt\n");
+
+	switch (pipe->pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		source_pad = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
+		break;
+	case ATOMISP_PIPE_VIEWFINDER:
+		source_pad = ATOMISP_SUBDEV_PAD_SOURCE_VF;
+		break;
+	case ATOMISP_PIPE_PREVIEW:
+		source_pad = ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW;
+		break;
+	default:
+		dev_err(isp->dev, "can't get source pad");
+		return -EINVAL;
+	}
+
+	dev_dbg(isp->dev, "setting resolution %ux%u on pad %u\n",
+		f->fmt.pix.width, f->fmt.pix.height, source_pad);
+	trace_printk("setting resolution %ux%u on pad %u\n",
+    f->fmt.pix.width, f->fmt.pix.height, source_pad);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    f->type != V4L2_BUF_TYPE_PRIVATE) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		trace_printk("Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	format_bridge = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
+	if (format_bridge == NULL) {
+		trace_printk("Format bridge is NULL\n");
+		return -EINVAL;
+	}
+
+	pipe->sh_fmt = format_bridge->sh_fmt;
+	pipe->pix.pixelformat = f->fmt.pix.pixelformat;
+
+	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF
+	    || (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW
+		&& isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)) {
+		if (isp_subdev->fmt_auto->val) {
+			struct v4l2_rect *capture_comp =
+				atomisp_subdev_get_rect(
+					&isp_subdev->subdev, NULL,
+					V4L2_SUBDEV_FORMAT_ACTIVE,
+					ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+					V4L2_SEL_TGT_COMPOSE);
+			struct v4l2_rect r;
+
+			memset(&r, 0, sizeof(r));
+
+			r.width = f->fmt.pix.width;
+			r.height = f->fmt.pix.height;
+
+			if (capture_comp->width < r.width
+			    || capture_comp->height < r.height) {
+				r.width = capture_comp->width;
+				r.height = capture_comp->height;
+			}
+
+			atomisp_subdev_set_selection(
+				&isp_subdev->subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE, source_pad,
+				V4L2_SEL_TGT_COMPOSE, 0, &r);
+
+			f->fmt.pix.width = r.width;
+			f->fmt.pix.height = r.height;
+		}
+
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+			ia_css_video_configure_viewfinder(isp_subdev,
+				f->fmt.pix.width, f->fmt.pix.height,
+				format_bridge->sh_fmt);
+			ia_css_video_get_viewfinder_frame_info(isp_subdev, &output_info);
+		} else {
+			ia_css_capture_configure_viewfinder(isp_subdev,
+				f->fmt.pix.width, f->fmt.pix.height,
+				format_bridge->sh_fmt);
+			ia_css_capture_get_viewfinder_frame_info(isp_subdev, &output_info);
+		}
+
+		goto done;
+	}
+
+	if(source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE && !(isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) && !(source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF) && !isp->sw_contex.file_input)
+			{
+				unsigned int width = f->fmt.pix.width;
+				unsigned int height = f->fmt.pix.height;
+				unsigned int pixelformat = f->fmt.pix.pixelformat;
+				switch(pixelformat)
+					{
+						case V4L2_PIX_FMT_YUV422P:
+
+							css_fmt = IA_CSS_STREAM_FORMAT_YUV422_8;
+							frame_format = IA_CSS_FRAME_FORMAT_YUV422;
+							break;
+						case V4L2_PIX_FMT_RGB565:
+							css_fmt = IA_CSS_STREAM_FORMAT_RGB_565;
+							frame_format = IA_CSS_FRAME_FORMAT_RGB565;
+							trace_printk("Setting RGB565 frame and stream format\n");
+							break;
+						case V4L2_PIX_FMT_RGB24:
+							css_fmt = IA_CSS_STREAM_FORMAT_RGB_888;
+							frame_format = IA_CSS_FRAME_FORMAT_RGBA888;
+							break;
+					  case V4L2_PIX_FMT_UYVY:
+							css_fmt = IA_CSS_STREAM_FORMAT_YUV422_8;
+							frame_format = IA_CSS_FRAME_FORMAT_UYVY;
+							break;
+					  default:
+							dev_err(isp->dev, "pixelformat error!!\n");
+							return -EINVAL;
+					}
+
+					trace_printk("Setting width and height= %dx%d\n", width, height);
+					//missing
+					isp_subdev->css2_basis.stream_config.input_res.width = width;
+					isp_subdev->css2_basis.stream_config.input_res.height = height;
+					//missing
+					isp_subdev->css2_basis.stream_config.effective_res.width = width;
+					isp_subdev->css2_basis.stream_config.effective_res.height = height;
+
+					//missing
+					isp_subdev->css2_basis.stream_config.mode = IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+
+					ia_css_capture_set_mode(isp_subdev,IA_CSS_CAPTURE_MODE_RAW);
+
+					isp_subdev->css2_basis.stream_config.format =
+						(enum ia_css_stream_format)css_fmt;
+
+					mipi_info = atomisp_to_sensor_mipi_info(
+							isp->inputs[isp_subdev->input_curr].camera);
+					isp_subdev->css2_basis.stream_config.source.port.port = __get_mipi_port(mipi_info->port);
+					isp_subdev->css2_basis.stream_config.source.port.num_lanes = mipi_info->num_lanes;
+					isp_subdev->css2_basis.stream_config.source.port.timeout = 0xffff4;
+
+					if (ia_css_capture_configure_output(isp_subdev, width, height, frame_format))
+					{
+						printk(KERN_ALERT "ERROR: css_capture_configure_output failed\n");
+						return -EINVAL;
+					}
+
+
+					//configure sensor output format&resolution
+					v4l2_fill_mbus_format(&snr_mbus_fmt, &f->fmt.pix,
+									format_bridge->mbus_code);
+
+					ret = v4l2_subdev_call(
+								isp->inputs[isp_subdev->input_curr].camera,
+								video, s_mbus_fmt, &snr_mbus_fmt);
+					if (ret) {
+						printk(KERN_ALERT "ERROR v4l2_subdev_call, s_mbus_fmt\n");
+
+					}
+
+					//This should create a port if it does not exist
+					if (ia_css_capture_get_output_frame_info(isp_subdev, &output_info)) {
+						printk(KERN_ALERT "ERROR: ia_css_capture_get_output_frame_info failed\n");
+					}
+					trace_printk("Returned from get_css_frame_info, output_info.padded_width=%d\n", output_info.padded_width);
+
+					/* Only main stream pipe will be here */
+					isp_subdev->capture_pad = source_pad;
+					printk("Exiting source_pad: ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE");
+			goto done;
+			}
+	/*
+	 * Check whether main resolution configured smaller
+	 * than snapshot resolution. If so, force main resolution
+	 * to be the same as snapshot resolution
+	 */
+	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE) {
+		struct v4l2_rect *r;
+
+		r = atomisp_subdev_get_rect(
+			&isp_subdev->subdev, NULL,
+			V4L2_SUBDEV_FORMAT_ACTIVE,
+			ATOMISP_SUBDEV_PAD_SOURCE_VF, V4L2_SEL_TGT_COMPOSE);
+
+		if (r->width && r->height
+		    && (r->width > f->fmt.pix.width
+			|| r->height > f->fmt.pix.height))
+			dev_warn(isp->dev,
+				 "Main Resolution config smaller then Vf Resolution. Force to be equal with Vf Resolution.");
+	}
+
+	/* V4L2_BUF_TYPE_PRIVATE will set offline processing */
+	if (f->type == V4L2_BUF_TYPE_PRIVATE)
+		isp_subdev->params.online_process = 0;
+	else
+		isp_subdev->params.online_process = 1;
+
+	/* Pipeline configuration done through subdevs. Bail out now. */
+	if (!isp_subdev->fmt_auto->val)
+		goto done;
+
+	/* get sensor resolution and format */
+	if (!isp->sw_contex.file_input) {
+		atomisp_try_fmt(vdev, &snr_fmt, &res_overflow);
+		f->fmt.pix.width = snr_fmt.fmt.pix.width;
+		f->fmt.pix.height = snr_fmt.fmt.pix.height;
+	}
+	else {
+		snr_fmt.fmt.pix.width = f->fmt.pix.width;
+		snr_fmt.fmt.pix.height = f->fmt.pix.height;
+	}
+
+	/*
+	 * Set mbus codes for bypass mode configuration, but do
+	 * nothing else.
+	 */
+	atomisp_subdev_get_ffmt(&isp_subdev->subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK)->code =
+		atomisp_get_format_bridge(
+			snr_fmt.fmt.pix.pixelformat)->mbus_code;
+
+	isp_sink_fmt = *atomisp_subdev_get_ffmt(&isp_subdev->subdev, NULL,
+					    V4L2_SUBDEV_FORMAT_ACTIVE,
+					    ATOMISP_SUBDEV_PAD_SINK);
+
+	memset(&isp_source_fmt, 0, sizeof(isp_source_fmt));
+	isp_source_fmt.code = atomisp_get_format_bridge(
+		f->fmt.pix.pixelformat)->mbus_code;
+	atomisp_subdev_set_ffmt(&isp_subdev->subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				source_pad, &isp_source_fmt);
+
+	if (isp->sw_contex.bypass)
+		padding_w = 0, padding_h = 0;
+
+	/* construct resolution supported by isp */
+	if (res_overflow && !isp_subdev->params.continuous_vf) {
+		f->fmt.pix.width = rounddown(
+			clamp_t(u32, f->fmt.pix.width - padding_w,
+				ATOM_ISP_MIN_WIDTH,
+				ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
+		f->fmt.pix.height = rounddown(
+			clamp_t(u32, f->fmt.pix.height - padding_h,
+				ATOM_ISP_MIN_HEIGHT,
+				ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
+	}
+
+	atomisp_get_dis_envelop(isp_subdev, f->fmt.pix.width, f->fmt.pix.height,
+				&dvs_env_w, &dvs_env_h);
+
+	/* Only main stream pipe will be here */
+	isp_subdev->capture_pad = source_pad;
+
+	/*
+	 * set format info to sensor
+	 * In case of continuous_vf, resolution is set only if it is higher than
+	 * existing value. This because preview pipe will be configured after
+	 * capture pipe and usually has lower resolution than capture pipe.
+	 */
+	if (!isp_subdev->params.continuous_vf ||
+	    isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
+	    (isp_sink_fmt.width < (f->fmt.pix.width + padding_w + dvs_env_w) &&
+	     isp_sink_fmt.height < (f->fmt.pix.height + padding_h +
+				    dvs_env_h))) {
+		ret = atomisp_set_fmt_to_snr(isp_subdev, f, f->fmt.pix.pixelformat,
+					     padding_w, padding_h,
+					     dvs_env_w, dvs_env_h);
+		if (ret) {
+			trace_printk("atomisp_set_fmt_to_snr failed\n");
+			return -EINVAL;
+		}
+	}
+
+	isp_sink_crop = *atomisp_subdev_get_rect(&isp_subdev->subdev, NULL,
+						 V4L2_SUBDEV_FORMAT_ACTIVE,
+						 ATOMISP_SUBDEV_PAD_SINK,
+						 V4L2_SEL_TGT_CROP);
+
+	/* Try to enable YUV downscaling if ISP input is 10 % (either
+	 * width or height) bigger than the desired result. */
+	if (isp_sink_crop.width * 9 / 10 < f->fmt.pix.width
+	    || isp_sink_crop.height * 9 / 10 < f->fmt.pix.height
+	    || isp->sw_contex.file_input
+	    || (isp->sw_contex.bypass
+		&& isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO
+		&& isp_subdev->enable_vfpp->val)
+	    || (!isp->sw_contex.bypass
+		&& isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)) {
+		isp_sink_crop.width = f->fmt.pix.width;
+		isp_sink_crop.height = f->fmt.pix.height;
+		atomisp_subdev_set_selection(&isp_subdev->subdev, NULL,
+					     V4L2_SUBDEV_FORMAT_ACTIVE,
+					     ATOMISP_SUBDEV_PAD_SINK,
+					     V4L2_SEL_TGT_CROP,
+					     V4L2_SEL_FLAG_KEEP_CONFIG,
+					     &isp_sink_crop);
+		atomisp_subdev_set_selection(&isp_subdev->subdev, NULL,
+					     V4L2_SUBDEV_FORMAT_ACTIVE,
+					     source_pad, V4L2_SEL_TGT_COMPOSE,
+					     0, &isp_sink_crop);
+	} else {
+		struct v4l2_rect main_compose;
+
+		memset(&main_compose, 0, sizeof(main_compose));
+
+		main_compose.width = isp_sink_crop.width - padding_w;
+		main_compose.height =
+			DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
+				     f->fmt.pix.width);
+		if (main_compose.height > isp_sink_crop.height - padding_h) {
+			main_compose.height = isp_sink_crop.height - padding_h;
+			main_compose.width =
+				DIV_ROUND_UP(main_compose.height *
+					     f->fmt.pix.width,
+					     f->fmt.pix.height);
+		}
+
+		atomisp_subdev_set_selection(&isp_subdev->subdev, NULL,
+					     V4L2_SUBDEV_FORMAT_ACTIVE,
+					     ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+					     V4L2_SEL_TGT_COMPOSE, 0,
+					     &main_compose);
+	}
+
+	/* set format to isp */
+	ret = atomisp_set_fmt_to_isp(vdev, &output_info, &raw_output_info,
+				     f->fmt.pix.width, f->fmt.pix.height,
+				     f->fmt.pix.pixelformat, source_pad);
+	if (ret) {
+		trace_printk("atomisp_set_fmt_to_isp failed\n");
+		return -EINVAL;
+	}
+done:
+	pipe->pix.width = f->fmt.pix.width;
+	pipe->pix.height = f->fmt.pix.height;
+	pipe->pix.pixelformat = f->fmt.pix.pixelformat;
+	pipe->pix.bytesperline =
+		DIV_ROUND_UP(format_bridge->depth * output_info.padded_width,
+			     8);
+	pipe->pix.sizeimage =
+	    PAGE_ALIGN(f->fmt.pix.height * pipe->pix.bytesperline);
+	if (f->fmt.pix.field == V4L2_FIELD_ANY)
+		f->fmt.pix.field = V4L2_FIELD_NONE;
+	pipe->pix.field = f->fmt.pix.field;
+
+	f->fmt.pix = pipe->pix; /* TODO VERIFY?!?! Field we just set gets overwritten */
+	f->fmt.pix.priv = PAGE_ALIGN(pipe->pix.width *
+				     pipe->pix.height * 2);
+
+	//TODO update with f->fmt.pix.field ?
+
+	/*
+	 * If in video 480P case, no GFX throttle
+	 */
+	if (pipe->pipe_type == ATOMISP_PIPE_CAPTURE) {
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
+		    f->fmt.pix.width == 720 && f->fmt.pix.height == 480) {
+			isp->need_gfx_throttle = false;
+		}
+		else {
+			isp->need_gfx_throttle = true;
+		}
+	}
+	trace_printk("EXIT DMA atomisp_set_fmt\n");
+	return 0;
+}
+
+int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	enum ia_css_stream_format sh_input_format;
+	int ret = 0;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+				"Wrong v4l2 buf type for output\n");
+		return -EINVAL;
+	}
+
+	ret = atomisp_try_fmt_file(isp, f);
+	if (ret)
+		return ret;
+
+		pipe->pix = f->fmt.pix;
+	sh_input_format = get_sh_input_format(
+						pipe->pix.pixelformat);
+	if (sh_input_format == -EINVAL) {
+		v4l2_err(&atomisp_dev,
+				"Wrong v4l2 format for output\n");
+		return -EINVAL;
+	}
+
+	isp_subdev->css2_basis.stream_config.format = sh_input_format;
+	isp_subdev->css2_basis.stream_config.mode = IA_CSS_INPUT_MODE_FIFO;
+	isp_subdev->css2_basis.stream_config.bayer_order = 0; /* TODO set real value */
+	isp_subdev->css2_basis.stream_config.source.port.port = __get_mipi_port(ATOMISP_CAMERA_PORT_PRIMARY);
+	isp_subdev->css2_basis.stream_config.source.port.num_lanes = 2;
+	isp_subdev->css2_basis.stream_config.source.port.timeout = 0xffff4;
+	return 0;
+}
+
+void atomisp_free_all_shading_tables(struct atomisp_device *isp)
+{
+	int i;
+	
+	for (i = 0; i < isp->input_cnt; i++) {
+		if (isp->inputs[i].shading_table == NULL)
+			continue;
+		ia_css_shading_table_free(isp->inputs[i].shading_table);
+		isp->inputs[i].shading_table = NULL;
+	}
+}
+
+int atomisp_set_shading_table(struct atomisp_sub_device *isp_subdev,
+		struct atomisp_shading_table *user_shading_table)
+{
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_shading_table *free_table;
+	unsigned int len_table;
+	int i;
+	int ret = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (!user_shading_table)
+		return -EINVAL;
+
+	if (user_shading_table->flags & ATOMISP_SC_FLAG_QUERY) {
+		user_shading_table->enable = isp_subdev->params.sc_en;
+		return 0;
+	}
+
+	if (!user_shading_table->enable) {
+		isp_subdev->params.config.shading_table = NULL;
+		isp_subdev->params.sc_en = 0;
+		return 0;
+	}
+
+	/* If enabling, all tables must be set */
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (!user_shading_table->data[i])
+			return -EINVAL;
+	}
+
+	/* Shading table size per color */
+	if (user_shading_table->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
+	    user_shading_table->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
+		return -EINVAL;
+
+	shading_table = ia_css_shading_table_alloc(user_shading_table->width,
+						   user_shading_table->height);
+	if (!shading_table)
+		return -ENOMEM;
+
+	len_table = user_shading_table->width * user_shading_table->height *
+		    ATOMISP_SC_TYPE_SIZE;
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		ret = copy_from_user(shading_table->data[i],
+				     user_shading_table->data[i], len_table);
+		if (ret) {
+			free_table = shading_table;
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+	shading_table->sensor_width = user_shading_table->sensor_width;
+	shading_table->sensor_height = user_shading_table->sensor_height;
+	shading_table->fraction_bits = user_shading_table->fraction_bits;
+
+	free_table = isp->inputs[isp_subdev->input_curr].shading_table;
+	isp->inputs[isp_subdev->input_curr].shading_table = shading_table;
+	isp_subdev->params.config.shading_table = shading_table;
+	isp_subdev->params.sc_en = 1;
+
+out:
+	if (free_table != NULL)
+		ia_css_shading_table_free(free_table);
+
+	return ret;
+}
+
+/*Turn off ISP dphy */
+int atomisp_ospm_dphy_down(struct atomisp_device *isp)
+{
+	u32 pwr_cnt = 0;
+	int timeout = 100;
+	bool idle;
+	u32 reg;
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "%s\n", __func__);
+
+	/* if ISP timeout, we can force powerdown */
+	if (isp->isp_timeout)
+		goto done;
+
+	if (!atomisp_dev_users(isp))
+		goto done;
+
+	idle = sh_css_hrt_system_is_idle();
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "%s system_is_idle:%d\n", __func__, idle);
+	while (!idle && timeout--) {
+		udelay(20);
+		idle = sh_css_hrt_system_is_idle();
+	}
+
+	if (timeout < 0) {
+		v4l2_err(&atomisp_dev,
+			 "Timeout to stop ISP HW\n");
+		/* force power down here */
+	}
+
+done:
+	if (IS_MRFLD) {
+		/*
+		 * MRFLD IUNIT DPHY is located in an always-power-on island
+		 * MRFLD HW design need all CSI ports are disabled before
+		 * powering down the IUNIT.
+		 */
+		pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &reg);
+		reg |= MRFLD_ALL_CSI_PORTS_OFF_MASK;
+		pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, reg);
+	} else {
+		/* power down DPHY */
+		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
+							MFLD_CSI_CONTROL);
+		pwr_cnt |= 0x300;
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
+						MFLD_CSI_CONTROL, pwr_cnt);
+	}
+
+	isp->sw_contex.power_state = ATOM_ISP_POWER_DOWN;
+	return 0;
+}
+
+/*Turn on ISP dphy */
+int atomisp_ospm_dphy_up(struct atomisp_device *isp)
+{
+	u32 pwr_cnt = 0;
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "%s\n", __func__);
+
+	/* MRFLD IUNIT DPHY is located in an always-power-on island */
+	if (!IS_MRFLD) {
+		/* power on DPHY */
+		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
+							MFLD_CSI_CONTROL);
+		pwr_cnt &= ~0x300;
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
+						MFLD_CSI_CONTROL, pwr_cnt);
+	}
+
+	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
+
+	return 0;
+}
+
+
+int atomisp_exif_makernote(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_makernote_info *config)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_control ctrl;
+
+	ctrl.id = V4L2_CID_FOCAL_ABSOLUTE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				 core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev, "failed to g_ctrl for focal length\n");
+	else
+		config->focal_length = ctrl.value;
+
+	ctrl.id = V4L2_CID_FNUMBER_ABSOLUTE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev, "failed to g_ctrl for f-number\n");
+	else
+		config->f_number_curr = ctrl.value;
+
+	ctrl.id = V4L2_CID_FNUMBER_RANGE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev,
+				"failed to g_ctrl for f number range\n");
+	else
+		config->f_number_range = ctrl.value;
+
+	return 0;
+}
+
+int atomisp_offline_capture_configure(struct atomisp_sub_device *isp_subdev,
+			      struct atomisp_cont_capture_conf *cvf_config)
+{
+	isp_subdev->params.offline_parm = *cvf_config;
+	if (isp_subdev->params.offline_parm.num_captures) {
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_DISABLED) {
+			int num_raw_frames =
+				min_t(int, ATOMISP_CONT_RAW_FRAMES,
+				      isp_subdev->params.offline_parm.num_captures
+				      + 3);
+
+			ia_css_stream_set_buffer_depth(isp_subdev->css2_basis.stream,
+							num_raw_frames);
+		}
+
+		isp_subdev->params.continuous_vf = true;
+	} else {
+		isp_subdev->params.continuous_vf = false;
+		__enable_continuous_vf(isp_subdev, false);
+	}
+
+	return 0;
+}
+
+int atomisp_flash_enable(struct atomisp_sub_device *isp_subdev, int num_frames)
+{
+	if (num_frames < 0) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "%s ERROR: num_frames: %d\n", __func__, num_frames);
+		return -EINVAL;
+	}
+	/* a requested flash is still in progress. */
+	if (num_frames && isp_subdev->params.flash_state != ATOMISP_FLASH_IDLE) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "%s flash busy: %d frames left: %d\n",__func__,
+				isp_subdev->params.flash_state,
+				isp_subdev->params.num_flash_frames);
+		return -EBUSY;
+	}
+
+	isp_subdev->params.num_flash_frames = num_frames;
+	isp_subdev->params.flash_state = ATOMISP_FLASH_REQUESTED;
+	return 0;
+}
+
+/* Added msgbus functions */
+static DEFINE_SPINLOCK(msgbus_lock);
+
+static struct pci_dev *pci_root;
+
+int intel_mid_msgbus_init(void)
+{
+        pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+        if (!pci_root) {
+                printk(KERN_ALERT "%s: Error: msgbus PCI handle NULL", __func__);
+                return -ENODEV;
+        }
+        return 0;
+}
+
+u32 intel_mid_msgbus_read32_raw(u32 cmd)
+{
+        unsigned long irq_flags;
+        u32 data;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+
+void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
+{
+        unsigned long irq_flags;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
+
+u32 intel_mid_msgbus_read32(u8 port, u32 addr)
+{
+        unsigned long irq_flags;
+        u32 data;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
+                ((addr & 0xff) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+
+void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data)
+{
+        unsigned long irq_flags;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
+                ((addr & 0xFF) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
diff --git a/drivers/media/atomisp2/atomisp_cmd.h b/drivers/media/atomisp2/atomisp_cmd.h
new file mode 100644
index 0000000..253e67c
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_cmd.h
@@ -0,0 +1,334 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_CMD_H__
+#define	__ATOMISP_CMD_H__
+
+#include <linux/atomisp.h>
+#include <linux/interrupt.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-subdev.h>
+
+#include "atomisp_internal.h"
+#include "ia_css_types.h"
+#include "ia_css.h"
+
+struct atomisp_device;
+struct sh_css_frame;
+
+#define MSI_ENABLE_BIT		16
+#define INTR_DISABLE_BIT	10
+#define BUS_MASTER_ENABLE	2
+#define MEMORY_SPACE_ENABLE	1
+#define INTR_IER		24
+#define INTR_IIR		16
+
+/* Added pci variables */
+/*
+ * Access to message bus through these 2 registers
+ * in CUNIT(0:0:0) PCI configuration space.
+ * MSGBUS_CTRL_REG(0xD0):
+ *   31:24      = message bus opcode
+ *   23:16      = message bus port
+ *   15:8       = message bus address
+ *   7:4        = message bus byte enables
+ * MSGBUS_DTAT_REG(0xD4):
+ *   hold the data for write or read
+ */
+#define PCI_ROOT_MSGBUS_CTRL_REG        0xD0
+#define PCI_ROOT_MSGBUS_DATA_REG        0xD4
+#define PCI_ROOT_MSGBUS_CTRL_EXT_REG    0xD8
+#define PCI_ROOT_MSGBUS_READ            0x10
+#define PCI_ROOT_MSGBUS_WRITE           0x11
+#define PCI_ROOT_MSGBUS_DWORD_ENABLE    0xf0
+
+/*
+ * Helper function
+ */
+void dump_sp_dmem(unsigned int addr, unsigned int size);
+struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd);
+struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev);
+struct atomisp_sub_device *atomisp_to_sub_device(struct atomisp_video_pipe
+						 *atomisp_pipe);
+int atomisp_reset(struct atomisp_device *isp);
+bool atomisp_buffers_queued(struct atomisp_sub_device *isp_subdev);
+void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *isp_subdev);
+void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *isp_subdev);
+void atomisp_clear_frame_counters(struct atomisp_sub_device *isp_subdev);
+
+/* Added intel_mid_msgbus function declarations */
+int intel_mid_msgbus_init(void);
+extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
+extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
+extern u32 intel_mid_msgbus_read32(u8 port, u32 addr);
+extern void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+
+void *atomisp_kernel_malloc(size_t bytes);
+void atomisp_kernel_free(void *ptr);
+
+/*
+ * Interrupt functions
+ */
+void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev);
+void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev);
+void atomisp_wdt_work(struct work_struct *work);
+void atomisp_wdt(unsigned long isp_addr);
+void atomisp_setup_flash(struct atomisp_sub_device *isp_subdev);
+irqreturn_t atomisp_isr(int irq, void *dev);
+irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr);
+const struct atomisp_format_bridge *get_atomisp_format_bridge_from_mbus(
+	enum v4l2_mbus_pixelcode mbus_code);
+int atomisp_is_mbuscode_raw(uint32_t code);
+int atomisp_get_frame_pgnr(const struct ia_css_frame *frame, u32 *p_pgnr);
+void atomisp_delayed_init_work(struct work_struct *work);
+
+/*
+ * CSI-2 receiver configuration
+ */
+void atomisp_set_term_en_count(struct atomisp_device *isp);
+
+/*
+ * Get internal fmt according to V4L2 fmt
+ */
+
+bool atomisp_is_viewfinder_support(struct atomisp_sub_device *isp_subdev);
+
+/*
+ * ISP features control function
+ */
+
+/*
+ * Function to enable/disable lens geometry distortion correction (GDC) and
+ * chromatic aberration correction (CAC)
+ */
+int atomisp_gdc_cac(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to enable/disable low light mode (including ANR)
+ */
+int atomisp_low_light(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to enable/disable extra noise reduction (XNR) in low light
+ * condition
+ */
+int atomisp_xnr(struct atomisp_sub_device *isp_subdev, int flag, int *arg);
+
+/*
+ * Function to configure noise reduction
+ */
+int atomisp_nr(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_nr_config *config);
+
+/*
+ * Function to configure temporal noise reduction (TNR)
+ */
+int atomisp_tnr(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_tnr_config *config);
+
+/*
+ * Function to get histogram data for image frame
+ */
+int atomisp_histogram(struct atomisp_sub_device *isp_subdev,
+	int flag, void *config);
+
+/*
+ * Function to configure black level compensation
+ */
+int atomisp_black_level(struct atomisp_sub_device *isp_subdev, int flag,
+			struct atomisp_ob_config *config);
+
+/*
+ * Function to configure edge enhancement
+ */
+int atomisp_ee(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_ee_config *config);
+
+/*
+ * Function to update Gamma table for gamma, brightness and contrast config
+ */
+int atomisp_gamma(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_gamma_table *config);
+/*
+ * Function to update Ctc table for Chroma Enhancement
+ */
+int atomisp_ctc(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_ctc_table *config);
+
+/*
+ * Function to update gamma correction parameters
+ */
+int atomisp_gamma_correction(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_gc_config *config);
+
+/*
+ * Function to update Gdc table for gdc
+ */
+int atomisp_gdc_cac_table(struct atomisp_sub_device *isp_subdev, int flag,
+
+			  struct atomisp_morph_table *config);
+
+/*
+ * Function to update table for macc
+ */
+int atomisp_macc_table(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_macc_config *config);
+/*
+ * Function to get DIS statistics.
+ */
+int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_dis_statistics *stats);
+
+/*
+ * Function to set the DIS coefficients.
+ */
+int atomisp_set_dis_coefs(struct atomisp_sub_device *isp_subdev,
+			  struct atomisp_dis_coefficients *coefs);
+
+/*
+ * Function to set the DIS motion vector.
+ */
+int atomisp_set_dis_vector(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_dis_vector *vector);
+
+/*
+ * Function to set/get 3A stat from isp
+ */
+int atomisp_3a_stat(struct atomisp_sub_device *isp_subdev, int flag,
+		    struct atomisp_3a_statistics *config);
+
+int atomisp_set_parameters(struct atomisp_sub_device *isp_subdev,
+		struct atomisp_parameters *arg);
+
+/*
+ * Function to set/get isp parameters to isp
+ */
+int atomisp_param(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_parm *config);
+
+/*
+ * Function to configure color effect of the image
+ */
+int atomisp_color_effect(struct atomisp_sub_device *isp_subdev, int flag, __s32 *effect);
+
+/*
+ * Function to configure bad pixel correction
+ */
+int atomisp_bad_pixel(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value);
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_bad_pixel_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_dp_config *config);
+
+/*
+ * Function to enable/disable video image stablization
+ */
+int atomisp_video_stable(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure fixed pattern noise
+ */
+int atomisp_fixed_pattern(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure fixed pattern noise table
+ */
+int atomisp_fixed_pattern_table(struct atomisp_sub_device *isp_subdev,
+				struct v4l2_framebuffer *config);
+
+/*
+ * Function to configure vf overlay image
+ */
+int atomisp_vf_overlay(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_overlay *overlay);
+
+/*
+ * Function to configure false color correction
+ */
+int atomisp_false_color(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure false color correction params
+ */
+int atomisp_false_color_param(struct atomisp_sub_device *isp_subdev, int flag,
+			      struct atomisp_de_config *config);
+
+/*
+ * Function to configure white balance params
+ */
+int atomisp_white_balance_param(struct atomisp_sub_device *isp_subdev, int flag,
+				struct atomisp_wb_config *config);
+
+int atomisp_3a_config_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_3a_config *config);
+
+/*
+ * Function to enable/disable lens shading correction
+ */
+int atomisp_shading_correction(struct atomisp_sub_device *isp_subdev, int flag,
+				       __s32 *value);
+
+/*
+ * Function to setup digital zoom
+ */
+int atomisp_digital_zoom(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+int atomisp_get_sensor_mode_data(struct atomisp_sub_device *isp_subdev,
+				 struct atomisp_sensor_mode_data *config);
+
+int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f);
+
+
+/* This function looks up the closest available resolution. */
+int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
+						bool *res_overflow);
+
+int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f);
+int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f);
+
+void atomisp_free_all_shading_tables(struct atomisp_device *isp);
+int atomisp_set_shading_table(struct atomisp_sub_device *isp_subdev,
+			      struct atomisp_shading_table *shading_table);
+
+int atomisp_offline_capture_configure(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_cont_capture_conf *cvf_config);
+
+int atomisp_ospm_dphy_down(struct atomisp_device *isp);
+int atomisp_ospm_dphy_up(struct atomisp_device *isp);
+int atomisp_exif_makernote(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_makernote_info *config);
+
+void atomisp_free_internal_buffers(struct atomisp_sub_device *isp_subdev);
+void atomisp_free_3a_dvs_buffers(struct atomisp_sub_device *isp_subdev);
+
+int  atomisp_flash_enable(struct atomisp_sub_device *isp_subdev, int num_frames);
+
+int atomisp_freq_scaling(struct atomisp_device *vdev,
+			 enum atomisp_dfs_mode mode);
+
+void atomisp_ISP_parameters_clean_up(struct atomisp_sub_device *isp_subdev,
+ 				     struct ia_css_isp_config *config);
+#endif /* __ATOMISP_CMD_H__ */
diff --git a/drivers/media/atomisp2/atomisp_common.h b/drivers/media/atomisp2/atomisp_common.h
new file mode 100644
index 0000000..66de149
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_common.h
@@ -0,0 +1,80 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_COMMON_H__
+#define	__ATOMISP_COMMON_H__
+
+#include <linux/atomisp.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/videobuf2-core.h>
+
+#ifdef CSS_2
+#include "ia_css.h"
+#else
+#include "sh_css.h"
+#endif
+
+extern int dbg_level;
+extern int mipicsi_flag;
+extern int pad_w;
+extern int pad_h;
+
+extern int atomisp_pci_vendor;
+extern int atomisp_pci_device;
+
+#define MFLD_MAX_ZOOM_FACTOR	64
+
+#define MRFLD_MAX_ZOOM_FACTOR	1024
+
+#define IS_MRFLD ((atomisp_pci_device & 0xfff8) == 0x0F38)
+
+struct atomisp_format_bridge {
+	unsigned int pixelformat;
+	unsigned int depth;
+	enum v4l2_mbus_pixelcode mbus_code;
+	enum ia_css_frame_format sh_fmt;
+	unsigned char description[32];	/* the same as struct v4l2_fmtdesc */
+};
+
+struct atomisp_fmt {
+	u32 pixelformat;
+	u32 depth;
+	u32 bytesperline;
+	u32 framesize;
+	u32 imagesize;
+	u32 width;
+	u32 height;
+	u32 bayer_order;
+};
+
+struct atomisp_vb2 {
+	struct vb2_buffer vb; /* Must be first */
+	struct list_head list;
+	struct ia_css_frame *cssframe;
+};
+
+/*
+ * supported V4L2 fmts and resolutions
+ */
+extern struct v4l2_device atomisp_dev;
+#endif
diff --git a/drivers/media/atomisp2/atomisp_compat.c b/drivers/media/atomisp2/atomisp_compat.c
new file mode 100644
index 0000000..7e728e6
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_compat.c
@@ -0,0 +1,870 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css.h"
+#include "atomisp_internal.h"
+#include "atomisp_fops.h"
+#include "ia_css_types.h"
+
+#include <linux/delay.h>
+
+enum frame_info_type {
+	VF_FRAME,
+	OUTPUT_FRAME,
+	RAW_FRAME,
+};
+static inline
+enum ia_css_pipe_mode __pipe_id_to_pipe_mode(enum ia_css_pipe_id pipe_id)
+{
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		return IA_CSS_PIPE_MODE_PREVIEW;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		return IA_CSS_PIPE_MODE_CAPTURE;
+	case IA_CSS_PIPE_ID_VIDEO:
+		return IA_CSS_PIPE_MODE_VIDEO;
+	case IA_CSS_PIPE_ID_ACC:
+		return IA_CSS_PIPE_MODE_ACC;
+	default:
+		return IA_CSS_PIPE_MODE_NUM;
+	}
+
+}
+static void __apply_additional_pipe_config(struct atomisp_sub_device *isp_subdev)
+{
+	int i = 0;
+	for (i = 0; i< IA_CSS_PIPE_ID_NUM; i++) {
+		isp_subdev->css2_basis.pipe_configs[i].isp_pipe_version = 2;
+	}
+
+}
+static void __configure_output(struct atomisp_sub_device *isp_subdev,
+			       unsigned int width,
+			       unsigned int height,
+			       enum ia_css_frame_format format,
+			       enum ia_css_pipe_id pipe_id)
+{
+
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.width =
+	    width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.height =
+	    height;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.format =
+	    format;
+	if (width * height > isp_subdev->css2_basis.stream_config.effective_res.width *
+	    isp_subdev->css2_basis.stream_config.effective_res.height) {
+		isp_subdev->css2_basis.stream_config.effective_res.width = width;
+		isp_subdev->css2_basis.stream_config.effective_res.height = height;
+	}
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d] output info w=%d.h=%d.f=%d.\n",
+		 pipe_id, width, height, format);
+}
+static void __configure_pp_input(struct atomisp_sub_device *isp_subdev,
+				 unsigned int width,
+				 unsigned int height,
+				 enum ia_css_pipe_id pipe_id)
+{
+	if (width == 0 && height == 0)
+		return;
+
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	if (width <=
+	    isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.width ||
+	    height <=
+	    isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.height
+	   )
+		return;
+	isp_subdev->css2_basis.pipe_extra_configs[pipe_id].enable_yuv_ds = true;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].bayer_ds_out_res.width = width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].bayer_ds_out_res.height = height;
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
+		 pipe_id, width, height);
+}
+static void __configure_vf_output(struct atomisp_sub_device *isp_subdev,
+				  unsigned int width,
+				  unsigned int height,
+				  enum ia_css_frame_format format,
+				  enum ia_css_pipe_id pipe_id)
+{
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.res.width = width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.res.height = height;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.format = format;
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d] vf output info w=%d.h=%d.f=%d.\n",
+		 pipe_id, width, height, format);
+}
+
+enum ia_css_err __destroy_pipes(struct atomisp_sub_device *isp_subdev, bool force)
+{
+	int i;
+	enum ia_css_err ret = IA_CSS_SUCCESS;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (isp_subdev->css2_basis.stream) {
+		dev_dbg(isp->dev, "destroy css stream first.\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i]
+		    		&& (force || isp_subdev->css2_basis.update_pipe[i])) {
+			ret |= ia_css_pipe_destroy(isp_subdev->css2_basis.pipes[i]);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					 "destroy pipe[%d]failed.\
+					 cannot recover\n", i);
+			}
+			isp_subdev->css2_basis.pipes[i] = NULL;
+			isp_subdev->css2_basis.update_pipe[i] = false;
+		}
+	}
+	return ret;
+}
+
+static enum ia_css_err __create_pipe(struct atomisp_sub_device *isp_subdev)
+{
+
+	int i, j;
+	enum ia_css_err ret;
+	struct ia_css_pipe_extra_config extra_config;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s\n", __func__);
+	__apply_additional_pipe_config(isp_subdev);
+	ia_css_pipe_extra_config_defaults(&extra_config);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipe_configs[i].output_info.res.width) {
+			if (!memcmp(&extra_config,
+				    &isp_subdev->css2_basis.pipe_extra_configs[i],
+				    sizeof(extra_config)))
+				ret = ia_css_pipe_create(
+					&isp_subdev->css2_basis.pipe_configs[i],
+					&isp_subdev->css2_basis.pipes[i]);
+			else
+				ret = ia_css_pipe_create_extra(
+					&isp_subdev->css2_basis.pipe_configs[i],
+					&isp_subdev->css2_basis.pipe_extra_configs[i],
+					&isp_subdev->css2_basis.pipes[i]);
+			if (ret) {
+				v4l2_err(&atomisp_dev, "create pipe[%d] error.\n", i);
+				goto pipe_err;
+	}
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "dump pipe[%d] info w=%d, h=%d,f=%d vf_w=%d vf_h=%d vf_f=%d.\n",
+				 i,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.res.width,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.res.height,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.format,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.res.width,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.res.height,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.format);
+		}
+	}
+
+	return IA_CSS_SUCCESS;
+pipe_err:
+	for (j = i; j >= 0; j--)
+		if (isp_subdev->css2_basis.pipes[j]) {
+			ia_css_pipe_destroy(isp_subdev->css2_basis.pipes[j]);
+			isp_subdev->css2_basis.pipes[j] = NULL;
+}
+
+	return ret;
+}
+static void dump_stream_pipe_config(struct atomisp_sub_device *isp_subdev)
+{
+	struct ia_css_pipe_config *p_config;
+	struct ia_css_pipe_extra_config *pe_config;
+	struct ia_css_stream_config *s_config;
+	int i = 0;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i]) {
+			p_config = &isp_subdev->css2_basis.pipe_configs[i];
+			pe_config = &isp_subdev->css2_basis.pipe_extra_configs[i];
+			pr_info("dumping pipe[%d] config:\n", i);
+			pr_info("pipe_config.pipe_id:%d.\n", p_config->mode);
+	pr_info("pipe_config.output_info w=%d, h=%d.\n",
+	       p_config->output_info.res.width,
+	       p_config->output_info.res.height);
+	pr_info("pipe_config.vf_output_info w=%d, h=%d.\n",
+	       p_config->vf_output_info.res.width,
+	       p_config->vf_output_info.res.height);
+	pr_info("pipe_config.bayer_ds_out_res w=%d, h=%d.\n",
+	       p_config->bayer_ds_out_res.width,
+	       p_config->bayer_ds_out_res.height);
+			pr_info("pipe_config.envelope w=%d, h=%d.\n",
+				p_config->dvs_envelope.width,
+				p_config->dvs_envelope.height);
+	pr_info("pipe_config.default_capture_config.capture_mode=%d.\n",
+	       p_config->default_capture_config.mode);
+
+			pr_info("dumping pipe[%d] extra config:\n", i);
+			pr_info("pipe_extra_config.enable_raw_binning:%d.\n",
+				pe_config->enable_raw_binning);
+			pr_info("pipe_extra_config.enable_yuv_ds:%d.\n",
+				pe_config->enable_yuv_ds);
+			pr_info("pipe_extra_config.enable_high_speed:%d.\n",
+				pe_config->enable_high_speed);
+			pr_info("pipe_extra_config.enable_dvs_6axis:%d.\n",
+				pe_config->enable_dvs_6axis);
+			pr_info("pipe_extra_config.enable_reduced_pipe:%d.\n",
+				pe_config->enable_reduced_pipe);
+			pr_info("pipe_extra_config.enable_dz:%d.\n",
+				pe_config->enable_dz);
+			//pr_info("pipe_extra_config.isp_pipe_version:%d.\n",
+			//	pe_config->isp_pipe_version);
+			pr_info("pipe_extra_config.disable_vf_pp:%d.\n",
+				pe_config->disable_vf_pp);
+			pr_info("pipe_extra_config.disable_capture_pp:%d.\n",
+				pe_config->disable_capture_pp);
+		}
+	}
+
+	s_config = &isp_subdev->css2_basis.stream_config;
+	pr_info("dumping stream config:\n");
+	pr_info("stream_config.input_res w=%d, h=%d.\n",
+	       s_config->input_res.width,
+	       s_config->input_res.height);
+	pr_info("stream_config.effective_res w=%d, h=%d.\n",
+	       s_config->effective_res.width,
+	       s_config->effective_res.height);
+	pr_info("stream_config.format=%d.\n",
+	       s_config->format);
+	pr_info("stream_config.bayer_order=%d.\n",
+	       s_config->bayer_order);
+	pr_info("stream_config.2ppc=%d.\n",
+	       s_config->two_pixels_per_clock);
+	pr_info("stream_config.online=%d.\n",
+	       s_config->online);
+	pr_info("stream_config.continuous=%d.\n",
+	       s_config->continuous);
+}
+enum ia_css_err __destroy_stream(struct atomisp_sub_device *isp_subdev, bool force)
+{
+	int i;
+	enum ia_css_err ret;
+	bool pipe_updated = false;
+	unsigned int streaming;
+
+	if (!isp_subdev->css2_basis.stream)
+		return IA_CSS_SUCCESS;
+
+	if (!force) {
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			if (isp_subdev->css2_basis.update_pipe[i]) {
+				pipe_updated = true;
+				break;
+			}
+	}
+
+	if (!(force || pipe_updated))
+		return IA_CSS_SUCCESS;
+
+	streaming = atomisp_subdev_streaming_count(isp_subdev->isp);
+
+	if (isp_subdev->css2_basis.stream_state == CSS2_STREAM_STARTED
+	    && !streaming) { /* single stream mode */
+		ret = ia_css_stream_stop(isp_subdev->css2_basis.stream);
+		if (ret != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+				 "stop stream failed.\n");
+			return ret;
+		}
+	} else if (isp_subdev->css2_basis.stream_state == CSS2_STREAM_STARTED
+	    && streaming) { /* multi stream mode */
+		unsigned int cnt;
+			/* CSS2.0 bug:
+			 * 1: it requires no buffer in css buffer queue after
+			 * stream stop
+			 * 2: it does not provide the buffer queue flush
+			 * machenism
+			 *
+			 * If there are multiple buffers in css at the time
+			 * calling ia_css_stream_stop, there will buffers
+			 * remaining in css, which will be dequeued next time
+			 * stream start, which will causes serious mm issue
+			 * since buffers are already invalid.
+			 *
+			 * So before calling ia_css_stream stop, we will wait
+			 * until all the buffers are dequeued from css.
+			 *
+			 * Note that there would have big pnp impact to wait
+			 * all the buffers dequeued from css, so we will only do
+			 * this in multiple stream mode, since in single
+			 * stream mode, no care on whether buffer remain in
+			 * css, as the css will be un-initialized after it.
+			 */
+
+			/*
+			 * check whether there is other stream in streaming
+			 * state. if so, we need to to dequeue all the buffers
+			 * in this stream, and also need to workaround to avoid
+			 * sp stuck.
+			 */
+
+			mutex_unlock(&isp_subdev->isp->mutex);
+			if (!wait_for_completion_timeout(&isp_subdev->buf_done,
+							 2 * HZ)) {
+				dev_warn(isp_subdev->isp->dev,
+					 "%s: wait buf clean timeout!.\n",
+					 __func__);
+			}
+			mutex_lock(&isp_subdev->isp->mutex);
+
+			ret = ia_css_stream_stop(isp_subdev->css2_basis.stream);
+			if (ret != IA_CSS_SUCCESS) {
+				v4l2_err(&atomisp_dev,
+					"stop stream failed.\n");
+				return ret;
+			}
+
+			/*
+			 * There is another issue if there is no buffer
+			 * remaining in css after calling ia_css_stream_stop:
+			 * the SP will get stuck, because it is blocking on
+			 * the empty queue. So after calling
+			 * ia_css_stream_stop(), we will queue only 1 buffer
+			 * to css to recover sp, then wait for
+			 * ia_css_stream_has_stopped(). The css will process the
+			 * final buffer and exit gracefully.
+			 */
+			/* queue 1 buffer to css to recover sp */
+			atomisp_qbuffers_to_css(isp_subdev, true);
+			cnt = 50;
+			/* wait for some time for stream stop */
+			while (--cnt) {
+				mutex_unlock(&isp_subdev->isp->mutex);
+				msleep(20);
+				mutex_lock(&isp_subdev->isp->mutex);
+				if (ia_css_stream_has_stopped(
+						isp_subdev->css2_basis.stream))
+					break;
+			}
+			if (!cnt)
+				dev_warn(isp_subdev->isp->dev,
+					 "%s: wait stream off timeout!.\n",
+					 __func__);
+
+ 		}
+
+		if ((ret = ia_css_stream_destroy(isp_subdev->css2_basis.stream))
+		    				!= IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+				  "destroy stream failed.\n");
+			return ret;
+		}
+		isp_subdev->css2_basis.stream = NULL;
+
+	return IA_CSS_SUCCESS;
+}
+
+void
+ia_css_input_set_mode(struct atomisp_sub_device *isp_subdev,
+		      enum ia_css_input_mode mode)
+{
+	isp_subdev->css2_basis.stream_config.mode = mode;
+	if (mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			ia_css_mipi_frame_specify(0x60000, false);
+	}
+}
+
+enum ia_css_input_mode get_input_mode(unsigned int input_type)
+{
+	if (input_type != TEST_PATTERN
+		&& input_type != FILE_INPUT) 
+		return IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+	else if(input_type == FILE_INPUT)
+		return IA_CSS_INPUT_MODE_FIFO;
+	else if(input_type == TEST_PATTERN)
+		return IA_CSS_INPUT_MODE_TPG;
+	return -1;
+}
+
+static enum ia_css_err __create_stream(struct atomisp_sub_device *isp_subdev)
+{
+	int pipe_index = 0, i;
+	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
+	const struct ia_css_stream_config *s_config =
+	    		&isp_subdev->css2_basis.stream_config;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 ">%s.\n", __func__);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i])
+			multi_pipes[pipe_index++] = isp_subdev->css2_basis.pipes[i];
+	}
+	
+	ia_css_input_set_mode(isp_subdev,
+			get_input_mode(isp_subdev->isp->inputs[isp_subdev->input_curr].type));
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "<%s.\n", __func__);
+	dump_stream_pipe_config(isp_subdev);
+	return ia_css_stream_create(s_config, pipe_index, multi_pipes,
+				    &isp_subdev->css2_basis.stream);
+}
+
+enum ia_css_err ia_css_update_stream(struct atomisp_sub_device *isp_subdev)
+{
+	enum ia_css_err ret;
+
+	if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp_subdev->isp->dev, "destroy stream failed.\n");
+
+	if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp_subdev->isp->dev, "destroy pipe failed.\n");
+
+	ret = __create_pipe(isp_subdev);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_err(isp_subdev->isp->dev, "create pipe failed.\n");
+		return ret;
+	}
+
+	ret = __create_stream(isp_subdev);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_warn(isp_subdev->isp->dev, "create stream failed.\n");
+		__destroy_pipes(isp_subdev, true);
+		return ret;
+	}
+
+	return ret;
+}
+
+static enum ia_css_err __get_frame_info(struct atomisp_sub_device *isp_subdev,
+				struct ia_css_frame_info *info,
+				enum frame_info_type type)
+{
+	enum ia_css_err ret;
+	struct ia_css_pipe_info p_info;
+	unsigned int pipe_id = isp_subdev->css2_basis.curr_pipe;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 ">%s.\n", __func__);
+
+	if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp->dev, "destroy stream failed.\n");
+
+	if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp->dev, "destroy pipe failed.\n");
+
+		if((ret = __create_pipe(isp_subdev)) != IA_CSS_SUCCESS)
+		goto pipe_err;
+
+		if((ret = __create_stream(isp_subdev)) != IA_CSS_SUCCESS)
+			goto stream_err;
+
+	ret = ia_css_pipe_get_info(
+			isp_subdev->css2_basis.pipes[pipe_id], &p_info);
+	if (ret == IA_CSS_SUCCESS) {
+		switch (type) {
+		case VF_FRAME:
+			*info = p_info.vf_output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting vf frame info.\n");
+			break;
+		case OUTPUT_FRAME:
+			*info = p_info.output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting main frame info.\n");
+			break;
+		case RAW_FRAME:
+			*info = p_info.raw_output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting raw frame info.\n");
+			break;
+		default:
+			info = NULL;
+			v4l2_err(&atomisp_dev,
+				  "wrong type for getting frame info");
+		}
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "get frame info: w=%d, h=%d.\n",
+			 	info->res.width, info->res.height);
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "<%s.\n", __func__);
+		return IA_CSS_SUCCESS;
+	}
+
+stream_err:
+	__destroy_pipes(isp_subdev, true);
+pipe_err:
+
+	return ret;
+}
+
+enum ia_css_err ia_css_preview_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_PREVIEW);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_preview_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_PREVIEW;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_capture_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format,
+			   IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_capture_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_vf_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	__get_frame_info(isp_subdev, info, VF_FRAME);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format,
+			   IA_CSS_PIPE_ID_VIDEO);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_VIDEO;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_video_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_vf_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_VIDEO);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_VIDEO;
+	return __get_frame_info(isp_subdev, info, VF_FRAME);
+}
+
+enum ia_css_err ia_css_preview_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height)
+{
+		__configure_pp_input(isp_subdev, width, height, IA_CSS_PIPE_ID_PREVIEW);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height)
+{
+	__configure_pp_input(isp_subdev, width, height, IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+void
+ia_css_capture_set_mode(struct atomisp_sub_device *isp_subdev,
+			enum ia_css_capture_mode mode)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	if (isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_CAPTURE].default_capture_config.mode != mode) {
+		isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_CAPTURE].default_capture_config.mode = mode;
+		isp_subdev->css2_basis.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
+	}
+}
+
+void
+ia_css_capture_enable_online(struct atomisp_sub_device *isp_subdev,
+			     bool enable)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	if (isp_subdev->css2_basis.stream_config.online != enable) {
+		isp_subdev->css2_basis.stream_config.online = enable;
+		isp_subdev->css2_basis.update_pipe[IA_CSS_PIPE_ID_CAPTURE] =
+		    true;
+	}
+}
+
+void
+ia_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *isp_subdev,
+					   bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.two_pixels_per_clock !=
+	    enable) {
+		isp_subdev->css2_basis.stream_config.two_pixels_per_clock =
+		    enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+
+void
+ia_css_enable_raw_binning(struct atomisp_sub_device *isp_subdev,
+			     bool enable)
+{
+	int i;
+	
+	for(i=0;i<IA_CSS_PIPE_ID_NUM;i++) {
+		if(isp_subdev->css2_basis.pipe_extra_configs[i].enable_raw_binning != enable) {
+			isp_subdev->css2_basis.pipe_extra_configs[i].enable_raw_binning = enable;
+			isp_subdev->css2_basis.update_pipe[i] = true;
+		}
+	}
+}
+
+void ia_css_enable_continuous(struct atomisp_sub_device *isp_subdev,
+				  bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.continuous != enable) {
+		isp_subdev->css2_basis.stream_config.continuous = enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+
+void ia_css_preview_enable_online(struct atomisp_sub_device *isp_subdev,
+				  bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.online != enable) {
+		isp_subdev->css2_basis.stream_config.online = enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+
+enum ia_css_err ia_css_capture_get_output_raw_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	return __get_frame_info(isp_subdev, info, RAW_FRAME);
+}
+
+void atomisp_sh_css_mmu_set_page_table_base_index(unsigned int base_index)
+{
+#ifndef CSS_2
+	sh_css_mmu_set_page_table_base_index((hrt_data) base_index);
+#endif
+}
+enum ia_css_err ia_css_start(struct atomisp_sub_device *isp_subdev, bool in_reset)
+{
+	enum ia_css_err ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (in_reset) {
+		if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+			dev_warn(isp->dev, "destroy stream failed.\n");
+
+		if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+			dev_warn(isp->dev, "destroy pipe failed.\n");
+
+		if ((ret = __create_pipe(isp_subdev)) != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "create pipe error.\n");
+			goto pipe_err;
+		}
+		if ((ret = __create_stream(isp_subdev)) != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "create stream error.\n");
+			goto stream_err;
+		}
+	}
+
+	/*
+	 * SP can only be started one time
+	 * if atomisp_subdev_streaming_count() tell there aleady has some subdev
+	 * at streamming, then SP should already be started previously, so
+	 * need to skip start sp procedure
+	 */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)) {
+		dev_dbg(isp_subdev->isp->dev, "skip start sp.\n");
+	} else {
+		ret = ia_css_start_sp();
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp_subdev->isp->dev, "start sp error.\n");
+			goto start_err;
+		}
+ 	}
+
+	if ((ret = ia_css_stream_start(isp_subdev->css2_basis.stream)) !=
+	    				IA_CSS_SUCCESS) {
+		v4l2_err(&atomisp_dev, "stream start error.\n");
+		goto start_err;
+	}
+
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_STARTED;
+	return IA_CSS_SUCCESS;
+
+start_err:
+	__destroy_stream(isp_subdev, true);
+stream_err:
+	__destroy_pipes(isp_subdev, true);
+
+	/* css 2.0 API limitation: ia_css_stop_sp() could be only called after
+	 * destroy all pipes
+	 * */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)){
+			v4l2_dbg(3, dbg_level, &atomisp_dev, "can not stop sp.\n");
+	} else if(ia_css_isp_has_started())
+		if(ia_css_stop_sp() != IA_CSS_SUCCESS)
+			v4l2_warn(&atomisp_dev, "stop sp failed\n");
+pipe_err:
+	return ret;
+}
+enum ia_css_err ia_css_stop(struct atomisp_sub_device *isp_subdev, bool in_reset)
+{
+	int i = 0;
+	enum ia_css_err ret = IA_CSS_SUCCESS;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	/* if is called in atomisp_reset(), force destroy stream */
+	if ((ret = __destroy_stream(isp_subdev, true)) != IA_CSS_SUCCESS) {
+		v4l2_err(&atomisp_dev, "destroy stream failed.\n");
+		goto err;
+	}
+	/* if is called in atomisp_reset(), force destroy all pipes */
+	if (!atomisp_subdev_streaming_count(isp))
+	{
+		for(i = 0; i < isp->num_of_streams; i++)
+		{
+			if ((ret = __destroy_pipes(&isp->isp_subdev[i], true)) != IA_CSS_SUCCESS) 		{
+				v4l2_err(&atomisp_dev, "destroy pipes failed.\n");
+				goto err;
+			}
+		}
+	}
+
+	/*
+	 * SP can not be stopped if other streams are still running
+	 * if atomisp_subdev_streaming_count() tell there aleady has some subdev
+	 * at streamming, then SP can not be stopped, so
+	 * need to skip start sp procedure
+	 */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)) {
+		v4l2_info(&atomisp_dev, "skip stop sp.\n");
+	} else if (ia_css_isp_has_started()) {
+		if (ia_css_stop_sp() != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "stop sp failed.\n");
+			goto err;
+		}
+	}
+
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_STOPPED;
+
+	/* FIXME: Current code would cause streamon, then streamoff failed
+	 * If configs are not cleared, it would create wrong pipe/stream in
+	 * set format. No better solution has found yet.*/
+	if (!in_reset) {
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+			ia_css_pipe_config_defaults(&isp_subdev->css2_basis.pipe_configs[i]);
+			ia_css_pipe_extra_config_defaults(
+						&isp_subdev->css2_basis.pipe_extra_configs[i]);
+		}
+		ia_css_stream_config_defaults(&isp_subdev->css2_basis.stream_config);
+	}
+
+	return IA_CSS_SUCCESS;
+
+err:
+	v4l2_err(&atomisp_dev, "stop css fatal error. cannot recover\n");
+	return ret;
+}
+
+void
+ia_css_disable_vf_pp(struct atomisp_sub_device *isp_subdev, bool disable)
+{
+	int i;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		isp_subdev->css2_basis.pipe_extra_configs[i].disable_vf_pp
+    							= !!disable;
+}
+
+void
+ia_css_enable_high_speed(struct atomisp_sub_device *isp_subdev, bool enable)
+{
+	int i;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		isp_subdev->css2_basis.pipe_extra_configs[i].enable_high_speed
+							= enable;
+}
+
+
diff --git a/drivers/media/atomisp2/atomisp_compat.h b/drivers/media/atomisp2/atomisp_compat.h
new file mode 100644
index 0000000..fc66390
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_compat.h
@@ -0,0 +1,129 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css.h"
+#include "sh_css_sp.h"
+
+#define ia_css_sp_has_booted() ia_css_sp_has_initialized()
+
+//static inline enum sh_css_err sh_css_allocate_continuous_frames(bool enable)
+//{
+	//return sh_css_err_unsupported_configuration;
+//}
+enum ia_css_err ia_css_preview_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_preview_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_capture_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_capture_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_capture_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_capture_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_video_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_video_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_video_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_video_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_preview_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height);
+
+enum ia_css_err ia_css_capture_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height);
+void
+ia_css_capture_set_mode(struct atomisp_sub_device *isp_subdev,
+			enum ia_css_capture_mode mode);
+
+void
+ia_css_capture_enable_online(struct atomisp_sub_device *isp_subdev,
+			     bool enable);
+
+void
+ia_css_enable_raw_binning(struct atomisp_sub_device *isp_subdev,
+			     bool enable);
+void
+ia_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *isp_subdev,
+					   bool enable);
+
+void ia_css_preview_enable_online(struct atomisp_sub_device *isp_subdev,
+				  bool enable);
+void ia_css_enable_continuous(struct atomisp_sub_device *isp_subdev,
+				  bool enable);
+enum ia_css_err ia_css_capture_get_output_raw_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+void atomisp_sh_css_mmu_set_page_table_base_index(unsigned int base_index);
+enum ia_css_err ia_css_stop(struct atomisp_sub_device *isp_subdev, bool need_reset);
+enum ia_css_err ia_css_start(struct atomisp_sub_device *isp_subdev, bool need_reset);
+void ia_css_disable_vf_pp(struct atomisp_sub_device *isp_subdev, bool disable);
+
+void
+ia_css_input_set_mode(struct atomisp_sub_device *isp_subdev,
+		      enum ia_css_input_mode mode);
+
+enum ia_css_err __destroy_stream(struct atomisp_sub_device *isp_subdev, bool force);
+
+enum ia_css_err __destroy_pipes(struct atomisp_sub_device *isp_subdev, bool force);
+
+enum ia_css_input_mode get_input_mode(unsigned int input_type);
+
+enum ia_css_err ia_css_update_stream(struct atomisp_sub_device *isp_subdev);
+
diff --git a/drivers/media/atomisp2/atomisp_csi2.c b/drivers/media/atomisp2/atomisp_csi2.c
new file mode 100644
index 0000000..d176f98
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_csi2.c
@@ -0,0 +1,387 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_internal.h"
+
+static const unsigned int csi2_input_fmts[] = {
+	V4L2_MBUS_FMT_SGRBG10_1X10,
+	V4L2_MBUS_FMT_SRGGB10_1X10,
+	V4L2_MBUS_FMT_SBGGR10_1X10,
+	V4L2_MBUS_FMT_SGBRG10_1X10,
+};
+
+static const unsigned int csi2_output_fmts[] = {
+	V4L2_MBUS_FMT_SGRBG10_1X10,
+	V4L2_MBUS_FMT_SRGGB10_1X10,
+	V4L2_MBUS_FMT_SBGGR10_1X10,
+	V4L2_MBUS_FMT_SGBRG10_1X10,
+};
+
+
+/* V4L2 subdev operations */
+
+static struct v4l2_mbus_framefmt *
+__csi2_get_format(struct atomisp_mipi_csi2_device *csi2,
+		struct v4l2_subdev_fh *fh,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+	else
+		return &csi2->formats[pad];
+}
+
+static enum v4l2_mbus_pixelcode
+isp_video_uncompressed_code(enum v4l2_mbus_pixelcode code)
+{
+	switch (code) {
+	case V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8:
+		return V4L2_MBUS_FMT_SBGGR10_1X10;
+	case V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:
+		return V4L2_MBUS_FMT_SGRBG10_1X10;
+	case V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8:
+		return V4L2_MBUS_FMT_SRGGB10_1X10;
+	case V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8:
+		return V4L2_MBUS_FMT_SGBRG10_1X10;
+	default:
+		return code;
+	}
+}
+
+static void
+csi2_try_format(struct atomisp_mipi_csi2_device *csi2,
+	struct v4l2_subdev_fh *fh,
+	unsigned int pad,
+	struct v4l2_mbus_framefmt *fmt,
+	enum v4l2_subdev_format_whence which)
+{
+	enum v4l2_mbus_pixelcode pixelcode;
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	switch (pad) {
+	case CSI2_PAD_SINK:
+		/* Clamp the width and height to valid range (1-8191). */
+		for (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {
+			if (fmt->code == csi2_input_fmts[i])
+				break;
+		}
+
+		/* If not found, use SGRBG10 as default */
+		if (i >= ARRAY_SIZE(csi2_input_fmts))
+			fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+		fmt->width = clamp_t(u32, fmt->width, 1, 4608);
+		fmt->height = clamp_t(u32, fmt->height, 1, 8191);
+		break;
+
+	case CSI2_PAD_SOURCE:
+		/* Source format same as sink format, except for DPCM
+		 * compression.
+		 */
+		pixelcode = fmt->code;
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SINK, which);
+		memcpy(fmt, format, sizeof(*fmt));
+
+		/* allow dpcm decompression */
+		if (isp_video_uncompressed_code(fmt->code) == pixelcode)
+			fmt->code = pixelcode;
+
+		break;
+
+	default:
+		break;
+	}
+
+	/* RGB, non-interlaced */
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+/*
+ * csi2_enum_mbus_code - Handle pixel format enumeration
+ * @sd     : pointer to v4l2 subdev structure
+ * @fh     : V4L2 subdev file handle
+ * @code   : pointer to v4l2_subdev_pad_mbus_code_enum structure
+ * return -EINVAL or zero on success
+*/
+static int csi2_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->pad == CSI2_PAD_SINK) {
+		if (code->index >= ARRAY_SIZE(csi2_input_fmts))
+			return -EINVAL;
+		code->code = csi2_input_fmts[code->index];
+	} else {
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SINK,
+			V4L2_SUBDEV_FORMAT_TRY);
+		switch (code->index) {
+		case 0:
+			/* Passthrough sink pad code */
+			code->code = format->code;
+			break;
+		case 1:
+			/* Uncompressed code */
+			code->code = isp_video_uncompressed_code(format->code);
+			break;
+		default:
+			/* Fallthrough if above is false */
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * csi2_get_format - Handle get format by pads subdev method
+ * @sd : pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @pad: pad num
+ * @fmt: pointer to v4l2 format structure
+ * return -EINVAL or zero on sucess
+*/
+static int csi2_get_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+/*
+ * csi2_set_format - Handle set format by pads subdev method
+ * @sd : pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @pad: pad num
+ * @fmt: pointer to v4l2 format structure
+ * return -EINVAL or zero on success
+*/
+static int csi2_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		    struct v4l2_subdev_format *fmt)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	csi2_try_format(csi2, fh, fmt->pad, &fmt->format, fmt->which);
+	*format = fmt->format;
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == CSI2_PAD_SINK) {
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SOURCE,
+			fmt->which);
+		*format = fmt->format;
+		csi2_try_format(csi2, fh, CSI2_PAD_SOURCE, format, fmt->which);
+	}
+
+	return 0;
+}
+
+/*
+ * csi2_set_stream - Enable/Disable streaming on the CSI2 module
+ * @sd: ISP CSI2 V4L2 subdevice
+ * @enable: Enable/disable stream (1/0)
+ *
+ * Return 0 on success or a negative error code otherwise.
+*/
+static int csi2_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	 return 0;
+}
+
+/* subdev core operations */
+static const struct v4l2_subdev_core_ops csi2_core_ops = {
+	.queryctrl = v4l2_subdev_queryctrl,
+	.querymenu = v4l2_subdev_querymenu,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.g_ext_ctrls = v4l2_subdev_g_ext_ctrls,
+	.try_ext_ctrls = v4l2_subdev_try_ext_ctrls,
+	.s_ext_ctrls = v4l2_subdev_s_ext_ctrls,
+};
+
+/* subdev video operations */
+static const struct v4l2_subdev_video_ops csi2_video_ops = {
+	.s_stream = csi2_set_stream,
+};
+
+/* subdev pad operations */
+static const struct v4l2_subdev_pad_ops csi2_pad_ops = {
+	.enum_mbus_code = csi2_enum_mbus_code,
+	.get_fmt = csi2_get_format,
+	.set_fmt = csi2_set_format,
+};
+
+/* subdev operations */
+static const struct v4l2_subdev_ops csi2_ops = {
+	.core = &csi2_core_ops,
+	.video = &csi2_video_ops,
+	.pad = &csi2_pad_ops,
+};
+
+
+/*
+ * csi2_link_setup - Setup CSI2 connections.
+ * @entity : Pointer to media entity structure
+ * @local  : Pointer to local pad array
+ * @remote : Pointer to remote pad array
+ * @flags  : Link flags
+ * return -EINVAL or zero on success
+*/
+static int csi2_link_setup(struct media_entity *entity,
+	    const struct media_pad *local,
+	    const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	u32 result = local->index | media_entity_type(remote->entity);
+
+	switch (result) {
+	case CSI2_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:
+		/* not supported yet */
+		return -EINVAL;
+
+	case CSI2_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (csi2->output & ~CSI2_OUTPUT_ISP_SUBDEV)
+				return -EBUSY;
+			csi2->output |= CSI2_OUTPUT_ISP_SUBDEV;
+		} else {
+			csi2->output &= ~CSI2_OUTPUT_ISP_SUBDEV;
+		}
+		break;
+
+	default:
+		/* Link from camera to CSI2 is fixed... */
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* media operations */
+static const struct media_entity_operations csi2_media_ops = {
+	.link_setup = csi2_link_setup,
+};
+
+/*
+* ispcsi2_init_entities - Initialize subdev and media entity.
+* @csi2: Pointer to ispcsi2 structure.
+* return -ENOMEM or zero on success
+*/
+static int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,
+					int port)
+{
+	struct v4l2_subdev *sd = &csi2->subdev;
+	struct media_pad *pads = csi2->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	v4l2_subdev_init(sd, &csi2_ops);
+	snprintf(sd->name, sizeof(sd->name), "ATOM ISP CSI2-port%d", port);
+
+	v4l2_set_subdevdata(sd, csi2);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &csi2_media_ops;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+	ret = media_entity_init(me, CSI2_PADS_NUM, pads, 0);
+	if (ret < 0)
+		return ret;
+
+	csi2->formats[CSI2_PAD_SINK].code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	csi2->formats[CSI2_PAD_SOURCE].code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+void
+atomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)
+{
+	media_entity_cleanup(&csi2->subdev.entity);
+	v4l2_device_unregister_subdev(&csi2->subdev);
+}
+
+int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
+			struct v4l2_device *vdev)
+{
+	int ret;
+
+	/* Register the subdev and video nodes. */
+	ret = v4l2_device_register_subdev(vdev, &csi2->subdev);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_mipi_csi2_unregister_entities(csi2);
+	return ret;
+}
+
+/*
+ * atomisp_mipi_csi2_cleanup - Routine for module driver cleanup
+*/
+void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp)
+{
+}
+
+
+int atomisp_mipi_csi2_init(struct atomisp_device *isp)
+{
+	struct atomisp_mipi_csi2_device *csi2_port;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		csi2_port = &isp->csi2_port[i];
+		csi2_port->isp = isp;
+		ret = mipi_csi2_init_entities(csi2_port, i);
+		if (ret < 0)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	atomisp_mipi_csi2_cleanup(isp);
+	return ret;
+}
+
diff --git a/drivers/media/atomisp2/atomisp_csi2.h b/drivers/media/atomisp2/atomisp_csi2.h
new file mode 100644
index 0000000..42ff5bb
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_csi2.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_CSI2_H__
+#define __ATOMISP_CSI2_H__
+
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+
+#define CSI2_PAD_SINK		0
+#define CSI2_PAD_SOURCE		1
+#define CSI2_PADS_NUM		2
+
+#define CSI2_OUTPUT_ISP_SUBDEV	(1 << 0)
+#define CSI2_OUTPUT_MEMORY	(1 << 1)
+
+struct atomisp_device;
+struct v4l2_device;
+
+struct atomisp_mipi_csi2_device {
+	struct v4l2_subdev subdev;
+	struct media_pad pads[CSI2_PADS_NUM];
+	struct v4l2_mbus_framefmt formats[CSI2_PADS_NUM];
+
+	struct v4l2_ctrl_handler ctrls;
+	struct atomisp_device *isp;
+
+	u32 output; /* output direction */
+};
+
+int atomisp_mipi_csi2_init(struct atomisp_device *isp);
+void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp);
+void atomisp_mipi_csi2_unregister_entities(
+					struct atomisp_mipi_csi2_device *csi2);
+int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
+			struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_CSI2_H__ */
diff --git a/drivers/media/atomisp2/atomisp_file.c b/drivers/media/atomisp2/atomisp_file.c
new file mode 100644
index 0000000..14ecd02
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_file.c
@@ -0,0 +1,351 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+
+#include <linux/delay.h>
+
+#include <ia_css.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_file.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+
+static void file_work(struct work_struct *work)
+{
+	struct atomisp_file_device *file_dev = container_of(work,
+					struct atomisp_file_device, work_thread);
+	struct atomisp_device *isp = file_dev->isp;
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	struct atomisp_video_pipe *out_pipe = &isp_subdev->video_in;
+	unsigned short *buf = NULL;
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
+		return;
+
+	dev_dbg(isp->dev, ">%s: ready to start streaming\n", __func__);
+	isp_sink_fmt = *atomisp_subdev_get_ffmt(&isp_subdev->subdev, NULL,
+						V4L2_SUBDEV_FORMAT_ACTIVE,
+						ATOMISP_SUBDEV_PAD_SINK);
+	while (1) {
+		wait_for_completion(&file_dev->file_inject_start);
+		INIT_COMPLETION(file_dev->file_inject_start);
+
+		if (out_pipe->vb2outq.bufs[file_dev->framecount] == NULL)
+			file_dev->framecount = 0;
+		buf = vb2_plane_vaddr(out_pipe->vb2outq.bufs[file_dev->framecount], 0);
+		file_dev->framecount++;
+
+		if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED || !file_dev->fStreaming)
+			return;
+	
+		while (!ia_css_isp_has_started())
+			usleep_range(1000, 1500);
+
+		ia_css_stream_send_input_frame(isp_subdev->css2_basis.stream,
+				       buf, isp_sink_fmt.width, isp_sink_fmt.height);
+	}
+
+	dev_dbg(isp->dev, "<%s: streaming done\n", __func__);
+}
+
+static int file_input_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = file_dev->isp;
+
+	dev_dbg(isp->dev, "%s: enable %d\n", __func__, enable);
+	if (enable) {
+		if (isp->isp_subdev[0].streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
+			return 0;
+
+		if (!file_dev->fWork_queued) {
+			queue_work(file_dev->work_queue, &file_dev->work_thread);
+			file_dev->fWork_queued = true;
+		}
+
+		file_dev->fStreaming = true;
+		complete(&file_dev->file_inject_start);
+	} else {
+		if (!file_dev->fWork_queued)
+			return 0;
+
+		file_dev->fStreaming = false;
+		complete(&file_dev->file_inject_start);
+		cancel_work_sync(&file_dev->work_thread);
+		file_dev->fWork_queued = false;
+	}
+	return 0;
+}
+
+static int file_input_g_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_s_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = file_dev->isp;
+	struct v4l2_mbus_framefmt *isp_sink_fmt;
+
+	isp_sink_fmt = atomisp_subdev_get_ffmt(&isp->isp_subdev[0].subdev, NULL,
+					       V4L2_SUBDEV_FORMAT_ACTIVE,
+					       ATOMISP_SUBDEV_PAD_SINK);
+
+	fmt->width = isp_sink_fmt->width;
+	fmt->height = isp_sink_fmt->height;
+	trace_printk("WARNING: in file_input_g_mbus_fmt, overwriting MBUS FMT to FIXED!!!. %dx%d\n", fmt->width, fmt->height);
+	fmt->code = isp_sink_fmt->code; //TODO set right code
+
+	return 0;
+}
+
+static int file_input_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+        struct atomisp_device *isp = file_dev->isp;
+
+	file_input_g_mbus_fmt(sd, fmt);
+	isp->isp_subdev[0].css2_basis.stream_config.mode = IA_CSS_INPUT_MODE_FIFO;
+	return 0;
+}
+
+static int file_input_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	if (!chip)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int file_input_log_status(struct v4l2_subdev *sd)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int file_input_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int file_input_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_s_power(struct v4l2_subdev *sd, int on)
+{
+	/* to fake */
+	return 0;
+}
+
+static int file_input_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frame_ival(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	/*to fake*/
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops file_input_video_ops = {
+	.s_stream = file_input_s_stream,
+	.g_parm = file_input_g_parm,
+	.s_parm = file_input_s_parm,
+	.enum_framesizes = file_input_enum_framesizes,
+	.enum_frameintervals = file_input_enum_frameintervals,
+	.enum_mbus_fmt = file_input_enum_mbus_fmt,
+	.try_mbus_fmt = file_input_g_mbus_fmt,
+	.g_mbus_fmt = file_input_g_mbus_fmt,
+	.s_mbus_fmt = file_input_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_core_ops file_input_core_ops = {
+	.g_chip_ident = file_input_g_chip_ident,
+	.log_status = file_input_log_status,
+	.queryctrl = file_input_queryctrl,
+	.g_ctrl = file_input_g_ctrl,
+	.s_ctrl = file_input_s_ctrl,
+	.s_power = file_input_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops file_input_pad_ops = {
+	.enum_mbus_code = file_input_enum_mbus_code,
+	.enum_frame_size = file_input_enum_frame_size,
+	.enum_frame_interval = file_input_enum_frame_ival,
+};
+
+static const struct v4l2_subdev_ops file_input_ops = {
+	.core = &file_input_core_ops,
+	.video = &file_input_video_ops,
+	.pad = &file_input_pad_ops,
+};
+
+void
+atomisp_file_input_unregister_entities(struct atomisp_file_device *file_dev)
+{
+	media_entity_cleanup(&file_dev->sd.entity);
+	v4l2_device_unregister_subdev(&file_dev->sd);
+}
+
+int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
+			struct v4l2_device *vdev)
+{
+	/* Register the subdev and video nodes. */
+	return  v4l2_device_register_subdev(vdev, &file_dev->sd);
+}
+
+void atomisp_file_input_cleanup(struct atomisp_device *isp)
+{
+	struct atomisp_file_device *file_dev = &isp->file_dev;
+
+	if (file_dev->fWork_queued) {
+		file_dev->fStreaming = false;
+		complete(&file_dev->file_inject_start);
+		cancel_work_sync(&file_dev->work_thread);
+		file_dev->fWork_queued = false;
+	}
+
+	if (file_dev->work_queue) {
+		destroy_workqueue(file_dev->work_queue);
+		file_dev->work_queue = NULL;
+	}
+
+	return;
+}
+
+int atomisp_file_input_init(struct atomisp_device *isp)
+{
+	struct atomisp_file_device *file_dev = &isp->file_dev;
+	struct v4l2_subdev *sd = &file_dev->sd;
+	struct media_pad *pads = file_dev->pads;
+	struct media_entity *me = &sd->entity;
+	struct camera_mipi_info *file_input_info = NULL;
+	int ret;
+
+	file_dev->isp = isp;
+	file_dev->work_queue = create_singlethread_workqueue(
+				"ATOMISP file injection work queue");
+	if (!file_dev->work_queue) {
+		dev_warn(isp->dev,
+			"Failed to create file inject work queue\n");
+		return -ENOMEM;
+	}
+	INIT_WORK(&file_dev->work_thread, file_work);
+	init_completion(&file_dev->file_inject_start);
+	file_dev->fWork_queued = false;
+	file_dev->fStreaming = false;
+	file_dev->framecount = 0;
+	v4l2_subdev_init(sd, &file_input_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	strcpy(sd->name, "file_input_subdev");
+	v4l2_set_subdevdata(sd, file_dev);
+
+	file_input_info = kzalloc(sizeof(*file_input_info), GFP_KERNEL);
+	if (!file_input_info) {
+		v4l2_err(&atomisp_dev,
+			    "Failed to allocate memory for file input\n");
+		return -ENOMEM;
+	}
+
+	file_input_info->port = ATOMISP_CAMERA_PORT_PRIMARY;
+	/* the default input format is IA_CSS_STREAM_FORMAT_YUV422_8 
+	and no bayer order */
+	file_input_info->input_format = IA_CSS_STREAM_FORMAT_YUV422_8;
+	v4l2_set_subdev_hostdata(sd, (void *)file_input_info);
+
+	pads[0].flags = MEDIA_PAD_FL_SINK;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+
+	ret = media_entity_init(me, 1, pads, 0);
+	if (ret < 0)
+		goto fail;
+	return 0;
+fail:
+	kfree(file_input_info);
+	atomisp_file_input_cleanup(isp);
+	return ret;
+}
diff --git a/drivers/media/atomisp2/atomisp_file.h b/drivers/media/atomisp2/atomisp_file.h
new file mode 100644
index 0000000..21afc8f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_file.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_FILE_H__
+#define __ATOMISP_FILE_H__
+
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+
+struct atomisp_device;
+
+struct atomisp_file_device {
+	struct v4l2_subdev sd;
+	struct atomisp_device *isp;
+	struct media_pad pads[1];
+
+	struct workqueue_struct *work_queue;
+	struct work_struct work_thread;
+	bool fWork_queued;
+	bool fStreaming;
+	 struct completion file_inject_start;
+	int framecount;
+};
+
+void atomisp_file_input_cleanup(struct atomisp_device *isp);
+int atomisp_file_input_init(struct atomisp_device *isp);
+void atomisp_file_input_unregister_entities(
+				struct atomisp_file_device *file_dev);
+int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
+			struct v4l2_device *vdev);
+#endif /* __ATOMISP_FILE_H__ */
diff --git a/drivers/media/atomisp2/atomisp_fops.c b/drivers/media/atomisp2/atomisp_fops.c
new file mode 100644
index 0000000..6ad19fe
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_fops.c
@@ -0,0 +1,1024 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_compat.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp_subdev.h"
+#include "atomisp-regs.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+#include "hrt/hive_isp_css_custom_host_hrt.h"
+
+#include "sh_css_debug.h"
+#include "host/mmu_local.h"
+#include "device_access/device_access.h"
+#include "memory_access/memory_access.h"
+
+#include "atomisp_acc.h"
+#include "atomisp_fw.h"
+
+#define ISP_LEFT_PAD			128	/* equal to 2*NWAY */
+#define CSS_DTRACE_VERBOSITY_LEVEL	5	/* Controls trace verbosity */
+
+/*
+ * input image data, and current frame resolution for test
+ */
+#define	ISP_PARAM_MMAP_OFFSET	0xfffff000
+
+#define MAGIC_CHECK(is, should)	\
+	if (unlikely((is) != (should))) { \
+		printk(KERN_ERR "magic mismatch: %x (expected %x)\n", \
+			is, should); \
+		BUG(); \
+	}
+
+int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			     struct atomisp_video_pipe *pipe,
+			     enum ia_css_buffer_type css_buf_type,
+			     enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_vb2 *vb2;
+	unsigned long irqflags;
+	int err, pipe_index;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER q_video_buffers_to_css, pipe=%p, pipe_type=%d, activeq list empty=%s, buffers_in_css=%d\n", pipe, pipe->pipe_type, (list_empty(&pipe->activeq))?"true":"false", pipe->buffers_in_css);
+
+	while (pipe->buffers_in_css < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer css_buf;
+		memset(&css_buf, 0, sizeof(struct ia_css_buffer));
+		spin_lock_irqsave(&pipe->irq_lock, irqflags);
+		if (list_empty(&pipe->activeq)) {
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "atomisp_q_video_buffers_to_css: DMA activeq empty, exiting function\n");
+			spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+			return -EINVAL;
+		}
+		vb2 = list_entry(pipe->activeq.next,
+			struct atomisp_vb2, list);
+		list_del_init(&vb2->list);
+		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+		css_buf.type = css_buf_type;
+		css_buf.data.frame = vb2->cssframe;  
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "q_video_buffers_to_css: DMA delete from activeq vb2 vaddr=%X, fd=%d, index=%d\n", vb2->cssframe->data, vb2->vb.v4l2_buf.m.fd, vb2->vb.v4l2_buf.index);
+		pipe_index = (unsigned int)(css_pipe_id);
+		err = ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+						 &css_buf);
+		if (err) {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR with ia_css_pipe_enqueue_buffer");
+			spin_lock_irqsave(&pipe->irq_lock, irqflags);
+			list_add_tail(&vb2->list, &pipe->activeq);
+			spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+			dev_err(isp->dev, "%s, css q fails: %d\n",
+					__func__, err);
+			return -EINVAL;
+		}
+
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+
+		if (streamoff)
+			return 0;
+
+		pipe->buffers_in_css++;
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "Buffers in css incremented to %d\n", pipe->buffers_in_css);
+		vb2 = NULL;
+	}
+	return 0;
+}
+
+int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_s3a_buf *s3a_buf;
+	int pipe_index = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (list_empty(&isp_subdev->s3a_stats)) {
+		WARN(1, "%s: No s3a buffers available!\n", __func__);
+		return -EINVAL;
+	}
+
+	while (isp_subdev->s3a_bufs_in_css[css_pipe_id] < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer buffer;
+		memset(&buffer, 0, sizeof(struct ia_css_buffer));
+		s3a_buf = list_entry(isp_subdev->s3a_stats.next,
+				struct atomisp_s3a_buf, list);
+		list_move_tail(&s3a_buf->list, &isp_subdev->s3a_stats);
+
+		buffer.type = IA_CSS_BUFFER_TYPE_3A_STATISTICS;
+		buffer.data.stats_3a = s3a_buf->s3a_stat;
+		pipe_index = (unsigned int)css_pipe_id;
+		if (ia_css_pipe_enqueue_buffer(
+					isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer)) {
+			dev_err(isp->dev, "failed to q s3a stat buffer\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+
+		if (streamoff)
+			return 0;
+
+		isp_subdev->s3a_bufs_in_css[css_pipe_id]++;
+	}
+	return 0;
+}
+
+int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct atomisp_dvs_buf *dvs_buf;
+	int pipe_index = 0;
+
+	if (list_empty(&isp_subdev->dvs_stats)) {
+		WARN(1, "%s: No dis buffers available!\n", __func__);
+		return -EINVAL;
+	}
+
+	while (isp_subdev->dis_bufs_in_css < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer buffer = {0};
+		dvs_buf = list_entry(isp_subdev->dvs_stats.next,
+				struct atomisp_dvs_buf, list);
+		list_move_tail(&dvs_buf->list, &isp_subdev->dvs_stats);
+
+		buffer.type = IA_CSS_BUFFER_TYPE_DIS_STATISTICS;
+		buffer.data.stats_dvs = dvs_buf->dvs_stat;
+		pipe_index = (unsigned int )(css_pipe_id);
+		if (ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer)) {
+			dev_err(isp->dev, "failed to q dvs stat buffer\n");
+			return -EINVAL;
+		}
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+		if (streamoff)
+			return 0;
+
+		isp_subdev->dis_bufs_in_css++;
+		dvs_buf = NULL;
+	}
+	return 0;
+}
+
+/* queue all available buffers to css */
+int atomisp_qbuffers_to_css(struct atomisp_sub_device *isp_subdev, bool streamoff)
+{
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id css_capture_pipe_id = IA_CSS_PIPE_ID_NUM;
+	enum ia_css_pipe_id css_preview_pipe_id = IA_CSS_PIPE_ID_NUM;
+	struct atomisp_video_pipe *capture_pipe = NULL;
+	struct atomisp_video_pipe *vf_pipe = NULL;
+	struct atomisp_video_pipe *preview_pipe = NULL;
+
+	if (!isp_subdev->enable_vfpp->val) {
+		preview_pipe = &isp_subdev->video_out_capture;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		capture_pipe = &isp_subdev->video_out_capture;
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_capture_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+	} else if (isp_subdev->params.continuous_vf) {
+		capture_pipe = &isp_subdev->video_out_capture;
+		vf_pipe = &isp_subdev->video_out_vf;
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_capture_pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_PREVIEW;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_PREVIEW;
+	} else {
+		/* ATOMISP_RUN_MODE_STILL_CAPTURE */
+		capture_pipe = &isp_subdev->video_out_capture;
+		if (!atomisp_is_mbuscode_raw(
+			    isp_subdev->
+			    fmt[isp_subdev->capture_pad].fmt.code))
+			vf_pipe = &isp_subdev->video_out_vf;
+		css_capture_pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+	}
+
+	if (capture_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, capture_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, capture_pipe, buf_type,
+					 css_capture_pipe_id, streamoff);
+	}
+
+	if (vf_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, vf_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, vf_pipe, buf_type,
+					 css_capture_pipe_id, streamoff);
+	}
+
+	if (preview_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, preview_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, preview_pipe, buf_type,
+					 css_preview_pipe_id, streamoff);
+	}
+
+	if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+		if (css_capture_pipe_id < IA_CSS_PIPE_ID_NUM)
+			atomisp_q_s3a_buffers_to_css(isp_subdev, css_capture_pipe_id, streamoff);
+		if (css_preview_pipe_id < IA_CSS_PIPE_ID_NUM && css_preview_pipe_id < IA_CSS_PIPE_ID_NUM)
+			atomisp_q_s3a_buffers_to_css(isp_subdev, css_preview_pipe_id, streamoff);
+	}
+
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable)
+		atomisp_q_dis_buffers_to_css(isp_subdev, css_capture_pipe_id, streamoff);
+
+	return 0;
+}
+
+static int atomisp_vb2_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
+	unsigned int *nbuffers, unsigned int *nplanes,
+	unsigned int sizes[], void *alloc_ctxs[]) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+  	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	unsigned long size;
+
+	if (fmt)
+		size = fmt->fmt.pix.sizeimage;
+	else {
+		size = pipe->pix.sizeimage;
+	}
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "atomisp_vb2_queue_setup: size=%lu\n", size);
+	trace_printk("atomisp_vb2_queue_setup: size=%lu\n", size);	
+
+  if (size == 0)
+    return -EINVAL;
+
+  if (0 == *nbuffers) {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "WARNING in atomisp_vb2_queue_setup, nbuffers == 0. Setting to 3\n");
+    *nbuffers = 3;
+	}
+
+  *nplanes = 1;
+  sizes[0] = size;
+
+	isp->raw_dmamask = DMA_BIT_MASK(36); /* 36 is ISP IUNIT MMU limit */
+	vdev->dev.dma_mask = &isp->raw_dmamask;
+	vdev->dev.coherent_dma_mask = isp->raw_dmamask; 
+
+	alloc_ctxs[0] = vb2_dma_contig_init_ctx(&vdev->dev);
+	if (!alloc_ctxs[0]) {
+		printk("Error in atomisp_vb2_queue_setup allocating alloc_ctx\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* This gets called from vb2_qbuf if already streaming, and from vb2_streamon*/
+static void atomisp_vb2_buf_queue(struct vb2_buffer *vb) {
+	struct vb2_queue *q = vb->vb2_queue;
+	struct video_device *vdev = vb2_get_drv_priv(q);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_vb2 *buf = container_of(vb, struct atomisp_vb2, vb);
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA atomisp_vb2_buf_queue, adding buf %d to activeq\n", vb->v4l2_buf.index);
+
+	list_add_tail(&buf->list, &pipe->activeq);
+
+}
+static int atomisp_vb2_buf_prepare(struct vb2_buffer *vb) {
+  struct video_device *vdev = vb2_get_drv_priv(vb->vb2_queue);
+  struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	unsigned long size;
+
+	size = pipe->pix.sizeimage;
+
+	vb2_set_plane_payload(vb, 0, size);
+	//TODO handle more planes
+
+	return 0;
+}
+
+static void atomisp_vb2_unlock(struct vb2_queue *vq) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	mutex_unlock(&isp->vb2mutex);
+}
+
+static void atomisp_vb2_lock(struct vb2_queue *vq) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	mutex_lock(&isp->vb2mutex);
+}
+
+static int atomisp_vb2_start_streaming(struct vb2_queue *vq, unsigned int count) {
+/*
+	called once to enter 'streaming' state; the driver may
+  receive buffers with @buf_queue callback before
+  @start_streaming is called; the driver gets the number
+  of already queued buffers in count parameter; driver
+  can return an error if hardware fails or not enough
+  buffers has been queued, in such case all buffers that
+  have been already given by the @buf_queue callback are
+  invalidated.
+*/
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "ENTER atomisp_vb2_start_streaming, queued buffer count=%d\n", count);
+	return 0;
+}
+
+static struct vb2_ops vb2_qops = {
+  .queue_setup    = atomisp_vb2_queue_setup, //required
+	.buf_prepare    = atomisp_vb2_buf_prepare,
+  .buf_queue      = atomisp_vb2_buf_queue, //required
+  .start_streaming = atomisp_vb2_start_streaming, //Called after streaming enabled in streamon
+  //.stop_streaming = atomisp_vb2_stop_streaming,
+  .wait_prepare   = atomisp_vb2_unlock, 
+  .wait_finish    = atomisp_vb2_lock,
+};
+
+static int atomisp_vb2_setup(struct video_device *vdev) {
+	int rc;
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct vb2_queue *q, *outq;
+	q = &pipe->vb2q;
+	memset(q, 0, sizeof(struct vb2_queue));
+  q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+  q->drv_priv = vdev;
+	q->buf_struct_size = sizeof(struct atomisp_vb2);
+  q->ops = &vb2_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	
+  rc = vb2_queue_init(q);
+  if (rc < 0)
+    return rc;
+	vdev->queue = q;
+	INIT_LIST_HEAD(&pipe->activeq);
+
+	/* Just for file injection */
+	outq = &pipe->vb2outq;
+	memset(outq, 0, sizeof(struct vb2_queue));
+	outq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	outq->io_modes = VB2_MMAP;
+	outq->drv_priv = vdev;
+	outq->buf_struct_size = sizeof(struct atomisp_vb2);
+	outq->ops = &vb2_qops;
+	outq->mem_ops = &vb2_dma_contig_memops;
+	rc = vb2_queue_init(outq);
+	if (rc < 0)
+		return rc;
+	INIT_LIST_HEAD(&pipe->activeq_out);
+
+	return 0;
+}
+
+int atomisp_dev_init_struct(struct atomisp_device *isp)
+{
+	int i = 0;
+	if (isp == NULL)
+		return -EINVAL;
+	
+	isp->sw_contex.file_input = 0;
+	isp->need_gfx_throttle = true;
+	isp->isp_fatal_error = false;
+	isp->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+	
+	for(i=0;i<ATOM_ISP_MAX_INPUTS;i++)
+		isp->inputs[i].used_by = -1;
+
+	/*
+	 * For Merrifield, frequency is scalable.
+	 * After boot-up, the default frequency is 200MHz.
+	 * For Medfield/Clovertrail, all running at 320MHz
+	 */
+	if (IS_MRFLD)
+		isp->sw_contex.running_freq = ISP_FREQ_200MHZ;
+	else
+		isp->sw_contex.running_freq = ISP_FREQ_320MHZ;
+
+	return 0;
+}
+
+int atomisp_subdev_init_struct(struct atomisp_sub_device *isp_subdev)
+{
+	int i = 0;
+
+	v4l2_ctrl_s_ctrl(isp_subdev->run_mode,
+			 ATOMISP_RUN_MODE_STILL_CAPTURE);
+	isp_subdev->params.color_effect = V4L2_COLORFX_NONE;
+	isp_subdev->params.bad_pixel_en = 1;
+	isp_subdev->params.gdc_cac_en = 0;
+	isp_subdev->params.video_dis_en = 0;
+	isp_subdev->params.sc_en = 0;
+	isp_subdev->params.fpn_en = 0;
+	isp_subdev->params.xnr_en = 0;
+	isp_subdev->params.false_color = 0;
+	isp_subdev->params.online_process = 1;
+	isp_subdev->params.yuv_ds_en = 0;
+	isp_subdev->params.offline_parm.num_captures = 1;
+	isp_subdev->params.offline_parm.skip_frames = 0;
+	isp_subdev->params.offline_parm.offset = 0;
+	isp_subdev->params.continuous_vf = false;
+
+	isp_subdev->css2_basis.stream = NULL;
+	for (i = 0; i < IA_CSS_PIPE_MODE_NUM; i++) {
+		isp_subdev->css2_basis.pipes[i] = NULL;
+		ia_css_pipe_config_defaults(&isp_subdev->css2_basis.pipe_configs[i]);
+		ia_css_pipe_extra_config_defaults(
+				&isp_subdev->css2_basis.pipe_extra_configs[i]);
+	}
+	ia_css_stream_config_defaults(&isp_subdev->css2_basis.stream_config);
+	isp_subdev->css2_basis.curr_pipe = 0;
+
+	/* Add for channel */
+	if (isp_subdev->isp->inputs[0].camera)
+		isp_subdev->input_curr = 0;
+
+	init_completion(&isp_subdev->buf_done);
+
+	return 0;
+}
+
+#ifndef ON_DEMAND_LOAD
+static
+#endif
+void *my_kernel_malloc(size_t bytes, bool zero_mem)
+{
+	void *ptr = atomisp_kernel_malloc(bytes);
+
+	if (ptr && zero_mem)
+		memset(ptr, 0, bytes);
+
+	return ptr;
+}
+
+/*
+ * Return the number of concurrent running streams.
+ */
+int atomisp_subdev_streaming_count(struct atomisp_device *isp)
+{
+	int i, sum;
+ 
+	for (i = 0, sum = 0; i < isp->num_of_streams; i++)
+		sum += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+
+	return sum;
+}
+
+/* SOF IRQ enable only in single stream mode */
+void atomisp_control_irq_sof(struct atomisp_device *isp)
+{
+	if (atomisp_subdev_streaming_count(isp) == 1)
+		ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, true);
+	else
+		ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);
+}
+
+/*
+ * file operation functions
+ */
+unsigned int atomisp_subdev_users(struct atomisp_sub_device *isp_subdev)
+{
+	
+	int no_of_users = isp_subdev->video_out_preview.users +
+	       isp_subdev->video_out_vf.users +
+	       isp_subdev->video_out_capture.users +
+	       isp_subdev->video_in.users;
+	return no_of_users;
+}
+
+unsigned int atomisp_dev_users(struct atomisp_device *isp)
+{
+	unsigned int i, sum = 0;
+
+	for (i = 0; i < isp->num_of_streams; i++)
+		sum += atomisp_subdev_users(&isp->isp_subdev[i]);
+
+	return sum;
+}
+
+int atomisp_css2_dbg_print(const char *fmt, va_list args)
+{
+	if (dbg_level > 5)
+		vprintk(fmt, args);
+	return 0;
+}
+
+int atomisp_css2_err_print(const char *fmt, va_list args)
+{
+	vprintk(fmt, args);
+	return 0;
+}
+
+#ifndef ON_DEMAND_LOAD
+struct ia_css_env css_env = {
+                .cpu_mem_env.alloc = my_kernel_malloc,
+                .cpu_mem_env.free = atomisp_kernel_free,
+                .css_mem_env.alloc = atomisp_css2_mm_alloc,
+                .css_mem_env.free = atomisp_css2_mm_free,
+                .css_mem_env.load = atomisp_css2_mm_load,
+                .css_mem_env.store = atomisp_css2_mm_store,
+                .css_mem_env.set = atomisp_css2_mm_set,
+                .css_mem_env.mmap = atomisp_css2_mm_mmap,
+
+                .hw_access_env.store_8 = atomisp_css2_hw_store_8,
+                .hw_access_env.store_16 = atomisp_css2_hw_store_16,
+                .hw_access_env.store_32 = atomisp_css2_hw_store_32,
+
+                .hw_access_env.load_8 = atomisp_css2_hw_load_8,
+                .hw_access_env.load_16 = atomisp_css2_hw_load_16,
+                .hw_access_env.load_32 = atomisp_css2_hw_load_32,
+
+                .hw_access_env.load = atomisp_css2_hw_load,
+                .hw_access_env.store = atomisp_css2_hw_store,
+
+                .print_env.debug_print = atomisp_css2_dbg_print,
+                .print_env.error_print = atomisp_css2_err_print,
+};
+#endif
+
+static int atomisp_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	int ret = -EINVAL;
+#ifndef ON_DEMAND_LOAD
+	int mmu_base_addr;
+#endif
+	int retval, i;
+
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, ">%s [%d]\n",
+				__func__, pipe->pipe_type);
+
+	//following conditions gets executed if only one sub_dev is registered
+	if(isp->detected_snr_cnt==1)
+			if(isp_subdev!=&isp->isp_subdev[0])
+				return 0;
+
+	mutex_lock(&isp->mutex);
+
+	if (!isp->input_cnt) {
+		v4l2_err(&atomisp_dev, "no camera attached\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (pipe->users)
+		goto done;
+
+	atomisp_vb2_setup(vdev);
+
+	if (atomisp_subdev_users(isp_subdev)) {
+		goto done;
+	}
+	
+	atomisp_subdev_init_struct(isp_subdev);
+
+	if(atomisp_dev_users(isp))
+		goto done;
+	
+	hrt_isp_css_mm_init();
+#ifdef ON_DEMAND_LOAD
+	isp->mmu_base_addr = hrt_isp_get_mmu_base_address();
+	if (isp->mmu_base_addr < 0) {
+#else
+	mmu_base_addr = hrt_isp_get_mmu_base_address();
+        if (mmu_base_addr < 0) {
+#endif
+                hrt_isp_css_mm_clear();
+                goto error;
+        }
+
+	/* runtime power management, turn on ISP */
+	ret = pm_runtime_get_sync(vdev->v4l2_dev->dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+				"Failed to power on device\n");
+		goto error;
+	}
+
+#ifndef ON_DEMAND_LOAD
+	for( i = 0; i <  MAX_LOAD_FIRMWARE_TIMEOUTS; i++)
+	{
+		retval = wait_event_interruptible_timeout(atomisp_wait_queue, isp->firmware_load_complete == true, 250);
+		if(retval>=0 && isp->firmware_load_complete)
+			break;
+	}
+
+	if(isp->firmware == NULL)
+	{
+		ret = -EINVAL;
+		goto css_init_failed;
+	}
+
+	//Fixing the issue where insmod failed because firmware data is accessed before we even check whether firmware load completed or not
+	isp->css_fw.data = (void *)isp->firmware->data;
+	isp->css_fw.bytes = isp->firmware->size;
+#endif
+	/* Init ISP */
+#ifndef ON_DEMAND_LOAD
+	if (ia_css_init(&css_env,
+			&isp->css_fw,
+			(uint32_t)mmu_base_addr,
+			IA_CSS_IRQ_TYPE_PULSE)) {
+		ret = -EINVAL;
+		goto css_init_failed;
+	}
+
+	/*uncomment the following to lines to enable offline preview*/
+	/*sh_css_enable_continuous(true);*/
+	/*sh_css_preview_enable_online(false);*/
+	atomisp_dev_init_struct(isp);
+#endif
+
+done:
+	pipe->users++;
+	mutex_unlock(&isp->mutex);
+	dev_warn(isp->dev, "atomisp_open: successfully opened video%d\n", pipe->pipe_type);
+	return 0;
+
+css_init_failed:
+	dev_err(isp->dev, "css init failed --- bad firmware?\n");
+error:
+	pm_runtime_put(vdev->v4l2_dev->dev);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_release(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+	struct v4l2_requestbuffers req;
+	int ret = 0;
+	if (isp == NULL)
+		return -EBADF;
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s [%d]\n", __func__, pipe->pipe_type);
+
+	req.count = 0;
+	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory = vdev->queue->memory;
+	mutex_lock(&isp->mutex);
+	pipe->users--;
+
+	if (pipe->vb2q.streaming && __atomisp_streamoff(file, NULL, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+	{
+		dev_err(isp->dev,
+			"atomisp_streamoff failed on release, driver bug");
+		goto done;
+	}
+
+	if (pipe->users)
+		goto done;
+
+	atomisp_free_css_frames(&pipe->vb2q);
+	vb2_fop_release(file);
+	vb2_queue_release(&pipe->vb2outq);
+
+	/*
+	 * A little trick here:
+	 * file injection input resolution is recorded in the sink pad,
+	 * therefore can not be cleared when releaseing one device node.
+	 * The sink pad setting can only be cleared when all device nodes
+	 * get released.
+	 */
+	if (!isp->sw_contex.file_input) {
+	memset(&isp_sink_fmt, 0, sizeof(isp_sink_fmt));
+	atomisp_subdev_set_ffmt(&isp_subdev->subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);
+	}
+
+	if (atomisp_subdev_users(isp_subdev))
+	{
+		goto done;
+	}
+
+	/* clear the sink pad for file input */
+	if (isp->sw_contex.file_input) {
+		memset(&isp_sink_fmt, 0, sizeof(isp_sink_fmt));
+		atomisp_subdev_set_ffmt(&isp_subdev->subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);
+	}
+
+	atomisp_ISP_parameters_clean_up(isp_subdev, &isp_subdev->params.config);
+ 	isp_subdev->params.css_update_params_needed = false;
+
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+	atomisp_free_internal_buffers(isp_subdev);
+
+	/*uninit the camera subdev*/
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			       core, init, 0);
+	if (ret == -1 || ret == -EINVAL)
+		v4l2_err(&atomisp_dev, "sensor firmware failed\n");
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_power, 0);
+	if (ret)
+		v4l2_warn(&atomisp_dev, "Failed to power-off sensor\n");
+
+	if(atomisp_dev_users(isp))
+	{
+		goto done;
+	}
+
+
+	del_timer_sync(&isp->wdt);
+	atomisp_acc_release(isp);
+	atomisp_free_all_shading_tables(isp);
+	ia_css_uninit();
+	hrt_isp_css_mm_clear();
+
+	if (pm_runtime_put_sync(vdev->v4l2_dev->dev) < 0)
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "Failed to power off device\n");
+done:
+	mutex_unlock(&isp->mutex);
+	return 0;
+}
+
+/*
+ * Memory help functions for image frame and private parameters
+ */
+static int do_isp_mm_remap(struct vm_area_struct *vma,
+		    void *isp_virt, u32 host_virt, u32 pgnr)
+{
+	u32 pfn;
+
+	while (pgnr) {
+		pfn = hmm_virt_to_phys(isp_virt) >> PAGE_SHIFT;
+		if (remap_pfn_range(vma, host_virt, pfn,
+				    PAGE_SIZE, PAGE_SHARED)) {
+			v4l2_err(&atomisp_dev,
+				    "remap_pfn_range err.\n");
+			return -EAGAIN;
+		}
+
+		isp_virt += PAGE_SIZE;
+		host_virt += PAGE_SIZE;
+		pgnr--;
+	}
+
+	return 0;
+}
+
+static int frame_mmap(const struct ia_css_frame *frame,
+	struct vm_area_struct *vma)
+{
+	void *isp_virt;
+	u32 host_virt;
+	u32 pgnr;
+
+	if (!frame) {
+		v4l2_err(&atomisp_dev,
+			    "%s: NULL frame pointer.\n", __func__);
+		return -EINVAL;
+	}
+
+	host_virt = vma->vm_start;
+	isp_virt = (void *)frame->data;
+	atomisp_get_frame_pgnr(frame, &pgnr);
+
+	if (do_isp_mm_remap(vma, isp_virt, host_virt, pgnr))
+		return -EAGAIN;
+
+	return 0;
+}
+
+int atomisp_vb2_mmap_mapper(struct vb2_queue *q,
+	struct vm_area_struct *vma)
+{
+	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
+	int ret = -EINVAL, i;
+	struct vb2_buffer *vb2;
+	struct atomisp_vb2 *avb2;
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+
+	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+		vb2 = q->bufs[i];
+		if (vb2 && vb2->v4l2_buf.memory == V4L2_MEMORY_MMAP
+		     && vb2->v4l2_planes[0].m.mem_offset == offset) 
+		{
+			avb2 = container_of(vb2, struct atomisp_vb2, vb);
+			ret = frame_mmap(avb2->cssframe, vma);
+			vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP; 
+			break;
+		}
+	}
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return ret;
+}
+
+/* The input frame contains left and right padding that need to be removed.
+ * There is always ISP_LEFT_PAD padding on the left side.
+ * There is also padding on the right (padded_width - width).
+ */
+static int
+remove_pad_from_frame(struct ia_css_frame *in_frame, __u32 width, __u32 height)
+{
+	unsigned int i;
+	unsigned short *buffer;
+	int ret = 0;
+	unsigned short *load = (unsigned short *)in_frame->data;
+	unsigned short *store = load;
+
+	buffer = kmalloc(width*sizeof(*load), GFP_KERNEL);
+	if (!buffer) {
+		v4l2_err(&atomisp_dev, "out of memory.\n");
+		return -ENOMEM;
+	}
+
+	load += ISP_LEFT_PAD;
+	for (i = 0; i < height; i++) {
+		ret = hrt_isp_css_mm_load(load, buffer, width*sizeof(*load));
+		if (ret < 0)
+			goto remove_pad_error;
+
+		ret = hrt_isp_css_mm_store(store, buffer, width*sizeof(*store));
+		if (ret < 0)
+			goto remove_pad_error;
+
+		load  += in_frame->info.padded_width;
+		store += width;
+	}
+
+remove_pad_error:
+	kfree(buffer);
+	return ret;
+}
+
+static int atomisp_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct ia_css_frame *raw_virt_addr;
+	u32 start = vma->vm_start;
+	u32 end = vma->vm_end;
+	u32 size = end - start;
+	u32 origin_size, new_size;
+	int ret;
+
+	if (!(vma->vm_flags & (VM_WRITE | VM_READ)))
+		return -EACCES;
+
+	if (!(vma->vm_flags & VM_SHARED))
+		return -EINVAL;
+
+	mutex_lock(&isp->mutex);
+	new_size = pipe->pix.width * pipe->pix.height * 2;
+
+	/* mmap for ISP offline raw data */
+	if ((pipe->pipe_type == ATOMISP_PIPE_CAPTURE) &&
+	    (vma->vm_pgoff == (ISP_PARAM_MMAP_OFFSET >> PAGE_SHIFT))) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "vma->vm_pgoff == (ISP_PARAM_MMAP_OFFSET >> PAGE_SHIFT)\n");
+		if (isp_subdev->params.online_process != 0) {
+			ret = -EINVAL;
+			goto error;
+		}
+		raw_virt_addr = isp_subdev->raw_output_frame;
+		if (raw_virt_addr == NULL) {
+			v4l2_err(&atomisp_dev,
+				 "Failed to request RAW frame\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+		ret = remove_pad_from_frame(raw_virt_addr,
+				      pipe->pix.width,
+				      pipe->pix.height);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev, "remove pad failed.\n");
+			goto error;
+		}
+		origin_size = raw_virt_addr->data_bytes;
+		raw_virt_addr->data_bytes = new_size;
+
+		if (size != PAGE_ALIGN(new_size)) {
+			v4l2_err(&atomisp_dev,
+				 "incorrect size for mmap ISP"
+				 " Raw Frame\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+		if (frame_mmap(raw_virt_addr, vma)) {
+			v4l2_err(&atomisp_dev,
+				 "frame_mmap failed.\n");
+			raw_virt_addr->data_bytes = origin_size;
+			ret = -EAGAIN;
+			goto error;
+		}
+		raw_virt_addr->data_bytes = origin_size;
+		vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
+		mutex_unlock(&isp->mutex);
+		return 0;
+	}
+
+	/*
+	 * mmap for normal frames
+	 */
+	if (size != pipe->pix.sizeimage) {
+		v4l2_err(&atomisp_dev,
+			    "incorrect size for mmap ISP frames\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	mutex_unlock(&isp->mutex);
+
+  return atomisp_vb2_mmap_mapper(&pipe->vb2q, vma);
+
+error:
+	mutex_unlock(&isp->mutex);
+
+	return ret;
+}
+
+int atomisp_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	return vb2_mmap(&pipe->vb2outq, vma);
+}
+
+static unsigned int
+atomisp_poll(struct file *file, struct poll_table_struct *pt)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "inside atomisp_poll before mutex lock\n");
+	mutex_lock(&isp->mutex);
+	if (pipe->vb2q.streaming != 1) {
+		mutex_unlock(&isp->mutex);
+		v4l2_dbg(4, dbg_level, &atomisp_dev,  KERN_ERR "pipe is not streaming. unlocking mutex\n");
+		return POLLERR;
+	}
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "device is streaming so unlock mutex\n");
+	return vb2_fop_poll(file, pt);
+}
+
+const struct v4l2_file_operations atomisp_fops = {
+	.owner = THIS_MODULE,
+	.open = atomisp_open,
+	.release = atomisp_release,
+	.mmap = atomisp_mmap,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = atomisp_poll,
+};
+
+const struct v4l2_file_operations atomisp_file_fops = {
+	.owner = THIS_MODULE,
+	.open = atomisp_open,
+	.release = atomisp_release,
+	.mmap = atomisp_file_mmap,
+	.ioctl = video_ioctl2,
+	.poll = atomisp_poll,
+};
+
diff --git a/drivers/media/atomisp2/atomisp_fops.h b/drivers/media/atomisp2/atomisp_fops.h
new file mode 100644
index 0000000..67c9d7e
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_fops.h
@@ -0,0 +1,69 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_FOPS_H__
+#define	__ATOMISP_FOPS_H__
+
+#include "sh_css_legacy.h"
+
+#define MAX_LOAD_FIRMWARE_TIMEOUTS 20
+static DECLARE_WAIT_QUEUE_HEAD(atomisp_wait_queue);
+
+int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			     struct atomisp_video_pipe *pipe,
+			     enum ia_css_buffer_type css_buf_type,
+			     enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_dev_init_struct(struct atomisp_device *isp);
+int atomisp_subdev_init_struct(struct atomisp_sub_device *isp_subdev);
+
+int atomisp_subdev_streaming_count(struct atomisp_device *isp);
+void atomisp_control_irq_sof(struct atomisp_device * isp);
+
+unsigned int atomisp_subdev_users(struct atomisp_sub_device *isp_subdev);
+unsigned int atomisp_dev_users(struct atomisp_device *isp);
+
+/*
+ * Memory help functions for image frame and private parameters
+ */
+
+int atomisp_file_mmap(struct file *file, struct vm_area_struct *vma);
+
+int atomisp_qbuffers_to_css(struct atomisp_sub_device *isp_subdev, bool streamoff);
+
+extern const struct v4l2_file_operations atomisp_fops;
+
+#ifdef ON_DEMAND_LOAD
+void *my_kernel_malloc(size_t bytes, bool zero_mem);
+
+int atomisp_css2_err_print(const char *fmt, va_list args);
+
+int atomisp_css2_dbg_print(const char *fmt, va_list args);
+#endif
+#endif /* __ATOMISP_FOPS_H__ */
diff --git a/drivers/media/atomisp2/atomisp_fw.h b/drivers/media/atomisp2/atomisp_fw.h
new file mode 100644
index 0000000..45276fe
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_fw.h
@@ -0,0 +1,68 @@
+/* this is the ISP firmware data running on Merrifield VP */
+char isp2400_fw_data_sim[] = {
+0x8e, 0x02, 0x33, 0x01, 0x14, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x54, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x54,
+0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
+0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
+0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
+0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
+0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x0e, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x0f, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
diff --git a/drivers/media/atomisp2/atomisp_helper.h b/drivers/media/atomisp2/atomisp_helper.h
new file mode 100644
index 0000000..e9650cb
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_helper.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef _atomisp_helper_h_
+#define _atomisp_helper_h_
+extern void __iomem *atomisp_io_base;
+
+static inline void __iomem *atomisp_get_io_virt_addr(unsigned int address)
+{
+	void __iomem *ret = atomisp_io_base + (address & 0x003FFFFF);
+	return ret;
+}
+#endif
+
diff --git a/drivers/media/atomisp2/atomisp_internal.h b/drivers/media/atomisp2/atomisp_internal.h
new file mode 100644
index 0000000..6a5e2b0
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_internal.h
@@ -0,0 +1,326 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_INTERNAL_H__
+#define __ATOMISP_INTERNAL_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/pm_qos.h>
+#include <linux/idr.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-subdev.h>
+
+#ifdef CSS_2
+#include "ia_css_types.h"
+#include "sh_css_legacy.h"
+#else
+#include "sh_css_types.h"
+#endif
+
+#include "atomisp_csi2.h"
+#include "atomisp_file.h"
+#include "atomisp_subdev.h"
+#include "atomisp_tpg.h"
+
+#include "gp_device.h"
+#include "irq.h"
+
+#define MULTI_STREAM_NUM	3
+#define EXP_ID_WRAPAROUND       250
+
+#define ATOMISP_MAJOR		0
+#define ATOMISP_MINOR		5
+#define ATOMISP_PATCHLEVEL	1
+
+#define DRIVER_VERSION_STR	__stringify(ATOMISP_MAJOR) \
+	"." __stringify(ATOMISP_MINOR) "." __stringify(ATOMISP_PATCHLEVEL)
+#define DRIVER_VERSION		KERNEL_VERSION(ATOMISP_MAJOR, \
+	ATOMISP_MINOR, ATOMISP_PATCHLEVEL)
+
+#define ATOM_ISP_STEP_WIDTH	4
+#define ATOM_ISP_STEP_HEIGHT	4
+
+#define ATOM_ISP_MIN_WIDTH	4
+#define ATOM_ISP_MIN_HEIGHT	4
+#define ATOM_ISP_MAX_WIDTH	4352
+#define ATOM_ISP_MAX_HEIGHT	3264
+
+/* sub-QCIF resolution */
+#define ATOM_RESOLUTION_SUBQCIF_WIDTH	128
+#define ATOM_RESOLUTION_SUBQCIF_HEIGHT	96
+
+#define ATOM_ISP_MAX_WIDTH_TMP	1280
+#define ATOM_ISP_MAX_HEIGHT_TMP	720
+
+#define ATOM_ISP_I2C_BUS_1	4
+#define ATOM_ISP_I2C_BUS_2	5
+
+#define ATOM_ISP_POWER_DOWN	0
+#define ATOM_ISP_POWER_UP	1
+
+#define ATOM_ISP_MAX_INPUTS	4
+
+#define ATOMISP_SC_TYPE_SIZE	2
+
+#define ATOMISP_ISP_TIMEOUT_DURATION		(2 * HZ) /* second */
+#define ATOMISP_ISP_FILE_TIMEOUT_DURATION	(60 * HZ)
+#define ATOMISP_ISP_MAX_TIMEOUT_COUNT	2
+
+#define ATOMISP_CSS2_PIPE_MAX	2
+#define ATOMISP_CSS_Q_DEPTH	3
+#define ATOMISP_CSS_EVENTS_MAX  16
+#define ATOMISP_CONT_RAW_FRAMES 10
+
+#define ATOMISP_DELAYED_INIT_NOT_QUEUED	0
+#define ATOMISP_DELAYED_INIT_QUEUED	1
+#define ATOMISP_DELAYED_INIT_WORK_DONE	2
+#define ATOMISP_DELAYED_INIT_DONE	2
+
+/*
+ * Define how fast CPU should be able to serve ISP interrupts.
+ * The bigger the value, the higher risk that the ISP is not
+ * triggered sufficiently fast for it to process image during
+ * vertical blanking time, increasing risk of dropped frames.
+ * 1000 us is a reasonable value considering that the processing
+ * time is typically ~2000 us.
+ */
+#define ATOMISP_MAX_ISR_LATENCY	1000
+
+struct atomisp_css_event {
+	enum ia_css_pipe_id pipe;
+	struct ia_css_event event;
+};
+
+struct atomisp_input_subdev {
+	unsigned int type;
+	enum atomisp_camera_port port;
+	int num_lanes;
+	struct v4l2_subdev *camera;
+	struct v4l2_subdev *motor;
+	struct ia_css_morph_table *morph_table;
+	struct ia_css_shading_table *shading_table;
+	struct v4l2_frmsizeenum frame_size;
+
+	/*
+	 * To show this resource is used by
+	 * which stream, in ISP multiple stream mode
+	 */
+	int used_by;
+};
+
+struct atomisp_freq_scaling_rule {
+	unsigned int width;
+	unsigned int height;
+	unsigned short fps;
+	unsigned int isp_freq;
+	unsigned int run_mode;
+};
+
+enum atomisp_dfs_mode {
+	ATOMISP_DFS_MODE_AUTO = 0,
+	ATOMISP_DFS_MODE_LOW,
+	ATOMISP_DFS_MODE_MAX,
+};
+
+struct atomisp_regs {
+	/* PCI config space info */
+	u16 pcicmdsts;
+	u32 ispmmadr;
+	u32 msicap;
+	u32 msi_addr;
+	u16 msi_data;
+	u8 intr;
+	u32 interrupt_control;
+	u32 pmcs;
+	u32 cg_dis;
+	u32 i_control;
+
+	/* I-Unit PHY related info */
+	u32 csi_rcomp_config;
+	u32 csi_afe_dly;
+	u32 csi_control;
+
+	/* New for MRFLD */
+	u32 csi_afe_rcomp_config;
+	u32 csi_afe_hs_control;
+	u32 csi_deadline_control;
+	u32 csi_access_viol;
+};
+
+struct atomisp_sw_contex {
+	bool bypass;
+	bool file_input;
+	int  invalid_frame;
+	int  invalid_vf_frame;
+	int  invalid_s3a;
+	int  invalid_dis;
+
+	int power_state;
+	int running_freq;
+};
+
+struct atomisp_acc_fw {
+	struct ia_css_fw_info *fw;
+	unsigned int handle;
+	unsigned int flags;
+	unsigned int type;
+	struct {
+		size_t length;
+		unsigned long css_ptr;
+		unsigned long usr_ptr;
+	} args[ATOMISP_ACC_NR_MEMORY];
+	struct list_head list;
+};
+
+struct atomisp_map {
+	hrt_vaddress ptr;
+	unsigned int usr_ptr;
+	size_t length;
+	struct list_head list;
+	/* FIXME: should keep book which maps are currently used
+	 * by binaries and not allow releasing those
+	 * which are in use. Implement by reference counting.
+	 */
+};
+
+#define ATOMISP_DEVICE_STREAMING_DISABLED	0
+#define ATOMISP_DEVICE_STREAMING_ENABLED	1
+#define ATOMISP_DEVICE_STREAMING_STOPPING	2
+#define ATOMISP_DEVICE_STREAMING_STARTING       3
+
+/*
+ * ci device struct
+ */
+struct atomisp_device {
+	struct pci_dev *pdev;
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct media_device media_dev;
+	struct atomisp_platform_data *pdata;
+	void *mmu_l1_base;
+	struct pci_dev *pci_root;
+	const struct firmware *firmware;
+	bool firmware_load_complete;
+
+	struct pm_qos_request pm_qos;
+	s32 max_isr_latency;
+
+	struct {
+		struct list_head fw;
+		struct list_head memory_maps;
+		struct ia_css_pipe *pipeline;
+		bool extension_mode;
+		struct ida ida;
+		struct completion acc_done;
+	} acc;
+
+	struct ia_css_fw css_fw;
+
+	/* ISP modules */
+	struct atomisp_sub_device *isp_subdev;
+	/*
+	 * MRFLD has 3 CSI ports, while MFLD has only 2.
+	 */
+	struct atomisp_mipi_csi2_device csi2_port[ATOMISP_CAMERA_NR_PORTS];
+	struct atomisp_tpg_device tpg;
+	struct atomisp_file_device file_dev;
+
+	/* Purpose of mutex is to protect and serialize use of isp data
+	 * structures and css API calls. */
+	struct mutex mutex;
+	struct mutex vb2mutex;
+	/*
+	 * Serialise streamoff: mutex is dropped during streamoff to
+	 * cancel the watchdog queue. MUST be acquired BEFORE
+	 * "mutex".
+	 */
+	struct mutex streamoff_mutex;
+
+	struct atomisp_input_subdev inputs[ATOM_ISP_MAX_INPUTS];
+	struct v4l2_subdev *flash;
+	struct v4l2_subdev *motor;
+
+	struct atomisp_regs saved_regs;
+	struct atomisp_sw_contex sw_contex;
+
+	/* isp timeout status flag */
+	bool isp_timeout;
+	bool isp_fatal_error;
+	struct workqueue_struct *wdt_work_queue;
+	struct work_struct wdt_work;
+	struct timer_list wdt;
+	atomic_t wdt_count;
+	unsigned int wdt_duration;	/* in jiffies */
+	enum atomisp_frame_status fr_status;
+
+	atomic_t sof_count;
+	atomic_t sequence;      /* Sequence value that is assigned to buffer. */
+	atomic_t sequence_temp;
+
+	spinlock_t lock; /* Just for streaming below */
+
+	bool need_gfx_throttle;
+
+	/* delayed memory allocation for css */
+	struct completion init_done;
+	struct workqueue_struct *delayed_init_workq;
+	unsigned int delayed_init;
+	struct work_struct delayed_init_work;
+
+	int num_of_streams;
+	int input_cnt;
+	u64 raw_dmamask;
+
+	/*
+	 * Counts number of successful registered sub_devs
+	 */
+	int detected_snr_cnt;
+#ifdef ON_DEMAND_LOAD
+	int mmu_base_addr;
+#endif
+};
+
+
+#define v4l2_dev_to_atomisp_device(dev) \
+	container_of(dev, struct atomisp_device, v4l2_dev)
+
+extern struct v4l2_device atomisp_dev;
+
+extern void *atomisp_kernel_malloc(size_t bytes);
+
+extern void atomisp_kernel_free(void *ptr);
+
+#define MFLD_FW_PATH	"shisp_css15.bin"
+#ifdef CSS_2
+#ifdef SYSTEM_hive_isp_css_2400_system
+#define MRFLD_FW_PATH   "iaisp_2400_css.bin"
+#else
+#define MRFLD_FW_PATH   "iaisp_2400_cssA0.bin"
+#endif
+#else
+#define MRFLD_FW_PATH   "shisp_2400.bin"
+#endif
+
+#endif /* __ATOMISP_INTERNAL_H__ */
diff --git a/drivers/media/atomisp2/atomisp_ioctl.c b/drivers/media/atomisp2/atomisp_ioctl.c
new file mode 100644
index 0000000..c7d711c
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_ioctl.c
@@ -0,0 +1,2512 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/delay.h>
+
+//#include <asm/intel-mid.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-core.h>
+
+#include "atomisp_acc.h"
+#include "atomisp_compat.h"
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp-regs.h"
+
+#include "sh_css_hrt.h"
+#include "sh_css_debug.h"
+#include "gp_device.h"
+#include "device_access.h"
+#include "irq.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+
+/* for v4l2_capability */
+static const char *DRIVER = "atomisp";	/* max size 15 */
+static const char *CARD = "ATOM ISP";	/* max size 31 */
+static const char *BUS_INFO = "PCI-3";	/* max size 31 */
+static const u32 VERSION = DRIVER_VERSION;
+
+#ifdef ON_DEMAND_LOAD
+struct ia_css_env css_env = {
+                .cpu_mem_env.alloc = my_kernel_malloc,
+                .cpu_mem_env.free = atomisp_kernel_free,
+                .css_mem_env.alloc = atomisp_css2_mm_alloc,
+                .css_mem_env.free = atomisp_css2_mm_free,
+                .css_mem_env.load = atomisp_css2_mm_load,
+                .css_mem_env.store = atomisp_css2_mm_store,
+                .css_mem_env.set = atomisp_css2_mm_set,
+                .css_mem_env.mmap = atomisp_css2_mm_mmap,
+
+                .hw_access_env.store_8 = atomisp_css2_hw_store_8,
+                .hw_access_env.store_16 = atomisp_css2_hw_store_16,
+                .hw_access_env.store_32 = atomisp_css2_hw_store_32,
+
+                .hw_access_env.load_8 = atomisp_css2_hw_load_8,
+                .hw_access_env.load_16 = atomisp_css2_hw_load_16,
+                .hw_access_env.load_32 = atomisp_css2_hw_load_32,
+
+                .hw_access_env.load = atomisp_css2_hw_load,
+                .hw_access_env.store = atomisp_css2_hw_store,
+
+                .print_env.debug_print = atomisp_css2_dbg_print,
+                .print_env.error_print = atomisp_css2_err_print,
+};
+#endif
+
+/*
+ * FIXME: ISP should not know beforehand all CIDs supported by sensor.
+ * Instead, it needs to propagate to sensor unkonwn CIDs.
+ */
+static struct v4l2_queryctrl ci_v4l2_controls[] = {
+	{
+		.id = V4L2_CID_AUTO_WHITE_BALANCE,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Automatic White Balance",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_RED_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Red Balance",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_BLUE_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Blue Balance",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_GAMMA,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Gamma",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_HFLIP,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image h-flip",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_VFLIP,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image v-flip",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.type = V4L2_CTRL_TYPE_MENU,
+		.name = "Light frequency filter",
+		.minimum = 1,
+		.maximum = 2,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_COLORFX,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image Color Effect",
+		.minimum = 0,
+		.maximum = 9,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Bad Pixel Correction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "GDC/CAC",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_VIDEO_STABLIZATION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Video Stablization",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_FIXED_PATTERN_NR,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Fixed Pattern Noise Reduction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "False Color Correction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_REQUEST_FLASH,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Request flash frames",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_LOW_LIGHT,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Low light mode",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Horizontal binning factor",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Vertical binning factor",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_2A_STATUS,
+		.type = V4L2_CTRL_TYPE_BITMASK,
+		.name = "AE and AWB status",
+		.minimum = 0,
+		.maximum = V4L2_2A_STATUS_AE_READY | V4L2_2A_STATUS_AWB_READY,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_EXPOSURE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "exposure",
+		.minimum = -4,
+		.maximum = 4,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_SCENE_MODE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "scene mode",
+		.minimum = 0,
+		.maximum = 13,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ISO_SENSITIVITY,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "iso",
+		.minimum = -4,
+		.maximum = 4,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "white balance",
+		.minimum = 0,
+		.maximum = 9,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_EXPOSURE_METERING,
+		.type = V4L2_CTRL_TYPE_MENU,
+		.name = "metering",
+		.minimum = 0,
+		.maximum = 2,
+		.step = 1,
+		.default_value = 1,
+	},
+};
+static const u32 ctrls_num = ARRAY_SIZE(ci_v4l2_controls);
+
+/*
+ * supported V4L2 fmts and resolutions
+ */
+const struct atomisp_format_bridge atomisp_output_fmts[] = {
+	{
+		.pixelformat = V4L2_PIX_FMT_YUV420,
+		.depth = 12,
+		.mbus_code = 0x8001,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV420,
+		.description = "YUV420, planner"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_YVU420,
+		.depth = 12,
+		.mbus_code = 0x8002,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_YV12,
+		.description = "YVU420, planner"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_YUV422P,
+		.depth = 16,
+		.mbus_code = 0x8003,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV422,
+		.description = "YUV422, planner"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_YUV444,
+		.depth = 24,
+		.mbus_code = 0x8004,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV444,
+		.description = "YUV444"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_NV12,
+		.depth = 12,
+		.mbus_code = 0x8005,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_NV12,
+		.description = "NV12, interleaved"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_NV21,
+		.depth = 12,
+		.mbus_code = 0x8006,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_NV21,
+		.description = "NV21, interleaved"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_NV16,
+		.depth = 16,
+		.mbus_code = 0x8007,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_NV16,
+		.description = "NV16, interleaved"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_YUYV,
+		.depth = 16,
+		.mbus_code = 0x8008,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_YUYV,
+		.description = "YUYV, interleaved"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_UYVY8_1X16,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
+		.description = "UYVY, interleaved"
+	}, { /* This one is for parallel sensors! DO NOT USE! */
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_UYVY8_2X8,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
+		.description = "UYVY, interleaved"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SBGGR16,
+		.depth = 16,
+		.mbus_code = 0x8009,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 16"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SBGGR8,
+		.depth = 8,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR8_1X8,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGBRG8,
+		.depth = 8,
+		.mbus_code = V4L2_MBUS_FMT_SGBRG8_1X8,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGRBG8,
+		.depth = 8,
+		.mbus_code = V4L2_MBUS_FMT_SGRBG8_1X8,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SRGGB8,
+		.depth = 8,
+		.mbus_code = V4L2_MBUS_FMT_SRGGB8_1X8,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SBGGR10,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 10"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGBRG10,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SGBRG10_1X10,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 10"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGRBG10,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SGRBG10_1X10,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 10"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SRGGB10,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SRGGB10_1X10,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 10"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SBGGR12,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 12"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGBRG12,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 12"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SGRBG12,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 12"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_SRGGB12,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+		.description = "Bayer 12"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_RGB32,
+		.depth = 32,
+		.mbus_code = 0x800a,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RGBA888,
+		.description = "32 RGB 8-8-8-8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_RGB24,
+		.depth = 32,
+		.mbus_code = 0x800b, /* TODO verify this MBUS code */
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RGBA888,
+		.description = "24 RGB 8-8-8"
+	}, {
+		.pixelformat = V4L2_PIX_FMT_RGB565,
+		.depth = 16,
+		.mbus_code = V4L2_MBUS_FMT_RGB565_2X8_LE,
+		.sh_fmt = IA_CSS_FRAME_FORMAT_RGB565,
+		.description = "16 RGB 5-6-5"
+	},
+};
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge(
+	unsigned int pixelformat)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
+		if (atomisp_output_fmts[i].pixelformat == pixelformat)
+			return &atomisp_output_fmts[i];
+	}
+
+	return NULL;
+}
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
+	enum v4l2_mbus_pixelcode mbus_code)
+{
+	unsigned int i;
+	trace_printk("mbus code requested 0X%X\n", mbus_code);
+	for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
+		if (mbus_code == atomisp_output_fmts[i].mbus_code)
+			return &atomisp_output_fmts[i];
+	}
+
+	return NULL;
+}
+
+unsigned int atomisp_get_pipe_index(struct atomisp_sub_device *isp_subdev,
+				    enum atomisp_pipe_type pipe_type)
+{
+	switch (pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+					|| !isp_subdev->enable_vfpp->val)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else
+			return (unsigned int) IA_CSS_PIPE_ID_CAPTURE;
+	case ATOMISP_PIPE_VIEWFINDER:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else if (!atomisp_is_mbuscode_raw(
+				 isp_subdev->
+				 fmt[isp_subdev->capture_pad].fmt.code))
+			return (unsigned int) IA_CSS_PIPE_ID_CAPTURE;
+	case ATOMISP_PIPE_PREVIEW:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else		
+			return (unsigned int) IA_CSS_PIPE_ID_PREVIEW;
+	case ATOMISP_PIPE_FILEINPUT:
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int __get_css_frame_info(struct atomisp_sub_device *isp_subdev,
+				enum atomisp_pipe_type pipe_type,
+				struct ia_css_frame_info *frame_info)
+{
+	enum ia_css_err ret;
+	struct ia_css_pipe_info info;
+	int pipe_index = atomisp_get_pipe_index(isp_subdev, pipe_type);
+
+	if (pipe_index >= IA_CSS_PIPE_ID_NUM)
+		return -EINVAL;
+
+	ret = ia_css_pipe_get_info(isp_subdev->css2_basis.pipes[pipe_index],
+					   &info);
+	if (ret != IA_CSS_SUCCESS)
+		return -EINVAL;
+
+	switch (pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		*frame_info = info.output_info;
+		break;
+	case ATOMISP_PIPE_VIEWFINDER:
+		*frame_info = info.vf_output_info;
+		break;
+	case ATOMISP_PIPE_PREVIEW:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			*frame_info = info.vf_output_info;
+		else
+			*frame_info = info.output_info;
+		break;
+	default:
+		frame_info = NULL;
+		break;
+	}
+	return frame_info ? 0 : -EINVAL;
+}
+
+/*
+ * v4l2 ioctls
+ * return ISP capabilities
+ *
+ * FIXME: capabilities should be different for video0/video2/video3
+ */
+static int atomisp_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap)
+{
+	int ret = 0;
+
+	memset(cap, 0, sizeof(struct v4l2_capability));
+
+	WARN_ON(sizeof(DRIVER) > sizeof(cap->driver) ||
+		sizeof(CARD) > sizeof(cap->card) ||
+		sizeof(BUS_INFO) > sizeof(cap->bus_info));
+
+	strncpy(cap->driver, DRIVER, sizeof(cap->driver) - 1);
+	strncpy(cap->card, CARD, sizeof(cap->card) - 1);
+	strncpy(cap->bus_info, BUS_INFO, sizeof(cap->card) - 1);
+
+	cap->version = VERSION;
+
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+	    V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+
+	return ret;
+}
+
+/*
+ * return sensor chip identification
+ */
+static int atomisp_g_chip_ident(struct file *file, void *fh,
+	struct v4l2_dbg_chip_ident *chip)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int ret = 0;
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			       core, g_chip_ident, chip);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "failed to g_chip_ident for sensor\n");
+	return ret;
+}
+
+/*
+ * enum input are used to check primary/secondary camera
+ */
+static int atomisp_enum_input(struct file *file, void *fh,
+	struct v4l2_input *input)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	
+	int index = input->index;
+
+	if (index >= isp->input_cnt)
+		return -EINVAL;
+
+	if (!isp->inputs[index].camera)
+		return -EINVAL;
+
+	memset(input, 0, sizeof(struct v4l2_input));
+	strncpy(input->name, isp->inputs[index].camera->name,
+		sizeof(input->name) - 1);
+
+	/*
+	 * HACK: append actuator's name to sensor's
+	 * As currently userspace can't talk directly to subdev nodes, this
+	 * ioctl is the only way to enum inputs + possible external actuators
+	 * for 3A tuning purpose.
+	 */
+	if (isp->inputs[index].motor &&
+	    strlen(isp->inputs[index].motor->name) > 0) {
+		const int cur_len = strnlen(input->name, 32);
+		const int max_size = sizeof(input->name) - cur_len - 1;
+
+		if (max_size > 0) {
+			input->name[cur_len] = '+';
+			strncpy(&input->name[cur_len + 1],
+				isp->inputs[index].motor->name, max_size - 1);
+		}
+	}
+
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+	input->index = index;
+	input->reserved[0] = isp->inputs[index].type;
+	input->reserved[1] = isp->inputs[index].port;
+
+	return 0;
+}
+
+static unsigned int atomisp_streaming_count(struct atomisp_sub_device *isp_subdev)
+{
+	//TODO DMA
+	return isp_subdev->video_out_preview.vb2q.streaming
+		+ isp_subdev->video_out_capture.vb2q.streaming
+		+ isp_subdev->video_in.vb2q.streaming;
+}
+
+/*
+ * get input are used to get current primary/secondary camera
+ */
+static int atomisp_g_input(struct file *file, void *fh, unsigned int *input)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	mutex_lock(&isp->mutex);
+	*input = isp_subdev->input_curr;
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+}
+
+
+/*
+ * set input are used to set current primary/secondary camera
+ */
+static int atomisp_s_input(struct file *file, void *fh, unsigned int port)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_subdev *camera = NULL;
+	int ret;
+	int i, input = 0;
+	int mipi_port = (int)port;
+	
+
+	mutex_lock(&isp->mutex);
+	if (mipi_port >= ATOM_ISP_MAX_INPUTS) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "input_cnt: %d\n",isp->input_cnt);
+		ret = -EINVAL;
+		goto error;
+	}
+	
+	if(mipi_port < 0)
+		input = 0; /* always use the first default one */
+	else
+	{
+	  /* convernt to input index from a physical mipi port */
+	  for(i = 0; i < ATOM_ISP_MAX_INPUTS; i++) {
+	    if(isp->inputs[i].port == mipi_port) {
+	      input = i;
+	      break;
+	    }  
+	  }
+	  if( i == ATOM_ISP_MAX_INPUTS) {
+		v4l2_err(&atomisp_dev,
+			 "%s, no camera on mipi port=%d\n",__func__, mipi_port);
+		ret = -EINVAL;
+		goto error;
+	  }
+	}  
+	trace_printk("Input selected: index=%d mipi-port=%d num_lanes=%d\n", 
+	       input, isp->inputs[input].port, isp->inputs[input].num_lanes);  
+
+	/*
+	 * Checked whether the request camera:
+	 * 1: already in use
+	 * 2: if in use, whether it is by other streams
+	 */
+	if (isp->inputs[input].used_by > -1 &&
+	    isp->inputs[input].used_by != isp_subdev->index) {
+		v4l2_err(&atomisp_dev,
+			 "%s, camera is already used by:%d\n", __func__,
+			 isp->inputs[input].used_by);
+		ret = -EBUSY;
+		goto error;
+	}
+	
+	camera = isp->inputs[input].camera;
+	if (!camera) {
+		v4l2_err(&atomisp_dev,
+			 "%s, no camera\n",__func__);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (atomisp_streaming_count(isp_subdev)) {
+		v4l2_err(&atomisp_dev,
+			 "ISP is still streaming, stop first\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* power off the current sensor, as it is not used this time */
+	if (isp->inputs[isp_subdev->input_curr].used_by == isp_subdev->index &&
+		isp_subdev->input_curr != input) {
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_power, 0);
+		if (ret)
+			v4l2_warn(&atomisp_dev,
+				    "Failed to power-off previous sensor\n");
+	}
+
+	/* powe on the new sensor */
+	if (!isp->sw_contex.file_input) {
+		ret = v4l2_subdev_call(isp->inputs[input].camera,
+				       core, s_power, 1);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "Failed to power-on new sensor\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+	if (!isp->sw_contex.file_input && isp->inputs[input].motor)
+			ret = v4l2_subdev_call(isp->inputs[input].motor, core,
+					       init, 1);
+	}
+
+	isp_subdev->input_curr = input;
+	/* marked this camera is used by stream */
+	isp->inputs[input].used_by = isp_subdev->index;
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&isp->mutex);
+
+	return ret;
+}
+
+static int atomisp_enum_fmt_cap(struct file *file, void *fh,
+	struct v4l2_fmtdesc *f)
+{
+	if (f->index >= ARRAY_SIZE(atomisp_output_fmts))
+		return -EINVAL;
+
+	f->pixelformat = atomisp_output_fmts[f->index].pixelformat;
+	memset(f->description, 0, sizeof(f->description));
+	strncpy(f->description, atomisp_output_fmts[f->index].description,
+		strlen(atomisp_output_fmts[f->index].description));
+
+	return 0;
+}
+
+static int atomisp_g_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+
+	int ret;
+
+	mutex_lock(&isp->mutex);
+	ret = atomisp_get_fmt(vdev, f);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_g_fmt_file(struct file *file, void *fh,
+		struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	mutex_lock(&isp->mutex);
+	f->fmt.pix = pipe->pix;
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+}
+
+/* This function looks up the closest available resolution. */
+static int atomisp_try_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&isp->mutex);
+	ret = atomisp_try_fmt(vdev, f, NULL);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_s_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+	v4l2_dbg(4, dbg_level, &atomisp_dev,  "ENTER atomisp_s_fmt_cap\n");
+
+	mutex_lock(&isp->mutex);
+	ret = atomisp_set_fmt(vdev, f);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_s_fmt_file(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&isp->mutex);
+	ret = atomisp_set_fmt_file(vdev, f);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+/*
+ * is_resolution_supported - Check whether resolution is supported
+ * @width: check resolution width
+ * @height: check resolution height
+ *
+ * Return 1 on supported or 0 otherwise.
+*/
+static int is_resolution_supported(u32 width, u32 height)
+{
+	if ((width > ATOM_ISP_MIN_WIDTH) && (width <= ATOM_ISP_MAX_WIDTH) &&
+	    (height > ATOM_ISP_MIN_HEIGHT) && (height <= ATOM_ISP_MAX_HEIGHT)) {
+		if (!(width % ATOM_ISP_STEP_WIDTH) &&
+		    !(height % ATOM_ISP_STEP_HEIGHT))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * This ioctl allows applications to enumerate all frame intervals that the
+ * device supports for the given pixel format and frame size.
+ *
+ * framerate =  1 / frameintervals
+ */
+static int atomisp_enum_frameintervals(struct file *file, void *fh,
+	struct v4l2_frmivalenum *arg)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	int ret;
+
+	if (arg->index != 0)
+		return -EINVAL;
+
+	if (!atomisp_get_format_bridge(arg->pixel_format))
+		return -EINVAL;
+
+	if (!is_resolution_supported(arg->width, arg->height))
+		return -EINVAL;
+
+	mutex_lock(&isp->mutex);
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+		video, enum_frameintervals, arg);
+
+	if (ret) {
+		/* set the FPS to default 15*/
+		arg->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+		arg->discrete.numerator = 1;
+		arg->discrete.denominator = 15;
+	}
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+}
+
+void atomisp_free_css_frames(struct vb2_queue *q)
+{
+	struct atomisp_vb2 *avb2;
+	int i;
+	for (i = 0; i < q->num_buffers; i++) {
+		avb2 = container_of(q->bufs[i], struct atomisp_vb2, vb);
+		ia_css_frame_free(avb2->cssframe);
+		avb2->cssframe = NULL;
+	}
+}
+
+int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_s3a_buf *s3a_buf = NULL;
+	struct atomisp_dvs_buf *dvs_buf = NULL;
+	/* 2 css pipes consuming 3a buffers */
+	int count = ATOMISP_CSS_Q_DEPTH * 2;
+
+	trace_printk("ENTER atomisp_alloc_css_stat_bufs\n");
+
+	if (!list_empty(&isp_subdev->s3a_stats) && !list_empty(&isp_subdev->dvs_stats))
+		return 0;
+
+	while (count--) {
+		if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+			v4l2_dbg(5, dbg_level, &atomisp_dev,
+				 "allocating %d 3a buffers\n", count);
+			s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);
+			if (!s3a_buf) {
+				v4l2_err(&atomisp_dev, "s3a stat buf alloc failed\n");
+				goto s3a_error;
+			}
+
+			s3a_buf->s3a_stat =
+			    ia_css_isp_3a_statistics_allocate(&isp_subdev->params.curr_grid_info.s3a_grid);
+			if (!s3a_buf->s3a_stat) {
+				v4l2_err(&atomisp_dev,
+					 "3a stat buf allocation failed\n");
+				kfree(s3a_buf);
+				goto s3a_error;
+			}
+			list_add_tail(&s3a_buf->list, &isp_subdev->s3a_stats);
+		}
+
+		if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+			v4l2_dbg(2, dbg_level, &atomisp_dev,
+				 "allocating %d dvs buffers\n", count);
+			dvs_buf = kzalloc(sizeof(struct atomisp_dvs_buf), GFP_KERNEL);
+			if (!dvs_buf) {
+				v4l2_err(&atomisp_dev, "dis stat buf alloc failed\n");
+				goto dvs_error;
+			}
+
+			dvs_buf->dvs_stat =
+			    ia_css_isp_dvs_statistics_allocate(&isp_subdev->params.curr_grid_info.dvs_grid);
+			if (!dvs_buf->dvs_stat) {
+				v4l2_err(&atomisp_dev,
+					 "dvs stat buf allocation failed\n");
+				kfree(dvs_buf);
+				goto dvs_error;
+			}
+			list_add_tail(&dvs_buf->list, &isp_subdev->dvs_stats);
+		}
+
+	}
+
+	trace_printk("EXIT atomisp_alloc_css_stat_bufs\n");
+	return 0;
+dvs_error:
+	v4l2_err(&atomisp_dev,
+		    "failed to allocate statistics buffers\n");
+
+	while (!list_empty(&isp_subdev->dvs_stats)) {
+		dvs_buf = list_entry(isp_subdev->dvs_stats.next,
+				     struct atomisp_dvs_buf, list);
+		ia_css_isp_dvs_statistics_free(dvs_buf->dvs_stat);
+		list_del(&dvs_buf->list);
+		kfree(dvs_buf);
+	}
+s3a_error:
+	while (!list_empty(&isp_subdev->s3a_stats)) {
+		s3a_buf = list_entry(isp_subdev->s3a_stats.next,
+					   struct atomisp_s3a_buf, list);
+		ia_css_isp_3a_statistics_free(s3a_buf->s3a_stat);
+		list_del(&s3a_buf->list);
+		kfree(s3a_buf);
+	}
+	trace_printk("ERROR in atomisp_alloc_css_stat_bufs\n");
+	return -ENOMEM;
+}
+
+/*
+ * Initiate Memory Mapping or User Pointer I/O
+ */
+int __atomisp_reqbufs(struct file *file, void *fh,
+	struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct ia_css_frame_info frame_info;
+	struct ia_css_frame *frame;
+	struct atomisp_vb2 *avb2;
+	int ret = 0, i = 0;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "Enter __atomisp_reqbufs, count=%d, req->mem=%d, req->type=%d\n", 
+		req->count, req->memory, req->type);
+
+	ret =  vb2_ioctl_reqbufs(file, fh, req);
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "Return value from vb2_ioctl_reqbufs=%d\n", ret);
+	if (req->count == 0) {
+		return 0; //TODO DMA is this check needed?
+	}
+	if (ret)
+		return ret;
+
+	atomisp_alloc_css_stat_bufs(isp_subdev);
+
+	/*
+	 * for user pointer type, buffers are not really allcated here,
+	 * buffers are setup in QBUF operation through v4l2_buffer structure
+	 */
+	if (req->memory == V4L2_MEMORY_USERPTR || req->memory == V4L2_MEMORY_DMABUF)
+		return 0;
+
+	ret = __get_css_frame_info(isp_subdev, pipe->pipe_type, &frame_info);
+	if (ret)
+		return -EINVAL;
+
+	/*
+	 * Allocate the real frame here for selected node using our
+	 * memory management function
+	 */
+	for (i = 0; i < req->count; i++) {
+		if (ia_css_frame_allocate_from_info(&frame, &frame_info)) {
+			v4l2_err(&atomisp_dev, "ERROR allocating css frame, buf=%d\n", i);
+			goto error;
+		}
+		avb2 = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		avb2->cssframe = frame;
+	}
+	printk("Exiting successfully from __atomisp_reqbufs\n");
+	return ret;
+
+error:
+	while (i--) {
+		avb2 = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		ia_css_frame_free(avb2->cssframe);
+		avb2->cssframe = NULL;
+	}
+
+	if (isp_subdev->vf_frame)
+		ia_css_frame_free(isp_subdev->vf_frame);
+
+	return -ENOMEM;
+}
+
+int atomisp_reqbufs(struct file *file, void *fh,
+	struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	mutex_lock(&isp->mutex);
+	ret = __atomisp_reqbufs(file, fh, req);
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+
+	return ret;
+}
+
+static int atomisp_reqbufs_file(struct file *file, void *fh,
+		struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	if (req->count == 0) {
+		atomisp_free_css_frames(&pipe->vb2outq);	
+	}	
+	return vb2_reqbufs(&pipe->vb2outq, req);
+}
+
+/* application query the status of a buffer */
+static int atomisp_querybuf(struct file *file, void *fh,
+	struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	return vb2_querybuf(&pipe->vb2q, buf);
+}
+
+static int atomisp_querybuf_file(struct file *file, void *fh,
+				struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	return vb2_querybuf(&pipe->vb2outq, buf);
+}
+
+/*
+ * Applications call the VIDIOC_QBUF ioctl to enqueue an empty (capturing) or
+ * filled (output) buffer in the drivers incoming queue.
+ */
+static int atomisp_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	unsigned long userptr = 0; 
+	struct vb2_queue *q = vdev->queue;
+	struct vb2_buffer *vb2 = q->bufs[buf->index];
+	struct atomisp_vb2 *avb2 = container_of(vb2, struct atomisp_vb2, vb);
+	struct ia_css_frame_info frame_info;
+	struct ia_css_frame *handle = NULL;
+	u32 length;
+	u32 pgnr;
+	int ret = 0;
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER atomisp_qbuf\n");
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	
+	mutex_lock(&isp->mutex);
+	if (isp->isp_fatal_error) {
+		ret = -EIO;
+		goto error;
+	}
+
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
+		v4l2_err(&atomisp_dev, "ISP ERROR\n");
+		ret = -EIO;
+		goto error;
+	}
+
+	if (!buf || buf->index >= VIDEO_MAX_FRAME || 
+		!pipe->vb2q.bufs[buf->index]) {
+		v4l2_err(&atomisp_dev,
+			    "Invalid index for qbuf.\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "atomisp_qbuf fd=%d, VB2_BUF_STATE=%d\n", buf->m.fd, vdev->queue->bufs[buf->index]->state);
+	ret = vb2_ioctl_qbuf(file, fh, buf); //This will call atomisp_vb2_buf_queue 
+	if (ret) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "ERROR with vb2_ioctl_qbuf\n");
+	   	goto error;
+	}
+
+	if (buf->memory == V4L2_MEMORY_DMABUF) {
+		struct vb2_dc_buf *dc_buf;
+		struct hrt_userbuffer_attr attributes;
+		length = vb2_plane_size(vb2, 0);
+		pgnr = (length + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		attributes.pgnr = pgnr;
+		attributes.type = HRT_KERNEL_PTR;
+		dc_buf = (struct vb2_dc_buf*) vb2->planes[0].mem_priv;
+		attributes.priv = (void*) dc_buf->dma_sgt;
+
+		if (__get_css_frame_info(isp_subdev, pipe->pipe_type,
+             &frame_info)) {
+      			ret = -EIO;
+      			goto error;
+    		}
+
+		ret = ia_css_frame_map(&handle, &frame_info, 0,
+               0, &attributes);
+
+    		if (ret != IA_CSS_SUCCESS) {
+      			dev_err(isp->dev, "Failed ia_css_frame_dma \n");
+      			ret = -ENOMEM;
+      			goto error;
+    		}
+
+		if (avb2->cssframe) {
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "WARNING cssframe already exists or was not initialized to NULL\n");
+			ia_css_frame_free(avb2->cssframe);
+			avb2->cssframe = NULL;
+		}
+		avb2->cssframe = handle;
+
+		//Note in vb2 do not need to set V4L2_BUF_FLAG
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "DMA after vb2_ioctl_qbuf V4L2_BUF_FLAG=0X%X, buf fd=%d, index=%d, vaddr=%X\n", buf->flags, buf->m.fd,avb2->vb.v4l2_buf.index, avb2->cssframe->data);
+
+		goto cssqbuf;
+	}
+
+	/*
+	 * For userptr type frame, we convert user space address to physic
+	 * address and reprograme out page table properly
+	 */
+	if (buf->memory == V4L2_MEMORY_USERPTR) {
+		struct hrt_userbuffer_attr attributes;
+		userptr = buf->m.userptr;
+		length = vb2_plane_size(vb2, 0);
+
+		if (__get_css_frame_info(isp_subdev, pipe->pipe_type,
+				   &frame_info)) {
+			ret = -EIO;
+			goto error;
+		}
+
+		pgnr = (length + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		attributes.pgnr = pgnr;
+#ifdef CONFIG_ION
+		attributes.type = buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_ION
+					? HRT_USR_ION : HRT_USR_PTR;
+#else
+		attributes.type = HRT_USR_PTR;
+#endif
+		ret = ia_css_frame_map(&handle, &frame_info, (void *)userptr,
+				       0, &attributes);
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp->dev, "Failed to map user buffer\n");
+			ret = -ENOMEM;
+			goto error;
+		}
+
+		if (avb2->cssframe) {
+			ia_css_frame_free(avb2->cssframe);
+			avb2->cssframe = NULL;
+		}
+
+		avb2->cssframe = handle;
+	} else if (buf->memory == V4L2_MEMORY_MMAP) {
+	}
+
+cssqbuf:
+	
+	/* TODO: do this better, not best way to queue to css */
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED){
+		atomisp_qbuffers_to_css(isp_subdev, false);
+
+		if (!timer_pending(&isp->wdt) &&
+		    atomisp_buffers_queued(isp_subdev))
+			mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
+	}
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return ret;
+
+error:
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_qbuf_file(struct file *file, void *fh,
+					struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	if (buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+    v4l2_err(&atomisp_dev, "Unsupported buffer type\n");
+    return -EINVAL;
+  }
+	return vb2_qbuf(&pipe->vb2outq, buf);
+}
+
+/*
+ * Applications call the VIDIOC_DQBUF ioctl to dequeue a filled (capturing) or
+ * displayed (output buffer)from the driver's outgoing queue
+ */
+static int atomisp_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	int ret = 0;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	ret = vb2_ioctl_dqbuf(file, fh, buf);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s. Ret=%d\n", __func__, ret);
+	return ret;
+}
+
+enum ia_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device *isp_subdev)
+{
+	if (isp_subdev->params.continuous_vf &&
+	    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO)
+		return IA_CSS_PIPE_ID_PREVIEW;
+
+	if (!isp_subdev->enable_vfpp->val)
+		return IA_CSS_PIPE_ID_CAPTURE;
+
+	switch (isp_subdev->run_mode->val) {
+	case ATOMISP_RUN_MODE_PREVIEW:
+		return IA_CSS_PIPE_ID_PREVIEW;
+	case ATOMISP_RUN_MODE_VIDEO:
+		return IA_CSS_PIPE_ID_VIDEO;
+	case ATOMISP_RUN_MODE_STILL_CAPTURE:
+		/* fall through */
+	default:
+		return IA_CSS_PIPE_ID_CAPTURE;
+	}
+}
+
+int atomisp_get_css_buf_type(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_video_pipe *pipe)
+{
+	if (pipe->pipe_type == ATOMISP_PIPE_CAPTURE ||
+	    (pipe->pipe_type == ATOMISP_PIPE_PREVIEW &&
+	     isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO))
+		return IA_CSS_BUFFER_TYPE_OUTPUT_FRAME;
+	else
+		return IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME;
+}
+
+static unsigned int atomisp_sensor_start_stream(struct atomisp_sub_device *isp_subdev)
+{
+	if (!isp_subdev->enable_vfpp->val)
+		return 1;
+
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
+	    (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE &&
+	     !atomisp_is_mbuscode_raw(
+		     isp_subdev->fmt[
+			     isp_subdev->capture_pad].fmt.code) &&
+	     !isp_subdev->params.continuous_vf))
+		return 2;
+	else
+		return 1;
+}
+
+
+/*
+ * This ioctl start the capture during streaming I/O.
+ */
+static int atomisp_streamon(struct file *file, void *fh,
+	enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	enum ia_css_pipe_id css_pipe_id;
+	unsigned int sensor_start_stream;
+	int ret = 0;
+#ifdef PUNIT_CAMERA_BUSY
+	u32 msg_ret;
+#endif
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (vb2_is_streaming(&pipe->vb2q)) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA WARNING: pipe->vb2q.streaming. Need to verify\n");
+		goto out;
+	}
+
+	/*
+	 * The number of streaming video nodes is based on which
+	 * binary is going to be run.
+	 */
+	sensor_start_stream = atomisp_sensor_start_stream(isp_subdev);
+
+	trace_printk("DMA About to call vb2_ioctl_streamon\n");
+	ret = vb2_ioctl_streamon(file, fh, type);
+	trace_printk("Return from streamon: %d\n", ret);
+	if (ret)
+		goto out;
+
+	if (atomisp_streaming_count(isp_subdev) > sensor_start_stream) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA atomisp_streaming_count(isp) > sensor_start_stream\n");
+		/* trigger still capture */
+		if (isp_subdev->params.continuous_vf &&
+		    pipe->pipe_type == ATOMISP_PIPE_CAPTURE &&
+		    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+			if (isp->delayed_init != ATOMISP_DELAYED_INIT_DONE){
+				flush_work(&isp->delayed_init_work);
+				mutex_unlock(&isp->mutex);
+				if (wait_for_completion_interruptible(
+						&isp->init_done) != 0)
+					return -ERESTARTSYS;
+				mutex_lock(&isp->mutex);
+			}
+			ret = ia_css_stream_capture(
+					isp_subdev->css2_basis.stream,
+					isp_subdev->params.offline_parm.num_captures,
+					isp_subdev->params.offline_parm.skip_frames,
+					isp_subdev->params.offline_parm.offset);
+			if (ret)
+				return -EINVAL;
+		}
+		atomisp_qbuffers_to_css(isp_subdev, false);
+		goto out;
+	}
+
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
+		atomisp_qbuffers_to_css(isp_subdev, false);
+		goto start_sensor;
+	}
+
+#ifdef PUNIT_CAMERA_BUSY
+	if (!IS_MRFLD && isp->need_gfx_throttle) {
+		/*
+		 * As per h/w architect and ECO 697611 we need to throttle the
+		 * GFX performance (freq) while camera is up to prevent peak
+		 * current issues. this is done by setting the camera busy bit.
+		 */
+		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
+		msg_ret |= 0x100;
+		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
+	}
+#endif
+
+	css_pipe_id = atomisp_get_css_pipe_id(isp_subdev);
+
+	ret = atomisp_acc_load_extensions(isp);
+	if (ret < 0) {
+		dev_err(isp->dev, "acc extension failed to load\n");
+		goto out;
+	}
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "About to call ia_css_start in atomisp_streamon\n");
+	ret = ia_css_start(isp_subdev, false);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "ia_css_start fails: %d\n", ret);
+		ret = -EINVAL;
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d] LINE:%d.\n",
+			 __func__, pipe->pipe_type, __LINE__);
+		goto out;
+	}
+
+	if (isp_subdev->params.continuous_vf &&
+	    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+		INIT_COMPLETION(isp->init_done);
+		isp->delayed_init = ATOMISP_DELAYED_INIT_QUEUED;
+		queue_work(isp->delayed_init_workq,
+			   &isp->delayed_init_work);
+	}
+
+	/* Make sure that update_isp_params is called at least once.*/
+	isp_subdev->params.css_update_params_needed = true;
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
+	atomic_set(&isp->sof_count, -1);
+	atomic_set(&isp->sequence, -1);
+	atomic_set(&isp->sequence_temp, -1);
+	atomic_set(&isp->wdt_count, 0);
+	if (isp->sw_contex.file_input)
+		isp->wdt_duration = ATOMISP_ISP_FILE_TIMEOUT_DURATION;
+	else
+		isp->wdt_duration = ATOMISP_ISP_TIMEOUT_DURATION;
+	isp->fr_status = ATOMISP_FRAME_STATUS_OK;
+	isp->sw_contex.invalid_frame = false;
+	isp_subdev->params.dvs_proj_data_valid = false;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA wdt_duration=%u, About to call atomisp_qbuffers_to_css\n", isp->wdt_duration);
+	atomisp_qbuffers_to_css(isp_subdev, false);
+
+	/* Only start sensor when the last streaming instance started */
+	/* File injection fails this check  */
+#if 0
+	if (atomisp_streaming_count(isp) < sensor_start_stream) {
+
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d] LINE:%d.\n",
+			 __func__, pipe->pipe_type, __LINE__);
+		goto out;
+	}
+#endif
+
+start_sensor:
+	if (isp->flash) {
+		ret += v4l2_subdev_call(isp->flash, core, s_power, 1);
+		isp_subdev->params.num_flash_frames = 0;
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+		atomisp_setup_flash(isp_subdev);
+	}
+
+	if (!isp->sw_contex.file_input) {
+		atomisp_control_irq_sof(isp);
+		atomisp_set_term_en_count(isp);
+
+		if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
+			dev_dbg(isp->dev, "dfs failed!\n");
+		} else {
+			if (IS_MRFLD &&
+				atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		}
+
+	/* stream on the sensor */
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       video, s_stream, 1);
+		if (ret) {
+			atomisp_reset(isp);
+			ret = -EINVAL;
+		}
+
+out:
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return ret;
+}
+
+int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct atomisp_vb2 *vb2 = NULL;
+	int ret;
+	unsigned long flags;
+	bool first_streamoff = false;
+#ifdef PUNIT_CAMERA_BUSY
+	u32 msg_ret;
+#endif
+
+	v4l2_dbg(2, dbg_level, &atomisp_dev, ">%s [%d]\n",
+				__func__, pipe->pipe_type);
+	BUG_ON(!mutex_is_locked(&isp->mutex));
+
+	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * do only streamoff for capture & vf pipes in
+	 * case of continuous capture
+	 */
+	if (isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO &&
+	    isp_subdev->params.continuous_vf &&
+	    pipe->pipe_type != ATOMISP_PIPE_PREVIEW) {
+
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "VB2 streamoff for continuous_vf not supported\n");
+		return -EINVAL;
+	}
+
+	if (!pipe->vb2q.streaming)
+		return 0;
+
+	atomisp_clear_frame_counters(isp_subdev);
+	spin_lock_irqsave(&isp->lock, flags);
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
+	    || isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STARTING) {
+		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
+		first_streamoff = true;
+	}
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (first_streamoff) {
+		mutex_unlock(&isp->mutex);
+		/* not disable watch dog if other streams still running */
+		if (!atomisp_subdev_streaming_count(isp_subdev->isp)) {
+			del_timer_sync(&isp->wdt);
+			cancel_work_sync(&isp->wdt_work);
+		}
+
+		/*
+		 * must stop sending pixels into GP_FIFO before stop
+		 * the pipeline.
+		 */
+		if (isp->sw_contex.file_input)
+			v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					video, s_stream, 0);
+
+		mutex_lock(&isp->mutex);
+		atomisp_acc_unload_extensions(isp);
+	}
+
+	spin_lock_irqsave(&isp->lock, flags);
+	if (atomisp_streaming_count(isp_subdev) <= 1)
+		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (!first_streamoff) {
+		ret = vb2_ioctl_streamoff(file, fh,  type);
+		if (ret)
+			return ret;
+		goto stopsensor;
+	}
+
+	if (!isp->sw_contex.file_input)
+		atomisp_control_irq_sof(isp);
+
+	if (isp->delayed_init == ATOMISP_DELAYED_INIT_QUEUED) {
+		cancel_work_sync(&isp->delayed_init_work);
+		isp->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+	}
+
+	ret = ia_css_stop(isp_subdev, false);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "stop css failed, ret=%d.\n", ret);
+		return ret;
+	}
+
+	//TODO DMA wake up interruptible pipes
+    	ret = vb2_ioctl_streamoff(file, fh,  type);
+
+    	atomisp_clear_css_buffer_counters(isp_subdev);
+
+	if (ret)
+		return ret;
+
+	/* cleanup css here */
+	/* no need for this, as ISP will be reset anyway */
+	/*atomisp_flush_bufs_in_css(isp);*/
+
+	spin_lock_irqsave(&pipe->irq_lock, flags);
+	
+while (!list_empty(&pipe->activeq)) {
+		vb2 = list_first_entry(&pipe->activeq, struct atomisp_vb2, list);
+		if (!vb2)
+			break;
+		list_del(&vb2->list);
+	}
+	spin_unlock_irqrestore(&pipe->irq_lock, flags);
+
+stopsensor:
+	if (atomisp_streaming_count(isp_subdev) + 1
+	    != atomisp_sensor_start_stream(isp_subdev)) {
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d]\n",
+			 __func__, pipe->pipe_type);
+		return 0;
+	}
+
+	if (!isp->sw_contex.file_input)
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       video, s_stream, 0);
+
+	if (isp->flash) {
+		ret += v4l2_subdev_call(isp->flash, core, s_power, 0);
+		isp_subdev->params.num_flash_frames = 0;
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+	}
+	
+	/* if other streams are running, we should not power off isp */
+	if (atomisp_subdev_streaming_count(isp))
+		return 0;
+
+#ifdef PUNIT_CAMERA_BUSY
+	if (!IS_MRFLD && isp->need_gfx_throttle) {
+		/* Free camera_busy bit */
+		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
+		msg_ret &= ~0x100;
+		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
+	}
+#endif
+
+	if (IS_MRFLD && atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW))
+		v4l2_warn(&atomisp_dev, "DFS failed.\n");
+	/*
+	 * ISP work around, need to reset isp
+	 * Is it correct time to reset ISP when first node does streamoff?
+	 */
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_UP)
+	{
+		atomisp_reset(isp);
+	}
+
+	v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d]\n",
+		 __func__, pipe->pipe_type);
+	return ret;
+}
+
+static int atomisp_streamoff(struct file *file, void *fh,
+			     enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int rval;
+
+	mutex_lock(&isp->mutex);
+	rval = __atomisp_streamoff(file, fh, type);
+	mutex_unlock(&isp->mutex);
+
+	return rval;
+}
+
+/*
+ * To get the current value of a control.
+ * applications initialize the id field of a struct v4l2_control and
+ * call this ioctl with a pointer to this structure
+ */
+static int atomisp_g_ctrl(struct file *file, void *fh,
+	struct v4l2_control *control)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == control->id) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	mutex_lock(&isp->mutex);
+
+	switch (control->id) {
+	case V4L2_CID_IRIS_ABSOLUTE:
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+	case V4L2_CID_FNUMBER_ABSOLUTE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_2A_STATUS:
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_SCENE_MODE:
+	case V4L2_CID_ISO_SENSITIVITY:
+	case V4L2_CID_EXPOSURE_METERING:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_SHARPNESS:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, g_ctrl, control);
+	case V4L2_CID_COLORFX:
+		ret = atomisp_color_effect(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
+		ret = atomisp_bad_pixel(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
+		ret = atomisp_gdc_cac(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
+		ret = atomisp_video_stable(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
+		ret = atomisp_fixed_pattern(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
+		ret = atomisp_false_color(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_LOW_LIGHT:
+		ret = atomisp_low_light(isp_subdev, 0, &control->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+/*
+ * To change the value of a control.
+ * applications initialize the id and value fields of a struct v4l2_control
+ * and call this ioctl.
+ */
+static int atomisp_s_ctrl(struct file *file, void *fh,
+			  struct v4l2_control *control)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == control->id) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	mutex_lock(&isp->mutex);
+	switch (control->id) {
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_SCENE_MODE:
+	case V4L2_CID_ISO_SENSITIVITY:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+	case V4L2_CID_EXPOSURE_METERING:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_SHARPNESS:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_ctrl, control);
+	case V4L2_CID_COLORFX:
+		ret = atomisp_color_effect(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
+		ret = atomisp_bad_pixel(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
+		ret = atomisp_gdc_cac(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
+		ret = atomisp_video_stable(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
+		ret = atomisp_fixed_pattern(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
+		ret = atomisp_false_color(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_REQUEST_FLASH:
+		ret = atomisp_flash_enable(isp_subdev, control->value);
+		break;
+	case V4L2_CID_ATOMISP_LOW_LIGHT:
+		ret = atomisp_low_light(isp_subdev, 1, &control->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+/*
+ * To query the attributes of a control.
+ * applications set the id field of a struct v4l2_queryctrl and call the
+ * this ioctl with a pointer to this structure. The driver fills
+ * the rest of the structure.
+ */
+static int atomisp_queryctl(struct file *file, void *fh,
+			    struct v4l2_queryctrl *qc)
+{
+	int i, ret = -EINVAL;
+
+	if (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL)
+		return ret;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == qc->id) {
+			memcpy(qc, &ci_v4l2_controls[i],
+			       sizeof(struct v4l2_queryctrl));
+			qc->reserved[0] = 0;
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+
+	return ret;
+}
+
+static int atomisp_camera_g_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_control ctrl;
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		switch (ctrl.id) {
+		case V4L2_CID_EXPOSURE_ABSOLUTE:
+		case V4L2_CID_IRIS_ABSOLUTE:
+		case V4L2_CID_FNUMBER_ABSOLUTE:
+		case V4L2_CID_BIN_FACTOR_HORZ:
+		case V4L2_CID_BIN_FACTOR_VERT:
+			/*
+			 * Exposure related control will be handled by sensor
+			 * driver
+			 */
+			ret = v4l2_subdev_call(isp->inputs
+					       [isp_subdev->input_curr].camera,
+					       core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_STATUS:
+		case V4L2_CID_FOCUS_AUTO:
+			if (isp->inputs[isp_subdev->input_curr].motor)
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, g_ctrl, &ctrl);
+			else
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FLASH_STATUS:
+		case V4L2_CID_FLASH_INTENSITY:
+		case V4L2_CID_FLASH_TORCH_INTENSITY:
+		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
+		case V4L2_CID_FLASH_TIMEOUT:
+		case V4L2_CID_FLASH_STROBE:
+		case V4L2_CID_FLASH_MODE:
+			if (isp->flash)
+				ret = v4l2_subdev_call(
+					isp->flash, core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_ZOOM_ABSOLUTE:
+			mutex_lock(&isp->mutex);
+			ret = atomisp_digital_zoom(isp_subdev, 0, &ctrl.value);
+			mutex_unlock(&isp->mutex);
+			break;
+		case V4L2_CID_G_SKIP_FRAMES:
+			ret = v4l2_subdev_call(
+				isp->inputs[isp_subdev->input_curr].camera,
+				sensor, g_skip_frames, (u32 *)&ctrl.value);
+			break;
+		default:
+			ret = -EINVAL;
+		}
+
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+		c->controls[i].value = ctrl.value;
+	}
+	return ret;
+}
+
+/* This ioctl allows the application to get multiple controls by class */
+static int atomisp_g_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct v4l2_control ctrl;
+	int i, ret = 0;
+
+	/* input_lock is not need for the Camera releated IOCTLs
+	 * The input_lock downgrade the FPS of 3A*/
+	ret = atomisp_camera_g_ext_ctrls(file, fh, c);
+	if (ret != -EINVAL)
+		return ret;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		ret = atomisp_g_ctrl(file, fh, &ctrl);
+		c->controls[i].value = ctrl.value;
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int atomisp_camera_s_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_control ctrl;
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < c->count; i++) {
+		struct v4l2_ctrl *ctr;
+
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		switch (ctrl.id) {
+		case V4L2_CID_EXPOSURE_ABSOLUTE:
+		case V4L2_CID_IRIS_ABSOLUTE:
+		case V4L2_CID_FNUMBER_ABSOLUTE:
+		case V4L2_CID_VCM_TIMEING:
+		case V4L2_CID_VCM_SLEW:
+		case V4L2_CID_TEST_PATTERN:
+			ret = v4l2_subdev_call(
+				isp->inputs[isp_subdev->input_curr].camera,
+				core, s_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_STATUS:
+		case V4L2_CID_FOCUS_AUTO:
+			if (isp->inputs[isp_subdev->input_curr].motor)
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, s_ctrl, &ctrl);
+			else
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, s_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FLASH_STATUS:
+		case V4L2_CID_FLASH_INTENSITY:
+		case V4L2_CID_FLASH_TORCH_INTENSITY:
+		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
+		case V4L2_CID_FLASH_TIMEOUT:
+		case V4L2_CID_FLASH_STROBE:
+		case V4L2_CID_FLASH_MODE:
+			mutex_lock(&isp->mutex);
+			if (isp->flash) {
+				ret = v4l2_subdev_call(isp->flash,
+					core, s_ctrl, &ctrl);
+				/* When flash mode is changed we need to reset
+				 * flash state */
+				if (ctrl.id == V4L2_CID_FLASH_MODE) {
+					isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+					isp_subdev->params.num_flash_frames = 0;
+				}
+			}
+			mutex_unlock(&isp->mutex);
+			break;
+		case V4L2_CID_ZOOM_ABSOLUTE:
+			mutex_lock(&isp->mutex);
+			ret = atomisp_digital_zoom(isp_subdev, 1, &ctrl.value);
+			mutex_unlock(&isp->mutex);
+			break;
+		default:
+			ctr = v4l2_ctrl_find(&isp_subdev->ctrl_handler,
+					     ctrl.id);
+			if (ctr)
+				ret = v4l2_ctrl_s_ctrl(ctr, ctrl.value);
+			else
+				ret = -EINVAL;
+		}
+
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+		c->controls[i].value = ctrl.value;
+	}
+	return ret;
+}
+
+/* This ioctl allows the application to set multiple controls by class */
+static int atomisp_s_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct v4l2_control ctrl;
+	int i, ret = 0;
+
+	/* input_lock is not need for the Camera releated IOCTLs
+	 * The input_lock downgrade the FPS of 3A*/
+	ret = atomisp_camera_s_ext_ctrls(file, fh, c);
+	if (ret != -EINVAL)
+		return ret;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		ret = atomisp_s_ctrl(file, fh, &ctrl);
+		c->controls[i].value = ctrl.value;
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+	}
+	return ret;
+}
+
+/*
+ * vidioc_g/s_param are used to switch isp running mode
+ */
+static int atomisp_g_parm(struct file *file, void *fh,
+	struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+	parm->parm.capture.capturemode = isp_subdev->run_mode->val;
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+}
+
+static int atomisp_s_parm(struct file *file, void *fh,
+	struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_subdev_frame_interval fi;
+	int mode;
+	int rval;
+
+#ifdef ON_DEMAND_LOAD	
+	if(!atomisp_subdev_streaming_count(isp))
+	{
+        	char *fw_path = IS_MRFLD ? MRFLD_FW_PATH : MFLD_FW_PATH;
+
+        	request_firmware(&isp->firmware, fw_path, isp->dev);
+
+        	isp->css_fw.data = (void *)isp->firmware->data;
+        	isp->css_fw.bytes = isp->firmware->size;
+
+        	if (ia_css_init(&css_env,
+                        	&isp->css_fw,
+                        	(uint32_t)isp->mmu_base_addr,
+                        	IA_CSS_IRQ_TYPE_PULSE)) {
+                	printk(KERN_ERR "ia_css_init failed\n");
+        	}
+	}
+
+        atomisp_dev_init_struct(isp);
+#endif
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	v4l2_dbg(4, dbg_level, &atomisp_dev,  "ENTER atomisp_s_parm\n");
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+
+	switch (parm->parm.capture.capturemode) {
+	case CI_MODE_NONE:
+		trace_printk("CI_MODE_NONE\n");
+		memset(&fi, 0, sizeof(fi));
+		fi.interval = parm->parm.capture.timeperframe;
+
+		rval = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					video, s_frame_interval, &fi);
+		if (!rval)
+			parm->parm.capture.timeperframe = fi.interval;
+		goto out;
+	case CI_MODE_VIDEO:
+		trace_printk("CI_MODE_VIDEO\n");
+		mode = ATOMISP_RUN_MODE_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		trace_printk("CI_MODE_STILL_CAPTURE\n");
+		mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
+		break;
+	case CI_MODE_CONTINUOUS:
+		trace_printk("CI_MODE_CONTINOUS\n");
+		mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE;
+		break;
+	case CI_MODE_PREVIEW:
+		trace_printk("CI_MODE_PREVIEW\n");
+		mode = ATOMISP_RUN_MODE_PREVIEW;
+		break;
+	default:
+		rval = -EINVAL;
+		goto out;
+	}
+
+	rval = v4l2_ctrl_s_ctrl(isp_subdev->run_mode, mode);
+
+out:
+	mutex_unlock(&isp->mutex);
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return rval == -ENOIOCTLCMD ? 0 : rval;
+}
+
+static int atomisp_s_parm_file(struct file *file, void *fh,
+				struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev =
+	    atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type for output\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * only isp_subdev[0] support file injection function.
+	 *
+	 * This is to simplify the driver design, since there would be no
+	 * context passed to atomisp_file.c to state which subdev is using the
+	 * file injection.
+	 *
+	 * Just hardcode in atomisp_file.c that isp_subdev[0] is always used.
+	 *
+	 * also, we should not have the obscure UCs that for example, one
+	 * stream is in sensor mode, while the other is in file injection.
+	 */
+	if (isp_subdev->index != 0)
+		return 0;
+
+	mutex_lock(&isp->mutex);
+	isp->sw_contex.file_input = 1;
+	mutex_unlock(&isp->mutex);
+
+	return 0;
+}
+
+/* set default atomisp ioctl value */
+static long atomisp_vidioc_default(struct file *file, void *fh,
+	bool valid_prio, int cmd, void *arg)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	int err;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	mutex_lock(&isp->mutex);
+	switch (cmd) {
+	case ATOMISP_IOC_G_XNR:
+		err = atomisp_xnr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_XNR:
+		err = atomisp_xnr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_NR:
+		err = atomisp_nr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_NR:
+		err = atomisp_nr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_TNR:
+		err = atomisp_tnr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_TNR:
+		err = atomisp_tnr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_HISTOGRAM:
+		err = atomisp_histogram(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_HISTOGRAM:
+		err = atomisp_histogram(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_BLACK_LEVEL_COMP:
+		err = atomisp_black_level(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_BLACK_LEVEL_COMP:
+		err = atomisp_black_level(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_EE:
+		err = atomisp_ee(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_EE:
+		err = atomisp_ee(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_DIS_STAT:
+		err = atomisp_get_dis_stat(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_DIS_COEFS:
+		err = atomisp_set_dis_coefs(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_DIS_VECTOR:
+		err = atomisp_set_dis_vector(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_PARM:
+		err = atomisp_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_PARM:
+		err = atomisp_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_3A_STAT:
+		err = atomisp_3a_stat(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GAMMA:
+		err = atomisp_gamma(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GAMMA:
+		err = atomisp_gamma(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GDC_TAB:
+		err = atomisp_gdc_cac_table(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GDC_TAB:
+		err = atomisp_gdc_cac_table(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_MACC:
+		err = atomisp_macc_table(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_MACC:
+		err = atomisp_macc_table(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:
+		err = atomisp_bad_pixel_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:
+		err = atomisp_bad_pixel_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:
+		err = atomisp_false_color_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:
+		err = atomisp_false_color_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_CTC:
+		err = atomisp_ctc(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_CTC:
+		err = atomisp_ctc(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_WHITE_BALANCE:
+		err = atomisp_white_balance_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_WHITE_BALANCE:
+		err = atomisp_white_balance_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_3A_CONFIG:
+		err = atomisp_3a_config_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_3A_CONFIG:
+		err = atomisp_3a_config_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_FPN_TABLE:
+		err = atomisp_fixed_pattern_table(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_ISP_MAKERNOTE:
+		err = atomisp_exif_makernote(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_SENSOR_MODE_DATA:
+		err = atomisp_get_sensor_mode_data(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:
+		mutex_unlock(&isp->mutex);
+		if (isp->inputs[isp_subdev->input_curr].motor)
+			return v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, ioctl, cmd, arg);
+		else
+			return v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, ioctl, cmd, arg);
+
+	case ATOMISP_IOC_S_EXPOSURE:
+	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					core, ioctl, cmd, arg);
+
+	case ATOMISP_IOC_ACC_LOAD:
+		err = atomisp_acc_load(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_LOAD_TO_PIPE:
+		err = atomisp_acc_load_to_pipe(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_UNLOAD:
+		err = atomisp_acc_unload(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_START:
+		err = atomisp_acc_start(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_WAIT:
+		err = atomisp_acc_wait(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_MAP:
+		err = atomisp_acc_map(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_UNMAP:
+		err = atomisp_acc_unmap(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_S_MAPPED_ARG:
+		err = atomisp_acc_s_mapped_arg(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_CLEAR_HMEM:
+		err = atomisp_acc_clear_hmem(isp, arg);
+		break;
+
+	case ATOMISP_IOC_CAMERA_BRIDGE:
+		err = -EINVAL;
+		break;
+
+	case ATOMISP_IOC_S_ISP_SHD_TAB:
+		err = atomisp_set_shading_table(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:
+		err = atomisp_gamma_correction(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:
+		err = atomisp_gamma_correction(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_S_PARAMETERS:
+		err = atomisp_set_parameters(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_CONT_CAPTURE_CONFIG:
+		err = atomisp_offline_capture_configure(isp_subdev, arg);
+		break;
+
+	default:
+		mutex_unlock(&isp->mutex);
+		return -EINVAL;
+	}
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return err;
+}
+
+const struct v4l2_ioctl_ops atomisp_ioctl_ops = {
+	.vidioc_querycap = atomisp_querycap,
+	.vidioc_g_chip_ident = atomisp_g_chip_ident,
+	.vidioc_enum_input = atomisp_enum_input,
+	.vidioc_g_input = atomisp_g_input,
+	.vidioc_s_input = atomisp_s_input,
+	.vidioc_queryctrl = atomisp_queryctl,
+	.vidioc_s_ctrl = atomisp_s_ctrl,
+	.vidioc_g_ctrl = atomisp_g_ctrl,
+	.vidioc_s_ext_ctrls = atomisp_s_ext_ctrls,
+	.vidioc_g_ext_ctrls = atomisp_g_ext_ctrls,
+	.vidioc_enum_fmt_vid_cap = atomisp_enum_fmt_cap,
+	.vidioc_try_fmt_vid_cap = atomisp_try_fmt_cap,
+	.vidioc_g_fmt_vid_cap = atomisp_g_fmt_cap,
+	.vidioc_s_fmt_vid_cap = atomisp_s_fmt_cap,
+	//.vidioc_s_fmt_type_private = atomisp_s_fmt_cap,
+	.vidioc_reqbufs = atomisp_reqbufs,
+	.vidioc_querybuf = atomisp_querybuf,
+	.vidioc_qbuf = atomisp_qbuf,
+	.vidioc_dqbuf = atomisp_dqbuf,
+	.vidioc_streamon = atomisp_streamon,
+	.vidioc_streamoff = atomisp_streamoff,
+	.vidioc_default = atomisp_vidioc_default,
+	.vidioc_enum_frameintervals = atomisp_enum_frameintervals,
+	.vidioc_s_parm = atomisp_s_parm,
+	.vidioc_g_parm = atomisp_g_parm,
+};
+
+const struct v4l2_ioctl_ops atomisp_file_ioctl_ops = {
+	.vidioc_querycap = atomisp_querycap,
+	.vidioc_g_fmt_vid_out = atomisp_g_fmt_file,
+	.vidioc_s_fmt_vid_out = atomisp_s_fmt_file,
+	.vidioc_s_parm = atomisp_s_parm_file,
+	.vidioc_reqbufs = atomisp_reqbufs_file,
+	.vidioc_querybuf = atomisp_querybuf_file,
+	.vidioc_qbuf = atomisp_qbuf_file,
+	/* .vidioc_streamon = atomisp_streamon_out, */
+};
diff --git a/drivers/media/atomisp2/atomisp_ioctl.h b/drivers/media/atomisp2/atomisp_ioctl.h
new file mode 100644
index 0000000..6208333
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_ioctl.h
@@ -0,0 +1,72 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_IOCTL_H__
+#define	__ATOMISP_IOCTL_H__
+
+#include <ia_css.h>
+#include <linux/dma-direction.h>
+
+struct atomisp_device;
+struct atomisp_video_pipe;
+
+/* Taken from videobuf2-dma-contig.c to extract dma_sgt
+ * to pass to CSS */
+struct vb2_dc_buf {
+  struct device     *dev;
+  void        *vaddr;
+  unsigned long     size;
+  dma_addr_t      dma_addr;
+  enum dma_data_direction   dma_dir;
+  struct sg_table     *dma_sgt;
+};
+
+extern const struct atomisp_format_bridge atomisp_output_fmts[];
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge(
+	unsigned int pixelformat);
+const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
+	enum v4l2_mbus_pixelcode mbus_code);
+
+int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *isp_subdev);
+
+int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type);
+int __atomisp_reqbufs(struct file *file, void *fh,
+		struct v4l2_requestbuffers *req);
+
+int atomisp_reqbufs(struct file *file, void *fh,
+			struct v4l2_requestbuffers *req);
+
+enum ia_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device *isp_subdev);
+
+int atomisp_get_css_buf_type(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_video_pipe *pipe);
+
+void atomisp_free_css_frames(struct vb2_queue *q);
+extern const struct v4l2_file_operations atomisp_file_fops;
+
+extern const struct v4l2_ioctl_ops atomisp_ioctl_ops;
+
+extern const struct v4l2_ioctl_ops atomisp_file_ioctl_ops;
+
+#endif /* __ATOMISP_IOCTL_H__ */
diff --git a/drivers/media/atomisp2/atomisp_subdev.c b/drivers/media/atomisp2/atomisp_subdev.c
new file mode 100644
index 0000000..1287c1c
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_subdev.c
@@ -0,0 +1,1026 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_internal.h"
+
+static const unsigned int isp_subdev_input_fmts[] = {
+	V4L2_MBUS_FMT_SGRBG10_1X10,
+	V4L2_MBUS_FMT_SRGGB10_1X10,
+	V4L2_MBUS_FMT_SBGGR10_1X10,
+	V4L2_MBUS_FMT_SGBRG10_1X10,
+};
+
+static const unsigned int isp_subdev_preview_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565 */
+	V4L2_MBUS_FMT_UYVY8_1X16,
+	V4L2_MBUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_NV21,
+};
+
+static const unsigned int isp_subdev_vf_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565 */
+	V4L2_MBUS_FMT_UYVY8_1X16,
+	V4L2_MBUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_NV21,
+};
+
+static const unsigned int isp_subdev_capture_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565, nv11, yuv422, nv16, yv16, yuy2 */
+	/* rgb565, rgb888 */
+	V4L2_MBUS_FMT_UYVY8_1X16,
+	V4L2_MBUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_YUV422P,
+	V4L2_PIX_FMT_YUV444,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_NV21,
+	V4L2_PIX_FMT_NV16,
+	V4L2_PIX_FMT_NV61,
+	V4L2_PIX_FMT_YUYV,
+	V4L2_PIX_FMT_UYVY,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_RGB32
+};
+
+const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {
+	{ V4L2_MBUS_FMT_SBGGR8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_BGGR },
+	{ V4L2_MBUS_FMT_SGBRG8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GBRG },
+	{ V4L2_MBUS_FMT_SGRBG8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GRBG },
+	{ V4L2_MBUS_FMT_SRGGB8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_RGGB },
+	{ V4L2_MBUS_FMT_SBGGR10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_BGGR },
+	{ V4L2_MBUS_FMT_SGBRG10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GBRG },
+	{ V4L2_MBUS_FMT_SGRBG10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GRBG },
+	{ V4L2_MBUS_FMT_SRGGB10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_RGGB },
+	{ V4L2_MBUS_FMT_SBGGR12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_BGGR },
+	{ V4L2_MBUS_FMT_SGBRG12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GBRG },
+	{ V4L2_MBUS_FMT_SGRBG12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GRBG },
+	{ V4L2_MBUS_FMT_SRGGB12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_RGGB },
+	{ V4L2_MBUS_FMT_UYVY8_1X16, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
+	{ 0x8003, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
+	{ V4L2_MBUS_FMT_RGB565_2X8_LE, ATOMISP_INPUT_FORMAT_RGB_565, 0 },
+	{ 0x800b, ATOMISP_INPUT_FORMAT_RGB_888, 0 },
+};
+
+const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
+	enum v4l2_mbus_pixelcode code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(atomisp_in_fmt_conv); i++)
+		if (code == atomisp_in_fmt_conv[i].code)
+			return &atomisp_in_fmt_conv[i];
+
+	return NULL;
+}
+
+/*
+ * V4L2 subdev operations
+ */
+
+/*
+ * isp_subdev_ioctl - CCDC module private ioctl's
+ * @sd: ISP V4L2 subdevice
+ * @cmd: ioctl command
+ * @arg: ioctl argument
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+static long isp_subdev_ioctl(struct v4l2_subdev *sd,
+	unsigned int cmd, void *arg)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/*
+ * isp_subdev_set_power - Power on/off the CCDC module
+ * @sd: ISP V4L2 subdevice
+ * @on: power on/off
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+static int isp_subdev_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int isp_subdev_subscribe_event(struct v4l2_subdev *sd,
+	struct v4l2_fh *fh,
+	struct v4l2_event_subscription *sub)
+{
+	if (sub->type != V4L2_EVENT_FRAME_SYNC &&
+	    sub->type != V4L2_EVENT_ATOMISP_3A_STATS_READY)
+		return -EINVAL;
+
+	return v4l2_event_subscribe(fh, sub, 16, NULL);
+}
+
+static int isp_subdev_unsubscribe_event(struct v4l2_subdev *sd,
+	struct v4l2_fh *fh,
+	struct v4l2_event_subscription *sub)
+{
+	return v4l2_event_unsubscribe(fh, sub);
+}
+
+/*
+ * isp_subdev_enum_mbus_code - Handle pixel format enumeration
+ * @sd: pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @code: pointer to v4l2_subdev_pad_mbus_code_enum structure
+ * return -EINVAL or zero on success
+ */
+static int isp_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_mbus_code_enum *code)
+{
+	switch (code->pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		if (code->index >= ARRAY_SIZE(isp_subdev_input_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_input_fmts[code->index];
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_preview_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_preview_output_fmts[code->index];
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_vf_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_vf_output_fmts[code->index];
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_capture_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_capture_output_fmts[code->index];
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int isp_subdev_validate_rect(struct v4l2_subdev *sd, uint32_t pad,
+				    uint32_t target)
+{
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return 0;
+		}
+		break;
+	default:
+		switch (target) {
+		case V4L2_SEL_TGT_COMPOSE:
+			return 0;
+		}
+		break;
+	}
+
+	return -EINVAL;
+}
+
+struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_fh *fh,
+					  uint32_t which, uint32_t pad,
+					  uint32_t target)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY) {
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return v4l2_subdev_get_try_crop(fh, pad);
+		case V4L2_SEL_TGT_COMPOSE:
+			return v4l2_subdev_get_try_compose(fh, pad);
+		}
+	}
+
+	switch (target) {
+	case V4L2_SEL_TGT_CROP:
+		return &isp_sd->fmt[pad].crop;
+	case V4L2_SEL_TGT_COMPOSE:
+		return &isp_sd->fmt[pad].compose;
+	}
+
+	return NULL;
+}
+
+struct v4l2_mbus_framefmt
+*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			 uint32_t which, uint32_t pad)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+
+	return &isp_sd->fmt[pad].fmt;
+}
+
+static void isp_get_fmt_rect(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     uint32_t which, struct v4l2_mbus_framefmt **ffmt,
+			     struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+			     struct v4l2_rect *comp[ATOMISP_SUBDEV_PADS_NUM])
+{
+	unsigned int i;
+
+	for (i = 0; i < ATOMISP_SUBDEV_PADS_NUM; i++) {
+		ffmt[i] = atomisp_subdev_get_ffmt(sd, fh, which, i);
+		crop[i] = atomisp_subdev_get_rect(sd, fh, which, i,
+						  V4L2_SEL_TGT_CROP);
+		comp[i] = atomisp_subdev_get_rect(sd, fh, which, i,
+						  V4L2_SEL_TGT_COMPOSE);
+	}
+}
+
+static void isp_subdev_propagate(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 uint32_t which, uint32_t pad, uint32_t target,
+				 uint32_t flags)
+{
+	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+		*comp[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect r;
+
+	if (flags & V4L2_SEL_FLAG_KEEP_CONFIG)
+		return;
+
+	isp_get_fmt_rect(sd, fh, which, ffmt, crop, comp);
+
+	memset(&r, 0, sizeof(r));
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		/* Only crop target supported on sink pad. */
+		r.width = ffmt[pad]->width;
+		r.height = ffmt[pad]->height;
+
+		atomisp_subdev_set_selection(
+			sd, fh, which, pad, target, flags, &r);
+		break;
+	}
+}
+
+static int isp_subdev_get_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_fh *fh,
+				    struct v4l2_subdev_selection *sel)
+{
+	int rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);
+	if (rval)
+		return rval;
+
+	sel->r = *atomisp_subdev_get_rect(sd, fh, sel->which, sel->pad,
+					  sel->target);
+
+	return 0;
+}
+
+static char *atomisp_pad_str[] = { "ATOMISP_SUBDEV_PAD_SINK",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_VF",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW" };
+
+int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh, uint32_t which,
+				 uint32_t pad, uint32_t target, uint32_t flags,
+				 struct v4l2_rect *r)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = isp_sd->isp;
+	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+		*comp[ATOMISP_SUBDEV_PADS_NUM];
+	unsigned int i;
+
+	isp_get_fmt_rect(sd, fh, which, ffmt, crop, comp);
+
+	dev_dbg(isp->dev,
+		"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\n",
+		atomisp_pad_str[pad], target == V4L2_SEL_TGT_CROP
+		? "V4L2_SEL_TGT_CROP" : "V4L2_SEL_TGT_COMPOSE",
+		r->left, r->top, r->width, r->height,
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
+		: "V4L2_SUBDEV_FORMAT_ACTIVE", flags);
+
+	r->width = rounddown(r->width, ATOM_ISP_STEP_WIDTH);
+	r->height = rounddown(r->height, ATOM_ISP_STEP_HEIGHT);
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK: {
+		/* Only crop target supported on sink pad. */
+		unsigned int dvs_w, dvs_h;
+
+		crop[pad]->width = ffmt[pad]->width;
+		crop[pad]->height = ffmt[pad]->height;
+
+		if (!isp->sw_contex.bypass && crop[pad]->width
+		    && crop[pad]->height)
+			crop[pad]->width -= pad_w, crop[pad]->height -= pad_h;
+
+		/* if subdev type is SOC camera,we do not need to set DVS */
+		if (isp->inputs[isp_sd->input_curr].type == SOC_CAMERA)
+			isp_sd->params.video_dis_en = 0;
+
+		if (isp_sd->params.video_dis_en &&
+		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+			/* This resolution contains 20 % of DVS slack
+			 * (of the desired captured image before
+			 * scaling, or 1 / 6 of what we get from the
+			 * sensor) in both width and height. Remove
+			 * it. */
+			crop[pad]->width = roundup(crop[pad]->width * 5 / 6,
+						   ATOM_ISP_STEP_WIDTH);
+			crop[pad]->height = roundup(crop[pad]->height * 5 / 6,
+						    ATOM_ISP_STEP_HEIGHT);
+		}
+
+		crop[pad]->width = min(crop[pad]->width, r->width);
+		crop[pad]->height = min(crop[pad]->height, r->height);
+
+		if (!(flags & V4L2_SEL_FLAG_KEEP_CONFIG)) {
+			for (i = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
+			     i <= ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW; i++) {
+				struct v4l2_rect tmp = *crop[pad];
+
+				atomisp_subdev_set_selection(
+					sd, fh, which, i, V4L2_SEL_TGT_COMPOSE,
+					flags, &tmp);
+			}
+		}
+
+		if (which == V4L2_SUBDEV_FORMAT_TRY)
+			break;
+
+		if (isp_sd->params.video_dis_en &&
+		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+			dvs_w = rounddown(crop[pad]->width / 5,
+					  ATOM_ISP_STEP_WIDTH);
+			dvs_h = rounddown(crop[pad]->height / 5,
+					  ATOM_ISP_STEP_HEIGHT);
+		} else {
+			dvs_w = dvs_h = 0;
+		}
+
+		isp_sd->css2_basis.pipe_configs[0].dvs_envelope.width = dvs_w;
+		isp_sd->css2_basis.pipe_configs[0].dvs_envelope.height = dvs_h;
+
+		isp_sd->css2_basis.stream_config.effective_res.width = crop[pad]->width;
+		isp_sd->css2_basis.stream_config.effective_res.height = crop[pad]->height;
+
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE: {
+		/* Only compose target is supported on source pads. */
+
+		if (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width
+		    && crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)
+			isp_sd->params.yuv_ds_en = false;
+		else
+			isp_sd->params.yuv_ds_en = true;
+
+		comp[pad]->width = r->width;
+		comp[pad]->height = r->height;
+
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+		comp[pad]->width = r->width;
+		comp[pad]->height = r->height;
+		break;
+	}
+
+	/* Set format dimensions on non-sink pads as well. */
+	if (pad != ATOMISP_SUBDEV_PAD_SINK) {
+		ffmt[pad]->width = comp[pad]->width;
+		ffmt[pad]->height = comp[pad]->height;
+	}
+
+	*r = *atomisp_subdev_get_rect(sd, fh, which, pad, target);
+
+	dev_dbg(isp->dev, "sel actual: l %d t %d w %d h %d\n",
+		r->left, r->top, r->width, r->height);
+
+	return 0;
+}
+
+static int isp_subdev_set_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_fh *fh,
+				    struct v4l2_subdev_selection *sel)
+{
+	int rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);
+	if (rval)
+		return rval;
+
+	return atomisp_subdev_set_selection(sd, fh, sel->which, sel->pad,
+					    sel->target, sel->flags, &sel->r);
+}
+
+static int atomisp_get_sensor_bin_factor(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_control ctrl;
+	int hbin, vbin;
+	int ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+	
+	if (isp->inputs[isp_subdev->input_curr].type == FILE_INPUT ||
+	isp->inputs[isp_subdev->input_curr].type == TEST_PATTERN)
+		return 0;
+
+	memset(&ctrl, 0, sizeof(ctrl));
+
+	ctrl.id = V4L2_CID_BIN_FACTOR_HORZ;
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, core,
+			       g_ctrl, &ctrl);
+	hbin = ctrl.value;
+	ctrl.id = V4L2_CID_BIN_FACTOR_VERT;
+	ret |= v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, core,
+				g_ctrl, &ctrl);
+	vbin = ctrl.value;
+
+	/*
+	 * ISP needs to know binning factor from sensor.
+	 * In case horizontal and vertical sensor's binning factors
+	 * are different or sensor does not support binning factor CID,
+	 * ISP will apply default 0 value.
+	 */
+	if (ret || hbin != vbin)
+		hbin = 0;
+
+	return hbin;
+}
+
+int atomisp_subdev_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			    uint32_t which, uint32_t pad,
+			    struct v4l2_mbus_framefmt *ffmt)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = isp_sd->isp;
+	struct v4l2_mbus_framefmt *__ffmt =
+		atomisp_subdev_get_ffmt(sd, fh, which, pad);
+
+	dev_dbg(isp->dev, "ffmt: pad %s w %d h %d code 0x%8.8x which %s\n",
+		atomisp_pad_str[pad], ffmt->width, ffmt->height, ffmt->code,
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
+		: "V4L2_SUBDEV_FORMAT_ACTIVE");
+
+	/* Set bypass mode. One must only set raw or non-raw formats
+	 * on the source pads. */
+	if (pad != ATOMISP_SUBDEV_PAD_SINK
+	    && which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		struct v4l2_mbus_framefmt *f =
+			atomisp_subdev_get_ffmt(sd, fh, which,
+						ATOMISP_SUBDEV_PAD_SINK);
+
+		isp->sw_contex.bypass = !atomisp_is_mbuscode_raw(f->code)
+			|| atomisp_is_mbuscode_raw(ffmt->code);
+	}
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK: {
+		const struct atomisp_in_fmt_conv *fc =
+			atomisp_find_in_fmt_conv(ffmt->code);
+
+		if (!fc) {
+			ffmt->code = atomisp_in_fmt_conv[0].code;
+			dev_dbg(isp->dev, "using 0x%8.8x instead\n",
+				ffmt->code);
+			fc = atomisp_find_in_fmt_conv(ffmt->code);
+			BUG_ON(!fc);
+		}
+
+		*__ffmt = *ffmt;
+
+		isp_subdev_propagate(sd, fh, which, pad,
+				     V4L2_SEL_TGT_CROP, 0);
+
+		if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp_sd->css2_basis.stream_config.input_res.width = ffmt->width; 
+			isp_sd->css2_basis.stream_config.input_res.height = ffmt->height; 
+			isp_sd->css2_basis.stream_config.sensor_binning_factor =
+			    atomisp_get_sensor_bin_factor(isp_sd);
+			isp_sd->css2_basis.stream_config.format = fc->in_sh_fmt;
+		}
+
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+		__ffmt->code = ffmt->code;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * isp_subdev_get_format - Retrieve the video format on a pad
+ * @sd : ISP V4L2 subdevice
+ * @fh : V4L2 subdev file handle
+ * @pad: Pad number
+ * @fmt: Format
+ *
+ * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
+ * to the format type.
+ */
+static int isp_subdev_get_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+	fmt->format = *atomisp_subdev_get_ffmt(sd, fh, fmt->which, fmt->pad);
+
+	return 0;
+}
+
+/*
+ * isp_subdev_set_format - Set the video format on a pad
+ * @sd : ISP subdev V4L2 subdevice
+ * @fh : V4L2 subdev file handle
+ * @pad: Pad number
+ * @fmt: Format
+ *
+ * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
+ * to the format type.
+ */
+static int isp_subdev_set_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+	return atomisp_subdev_set_ffmt(sd, fh, fmt->which, fmt->pad,
+				       &fmt->format);
+}
+
+/* V4L2 subdev core operations */
+static const struct v4l2_subdev_core_ops isp_subdev_v4l2_core_ops = {
+	 .ioctl = isp_subdev_ioctl,
+	 .s_power = isp_subdev_set_power,
+	 .subscribe_event = isp_subdev_subscribe_event,
+	 .unsubscribe_event = isp_subdev_unsubscribe_event,
+};
+
+/* V4L2 subdev pad operations */
+static const struct v4l2_subdev_pad_ops isp_subdev_v4l2_pad_ops = {
+	 .enum_mbus_code = isp_subdev_enum_mbus_code,
+	 .get_fmt = isp_subdev_get_format,
+	 .set_fmt = isp_subdev_set_format,
+	 .get_selection = isp_subdev_get_selection,
+	 .set_selection = isp_subdev_set_selection,
+};
+
+/* V4L2 subdev operations */
+static const struct v4l2_subdev_ops isp_subdev_v4l2_ops = {
+	 .core = &isp_subdev_v4l2_core_ops,
+	 .pad = &isp_subdev_v4l2_pad_ops,
+};
+
+static void isp_subdev_init_params(struct atomisp_sub_device *isp_subdev)
+{
+	/* parameters initialization */
+	INIT_LIST_HEAD(&isp_subdev->s3a_stats);
+	INIT_LIST_HEAD(&isp_subdev->dvs_stats);
+}
+
+/*
+* isp_subdev_link_setup - Setup isp subdev connections
+* @entity: ispsubdev media entity
+* @local: Pad at the local end of the link
+* @remote: Pad at the remote end of the link
+* @flags: Link flags
+*
+* return -EINVAL or zero on success
+*/
+static int isp_subdev_link_setup(struct media_entity *entity,
+	const struct media_pad *local,
+	const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = isp_sd->isp;
+	unsigned int i;
+
+	switch (local->index | media_entity_type(remote->entity)) {
+	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:
+		/* Read from the sensor CSI2-ports. */
+		if (!(flags & MEDIA_LNK_FL_ENABLED)) {
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
+			break;
+		}
+
+		if (isp_sd->input != ATOMISP_SUBDEV_INPUT_NONE)
+			return -EBUSY;
+
+		for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+			if (remote->entity != &isp->csi2_port[i].subdev.entity)
+				continue;
+
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_CSI2_PORT1 + i;
+			return 0;
+		}
+
+		return -EINVAL;
+
+	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_DEVNODE:
+		/* read from memory */
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (isp_sd->input >= ATOMISP_SUBDEV_INPUT_CSI2_PORT1 &&
+				isp_sd->input < (ATOMISP_SUBDEV_INPUT_CSI2_PORT1
+						+ ATOMISP_CAMERA_NR_PORTS))
+				return -EBUSY;
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_MEMORY;
+		} else {
+			if (isp_sd->input == ATOMISP_SUBDEV_INPUT_MEMORY)
+				isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
+		}
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* media operations */
+static const struct media_entity_operations isp_subdev_media_ops = {
+	 .link_setup = isp_subdev_link_setup,
+/*	 .set_power = v4l2_subdev_set_power,	*/
+};
+
+static int __atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_ctrl *ctrl = isp_subdev->run_mode;
+	struct v4l2_ctrl *c;
+	struct v4l2_streamparm p;
+	int modes[] = { CI_MODE_NONE,
+			CI_MODE_VIDEO,
+			CI_MODE_STILL_CAPTURE,
+			CI_MODE_CONTINUOUS,
+			CI_MODE_PREVIEW };
+	s32 mode;
+
+	if (ctrl->val != ATOMISP_RUN_MODE_VIDEO &&
+	    isp_subdev->params.continuous_vf)
+		mode = ATOMISP_RUN_MODE_PREVIEW;
+	else
+		mode = ctrl->val;
+
+	c = v4l2_ctrl_find(
+		isp->inputs[isp_subdev->input_curr].camera->ctrl_handler,
+		V4L2_CID_RUN_MODE);
+
+	if (c)
+		return v4l2_ctrl_s_ctrl(c, mode);
+
+	/* Fall back to obsolete s_parm */
+	memset(&p, 0, sizeof(p));
+
+	p.parm.capture.capturemode = modes[mode];
+
+	return v4l2_subdev_call(
+		isp->inputs[isp_subdev->input_curr].camera, video, s_parm, &p);
+}
+
+int atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev)
+{
+	int rval;
+
+	mutex_lock(&isp_subdev->ctrl_handler.lock);
+	rval = __atomisp_update_run_mode(isp_subdev);
+	mutex_unlock(&isp_subdev->ctrl_handler.lock);
+
+	return rval;
+}
+
+static int s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct atomisp_sub_device *isp_subdev = container_of(
+                ctrl->handler, struct atomisp_sub_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		return __atomisp_update_run_mode(isp_subdev);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = &s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ctrl_fmt_auto = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_FMT_AUTO,
+	.name = "Automatic format guessing",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.def = 1,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "Atomisp run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 1,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct v4l2_ctrl_config ctrl_enable_vfpp = {
+	.id = V4L2_CID_ENABLE_VFPP,
+	.name = "Atomisp vf postprocess",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.def = 1,
+	.max = 1,
+};
+
+/*
+ * isp_subdev_init_entities - Initialize V4L2 subdev and media entity
+ * @isp_subdev: ISP CCDC module
+ *
+ * Return 0 on success and a negative error code on failure.
+ */
+static int isp_subdev_init_entities(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_subdev *sd = &isp_subdev->subdev;
+	struct media_pad *pads = isp_subdev->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	isp_subdev->input = ATOMISP_SUBDEV_INPUT_NONE;
+
+	v4l2_subdev_init(sd, &isp_subdev_v4l2_ops);
+	strlcpy(sd->name, "ATOM ISP SUBDEV", sizeof(sd->name));
+	v4l2_set_subdevdata(sd, isp_subdev);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[ATOMISP_SUBDEV_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].flags = MEDIA_PAD_FL_SOURCE;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_VF].flags = MEDIA_PAD_FL_SOURCE;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].flags = MEDIA_PAD_FL_SOURCE;
+
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SINK].fmt.code =
+		V4L2_MBUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].fmt.code =
+		V4L2_MBUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_VF].fmt.code =
+		V4L2_MBUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].fmt.code =
+		V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	me->ops = &isp_subdev_media_ops;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+	ret = media_entity_init(me, ATOMISP_SUBDEV_PADS_NUM, pads, 0);
+	if (ret < 0)
+		return ret;
+
+	isp_subdev->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	isp_subdev->video_in.isp = isp_subdev->isp;
+	isp_subdev->video_in.isp_subdev = isp_subdev;
+	isp_subdev->video_in.pipe_type = ATOMISP_PIPE_FILEINPUT;
+	spin_lock_init(&isp_subdev->video_in.irq_lock);
+
+	isp_subdev->video_out_preview.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_preview.isp = isp_subdev->isp;
+	isp_subdev->video_out_preview.pipe_type = ATOMISP_PIPE_PREVIEW;
+	isp_subdev->video_out_preview.isp_subdev = isp_subdev;
+	spin_lock_init(&isp_subdev->video_out_preview.irq_lock);
+
+	isp_subdev->video_out_vf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_vf.isp = isp_subdev->isp;
+	isp_subdev->video_out_vf.isp_subdev = isp_subdev;
+	isp_subdev->video_out_vf.pipe_type = ATOMISP_PIPE_VIEWFINDER;
+	spin_lock_init(&isp_subdev->video_out_vf.irq_lock);
+
+	isp_subdev->video_out_capture.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_capture.isp = isp_subdev->isp;
+	isp_subdev->video_out_capture.isp_subdev = isp_subdev;
+	isp_subdev->video_out_capture.pipe_type = ATOMISP_PIPE_CAPTURE;
+	spin_lock_init(&isp_subdev->video_out_capture.irq_lock);
+
+	ret = atomisp_video_init(&isp_subdev->video_in, "MEMORY");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_capture, "CAPTURE");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_vf, "VIEWFINDER");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_preview, "PREVIEW");
+	if (ret < 0)
+		return ret;
+
+	/* Connect the isp subdev to the video node. */
+	ret = media_entity_create_link(&isp_subdev->video_in.vdev.entity,
+		0, &isp_subdev->subdev.entity, ATOMISP_SUBDEV_PAD_SINK, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW,
+		&isp_subdev->video_out_preview.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_VF,
+		&isp_subdev->video_out_vf.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+		&isp_subdev->video_out_capture.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_ctrl_handler_init(&isp_subdev->ctrl_handler, 1);
+	if (ret)
+		return ret;
+
+	isp_subdev->fmt_auto = v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						    &ctrl_fmt_auto, NULL);
+	isp_subdev->run_mode = v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						    &ctrl_run_mode, NULL);
+	isp_subdev->enable_vfpp =
+				v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						     &ctrl_enable_vfpp, NULL);
+
+	/* Make controls visible on subdev as well. */
+	isp_subdev->subdev.ctrl_handler = &isp_subdev->ctrl_handler;
+
+	return isp_subdev->ctrl_handler.error;
+}
+
+void atomisp_subdev_unregister_entities(struct atomisp_sub_device *isp_subdev)
+{
+	v4l2_ctrl_handler_free(&isp_subdev->ctrl_handler);
+
+	media_entity_cleanup(&isp_subdev->subdev.entity);
+
+	v4l2_device_unregister_subdev(&isp_subdev->subdev);
+	atomisp_video_unregister(&isp_subdev->video_in);
+	atomisp_video_unregister(&isp_subdev->video_out_preview);
+	atomisp_video_unregister(&isp_subdev->video_out_vf);
+	atomisp_video_unregister(&isp_subdev->video_out_capture);
+}
+
+int atomisp_subdev_register_entities(struct atomisp_sub_device *isp_subdev,
+	struct v4l2_device *vdev)
+{
+	int ret;
+
+	/* Register the subdev and video node. */
+	ret = v4l2_device_register_subdev(vdev, &isp_subdev->subdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_capture, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_vf, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_preview, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_in, vdev);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_subdev_unregister_entities(isp_subdev);
+	return ret;
+}
+
+
+/*
+ * atomisp_subdev_init - ISP Subdevice  initialization.
+ * @dev: Device pointer specific to the ATOM ISP.
+ *
+ * TODO: Get the initialisation values from platform data.
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+int atomisp_subdev_init(struct atomisp_device *isp)
+{
+	struct atomisp_sub_device *isp_subdev;
+	int ret = 0, i;
+	/*
+	 * CSS2.0 supports multiple streams
+	 */
+	isp->num_of_streams = IS_MRFLD ? MULTI_STREAM_NUM : 1;
+	isp->isp_subdev = kzalloc(sizeof(struct atomisp_sub_device) *
+				  isp->num_of_streams, GFP_KERNEL);
+	if(!isp->isp_subdev)
+	{
+		return -ENOMEM;
+	}
+
+	for(i =0; i< isp->num_of_streams; i++){
+		isp_subdev = &isp->isp_subdev[i];
+		spin_lock_init(&isp_subdev->lock);
+		isp_subdev->isp = isp;
+		isp_subdev->index = i;
+		isp_subdev_init_params(isp_subdev);
+		ret = isp_subdev_init_entities(isp_subdev);
+		if (ret < 0)
+		 	break;
+	}
+
+	return ret;
+}
+
+void atomisp_subdev_cleanup(struct atomisp_sub_device *isp_subdev)
+{
+	kfree(isp_subdev);
+}
+
diff --git a/drivers/media/atomisp2/atomisp_subdev.h b/drivers/media/atomisp2/atomisp_subdev.h
new file mode 100644
index 0000000..bc18615
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_subdev.h
@@ -0,0 +1,299 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_SUBDEV_H__
+#define __ATOMISP_SUBDEV_H__
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-core.h>
+
+#include "atomisp_common.h"
+#include "atomisp_v4l2.h"
+#include "ia_css.h"
+
+enum atomisp_subdev_input_entity {
+	ATOMISP_SUBDEV_INPUT_NONE,
+	ATOMISP_SUBDEV_INPUT_MEMORY,
+	ATOMISP_SUBDEV_INPUT_CSI2,
+	/*
+	 * The following enum for CSI2 port must go together in one row.
+	 * Otherwise it breaks the code logic.
+	 */
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT1,
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT2,
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT3,
+};
+
+#define ATOMISP_SUBDEV_PAD_SINK			0
+/* capture output for still and video frames */
+#define ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE	1
+/* viewfinder output for downscaled capture output */
+#define ATOMISP_SUBDEV_PAD_SOURCE_VF		2
+/* preview output for display */
+#define ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW	3
+#define ATOMISP_SUBDEV_PADS_NUM			4
+
+enum atomisp_pipe_type {
+	ATOMISP_PIPE_CAPTURE,
+	ATOMISP_PIPE_VIEWFINDER,
+	ATOMISP_PIPE_PREVIEW,
+	ATOMISP_PIPE_FILEINPUT
+};
+
+struct atomisp_in_fmt_conv {
+	enum v4l2_mbus_pixelcode code;
+	enum ia_css_stream_format in_sh_fmt;
+	enum ia_css_bayer_order bayer_order;
+};
+
+struct atomisp_3a_dis_stat_buf {
+	struct ia_css_isp_3a_statistics s3a_data;
+	struct ia_css_isp_dvs_statistics dvs_stat;
+	struct list_head list;
+};
+
+struct atomisp_s3a_buf {
+	struct ia_css_isp_3a_statistics *s3a_stat;
+	struct list_head list;
+};
+
+struct atomisp_dvs_buf {
+	struct ia_css_isp_dvs_statistics *dvs_stat;
+	struct list_head list;
+};
+
+struct atomisp_sub_device;
+
+struct atomisp_video_pipe {
+	struct video_device vdev;
+	enum v4l2_buf_type type;
+	struct media_pad pad;
+	struct vb2_queue vb2q;
+	struct vb2_queue vb2outq; /* Just for file injection */
+	struct list_head activeq;
+	struct list_head activeq_out;
+	unsigned int buffers_in_css;
+
+	/* irq_lock is used to protect video buffer state change operations and
+	 * also to make activeq, activeq_out, capq and outq list
+	 * operations atomic. */
+	spinlock_t irq_lock;
+	unsigned int users;
+	enum atomisp_pipe_type pipe_type;
+
+	struct atomisp_device *isp;
+	struct v4l2_pix_format pix;
+	uint32_t sh_fmt;
+	struct atomisp_sub_device *isp_subdev;
+	int field_sequence;
+	int previous_frame_exp_id;
+};
+
+struct atomisp_pad_format {
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+/* Internal states for flash process */
+enum atomisp_flash_state {
+        ATOMISP_FLASH_IDLE,
+        ATOMISP_FLASH_REQUESTED,
+        ATOMISP_FLASH_ONGOING,
+        ATOMISP_FLASH_DONE
+};
+
+enum atomisp_css2_stream_state {
+        CSS2_STREAM_UNINIT,
+        CSS2_STREAM_CREATED,
+        CSS2_STREAM_STARTED,
+        CSS2_STREAM_STOPPED,
+};
+
+struct atomisp_css_params {
+	int online_process;
+	int yuv_ds_en;
+	unsigned int color_effect;
+	bool gdc_cac_en;
+	bool macc_en;
+	bool bad_pixel_en;
+	bool video_dis_en;
+	bool sc_en;
+	bool fpn_en;
+	bool xnr_en;
+	bool low_light;
+	bool continuous_vf;
+	int false_color;
+	unsigned int histogram_elenum;
+	struct ia_css_isp_config config;
+
+	/* current configurations */
+	struct ia_css_dp_config   dp_config;
+	struct ia_css_wb_config   wb_config;
+	struct ia_css_cc_config   cc_config;
+	struct ia_css_nr_config   nr_config;
+	struct ia_css_ee_config   ee_config;
+	struct ia_css_ob_config   ob_config;
+	struct ia_css_de_config   de_config;
+	struct ia_css_ce_config   ce_config;
+	struct ia_css_gc_config   gc_config;
+	struct ia_css_tnr_config  tnr_config;
+	struct ia_css_3a_config   s3a_config;
+	struct ia_css_macc_config   macc_config;
+	struct ia_css_anr_config  anr_config;
+	struct ia_css_dz_config   dz_config;  /**< Digital Zoom */
+	struct ia_css_capture_config   capture_config;
+	struct ia_css_gamma_table gamma_table;
+	struct ia_css_ctc_table   ctc_table;
+	struct ia_css_macc_table  macc_table;
+	struct ia_css_xnr_table   xnr_table;
+	struct ia_css_dvs_coefficients dvs_coefs;
+	struct ia_css_vector  motion_vector;
+	/*
+	 * overlay removed from css 1.5
+	 * struct ia_css_overlay	*vf_overlay;
+	 */
+
+	/* Current grid info */
+	struct ia_css_grid_info curr_grid_info;
+
+	/* Intermediate buffers used to communicate data between
+	   CSS and user space. These are needed to perform the
+	   copy_to_user. */
+	struct ia_css_3a_statistics *s3a_user_stat;
+	int s3a_output_bytes;
+	bool s3a_buf_data_valid;
+
+	struct ia_css_dvs_coefficients *dvs_coeff;
+	struct ia_css_dvs_statistics *dvs_stat;
+	bool dvs_proj_data_valid;
+	int  dvs_hor_coef_bytes;
+	int  dvs_ver_coef_bytes;
+	int  dvs_ver_proj_bytes;
+	int  dvs_hor_proj_bytes;
+
+	/* Flash */
+	int num_flash_frames;
+	enum atomisp_flash_state flash_state;
+	enum atomisp_frame_status last_frame_status;
+	/* continuous capture */
+	struct atomisp_cont_capture_conf offline_parm;
+	/* Flag to check if driver needs to update params to css */
+	bool css_update_params_needed;
+};
+
+struct atomisp_css2_basis {
+	struct ia_css_stream *stream;
+	struct ia_css_stream_config stream_config;
+	struct ia_css_pipe *pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe_config pipe_configs[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe_extra_config pipe_extra_configs[IA_CSS_PIPE_ID_NUM];
+	bool update_pipe[IA_CSS_PIPE_ID_NUM];
+	unsigned int curr_pipe;
+	enum atomisp_css2_stream_state stream_state;
+};
+
+struct atomisp_sub_device {
+	struct v4l2_subdev subdev;
+	struct media_pad pads[ATOMISP_SUBDEV_PADS_NUM];
+	struct atomisp_pad_format fmt[ATOMISP_SUBDEV_PADS_NUM];
+	uint16_t capture_pad; /* main capture pad; defines much of isp config */
+	
+	struct atomisp_css_params params;
+
+	enum atomisp_subdev_input_entity input;
+	unsigned int output;
+	struct atomisp_video_pipe video_in;
+	struct atomisp_video_pipe video_out_capture; /* capture output */
+	struct atomisp_video_pipe video_out_vf;      /* viewfinder output */
+	struct atomisp_video_pipe video_out_preview; /* preview output */
+	/* struct isp_subdev_params params; */
+	spinlock_t lock;
+	struct atomisp_device *isp;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *fmt_auto;
+	struct v4l2_ctrl *run_mode;
+	struct v4l2_ctrl *enable_vfpp;
+
+	struct atomisp_css2_basis css2_basis;	
+
+	struct list_head s3a_stats;
+	struct list_head dvs_stats;
+        unsigned int s3a_bufs_in_css[IA_CSS_PIPE_ID_NUM];
+        unsigned int dis_bufs_in_css;
+
+
+	struct ia_css_frame *vf_frame; /* TODO: needed? */
+	struct ia_css_frame *raw_output_frame;
+	enum atomisp_frame_status frame_status[VIDEO_MAX_FRAME];
+
+	int input_curr;
+
+	unsigned int streaming; /* Hold both mutex and lock to change this */
+
+	/*
+	 * subdev index;
+	 * recored in resource(atomisp_input_subdev) to show which sub device
+	 * is using this resource
+	 */
+	int index;
+
+	/*
+	 * this is to notify all the buffers are dequeued from CSS.
+	 *
+	 * css2.0 bug: all the buffers needs to be dequeued after stream off
+	 */
+	struct completion buf_done;
+};
+
+extern const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[];
+
+const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
+	enum v4l2_mbus_pixelcode code);
+
+/* Get pointer to appropriate format */
+struct v4l2_mbus_framefmt
+*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			 uint32_t which, uint32_t pad);
+struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_fh *fh,
+					  uint32_t which, uint32_t pad,
+					  uint32_t target);
+int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh, uint32_t which,
+				 uint32_t pad, uint32_t target, uint32_t flags,
+				 struct v4l2_rect *r);
+/* Actually set the format */
+int atomisp_subdev_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			    uint32_t which, uint32_t pad,
+			    struct v4l2_mbus_framefmt *ffmt);
+
+int atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev);
+
+void atomisp_subdev_unregister_entities(struct atomisp_sub_device *isp_subdev);
+int atomisp_subdev_register_entities(struct atomisp_sub_device *isp_subdev,
+	struct v4l2_device *vdev);
+int atomisp_subdev_init(struct atomisp_device *isp);
+void atomisp_subdev_cleanup(struct atomisp_sub_device *isp_subdev);
+
+#endif /* __ATOMISP_SUBDEV_H__ */
diff --git a/drivers/media/atomisp2/atomisp_tables.h b/drivers/media/atomisp2/atomisp_tables.h
new file mode 100644
index 0000000..f9bf76a
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tables.h
@@ -0,0 +1,327 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef	__ATOMISP_TABLES_H__
+#define	__ATOMISP_TABLES_H__
+
+#include "sh_css_params.h"
+
+/*Sepia image effect table*/
+static struct ia_css_cc_config sepia_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {141, 18, 68, -40, -5, -19, 35, 4, 16},
+};
+
+/*Negative image effect table*/
+static struct ia_css_cc_config nega_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {255, 29, 120, 0, 374, 342, 0, 672, -301},
+};
+
+/*Mono image effect table*/
+static struct ia_css_cc_config mono_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {255, 29, 120, 0, 0, 0, 0, 0, 0},
+};
+
+/*Skin whiten image effect table*/
+static struct ia_css_macc_table skin_low_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	7168, 0, 2048, 8192,
+	5120, -1024, 2048, 8192,
+	8192, 2048, -1024, 5120,
+	8192, 2048, 0, 7168,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+static struct ia_css_macc_table skin_medium_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	5120, 0, 6144, 8192,
+	3072, -1024, 2048, 6144,
+	6144, 2048, -1024, 3072,
+	8192, 6144, 0, 5120,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+static struct ia_css_macc_table skin_high_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	4096, 0, 8192, 8192,
+	0, -2048, 4096, 6144,
+	6144, 4096, -2048, 0,
+	8192, 8192, 0, 4096,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+/*Blue enhencement image effect table*/
+static struct ia_css_macc_table blue_macc_table = {
+	.data = {
+	9728, -3072, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	9728, 0, -3072, 8192,
+	12800, 1536, -3072, 8192,
+	11264, 0, 0, 11264,
+	9728, -3072, 0, 11264
+	}
+};
+
+/*Green enhencement image effect table*/
+static struct ia_css_macc_table green_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	10240, 4096, 0, 8192,
+	10240, 4096, 0, 12288,
+	12288, 0, 0, 12288,
+	14336, -2048, 4096, 8192,
+	10240, 0, 4096, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+/* this table is from CSS1.5 default_ctc_table(20121003) */
+static struct ia_css_ctc_table vivid_ctc_table = {
+	.data.vamem_2 = {
+	0,  384,  837,  957, 1011, 1062, 1083, 1080,
+	1078, 1077, 1053, 1039, 1012,  992,  969,  951,
+	929,  906,  886,  866,  845,  823,  809,  790,
+	772,  758,  741,  726,  711,  701,  688,  675,
+	666,  656,  648,  639,  633,  626,  618,  612,
+	603,  594,  582,  572,  557,  545,  529,  516,
+	504,  491,  480,  467,  459,  447,  438,  429,
+	419,  412,  404,  397,  389,  382,  376,  368,
+	363,  357,  351,  345,  340,  336,  330,  326,
+	321,  318,  312,  308,  304,  300,  297,  294,
+	291,  286,  284,  281,  278,  275,  271,  268,
+	261,  257,  251,  245,  240,  235,  232,  225,
+	223,  218,  213,  209,  206,  204,  199,  197,
+	193,  189,  186,  185,  183,  179,  177,  175,
+	172,  170,  169,  167,  164,  164,  162,  160,
+	158,  157,  156,  154,  154,  152,  151,  150,
+	149,  148,  146,  147,  146,  144,  143,  143,
+	142,  141,  140,  141,  139,  138,  138,  138,
+	137,  136,  136,  135,  134,  134,  134,  133,
+	132,  132,  131,  130,  131,  130,  129,  128,
+	129,  127,  127,  127,  127,  125,  125,  125,
+	123,  123,  122,  120,  118,  115,  114,  111,
+	110,  108,  106,  105,  103,  102,  100,   99,
+	97,   97,   96,   95,   94,   93,   93,   91,
+	91,   91,   90,   90,   89,   89,   88,   88,
+	89,   88,   88,   87,   87,   87,   87,   86,
+	87,   87,   86,   87,   86,   86,   84,   84,
+	82,   80,   78,   76,   74,   72,   70,   68,
+	67,   65,   62,   60,   58,   56,   55,   54,
+	53,   51,   49,   49,   47,   45,   45,   45,
+	41,   40,   39,   39,   34,   33,   34,   32,
+	25,   23,   24,   20,   13,    9,   12,    0,
+	0
+	}
+};
+#if 0
+/*Color enhancement image effect table*/
+static struct ia_css_ctc_table vivid_ctc_table = {
+	.data = {
+	876, 872, 869, 865, 861, 858, 854, 850,
+	847, 843, 839, 835, 832, 828, 824, 821,
+	817, 813, 810, 806, 802, 799, 795, 791,
+	788, 784, 780, 777, 773, 769, 766, 762,
+	758, 754, 751, 747, 743, 740, 736, 732,
+	729, 725, 721, 718, 714, 710, 707, 703,
+	699, 696, 692, 688, 685, 681, 677, 673,
+	670, 666, 662, 659, 655, 651, 648, 644,
+	640, 637, 633, 629, 626, 622, 618, 615,
+	611, 607, 604, 600, 596, 592, 589, 585,
+	581, 578, 574, 570, 567, 563, 559, 556,
+	552, 548, 545, 541, 539, 537, 536, 534,
+	533, 531, 530, 528, 527, 525, 524, 522,
+	521, 519, 518, 516, 515, 514, 512, 511,
+	509, 508, 506, 505, 503, 502, 500, 499,
+	497, 496, 494, 493, 491, 490, 488, 487,
+	485, 484, 482, 481, 479, 478, 476, 475,
+	473, 472, 470, 469, 467, 466, 464, 463,
+	461, 460, 458, 457, 455, 454, 452, 451,
+	449, 448, 446, 445, 443, 442, 440, 439,
+	437, 436, 434, 433, 431, 430, 428, 427,
+	425, 424, 422, 421, 419, 418, 417, 415,
+	414, 412, 411, 409, 408, 406, 405, 403,
+	402, 400, 399, 397, 396, 394, 393, 392,
+	392, 391, 391, 390, 389, 389, 388, 388,
+	387, 387, 386, 385, 385, 384, 384, 383,
+	383, 382, 381, 381, 380, 380, 379, 379,
+	378, 377, 377, 376, 376, 375, 375, 374,
+	374, 373, 372, 372, 371, 371, 370, 370,
+	369, 368, 368, 367, 367, 366, 366, 365,
+	364, 364, 363, 363, 362, 362, 361, 360,
+	360, 359, 359, 358, 358, 357, 356, 356,
+	355, 355, 354, 354, 353, 352, 352, 351,
+	351, 350, 350, 349, 348, 348, 347, 347,
+	346, 346, 345, 344, 344, 343, 343, 342,
+	342, 341, 340, 340, 339, 339, 338, 338,
+	337, 336, 336, 335, 335, 334, 334, 333,
+	333, 332, 331, 331, 330, 330, 329, 329,
+	328, 327, 327, 326, 326, 325, 325, 324,
+	323, 323, 322, 322, 321, 321, 320, 319,
+	319, 318, 318, 317, 317, 316, 315, 315,
+	314, 314, 313, 313, 312, 311, 311, 310,
+	310, 309, 309, 308, 307, 307, 306, 306,
+	305, 305, 304, 303, 303, 302, 302, 301,
+	301, 300, 299, 299, 298, 298, 297, 297,
+	296, 296, 295, 294, 294, 293, 293, 292,
+	292, 291, 290, 290, 289, 289, 288, 288,
+	287, 286, 286, 285, 285, 284, 284, 283,
+	282, 282, 281, 281, 280, 280, 279, 278,
+	278, 277, 277, 276, 276, 275, 274, 274,
+	273, 273, 272, 272, 271, 270, 270, 269,
+	269, 268, 268, 267, 266, 266, 265, 265,
+	264, 264, 263, 262, 262, 261, 261, 260,
+	260, 259, 259, 258, 257, 257, 256, 256,
+	255, 255, 254, 253, 253, 252, 252, 251,
+	251, 250, 249, 249, 248, 248, 247, 247,
+	246, 245, 245, 244, 244, 243, 243, 242,
+	241, 241, 240, 240, 239, 239, 238, 237,
+	237, 236, 236, 235, 235, 234, 233, 233,
+	232, 232, 231, 231, 230, 229, 229, 228,
+	228, 227, 227, 226, 225, 225, 224, 224,
+	223, 223, 222, 221, 221, 220, 220, 219,
+	219, 218, 218, 217, 216, 216, 215, 215,
+	214, 214, 213, 212, 212, 211, 211, 210,
+	210, 209, 208, 208, 207, 207, 206, 206,
+	205, 204, 204, 203, 203, 202, 202, 201,
+	200, 200, 199, 199, 198, 198, 197, 196,
+	196, 195, 195, 194, 194, 193, 192, 192,
+	191, 191, 190, 190, 189, 188, 188, 187,
+	187, 186, 186, 185, 184, 184, 183, 183,
+	182, 182, 181, 181, 180, 179, 179, 178,
+	178, 177, 177, 176, 175, 175, 174, 174,
+	173, 173, 172, 171, 171, 170, 170, 169,
+	169, 168, 167, 167, 166, 166, 165, 165,
+	164, 163, 163, 163, 162, 162, 161, 161,
+	161, 160, 160, 159, 159, 159, 158, 158,
+	158, 157, 157, 156, 156, 156, 155, 155,
+	155, 154, 154, 153, 153, 153, 152, 152,
+	152, 151, 151, 150, 150, 150, 149, 149,
+	149, 148, 148, 147, 147, 147, 146, 146,
+	145, 145, 145, 144, 144, 144, 143, 143,
+	142, 142, 142, 141, 141, 141, 140, 140,
+	139, 139, 139, 138, 138, 138, 137, 137,
+	136, 136, 136, 135, 135, 134, 134, 134,
+	133, 133, 133, 132, 132, 131, 131, 131,
+	130, 130, 130, 129, 129, 128, 128, 128,
+	127, 127, 127, 126, 126, 125, 125, 125,
+	124, 124, 123, 123, 123, 122, 122, 122,
+	121, 121, 120, 120, 120, 119, 119, 119,
+	118, 118, 117, 117, 117, 116, 116, 116,
+	115, 115, 114, 114, 114, 113, 113, 112,
+	112, 112, 111, 111, 111, 110, 110, 109,
+	109, 109, 108, 108, 108, 107, 107, 106,
+	106, 106, 105, 105, 105, 104, 104, 103,
+	103, 103, 102, 102, 101, 101, 101, 100,
+	100, 100, 99, 99, 98, 98, 98, 97,
+	97, 97, 96, 96, 95, 95, 95, 94,
+	94, 94, 93, 93, 92, 92, 92, 91,
+	91, 91, 90, 90, 89, 89, 89, 88,
+	88, 87, 87, 87, 86, 86, 86, 85,
+	85, 84, 84, 84, 83, 83, 83, 82,
+	82, 81, 81, 81, 80, 80, 80, 79,
+	79, 78, 78, 78, 77, 77, 76, 76,
+	76, 75, 75, 75, 74, 74, 73, 73,
+	73, 72, 72, 72, 71, 71, 70, 70,
+	70, 69, 69, 69, 68, 68, 67, 67,
+	67, 66, 66, 65, 65, 65, 64, 64,
+	64, 63, 63, 61, 61, 61, 61, 61,
+	61, 60, 60, 58, 58, 58, 58, 58,
+	58, 57, 57, 56, 56, 56, 55, 55,
+	54, 54, 54, 53, 53, 53, 51, 51,
+	51, 51, 51, 50, 50, 50, 48, 48,
+	48, 48, 48, 47, 47, 47, 45, 45,
+	45, 45, 45, 44, 44, 42, 42, 42,
+	42, 42, 42, 41, 41, 40, 40, 40,
+	39, 39, 39, 38, 38, 37, 37, 37,
+	35, 35, 35, 35, 35, 34, 34, 34,
+	32, 32, 32, 32, 32, 31, 31, 31,
+	29, 29, 29, 29, 29, 28, 28, 28,
+	26, 26, 25, 25, 25, 25, 25, 25,
+	24, 24, 22, 22, 22, 22, 22, 22,
+	21, 21, 19, 19, 19, 19, 19, 18,
+	18, 18, 16, 16, 16, 16, 16, 15,
+	15, 15, 13, 13, 13, 12, 12, 12,
+	12, 12, 10, 10, 10, 9, 9, 9,
+	9, 9, 8, 8, 6, 6, 6, 6,
+	6, 6, 5, 5, 3, 3, 3, 3,
+	3, 3, 2, 2, 0, 0, 0, 0,
+	}
+};
+#endif
+#endif
diff --git a/drivers/media/atomisp2/atomisp_tpg.c b/drivers/media/atomisp2/atomisp_tpg.c
new file mode 100644
index 0000000..68c3b37
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tpg.c
@@ -0,0 +1,247 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_internal.h"
+#include "atomisp_tpg.h"
+
+static int tpg_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int tpg_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	if (!chip)
+		return -EINVAL;
+	return 0;
+}
+
+static int tpg_log_status(struct v4l2_subdev *sd)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int tpg_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int tpg_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_power(struct v4l2_subdev *sd, int on)
+{
+	/*
+	int x_delta = -2;
+	int y_delta = 3;
+	unsigned int x_mask  = (1 << 4) - 1;
+	unsigned int y_mask  = (1 << 4) - 1;
+	unsigned int xy_mask = (1 << 8) - 1;
+
+	sh_css_input_set_bayer_order(sh_css_bayer_order_grbg);
+	sh_css_input_set_format(SH_CSS_INPUT_FORMAT_RAW_10);
+	sh_css_input_configure_port(MIPI_PORT0_ID, 2, 0xffff4);
+	sh_css_tpg_configure(x_mask, x_delta, y_mask, y_delta, xy_mask);
+	sh_css_input_set_mode(SH_CSS_INPUT_MODE_TPG);
+	*/
+
+	return 0;
+}
+
+static int tpg_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frame_ival(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	/*to fake*/
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops tpg_video_ops = {
+	.s_stream = tpg_s_stream,
+	.g_parm = tpg_g_parm,
+	.s_parm = tpg_s_parm,
+	.enum_framesizes = tpg_enum_framesizes,
+	.enum_frameintervals = tpg_enum_frameintervals,
+	.enum_mbus_fmt = tpg_enum_mbus_fmt,
+	.try_mbus_fmt = tpg_try_mbus_fmt,
+	.g_mbus_fmt = tpg_g_mbus_fmt,
+	.s_mbus_fmt = tpg_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_core_ops tpg_core_ops = {
+	.g_chip_ident = tpg_g_chip_ident,
+	.log_status = tpg_log_status,
+	.queryctrl = tpg_queryctrl,
+	.g_ctrl = tpg_g_ctrl,
+	.s_ctrl = tpg_s_ctrl,
+	.s_power = tpg_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops tpg_pad_ops = {
+	.enum_mbus_code = tpg_enum_mbus_code,
+	.enum_frame_size = tpg_enum_frame_size,
+	.enum_frame_interval = tpg_enum_frame_ival,
+};
+
+static const struct v4l2_subdev_ops tpg_ops = {
+	.core = &tpg_core_ops,
+	.video = &tpg_video_ops,
+	.pad = &tpg_pad_ops,
+};
+
+void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg)
+{
+	media_entity_cleanup(&tpg->sd.entity);
+	v4l2_device_unregister_subdev(&tpg->sd);
+}
+
+int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
+			struct v4l2_device *vdev)
+{
+	int ret;
+	/* Register the subdev and video nodes. */
+	ret = v4l2_device_register_subdev(vdev, &tpg->sd);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_tpg_unregister_entities(tpg);
+	return ret;
+}
+
+void atomisp_tpg_cleanup(struct atomisp_device *isp)
+{
+
+}
+
+int atomisp_tpg_init(struct atomisp_device *isp)
+{
+	struct atomisp_tpg_device *tpg = &isp->tpg;
+	struct v4l2_subdev *sd = &tpg->sd;
+	struct media_pad *pads = tpg->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	tpg->isp = isp;
+	v4l2_subdev_init(sd, &tpg_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	strcpy(sd->name, "tpg_subdev");
+	v4l2_set_subdevdata(sd, tpg);
+
+	pads[0].flags = MEDIA_PAD_FL_SINK;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+
+	ret = media_entity_init(me, 1, pads, 0);
+	if (ret < 0)
+		goto fail;
+	return 0;
+fail:
+	atomisp_tpg_cleanup(isp);
+	return ret;
+}
diff --git a/drivers/media/atomisp2/atomisp_tpg.h b/drivers/media/atomisp2/atomisp_tpg.h
new file mode 100644
index 0000000..64ab60f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tpg.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_TPG_H__
+#define __ATOMISP_TPG_H__
+
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+
+struct atomisp_tpg_device {
+	struct v4l2_subdev sd;
+	struct atomisp_device *isp;
+	struct media_pad pads[1];
+};
+
+void atomisp_tpg_cleanup(struct atomisp_device *isp);
+int atomisp_tpg_init(struct atomisp_device *isp);
+void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg);
+int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
+			struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_TPG_H__ */
diff --git a/drivers/media/atomisp2/atomisp_v4l2.c b/drivers/media/atomisp2/atomisp_v4l2.c
new file mode 100644
index 0000000..a27778b
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_v4l2.c
@@ -0,0 +1,1227 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_file.h"
+#include "atomisp_ioctl.h"
+#include "atomisp_internal.h"
+#include "atomisp_acc.h"
+#include "atomisp-regs.h"
+#include "hmm/hmm.h"
+
+#include "device_access.h"
+#include "memory_access.h"
+
+/* set reserved memory pool size in page */
+unsigned int repool_pgnr;
+module_param(repool_pgnr, uint, 0644);
+MODULE_PARM_DESC(repool_pgnr,
+		"Set the reserved memory pool size in page (default:0)");
+
+bool dypool_enable;
+module_param(dypool_enable, bool, 0644);
+MODULE_PARM_DESC(dypool_enable,
+		"dynamic memory pool enable/disable (default:disable)");
+
+/* cross componnet debug message flag */
+int dbg_level = 2;
+module_param(dbg_level, int, 0644);
+MODULE_PARM_DESC(dbg_level, "debug message on/off (default:off)");
+
+int mipicsi_flag;
+module_param(mipicsi_flag, int, 0644);
+MODULE_PARM_DESC(mipicsi_flag, "mipi csi compression predictor algorithm");
+
+/*set to 16x16 since this is the amount of lines and pixels the sensor
+exports extra. If these are kept at the 10x8 that they were on, in yuv
+downscaling modes incorrect resolutions where requested to the sensor
+driver with strange outcomes as a result. The proper way tot do this
+would be to have a list of tables the specify the sensor res, mipi rec,
+output res, and isp output res. however since we do not have this yet,
+the chosen solution is the next best thing. */
+int pad_w = 16;
+module_param(pad_w, int, 0644);
+MODULE_PARM_DESC(pad_w, "extra data for ISP processing");
+
+int pad_h = 16;
+module_param(pad_h, int, 0644);
+MODULE_PARM_DESC(pad_h, "extra data for ISP processing");
+
+struct v4l2_device atomisp_dev = {
+	.name = "atomisp",
+};
+
+void __iomem *atomisp_io_base;
+
+int atomisp_pci_vendor; /* pci vendor id */
+int atomisp_pci_device; /* pci device id */
+
+int atomisp_video_init(struct atomisp_video_pipe *video, const char *name)
+{
+	int ret;
+	const char *direction;
+
+	switch (video->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		direction = "output";
+		video->pad.flags = MEDIA_PAD_FL_SINK;
+		video->vdev.fops = &atomisp_fops;
+		video->vdev.ioctl_ops = &atomisp_ioctl_ops;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		direction = "input";
+		video->pad.flags = MEDIA_PAD_FL_SOURCE;
+		video->vdev.fops = &atomisp_file_fops;
+		video->vdev.ioctl_ops = &atomisp_file_ioctl_ops;
+		video->vdev.vfl_dir = VFL_DIR_TX;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = media_entity_init(&video->vdev.entity, 1, &video->pad, 0);
+	if (ret < 0)
+		return ret;
+
+	/* Initialize the video device. */
+	snprintf(video->vdev.name, sizeof(video->vdev.name),
+		 "ATOMISP ISP %s %s", name, direction);
+	video->vdev.release = video_device_release_empty;
+	video_set_drvdata(&video->vdev, video->isp);
+
+	return 0;
+}
+
+int atomisp_video_register(struct atomisp_video_pipe *video,
+	struct v4l2_device *vdev)
+{
+	int ret;
+
+	video->vdev.v4l2_dev = vdev;
+
+	ret = video_register_device(&video->vdev, VFL_TYPE_GRABBER, -1);
+	if (ret < 0)
+		v4l2_err(&atomisp_dev,
+			"%s: could not register video device (%d)\n",
+			__func__, ret);
+
+	return ret;
+}
+
+void atomisp_video_unregister(struct atomisp_video_pipe *video)
+{
+	if (video_is_registered(&video->vdev)) {
+		media_entity_cleanup(&video->vdev.entity);
+		video_unregister_device(&video->vdev);
+	}
+}
+
+static int atomisp_save_iunit_reg(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+
+	dev_dbg(isp->dev, "%s\n", __func__);
+
+	pci_read_config_word(dev, PCI_COMMAND, &isp->saved_regs.pcicmdsts);
+	/* isp->saved_regs.ispmmadr is set from the atomisp_pci_probe() */
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &isp->saved_regs.msicap);
+	pci_read_config_dword(dev, PCI_MSI_ADDR, &isp->saved_regs.msi_addr);
+	pci_read_config_word(dev, PCI_MSI_DATA,  &isp->saved_regs.msi_data);
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &isp->saved_regs.intr);
+	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL,
+			      &isp->saved_regs.interrupt_control);
+
+	if (IS_MRFLD) {
+		pci_read_config_dword(dev, MRFLD_PCI_PMCS,
+				      &isp->saved_regs.pmcs);
+		/* Ensure read/write combining is enabled. */
+		pci_read_config_dword(dev, PCI_I_CONTROL,
+				&isp->saved_regs.i_control);
+		isp->saved_regs.i_control |=
+				MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
+				MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
+				      &isp->saved_regs.csi_access_viol);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
+				      &isp->saved_regs.csi_rcomp_config);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				      &isp->saved_regs.csi_afe_dly);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
+				      &isp->saved_regs.csi_control);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
+				      &isp->saved_regs.csi_afe_rcomp_config);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
+				      &isp->saved_regs.csi_afe_hs_control);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
+				      &isp->saved_regs.csi_deadline_control);
+	} else {
+		pci_read_config_dword(dev, MFLD_PCI_PMCS,
+				      &isp->saved_regs.pmcs);
+
+		/* Ensure clock gating for ISPCLK, PERF and NOA monitoring. */
+		pci_read_config_dword(dev, MFLD_PCI_CG_DIS,
+				      &isp->saved_regs.cg_dis);
+		isp->saved_regs.cg_dis &= ~(MFLD_PCI_CG_DIS_DISABLED_ISPCLK |
+				MFLD_PCI_CG_DIS_DISABLED_PERF_MON |
+				MFLD_PCI_CG_DIS_DISABLED_NOA_MON);
+
+		/* Ensure read/write combining is enabled. */
+		pci_read_config_dword(dev, PCI_I_CONTROL,
+				&isp->saved_regs.i_control);
+		isp->saved_regs.i_control |=
+				MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
+				MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+
+		isp->saved_regs.csi_rcomp_config = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP);
+		isp->saved_regs.csi_afe_dly = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_AFE);
+
+		/* Ensure mipi1 and mipi4 configurations are enabled */
+		isp->saved_regs.csi_control = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
+		isp->saved_regs.csi_control &= ~(MFLD_CSI_CONTROL_DIS_MIPI4_IF |
+				MFLD_CSI_CONTROL_DIS_MIPI1_IF);
+		isp->saved_regs.csi_control |= MFLD_CSI_CONTROL_EN_MIPI4_LANE |
+				MFLD_CSI_CONTROL_EN_MIPI1_LANE;
+	}
+
+	return 0;
+}
+
+extern void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data);
+static int atomisp_restore_iunit_reg(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+
+	dev_dbg(isp->dev, "%s\n", __func__);
+
+	pci_write_config_word(dev, PCI_COMMAND, isp->saved_regs.pcicmdsts);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+			       isp->saved_regs.ispmmadr);
+	pci_write_config_dword(dev, PCI_MSI_CAPID, isp->saved_regs.msicap);
+	pci_write_config_dword(dev, PCI_MSI_ADDR, isp->saved_regs.msi_addr);
+	pci_write_config_word(dev, PCI_MSI_DATA, isp->saved_regs.msi_data);
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, isp->saved_regs.intr);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL,
+			       isp->saved_regs.interrupt_control);
+	pci_write_config_dword(dev, PCI_I_CONTROL,
+					isp->saved_regs.i_control);
+
+	if (IS_MRFLD) {
+		pci_write_config_dword(dev, MRFLD_PCI_PMCS,
+						isp->saved_regs.pmcs);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
+				      isp->saved_regs.csi_access_viol);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
+				      isp->saved_regs.csi_rcomp_config);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				      isp->saved_regs.csi_afe_dly);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
+				      isp->saved_regs.csi_control);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
+				      isp->saved_regs.csi_afe_rcomp_config);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
+				      isp->saved_regs.csi_afe_hs_control);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
+				      isp->saved_regs.csi_deadline_control);
+
+		atomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
+
+	} else {
+		pci_write_config_dword(dev, MFLD_PCI_PMCS,
+				       isp->saved_regs.pmcs);
+		pci_write_config_dword(dev, MFLD_PCI_CG_DIS,
+						isp->saved_regs.cg_dis);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP,
+				    isp->saved_regs.csi_rcomp_config);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_AFE,
+				    isp->saved_regs.csi_afe_dly);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL,
+				    isp->saved_regs.csi_control);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int atomisp_mrfld_pre_power_down(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+	u32 irq;
+	unsigned long timeout;
+
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN)
+		return 0;
+
+	/*
+	 * MRFLD HAS requirement: cannot power off i-unit if
+	 * ISP has IRQ not serviced.
+	 * So, here we need to check if there is any pending
+	 * IRQ, if so, waiting for it to be served
+	 */
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (1) {
+		pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
+		if (!(irq & (1 << INTR_IIR)))
+			break;
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"%s: IRQ raised!!!\n", __func__);
+			return -EAGAIN;
+		}
+		usleep_range(1000, 1500);
+	};
+
+	/*
+	* MRFLD WORKAROUND:
+	* before powering off IUNIT, clear the pending interrupts
+	* and disable the interrupt. driver should avoid writing 0
+	* to IIR. It could block subsequent interrupt messages.
+	* HW sighting:4568410.
+	*/
+	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
+	irq = (irq & ~(1 << INTR_IER)) | (1 << INTR_IIR);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
+	atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+
+/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
+static int atomisp_mrfld_power_down(struct atomisp_device *isp)
+{
+	unsigned long timeout;
+	u32 reg_value;
+
+	/* writing 0x3 to ISPSSPM0 bit[1:0] to power off the IUNIT */
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
+	reg_value |= MRFLD_ISPSSPM0_IUNIT_POWER_OFF;
+	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
+
+	/*
+	 * There should be no iunit access while power-down is
+	 * in progress HW sighting: 4567865
+	 * FIXME: msecs_to_jiffies(50)- experienced value
+	 */
+	timeout = jiffies + msecs_to_jiffies(50);
+	while (1) {
+		reg_value = intel_mid_msgbus_read32(PUNIT_PORT,
+							MRFLD_ISPSSPM0);
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+				"power-off in progress, ISPSSPM0: 0x%x\n",
+				reg_value);
+		/* wait until ISPSSPM0 bit[25:24] shows 0x3 */
+		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
+			MRFLD_ISPSSPM0_IUNIT_POWER_OFF)
+			return 0;
+
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"power-off iunit timeout.\n");
+			return -EBUSY;
+		}
+		/* FIXME: experienced value for delay */
+		usleep_range(100, 150);
+	};
+}
+
+
+/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
+static int atomisp_mrfld_power_up(struct atomisp_device *isp)
+{
+	unsigned long timeout;
+	u32 reg_value;
+
+	/* writing 0x0 to ISPSSPM0 bit[1:0] to power off the IUNIT */
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
+	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+
+	/* FIXME: experienced value for delay */
+	timeout = jiffies + msecs_to_jiffies(50);
+	while (1) {
+		reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+				"power-on in progress, ISPSSPM0: 0x%x\n",
+				reg_value);
+		/* wait until ISPSSPM0 bit[25:24] shows 0x0 */
+		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
+			MRFLD_ISPSSPM0_IUNIT_POWER_ON)
+			return 0;
+
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"power-on iunit timeout.\n");
+			return -EBUSY;
+		}
+		/* FIXME: experienced value for delay */
+		usleep_range(100, 150);
+	};
+}
+
+static int atomisp_runtime_suspend(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_pre_power_down(isp);
+		if (ret)
+			return ret;
+	}
+
+	/*Turn off the ISP d-phy*/
+	ret = atomisp_ospm_dphy_down(isp);
+	if (!ret) {
+		pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
+	if (IS_MRFLD)
+			ret = atomisp_mrfld_power_down(isp);
+	}
+
+	return ret;
+}
+
+static int atomisp_runtime_resume(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_power_up(isp);
+		if (ret)
+			return ret;
+	}
+
+	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN) {
+		/*Turn on ISP d-phy */
+		ret = atomisp_ospm_dphy_up(isp);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "Failed to power up ISP!.\n");
+			return -EINVAL;
+		}
+	}
+
+	/*restore register values for iUnit and iUnitPHY registers*/
+	if (isp->saved_regs.pcicmdsts)
+		atomisp_restore_iunit_reg(isp);
+
+	if (IS_MRFLD)
+		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+
+static int atomisp_suspend(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	unsigned long flags;
+	int ret, i;
+
+	/*
+	 * FIXME: Suspend is not supported by sensors. Abort if any video
+	 * node was opened.
+	 */
+	if (atomisp_dev_users(isp))
+		return -EBUSY;
+
+	spin_lock_irqsave(&isp->lock, flags);
+	for(i=0;i<isp->num_of_streams;i++)
+	{
+		if (isp->isp_subdev[i].streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
+			spin_unlock_irqrestore(&isp->lock, flags);
+			v4l2_err(&atomisp_dev,
+				    "atomisp cannot suspend at this time.\n");
+			return -EINVAL;
+		}
+		spin_unlock_irqrestore(&isp->lock, flags);
+	}
+
+	/* Prepare for MRFLD IUNIT power down */
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_pre_power_down(isp);
+		if (ret)
+			return ret;
+	}
+
+	/*Turn off the ISP d-phy */
+	ret = atomisp_ospm_dphy_down(isp);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "fail to power off ISP\n");
+	} else {
+		pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
+	if (IS_MRFLD)
+			ret = atomisp_mrfld_power_down(isp);
+	}
+
+	return ret;
+}
+
+static int atomisp_resume(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_power_up(isp);
+		if (ret)
+			return ret;
+	}
+
+	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
+
+	/*Turn on ISP d-phy */
+	ret = atomisp_ospm_dphy_up(isp);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "Failed to power up ISP!.\n");
+		return -EINVAL;
+	}
+
+	/*restore register values for iUnit and iUnitPHY registers*/
+	if (isp->saved_regs.pcicmdsts)
+		atomisp_restore_iunit_reg(isp);
+
+	if (IS_MRFLD)
+		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+#endif
+
+static int mrfld_csi_lane_config(struct atomisp_device *isp)
+{
+	static const u8 mipi_lanes[MRFLD_PORT_CONFIG_NUM][MRFLD_PORT_NUM] = {
+		{4, 1, 0},
+		{3, 1, 0},
+		{2, 1, 0},
+		{1, 1, 0},
+		{2, 1, 2},
+		{3, 1, 1},
+		{2, 1, 1},
+		{1, 1, 1}
+	};
+
+	unsigned int i, j;
+	u8 sensor_lanes[MRFLD_PORT_NUM] = {0};
+	u32 data;
+
+	for (i = 0; i < isp->input_cnt; i++) {
+
+		if (isp->inputs[i].type != RAW_CAMERA &&
+			isp->inputs[i].type != SOC_CAMERA)
+			continue;
+
+		switch (isp->inputs[i].port) {
+		case ATOMISP_CAMERA_PORT_PRIMARY:
+			sensor_lanes[0] = isp->inputs[i].num_lanes;
+			printk("CSI_CONTROL ATOMISP_CAMERA_PORT_PRIMARY port = %d num lanse=%d\n", 
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+			
+			break;
+		case ATOMISP_CAMERA_PORT_SECONDARY:
+			sensor_lanes[1] = isp->inputs[i].num_lanes;
+			printk("CSI_CONTROL ATOMISP_CAMERA_PORT_SECONDARY port = %d num lanse=%d\n", 
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+			
+			break;
+		case ATOMISP_CAMERA_PORT_THIRD:
+			sensor_lanes[2] = isp->inputs[i].num_lanes;
+			printk("CSI_CONTROL ATOMISP_CAMERA_PORT_THIRD port = %d num lanse=%d\n", 
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+			
+			break;
+		default:
+			v4l2_err(&atomisp_dev,
+				"%s: invalid port: %d for the %dth sensor\n",
+				__func__, isp->inputs[i].port, i);
+			break;
+		}
+	}
+
+	for (i = 0; i < MRFLD_PORT_CONFIG_NUM; i++) {
+		for (j = 0; j < MRFLD_PORT_NUM; j++)
+			if (sensor_lanes[j]
+				&& sensor_lanes[j] != mipi_lanes[i][j])
+				break;
+
+		if (j == MRFLD_PORT_NUM)
+			break;	/* matched setting is found */
+	}
+
+	if (i == MRFLD_PORT_CONFIG_NUM) {
+		v4l2_err(&atomisp_dev,
+			"%s: could not find the CSI port setting for %d-%d-%d\n",
+			__func__, sensor_lanes[0],
+			sensor_lanes[1], sensor_lanes[2]);
+		return -EINVAL;
+	}
+
+	pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &data);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+				"%s: original CSI_CONTROL is 0x%x\n",
+				__func__, data);
+	data &= ~MRFLD_PORT_CONFIG_MASK;
+	data |= (i << MRFLD_PORT_CONFIGCODE_SHIFT)
+		| (mipi_lanes[i][2] ? 0 : (1 << MRFLD_PORT3_ENABLE_SHIFT))
+		| (((1 << mipi_lanes[i][0]) - 1) << MRFLD_PORT1_LANES_SHIFT)
+		| (((1 << mipi_lanes[i][1]) - 1) << MRFLD_PORT2_LANES_SHIFT)
+		| (((1 << mipi_lanes[i][2]) - 1) << MRFLD_PORT3_LANES_SHIFT);
+
+	pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, data);
+
+	pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &data);
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		"%s: the portconfig is %d-%d-%d, CSI_CONTROL is 0x%x\n",
+		__func__, mipi_lanes[i][0], mipi_lanes[i][1],
+		mipi_lanes[i][2], data);
+
+	return 0;
+}
+
+extern struct atomisp_platform_data *__intel_get_v4l2_subdev_table(void);
+
+static int atomisp_subdev_probe(struct atomisp_device *isp)
+{
+	const struct atomisp_platform_data *pdata;
+	struct intel_v4l2_subdev_table *subdevs;
+	int raw_index = -1;
+
+	pdata = __intel_get_v4l2_subdev_table();
+	if (pdata == NULL) {
+		dev_err(isp->dev, "no platform data available\n");
+		return 0;
+	}
+
+	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
+		struct v4l2_subdev *subdev;
+		struct i2c_board_info *board_info =
+			&subdevs->v4l2_subdev.board_info;
+		struct i2c_adapter *adapter =
+			i2c_get_adapter(subdevs->v4l2_subdev.i2c_adapter_id);
+
+		if (adapter == NULL) {
+			dev_err(isp->dev,
+				"Failed to find i2c adapter for subdev %s\n",
+				board_info->type);
+			break;
+		}
+
+		subdev = v4l2_i2c_new_subdev_board(&isp->v4l2_dev, adapter,
+				board_info, NULL);
+
+		if (subdev == NULL) {
+			dev_warn(isp->dev, "Subdev %s detection fail\n",
+				 board_info->type);
+			continue;
+		}
+
+		dev_info(isp->dev, "Subdev %s successfully register\n",
+			 board_info->type);
+		isp->detected_snr_cnt++;
+
+		switch (subdevs->type) {
+		case RAW_CAMERA:
+			raw_index = isp->input_cnt;
+			dev_dbg(isp->dev, "raw_index: %d\n", raw_index);
+		case SOC_CAMERA:
+			dev_dbg(isp->dev, "SOC_INDEX: %d\n", isp->input_cnt);
+			if (isp->input_cnt >= ATOM_ISP_MAX_INPUTS) {
+				dev_warn(isp->dev,
+					 "too many atomisp inputs, ignored\n");
+				break;
+			}
+
+			isp->inputs[isp->input_cnt].type = subdevs->type;
+			isp->inputs[isp->input_cnt].port = subdevs->port;
+			isp->inputs[isp->input_cnt].num_lanes = subdevs->num_lanes;
+			isp->inputs[isp->input_cnt].camera = subdev;
+			isp->inputs[isp->input_cnt].shading_table = NULL;
+			isp->inputs[isp->input_cnt].morph_table = NULL;
+			/*
+			 * initialize the subdev frame size, then next we can
+			 * judge whether frame_size store effective value via
+			 * pixel_format.
+			 */
+			isp->inputs[isp->input_cnt].frame_size.pixel_format = 0;
+			isp->input_cnt++;
+			break;
+		case CAMERA_MOTOR:
+			isp->motor = subdev;
+			break;
+		case LED_FLASH:
+		case XENON_FLASH:
+			isp->flash = subdev;
+			break;
+		default:
+			dev_dbg(isp->dev, "unknown subdev probed\n");
+			break;
+		}
+
+	}
+
+	/*
+	 * HACK: Currently VCM belongs to primary sensor only, but correct
+	 * approach must be to acquire from platform code which sensor
+	 * owns it.
+	 */
+	if (isp->motor && raw_index >= 0)
+		isp->inputs[raw_index].motor = isp->motor;
+
+	/* Proceed even if no modules detected. For COS mode and no modules. */
+	if (!isp->inputs[0].camera)
+	{
+		//setting detected_snr_cnt to 1 for file injection
+		isp->detected_snr_cnt = 1;
+		dev_warn(isp->dev, "no camera attached or fail to detect\n");
+
+	}
+	if (IS_MRFLD)
+		return mrfld_csi_lane_config(isp);
+
+	return 0;
+}
+
+static void atomisp_unregister_entities(struct atomisp_device *isp)
+{
+	unsigned int i;
+	for(i =0;i< isp->detected_snr_cnt; i++)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+	atomisp_tpg_unregister_entities(&isp->tpg);
+	atomisp_file_input_unregister_entities(&isp->file_dev);
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
+		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
+
+	v4l2_device_unregister(&isp->v4l2_dev);
+	media_device_unregister(&isp->media_dev);
+}
+
+static int atomisp_register_entities(struct atomisp_device *isp)
+{
+	int ret = 0;
+	unsigned int i;
+	struct v4l2_subdev *subdev = NULL;
+	struct media_entity *input = NULL;
+	unsigned int flags;
+	unsigned int pad;
+
+	isp->media_dev.dev = isp->dev;
+
+	strlcpy(isp->media_dev.model, "Intel Atom ISP",
+		sizeof(isp->media_dev.model));
+	if (IS_MRFLD)
+		isp->media_dev.hw_revision = ATOMISP_CSS_VERSION_20;
+	else
+		isp->media_dev.hw_revision = ATOMISP_CSS_VERSION_15;
+
+	ret = media_device_register(&isp->media_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "%s: Media device registration "
+			 "failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	isp->v4l2_dev.mdev = &isp->media_dev;
+	ret = v4l2_device_register(isp->dev, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"%s: V4L2 device registration failed (%d)\n",
+			__func__, ret);
+		goto v4l2_device_failed;
+	}
+
+	ret = atomisp_subdev_probe(isp);
+	if (ret < 0)
+		goto csi_and_subdev_probe_failed;
+
+	/* Register internal entities */
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		ret = atomisp_mipi_csi2_register_entities(&isp->csi2_port[i],
+								&isp->v4l2_dev);
+		if (ret == 0)
+			continue;
+
+		/* error case */
+		v4l2_err(&atomisp_dev,
+			"failed to register the CSI port: %d\n", i);
+		/* deregister all registered CSI ports */
+		while (i--)
+			atomisp_mipi_csi2_unregister_entities(
+							&isp->csi2_port[i]);
+
+		goto csi_and_subdev_probe_failed;
+	}
+
+	ret =
+	atomisp_file_input_register_entities(&isp->file_dev, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"atomisp_file_input_register_entities\n");
+		goto file_input_register_failed;
+	}
+
+	ret = atomisp_tpg_register_entities(&isp->tpg, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "atomisp_tpg_register_entities\n");
+		goto tpg_register_failed;
+	}
+
+	for(i=0;i<isp->detected_snr_cnt;i++)
+	{
+		ret =
+		atomisp_subdev_register_entities(&isp->isp_subdev[i], &isp->v4l2_dev);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev,
+				"atomisp_subdev_register_entities fail\n");
+			goto subdev_register_failed;
+		}
+	}
+
+	for (i = 0; i < isp->input_cnt; i++) {
+		if (isp->inputs[i].port >= ATOMISP_CAMERA_NR_PORTS) {
+			v4l2_err(&atomisp_dev,
+					"isp->inputs port %d not supported\n",
+					isp->inputs[i].port);
+			ret = -EINVAL;
+			goto link_failed;
+		}
+
+		subdev = isp->inputs[i].camera;
+		input = &isp->csi2_port[isp->inputs[i].port].subdev.entity;
+		pad = CSI2_PAD_SINK;
+		flags = 0;
+
+		ret = media_entity_create_link(&subdev->entity, 0,
+			input, pad, flags);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev,
+				"snr to mipi csi link failed\n");
+			goto link_failed;
+		}
+	}
+
+	v4l2_dbg(1, dbg_level, &atomisp_dev,
+		"FILE_INPUT enable, camera_cnt: %d\n", isp->input_cnt);
+	isp->inputs[isp->input_cnt].type = FILE_INPUT;
+	isp->inputs[isp->input_cnt].port = -1;
+	isp->inputs[isp->input_cnt].shading_table = NULL;
+	isp->inputs[isp->input_cnt].morph_table = NULL;
+	isp->inputs[isp->input_cnt++].camera = &isp->file_dev.sd;
+
+	if (isp->input_cnt < ATOM_ISP_MAX_INPUTS) {
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+			"TPG detected, camera_cnt: %d\n", isp->input_cnt);
+		isp->inputs[isp->input_cnt].type = TEST_PATTERN;
+		isp->inputs[isp->input_cnt].port = -1;
+		isp->inputs[isp->input_cnt].shading_table = NULL;
+		isp->inputs[isp->input_cnt].morph_table = NULL;
+		isp->inputs[isp->input_cnt++].camera = &isp->tpg.sd;
+	} else {
+		v4l2_warn(&atomisp_dev,
+			"too many atomisp inputs, TPG ignored.\n");
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);
+	if (ret < 0)
+		goto link_failed;
+
+	return ret;
+
+link_failed:
+	for(i=0;i<isp->num_of_streams;i++)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+subdev_register_failed:
+	while(i--)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+tpg_register_failed:
+	atomisp_tpg_unregister_entities(&isp->tpg);
+file_input_register_failed:
+	atomisp_file_input_unregister_entities(&isp->file_dev);
+csi_and_subdev_probe_failed:
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
+		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
+v4l2_device_failed:
+	v4l2_device_unregister(&isp->v4l2_dev);
+	media_device_unregister(&isp->media_dev);
+	return ret;
+}
+
+static int atomisp_initialize_modules(struct atomisp_device *isp)
+{
+	int ret;
+	unsigned int i, j;
+
+	ret = atomisp_mipi_csi2_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "mipi csi2 initialization failed\n");
+		goto error_mipi_csi2;
+	}
+
+	ret = atomisp_file_input_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"file input device initialization failed\n");
+		goto error_file_input;
+	}
+
+	ret = atomisp_tpg_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "tpg initialization failed\n");
+		goto error_tpg;
+	}
+
+	ret = atomisp_subdev_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "ISP subdev initialization failed\n");
+		goto error_isp_subdev;
+	}
+
+	/* connect submoduels */
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		for(j=0;j<isp->num_of_streams;j++)
+		ret = media_entity_create_link(
+				&isp->csi2_port[i].subdev.entity,
+				CSI2_PAD_SOURCE,
+				&isp->isp_subdev[j].subdev.entity,
+				ATOMISP_SUBDEV_PAD_SINK,
+				0);
+		if (ret < 0)
+			goto error_link;
+	}
+	return 0;
+
+error_link:
+error_isp_subdev:
+	atomisp_subdev_cleanup(isp->isp_subdev);
+error_tpg:
+	atomisp_tpg_cleanup(isp);
+error_file_input:
+	atomisp_file_input_cleanup(isp);
+error_mipi_csi2:
+	atomisp_mipi_csi2_cleanup(isp);
+	return ret;
+}
+
+int load_ISP_firmware(void *void_isp)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)void_isp;
+	struct device *dev = isp->dev;
+	const struct firmware *fw;
+	int rc, retval = 0;
+	char *fw_path = IS_MRFLD ? MRFLD_FW_PATH : MFLD_FW_PATH;
+
+	rc = request_firmware(&fw, fw_path, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			printk(KERN_ALERT "atomisp: Error ISP firmware %s not found.\n",
+				    fw_path);
+		else
+			printk(KERN_ALERT "atomisp: Error %d while requesting"
+				    " firmware %s\n", rc, fw_path);
+		isp->firmware = NULL;
+		retval = -1;
+	} else if (fw == NULL || fw->data == NULL) {
+		printk(KERN_ALERT "atomisp: ISP firmware data is NULL.\n");
+		isp->firmware = NULL;
+	} else {
+		printk(KERN_ALERT "atomisp: ISP firmware %s successfully loaded\n", fw_path);	
+		isp->firmware = fw;
+	}
+
+	isp->firmware_load_complete = true;
+	wake_up_interruptible(&atomisp_wait_queue);
+	return retval;
+}
+
+#define ATOM_ISP_PCI_BAR	0
+
+static int atomisp_pci_probe(struct pci_dev *dev,
+				       const struct pci_device_id *id)
+{
+	struct atomisp_device *isp;
+	unsigned int start;
+	void __iomem *base;
+	int err, i;
+
+	err = byt_plat_clk_init();
+	if(err)
+	{
+		dev_err(&dev->dev, "atomisp: PMC clock initialization failed\n");
+		return err;	
+	}
+
+	for( i = 0; i < MAX_CLK_COUNT; i++)
+	{
+		byt_plat_set_clock_freq(i, CLK_FREQ_TYPE_PLL);
+		byt_plat_configure_clock(i, CLK_CONFG_FORCE_ON);
+	}
+
+	if (!dev) {
+		dev_err(&dev->dev, "atomisp: error device ptr\n");
+		return -EINVAL;
+	}
+
+	atomisp_pci_vendor = id->vendor;
+	atomisp_pci_device = id->device;
+
+	err = pcim_enable_device(dev);
+	if (err) {
+		dev_err(&dev->dev, "Failed to enable CI ISP device (%d)\n",
+			err);
+		return err;
+	}
+
+	start = pci_resource_start(dev, ATOM_ISP_PCI_BAR);
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "start: 0x%x\n", start);
+
+	err = pcim_iomap_regions(dev, 1 << ATOM_ISP_PCI_BAR, pci_name(dev));
+	if (err) {
+		dev_err(&dev->dev, "Failed to I/O memory remapping (%d)\n",
+			err);
+		return err;
+	}
+
+	base = pcim_iomap_table(dev)[ATOM_ISP_PCI_BAR];
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "base: %p\n", base);
+
+	atomisp_io_base = base;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "atomisp_io_base: %p\n",
+			atomisp_io_base);
+
+	isp = devm_kzalloc(&dev->dev, sizeof(struct atomisp_device), GFP_KERNEL);
+	if (!isp) {
+		dev_err(&dev->dev, "Failed to alloc CI ISP structure\n");
+		return -ENOMEM;
+	}
+	isp->pdev = dev;
+	isp->dev = &dev->dev;
+	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
+	isp->pci_root = pci_get_bus_and_slot(0, 0);
+	if (!isp->pci_root) {
+		dev_err(&dev->dev, "Unable to find PCI host\n");
+		return -ENODEV;
+	}
+	isp->saved_regs.ispmmadr = start;
+
+	mutex_init(&isp->mutex);
+	mutex_init(&isp->streamoff_mutex);
+	mutex_init(&isp->vb2mutex);
+	spin_lock_init(&isp->lock);
+	init_completion(&isp->init_done);
+
+	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
+
+	/* Load isp firmware from user space */
+	isp->firmware = NULL;
+	isp->firmware_load_complete = false;
+#ifndef ON_DEMAND_LOAD
+	kthread_run(&load_ISP_firmware, (void *)isp, "load_isp_firmware");
+#endif
+	isp->wdt_work_queue = alloc_workqueue(isp->v4l2_dev.name, 0, 1);
+	if (isp->wdt_work_queue == NULL) {
+		dev_err(&dev->dev, "Failed to initialize wdt work queue\n");
+		err = -ENOMEM;
+		goto wdt_work_queue_fail;
+	}
+	INIT_WORK(&isp->wdt_work, atomisp_wdt_work);
+
+	isp->delayed_init_workq =
+		alloc_workqueue(isp->v4l2_dev.name, WQ_CPU_INTENSIVE, 1);
+	if (isp->delayed_init_workq == NULL) {
+		dev_err(&dev->dev, "Failed to initialize delayed init workq\n");
+		err = -ENOMEM;
+		goto delayed_init_work_queue_fail;
+	}
+	INIT_WORK(&isp->delayed_init_work, atomisp_delayed_init_work);
+
+	pci_set_master(dev);
+	pci_set_drvdata(dev, isp);
+
+	err = pci_enable_msi(dev);
+	if (err) {
+		dev_err(&dev->dev, "Failed to enable msi (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	err = devm_request_threaded_irq(&dev->dev, dev->irq,
+					atomisp_isr, atomisp_isr_thread,
+					IRQF_SHARED, "isp_irq", isp);
+	if (err) {
+		dev_err(&dev->dev, "Failed to request irq (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	setup_timer(&isp->wdt, atomisp_wdt, (unsigned long)isp);
+
+	atomisp_msi_irq_init(isp, dev);
+
+	pm_qos_add_request(&isp->pm_qos, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_DEFAULT_VALUE);
+
+	if (IS_MRFLD) {
+		u32 reg32;
+		atomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
+		pci_read_config_dword(dev, PCI_I_CONTROL, &reg32);
+		reg32 |= MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING
+			| MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+		pci_write_config_dword(dev, PCI_I_CONTROL, reg32);
+	}
+
+	err = atomisp_initialize_modules(isp);
+	if (err < 0) {
+		dev_err(&dev->dev, "atomisp_initialize_modules (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	err = atomisp_register_entities(isp);
+	if (err < 0) {
+		dev_err(&dev->dev, "atomisp_register_entities failed (%d)\n",
+			err);
+		goto enable_msi_fail;
+	}
+	atomisp_acc_init(isp);
+
+	/* save the iunit context only once after all the values are init'ed. */
+	atomisp_save_iunit_reg(isp);
+
+	/* init the msgbus */
+	intel_mid_msgbus_init();
+
+	err = hmm_pool_register(repool_pgnr, HMM_POOL_TYPE_RESERVED);
+	if (err)
+		v4l2_dbg(3, dbg_level, &atomisp_dev,"Failed to register reserved memory pool.\n");
+
+	pm_runtime_put_noidle(&dev->dev);
+	pm_runtime_allow(&dev->dev);
+	return 0;
+
+enable_msi_fail:
+	destroy_workqueue(isp->delayed_init_workq);
+delayed_init_work_queue_fail:
+	destroy_workqueue(isp->wdt_work_queue);
+wdt_work_queue_fail:
+	release_firmware(isp->firmware);
+	pci_dev_put(isp->pci_root);
+	return err;
+}
+
+static void __exit atomisp_pci_remove(struct pci_dev *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		pci_get_drvdata(dev);
+
+	atomisp_acc_cleanup(isp);
+
+	pm_runtime_forbid(&dev->dev);
+	pm_runtime_get_noresume(&dev->dev);
+	pm_qos_remove_request(&isp->pm_qos);
+
+	atomisp_msi_irq_uninit(isp, dev);
+	pci_dev_put(isp->pci_root);
+
+	atomisp_unregister_entities(isp);
+
+	destroy_workqueue(isp->wdt_work_queue);
+	atomisp_file_input_cleanup(isp);
+
+	release_firmware(isp->firmware);
+	hmm_pool_unregister(HMM_POOL_TYPE_RESERVED);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(atomisp_pci_tbl) = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0148)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0149)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014A)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014B)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014C)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014D)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014E)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014F)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08D0)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1178)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0F38)},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, atomisp_pci_tbl);
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops atomisp_pm_ops = {
+	.runtime_suspend = atomisp_runtime_suspend,
+	.runtime_resume = atomisp_runtime_resume,
+	.suspend = atomisp_suspend,
+	.resume = atomisp_resume,
+};
+
+#define DEV_PM_OPS (&atomisp_pm_ops)
+#else
+#define DEV_PM_OPS NULL
+#endif
+
+static struct pci_driver atomisp_pci_driver = {
+	.driver = {
+		.pm = DEV_PM_OPS,
+	},
+	.name = "atomisp",
+	.id_table = atomisp_pci_tbl,
+	.probe = atomisp_pci_probe,
+	.remove = atomisp_pci_remove,
+};
+
+static int __init atomisp_init(void)
+{
+	return pci_register_driver(&atomisp_pci_driver);
+}
+
+static void __exit atomisp_exit(void)
+{
+	pci_unregister_driver(&atomisp_pci_driver);
+}
+
+module_init(atomisp_init);
+module_exit(atomisp_exit);
+
+MODULE_AUTHOR("Wen Wang <wen.w.wang@intel.com>");
+MODULE_AUTHOR("Xiaolin Zhang <xiaolin.zhang@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ATOM Platform ISP Driver");
diff --git a/drivers/media/atomisp2/atomisp_v4l2.h b/drivers/media/atomisp2/atomisp_v4l2.h
new file mode 100644
index 0000000..05eed6e
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_v4l2.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_V4L2_H__
+#define __ATOMISP_V4L2_H__
+
+struct atomisp_video_pipe;
+struct v4l2_device;
+
+int atomisp_video_init(struct atomisp_video_pipe *video, const char *name);
+void atomisp_video_unregister(struct atomisp_video_pipe *video);
+int atomisp_video_register(struct atomisp_video_pipe *video,
+	struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_V4L2_H__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h
new file mode 100644
index 0000000..819651f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h
@@ -0,0 +1,60 @@
+#ifndef __DEBUG_GLOBAL_H_INCLUDED__
+#define __DEBUG_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define DEBUG_BUF_SIZE	1024
+#define DEBUG_BUF_MASK	(DEBUG_BUF_SIZE - 1)
+
+#define DEBUG_DATA_ENABLE_ADDR		0x00
+#define DEBUG_DATA_BUF_MODE_ADDR	0x04
+#define DEBUG_DATA_HEAD_ADDR		0x08
+#define DEBUG_DATA_TAIL_ADDR		0x0C
+#define DEBUG_DATA_BUF_ADDR			0x10
+
+#define DEBUG_DATA_ENABLE_DDR_ADDR		0x00
+#define DEBUG_DATA_BUF_MODE_DDR_ADDR	HIVE_ISP_DDR_WORD_BYTES
+#define DEBUG_DATA_HEAD_DDR_ADDR		(2 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_TAIL_DDR_ADDR		(3 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_BUF_DDR_ADDR			(4 * HIVE_ISP_DDR_WORD_BYTES)
+
+#define DEBUG_BUFFER_ISP_DMEM_ADDR       0x0
+
+/*
+ * The linear buffer mode will accept data until the first
+ * overflow and then stop accepting new data
+ * The circular buffer mode will accept if there is place
+ * and discard the data if the buffer is full
+ */
+typedef enum {
+	DEBUG_BUFFER_MODE_LINEAR = 0,
+	DEBUG_BUFFER_MODE_CIRCULAR,
+	N_DEBUG_BUFFER_MODE
+} debug_buf_mode_t;
+
+struct debug_data_s {
+	uint32_t			enable;
+	uint32_t			bufmode;
+	uint32_t			head;
+	uint32_t			tail;
+	uint32_t			buf[DEBUG_BUF_SIZE];
+};
+
+struct debug_data_ddr_s {
+	uint32_t			enable;
+	int8_t				padding1[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			bufmode;
+	int8_t				padding2[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			head;
+	int8_t				padding3[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			tail;
+	int8_t				padding4[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			buf[DEBUG_BUF_SIZE];
+};
+
+#endif /* __DEBUG_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h
new file mode 100644
index 0000000..2d172a2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h
@@ -0,0 +1,266 @@
+#ifndef __DMA_GLOBAL_H_INCLUDED__
+#define __DMA_GLOBAL_H_INCLUDED__
+
+#define IS_DMA_VERSION_2
+
+#define HIVE_ISP_NUM_DMA_CONNS		3
+/*
+ * Consumes an unacceptable amount of SP resources
+ *
+#define HIVE_ISP_NUM_DMA_CHANNELS_LOG2	5
+#define HIVE_ISP_NUM_DMA_CHANNELS	32
+ */
+#define HIVE_ISP_NUM_DMA_CHANNELS_LOG2	4
+#define HIVE_ISP_NUM_DMA_CHANNELS	16
+
+#define N_DMA_CHANNEL_ID	HIVE_ISP_NUM_DMA_CHANNELS
+
+#include "dma_v2_defs.h"
+
+/*
+ * Command token bit mappings
+ *
+ * transfer / config
+ *    param id[4] channel id[5] cmd id[6]
+ *	| b14 .. b11 | b10 ... b6 | b5 ... b0 |
+ *
+ *
+ * fast transfer:
+ *    height[5]     width[8]      width[8]  channel id[5] cmd id[6]
+ *	| b31 .. b26 | b25 .. b18 | b17 .. b11 | b10 ... b6 | b5 ... b0 |
+ *
+ */
+
+#define _DMA_PACKING_SETUP_PARAM	_DMA_V2_PACKING_SETUP_PARAM
+#define _DMA_HEIGHT_PARAM			_DMA_V2_HEIGHT_PARAM
+#define _DMA_STRIDE_A_PARAM			_DMA_V2_STRIDE_A_PARAM
+#define _DMA_ELEM_CROPPING_A_PARAM	_DMA_V2_ELEM_CROPPING_A_PARAM
+#define _DMA_WIDTH_A_PARAM			_DMA_V2_WIDTH_A_PARAM
+#define _DMA_STRIDE_B_PARAM			_DMA_V2_STRIDE_B_PARAM
+#define _DMA_ELEM_CROPPING_B_PARAM	_DMA_V2_ELEM_CROPPING_B_PARAM
+#define _DMA_WIDTH_B_PARAM			_DMA_V2_WIDTH_B_PARAM
+
+#define _DMA_ZERO_EXTEND     _DMA_V2_ZERO_EXTEND
+#define _DMA_SIGN_EXTEND     _DMA_V2_SIGN_EXTEND
+
+
+typedef unsigned int dma_channel;
+
+typedef enum {
+  dma_isp_to_bus_connection = HIVE_DMA_ISP_BUS_CONN,
+  dma_isp_to_ddr_connection = HIVE_DMA_ISP_DDR_CONN,
+  dma_bus_to_ddr_connection = HIVE_DMA_BUS_DDR_CONN,
+} dma_connection;
+
+typedef enum {
+  dma_zero_extension = _DMA_ZERO_EXTEND,
+  dma_sign_extension = _DMA_SIGN_EXTEND
+} dma_extension;
+
+
+#define DMA_PROP_SHIFT(val, param)       ((val) << _DMA_V2_ ## param ## _IDX)
+#define DMA_PROP_MASK(param)             ((1U << _DMA_V2_ ## param ## _BITS)-1)
+#define DMA_PACK(val, param)             DMA_PROP_SHIFT((val) & DMA_PROP_MASK(param), param)
+
+#define DMA_PACK_COMMAND(cmd)            DMA_PACK(cmd, CMD)
+#define DMA_PACK_CHANNEL(ch)             DMA_PACK(ch,  CHANNEL)
+#define DMA_PACK_PARAM(par)              DMA_PACK(par, PARAM)
+#define DMA_PACK_EXTENSION(ext)          DMA_PACK(ext, EXTENSION)
+#define DMA_PACK_LEFT_CROPPING(lc)       DMA_PACK(lc,  LEFT_CROPPING)
+#define DMA_PACK_WIDTH_A(w)              DMA_PACK(w,   SPEC_DEV_A_XB)
+#define DMA_PACK_WIDTH_B(w)              DMA_PACK(w,   SPEC_DEV_B_XB)
+#define DMA_PACK_HEIGHT(h)               DMA_PACK(h,   SPEC_YB)
+
+#define DMA_PACK_CMD_CHANNEL(cmd, ch)	 (DMA_PACK_COMMAND(cmd) | DMA_PACK_CHANNEL(ch))
+#define DMA_PACK_SETUP(conn, ext)        ((conn) | DMA_PACK_EXTENSION(ext))
+#define DMA_PACK_CROP_ELEMS(elems, crop) ((elems) | DMA_PACK_LEFT_CROPPING(crop))
+
+#define hive_dma_snd(dma_id, token) OP_std_snd(dma_id, (unsigned int)(token))
+
+#define DMA_PACK_BLOCK_CMD(cmd, ch, width_a, width_b, height) \
+  (DMA_PACK_COMMAND(cmd)     | \
+   DMA_PACK_CHANNEL(ch)      | \
+   DMA_PACK_WIDTH_A(width_a) | \
+   DMA_PACK_WIDTH_B(width_b) | \
+   DMA_PACK_HEIGHT(height))
+
+#ifdef __HIVECC
+#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_MOVE_B2A_COMMAND:_DMA_V2_MOVE_A2B_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+}
+#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND:_DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+}
+#else
+#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_MOVE_B2A_COMMAND:_DMA_V2_MOVE_A2B_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+  hive_dma_snd(dma_id, to_is_var); \
+  hive_dma_snd(dma_id, from_is_var); \
+}
+#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND:_DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+  hive_dma_snd(dma_id, to_is_var); \
+  hive_dma_snd(dma_id, from_is_var); \
+}
+#endif
+
+#define hive_dma_move_b2a_data(dma_id, channel, to_addr, from_addr, to_is_var, from_is_var) \
+{ \
+  hive_dma_move_data(dma_id, true, channel, to_addr, from_addr, to_is_var, from_is_var) \
+}
+
+#define hive_dma_move_a2b_data(dma_id, channel, from_addr, to_addr, from_is_var, to_is_var) \
+{ \
+  hive_dma_move_data(dma_id, false, channel, from_addr, to_addr, from_is_var, to_is_var) \
+}
+
+#ifdef __HIVECC
+#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
+{ \
+  hive_dma_snd(dma_id, _DMA_V2_PACK_CHANNEL_CMD(_DMA_V2_INIT_A_COMMAND, channel)); \
+  hive_dma_snd(dma_id, value); \
+  hive_dma_snd(dma_id, address); \
+}
+#else
+#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_INIT_A_COMMAND, channel)); \
+  hive_dma_snd(dma_id, value); \
+  hive_dma_snd(dma_id, address); \
+  hive_dma_snd(dma_id, is_var); \
+}
+#endif
+
+#define hive_dma_clear_data(dma_id, channel, address, is_var) hive_dma_set_data(dma_id, channel, address, 0, is_var)
+
+#define hive_dma_configure(dma_id, channel, connection, extension, height, \
+	stride_A, elems_A, cropping_A, width_A, \
+	stride_B, elems_B, cropping_B, width_B) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
+  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+  hive_dma_snd(dma_id, stride_A); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, cropping_A)); \
+  hive_dma_snd(dma_id, width_A); \
+  hive_dma_snd(dma_id, stride_B); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, cropping_B)); \
+  hive_dma_snd(dma_id, width_B); \
+  hive_dma_snd(dma_id, height); \
+}
+
+#ifdef __HIVECC
+/* If the command is "set" the 5th argument holds the value */
+#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
+  hive_dma_snd(dma_id, to_addr); \
+  hive_dma_snd(dma_id, from_addr_value); \
+}
+#else
+#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
+  hive_dma_snd(dma_id, to_addr); \
+  hive_dma_snd(dma_id, from_addr_value); \
+  hive_dma_snd(dma_id, to_is_var); \
+  if ((cmd & DMA_CLEAR_CMDBIT) == 0) { \
+	hive_dma_snd(dma_id, from_is_var); \
+  } \
+}
+#endif
+
+#define hive_dma_configure_fast(dma_id, channel, connection, extension, elems_A, elems_B) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
+  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, 1); \
+}
+
+#define hive_dma_set_parameter(dma_id, channel, param, value) \
+{ \
+  hive_dma_snd(dma_id, _DMA_V2_SET_CHANNEL_PARAM_COMMAND | DMA_PACK_CHANNEL(channel) | DMA_PACK_PARAM(param)); \
+  hive_dma_snd(dma_id, value); \
+}
+
+#define	DMA_SPECIFIC_CMDBIT	0x01
+#define	DMA_CHECK_CMDBIT	0x02
+#define	DMA_RW_CMDBIT		0x04
+#define	DMA_CLEAR_CMDBIT	0x08
+#define	DMA_ACK_CMDBIT		0x10
+#define	DMA_CFG_CMDBIT		0x20
+#define	DMA_PARAM_CMDBIT	0x01
+
+/* Write complete check not necessary if there's no ack */
+#define	DMA_NOACK_CMD		(DMA_ACK_CMDBIT | DMA_CHECK_CMDBIT)
+#define	DMA_CFG_CMD			(DMA_CFG_CMDBIT)
+#define	DMA_CFGPARAM_CMD	(DMA_CFG_CMDBIT | DMA_PARAM_CMDBIT)
+
+#define DMA_CMD_NEEDS_ACK(cmd) ((cmd & DMA_NOACK_CMD) == 0)
+#define DMA_CMD_IS_TRANSFER(cmd) ((cmd & DMA_CFG_CMDBIT) == 0)
+#define DMA_CMD_IS_WR(cmd) ((cmd & DMA_RW_CMDBIT) != 0)
+#define DMA_CMD_IS_RD(cmd) ((cmd & DMA_RW_CMDBIT) == 0)
+#define DMA_CMD_IS_CLR(cmd) ((cmd & DMA_CLEAR_CMDBIT) != 0)
+#define DMA_CMD_IS_CFG(cmd) ((cmd & DMA_CFG_CMDBIT) != 0)
+#define DMA_CMD_IS_PARAMCFG(cmd) ((cmd & DMA_CFGPARAM_CMD) == DMA_CFGPARAM_CMD)
+
+/* As a matter of convention */
+#define DMA_TRANSFER_READ		DMA_TRANSFER_B2A
+#define DMA_TRANSFER_WRITE		DMA_TRANSFER_A2B
+/* store/load from the PoV of the system(memory) */
+#define DMA_TRANSFER_STORE		DMA_TRANSFER_B2A
+#define DMA_TRANSFER_LOAD		DMA_TRANSFER_A2B
+#define DMA_TRANSFER_CLEAR		DMA_TRANSFER_CLEAR_A
+
+typedef enum {
+	DMA_TRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT,                                       /* 8 */
+	DMA_TRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT,                       /* 12 */
+	DMA_TRANSFER_A2B = DMA_RW_CMDBIT,                                              /* 4 */
+	DMA_TRANSFER_B2A = 0,                                                          /* 0 */
+	DMA_TRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD,                 /* 26 */
+	DMA_TRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD, /* 30 */
+	DMA_TRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD,                        /* 22 */
+	DMA_TRANSFER_B2A_NOACK = DMA_NOACK_CMD,                                        /* 18 */
+	DMA_FASTTRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_A2B = DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_B2A = DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_B2A_NOACK = DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+} dma_transfer_type_t;
+
+typedef enum {
+	DMA_CONFIG_SETUP = _DMA_V2_PACKING_SETUP_PARAM,
+	DMA_CONFIG_HEIGHT = _DMA_V2_HEIGHT_PARAM,
+	DMA_CONFIG_STRIDE_A_ = _DMA_V2_STRIDE_A_PARAM,
+	DMA_CONFIG_CROP_ELEM_A = _DMA_V2_ELEM_CROPPING_A_PARAM,
+	DMA_CONFIG_WIDTH_A = _DMA_V2_WIDTH_A_PARAM,
+	DMA_CONFIG_STRIDE_B_ = _DMA_V2_STRIDE_B_PARAM,
+	DMA_CONFIG_CROP_ELEM_B = _DMA_V2_ELEM_CROPPING_B_PARAM,
+	DMA_CONFIG_WIDTH_B = _DMA_V2_WIDTH_B_PARAM,
+} dma_config_type_t;
+
+#endif /* __DMA_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_global.h
new file mode 100644
index 0000000..f41394f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_global.h
@@ -0,0 +1,6 @@
+#ifndef __EVENT_GLOBAL_H_INCLUDED__
+#define __EVENT_GLOBAL_H_INCLUDED__
+
+/*#error "event_global.h: No global event information permitted"*/
+
+#endif /* __EVENT_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h
new file mode 100644
index 0000000..b41a757
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h
@@ -0,0 +1,18 @@
+#ifndef __FIFO_MONITOR_GLOBAL_H_INCLUDED__
+#define __FIFO_MONITOR_GLOBAL_H_INCLUDED__
+
+#define IS_FIFO_MONITOR_VERSION_2
+
+/*
+#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      0
+#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
+#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       2
+ *
+ * Actually, "HIVE_ISP_CSS_STREAM_SWITCH_SP = 1", "HIVE_ISP_CSS_STREAM_SWITCH_ISP = 0"
+ * "hive_isp_css_stream_switch_hrt.h"
+ */
+#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       0
+#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
+#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      2
+
+#endif /* __FIFO_MONITOR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h
new file mode 100644
index 0000000..f551ecd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h
@@ -0,0 +1,70 @@
+#ifndef __GDC_GLOBAL_H_INCLUDED__
+#define __GDC_GLOBAL_H_INCLUDED__
+
+#define IS_GDC_VERSION_2
+
+#include "gdc_v2_defs.h"
+
+/*
+ * Storage addresses for packed data transfer
+ */
+#define GDC_PARAM_ICX_LEFT_ROUNDED_IDX            0
+#define GDC_PARAM_OXDIM_FLOORED_IDX               1
+#define GDC_PARAM_OXDIM_LAST_IDX                  2
+#define GDC_PARAM_WOIX_LAST_IDX                   3
+#define GDC_PARAM_IY_TOPLEFT_IDX                  4
+#define GDC_PARAM_CHUNK_CNT_IDX                   5
+/*#define GDC_PARAM_ELEMENTS_PER_XMEM_ADDR_IDX    6 */		/* Derived from bpp */
+#define GDC_PARAM_BPP_IDX						  6
+#define GDC_PARAM_BLOCK_HEIGHT_IDX                7
+/*#define GDC_PARAM_DMA_CHANNEL_STRIDE_A_IDX        8*/		/* The DMA stride == the GDC buffer stride */
+#define GDC_PARAM_WOIX_IDX						  8
+#define GDC_PARAM_DMA_CHANNEL_STRIDE_B_IDX        9
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_A_IDX        10
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_B_IDX        11
+#define GDC_PARAM_VECTORS_PER_LINE_IN_IDX        12
+#define GDC_PARAM_VECTORS_PER_LINE_OUT_IDX       13
+#define GDC_PARAM_VMEM_IN_DIMY_IDX               14
+#define GDC_PARAM_COMMAND_IDX					 15
+#define N_GDC_PARAM								 16
+
+/* Because of the packed parameter transfer max(params) == max(fragments) */
+#define	N_GDC_FRAGMENTS		N_GDC_PARAM
+
+/* The GDC is capable of higher internal precision than the parameter data structures */
+#define HRT_GDC_COORD_SCALE_BITS	6
+#define HRT_GDC_COORD_SCALE			(1 << HRT_GDC_COORD_SCALE_BITS) 
+
+typedef enum {
+	gdc_8_bpp  = 8,
+	gdc_10_bpp = 10,
+	gdc_12_bpp = 12,
+	gdc_14_bpp = 14
+} gdc_bits_per_pixel_t;
+
+typedef struct gdc_scale_param_mem_s {
+	uint16_t  params[N_GDC_PARAM];
+	uint16_t  ipx_start_array[N_GDC_PARAM];
+	uint16_t  ibuf_offset[N_GDC_PARAM];
+	uint16_t  obuf_offset[N_GDC_PARAM];
+} gdc_scale_param_mem_t;
+
+typedef struct {
+	unsigned int      origin_x;
+	unsigned int      origin_y;
+	unsigned int      in_addr_offset;
+	unsigned int      in_block_width;
+	unsigned int      in_block_height;
+	unsigned int      p0_x;
+	unsigned int      p0_y;
+	unsigned int      p1_x;
+	unsigned int      p1_y;
+	unsigned int      p2_x;
+	unsigned int      p2_y;
+	unsigned int      p3_x;
+	unsigned int      p3_y;
+	unsigned int      padding[3];
+} gdc_warp_param_mem_t;
+
+
+#endif /* __GDC_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h
new file mode 100644
index 0000000..fd10ba6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h
@@ -0,0 +1,71 @@
+#ifndef __GP_DEVICE_GLOBAL_H_INCLUDED__
+#define __GP_DEVICE_GLOBAL_H_INCLUDED__
+
+#define IS_GP_DEVICE_VERSION_2
+
+#define _REG_GP_IRQ_REQ0_ADDR				0x08
+#define _REG_GP_IRQ_REQ1_ADDR				0x0C
+/* The SP sends SW interrupt info to this register */
+#define _REG_GP_IRQ_REQUEST0_ADDR			_REG_GP_IRQ_REQ0_ADDR
+#define _REG_GP_IRQ_REQUEST1_ADDR			_REG_GP_IRQ_REQ1_ADDR
+
+/* The SP configures FIFO switches in these registers */
+#define _REG_GP_SWITCH_IF_ADDR						0x40
+#define _REG_GP_SWITCH_GDC1_ADDR					0x44
+#define _REG_GP_SWITCH_GDC2_ADDR					0x48
+/* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
+#define _REG_GP_IFMT_input_switch_lut_reg0			0x00030800
+#define _REG_GP_IFMT_input_switch_lut_reg1			0x00030804
+#define _REG_GP_IFMT_input_switch_lut_reg2			0x00030808
+#define _REG_GP_IFMT_input_switch_lut_reg3			0x0003080C
+#define _REG_GP_IFMT_input_switch_lut_reg4			0x00030810
+#define _REG_GP_IFMT_input_switch_lut_reg5			0x00030814
+#define _REG_GP_IFMT_input_switch_lut_reg6			0x00030818
+#define _REG_GP_IFMT_input_switch_lut_reg7			0x0003081C
+#define _REG_GP_IFMT_input_switch_fsync_lut			0x00030820
+#define _REG_GP_IFMT_srst							0x00030824
+#define _REG_GP_IFMT_slv_reg_srst					0x00030828
+#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0x0003082C
+
+/* @ GP_DEVICE_BASE */
+#define _REG_GP_SYNCGEN_ENABLE_ADDR					0x00090000
+#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR			0x00090004
+#define _REG_GP_SYNCGEN_PAUSE_ADDR					0x00090008
+#define _REG_GP_NR_FRAMES_ADDR						0x0009000C
+#define _REG_GP_SYNGEN_NR_PIX_ADDR					0x00090010
+#define _REG_GP_SYNGEN_NR_LINES_ADDR				0x00090014
+#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR			0x00090018
+#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR			0x0009001C
+#define _REG_GP_ISEL_SOF_ADDR						0x00090020
+#define _REG_GP_ISEL_EOF_ADDR						0x00090024
+#define _REG_GP_ISEL_SOL_ADDR						0x00090028
+#define _REG_GP_ISEL_EOL_ADDR						0x0009002C
+#define _REG_GP_ISEL_LFSR_ENABLE_ADDR				0x00090030
+#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR				0x00090034
+#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR			0x00090038
+#define _REG_GP_ISEL_TPG_ENABLE_ADDR				0x0009003C
+#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR				0x00090040
+#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR				0x00090044
+#define _REG_GP_ISEL_VER_CNT_MASK_ADDR				0x00090048
+#define _REG_GP_ISEL_XY_CNT_MASK_ADDR				0x0009004C
+#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR				0x00090050
+#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR				0x00090054
+#define _REG_GP_ISEL_TPG_MODE_ADDR					0x00090058
+#define _REG_GP_ISEL_TPG_RED1_ADDR					0x0009005C
+#define _REG_GP_ISEL_TPG_GREEN1_ADDR				0x00090060
+#define _REG_GP_ISEL_TPG_BLUE1_ADDR					0x00090064
+#define _REG_GP_ISEL_TPG_RED2_ADDR					0x00090068
+#define _REG_GP_ISEL_TPG_GREEN2_ADDR				0x0009006C
+#define _REG_GP_ISEL_TPG_BLUE2_ADDR					0x00090070
+#define _REG_GP_ISEL_CH_ID_ADDR						0x00090074
+#define _REG_GP_ISEL_FMT_TYPE_ADDR					0x00090078
+#define _REG_GP_ISEL_DATA_SEL_ADDR					0x0009007C
+#define _REG_GP_ISEL_SBAND_SEL_ADDR					0x00090080
+#define _REG_GP_ISEL_SYNC_SEL_ADDR					0x00090084
+#define _REG_GP_SYNCGEN_HOR_CNT_ADDR				0x00090088
+#define _REG_GP_SYNCGEN_VER_CNT_ADDR				0x0009008C
+#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR				0x00090090
+#define _REG_GP_SOFT_RESET_ADDR						0x00090094
+
+
+#endif /* __GP_DEVICE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h
new file mode 100644
index 0000000..78413f4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h
@@ -0,0 +1,31 @@
+#ifndef __GPIO_GLOBAL_H_INCLUDED__
+#define __GPIO_GLOBAL_H_INCLUDED__
+
+#define IS_GPIO_VERSION_1
+
+#include <gpio_block_defs.h>
+
+/* pqiao: following part only defines in hive_isp_css_defs.h in fpga system.
+	port it here
+*/
+
+/* GPIO pin defines */
+/*#define HIVE_GPIO_CAMERA_BOARD_RESET_PIN_NR                   0
+#define HIVE_GPIO_LCD_CLOCK_SELECT_PIN_NR                     7
+#define HIVE_GPIO_HDMI_CLOCK_SELECT_PIN_NR                    8
+#define HIVE_GPIO_LCD_VERT_FLIP_PIN_NR                        8
+#define HIVE_GPIO_LCD_HOR_FLIP_PIN_NR                         9
+#define HIVE_GPIO_AS3683_GPIO_P0_PIN_NR                       1
+#define HIVE_GPIO_AS3683_DATA_P1_PIN_NR                       2
+#define HIVE_GPIO_AS3683_CLK_P2_PIN_NR                        3
+#define HIVE_GPIO_AS3683_T1_F0_PIN_NR                         4
+#define HIVE_GPIO_AS3683_SFL_F1_PIN_NR                        5
+#define HIVE_GPIO_AS3683_STROBE_F2_PIN_NR                     6
+#define HIVE_GPIO_MAX1577_EN1_PIN_NR                          1
+#define HIVE_GPIO_MAX1577_EN2_PIN_NR                          2
+#define HIVE_GPIO_MAX8685A_EN_PIN_NR                          3
+#define HIVE_GPIO_MAX8685A_TRIG_PIN_NR                        4*/
+
+#define HIVE_GPIO_STROBE_TRIGGER_PIN						2
+
+#endif /* __GPIO_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h
new file mode 100644
index 0000000..39b8b7c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h
@@ -0,0 +1,35 @@
+#ifndef __HMEM_GLOBAL_H_INCLUDED__
+#define __HMEM_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define IS_HMEM_VERSION_1
+
+#include "isp.h"
+
+/*
+#define ISP_HIST_ADDRESS_BITS                  12
+#define ISP_HIST_ALIGNMENT                     4
+#define ISP_HIST_COMP_IN_PREC                  12
+#define ISP_HIST_DEPTH                         1024
+#define ISP_HIST_WIDTH                         24
+#define ISP_HIST_COMPONENTS                    4
+*/
+#define ISP_HIST_ALIGNMENT_LOG2		2
+
+#define HMEM_SIZE_LOG2		(ISP_HIST_ADDRESS_BITS-ISP_HIST_ALIGNMENT_LOG2)
+#define HMEM_SIZE			ISP_HIST_DEPTH
+
+#define HMEM_UNIT_SIZE		(HMEM_SIZE/ISP_HIST_COMPONENTS)
+#define HMEM_UNIT_COUNT		ISP_HIST_COMPONENTS
+
+#define HMEM_RANGE_LOG2		ISP_HIST_WIDTH
+#define HMEM_RANGE			(1UL<<HMEM_RANGE_LOG2)
+
+typedef uint32_t			hmem_data_t;
+
+#endif /* __HMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c
new file mode 100644
index 0000000..70f72b4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c
@@ -0,0 +1,64 @@
+
+#include "debug.h"
+
+#ifndef __INLINE_DEBUG__
+#include "debug_private.h"
+#endif /* __INLINE_DEBUG__ */
+
+#include "memory_access.h"
+
+#include "sp.h"
+
+#include "assert_support.h"
+
+/* The address of the remote copy */
+hrt_address	debug_buffer_address = (hrt_address)-1;
+hrt_vaddress	debug_buffer_ddr_address = (hrt_vaddress)-1;
+/* The local copy */
+debug_data_t		debug_data;
+debug_data_t		*debug_data_ptr = &debug_data;
+
+void debug_buffer_init(
+	const hrt_address		addr)
+{
+	debug_buffer_address = addr;
+
+	debug_data.head = 0;
+	debug_data.tail = 0;
+return;
+}
+
+void debug_buffer_ddr_init(
+	const hrt_vaddress		addr)
+{
+	debug_buf_mode_t mode = DEBUG_BUFFER_MODE_LINEAR;
+	uint32_t enable = 1;
+	uint32_t head = 0;
+	uint32_t tail = 0;
+	/* set the ddr queue */
+	debug_buffer_ddr_address = addr;
+	mmgr_store(addr + DEBUG_DATA_BUF_MODE_DDR_ADDR,
+				&mode, sizeof(debug_buf_mode_t));
+	mmgr_store(addr + DEBUG_DATA_HEAD_DDR_ADDR,
+				&head, sizeof(uint32_t));
+	mmgr_store(addr + DEBUG_DATA_TAIL_DDR_ADDR,
+				&tail, sizeof(uint32_t));
+	mmgr_store(addr + DEBUG_DATA_ENABLE_DDR_ADDR,
+				&enable, sizeof(uint32_t));
+
+	/* set the local copy */
+	debug_data.head = 0;
+	debug_data.tail = 0;
+return;
+}
+
+void debug_buffer_setmode(
+	const debug_buf_mode_t	mode)
+{
+assert(debug_buffer_address != ((hrt_address)-1));
+
+	sp_dmem_store_uint32(SP0_ID,
+		debug_buffer_address + DEBUG_DATA_BUF_MODE_ADDR, mode);
+return;
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h
new file mode 100644
index 0000000..c57e817
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h
@@ -0,0 +1,7 @@
+#ifndef __DEBUG_LOCAL_H_INCLUDED__
+#define __DEBUG_LOCAL_H_INCLUDED__
+
+#include "debug_global.h"
+
+#endif /* __DEBUG_LOCAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h
new file mode 100644
index 0000000..76ab833
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h
@@ -0,0 +1,88 @@
+#ifndef __DEBUG_PRIVATE_H_INCLUDED__
+#define __DEBUG_PRIVATE_H_INCLUDED__
+
+#include "debug_public.h"
+
+#include "sp.h"
+
+#define __INLINE_ISP__
+#include "isp.h"
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_DEBUG_C bool is_debug_buffer_empty(void)
+{
+return (debug_data_ptr->head == debug_data_ptr->tail);
+}
+
+STORAGE_CLASS_DEBUG_C hrt_data debug_dequeue(void)
+{
+	hrt_data	value = 0;
+
+assert(debug_buffer_address != ((hrt_address)-1));
+
+	debug_synch_queue();
+
+	if (!is_debug_buffer_empty()) {
+		value = debug_data_ptr->buf[debug_data_ptr->head];
+		debug_data_ptr->head = (debug_data_ptr->head + 1) & DEBUG_BUF_MASK;
+		sp_dmem_store_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_HEAD_ADDR, debug_data_ptr->head);
+	}
+
+return value;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue(void)
+{
+	uint32_t	remote_tail	= sp_dmem_load_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_TAIL_ADDR);
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue_isp(void)
+{
+	uint32_t	remote_tail	= isp_dmem_load_uint32(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_TAIL_ADDR);
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue_ddr(void)
+{
+	uint32_t	remote_tail;
+
+	mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_TAIL_DDR_ADDR, &remote_tail, sizeof(uint32_t));
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+#endif /* __DEBUG_PRIVATE_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c
new file mode 100644
index 0000000..0f0fb13
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c
@@ -0,0 +1,269 @@
+
+#include <stddef.h>		/* NULL */
+
+#include "dma.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_DMA__
+#include "dma_private.h"
+#endif /* __INLINE_DMA__ */
+
+void dma_get_state(
+	const dma_ID_t		ID,
+	dma_state_t			*state)
+{
+	int			i;
+	hrt_data	tmp;
+
+assert(ID < N_DMA_ID);
+assert(state != NULL);
+
+	tmp = dma_reg_load(ID, DMA_COMMAND_FSM_REG_IDX);
+	state->fsm_command_idle = tmp & 0x1;
+	state->fsm_command_run = tmp & 0x2;
+	state->fsm_command_stalling = tmp & 0x4;
+	state->fsm_command_error    = tmp & 0x8;
+	state->last_command_channel = (tmp>>8 & 0xFF);
+	state->last_command_param =  (tmp>>16 & 0x0F);
+	tmp = (tmp>>4) & 0x0F;
+/* state->last_command = (dma_commands_t)tmp; */
+/* if the enumerator is made non-linear */
+	if (tmp == 0)
+		state->last_command = DMA_COMMAND_READ;
+	if (tmp == 1)
+		state->last_command = DMA_COMMAND_WRITE;
+	if (tmp == 2)
+		state->last_command = DMA_COMMAND_SET_CHANNEL;
+	if (tmp == 3)
+		state->last_command = DMA_COMMAND_SET_PARAM;
+	if (tmp == 4)
+		state->last_command = DMA_COMMAND_READ_SPECIFIC;
+	if (tmp == 5)
+		state->last_command = DMA_COMMAND_WRITE_SPECIFIC;
+	if (tmp == 8)
+		state->last_command = DMA_COMMAND_INIT;
+	if (tmp == 12)
+		state->last_command = DMA_COMMAND_INIT_SPECIFIC;
+	if (tmp == 15)
+		state->last_command = DMA_COMMAND_RST;
+
+/* No sub-fields, idx = 0 */
+	state->current_command = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_CMD_IDX));
+	state->current_addr_a = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_A_IDX));
+	state->current_addr_b = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_B_IDX));
+
+	tmp =  dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_idle = tmp & 0x1;
+	state->fsm_ctrl_run = tmp & 0x2;
+	state->fsm_ctrl_stalling = tmp & 0x4;
+	state->fsm_ctrl_error = tmp & 0x8;
+	tmp = tmp >> 4;
+/* state->fsm_ctrl_state = (dma_ctrl_states_t)tmp; */
+	if (tmp == 0)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_IDLE;
+	if (tmp == 1)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_REQ_RCV;
+	if (tmp == 2)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV;
+	if (tmp == 3)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV_REQ;
+	if (tmp == 4)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_INIT;
+	state->fsm_ctrl_source_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_addr = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_stride = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_dest_addr = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_dest_stride = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_elems = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_elems = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_extension = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_idle     = tmp & 0x1;
+	state->pack_run      = tmp & 0x2;
+	state->pack_stalling = tmp & 0x4;
+	state->pack_error    = tmp & 0x8;
+	state->pack_cnt_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_src_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_dest_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+/* state->read_state = (dma_rw_states_t)tmp; */
+	if (tmp == 0)
+		state->read_state = DMA_RW_STATE_IDLE;
+	if (tmp == 1)
+		state->read_state = DMA_RW_STATE_REQ;
+	if (tmp == 2)
+		state->read_state = DMA_RW_STATE_NEXT_LINE;
+	if (tmp == 3)
+		state->read_state = DMA_RW_STATE_UNLOCK_CHANNEL;
+	state->read_cnt_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+	state->read_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+/* state->write_state = (dma_rw_states_t)tmp; */
+	if (tmp == 0)
+		state->write_state = DMA_RW_STATE_IDLE;
+	if (tmp == 1)
+		state->write_state = DMA_RW_STATE_REQ;
+	if (tmp == 2)
+		state->write_state = DMA_RW_STATE_NEXT_LINE;
+	if (tmp == 3)
+		state->write_state = DMA_RW_STATE_UNLOCK_CHANNEL;
+	state->write_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+	state->write_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+
+	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
+		dma_port_state_t *port = &(state->port_states[i]);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(0, i));
+		port->req_cs   = ((tmp & 0x1) != 0);
+		port->req_we_n = ((tmp & 0x2) != 0);
+		port->req_run  = ((tmp & 0x4) != 0);
+		port->req_ack  = ((tmp & 0x8) != 0);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(1, i));
+		port->send_cs   = ((tmp & 0x1) != 0);
+		port->send_we_n = ((tmp & 0x2) != 0);
+		port->send_run  = ((tmp & 0x4) != 0);
+		port->send_ack  = ((tmp & 0x8) != 0);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(2, i));
+		if (tmp & 0x1)
+			port->fifo_state = DMA_FIFO_STATE_WILL_BE_FULL;
+		if (tmp & 0x2)
+			port->fifo_state = DMA_FIFO_STATE_FULL;
+		if (tmp & 0x4)
+			port->fifo_state = DMA_FIFO_STATE_EMPTY;
+		port->fifo_counter = tmp >> 3;
+	}
+
+	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
+		dma_channel_state_t *ch = &(state->channel_states[i]);
+
+		ch->connection = DMA_GET_CONNECTION(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_PACKING_SETUP_PARAM)));
+		ch->sign_extend = DMA_GET_EXTENSION(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_PACKING_SETUP_PARAM)));
+		ch->height = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_HEIGHT_PARAM));
+		ch->stride_a = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_STRIDE_A_PARAM));
+		ch->elems_a = DMA_GET_ELEMENTS(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_A_PARAM)));
+		ch->cropping_a = DMA_GET_CROPPING(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_A_PARAM)));
+		ch->width_a = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_WIDTH_A_PARAM));
+		ch->stride_b = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_STRIDE_B_PARAM));
+		ch->elems_b = DMA_GET_ELEMENTS(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_B_PARAM)));
+		ch->cropping_b = DMA_GET_CROPPING(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_B_PARAM)));
+		ch->width_b = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_WIDTH_B_PARAM));
+	}
+
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h
new file mode 100644
index 0000000..9c62370
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h
@@ -0,0 +1,193 @@
+#ifndef __DMA_LOCAL_H_INCLUDED__
+#define __DMA_LOCAL_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+#include "dma_global.h"
+
+#include <hrt/defs.h>				/* HRTCAT() */
+#include <hrt/bits.h>				/* _hrt_get_bits() */
+#include <hive_isp_css_defs.h>		/* HIVE_DMA_NUM_CHANNELS */
+#include <dma_v2_defs.h>
+
+#define _DMA_FSM_GROUP_CMD_IDX						_DMA_V2_FSM_GROUP_CMD_IDX
+#define _DMA_FSM_GROUP_ADDR_A_IDX					_DMA_V2_FSM_GROUP_ADDR_SRC_IDX
+#define _DMA_FSM_GROUP_ADDR_B_IDX					_DMA_V2_FSM_GROUP_ADDR_DEST_IDX
+
+#define _DMA_FSM_GROUP_CMD_CTRL_IDX					_DMA_V2_FSM_GROUP_CMD_CTRL_IDX
+
+#define _DMA_FSM_GROUP_FSM_CTRL_IDX					_DMA_V2_FSM_GROUP_FSM_CTRL_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX
+
+#define _DMA_FSM_GROUP_FSM_PACK_IDX					_DMA_V2_FSM_GROUP_FSM_PACK_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX
+
+#define _DMA_FSM_GROUP_FSM_REQ_IDX					_DMA_V2_FSM_GROUP_FSM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX
+
+#define _DMA_FSM_GROUP_FSM_WR_IDX					_DMA_V2_FSM_GROUP_FSM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_WR_STATE_IDX				_DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX
+
+/*
+ * Macro's to compute the DMA parameter register indices
+ */
+#define DMA_SEL_COMP(comp)     (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_COMP_BITS))            << _DMA_V2_ADDR_SEL_COMP_IDX)
+#define DMA_SEL_CH(ch)         (((ch)    & _hrt_ones(_DMA_V2_ADDR_SEL_CH_REG_BITS))          << _DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define DMA_SEL_PARAM(param)   (((param) & _hrt_ones(_DMA_V2_ADDR_SEL_PARAM_BITS))           << _DMA_V2_ADDR_SEL_PARAM_IDX)
+/* CG = Connection Group */
+#define DMA_SEL_CG_INFO(info)  (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS)) << _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX)
+#define DMA_SEL_CG_COMP(comp)  (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_BITS))      << _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define DMA_SEL_DEV_INFO(info) (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS)) << _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX)
+#define DMA_SEL_DEV_ID(dev)    (((dev)   & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS))  << _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX)
+
+#define DMA_COMMAND_FSM_REG_IDX					(DMA_SEL_COMP(_DMA_V2_SEL_FSM_CMD) >> 2)
+#define DMA_CHANNEL_PARAM_REG_IDX(ch, param)	((DMA_SEL_COMP(_DMA_V2_SEL_CH_REG) | DMA_SEL_CH(ch) | DMA_SEL_PARAM(param)) >> 2)
+#define DMA_CG_INFO_REG_IDX(info_id, comp_id)	((DMA_SEL_COMP(_DMA_V2_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | DMA_SEL_CG_COMP(comp_id)) >> 2)
+#define DMA_DEV_INFO_REG_IDX(info_id, dev_id)	((DMA_SEL_COMP(_DMA_V2_SEL_DEV_INTERF) | DMA_SEL_DEV_INFO(info_id) | DMA_SEL_DEV_ID(dev_id)) >> 2)
+#define DMA_RST_REG_IDX							(DMA_SEL_COMP(_DMA_V2_SEL_RESET) >> 2)
+
+#define DMA_GET_CONNECTION(val)    _hrt_get_bits(val, _DMA_V2_CONNECTION_IDX,    _DMA_V2_CONNECTION_BITS)
+#define DMA_GET_EXTENSION(val)     _hrt_get_bits(val, _DMA_V2_EXTENSION_IDX,     _DMA_V2_EXTENSION_BITS)
+#define DMA_GET_ELEMENTS(val)      _hrt_get_bits(val, _DMA_V2_ELEMENTS_IDX,      _DMA_V2_ELEMENTS_BITS)
+#define DMA_GET_CROPPING(val)      _hrt_get_bits(val, _DMA_V2_LEFT_CROPPING_IDX, _DMA_V2_LEFT_CROPPING_BITS)
+
+typedef enum {
+	DMA_CTRL_STATE_IDLE,
+	DMA_CTRL_STATE_REQ_RCV,
+	DMA_CTRL_STATE_RCV,
+	DMA_CTRL_STATE_RCV_REQ,
+	DMA_CTRL_STATE_INIT,
+	N_DMA_CTRL_STATES
+} dma_ctrl_states_t;
+
+typedef enum {
+	DMA_COMMAND_READ,
+	DMA_COMMAND_WRITE,
+	DMA_COMMAND_SET_CHANNEL,
+	DMA_COMMAND_SET_PARAM,
+	DMA_COMMAND_READ_SPECIFIC,
+	DMA_COMMAND_WRITE_SPECIFIC,
+	DMA_COMMAND_INIT,
+	DMA_COMMAND_INIT_SPECIFIC,
+	DMA_COMMAND_RST,
+	N_DMA_COMMANDS
+} dma_commands_t;
+
+typedef enum {
+	DMA_RW_STATE_IDLE,
+	DMA_RW_STATE_REQ,
+	DMA_RW_STATE_NEXT_LINE,
+	DMA_RW_STATE_UNLOCK_CHANNEL,
+	N_DMA_RW_STATES
+} dma_rw_states_t;
+
+typedef enum {
+	DMA_FIFO_STATE_WILL_BE_FULL,
+	DMA_FIFO_STATE_FULL,
+	DMA_FIFO_STATE_EMPTY,
+	N_DMA_FIFO_STATES
+} dma_fifo_states_t;
+
+/* typedef struct dma_state_s			dma_state_t; */
+typedef struct dma_channel_state_s	dma_channel_state_t;
+typedef struct dma_port_state_s		dma_port_state_t;
+
+struct dma_port_state_s {
+	bool                       req_cs;
+	bool                       req_we_n;
+	bool                       req_run;
+	bool                       req_ack;
+	bool                       send_cs;
+	bool                       send_we_n;
+	bool                       send_run;
+	bool                       send_ack;
+	dma_fifo_states_t          fifo_state;
+	int                        fifo_counter;
+};
+
+struct dma_channel_state_s {
+	int                        connection;
+	bool                       sign_extend;
+	int                        height;
+	int                        stride_a;
+	int                        elems_a;
+	int                        cropping_a;
+	int                        width_a;
+	int                        stride_b;
+	int                        elems_b;
+	int                        cropping_b;
+	int                        width_b;
+};
+
+struct dma_state_s {
+	bool                       fsm_command_idle;
+	bool                       fsm_command_run;
+	bool                       fsm_command_stalling;
+	bool                       fsm_command_error;
+	dma_commands_t             last_command;
+	int                        last_command_channel;
+	int                        last_command_param;
+	dma_commands_t             current_command;
+	int                        current_addr_a;
+	int                        current_addr_b;
+	bool                       fsm_ctrl_idle;
+	bool                       fsm_ctrl_run;
+	bool                       fsm_ctrl_stalling;
+	bool                       fsm_ctrl_error;
+	dma_ctrl_states_t          fsm_ctrl_state;
+	int                        fsm_ctrl_source_dev;
+	int                        fsm_ctrl_source_addr;
+	int                        fsm_ctrl_source_stride;
+	int                        fsm_ctrl_source_width;
+	int                        fsm_ctrl_source_height;
+	int                        fsm_ctrl_pack_source_dev;
+	int                        fsm_ctrl_pack_dest_dev;
+	int                        fsm_ctrl_dest_addr;
+	int                        fsm_ctrl_dest_stride;
+	int                        fsm_ctrl_pack_source_width;
+	int                        fsm_ctrl_pack_dest_height;
+	int                        fsm_ctrl_pack_dest_width;
+	int                        fsm_ctrl_pack_source_elems;
+	int                        fsm_ctrl_pack_dest_elems;
+	int                        fsm_ctrl_pack_extension;
+	int						   pack_idle;
+	int	                       pack_run;
+	int		               	   pack_stalling;
+	int		                   pack_error;
+	int                        pack_cnt_height;
+	int                        pack_src_cnt_width;
+	int                        pack_dest_cnt_width;
+	dma_rw_states_t            read_state;
+	int                        read_cnt_height;
+	int                        read_cnt_width;
+	dma_rw_states_t            write_state;
+	int                        write_height;
+	int                        write_width;
+	dma_port_state_t           port_states[HIVE_ISP_NUM_DMA_CONNS];
+	dma_channel_state_t        channel_states[HIVE_DMA_NUM_CHANNELS];
+};
+
+#endif /* __DMA_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h
new file mode 100644
index 0000000..ad35618
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h
@@ -0,0 +1,30 @@
+#ifndef __DMA_PRIVATE_H_INCLUDED__
+#define __DMA_PRIVATE_H_INCLUDED__
+
+#include "dma_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_DMA_C void dma_reg_store(
+	const dma_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_DMA_ID);
+assert(DMA_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_DMA_C hrt_data dma_reg_load(
+	const dma_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_DMA_ID);
+assert(DMA_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __DMA_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event.c
new file mode 100644
index 0000000..690d68d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event.c
@@ -0,0 +1,6 @@
+
+#include "event.h"
+
+#ifndef __INLINE_EVENT__
+#include "event_private.h"
+#endif /* __INLINE_EVENT__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_local.h
new file mode 100644
index 0000000..ab35995
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_local.h
@@ -0,0 +1,43 @@
+#ifndef __EVENT_LOCAL_H_INCLUDED__
+#define __EVENT_LOCAL_H_INCLUDED__
+
+/*
+ * All events come from connections mapped on the system
+ * bus but do not use a global IRQ
+ */
+#include "event_global.h"
+
+typedef enum {
+	SP0_EVENT_ID,
+	ISP0_EVENT_ID,
+	STR2MIPI_EVENT_ID,
+	N_EVENT_ID
+} event_ID_t;
+
+#define	EVENT_QUERY_BIT		0
+
+/* Events are read from FIFO */
+static const hrt_address event_source_addr[N_EVENT_ID] = {
+	0x0000000000380000ULL,
+	0x0000000000380004ULL,
+	0xffffffffffffffffULL};
+
+/* Read from FIFO are blocking, query data availability */
+static const hrt_address event_source_query_addr[N_EVENT_ID] = {
+	0x0000000000380010ULL,
+	0x0000000000380014ULL,
+	0xffffffffffffffffULL};
+
+/* Events are written to FIFO */
+static const hrt_address event_sink_addr[N_EVENT_ID] = {
+	0x0000000000380008ULL,
+	0x000000000038000CULL,
+	0x0000000000090104ULL};
+
+/* Writes to FIFO are blocking, query data space */
+static const hrt_address event_sink_query_addr[N_EVENT_ID] = {
+	0x0000000000380018ULL,
+	0x000000000038001CULL,
+	0x000000000009010CULL};
+
+#endif /* __EVENT_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_private.h
new file mode 100644
index 0000000..6a823fe
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_private.h
@@ -0,0 +1,69 @@
+#ifndef __EVENT_PRIVATE_H_INCLUDED__
+#define __EVENT_PRIVATE_H_INCLUDED__
+
+#include "event_public.h"
+
+#include "device_access.h"
+
+#include <bits.h>
+
+#include "assert_support.h"
+
+STORAGE_CLASS_EVENT_C void event_wait_for(
+	const event_ID_t		ID)
+{
+assert(ID < N_EVENT_ID);
+assert(event_source_addr[ID] != ((hrt_address)-1));
+	(void)device_load_uint32(event_source_addr[ID]);
+return;
+}
+
+STORAGE_CLASS_EVENT_C void cnd_event_wait_for(
+	const event_ID_t		ID,
+	const bool				cnd)
+{
+	if (cnd) {
+		event_wait_for(ID);
+	}
+return;
+}
+
+STORAGE_CLASS_EVENT_C hrt_data event_receive_token(
+	const event_ID_t		ID)
+{
+assert(ID < N_EVENT_ID);
+assert(event_source_addr[ID] != ((hrt_address)-1));
+return device_load_uint32(event_source_addr[ID]);
+}
+
+STORAGE_CLASS_EVENT_C void event_send_token(
+	const event_ID_t		ID,
+	const hrt_data			token)
+{
+assert(ID < N_EVENT_ID);
+assert(event_sink_addr[ID] != ((hrt_address)-1));
+	device_store_uint32(event_sink_addr[ID], token);
+return;
+}
+
+STORAGE_CLASS_EVENT_C bool is_event_pending(
+	const event_ID_t		ID)
+{
+	hrt_data	value;
+assert(ID < N_EVENT_ID);
+assert(event_source_query_addr[ID] != ((hrt_address)-1));
+	value = device_load_uint32(event_source_query_addr[ID]);
+return !_hrt_get_bit(value, EVENT_QUERY_BIT);
+}
+
+STORAGE_CLASS_EVENT_C bool can_event_send_token(
+	const event_ID_t		ID)
+{
+	hrt_data	value;
+assert(ID < N_EVENT_ID);
+assert(event_sink_query_addr[ID] != ((hrt_address)-1));
+	value = device_load_uint32(event_sink_query_addr[ID]);
+return !_hrt_get_bit(value, EVENT_QUERY_BIT);
+}
+
+#endif /* __EVENT_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c
new file mode 100644
index 0000000..ed3155b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c
@@ -0,0 +1,556 @@
+
+#include "fifo_monitor.h"
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+#include "device_access.h"
+
+#include <hrt/bits.h>
+
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_FIFO_MONITOR__
+#define STORAGE_CLASS_FIFO_MONITOR_DATA static const
+
+STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
+
+#include "fifo_monitor_private.h"
+#else
+#define STORAGE_CLASS_FIFO_MONITOR_DATA const
+
+STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
+#endif /* __INLINE_FIFO_MONITOR__ */
+
+STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH] = {
+	_REG_GP_SWITCH_IF_ADDR,
+	_REG_GP_SWITCH_GDC1_ADDR,
+	_REG_GP_SWITCH_GDC2_ADDR};
+
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_valid (
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id);
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_accept(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id);
+
+
+void fifo_channel_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_channel_t		channel_id,
+	fifo_channel_state_t		*state)
+{
+assert(state != NULL);
+assert(channel_id < N_FIFO_CHANNEL);
+
+	switch (channel_id) {
+	case FIFO_CHANNEL_ISP0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_IF0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_IF0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A); /* ISP_STR_MON_PORT_PIFA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_IF1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_IF1_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* ISP_STR_MON_PORT_PIFB2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_DMA0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA); /* ISP_STR_MON_PORT_ISP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP); /* MOD_STR_MON_PORT_ISP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP);
+		break;
+	case FIFO_CHANNEL_DMA0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP); /* MOD_STR_MON_PORT_DMA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA); /* ISP_STR_MON_PORT_DMA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_GDC0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC); /* ISP_STR_MON_PORT_ISP2GDC1 */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC); /* MOD_STR_MON_PORT_CELLS2GDC1 */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC);
+		break;
+	case FIFO_CHANNEL_GDC0_TO_ISP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC); /* MOD_STR_MON_PORT_GDC12CELLS */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC); /* ISP_STR_MON_PORT_GDC12ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_GDC1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		break;
+	case FIFO_CHANNEL_GDC1_TO_ISP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_HOST0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD); /* ISP_STR_MON_PORT_ISP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD);
+		{
+		hrt_data	value = device_load_uint32(0x0000000000380014ULL);
+		state->fifo_valid  = !_hrt_get_bit(value, 0);
+		state->sink_accept = false; /* no monitor connected */
+		}
+		break;
+	case FIFO_CHANNEL_HOST0_TO_ISP0:
+		{
+		hrt_data	value = device_load_uint32(0x000000000038001CULL);
+		state->fifo_valid  = false; /* no monitor connected */
+		state->sink_accept = !_hrt_get_bit(value, 0);
+		}
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD); /* ISP_STR_MON_PORT_FA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A); /* SP_STR_MON_PORT_SP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_IF0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A); /* SP_STR_MON_PORT_PIFA2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B); /* SP_STR_MON_PORT_SP2PIFB */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_IF1_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* SP_STR_MON_PORT_PIFB2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF2:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF); /* SP_STR_MON_PORT_SP2SIF */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF); /* MOD_STR_MON_PORT_SP2SIF */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF);
+		break;
+	case FIFO_CHANNEL_IF2_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF); /* MOD_STR_MON_PORT_SIF2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF); /* SP_STR_MON_PORT_SIF2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF);
+		break;
+	case FIFO_CHANNEL_SP0_TO_DMA0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA); /* SP_STR_MON_PORT_SP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP); /* MOD_STR_MON_PORT_SP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP);
+		break;
+	case FIFO_CHANNEL_DMA0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP); /* MOD_STR_MON_PORT_DMA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA); /* SP_STR_MON_PORT_DMA2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA);
+		break;
+	case FIFO_CHANNEL_SP0_TO_GDC0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
+		break;
+	case FIFO_CHANNEL_GDC0_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_GDC1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		break;
+	case FIFO_CHANNEL_GDC1_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_HOST0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD); /* SP_STR_MON_PORT_SP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD);
+		{
+		hrt_data	value = device_load_uint32(0x0000000000380010ULL);
+		state->fifo_valid  = !_hrt_get_bit(value, 0);
+		state->sink_accept = false; /* no monitor connected */
+		}
+		break;
+	case FIFO_CHANNEL_HOST0_TO_SP0:
+		{
+		hrt_data	value = device_load_uint32(0x0000000000380018ULL);
+		state->fifo_valid  = false; /* no monitor connected */
+		state->sink_accept = !_hrt_get_bit(value, 0);
+		}
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD); /* SP_STR_MON_PORT_FA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD);
+		break;
+	case FIFO_CHANNEL_SP0_TO_STREAM2MEM0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_SP2MC */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_SP2MC */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC);
+		break;
+	case FIFO_CHANNEL_STREAM2MEM0_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_MC2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_MC2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC);
+		break;
+	case FIFO_CHANNEL_SP0_TO_INPUT_SYSTEM0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_valid  = false;
+		state->sink_accept = false;
+		break;
+	case FIFO_CHANNEL_INPUT_SYSTEM0_TO_SP0:
+		state->fifo_valid  = false;
+		state->sink_accept = false;
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
+		break;
+	default:
+assert(0);
+		break;
+	}
+
+return;
+}
+
+void fifo_switch_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	fifo_switch_state_t			*state)
+{
+	hrt_data		data = (hrt_data)-1;
+
+assert(state != NULL);
+assert(switch_id < N_FIFO_SWITCH);
+assert(ID == FIFO_MONITOR0_ID);
+
+(void)ID;
+
+	data = gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
+
+	state->is_none = (data == HIVE_ISP_CSS_STREAM_SWITCH_NONE);
+	state->is_sp = (data == HIVE_ISP_CSS_STREAM_SWITCH_SP);
+	state->is_isp = (data == HIVE_ISP_CSS_STREAM_SWITCH_ISP);
+
+return;
+}
+
+void fifo_monitor_get_state(
+	const fifo_monitor_ID_t		ID,
+	fifo_monitor_state_t		*state)
+{
+	fifo_channel_t	ch_id;
+	fifo_switch_t	sw_id;
+
+assert(state != NULL);
+assert(ID < N_FIFO_MONITOR_ID);
+
+	for (ch_id = 0; ch_id < N_FIFO_CHANNEL; ch_id++) {
+		fifo_channel_get_state(ID, ch_id,
+			&(state->fifo_channels[ch_id]));
+	}
+
+	for (sw_id = 0; sw_id < N_FIFO_SWITCH; sw_id++) {
+		fifo_switch_get_state(ID, sw_id,
+			&(state->fifo_switches[sw_id]));
+	}
+return;
+}
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_valid (
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id)
+{
+hrt_data	data = fifo_monitor_reg_load(ID, reg);
+return (data >> (((port_id * 2) + _hive_str_mon_valid_offset))) & 0x1;
+}
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_accept(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id)
+{
+hrt_data	data = fifo_monitor_reg_load(ID, reg);
+return (data >> (((port_id * 2) + _hive_str_mon_accept_offset))) & 0x1;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h
new file mode 100644
index 0000000..3543bbc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h
@@ -0,0 +1,88 @@
+#ifndef __FIFO_MONITOR_LOCAL_H_INCLUDED__
+#define __FIFO_MONITOR_LOCAL_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include "fifo_monitor_global.h"
+
+#include "hive_isp_css_defs.h"	/* ISP_STR_MON_PORT_SND_SP, ... */
+
+#define _hive_str_mon_valid_offset   0
+#define _hive_str_mon_accept_offset  1
+
+#define	FIFO_CHANNEL_SP_VALID_MASK		0x55555555
+#define	FIFO_CHANNEL_SP_VALID_B_MASK	0x00000055
+#define	FIFO_CHANNEL_ISP_VALID_MASK		0x15555555
+#define	FIFO_CHANNEL_MOD_VALID_MASK		0x55555555
+
+typedef enum {
+	FIFO_SWITCH_IF,
+	FIFO_SWITCH_GDC0,
+	FIFO_SWITCH_GDC1,
+	N_FIFO_SWITCH
+} fifo_switch_t;
+
+typedef enum {
+	FIFO_CHANNEL_ISP0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_IF0,
+	FIFO_CHANNEL_IF0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_IF1,
+	FIFO_CHANNEL_IF1_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_DMA0,
+	FIFO_CHANNEL_DMA0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_GDC0,
+	FIFO_CHANNEL_GDC0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_GDC1,
+	FIFO_CHANNEL_GDC1_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_HOST0,
+	FIFO_CHANNEL_HOST0_TO_ISP0,
+	FIFO_CHANNEL_SP0_TO_IF0,
+	FIFO_CHANNEL_IF0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_IF1,
+	FIFO_CHANNEL_IF1_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_IF2,
+	FIFO_CHANNEL_IF2_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_DMA0,
+	FIFO_CHANNEL_DMA0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_GDC0,
+	FIFO_CHANNEL_GDC0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_GDC1,
+	FIFO_CHANNEL_GDC1_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_HOST0,
+	FIFO_CHANNEL_HOST0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_STREAM2MEM0,
+	FIFO_CHANNEL_STREAM2MEM0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_INPUT_SYSTEM0,
+	FIFO_CHANNEL_INPUT_SYSTEM0_TO_SP0,
+/*
+ * No clue what this is
+ *
+	FIFO_CHANNEL_SP0_TO_IRQ0,
+	FIFO_CHANNEL_IRQ0_TO_SP0,
+ */
+	N_FIFO_CHANNEL
+} fifo_channel_t;
+
+struct fifo_channel_state_s {
+	bool	src_valid;
+	bool	fifo_accept;
+	bool	fifo_valid;
+	bool	sink_accept;
+};
+
+/* The switch is tri-state */
+struct fifo_switch_state_s {
+	bool	is_none;
+	bool	is_isp;
+	bool	is_sp;
+};
+
+struct fifo_monitor_state_s {
+	struct fifo_channel_state_s	fifo_channels[N_FIFO_CHANNEL];
+	struct fifo_switch_state_s	fifo_switches[N_FIFO_SWITCH];
+};
+
+#endif /* __FIFO_MONITOR_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h
new file mode 100644
index 0000000..43080f1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h
@@ -0,0 +1,63 @@
+#ifndef __FIFO_MONITOR_PRIVATE_H_INCLUDED__
+#define __FIFO_MONITOR_PRIVATE_H_INCLUDED__
+
+#include "fifo_monitor_public.h"
+
+#define __INLINE_GP_DEVICE__
+#include "gp_device.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+#ifdef __INLINE_FIFO_MONITOR__
+extern const unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
+#endif
+
+STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	const hrt_data				sel)
+{
+assert(ID == FIFO_MONITOR0_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+assert(switch_id < N_FIFO_SWITCH);
+
+	gp_device_reg_store(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id], sel);
+
+return;
+}
+
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_switch_get(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id)
+{
+assert(ID == FIFO_MONITOR0_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+assert(switch_id < N_FIFO_SWITCH);
+
+return gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
+}
+
+
+STORAGE_CLASS_FIFO_MONITOR_C void fifo_monitor_reg_store(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_FIFO_MONITOR_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(FIFO_MONITOR_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_monitor_reg_load(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg)
+{
+assert(ID < N_FIFO_MONITOR_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(FIFO_MONITOR_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __FIFO_MONITOR_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c
new file mode 100644
index 0000000..5fbb748
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c
@@ -0,0 +1,81 @@
+
+/* The name "gdc.h is already taken" */
+#include "gdc_device.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+/*
+ * Local function declarations
+ */
+STORAGE_CLASS_INLINE void gdc_reg_store(
+	const gdc_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+STORAGE_CLASS_INLINE hrt_data gdc_reg_load(
+	const gdc_ID_t		ID,
+	const unsigned int	reg);
+
+
+#ifndef __INLINE_GDC__
+#include "gdc_private.h"
+#endif /* __INLINE_GDC__ */
+
+/*
+ * Exported function implementations
+ */
+void gdc_lut_store(
+	const gdc_ID_t		ID,
+	const int			data[4][HRT_GDC_N])
+{
+	unsigned int i, lut_offset = HRT_GDC_LUT_IDX;
+
+assert(ID < N_GDC_ID);
+assert(HRT_GDC_LUT_COEFF_OFFSET <= (4*sizeof(hrt_data)));
+
+	for (i = 0; i < HRT_GDC_N; i++) {
+		hrt_data	entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;
+
+		hrt_data	word_0 = entry_0 |
+			(entry_1 << HRT_GDC_LUT_COEFF_OFFSET);
+		hrt_data	word_1 = entry_2 |
+			(entry_3 << HRT_GDC_LUT_COEFF_OFFSET);
+
+		gdc_reg_store(ID, lut_offset++, word_0);
+		gdc_reg_store(ID, lut_offset++, word_1);
+	}
+return;
+}
+
+int gdc_get_unity(
+	const gdc_ID_t		ID)
+{
+assert(ID < N_GDC_ID);
+	(void)ID;
+return (int)(1UL << HRT_GDC_FRAC_BITS);
+}
+
+
+/*
+ * Local function implementations
+ */
+STORAGE_CLASS_INLINE void gdc_reg_store(
+	const gdc_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+	device_store_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INLINE hrt_data gdc_reg_load(
+	const gdc_ID_t		ID,
+	const unsigned int	reg)
+{
+return device_load_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data));
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h
new file mode 100644
index 0000000..6fd3c6f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h
@@ -0,0 +1,6 @@
+#ifndef __GDC_LOCAL_H_INCLUDED__
+#define __GDC_LOCAL_H_INCLUDED__
+
+#include "gdc_global.h"
+
+#endif /* __GDC_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h
new file mode 100644
index 0000000..1d9e61c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h
@@ -0,0 +1,6 @@
+#ifndef __GDC_PRIVATE_H_INCLUDED__
+#define __GDC_PRIVATE_H_INCLUDED__
+
+#include "gdc_public.h"
+
+#endif /* __GDC_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c
new file mode 100644
index 0000000..a5d27df
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c
@@ -0,0 +1,93 @@
+#include "gp_device.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#include "gp_device_private.h"
+#endif /* __INLINE_GP_DEVICE__ */
+
+void gp_device_get_state(
+	const gp_device_ID_t		ID,
+	gp_device_state_t			*state)
+{
+assert(ID < N_GP_DEVICE_ID);
+assert(state != NULL);
+
+	state->syncgen_enable = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_ENABLE_ADDR);
+	state->syncgen_free_running = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_FREE_RUNNING_ADDR);
+	state->syncgen_pause = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_PAUSE_ADDR);
+	state->nr_frames = gp_device_reg_load(ID,
+		_REG_GP_NR_FRAMES_ADDR);
+	state->syngen_nr_pix = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_pix = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_lines = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_LINES_ADDR);
+	state->syngen_hblank_cycles = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_HBLANK_CYCLES_ADDR);
+	state->syngen_vblank_cycles = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_VBLANK_CYCLES_ADDR);
+	state->isel_sof = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SOF_ADDR);
+	state->isel_eof = gp_device_reg_load(ID,
+		_REG_GP_ISEL_EOF_ADDR);
+	state->isel_sol = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SOL_ADDR);
+	state->isel_eol = gp_device_reg_load(ID,
+		_REG_GP_ISEL_EOL_ADDR);
+	state->isel_lfsr_enable = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_ENABLE_ADDR);
+	state->isel_lfsr_enable_b = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_ENABLE_B_ADDR);
+	state->isel_lfsr_reset_value = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_RESET_VALUE_ADDR);
+	state->isel_tpg_enable = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_ENABLE_ADDR);
+	state->isel_tpg_enable_b = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_ENABLE_B_ADDR);
+	state->isel_hor_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_HOR_CNT_MASK_ADDR);
+	state->isel_ver_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_VER_CNT_MASK_ADDR);
+	state->isel_xy_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_XY_CNT_MASK_ADDR);
+	state->isel_hor_cnt_delta = gp_device_reg_load(ID,
+		_REG_GP_ISEL_HOR_CNT_DELTA_ADDR);
+	state->isel_ver_cnt_delta = gp_device_reg_load(ID,
+		_REG_GP_ISEL_VER_CNT_DELTA_ADDR);
+	state->isel_tpg_mode = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_MODE_ADDR);
+	state->isel_tpg_red1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_RED1_ADDR);
+	state->isel_tpg_green1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_GREEN1_ADDR);
+	state->isel_tpg_blue1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_BLUE1_ADDR);
+	state->isel_tpg_red2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_RED2_ADDR);
+	state->isel_tpg_green2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_GREEN2_ADDR);
+	state->isel_tpg_blue2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_BLUE2_ADDR);
+	state->isel_ch_id = gp_device_reg_load(ID,
+		_REG_GP_ISEL_CH_ID_ADDR);
+	state->isel_fmt_type = gp_device_reg_load(ID,
+		_REG_GP_ISEL_FMT_TYPE_ADDR);
+	state->isel_data_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_DATA_SEL_ADDR);
+	state->isel_sband_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SBAND_SEL_ADDR);
+	state->isel_sync_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SYNC_SEL_ADDR);
+	state->syncgen_hor_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_HOR_CNT_ADDR);
+	state->syncgen_ver_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_VER_CNT_ADDR);
+	state->syncgen_frame_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_FRAME_CNT_ADDR);
+	state->soft_reset = gp_device_reg_load(ID,
+		_REG_GP_SOFT_RESET_ADDR);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h
new file mode 100644
index 0000000..b8de820
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h
@@ -0,0 +1,128 @@
+#ifndef __GP_DEVICE_LOCAL_H_INCLUDED__
+#define __GP_DEVICE_LOCAL_H_INCLUDED__
+
+#include "gp_device_global.h"
+
+/* @ GP_REGS_BASE -> GP_DEVICE_BASE */
+#define _REG_GP_SDRAM_WAKEUP_ADDR					0x00
+#define _REG_GP_IDLE_ADDR							0x04
+/* #define _REG_GP_IRQ_REQ0_ADDR					0x08 */
+/* #define _REG_GP_IRQ_REQ1_ADDR					0x0C */
+#define _REG_GP_SP_STREAM_STAT_ADDR					0x10
+#define _REG_GP_SP_STREAM_STAT_B_ADDR				0x14
+#define _REG_GP_ISP_STREAM_STAT_ADDR				0x18
+#define _REG_GP_MOD_STREAM_STAT_ADDR				0x1C
+#define _REG_GP_SP_STREAM_STAT_IRQ_COND_ADDR		0x20
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_COND_ADDR		0x24
+#define _REG_GP_ISP_STREAM_STAT_IRQ_COND_ADDR		0x28
+#define _REG_GP_MOD_STREAM_STAT_IRQ_COND_ADDR		0x2C
+#define _REG_GP_SP_STREAM_STAT_IRQ_ENABLE_ADDR		0x30
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_ENABLE_ADDR	0x34
+#define _REG_GP_ISP_STREAM_STAT_IRQ_ENABLE_ADDR		0x38
+#define _REG_GP_MOD_STREAM_STAT_IRQ_ENABLE_ADDR		0x3C
+/*
+#define _REG_GP_SWITCH_IF_ADDR						0x40
+#define _REG_GP_SWITCH_GDC1_ADDR					0x44
+#define _REG_GP_SWITCH_GDC2_ADDR					0x48
+*/
+#define _REG_GP_SLV_REG_RST_ADDR					0x50
+
+/* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
+/*
+#define _REG_GP_IFMT_input_switch_lut_reg0			0x00030800
+#define _REG_GP_IFMT_input_switch_lut_reg1			0x00030804
+#define _REG_GP_IFMT_input_switch_lut_reg2			0x00030808
+#define _REG_GP_IFMT_input_switch_lut_reg3			0x0003080C
+#define _REG_GP_IFMT_input_switch_lut_reg4			0x00030810
+#define _REG_GP_IFMT_input_switch_lut_reg5			0x00030814
+#define _REG_GP_IFMT_input_switch_lut_reg6			0x00030818
+#define _REG_GP_IFMT_input_switch_lut_reg7			0x0003081C
+#define _REG_GP_IFMT_input_switch_fsync_lut			0x00030820
+#define _REG_GP_IFMT_srst							0x00030824
+#define _REG_GP_IFMT_slv_reg_srst					0x00030828
+#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0x0003082C
+*/
+/* @ GP_DEVICE_BASE */
+/*
+#define _REG_GP_SYNCGEN_ENABLE_ADDR					0x00090000
+#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR			0x00090004
+#define _REG_GP_SYNCGEN_PAUSE_ADDR					0x00090008
+#define _REG_GP_NR_FRAMES_ADDR						0x0009000C
+#define _REG_GP_SYNGEN_NR_PIX_ADDR					0x00090010
+#define _REG_GP_SYNGEN_NR_LINES_ADDR				0x00090014
+#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR			0x00090018
+#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR			0x0009001C
+#define _REG_GP_ISEL_SOF_ADDR						0x00090020
+#define _REG_GP_ISEL_EOF_ADDR						0x00090024
+#define _REG_GP_ISEL_SOL_ADDR						0x00090028
+#define _REG_GP_ISEL_EOL_ADDR						0x0009002C
+#define _REG_GP_ISEL_LFSR_ENABLE_ADDR				0x00090030
+#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR				0x00090034
+#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR			0x00090038
+#define _REG_GP_ISEL_TPG_ENABLE_ADDR				0x0009003C
+#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR				0x00090040
+#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR				0x00090044
+#define _REG_GP_ISEL_VER_CNT_MASK_ADDR				0x00090048
+#define _REG_GP_ISEL_XY_CNT_MASK_ADDR				0x0009004C
+#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR				0x00090050
+#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR				0x00090054
+#define _REG_GP_ISEL_TPG_MODE_ADDR					0x00090058
+#define _REG_GP_ISEL_TPG_RED1_ADDR					0x0009005C
+#define _REG_GP_ISEL_TPG_GREEN1_ADDR				0x00090060
+#define _REG_GP_ISEL_TPG_BLUE1_ADDR					0x00090064
+#define _REG_GP_ISEL_TPG_RED2_ADDR					0x00090068
+#define _REG_GP_ISEL_TPG_GREEN2_ADDR				0x0009006C
+#define _REG_GP_ISEL_TPG_BLUE2_ADDR					0x00090070
+#define _REG_GP_ISEL_CH_ID_ADDR						0x00090074
+#define _REG_GP_ISEL_FMT_TYPE_ADDR					0x00090078
+#define _REG_GP_ISEL_DATA_SEL_ADDR					0x0009007C
+#define _REG_GP_ISEL_SBAND_SEL_ADDR					0x00090080
+#define _REG_GP_ISEL_SYNC_SEL_ADDR					0x00090084
+#define _REG_GP_SYNCGEN_HOR_CNT_ADDR				0x00090088
+#define _REG_GP_SYNCGEN_VER_CNT_ADDR				0x0009008C
+#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR				0x00090090
+#define _REG_GP_SOFT_RESET_ADDR						0x00090094
+*/
+
+struct gp_device_state_s {
+	int syncgen_enable;
+	int syncgen_free_running;
+	int syncgen_pause;
+	int nr_frames;
+	int syngen_nr_pix;
+	int syngen_nr_lines;
+	int syngen_hblank_cycles;
+	int syngen_vblank_cycles;
+	int isel_sof;
+	int isel_eof;
+	int isel_sol;
+	int isel_eol;
+	int isel_lfsr_enable;
+	int isel_lfsr_enable_b;
+	int isel_lfsr_reset_value;
+	int isel_tpg_enable;
+	int isel_tpg_enable_b;
+	int isel_hor_cnt_mask;
+	int isel_ver_cnt_mask;
+	int isel_xy_cnt_mask;
+	int isel_hor_cnt_delta;
+	int isel_ver_cnt_delta;
+	int isel_tpg_mode;
+	int isel_tpg_red1;
+	int isel_tpg_green1;
+	int isel_tpg_blue1;
+	int isel_tpg_red2;
+	int isel_tpg_green2;
+	int isel_tpg_blue2;
+	int isel_ch_id;
+	int isel_fmt_type;
+	int isel_data_sel;
+	int isel_sband_sel;
+	int isel_sync_sel;
+	int syncgen_hor_cnt;
+	int syncgen_ver_cnt;
+	int syncgen_frame_cnt;
+	int soft_reset;
+};
+
+#endif /* __GP_DEVICE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h
new file mode 100644
index 0000000..56bccbb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h
@@ -0,0 +1,32 @@
+#ifndef __GP_DEVICE_PRIVATE_H_INCLUDED__
+#define __GP_DEVICE_PRIVATE_H_INCLUDED__
+
+#include "gp_device_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_GP_DEVICE_C void gp_device_reg_store(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value)
+{
+assert(ID < N_GP_DEVICE_ID);
+assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+	device_store_uint32(GP_DEVICE_BASE[ID] + reg_addr, value);
+return;
+}
+
+STORAGE_CLASS_GP_DEVICE_C hrt_data gp_device_reg_load(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr)
+{
+assert(ID < N_GP_DEVICE_ID);
+assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+return device_load_uint32(GP_DEVICE_BASE[ID] + reg_addr);
+}
+
+#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h
new file mode 100644
index 0000000..093e7c7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h
@@ -0,0 +1,6 @@
+#ifndef __GPIO_LOCAL_H_INCLUDED__
+#define __GPIO_LOCAL_H_INCLUDED__
+
+#include "gpio_global.h"
+
+#endif /* __GPIO_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h
new file mode 100644
index 0000000..61fe4c3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h
@@ -0,0 +1,30 @@
+#ifndef __GPIO_PRIVATE_H_INCLUDED__
+#define __GPIO_PRIVATE_H_INCLUDED__
+
+#include "gpio_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_GPIO_C void gpio_reg_store(
+	const gpio_ID_t	ID,
+	const unsigned int		reg,
+	const hrt_data			value)
+{
+OP___assert(ID < N_GPIO_ID);
+OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_GPIO_C hrt_data gpio_reg_load(
+	const gpio_ID_t	ID,
+	const unsigned int		reg)
+{
+OP___assert(ID < N_GPIO_ID);
+OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __GPIO_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h
new file mode 100644
index 0000000..fea4cff
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h
@@ -0,0 +1,134 @@
+#ifndef _hive_isp_css_dma_hrt_h_
+#define _hive_isp_css_dma_hrt_h_
+
+#include <hmm_64/hmm.h>
+
+/* This function reads an image from DDR and stores it in the img_buf array
+   that has been allocated by the caller.
+   The specifics of how the pixels are stored into DDR by the DMA are taken
+   into account (bits padded to a width of 256, depending on the number of
+   elements per ddr word).
+   The DMA specific parameters give to this function (elems_per_xword and sign_extend)
+   should correspond to those given to the DMA engine.
+   The address is a virtual address which will be translated to a physical address before
+   data is loaded from or stored to that address.
+
+   The return value is 0 in case of success and 1 in case of failure.
+ */
+unsigned int
+hrt_isp_css_read_image_from_ddr(
+    unsigned short *img_buf,
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword,
+    unsigned int sign_extend,
+    hmm_ptr virt_addr);
+
+/* This function writes an image to DDR, keeping the same aspects into account as the read_image function
+   above. */
+unsigned int
+hrt_isp_css_write_image_to_ddr(
+    const unsigned short *img_buf,
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword,
+    unsigned int sign_extend,
+    hmm_ptr virt_addr);
+
+/* return the size in bytes of an image (frame or plane). */
+unsigned int
+hrt_isp_css_sizeof_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+unsigned int
+hrt_isp_css_stride_of_image_in_ddr(
+    unsigned int width,
+    unsigned int bits_per_element);
+
+hmm_ptr
+hrt_isp_css_alloc_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+hmm_ptr
+hrt_isp_css_calloc_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+#ifndef HIVE_ISP_NO_GDC
+#include "gdc_v2_defs.h"
+
+hmm_ptr
+hrt_isp_css_alloc_gdc_lut_in_ddr(void);
+
+void
+hrt_isp_css_write_gdc_lut_to_ddr(
+    short values[4][HRT_GDC_N],
+    hmm_ptr virt_addr);
+#endif
+
+#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
+hmm_ptr
+hrt_isp_css_alloc_image_for_display(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+hmm_ptr
+hrt_isp_css_calloc_image_for_display(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+#endif
+
+/* New set of functions, these do not require the elems_per_xword, but use bits_per_element instead,
+   this way the user does not need to know about the width of a DDR word. */
+unsigned int
+hrt_isp_css_read_unsigned(
+    unsigned short *target,
+    unsigned int width,
+    unsigned int height,
+    unsigned int source_bits_per_element,
+    hmm_ptr source);
+
+unsigned int
+hrt_isp_css_read_signed(
+    short *target,
+    unsigned int width,
+    unsigned int height,
+    unsigned int source_bits_per_element,
+    hmm_ptr source);
+
+unsigned int 
+hrt_isp_css_write_unsigned(
+    const unsigned short *source,
+    unsigned int width,
+    unsigned int height,
+    unsigned int target_bits_per_element,
+    hmm_ptr target);
+
+unsigned int 
+hrt_isp_css_write_signed(
+    const short *source,
+    unsigned int width,
+    unsigned int height,
+    unsigned int target_bits_per_element,
+    hmm_ptr target);
+
+hmm_ptr
+hrt_isp_css_alloc(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+hmm_ptr
+hrt_isp_css_calloc(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+#endif /* _hive_isp_css_dma_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h
new file mode 100644
index 0000000..53bbe58
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h
@@ -0,0 +1,84 @@
+#ifndef _hive_isp_css_hrt_h
+#define _hive_isp_css_hrt_h
+
+#include "system_types.h"
+
+//#include <hrt/api.h>
+#include "hive_isp_css_host_ids_hrt.h"
+#include "hive_isp_css_defs.h"
+
+#ifdef HRT_ISP_CSS_CUSTOM_HOST
+#ifndef HRT_USE_VIR_ADDRS
+#define HRT_USE_VIR_ADDRS
+#endif
+/*#include "hive_isp_css_custom_host_hrt.h"*/
+#endif
+
+#include <gpio_block.h>
+#include <gp_regs.h>
+#include <gp_timer_hrt.h>
+#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
+  #include <i2c_api.h>
+  #include <dis_sensor.h>
+  #include <display_driver.h>
+  #include <display.h>
+  #include <display_driver.h>
+  #include <shi_sensor_api.h>
+#define hrt_gdc_slave_port(gdc_id)    HRTCAT(gdc_id,_sl_in)
+  #include <isp2400_mamoiada_demo_params.h>
+  #include <isp2400_support.h>
+  #include "isp_css_dev_flash_hrt.h"
+  #include "isp_css_dev_display_hrt.h"
+  #include "isp_css_dev_i2c_hrt.h"
+  #include "isp_css_dev_tb.h"
+#else /* CSS ASIC system */
+  #include <css_receiver_2400_hrt.h>
+//  #include <isp2400_mamoiada_params.h>
+//  #include <isp2400_support.h>
+  /* insert idle signal clearing and setting around hrt_main */
+  #if !defined(HRT_HW) || defined(HRT_ISP_CSS_INSERT_IDLE_SIGNAL)
+    #define hrt_main _hrt_isp_css_main
+  #endif
+  #ifdef _HIVE_ISP_CSS_SPECMAN_SYSTEM
+    #include "hive_isp_css_2400_specman_system.h"
+  #else
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+    #include "hive_isp_css_2400_system.h"
+#elif defined(IS_ISP_2400A0_MAMOIADA_SYSTEM)
+    #include "hive_isp_css_2400A0_system.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+    #include "hive_isp_css_2401_system.h"
+#else
+#error "hive_isp_css_hrt_modified.h: SYSTEM must be one of {2400_MAMOIADA_SYSTEM, 2400A0_MAMOIADA_SYSTEM, 2401_MAMOIADA_SYSTEM}"
+#endif
+  #endif
+#endif /* _HIVE_ISP_CSS_FPGA_SYSTEM */
+#include <sp_hrt.h>
+#include <input_system_hrt.h>
+#include <input_selector_hrt.h>
+#include <sig_monitor_hrt.h>
+
+#include "hive_isp_css_sdram_wakeup_hrt.h"
+#include "hive_isp_css_idle_signal_hrt.h"
+#include "hive_isp_css_sp_hrt.h"
+#include "hive_isp_css_isp_hrt.h"
+#include "hive_isp_css_streaming_to_mipi_hrt.h"
+#include "hive_isp_css_testbench_hrt.h"
+#include "hive_isp_css_streaming_monitors_hrt.h"
+#include "hive_isp_css_gp_regs_hrt.h"
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM) || defined(IS_ISP_2400A0_MAMOIADA_SYSTEM)
+#include "hive_isp_css_irq_hrt.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+#include "hive_isp_css_2401_irq_hrt.h"
+#else
+#error "hive_isp_css_hrt_modified.h: SYSTEM must be one of {2400_MAMOIADA_SYSTEM, 2400A0_MAMOIADA_SYSTEM, 2401_MAMOIADA_SYSTEM}"
+#endif
+
+#include "hive_isp_css_stream_switch_hrt.h"
+
+#include "hive_isp_css_ddr_hrt_modified.h"
+#include "hive_isp_css_dma_set_hrt.h"
+
+#define HIVE_ISP_CSS_NO_STREAM_SWITCH 1
+
+#endif /* _hive_isp_css_hrt_h */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c
new file mode 100644
index 0000000..17f70db
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c
@@ -0,0 +1,6 @@
+
+#include "hmem.h"
+
+#ifndef __INLINE_HMEM__
+#include "hmem_private.h"
+#endif /* __INLINE_HMEM__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h
new file mode 100644
index 0000000..19861cf
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h
@@ -0,0 +1,6 @@
+#ifndef __HMEM_LOCAL_H_INCLUDED__
+#define __HMEM_LOCAL_H_INCLUDED__
+
+#include "hmem_global.h"
+
+#endif /* __HMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h
new file mode 100644
index 0000000..09a59ba
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h
@@ -0,0 +1,16 @@
+#ifndef __HMEM_PRIVATE_H_INCLUDED__
+#define __HMEM_PRIVATE_H_INCLUDED__
+
+#include "hmem_public.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_HMEM_C size_t sizeof_hmem(
+	const hmem_ID_t		ID)
+{
+assert(ID < N_HMEM_ID);
+	(void)ID;
+return HMEM_SIZE*sizeof(hmem_data_t);
+}
+
+#endif /* __HMEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c
new file mode 100644
index 0000000..20db7e1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c
@@ -0,0 +1,204 @@
+
+//#include "stddef.h"		/* NULL */
+//#include <stdbool.h>
+
+#include "input_formatter.h"
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_INPUT_FORMATTER__
+#include "input_formatter_private.h"
+#endif /* __INLINE_INPUT_FORMATTER__ */
+
+const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID] = {
+	INPUT_FORMATTER0_SRST_OFFSET,
+	INPUT_FORMATTER1_SRST_OFFSET,
+	INPUT_FORMATTER2_SRST_OFFSET,
+	INPUT_FORMATTER3_SRST_OFFSET};
+
+const hrt_data HIVE_IF_SRST_MASK[N_INPUT_FORMATTER_ID] = {
+	INPUT_FORMATTER0_SRST_MASK,
+	INPUT_FORMATTER1_SRST_MASK,
+	INPUT_FORMATTER2_SRST_MASK,
+	INPUT_FORMATTER3_SRST_MASK};
+
+const uint8_t HIVE_IF_SWITCH_CODE[N_INPUT_FORMATTER_ID] = {
+	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
+	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
+	HIVE_INPUT_SWITCH_SELECT_IF_SEC,
+	HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM};
+
+/* MW Should be part of system_global.h, where we have the main enumeration */
+const bool HIVE_IF_BIN_COPY[N_INPUT_FORMATTER_ID] = {
+	false, false, false, true};
+
+void input_formatter_rst(
+	const input_formatter_ID_t		ID)
+{
+	hrt_address	addr;
+	hrt_data	rst;
+
+assert(ID < N_INPUT_FORMATTER_ID);
+
+	addr = HIVE_IF_SRST_ADDRESS[ID];
+	rst = HIVE_IF_SRST_MASK[ID];
+
+	input_formatter_reg_store(ID,
+		 addr, rst);
+
+return;
+}
+
+unsigned int input_formatter_get_alignment(
+	const input_formatter_ID_t		ID)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+
+return input_formatter_alignment[ID];
+}
+
+void input_formatter_set_fifo_blocking_mode(
+	const input_formatter_ID_t		ID,
+	const bool						enable)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+/* cnd_input_formatter_reg_store() */
+if (!HIVE_IF_BIN_COPY[ID]) {
+	input_formatter_reg_store(ID,
+		 HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS, enable);
+}
+return;
+}
+
+void input_formatter_get_switch_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_switch_state_t	*state)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(state != NULL);
+/* We'll change this into an intelligent function to get switch info per IF */
+(void)ID;
+
+	state->if_input_switch_lut_reg[0] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg0);
+	state->if_input_switch_lut_reg[1] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg1);
+	state->if_input_switch_lut_reg[2] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg2);
+	state->if_input_switch_lut_reg[3] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg3);
+	state->if_input_switch_lut_reg[4] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg4);
+	state->if_input_switch_lut_reg[5] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg5);
+	state->if_input_switch_lut_reg[6] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg6);
+	state->if_input_switch_lut_reg[7] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg7);
+	state->if_input_switch_fsync_lut = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_fsync_lut);
+	state->if_input_switch_ch_id_fmt_type = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_ch_id_fmt_type);
+
+return;
+}
+
+void input_formatter_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_state_t			*state)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(state != NULL);
+/*
+	state->reset = input_formatter_reg_load(ID,
+		HIVE_IF_RESET_ADDRESS);
+ */
+	state->start_line = input_formatter_reg_load(ID,
+		HIVE_IF_START_LINE_ADDRESS);
+	state->start_column = input_formatter_reg_load(ID,
+		HIVE_IF_START_COLUMN_ADDRESS);
+	state->cropped_height = input_formatter_reg_load(ID,
+		HIVE_IF_CROPPED_HEIGHT_ADDRESS);
+	state->cropped_width = input_formatter_reg_load(ID,
+		HIVE_IF_CROPPED_WIDTH_ADDRESS);
+	state->ver_decimation = input_formatter_reg_load(ID,
+		HIVE_IF_VERTICAL_DECIMATION_ADDRESS);
+	state->hor_decimation = input_formatter_reg_load(ID,
+		HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS);
+	state->hor_deinterleaving = input_formatter_reg_load(ID,
+		HIVE_IF_H_DEINTERLEAVING_ADDRESS);
+	state->left_padding = input_formatter_reg_load(ID,
+		HIVE_IF_LEFTPADDING_WIDTH_ADDRESS);
+	state->eol_offset = input_formatter_reg_load(ID,
+		HIVE_IF_END_OF_LINE_OFFSET_ADDRESS);
+	state->vmem_start_address = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_START_ADDRESS_ADDRESS);
+	state->vmem_end_address = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_END_ADDRESS_ADDRESS);
+	state->vmem_increment = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_INCREMENT_ADDRESS);
+	state->is_yuv420 = input_formatter_reg_load(ID,
+		HIVE_IF_YUV_420_FORMAT_ADDRESS);
+	state->vsync_active_low = input_formatter_reg_load(ID,
+		HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS);
+	state->hsync_active_low = input_formatter_reg_load(ID,
+		HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS);
+	state->allow_fifo_overflow = input_formatter_reg_load(ID,
+		HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS);
+	state->block_fifo_when_no_req = input_formatter_reg_load(ID,
+		HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS);
+	state->ver_deinterleaving = input_formatter_reg_load(ID,
+		HIVE_IF_V_DEINTERLEAVING_ADDRESS);
+/* FSM */
+	state->fsm_sync_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_SYNC_STATUS);
+	state->fsm_sync_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_SYNC_COUNTER);
+	state->fsm_crop_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_STATUS);
+	state->fsm_crop_line_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_LINE_COUNTER);
+	state->fsm_crop_pixel_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_PIXEL_COUNTER);
+	state->fsm_deinterleaving_index = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DEINTERLEAVING_IDX);
+	state->fsm_dec_h_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_H_COUNTER);
+	state->fsm_dec_v_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_V_COUNTER);
+	state->fsm_dec_block_v_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER);
+	state->fsm_padding_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_PADDING_STATUS);
+	state->fsm_padding_elem_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_PADDING_ELEMENT_COUNTER);
+	state->fsm_vector_support_error = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT_ERROR);
+	state->fsm_vector_buffer_full = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL);
+	state->vector_support = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT);
+	state->sensor_data_lost = input_formatter_reg_load(ID,
+		HIVE_IF_FIFO_SENSOR_STATUS);
+
+return;
+}
+
+void input_formatter_bin_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_bin_state_t		*state)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(state != NULL);
+
+	state->reset = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS);
+	state->input_endianness = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS);
+	state->output_endianness = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS);
+	state->bitswap = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS);
+	state->block_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS);
+	state->packet_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS);
+	state->readpostwrite_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS);
+	state->is_2ppc = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS);
+	state->en_status_update = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h
new file mode 100644
index 0000000..09ac624
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h
@@ -0,0 +1,109 @@
+#ifndef __INPUT_FORMATTER_LOCAL_H_INCLUDED__
+#define __INPUT_FORMATTER_LOCAL_H_INCLUDED__
+
+#include "input_formatter_global.h"
+
+#include "isp.h"		/* ISP_VEC_ALIGN */
+
+typedef struct input_formatter_switch_state_s	input_formatter_switch_state_t;
+typedef struct input_formatter_state_s			input_formatter_state_t;
+typedef struct input_formatter_bin_state_s		input_formatter_bin_state_t;
+
+#define HIVE_IF_FSM_SYNC_STATUS                 0x100
+#define HIVE_IF_FSM_SYNC_COUNTER                0x104
+#define HIVE_IF_FSM_CROP_STATUS                 0x108
+#define HIVE_IF_FSM_CROP_LINE_COUNTER           0x10C
+#define HIVE_IF_FSM_CROP_PIXEL_COUNTER          0x110
+#define HIVE_IF_FSM_DEINTERLEAVING_IDX          0x114
+#define HIVE_IF_FSM_DECIMATION_H_COUNTER        0x118
+#define HIVE_IF_FSM_DECIMATION_V_COUNTER        0x11C
+#define HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER  0x120
+#define HIVE_IF_FSM_PADDING_STATUS              0x124
+#define HIVE_IF_FSM_PADDING_ELEMENT_COUNTER     0x128
+#define HIVE_IF_FSM_VECTOR_SUPPORT_ERROR        0x12C
+#define HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL    0x130
+#define HIVE_IF_FSM_VECTOR_SUPPORT              0x134
+#define HIVE_IF_FIFO_SENSOR_STATUS              0x138
+
+/*
+ * The switch LUT's coding defines a sink for each
+ * single channel ID + channel format type. Conversely
+ * the sink (i.e. an input formatter) can be reached
+ * from multiple channel & format type combinations
+ *
+ * LUT[0,1] channel=0, format type {0,1,...31}
+ * LUT[2,3] channel=1, format type {0,1,...31}
+ * LUT[4,5] channel=2, format type {0,1,...31}
+ * LUT[6,7] channel=3, format type {0,1,...31}
+ *
+ * Each register hold 16 2-bit fields encoding the sink
+ * {0,1,2,3}, "0" means unconnected.
+ *
+ * The single FSYNCH register uses four 3-bit fields of 1-hot
+ * encoded sink information, "0" means unconnected.
+ *
+ * The encoding is redundant. The FSYNCH setting will connect
+ * a channel to a sink. At that point the LUT's belonging to
+ * that channel can be directed to another sink. Thus the data
+ * goes to another place than the synch
+ */
+struct input_formatter_switch_state_s {
+	int	if_input_switch_lut_reg[8];
+	int	if_input_switch_fsync_lut;
+	int	if_input_switch_ch_id_fmt_type;
+	bool if_input_switch_map[HIVE_SWITCH_N_CHANNELS][HIVE_SWITCH_N_FORMATTYPES];
+};
+
+struct input_formatter_state_s {
+/*	int	reset; */
+	int	start_line;
+	int	start_column;
+	int	cropped_height;
+	int	cropped_width;
+	int	ver_decimation;
+	int	hor_decimation;
+	int	ver_deinterleaving;
+	int	hor_deinterleaving;
+	int	left_padding;
+	int	eol_offset;
+	int	vmem_start_address;
+	int	vmem_end_address;
+	int	vmem_increment;
+	int	is_yuv420;
+	int	vsync_active_low;
+	int	hsync_active_low;
+	int	allow_fifo_overflow;
+	int block_fifo_when_no_req;
+	int	fsm_sync_status;
+	int	fsm_sync_counter;
+	int	fsm_crop_status;
+	int	fsm_crop_line_counter;
+	int	fsm_crop_pixel_counter;
+	int	fsm_deinterleaving_index;
+	int	fsm_dec_h_counter;
+	int	fsm_dec_v_counter;
+	int	fsm_dec_block_v_counter;
+	int	fsm_padding_status;
+	int	fsm_padding_elem_counter;
+	int	fsm_vector_support_error;
+	int	fsm_vector_buffer_full;
+	int	vector_support;
+	int	sensor_data_lost;
+};
+
+struct input_formatter_bin_state_s {
+	uint32_t	reset;
+	uint32_t	input_endianness;
+	uint32_t	output_endianness;
+	uint32_t	bitswap;
+	uint32_t	block_synch;
+	uint32_t	packet_synch;
+	uint32_t	readpostwrite_synch;
+	uint32_t	is_2ppc;
+	uint32_t	en_status_update;
+};
+
+static const unsigned int input_formatter_alignment[N_INPUT_FORMATTER_ID] = {
+	ISP_VEC_ALIGN, ISP_VEC_ALIGN, HIVE_ISP_CTRL_DATA_BYTES};
+
+#endif /* __INPUT_FORMATTER_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h
new file mode 100644
index 0000000..eb718dd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h
@@ -0,0 +1,32 @@
+#ifndef __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
+#define __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
+
+#include "input_formatter_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_INPUT_FORMATTER_C void input_formatter_reg_store(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+	device_store_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr, value);
+return;
+}
+
+STORAGE_CLASS_INPUT_FORMATTER_C hrt_data input_formatter_reg_load(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+return device_load_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr);
+}
+
+#endif /* __INPUT_FORMATTER_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c
new file mode 100644
index 0000000..dd528560
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c
@@ -0,0 +1,1811 @@
+
+#include "stddef.h"		/* NULL */
+
+#include "input_system.h"
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_INPUT_SYSTEM__
+#include "input_system_private.h"
+#endif /* __INLINE_INPUT_SYSTEM__ */
+
+#define ZERO (0x0)
+#define ONE  (1U)
+
+const ib_buffer_t   IB_BUFFER_NULL = {0 ,0, 0 };
+
+static input_system_error_t input_system_configure_channel(
+	const channel_cfg_t		channel);
+
+static input_system_error_t input_system_configure_channel_sensor(
+	const channel_cfg_t		channel);
+
+static input_system_error_t input_buffer_configuration(void);
+
+static input_system_error_t configuration_to_registers(void);
+
+static void receiver_rst(const rx_ID_t ID);
+static void input_system_network_rst(const input_system_ID_t ID);
+
+static void capture_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg);
+
+static void acquisition_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg);
+
+static void ctrl_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ctrl_unit_cfg_t* const	cfg);
+
+static void input_system_network_configure(
+	const input_system_ID_t			ID,
+	const input_system_network_cfg_t * const	cfg);
+
+// MW: CSI is previously named as "rx" short for "receiver"
+static input_system_error_t set_csi_cfg(
+	csi_cfg_t* const						lhs,
+	const csi_cfg_t* const					rhs,
+	input_system_config_flags_t* const 		flags);
+
+static input_system_error_t set_source_type(
+	input_system_source_t* const 			lhs,
+	const input_system_source_t	 			rhs,
+	input_system_config_flags_t* const		flags);
+
+static input_system_error_t input_system_multiplexer_cfg(
+	input_system_multiplex_t* const			lhs,
+	const input_system_multiplex_t			rhs,
+	input_system_config_flags_t* const		flags);
+
+
+
+STORAGE_CLASS_INLINE void capture_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	capture_unit_state_t			*state);
+
+STORAGE_CLASS_INLINE void acquisition_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	acquisition_unit_state_t		*state);
+
+STORAGE_CLASS_INLINE void ctrl_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	ctrl_unit_state_t				*state);
+
+STORAGE_CLASS_INLINE void mipi_port_get_state(
+	const rx_ID_t					ID,
+	const mipi_port_ID_t			port_ID,
+	mipi_port_state_t				*state);
+
+STORAGE_CLASS_INLINE void rx_channel_get_state(
+	const rx_ID_t					ID,
+	const unsigned int				ch_id,
+	rx_channel_state_t				*state);
+
+static void gp_device_rst(const gp_device_ID_t		ID);
+
+static void input_selector_cfg_for_sensor(const gp_device_ID_t	ID);
+
+static void input_switch_rst(const gp_device_ID_t	ID);
+
+static void input_switch_cfg(
+	const gp_device_ID_t				ID,
+	const input_switch_cfg_t * const	cfg
+);
+
+void input_system_get_state(
+	const input_system_ID_t			ID,
+	input_system_state_t			*state)
+{
+	sub_system_ID_t	sub_id;
+
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(state != NULL);
+
+	state->str_multicastA_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX);
+	state->str_multicastB_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX);
+	state->str_multicastC_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX);
+	state->str_mux_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX);
+	state->str_mon_status = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_STAT_IDX);
+	state->str_mon_irq_cond = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_COND_IDX);
+	state->str_mon_irq_en = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX);
+	state->isys_srst = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_SRST_IDX);
+	state->isys_slv_reg_srst = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_SLV_REG_SRST_IDX);
+	state->str_deint_portA_cnt = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_REG_PORT_A_IDX);
+	state->str_deint_portB_cnt = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_REG_PORT_B_IDX);
+
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		capture_unit_get_state(ID, sub_id,
+			&(state->capture_unit[sub_id - CAPTURE_UNIT0_ID]));
+	}
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		acquisition_unit_get_state(ID, sub_id,
+			&(state->acquisition_unit[sub_id - ACQUISITION_UNIT0_ID]));
+	}
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		ctrl_unit_get_state(ID, sub_id,
+			&(state->ctrl_unit_state[sub_id - CTRL_UNIT0_ID]));
+	}
+
+return;
+}
+
+void receiver_get_state(
+	const rx_ID_t				ID,
+	receiver_state_t			*state)
+{
+	mipi_port_ID_t	port_id;
+	unsigned int	ch_id;
+
+assert(ID < N_RX_ID);
+assert(state != NULL);
+
+	state->fs_to_ls_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX);
+	state->ls_to_data_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX);
+	state->data_to_le_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX);
+	state->le_to_fe_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX);
+	state->fe_to_fs_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX);
+	state->le_to_fs_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX);
+	state->is_two_ppc = (bool)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX);
+	state->backend_rst = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX);
+	state->raw18 = (uint16_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_RAW18_REG_IDX);
+	state->force_raw8 = (bool)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX);
+	state->raw16 = (uint16_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_RAW16_REG_IDX);
+
+	for (port_id = (mipi_port_ID_t)0; port_id < N_MIPI_PORT_ID; port_id++) {
+		mipi_port_get_state(ID, port_id,
+			&(state->mipi_port_state[port_id]));
+	}
+	for (ch_id = (unsigned int)0; ch_id < N_RX_CHANNEL_ID; ch_id++) {
+		rx_channel_get_state(ID, ch_id,
+			&(state->rx_channel_state[ch_id]));
+	}
+
+	state->be_gsp_acc_ovl = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX);
+	state->be_srst = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_SRST_REG_IDX);
+	state->be_is_two_ppc = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX);
+	state->be_comp_format0 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX);
+	state->be_comp_format1 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX);
+	state->be_comp_format2 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX);
+	state->be_comp_format3 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX);
+	state->be_sel = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_SEL_REG_IDX);
+	state->be_raw16_config = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX);
+	state->be_raw18_config = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX);
+	state->be_force_raw8 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX);
+	state->be_irq_status = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX);
+	state->be_irq_clear = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX);
+
+return;
+}
+
+bool is_mipi_format_yuv420(
+	const mipi_format_t			mipi_format)
+{
+	bool	is_yuv420 = (
+		(mipi_format == MIPI_FORMAT_YUV420_8) ||
+		(mipi_format == MIPI_FORMAT_YUV420_10) ||
+		(mipi_format == MIPI_FORMAT_YUV420_8_SHIFT) ||
+		(mipi_format == MIPI_FORMAT_YUV420_10_SHIFT));
+/* MIPI_FORMAT_YUV420_8_LEGACY is not YUV420 */
+
+return is_yuv420;
+}
+
+void receiver_set_compression(
+	const rx_ID_t				ID,
+	const unsigned int			cfg_ID,
+	const mipi_compressor_t		comp,
+	const mipi_predictor_t		pred)
+{
+	const unsigned int	field_id = cfg_ID % N_MIPI_FORMAT_CUSTOM;
+	const unsigned int	ch_id = cfg_ID / N_MIPI_FORMAT_CUSTOM;
+	hrt_data			val;
+	hrt_address			addr;
+	hrt_data			reg;
+
+assert(ID < N_RX_ID);
+assert(cfg_ID < N_MIPI_COMPRESSOR_CONTEXT);
+assert(field_id < N_MIPI_FORMAT_CUSTOM);
+assert(ch_id < N_RX_CHANNEL_ID);
+assert(comp < N_MIPI_COMPRESSOR_METHODS);
+assert(pred < N_MIPI_PREDICTOR_TYPES);
+
+	val = (((uint8_t)pred) << 3) | comp;
+
+	switch (ch_id) {
+	case 0: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
+		break;
+	case 1: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
+		break;
+	case 2: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
+		break;
+	case 3: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
+		break;
+	}
+
+	reg = ((field_id < 6)?(val << (field_id * 5)):(val << ((field_id - 6) * 5)));
+	receiver_reg_store(ID, addr, reg);
+
+return;
+}
+
+void receiver_port_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const bool					cnd)
+{
+	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+
+	if (cnd) {
+		reg |= 0x01;
+	} else {
+		reg &= ~0x01;
+	}
+
+	receiver_port_reg_store(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, reg);
+return;
+}
+
+bool is_receiver_port_enabled(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID)
+{
+	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+return ((reg & 0x01) != 0);
+}
+
+void receiver_irq_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t			irq_info)
+{
+	receiver_port_reg_store(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);
+return;
+}
+
+rx_irq_info_t receiver_get_irq_info(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID)
+{
+return receiver_port_reg_load(ID,
+	port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+}
+
+void receiver_irq_clear(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t			irq_info)
+{
+	receiver_port_reg_store(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);
+return;
+}
+
+STORAGE_CLASS_INLINE void capture_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	capture_unit_state_t			*state)
+{
+assert(state != NULL);
+assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (sub_id <= CAPTURE_UNIT2_ID));
+
+	state->StartMode = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_MODE_REG_ID);
+	state->Start_Addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_ADDR_REG_ID);
+	state->Mem_Region_Size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_MEM_REGION_SIZE_REG_ID);
+	state->Num_Mem_Regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->Init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_INIT_REG_ID);
+	state->Start = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_REG_ID);
+	state->Stop = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_STOP_REG_ID);
+*/	
+	state->Packet_Length = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_PACKET_LENGTH_REG_ID);
+	state->Received_Length = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_LENGTH_REG_ID);
+	state->Received_Short_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_SHORT_PACKETS_REG_ID);
+	state->Received_Long_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_LONG_PACKETS_REG_ID);
+	state->Last_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_LAST_COMMAND_REG_ID);
+	state->Next_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NEXT_COMMAND_REG_ID);
+	state->Last_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_LAST_ACKNOWLEDGE_REG_ID);
+	state->Next_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NEXT_ACKNOWLEDGE_REG_ID);
+	state->FSM_State_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_FSM_STATE_INFO_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void acquisition_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	acquisition_unit_state_t		*state)
+{
+assert(state != NULL);
+assert(sub_id == ACQUISITION_UNIT0_ID);
+
+	state->Start_Addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_START_ADDR_REG_ID);
+	state->Mem_Region_Size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_MEM_REGION_SIZE_REG_ID);
+	state->Num_Mem_Regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->Init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_INIT_REG_ID);
+*/
+	state->Received_Short_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_RECEIVED_SHORT_PACKETS_REG_ID);
+	state->Received_Long_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_RECEIVED_LONG_PACKETS_REG_ID);
+	state->Last_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_LAST_COMMAND_REG_ID);
+	state->Next_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NEXT_COMMAND_REG_ID);
+	state->Last_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_LAST_ACKNOWLEDGE_REG_ID);
+	state->Next_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NEXT_ACKNOWLEDGE_REG_ID);
+	state->FSM_State_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_FSM_STATE_INFO_REG_ID);
+	state->Int_Cntr_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_INT_CNTR_INFO_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void ctrl_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	ctrl_unit_state_t				*state)
+{
+assert(state != NULL);
+assert(sub_id == CTRL_UNIT0_ID);
+
+	state->captA_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_A_REG_ID);
+	state->captB_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_B_REG_ID);
+	state->captC_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_C_REG_ID);
+	state->captA_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID);
+	state->captB_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID);
+	state->captC_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID);
+	state->captA_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID);
+	state->captB_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID);
+	state->captC_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID);
+	state->acq_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_START_ADDR_REG_ID);
+	state->acq_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID);
+	state->acq_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->ctrl_init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_INIT_REG_ID);
+*/
+	state->last_cmd = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_LAST_COMMAND_REG_ID);
+	state->next_cmd = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_NEXT_COMMAND_REG_ID);
+	state->last_ack = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID);
+	state->next_ack = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID);
+	state->top_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_FSM_STATE_INFO_REG_ID);
+	state->captA_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID);
+	state->captB_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID);
+	state->captC_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID);
+	state->acq_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID);
+	state->capt_reserve_one_mem_region = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void mipi_port_get_state(
+	const rx_ID_t					ID,
+	const mipi_port_ID_t			port_ID,
+	mipi_port_state_t				*state)
+{
+	int	i;
+
+assert(ID < N_RX_ID);
+assert(port_ID < N_MIPI_PORT_ID);
+assert(state != NULL);
+
+	state->device_ready = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+	state->irq_status = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+	state->irq_enable = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+	state->timeout_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX);
+	state->init_count = (uint16_t)receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX);
+	state->raw16_18 = (uint16_t)receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX);
+	state->sync_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX);
+	state->rx_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX);
+
+	for (i = 0; i < MIPI_4LANE_CFG ; i++) {
+		state->lane_sync_count[i] = (uint8_t)((state->sync_count)>>(i*8));
+		state->lane_rx_count[i] = (uint8_t)((state->rx_count)>>(i*8));
+	}
+
+return;
+}
+
+STORAGE_CLASS_INLINE void rx_channel_get_state(
+	const rx_ID_t					ID,
+	const unsigned int				ch_id,
+	rx_channel_state_t				*state)
+{
+	int	i;
+
+assert(ID < N_RX_ID);
+assert(ch_id < N_RX_CHANNEL_ID);
+assert(state != NULL);
+
+	switch (ch_id) {
+		case 0:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
+	break;
+		case 1:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
+	break;
+		case 2:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
+	break;
+		case 3:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
+	break;
+	}
+
+/* See Table 7.1.17,..., 7.1.24 */
+	for (i = 0; i < 6; i++) {
+		uint8_t	val = (uint8_t)((state->comp_scheme0)>>(i*5)) & 0x1f;
+		state->comp[i] = (mipi_compressor_t)(val & 0x07);
+		state->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);
+	}
+	for (i = 6; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		uint8_t	val = (uint8_t)((state->comp_scheme0)>>((i-6)*5)) & 0x1f;
+		state->comp[i] = (mipi_compressor_t)(val & 0x07);
+		state->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);
+	}
+
+return;
+}
+
+// MW: "2400" in the name is not good, but this is to avoid a naming conflict
+input_system_cfg2400_t config;
+
+static void receiver_rst(
+	const rx_ID_t				ID)
+{
+	mipi_port_ID_t		port_id;
+
+assert(ID < N_RX_ID);
+	
+// Disable all ports.
+	for (port_id = MIPI_PORT0_ID; port_id < N_MIPI_PORT_ID; port_id++) {
+		receiver_port_enable(ID, port_id, false);
+	}
+
+	// AM: Additional actions for stopping receiver?
+
+	return;
+}
+
+ // AM: Check if input_system_source_t could be used instead.
+typedef enum {
+	SELECT_MIPI_CSI = 0,
+	SELECT_TPG,
+	SELECT_PRBS,
+	SELECT_GPFIFO,
+	N_SELECT
+} input_selector_t;
+
+//Single function to reset all the devices mapped via GP_DEVICE.
+static void gp_device_rst(const gp_device_ID_t		ID)
+{
+assert(ID < N_GP_DEVICE_ID);
+
+	gp_device_reg_store(ID, _REG_GP_SYNCGEN_ENABLE_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNCGEN_FREE_RUNNING_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNCGEN_PAUSE_ADDR, ONE);
+	// gp_device_reg_store(ID, _REG_GP_NR_FRAMES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_LINES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR, ZERO);
+// AM: Following calls cause strange warnings. Probably they should not be initialized.
+//	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_B_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_B_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_XY_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_DELTA_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_DELTA_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_MODE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED2_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN2_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE2_ADDR, ZERO);
+	//gp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);
+	//gp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_HOR_CNT_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_VER_CNT_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_FRAME_CNT_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR, ZERO); // AM: Maybe this soft reset is not safe.
+
+	return;
+}
+
+static void input_selector_cfg_for_sensor(const gp_device_ID_t ID)
+{
+assert(ID < N_GP_DEVICE_ID);
+
+	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR, ZERO);
+
+	return;
+}
+
+static void input_switch_rst(const gp_device_ID_t ID)
+{
+	int addr;
+	
+assert(ID < N_GP_DEVICE_ID);
+	
+	// Initialize the data&hsync LUT.
+	for (addr = _REG_GP_IFMT_input_switch_lut_reg0;
+			 addr <= _REG_GP_IFMT_input_switch_lut_reg7; addr += SIZEOF_HRT_REG) {
+
+		gp_device_reg_store(ID, addr, ZERO);
+	}
+
+	// Initialize the vsync LUT.
+	gp_device_reg_store(ID,
+		_REG_GP_IFMT_input_switch_fsync_lut,
+		ZERO);
+
+	return;
+}
+
+static void input_switch_cfg(
+	const gp_device_ID_t				ID,
+	const input_switch_cfg_t * const	cfg)
+{
+	int addr_offset;
+	
+assert(ID < N_GP_DEVICE_ID);
+assert(cfg != NULL);
+	
+	// Initialize the data&hsync LUT.
+	for (addr_offset = 0; addr_offset < N_RX_CHANNEL_ID * 2; addr_offset++) {
+assert(addr_offset * SIZEOF_HRT_REG + _REG_GP_IFMT_input_switch_lut_reg0 <= _REG_GP_IFMT_input_switch_lut_reg7);
+		gp_device_reg_store(ID,
+			_REG_GP_IFMT_input_switch_lut_reg0 + addr_offset * SIZEOF_HRT_REG,
+			cfg->hsync_data_reg[addr_offset]);
+	}
+
+	// Initialize the vsync LUT.
+	gp_device_reg_store(ID,
+		_REG_GP_IFMT_input_switch_fsync_lut,
+		cfg->vsync_data_reg);
+
+	return;
+}
+
+
+static void input_system_network_rst(const input_system_ID_t ID)
+{
+	unsigned int sub_id;
+	
+	// Reset all 3 multicasts.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+
+	// Reset stream mux.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX,
+		N_INPUT_SYSTEM_MULTIPLEX);
+
+	// Reset 3 capture units.
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			CAPT_INIT_REG_ID,
+			1U << CAPT_INIT_RST_REG_BIT);
+	}
+	
+	// Reset acquisition unit.
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			ACQ_INIT_REG_ID,
+			1U << ACQ_INIT_RST_REG_BIT);
+	}
+
+	// DMA unit reset is not needed.
+	
+	// Reset controller units.
+	// NB: In future we need to keep part of ctrl_state for split capture and
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			ISYS_CTRL_INIT_REG_ID,
+			1U); //AM: Is there any named constant?
+	}
+	
+	return;
+}
+
+// Function that resets current configuration.
+input_system_error_t input_system_configuration_reset(void)
+{
+	unsigned int i;
+
+	receiver_rst(RX0_ID);
+	
+	input_system_network_rst(INPUT_SYSTEM0_ID);
+
+	gp_device_rst(INPUT_SYSTEM0_ID);
+	
+	input_switch_rst(INPUT_SYSTEM0_ID);
+
+	//target_rst();
+	
+	// Reset IRQ_CTRLs.
+
+	// Reset configuration data structures.
+	for (i = 0; i < N_CHANNELS; i++ ) {
+		config.ch_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_isp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_sp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_strm2mem_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+	}
+
+	for (i = 0; i < N_CSI_PORTS; i++ ) { 
+		config.csi_buffer_flags[i]	 = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.multicast[i]		 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	}
+
+	config.source_type_flags				 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.acquisition_buffer_unique_flags	 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.unallocated_ib_mem_words			 = IB_CAPACITY_IN_WORDS; 
+	//config.acq_allocated_ib_mem_words		 = 0; 
+
+	// Set the start of the session cofiguration.
+	config.session_flags = INPUT_SYSTEM_CFG_FLAG_REQUIRED;
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// MW: Comments are good, but doxygen is required, place it at the declaration
+// Function that appends the channel to current configuration.
+static input_system_error_t input_system_configure_channel(
+	const channel_cfg_t		channel)
+{
+	input_system_error_t error = INPUT_SYSTEM_ERR_NO_ERROR;
+	// Check if channel is not already configured.
+	if (config.ch_flags[channel.ch_id] & INPUT_SYSTEM_CFG_FLAG_SET){
+		return INPUT_SYSTEM_ERR_CHANNEL_ALREADY_SET;
+	} else {
+		switch (channel.source_type){
+			case INPUT_SYSTEM_SOURCE_SENSOR :
+				error = input_system_configure_channel_sensor(channel);
+				break;	
+			case INPUT_SYSTEM_SOURCE_TPG :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;	
+			case INPUT_SYSTEM_SOURCE_PRBS :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;	
+			case INPUT_SYSTEM_SOURCE_FIFO :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;	
+			default :	
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;	
+		}
+
+		if (error != INPUT_SYSTEM_ERR_NO_ERROR) return error;
+		// Input switch channel configurations must be combined in united config.
+		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2] = 
+				channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[0];
+		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2 + 1] =
+				channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[1];
+		config.input_switch_cfg.vsync_data_reg |=
+				 (channel.target_cfg.input_switch_channel_cfg.vsync_data_reg & 0x7) << (channel.source_cfg.csi_cfg.csi_port * 3);
+
+		// Other targets are just copied and marked as set.
+		config.target_isp[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_isp_cfg;
+		config.target_sp[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_sp_cfg;
+		config.target_strm2mem[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_strm2mem_cfg;
+		config.target_isp_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+		config.target_sp_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+		config.target_strm2mem_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+
+		config.ch_flags[channel.ch_id] = INPUT_SYSTEM_CFG_FLAG_SET;
+	}
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// Function that partitions input buffer space with determining addresses. 
+static input_system_error_t input_buffer_configuration(void)
+{
+	uint32_t current_address    = 0;
+	uint32_t unallocated_memory = IB_CAPACITY_IN_WORDS;
+
+	ib_buffer_t 	candidate_buffer_acq  = IB_BUFFER_NULL;
+	uint32_t size_requested;
+	input_system_config_flags_t 	acq_already_specified = INPUT_SYSTEM_CFG_FLAG_RESET;  
+	input_system_csi_port_t port;
+	for (port = INPUT_SYSTEM_PORT_A; port < N_INPUT_SYSTEM_PORTS; port++) {
+
+		csi_cfg_t source = config.csi_value[port];//.csi_cfg;
+	
+		if ( config.csi_flags[port] & INPUT_SYSTEM_CFG_FLAG_SET) {
+	
+			uint32_t size_requested;
+			// Check and set csi buffer in input buffer.
+			switch (source.buffering_mode) {
+				case INPUT_SYSTEM_FIFO_CAPTURE :
+				case INPUT_SYSTEM_XMEM_ACQUIRE :
+					config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED; // Well, not used.
+					break;
+				
+				case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+				case INPUT_SYSTEM_SRAM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_CAPTURE :
+					size_requested = source.csi_buffer.mem_reg_size * source.csi_buffer.nof_mem_regs;
+					if (source.csi_buffer.mem_reg_size > 0
+						&& source.csi_buffer.nof_mem_regs >0
+						&& size_requested <= unallocated_memory
+						) {
+							config.csi_buffer[port].mem_reg_addr = current_address;
+							config.csi_buffer[port].mem_reg_size = source.csi_buffer.mem_reg_size;
+							config.csi_buffer[port].nof_mem_regs = source.csi_buffer.nof_mem_regs;
+							current_address		+= size_requested;
+							unallocated_memory 	-= size_requested;
+							config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_SET;
+					} else {
+							config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+							return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+					}
+					break;
+				
+				default :
+					config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+					return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+					break;
+			}
+
+			// Check acquisition buffer specified but set it later since it has to be unique.
+			switch (source.buffering_mode) {
+				case INPUT_SYSTEM_FIFO_CAPTURE :
+				case INPUT_SYSTEM_SRAM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_CAPTURE :
+					// Nothing to do.
+					break;
+				
+				case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+				case INPUT_SYSTEM_XMEM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_ACQUIRE :
+					if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_RESET) {
+						uint32_t size_requested = source.acquisition_buffer.mem_reg_size 
+													* source.acquisition_buffer.nof_mem_regs;
+						if (source.acquisition_buffer.mem_reg_size > 0
+							&& source.acquisition_buffer.nof_mem_regs >0
+							&& size_requested <= unallocated_memory
+							) {
+								candidate_buffer_acq = source.acquisition_buffer;
+								acq_already_specified = INPUT_SYSTEM_CFG_FLAG_SET;
+						}
+					} else {
+						// Check if specified acquisition buffer is the same as specified before.
+						if (source.acquisition_buffer.mem_reg_size != candidate_buffer_acq.mem_reg_size
+							|| source.acquisition_buffer.nof_mem_regs !=  candidate_buffer_acq.nof_mem_regs
+						   ) {
+							config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+							return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+						}
+					}
+					break;
+				
+				default :
+					return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+					break;
+			}
+		} else {
+			config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED;	
+		}
+	} // end of for ( port )
+
+	// Set the acquisition buffer at the end.
+	size_requested = candidate_buffer_acq.mem_reg_size * candidate_buffer_acq.nof_mem_regs;
+	if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_SET
+		&& size_requested <= unallocated_memory) {
+		config.acquisition_buffer_unique.mem_reg_addr = current_address;
+		config.acquisition_buffer_unique.mem_reg_size = candidate_buffer_acq.mem_reg_size;
+		config.acquisition_buffer_unique.nof_mem_regs = candidate_buffer_acq.nof_mem_regs;
+		current_address		+= size_requested;
+		unallocated_memory 	-= size_requested;
+		config.acquisition_buffer_unique_flags = INPUT_SYSTEM_CFG_FLAG_SET;
+
+assert(current_address <= IB_CAPACITY_IN_WORDS);
+	}
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+static void capture_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (sub_id <= CAPTURE_UNIT2_ID)); // Commented part is always true.
+assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_START_ADDR_REG_ID,
+		cfg->mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_MEM_REGION_SIZE_REG_ID,
+		cfg->mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_NUM_MEM_REGIONS_REG_ID,
+		cfg->nof_mem_regs);
+
+	return;
+}
+
+
+static void acquisition_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_id == ACQUISITION_UNIT0_ID);
+assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_START_ADDR_REG_ID,
+		cfg->mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_NUM_MEM_REGIONS_REG_ID,
+		cfg->nof_mem_regs);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_MEM_REGION_SIZE_REG_ID,
+		cfg->mem_reg_size);
+
+	return;
+}
+
+
+static void ctrl_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ctrl_unit_cfg_t* const	cfg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_id == CTRL_UNIT0_ID);
+assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_START_ADDR_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].nof_mem_regs);
+	input_system_sub_system_reg_store(ID,
+                sub_id,
+                ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID,
+		0);
+	return;
+}
+
+static void input_system_network_configure(
+	const input_system_ID_t			ID,
+	const input_system_network_cfg_t * const 	cfg)
+{
+	uint32_t sub_id;
+
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(cfg != NULL);
+
+	// Set all 3 multicasts.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT0_ID]);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT1_ID]);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT2_ID]);
+
+	// Set stream mux.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX,
+		cfg->mux_cfg);
+
+	// Set capture units.
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		capture_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[ID].buffer_mipi[sub_id - CAPTURE_UNIT0_ID])); 
+	}
+	
+	// Set acquisition units. 
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		acquisition_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[sub_id - ACQUISITION_UNIT0_ID].buffer_acquire[sub_id - ACQUISITION_UNIT0_ID]));
+	}
+	
+	// No DMA configuration needed. Ctrl_unit will fully control it.
+	
+	// Set controller units.
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		ctrl_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[sub_id - CTRL_UNIT0_ID]));	
+	}
+	
+	return; 
+}
+
+static input_system_error_t configuration_to_registers(void)
+{
+	input_system_network_cfg_t input_system_network_cfg;
+	int i; 
+
+assert (config.source_type_flags & INPUT_SYSTEM_CFG_FLAG_SET);  
+
+	switch (config.source_type) {
+		case INPUT_SYSTEM_SOURCE_SENSOR :
+
+			// Determine stream multicasts setting based on the mode of csi_cfg_t.
+			// AM: This should be moved towards earlier function call, e.g. in
+			// the commit function.
+			for (i = MIPI_PORT0_ID; i < N_MIPI_PORT_ID; i++) {
+				if (config.csi_flags[i] & INPUT_SYSTEM_CFG_FLAG_SET) {
+				
+					switch (config.csi_value[i].buffering_mode) {
+		
+						case INPUT_SYSTEM_FIFO_CAPTURE:
+							config.multicast[i] = INPUT_SYSTEM_CSI_BACKEND;
+							break;
+					
+						case INPUT_SYSTEM_XMEM_CAPTURE:
+						case INPUT_SYSTEM_SRAM_BUFFERING:
+						case INPUT_SYSTEM_XMEM_BUFFERING:
+							config.multicast[i] = INPUT_SYSTEM_INPUT_BUFFER;
+							break;
+					
+						case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:
+							config.multicast[i] = INPUT_SYSTEM_MULTICAST;
+							break;
+					
+						case INPUT_SYSTEM_XMEM_ACQUIRE:
+							config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+							break;
+		
+						default:
+							config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+							return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+							//break;
+					}
+				} else {
+					config.multicast[i]= INPUT_SYSTEM_DISCARD_ALL;
+				}
+
+				input_system_network_cfg.multicast_cfg[i] = config.multicast[i];
+
+			} // for 
+
+			input_system_network_cfg.mux_cfg = config.multiplexer;
+			
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT0_ID] = config.csi_buffer[MIPI_PORT0_ID];	
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT1_ID] = config.csi_buffer[MIPI_PORT1_ID];	
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT2_ID] = config.csi_buffer[MIPI_PORT2_ID];	
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID] =
+					config.acquisition_buffer_unique;	
+			
+			// First set input network around CSI receiver.
+			input_system_network_configure(INPUT_SYSTEM0_ID, &input_system_network_cfg);
+
+			// Set the CSI receiver.
+			//...
+			break;
+
+		case INPUT_SYSTEM_SOURCE_TPG :
+
+			break;
+
+		case INPUT_SYSTEM_SOURCE_PRBS :
+			
+			break;
+
+		case INPUT_SYSTEM_SOURCE_FIFO :
+			break;
+
+		default :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+
+	} // end of switch (source_type)
+
+	// Set input selector. 
+	input_selector_cfg_for_sensor(INPUT_SYSTEM0_ID);
+	
+	// Set input switch. 
+	input_switch_cfg(INPUT_SYSTEM0_ID, &config.input_switch_cfg);
+
+	// Set input formatters.
+	// AM: IF are set dynamically. 
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Function that applies the whole configuration.
+input_system_error_t input_system_configuration_commit()
+{
+	// The last configuration step is to configure the input buffer.
+	input_system_error_t error = input_buffer_configuration();
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR) {
+		return error;
+	}
+
+	// Translate the whole configuration into registers.
+	error = configuration_to_registers();
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR) {
+		return error;
+	}
+
+	// Translate the whole configuration into ctrl commands etc.
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+
+// FIFO
+
+input_system_error_t	input_system_csi_fifo_channel_cfg(
+		uint32_t				ch_id,
+		input_system_csi_port_t	port,
+		backend_channel_cfg_t	backend_ch,
+		target_cfg2400_t		target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_FIFO_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer 			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer	= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+input_system_error_t	input_system_csi_fifo_channel_with_counting_cfg(
+		uint32_t				ch_id,
+		uint32_t				nof_frames,
+		input_system_csi_port_t	port,
+		backend_channel_cfg_t	backend_ch,
+		uint32_t				csi_mem_reg_size,
+		uint32_t				csi_nof_mem_regs,
+		target_cfg2400_t			target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+// SRAM
+
+input_system_error_t	input_system_csi_sram_channel_cfg(
+		uint32_t				ch_id,
+		input_system_csi_port_t	port,
+		backend_channel_cfg_t	backend_ch,
+		uint32_t				csi_mem_reg_size,
+		uint32_t				csi_nof_mem_regs,
+	//	uint32_t				acq_mem_reg_size,
+	//	uint32_t				acq_nof_mem_regs,
+		target_cfg2400_t 			target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_SRAM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+//XMEM
+
+// Collects all parameters and puts them in channel_cfg_t.
+input_system_error_t	input_system_csi_xmem_channel_cfg(
+		uint32_t 				ch_id,
+		input_system_csi_port_t port,
+		backend_channel_cfg_t	backend_ch,
+		uint32_t 				csi_mem_reg_size,
+		uint32_t 				csi_nof_mem_regs,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 			target,
+		uint32_t 				nof_xmem_buffers
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_xmem_buffers;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+
+
+input_system_error_t	input_system_csi_xmem_acquire_only_channel_cfg(
+		uint32_t 				ch_id,
+		uint32_t 				nof_frames,
+		input_system_csi_port_t port,
+		backend_channel_cfg_t	backend_ch,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 		target)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_ACQUIRE;
+	channel.source_cfg.csi_cfg.csi_buffer		= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+input_system_error_t	input_system_csi_xmem_capture_only_channel_cfg(
+		uint32_t 				ch_id,
+		uint32_t 				nof_frames,
+		input_system_csi_port_t port,
+		uint32_t 				csi_mem_reg_size,
+		uint32_t 				csi_nof_mem_regs,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 		target)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	//channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	//channel.source_cfg.csi_cfg.backend_ch 		= backend_ch;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+	
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+
+// Non - CSI
+
+input_system_error_t	input_system_prbs_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t		nof_frames,//not used yet
+		uint32_t		seed,
+		uint32_t		sync_gen_width,
+		uint32_t		sync_gen_height,
+		uint32_t		sync_gen_hblank_cycles,
+		uint32_t		sync_gen_vblank_cycles,
+		target_cfg2400_t	target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	//channel.backend_ch 	= backend_ch;
+	channel.source_type= INPUT_SYSTEM_SOURCE_PRBS;
+
+	channel.source_cfg.prbs_cfg.seed = seed;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.width         	= sync_gen_width;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.height        	= sync_gen_height;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.hblank_cycles	= sync_gen_hblank_cycles;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.vblank_cycles 	= sync_gen_vblank_cycles;
+	
+	channel.target_cfg	= target;
+
+	assert(nof_frames);
+	
+	return input_system_configure_channel(channel);
+}
+
+
+
+input_system_error_t	input_system_tpg_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t 		nof_frames,//not used yet
+		uint32_t		x_mask,
+		uint32_t		y_mask,
+		uint32_t		x_delta,
+		uint32_t		y_delta,
+		uint32_t		xy_mask,
+		uint32_t		sync_gen_width,
+		uint32_t		sync_gen_height,
+		uint32_t		sync_gen_hblank_cycles,
+		uint32_t		sync_gen_vblank_cycles,
+		target_cfg2400_t	target
+)
+{
+	channel_cfg_t channel;
+	//channel.backend_ch 	= backend_ch;
+
+	channel.ch_id 	= ch_id;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_TPG;
+
+	channel.source_cfg.tpg_cfg.x_mask	= x_mask;
+	channel.source_cfg.tpg_cfg.y_mask	= y_mask; 	
+	channel.source_cfg.tpg_cfg.x_delta	= x_delta;
+	channel.source_cfg.tpg_cfg.y_delta	= y_delta;
+	channel.source_cfg.tpg_cfg.xy_mask	= xy_mask;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.width         	= sync_gen_width;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.height        	= sync_gen_height;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.hblank_cycles	= sync_gen_hblank_cycles;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.vblank_cycles 	= sync_gen_vblank_cycles;
+	
+	channel.target_cfg	= target;
+	assert(nof_frames);
+	return input_system_configure_channel(channel);
+}
+
+// MW: Don't use system specific names, (even in system specific files) "cfg2400" -> cfg
+input_system_error_t	input_system_gpfifo_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t 		nof_frames, //not used yet
+		target_cfg2400_t	target)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	//channel.backend_ch 	= 0;
+	channel.source_type	= INPUT_SYSTEM_SOURCE_FIFO;
+	// channel.source_cfg.gpfifo	= ?;
+	
+	channel.target_cfg	= target;
+	assert(nof_frames);
+	return input_system_configure_channel(channel);
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+// Private specialized functions for channel setting.
+//    
+///////////////////////////////////////////////////////////////////////////
+
+// Fills the parameters to config.csi_value[port]
+static input_system_error_t input_system_configure_channel_sensor(
+	const channel_cfg_t channel)
+{
+	uint32_t port = channel.source_cfg.csi_cfg.csi_port;
+	input_system_error_t status = INPUT_SYSTEM_ERR_NO_ERROR;
+
+	input_system_multiplex_t mux;
+
+	//check if port > N_INPUT_SYSTEM_MULTIPLEX
+
+	status = set_source_type(&(config.source_type), channel.source_type, &config.source_type_flags);
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+
+	// Check for conflicts on source (implicitly on multicast, capture unit and input buffer).
+
+	status = set_csi_cfg(&(config.csi_value[port]), &channel.source_cfg.csi_cfg, &(config.csi_flags[port]));
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+		
+
+	switch (channel.source_cfg.csi_cfg.buffering_mode){
+		case INPUT_SYSTEM_FIFO_CAPTURE:
+			
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_MIPI_PORT0 + channel.source_cfg.csi_cfg.csi_port;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[channel.source_cfg.csi_cfg.csi_port] = INPUT_SYSTEM_CSI_BACKEND;
+			
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			
+			break;	
+		case INPUT_SYSTEM_SRAM_BUFFERING :
+			
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_ACQUISITION_UNIT;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[channel.source_cfg.csi_cfg.csi_port] = INPUT_SYSTEM_INPUT_BUFFER;
+			
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			
+			break;	
+		case INPUT_SYSTEM_XMEM_BUFFERING :
+		
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_ACQUISITION_UNIT;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[channel.source_cfg.csi_cfg.csi_port] = INPUT_SYSTEM_INPUT_BUFFER;
+			
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+		
+			break;	
+		case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;	
+		case INPUT_SYSTEM_XMEM_CAPTURE :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;	
+		case INPUT_SYSTEM_XMEM_ACQUIRE :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;	
+		default :	
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;	
+	}
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// Test flags and set structure.
+static input_system_error_t set_source_type(
+		input_system_source_t * const 			lhs,
+		const input_system_source_t 			rhs,
+		input_system_config_flags_t * const 	flags)
+{
+// MW: Not enough asserts
+assert(lhs != NULL);
+assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;		
+	}
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// Check for consistency with already set value.
+		if ((*lhs) == (rhs)) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually). 
+	if (rhs >= N_INPUT_SYSTEM_SOURCE) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+	// Set the value. 
+	*lhs = rhs;
+	
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Test flags and set structure.
+static input_system_error_t set_csi_cfg(
+		csi_cfg_t* const 						lhs,
+		const csi_cfg_t* const 					rhs,
+		input_system_config_flags_t * const 	flags)
+{
+	uint32_t memory_required;
+	uint32_t acq_memory_required;
+
+assert(lhs != NULL);
+assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;		
+	}
+
+	if (*flags & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// check for consistency with already set value.
+		if (/*lhs->backend_ch == rhs.backend_ch
+			&&*/ lhs->buffering_mode == rhs->buffering_mode
+			&& lhs->csi_buffer.mem_reg_size == rhs->csi_buffer.mem_reg_size
+			&& lhs->csi_buffer.nof_mem_regs  == rhs->csi_buffer.nof_mem_regs
+			&& lhs->acquisition_buffer.mem_reg_size == rhs->acquisition_buffer.mem_reg_size
+			&& lhs->acquisition_buffer.nof_mem_regs  == rhs->acquisition_buffer.nof_mem_regs
+			&& lhs->nof_xmem_buffers  == rhs->nof_xmem_buffers  
+			) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually). 
+	// no check for backend_ch
+	// no check for nof_xmem_buffers
+	memory_required = rhs->csi_buffer.mem_reg_size * rhs->csi_buffer.nof_mem_regs;
+	acq_memory_required = rhs->acquisition_buffer.mem_reg_size * rhs->acquisition_buffer.nof_mem_regs;
+	if (rhs->buffering_mode >= N_INPUT_SYSTEM_BUFFERING_MODE
+		|| 
+	// Check if required memory is available in input buffer (SRAM).
+		(memory_required + acq_memory_required )> config.unallocated_ib_mem_words
+		
+		) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+	// Set the value. 
+	//lhs[port]->backend_ch 		= rhs.backend_ch;
+	lhs->buffering_mode 	= rhs->buffering_mode;
+	lhs->nof_xmem_buffers = rhs->nof_xmem_buffers;
+
+	lhs->csi_buffer.mem_reg_size = rhs->csi_buffer.mem_reg_size;
+	lhs->csi_buffer.nof_mem_regs  = rhs->csi_buffer.nof_mem_regs;
+	lhs->acquisition_buffer.mem_reg_size = rhs->acquisition_buffer.mem_reg_size;
+	lhs->acquisition_buffer.nof_mem_regs  = rhs->acquisition_buffer.nof_mem_regs;
+    // ALX: NB: Here we just set buffer parameters, but still not allocate it 
+	// (no addresses determined). That will be done during commit.
+
+	//  FIXIT:	acq_memory_required is not deducted, since it can be allocated multiple times.
+	config.unallocated_ib_mem_words -= memory_required; 
+//assert(config.unallocated_ib_mem_words >=0);
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Test flags and set structure.
+static input_system_error_t input_system_multiplexer_cfg(
+	input_system_multiplex_t* const		lhs,
+	const input_system_multiplex_t		rhs,
+	input_system_config_flags_t* const	flags)
+{
+assert(lhs != NULL);
+assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;		
+	}
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// Check for consistency with already set value.
+		if ((*lhs) == (rhs)) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually). 
+	if (rhs >= N_INPUT_SYSTEM_MULTIPLEX) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+	}
+	// Set the value. 
+	*lhs = rhs;
+	
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h
new file mode 100644
index 0000000..d54a770
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h
@@ -0,0 +1,537 @@
+#ifndef __INPUT_SYSTEM_LOCAL_H_INCLUDED__
+#define __INPUT_SYSTEM_LOCAL_H_INCLUDED__
+
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#include <stdbool.h>
+#endif
+
+#include "input_system_global.h"
+//#include "gp_device_local.h"
+
+#include "input_system_defs.h"		/* HIVE_ISYS_GPREG_MULTICAST_A_IDX,... */
+#include "css_receiver_2400_defs.h"	/* _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX, _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX,... */
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM) || defined(IS_ISP_2400A0_MAMOIADA_SYSTEM)
+#include "isp_capture_defs.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+/* Same name, but keep the distinction,it is a different device */
+#include "isp_capture_defs.h"
+#else
+#error "input_system_local.h: 2400_SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+#include "isp_acquisition_defs.h"
+#include "input_system_ctrl_defs.h"
+
+
+typedef enum {
+	INPUT_SYSTEM_ERR_NO_ERROR = 0,
+	INPUT_SYSTEM_ERR_GENERIC,
+	INPUT_SYSTEM_ERR_CHANNEL_ALREADY_SET,
+	INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE,
+	INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED,
+	N_INPUT_SYSTEM_ERR
+} input_system_error_t; 
+
+typedef enum {
+    INPUT_SYSTEM_PORT_A = 0,
+    INPUT_SYSTEM_PORT_B,
+    INPUT_SYSTEM_PORT_C,
+    N_INPUT_SYSTEM_PORTS
+} input_system_csi_port_t;
+
+typedef struct ctrl_unit_cfg_s					ctrl_unit_cfg_t; 
+
+typedef struct input_system_network_cfg_s 		input_system_network_cfg_t;
+
+typedef struct target_cfg2400_s 				target_cfg2400_t;
+
+typedef struct channel_cfg_s 							channel_cfg_t;
+
+typedef struct backend_channel_cfg_s 					backend_channel_cfg_t;
+
+typedef struct input_system_cfg2400_s 					input_system_cfg2400_t;
+
+typedef struct mipi_port_state_s				mipi_port_state_t;
+
+typedef struct rx_channel_state_s				rx_channel_state_t;
+
+typedef struct input_switch_cfg_channel_s 		input_switch_cfg_channel_t;
+
+typedef struct input_switch_cfg_s 				input_switch_cfg_t;
+
+struct ctrl_unit_cfg_s {
+	ib_buffer_t		buffer_mipi[N_CAPTURE_UNIT_ID];
+	ib_buffer_t		buffer_acquire[N_ACQUISITION_UNIT_ID];
+};
+
+struct input_system_network_cfg_s {
+	input_system_connection_t	multicast_cfg[N_CAPTURE_UNIT_ID];
+	input_system_multiplex_t	mux_cfg;
+	ctrl_unit_cfg_t				ctrl_unit_cfg[N_CTRL_UNIT_ID];
+};
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_isp_cfg_t;
+
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_sp_cfg_t;
+
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_strm2mem_cfg_t;
+
+struct input_switch_cfg_channel_s {
+	uint32_t hsync_data_reg[2];
+	uint32_t vsync_data_reg;
+};
+
+struct target_cfg2400_s {
+	input_switch_cfg_channel_t 		input_switch_channel_cfg;
+	target_isp_cfg_t	target_isp_cfg;
+	target_sp_cfg_t		target_sp_cfg;
+	target_strm2mem_cfg_t	target_strm2mem_cfg;
+};
+
+struct backend_channel_cfg_s {
+	uint32_t	fmt_control_word_1; // Format config.
+	uint32_t	fmt_control_word_2;
+	uint32_t	no_side_band;
+};
+
+typedef union  {
+	csi_cfg_t				csi_cfg;
+	tpg_cfg_t				tpg_cfg;	 
+    prbs_cfg_t				prbs_cfg;	 
+    gpfifo_cfg_t			gpfifo_cfg;
+} source_cfg_t;
+
+
+struct input_switch_cfg_s {
+	uint32_t hsync_data_reg[N_RX_CHANNEL_ID * 2];
+	uint32_t vsync_data_reg;
+};
+
+// Configuration of a channel.
+struct channel_cfg_s{   
+	uint32_t				ch_id;
+	backend_channel_cfg_t	backend_ch;
+
+	input_system_source_t	source_type;
+    source_cfg_t			source_cfg;
+
+	target_cfg2400_t		target_cfg;
+};
+
+
+// Complete configuration for input system.
+struct input_system_cfg2400_s {
+
+	input_system_source_t source_type;				input_system_config_flags_t	source_type_flags;
+	//channel_cfg_t		channel[N_CHANNELS];
+	input_system_config_flags_t	ch_flags[N_CHANNELS];
+	//  This is the place where the buffers' settings are collected, as given.
+	csi_cfg_t			csi_value[N_CSI_PORTS];		input_system_config_flags_t	csi_flags[N_CSI_PORTS];
+
+	// Possible another struct for ib.
+	// This buffers set at the end, based on the all configurations.
+	ib_buffer_t			csi_buffer[N_CSI_PORTS];	input_system_config_flags_t	csi_buffer_flags[N_CSI_PORTS];
+	ib_buffer_t			acquisition_buffer_unique;	input_system_config_flags_t	acquisition_buffer_unique_flags;
+	uint32_t			unallocated_ib_mem_words; // Used for check.DEFAULT = IB_CAPACITY_IN_WORDS.
+	//uint32_t			acq_allocated_ib_mem_words;
+
+	input_system_connection_t		multicast[N_CSI_PORTS];
+	input_system_multiplex_t		multiplexer;   					input_system_config_flags_t		multiplexer_flags;
+
+
+	tpg_cfg_t			tpg_value;			input_system_config_flags_t	tpg_flags;
+	prbs_cfg_t			prbs_value;			input_system_config_flags_t	prbs_flags;
+	gpfifo_cfg_t		gpfifo_value;		input_system_config_flags_t	gpfifo_flags;
+
+
+	input_switch_cfg_t		input_switch_cfg;
+
+
+	target_isp_cfg_t		target_isp      [N_CHANNELS];	input_system_config_flags_t	target_isp_flags      [N_CHANNELS];
+	target_sp_cfg_t			target_sp       [N_CHANNELS];	input_system_config_flags_t	target_sp_flags       [N_CHANNELS];
+	target_strm2mem_cfg_t	target_strm2mem [N_CHANNELS];	input_system_config_flags_t	target_strm2mem_flags [N_CHANNELS];
+
+	input_system_config_flags_t		session_flags;
+
+};
+
+/*
+ * For each MIPI port
+ */
+#define _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX			_HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX
+#define _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX		    _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX			_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX
+/* new regs for each MIPI port w.r.t. 2300 */
+#define _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX       _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX
+#define _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX            _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX
+#define _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX              _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX
+
+/* _HRT_CSS_RECEIVER_2400_COMP_FORMAT_REG_IDX is not defined per MIPI port but per channel */
+/* _HRT_CSS_RECEIVER_2400_COMP_PREDICT_REG_IDX is not defined per MIPI port but per channel */
+#define _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX			_HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX
+#define _HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX           _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW18_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX
+#define _HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX            _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW16_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX
+
+/* Previously MIPI port regs, now 2x2 logical channel regs */
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX
+
+/* Second backend is at offset 0x0700 w.r.t. the first port at offset 0x0100 */
+#define _HRT_CSS_BE_OFFSET                              448
+#define _HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX        (_HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SRST_REG_IDX               (_HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX            (_HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SEL_REG_IDX                (_HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX          (_HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX + _HRT_CSS_BE_OFFSET)
+
+
+#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT				_HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT
+#define _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT	        _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT		_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT		_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT			_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT			_HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT				_HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT				_HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT
+#define _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT			_HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT			_HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT			_HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT
+
+#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX				_HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX				_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX
+#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS				_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS
+
+typedef struct capture_unit_state_s		capture_unit_state_t;
+typedef struct acquisition_unit_state_s	acquisition_unit_state_t;
+typedef struct ctrl_unit_state_s		ctrl_unit_state_t;
+
+/*
+ * In 2300 ports can be configured independently and stream
+ * formats need to be specified. In 2400, there are only 8
+ * supported configurations but the HW is fused to support
+ * only a single one.
+ * 
+ * In 2300 the compressed format types are programmed by the
+ * user. In 2400 all stream formats are encoded on the stream.
+ *
+ * Use the enum to check validity of a user configuration
+ */
+typedef enum {
+	MONO_4L_1L_0L = 0,
+	MONO_3L_1L_0L,
+	MONO_2L_1L_0L,
+	MONO_1L_1L_0L,
+	STEREO_2L_1L_2L,
+	STEREO_3L_1L_1L,
+	STEREO_2L_1L_1L,
+	STEREO_1L_1L_1L,
+	N_RX_MODE
+} rx_mode_t;
+
+typedef enum {
+	MIPI_PREDICTOR_NONE = 0,
+	MIPI_PREDICTOR_TYPE1,
+	MIPI_PREDICTOR_TYPE2,
+	N_MIPI_PREDICTOR_TYPES
+} mipi_predictor_t;
+
+typedef enum {
+	MIPI_COMPRESSOR_NONE = 0,
+	MIPI_COMPRESSOR_10_6_10,
+	MIPI_COMPRESSOR_10_7_10,
+	MIPI_COMPRESSOR_10_8_10,
+	MIPI_COMPRESSOR_12_6_12,
+	MIPI_COMPRESSOR_12_7_12,
+	MIPI_COMPRESSOR_12_8_12,
+	N_MIPI_COMPRESSOR_METHODS
+} mipi_compressor_t;
+
+typedef enum {
+	MIPI_FORMAT_RGB888 = 0,
+	MIPI_FORMAT_RGB555,
+	MIPI_FORMAT_RGB444,
+	MIPI_FORMAT_RGB565,
+	MIPI_FORMAT_RGB666,
+	MIPI_FORMAT_RAW8,		/* 5 */
+	MIPI_FORMAT_RAW10,
+	MIPI_FORMAT_RAW6,
+	MIPI_FORMAT_RAW7,
+	MIPI_FORMAT_RAW12,
+	MIPI_FORMAT_RAW14,		/* 10 */
+	MIPI_FORMAT_YUV420_8,
+	MIPI_FORMAT_YUV420_10,
+	MIPI_FORMAT_YUV422_8,
+	MIPI_FORMAT_YUV422_10,
+	MIPI_FORMAT_CUSTOM0,	/* 15 */
+	MIPI_FORMAT_YUV420_8_LEGACY,
+	MIPI_FORMAT_EMBEDDED,
+	MIPI_FORMAT_CUSTOM1,
+	MIPI_FORMAT_CUSTOM2,
+	MIPI_FORMAT_CUSTOM3,	/* 20 */
+	MIPI_FORMAT_CUSTOM4,
+	MIPI_FORMAT_CUSTOM5,
+	MIPI_FORMAT_CUSTOM6,
+	MIPI_FORMAT_CUSTOM7,
+	MIPI_FORMAT_YUV420_8_SHIFT,	/* 25 */
+	MIPI_FORMAT_YUV420_10_SHIFT,
+	MIPI_FORMAT_RAW16,
+	MIPI_FORMAT_RAW18,
+	N_MIPI_FORMAT,
+} mipi_format_t;
+
+#define MIPI_FORMAT_JPEG		MIPI_FORMAT_CUSTOM0
+#define MIPI_FORMAT_BINARY_8	MIPI_FORMAT_CUSTOM0
+#define N_MIPI_FORMAT_CUSTOM	8
+
+/* The number of stores for compressed format types */
+#define	N_MIPI_COMPRESSOR_CONTEXT	(N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
+
+typedef enum {
+	RX_IRQ_INFO_BUFFER_OVERRUN   = 1UL << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT,
+	RX_IRQ_INFO_INIT_TIMEOUT     = 1UL << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT,
+	RX_IRQ_INFO_ENTER_SLEEP_MODE = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT,
+	RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT,
+	RX_IRQ_INFO_ECC_CORRECTED    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT,
+	RX_IRQ_INFO_ERR_SOT          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT,
+	RX_IRQ_INFO_ERR_SOT_SYNC     = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT,
+	RX_IRQ_INFO_ERR_CONTROL      = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT,
+	RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT,
+/*	RX_IRQ_INFO_NO_ERR           = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT, */
+	RX_IRQ_INFO_ERR_CRC          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT,
+	RX_IRQ_INFO_ERR_FRAME_SYNC   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT,
+	RX_IRQ_INFO_ERR_FRAME_DATA   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT,
+	RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1UL << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT,
+	RX_IRQ_INFO_ERR_LINE_SYNC    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT,
+}  rx_irq_info_t;
+
+typedef struct rx_cfg_s		rx_cfg_t;
+
+/*
+ * Applied per port
+ */
+struct rx_cfg_s {
+	rx_mode_t			mode;	/* The HW config */
+	mipi_port_ID_t		port;	/* The port ID to apply the control on */
+	unsigned int		timeout;
+	unsigned int		initcount;
+	unsigned int		synccount;
+	unsigned int		rxcount;
+	mipi_predictor_t	comp;	/* Just for backward compatibility */
+	bool                is_two_ppc;
+};
+
+/* NOTE: The base has already an offset of 0x0100 */
+static const hrt_address MIPI_PORT_OFFSET[N_MIPI_PORT_ID] = {
+	0x00000000UL,
+	0x00000100UL,
+	0x00000200UL};
+
+static const mipi_lane_cfg_t MIPI_PORT_MAXLANES[N_MIPI_PORT_ID] = {
+	MIPI_4LANE_CFG,
+	MIPI_1LANE_CFG,
+	MIPI_2LANE_CFG};
+
+static const bool MIPI_PORT_ACTIVE[N_RX_MODE][N_MIPI_PORT_ID] = {
+	{true, true, false},
+	{true, true, false},
+	{true, true, false},
+	{true, true, false},
+	{true, true, true},
+	{true, true, true},
+	{true, true, true},
+	{true, true, true}};
+
+static const mipi_lane_cfg_t MIPI_PORT_LANES[N_RX_MODE][N_MIPI_PORT_ID] = {
+	{MIPI_4LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_2LANE_CFG},
+	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
+	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG}};
+
+static const hrt_address SUB_SYSTEM_OFFSET[N_SUB_SYSTEM_ID] = {
+	0x00001000UL,
+	0x00002000UL,
+	0x00003000UL,
+	0x00004000UL,
+	0x00005000UL,
+	0x00009000UL,
+	0x0000A000UL,
+	0x0000B000UL,
+	0x0000C000UL};
+
+struct capture_unit_state_s {
+	int	Packet_Length;
+	int	Received_Length;
+	int	Received_Short_Packets;
+	int	Received_Long_Packets;
+	int	Last_Command;
+	int	Next_Command;
+	int	Last_Acknowledge;
+	int	Next_Acknowledge;
+	int	FSM_State_Info;
+	int	StartMode;
+	int	Start_Addr;
+	int	Mem_Region_Size;
+	int	Num_Mem_Regions;
+/*	int	Init;   write-only registers
+	int	Start;
+	int	Stop;      */
+};
+
+struct acquisition_unit_state_s {
+/*	int	Init;   write-only register */
+	int	Received_Short_Packets;
+	int	Received_Long_Packets;
+	int	Last_Command;
+	int	Next_Command;
+	int	Last_Acknowledge;
+	int	Next_Acknowledge;
+	int	FSM_State_Info;
+	int	Int_Cntr_Info;
+	int	Start_Addr;
+	int	Mem_Region_Size;
+	int	Num_Mem_Regions;
+};
+
+struct ctrl_unit_state_s {
+	int	last_cmd;
+	int	next_cmd;
+	int	last_ack;
+	int	next_ack;
+	int	top_fsm_state;
+	int	captA_fsm_state;
+	int	captB_fsm_state;
+	int	captC_fsm_state;
+	int	acq_fsm_state;
+	int	captA_start_addr;
+	int	captB_start_addr;
+	int	captC_start_addr;
+	int	captA_mem_region_size;
+	int	captB_mem_region_size;
+	int	captC_mem_region_size;
+	int	captA_num_mem_regions;
+	int	captB_num_mem_regions;
+	int	captC_num_mem_regions;
+	int	acq_start_addr;
+	int	acq_mem_region_size;
+	int	acq_num_mem_regions;
+/*	int	ctrl_init;  write only register */
+	int	capt_reserve_one_mem_region;
+};
+
+struct input_system_state_s {
+	int	str_multicastA_sel;
+	int	str_multicastB_sel;
+	int	str_multicastC_sel;
+	int	str_mux_sel;
+	int	str_mon_status;
+	int	str_mon_irq_cond;
+	int	str_mon_irq_en;
+	int	isys_srst;
+	int	isys_slv_reg_srst;
+	int	str_deint_portA_cnt;
+	int	str_deint_portB_cnt;
+	struct capture_unit_state_s		capture_unit[N_CAPTURE_UNIT_ID];
+	struct acquisition_unit_state_s	acquisition_unit[N_ACQUISITION_UNIT_ID];
+	struct ctrl_unit_state_s		ctrl_unit_state[N_CTRL_UNIT_ID];
+};
+
+struct mipi_port_state_s {
+	int	device_ready;
+	int	irq_status;
+	int	irq_enable;
+	uint32_t	timeout_count;
+	uint16_t	init_count;
+	uint16_t	raw16_18;
+	uint32_t	sync_count;		/*4 x uint8_t */
+	uint32_t	rx_count;		/*4 x uint8_t */
+	uint8_t		lane_sync_count[MIPI_4LANE_CFG];
+	uint8_t		lane_rx_count[MIPI_4LANE_CFG];
+};
+
+struct rx_channel_state_s {
+	uint32_t	comp_scheme0;
+	uint32_t	comp_scheme1;
+	mipi_predictor_t		pred[N_MIPI_FORMAT_CUSTOM];
+	mipi_compressor_t		comp[N_MIPI_FORMAT_CUSTOM];
+};
+
+struct receiver_state_s {
+	uint8_t	fs_to_ls_delay;
+	uint8_t	ls_to_data_delay;
+	uint8_t	data_to_le_delay;
+	uint8_t	le_to_fe_delay;
+	uint8_t	fe_to_fs_delay;
+	uint8_t	le_to_fs_delay;
+	bool	is_two_ppc;
+	int	backend_rst;
+	uint16_t	raw18;
+	bool		force_raw8;
+	uint16_t	raw16;
+	struct mipi_port_state_s	mipi_port_state[N_MIPI_PORT_ID];
+	struct rx_channel_state_s	rx_channel_state[N_RX_CHANNEL_ID];
+	int	be_gsp_acc_ovl;
+	int	be_srst;
+	int	be_is_two_ppc;
+	int	be_comp_format0;
+	int	be_comp_format1;
+	int	be_comp_format2;
+	int	be_comp_format3;
+	int	be_sel;
+	int	be_raw16_config;
+	int	be_raw18_config;
+	int	be_force_raw8;
+	int	be_irq_status;
+	int	be_irq_clear;
+};
+
+#endif /* __INPUT_SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h
new file mode 100644
index 0000000..766f3e9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h
@@ -0,0 +1,102 @@
+#ifndef __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
+#define __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
+
+#include "input_system_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_INPUT_SYSTEM_C void input_system_reg_store(
+	const input_system_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(INPUT_SYSTEM_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_reg_load(
+	const input_system_ID_t		ID,
+	const unsigned int			reg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(INPUT_SYSTEM_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(
+	const rx_ID_t				ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_RX_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(RX_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(
+	const rx_ID_t				ID,
+	const unsigned int			reg)
+{
+assert(ID < N_RX_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(RX_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void receiver_port_reg_store(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_RX_ID);
+assert(port_ID < N_MIPI_PORT_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
+	device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_port_reg_load(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const unsigned int			reg)
+{
+assert(ID < N_RX_ID);
+assert(port_ID < N_MIPI_PORT_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
+return device_load_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void input_system_sub_system_reg_store(
+	const input_system_ID_t		ID,
+	const sub_system_ID_t		sub_ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_ID < N_SUB_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
+	device_store_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_sub_system_reg_load(
+	const input_system_ID_t		ID,
+	const sub_system_ID_t		sub_ID,
+	const unsigned int			reg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_ID < N_SUB_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
+return device_load_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __INPUT_SYSTEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c
new file mode 100644
index 0000000..b57dc18
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c
@@ -0,0 +1,436 @@
+#include "irq.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#define __INLINE_GP_DEVICE__
+#endif
+#include "gp_device.h"	/* _REG_GP_IRQ_REQUEST_ADDR */
+
+#include "platform_support.h"			/* hrt_sleep() */
+
+STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
+	const irq_ID_t		ID);
+
+STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
+	const irq_ID_t				ID);
+
+STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
+	const virq_id_t		irq_ID,
+	unsigned int		*channel_ID);
+
+#ifndef __INLINE_IRQ__
+#include "irq_private.h"
+#endif /* __INLINE_IRQ__ */
+
+static unsigned short IRQ_N_CHANNEL[N_IRQ_ID] = {
+	IRQ0_ID_N_CHANNEL,
+	IRQ1_ID_N_CHANNEL,
+	IRQ2_ID_N_CHANNEL,
+	IRQ3_ID_N_CHANNEL};
+
+static unsigned short IRQ_N_ID_OFFSET[N_IRQ_ID + 1] = {
+	IRQ0_ID_OFFSET,
+	IRQ1_ID_OFFSET,
+	IRQ2_ID_OFFSET,
+	IRQ3_ID_OFFSET,
+	IRQ_END_OFFSET};
+
+static virq_id_t IRQ_NESTING_ID[N_IRQ_ID] = {
+	N_virq_id,
+	virq_ifmt,
+	virq_isys,
+	virq_isel};
+
+void irq_clear_all(
+	const irq_ID_t				ID)
+{
+	hrt_data	mask = 0xFFFFFFFF;
+
+assert(ID < N_IRQ_ID);
+assert(IRQ_N_CHANNEL[ID] <= HRT_DATA_WIDTH);
+
+	if (IRQ_N_CHANNEL[ID] < HRT_DATA_WIDTH) {
+/* */
+		mask = ~((~(hrt_data)0)>>IRQ_N_CHANNEL[ID]);
+	}
+
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);
+return;
+}
+
+/*
+ * Do we want the user to be able to set the signalling method ?
+ */
+void irq_enable_channel(
+	const irq_ID_t				ID,
+    const unsigned int			irq_id)
+{
+	unsigned int mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int edge_in = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
+	unsigned int me = 1U << irq_id;
+
+assert(ID < N_IRQ_ID);
+assert(irq_id < IRQ_N_CHANNEL[ID]);
+
+	mask |= me;
+	enable |= me;
+	edge_in |= me;	/* rising edge */
+
+/* to avoid mishaps configuration must follow the following order */
+
+/* mask this interrupt */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);
+/* rising edge at input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);
+/* enable interrupt to output */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+/* clear current irq only */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+/* unmask interrupt from input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+
+	irq_wait_for_write_complete(ID);
+
+return;
+}
+
+void irq_enable_pulse(
+	const irq_ID_t	ID,
+	bool 			pulse)
+{
+	unsigned int edge_out = 0x0;
+	if (pulse) {
+		edge_out = 0xffffffff;
+	}
+	/* output is given as edge, not pulse */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);
+return;
+}
+
+void irq_disable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq_id)
+{
+	unsigned int mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int me = 1U << irq_id;
+
+assert(ID < N_IRQ_ID);
+assert(irq_id < IRQ_N_CHANNEL[ID]);
+
+	mask &= ~me;
+	enable &= ~me;
+
+/* enable interrupt to output */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+/* unmask interrupt from input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+/* clear current irq only */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+
+	irq_wait_for_write_complete(ID);
+
+return;
+}
+
+enum hrt_isp_css_irq_status irq_get_channel_id(
+	const irq_ID_t				ID,
+	unsigned int				*irq_id)
+{
+	unsigned int irq_status = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int idx;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
+
+assert(ID < N_IRQ_ID);
+assert(irq_id != NULL);
+
+/* find the first irq bit */
+	for (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {
+		if (irq_status & (1U << idx))
+			break;
+	}
+	if (idx == IRQ_N_CHANNEL[ID])
+		return hrt_isp_css_irq_status_error;
+
+/* now check whether there are more bits set */
+	if (irq_status != (1U << idx))
+		status = hrt_isp_css_irq_status_more_irqs;
+
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+
+	irq_wait_for_write_complete(ID);
+
+	if (irq_id != NULL)
+		*irq_id = (unsigned int)idx;
+
+return status;
+}
+
+static const hrt_address IRQ_REQUEST_ADDR[N_IRQ_SW_CHANNEL_ID] = {
+	_REG_GP_IRQ_REQUEST0_ADDR,
+	_REG_GP_IRQ_REQUEST1_ADDR};
+
+void irq_raise(
+	const irq_ID_t				ID,
+	const irq_sw_channel_id_t	irq_id)
+{
+	hrt_address		addr;
+
+OP___assert(ID == IRQ0_ID);
+OP___assert(IRQ_BASE[ID] != (hrt_address)-1);
+OP___assert(irq_id < N_IRQ_SW_CHANNEL_ID);
+
+(void)ID;
+
+	addr = IRQ_REQUEST_ADDR[irq_id];
+/* The SW IRQ pins are remapped to offset zero */
+	gp_device_reg_store(GP_DEVICE0_ID,
+		addr, 1);
+#ifdef HRT_CSIM
+	hrt_sleep();
+#endif
+	gp_device_reg_store(GP_DEVICE0_ID,
+		addr, 0);
+return;
+}
+
+void irq_controller_get_state(
+	const irq_ID_t				ID,
+	irq_controller_state_t		*state)
+{
+assert(ID < N_IRQ_ID);
+assert(state != NULL);
+
+	state->irq_edge = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
+	state->irq_mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	state->irq_status = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	state->irq_enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	state->irq_level_not_pulse = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX);
+return;
+}
+
+bool any_virq_signal(void)
+{
+	unsigned int irq_status = irq_reg_load(IRQ0_ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+return (irq_status != 0);
+}
+
+void cnd_virq_enable_channel(
+	const virq_id_t				irq_ID,
+	const bool					en)
+{
+	irq_ID_t		i;
+	unsigned int	channel_ID;
+	irq_ID_t		ID = virq_get_irq_id(irq_ID, &channel_ID);
+	
+assert(ID < N_IRQ_ID);
+for (i=IRQ1_ID;i<N_IRQ_ID;i++) {
+/* It is not allowed to enable the pin of a nested IRQ directly */
+	assert(irq_ID != IRQ_NESTING_ID[i]);
+}
+
+	if (en) {
+		irq_enable_channel(ID, channel_ID);
+		if (IRQ_NESTING_ID[ID] != N_virq_id) {
+/* Single level nesting, otherwise we'd need to recurse */
+			irq_enable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);
+		}
+	} else {
+		irq_disable_channel(ID, channel_ID);
+		if ((IRQ_NESTING_ID[ID] != N_virq_id) && !any_irq_channel_enabled(ID)) {
+/* Only disable the top if the nested ones are empty */
+			irq_disable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);
+		}
+	}
+return;
+}
+
+
+void virq_clear_all(void)
+{
+	irq_ID_t	irq_id;
+	for (irq_id = (irq_ID_t)0; irq_id < N_IRQ_ID; irq_id++) {
+/* */
+		irq_clear_all(irq_id);
+	}
+return;
+}
+
+enum hrt_isp_css_irq_status virq_get_channel_signals(
+	virq_info_t					*irq_info)
+{
+	enum hrt_isp_css_irq_status irq_status = hrt_isp_css_irq_status_error;
+	irq_ID_t ID;
+
+assert(irq_info != NULL);
+
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+		if (any_irq_channel_enabled(ID)) {
+			hrt_data	irq_data = irq_reg_load(ID,
+				_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+
+			if (irq_data != 0) {
+/* The error condition is an IRQ pulse received with no IRQ status written */
+				irq_status = hrt_isp_css_irq_status_success;
+			}
+
+			irq_info->irq_status_reg[ID] |= irq_data;
+
+			irq_reg_store(ID,
+				_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, irq_data);
+
+			irq_wait_for_write_complete(ID);
+		}
+	}
+
+return irq_status;
+}
+
+void virq_clear_info(
+	virq_info_t					*irq_info)
+{
+	irq_ID_t ID;
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+/* */
+			irq_info->irq_status_reg[ID] = 0;
+	}
+return;
+}
+
+enum hrt_isp_css_irq_status virq_get_channel_id(
+	virq_id_t					*irq_id)
+{
+	unsigned int irq_status = irq_reg_load(IRQ0_ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int idx;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
+	irq_ID_t ID;
+
+
+/* find the first irq bit on device 0 */
+	for (idx = 0; idx < IRQ_N_CHANNEL[IRQ0_ID]; idx++) {
+		if (irq_status & (1U << idx))
+			break;
+	}
+
+	if (idx == IRQ_N_CHANNEL[IRQ0_ID]) {
+		return hrt_isp_css_irq_status_error;
+	}
+
+/* Check whether there are more bits set on device 0 */
+	if (irq_status != (1U << idx)) {
+		status = hrt_isp_css_irq_status_more_irqs;
+	}
+
+/* Check whether we have an IRQ on one of the nested devices */
+	for (ID = N_IRQ_ID-1 ; ID > (irq_ID_t)0; ID--) {
+		if (IRQ_NESTING_ID[ID] == (virq_id_t)idx) {
+			break;
+		}
+	}
+
+/* If we have a nested IRQ, load that state, discard the device 0 state */
+	if (ID != IRQ0_ID) {
+		irq_status = irq_reg_load(ID,
+			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+/* find the first irq bit on device "id" */
+		for (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {
+			if (irq_status & (1U << idx))
+				break;
+		}
+
+		if (idx == IRQ_N_CHANNEL[ID]) {
+			return hrt_isp_css_irq_status_error;
+		}
+
+/* Alternatively check whether there are more bits set on this device */
+		if (irq_status != (1U << idx)) {
+			status = hrt_isp_css_irq_status_more_irqs;
+		} else {
+/* If this device is empty, clear the state on device 0 */
+			irq_reg_store(IRQ0_ID,
+				_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << IRQ_NESTING_ID[ID]);
+		}
+	} /* if (ID != IRQ0_ID) */
+
+/* Here we proceed to clear the IRQ on detected device, if no nested IRQ, this is device 0 */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+
+	irq_wait_for_write_complete(ID);
+
+	idx += IRQ_N_ID_OFFSET[ID];
+	if (irq_id != NULL)
+		*irq_id = (virq_id_t)idx;
+
+return status;
+}
+
+STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
+	const irq_ID_t		ID)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+	(void)device_load_uint32(IRQ_BASE[ID] +
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX*sizeof(hrt_data));
+#ifdef HRT_CSIM
+	hrt_sleep();
+#endif
+return;
+}
+
+STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
+	const irq_ID_t				ID)
+{
+	hrt_data	en_reg;
+
+assert(ID < N_IRQ_ID);
+
+	en_reg = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+
+return (en_reg != 0);
+}
+
+STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
+	const virq_id_t		irq_ID,
+	unsigned int		*channel_ID)
+{
+	irq_ID_t ID;
+
+assert(channel_ID != NULL);
+
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+		if (irq_ID < IRQ_N_ID_OFFSET[ID + 1]) {
+/* */
+			break;
+		}
+	}
+
+	*channel_ID = (unsigned int)irq_ID - IRQ_N_ID_OFFSET[ID];
+
+return ID;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h
new file mode 100644
index 0000000..b8e2ed2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h
@@ -0,0 +1,122 @@
+#ifndef __IRQ_LOCAL_H_INCLUDED__
+#define __IRQ_LOCAL_H_INCLUDED__
+
+#include "irq_global.h"
+
+#include <irq_controller_defs.h>
+
+/* IRQ0_ID */
+#include "hive_isp_css_defs.h"
+#define HIVE_GP_DEV_IRQ_NUM_IRQS	32
+/* IRQ1_ID */
+#include "input_formatter_subsystem_defs.h"
+#define HIVE_IFMT_IRQ_NUM_IRQS		5
+/* IRQ2_ID */
+#include "input_system_defs.h"
+/* IRQ3_ID */
+#include "input_selector_defs.h"
+
+
+#define	IRQ_ID_OFFSET	32
+#define	IRQ0_ID_OFFSET	0
+#define	IRQ1_ID_OFFSET	IRQ_ID_OFFSET
+#define	IRQ2_ID_OFFSET	(2*IRQ_ID_OFFSET)
+#define	IRQ3_ID_OFFSET	(3*IRQ_ID_OFFSET)
+#define	IRQ_END_OFFSET	(4*IRQ_ID_OFFSET)
+
+#define	IRQ0_ID_N_CHANNEL	HIVE_GP_DEV_IRQ_NUM_IRQS
+#define	IRQ1_ID_N_CHANNEL	HIVE_IFMT_IRQ_NUM_IRQS
+#define	IRQ2_ID_N_CHANNEL	HIVE_ISYS_IRQ_NUM_BITS
+#define	IRQ3_ID_N_CHANNEL	HIVE_ISEL_IRQ_NUM_IRQS
+
+typedef struct virq_info_s					virq_info_t;
+typedef struct irq_controller_state_s		irq_controller_state_t;
+
+
+typedef enum {
+	virq_gpio_pin_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
+	virq_gpio_pin_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
+	virq_gpio_pin_2            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
+	virq_gpio_pin_3            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
+	virq_gpio_pin_4            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
+	virq_gpio_pin_5            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
+	virq_gpio_pin_6            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
+	virq_gpio_pin_7            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
+	virq_gpio_pin_8            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
+	virq_gpio_pin_9            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
+	virq_gpio_pin_10           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
+	virq_gpio_pin_11           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
+	virq_sp                    = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_BIT_ID,
+	virq_isp                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BIT_ID,
+	virq_isys                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
+	virq_isel                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
+	virq_ifmt                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
+	virq_sp_stream_mon         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
+	virq_isp_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
+	virq_mod_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM) || defined(IS_ISP_2400A0_MAMOIADA_SYSTEM)
+	virq_isp_pmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+	virq_isys_2401             = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IS2401_BIT_ID,
+#else
+#error "irq_local.h: 2400_SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+	virq_isp_bamem_error       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
+	virq_isp_dmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
+	virq_sp_icache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
+	virq_sp_dmem_error         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
+	virq_mmu_cache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
+	virq_gp_timer_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
+	virq_gp_timer_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,              
+	virq_sw_pin_0              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
+	virq_sw_pin_1              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
+	virq_dma                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_DMA_BIT_ID,
+	virq_sp_stream_mon_b       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
+
+	virq_ifmt0_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID,
+	virq_ifmt1_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID,
+	virq_ifmt2_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_SEC_BIT_ID,
+	virq_ifmt3_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_MEM_CPY_BIT_ID,
+	virq_ifmt_sideband_changed = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID,
+
+	virq_isys_sof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOF_BIT_ID,
+	virq_isys_eof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOF_BIT_ID,
+	virq_isys_sol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOL_BIT_ID,
+	virq_isys_eol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOL_BIT_ID,
+	virq_isys_csi              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID,
+	virq_isys_csi_be           = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID,
+	virq_isys_capt0_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP,
+	virq_isys_capt0_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP,
+	virq_isys_capt1_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP,
+	virq_isys_capt1_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP,
+	virq_isys_capt2_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP,
+	virq_isys_capt2_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP,
+	virq_isys_acq_sop_mismatch = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH,
+	virq_isys_ctrl_capt0       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPA,
+	virq_isys_ctrl_capt1       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPB,
+	virq_isys_ctrl_capt2       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPC,
+	virq_isys_cio_to_ahb       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CIO2AHB,
+	virq_isys_dma              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_DMA_BIT_ID,
+	virq_isys_fifo_monitor     = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_STREAM_MON_BIT_ID,
+
+	virq_isel_sof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID,
+	virq_isel_eof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID,
+	virq_isel_sol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID,
+	virq_isel_eol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID,
+
+	N_virq_id                  = IRQ_END_OFFSET
+} virq_id_t;
+
+struct virq_info_s {
+	hrt_data		irq_status_reg[N_IRQ_ID];
+};
+
+struct irq_controller_state_s {
+	unsigned int	irq_edge;
+	unsigned int	irq_mask;
+	unsigned int	irq_status;
+	unsigned int	irq_enable;
+	unsigned int	irq_level_not_pulse;
+};
+
+#endif /* __IRQ_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h
new file mode 100644
index 0000000..08435fd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h
@@ -0,0 +1,30 @@
+#ifndef __IRQ_PRIVATE_H_INCLUDED__
+#define __IRQ_PRIVATE_H_INCLUDED__
+
+#include "irq_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_IRQ_C void irq_reg_store(
+	const irq_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_IRQ_C hrt_data irq_reg_load(
+	const irq_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __IRQ_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c
new file mode 100644
index 0000000..800b5e0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c
@@ -0,0 +1,70 @@
+#include "isp.h"
+
+#ifndef __INLINE_ISP__
+#include "isp_private.h"
+#endif /* __INLINE_ISP__ */
+
+void cnd_isp_irq_enable(
+	const isp_ID_t		ID,
+	const bool			cnd)
+{
+	if (cnd) {
+		isp_ctrl_setbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);
+/* Enabling the IRQ immediately triggers an interrupt, clear it */
+		isp_ctrl_setbit(ID, ISP_IRQ_CLEAR_REG, ISP_IRQ_CLEAR_BIT);
+	} else {
+		isp_ctrl_clearbit(ID, ISP_IRQ_READY_REG,
+			ISP_IRQ_READY_BIT);
+	}
+return;
+}
+
+void isp_get_state(
+	const isp_ID_t		ID,
+    isp_state_t			*state,
+	isp_stall_t			*stall)
+{
+	hrt_data sc = isp_ctrl_load(ID, ISP_SC_REG);
+	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
+	state->status_register = sc;
+	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
+	state->is_idle = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
+	state->is_sleeping = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
+	state->is_stalling = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_STALLING_BIT);
+	stall->stat_ctrl =
+		!isp_ctrl_getbit(ID, ISP_CTRL_SINK_REG, ISP_CTRL_SINK_BIT);
+	stall->pmem =
+		!isp_ctrl_getbit(ID, ISP_PMEM_SINK_REG, ISP_PMEM_SINK_BIT);
+	stall->dmem =
+		!isp_ctrl_getbit(ID, ISP_DMEM_SINK_REG, ISP_DMEM_SINK_BIT);
+	stall->vmem =
+		!isp_ctrl_getbit(ID, ISP_VMEM_SINK_REG, ISP_VMEM_SINK_BIT);
+	stall->fifo0 =
+		!isp_ctrl_getbit(ID, ISP_FIFO0_SINK_REG, ISP_FIFO0_SINK_BIT);
+	stall->fifo1 =
+		!isp_ctrl_getbit(ID, ISP_FIFO1_SINK_REG, ISP_FIFO1_SINK_BIT);
+	stall->fifo2 =
+		!isp_ctrl_getbit(ID, ISP_FIFO2_SINK_REG, ISP_FIFO2_SINK_BIT);
+	stall->fifo3 =
+		!isp_ctrl_getbit(ID, ISP_FIFO3_SINK_REG, ISP_FIFO3_SINK_BIT);
+	stall->fifo4 =
+		!isp_ctrl_getbit(ID, ISP_FIFO4_SINK_REG, ISP_FIFO4_SINK_BIT);
+	stall->fifo5 =
+		!isp_ctrl_getbit(ID, ISP_FIFO5_SINK_REG, ISP_FIFO5_SINK_BIT);
+	stall->fifo6 =
+		!isp_ctrl_getbit(ID, ISP_FIFO6_SINK_REG, ISP_FIFO6_SINK_BIT);
+	stall->vamem1 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM1_SINK_REG, ISP_VAMEM1_SINK_BIT);
+	stall->vamem2 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM2_SINK_REG, ISP_VAMEM2_SINK_BIT);
+	stall->vamem3 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM3_SINK_REG, ISP_VAMEM3_SINK_BIT);
+	stall->hmem =
+		!isp_ctrl_getbit(ID, ISP_HMEM_SINK_REG, ISP_HMEM_SINK_BIT);
+/*
+	stall->icache_master =
+		!isp_ctrl_getbit(ID, ISP_ICACHE_MT_SINK_REG,
+			ISP_ICACHE_MT_SINK_BIT);
+ */
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h
new file mode 100644
index 0000000..c1012ce
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h
@@ -0,0 +1,41 @@
+#ifndef __ISP_LOCAL_H_INCLUDED__
+#define __ISP_LOCAL_H_INCLUDED__
+
+#include <stdbool.h>
+
+#include "isp_global.h"
+
+#define HIVE_ISP_VMEM_MASK	((1U<<ISP_VMEM_ELEMBITS)-1)
+
+typedef struct isp_state_s		isp_state_t;
+typedef struct isp_stall_s		isp_stall_t;
+
+struct isp_state_s {
+	int		pc;
+	int		status_register;
+	bool	is_broken;
+	bool	is_idle;
+	bool	is_sleeping;
+	bool	is_stalling;
+};
+
+struct isp_stall_s {
+	bool	fifo0;
+	bool	fifo1;
+	bool	fifo2;
+	bool	fifo3;
+	bool	fifo4;
+	bool	fifo5;
+	bool	fifo6;
+	bool	stat_ctrl;
+	bool	dmem;
+	bool	vmem;
+	bool	vamem1;
+	bool	vamem2;
+	bool	vamem3;
+	bool	hmem;
+	bool	pmem;
+	bool	icache_master;
+};
+
+#endif /* __ISP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h
new file mode 100644
index 0000000..b80266f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h
@@ -0,0 +1,248 @@
+#ifndef __ISP_PRIVATE_H_INCLUDED__
+#define __ISP_PRIVATE_H_INCLUDED__
+
+#include "isp_public.h"
+
+#ifdef C_RUN
+#include <string.h>		/* memcpy() */
+#endif
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_ISP_C void isp_ctrl_store(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_ISP_C hrt_data isp_ctrl_load(
+	const isp_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_ISP_C bool isp_ctrl_getbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data val = isp_ctrl_load(ID, reg);
+return (val & (1UL << bit)) != 0;
+}
+
+STORAGE_CLASS_ISP_C void isp_ctrl_setbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = isp_ctrl_load(ID, reg);
+	isp_ctrl_store(ID, reg, (data | (1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_ctrl_clearbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = isp_ctrl_load(ID, reg);
+	isp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store(ISP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void				*data,
+	const size_t		size)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+
+	device_load(ISP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_hmem_load(
+	const hmem_ID_t		ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size)
+{
+assert(ID < N_HMEM_ID);
+assert(ISP_HMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+
+	device_load(ISP_HMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_hmem_store(
+	const hmem_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size)
+{
+assert(ID < N_HMEM_ID);
+assert(ISP_HMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store(ISP_HMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_store_uint32(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store_uint32(ISP_DMEM_BASE[ISP0_ID] + addr, data);
+#else
+	*(uint32_t *)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(
+	const isp_ID_t		ID,
+	const unsigned int	addr)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	return device_load_uint32(ISP_DMEM_BASE[ISP0_ID] + addr);
+#else
+	return *(uint32_t *)addr;
+#endif
+}
+
+STORAGE_CLASS_ISP_C uint32_t isp_2w_cat_1w(
+	const uint16_t		x0,
+	const uint16_t		x1)
+{
+	uint32_t out = ((uint32_t)(x1 & HIVE_ISP_VMEM_MASK) << ISP_VMEM_ELEMBITS)
+		| (x0 & HIVE_ISP_VMEM_MASK);
+return out;
+}
+
+STORAGE_CLASS_ISP_C void isp_pmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size)
+{
+#ifndef C_RUN
+	int i;
+	uint32_t *p = (uint32_t *)data;
+#endif
+assert(ID < N_ISP_ID);
+assert(ISP_PMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+         for (i = 0; i < size; i = i + 4)
+		device_store_uint32(ISP_PMEM_BASE[ID] + addr + i, *p++);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_pmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_PMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_load(ISP_PMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+return;
+}
+
+
+STORAGE_CLASS_ISP_C void isp_vamem_store(
+	const vamem_ID_t	ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size)
+{
+#ifndef C_RUN
+	uint16_t *p = (uint16_t *) data;
+	int i;
+#endif
+assert(ID < N_VAMEM_ID);
+assert(ISP_VAMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+         for (i = 0; i < size; i = i + sizeof(*p))
+		 device_store_uint16(ISP_VAMEM_BASE[ID] + addr + i, *p++);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_vamem_load(
+	const vamem_ID_t	ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size)
+{
+#ifndef C_RUN
+	uint16_t *p = (uint16_t *) data;
+	int i;
+#endif
+assert(ID < N_VAMEM_ID);
+assert(ISP_VAMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+         for (i = 0; i < size; i = i + sizeof(*p))
+		 *p++ = device_load_uint16(ISP_VAMEM_BASE[ID] + addr + i);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+
+
+#endif /* __ISP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c
new file mode 100644
index 0000000..ba0e856
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c
@@ -0,0 +1,29 @@
+
+
+/* The name "mmu.h is already taken" */
+#include "mmu_device.h"
+
+#ifndef __INLINE_MMU__
+#include "mmu_private.h"
+#endif /* __INLINE_MMU__ */
+
+void mmu_set_page_table_base_index(
+	const mmu_ID_t		ID,
+	const hrt_data		base_index)
+{
+	mmu_reg_store(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX, base_index);
+return;
+}
+
+hrt_data mmu_get_page_table_base_index(
+	const mmu_ID_t		ID)
+{
+return mmu_reg_load(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX);
+}
+
+void mmu_invalidate_cache(
+	const mmu_ID_t		ID)
+{
+	mmu_reg_store(ID, _HRT_MMU_INVALIDATE_TLB_REG_IDX, 1);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h
new file mode 100644
index 0000000..ba9bf81
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h
@@ -0,0 +1,8 @@
+#ifndef __MMU_LOCAL_H_INCLUDED__
+#define __MMU_LOCAL_H_INCLUDED__
+
+#include "mmu_global.h"
+
+#define HOST_ADDRESS(x) (unsigned long)(x)
+
+#endif /* __MMU_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h
new file mode 100644
index 0000000..84dc67b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h
@@ -0,0 +1,30 @@
+#ifndef __MMU_PRIVATE_H_INCLUDED__
+#define __MMU_PRIVATE_H_INCLUDED__
+
+#include "mmu_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_MMU_H void mmu_reg_store(
+	const mmu_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_MMU_ID);
+assert(MMU_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_MMU_H hrt_data mmu_reg_load(
+	const mmu_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_MMU_ID);
+assert(MMU_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __MMU_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c
new file mode 100644
index 0000000..641428d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c
@@ -0,0 +1,63 @@
+#include "sp.h"
+
+#ifndef __INLINE_SP__
+#include "sp_private.h"
+#endif /* __INLINE_SP__ */
+
+void cnd_sp_irq_enable(
+	const sp_ID_t		ID,
+	const bool			cnd)
+{
+	if (cnd) {
+		sp_ctrl_setbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
+/* Enabling the IRQ immediately triggers an interrupt, clear it */
+		sp_ctrl_setbit(ID, SP_IRQ_CLEAR_REG, SP_IRQ_CLEAR_BIT);
+	} else {
+		sp_ctrl_clearbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
+	}
+return;
+}
+
+void sp_get_state(
+	const sp_ID_t			ID,
+	sp_state_t				*state,
+	sp_stall_t				*stall)
+{
+	hrt_data sc = sp_ctrl_load(ID, SP_SC_REG);
+	state->pc = sp_ctrl_load(ID, SP_PC_REG);
+	state->status_register = sc;
+	state->is_broken   = (sc & (1U << SP_BROKEN_BIT)) != 0;
+	state->is_idle     = (sc & (1U << SP_IDLE_BIT)) != 0;
+	state->is_sleeping = (sc & (1U << SP_SLEEPING_BIT)) != 0;
+	state->is_stalling = (sc & (1U << SP_STALLING_BIT)) != 0;
+	stall->fifo0 =
+		!sp_ctrl_getbit(ID, SP_FIFO0_SINK_REG, SP_FIFO0_SINK_BIT);
+	stall->fifo1 =
+		!sp_ctrl_getbit(ID, SP_FIFO1_SINK_REG, SP_FIFO1_SINK_BIT);
+	stall->fifo2 =
+		!sp_ctrl_getbit(ID, SP_FIFO2_SINK_REG, SP_FIFO2_SINK_BIT);
+	stall->fifo3 =
+		!sp_ctrl_getbit(ID, SP_FIFO3_SINK_REG, SP_FIFO3_SINK_BIT);
+	stall->fifo4 =
+		!sp_ctrl_getbit(ID, SP_FIFO4_SINK_REG, SP_FIFO4_SINK_BIT);
+	stall->fifo5 =
+		!sp_ctrl_getbit(ID, SP_FIFO5_SINK_REG, SP_FIFO5_SINK_BIT);
+	stall->fifo6 =
+		!sp_ctrl_getbit(ID, SP_FIFO6_SINK_REG, SP_FIFO6_SINK_BIT);
+	stall->fifo7 =
+		!sp_ctrl_getbit(ID, SP_FIFO7_SINK_REG, SP_FIFO7_SINK_BIT);
+	stall->fifo8 =
+		!sp_ctrl_getbit(ID, SP_FIFO8_SINK_REG, SP_FIFO8_SINK_BIT);
+	stall->fifo9 =
+		!sp_ctrl_getbit(ID, SP_FIFO9_SINK_REG, SP_FIFO9_SINK_BIT);
+	stall->fifoa =
+		!sp_ctrl_getbit(ID, SP_FIFOA_SINK_REG, SP_FIFOA_SINK_BIT);
+	stall->dmem =
+		!sp_ctrl_getbit(ID, SP_DMEM_SINK_REG, SP_DMEM_SINK_BIT);
+	stall->control_master =
+		!sp_ctrl_getbit(ID, SP_CTRL_MT_SINK_REG, SP_CTRL_MT_SINK_BIT);
+	stall->icache_master =
+		!sp_ctrl_getbit(ID, SP_ICACHE_MT_SINK_REG,
+			SP_ICACHE_MT_SINK_BIT);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h
new file mode 100644
index 0000000..1e95322
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h
@@ -0,0 +1,95 @@
+#ifndef __SP_LOCAL_H_INCLUDED__
+#define __SP_LOCAL_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include "sp_global.h"
+
+struct sp_state_s {
+	int		pc;
+	int		status_register;
+	bool	is_broken;
+	bool	is_idle;
+	bool	is_sleeping;
+	bool	is_stalling;
+};
+
+struct sp_stall_s {
+	bool	fifo0;
+	bool	fifo1;
+	bool	fifo2;
+	bool	fifo3;
+	bool	fifo4;
+	bool	fifo5;
+	bool	fifo6;
+	bool	fifo7;
+	bool	fifo8;
+	bool	fifo9;
+	bool	fifoa;
+	bool	dmem;
+	bool	control_master;
+	bool	icache_master;
+};
+
+#if !defined(HRT_RTL) && !defined(HRT_HW) && !defined(HRT_FPGA) && !defined(HRT_PD)
+#include "hive_isp_css_sp_hrt.h"
+#define sp_address_of(var)	_sp_var_addr(var)
+#else
+#define sp_address_of(var)	(HIVE_ADDR_ ## var)
+#endif
+
+/*
+ * deprecated
+ */
+#define store_sp_int(var, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
+		(uint32_t)(value))
+
+#define store_sp_ptr(var, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
+		(uint32_t)(value))
+
+#define load_sp_uint(var) \
+	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(var))
+
+#define load_sp_array_uint8(array_name, index) \
+	sp_dmem_load_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint8_t))
+
+#define load_sp_array_uint16(array_name, index) \
+	sp_dmem_load_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint16_t))
+
+#define load_sp_array_uint(array_name, index) \
+	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint32_t))
+
+#define store_sp_var(var, data, bytes) \
+	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
+
+#define store_sp_array_uint8(array_name, index, value) \
+	sp_dmem_store_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint8_t), value)
+
+#define store_sp_array_uint16(array_name, index, value) \
+	sp_dmem_store_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint16_t), value)
+
+#define store_sp_array_uint(array_name, index, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint32_t), value)
+
+#define store_sp_var_with_offset(var, offset, data, bytes) \
+	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var) + \
+		offset, data, bytes)
+
+#define load_sp_var(var, data, bytes) \
+	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
+
+#define load_sp_var_with_offset(var, offset, data, bytes) \
+	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var) + offset, \
+		data, bytes)
+
+#endif /* __SP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h
new file mode 100644
index 0000000..e27cf6b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h
@@ -0,0 +1,178 @@
+#ifndef __SP_PRIVATE_H_INCLUDED__
+#define __SP_PRIVATE_H_INCLUDED__
+
+#include "sp_public.h"
+
+#include "device_access.h"
+#ifdef C_RUN
+#include <string.h>	/* memcpy() */
+#endif
+
+#include "assert_support.h"
+
+STORAGE_CLASS_SP_C void sp_ctrl_store(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_SP_ID);
+assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_SP_C hrt_data sp_ctrl_load(
+	const sp_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_SP_ID);
+assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
+return device_load_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_SP_C bool sp_ctrl_getbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data val = sp_ctrl_load(ID, reg);
+return (val & (1UL << bit)) != 0;
+}
+
+STORAGE_CLASS_SP_C void sp_ctrl_setbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = sp_ctrl_load(ID, reg);
+	sp_ctrl_store(ID, reg, (data | (1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_ctrl_clearbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = sp_ctrl_load(ID, reg);
+	sp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const void			*data,
+	const size_t		size)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store(SP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_load(
+	const sp_ID_t		ID,
+	const unsigned int	addr,
+	void				*data,
+	const size_t		size)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_load(SP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint8(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint8_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store_uint8(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint8_t *)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint16(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint16_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store_uint16(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint16_t *)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint32(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	device_store_uint32(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint32_t *)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(
+	const sp_ID_t		ID,
+	const unsigned int	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	return device_load_uint8(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint8_t *)addr;
+#endif
+}
+
+STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(
+	const sp_ID_t		ID,
+	const unsigned int	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	return device_load_uint16(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint16_t *)addr;
+#endif
+}
+
+STORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(
+	const sp_ID_t		ID,
+	const unsigned int	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	return device_load_uint32(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint32_t *)addr;
+#endif
+}
+
+#endif /* __SP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h
new file mode 100644
index 0000000..e11d56a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h
@@ -0,0 +1,285 @@
+#ifndef __SYSTEM_LOCAL_H_INCLUDED__
+#define __SYSTEM_LOCAL_H_INCLUDED__
+
+#ifdef HRT_ISP_CSS_CUSTOM_HOST
+#ifndef HRT_USE_VIR_ADDRS
+#define HRT_USE_VIR_ADDRS
+#endif
+/* This interface is deprecated */
+/*#include "hive_isp_css_custom_host_hrt.h"*/
+#endif
+
+#include "system_global.h"
+
+#ifdef __FIST__
+#define HRT_ADDRESS_WIDTH	32		/* Surprise, this is a local property and even differs per platform */
+#else
+#define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property */
+#endif
+
+#if !defined(__KERNEL__) || (1==1)
+/* This interface is deprecated */
+#include "hrt/hive_types.h"
+#else  /* __KERNEL__ */
+#include <linux/types.h>
+
+#if HRT_ADDRESS_WIDTH==64
+typedef uint64_t			hrt_address;
+#elif HRT_ADDRESS_WIDTH==32
+typedef uint32_t			hrt_address;
+#else
+#error "system_local.h: HRT_ADDRESS_WIDTH must be one of {32,64}"
+#endif
+
+typedef uint32_t			hrt_vaddress;
+typedef uint32_t			hrt_data;
+#endif /* __KERNEL__ */
+
+/*
+ * Cell specific address maps
+ */
+#if HRT_ADDRESS_WIDTH==64
+
+#define GP_FIFO_BASE   ((hrt_address)0x0000000000090104)		/* This is NOT a base address */
+
+/* DDR */
+static const hrt_address DDR_BASE[N_DDR_ID] = {
+	0x0000000120000000ULL};
+
+/* ISP */
+static const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
+	0x0000000000020000ULL};
+
+static const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
+	0x0000000000200000ULL};
+
+static const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
+	0x0000000000000000ULL};
+
+static const hrt_address ISP_VAMEM_BASE[N_VAMEM_ID] = {
+	0x00000000001C0000ULL,
+	0x00000000001D0000ULL,
+	0x00000000001E0000ULL};
+
+static const hrt_address ISP_HMEM_BASE[N_HMEM_ID] = {
+        0x000000000001F0000ULL};
+
+static const hrt_address ISP_PMEM_BASE[N_ISP_ID] = {
+	0x00000000000180000ULL};
+
+/* SP */
+static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
+	0x0000000000010000ULL};
+
+static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
+	0x0000000000300000ULL};
+
+/* MMU */
+#if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+/*
+ * MMU0_ID: The data MMU
+ * MMU1_ID: The icache MMU
+ */
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	0x0000000000070000ULL,
+	0x00000000000A0000ULL};
+#elif defined (IS_ISP_2400A0_MAMOIADA_SYSTEM)
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	0x0000000000070000ULL};
+#else
+#error "system_local.h: SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+
+/* DMA */
+static const hrt_address DMA_BASE[N_DMA_ID] = {
+	0x0000000000040000ULL};
+
+/* IRQ */
+static const hrt_address IRQ_BASE[N_IRQ_ID] = {
+	0x0000000000000500ULL,
+	0x0000000000030A00ULL,
+	0x000000000008C000ULL,
+	0x0000000000090200ULL};
+/*
+	0x0000000000000500ULL};
+ */
+
+/* GDC */
+static const hrt_address GDC_BASE[N_GDC_ID] = {
+	0x0000000000050000ULL,
+	0x0000000000060000ULL};
+
+/* FIFO_MONITOR (not a subset of GP_DEVICE) */
+static const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
+	0x0000000000000000ULL};
+
+/*
+static const hrt_address GP_REGS_BASE[N_GP_REGS_ID] = {
+	0x0000000000000000ULL};
+
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	0x0000000000090000ULL};
+*/
+
+/* GP_DEVICE (single base for all separate GP_REG instances) */
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	0x0000000000000000ULL};
+
+/* GPIO */
+static const hrt_address GPIO_BASE[N_GPIO_ID] = {
+	0x0000000000000400ULL};
+
+/* TIMED_CTRL */
+static const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
+	0x0000000000000100ULL};
+
+
+/* INPUT_FORMATTER */
+static const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
+	0x0000000000030000ULL,
+	0x0000000000030200ULL,
+	0x0000000000030400ULL,
+	0x0000000000030600ULL}; /* memcpy() */
+
+/* INPUT_SYSTEM */
+static const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
+	0x0000000000080000ULL};
+/*	0x0000000000081000ULL, */ /* capture A */
+/*	0x0000000000082000ULL, */ /* capture B */
+/*	0x0000000000083000ULL, */ /* capture C */
+/*	0x0000000000084000ULL, */ /* Acquisition */
+/*	0x0000000000085000ULL, */ /* DMA */
+/*	0x0000000000089000ULL, */ /* ctrl */
+/*	0x000000000008A000ULL, */ /* GP regs */
+/*	0x000000000008B000ULL, */ /* FIFO */
+/*	0x000000000008C000ULL, */ /* IRQ */
+
+/* RX, the MIPI lane control regs start at offset 0 */
+static const hrt_address RX_BASE[N_RX_ID] = {
+	0x0000000000080100ULL};
+
+#elif HRT_ADDRESS_WIDTH==32
+
+#define GP_FIFO_BASE   ((hrt_address)0x00090104)		/* This is NOT a base address */
+
+/* DDR : Attention, this value not defined in 32-bit */
+static const hrt_address DDR_BASE[N_DDR_ID] = {
+	0x00000000UL};
+
+/* ISP */
+static const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
+	0x00020000UL};
+
+static const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
+	0x00200000UL};
+
+static const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
+	0x00000000UL};
+
+static const hrt_address ISP_VAMEM_BASE[N_VAMEM_ID] = {
+	0x001C0000UL,
+	0x001D0000UL,
+	0x001E0000UL};
+
+static const hrt_address ISP_HMEM_BASE[N_HMEM_ID] = {
+        0x001F0000UL};
+
+static const hrt_address ISP_PMEM_BASE[N_ISP_ID] = {
+	0x00180000UL};
+
+/* SP */
+static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
+	0x00010000UL};
+
+static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
+	0x00300000UL};
+
+/* MMU */
+#if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+/*
+ * MMU0_ID: The data MMU
+ * MMU1_ID: The icache MMU
+ */
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	0x00070000UL,
+	0x000A0000UL};
+#elif defined (IS_ISP_2400A0_MAMOIADA_SYSTEM)
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	0x00070000UL};
+#else
+#error "system_local.h: SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+
+/* DMA */
+static const hrt_address DMA_BASE[N_DMA_ID] = {
+	0x00040000UL};
+
+/* IRQ */
+static const hrt_address IRQ_BASE[N_IRQ_ID] = {
+	0x00000500UL,
+	0x00030A00UL,
+	0x0008C000UL,
+	0x00090200UL};
+/*
+	0x00000500UL};
+ */
+
+/* GDC */
+static const hrt_address GDC_BASE[N_GDC_ID] = {
+	0x00050000UL,
+	0x00060000UL};
+
+/* FIFO_MONITOR (not a subset of GP_DEVICE) */
+static const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
+	0x00000000UL};
+
+/*
+static const hrt_address GP_REGS_BASE[N_GP_REGS_ID] = {
+	0x00000000UL};
+
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	0x00090000UL};
+*/
+
+/* GP_DEVICE (single base for all separate GP_REG instances) */
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	0x00000000UL};
+
+/* GPIO */
+static const hrt_address GPIO_BASE[N_GPIO_ID] = {
+	0x00000400UL};
+
+/* TIMED_CTRL */
+static const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
+	0x00000100UL};
+
+
+/* INPUT_FORMATTER */
+static const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
+	0x00030000UL,
+	0x00030200UL,
+	0x00030400UL};
+/*	0x00030600UL, */ /* memcpy() */
+
+/* INPUT_SYSTEM */
+static const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
+	0x00080000UL};
+/*	0x00081000UL, */ /* capture A */
+/*	0x00082000UL, */ /* capture B */
+/*	0x00083000UL, */ /* capture C */
+/*	0x00084000UL, */ /* Acquisition */
+/*	0x00085000UL, */ /* DMA */
+/*	0x00089000UL, */ /* ctrl */
+/*	0x0008A000UL, */ /* GP regs */
+/*	0x0008B000UL, */ /* FIFO */
+/*	0x0008C000UL, */ /* IRQ */
+
+/* RX, the MIPI lane control regs start at offset 0 */
+static const hrt_address RX_BASE[N_RX_ID] = {
+	0x00080100UL};
+
+#else
+#error "system_local.h: HRT_ADDRESS_WIDTH must be one of {32,64}"
+#endif
+
+#endif /* __SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c
new file mode 100644
index 0000000..4a91822
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c
@@ -0,0 +1,63 @@
+#include "timed_ctrl.h"
+
+#ifndef __INLINE_TIMED_CTRL__
+#include "timed_ctrl_private.h"
+#endif /* __INLINE_TIMED_CTRL__ */
+
+#include "assert_support.h"
+
+void timed_ctrl_snd_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	hrt_address				addr,
+	hrt_data				value)
+{
+OP___assert(ID == TIMED_CTRL0_ID);
+OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
+
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, mask);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, condition);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, counter);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, addr);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, value);
+return;
+}
+
+/* pqiao TODO: make sure the following commands get
+	correct BASE address both for csim and android */
+
+void timed_ctrl_snd_sp_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const sp_ID_t			SP_ID,
+	hrt_address				offset,
+	hrt_data				value)
+{
+OP___assert(SP_ID < N_SP_ID);
+OP___assert(SP_DMEM_BASE[SP_ID] != (hrt_address)-1);
+
+	timed_ctrl_snd_commnd(ID, mask, condition, counter,
+				SP_DMEM_BASE[SP_ID]+offset, value);
+return;
+}
+
+void timed_ctrl_snd_gpio_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const gpio_ID_t			GPIO_ID,
+	hrt_address				offset,
+	hrt_data				value)
+{
+OP___assert(GPIO_ID < N_GPIO_ID);
+OP___assert(GPIO_BASE[GPIO_ID] != (hrt_address)-1);
+
+	timed_ctrl_snd_commnd(ID, mask, condition, counter,
+				GPIO_BASE[GPIO_ID]+offset, value);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h
new file mode 100644
index 0000000..c2b4264
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h
@@ -0,0 +1,6 @@
+#ifndef __TIMED_CTRL_LOCAL_H_INCLUDED__
+#define __TIMED_CTRL_LOCAL_H_INCLUDED__
+
+#include "timed_ctrl_global.h"
+
+#endif /* __TIMED_CTRL_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h
new file mode 100644
index 0000000..489a60b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h
@@ -0,0 +1,21 @@
+#ifndef __TIMED_CTRL_PRIVATE_H_INCLUDED__
+#define __TIMED_CTRL_PRIVATE_H_INCLUDED__
+
+#include "timed_ctrl_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_TIMED_CTRL_C void timed_ctrl_reg_store(
+	const timed_ctrl_ID_t	ID,
+	const unsigned int		reg,
+	const hrt_data			value)
+{
+OP___assert(ID < N_TIMED_CTRL_ID);
+OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
+	device_store_uint32(TIMED_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h
new file mode 100644
index 0000000..588e85a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h
@@ -0,0 +1,6 @@
+#ifndef __VAMEM_LOCAL_H_INCLUDED__
+#define __VAMEM_LOCAL_H_INCLUDED__
+
+#include "vamem_global.h"
+
+#endif /* __VAMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h
new file mode 100644
index 0000000..c4e78cc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h
@@ -0,0 +1,99 @@
+#ifndef __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
+#define __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
+
+#define IS_INPUT_FORMATTER_VERSION2
+#define IS_INPUT_SWITCH_VERSION2
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#include "if_defs.h"
+#include "str2mem_defs.h"
+#include "input_switch_2400_defs.h"
+#define _HIVE_INPUT_SWITCH_GET_FSYNC_REG_LSB(ch_id)        ((ch_id) * 3)
+
+#define HIVE_SWITCH_N_CHANNELS				4
+#define HIVE_SWITCH_N_FORMATTYPES			32
+#define HIVE_SWITCH_N_SWITCH_CODE			4
+#define HIVE_SWITCH_M_CHANNELS				0x00000003
+#define HIVE_SWITCH_M_FORMATTYPES			0x0000001f
+#define HIVE_SWITCH_M_SWITCH_CODE			0x00000003
+#define HIVE_SWITCH_M_FSYNC					0x00000007
+
+#define HIVE_SWITCH_ENCODE_FSYNC(x) \
+	(1U<<(((x)-1)&HIVE_SWITCH_M_CHANNELS))
+
+#define _HIVE_INPUT_SWITCH_GET_LUT_FIELD(reg, bit_index) \
+	(((reg) >> (bit_index)) & HIVE_SWITCH_M_SWITCH_CODE)
+#define _HIVE_INPUT_SWITCH_SET_LUT_FIELD(reg, bit_index, val) \
+	(((reg) & ~(HIVE_SWITCH_M_SWITCH_CODE<<(bit_index))) | (((hrt_data)(val)&HIVE_SWITCH_M_SWITCH_CODE)<<(bit_index)))
+#define _HIVE_INPUT_SWITCH_GET_FSYNC_FIELD(reg, bit_index) \
+	(((reg) >> (bit_index)) & HIVE_SWITCH_M_FSYNC)
+#define _HIVE_INPUT_SWITCH_SET_FSYNC_FIELD(reg, bit_index, val) \
+	(((reg) & ~(HIVE_SWITCH_M_FSYNC<<(bit_index))) | (((hrt_data)(val)&HIVE_SWITCH_M_FSYNC)<<(bit_index)))
+
+typedef struct input_formatter_cfg_s	input_formatter_cfg_t;
+
+/* Hardware registers */
+/*#define HIVE_IF_RESET_ADDRESS                   0x000*/ /* deprecated */
+#define HIVE_IF_START_LINE_ADDRESS              0x004
+#define HIVE_IF_START_COLUMN_ADDRESS            0x008
+#define HIVE_IF_CROPPED_HEIGHT_ADDRESS          0x00C
+#define HIVE_IF_CROPPED_WIDTH_ADDRESS           0x010
+#define HIVE_IF_VERTICAL_DECIMATION_ADDRESS     0x014
+#define HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS   0x018
+#define HIVE_IF_H_DEINTERLEAVING_ADDRESS        0x01C
+#define HIVE_IF_LEFTPADDING_WIDTH_ADDRESS       0x020
+#define HIVE_IF_END_OF_LINE_OFFSET_ADDRESS      0x024
+#define HIVE_IF_VMEM_START_ADDRESS_ADDRESS      0x028
+#define HIVE_IF_VMEM_END_ADDRESS_ADDRESS        0x02C
+#define HIVE_IF_VMEM_INCREMENT_ADDRESS          0x030
+#define HIVE_IF_YUV_420_FORMAT_ADDRESS          0x034
+#define HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS       0x038
+#define HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS       0x03C
+#define HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS     0x040
+#define HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS       0x044
+#define HIVE_IF_V_DEINTERLEAVING_ADDRESS        0x048
+/* Registers only for simulation */
+#define HIVE_IF_CRUN_MODE_ADDRESS               0x04C
+#define HIVE_IF_DUMP_OUTPUT_ADDRESS             0x050
+
+/* Follow the DMA syntax, "cmd" last */
+#define IF_PACK(val, cmd)             ((val & 0x0fff) | (cmd /*& 0xf000*/))
+
+#define HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS                   (_STR2MEM_SOFT_RESET_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS             (_STR2MEM_INPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS            (_STR2MEM_OUTPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS                 (_STR2MEM_BIT_SWAPPING_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS             (_STR2MEM_BLOCK_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS            (_STR2MEM_PACKET_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS  (_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS     (_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS                   (_STR2MEM_EN_STAT_UPDATE_ID * _STR2MEM_REG_ALIGN)
+
+/*
+ * This data structure is shared between host and SP
+ */
+struct input_formatter_cfg_s {
+	uint32_t	start_line;
+	uint32_t	start_column;
+	uint32_t	left_padding;
+	uint32_t	cropped_height;
+	uint32_t	cropped_width;
+	uint32_t	deinterleaving;
+	uint32_t	buf_vecs;
+	uint32_t	buf_start_index;
+	uint32_t	buf_increment;
+	uint32_t	buf_eol_offset;
+	uint32_t	is_yuv420_format;
+	uint32_t	block_no_reqs;
+};
+
+extern const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID];
+extern const hrt_data HIVE_IF_SRST_MASK[N_INPUT_FORMATTER_ID];
+extern const uint8_t HIVE_IF_SWITCH_CODE[N_INPUT_FORMATTER_ID];
+
+#endif /* __INPUT_FORMATTER_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h
new file mode 100644
index 0000000..2cb90d5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h
@@ -0,0 +1,145 @@
+#ifndef __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
+#define __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
+
+#define IS_INPUT_SYSTEM_VERSION_2
+
+//CSI reveiver has 3 ports.
+#define		N_CSI_PORTS (3) 
+//AM: Use previous define for this.
+ 
+//MIPI allows upto 4 channels.
+#define		N_CHANNELS  (4) 
+// 12KB = 256bit x 384 words
+#define		IB_CAPACITY_IN_WORDS (384)  
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+typedef enum {
+	MIPI_0LANE_CFG = 0,
+	MIPI_1LANE_CFG = 1,
+	MIPI_2LANE_CFG = 2,
+	MIPI_3LANE_CFG = 3,
+	MIPI_4LANE_CFG = 4
+} mipi_lane_cfg_t;
+
+typedef enum {
+	INPUT_SYSTEM_SOURCE_SENSOR = 0,
+	INPUT_SYSTEM_SOURCE_FIFO,
+	INPUT_SYSTEM_SOURCE_TPG,
+	INPUT_SYSTEM_SOURCE_PRBS,
+	INPUT_SYSTEM_SOURCE_MEMORY,
+	N_INPUT_SYSTEM_SOURCE
+} input_system_source_t;
+
+/* internal routing configuration */
+typedef enum {
+	INPUT_SYSTEM_DISCARD_ALL = 0,
+	INPUT_SYSTEM_CSI_BACKEND = 1,
+	INPUT_SYSTEM_INPUT_BUFFER = 2, 
+	INPUT_SYSTEM_MULTICAST = 3,
+	N_INPUT_SYSTEM_CONNECTION
+} input_system_connection_t;
+
+typedef enum {
+	INPUT_SYSTEM_MIPI_PORT0,
+	INPUT_SYSTEM_MIPI_PORT1,
+	INPUT_SYSTEM_MIPI_PORT2,
+	INPUT_SYSTEM_ACQUISITION_UNIT,
+	N_INPUT_SYSTEM_MULTIPLEX
+} input_system_multiplex_t;
+
+typedef enum {
+	INPUT_SYSTEM_SINK_MEMORY = 0,
+	INPUT_SYSTEM_SINK_ISP,
+	INPUT_SYSTEM_SINK_SP,
+	N_INPUT_SYSTEM_SINK
+} input_system_sink_t;
+
+typedef enum {
+	INPUT_SYSTEM_FIFO_CAPTURE = 0,
+	INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING,
+	INPUT_SYSTEM_SRAM_BUFFERING,
+	INPUT_SYSTEM_XMEM_BUFFERING,
+	INPUT_SYSTEM_XMEM_CAPTURE,
+	INPUT_SYSTEM_XMEM_ACQUIRE,
+	N_INPUT_SYSTEM_BUFFERING_MODE
+} buffering_mode_t;
+
+typedef struct input_system_cfg_s	input_system_cfg_t;
+typedef struct sync_generator_cfg_s	sync_generator_cfg_t;
+typedef struct tpg_cfg_s			tpg_cfg_t;
+typedef struct prbs_cfg_s			prbs_cfg_t;
+
+/* MW: uint16_t should be sufficient */
+struct input_system_cfg_s {
+	uint32_t	no_side_band;
+	uint32_t	fmt_type;
+	uint32_t	ch_id;
+	uint32_t	input_mode;
+};
+
+struct sync_generator_cfg_s {
+	uint32_t	width;
+	uint32_t	height;
+	uint32_t	hblank_cycles;
+	uint32_t	vblank_cycles;
+};
+
+/* MW: tpg & prbs are exclusive */
+struct tpg_cfg_s {
+	uint32_t	x_mask;
+	uint32_t	y_mask;
+	uint32_t	x_delta;
+	uint32_t	y_delta;
+	uint32_t	xy_mask;
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+struct prbs_cfg_s {
+	uint32_t	seed;
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+struct gpfifo_cfg_s {
+// TBD.
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+typedef struct gpfifo_cfg_s		gpfifo_cfg_t;
+
+//ALX:Commented out to pass the compilation.
+//typedef struct input_system_cfg_s input_system_cfg_t;
+
+struct ib_buffer_s {
+	uint32_t	mem_reg_size;
+	uint32_t	nof_mem_regs;
+	uint32_t	mem_reg_addr;
+};
+
+typedef struct ib_buffer_s	ib_buffer_t;
+
+struct csi_cfg_s {
+	uint32_t			csi_port;
+    buffering_mode_t	buffering_mode;
+	ib_buffer_t			csi_buffer;
+	ib_buffer_t			acquisition_buffer;
+	uint32_t			nof_xmem_buffers;
+};
+
+typedef struct csi_cfg_s	 csi_cfg_t;
+
+typedef enum {
+	INPUT_SYSTEM_CFG_FLAG_RESET	= 0,
+	INPUT_SYSTEM_CFG_FLAG_SET		= 1U << 0,
+	INPUT_SYSTEM_CFG_FLAG_BLOCKED	= 1U << 1,
+	INPUT_SYSTEM_CFG_FLAG_REQUIRED	= 1U << 2,
+	INPUT_SYSTEM_CFG_FLAG_CONFLICT	= 1U << 3	// To mark a conflicting configuration.
+} input_system_cfg_flag_t;
+
+typedef uint32_t input_system_config_flags_t; 
+
+#endif /* __INPUT_SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h
new file mode 100644
index 0000000..60e97f3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h
@@ -0,0 +1,29 @@
+#ifndef __IRQ_GLOBAL_H_INCLUDED__
+#define __IRQ_GLOBAL_H_INCLUDED__
+
+#define IS_IRQ_VERSION_2
+#define IS_IRQ_MAP_VERSION_2
+
+/* We cannot include the (hrt host ID) file defining the "CSS_RECEIVER" property without side effects */
+#ifndef HAS_NO_RX
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM) || defined(IS_ISP_2400A0_MAMOIADA_SYSTEM)
+#define CSS_RECEIVER testbench_isp_inp_sys_csi_receiver
+#include "hive_isp_css_irq_types_hrt.h"	/* enum	hrt_isp_css_irq */
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+#define CSS_RECEIVER testbench_isp_is_2400_inp_sys_csi_receiver
+#include "hive_isp_css_2401_irq_types_hrt.h"	/* enum	hrt_isp_css_irq */
+#else
+#error "irq_global.h: 2400_SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+#endif
+
+/* The IRQ is not mapped uniformly on its related interfaces */
+#define	IRQ_SW_CHANNEL_OFFSET	hrt_isp_css_irq_sw_pin_0
+
+typedef enum {
+	IRQ_SW_CHANNEL0_ID = hrt_isp_css_irq_sw_pin_0 - IRQ_SW_CHANNEL_OFFSET,
+	IRQ_SW_CHANNEL1_ID = hrt_isp_css_irq_sw_pin_1 - IRQ_SW_CHANNEL_OFFSET,
+	N_IRQ_SW_CHANNEL_ID
+} irq_sw_channel_id_t;
+
+#endif /* __IRQ_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h
new file mode 100644
index 0000000..d54d789
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h
@@ -0,0 +1,86 @@
+#ifndef __ISP_GLOBAL_H_INCLUDED__
+#define __ISP_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#if defined (HAS_ISP_2401_MAMOIADA)
+#define IS_ISP_2401_MAMOIADA
+
+#include "isp2401_mamoiada_params.h"
+#elif defined (HAS_ISP_2400_MAMOIADA)
+#define IS_ISP_2400_MAMOIADA
+
+#include "isp2400_mamoiada_params.h"
+#elif defined (HAS_ISP_2400A0_MAMOIADA)
+#define IS_ISP_2400A0_MAMOIADA
+
+#include "isp2400A0_mamoiada_params.h"
+#else
+#error "isp_global_h: ISP_2400_MAMOIDA must be one of {2400, 2400A0, 2401 }"
+#endif
+
+#define ISP_PMEM_WIDTH_LOG2		ISP_LOG2_PMEM_WIDTH
+#define ISP_PMEM_SIZE			ISP_PMEM_DEPTH
+
+#define ISP_NWAY_LOG2			6
+#define ISP_VEC_NELEMS_LOG2		ISP_NWAY_LOG2
+
+/* The number of data bytes in a vector disregarding the reduced precision */
+#define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
+
+/* ISP SC Registers */
+#define ISP_SC_REG				0x00
+#define ISP_PC_REG				0x07
+#define ISP_IRQ_READY_REG		0x00
+#define ISP_IRQ_CLEAR_REG		0x00
+
+/* ISP SC Register bits */
+#define ISP_RST_BIT				0x00
+#define ISP_START_BIT			0x01
+#define ISP_BREAK_BIT			0x02
+#define ISP_RUN_BIT				0x03
+#define ISP_BROKEN_BIT			0x04
+#define ISP_IDLE_BIT			0x05     /* READY */
+#define ISP_STALLING_BIT		0x07
+#define ISP_IRQ_CLEAR_BIT		0x08
+#define ISP_IRQ_READY_BIT		0x0A
+#define ISP_SLEEPING_BIT		0x0B     /* SLEEPING_IRQ_MASK */
+
+/* ISP Register bits */
+#define ISP_CTRL_SINK_BIT		0x00
+#define ISP_PMEM_SINK_BIT		0x01
+#define ISP_DMEM_SINK_BIT		0x02
+#define ISP_FIFO0_SINK_BIT		0x03
+#define ISP_FIFO1_SINK_BIT		0x04
+#define ISP_FIFO2_SINK_BIT		0x05
+#define ISP_FIFO3_SINK_BIT		0x06
+#define ISP_FIFO4_SINK_BIT		0x07
+#define ISP_FIFO5_SINK_BIT		0x08
+#define ISP_FIFO6_SINK_BIT		0x09
+#define ISP_VMEM_SINK_BIT		0x0A
+#define ISP_VAMEM1_SINK_BIT		0x0B
+#define ISP_VAMEM2_SINK_BIT		0x0C
+#define ISP_VAMEM3_SINK_BIT		0x0D
+#define ISP_HMEM_SINK_BIT		0x0E
+
+#define ISP_CTRL_SINK_REG		0x08
+#define ISP_PMEM_SINK_REG		0x08
+#define ISP_DMEM_SINK_REG		0x08
+#define ISP_FIFO0_SINK_REG		0x08
+#define ISP_FIFO1_SINK_REG		0x08
+#define ISP_FIFO2_SINK_REG		0x08
+#define ISP_FIFO3_SINK_REG		0x08
+#define ISP_FIFO4_SINK_REG		0x08
+#define ISP_FIFO5_SINK_REG		0x08
+#define ISP_FIFO6_SINK_REG		0x08
+#define ISP_VMEM_SINK_REG		0x08
+#define ISP_VAMEM1_SINK_REG		0x08
+#define ISP_VAMEM2_SINK_REG		0x08
+#define ISP_VAMEM3_SINK_REG		0x08
+#define ISP_HMEM_SINK_REG		0x08
+
+#endif /* __ISP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h
new file mode 100644
index 0000000..073e978
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h
@@ -0,0 +1,8 @@
+#ifndef __MMU_GLOBAL_H_INCLUDED__
+#define __MMU_GLOBAL_H_INCLUDED__
+
+#define IS_MMU_VERSION_2
+
+#include <mmu_defs.h>
+
+#endif /* __MMU_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/program_load/program_load.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/program_load/program_load.c
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/program_load/program_load.c
@@ -0,0 +1 @@
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h
new file mode 100644
index 0000000..4cd6ab8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h
@@ -0,0 +1,21 @@
+#ifndef __RESOURCE_GLOBAL_H_INCLUDED__
+#define __RESOURCE_GLOBAL_H_INCLUDED__
+
+#define IS_RESOURCE_VERSION_1
+
+typedef enum {
+	DMA_CHANNEL_RESOURCE_TYPE,
+	IRQ_CHANNEL_RESOURCE_TYPE,
+	MEM_SECTION_RESOURCE_TYPE,
+	N_RESOURCE_TYPE
+} resource_type_ID_t;
+
+typedef enum {
+	PERMANENT_RESOURCE_RESERVATION,
+	PERSISTENT_RESOURCE_RESERVATION,
+	DEDICTATED_RESOURCE_RESERVATION,
+	SHARED_RESOURCE_RESERVATION,
+	N_RESOURCE_RESERVATION
+} resource_reservation_t;
+
+#endif /* __RESOURCE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h
new file mode 100644
index 0000000..bc0dc31
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h
@@ -0,0 +1,80 @@
+#ifndef __SP_GLOBAL_H_INCLUDED__
+#define __SP_GLOBAL_H_INCLUDED__
+
+#if defined(HAS_SP_2401)
+#define IS_SP_2401
+/* 2401 uses 2400 */
+#include <scalar_processor_2400_params.h>
+#elif defined(HAS_SP_2400)
+#define IS_SP_2400
+
+#include <scalar_processor_2400_params.h>
+#elif defined(HAS_SP_2400A0)
+#define IS_SP_2400A0
+
+#include <scalar_processor_2400_params.h>
+#else
+#error "sp_global.h: SP_2400 must be one of {2400, 2400A0, 2401 }"
+#endif
+
+#define SP_PMEM_WIDTH_LOG2		SP_PMEM_LOG_WIDTH_BITS
+#define SP_PMEM_SIZE			SP_PMEM_DEPTH
+
+#define SP_DMEM_SIZE			0x4000
+
+/* SP Registers */
+#define SP_PC_REG				0x09
+#define SP_SC_REG				0x00
+#define SP_START_ADDR_REG		0x01
+#define SP_ICACHE_ADDR_REG		0x05
+#define SP_IRQ_READY_REG		0x00
+#define SP_IRQ_CLEAR_REG		0x00
+#define SP_ICACHE_INV_REG		0x00
+#define SP_CTRL_SINK_REG		0x0A
+
+/* SP Register bits */
+#define SP_RST_BIT				0x00
+#define SP_START_BIT			0x01
+#define SP_BREAK_BIT			0x02
+#define SP_RUN_BIT				0x03
+#define SP_BROKEN_BIT			0x04
+#define SP_IDLE_BIT				0x05     /* READY */
+#define SP_STALLING_BIT			0x07
+#define SP_IRQ_CLEAR_BIT		0x08
+#define SP_IRQ_READY_BIT		0x0A
+#define SP_SLEEPING_BIT			0x0B     /* SLEEPING_IRQ_MASK */
+
+#define SP_ICACHE_INV_BIT		0x0C
+#define SP_IPREFETCH_EN_BIT		0x0D
+
+#define SP_FIFO0_SINK_BIT		0x00
+#define SP_FIFO1_SINK_BIT		0x01
+#define SP_FIFO2_SINK_BIT		0x02
+#define SP_FIFO3_SINK_BIT		0x03
+#define SP_FIFO4_SINK_BIT		0x04
+#define SP_FIFO5_SINK_BIT		0x05
+#define SP_FIFO6_SINK_BIT		0x06
+#define SP_FIFO7_SINK_BIT		0x07
+#define SP_FIFO8_SINK_BIT		0x08
+#define SP_FIFO9_SINK_BIT		0x09
+#define SP_FIFOA_SINK_BIT		0x0A
+#define SP_DMEM_SINK_BIT		0x0B
+#define SP_CTRL_MT_SINK_BIT		0x0C
+#define SP_ICACHE_MT_SINK_BIT	0x0D
+
+#define SP_FIFO0_SINK_REG		0x0A
+#define SP_FIFO1_SINK_REG		0x0A
+#define SP_FIFO2_SINK_REG		0x0A
+#define SP_FIFO3_SINK_REG		0x0A
+#define SP_FIFO4_SINK_REG		0x0A
+#define SP_FIFO5_SINK_REG		0x0A
+#define SP_FIFO6_SINK_REG		0x0A
+#define SP_FIFO7_SINK_REG		0x0A
+#define SP_FIFO8_SINK_REG		0x0A
+#define SP_FIFO9_SINK_REG		0x0A
+#define SP_FIFOA_SINK_REG		0x0A
+#define SP_DMEM_SINK_REG		0x0A
+#define SP_CTRL_MT_SINK_REG		0x0A
+#define SP_ICACHE_MT_SINK_REG	0x0A
+
+#endif /* __SP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h
new file mode 100644
index 0000000..bc4e233
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h
@@ -0,0 +1,286 @@
+#ifndef __SYSTEM_GLOBAL_H_INCLUDED__
+#define __SYSTEM_GLOBAL_H_INCLUDED__
+
+#include <hive_isp_css_defs.h>
+
+/*
+ * The longest allowed (uninteruptible) bus transfer, does not
+ * take stalling into account
+ */
+#define HIVE_ISP_MAX_BURST_LENGTH	1024
+
+/*
+ * Create a list of HAS and IS properties that defines the system
+ *
+ * The configuration assumes the following
+ * - The system is hetereogeneous; Multiple cells and devices classes
+ * - The cell and device instances are homogeneous, each device type
+ *   belongs to the same class
+ * - Device instances supporting a subset of the class capabilities are
+ *   allowed
+ *
+ * We could manage different device classes through the enumerated
+ * lists (C) or the use of classes (C++), but that is presently not
+ * fully supported
+ *
+ * N.B. the 3 input formatters are of 2 different classess
+ */
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define IS_ISP_2400_SYSTEM
+/*
+ * Since the 2400A0 system is temporary, we use the same DLI for
+ * both systems. The difference is only visible in the name of
+ * cell specififc include files for the ISP and SP
+ *
+ * Since this file is visible everywhere and the system definition
+ * macros are not, detect the separate definitions for {host, SP, ISP}
+ *
+ * The 2401 system has the nice property that it uses a vanilla 2400 SP
+ * so the SP will believe it is a 2400 system rather than 2401...
+ */
+//#if defined(SYSTEM_hive_isp_css_2401_system) || defined(__isp2401_mamoiada) || defined(__scalar_processor_2401)
+#if defined(SYSTEM_hive_isp_css_2401_system) || defined(__isp2401_mamoiada)
+#define IS_ISP_2401_MAMOIADA_SYSTEM
+#define HAS_ISP_2401_MAMOIADA
+#define HAS_SP_2400
+//#elif defined(SYSTEM_hive_isp_css_2400_system) || defined(__isp2400_mamoiada) || defined(__scalar_processor_2400)
+#elif defined(SYSTEM_hive_isp_css_2400_system) || defined(__isp2400_mamoiada)
+#define IS_ISP_2400_MAMOIADA_SYSTEM
+#define HAS_ISP_2400_MAMOIADA
+#define HAS_SP_2400
+//#elif defined(SYSTEM_hive_isp_css_2400A0_system) || defined(__isp2400A0_mamoiada) || defined(__scalar_processor_2400A0)
+#elif defined(SYSTEM_hive_isp_css_2400A0_system) || defined(__isp2400A0_mamoiada)
+#define IS_ISP_2400A0_MAMOIADA_SYSTEM
+#define HAS_ISP_2400A0_MAMOIADA
+#define HAS_SP_2400A0
+#else
+#error "system_global.h: 2400_SYSTEM must be one of {2400, 2400A0, 2401 }"
+#endif
+
+#define HAS_MMU_VERSION_2
+#define HAS_DMA_VERSION_2
+#define HAS_GDC_VERSION_2
+#define HAS_VAMEM_VERSION_2
+#define HAS_HMEM_VERSION_1
+#define HAS_BAMEM_VERSION_2
+#define HAS_IRQ_VERSION_2
+#define HAS_IRQ_MAP_VERSION_2
+#define HAS_INPUT_FORMATTER_VERSION_2
+/* 2401: HAS_INPUT_SYSTEM_VERSION_3 */
+#define HAS_INPUT_SYSTEM_VERSION_2
+#define HAS_BUFFERED_SENSOR
+#define HAS_FIFO_MONITORS_VERSION_2
+/* #define HAS_GP_REGS_VERSION_2 */
+#define HAS_GP_DEVICE_VERSION_2
+#define HAS_GPIO_VERSION_1
+#define HAS_TIMED_CTRL_VERSION_1
+#define HAS_RX_VERSION_2
+
+/*
+ * Semi global. "HRT" is accessible from SP, but the HRT types do not fully apply
+ */
+#define HRT_VADDRESS_WIDTH	32
+//#define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property*/
+#define HRT_DATA_WIDTH		32
+
+#define SIZEOF_HRT_REG		(HRT_DATA_WIDTH>>3)
+#define HIVE_ISP_CTRL_DATA_BYTES (HIVE_ISP_CTRL_DATA_WIDTH/8)
+
+/* The main bus connecting all devices */
+#define HRT_BUS_WIDTH		HIVE_ISP_CTRL_DATA_WIDTH
+#define HRT_BUS_BYTES		HIVE_ISP_CTRL_DATA_BYTES
+
+typedef uint32_t			hrt_bus_align_t;
+
+/*
+ * Enumerate the devices, device access through the API is by ID, through the DLI by address
+ * The enumerator terminators are used to size the wiring arrays and as an exception value.
+ */
+typedef enum {
+	DDR0_ID = 0,
+	N_DDR_ID
+} ddr_ID_t;
+
+typedef enum {
+	ISP0_ID = 0,
+	N_ISP_ID
+} isp_ID_t;
+
+typedef enum {
+	SP0_ID = 0,
+	N_SP_ID
+} sp_ID_t;
+
+#if defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+typedef enum {
+	MMU0_ID = 0,
+	MMU1_ID,
+	N_MMU_ID
+} mmu_ID_t;
+#elif defined (IS_ISP_2400_MAMOIADA_SYSTEM)
+typedef enum {
+	MMU0_ID = 0,
+	MMU1_ID,
+	N_MMU_ID
+} mmu_ID_t;
+#elif defined (IS_ISP_2400A0_MAMOIADA_SYSTEM)
+typedef enum {
+	MMU0_ID = 0,
+	N_MMU_ID
+} mmu_ID_t;
+#else
+#error "system_global.h: SYSTEM must be one of {2400, 2400A0, 2401}"
+#endif
+
+typedef enum {
+	DMA0_ID = 0,
+	N_DMA_ID
+} dma_ID_t;
+
+typedef enum {
+	GDC0_ID = 0,
+	GDC1_ID,
+	N_GDC_ID
+} gdc_ID_t;
+
+#define N_GDC_ID_CPP 2 // this extra define is needed because we want to use it also in the preprocessor, and that doesn't work with enums.
+
+typedef enum {
+	VAMEM0_ID = 0,
+	VAMEM1_ID,
+	VAMEM2_ID,
+	N_VAMEM_ID
+} vamem_ID_t;
+
+typedef enum {
+	BAMEM0_ID = 0,
+	N_BAMEM_ID
+} bamem_ID_t;
+
+typedef enum {
+	HMEM0_ID = 0,
+	N_HMEM_ID
+} hmem_ID_t;
+
+/*
+typedef enum {
+	IRQ0_ID = 0,
+	N_IRQ_ID
+} irq_ID_t;
+*/
+
+typedef enum {
+	IRQ0_ID = 0,	// GP IRQ block
+	IRQ1_ID,		// Input formatter
+	IRQ2_ID,		// input system
+	IRQ3_ID,		// input selector
+	N_IRQ_ID
+} irq_ID_t;
+
+typedef enum {
+	FIFO_MONITOR0_ID = 0,
+	N_FIFO_MONITOR_ID
+} fifo_monitor_ID_t;
+
+/*
+ * Deprecated: Since all gp_reg instances are different
+ * and put in the address maps of other devices we cannot
+ * enumerate them as that assumes the instrances are the
+ * same.
+ * 
+ * We define a single GP_DEVICE containing all gp_regs
+ * w.r.t. a single base address
+ *
+typedef enum {
+	GP_REGS0_ID = 0,
+	N_GP_REGS_ID
+} gp_regs_ID_t;
+ */
+typedef enum {
+	GP_DEVICE0_ID = 0,
+	N_GP_DEVICE_ID
+} gp_device_ID_t;
+
+typedef enum {
+	GPIO0_ID = 0,
+	N_GPIO_ID
+} gpio_ID_t;
+
+typedef enum {
+	TIMED_CTRL0_ID = 0,
+	N_TIMED_CTRL_ID
+} timed_ctrl_ID_t;
+
+typedef enum {
+	INPUT_FORMATTER0_ID = 0,
+	INPUT_FORMATTER1_ID,
+	INPUT_FORMATTER2_ID,
+	INPUT_FORMATTER3_ID,
+	N_INPUT_FORMATTER_ID
+} input_formatter_ID_t;
+
+/* The IF RST is outside the IF */
+#define INPUT_FORMATTER0_SRST_OFFSET	0x0824
+#define INPUT_FORMATTER1_SRST_OFFSET	0x0624
+#define INPUT_FORMATTER2_SRST_OFFSET	0x0424
+#define INPUT_FORMATTER3_SRST_OFFSET	0x0224
+
+#define INPUT_FORMATTER0_SRST_MASK		0x0001
+#define INPUT_FORMATTER1_SRST_MASK		0x0002
+#define INPUT_FORMATTER2_SRST_MASK		0x0004
+#define INPUT_FORMATTER3_SRST_MASK		0x0008
+
+typedef enum {
+	INPUT_SYSTEM0_ID = 0,
+	N_INPUT_SYSTEM_ID
+} input_system_ID_t;
+
+typedef enum {
+	RX0_ID = 0,
+	N_RX_ID
+} rx_ID_t;
+
+typedef enum {
+	MIPI_PORT0_ID = 0,
+	MIPI_PORT1_ID,
+	MIPI_PORT2_ID,
+	N_MIPI_PORT_ID
+} mipi_port_ID_t;
+
+#define	N_RX_CHANNEL_ID		4
+
+/* Generic port enumeration with an internal port type ID */
+typedef enum {
+	CSI_PORT0_ID = 0,
+	CSI_PORT1_ID,
+	CSI_PORT2_ID,
+	TPG_PORT0_ID,
+	PRBS_PORT0_ID,
+	FIFO_PORT0_ID,
+	MEMORY_PORT0_ID,
+	N_INPUT_PORT_ID
+} input_port_ID_t;
+
+typedef enum {
+	CAPTURE_UNIT0_ID = 0,
+	CAPTURE_UNIT1_ID,
+	CAPTURE_UNIT2_ID,
+	ACQUISITION_UNIT0_ID,
+	DMA_UNIT0_ID,
+	CTRL_UNIT0_ID,
+	GPREGS_UNIT0_ID,
+	FIFO_UNIT0_ID,
+	IRQ_UNIT0_ID,
+	N_SUB_SYSTEM_ID
+} sub_system_ID_t;
+
+#define	N_CAPTURE_UNIT_ID		3
+#define	N_ACQUISITION_UNIT_ID	1
+#define	N_CTRL_UNIT_ID			1
+
+#endif /* __SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h
new file mode 100644
index 0000000..68c3f45
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h
@@ -0,0 +1,37 @@
+#ifndef __TIMED_CTRL_GLOBAL_H_INCLUDED__
+#define __TIMED_CTRL_GLOBAL_H_INCLUDED__
+
+#define IS_TIMED_CTRL_VERSION_1
+
+#include <timed_controller_defs.h>
+
+/* order of the input bits for the timed controller */
+#define HIVE_TIMED_CTRL_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_TIMED_CTRL_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_TIMED_CTRL_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_TIMED_CTRL_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_TIMED_CTRL_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_TIMED_CTRL_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_TIMED_CTRL_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_TIMED_CTRL_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_TIMED_CTRL_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_TIMED_CTRL_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_TIMED_CTRL_SP_BIT_ID                              10
+#define HIVE_TIMED_CTRL_ISP_BIT_ID                             11
+#define HIVE_TIMED_CTRL_MIPI_RCV_IRQ_BIT_ID                    12
+#define HIVE_TIMED_CTRL_IFMT_BIT_ID                            13
+#define HIVE_TIMED_CTRL_IFMT_B_BIT_ID                          14
+#define HIVE_TIMED_CTRL_IFMT_SEC_BIT_ID                        15
+#define HIVE_TIMED_CTRL_MEM_CPY_BIT_ID                         16
+#define HIVE_TIMED_CTRL_MIPI_FIFO_FULL_BIT_ID                  17
+#define HIVE_TIMED_CTRL_MIPI_SOF_BIT_ID                        18
+#define HIVE_TIMED_CTRL_MIPI_EOF_BIT_ID                        19
+#define HIVE_TIMED_CTRL_MIPI_SOL_BIT_ID                        20
+#define HIVE_TIMED_CTRL_MIPI_EOL_BIT_ID                        21
+#define HIVE_TIMED_CTRL_SYNC_GEN_SOF_BIT_ID                    22
+#define HIVE_TIMED_CTRL_SYNC_GEN_EOF_BIT_ID                    23
+#define HIVE_TIMED_CTRL_SYNC_GEN_SOL_BIT_ID                    24
+#define HIVE_TIMED_CTRL_SYNC_GEN_EOL_BIT_ID                    25
+
+
+#endif /* __TIMED_CTRL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h
new file mode 100644
index 0000000..d5b79c5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h
@@ -0,0 +1,24 @@
+#ifndef __VAMEM_GLOBAL_H_INCLUDED__
+#define __VAMEM_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define IS_VAMEM_VERSION_2
+
+/* (log) stepsize of linear interpolation */
+#define VAMEM_INTERP_STEP_LOG2	4
+#define VAMEM_INTERP_STEP		(1<<VAMEM_INTERP_STEP_LOG2)
+/* (physical) size of the tables */
+#define VAMEM_TABLE_UNIT_SIZE	((1<<(ISP_VAMEM_ADDRESS_BITS-VAMEM_INTERP_STEP_LOG2)) + 1)
+/* (logical) size of the tables */
+#define VAMEM_TABLE_UNIT_STEP	((VAMEM_TABLE_UNIT_SIZE-1)<<1)
+/* Number of tables */
+#define VAMEM_TABLE_UNIT_COUNT	(ISP_VAMEM_DEPTH/VAMEM_TABLE_UNIT_STEP)
+
+typedef uint16_t				vamem_data_t;
+
+#endif /* __VAMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/addr_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/addr_support.h
new file mode 100644
index 0000000..5af6ac2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/addr_support.h
@@ -0,0 +1,15 @@
+#ifndef __ADDR_SUPPORT_H_INCLUDED__
+#define __ADDR_SUPPORT_H_INCLUDED__
+
+/*
+ * Compute the byte address offset of a struct or array member from the base struct base
+ *
+ * Note:
+ *	- The header defining the type "T" must be included
+ *	- This macro works on all cells, but not necessarily with the same output
+ *	- Works for arrays, structs, arrays of structs, arrays in structs etc.
+ */
+#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
+#define OFFSET_OF(T, x) offsetof(T, x)
+
+#endif /* __ADDR_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h
new file mode 100644
index 0000000..e0cae12
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h
@@ -0,0 +1,51 @@
+#ifndef __ASSERT_SUPPORT_H_INCLUDED__
+#define __ASSERT_SUPPORT_H_INCLUDED__
+
+#if defined(_MSC_VER)
+#include "assert.h"
+#define OP___assert(cnd) assert(cnd)
+#elif defined(__HIVECC)
+
+/*
+ * Enabling assert on cells has too many side effects, it should
+ * by default be limited to the unsched CSIM mode, or to only
+ * controller type processors. Presently there are not controls
+ * in place for that
+ */
+/* #define OP___assert(cnd) OP___csim_assert(cnd) */
+//#if defined(__SP)
+//#define OP___assert(cnd) OP___csim_assert(cnd)
+//#else
+#define OP___assert(cnd) ((void)0)
+//#endif
+
+#elif defined(__KERNEL__) /* a.o. Android builds */
+
+#include "sh_css_debug.h"
+#define __symbol2value( x ) #x
+#define __symbol2string( x ) __symbol2value( x )
+#define assert( expression )                                            \
+	do {                                                            \
+		if (!(expression))                                      \
+			sh_css_dtrace(SH_DBG_ERROR, "%s",               \
+				"Assertion failed: " #expression        \
+				  ", file " __FILE__                    \
+				  ", line " __symbol2string( __LINE__ ) \
+				  ".\n" );                              \
+	} while (0)
+
+#define OP___assert(cnd) assert(cnd)
+
+#elif defined(__FIST__)
+
+#include "assert.h"
+#define OP___assert(cnd) assert(cnd)
+
+#elif defined(__GNUC__)
+#include "assert.h"
+#define OP___assert(cnd) assert(cnd)
+#else /* default is for unknown environments */
+#define assert(cnd) ((void)0)
+#endif
+
+#endif /* __ASSERT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/csc_kernel.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/csc_kernel.h
new file mode 100644
index 0000000..ce861d8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/csc_kernel.h
@@ -0,0 +1,36 @@
+#ifndef __CSC_KERNEL_H_INCLUDED__
+#define __CSC_KERNEL_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the CSC kernel.
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "csc_kernel_local.h"
+
+#ifdef __ON__
+
+#ifndef __INLINE_CSC_KERNEL__
+#define STORAGE_CLASS_CSC_KERNEL_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_CSC_KERNEL_C 
+#include "csc_kernel_public.h"
+#else  /* __INLINE_CSC_KERNEL__ */
+#define STORAGE_CLASS_CSC_KERNEL_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_CSC_KERNEL_C STORAGE_CLASS_INLINE
+#include "csc_kernel_private.h"
+#endif /* __INLINE_CSC_KERNEL__ */
+
+#endif /* __ON__ */
+
+#endif /* __CSC_KERNEL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h
new file mode 100644
index 0000000..3eb12c9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h
@@ -0,0 +1,34 @@
+#ifndef __DEBUG_H_INCLUDED__
+#define __DEBUG_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "debug_local.h"
+
+#ifndef __INLINE_DEBUG__
+#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_DEBUG_C 
+#include "debug_public.h"
+#else  /* __INLINE_DEBUG__ */
+#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_DEBUG_C STORAGE_CLASS_INLINE
+#include "debug_private.h"
+#endif /* __INLINE_DEBUG__ */
+
+#endif /* __DEBUG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h
new file mode 100644
index 0000000..fef8138
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h
@@ -0,0 +1,171 @@
+#ifndef __DEVICE_ACCESS_H_INCLUDED__
+#define __DEVICE_ACCESS_H_INCLUDED__
+
+/*!
+ * \brief
+ * Define the public interface for physical system
+ * access functions to SRAM and registers. Access
+ * types are limited to those defined in <stdint.h>
+ * All accesses are aligned
+ *
+ * The address representation is private to the system
+ * and represented as/stored in "hrt_address".
+ *
+ * The system global address can differ by an offset;
+ * The device base address. This offset must be added
+ * by the implementation of the access function
+ *
+ * "store" is a transfer to the device
+ * "load" is a transfer from the device
+ */
+
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#include "stddef.h"
+
+/*
+ * User provided file that defines the system address types:
+ *	- hrt_address	a type that can hold the (sub)system address range
+ */
+#include "system_types.h"
+/*
+ * We cannot assume that the global system address size is the size of
+ * a pointer because a (say) 64-bit host can be simulated in a 32-bit
+ * environment. Only if the host environment is modelled as on the target
+ * we could use a pointer. Even then, prototyping may need to be done
+ * before the target environment is available. AS we cannot wait for that
+ * we are stuck with integer addresses
+ */
+
+/*typedef	char *sys_address;*/
+typedef	hrt_address		sys_address;
+
+/*! Set the (sub)system base address
+
+ \param	base_addr[in]		The offset on which the (sub)system is located
+							in the global address map
+
+ \return none,
+ */
+extern void device_set_base_address(
+	const sys_address		base_addr);
+
+
+/*! Get the (sub)system base address
+
+ \return base_address,
+ */
+extern sys_address device_get_base_address(void);
+
+/*! Read an 8-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint8_t device_load_uint8(
+	const hrt_address		addr);
+
+/*! Read a 16-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint16_t device_load_uint16(
+	const hrt_address		addr);
+
+/*! Read a 32-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint32_t device_load_uint32(
+	const hrt_address		addr);
+
+/*! Read a 64-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint64_t device_load_uint64(
+	const hrt_address		addr);
+
+/*! Write an 8-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void device_store_uint8(
+	const hrt_address		addr,
+	const uint8_t			data);
+
+/*! Write a 16-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void device_store_uint16(
+	const hrt_address		addr,
+	const uint16_t			data);
+
+/*! Write a 32-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void device_store_uint32(
+	const hrt_address		addr,
+	const uint32_t			data);
+
+/*! Write a 64-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void device_store_uint64(
+	const hrt_address		addr,
+	const uint64_t			data);
+
+/*! Read an array of bytes from device registers or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[out]			pointer to the destination array
+ \param	size[in]			number of bytes to read
+
+ \return none
+ */
+extern void device_load(
+	const hrt_address		addr,
+	void					*data,
+	const size_t			size);
+
+/*! Write an array of bytes to device registers or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			pointer to the source array
+ \param	size[in]			number of bytes to write
+
+ \return none
+ */
+extern void device_store(
+	const hrt_address		addr,
+	const void				*data,
+	const size_t			size);
+
+#endif /* __DEVICE_ACCESS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h
new file mode 100644
index 0000000..0c6815a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h
@@ -0,0 +1,34 @@
+#ifndef __DMA_H_INCLUDED__
+#define __DMA_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "dma_local.h"
+
+#ifndef __INLINE_DMA__
+#define STORAGE_CLASS_DMA_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_DMA_C 
+#include "dma_public.h"
+#else  /* __INLINE_DMA__ */
+#define STORAGE_CLASS_DMA_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_DMA_C STORAGE_CLASS_INLINE
+#include "dma_private.h"
+#endif /* __INLINE_DMA__ */
+
+#endif /* __DMA_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/event.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/event.h
new file mode 100644
index 0000000..5162ea1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/event.h
@@ -0,0 +1,33 @@
+#ifndef __EVENT_H_INCLUDED__
+#define __EVENT_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the IRQ device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "event_local.h"
+
+#ifndef __INLINE_EVENT__
+#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_EVENT_C 
+#include "event_public.h"
+#else  /* __INLINE_EVENT__ */
+#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_EVENT_C STORAGE_CLASS_INLINE
+#include "event_private.h"
+#endif /* __INLINE_EVENT__ */
+
+#endif /* __EVENT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h
new file mode 100644
index 0000000..998c794
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h
@@ -0,0 +1,33 @@
+#ifndef __FIFO_MONITOR_H_INCLUDED__
+#define __FIFO_MONITOR_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "fifo_monitor_local.h"
+
+#ifndef __INLINE_FIFO_MONITOR__
+#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_FIFO_MONITOR_C 
+#include "fifo_monitor_public.h"
+#else  /* __INLINE_FIFO_MONITOR__ */
+#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_FIFO_MONITOR_C STORAGE_CLASS_INLINE
+#include "fifo_monitor_private.h"
+#endif /* __INLINE_FIFO_MONITOR__ */
+
+#endif /* __FIFO_MONITOR_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h
new file mode 100644
index 0000000..d6582f0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h
@@ -0,0 +1,35 @@
+#ifndef __GDC_DEVICE_H_INCLUDED__
+#define __GDC_DEVICE_H_INCLUDED__
+
+/* The file gdc.h already exists */
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the GDC device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gdc_local.h"
+
+#ifndef __INLINE_GDC__
+#define STORAGE_CLASS_GDC_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GDC_C 
+#include "gdc_public.h"
+#else  /* __INLINE_GDC__ */
+#define STORAGE_CLASS_GDC_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GDC_C STORAGE_CLASS_INLINE
+#include "gdc_private.h"
+#endif /* __INLINE_GDC__ */
+
+#endif /* __GDC_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h
new file mode 100644
index 0000000..9c6a2b8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h
@@ -0,0 +1,33 @@
+#ifndef __GP_DEVICE_H_INCLUDED__
+#define __GP_DEVICE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gp_device_local.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GP_DEVICE_C 
+#include "gp_device_public.h"
+#else  /* __INLINE_GP_DEVICE__ */
+#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GP_DEVICE_C STORAGE_CLASS_INLINE
+#include "gp_device_private.h"
+#endif /* __INLINE_GP_DEVICE__ */
+
+#endif /* __GP_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h
new file mode 100644
index 0000000..4eb5697
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h
@@ -0,0 +1,33 @@
+#ifndef __GPIO_H_INCLUDED__
+#define __GPIO_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gpio_local.h"
+
+#ifndef __INLINE_GPIO__
+#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GPIO_C 
+#include "gpio_public.h"
+#else  /* __INLINE_GPIO__ */
+#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GPIO_C STORAGE_CLASS_INLINE
+#include "gpio_private.h"
+#endif /* __INLINE_GPIO__ */
+
+#endif /* __GPIO_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h
new file mode 100644
index 0000000..81decf6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h
@@ -0,0 +1,33 @@
+#ifndef __HMEM_H_INCLUDED__
+#define __HMEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the HMEM device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "hmem_local.h"
+
+#ifndef __INLINE_HMEM__
+#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_HMEM_C 
+#include "hmem_public.h"
+#else  /* __INLINE_HMEM__ */
+#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_HMEM_C STORAGE_CLASS_INLINE
+#include "hmem_private.h"
+#endif /* __INLINE_HMEM__ */
+
+#endif /* __HMEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h
new file mode 100644
index 0000000..d680327
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h
@@ -0,0 +1,88 @@
+#ifndef __DEBUG_PUBLIC_H_INCLUDED__
+#define __DEBUG_PUBLIC_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include "stdbool.h"
+#endif
+
+#include "system_types.h"
+
+/*! brief
+ *
+ * Simple queuing trace buffer for debug data
+ * instantiatable in SP DMEM
+ *
+ * The buffer has a remote and and a local store
+ * which contain duplicate data (when in sync).
+ * The buffers are automatically synched when the
+ * user dequeues, or manualy using the synch function
+ *
+ * An alternative (storage efficient) implementation
+ * could manage the buffers to contain unique data
+ *
+ * The buffer empty status is computed from local
+ * state which does not reflect the presence of data
+ * in the remote buffer (unless the alternative
+ * implementation is followed)
+ */
+
+typedef struct debug_data_s		debug_data_t;
+typedef struct debug_data_ddr_s	debug_data_ddr_t;
+
+extern debug_data_t				*debug_data_ptr;
+extern hrt_address				debug_buffer_address;
+extern hrt_vaddress				debug_buffer_ddr_address;
+
+/*! Check the empty state of the local debug data buffer
+ 
+ \return isEmpty(buffer)
+ */
+STORAGE_CLASS_DEBUG_H bool is_debug_buffer_empty(void);
+
+/*! Dequeue a token from the debug data buffer
+ 
+ \return isEmpty(buffer)?0:buffer[head]
+ */
+STORAGE_CLASS_DEBUG_H hrt_data debug_dequeue(void);
+
+/*! Synchronise the remote buffer to the local buffer
+ 
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue(void);
+
+/*! Synchronise the remote buffer to the local buffer
+ 
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue_isp(void);
+
+
+/*! Synchronise the remote buffer to the local buffer
+ 
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue_ddr(void);
+
+/*! Set the offset/address of the (remote) debug buffer
+ 
+ \return none
+ */
+extern void debug_buffer_init(
+	const hrt_address		addr);
+
+/*! Set the offset/address of the (remote) debug buffer
+ 
+ \return none
+ */
+extern void debug_buffer_ddr_init(
+	const hrt_vaddress		addr);
+
+/*! Set the (remote) operating mode of the debug buffer
+ 
+ \return none
+ */
+extern void debug_buffer_setmode(
+	const debug_buf_mode_t	mode);
+
+#endif /* __DEBUG_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h
new file mode 100644
index 0000000..4499cae
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h
@@ -0,0 +1,44 @@
+#ifndef __DMA_PUBLIC_H_INCLUDED__
+#define __DMA_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct dma_state_s		dma_state_t;
+
+/*! Read the control registers of DMA[ID]
+ 
+ \param	ID[in]				DMA identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = DMA[ID].state
+ */
+extern void dma_get_state(
+	const dma_ID_t		ID,
+	dma_state_t			*state);
+
+/*! Write to a control register of DMA[ID]
+
+ \param	ID[in]				DMA identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, DMA[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_DMA_H void dma_reg_store(
+	const dma_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of DMA[ID]
+ 
+ \param	ID[in]				DMA identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return DMA[ID].ctrl[reg]
+ */
+STORAGE_CLASS_DMA_H hrt_data dma_reg_load(
+	const dma_ID_t		ID,
+	const unsigned int	reg);
+
+#endif /* __DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_public.h
new file mode 100644
index 0000000..072eb0c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_public.h
@@ -0,0 +1,68 @@
+#ifndef __EVENT_PUBLIC_H_INCLUDED__
+#define __EVENT_PUBLIC_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include "system_types.h"
+
+/*! Blocking read from an event source EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+
+ \return none, dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void event_wait_for(
+	const event_ID_t		ID);
+
+/*! Conditional blocking wait for an event source EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void cnd_event_wait_for(
+	const event_ID_t		ID,
+	const bool				cnd);
+
+/*! Blocking read from an event source EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+
+ \return dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H hrt_data event_receive_token(
+	const event_ID_t		ID);
+
+/*! Blocking write to an event sink EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+ \param	token[in]			token to be written on the event
+
+ \return none, enqueue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void event_send_token(
+	const event_ID_t		ID,
+	const hrt_data			token);
+
+/*! Query an event source EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+
+ \return !isempty(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H bool is_event_pending(
+	const event_ID_t		ID);
+
+/*! Query an event sink EVENT[ID]
+ 
+ \param	ID[in]				EVENT identifier
+
+ \return !isfull(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H bool can_event_send_token(
+	const event_ID_t		ID);
+
+#endif /* __EVENT_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h
new file mode 100644
index 0000000..b229589
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h
@@ -0,0 +1,96 @@
+#ifndef __FIFO_MONITOR_PUBLIC_H_INCLUDED__
+#define __FIFO_MONITOR_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct fifo_channel_state_s		fifo_channel_state_t;
+typedef struct fifo_switch_state_s		fifo_switch_state_t;
+typedef struct fifo_monitor_state_s		fifo_monitor_state_t;
+
+/*! Set a fifo switch multiplex
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+ \param	sel[in]				fifo switch selector
+
+ \return none, fifo_switch[switch_id].sel = sel
+ */
+STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	const hrt_data				sel);
+
+/*! Get a fifo switch multiplex
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+
+ \return fifo_switch[switch_id].sel
+ */
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_switch_get(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id);
+
+/*! Read the state of FIFO_MONITOR[ID]
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	state[out]			fifo monitor state structure
+
+ \return none, state = FIFO_MONITOR[ID].state
+ */
+extern void fifo_monitor_get_state(
+	const fifo_monitor_ID_t		ID,
+	fifo_monitor_state_t		*state);
+
+/*! Read the state of a fifo channel
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	channel_id[in]		fifo channel identifier
+ \param	state[out]			fifo channel state structure
+
+ \return none, state = fifo_channel[channel_id].state
+ */
+extern void fifo_channel_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_channel_t		channel_id,
+	fifo_channel_state_t		*state);
+
+/*! Read the state of a fifo switch
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+ \param	state[out]			fifo switch state structure
+
+ \return none, state = fifo_switch[switch_id].state
+ */
+extern void fifo_switch_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	fifo_switch_state_t			*state);
+
+/*! Write to a control register of FIFO_MONITOR[ID]
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, FIFO_MONITOR[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_FIFO_MONITOR_H void fifo_monitor_reg_store(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of FIFO_MONITOR[ID]
+ 
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return FIFO_MONITOR[ID].ctrl[reg]
+ */
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_monitor_reg_load(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg);
+
+#endif /* __FIFO_MONITOR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h
new file mode 100644
index 0000000..2945f59
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h
@@ -0,0 +1,35 @@
+#ifndef __GDC_PUBLIC_H_INCLUDED__
+#define __GDC_PUBLIC_H_INCLUDED__
+
+/*! Write the bicubic interpolation table of GDC[ID]
+
+ \param	ID[in]				GDC identifier
+ \param data[in]			The data matrix to be written
+
+ \pre
+	- data must point to a matrix[4][HRT_GDC_N]
+
+ \implementation dependent
+	- The value of "HRT_GDC_N" is device specific
+	- The LUT should not be partially written
+	- The LUT format is a quadri-phase interpolation
+	  table. The layout is device specific
+	- The range of the values data[n][m] is device
+	  specific
+
+ \return none, GDC[ID].lut[0...3][0...HRT_GDC_N-1] = data
+ */
+STORAGE_CLASS_EXTERN void gdc_lut_store(
+	const gdc_ID_t		ID,
+	const int			data[4][HRT_GDC_N]);
+
+/*! Return the integer representation of 1.0 of GDC[ID]
+ 
+ \param	ID[in]				GDC identifier
+
+ \return unity
+ */
+STORAGE_CLASS_EXTERN int gdc_get_unity(
+	const gdc_ID_t		ID);
+
+#endif /* __GDC_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h
new file mode 100644
index 0000000..22850ac
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h
@@ -0,0 +1,44 @@
+#ifndef __GP_DEVICE_PUBLIC_H_INCLUDED__
+#define __GP_DEVICE_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct gp_device_state_s		gp_device_state_t;
+
+/*! Read the state of GP_DEVICE[ID]
+ 
+ \param	ID[in]				GP_DEVICE identifier
+ \param	state[out]			gp device state structure
+
+ \return none, state = GP_DEVICE[ID].state
+ */
+extern void gp_device_get_state(
+	const gp_device_ID_t		ID,
+	gp_device_state_t			*state);
+
+/*! Write to a control register of GP_DEVICE[ID]
+
+ \param	ID[in]				GP_DEVICE identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, GP_DEVICE[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+/*! Read from a control register of GP_DEVICE[ID]
+ 
+ \param	ID[in]				GP_DEVICE identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return GP_DEVICE[ID].ctrl[reg]
+ */
+STORAGE_CLASS_GP_DEVICE_H hrt_data gp_device_reg_load(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr);
+
+#endif /* __GP_DEVICE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h
new file mode 100644
index 0000000..ce1b026
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h
@@ -0,0 +1,31 @@
+#ifndef __GPIO_PUBLIC_H_INCLUDED__
+#define __GPIO_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Write to a control register of GPIO[ID]
+
+ \param	ID[in]				GPIO identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, GPIO[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_GPIO_H void gpio_reg_store(
+	const gpio_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+/*! Read from a control register of GPIO[ID]
+ 
+ \param	ID[in]				GPIO identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return GPIO[ID].ctrl[reg]
+ */
+STORAGE_CLASS_GPIO_H hrt_data gpio_reg_load(
+	const gpio_ID_t	ID,
+	const unsigned int		reg_addr);
+
+#endif /* __GPIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h
new file mode 100644
index 0000000..d7f87f7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h
@@ -0,0 +1,18 @@
+#ifndef __HMEM_PUBLIC_H_INCLUDED__
+#define __HMEM_PUBLIC_H_INCLUDED__
+
+#include <stddef.h>		/* size_t */
+
+/*! Return the size of HMEM[ID]
+ 
+ \param	ID[in]				HMEM identifier
+
+ \Note: The size is the byte size of the area it occupies
+		in the address map. I.e. disregarding internal structure
+
+ \return sizeof(HMEM[ID])
+ */
+STORAGE_CLASS_HMEM_H size_t sizeof_hmem(
+	const hmem_ID_t		ID);
+
+#endif /* __HMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_public.h
new file mode 100644
index 0000000..8133933
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_public.h
@@ -0,0 +1,8 @@
+#ifndef __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__
+#define __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__
+
+IA_CSS_I_RMGR_INIT(host)
+
+#include "ia_css_i_rmgr_vbuf_public.h"
+
+#endif /* __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
new file mode 100644
index 0000000..749f36e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
@@ -0,0 +1,17 @@
+#ifndef __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__
+#define __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__
+
+#include "ia_css_i_rmgr.h"
+
+/* declare supported types and functions
+ *
+ */
+IA_CSS_I_RMGR_TYPE(host, vbuf)
+
+IA_CSS_I_REFCOUNT(host, vbuf)
+
+/* include the system shared declarations
+ */
+#include "ia_css_i_rmgr_vbuf_shared.h"
+
+#endif /* __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h
new file mode 100644
index 0000000..1570b8f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h
@@ -0,0 +1,104 @@
+#ifndef __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
+#define __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include "system_types.h"
+
+/*! Reset INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+
+ \return none, reset(INPUT_FORMATTER[ID])
+ */
+extern void input_formatter_rst(
+	const input_formatter_ID_t		ID);
+
+/*! Set the blocking mode of INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	enable[in]			blocking enable flag
+
+ \use
+	- In HW, the capture unit will deliver an infinite stream of frames,
+	  the input formatter will synchronise on the first SOF. In simulation
+	  there are only a fixed number of frames, presented only once. By
+	  enabling blocking the inputformatter will wait on the first presented
+	  frame, thus avoiding race in the simulation setup.
+
+ \return none, INPUT_FORMATTER[ID].blocking_mode = enable
+ */
+extern void input_formatter_set_fifo_blocking_mode(
+	const input_formatter_ID_t		ID,
+	const bool						enable);
+
+/*! Return the data alignment of INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+
+ \return alignment(INPUT_FORMATTER[ID].data)
+ */
+extern unsigned int input_formatter_get_alignment(
+	const input_formatter_ID_t		ID);
+
+/*! Read the source switch state into INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter switch state structure
+
+ \return none, state = INPUT_FORMATTER[ID].switch_state
+ */
+extern void input_formatter_get_switch_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_switch_state_t	*state);
+
+/*! Read the control registers of INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = INPUT_FORMATTER[ID].state
+ */
+extern void input_formatter_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_state_t			*state);
+
+/*! Read the control registers of bin copy INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = INPUT_FORMATTER[ID].state
+ */
+extern void input_formatter_bin_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_bin_state_t		*state);
+
+/*! Write to a control register of INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, INPUT_FORMATTER[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_FORMATTER_H void input_formatter_reg_store(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr,
+	const hrt_data				value);
+
+/*! Read from a control register of INPUT_FORMATTER[ID]
+ 
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return INPUT_FORMATTER[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_FORMATTER_H hrt_data input_formatter_reg_load(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr);
+
+#endif /* __INPUT_FORMATTER_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h
new file mode 100644
index 0000000..bdc1631
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h
@@ -0,0 +1,360 @@
+#ifndef __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
+#define __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include "stdbool.h"
+#endif
+
+typedef struct input_system_state_s		input_system_state_t;
+typedef struct receiver_state_s			receiver_state_t;
+
+/*! Read the state of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	state[out]			input system state structure
+
+ \return none, state = INPUT_SYSTEM[ID].state
+ */
+extern void input_system_get_state(
+	const input_system_ID_t		ID,
+	input_system_state_t		*state);
+
+/*! Read the state of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	state[out]			receiver state structure
+
+ \return none, state = RECEIVER[ID].state
+ */
+extern void receiver_get_state(
+	const rx_ID_t				ID,
+	receiver_state_t			*state);
+
+/*! Flag whether a MIPI format is YUV420
+
+ \param	mipi_format[in]		MIPI format
+
+ \return mipi_format == YUV420
+ */
+extern bool is_mipi_format_yuv420(
+	const mipi_format_t			mipi_format);
+
+/*! Set compression parameters for cfg[cfg_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	cfg_ID[in]			Configuration identifier
+ \param	comp[in]			Compression method
+ \param	pred[in]			Predictor method
+
+ \NOTE: the storage of compression configuration is
+        implementation specific. The config can be
+        carried either on MIPI ports or on MIPI channels
+
+ \return none, RECEIVER[ID].cfg[cfg_ID] = {comp, pred}
+ */
+extern void receiver_set_compression(
+	const rx_ID_t				ID,
+	const unsigned int			cfg_ID,
+	const mipi_compressor_t		comp,
+	const mipi_predictor_t		pred);
+
+/*! Enable PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	cnd[in]				irq predicate
+
+ \return None, enable(RECEIVER[ID].PORT[port_ID])
+ */
+extern void receiver_port_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const bool					cnd);
+
+/*! Flag if PORT[port_ID] of RECEIVER[ID] is enabled
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+
+ \return enable(RECEIVER[ID].PORT[port_ID]) == true
+ */
+extern bool is_receiver_port_enabled(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID);
+
+/*! Enable the IRQ channels of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	irq_info[in]		irq channels
+
+ \return None, enable(RECEIVER[ID].PORT[port_ID].irq_info)
+ */
+extern void receiver_irq_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t			irq_info);
+
+/*! Return the IRQ status of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+
+ \return RECEIVER[ID].PORT[port_ID].irq_info
+ */
+extern rx_irq_info_t receiver_get_irq_info(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID);
+
+/*! Clear the IRQ status of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	irq_info[in]		irq status
+
+ \return None, clear(RECEIVER[ID].PORT[port_ID].irq_info)
+ */
+extern void receiver_irq_clear(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t			irq_info);
+
+/*! Write to a control register of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, INPUT_SYSTEM[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void input_system_reg_store(
+	const input_system_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return INPUT_SYSTEM[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_reg_load(
+	const input_system_ID_t		ID,
+	const unsigned int			reg);
+
+/*! Write to a control register of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, RECEIVER[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(
+	const rx_ID_t				ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return RECEIVER[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(
+	const rx_ID_t				ID,
+	const unsigned int			reg);
+
+/*! Write to a control register of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, RECEIVER[ID].PORT[port_ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void receiver_port_reg_store(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register PORT[port_ID] of of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return RECEIVER[ID].PORT[port_ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_port_reg_load(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const unsigned int			reg);
+
+/*! Write to a control register of SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	port_ID[in]			sub system identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void input_system_sub_system_reg_store(
+	const input_system_ID_t		ID,
+	const sub_system_ID_t		sub_ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	port_ID[in]			sub system identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_sub_system_reg_load(
+	const input_system_ID_t		ID,
+	const sub_system_ID_t		sub_ID,
+	const unsigned int			reg);
+
+
+
+///////////////////////////////////////////////////////////////////////////
+//
+//    Functions for configuration phase on input system.
+//
+///////////////////////////////////////////////////////////////////////////
+
+// Function that resets current configuration.
+// remove the argument since it should be private.
+input_system_error_t input_system_configuration_reset(void);
+
+// Function that commits current configuration.
+// remove the argument since it should be private.
+input_system_error_t input_system_configuration_commit(void);
+
+///////////////////////////////////////////////////////////////////////////
+//
+// User functions:
+//		(encoded generic function)
+//    - no checking
+//    - decoding name and agruments into the generic (channel) configuration
+//    function.
+//
+///////////////////////////////////////////////////////////////////////////
+
+
+// FIFO channel config function user
+
+input_system_error_t	input_system_csi_fifo_channel_cfg(
+	uint32_t				ch_id,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	target_cfg2400_t			target
+);
+
+input_system_error_t	input_system_csi_fifo_channel_with_counting_cfg(
+	uint32_t				ch_id,
+	uint32_t				nof_frame,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t				mem_region_size,
+	uint32_t				nof_mem_regions,
+	target_cfg2400_t			target
+);
+
+
+// SRAM channel config function user
+
+input_system_error_t	input_system_csi_sram_channel_cfg(
+	uint32_t				ch_id,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t				csi_mem_region_size,
+	uint32_t				csi_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+
+//XMEM channel config function user
+
+input_system_error_t	input_system_csi_xmem_channel_cfg(
+	uint32_t 				ch_id,
+	input_system_csi_port_t port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t 				mem_region_size,
+	uint32_t 				nof_mem_regions,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target,
+	uint32_t 				nof_xmem_buffers
+);
+
+input_system_error_t	input_system_csi_xmem_capture_only_channel_cfg(
+	uint32_t 				ch_id,
+	uint32_t 				nof_frames,
+	input_system_csi_port_t port,
+	uint32_t 				csi_mem_region_size,
+	uint32_t 				csi_nof_mem_regions,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+input_system_error_t	input_system_csi_xmem_acquire_only_channel_cfg(
+	uint32_t 				ch_id,
+	uint32_t 				nof_frames,
+	input_system_csi_port_t port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+// Non - CSI channel config function user
+
+input_system_error_t	input_system_prbs_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t		nof_frames,
+	uint32_t		seed,
+	uint32_t		sync_gen_width,
+	uint32_t		sync_gen_height,
+	uint32_t		sync_gen_hblank_cycles,
+	uint32_t		sync_gen_vblank_cycles,
+	target_cfg2400_t	target
+);
+
+
+input_system_error_t	input_system_tpg_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t 		nof_frames,//not used yet
+	uint32_t		x_mask,
+	uint32_t		y_mask,
+	uint32_t		x_delta,
+	uint32_t		y_delta,
+	uint32_t		xy_mask,
+	uint32_t		sync_gen_width,
+	uint32_t		sync_gen_height,
+	uint32_t		sync_gen_hblank_cycles,
+	uint32_t		sync_gen_vblank_cycles,
+	target_cfg2400_t	target
+);
+
+
+input_system_error_t	input_system_gpfifo_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t 		nof_frames,
+	target_cfg2400_t	target
+);
+
+#endif /* __INPUT_SYSTEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h
new file mode 100644
index 0000000..c4d829d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h
@@ -0,0 +1,176 @@
+#ifndef __IRQ_PUBLIC_H_INCLUDED__
+#define __IRQ_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#include "stddef.h"			/* size_t */
+#include <stdbool.h>		/* bool */
+#endif
+
+/*! Read the control registers of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	state[out]			irq controller state structure
+
+ \return none, state = IRQ[ID].state
+ */
+extern void irq_controller_get_state(
+	const irq_ID_t				ID,
+	irq_controller_state_t		*state);
+
+/*! Write to a control register of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, IRQ[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_IRQ_H void irq_reg_store(
+	const irq_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return IRQ[ID].ctrl[reg]
+ */
+STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(
+	const irq_ID_t		ID,
+	const unsigned int	reg);
+
+/*! Enable an IRQ channel of IRQ[ID] with a mode
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq[in]				IRQ (channel) identifier
+
+ \return none, enable(IRQ[ID].channel[irq_ID])
+ */
+extern void irq_enable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq_ID);
+
+/*! Enable pulse interrupts for IRQ[ID] with a mode
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	enable				enable/disable pulse interrupts
+
+ \return none
+ */
+extern void irq_enable_pulse(
+	const irq_ID_t	ID,
+	bool 			pulse);
+
+/*! Disable an IRQ channel of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq[in]				IRQ (channel) identifier
+
+ \return none, disable(IRQ[ID].channel[irq_ID])
+ */
+extern void irq_disable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq);
+
+/*! Clear the state of all IRQ channels of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+
+ \return none, clear(IRQ[ID].channel[])
+ */
+extern void irq_clear_all(
+	const irq_ID_t				ID);
+
+/*! Return the ID of a signalling IRQ channel of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param irq_id[out]			active IRQ (channel) identifier
+
+ \Note: This function operates as strtok(), based on the return
+  state the user is informed if there are additional signalling
+  channels
+
+ \return state(IRQ[ID])
+ */
+extern enum hrt_isp_css_irq_status irq_get_channel_id(
+	const irq_ID_t				ID,
+	unsigned int				*irq_id);
+
+/*! Raise an interrupt on channel irq_id of device IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq_id[in]			IRQ (channel) identifier
+
+ \return none, signal(IRQ[ID].channel[irq_id])
+ */
+extern void irq_raise(
+	const irq_ID_t				ID,
+	const irq_sw_channel_id_t	irq_id);
+
+/*! Test if any IRQ channel of the virtual super IRQ has raised a signal
+
+ \return any(VIRQ.channel[irq_ID] != 0)
+ */
+extern bool any_virq_signal(void);
+
+/*! Enable an IRQ channel of the virtual super IRQ
+
+ \param	irq[in]				IRQ (channel) identifier
+ \param	en[in]				predicate channel enable
+
+ \return none, VIRQ.channel[irq_ID].enable = en
+ */
+extern void cnd_virq_enable_channel(
+	const virq_id_t				irq_ID,
+	const bool					en);
+
+/*! Clear the state of all IRQ channels of the virtual super IRQ
+
+ \return none, clear(VIRQ.channel[])
+ */
+extern void virq_clear_all(void);
+
+/*! Clear the IRQ info state of the virtual super IRQ
+
+ \param irq_info[in/out]	The IRQ (channel) state
+
+ \return none
+ */
+extern void virq_clear_info(
+	virq_info_t					*irq_info);
+
+/*! Return the ID of a signalling IRQ channel of the virtual super IRQ
+
+ \param irq_id[out]			active IRQ (channel) identifier
+
+ \Note: This function operates as strtok(), based on the return
+  state the user is informed if there are additional signalling
+  channels
+
+ \return state(IRQ[...])
+ */
+extern enum hrt_isp_css_irq_status virq_get_channel_id(
+	virq_id_t					*irq_id);
+
+/*! Return the IDs of all signaling IRQ channels of the virtual super IRQ
+
+ \param irq_info[out]		all active IRQ (channel) identifiers
+
+ \Note: Unlike "irq_get_channel_id()" this function returns all
+  channel signaling info. The new info is OR'd with the current
+  info state. N.B. this is the same as repeatedly calling the function
+  "irq_get_channel_id()" in a (non-blocked) handler routine
+
+ \return (error(state(IRQ[...]))
+ */
+extern enum hrt_isp_css_irq_status virq_get_channel_signals(
+	virq_info_t					*irq_info);
+
+#endif /* __IRQ_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h
new file mode 100644
index 0000000..8c212eb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h
@@ -0,0 +1,262 @@
+#ifndef __ISP_PUBLIC_H_INCLUDED__
+#define __ISP_PUBLIC_H_INCLUDED__
+
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#include "stddef.h"			/* size_t */
+#include <stdbool.h>		/* bool */
+#endif
+
+#include "system_types.h"
+
+/*! Enable or disable the program complete irq signal of ISP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) enable(ISP[ID].irq) else disable(ISP[ID].irq)
+ */
+extern void cnd_isp_irq_enable(
+	const isp_ID_t		ID,
+	const bool			cnd);
+
+/*! Read the state of cell ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	state[out]			isp state structure
+ \param	stall[out]			isp stall conditions
+
+ \return none, state = ISP[ID].state, stall = ISP[ID].stall
+ */
+extern void isp_get_state(
+	const isp_ID_t		ID,
+	isp_state_t			*state,
+	isp_stall_t			*stall);
+
+
+/*! Write to the status and control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, ISP[ID].sc[reg] = value
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_store(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from the status and control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return ISP[ID].sc[reg]
+ */
+STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(
+	const isp_ID_t		ID,
+	const unsigned int	reg);
+
+/*! Get the status of a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be checked
+
+ \return  (ISP[ID].sc[reg] & (1<<bit)) != 0
+ */
+STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Set a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, ISP[ID].sc[reg] |= (1<<bit)
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_setbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Clear a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, ISP[ID].sc[reg] &= ~(1<<bit)
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Write to the VAMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_ISP_H void isp_vamem_store(
+	const vamem_ID_t	ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size);
+
+/*! Write to the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size);
+
+/*! Read from the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size);
+
+/*! Read from the HMEM of ISP[ID]
+
+ \param	ID[in]				hmem identifier
+ \param	addr[in]			the address in HMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_ISP_H void isp_hmem_load(
+	const hmem_ID_t		ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size);
+
+/*! Write to the HMEM of ISP[ID]
+
+ \param	ID[in]				hmem identifier
+ \param	addr[in]			the address in HMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, HMEM[ID].hmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_ISP_H void isp_hmem_store(
+	const hmem_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size);
+
+/*! Read from the VAMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_ISP_H void isp_vamem_load(
+	const vamem_ID_t	ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size);
+
+/*! Write to the PMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].pmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_ISP_H void isp_pmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void		*data,
+	const size_t		size);
+
+/*! Read from the PMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in PMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_ISP_H void isp_pmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void			*data,
+	const size_t		size);
+
+/*! Write a 32-bit datum to the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].dmem[addr] = data
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data);
+
+/*! Load a 32-bit datum from the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr]
+ */
+STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(
+	const isp_ID_t		ID,
+	const unsigned int	addr);
+
+/*! Concatenate the LSW and MSW into a double precision word
+
+ \param	x0[in]				Integer containing the LSW
+ \param	x1[in]				Integer containing the MSW
+
+ \return x0 | (x1 << bits_per_vector_element)
+ */
+STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
+	const uint16_t		x0,
+	const uint16_t		x1);
+
+#endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h
new file mode 100644
index 0000000..afeded0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h
@@ -0,0 +1,62 @@
+#ifndef __MMU_PUBLIC_H_INCLUDED__
+#define __MMU_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Set the page table base index of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	base_index[in]		page table base index
+
+ \return none, MMU[ID].page_table_base_index = base_index
+ */
+STORAGE_CLASS_EXTERN void mmu_set_page_table_base_index(
+	const mmu_ID_t		ID,
+	const hrt_data		base_index);
+
+/*! Get the page table base index of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	base_index[in]		page table base index
+
+ \return MMU[ID].page_table_base_index
+ */
+STORAGE_CLASS_EXTERN hrt_data mmu_get_page_table_base_index(
+	const mmu_ID_t		ID);
+
+/*! Invalidate the page table cache of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+
+ \return none
+ */
+STORAGE_CLASS_EXTERN void mmu_invalidate_cache(
+	const mmu_ID_t		ID);
+
+
+/*! Write to a control register of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, MMU[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_MMU_H void mmu_reg_store(
+	const mmu_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return MMU[ID].ctrl[reg]
+ */
+STORAGE_CLASS_MMU_H hrt_data mmu_reg_load(
+	const mmu_ID_t		ID,
+	const unsigned int	reg);
+
+#endif /* __MMU_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h
new file mode 100644
index 0000000..790e3d3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h
@@ -0,0 +1,4 @@
+#ifndef __PIPELINE_PUBLIC_H_INCLUDED__
+#define __PIPELINE_PUBLIC_H_INCLUDED__
+
+#endif /* __PIPELINE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/queue_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/queue_public.h
new file mode 100644
index 0000000..760fd44
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/queue_public.h
@@ -0,0 +1,98 @@
+#ifndef __QUEUE_PUBLIC_H_INCLUDED__
+#define __QUEUE_PUBLIC_H_INCLUDED__
+
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#else
+#include <stdint.h>
+#include <stdbool.h>	/* bool */
+#endif
+
+#include "sh_css_internal.h"	/* enum sh_css_frame_id */
+
+
+/*! The Host initialize the "host2sp" queues.
+ */
+extern void init_host2sp_queues(void);
+
+/*! The Host initialize the "sp2host" queues.
+ */
+extern void init_sp2host_queues(void);
+
+/************************************************************
+ *
+ * Buffer queues (the host -> the SP).
+ *
+ ************************************************************/
+/*! The Host puts the buffer at the tail of the queue
+
+ \param	pipe_num[in]			the pipe number
+ \param stage_num[in]			the stage number
+ \param	ERROR frame_id[in]			the frame type
+ \param	ERROR frame_data[in]			the frame that will be enqueued
+
+ \return !isFull(host2sp_queue[pipe_num][stage_num][frame_id])
+ */
+extern bool host2sp_enqueue_buffer(
+	unsigned int pipe_num,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t buffer_ptr);
+
+extern bool host2sp_dequeue_buffer(
+	unsigned int thread_id,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t *buffer_ptr);
+
+/************************************************************
+ *
+ * Buffer queues (the SP -> the host).
+ *
+ ************************************************************/
+/*! The Host gets the buffer at the head of the queue
+
+ \param	pipe_num[in]			the pipe number
+ \param stage_num[in]			the stage number
+ \param	ERROR frame_id[in]			the frame type
+ \param	ERROR frame_data[out]			the frame that will be dequeued
+
+ \return !isEmpty(sp2host_queue[frame_id])
+ */
+extern bool sp2host_dequeue_buffer(
+	unsigned int pipe_num,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t *buffer_ptr);
+
+/************************************************************
+ *
+ * Event queues (the host -> the SP).
+ *
+ ************************************************************/
+/*! The Host puts the SP event at the tail of the queue.
+
+ \param	event[in]			the SP event that will be queued
+
+ \return !isFull(host2sp_queue)
+ */
+extern bool host2sp_enqueue_sp_event(
+		uint32_t event);
+
+/************************************************************
+ *
+ * Event queues (the SP -> the host).
+ *
+ ************************************************************/
+/*! The Host gets the IRQ event from the IRQ queue
+
+ \param	event[out]			the IRQ event that will be dequeued
+
+ \return !isEmpty(sp2host_queue)
+ */
+extern bool sp2host_dequeue_irq_event(
+	uint32_t *event);
+
+#endif /* __QUEUE_PUBLIC_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h
new file mode 100644
index 0000000..7f30dc0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h
@@ -0,0 +1,216 @@
+#ifndef __SP_PUBLIC_H_INCLUDED__
+#define __SP_PUBLIC_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#include "stddef.h"			/* size_t */
+#include "stdbool.h"		/* bool */
+#endif
+
+#include "system_types.h"
+
+typedef struct sp_state_s		sp_state_t;
+typedef struct sp_stall_s		sp_stall_t;
+
+/*! Enable or disable the program complete irq signal of SP[ID]
+ 
+ \param	ID[in]				SP identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) enable(SP[ID].irq) else disable(SP[ID].irq)
+ */
+extern void cnd_sp_irq_enable(
+	const sp_ID_t		ID,
+	const bool			cnd);
+
+/*! Read the state of cell SP[ID]
+ 
+ \param	ID[in]				SP identifier
+ \param	state[out]			sp state structure
+ \param	stall[out]			isp stall conditions
+
+ \return none, state = SP[ID].state, stall = SP[ID].stall
+ */
+extern void sp_get_state(
+	const sp_ID_t		ID,
+	sp_state_t			*state,
+	sp_stall_t			*stall);
+
+/*! Write to the status and control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, SP[ID].sc[reg] = value
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_store(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from the status and control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return SP[ID].sc[reg]
+ */
+STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(
+	const sp_ID_t		ID,
+	const unsigned int	reg);
+
+/*! Get the status of a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be checked
+
+ \return  (SP[ID].sc[reg] & (1<<bit)) != 0
+ */
+STORAGE_CLASS_SP_H bool sp_ctrl_getbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Set a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, SP[ID].sc[reg] |= (1<<bit)
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_setbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Clear a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, SP[ID].sc[reg] &= ~(1<<bit)
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_clearbit(
+	const sp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Write to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const void			*data,
+	const size_t		size);
+
+/*! Read from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H void sp_dmem_load(
+	const sp_ID_t		ID,
+	const unsigned int	addr,
+	void				*data,
+	const size_t		size);
+
+/*! Write a 8-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint8(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint8_t		data);
+
+/*! Write a 16-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint16(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint16_t		data);
+
+/*! Write a 32-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint32(
+	const sp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data);
+
+/*! Load a 8-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(
+	const sp_ID_t		ID,
+	const unsigned int	addr);
+
+/*! Load a 16-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(
+	const sp_ID_t		ID,
+	const unsigned int	addr);
+
+/*! Load a 32-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint32_t sp_dmem_load_uint32(
+	const sp_ID_t		ID,
+	const unsigned int	addr);
+
+#endif /* __SP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sw_event_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sw_event_public.h
new file mode 100644
index 0000000..7431b07
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sw_event_public.h
@@ -0,0 +1,34 @@
+/****************************************************************
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#ifndef __SW_EVENT_PUBLIC_H_INCLUDED__
+#define __SW_EVENT_PUBLIC_H_INCLUDED__
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include "system_types.h"
+
+/**
+ * @brief Encode the information into the software-event.
+ * Encode a certain amount of information into a signel software-event.
+ *
+ * @param[in]	in	The inputs of the encoder.
+ * @param[in]	nr	The number of inputs.
+ * @param[out]	out	The output of the encoder.
+ *
+ * @return true if it is successfull.
+ */
+STORAGE_CLASS_SW_EVENT_H bool encode_sw_event(
+	uint32_t	*in,
+	uint32_t	nr,
+	uint32_t	*out);
+#endif /* __SW_EVENT_PUBLIC_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h
new file mode 100644
index 0000000..360eb26
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h
@@ -0,0 +1,27 @@
+#ifndef __TAG_PUBLIC_H_INCLUDED__
+#define __TAG_PUBLIC_H_INCLUDED__
+
+/**
+ * @brief	Creates the tag description from the given parameters.
+ * @param[in]	num_captures
+ * @param[in]	skip
+ * @param[in]	offset
+ * @param[out]	tag_descr
+ */
+void
+sh_css_create_tag_descr(int num_captures,
+			unsigned int skip,
+			int offset,
+			unsigned int exp_id,
+			struct sh_css_tag_descr *tag_descr);
+
+/**
+ * @brief	Encodes the members of tag description into a 32-bit value.
+ * @param[in]	tag		Pointer to the tag description
+ * @return	(unsigned int)	Encoded 32-bit tag-info
+ */
+unsigned int
+sh_css_encode_tag_descr(struct sh_css_tag_descr *tag);
+
+#endif /* __TAG_PUBLIC_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h
new file mode 100644
index 0000000..e20727b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h
@@ -0,0 +1,47 @@
+#ifndef __TIMED_CTRL_PUBLIC_H_INCLUDED__
+#define __TIMED_CTRL_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Write to a control register of TIMED_CTRL[ID]
+
+ \param	ID[in]				TIMED_CTRL identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, TIMED_CTRL[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_TIMED_CTRL_H void timed_ctrl_reg_store(
+	const timed_ctrl_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+extern void timed_ctrl_snd_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	hrt_address				addr,
+	hrt_data				value);
+
+extern void timed_ctrl_snd_sp_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const sp_ID_t			SP_ID,
+	hrt_address				offset,
+	hrt_data				value);
+
+extern void timed_ctrl_snd_gpio_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const gpio_ID_t			GPIO_ID,
+	hrt_address				offset,
+	hrt_data				value);
+
+
+
+#endif /* __TIMED_CTRL_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h
new file mode 100644
index 0000000..97c68ef
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h
@@ -0,0 +1,6 @@
+#ifndef __VAMEM_PUBLIC_H_INCLUDED__
+#define __VAMEM_PUBLIC_H_INCLUDED__
+
+
+
+#endif /* __VAMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/ia_css_i_rmgr.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/ia_css_i_rmgr.h
new file mode 100644
index 0000000..d22bafc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/ia_css_i_rmgr.h
@@ -0,0 +1,59 @@
+#ifndef __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__
+#define __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__
+
+#include "storage_class.h"
+
+#ifndef __INLINE_RMGR__
+#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_RMGR_C
+#else  /* __INLINE_RMGR__ */
+#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_RMGR_C STORAGE_CLASS_INLINE
+#endif /* __INLINE_RMGR__ */
+
+/* definition of init uninit function that needs to be implemented
+ * per system?
+ */
+#define IA_CSS_I_RMGR_INIT(proc) \
+void ia_css_i_ ## proc ## _rmgr_init(void); \
+\
+void ia_css_i_ ## proc ## _rmgr_uninit(void);
+
+/*
+ * macro to define the interface for resource type
+ */
+#define IA_CSS_I_RMGR_TYPE(proc, type) \
+\
+struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool; \
+\
+struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle; \
+\
+STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_init_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool); \
+\
+STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_uninit_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool); \
+\
+STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_acq_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool, \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
+\
+STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_rel_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool, \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
+
+/*
+ * macro to define the interface for refcounting
+ */
+#define IA_CSS_I_REFCOUNT(proc, type) \
+void ia_css_i_ ## proc ## _refcount_retain_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
+\
+void ia_css_i_ ## proc ## _refcount_release_ ## type( \
+	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle);
+
+
+#include "ia_css_i_rmgr_public.h"
+
+
+#endif /* __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h
new file mode 100644
index 0000000..1e9f4db
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h
@@ -0,0 +1,33 @@
+#ifndef __INPUT_FORMATTER_H_INCLUDED__
+#define __INPUT_FORMATTER_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "input_formatter_local.h"
+
+#ifndef __INLINE_INPUT_FORMATTER__
+#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_INPUT_FORMATTER_C 
+#include "input_formatter_public.h"
+#else  /* __INLINE_INPUT_FORMATTER__ */
+#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_INPUT_FORMATTER_C STORAGE_CLASS_INLINE
+#include "input_formatter_private.h"
+#endif /* __INLINE_INPUT_FORMATTER__ */
+
+#endif /* __INPUT_FORMATTER_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h
new file mode 100644
index 0000000..8b28275
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h
@@ -0,0 +1,33 @@
+#ifndef __INPUT_SYSTEM_H_INCLUDED__
+#define __INPUT_SYSTEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "input_system_local.h"
+
+#ifndef __INLINE_INPUT_SYSTEM__
+#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_INPUT_SYSTEM_C 
+#include "input_system_public.h"
+#else  /* __INLINE_INPUT_SYSTEM__ */
+#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_INPUT_SYSTEM_C STORAGE_CLASS_INLINE
+#include "input_system_private.h"
+#endif /* __INLINE_INPUT_SYSTEM__ */
+
+#endif /* __INPUT_SYSTEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h
new file mode 100644
index 0000000..9b46647
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h
@@ -0,0 +1,33 @@
+#ifndef __IRQ_H_INCLUDED__
+#define __IRQ_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the IRQ device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "irq_local.h"
+
+#ifndef __INLINE_IRQ__
+#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_IRQ_C 
+#include "irq_public.h"
+#else  /* __INLINE_IRQ__ */
+#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_IRQ_C STORAGE_CLASS_INLINE
+#include "irq_private.h"
+#endif /* __INLINE_IRQ__ */
+
+#endif /* __IRQ_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h
new file mode 100644
index 0000000..34f1479
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h
@@ -0,0 +1,33 @@
+#ifndef __ISP_H_INCLUDED__
+#define __ISP_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the ISP cell. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "isp_local.h"
+
+#ifndef __INLINE_ISP__
+#define STORAGE_CLASS_ISP_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_ISP_C 
+#include "isp_public.h"
+#else  /* __INLINE_iSP__ */
+#define STORAGE_CLASS_ISP_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_ISP_C STORAGE_CLASS_INLINE
+#include "isp_private.h"
+#endif /* __INLINE_ISP__ */
+
+#endif /* __ISP_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h
new file mode 100644
index 0000000..83fe2b3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h
@@ -0,0 +1,367 @@
+#ifndef __MATH_SUPPORT_H_INCLUDED__
+#define __MATH_SUPPORT_H_INCLUDED__
+
+/* ceil((real)a / b) */
+#define ceil_div(a,b) (((a)+(b)-1)/(b))
+
+#if defined(_MSC_VER)
+
+/* MSC already provides min/max */
+/*#define min(a, b) ((a) < (b) ? (a) : (b)) */
+/*#define max(a, b) ((a) > (b) ? (a) : (b)) */
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static __inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static __inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static __inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static __inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static __inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static __inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__HIVECC)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+/* the HIVE operator clip() is an assymetric bound() */
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__KERNEL__)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__FIST__)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__GNUC__)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+/*
+#define min(a, b) ({ \
+	__typeof__ (a) _a = (a); \
+	__typeof__ (b) _b = (b); \
+	_a < _b ? _a : _b; }) 
+
+#define max(a, b) ({ \
+	__typeof__ (a) _a = (a); \
+	__typeof__ (b) _b = (b); \
+	_a > _b ? _a : _b; }) 
+ */
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#else /* default is for an unknown environment */
+
+/* already defined */
+
+#endif
+
+#endif /* __MATH_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h
new file mode 100644
index 0000000..06733b3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h
@@ -0,0 +1,269 @@
+#ifndef __MEMORY_ACCESS_H_INCLUDED__
+#define __MEMORY_ACCESS_H_INCLUDED__
+
+/*!
+ * \brief
+ * Define the public interface for virtual memory
+ * access functions. Access types are limited to
+ * those defined in <stdint.h>
+ *
+ * The address representation is private to the system
+ * and represented as "hrt_vaddress" rather than a
+ * pointer, as the memory allocation cannot be accessed
+ * by dereferencing but reaquires load and store access
+ * functions
+ *
+ * The page table selection or virtual memory context;
+ * The page table base index; Is implicit. This page
+ * table base index must be set by the implementation
+ * of the access function
+ *
+ * "store" is a transfer to the system
+ * "load" is a transfer from the system
+ *
+ * Allocation properties can be specified by setting
+ * attributes (see below) in case of multiple physical
+ * memories the memory ID is encoded on the attribute
+ *
+ * Allocations in the same physical memory, but in a
+ * different (set of) page tables can be shared through
+ * a page table information mapping function
+ */
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include "stddef.h"
+
+/*
+ * User provided file that defines the (sub)system address types:
+ *	- hrt_vaddress	a type that can hold the (sub)system virtual address range
+ */
+#include "system_types.h"
+
+/*
+ * The MMU base address is a physical address, thus the same type is used
+ * as for the device base address
+ */
+#include "device_access.h"
+
+/*!
+ * \brief
+ * Bit masks for specialised allocation functions
+ * the default is "uncached", "not contiguous",
+ * "not page aligned" and "not cleared"
+ *
+ * Forcing alignment (usually) returns a pointer
+ * at an alignment boundary that is offset from
+ * the allocated pointer. Without storing this
+ * pointer/offset, we cannot free it. The memory
+ * manager is responsible for the bookkeeping, e.g.
+ * the allocation function creates a sentinel
+ * within the allocation referencable from the
+ * returned pointer/address.
+ */
+#define MMGR_ATTRIBUTE_MASK			0x000f
+#define MMGR_ATTRIBUTE_CACHED		0x0001
+#define MMGR_ATTRIBUTE_CONTIGUOUS	0x0002
+#define MMGR_ATTRIBUTE_PAGEALIGN	0x0004
+#define MMGR_ATTRIBUTE_CLEARED		0x0008
+#define MMGR_ATTRIBUTE_UNUSED		0xfff0
+
+/* #define MMGR_ATTRIBUTE_DEFAULT	(MMGR_ATTRIBUTE_CACHED) */
+#define MMGR_ATTRIBUTE_DEFAULT	0
+
+extern const hrt_vaddress	mmgr_NULL;
+
+/*! Set the (sub)system virtual memory page table base address
+
+ \param	base_addr[in]		The address where page table 0 is located
+
+ \Note: The base_addr is an absolute system address, thus it is not
+        relative to the DDR base address
+
+ \return none,
+ */
+extern void mmgr_set_base_address(
+	const sys_address		base_addr);
+
+/*! Get the (sub)system virtual memory page table base address
+
+ \return base_address,
+ */
+/* unused */
+extern sys_address mmgr_get_base_address(void);
+
+
+/*! Set the (sub)system virtual memory page table base index
+
+ \param	base_addr[in]		The index  where page table 0 is located
+
+ \Note: The base_index is the MSB section of an absolute system address,
+        the in-page address bits are discared. The base address is not
+		relative to the DDR base address
+
+ \return none,
+ */
+/* unused */
+extern void mmgr_set_base_index(
+	const hrt_data			base_index);
+
+/*! Get the (sub)system virtual memory page table base index
+
+ \return base_address,
+ */
+/* unused */
+extern hrt_data mmgr_get_base_index(void);
+
+/*! Return the address of an allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_malloc(
+	const size_t			size);
+
+/*! Return the address of a zero initialised allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_calloc(
+	const size_t			N,
+	const size_t			size);
+
+/*! Return the address of a reallocated allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the allocation
+
+ \Note
+	All limitations and particularities of the C stdlib
+	realloc function apply
+
+ \return vaddress
+ */
+/* unused */
+extern hrt_vaddress mmgr_realloc(
+	hrt_vaddress			vaddr,
+	const size_t			size);
+
+/*! Free the memory allocation identified by the address
+
+ \param	vaddr[in]			Address of the allocation
+
+ \return vaddress
+ */
+extern void mmgr_free(
+	hrt_vaddress			vaddr);
+
+/*! Return the address of an allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+ \param	attribute[in]		Bit vector specifying the properties
+							of the allocation including zero
+							initialisation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_alloc_attr(
+	const size_t			size,
+	const uint16_t			attribute);
+
+/*! Return the address of a reallocated allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the allocation
+ \param	attribute[in]		Bit vector specifying the properties
+							of the allocation
+
+ \Note
+	All limitations and particularities of the C stdlib
+	realloc function apply
+
+ \return vaddress
+ */
+/* unused */
+extern hrt_vaddress mmgr_realloc_attr(
+	hrt_vaddress			vaddr,
+	const size_t			size,
+	const uint16_t			attribute);
+
+/*! Return the address of a mapped existing allocation in memory
+
+ \param	ptr[in]				Pointer to an allocation in a different
+					virtual memory page table, but the same
+					physical memory
+ \param size[in]			Size of the memory of the pointer
+ \param	attribute[in]			Bit vector specifying the properties
+					of the allocation
+ \param context				Pointer of a context provided by
+					client/driver for additonal parameters
+					needed by the implementation
+ \Note
+	This interface is tentative, limited to the desired function
+	the actual interface may require furhter parameters
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_mmap(
+	const void *ptr,
+	const size_t size,
+	uint16_t attribute,
+	void *context);
+
+/*! Zero initialise an allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the area to be cleared
+
+ \return none
+ */
+extern void mmgr_clear(
+	hrt_vaddress			vaddr,
+	const size_t			size);
+
+/*! Set an allocation in memory to a value
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[in]			Value to set
+ \param	size[in]			Size in bytes of the area to be set
+
+ \return none
+ */
+/* unused */
+extern void mmgr_set(
+	hrt_vaddress			vaddr,
+	const uint8_t			data,
+	const size_t			size);
+
+/*! Read an array of bytes from a virtual memory address
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[out]			pointer to the destination array
+ \param	size[in]			number of bytes to read
+
+ \return none
+ */
+extern void mmgr_load(
+	const hrt_vaddress		vaddr,
+	void					*data,
+	const size_t			size);
+
+/*! Write an array of bytes to device registers or memory in the device
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[in]			pointer to the source array
+ \param	size[in]			number of bytes to write
+
+ \return none
+ */
+extern void mmgr_store(
+	const hrt_vaddress		vaddr,
+	const void				*data,
+	const size_t			size);
+
+#endif /* __MEMORY_ACCESS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h
new file mode 100644
index 0000000..5a10725
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h
@@ -0,0 +1,35 @@
+#ifndef __MMU_DEVICE_H_INCLUDED__
+#define __MMU_DEVICE_H_INCLUDED__
+
+/* The file mmu.h already exists */
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the MMU device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "mmu_local.h"
+
+#ifndef __INLINE_MMU__
+#define STORAGE_CLASS_MMU_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_MMU_C 
+#include "mmu_public.h"
+#else  /* __INLINE_MMU__ */
+#define STORAGE_CLASS_MMU_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_MMU_C STORAGE_CLASS_INLINE
+#include "mmu_private.h"
+#endif /* __INLINE_MMU__ */
+
+#endif /* __MMU_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/pipeline.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/pipeline.h
new file mode 100644
index 0000000..c97830c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/pipeline.h
@@ -0,0 +1,40 @@
+#ifndef __PIPELINE_H_INCLUDED__
+#define __PIPELINE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the pipeline.
+ *
+ * Problematic is the definition of the pipeline. For the moment it refers
+ * to the algorithmic pipeline (i.e. a DAG of kernels) as the user would see
+ * it. The pipeline thus aggregates all parameter sets of all kernels
+ * irrespective of the partitioning of the pipeline over stages or sections
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+/* #define __PARAM_BY_ADDRESS__ 1 */
+#define __PARAM_BY_TEMPLATE__ 1
+
+#include "storage_class.h"
+
+#include "pipeline_local.h"
+
+#ifndef __INLINE_PIPELINE__
+#define STORAGE_CLASS_PIPELINE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_PIPELINE_C 
+#include "pipeline_public.h"
+#else  /* __INLINE_PIPELINE__ */
+#define STORAGE_CLASS_PIPELINE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_PIPELINE_C STORAGE_CLASS_INLINE
+#include "pipeline_private.h"
+#endif /* __INLINE_PIPELINE__ */
+
+#endif /* __PIPELINE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h
new file mode 100644
index 0000000..85fb9bf
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h
@@ -0,0 +1,56 @@
+#ifndef __PLATFORM_SUPPORT_H_INCLUDED__
+#define __PLATFORM_SUPPORT_H_INCLUDED__
+
+#if defined(_MSC_VER)
+#include "storage_class.h"
+/*
+ * Put here everything _MSC_VER specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+STORAGE_CLASS_INLINE void
+hrt_sleep(void)
+{
+	/* Empty for now. Polling is not used in many places */
+}
+
+#elif defined(__HIVECC)
+/*
+ * Put here everything __HIVECC specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include "hrt/host.h"
+
+#elif defined(__KERNEL__)
+#include "storage_class.h"
+#include <linux/delay.h>
+STORAGE_CLASS_INLINE void hrt_sleep(void)
+{
+	udelay(1);
+}
+/*
+ * Put here everything __KERNEL__ specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#elif defined(__FIST__)
+/*
+ * Put here everything __FIST__ specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+
+#elif defined(__GNUC__)
+/*
+ * Put here everything __GNUC__ specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include "hrt/host.h"
+
+
+#else /* default is for unknwn environments */
+/*
+ * Put here everything specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+
+#endif
+
+#endif /* __PLATFORM_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h
new file mode 100644
index 0000000..583ca08
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h
@@ -0,0 +1,28 @@
+#ifndef __PRINT_SUPPORT_H_INCLUDED__
+#define __PRINT_SUPPORT_H_INCLUDED__
+
+#if defined(_MSC_VER)
+
+#include <stdio.h>
+
+#elif defined(__HIVECC)
+/*
+ * Use OP___dump()
+ */
+
+#elif defined(__KERNEL__)
+/* printk() */
+
+#elif defined(__FIST__)
+
+#elif defined(__GNUC__)
+
+#include <stdio.h>
+
+#else /* default is for unknown environments */
+
+/* ? */
+
+#endif
+
+#endif /* __PRINT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/program_load/program_load.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/program_load/program_load.h
new file mode 100644
index 0000000..036b04b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/program_load/program_load.h
@@ -0,0 +1,11 @@
+#ifndef __PROGRAM_LOAD_H_INCLUDED__
+#define __PROGRAM_LOAD_H_INCLUDED__
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+extern bool program_load(
+	const cell_id_t			ID,
+	const firmware_h		firmware);
+
+#endif /* __PROGRAM_LOAD_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h
new file mode 100644
index 0000000..cb15639
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h
@@ -0,0 +1,32 @@
+#ifndef __QUEUE_H_INCLUDED__
+#define __QUEUE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and is system agnostic
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  cell specific interfaces
+ *	- private: cell specific inline implementations
+ *	- global:  inter cell constants and identifiers
+ *	- local:   cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "queue_local.h"
+
+#ifndef __INLINE_QUEUE__
+#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_QUEUE_C 
+#include "queue_public.h"
+#else  /* __INLINE_QUEUE__ */
+#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_QUEUE_C STORAGE_CLASS_INLINE
+#include "queue_private.h"
+#endif /* __INLINE_QUEUE__ */
+
+#endif /* __QUEUE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h
new file mode 100644
index 0000000..719d4a5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h
@@ -0,0 +1,34 @@
+#ifndef __RESOURCE_H_INCLUDED__
+#define __RESOURCE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses a RESOURCE manager. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "resource_local.h"
+
+#ifndef __INLINE_RESOURCE__
+#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_RESOURCE_C 
+#include "resource_public.h"
+#else  /* __INLINE_RESOURCE__ */
+#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_RESOURCE_C STORAGE_CLASS_INLINE
+#include "resource_private.h"
+#endif /* __INLINE_RESOURCE__ */
+
+#endif /* __RESOURCE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h
new file mode 100644
index 0000000..ffe0287
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h
@@ -0,0 +1,33 @@
+#ifndef __SP_H_INCLUDED__
+#define __SP_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the SP cell. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "sp_local.h"
+
+#ifndef __INLINE_SP__
+#define STORAGE_CLASS_SP_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_SP_C 
+#include "sp_public.h"
+#else  /* __INLINE_SP__ */
+#define STORAGE_CLASS_SP_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_SP_C STORAGE_CLASS_INLINE
+#include "sp_private.h"
+#endif /* __INLINE_SP__ */
+
+#endif /* __SP_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h
new file mode 100644
index 0000000..21eae8f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h
@@ -0,0 +1,14 @@
+#ifndef __STORAGE_CLASS_H_INCLUDED__
+#define __STORAGE_CLASS_H_INCLUDED__
+
+#define STORAGE_CLASS_EXTERN extern
+
+#if defined(_MSC_VER)
+#define STORAGE_CLASS_INLINE static __inline
+#elif defined(__HIVECC)
+#define STORAGE_CLASS_INLINE static inline
+#else
+#define STORAGE_CLASS_INLINE static inline
+#endif
+
+#endif /* __STORAGE_CLASS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/sw_event.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/sw_event.h
new file mode 100644
index 0000000..f2ca078
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/sw_event.h
@@ -0,0 +1,43 @@
+/****************************************************************
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#ifndef __SW_EVENT_H_INCLUDED__
+#define __SW_EVENT_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the IRQ device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "sw_event_local.h"
+
+#ifndef __INLINE_SW_EVENT__
+#define STORAGE_CLASS_SW_EVENT_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_SW_EVENT_C 
+#include "sw_event_public.h"
+#else  /* __INLINE_SW_EVENT__ */
+#define STORAGE_CLASS_SW_EVENT_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_SW_EVENT_C STORAGE_CLASS_INLINE
+#include "sw_event_private.h"
+#endif /* __INLINE_SW_EVENT__ */
+
+#endif /* __SW_EVENT_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h
new file mode 100644
index 0000000..d294612
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h
@@ -0,0 +1,6 @@
+#ifndef __SYSTEM_TYPES_H_INCLUDED__
+#define __SYSTEM_TYPES_H_INCLUDED__
+
+#include "system_local.h"
+
+#endif /* __SYSTEM_TYPES_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h
new file mode 100644
index 0000000..7c5f1cd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h
@@ -0,0 +1,32 @@
+#ifndef __TAG_H_INCLUDED__
+#define __TAG_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and is system agnostic
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  cell specific interfaces
+ *	- private: cell specific inline implementations
+ *	- global:  inter cell constants and identifiers
+ *	- local:   cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "tag_local.h"
+
+#ifndef __INLINE_TAG__
+#define STORAGE_CLASS_TAG_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_TAG_C 
+#include "tag_public.h"
+#else  /* __INLINE_TAG__ */
+#define STORAGE_CLASS_TAG_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_TAG_C STORAGE_CLASS_INLINE
+#include "tag_private.h"
+#endif /* __INLINE_TAG__ */
+
+#endif /* __TAG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h
new file mode 100644
index 0000000..50a6bec
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h
@@ -0,0 +1,33 @@
+#ifndef __TIMED_CTRL_H_INCLUDED__
+#define __TIMED_CTRL_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "timed_ctrl_local.h"
+
+#ifndef __INLINE_TIMED_CTRL__
+#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_TIMED_CTRL_C 
+#include "timed_ctrl_public.h"
+#else  /* __INLINE_TIMED_CTRL__ */
+#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_TIMED_CTRL_C STORAGE_CLASS_INLINE
+#include "timed_ctrl_private.h"
+#endif /* __INLINE_TIMED_CTRL__ */
+
+#endif /* __TIMED_CTRL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h
new file mode 100644
index 0000000..da9e2cd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h
@@ -0,0 +1,33 @@
+#ifndef __VAMEM_H_INCLUDED__
+#define __VAMEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the VAMEM device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "vamem_local.h"
+
+#ifndef __INLINE_VAMEM__
+#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VAMEM_C 
+#include "vamem_public.h"
+#else  /* __INLINE_VAMEM__ */
+#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VAMEM_C STORAGE_CLASS_INLINE
+#include "vamem_private.h"
+#endif /* __INLINE_VAMEM__ */
+
+#endif /* __VAMEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h
new file mode 100644
index 0000000..9489f7c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h
@@ -0,0 +1,18 @@
+#ifndef __VECTOR_FUNC_H_INCLUDED__
+#define __VECTOR_FUNC_H_INCLUDED__
+
+#include "storage_class.h"
+
+#include "vector_func_local.h"
+
+#ifndef __INLINE_VECTOR_FUNC__
+#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VECTOR_FUNC_C 
+#include "vector_func_public.h"
+#else  /* __INLINE_VECTOR_FUNC__ */
+#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VECTOR_FUNC_C STORAGE_CLASS_INLINE
+#include "vector_func_private.h"
+#endif /* __INLINE_VECTOR_FUNC__ */
+
+#endif /* __VECTOR_FUNC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h
new file mode 100644
index 0000000..08b7575
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h
@@ -0,0 +1,18 @@
+#ifndef __VECTOR_OPS_H_INCLUDED__
+#define __VECTOR_OPS_H_INCLUDED__
+
+#include "storage_class.h"
+
+#include "vector_ops_local.h"
+
+#ifndef __INLINE_VECTOR_OPS__
+#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VECTOR_OPS_C 
+#include "vector_ops_public.h"
+#else  /* __INLINE_VECTOR_OPS__ */
+#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VECTOR_OPS_C STORAGE_CLASS_INLINE
+#include "vector_ops_private.h"
+#endif /* __INLINE_VECTOR_OPS__ */
+
+#endif /* __VECTOR_OPS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/csc_kernel_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/csc_kernel_global.h
new file mode 100644
index 0000000..bb2ca0d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/csc_kernel_global.h
@@ -0,0 +1,32 @@
+#ifndef __CSC_KERNEL_GLOBAL_H_INCLUDED__
+#define __CSC_KERNEL_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+/* Can we pass a pointer (that can be resolved to a constant) without ill effects */
+//typedef const struct csc_kernel_param_s	*csc_kernel_param_h;
+/* Else, can we pass a register struct (defined in csc_kernel_local.h) */
+
+/* Else, can we only pass an ID / index ? */
+typedef csc_kernel_param_set_t			csc_kernel_param_h;
+
+typedef struct csc_kernel_param_s		csc_kernel_param_t;
+
+struct csc_kernel_param_s {
+	uint16_t	m_shift;
+	int16_t		m00;
+	int16_t		m01;
+	int16_t		m02;
+	int16_t		m10;
+	int16_t		m11;
+	int16_t		m12;
+	int16_t		m20;
+	int16_t		m21;
+	int16_t		m22;
+};
+
+#endif /* __CSC_KERNEL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/host/csc_kernel_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/host/csc_kernel_local.h
new file mode 100644
index 0000000..bb70c4e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/csc/host/csc_kernel_local.h
@@ -0,0 +1,6 @@
+#ifndef __CSC_KERNEL_LOCAL_H_INCLUDED__
+#define __CSC_KERNEL_LOCAL_H_INCLUDED__
+
+#include "csc_kernel_global.h"
+
+#endif /* __CSC_KERNEL_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/host/pipeline_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/host/pipeline_local.h
new file mode 100644
index 0000000..4e5131c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/host/pipeline_local.h
@@ -0,0 +1,6 @@
+#ifndef __PIPELINE_LOCAL_H_INCLUDED__
+#define __PIPELINE_LOCAL_H_INCLUDED__
+
+#include "pipeline_global.h"
+
+#endif /* __PIPELINE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/pipeline_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/pipeline_global.h
new file mode 100644
index 0000000..049e721
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_kernel/pipeline/pipeline_global.h
@@ -0,0 +1,262 @@
+#ifndef __PIPELINE_GLOBAL_H_INCLUDED__
+#define __PIPELINE_GLOBAL_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#include "system_types.h"	/* To get the DLI version, we should not need that */
+
+#if defined(IS_ISP_2400_SYSTEM)
+#define SH_CSS_ISP_PARAMS_VERSION	2
+#define SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB	1
+#else
+#define SH_CSS_ISP_PARAMS_VERSION	1
+#define SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB	0
+#endif
+
+#define SH_CSS_MAX_STAGES	6
+
+typedef struct sh_css_isp_params		pipeline_param_t;
+typedef const struct sh_css_isp_params	*pipeline_param_h;
+//typedef const pipeline_param_t		*pipeline_param_h;
+
+typedef struct sh_css_uds_info			sh_css_uds_info_t;
+typedef struct sh_css_crop_pos			sh_css_crop_pos_t;
+
+/*
+ * Compose the pipeline (parameters) from one or more module parameter sets
+ *
+ * This file should be sperated for pipeline versions, but separation is not
+ * yet possible at CSS API level. So
+ *
+ * For ISP 1.0:
+ *	CSC_KERNEL_PARAM_SET0: CSC conversion matrix
+ *	CSC_KERNEL_PARAM_SET1: Not used
+ *
+ * For ISP 1.0:
+ *	CSC_KERNEL_PARAM_SET0: RGB 2 YUV
+ *	CSC_KERNEL_PARAM_SET1: YUV 2 RGB
+ *
+ * becomes
+ *	CSC_KERNEL_PARAM_SET0: CSC conversion matrix
+ *	CSC_KERNEL_PARAM_SET1: RGB 2 YUV
+ *	CSC_KERNEL_PARAM_SET2: YUV 2 RGB
+ *
+ * Using enums to create constants is not supported in the pipeline generator flow
+ *
+typedef enum {
+	CSC_KERNEL_PARAM_SET0 = 0,
+	CSC_KERNEL_PARAM_SET1,
+	CSC_KERNEL_PARAM_SET2,
+	N_CSC_KERNEL_PARAM_SET
+} csc_kernel_param_set_t;
+ */
+
+#define CSC_KERNEL_PARAM_SET0	0
+#define CSC_KERNEL_PARAM_SET1	1
+#define CSC_KERNEL_PARAM_SET2	2
+#define N_CSC_KERNEL_PARAM_SET	3
+typedef uint16_t	csc_kernel_param_set_t;
+
+#define pipeline_get_csc_param_set(pipeline_param, csc_kernel_param_set) csc_kernel_param_set
+#define g_ispparm_csc_param_set(csc_kernel_param) g_ispparm.csc_kernel_param[csc_kernel_param]
+
+#include "csc_kernel.h"
+
+struct sh_css_uds_info {
+	uint16_t curr_dx;
+	uint16_t curr_dy;
+	uint16_t xc;
+	uint16_t yc;
+};
+
+struct sh_css_crop_pos {
+	uint16_t x;
+	uint16_t y;
+};
+
+/* Data structures shared with ISP */
+struct sh_css_isp_params {
+	/* FPNR (Fixed Pattern Noise Reduction) */
+	int fpn_shift;
+	int fpn_enabled;
+
+	/* OB (Optical Black) */
+	int ob_blacklevel_gr;
+	int ob_blacklevel_r;
+	int ob_blacklevel_b;
+	int ob_blacklevel_gb;
+	int obarea_start_bq;
+	int obarea_length_bq;
+	int obarea_length_bq_inverse;
+
+	/* SC (Shading Corrction) */
+	int sc_gain_shift;
+
+	/* WB (White Balance) */
+	int wb_gain_shift;
+	int wb_gain_gr;
+	int wb_gain_r;
+	int wb_gain_b;
+	int wb_gain_gb;
+
+	/* DP (Defect Pixel Correction) */
+	int dp_threshold_single_when_2adjacent_on;
+	int dp_threshold_2adjacent_when_2adjacent_on;
+	int dp_threshold_single_when_2adjacent_off;
+	int dp_threshold_2adjacent_when_2adjacent_off;
+	int dp_gain;
+#if SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB
+	int dpc_coef_rr_gr;
+	int dpc_coef_rr_gb;
+	int dpc_coef_bb_gb;
+	int dpc_coef_bb_gr;
+	int dpc_coef_gr_rr;
+	int dpc_coef_gr_bb;
+	int dpc_coef_gb_bb;
+	int dpc_coef_gb_rr;
+#endif
+
+	/* BNR (Bayer Noise Reduction) */
+	int bnr_gain_all;
+	int bnr_gain_dir;
+	int bnr_threshold_low;
+	int bnr_threshold_width_log2;
+	int bnr_threshold_width;
+	int bnr_clip;
+
+	/* S3A (3A Support): coefficients to calculate Y */
+	int ae_y_coef_r;
+	int ae_y_coef_g;
+	int ae_y_coef_b;
+
+	/* S3A (3A Support): AWB level gate */
+	int awb_lg_high_raw;
+	int awb_lg_low;
+	int awb_lg_high;
+
+	/* S3A (3A Support): af fir coefficients */
+	int af_fir1[7];
+	int af_fir2[7];
+
+	/* DE (Demosaic) */
+	int de_pixelnoise;
+	int de_c1_coring_threshold;
+	int de_c2_coring_threshold;
+
+	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
+	int ynr_threshold;
+	int ynr_gain_all;
+	int ynr_gain_dir;
+	int ynryee_dirthreshold_s;
+	int ynryee_dirthreshold_g;
+	int ynryee_dirthreshold_width_log2;
+	int ynryee_dirthreshold_width;
+	int yee_detailgain;
+	int yee_coring_s;
+	int yee_coring_g;
+	int yee_scale_plus_s;
+	int yee_scale_plus_g;
+	int yee_scale_minus_s;
+	int yee_scale_minus_g;
+	int yee_clip_plus_s;
+	int yee_clip_plus_g;
+	int yee_clip_minus_s;
+	int yee_clip_minus_g;
+	int ynryee_Yclip;
+
+	/* CSC (Color Space Conversion) */
+	/* YC1C2->YCbCr */
+	csc_kernel_param_t	csc_kernel_param[N_CSC_KERNEL_PARAM_SET];
+
+	/* GC (Gamma Correction) */
+	int gamma_gain_k1;
+	int gamma_gain_k2;
+
+	/* TNR (Temporal Noise Reduction) */
+	int tnr_coef;
+	int tnr_threshold_Y;
+	int tnr_threshold_C;
+
+	/* ANR (Advance Noise Reduction) */
+	int anr_threshold;
+
+	/* CE (Chroma Enhancement) */
+	int ce_uv_level_min;
+	int ce_uv_level_max;
+
+	sh_css_crop_pos_t sp_out_crop_pos[SH_CSS_MAX_STAGES];
+	sh_css_uds_info_t uds[SH_CSS_MAX_STAGES];
+
+/* parameters for ISP pipe version 2 */
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	/* DE (Demosaic) */
+	int ecd_zip_strength;
+	int ecd_fc_strength;
+	int ecd_fc_debias;
+
+	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
+	int yee_edge_sense_gain_0;
+	int yee_edge_sense_gain_1;
+	int yee_corner_sense_gain_0;
+	int yee_corner_sense_gain_1;
+
+	/* Fringe Control */
+	int fc_gain_exp;
+	int fc_gain_pos_0;
+	int fc_gain_pos_1;
+	int fc_gain_neg_0;
+	int fc_gain_neg_1;
+	int fc_crop_pos_0;
+	int fc_crop_pos_1;
+	int fc_crop_neg_0;
+	int fc_crop_neg_1;
+
+	/* CNR */
+	int cnr_coring_u;
+	int cnr_coring_v;
+	int cnr_sense_gain_vy;
+	int cnr_sense_gain_vu;
+	int cnr_sense_gain_vv;
+	int cnr_sense_gain_hy;
+	int cnr_sense_gain_hu;
+	int cnr_sense_gain_hv;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	/* MACC */
+	int exp;
+
+/* parameters for ISP pipe version 2 */
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	/* CTC */
+	int ctc_y0;
+	int ctc_y1;
+	int ctc_y2;
+	int ctc_y3;
+	int ctc_y4;
+	int ctc_y5;
+	int ctc_ce_gain_exp;
+	int ctc_x1;
+	int ctc_x2;
+	int ctc_x3;
+	int ctc_x4;
+	int ctc_dydx0;
+	int ctc_dydx0_shift;
+	int ctc_dydx1;
+	int ctc_dydx1_shift;
+	int ctc_dydx2;
+	int ctc_dydx2_shift;
+	int ctc_dydx3;
+	int ctc_dydx3_shift;
+	int ctc_dydx4;
+	int ctc_dydx4_shift;
+
+	/* Anti-Aliasing */
+	int aa_scale;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+};
+
+#endif /* __CSC_KERNEL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.c
new file mode 100644
index 0000000..32555a3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.c
@@ -0,0 +1,389 @@
+#include "ia_css_i_host_rmgr_gen_shared.h"
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+#include <assert_support.h>
+#include <ia_css.h>
+
+//#include "memory_access.h"
+
+//#include "sh_css_debug.h"
+
+
+static enum ia_css_err set_resource_pool_size(ia_css_resource_list_t* pool, uint32_t size);
+static enum ia_css_err acquire_resource(ia_css_resource_list_t* pool, uint32_t* resource_id);
+static enum ia_css_err release_resource(ia_css_resource_list_t* pool, uint32_t resource_id);
+
+
+/* test functionality*/
+#define TEST_RM 
+#ifdef TEST_RM
+void check_aquire(ia_css_resource_type_t resource_type, uint32_t* resource_id,uint32_t expected, bool shouldfail);
+void check_release(ia_css_resource_type_t resource_type, uint32_t resource_id, bool shouldfail);
+void Test_resource_manager(void);
+#endif
+
+
+ia_css_resource_list_t g_resource_sp_thread_pool;
+ia_css_resource_list_t g_resource_queue_pool;
+
+
+/*****************************************************************************
+In the ia_css_resource_mgr_setup function the resources can be configured 
+arguments:
+resource_type: can be any enum from the ia_css_resource_type_t list
+size: the new resource pool size
+ *****************************************************************************/
+
+
+enum ia_css_err ia_css_i_host_rmgr_init_gen(ia_css_resource_type_t resource_type)
+{
+	enum ia_css_err rval = IA_CSS_ERR_INTERNAL_ERROR;
+	assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type < IA_CSS_RESOURCE_END));
+
+	switch (resource_type)
+	{
+		case IA_CSS_RESOURCE_SP_THREAD:
+		{
+			g_resource_sp_thread_pool.size = 0;
+		rval = IA_CSS_SUCCESS;
+		break;
+	}
+	case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+	{
+		g_resource_queue_pool.size = 0;
+		rval = IA_CSS_SUCCESS;
+		break;
+	}
+	default:
+	{
+		assert(0); /* Resource type not implemented please add it to the list. */
+		break;
+	}
+	}
+	return rval;
+}
+
+
+enum ia_css_err ia_css_i_host_rmgr_setup_gen(ia_css_resource_type_t resource_type, uint32_t size)
+{
+	enum ia_css_err rval = IA_CSS_ERR_INTERNAL_ERROR; 
+	assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <	IA_CSS_RESOURCE_END));
+	switch (resource_type)
+	{
+	case IA_CSS_RESOURCE_SP_THREAD:
+	{
+		return set_resource_pool_size(&g_resource_sp_thread_pool, size);
+		break;
+	}
+	case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+	{
+		return set_resource_pool_size(&g_resource_queue_pool,  size);
+		break;
+	}
+	default:
+	{
+		assert(0); /* Resource type not implemented please add it to the list. */
+		break;
+	}
+	}
+	return rval;
+}
+
+
+
+enum ia_css_err ia_css_i_host_rmgr_acq_gen(ia_css_resource_type_t resource_type, uint32_t* resource_id)
+{
+	enum ia_css_err rval = IA_CSS_ERR_INTERNAL_ERROR; 
+
+	assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <	IA_CSS_RESOURCE_END));
+	switch (resource_type)
+	{
+		case IA_CSS_RESOURCE_SP_THREAD:
+		{
+			return acquire_resource(&g_resource_sp_thread_pool, resource_id);
+			break;
+		}
+	case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+		{
+			return acquire_resource(&g_resource_queue_pool, resource_id);
+			break;
+		}
+	default:
+		{
+			assert(0);  /* Resource type not implemented please add it to the list. */
+			break;
+		}
+	}
+	return rval;
+}
+
+
+
+enum ia_css_err ia_css_i_host_rmgr_rel_gen(ia_css_resource_type_t resource_type, uint32_t resource_id)
+{
+	assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type < IA_CSS_RESOURCE_END));
+	switch (resource_type)
+	{
+		case IA_CSS_RESOURCE_SP_THREAD:
+		{
+		return release_resource(&g_resource_sp_thread_pool, resource_id);
+		break;
+		}
+		case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+		{
+			return release_resource(&g_resource_queue_pool, resource_id);
+			break;
+		}
+		default:
+		{
+			assert(0);	/* Resource type not implemented please add it to the list. */
+			break;
+		}
+	}
+	return IA_CSS_ERR_INTERNAL_ERROR; 
+}
+
+
+
+
+/**************************************************************************************************/
+/***********************              Resource manager support functions           *******************************/
+/**************************************************************************************************/
+
+
+/* set the pool size */
+static enum ia_css_err 
+set_resource_pool_size(ia_css_resource_list_t* pool, uint32_t size)
+{
+	enum ia_css_err rval = IA_CSS_SUCCESS; 
+	uint32_t i = 0;
+	if (size > IA_CSS_RESOURCE_LIST_MAX_AMOUNT) 
+		return IA_CSS_ERR_RESOURCE_LIST_TO_SMALL; 
+
+	if (size < pool->size)
+	{
+	/* Size is going to be reduced, check for reserved items */
+	for (i = size; i < pool->size; i++)
+	{
+		if (pool->list[i].reserved == IA_CSS_RESOURCE_RESERVED)
+		{
+			return IA_CSS_ERR_RESOURCE_ITEMS_STILL_ALLOCATED;
+		}
+	}
+	}
+	else
+	{
+		for (i = pool->size; i <= size; i++)
+		{
+			pool->list[i].id = i;
+		}
+	}
+	pool->size = size;
+return rval;
+}
+
+
+
+/* request for resource, if available an id will be send back */
+static enum ia_css_err 
+acquire_resource(ia_css_resource_list_t* pool, uint32_t* resource_id)
+{
+	enum ia_css_err rval = IA_CSS_ERR_RESOURCE_EXHAUSTED;
+	bool free_place_found = false;
+	uint16_t i = 0;
+	/* loop trough list */
+	for (;( i < pool->size); i++)
+	{
+		if (pool->list[i].reserved == IA_CSS_RESOURCE_AVAILABLE)
+		{
+			*resource_id = pool->list[i].id;
+			pool->list[i].reserved = IA_CSS_RESOURCE_RESERVED;
+			rval = IA_CSS_SUCCESS;
+			break;
+		}
+	}
+	return rval;
+}
+
+
+/* release resource, if available */
+static enum ia_css_err release_resource(ia_css_resource_list_t* pool, uint32_t resource_id)
+{
+	enum ia_css_err rval = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	bool resource_found = false;
+	uint16_t i = 0;
+	/* loop trough list */
+	for (;( i <= pool->size) || (resource_found == false); i++)
+	{
+		if (pool->list[i].id == resource_id)
+		{
+			resource_found = true;
+			if (pool->list[i].reserved != IA_CSS_RESOURCE_RESERVED)
+			{
+				return	IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;   
+			}
+			else
+			{
+				pool->list[i].reserved = IA_CSS_RESOURCE_AVAILABLE;
+			}
+		rval = IA_CSS_SUCCESS;
+		}
+	}
+return rval;
+}
+
+
+
+
+#ifdef TEST_RM
+
+/**************************************************************************************************/
+/***********************              Resource manager test functions                *******************************/
+/**************************************************************************************************/
+
+void check_aquire(ia_css_resource_type_t resource_type, uint32_t* resource_id,uint32_t expected, bool shouldfail)
+{
+	enum ia_css_err rval = 0;
+
+	if (!shouldfail)
+	{
+		rval = ia_css_i_host_rmgr_acq_gen(resource_type, resource_id);
+		if(rval !=IA_CSS_SUCCESS) sh_css_dtrace(SH_DBG_ERROR, "Failed rval = %d\n", rval);  
+		if (*resource_id != expected)
+			while(1);//sh_css_dtrace(SH_DBG_ERROR,"Failed: rval = %d ... expected = %d\n",*resource_id, expected);
+		else sh_css_dtrace(SH_DBG_ERROR, "Succes: resourcetype = %x - Resource	%d acquired\n", resource_type, *resource_id);	 
+			
+		
+	}
+	else
+	{
+		if (IA_CSS_ERR_RESOURCE_EXHAUSTED == ia_css_i_host_rmgr_acq_gen(resource_type, resource_id))
+			sh_css_dtrace(SH_DBG_ERROR, "Succes: resource exhausted\n"); 
+		else while(1);//	sh_css_dtrace(SH_DBG_ERROR, "Failed: error not what expected\n");  
+	}
+}
+
+void check_release(ia_css_resource_type_t resource_type, uint32_t resource_id, bool shouldfail)
+{
+	enum ia_css_err rval = 0;
+
+	if (!shouldfail)
+	{
+		rval = ia_css_i_host_rmgr_rel_gen(resource_type, resource_id);
+		if(rval !=IA_CSS_SUCCESS) while(1);//sh_css_dtrace(SH_DBG_ERROR, "Failed rval = %d\n", rval); 
+	}
+	else
+	{
+		rval = ia_css_i_host_rmgr_rel_gen(resource_type, resource_id);
+		if(rval == IA_CSS_ERR_RESOURCE_NOT_AVAILABLE) sh_css_dtrace(SH_DBG_ERROR, "Success: resource not avaliable\n"); 
+	}
+}
+
+
+
+void test_resource_manager(void)
+{
+	enum ia_css_err rval = 0;
+	uint32_t resource_id_q = 0;
+	uint32_t resource_id_thread = 0;
+	
+	//sh_css_set_dtrace_level(9);
+	
+	rval = ia_css_i_host_rmgr_init_gen(IA_CSS_RESOURCE_SP_THREAD);
+	assert(rval ==IA_CSS_SUCCESS);
+	rval = ia_css_i_host_rmgr_init_gen(IA_CSS_RESOURCE_HOST2SP_QUEUE);
+	assert(rval ==IA_CSS_SUCCESS);
+	
+	rval = ia_css_i_host_rmgr_setup_gen(IA_CSS_RESOURCE_SP_THREAD, 10);
+	assert(rval ==IA_CSS_SUCCESS);
+	rval = ia_css_i_host_rmgr_setup_gen(IA_CSS_RESOURCE_HOST2SP_QUEUE, 1111);
+	assert(rval!= IA_CSS_SUCCESS); 
+	rval = ia_css_i_host_rmgr_setup_gen(IA_CSS_RESOURCE_HOST2SP_QUEUE, 1);
+	assert(rval == IA_CSS_SUCCESS); 
+
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 0, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 1, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 2, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 3, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 4, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 5, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 6, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 7, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 8, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 9, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, IA_CSS_RESOURCE_LIST_MAX_AMOUNT, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, IA_CSS_RESOURCE_LIST_MAX_AMOUNT + 1, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, IA_CSS_RESOURCE_LIST_MAX_AMOUNT + 100, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 0, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 1, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 2, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 3, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 4, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 5, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 6, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 7, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 8, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 9, 1);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 3, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 8, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 2, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 7, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 7, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 2, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 3, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 7, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 8, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 8, 1);
+	
+
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 0, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 1, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 2, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 3, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 4, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 5, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 6, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 7, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 8, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 9, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, IA_CSS_RESOURCE_LIST_MAX_AMOUNT, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, IA_CSS_RESOURCE_LIST_MAX_AMOUNT + 1, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, IA_CSS_RESOURCE_LIST_MAX_AMOUNT + 100, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 0, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 1, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 2, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 3, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 4, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 5, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 6, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 7, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 8, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 9, 1);
+	check_release(IA_CSS_RESOURCE_HOST2SP_QUEUE, 3, 0);
+	check_release(IA_CSS_RESOURCE_HOST2SP_QUEUE, 8, 0);
+	check_release(IA_CSS_RESOURCE_HOST2SP_QUEUE, 2, 0);
+	check_release(IA_CSS_RESOURCE_HOST2SP_QUEUE, 7, 0);
+	check_release(IA_CSS_RESOURCE_HOST2SP_QUEUE, 7, 1);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 2, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 3, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 7, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 8, 0);
+	check_aquire(IA_CSS_RESOURCE_HOST2SP_QUEUE, &resource_id_q, 8, 1);
+
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 1, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 2, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 3, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 4, 0);
+	check_release(IA_CSS_RESOURCE_SP_THREAD, 2, 1);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 1, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 2, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 3, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 4, 0);
+	check_aquire(IA_CSS_RESOURCE_SP_THREAD, &resource_id_thread, 5, 1);
+
+
+
+}
+#endif
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.h
new file mode 100644
index 0000000..a4ce87c80
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_host_rmgr_gen_shared.h
@@ -0,0 +1,47 @@
+#ifndef __IA_CSS_I_RMGR_GEN_HOST_SHARED_H_INCLUDED__
+#define __IA_CSS_I_RMGR_GEN_HOST_SHARED_H_INCLUDED__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <ia_css.h>
+#include <sh_css_debug.h>
+
+
+#define IA_CSS_RESOURCE_LIST_MAX_AMOUNT 10 
+#define IA_CSS_RESOURCE_RESERVED  1
+#define IA_CSS_RESOURCE_AVAILABLE 0
+
+
+typedef enum ia_css_resource_type
+{
+    IA_CSS_RESOURCE_START  = 1230,     // start at random number for code robustness, 
+    IA_CSS_RESOURCE_SP_THREAD,        // register the threads of the sp
+    IA_CSS_RESOURCE_HOST2SP_QUEUE,    // register the host to sp queues
+    IA_CSS_RESOURCE_END               
+}ia_css_resource_type_t;
+
+typedef struct ia_css_resource_list_item
+{
+    uint32_t id;
+    uint16_t reserved;
+}ia_css_resource_list_item_t;
+
+typedef struct ia_css_resource_list
+{
+    ia_css_resource_list_item_t list[IA_CSS_RESOURCE_LIST_MAX_AMOUNT];
+    uint16_t size;
+}ia_css_resource_list_t;
+void test_resource_manager(void);
+
+
+enum ia_css_err ia_css_i_host_rmgr_init_gen(ia_css_resource_type_t resource_type);
+enum ia_css_err ia_css_i_host_rmgr_setup_gen(ia_css_resource_type_t resource_type, uint32_t size);
+enum ia_css_err ia_css_i_host_rmgr_acq_gen(ia_css_resource_type_t resource_type, uint32_t* resource_id);
+enum ia_css_err ia_css_i_host_rmgr_rel_gen(ia_css_resource_type_t resource_type, uint32_t size);
+
+
+
+#endif /* __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_gen_shared.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_gen_shared.c
new file mode 100644
index 0000000..4a589398
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_gen_shared.c
@@ -0,0 +1,265 @@
+#include "ia_css_i_host_rmgr_gen_shared.h"
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include <assert_support.h>
+#include <ia_css.h>
+
+//#include "memory_access.h"
+
+//#include "sh_css_debug.h"
+
+
+#define IA_CSS_RESOURCE_LIST_MAX_AMOUNT 10 
+#define IA_CSS_RESOURCE_RESERVED  1
+#define IA_CSS_RESOURCE_AVAILABLE 0
+
+
+#error
+
+
+ia_css_err_t set_resource_pool_size(ia_css_resource_list_t* pool, uint32_t size);
+ia_css_err_t acquire_resource(ia_css_resource_list_t* pool, uint32_t* resource_id);
+ia_css_err_t release_resource(ia_css_resource_list_t* pool, uint32_t resource_id);
+
+
+typedef enum ia_css_resource_type
+(
+    IA_CSS_RESOURCE_START  = 1230,     // start at random number for code robustness, 
+    IA_CSS_RESOURCE_SP_THREAD,        // register the threads of the sp
+    IA_CSS_RESOURCE_HOST2SP_QUEUE,    // register the host to sp queues
+    IA_CSS_RESOURCE_END               
+}ia_css_resource_type_t;
+
+typedef struct ia_css_resource_list_item
+{
+    uint32_t id;
+    uint16_t reserved;
+}ia_css_resource_list_item_t
+
+typedef struct ia_css_resource_list
+{
+    ia_css_resource_list_item_t list[IA_CSS_RESOURCE_LIST_MAX_AMOUNT];
+    uint16_t size;
+}ia_css_resource_list_t;
+
+
+ia_css_resource_list_t g_resource_sp_thread_pool;
+ia_css_resource_list_t g_resource_queue_pool;
+
+
+/*****************************************************************************
+ In the ia_css_resource_mgr_setup function the resources can be configured 
+  arguments:                                                                
+  resource_type: can be any enum from the ia_css_resource_type_t list       
+  size: the new resource pool size                                          
+ *****************************************************************************/
+
+ia_css_i_host_rmgr_init_gen
+
+ia_css_err_t ia_css_i_host_rmgr_init_gen(ia_css_resource_type_t resource_type)
+{
+    ia_css_err_t rval = IA_CSS_ERR_INTERNAL_ERROR; 
+    assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <  IA_CSS_RESOURCE_END));
+    switch (resource_type)
+    {
+        case IA_CSS_RESOURCE_SP_THREAD:
+        {
+           g_resource_sp_thread_pool.size = 0;
+           rval = IA_CSS_SUCCESS;
+           break;
+        }
+        case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+        {
+            g_resource_queue_pool.size = 0;
+            rval = IA_CSS_SUCCESS;
+            break;
+        }
+        default:
+        {
+            assert(0); /* Resource type not implemented please add it to the list. */
+            break;
+        }
+    }
+    return rval;
+}
+
+ia_css_i_host_rmgr_setup_gen
+
+ia_css_err_t ia_css_i_host_rmgr_setup_gen(ia_css_resource_type_t resource_type, uint32_t size)
+{
+    ia_css_err_t rval = IA_CSS_ERR_INTERNAL_ERROR; 
+    assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <  IA_CSS_RESOURCE_END));
+    switch (resource_type)
+    {
+        case IA_CSS_RESOURCE_SP_THREAD:
+        {
+           return set_resource_pool_size(&g_resource_sp_thread_pool, uint32_t size);
+           break;
+        }
+        case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+        {
+            return set_resource_pool_size(&g_resource_queue_pool, uint32_t size);
+            break;
+        }
+        default:
+        {
+            assert(0); /* Resource type not implemented please add it to the list. */
+            break;
+        }
+    }
+    return rval;
+}
+
+
+
+ia_css_err_t ia_css_i_host_rmgr_acq_gen(ia_css_resource_type_t resource_type, void* id)
+{
+    ia_css_err_t rval = IA_CSS_ERR_INTERNAL_ERROR; 
+
+    assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <  IA_CSS_RESOURCE_END));
+    switch (resource_type)
+    {
+       case IA_CSS_RESOURCE_SP_THREAD:
+       {
+          return acquire_resource(&g_resource_sp_thread_pool, id)
+          break;
+       }
+       case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+       {
+          return acquire_resource(&g_resource_queue_pool, id);
+          break;
+       }
+       default:
+       {
+          assert(0);  /* Resource type not implemented please add it to the list. */
+          break;
+       }
+    }
+    return rval;
+}
+
+
+
+void* ia_css_i_host_rmgr_rel_gen(ia_css_resource_type resource_type, uint32_t size)
+{
+    assert((resource_type > IA_CSS_RESOURCE_START) && (resource_type <  IA_CSS_RESOURCE_END));
+    switch (resource_type)
+    {
+        case IA_CSS_RESOURCE_SP_THREAD:
+        {
+            return release_resource(&g_resource_sp_thread_pool, id);
+            break;
+        }
+        case IA_CSS_RESOURCE_HOST2SP_QUEUE:
+        {
+            return release_resource(&g_resource_queue_pool, id);
+            break;
+        }
+        default:
+        {
+            assert(0);  /* Resource type not implemented please add it to the list. */
+            break;
+        }
+    }
+}
+
+
+
+
+/**************************************************************************************************/
+/***********************          Resource   manager support functions             *******************************/
+/**************************************************************************************************/
+
+
+/* set the pool size */
+static ia_css_err_t set_resource_pool_size(ia_css_resource_list_t* pool, uint32_t size)
+{
+    ia_css_err_t rval = IA_CSS_SUCCESS; 
+    uint32_t i = 0;
+    if (size > IA_CSS_RESOURCE_LIST_MAX_AMOUNT) return IA_CSS_ERR_RESOURCE_LIST_TO_SMALL; 
+
+    if (size < pool->size)
+    {   
+        /* Size is going to be reduced, check for reserved items */
+        for (i = size; i <= pool->size; i++)
+        {
+            if (pool->list[i].reserved == IA_CSS_RESOURCE_RESERVED)
+            {
+                return IA_CSS_ERR_RESOURCE_ITEMS_STILL_ALLOCATED;
+            }
+        }
+    }
+    else
+    {
+        for (i = pool->size; i <= size; i++)
+        {
+            pool->list[i].id = i;
+        }
+    }
+    pool->size = size;
+    return rval;
+}
+
+
+
+/* request for resource, if available an id will be send back */
+static ia_css_err_t acquire_resource(ia_css_resource_list_t* pool, uint32_t* resource_id)
+{
+    ia_css_err_t rval = IA_CSS_ERR_RESOURCE_EXHAUSTED;
+    bool free_place_found = false;
+    uint16_t i = 0;
+    /* loop trough list */
+    for (;( i <= pool->size) || (free_place_found == false); i++)
+    {
+        if (pool->list[i].reserved == IA_CSS_RESOURCE_AVAILABLE)
+        {
+            free_place_found = true;
+            resource_id = pool->list[i].id;
+            pool->list[i].reserved = IA_CSS_RESOURCE_RESERVED;
+            rval = IA_CSS_SUCCESS;
+        }
+    }
+    
+    return rval;
+}
+
+
+/* release resource, if available */
+static ia_css_err_t release_resource(ia_css_resource_list_t* pool, uint32_t resource_id)
+{
+    ia_css_err_t rval = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+    bool resource_found = false;
+    uint16_t i = 0;
+    /* loop trough list */
+    for (;( i <= pool->size) || (resource_found == false); i++)
+    {
+        if (pool->list[i].id == resource_id)
+        {
+            resource_found = true;
+            if (pool->list[i].reserved != IA_CSS_RESOURCE_RESERVED)
+            {
+                return  IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;   
+            }
+            else
+            {
+                pool->list[i].reserved = IA_CSS_RESOURCE_AVAILABLE;
+            }
+
+            rval = IA_CSS_SUCCESS;
+        }
+    }
+    
+    return rval;
+}
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
new file mode 100644
index 0000000..1dff832
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
@@ -0,0 +1,23 @@
+#include "ia_css_i_rmgr.h"
+
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+
+#include <assert_support.h>
+
+
+void ia_css_i_host_rmgr_init(void)
+{
+	ia_css_i_host_rmgr_init_vbuf(vbuf_ref);
+	ia_css_i_host_rmgr_init_vbuf(vbuf_write);
+	ia_css_i_host_rmgr_init_vbuf(hmm_buffer_pool);
+}
+
+void ia_css_i_host_rmgr_uninit(void)
+{
+	ia_css_i_host_rmgr_uninit_vbuf(hmm_buffer_pool);
+	ia_css_i_host_rmgr_uninit_vbuf(vbuf_write);
+	ia_css_i_host_rmgr_uninit_vbuf(vbuf_ref);
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
new file mode 100644
index 0000000..2f101aa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
@@ -0,0 +1,245 @@
+#include "ia_css_i_rmgr.h"
+#ifndef __KERNEL__
+#include <stdbool.h>
+#endif
+#include <assert_support.h>
+
+#include "memory_access.h"
+
+#include "sh_css_debug.h"
+
+#define NUM_HANDLES 1000
+struct ia_css_i_host_rmgr_vbuf_handle handle_table[NUM_HANDLES];
+
+struct ia_css_i_host_rmgr_vbuf_pool refpool = {
+	false, /* copy_on_write */ \
+	false, /* recycle */ \
+	0,     /* size */ \
+	0,     /* index */ \
+	NULL,  /* handles */ \
+};
+
+struct ia_css_i_host_rmgr_vbuf_pool writepool = {
+	true, /* copy_on_write */ \
+	false, /* recycle */ \
+	0,     /* size */ \
+	0,     /* index */ \
+	NULL,  /* handles */ \
+};
+
+struct ia_css_i_host_rmgr_vbuf_pool hmmbufferpool = {
+	true, /* copy_on_write */ \
+	true, /* recycle */ \
+	20,    /* size */ \
+	0,     /* index */ \
+	NULL,  /* handles */ \
+};
+
+struct ia_css_i_host_rmgr_vbuf_pool *vbuf_ref = &refpool;
+struct ia_css_i_host_rmgr_vbuf_pool *vbuf_write = &writepool;
+struct ia_css_i_host_rmgr_vbuf_pool *hmm_buffer_pool = &hmmbufferpool;
+
+static void ia_css_i_host_refcount_init_vbuf(void)
+{
+	/* initialize the refcount table */
+	memset(&handle_table, 0, sizeof(handle_table));
+}
+
+void ia_css_i_host_refcount_retain_vbuf(
+		struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	int i;
+	struct ia_css_i_host_rmgr_vbuf_handle *h;
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	/* new vbuf to count on */
+	if ((*handle)->count == 0) {
+		h = *handle;
+		*handle = NULL;
+		for (i = 0; i < NUM_HANDLES; i++) {
+			if (handle_table[i].count == 0) {
+				*handle = &handle_table[i];
+				break;
+			}
+		}
+		assert(*handle != NULL);
+		(*handle)->vptr = h->vptr;
+		(*handle)->size = h->size;
+	}
+	(*handle)->count++;
+}
+
+
+void ia_css_i_host_refcount_release_vbuf(
+		struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	assert((*handle)->count != 0);
+	/* decrease reference count */
+	(*handle)->count--;
+	/* remove from admin */
+	if ((*handle)->count == 0) {
+		(*handle)->vptr = 0x0;
+		(*handle)->size = 0;
+		*handle = NULL;
+	}
+}
+
+void ia_css_i_host_rmgr_init_vbuf(struct ia_css_i_host_rmgr_vbuf_pool *pool)
+{
+	size_t bytes_needed;
+	ia_css_i_host_refcount_init_vbuf();
+	assert(pool != NULL);
+	if (pool == NULL)
+		return;
+	/* initialize the recycle pool if used */
+	if (pool->recycle && pool->size) {
+		/* allocate memory for storing the handles */
+		bytes_needed = 
+			sizeof(struct ia_css_i_host_rmgr_vbuf_handle *) *
+			pool->size;
+		pool->handles = sh_css_malloc(bytes_needed);
+		memset(pool->handles, 0, bytes_needed);
+	}
+	else {
+		/* just in case, set the size to 0 */
+		pool->size = 0;
+		pool->handles = NULL;
+	}
+}
+
+void ia_css_i_host_rmgr_uninit_vbuf(struct ia_css_i_host_rmgr_vbuf_pool *pool)
+{
+	uint32_t i;
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_i_host_rmgr_uninit_vbuf()\n");
+	assert(pool != NULL);
+	if (pool->handles != NULL) {
+		/* free the hmm buffers */
+		for (i = 0; i < pool->size; i++) {
+			if (pool->handles[i] != NULL) {
+				sh_css_dtrace(SH_DBG_TRACE,
+					"   freeing/releasing %x (count=%d)\n",
+					pool->handles[i]->vptr,
+					pool->handles[i]->count);
+				/* free memory */
+				mmgr_free(pool->handles[i]->vptr);
+				/* remove from refcount admin*/
+				ia_css_i_host_refcount_release_vbuf(
+						&pool->handles[i]);
+			}
+		}
+		/* now free the pool handles list */
+		sh_css_free(pool->handles);
+		pool->handles = NULL;
+	}
+}
+
+static
+void ia_css_i_host_rmgr_push_handle(
+	struct ia_css_i_host_rmgr_vbuf_pool *pool,
+	struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	uint32_t i;
+	bool succes = false;
+	assert(pool != NULL);
+	assert(pool->recycle);
+	assert(pool->handles != NULL);
+	assert(handle != NULL);
+	for (i = 0; i < pool->size; i++) {
+		if (pool->handles[i] == NULL) {
+			ia_css_i_host_refcount_retain_vbuf(handle);
+			pool->handles[i] = *handle;
+			succes = true;
+			break;
+		}
+	}
+	assert(succes);
+}
+
+static
+void ia_css_i_host_rmgr_pop_handle(
+	struct ia_css_i_host_rmgr_vbuf_pool *pool,
+	struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	uint32_t i;
+	bool succes = false;
+	assert(pool != NULL);
+	assert(pool->recycle);
+	assert(pool->handles != NULL);
+	assert(handle != NULL);
+	for (i = 0; i < pool->size; i++) {
+		if (pool->handles[i] != NULL && pool->handles[i]->size == (*handle)->size) {
+			*handle = pool->handles[i];
+			pool->handles[i] = NULL;
+			/* dont release, we are returning it...
+			   ia_css_i_host_refcount_release_vbuf(handle); */
+			succes = true;
+			break;
+		}
+	}
+}
+
+void ia_css_i_host_rmgr_acq_vbuf(
+	struct ia_css_i_host_rmgr_vbuf_pool *pool,
+	struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	struct ia_css_i_host_rmgr_vbuf_handle h;
+	assert(pool != NULL);
+	assert(handle != NULL);
+	if (pool->copy_on_write) {
+		/* only one reference, reuse (no new retain) */
+		if ((*handle)->count == 1)
+			return;
+		/* more than one reference, release current buffer */
+		if ((*handle)->count > 1) {
+			/* store current values */
+			h.vptr = 0x0;
+			h.size = (*handle)->size;
+			/* release ref to current buffer */
+			ia_css_i_host_refcount_release_vbuf(handle);
+			*handle = &h;
+		}
+		/* get new buffer for needed size */
+		if ((*handle)->vptr == 0x0) {
+			if (pool->recycle) {
+				/* try and pop from pool */
+				ia_css_i_host_rmgr_pop_handle(pool, handle);
+			}
+			if ((*handle)->vptr == 0x0) {
+				/* we need to allocate */
+				(*handle)->vptr = mmgr_malloc((*handle)->size);
+			}
+			else {
+				/* we popped a buffer */
+				return;
+			}
+		}
+	}
+	/* Note that handle will change to an internally maintained one */
+	ia_css_i_host_refcount_retain_vbuf(handle);
+}
+
+void ia_css_i_host_rmgr_rel_vbuf(
+	struct ia_css_i_host_rmgr_vbuf_pool *pool,
+	struct ia_css_i_host_rmgr_vbuf_handle **handle)
+{
+	assert(pool != NULL);
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	/* release the handle */
+	if ((*handle)->count == 1) {
+		if (!pool->recycle) {
+			/* non recycling pool, free mem */
+			mmgr_free((*handle)->vptr);
+		}
+		else {
+			/* recycle to pool */
+			ia_css_i_host_rmgr_push_handle(pool, handle);
+		}
+	}
+	ia_css_i_host_refcount_release_vbuf(handle);
+	*handle = NULL;
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
new file mode 100644
index 0000000..7c87420
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
@@ -0,0 +1,34 @@
+#ifndef __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__
+#define __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__
+
+#include "ia_css_i_rmgr_vbuf_public.h"
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#include "sh_css_internal.h"
+
+/* complete the types for the sp implementation of the dma resource pool */
+
+struct ia_css_i_host_rmgr_vbuf_handle {
+	hrt_vaddress vptr;
+	uint8_t count;
+	uint32_t size;
+};
+
+struct ia_css_i_host_rmgr_vbuf_pool {
+	uint8_t copy_on_write;
+	uint8_t recycle;
+	uint32_t size;
+	uint32_t index;
+	struct ia_css_i_host_rmgr_vbuf_handle **handles;
+};
+
+extern struct ia_css_i_host_rmgr_vbuf_pool *vbuf_ref;
+extern struct ia_css_i_host_rmgr_vbuf_pool *vbuf_write;
+extern struct ia_css_i_host_rmgr_vbuf_pool *hmm_buffer_pool;
+
+#endif /* __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue.c
new file mode 100644
index 0000000..37cf7fc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue.c
@@ -0,0 +1,696 @@
+
+#include "queue.h"
+
+#include "sp.h"
+#ifndef __KERNEL__
+#include <stdbool.h>	/* bool				*/
+#endif
+
+/* MW: The queue should be application agnostic */
+#include "sh_css_internal.h"
+/* sh_css_frame_id,  struct sh_css_circular_buf		*/
+
+/* MW: The queue should not depend on principal interface types */
+#include "ia_css_types.h"		/* ia_css_fw_info		*/
+
+#include "assert_support.h"
+
+#ifndef offsetof
+#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
+#endif
+
+/*
+ * MW: The interface to get events is in "event.h"
+ * presently that is wired to the HOST2SP (HW) FIFO
+ * In the case that events are signaled by interrupt
+ * and retrieved from SP, then the access mechanism
+ * to that queue must be here as it is addressed by
+ * SP_ID. The functions interpreting and acting on
+ * the event are not part of the SP device interface
+ */
+
+/*
+ * Local declarations.
+ *
+ * NOTE: Linux checkpatch cannot handle the storage class
+ * macro "STORAGE_CLASS_INLINE" that is used to hide
+ * compiler specific "inline" specifiers. To maintain
+ * portability do not force inline.
+ */
+
+/************************************************************
+ *
+ * Generic queues.
+ *
+ ************************************************************/
+/*! The Host initialize the target "host2sp" queue.
+
+ @param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_communication"
+ */
+/*STORAGE_CLASS_INLINE void init_sp_queue(*/
+static void init_sp_queue(
+	struct sh_css_circular_buf *offset);
+
+/*! Push an element to the queue.
+
+ @param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_communication".
+ @param elem[in]	the element to be enqueued.
+ */
+/*STORAGE_CLASS_INLINE bool push_sp_queue(*/
+static void push_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int elem);
+
+/*! Pop an element from the queue.
+
+ @param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_communication".
+ @param elem[in]	the element to be dequeued.
+ */
+/*STORAGE_CLASS_INLINE bool pop_sp_queue(*/
+static void pop_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int *elem);
+
+
+/*! Check whether the "host2sp" queue is full or not.
+
+ @param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_communication".
+
+ \return true if the queue is full
+ */
+/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
+static bool is_sp_queue_full(
+	struct sh_css_circular_buf *offset);
+
+/*! Check whether the "host2sp" queue is empty or not.
+
+ \param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_queuemunication".
+
+ \return true if the queue is empty
+ */
+/*STORAGE_CLASS_INLINE bool is_sp_queue_empty(*/
+static bool is_sp_queue_empty(
+	struct sh_css_circular_buf *offset);
+
+/*
+ * The compiler complains that "warning: dump_sp_queue defined
+ * but not used", which treats warnings as errors. So dump_sp_queue
+ * is disabled. Enable it as soon as it is used.
+ */
+#if 0
+/*! The Host prints the contents within the target "host2sp" queue.
+
+ \param	offset[in]	The target queue's offset that is
+			relative to the base address of the struct
+			"host_sp_queuemunication"
+ */
+/*STORAGE_CLASS_INLINE void dump_sp_queue(*/
+static void dump_sp_queue(
+	struct sh_css_circular_buf *offset);
+#endif
+/* end of local declarations */
+
+#ifndef __INLINE_QUEUE__
+#include "queue_private.h"
+#endif /* __INLINE_QUEUE__ */
+
+/************************************************************
+ *
+ * Application-specific queues.
+ *
+ ************************************************************/
+void init_host2sp_queues(void)
+{
+	unsigned int i, j;
+	struct sh_css_circular_buf *offset_to_queue;
+
+	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
+		for (j = 0; j < SH_CSS_NUM_BUFFER_QUEUES; j++) {
+			offset_to_queue = (struct sh_css_circular_buf *)
+				offsetof(struct host_sp_queues,
+					host2sp_buffer_queues[i][j]);
+			init_sp_queue(offset_to_queue);
+		}
+	}
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			host2sp_event_queue);
+	init_sp_queue(offset_to_queue);
+}
+
+void init_sp2host_queues(void)
+{
+	unsigned int j;
+//	struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+
+	for (j = 0; j < SH_CSS_NUM_BUFFER_QUEUES; j++) {
+		offset_to_queue = (struct sh_css_circular_buf *)
+			offsetof(struct host_sp_queues,
+				sp2host_buffer_queues[j]);
+		init_sp_queue(offset_to_queue);
+		//init_sp_queue(&my_queues->sp2host_buffer_queues[j]);
+	}
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			sp2host_event_queue);
+	init_sp_queue(offset_to_queue);
+//	init_sp_queue(&my_queues->sp2host_event_queue);
+}
+
+/************************************************************
+ *
+ * Buffer queues (direction: the host -> the SP).
+ *
+ ************************************************************/
+bool host2sp_enqueue_buffer(
+	unsigned int pipe_num,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t buffer_ptr)
+{
+	bool is_full;
+//	struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+
+	(void)stage_num;
+
+assert(pipe_num < SH_CSS_MAX_SP_THREADS);
+assert((index < SH_CSS_NUM_BUFFER_QUEUES));
+
+	if (pipe_num >= SH_CSS_MAX_SP_THREADS)
+		return false;
+
+	/* This is just the first step of introducing the queue API */
+	/* The implementation is still the old non-queue implementation */
+	/* till the new queue implementation is there */
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			host2sp_buffer_queues[pipe_num][index]);
+
+	/* check whether both queues are full or not */
+	is_full = is_sp_queue_full(offset_to_queue);
+
+	if (!is_full) {
+		/* push elements into the queues */
+		push_sp_queue(offset_to_queue, (uint32_t)buffer_ptr);
+	}
+
+
+	return !is_full;
+}
+
+/************************************************************
+ *
+ * Buffer queues (direction: the host -> the SP).
+ *
+ ************************************************************/
+bool host2sp_dequeue_buffer(
+	unsigned int thread_id,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t *buffer_ptr)
+{
+	bool is_empty;
+	uint32_t elem;
+//	struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+
+	(void)stage_num;
+
+assert(thread_id < SH_CSS_MAX_SP_THREADS);
+assert((index < SH_CSS_NUM_BUFFER_QUEUES));
+
+	if (thread_id >= SH_CSS_MAX_SP_THREADS)
+		return false;
+
+	/* This is just the first step of introducing the queue API */
+	/* The implementation is still the old non-queue implementation */
+	/* till the new queue implementation is there */
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			host2sp_buffer_queues[thread_id][index]);
+
+	/* check whether the queue is empty or not */
+	is_empty = is_sp_queue_empty(offset_to_queue);
+
+	/* pop when both queue is not empty */
+	if (!is_empty) {
+		/* pop element from the queue */
+		pop_sp_queue(offset_to_queue, &elem);
+
+		/* set the frame data */
+		*buffer_ptr = elem;
+	}
+
+	return !is_empty;
+}
+
+/************************************************************
+ *
+ * Event queues (the host -> the SP).
+ *
+ ************************************************************/
+bool host2sp_enqueue_sp_event(
+		uint32_t event)
+{
+	bool is_full;
+	//struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			host2sp_event_queue);
+
+	/* check whether the queue is full or not */
+	is_full = is_sp_queue_full(offset_to_queue);
+
+	if (!is_full) {
+		/* push elements into the queues */
+		push_sp_queue(offset_to_queue, event);
+	}
+
+	return !is_full;
+}
+
+/************************************************************
+ *
+ * Buffer queues (the SP -> the host).
+ *
+ ************************************************************/
+bool sp2host_dequeue_buffer(
+	unsigned int pipe_num,
+	unsigned int stage_num,
+	enum sh_css_buffer_queue_id index,
+	uint32_t *buffer_ptr)
+{
+	uint32_t elem;
+	bool is_empty;
+	//struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			sp2host_buffer_queues[index]);
+
+	(void)stage_num;
+	(void)pipe_num;
+
+assert((index < SH_CSS_NUM_BUFFER_QUEUES));
+
+	/* This is just the first step of introducing the queue API */
+	/* The implementation is still the old non-queue implementation */
+	/* till the new queue implementation is there */
+
+	/* check whether the queue is empty or not */
+	is_empty = is_sp_queue_empty(offset_to_queue);
+
+	/* pop when both queue is not empty */
+	if (!is_empty) {
+		/* pop element from the queue */
+		pop_sp_queue(offset_to_queue, &elem);
+
+		/* set the frame data */
+		*buffer_ptr = elem;
+	}
+
+	return !is_empty;
+}
+
+/************************************************************
+ *
+ * Event queues (the SP -> the host).
+ *
+ ************************************************************/
+bool sp2host_dequeue_irq_event(
+	uint32_t *event)
+{
+	unsigned int elem;
+	bool is_empty;
+	//struct host_sp_queues *my_queues = NULL;
+	struct sh_css_circular_buf *offset_to_queue;
+	offset_to_queue = (struct sh_css_circular_buf *)
+		offsetof(struct host_sp_queues,
+			sp2host_event_queue);
+
+	/* check whether the queue is empty or not */
+	is_empty = is_sp_queue_empty(offset_to_queue);
+
+	/* pop when both queue is not empty */
+	if (!is_empty) {
+		/* pop element from the queue */
+		pop_sp_queue(offset_to_queue, &elem);
+
+		/* fill in the IRQ event */
+		*event = elem;
+	}
+
+	return !is_empty;
+}
+
+static void store_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int *size,
+	unsigned int *step,
+	unsigned int *start,
+	unsigned int *end)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+	unsigned int entry_to_cb_size  = (unsigned)&offset->size;
+	unsigned int entry_to_cb_step  = (unsigned)&offset->step;
+	unsigned int entry_to_cb_start = (unsigned)&offset->start;
+	unsigned int entry_to_cb_end   = (unsigned)&offset->end;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	/* update the contents at the entries */
+	if (size)
+		store_sp_array_uint8(host_sp_queue,
+			entry_to_cb_size / sizeof(offset->size),
+			*size);
+
+	if (step)
+		store_sp_array_uint8(host_sp_queue,
+			entry_to_cb_step / sizeof(offset->step),
+			*step);
+
+	if (start)
+		store_sp_array_uint8(host_sp_queue,
+			entry_to_cb_start / sizeof(offset->start),
+			*start);
+
+	if (end)
+		store_sp_array_uint8(host_sp_queue,
+			entry_to_cb_end / sizeof(offset->end),
+			*end);
+}
+
+static void load_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int *size,
+	unsigned int *step,
+	unsigned int *start,
+	unsigned int *end)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+	unsigned int entry_to_cb_size  = (unsigned)&offset->size;
+	unsigned int entry_to_cb_step  = (unsigned)&offset->step;
+	unsigned int entry_to_cb_start = (unsigned)&offset->start;
+	unsigned int entry_to_cb_end   = (unsigned)&offset->end;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	/* update the contents at the entries */
+	if (size)  *size  = load_sp_array_uint8(host_sp_queue,
+			entry_to_cb_size / sizeof(offset->size));
+
+	if (step)  *step  = load_sp_array_uint8(host_sp_queue,
+			entry_to_cb_step / sizeof(offset->step));
+
+	if (start) *start = load_sp_array_uint8(host_sp_queue,
+			entry_to_cb_start / sizeof(offset->start));
+
+	if (end)   *end   = load_sp_array_uint8(host_sp_queue,
+			entry_to_cb_end / sizeof(offset->end));
+}
+
+/************************************************************
+ *
+ * Generic queues.
+ *
+ ************************************************************/
+/*STORAGE_CLASS_INLINE void init_sp_queue(*/
+static void init_sp_queue(
+	struct sh_css_circular_buf *offset)
+{
+	unsigned int size  = SH_CSS_CIRCULAR_BUF_NUM_ELEMS;
+	unsigned int step  = sizeof(offset->elems[0]);
+	unsigned int start = 0;
+	unsigned int end   = 0;
+	store_sp_queue (offset, &size, &step, &start, &end);
+}
+
+/*STORAGE_CLASS_INLINE void push_sp_queue(*/
+static void push_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int elem)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+
+	unsigned int cb_size;
+	unsigned int cb_start;
+	unsigned int cb_end;
+	unsigned int entry_to_cb_elem;
+	uint32_t cb_elem;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	/* set a local copy of the circular buffer */
+	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
+
+	entry_to_cb_elem = (unsigned)&offset->elems[cb_end];
+
+	/* enqueue the element */
+	cb_elem = (uint32_t)elem;
+	store_sp_array_uint(host_sp_queue,
+			entry_to_cb_elem / sizeof(uint32_t),
+			cb_elem);
+
+	/* update the "end" index */
+	cb_end = (cb_end + 1) % cb_size;
+	store_sp_queue (offset, NULL, NULL, NULL, &cb_end);
+}
+
+/*STORAGE_CLASS_INLINE void pop_sp_queue(*/
+static void pop_sp_queue(
+	struct sh_css_circular_buf *offset,
+	unsigned int *elem)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+
+	unsigned int cb_size;
+	unsigned int cb_start;
+	unsigned int cb_end;
+
+	unsigned int entry_to_cb_elem;
+	uint32_t cb_elem;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	load_sp_queue(offset, &cb_size, NULL, &cb_start, &cb_end);
+
+	/* read from the non-empty queue */
+	entry_to_cb_elem = (unsigned)&offset->elems[cb_start];
+
+	/* dequeue the buffer */
+	cb_elem = load_sp_array_uint(host_sp_queue,
+			entry_to_cb_elem / sizeof(uint32_t));
+	*elem = (unsigned int)cb_elem;
+
+	/* update the "start" index */
+	cb_start = (cb_start + 1) % cb_size;
+	store_sp_queue(offset, NULL, NULL, &cb_start, NULL);
+}
+
+#if 1
+/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
+static bool is_sp_queue_full(
+	struct sh_css_circular_buf *offset)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+
+	unsigned int cb_size;
+	unsigned int cb_start;
+	unsigned int cb_end;
+
+	bool is_full;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
+
+	/* check whether the queue is full or not */
+	is_full = ((cb_end + 1) % cb_size == cb_start);
+
+	return is_full;
+}
+
+#else
+
+/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
+static bool is_sp_queue_full(
+        unsigned int base)
+{
+#ifndef C_RUN
+        unsigned int HIVE_ADDR_host_sp_queue;
+        const struct ia_css_fw_info *fw;
+#endif
+
+        unsigned int offset;
+
+        unsigned int entry_to_cb_fsm;
+
+        uint32_t cb_fsm;
+
+        bool is_full;
+
+#ifndef C_RUN
+        /* get the variable address from the firmware */
+        fw = &sh_css_sp_fw;
+        HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+        /* get the offsets (in words) */
+        offset = offsetof(struct sh_css_circular_buf, fsm)
+                / sizeof(int);
+
+        /* get the entries (in words) */
+        entry_to_cb_fsm = base + offset;
+
+        /* get a local copy of the circular buffer */
+        cb_fsm   = load_sp_array_uint(host_sp_queue, entry_to_cb_fsm);
+
+        /* check whether the queue is full or not */
+        is_full  = (SP_QUEUE_FSM_GET_CURR_STATE(cb_fsm) == SP_QUEUE_STATE_FULL);
+
+        return is_full;
+}
+#endif
+
+/*STORAGE_CLASS_INLINE bool is_sp_queue_empty(*/
+static bool is_sp_queue_empty(
+	struct sh_css_circular_buf *offset)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+
+	unsigned int cb_size;
+	unsigned int cb_start;
+	unsigned int cb_end;
+
+	bool is_empty;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
+
+	/* check whether the queue is full or not */
+	is_empty = (cb_start == cb_end);
+
+	return is_empty;
+}
+
+/*
+ * The compiler complains that "warning: dump_sp_queue defined
+ * but not used", which treats warnings as errors. So dump_sp_queue
+ * is disabled. Enable it as soon as it is used.
+ */
+#if 0
+/*STORAGE_CLASS_INLINE void dump_sp_queue(*/
+static void dump_sp_queue(
+	struct sh_ccs_circular_buf *offset)
+{
+#ifndef C_RUN
+	unsigned int HIVE_ADDR_host_sp_queue;
+	const struct ia_css_fw_info *fw;
+#endif
+
+	unsigned int offset_4;
+
+	unsigned int entry_to_cb_elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS];
+
+	unsigned int cb_size;
+	unsigned int cb_step;
+	unsigned int cb_start;
+	unsigned int cb_end;
+	uint32_t cb_elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS];
+
+	unsigned int i;
+
+#ifndef C_RUN
+	/* get the variable address from the firmware */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+
+	/* get the offsets (in words) */
+	offset_4 = offsetof(struct sh_css_circular_buf, elems)
+		/ sizeof(int);
+
+	/* get the entries (in words) */
+	for (i = 0; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++) {
+		entry_to_cb_elems[i] = base + offset_4;
+		entry_to_cb_elems[i] +=	i;
+	}
+
+	/* update the contents at the entries */
+	load_sp_queue (offset, &cb_size, &cb_step, &cb_start, &cb_end);
+
+	for (i = 0 ; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++) {
+		cb_elems[i] = load_sp_array_uint(host_sp_queue,
+						entry_to_cb_elems[i]);
+	}
+
+#ifdef C_RUN
+	printf("base     = %d\n", base);
+	printf("cb_size  = %d\n", cb_size);
+	printf("cb_step  = %d (bytes)\n", cb_step);
+	printf("cb_start = %d\n", cb_start);
+	printf("cb_end   = %d\n", cb_end);
+	for (i = 0 ; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++)
+		printf("cb_elems[%d] = %d\n", i, cb_elems[i]);
+
+	printf("\n");
+#endif
+}
+#endif
+/* end of local definitions */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h
new file mode 100644
index 0000000..a3d9cb4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h
@@ -0,0 +1,6 @@
+#ifndef __QUEUE_LOCAL_H_INCLUDED__
+#define __QUEUE_LOCAL_H_INCLUDED__
+
+#include "queue_global.h"
+
+#endif /* __QUEUE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h
new file mode 100644
index 0000000..ba536d8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h
@@ -0,0 +1,4 @@
+#ifndef __QUEUE_PRIVATE_H_INCLUDED__
+#define __QUEUE_PRIVATE_H_INCLUDED__
+
+#endif /* __QUEUE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event.c
new file mode 100644
index 0000000..5ccbbca
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event.c
@@ -0,0 +1,70 @@
+/****************************************************************
+ *
+ * Time: 2012-09-12, 14:23.
+ * Author: zhengjie.lu@intel.com
+ * Comment:
+ * - Extend the bit number per information. In the previous
+ *   version, the bit number per information can be 32, 16,
+ *   or 8. In this version, it is determined by the formula
+ *   "32-bit / number of information".
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#include "sw_event.h"
+#ifndef __KERNEL__
+#include <stdbool.h>		/* bool */
+#include <stddef.h>		/* NULL */
+#endif
+
+#include "assert_support.h"	/* OP___assert() */
+
+/****************************************
+ *
+ * Local declarations.
+ *
+ ****************************************/
+/* end of local declarations */
+
+#ifndef __INLINE_SW_EVENT__
+#include "sw_event_private.h"
+#endif /* __INLINE_SW_EVENT__ */
+
+/**
+ * @brief Encode the information into the software-event.
+ * Refer to "sw_event_public.h" for details.
+ */
+STORAGE_CLASS_SW_EVENT_C bool
+encode_sw_event(
+	uint32_t	*in,
+	uint32_t	nr,
+	uint32_t	*out)
+{
+	bool ret;
+	uint32_t nr_of_bits;
+	uint32_t i;
+
+OP___assert (nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
+
+	/* initialize the output */
+	*out = 0;
+	
+	/* get the number of bits per information */
+	nr_of_bits = sizeof(uint32_t) * 8 / nr;
+
+	/* compress the all inputs into a signle output */
+	for (i = 0; i < nr; i++) {
+		*out <<= nr_of_bits;
+		*out |= in[i];
+	}
+
+	/* get the return value */
+	ret = (nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
+
+	return ret;
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_local.h
new file mode 100644
index 0000000..c215cb8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_local.h
@@ -0,0 +1,16 @@
+/****************************************************************
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#ifndef __SW_EVENT_LOCAL_H_INCLUDED__
+#define __SW_EVENT_LOCAL_H_INCLUDED__
+
+#include "sw_event_global.h"
+
+#endif /* __SW_EVENT_LOCAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_private.h
new file mode 100644
index 0000000..b005fff
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/sw_event_private.h
@@ -0,0 +1,14 @@
+/****************************************************************
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#ifndef __SW_EVENT_PRIVATE_H_INCLUDED__
+#define __SW_EVENT_PRIVATE_H_INCLUDED__
+
+#endif /* __SW_EVENT_PRIVATE_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c
new file mode 100644
index 0000000..c249f92
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c
@@ -0,0 +1,78 @@
+#include "assert_support.h"
+#include "tag_local.h"
+#include "tag.h"
+
+/**
+ * @brief	Creates the tag description from the given parameters.
+ * @param[in]	num_captures
+ * @param[in]	skip
+ * @param[in]	offset
+ * @param[out]	tag_descr
+ */
+void
+sh_css_create_tag_descr(int num_captures,
+			unsigned int skip,
+			int offset,
+			unsigned int exp_id,
+			struct sh_css_tag_descr *tag_descr)
+{
+	tag_descr->num_captures = num_captures;
+	tag_descr->skip		= skip;
+	tag_descr->offset	= offset;
+	tag_descr->exp_id	= exp_id;
+}
+
+/**
+ * @brief	Encodes the members of tag description into a 32-bit value.
+ * @param[in]	tag		Pointer to the tag description
+ * @return	(unsigned int)	Encoded 32-bit tag-info
+ */
+unsigned int
+sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
+{
+	int num_captures;
+	unsigned int num_captures_sign;
+	unsigned int skip;
+	int offset;
+	unsigned int offset_sign;
+	unsigned int exp_id;
+
+	unsigned int encoded_tag;
+
+	if (tag->num_captures < 0) {
+		num_captures = -tag->num_captures;
+		num_captures_sign = 1;
+	} else {
+		num_captures = tag->num_captures;
+		num_captures_sign = 0;
+	}
+	skip = tag->skip;
+	if (tag->offset < 0) {
+		offset = -tag->offset;
+		offset_sign = 1;
+	} else {
+		offset = tag->offset;
+		offset_sign = 0;
+	}
+	exp_id = tag->exp_id;
+
+	if (exp_id != 0)
+	{
+		/* we encode either an exp_id or capture data */
+		assert((num_captures == 0) && (skip == 0) && (offset == 0));
+
+		encoded_tag = TAG_EXP | (exp_id & 0xFF) << TAG_EXP_ID_SHIFT;
+	}
+	else
+	{
+		encoded_tag = TAG_CAP 
+				| ((num_captures_sign & 0x00000001) << TAG_NUM_CAPTURES_SIGN_SHIFT)
+				| ((offset_sign       & 0x00000001) << TAG_OFFSET_SIGN_SHIFT)
+				| ((num_captures      & 0x000000FF) << TAG_NUM_CAPTURES_SHIFT)
+				| ((skip              & 0x000000FF) << TAG_OFFSET_SHIFT)
+				| ((offset            & 0x000000FF) << TAG_SKIP_SHIFT);
+
+	}
+	return encoded_tag;
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h
new file mode 100644
index 0000000..e908448
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h
@@ -0,0 +1,8 @@
+#ifndef __TAG_LOCAL_H_INCLUDED__
+#define __TAG_LOCAL_H_INCLUDED__
+
+#include "tag_global.h"
+
+#define SH_CSS_MINIMUM_TAG_ID (-1)
+
+#endif /* __TAG_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h
new file mode 100644
index 0000000..711dc2d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h
@@ -0,0 +1,4 @@
+#ifndef __TAG_PRIVATE_H_INCLUDED__
+#define __TAG_PRIVATE_H_INCLUDED__
+
+#endif /* __TAG_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h
new file mode 100644
index 0000000..3a47fc3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h
@@ -0,0 +1,5 @@
+#ifndef __QUEUE_GLOBAL_H_INCLUDED__
+#define __QUEUE_GLOBAL_H_INCLUDED__
+
+#endif /* __QUEUE_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h
new file mode 100644
index 0000000..adc569a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h
@@ -0,0 +1,47 @@
+/****************************************************************
+ *
+ * Time   : 2012-09-12, 19:22.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Define the software event IDs.
+ *
+ * Time   : 2012-09-06, 11:16.
+ * Author : zhengjie.lu@intel.com
+ * Comment:
+ * - Initial version.
+ *
+ ****************************************************************/
+
+#ifndef __SW_EVENT_GLOBAL_H_INCLUDED__
+#define __SW_EVENT_GLOBAL_H_INCLUDED__
+
+#define MAX_NR_OF_PAYLOADS_PER_SW_EVENT 4
+
+#define SP_SW_EVENT_ID_0	0	/* for the error		*/
+#define SP_SW_EVENT_ID_1	1	/* for the host2sp_buffer_queue */
+#define SP_SW_EVENT_ID_2	2	/* for the sp2host_buffer_queue */
+#define SP_SW_EVENT_ID_3	3	/* for the sp2host_event_queue  */
+#define SP_SW_EVENT_ID_4	4	/* for the start stream cmd */
+#define SP_SW_EVENT_ID_5	5	/* for the stop stream cmd  */
+
+/*********************************************
+ *
+ * Hack for Baytrail.
+ *
+ * AUTHOR: zhengjie.lu@intel.com
+ * TIME: 2013-01-19, 14:38.
+ * LOCATION: Santa Clara, U.S.A.
+ * COMMENT:
+ * Define a new Host2SP event which indicates
+ * the Host has passed the pointers of the
+ * empty MIPI buffers to the SP.
+ *
+ ********************************************/	
+#define SP_SW_EVENT_ID_6	6	/* for the completion of passing the
+					   pointers of the empty MIPI buffers
+					   from the Host to the SP
+					*/
+/** End of hack for Baytrail **/
+
+#endif /* __SW_EVENT_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h
new file mode 100644
index 0000000..68f030f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h
@@ -0,0 +1,42 @@
+#ifndef __TAG_GLOBAL_H_INCLUDED__
+#define __TAG_GLOBAL_H_INCLUDED__
+
+/* offsets for encoding/decoding the tag into an uint32_t */
+
+#define TAG_CAP	1
+#define TAG_EXP	2
+
+#define TAG_NUM_CAPTURES_SIGN_SHIFT	 6
+#define TAG_OFFSET_SIGN_SHIFT 		 7
+#define TAG_NUM_CAPTURES_SHIFT 		 8
+#define TAG_OFFSET_SHIFT 		16
+#define TAG_SKIP_SHIFT 			24
+
+#define TAG_EXP_ID_SHIFT 		 8
+
+/* Data structure containing the tagging information which is used in
+ * continuous mode to specify which frames should be captured.
+ * num_captures		The number of RAW frames to be processed to
+ *                      YUV. Setting this to -1 will make continuous
+ *                      capture run until it is stopped.
+ * skip			Skip N frames in between captures. This can be
+ *                      used to select a slower capture frame rate than
+ *                      the sensor output frame rate.
+ * offset		Start the RAW-to-YUV processing at RAW buffer
+ *                      with this offset. This allows the user to
+ *                      process RAW frames that were captured in the
+ *                      past or future.
+ * exp_id		Exposure id of the RAW frame to tag.
+ *
+ * NOTE: Either exp_id = 0 or all other fields are 0
+ *	 (so yeah, this could be a union)
+ */
+
+struct sh_css_tag_descr {
+	int num_captures;
+	unsigned int skip;
+	int offset;
+	unsigned int exp_id;
+};
+
+#endif /* __TAG_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/bits.h b/drivers/media/atomisp2/css2400/hrt/bits.h
new file mode 100644
index 0000000..af592d7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/bits.h
@@ -0,0 +1,113 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_BITS_H
+#define _HRT_BITS_H
+
+#include "defs.h"
+
+#define _hrt_ones(n) HRTCAT(_hrt_ones_, n)
+#define _hrt_ones_0x0  0x00000000U
+#define _hrt_ones_0x1  0x00000001U
+#define _hrt_ones_0x2  0x00000003U
+#define _hrt_ones_0x3  0x00000007U
+#define _hrt_ones_0x4  0x0000000FU
+#define _hrt_ones_0x5  0x0000001FU
+#define _hrt_ones_0x6  0x0000003FU
+#define _hrt_ones_0x7  0x0000007FU
+#define _hrt_ones_0x8  0x000000FFU
+#define _hrt_ones_0x9  0x000001FFU
+#define _hrt_ones_0xA  0x000003FFU
+#define _hrt_ones_0xB  0x000007FFU
+#define _hrt_ones_0xC  0x00000FFFU
+#define _hrt_ones_0xD  0x00001FFFU
+#define _hrt_ones_0xE  0x00003FFFU
+#define _hrt_ones_0xF  0x00007FFFU
+#define _hrt_ones_0x10 0x0000FFFFU
+#define _hrt_ones_0x11 0x0001FFFFU
+#define _hrt_ones_0x12 0x0003FFFFU
+#define _hrt_ones_0x13 0x0007FFFFU
+#define _hrt_ones_0x14 0x000FFFFFU
+#define _hrt_ones_0x15 0x001FFFFFU
+#define _hrt_ones_0x16 0x003FFFFFU
+#define _hrt_ones_0x17 0x007FFFFFU
+#define _hrt_ones_0x18 0x00FFFFFFU
+#define _hrt_ones_0x19 0x01FFFFFFU
+#define _hrt_ones_0x1A 0x03FFFFFFU
+#define _hrt_ones_0x1B 0x07FFFFFFU
+#define _hrt_ones_0x1C 0x0FFFFFFFU
+#define _hrt_ones_0x1D 0x1FFFFFFFU
+#define _hrt_ones_0x1E 0x3FFFFFFFU
+#define _hrt_ones_0x1F 0x7FFFFFFFU
+#define _hrt_ones_0x20 0xFFFFFFFFU
+
+#define _hrt_ones_0  _hrt_ones_0x0
+#define _hrt_ones_1  _hrt_ones_0x1
+#define _hrt_ones_2  _hrt_ones_0x2
+#define _hrt_ones_3  _hrt_ones_0x3
+#define _hrt_ones_4  _hrt_ones_0x4
+#define _hrt_ones_5  _hrt_ones_0x5
+#define _hrt_ones_6  _hrt_ones_0x6
+#define _hrt_ones_7  _hrt_ones_0x7
+#define _hrt_ones_8  _hrt_ones_0x8
+#define _hrt_ones_9  _hrt_ones_0x9
+#define _hrt_ones_10 _hrt_ones_0xA
+#define _hrt_ones_11 _hrt_ones_0xB
+#define _hrt_ones_12 _hrt_ones_0xC
+#define _hrt_ones_13 _hrt_ones_0xD
+#define _hrt_ones_14 _hrt_ones_0xE
+#define _hrt_ones_15 _hrt_ones_0xF
+#define _hrt_ones_16 _hrt_ones_0x10
+#define _hrt_ones_17 _hrt_ones_0x11
+#define _hrt_ones_18 _hrt_ones_0x12
+#define _hrt_ones_19 _hrt_ones_0x13
+#define _hrt_ones_20 _hrt_ones_0x14
+#define _hrt_ones_21 _hrt_ones_0x15
+#define _hrt_ones_22 _hrt_ones_0x16
+#define _hrt_ones_23 _hrt_ones_0x17
+#define _hrt_ones_24 _hrt_ones_0x18
+#define _hrt_ones_25 _hrt_ones_0x19
+#define _hrt_ones_26 _hrt_ones_0x1A
+#define _hrt_ones_27 _hrt_ones_0x1B
+#define _hrt_ones_28 _hrt_ones_0x1C
+#define _hrt_ones_29 _hrt_ones_0x1D
+#define _hrt_ones_30 _hrt_ones_0x1E
+#define _hrt_ones_31 _hrt_ones_0x1F
+#define _hrt_ones_32 _hrt_ones_0x20
+
+#define _hrt_mask(b, n) \
+  (_hrt_ones(n) << (b))
+#define _hrt_get_bits(w, b, n) \
+  (((w) >> (b)) & _hrt_ones(n))
+#define _hrt_set_bits(w, b, n, v) \
+  (((w) & ~_hrt_mask(b, n)) | (((v) & _hrt_ones(n)) << (b)))
+#define _hrt_get_bit(w, b) \
+  (((w) >> (b)) & 1)
+#define _hrt_set_bit(w, b, v) \
+  (((w) & (~(1 << (b)))) | (((v)&1) << (b)))
+#define _hrt_set_lower_half(w, v) \
+  _hrt_set_bits(w, 0, 16, v)
+#define _hrt_set_upper_half(w, v) \
+  _hrt_set_bits(w, 16, 16, v)
+
+#endif /* _HRT_BITS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/cell_params.h b/drivers/media/atomisp2/css2400/hrt/cell_params.h
new file mode 100644
index 0000000..55ec7f9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/cell_params.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _cell_params_h
+#define _cell_params_h
+
+#define SP_PMEM_LOG_WIDTH_BITS           6  /*Width of PC, 64 bits, 8 bytes*/
+#define SP_ICACHE_TAG_BITS               4  /*size of tag*/
+#define SP_ICACHE_SET_BITS               8  /* 256 sets*/
+#define SP_ICACHE_BLOCKS_PER_SET_BITS    1  /* 2 way associative*/
+#define SP_ICACHE_BLOCK_ADDRESS_BITS     11 /* 2048 lines capacity*/
+
+#define SP_ICACHE_ADDRESS_BITS \
+	                    (SP_ICACHE_TAG_BITS+SP_ICACHE_BLOCK_ADDRESS_BITS)
+
+#define SP_PMEM_DEPTH        (1<<SP_ICACHE_ADDRESS_BITS)
+
+#define SP_FIFO_0_DEPTH      0
+#define SP_FIFO_1_DEPTH      0
+#define SP_FIFO_2_DEPTH      0
+#define SP_FIFO_3_DEPTH      0
+#define SP_FIFO_4_DEPTH      0
+#define SP_FIFO_5_DEPTH      0
+#define SP_FIFO_6_DEPTH      0
+#define SP_FIFO_7_DEPTH      0
+
+
+#define SP_SLV_BUS_MAXBURSTSIZE        1
+
+#endif /* _cell_params_h */
+
diff --git a/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h
new file mode 100644
index 0000000..a89839f8a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h
@@ -0,0 +1,209 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _css_receiver_2400_common_defs_h_
+#define _css_receiver_2400_common_defs_h_
+#ifndef _mipi_backend_common_defs_h_
+#define _mipi_backend_common_defs_h_
+
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH     16
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH     2
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH  3
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH (_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH      32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */ 
+
+/* Definition of data format ID at the interface CSS_receiver capture/acquisition units */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8          24   /* 01 1000 YUV420 8-bit                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10         25   /* 01 1001  YUV420 10-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L         26   /* 01 1010   YUV420 8-bit legacy                               */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8          30   /* 01 1110   YUV422 8-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10         31   /* 01 1111   YUV422 10-bit                                     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444            32   /* 10 0000   RGB444                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555            33   /* 10 0001   RGB555                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565            34   /* 10 0010   RGB565                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666            35   /* 10 0011   RGB666                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888            36   /* 10 0100   RGB888                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6              40   /* 10 1000   RAW6                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7              41   /* 10 1001   RAW7                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8              42   /* 10 1010   RAW8                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10             43   /* 10 1011   RAW10                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12             44   /* 10 1100   RAW12                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14             45   /* 10 1101   RAW14                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1         48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2         49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3         50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4         51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5         52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6         53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7         54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8         55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb               18   /* 01 0010    embedded eight bit non image data                */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF                0   /* 00 0000    frame start                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF                1   /* 00 0001    frame end                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL                2   /* 00 0010    line start                                       */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL                3   /* 00 0011    line end                                         */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1            8   /* 00 1000  Generic Short Packet Code 1                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2            9   /* 00 1001    Generic Short Packet Code 2                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3           10   /* 00 1010    Generic Short Packet Code 3                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4           11   /* 00 1011    Generic Short Packet Code 4                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5           12   /* 00 1100    Generic Short Packet Code 5                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6           13   /* 00 1101    Generic Short Packet Code 6                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7           14   /* 00 1110    Generic Short Packet Code 7                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8           15   /* 00 1111    Generic Short Packet Code 8                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS     28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS    29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+/* used reseved mipi positions for these */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16             46 
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18             47 
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2           37 
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3           38 
+
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH              6
+
+/* Definition of format_types at the interface CSS --> input_selector*/
+/* !! Changes here should be copied to systems/isp/isp_css/bin/conv_transmitter_cmd.tcl !! */
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888           0  // 36 'h24
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555           1  // 33 'h
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444           2  // 32
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565           3  // 34
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666           4  // 35
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8             5  // 42 
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10            6  // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6             7  // 40
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7             8  // 41
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12            9  // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14           10  // 45
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8        11  // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10       12  // 25
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8        13  // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10       14  // 31
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1       15  // 48
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L       16  // 26
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb             17  // 18
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2       18  // 49
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3       19  // 50
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4       20  // 51
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5       21  // 52
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6       22  // 53
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7       23  // 54
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8       24  // 55
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS   25  // 28
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS  26  // 29
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16           27  // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18           28  // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2         29  // ? Option 2 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3         30  // ? Option 3 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM          31  // to signal custom decoding 
+
+/* definition for state machine of data FIFO for decode different type of data */
+#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN                 1  
+#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN                5
+#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN                1
+#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN                 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN                5
+#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN                   2 
+#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN                   2
+#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN                   2
+#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN                   9                       
+#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN                   3
+#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN                     3
+#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN                     7
+#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN                     1
+#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN                    5
+#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN                    3        
+#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN                    7
+
+#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN                      _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX                     0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH                   3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX                    3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH                  1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS                    4  /* bits per USD type */
+
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX                 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX                     6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX                 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX                 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX                     8
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP                     0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10                     1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10                     2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10                     3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12                     4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12                     5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12                     6
+
+
+/* packet bit definition */
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX                        32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS                        1
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX                      22
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS                      2
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX                     16
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS                     6
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX                   0
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS                 16
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX                     0
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS                   32
+
+
+/*************************************************************************************************/
+/* Custom Decoding                                                                               */
+/* These Custom Defs are defined based on design-time config in "csi_be_pixel_formatter.chdl" !! */
+/*************************************************************************************************/
+#define BE_CUST_EN_IDX                     0     /* 2bits */
+#define BE_CUST_EN_DATAID_IDX              2     /* 6bits MIPI DATA ID */ 
+#define BE_CUST_EN_WIDTH                   8     
+#define BE_CUST_MODE_ALL                   1     /* Enable Custom Decoding for all DATA IDs */
+#define BE_CUST_MODE_ONE                   3     /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
+
+/* Data State config = {get_bits(6bits), valid(1bit)}  */
+#define BE_CUST_DATA_STATE_S0_IDX          0     /* 7bits */ 
+#define BE_CUST_DATA_STATE_S1_IDX          7     /* 7bits */ 
+#define BE_CUST_DATA_STATE_S2_IDX          14    /* 7bits */
+#define BE_CUST_DATA_STATE_WIDTH           21    
+#define BE_CUST_DATA_STATE_VALID_IDX       0     /* 1bits */
+#define BE_CUST_DATA_STATE_GETBITS_IDX     1     /* 6bits */
+
+/* Pixel Extractor config */
+#define BE_CUST_PIX_EXT_DATA_ALIGN_IDX     0     /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_ALIGN_IDX      5     /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_MASK_IDX       10    /* 18bits */
+#define BE_CUST_PIX_EXT_PIX_EN_IDX         28    /* 1bits */
+#define BE_CUST_PIX_EXT_WIDTH              29    
+
+/* Pixel Valid & EoP config = {[eop,valid](especial), [eop,valid](normal)} */
+#define BE_CUST_PIX_VALID_EOP_P0_IDX        0    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P1_IDX        4    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P2_IDX        8    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P3_IDX        12   /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_WIDTH         16 
+#define BE_CUST_PIX_VALID_EOP_NOR_VALID_IDX 0    /* Normal (NO less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_NOR_EOP_IDX   1    /* Normal (NO less get_bits case) EoP - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_VALID_IDX 2    /* Especial (less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_EOP_IDX   3    /* Especial (less get_bits case) EoP - 1bits */
+
+#endif /* _mipi_backend_common_defs_h_ */
+#endif /* _css_receiver_2400_common_defs_h_ */ 
diff --git a/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h
new file mode 100644
index 0000000..cae9093
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h
@@ -0,0 +1,267 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _css_receiver_2400_defs_h_
+#define _css_receiver_2400_defs_h_
+
+#include "css_receiver_2400_common_defs.h"
+
+#define CSS_RECEIVER_DATA_WIDTH                8
+#define CSS_RECEIVER_RX_TRIG                   4
+#define CSS_RECEIVER_RF_WORD                  32
+#define CSS_RECEIVER_IMG_PROC_RF_ADDR         10
+#define CSS_RECEIVER_CSI_RF_ADDR               4
+#define CSS_RECEIVER_DATA_OUT                 12
+#define CSS_RECEIVER_CHN_NO                    2
+#define CSS_RECEIVER_DWORD_CNT                11
+#define CSS_RECEIVER_FORMAT_TYP                5
+#define CSS_RECEIVER_HRESPONSE                 2
+#define CSS_RECEIVER_STATE_WIDTH               3
+#define CSS_RECEIVER_FIFO_DAT                 32
+#define CSS_RECEIVER_CNT_VAL                   2
+#define CSS_RECEIVER_PRED10_VAL               10
+#define CSS_RECEIVER_PRED12_VAL               12
+#define CSS_RECEIVER_CNT_WIDTH                 8
+#define CSS_RECEIVER_WORD_CNT                 16
+#define CSS_RECEIVER_PIXEL_LEN                 6
+#define CSS_RECEIVER_PIXEL_CNT                 5
+#define CSS_RECEIVER_COMP_8_BIT                8
+#define CSS_RECEIVER_COMP_7_BIT                7
+#define CSS_RECEIVER_COMP_6_BIT                6
+
+#define CSI_CONFIG_WIDTH                       4
+
+/* division of gen_short data, ch_id and fmt_type over streaming data interface */
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     0
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     + _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_MSB     (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_MSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_MSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH       - 1)
+
+#define _HRT_CSS_RECEIVER_2400_REG_ALIGN 4
+#define _HRT_CSS_RECEIVER_2400_BYTES_PER_PKT             4
+
+#define hrt_css_receiver_2400_4_lane_port_offset  0x100
+#define hrt_css_receiver_2400_1_lane_port_offset  0x200
+#define hrt_css_receiver_2400_2_lane_port_offset  0x300
+#define hrt_css_receiver_2400_backend_port_offset 0x100
+
+#define _HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX      0
+#define _HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX        1
+#define _HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX        2
+#define _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX    3
+#define _HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX        4
+#define _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX    7
+#define _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX  8
+#define _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX  9
+#define _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX   10
+#define _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX   11
+#define _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX   12
+#define _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX     13
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX  14
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX       15
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX         16
+#define _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX      17
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX 18
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX 19
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX 20
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX 21
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX 22
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX 23
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX 24
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX 25
+#define _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX            26
+#define _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX       27
+#define _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX            28
+
+/* Interrupt bits for IRQ_STATUS and IRQ_ENABLE registers */
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT                0
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT               1
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT       2
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT        3
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT             4
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT        5
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT            6
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT         7
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT      8
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT  9
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT               10
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT                11
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT        12
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT        13
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT          14
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT            15
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT         16
+
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_CAUSE_                  "Fifo Overrun"
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_CAUSE_                 "Reserved"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_CAUSE_         "Sleep mode entry"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_CAUSE_          "Sleep mode exit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_CAUSE_               "Error high speed SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_CAUSE_          "Error high speed sync SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_CAUSE_              "Error control"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_CAUSE_           "Error correction double bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_CAUSE_        "Error correction single bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_CAUSE_    "No error"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_CAUSE_                  "Error cyclic redundancy check"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_CAUSE_                   "Error id"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_CAUSE_           "Error frame sync"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_CAUSE_           "Error frame data"
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_CAUSE_             "Data time-out"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_CAUSE_               "Error escape"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_CAUSE_            "Error line sync"
+
+/* Bits for CSI2_DEVICE_READY register */
+#define _HRT_CSS_RECEIVER_2400_CSI2_DEVICE_READY_IDX                          0
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_INIT_TIME_OUT_ERR_IDX                2
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_OVER_RUN_ERR_IDX                     3
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_SOT_SYNC_ERR_IDX                     4
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_RECEIVE_DATA_TIME_OUT_ERR_IDX        5
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_ECC_TWO_BIT_ERR_IDX                  6
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_DATA_ID_ERR_IDX                      7
+
+                                  
+/* Bits for CSI2_FUNC_PROG register */
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX    0
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS   19
+
+/* Bits for INIT_COUNT register */
+#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_IDX  0
+#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_BITS 16
+
+/* Bits for COUNT registers */
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_IDX     0
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_BITS    8
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_IDX       0
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_BITS      8
+
+/* Bits for RAW116_18_DATAID register */
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_IDX   0
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_BITS  6
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_IDX   8
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_BITS  6
+
+/* Bits for COMP_FORMAT register, this selects the compression data format */
+#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS 8
+#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_IDX  (_HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX + _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS)
+#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_BITS 8
+
+/* Bits for COMP_PREDICT register, this selects the predictor algorithm */
+#define _HRT_CSS_RECEIVER_2400_PREDICT_NO_COMP 0
+#define _HRT_CSS_RECEIVER_2400_PREDICT_1       1
+#define _HRT_CSS_RECEIVER_2400_PREDICT_2       2
+
+/* Number of bits used for the delay registers */
+#define _HRT_CSS_RECEIVER_2400_DELAY_BITS 8
+
+/* Bits for COMP_SCHEME register, this  selects the compression scheme for a VC */
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD1_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD2_BITS_IDX  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD3_BITS_IDX  10
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD4_BITS_IDX  15
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD5_BITS_IDX  20
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD6_BITS_IDX  25
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD7_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD8_BITS_IDX  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_BITS_BITS  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_IDX   0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_BITS  3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_IDX  3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_BITS 2
+
+
+/* BITS for backend RAW16 and RAW 18 registers */
+
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_IDX    0
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_BITS   6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_IDX    6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_BITS   2
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_IDX        8
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_BITS       1
+
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_IDX    0
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_BITS   6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_IDX    6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_BITS   2
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_IDX        8
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_BITS       1
+
+/* These hsync and vsync values are for HSS simulation only */
+#define _HRT_CSS_RECEIVER_2400_HSYNC_VAL (1<<16)
+#define _HRT_CSS_RECEIVER_2400_VSYNC_VAL (1<<17)
+
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_WIDTH                 28
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB              0
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB + CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB + CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_EOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT + 1)
+
+// SH Backend Register IDs
+#define _HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX              0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX                     1
+#define _HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX                  2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX             3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX             4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX             5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX             6
+#define _HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX                      7
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX             8
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX             9
+#define _HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX              10
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX              11
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX               12
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_EN_REG_IDX                 13
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_DATA_STATE_REG_IDX         14    /* Data State 0,1,2 config */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P0_REG_IDX       15    /* Pixel Extractor config for Data State 0 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P1_REG_IDX       16    /* Pixel Extractor config for Data State 0 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P2_REG_IDX       17    /* Pixel Extractor config for Data State 0 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P3_REG_IDX       18    /* Pixel Extractor config for Data State 0 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P0_REG_IDX       19    /* Pixel Extractor config for Data State 1 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P1_REG_IDX       20    /* Pixel Extractor config for Data State 1 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P2_REG_IDX       21    /* Pixel Extractor config for Data State 1 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P3_REG_IDX       22    /* Pixel Extractor config for Data State 1 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P0_REG_IDX       23    /* Pixel Extractor config for Data State 2 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P1_REG_IDX       24    /* Pixel Extractor config for Data State 2 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P2_REG_IDX       25    /* Pixel Extractor config for Data State 2 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P3_REG_IDX       26    /* Pixel Extractor config for Data State 2 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_VALID_EOP_REG_IDX      27    /* Pixel Valid & EoP config for Pix 0,1,2,3 */
+
+#define _HRT_CSS_RECEIVER_2400_BE_NOF_REGISTERS                   28
+
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_HE                          0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_RCF                         1
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PF                          2
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SM                          3
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PD                          4
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SD                          5
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_OT                          6
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_BC                          7
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_WIDTH                       8
+
+#endif /* _css_receiver_2400_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/defs.h b/drivers/media/atomisp2/css2400/hrt/defs.h
new file mode 100644
index 0000000..f95c33e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/defs.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_DEFS_H_
+#define _HRT_DEFS_H_
+
+#ifndef HRTCAT
+#define _HRTCAT(m, n)     m##n
+#define HRTCAT(m, n)      _HRTCAT(m, n)
+#endif
+
+#ifndef HRTSTR
+#define _HRTSTR(x)   #x
+#define HRTSTR(x)    _HRTSTR(x)
+#endif
+
+#ifndef HRTMIN
+#define HRTMIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef HRTMAX
+#define HRTMAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#endif /* _HRT_DEFS_H_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h b/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h
new file mode 100644
index 0000000..93bb083
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h
@@ -0,0 +1,208 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _dma_v2_defs_h
+#define _dma_v2_defs_h
+
+#define _DMA_V2_NUM_CHANNELS_ID               MaxNumChannels
+#define _DMA_V2_CONNECTIONS_ID                Connections
+#define _DMA_V2_DEV_ELEM_WIDTHS_ID            DevElemWidths
+#define _DMA_V2_DEV_FIFO_DEPTH_ID             DevFifoDepth
+#define _DMA_V2_DEV_FIFO_RD_LAT_ID            DevFifoRdLat
+#define _DMA_V2_DEV_FIFO_LAT_BYPASS_ID        DevFifoRdLatBypass
+#define _DMA_V2_DEV_NO_BURST_ID               DevNoBurst
+#define _DMA_V2_DEV_RD_ACCEPT_ID              DevRdAccept
+#define _DMA_V2_DEV_SRMD_ID                   DevSRMD
+#define _DMA_V2_DEV_HAS_CRUN_ID               CRunMasters
+#define _DMA_V2_CTRL_ACK_FIFO_DEPTH_ID        CtrlAckFifoDepth
+#define _DMA_V2_CMD_FIFO_DEPTH_ID             CommandFifoDepth
+#define _DMA_V2_CMD_FIFO_RD_LAT_ID            CommandFifoRdLat
+#define _DMA_V2_CMD_FIFO_LAT_BYPASS_ID        CommandFifoRdLatBypass
+#define _DMA_V2_NO_PACK_ID                    has_no_pack
+
+#define _DMA_V2_REG_ALIGN                4
+#define _DMA_V2_REG_ADDR_BITS            2
+
+/* Command word */
+#define _DMA_V2_CMD_IDX            0
+#define _DMA_V2_CMD_BITS           6
+#define _DMA_V2_CHANNEL_IDX        (_DMA_V2_CMD_IDX + _DMA_V2_CMD_BITS)
+#define _DMA_V2_CHANNEL_BITS       5
+
+/* The command to set a parameter contains the PARAM field next */
+#define _DMA_V2_PARAM_IDX          (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_PARAM_BITS         4
+
+/* Commands to read, write or init specific blocks contain these
+   three values */
+#define _DMA_V2_SPEC_DEV_A_XB_IDX  (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_SPEC_DEV_A_XB_BITS 8
+#define _DMA_V2_SPEC_DEV_B_XB_IDX  (_DMA_V2_SPEC_DEV_A_XB_IDX + _DMA_V2_SPEC_DEV_A_XB_BITS)
+#define _DMA_V2_SPEC_DEV_B_XB_BITS 8
+#define _DMA_V2_SPEC_YB_IDX        (_DMA_V2_SPEC_DEV_B_XB_IDX + _DMA_V2_SPEC_DEV_B_XB_BITS)
+#define _DMA_V2_SPEC_YB_BITS       (32-_DMA_V2_SPEC_DEV_B_XB_BITS-_DMA_V2_SPEC_DEV_A_XB_BITS-_DMA_V2_CMD_BITS-_DMA_V2_CHANNEL_BITS)
+
+/* */
+#define _DMA_V2_CMD_CTRL_IDX       4
+#define _DMA_V2_CMD_CTRL_BITS      4
+
+/* Packing setup word */
+#define _DMA_V2_CONNECTION_IDX     0
+#define _DMA_V2_CONNECTION_BITS    4
+#define _DMA_V2_EXTENSION_IDX      (_DMA_V2_CONNECTION_IDX + _DMA_V2_CONNECTION_BITS)
+#define _DMA_V2_EXTENSION_BITS     1
+
+/* Elements packing word */
+#define _DMA_V2_ELEMENTS_IDX        0
+#define _DMA_V2_ELEMENTS_BITS       8
+#define _DMA_V2_LEFT_CROPPING_IDX  (_DMA_V2_ELEMENTS_IDX + _DMA_V2_ELEMENTS_BITS)
+#define _DMA_V2_LEFT_CROPPING_BITS  8
+
+#define _DMA_V2_WIDTH_IDX           0
+#define _DMA_V2_WIDTH_BITS         16
+
+#define _DMA_V2_HEIGHT_IDX          0
+#define _DMA_V2_HEIGHT_BITS        16
+
+#define _DMA_V2_STRIDE_IDX          0
+#define _DMA_V2_STRIDE_BITS        32
+
+/* Command IDs */
+#define _DMA_V2_MOVE_B2A_COMMAND                             0      
+#define _DMA_V2_MOVE_B2A_BLOCK_COMMAND                       1      
+#define _DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND                 2      
+#define _DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND           3      
+#define _DMA_V2_MOVE_A2B_COMMAND                             4      
+#define _DMA_V2_MOVE_A2B_BLOCK_COMMAND                       5      
+#define _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND                 6      
+#define _DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND           7      
+#define _DMA_V2_INIT_A_COMMAND                               8      
+#define _DMA_V2_INIT_A_BLOCK_COMMAND                         9      
+#define _DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND                  10      
+#define _DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND            11      
+#define _DMA_V2_INIT_B_COMMAND                              12      
+#define _DMA_V2_INIT_B_BLOCK_COMMAND                        13      
+#define _DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND                  14      
+#define _DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND            15      
+#define _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND       + 16) 
+#define _DMA_V2_NO_ACK_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND + 16) 
+#define _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND       + 16) 
+#define _DMA_V2_NO_ACK_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND + 16) 
+#define _DMA_V2_NO_ACK_INIT_A_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND         + 16) 
+#define _DMA_V2_NO_ACK_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND   + 16) 
+#define _DMA_V2_NO_ACK_INIT_B_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND         + 16) 
+#define _DMA_V2_NO_ACK_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND   + 16) 
+#define _DMA_V2_CONFIG_CHANNEL_COMMAND                      32   
+#define _DMA_V2_SET_CHANNEL_PARAM_COMMAND                   33   
+#define _DMA_V2_SET_CRUN_COMMAND                            62   
+
+/* Channel Parameter IDs */
+#define _DMA_V2_PACKING_SETUP_PARAM                     0  
+#define _DMA_V2_STRIDE_A_PARAM                          1  
+#define _DMA_V2_ELEM_CROPPING_A_PARAM                   2  
+#define _DMA_V2_WIDTH_A_PARAM                           3  
+#define _DMA_V2_STRIDE_B_PARAM                          4  
+#define _DMA_V2_ELEM_CROPPING_B_PARAM                   5  
+#define _DMA_V2_WIDTH_B_PARAM                           6  
+#define _DMA_V2_HEIGHT_PARAM                            7  
+#define _DMA_V2_QUEUED_CMDS                             8  
+
+/* Parameter Constants */
+#define _DMA_V2_ZERO_EXTEND                             0
+#define _DMA_V2_SIGN_EXTEND                             1
+
+  /* SLAVE address map */
+#define _DMA_V2_SEL_FSM_CMD                             0
+#define _DMA_V2_SEL_CH_REG                              1
+#define _DMA_V2_SEL_CONN_GROUP                          2
+#define _DMA_V2_SEL_DEV_INTERF                          3
+
+#define _DMA_V2_ADDR_SEL_COMP_IDX                      12
+#define _DMA_V2_ADDR_SEL_COMP_BITS                      4
+#define _DMA_V2_ADDR_SEL_CH_REG_IDX                     2
+#define _DMA_V2_ADDR_SEL_CH_REG_BITS                    6
+#define _DMA_V2_ADDR_SEL_PARAM_IDX                      (_DMA_V2_ADDR_SEL_CH_REG_BITS+_DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define _DMA_V2_ADDR_SEL_PARAM_BITS                     4
+
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_IDX                 2
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_BITS                6
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX            (_DMA_V2_ADDR_SEL_GROUP_COMP_BITS + _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS           4
+
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX             2
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS            6
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX            (_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX+_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS)
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS           4
+
+#define _DMA_V2_FSM_GROUP_CMD_IDX                       0
+#define _DMA_V2_FSM_GROUP_ADDR_SRC_IDX                  1
+#define _DMA_V2_FSM_GROUP_ADDR_DEST_IDX                 2
+#define _DMA_V2_FSM_GROUP_CMD_CTRL_IDX                  3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_IDX                  4
+#define _DMA_V2_FSM_GROUP_FSM_PACK_IDX                  5
+#define _DMA_V2_FSM_GROUP_FSM_REQ_IDX                   6
+#define _DMA_V2_FSM_GROUP_FSM_WR_IDX                    7
+  
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX            0
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX          1
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX         2
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX       3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX           4
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX           5
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX     6
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX      7
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX          8
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX        9
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX     10
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX      11
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX      12
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX   13
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX    14
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX        15
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_CMD_CTRL_IDX        15
+
+#define _DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX            0
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX           1
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX       2
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX        3
+
+#define _DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX             0
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX            1
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX            2
+#define _DMA_V2_FSM_GROUP_FSM_REQ_XB_REMAINING_IDX      3
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_BURST_IDX         4
+
+#define _DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX              0
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX             1
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX             2
+#define _DMA_V2_FSM_GROUP_FSM_WR_XB_REMAINING_IDX       3
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_BURST_IDX          4
+
+#define _DMA_V2_DEV_INTERF_REQ_SIDE_STATUS_IDX          0
+#define _DMA_V2_DEV_INTERF_SEND_SIDE_STATUS_IDX         1
+#define _DMA_V2_DEV_INTERF_FIFO_STATUS_IDX              2
+#define _DMA_V2_DEV_INTERF_REQ_ONLY_COMPLETE_BURST_IDX  3
+#define _DMA_V2_DEV_INTERF_MAX_BURST_IDX                4
+#define _DMA_V2_DEV_INTERF_CHK_ADDR_ALIGN               5
+
+#endif /* _dma_v2_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h b/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h
new file mode 100644
index 0000000..ec7a2da
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h
@@ -0,0 +1,179 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef HRT_GDC_v2_defs_h_
+#define HRT_GDC_v2_defs_h_
+
+#define HRT_GDC_IS_V2
+
+#define HRT_GDC_N                     1024 /* Top-level design constant, equal to the number of entries in the LUT      */
+#define HRT_GDC_FRAC_BITS               10 /* Number of fractional bits in the GDC block, driven by the size of the LUT */
+
+#define HRT_GDC_BLI_FRAC_BITS            4 /* Number of fractional bits for the bi-linear interpolation type            */
+#define HRT_GDC_BLI_COEF_ONE             (1 << HRT_GDC_BLI_FRAC_BITS)
+
+#define HRT_GDC_BCI_COEF_BITS           14 /* 14 bits per coefficient                                                   */
+#define HRT_GDC_BCI_COEF_ONE             (1 << (HRT_GDC_BCI_COEF_BITS-2))  /* We represent signed 10 bit coefficients.  */
+                                                                        /* The supported range is [-256, .., +256]      */
+                                                                        /* in 14-bit signed notation,                   */
+                                                                        /* We need all ten bits (MSB must be zero).     */
+                                                                        /* -s is inserted to solve this issue, and      */
+                                                                        /* therefore "1" is equal to +256.              */
+#define HRT_GDC_BCI_COEF_MASK            ((1 << HRT_GDC_BCI_COEF_BITS) - 1) 
+
+#define HRT_GDC_LUT_BYTES                (HRT_GDC_N*4*2)                /* 1024 addresses, 4 coefficients per address,  */
+                                                                        /* 2 bytes per coefficient                      */
+
+#define _HRT_GDC_REG_ALIGN               4                              
+
+  //     31  30  29    25 24                     0
+  //  |-----|---|--------|------------------------|
+  //  | CMD | C | Reg_ID |        Value           |
+
+
+  // There are just two commands possible for the GDC block:
+  // 1 - Configure reg 
+  // 0 - Data token    
+  
+  // C      - Reserved bit
+  //          Used in protocol to indicate whether it is C-run or other type of runs
+  //          In case of C-run, this bit has a value of 1, for all the other runs, it is 0.
+
+  // Reg_ID - Address of the register to be configured
+  
+  // Value  - Value to store to the addressed register, maximum of 24 bits
+
+  // Configure reg command is not followed by any other token. 
+  // The address of the register and the data to be filled in is contained in the same token 
+  
+  // When the first data token is received, it must be:
+  //   1. FRX and FRY (device configured in one of the  scaling modes) ***DEFAULT MODE***, or,
+  //   2. P0'X        (device configured in one of the tetragon modes)
+  // After the first data token is received, pre-defined number of tokens with the following meaning follow:
+  //   1. two  tokens: SRC address ; DST address
+  //   2. nine tokens: P0'Y, .., P3'Y ; SRC address ; DST address
+  
+#define HRT_GDC_CONFIG_CMD             1
+#define HRT_GDC_DATA_CMD               0
+
+
+#define HRT_GDC_CMD_POS               31
+#define HRT_GDC_CMD_BITS               1
+#define HRT_GDC_CRUN_POS              30
+#define HRT_GDC_REG_ID_POS            25
+#define HRT_GDC_REG_ID_BITS            5
+#define HRT_GDC_DATA_POS               0
+#define HRT_GDC_DATA_BITS             25
+
+#define HRT_GDC_FRYIPXFRX_BITS        26
+#define HRT_GDC_P0X_BITS              23
+
+
+#define HRT_GDC_MAX_OXDIM           (8192-64)
+#define HRT_GDC_MAX_OYDIM           4095
+#define HRT_GDC_MAX_IXDIM           (8192-64)
+#define HRT_GDC_MAX_IYDIM           4095
+#define HRT_GDC_MAX_DS_FAC            16
+#define HRT_GDC_MAX_DX                 (HRT_GDC_MAX_DS_FAC*HRT_GDC_N - 1)
+#define HRT_GDC_MAX_DY                 HRT_GDC_MAX_DX
+
+
+/* GDC lookup tables entries are 10 bits values, but they're
+   stored 2 by 2 as 32 bit values, yielding 16 bits per entry.
+   A GDC lookup table contains 64 * 4 elements */
+
+#define HRT_GDC_PERF_1_1_pix          0
+#define HRT_GDC_PERF_2_1_pix          1
+#define HRT_GDC_PERF_1_2_pix          2
+#define HRT_GDC_PERF_2_2_pix          3
+
+#define HRT_GDC_NND_MODE              0
+#define HRT_GDC_BLI_MODE              1
+#define HRT_GDC_BCI_MODE              2
+#define HRT_GDC_LUT_MODE              3
+
+#define HRT_GDC_SCAN_STB              0
+#define HRT_GDC_SCAN_STR              1
+
+#define HRT_GDC_MODE_SCALING          0
+#define HRT_GDC_MODE_TETRAGON         1
+
+#define HRT_GDC_LUT_COEFF_OFFSET     16 
+#define HRT_GDC_FRY_BIT_OFFSET       16 
+// FRYIPXFRX is the only register where we store two values in one field, 
+// to save one token in the scaling protocol. 
+// Like this, we have three tokens in the scaling protocol, 
+// Otherwise, we would have had four.
+// The register bit-map is:
+//   31  26 25      16 15  10 9        0
+//  |------|----------|------|----------|
+//  | XXXX |   FRY    |  IPX |   FRX    |
+
+
+#define HRT_GDC_CE_FSM0_POS           0
+#define HRT_GDC_CE_FSM0_LEN           2
+#define HRT_GDC_CE_OPY_POS            2
+#define HRT_GDC_CE_OPY_LEN           14
+#define HRT_GDC_CE_OPX_POS           16
+#define HRT_GDC_CE_OPX_LEN           16
+// CHK_ENGINE register bit-map:
+//   31            16 15        2 1  0
+//  |----------------|-----------|----|
+//  |      OPX       |    OPY    |FSM0|
+// However, for the time being at least, 
+// this implementation is meaningless in hss model,
+// So, we just return 0
+
+
+#define HRT_GDC_CHK_ENGINE_IDX        0
+#define HRT_GDC_WOIX_IDX              1
+#define HRT_GDC_WOIY_IDX              2
+#define HRT_GDC_BPP_IDX               3
+#define HRT_GDC_FRYIPXFRX_IDX         4
+#define HRT_GDC_OXDIM_IDX             5
+#define HRT_GDC_OYDIM_IDX             6
+#define HRT_GDC_SRC_ADDR_IDX          7
+#define HRT_GDC_SRC_END_ADDR_IDX      8
+#define HRT_GDC_SRC_WRAP_ADDR_IDX     9
+#define HRT_GDC_SRC_STRIDE_IDX       10
+#define HRT_GDC_DST_ADDR_IDX         11
+#define HRT_GDC_DST_STRIDE_IDX       12
+#define HRT_GDC_DX_IDX               13
+#define HRT_GDC_DY_IDX               14
+#define HRT_GDC_P0X_IDX              15
+#define HRT_GDC_P0Y_IDX              16
+#define HRT_GDC_P1X_IDX              17
+#define HRT_GDC_P1Y_IDX              18
+#define HRT_GDC_P2X_IDX              19
+#define HRT_GDC_P2Y_IDX              20
+#define HRT_GDC_P3X_IDX              21
+#define HRT_GDC_P3Y_IDX              22
+#define HRT_GDC_PERF_POINT_IDX       23  // 1x1 ; 1x2 ; 2x1 ; 2x2 pixels per cc
+#define HRT_GDC_INTERP_TYPE_IDX      24  // NND ; BLI ; BCI ; LUT
+#define HRT_GDC_SCAN_IDX             25  // 0 = STB (Slide To Bottom) ; 1 = STR (Slide To Right)
+#define HRT_GDC_PROC_MODE_IDX        26  // 0 = Scaling ; 1 = Tetragon
+
+#define HRT_GDC_LUT_IDX              32
+
+
+#endif /* HRT_GDC_v2_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h b/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h
new file mode 100644
index 0000000..a8c06a1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _gp_regs_defs_h
+#define _gp_regs_defs_h
+
+#define _HRT_GP_REGS_IS_FWD_REG_IDX 0
+
+#define _HRT_GP_REGS_REG_ALIGN 4
+
+#endif /* _gp_regs_defs_h */   
diff --git a/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h b/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h
new file mode 100644
index 0000000..c81eeb5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _gpio_block_defs_h_
+#define _gpio_block_defs_h_
+
+#define _HRT_GPIO_BLOCK_REG_ALIGN 4
+
+/* R/W registers */
+#define _gpio_block_reg_do_e			         0
+#define _gpio_block_reg_do_select		       1
+#define _gpio_block_reg_do_0			         2
+#define _gpio_block_reg_do_1			         3
+#define _gpio_block_reg_do_pwm_cnt_0	     4
+#define _gpio_block_reg_do_pwm_cnt_1	     5
+#define _gpio_block_reg_do_pwm_cnt_2	     6
+#define _gpio_block_reg_do_pwm_cnt_3	     7
+#define _gpio_block_reg_do_pwm_main_cnt    8
+#define _gpio_block_reg_do_pwm_enable      9
+#define _gpio_block_reg_di_debounce_sel	  10
+#define _gpio_block_reg_di_debounce_cnt_0	11
+#define _gpio_block_reg_di_debounce_cnt_1	12
+#define _gpio_block_reg_di_debounce_cnt_2	13
+#define _gpio_block_reg_di_debounce_cnt_3	14
+#define _gpio_block_reg_di_active_level	  15
+
+
+/* read-only registers */
+#define _gpio_block_reg_di			          16
+
+#endif /* _gpio_block_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h
new file mode 100644
index 0000000..7449faa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h
@@ -0,0 +1,441 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_defs_h__
+#define _hive_isp_css_defs_h__
+
+#ifdef SYSTEM_hive_isp_css_2400_system
+#define HIVE_ISP_CSS_IS_2400B0_SYSTEM
+#else
+#define HIVE_ISP_CSS_IS_2400A0_SYSTEM
+#endif
+
+#define HIVE_ISP_CTRL_DATA_WIDTH     32
+#define HIVE_ISP_CTRL_ADDRESS_WIDTH  32
+#define HIVE_ISP_CTRL_MAX_BURST_SIZE  1
+#define HIVE_ISP_DDR_ADDRESS_WIDTH   36
+
+#define HIVE_ISP_HOST_MAX_BURST_SIZE  8 /* host supports bursts in order to prevent repeating DDRAM accesses */
+#define HIVE_ISP_NUM_GPIO_PINS       12
+
+/* This list of vector num_elems/elem_bits pairs is valid both in C as initializer
+   and in the DMA parameter list */
+#define HIVE_ISP_DDR_DMA_SPECS {{32,  8}, {16, 16}, {18, 14}, {25, 10}, {21, 12}}
+#define HIVE_ISP_DDR_WORD_BITS 256
+#define HIVE_ISP_DDR_WORD_BYTES  (HIVE_ISP_DDR_WORD_BITS/8)
+#define HIVE_ISP_DDR_BYTES       (512 * 1024 * 1024)
+#ifdef SYSTEM_hive_isp_css_2400_system
+#define HIVE_ISP_DDR_BYTES_RTL   (127 * 1024 * 1024) /* RTL only */
+#else
+#define HIVE_ISP_DDR_BYTES_RTL   HIVE_ISP_DDR_BYTES
+#endif
+#define HIVE_ISP_DDR_SMALL_BYTES (128 * 256 / 8)
+#define HIVE_ISP_PAGE_SHIFT    12
+#define HIVE_ISP_PAGE_SIZE     (1<<HIVE_ISP_PAGE_SHIFT)
+
+#define CSS_DDR_WORD_BITS        HIVE_ISP_DDR_WORD_BITS
+#define CSS_DDR_WORD_BYTES       HIVE_ISP_DDR_WORD_BYTES
+
+/* If HIVE_ISP_DDR_BASE_OFFSET is set to a non-zero value, the wide bus just before the DDRAM gets an extra dummy port where         */
+/* address range 0 .. HIVE_ISP_DDR_BASE_OFFSET-1 maps onto. This effectively creates an offset for the DDRAM from system perspective */
+#define HIVE_ISP_DDR_BASE_OFFSET 0x120000000 /* 0x200000 */
+
+#define HIVE_DMA_ISP_BUS_CONN 0
+#define HIVE_DMA_ISP_DDR_CONN 1
+#define HIVE_DMA_BUS_DDR_CONN 2
+#define HIVE_DMA_ISP_MASTER master_port0
+#define HIVE_DMA_BUS_MASTER master_port1
+#define HIVE_DMA_DDR_MASTER master_port2
+
+#define HIVE_DMA_NUM_CHANNELS       32 /* old value was  8 */
+#define HIVE_DMA_CMD_FIFO_DEPTH     24 /* old value was 12 */
+
+#define HIVE_IF_PIXEL_WIDTH 12
+
+#ifdef SYSTEM_hive_isp_css_2400_system
+#define HIVE_MMU_TLB_SETS           8
+#else
+#define HIVE_MMU_TLB_SETS           16
+#endif
+#define HIVE_MMU_TLB_SET_BLOCKS     8
+#define HIVE_MMU_TLB_BLOCK_ELEMENTS 8
+#define HIVE_MMU_PAGE_TABLE_LEVELS  2
+#define HIVE_MMU_PAGE_BYTES         HIVE_ISP_PAGE_SIZE
+
+#define HIVE_ISP_CH_ID_BITS    2
+#define HIVE_ISP_FMT_TYPE_BITS 5
+#define HIVE_ISP_ISEL_SEL_BITS 2
+
+#define HIVE_GP_REGS_SDRAM_WAKEUP_IDX                           0
+#define HIVE_GP_REGS_IDLE_IDX                                   1
+#define HIVE_GP_REGS_IRQ_0_IDX                                  2
+#define HIVE_GP_REGS_IRQ_1_IDX                                  3
+#define HIVE_GP_REGS_SP_STREAM_STAT_IDX                         4
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IDX                       5
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IDX                        6
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IDX                        7
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_COND_IDX                8
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_COND_IDX              9
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_COND_IDX              10
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_COND_IDX              11
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_ENABLE_IDX             12
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_ENABLE_IDX           13
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_ENABLE_IDX            14
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_ENABLE_IDX            15
+#define HIVE_GP_REGS_SWITCH_PRIM_IF_IDX                        16
+#define HIVE_GP_REGS_SWITCH_GDC1_IDX                           17
+#define HIVE_GP_REGS_SWITCH_GDC2_IDX                           18
+#define HIVE_GP_REGS_SRST_IDX                                  19
+#define HIVE_GP_REGS_SLV_REG_SRST_IDX                          20
+#define HIVE_GP_REGS_VISA_REG_IDX                              21
+
+/* Bit numbers of the soft reset register */
+#define HIVE_GP_REGS_SRST_ISYS_CBUS                             0
+#define HIVE_GP_REGS_SRST_ISEL_CBUS                             1
+#define HIVE_GP_REGS_SRST_IFMT_CBUS                             2
+#define HIVE_GP_REGS_SRST_GPDEV_CBUS                            3
+#define HIVE_GP_REGS_SRST_GPIO                                  4
+#define HIVE_GP_REGS_SRST_TC                                    5
+#define HIVE_GP_REGS_SRST_GPTIMER                               6
+#define HIVE_GP_REGS_SRST_FACELLFIFOS                           7
+#ifdef SYSTEM_hive_isp_css_2400_system
+#define HIVE_GP_REGS_SRST_D_OSYS                                8
+#else
+#define HIVE_GP_REGS_SRST_OSYS                                  8
+#endif
+#define HIVE_GP_REGS_SRST_IFT_SEC_PIPE                          9
+#define HIVE_GP_REGS_SRST_GDC1                                 10
+#define HIVE_GP_REGS_SRST_GDC2                                 11
+#define HIVE_GP_REGS_SRST_VEC_BUS                              12
+#define HIVE_GP_REGS_SRST_ISP                                  13
+#define HIVE_GP_REGS_SRST_SLV_GRP_BUS                          14
+#define HIVE_GP_REGS_SRST_DMA                                  15
+#define HIVE_GP_REGS_SRST_SF_ISP_SP                            16
+#define HIVE_GP_REGS_SRST_SF_PIF_CELLS                         17
+#define HIVE_GP_REGS_SRST_SF_SIF_SP                            18
+#define HIVE_GP_REGS_SRST_SF_MC_SP                             19
+#define HIVE_GP_REGS_SRST_SF_ISYS_SP                           20
+#define HIVE_GP_REGS_SRST_SF_DMA_CELLS                         21
+#define HIVE_GP_REGS_SRST_SF_GDC1_CELLS                        22
+#define HIVE_GP_REGS_SRST_SF_GDC2_CELLS                        23
+#define HIVE_GP_REGS_SRST_SP                                   24
+#define HIVE_GP_REGS_SRST_OCP2CIO                              25
+#define HIVE_GP_REGS_SRST_NBUS                                 26
+#define HIVE_GP_REGS_SRST_HOST12BUS                            27
+#define HIVE_GP_REGS_SRST_WBUS                                 28
+#define HIVE_GP_REGS_SRST_IC_OSYS                              29
+#define HIVE_GP_REGS_SRST_WBUS_IC                              30
+
+/* Bit numbers of the slave register soft reset register */
+#define HIVE_GP_REGS_SLV_REG_SRST_DMA                           0
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC1                          1
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC2                          2
+
+/* order of the input bits for the irq controller */
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID                     10
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID                     11
+#define HIVE_GP_DEV_IRQ_SP_BIT_ID                              12
+#define HIVE_GP_DEV_IRQ_ISP_BIT_ID                             13
+#define HIVE_GP_DEV_IRQ_ISYS_BIT_ID                            14
+#define HIVE_GP_DEV_IRQ_ISEL_BIT_ID                            15
+#define HIVE_GP_DEV_IRQ_IFMT_BIT_ID                            16
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID                   17
+#define HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID                  18
+#define HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID                  19
+#define HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID                  20
+#define HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID                 21
+#define HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID                  22
+#define HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID             23
+#define HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID                   24
+#define HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID             25
+#define HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID                      26
+#define HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID                      27
+#define HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID                        28
+#define HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID                        29
+#define HIVE_GP_DEV_IRQ_DMA_BIT_ID                             30
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID                 31
+
+#define HIVE_GP_REGS_NUM_SW_IRQ_REGS                            2
+
+/* order of the input bits for the timed controller */
+#define HIVE_GP_DEV_TC_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_GP_DEV_TC_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_GP_DEV_TC_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_GP_DEV_TC_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_GP_DEV_TC_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_GP_DEV_TC_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_GP_DEV_TC_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_GP_DEV_TC_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_GP_DEV_TC_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_GP_DEV_TC_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_GP_DEV_TC_GPIO_PIN_10_BIT_ID                     10
+#define HIVE_GP_DEV_TC_GPIO_PIN_11_BIT_ID                     11
+#define HIVE_GP_DEV_TC_SP_BIT_ID                              12
+#define HIVE_GP_DEV_TC_ISP_BIT_ID                             13
+#define HIVE_GP_DEV_TC_ISYS_BIT_ID                            14
+#define HIVE_GP_DEV_TC_ISEL_BIT_ID                            15
+#define HIVE_GP_DEV_TC_IFMT_BIT_ID                            16
+#define HIVE_GP_DEV_TC_GP_TIMER_0_BIT_ID                      17
+#define HIVE_GP_DEV_TC_GP_TIMER_1_BIT_ID                      18
+#define HIVE_GP_DEV_TC_MIPI_SOL_BIT_ID                        19
+#define HIVE_GP_DEV_TC_MIPI_EOL_BIT_ID                        20
+#define HIVE_GP_DEV_TC_MIPI_SOF_BIT_ID                        21
+#define HIVE_GP_DEV_TC_MIPI_EOF_BIT_ID                        22
+#define HIVE_GP_DEV_TC_INPSYS_SM                              23
+
+/* definitions for the gp_timer block */
+#define HIVE_GP_TIMER_0                                         0
+#define HIVE_GP_TIMER_1                                         1
+#define HIVE_GP_TIMER_2                                         2
+#define HIVE_GP_TIMER_3                                         3
+#define HIVE_GP_TIMER_4                                         4
+#define HIVE_GP_TIMER_5                                         5
+#define HIVE_GP_TIMER_6                                         6
+#define HIVE_GP_TIMER_7                                         7
+#define HIVE_GP_TIMER_NUM_COUNTERS                              8
+
+#define HIVE_GP_TIMER_IRQ_0                                     0
+#define HIVE_GP_TIMER_IRQ_1                                     1
+#define HIVE_GP_TIMER_NUM_IRQS                                  2
+
+#define HIVE_GP_TIMER_GPIO_0_BIT_ID                             0
+#define HIVE_GP_TIMER_GPIO_1_BIT_ID                             1
+#define HIVE_GP_TIMER_GPIO_2_BIT_ID                             2
+#define HIVE_GP_TIMER_GPIO_3_BIT_ID                             3
+#define HIVE_GP_TIMER_GPIO_4_BIT_ID                             4
+#define HIVE_GP_TIMER_GPIO_5_BIT_ID                             5
+#define HIVE_GP_TIMER_GPIO_6_BIT_ID                             6
+#define HIVE_GP_TIMER_GPIO_7_BIT_ID                             7
+#define HIVE_GP_TIMER_GPIO_8_BIT_ID                             8
+#define HIVE_GP_TIMER_GPIO_9_BIT_ID                             9
+#define HIVE_GP_TIMER_GPIO_10_BIT_ID                           10
+#define HIVE_GP_TIMER_GPIO_11_BIT_ID                           11
+#define HIVE_GP_TIMER_INP_SYS_IRQ                              12
+#define HIVE_GP_TIMER_ISEL_IRQ                                 13
+#define HIVE_GP_TIMER_IFMT_IRQ                                 14
+#define HIVE_GP_TIMER_SP_STRMON_IRQ                            15
+#define HIVE_GP_TIMER_SP_B_STRMON_IRQ                          16
+#define HIVE_GP_TIMER_ISP_STRMON_IRQ                           17
+#define HIVE_GP_TIMER_MOD_STRMON_IRQ                           18
+#define HIVE_GP_TIMER_ISP_PMEM_ERROR_IRQ                       19
+#define HIVE_GP_TIMER_ISP_BAMEM_ERROR_IRQ                      20
+#define HIVE_GP_TIMER_ISP_DMEM_ERROR_IRQ                       21
+#define HIVE_GP_TIMER_SP_ICACHE_MEM_ERROR_IRQ                  22
+#define HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ                        23
+#define HIVE_GP_TIMER_SP_OUT_RUN_DP                            24
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0         25
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1         26
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I2         27
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I3         28
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I4         29
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I5         30
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I6         31
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I7         32
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I8         33
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I9         34
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I10        35
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0         36
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0         37
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0         38
+#define HIVE_GP_TIMER_ISP_OUT_RUN_DP                           39
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0        40
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1        41
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0        42
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0        43
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I1        44
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I2        45
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I3        46
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I4        47
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I5        48
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I6        49
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0        50
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I4_I0        51
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I5_I0        52
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I6_I0        53
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I7_I0        54                                                         
+#define HIVE_GP_TIMER_MIPI_SOL_BIT_ID                          55
+#define HIVE_GP_TIMER_MIPI_EOL_BIT_ID                          56
+#define HIVE_GP_TIMER_MIPI_SOF_BIT_ID                          57
+#define HIVE_GP_TIMER_MIPI_EOF_BIT_ID                          58
+#define HIVE_GP_TIMER_INPSYS_SM                                59
+
+/* port definitions for the streaming monitors */
+/* port definititions SP streaming monitor, monitors the status of streaming ports at the SP side of the streaming FIFO's */
+#define SP_STR_MON_PORT_SP2SIF            0
+#define SP_STR_MON_PORT_SIF2SP            1
+#define SP_STR_MON_PORT_SP2MC             2 
+#define SP_STR_MON_PORT_MC2SP             3
+#define SP_STR_MON_PORT_SP2DMA            4 
+#define SP_STR_MON_PORT_DMA2SP            5
+#define SP_STR_MON_PORT_SP2ISP            6 
+#define SP_STR_MON_PORT_ISP2SP            7
+#define SP_STR_MON_PORT_SP2GPD            8
+#define SP_STR_MON_PORT_FA2SP             9
+#define SP_STR_MON_PORT_SP2ISYS          10 
+#define SP_STR_MON_PORT_ISYS2SP          11
+#define SP_STR_MON_PORT_SP2PIFA          12
+#define SP_STR_MON_PORT_PIFA2SP          13
+#define SP_STR_MON_PORT_SP2PIFB          14
+#define SP_STR_MON_PORT_PIFB2SP          15
+
+#define SP_STR_MON_PORT_B_SP2GDC1         0
+#define SP_STR_MON_PORT_B_GDC12SP         1
+#define SP_STR_MON_PORT_B_SP2GDC2         2
+#define SP_STR_MON_PORT_B_GDC22SP         3
+
+/* previously used SP streaming monitor port identifiers, kept for backward compatibility */
+#define SP_STR_MON_PORT_SND_SIF           SP_STR_MON_PORT_SP2SIF
+#define SP_STR_MON_PORT_RCV_SIF           SP_STR_MON_PORT_SIF2SP
+#define SP_STR_MON_PORT_SND_MC            SP_STR_MON_PORT_SP2MC
+#define SP_STR_MON_PORT_RCV_MC            SP_STR_MON_PORT_MC2SP
+#define SP_STR_MON_PORT_SND_DMA           SP_STR_MON_PORT_SP2DMA
+#define SP_STR_MON_PORT_RCV_DMA           SP_STR_MON_PORT_DMA2SP
+#define SP_STR_MON_PORT_SND_ISP           SP_STR_MON_PORT_SP2ISP
+#define SP_STR_MON_PORT_RCV_ISP           SP_STR_MON_PORT_ISP2SP
+#define SP_STR_MON_PORT_SND_GPD           SP_STR_MON_PORT_SP2GPD
+#define SP_STR_MON_PORT_RCV_GPD           SP_STR_MON_PORT_FA2SP
+/* Deprecated */
+#define SP_STR_MON_PORT_SND_PIF           SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF           SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIFB          SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIFB          SP_STR_MON_PORT_PIFB2SP
+
+#define SP_STR_MON_PORT_SND_PIF_A         SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF_A         SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIF_B         SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIF_B         SP_STR_MON_PORT_PIFB2SP
+
+/* port definititions ISP streaming monitor, monitors the status of streaming ports at the ISP side of the streaming FIFO's */
+#define ISP_STR_MON_PORT_ISP2PIFA         0
+#define ISP_STR_MON_PORT_PIFA2ISP         1
+#define ISP_STR_MON_PORT_ISP2PIFB         2 
+#define ISP_STR_MON_PORT_PIFB2ISP         3
+#define ISP_STR_MON_PORT_ISP2DMA          4 
+#define ISP_STR_MON_PORT_DMA2ISP          5
+#define ISP_STR_MON_PORT_ISP2GDC1         6 
+#define ISP_STR_MON_PORT_GDC12ISP         7
+#define ISP_STR_MON_PORT_ISP2GDC2         8 
+#define ISP_STR_MON_PORT_GDC22ISP         9
+#define ISP_STR_MON_PORT_ISP2GPD         10 
+#define ISP_STR_MON_PORT_FA2ISP          11
+#define ISP_STR_MON_PORT_ISP2SP          12 
+#define ISP_STR_MON_PORT_SP2ISP          13
+
+/* previously used ISP streaming monitor port identifiers, kept for backward compatibility */
+#define ISP_STR_MON_PORT_SND_PIF_A       ISP_STR_MON_PORT_ISP2PIFA
+#define ISP_STR_MON_PORT_RCV_PIF_A       ISP_STR_MON_PORT_PIFA2ISP
+#define ISP_STR_MON_PORT_SND_PIF_B       ISP_STR_MON_PORT_ISP2PIFB 
+#define ISP_STR_MON_PORT_RCV_PIF_B       ISP_STR_MON_PORT_PIFB2ISP
+#define ISP_STR_MON_PORT_SND_DMA         ISP_STR_MON_PORT_ISP2DMA  
+#define ISP_STR_MON_PORT_RCV_DMA         ISP_STR_MON_PORT_DMA2ISP 
+#define ISP_STR_MON_PORT_SND_GDC         ISP_STR_MON_PORT_ISP2GDC1 
+#define ISP_STR_MON_PORT_RCV_GDC         ISP_STR_MON_PORT_GDC12ISP
+#define ISP_STR_MON_PORT_SND_GPD         ISP_STR_MON_PORT_ISP2GPD 
+#define ISP_STR_MON_PORT_RCV_GPD         ISP_STR_MON_PORT_FA2ISP
+#define ISP_STR_MON_PORT_SND_SP          ISP_STR_MON_PORT_ISP2SP
+#define ISP_STR_MON_PORT_RCV_SP          ISP_STR_MON_PORT_SP2ISP
+                                           
+/* port definititions MOD streaming monitor, monitors the status of streaming ports at the module side of the streaming FIFO's */
+
+#define MOD_STR_MON_PORT_PIFA2CELLS       0
+#define MOD_STR_MON_PORT_CELLS2PIFA       1
+#define MOD_STR_MON_PORT_PIFB2CELLS       2
+#define MOD_STR_MON_PORT_CELLS2PIFB       3
+#define MOD_STR_MON_PORT_SIF2SP           4
+#define MOD_STR_MON_PORT_SP2SIF           5
+#define MOD_STR_MON_PORT_MC2SP            6
+#define MOD_STR_MON_PORT_SP2MC            7
+#define MOD_STR_MON_PORT_DMA2ISP          8
+#define MOD_STR_MON_PORT_ISP2DMA          9
+#define MOD_STR_MON_PORT_DMA2SP          10
+#define MOD_STR_MON_PORT_SP2DMA          11
+#define MOD_STR_MON_PORT_GDC12CELLS      12
+#define MOD_STR_MON_PORT_CELLS2GDC1      13
+#define MOD_STR_MON_PORT_GDC22CELLS      14
+#define MOD_STR_MON_PORT_CELLS2GDC2      15
+
+#define MOD_STR_MON_PORT_SND_PIF_A        0
+#define MOD_STR_MON_PORT_RCV_PIF_A        1
+#define MOD_STR_MON_PORT_SND_PIF_B        2
+#define MOD_STR_MON_PORT_RCV_PIF_B        3
+#define MOD_STR_MON_PORT_SND_SIF          4
+#define MOD_STR_MON_PORT_RCV_SIF          5
+#define MOD_STR_MON_PORT_SND_MC           6
+#define MOD_STR_MON_PORT_RCV_MC           7
+#define MOD_STR_MON_PORT_SND_DMA2ISP      8
+#define MOD_STR_MON_PORT_RCV_DMA_FR_ISP   9
+#define MOD_STR_MON_PORT_SND_DMA2SP      10
+#define MOD_STR_MON_PORT_RCV_DMA_FR_SP   11
+#define MOD_STR_MON_PORT_SND_GDC         12
+#define MOD_STR_MON_PORT_RCV_GDC         13
+
+
+/* testbench signals:       */
+
+/* testbench GP adapter register ids  */
+#define HIVE_TESTBENCH_GPIO_DATA_OUT_REG_IDX                    0
+#define HIVE_TESTBENCH_GPIO_DIR_OUT_REG_IDX                     1
+#define HIVE_TESTBENCH_IRQ_REG_IDX                              2
+#define HIVE_TESTBENCH_SDRAM_WAKEUP_REG_IDX                     3
+#define HIVE_TESTBENCH_IDLE_REG_IDX                             4
+#define HIVE_TESTBENCH_GPIO_DATA_IN_REG_IDX                     5
+#define HIVE_TESTBENCH_MIPI_BFM_EN_REG_IDX                      6
+#define HIVE_TESTBENCH_CSI_CONFIG_REG_IDX                       7 
+#define HIVE_TESTBENCH_DDR_STALL_EN_REG_IDX                     8
+
+#define HIVE_TESTBENCH_ISP_PMEM_ERROR_IRQ_REG_IDX               9
+#define HIVE_TESTBENCH_ISP_BAMEM_ERROR_IRQ_REG_IDX             10
+#define HIVE_TESTBENCH_ISP_DMEM_ERROR_IRQ_REG_IDX              11
+#define HIVE_TESTBENCH_SP_ICACHE_MEM_ERROR_IRQ_REG_IDX         12
+#define HIVE_TESTBENCH_SP_DMEM_ERROR_IRQ_REG_IDX               13
+
+/* Signal monitor input bit ids */
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_O_BIT_ID                0
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_1_BIT_ID                1
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_2_BIT_ID                2
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_3_BIT_ID                3
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_4_BIT_ID                4
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_5_BIT_ID                5
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_6_BIT_ID                6
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_7_BIT_ID                7
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_8_BIT_ID                8
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_9_BIT_ID                9
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_10_BIT_ID              10
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_11_BIT_ID              11
+#define HIVE_TESTBENCH_SIG_MON_IRQ_PIN_BIT_ID                  12
+#define HIVE_TESTBENCH_SIG_MON_SDRAM_WAKEUP_PIN_BIT_ID         13
+#define HIVE_TESTBENCH_SIG_MON_IDLE_PIN_BIT_ID                 14
+
+#define ISP2400_DEBUG_NETWORK    1
+
+#endif /* _hive_isp_css_defs_h__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h
new file mode 100644
index 0000000..6e4af2b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h
@@ -0,0 +1,95 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_host_ids_hrt_h_
+#define _hive_isp_css_host_ids_hrt_h_
+
+/* ISP_CSS identifiers */
+#define INP_SYS       testbench_isp_inp_sys
+#define ISYS_GP_REGS  testbench_isp_inp_sys_gpreg
+#define ISYS_IRQ_CTRL testbench_isp_inp_sys_irq_ctrl
+#define ISYS_CAP_A    testbench_isp_inp_sys_capt_unit_a
+#define ISYS_CAP_B    testbench_isp_inp_sys_capt_unit_b
+#define ISYS_CAP_C    testbench_isp_inp_sys_capt_unit_c
+#define ISYS_INP_BUF  testbench_isp_inp_sys_input_buffer
+#define ISYS_INP_CTRL testbench_isp_inp_sys_inp_ctrl
+#define ISYS_ACQ      testbench_isp_inp_sys_acq_unit
+
+#define ISP           testbench_isp_isp
+#define SP            testbench_isp_scp
+
+#define IF_PRIM       testbench_isp_ifmt_ift_prim  
+#define IF_PRIM_B     testbench_isp_ifmt_ift_prim_b
+#define IF_SEC        testbench_isp_ifmt_ift_sec
+#define IF_SEC_MASTER testbench_isp_ifmt_ift_sec_mt_out
+#define STR_TO_MEM    testbench_isp_ifmt_mem_cpy
+#define IFMT_GP_REGS  testbench_isp_ifmt_gp_reg
+#define IFMT_IRQ_CTRL testbench_isp_ifmt_irq_ctrl
+
+#define CSS_RECEIVER  testbench_isp_inp_sys_csi_receiver
+
+#define TC            testbench_isp_gpd_tc
+#define GPTIMER       testbench_isp_gpd_gptimer
+#define DMA           testbench_isp_isp_dma
+#define GDC           testbench_isp_gdc1
+#define GDC2          testbench_isp_gdc2
+#define IRQ_CTRL      testbench_isp_gpd_irq_ctrl
+#define GPIO          testbench_isp_gpd_c_gpio
+#define GP_REGS       testbench_isp_gpd_gp_reg
+#define ISEL_GP_REGS  testbench_isp_isel_gpr
+#define ISEL_IRQ_CTRL testbench_isp_isel_irq_ctrl
+#define MMU           testbench_isp_out_sys_c_mmu
+#define DATA_MMU      testbench_isp_data_out_sys_c_mmu
+#define ICACHE_MMU    testbench_isp_icache_out_sys_c_mmu
+
+/* next is actually not FIFO but FIFO adapter, or slave to streaming adapter */
+#define ISP_SP_FIFO   testbench_isp_fa_sp_isp
+#define ISEL_FIFO     testbench_isp_isel_sf_fa_in
+
+#define FIFO_GPF_SP   testbench_isp_sf_fa2sp_in
+#define FIFO_GPF_ISP  testbench_isp_sf_fa2isp_in
+#define FIFO_SP_GPF   testbench_isp_sf_sp2fa_in
+#define FIFO_ISP_GPF  testbench_isp_sf_isp2fa_in
+
+#define OCP_MASTER    testbench_isp_out_sys_cio2ocp_wide_data_out_mt
+#define DATA_OCP_MASTER    testbench_isp_data_out_sys_cio2ocp_wide_data_out_mt
+#define ICACHE_OCP_MASTER  testbench_isp_icache_out_sys_cio2ocp_wide_data_out_mt
+
+#define SP_IN_FIFO    testbench_isp_sf_fa2sp_in
+#define SP_OUT_FIFO   testbench_isp_sf_sp2fa_out
+#define ISP_IN_FIFO   testbench_isp_sf_fa2isp_in
+#define ISP_OUT_FIFO  testbench_isp_sf_isp2fa_out
+#define GEN_SHORT_PACK_PORT testbench_isp_inp_sys_csi_str_mon_fa_gensh_out
+#define ISYS_GP_REGS  testbench_isp_inp_sys_gpreg
+
+/* Testbench identifiers */
+#define DDR             testbench_ddram
+#define DDR_SMALL       testbench_ddram_small
+#define XMEM            DDR
+#define GPIO_ADAPTER    testbench_gp_adapter
+#define SIG_MONITOR     testbench_sig_mon
+#define DDR_SLAVE       testbench_ddram_ip0
+#define DDR_SMALL_SLAVE testbench_ddram_small_ip0
+#define HOST_MASTER     host_op0
+
+#endif /* _hive_isp_css_host_ids_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h
new file mode 100644
index 0000000..f5432db
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h
@@ -0,0 +1,81 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
+#define _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
+
+/*
+ * These are the indices of each interrupt in the interrupt
+ * controller's registers. these can be used as the irq_id
+ * argument to the hrt functions irq_controller.h.
+ *
+ * The definitions are taken from <system>_defs.h
+ */
+typedef enum hrt_isp_css_irq {
+  hrt_isp_css_irq_gpio_pin_0           = HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_1           = HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_2           = HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_3           = HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_4           = HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_5           = HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_6           = HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_7           = HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_8           = HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_9           = HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID          ,               
+  hrt_isp_css_irq_gpio_pin_10          = HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID         ,              
+  hrt_isp_css_irq_gpio_pin_11          = HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID         ,              
+  hrt_isp_css_irq_sp                   = HIVE_GP_DEV_IRQ_SP_BIT_ID                  ,                       
+  hrt_isp_css_irq_isp                  = HIVE_GP_DEV_IRQ_ISP_BIT_ID                 ,                      
+  hrt_isp_css_irq_isys                 = HIVE_GP_DEV_IRQ_ISYS_BIT_ID                ,                     
+  hrt_isp_css_irq_isel                 = HIVE_GP_DEV_IRQ_ISEL_BIT_ID                ,                     
+  hrt_isp_css_irq_ifmt                 = HIVE_GP_DEV_IRQ_IFMT_BIT_ID                ,                     
+  hrt_isp_css_irq_sp_stream_mon        = HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID       ,            
+  hrt_isp_css_irq_isp_stream_mon       = HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID      ,           
+  hrt_isp_css_irq_mod_stream_mon       = HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID      ,
+#ifdef _HIVE_ISP_CSS_2401_SYSTEM
+  hrt_isp_css_irq_is2401               = HIVE_GP_DEV_IRQ_IS2401_BIT_ID              ,           
+#else
+  hrt_isp_css_irq_isp_pmem_error       = HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID      ,           
+#endif
+  hrt_isp_css_irq_isp_bamem_error      = HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID     ,          
+  hrt_isp_css_irq_isp_dmem_error       = HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID      ,           
+  hrt_isp_css_irq_sp_icache_mem_error  = HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID ,      
+  hrt_isp_css_irq_sp_dmem_error        = HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID       ,            
+  hrt_isp_css_irq_mmu_cache_mem_error  = HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID ,      
+  hrt_isp_css_irq_gp_timer_0           = HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID          ,               
+  hrt_isp_css_irq_gp_timer_1           = HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID          ,               
+  hrt_isp_css_irq_sw_pin_0             = HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID            ,                 
+  hrt_isp_css_irq_sw_pin_1             = HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID            ,                 
+  hrt_isp_css_irq_dma                  = HIVE_GP_DEV_IRQ_DMA_BIT_ID                 ,
+  hrt_isp_css_irq_sp_stream_mon_b      = HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID     ,
+  /* this must (obviously) be the last on in the enum */
+  hrt_isp_css_irq_num_irqs
+} hrt_isp_css_irq_t;
+
+typedef enum hrt_isp_css_irq_status {
+  hrt_isp_css_irq_status_error,
+  hrt_isp_css_irq_status_more_irqs,
+  hrt_isp_css_irq_status_success
+} hrt_isp_css_irq_status_t;
+
+#endif /* _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
new file mode 100644
index 0000000..812cadd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_streaming_to_mipi_types_hrt_h_
+#define _hive_isp_css_streaming_to_mipi_types_hrt_h_
+
+#include <streaming_to_mipi_defs.h>
+
+#define _HIVE_ISP_CH_ID_MASK    ((1U << HIVE_ISP_CH_ID_BITS)-1)
+#define _HIVE_ISP_FMT_TYPE_MASK ((1U << HIVE_ISP_FMT_TYPE_BITS)-1)
+
+#define _HIVE_STR_TO_MIPI_FMT_TYPE_LSB (HIVE_STR_TO_MIPI_CH_ID_LSB + HIVE_ISP_CH_ID_BITS)
+#define _HIVE_STR_TO_MIPI_DATA_B_LSB   (HIVE_STR_TO_MIPI_DATA_A_LSB + HIVE_IF_PIXEL_WIDTH)
+ 
+#endif /* _hive_isp_css_streaming_to_mipi_types_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_types.h b/drivers/media/atomisp2/css2400/hrt/hive_types.h
new file mode 100644
index 0000000..15d644e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_types.h
@@ -0,0 +1,137 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_HIVE_TYPES_H 
+#define _HRT_HIVE_TYPES_H 
+
+#include "version.h"
+#include "defs.h"
+
+#ifndef HRTCAT3
+#define _HRTCAT3(m,n,o)     m##n##o
+#define HRTCAT3(m,n,o)      _HRTCAT3(m,n,o)
+#endif
+
+#ifndef HRTCAT4
+#define _HRTCAT4(m,n,o,p)     m##n##o##p
+#define HRTCAT4(m,n,o,p)      _HRTCAT4(m,n,o,p)
+#endif
+
+#ifndef HRTMIN
+#define HRTMIN(a,b) (((a)<(b))?(a):(b))
+#endif
+                                 
+#ifndef HRTMAX
+#define HRTMAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+/* boolean data type */
+typedef unsigned int hive_bool;
+#define hive_false 0
+#define hive_true  1
+
+typedef char                 hive_int8;
+typedef short                hive_int16;
+typedef int                  hive_int32;
+typedef long long            hive_int64;
+
+typedef unsigned char        hive_uint8;
+typedef unsigned short       hive_uint16;
+typedef unsigned int         hive_uint32;
+typedef unsigned long long   hive_uint64;
+
+/* by default assume 32 bit master port (both data and address) */
+#ifndef HRT_DATA_WIDTH
+#define HRT_DATA_WIDTH 32
+#endif
+#ifndef HRT_ADDRESS_WIDTH
+#define HRT_ADDRESS_WIDTH 32
+#endif
+
+#define HRT_DATA_BYTES    (HRT_DATA_WIDTH/8)
+#define HRT_ADDRESS_BYTES (HRT_ADDRESS_WIDTH/8)
+
+#if HRT_DATA_WIDTH == 64
+typedef hive_uint64 hrt_data;
+#elif HRT_DATA_WIDTH == 32
+typedef hive_uint32 hrt_data;
+#else
+#error data width not supported
+#endif
+
+#if HRT_ADDRESS_WIDTH == 64
+typedef hive_uint64 hrt_address; 
+#elif HRT_ADDRESS_WIDTH == 32
+typedef hive_uint32 hrt_address;
+#else
+#error adddres width not supported
+#endif
+
+/* The SP side representation of an HMM virtual address */
+typedef hive_uint32 hrt_vaddress;
+
+/* use 64 bit addresses in simulation, where possible */
+typedef hive_uint64  hive_sim_address;
+
+/* below is for csim, not for hrt, rename and move this elsewhere */
+
+typedef unsigned int hive_uint;
+typedef hive_uint32  hive_address;
+typedef hive_address hive_slave_address;
+typedef hive_address hive_mem_address;
+
+/* MMIO devices */
+typedef hive_uint    hive_mmio_id;
+typedef hive_mmio_id hive_slave_id;
+typedef hive_mmio_id hive_port_id;
+typedef hive_mmio_id hive_master_id; 
+typedef hive_mmio_id hive_mem_id;
+typedef hive_mmio_id hive_dev_id;
+typedef hive_mmio_id hive_fifo_id;
+
+typedef hive_uint      hive_hier_id;
+typedef hive_hier_id   hive_device_id;
+typedef hive_device_id hive_proc_id;
+typedef hive_device_id hive_cell_id;
+typedef hive_device_id hive_host_id;
+typedef hive_device_id hive_bus_id;
+typedef hive_device_id hive_bridge_id;
+typedef hive_device_id hive_fifo_adapter_id;
+typedef hive_device_id hive_custom_device_id;
+
+typedef hive_uint hive_slot_id;
+typedef hive_uint hive_fu_id;
+typedef hive_uint hive_reg_file_id;
+typedef hive_uint hive_reg_id;
+
+/* Streaming devices */
+typedef hive_uint hive_outport_id;
+typedef hive_uint hive_inport_id;
+
+typedef hive_uint hive_msink_id;
+
+/* HRT specific */
+typedef char* hive_program;
+typedef char* hive_function;
+
+#endif /* _HRT_HIVE_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/if_defs.h b/drivers/media/atomisp2/css2400/hrt/if_defs.h
new file mode 100644
index 0000000..7fee792
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/if_defs.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IF_DEFS_H
+#define _IF_DEFS_H
+
+#define HIVE_IF_FRAME_REQUEST        0xA000
+#define HIVE_IF_LINES_REQUEST        0xB000
+#define HIVE_IF_VECTORS_REQUEST      0xC000
+
+#endif /* _IF_DEFS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h b/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h
new file mode 100644
index 0000000..1fcddf8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h
@@ -0,0 +1,62 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _if_subsystem_defs_h
+#define _if_subsystem_defs_h__
+
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0            0
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_1            1
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_2            2
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_3            3
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_4            4
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_5            5
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_6            6
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_7            7 
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_FSYNC_LUT_REG        8
+#define HIVE_IFMT_GP_REGS_SRST_IDX                          9
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IDX                 10
+
+#define HIVE_IFMT_GP_REGS_CH_ID_FMT_TYPE_IDX               11
+
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_BASE         HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0
+
+/* order of the input bits for the ifmt irq controller */
+#define HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID                       0
+#define HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID                     1
+#define HIVE_IFMT_IRQ_IFT_SEC_BIT_ID                        2
+#define HIVE_IFMT_IRQ_MEM_CPY_BIT_ID                        3
+#define HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID               4
+
+/* order of the input bits for the ifmt Soft reset register */
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_BIT_IDX             0
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_B_BIT_IDX           1
+#define HIVE_IFMT_GP_REGS_SRST_IFT_SEC_BIT_IDX              2
+#define HIVE_IFMT_GP_REGS_SRST_MEM_CPY_BIT_IDX              3
+
+/* order of the input bits for the ifmt Soft reset register */
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_BIT_IDX     0
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_B_BIT_IDX   1
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_SEC_BIT_IDX      2
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_MEM_CPY_BIT_IDX      3
+
+#endif /* _if_subsystem_defs_h__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h b/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h
new file mode 100644
index 0000000..05c8b44
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h
@@ -0,0 +1,98 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_selector_defs_h
+#define _input_selector_defs_h
+
+#ifndef HIVE_ISP_ISEL_SEL_BITS
+#define HIVE_ISP_ISEL_SEL_BITS                                  2
+#endif
+
+#ifndef HIVE_ISP_CH_ID_BITS
+#define HIVE_ISP_CH_ID_BITS                                     2
+#endif
+
+#ifndef HIVE_ISP_FMT_TYPE_BITS
+#define HIVE_ISP_FMT_TYPE_BITS                                  5
+#endif
+
+/* gp_register register id's -- Outputs */
+#define HIVE_ISEL_GP_REGS_SYNCGEN_ENABLE_IDX                    0
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FREE_RUNNING_IDX              1
+#define HIVE_ISEL_GP_REGS_SYNCGEN_PAUSE_IDX                     2
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_FRAMES_IDX                 3 
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_PIX_IDX                    4      
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_LINES_IDX                  5      
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HBLANK_CYCLES_IDX             6      
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VBLANK_CYCLES_IDX             7      
+
+#define HIVE_ISEL_GP_REGS_SOF_IDX                               8 
+#define HIVE_ISEL_GP_REGS_EOF_IDX                               9 
+#define HIVE_ISEL_GP_REGS_SOL_IDX                              10 
+#define HIVE_ISEL_GP_REGS_EOL_IDX                              11 
+
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE                          12      
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE_PORT_B                   13      
+#define HIVE_ISEL_GP_REGS_PRBS_LFSR_RESET_VALUE                14      
+
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE                           15      
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE_PORT_B                    16      
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_MASK_IDX                 17      
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_MASK_IDX                 18      
+#define HIVE_ISEL_GP_REGS_TPG_XY_CNT_MASK_IDX                  19      
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_DELTA_IDX                20      
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_DELTA_IDX                21      
+#define HIVE_ISEL_GP_REGS_TPG_MODE_IDX                         22     
+#define HIVE_ISEL_GP_REGS_TPG_R1_IDX                           23 
+#define HIVE_ISEL_GP_REGS_TPG_G1_IDX                           24
+#define HIVE_ISEL_GP_REGS_TPG_B1_IDX                           25
+#define HIVE_ISEL_GP_REGS_TPG_R2_IDX                           26
+#define HIVE_ISEL_GP_REGS_TPG_G2_IDX                           27
+#define HIVE_ISEL_GP_REGS_TPG_B2_IDX                           28
+
+
+#define HIVE_ISEL_GP_REGS_CH_ID_IDX                            29
+#define HIVE_ISEL_GP_REGS_FMT_TYPE_IDX                         30
+#define HIVE_ISEL_GP_REGS_DATA_SEL_IDX                         31
+#define HIVE_ISEL_GP_REGS_SBAND_SEL_IDX                        32
+#define HIVE_ISEL_GP_REGS_SYNC_SEL_IDX                         33
+#define HIVE_ISEL_GP_REGS_SRST_IDX                             37
+
+#define HIVE_ISEL_GP_REGS_SRST_SYNCGEN_BIT                      0
+#define HIVE_ISEL_GP_REGS_SRST_PRBS_BIT                         1
+#define HIVE_ISEL_GP_REGS_SRST_TPG_BIT                          2
+#define HIVE_ISEL_GP_REGS_SRST_FIFO_BIT                         3
+
+/* gp_register register id's -- Inputs   */
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HOR_CNT_IDX                  34
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VER_CNT_IDX                  35
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FRAMES_CNT_IDX               36
+
+/* irq sources isel irq controller */
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID                       0
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID                       1
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID                       2
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID                       3
+#define HIVE_ISEL_IRQ_NUM_IRQS                                  4
+
+#endif /* _input_selector_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h b/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h
new file mode 100644
index 0000000..34838b4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_switch_2400_defs_h
+#define _input_switch_2400_defs_h
+
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_ID(ch_id, fmt_type) (((ch_id)*2) + ((fmt_type)>=16))
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_LSB(fmt_type)        (((fmt_type)%16) * 2)
+
+#define HIVE_INPUT_SWITCH_SELECT_NO_OUTPUT   0
+#define HIVE_INPUT_SWITCH_SELECT_IF_PRIM     1
+#define HIVE_INPUT_SWITCH_SELECT_IF_SEC      2
+#define HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM  3
+#define HIVE_INPUT_SWITCH_VSELECT_NO_OUTPUT  0
+#define HIVE_INPUT_SWITCH_VSELECT_IF_PRIM    1
+#define HIVE_INPUT_SWITCH_VSELECT_IF_SEC     2
+#define HIVE_INPUT_SWITCH_VSELECT_STR_TO_MEM 4
+
+#endif /* _input_switch_2400_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h b/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h
new file mode 100644
index 0000000..96a6a3b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h
@@ -0,0 +1,263 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_system_ctrl_defs_h
+#define _input_system_ctrl_defs_h
+
+#define _INPUT_SYSTEM_CTRL_REG_ALIGN                    4  /* assuming 32 bit control bus width */
+
+/* --------------------------------------------------*/
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+// Number of registers
+#define ISYS_CTRL_NOF_REGS                              23
+
+// Register id's of MMIO slave accesible registers
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_ID              0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_ID              1
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_ID              2
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID         3
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID         4
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID         5
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID         6
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID         7
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID         8
+#define ISYS_CTRL_ACQ_START_ADDR_REG_ID                 9
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID            10
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID            11
+#define ISYS_CTRL_INIT_REG_ID                           12
+#define ISYS_CTRL_LAST_COMMAND_REG_ID                   13
+#define ISYS_CTRL_NEXT_COMMAND_REG_ID                   14
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID               15
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID               16
+#define ISYS_CTRL_FSM_STATE_INFO_REG_ID                 17
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID          18
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID          19
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID          20
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID             21
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID    22
+ 
+
+/* register reset value */
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_RSTVAL      3 
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_RSTVAL      3 
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_RSTVAL      3 
+#define ISYS_CTRL_ACQ_START_ADDR_REG_RSTVAL              0
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_RSTVAL         128 
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_RSTVAL         3 
+#define ISYS_CTRL_INIT_REG_RSTVAL                        0
+#define ISYS_CTRL_LAST_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)  
+#define ISYS_CTRL_NEXT_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_FSM_STATE_INFO_REG_RSTVAL              0
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_RSTVAL       0 
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_RSTVAL       0
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_RSTVAL       0
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_RSTVAL          0
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_RSTVAL 0
+
+/* register width value */
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_WIDTH            9 
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_WIDTH            9 
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_WIDTH            9 
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_WIDTH       9 
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_WIDTH       9 
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_WIDTH       9 
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_WIDTH       9 
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_WIDTH       9 
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_WIDTH       9 
+#define ISYS_CTRL_ACQ_START_ADDR_REG_WIDTH               9 
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_WIDTH          9 
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_WIDTH          9 
+#define ISYS_CTRL_INIT_REG_WIDTH                         3 
+#define ISYS_CTRL_LAST_COMMAND_REG_WIDTH                 32    /* slave data width */
+#define ISYS_CTRL_NEXT_COMMAND_REG_WIDTH                 32
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_WIDTH             32
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_WIDTH             32
+#define ISYS_CTRL_FSM_STATE_INFO_REG_WIDTH               32
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_WIDTH           32
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_WIDTH  1
+
+/* bit definitions */
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+
+/*
+InpSysCaptFramesAcq  1/0  [3:0] - 'b0000
+[7:4] - CaptPortId,
+           CaptA-'b0000
+           CaptB-'b0001
+           CaptC-'b0010
+[31:16] - NOF_frames
+InpSysCaptFrameExt  2/0  [3:0] - 'b0001'
+[7:4] - CaptPortId,
+           'b0000 - CaptA 
+           'b0001 - CaptB
+           'b0010 - CaptC
+
+  2/1  [31:0] - external capture address
+InpSysAcqFrame  2/0  [3:0] - 'b0010, 
+[31:4] - NOF_ext_mem_words
+  2/1  [31:0] - external memory read start address
+InpSysOverruleON  1/0  [3:0] - 'b0011, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysOverruleOFF  1/0  [3:0] - 'b0100, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysOverruleCmd  2/0  [3:0] - 'b0101, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+  2/1  [31:0] - command token value for port opid
+
+
+acknowledge tokens:
+
+InpSysAckCFA  1/0   [3:0] - 'b0000
+ [7:4] - CaptPortId,
+           CaptA-'b0000
+           CaptB- 'b0001
+           CaptC-'b0010
+ [31:16] - NOF_frames
+InpSysAckCFE  1/0  [3:0] - 'b0001'
+[7:4] - CaptPortId,
+           'b0000 - CaptA 
+           'b0001 - CaptB
+           'b0010 - CaptC
+
+InpSysAckAF  1/0  [3:0] - 'b0010
+InpSysAckOverruleON  1/0  [3:0] - 'b0011, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysAckOverruleOFF  1/0  [3:0] - 'b0100, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysAckOverrule  2/0  [3:0] - 'b0101, 
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+  2/1  [31:0] - acknowledge token value from port opid
+
+
+
+*/
+
+
+/* Command and acknowledge tokens IDs */
+#define ISYS_CTRL_CAPT_FRAMES_ACQ_TOKEN_ID        0 /* 0000b */
+#define ISYS_CTRL_CAPT_FRAME_EXT_TOKEN_ID         1 /* 0001b */
+#define ISYS_CTRL_ACQ_FRAME_TOKEN_ID              2 /* 0010b */
+#define ISYS_CTRL_OVERRULE_ON_TOKEN_ID            3 /* 0011b */
+#define ISYS_CTRL_OVERRULE_OFF_TOKEN_ID           4 /* 0100b */
+#define ISYS_CTRL_OVERRULE_TOKEN_ID               5 /* 0101b */
+
+#define ISYS_CTRL_ACK_CFA_TOKEN_ID                0
+#define ISYS_CTRL_ACK_CFE_TOKEN_ID                1
+#define ISYS_CTRL_ACK_AF_TOKEN_ID                 2
+#define ISYS_CTRL_ACK_OVERRULE_ON_TOKEN_ID        3
+#define ISYS_CTRL_ACK_OVERRULE_OFF_TOKEN_ID       4
+#define ISYS_CTRL_ACK_OVERRULE_TOKEN_ID           5
+#define ISYS_CTRL_ACK_DEVICE_ERROR_TOKEN_ID       6
+
+#define ISYS_CTRL_TOKEN_ID_MSB                    3
+#define ISYS_CTRL_TOKEN_ID_LSB                    0
+#define ISYS_CTRL_PORT_ID_TOKEN_MSB               7
+#define ISYS_CTRL_PORT_ID_TOKEN_LSB               4
+#define ISYS_CTRL_NOF_CAPT_TOKEN_MSB              31
+#define ISYS_CTRL_NOF_CAPT_TOKEN_LSB              16
+#define ISYS_CTRL_NOF_EXT_TOKEN_MSB               31
+#define ISYS_CTRL_NOF_EXT_TOKEN_LSB               8
+
+#define ISYS_CTRL_TOKEN_ID_IDX                    0
+#define ISYS_CTRL_TOKEN_ID_BITS                   (ISYS_CTRL_TOKEN_ID_MSB - ISYS_CTRL_TOKEN_ID_LSB + 1)
+#define ISYS_CTRL_PORT_ID_IDX                     (ISYS_CTRL_TOKEN_ID_IDX + ISYS_CTRL_TOKEN_ID_BITS)
+#define ISYS_CTRL_PORT_ID_BITS                    (ISYS_CTRL_PORT_ID_TOKEN_MSB - ISYS_CTRL_PORT_ID_TOKEN_LSB +1)
+#define ISYS_CTRL_NOF_CAPT_IDX                    ISYS_CTRL_NOF_CAPT_TOKEN_LSB    
+#define ISYS_CTRL_NOF_CAPT_BITS                   (ISYS_CTRL_NOF_CAPT_TOKEN_MSB - ISYS_CTRL_NOF_CAPT_TOKEN_LSB + 1)
+#define ISYS_CTRL_NOF_EXT_IDX                     ISYS_CTRL_NOF_EXT_TOKEN_LSB    
+#define ISYS_CTRL_NOF_EXT_BITS                    (ISYS_CTRL_NOF_EXT_TOKEN_MSB - ISYS_CTRL_NOF_EXT_TOKEN_LSB + 1)
+
+#define ISYS_CTRL_PORT_ID_CAPT_A                  0 /* device ID for capture unit A      */
+#define ISYS_CTRL_PORT_ID_CAPT_B                  1 /* device ID for capture unit B      */
+#define ISYS_CTRL_PORT_ID_CAPT_C                  2 /* device ID for capture unit C      */
+#define ISYS_CTRL_PORT_ID_ACQUISITION             3 /* device ID for acquistion unit     */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_A              4 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_B              5 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_C              6 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_ACQ                 7 /* device ID for dma unit            */
+
+#define ISYS_CTRL_NO_ACQ_ACK                      16 /* no ack from acquisition unit */
+#define ISYS_CTRL_NO_DMA_ACK                      0 
+#define ISYS_CTRL_NO_CAPT_ACK                     16
+
+#endif /* _input_system_ctrl_defs_h */ 
diff --git a/drivers/media/atomisp2/css2400/hrt/input_system_defs.h b/drivers/media/atomisp2/css2400/hrt/input_system_defs.h
new file mode 100644
index 0000000..0a29884
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_system_defs.h
@@ -0,0 +1,135 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_system_defs_h
+#define _input_system_defs_h
+
+/* csi controller modes */
+#define HIVE_CSI_CONFIG_MAIN                   0
+#define HIVE_CSI_CONFIG_STEREO1                4
+#define HIVE_CSI_CONFIG_STEREO2                8
+
+/* general purpose register IDs */
+
+/* Stream Multicast select modes */
+#define HIVE_ISYS_GPREG_MULTICAST_A_IDX           0
+#define HIVE_ISYS_GPREG_MULTICAST_B_IDX           1
+#define HIVE_ISYS_GPREG_MULTICAST_C_IDX           2
+
+/* Stream Mux select modes */
+#define HIVE_ISYS_GPREG_MUX_IDX                   3
+
+/* streaming monitor status and control */
+#define HIVE_ISYS_GPREG_STRMON_STAT_IDX           4
+#define HIVE_ISYS_GPREG_STRMON_COND_IDX           5
+#define HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX         6
+#define HIVE_ISYS_GPREG_SRST_IDX                  7
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_IDX          8
+#define HIVE_ISYS_GPREG_REG_PORT_A_IDX            9
+#define HIVE_ISYS_GPREG_REG_PORT_B_IDX            10
+
+/* Bit numbers of the soft reset register */
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_A_BIT      0
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_B_BIT      1
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_C_BIT      2
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_A_BIT      3
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_B_BIT      4
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_C_BIT      5
+#define HIVE_ISYS_GPREG_SRST_CAPT_A_BIT           6
+#define HIVE_ISYS_GPREG_SRST_CAPT_B_BIT           7
+#define HIVE_ISYS_GPREG_SRST_CAPT_C_BIT           8
+#define HIVE_ISYS_GPREG_SRST_ACQ_BIT              9
+/* For ISYS_CTRL 5bits are defined to allow soft-reset per sub-controller and top-ctrl */
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_BIT        10  /*LSB for 5bit vector */
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_A_BIT 10
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_B_BIT 11
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_C_BIT 12
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_ACQ_BIT    13
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_TOP_BIT    14
+/* -- */
+#define HIVE_ISYS_GPREG_SRST_STR_MUX_BIT          15
+#define HIVE_ISYS_GPREG_SRST_CIO2AHB_BIT          16
+#define HIVE_ISYS_GPREG_SRST_GEN_SHORT_FIFO_BIT   17
+#define HIVE_ISYS_GPREG_SRST_WIDE_BUS_BIT         18 // includes CIO conv
+#define HIVE_ISYS_GPREG_SRST_DMA_BIT              19
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_A_BIT   20
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_B_BIT   21
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_C_BIT   22
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_ACQ_BIT      23
+#define HIVE_ISYS_GPREG_SRST_CSI_BE_OUT_BIT       24
+
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_A_BIT    0
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_B_BIT    1
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_C_BIT    2
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ACQ_BIT       3
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_DMA_BIT        4
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ISYS_CTRL_BIT  5
+
+/* streaming monitor port id's */
+#define HIVE_ISYS_STR_MON_PORT_CAPA            0
+#define HIVE_ISYS_STR_MON_PORT_CAPB            1
+#define HIVE_ISYS_STR_MON_PORT_CAPC            2
+#define HIVE_ISYS_STR_MON_PORT_ACQ             3
+#define HIVE_ISYS_STR_MON_PORT_CSS_GENSH       4
+#define HIVE_ISYS_STR_MON_PORT_SF_GENSH        5
+#define HIVE_ISYS_STR_MON_PORT_SP2ISYS         6
+#define HIVE_ISYS_STR_MON_PORT_ISYS2SP         7
+#define HIVE_ISYS_STR_MON_PORT_PIXA            8
+#define HIVE_ISYS_STR_MON_PORT_PIXB            9
+
+/* interrupt bit ID's        */
+#define HIVE_ISYS_IRQ_CSI_SOF_BIT_ID           0
+#define HIVE_ISYS_IRQ_CSI_EOF_BIT_ID           1
+#define HIVE_ISYS_IRQ_CSI_SOL_BIT_ID           2
+#define HIVE_ISYS_IRQ_CSI_EOL_BIT_ID           3
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID      4
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID   5
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP        6
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP      7
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_A_UNDEF_PH      7*/
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP        8
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP      9
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_B_UNDEF_PH     10*/
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP       10
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP     11
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_C_UNDEF_PH     13*/
+#define HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH   12
+/*#define HIVE_ISYS_IRQ_ACQ_UNIT_UNDEF_PH       15*/
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPA           13
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPB           14
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPC           15
+#define HIVE_ISYS_IRQ_CIO2AHB                 16
+#define HIVE_ISYS_IRQ_DMA_BIT_ID              17
+#define HIVE_ISYS_IRQ_STREAM_MON_BIT_ID       18
+#define HIVE_ISYS_IRQ_NUM_BITS                19
+
+/* DMA */
+#define HIVE_ISYS_DMA_CHANNEL                  0
+#define HIVE_ISYS_DMA_IBUF_DDR_CONN            0
+#define HIVE_ISYS_DMA_HEIGHT                   1
+#define HIVE_ISYS_DMA_ELEMS                    1 /* both master buses of same width */
+#define HIVE_ISYS_DMA_STRIDE                   0 /* no stride required as height is fixed to 1 */
+#define HIVE_ISYS_DMA_CROP                     0 /* no cropping */
+#define HIVE_ISYS_DMA_EXTENSION                0 /* no extension as elem width is same on both side */
+
+#endif /* _input_system_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h b/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h
new file mode 100644
index 0000000..c89e4c2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _irq_controller_defs_h
+#define _irq_controller_defs_h
+
+#define _HRT_IRQ_CONTROLLER_EDGE_REG_IDX           0
+#define _HRT_IRQ_CONTROLLER_MASK_REG_IDX           1
+#define _HRT_IRQ_CONTROLLER_STATUS_REG_IDX         2
+#define _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX          3
+#define _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX         4
+#define _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX 5
+#define _HRT_IRQ_CONTROLLER_STR_OUT_ENABLE_REG_IDX 6
+
+#define _HRT_IRQ_CONTROLLER_REG_ALIGN 4
+
+#endif /* _irq_controller_defs_h */   
diff --git a/drivers/media/atomisp2/css2400/hrt/isp2400A0_mamoiada_params.h b/drivers/media/atomisp2/css2400/hrt/isp2400A0_mamoiada_params.h
new file mode 100644
index 0000000..dc87430
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp2400A0_mamoiada_params.h
@@ -0,0 +1,267 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Version */
+#define RTL_VERSION
+
+/* Cell name  */
+#define ISP_CELL_TYPE                          isp2400A0_mamoiada
+#define ISP_VMEM                               simd_vmem
+#define _HRT_ISP_VMEM                          isp2400A0_mamoiada_simd_vmem
+
+/* instruction pipeline depth */
+#define ISP_BRANCHDELAY                        4
+
+/* bus */
+#define ISP_BUS_WIDTH                          32
+#define ISP_BUS_ADDR_WIDTH                     32
+#define ISP_BUS_BURST_SIZE                     1
+
+/* data-path */
+#define ISP_SCALAR_WIDTH                       32
+#define ISP_SLICE_NELEMS                       4
+#define ISP_VEC_NELEMS                         64
+#define ISP_VEC_ELEMBITS                       14
+#define ISP_VEC_ELEM8BITS                      16
+#define ISP_CLONE_DATAPATH_IS_16               1
+
+/* memories */
+#define ISP_DMEM_DEPTH                         4096
+#define ISP_DMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_DEPTH                         3072
+#define ISP_VMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_ELEMBITS                      14
+#define ISP_VMEM_ELEM_PRECISION                14
+#define ISP_VMEM_IS_BAMEM                      1
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_BAMEM_MAX_BOI_HEIGHT        8
+  #define ISP_VMEM_BAMEM_LATENCY               5
+  #define ISP_VMEM_BAMEM_BANK_NARROWING_FACTOR 2
+  #define ISP_VMEM_BAMEM_NR_DATA_PLANES        8
+  #define ISP_VMEM_BAMEM_NR_CFG_REGISTERS      16
+  #define ISP_VMEM_BAMEM_LININT                0
+  #define ISP_VMEM_BAMEM_DAP_BITS              3
+  #define ISP_VMEM_BAMEM_LININT_FRAC_BITS      0
+  #define ISP_VMEM_BAMEM_PID_BITS              3
+  #define ISP_VMEM_BAMEM_OFFSET_BITS           19
+  #define ISP_VMEM_BAMEM_ADDRESS_BITS          25
+  #define ISP_VMEM_BAMEM_RID_BITS              4
+  #define ISP_VMEM_BAMEM_TRANSPOSITION         1
+  #define ISP_VMEM_BAMEM_VEC_PLUS_SLICE        1
+  #define ISP_VMEM_BAMEM_ARB_SERVICE_CYCLE_BITS 1
+  #define ISP_VMEM_BAMEM_LUT_ELEMS             0
+  #define ISP_VMEM_BAMEM_LUT_ADDR_WIDTH        0
+  #define ISP_VMEM_BAMEM_HALF_BLOCK_WRITE      1
+  #define ISP_VMEM_BAMEM_SMART_FETCH           1
+  #define ISP_VMEM_BAMEM_BIG_ENDIANNESS        0
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_PMEM_DEPTH                         2048
+#define ISP_PMEM_WIDTH                         640
+#define ISP_VAMEM_ADDRESS_BITS                 12
+#define ISP_VAMEM_ELEMBITS                     12
+#define ISP_VAMEM_DEPTH                        2048
+#define ISP_VAMEM_ALIGNMENT                    2
+#define ISP_VA_ADDRESS_WIDTH                   896
+#define ISP_VEC_VALSU_LATENCY                  ISP_VEC_NELEMS
+#define ISP_HIST_ADDRESS_BITS                  12
+#define ISP_HIST_ALIGNMENT                     4
+#define ISP_HIST_COMP_IN_PREC                  12
+#define ISP_HIST_DEPTH                         1024
+#define ISP_HIST_WIDTH                         24
+#define ISP_HIST_COMPONENTS                    4
+
+/* program counter */
+#define ISP_PC_WIDTH                           13
+
+/* Template switches */
+#define ISP_SHIELD_INPUT_DMEM                  0
+#define ISP_SHIELD_OUTPUT_DMEM                 1
+#define ISP_SHIELD_INPUT_VMEM                  0
+#define ISP_SHIELD_OUTPUT_VMEM                 0
+#define ISP_SHIELD_INPUT_PMEM                  0
+#define ISP_SHIELD_OUTPUT_PMEM                 1
+#define ISP_SHIELD_INPUT_HIST                  1
+#define ISP_SHIELD_OUTPUT_HIST                 1
+/* When LUT is select the shielding is always on */
+#define ISP_SHIELD_INPUT_VAMEM                 1
+#define ISP_SHIELD_OUTPUT_VAMEM                1
+
+#define ISP_HAS_IRQ                            1
+#define ISP_HAS_SOFT_RESET                     1
+#define ISP_HAS_VEC_DIV                        0
+#define ISP_HAS_VFU_W_2O                       1
+#define ISP_HAS_DEINT3                         1
+#define ISP_HAS_LUT                            1
+#define ISP_HAS_HIST                           1
+#define ISP_HAS_VALSU                          1
+#define ISP_HAS_3rdVALSU                       1
+#define ISP_VRF1_HAS_2P                        1
+
+#define ISP_SRU_GUARDING                       1
+#define ISP_VLSU_GUARDING                      1
+
+#define ISP_VRF_RAM     	                     1
+#define ISP_SRF_RAM     	                     1
+
+#define ISP_SPLIT_VMUL_VADD_IS                 1
+#define ISP_RFSPLIT_FPGA                       0
+
+/* RSN or Bus pipelining */
+#define ISP_RSN_PIPE                           1
+#define ISP_VSF_BUS_PIPE                       0
+
+/* extra slave port to vmem */
+#define ISP_IF_VMEM                            0
+#define ISP_GDC_VMEM                           0
+
+/* Streaming ports */
+#define ISP_IF                                 1
+#define ISP_IF_B                               1
+#define ISP_GDC                                1
+#define ISP_SCL                                1
+#define ISP_GPFIFO                             1
+#define ISP_SP                                 1
+
+/* Removing Issue Slot(s) */
+#define ISP_HAS_NOT_SIMD_IS2                   0
+#define ISP_HAS_NOT_SIMD_IS3                   0
+#define ISP_HAS_NOT_SIMD_IS4                   0
+#define ISP_HAS_NOT_SIMD_IS4_VADD              0
+#define ISP_HAS_NOT_SIMD_IS5                   0
+#define ISP_HAS_NOT_SIMD_IS6                   0
+#define ISP_HAS_NOT_SIMD_IS7                   0
+#define ISP_HAS_NOT_SIMD_IS8                   0
+
+/* ICache  */
+#define ISP_ICACHE                             1
+#define ISP_ICACHE_ONLY                        0
+#define ISP_ICACHE_PREFETCH                    1
+#define ISP_ICACHE_INDEX_BITS                  8
+#define ISP_ICACHE_SET_BITS                    5
+#define ISP_ICACHE_BLOCKS_PER_SET_BITS         1
+
+/* Experimental Flags */
+#define ISP_EXP_1                              0
+#define ISP_EXP_2                              0
+#define ISP_EXP_3                              0
+#define ISP_EXP_4                              0
+#define ISP_EXP_5                              0
+#define ISP_EXP_6                              0
+
+/* Derived values */
+#define ISP_LOG2_PMEM_WIDTH                    10
+#define ISP_VEC_WIDTH                          896
+#define ISP_SLICE_WIDTH                        56
+#define ISP_VMEM_WIDTH                         896
+#define ISP_VMEM_ALIGN                         128
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_ALIGN_ELEM                  2
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_SIMDLSU                            1
+#define ISP_LSU_IMM_BITS                       12
+
+/* convenient shortcuts for software*/
+#define ISP_NWAY                               ISP_VEC_NELEMS
+#define NBITS                                  ISP_VEC_ELEMBITS
+
+#define _isp_ceil_div(a,b)                     (((a)+(b)-1)/(b))
+
+#ifdef C_RUN
+#define ISP_VEC_ALIGN                          (_isp_ceil_div(ISP_VEC_WIDTH, 64)*8)
+#else
+#define ISP_VEC_ALIGN                          ISP_VMEM_ALIGN
+#endif
+
+/* HRT specific vector support */
+#define isp2400A0_mamoiada_vector_alignment         ISP_VEC_ALIGN
+#define isp2400A0_mamoiada_vector_elem_bits         ISP_VMEM_ELEMBITS
+#define isp2400A0_mamoiada_vector_elem_precision    ISP_VMEM_ELEM_PRECISION
+#define isp2400A0_mamoiada_vector_num_elems         ISP_VEC_NELEMS
+
+/* register file sizes */
+#define ISP_RF0_SIZE        64
+#define ISP_RF1_SIZE        16
+#define ISP_RF2_SIZE        64
+#define ISP_RF3_SIZE        4
+#define ISP_RF4_SIZE        64
+#define ISP_RF5_SIZE        16
+#define ISP_RF6_SIZE        16
+#define ISP_RF7_SIZE        16
+#define ISP_RF8_SIZE        16
+#define ISP_RF9_SIZE        16
+#define ISP_RF10_SIZE       16
+#define ISP_RF11_SIZE       16
+#define ISP_VRF1_SIZE       24
+#define ISP_VRF2_SIZE       24
+#define ISP_VRF3_SIZE       24
+#define ISP_VRF4_SIZE       24
+#define ISP_VRF5_SIZE       24
+#define ISP_VRF6_SIZE       24
+#define ISP_VRF7_SIZE       24
+#define ISP_VRF8_SIZE       24
+#define ISP_SRF1_SIZE       4
+#define ISP_SRF2_SIZE       64
+#define ISP_SRF3_SIZE       64
+#define ISP_SRF4_SIZE       32
+#define ISP_SRF5_SIZE       64
+#define ISP_FRF0_SIZE       16
+#define ISP_FRF1_SIZE       4
+#define ISP_FRF2_SIZE       16
+#define ISP_FRF3_SIZE       4
+#define ISP_FRF4_SIZE       4
+#define ISP_FRF5_SIZE       8
+#define ISP_FRF6_SIZE       4
+/* register file read latency */
+#define ISP_VRF1_READ_LAT       1
+#define ISP_VRF2_READ_LAT       1
+#define ISP_VRF3_READ_LAT       1
+#define ISP_VRF4_READ_LAT       1
+#define ISP_VRF5_READ_LAT       1
+#define ISP_VRF6_READ_LAT       1
+#define ISP_VRF7_READ_LAT       1
+#define ISP_VRF8_READ_LAT       1
+#define ISP_SRF1_READ_LAT       1
+#define ISP_SRF2_READ_LAT       1
+#define ISP_SRF3_READ_LAT       1
+#define ISP_SRF4_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+/* immediate sizes */
+#define ISP_IS1_IMM_BITS        14
+#define ISP_IS2_IMM_BITS        13
+#define ISP_IS3_IMM_BITS        14
+#define ISP_IS4_IMM_BITS        14
+#define ISP_IS5_IMM_BITS        9
+#define ISP_IS6_IMM_BITS        16
+#define ISP_IS7_IMM_BITS        9
+#define ISP_IS8_IMM_BITS        16
+#define ISP_IS9_IMM_BITS        11
+/* fifo depths */
+#define ISP_IF_FIFO_DEPTH         0
+#define ISP_IF_B_FIFO_DEPTH       0
+#define ISP_DMA_FIFO_DEPTH        0
+#define ISP_OF_FIFO_DEPTH         0
+#define ISP_GDC_FIFO_DEPTH        0
+#define ISP_SCL_FIFO_DEPTH        0
+#define ISP_GPFIFO_FIFO_DEPTH     0
+#define ISP_SP_FIFO_DEPTH         0
diff --git a/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h b/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h
new file mode 100644
index 0000000..8aaf334
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h
@@ -0,0 +1,267 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Version */
+#define RTL_VERSION
+
+/* Cell name  */
+#define ISP_CELL_TYPE                          isp2400_mamoiada
+#define ISP_VMEM                               simd_vmem
+#define _HRT_ISP_VMEM                          isp2400_mamoiada_simd_vmem
+
+/* instruction pipeline depth */
+#define ISP_BRANCHDELAY                        5
+
+/* bus */
+#define ISP_BUS_WIDTH                          32
+#define ISP_BUS_ADDR_WIDTH                     32
+#define ISP_BUS_BURST_SIZE                     1
+
+/* data-path */
+#define ISP_SCALAR_WIDTH                       32
+#define ISP_SLICE_NELEMS                       4
+#define ISP_VEC_NELEMS                         64
+#define ISP_VEC_ELEMBITS                       14
+#define ISP_VEC_ELEM8BITS                      16
+#define ISP_CLONE_DATAPATH_IS_16               1
+
+/* memories */
+#define ISP_DMEM_DEPTH                         4096
+#define ISP_DMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_DEPTH                         3072
+#define ISP_VMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_ELEMBITS                      14
+#define ISP_VMEM_ELEM_PRECISION                14
+#define ISP_VMEM_IS_BAMEM                      1
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_BAMEM_MAX_BOI_HEIGHT        8
+  #define ISP_VMEM_BAMEM_LATENCY               5
+  #define ISP_VMEM_BAMEM_BANK_NARROWING_FACTOR 2
+  #define ISP_VMEM_BAMEM_NR_DATA_PLANES        8
+  #define ISP_VMEM_BAMEM_NR_CFG_REGISTERS      16
+  #define ISP_VMEM_BAMEM_LININT                0
+  #define ISP_VMEM_BAMEM_DAP_BITS              3
+  #define ISP_VMEM_BAMEM_LININT_FRAC_BITS      0
+  #define ISP_VMEM_BAMEM_PID_BITS              3
+  #define ISP_VMEM_BAMEM_OFFSET_BITS           19
+  #define ISP_VMEM_BAMEM_ADDRESS_BITS          25
+  #define ISP_VMEM_BAMEM_RID_BITS              4
+  #define ISP_VMEM_BAMEM_TRANSPOSITION         1
+  #define ISP_VMEM_BAMEM_VEC_PLUS_SLICE        1
+  #define ISP_VMEM_BAMEM_ARB_SERVICE_CYCLE_BITS 1
+  #define ISP_VMEM_BAMEM_LUT_ELEMS             16
+  #define ISP_VMEM_BAMEM_LUT_ADDR_WIDTH        14
+  #define ISP_VMEM_BAMEM_HALF_BLOCK_WRITE      1
+  #define ISP_VMEM_BAMEM_SMART_FETCH           1
+  #define ISP_VMEM_BAMEM_BIG_ENDIANNESS        0
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_PMEM_DEPTH                         2048
+#define ISP_PMEM_WIDTH                         640
+#define ISP_VAMEM_ADDRESS_BITS                 12
+#define ISP_VAMEM_ELEMBITS                     12
+#define ISP_VAMEM_DEPTH                        2048
+#define ISP_VAMEM_ALIGNMENT                    2
+#define ISP_VA_ADDRESS_WIDTH                   896
+#define ISP_VEC_VALSU_LATENCY                  ISP_VEC_NELEMS
+#define ISP_HIST_ADDRESS_BITS                  12
+#define ISP_HIST_ALIGNMENT                     4
+#define ISP_HIST_COMP_IN_PREC                  12
+#define ISP_HIST_DEPTH                         1024
+#define ISP_HIST_WIDTH                         24
+#define ISP_HIST_COMPONENTS                    4
+
+/* program counter */
+#define ISP_PC_WIDTH                           13
+
+/* Template switches */
+#define ISP_SHIELD_INPUT_DMEM                  0
+#define ISP_SHIELD_OUTPUT_DMEM                 1
+#define ISP_SHIELD_INPUT_VMEM                  0
+#define ISP_SHIELD_OUTPUT_VMEM                 0
+#define ISP_SHIELD_INPUT_PMEM                  1
+#define ISP_SHIELD_OUTPUT_PMEM                 1
+#define ISP_SHIELD_INPUT_HIST                  1
+#define ISP_SHIELD_OUTPUT_HIST                 1
+/* When LUT is select the shielding is always on */
+#define ISP_SHIELD_INPUT_VAMEM                 1
+#define ISP_SHIELD_OUTPUT_VAMEM                1
+
+#define ISP_HAS_IRQ                            1
+#define ISP_HAS_SOFT_RESET                     1
+#define ISP_HAS_VEC_DIV                        0
+#define ISP_HAS_VFU_W_2O                       1
+#define ISP_HAS_DEINT3                         1
+#define ISP_HAS_LUT                            1
+#define ISP_HAS_HIST                           1
+#define ISP_HAS_VALSU                          1
+#define ISP_HAS_3rdVALSU                       1
+#define ISP_VRF1_HAS_2P                        1
+
+#define ISP_SRU_GUARDING                       1
+#define ISP_VLSU_GUARDING                      1
+
+#define ISP_VRF_RAM     	                     1
+#define ISP_SRF_RAM     	                     1
+
+#define ISP_SPLIT_VMUL_VADD_IS                 0
+#define ISP_RFSPLIT_FPGA                       0
+
+/* RSN or Bus pipelining */
+#define ISP_RSN_PIPE                           1
+#define ISP_VSF_BUS_PIPE                       0
+
+/* extra slave port to vmem */
+#define ISP_IF_VMEM                            0
+#define ISP_GDC_VMEM                           0
+
+/* Streaming ports */
+#define ISP_IF                                 1
+#define ISP_IF_B                               1
+#define ISP_GDC                                1
+#define ISP_SCL                                1
+#define ISP_GPFIFO                             1
+#define ISP_SP                                 1
+
+/* Removing Issue Slot(s) */
+#define ISP_HAS_NOT_SIMD_IS2                   0
+#define ISP_HAS_NOT_SIMD_IS3                   0
+#define ISP_HAS_NOT_SIMD_IS4                   0
+#define ISP_HAS_NOT_SIMD_IS4_VADD              0
+#define ISP_HAS_NOT_SIMD_IS5                   0
+#define ISP_HAS_NOT_SIMD_IS6                   0
+#define ISP_HAS_NOT_SIMD_IS7                   0
+#define ISP_HAS_NOT_SIMD_IS8                   0
+
+/* ICache  */
+#define ISP_ICACHE                             1
+#define ISP_ICACHE_ONLY                        0
+#define ISP_ICACHE_PREFETCH                    1
+#define ISP_ICACHE_INDEX_BITS                  8
+#define ISP_ICACHE_SET_BITS                    5
+#define ISP_ICACHE_BLOCKS_PER_SET_BITS         1
+
+/* Experimental Flags */
+#define ISP_EXP_1                              0
+#define ISP_EXP_2                              0
+#define ISP_EXP_3                              0
+#define ISP_EXP_4                              0
+#define ISP_EXP_5                              0
+#define ISP_EXP_6                              0
+
+/* Derived values */
+#define ISP_LOG2_PMEM_WIDTH                    10
+#define ISP_VEC_WIDTH                          896
+#define ISP_SLICE_WIDTH                        56
+#define ISP_VMEM_WIDTH                         896
+#define ISP_VMEM_ALIGN                         128
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_ALIGN_ELEM                  2
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_SIMDLSU                            1
+#define ISP_LSU_IMM_BITS                       12
+
+/* convenient shortcuts for software*/
+#define ISP_NWAY                               ISP_VEC_NELEMS
+#define NBITS                                  ISP_VEC_ELEMBITS
+
+#define _isp_ceil_div(a,b)                     (((a)+(b)-1)/(b))
+
+#ifdef C_RUN
+#define ISP_VEC_ALIGN                          (_isp_ceil_div(ISP_VEC_WIDTH, 64)*8)
+#else
+#define ISP_VEC_ALIGN                          ISP_VMEM_ALIGN
+#endif
+
+/* HRT specific vector support */
+#define isp2400_mamoiada_vector_alignment         ISP_VEC_ALIGN
+#define isp2400_mamoiada_vector_elem_bits         ISP_VMEM_ELEMBITS
+#define isp2400_mamoiada_vector_elem_precision    ISP_VMEM_ELEM_PRECISION
+#define isp2400_mamoiada_vector_num_elems         ISP_VEC_NELEMS
+
+/* register file sizes */
+#define ISP_RF0_SIZE        64
+#define ISP_RF1_SIZE        16
+#define ISP_RF2_SIZE        64
+#define ISP_RF3_SIZE        4
+#define ISP_RF4_SIZE        64
+#define ISP_RF5_SIZE        16
+#define ISP_RF6_SIZE        16
+#define ISP_RF7_SIZE        16
+#define ISP_RF8_SIZE        16
+#define ISP_RF9_SIZE        16
+#define ISP_RF10_SIZE       16
+#define ISP_RF11_SIZE       16
+#define ISP_VRF1_SIZE       24
+#define ISP_VRF2_SIZE       24
+#define ISP_VRF3_SIZE       24
+#define ISP_VRF4_SIZE       24
+#define ISP_VRF5_SIZE       24
+#define ISP_VRF6_SIZE       24
+#define ISP_VRF7_SIZE       24
+#define ISP_VRF8_SIZE       24
+#define ISP_SRF1_SIZE       4
+#define ISP_SRF2_SIZE       64
+#define ISP_SRF3_SIZE       64
+#define ISP_SRF4_SIZE       32
+#define ISP_SRF5_SIZE       64
+#define ISP_FRF0_SIZE       16
+#define ISP_FRF1_SIZE       4
+#define ISP_FRF2_SIZE       16
+#define ISP_FRF3_SIZE       4
+#define ISP_FRF4_SIZE       4
+#define ISP_FRF5_SIZE       8
+#define ISP_FRF6_SIZE       4
+/* register file read latency */
+#define ISP_VRF1_READ_LAT       1
+#define ISP_VRF2_READ_LAT       1
+#define ISP_VRF3_READ_LAT       1
+#define ISP_VRF4_READ_LAT       1
+#define ISP_VRF5_READ_LAT       1
+#define ISP_VRF6_READ_LAT       1
+#define ISP_VRF7_READ_LAT       1
+#define ISP_VRF8_READ_LAT       1
+#define ISP_SRF1_READ_LAT       1
+#define ISP_SRF2_READ_LAT       1
+#define ISP_SRF3_READ_LAT       1
+#define ISP_SRF4_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+/* immediate sizes */
+#define ISP_IS1_IMM_BITS        14
+#define ISP_IS2_IMM_BITS        13
+#define ISP_IS3_IMM_BITS        14
+#define ISP_IS4_IMM_BITS        14
+#define ISP_IS5_IMM_BITS        9
+#define ISP_IS6_IMM_BITS        16
+#define ISP_IS7_IMM_BITS        9
+#define ISP_IS8_IMM_BITS        16
+#define ISP_IS9_IMM_BITS        11
+/* fifo depths */
+#define ISP_IF_FIFO_DEPTH         0
+#define ISP_IF_B_FIFO_DEPTH       0
+#define ISP_DMA_FIFO_DEPTH        0
+#define ISP_OF_FIFO_DEPTH         0
+#define ISP_GDC_FIFO_DEPTH        0
+#define ISP_SCL_FIFO_DEPTH        0
+#define ISP_GPFIFO_FIFO_DEPTH     0
+#define ISP_SP_FIFO_DEPTH         0
diff --git a/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h b/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h
new file mode 100644
index 0000000..d99730a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h
@@ -0,0 +1,243 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _isp_acquisition_defs_h
+#define _isp_acquisition_defs_h
+
+#define _ISP_ACQUISITION_REG_ALIGN                4  /* assuming 32 bit control bus width */
+#define _ISP_ACQUISITION_BYTES_PER_ELEM           4		
+
+/* --------------------------------------------------*/
+
+#define NOF_ACQ_IRQS                              1
+
+/* --------------------------------------------------*/
+/* FSM */
+/* --------------------------------------------------*/
+#define MEM2STREAM_FSM_STATE_BITS                 2
+#define ACQ_SYNCHRONIZER_FSM_STATE_BITS           2
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+#define NOF_ACQ_REGS                              12      
+
+// Register id's of MMIO slave accesible registers
+#define ACQ_START_ADDR_REG_ID                     0              
+#define ACQ_MEM_REGION_SIZE_REG_ID                1
+#define ACQ_NUM_MEM_REGIONS_REG_ID                2
+#define ACQ_INIT_REG_ID                           3 
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_ID         4
+#define ACQ_RECEIVED_LONG_PACKETS_REG_ID          5
+#define ACQ_LAST_COMMAND_REG_ID                   6
+#define ACQ_NEXT_COMMAND_REG_ID                   7
+#define ACQ_LAST_ACKNOWLEDGE_REG_ID               8
+#define ACQ_NEXT_ACKNOWLEDGE_REG_ID               9
+#define ACQ_FSM_STATE_INFO_REG_ID                 10
+#define ACQ_INT_CNTR_INFO_REG_ID                  11
+ 
+// Register width
+#define ACQ_START_ADDR_REG_WIDTH                  9               
+#define ACQ_MEM_REGION_SIZE_REG_WIDTH             9  
+#define ACQ_NUM_MEM_REGIONS_REG_WIDTH             9  
+#define ACQ_INIT_REG_WIDTH                        3  
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_WIDTH      32 
+#define ACQ_RECEIVED_LONG_PACKETS_REG_WIDTH       32  
+#define ACQ_LAST_COMMAND_REG_WIDTH                32  
+#define ACQ_NEXT_COMMAND_REG_WIDTH                32  
+#define ACQ_LAST_ACKNOWLEDGE_REG_WIDTH            32  
+#define ACQ_NEXT_ACKNOWLEDGE_REG_WIDTH            32  
+#define ACQ_FSM_STATE_INFO_REG_WIDTH              ((MEM2STREAM_FSM_STATE_BITS * 3) + (ACQ_SYNCHRONIZER_FSM_STATE_BITS *3))
+#define ACQ_INT_CNTR_INFO_REG_WIDTH               32
+
+/* register reset value */
+#define ACQ_START_ADDR_REG_RSTVAL                 0              
+#define ACQ_MEM_REGION_SIZE_REG_RSTVAL            128
+#define ACQ_NUM_MEM_REGIONS_REG_RSTVAL            3
+#define ACQ_INIT_REG_RSTVAL                       0                           
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_RSTVAL     0
+#define ACQ_RECEIVED_LONG_PACKETS_REG_RSTVAL      0
+#define ACQ_LAST_COMMAND_REG_RSTVAL               0
+#define ACQ_NEXT_COMMAND_REG_RSTVAL               0
+#define ACQ_LAST_ACKNOWLEDGE_REG_RSTVAL           0
+#define ACQ_NEXT_ACKNOWLEDGE_REG_RSTVAL           0 
+#define ACQ_FSM_STATE_INFO_REG_RSTVAL             0
+#define ACQ_INT_CNTR_INFO_REG_RSTVAL              0 
+
+/* bit definitions */
+#define ACQ_INIT_RST_REG_BIT                      0
+#define ACQ_INIT_RESYNC_BIT                       2
+#define ACQ_INIT_RST_IDX                          ACQ_INIT_RST_REG_BIT
+#define ACQ_INIT_RST_BITS                         1
+#define ACQ_INIT_RESYNC_IDX                       ACQ_INIT_RESYNC_BIT
+#define ACQ_INIT_RESYNC_BITS                      1
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+#define ACQ_TOKEN_ID_LSB                          0
+#define ACQ_TOKEN_ID_MSB                          3            
+#define ACQ_TOKEN_WIDTH                           (ACQ_TOKEN_ID_MSB - ACQ_TOKEN_ID_LSB  + 1) // 4
+#define ACQ_TOKEN_ID_IDX                          0
+#define ACQ_TOKEN_ID_BITS                         ACQ_TOKEN_WIDTH
+#define ACQ_INIT_CMD_INIT_IDX                     4
+#define ACQ_INIT_CMD_INIT_BITS                    3
+#define ACQ_CMD_START_ADDR_IDX                    4
+#define ACQ_CMD_START_ADDR_BITS                   9
+#define ACQ_CMD_NOFWORDS_IDX                      13
+#define ACQ_CMD_NOFWORDS_BITS                     9  
+#define ACQ_MEM_REGION_ID_IDX                     22
+#define ACQ_MEM_REGION_ID_BITS                    9 
+#define ACQ_PACKET_LENGTH_TOKEN_MSB               21
+#define ACQ_PACKET_LENGTH_TOKEN_LSB               13
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_MSB       9
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_LSB       4
+#define ACQ_PACKET_CH_ID_TOKEN_MSB                11
+#define ACQ_PACKET_CH_ID_TOKEN_LSB                10
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_MSB        12		/* only for capt_end_of_packet_written */
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_LSB        4		/* only for capt_end_of_packet_written */
+
+
+/* Command tokens IDs */
+#define ACQ_READ_REGION_AUTO_INCR_TOKEN_ID        0 //0000b
+#define ACQ_READ_REGION_TOKEN_ID                  1 //0001b
+#define ACQ_READ_REGION_SOP_TOKEN_ID              2 //0010b  
+#define ACQ_INIT_TOKEN_ID                         8 //1000b
+
+/* Acknowledge token IDs */
+#define ACQ_READ_REGION_ACK_TOKEN_ID              0 //0000b
+#define ACQ_END_OF_PACKET_TOKEN_ID                4 //0100b
+#define ACQ_END_OF_REGION_TOKEN_ID                5 //0101b
+#define ACQ_SOP_MISMATCH_TOKEN_ID                 6 //0110b
+#define ACQ_UNDEF_PH_TOKEN_ID                     7 //0111b
+
+#define ACQ_TOKEN_MEMREGIONID_MSB                 30
+#define ACQ_TOKEN_MEMREGIONID_LSB                 22
+#define ACQ_TOKEN_NOFWORDS_MSB                    21
+#define ACQ_TOKEN_NOFWORDS_LSB                    13
+#define ACQ_TOKEN_STARTADDR_MSB                   12
+#define ACQ_TOKEN_STARTADDR_LSB                   4  
+
+
+/* --------------------------------------------------*/
+/* MIPI */
+/* --------------------------------------------------*/
+
+#define WORD_COUNT_WIDTH                          16
+#define PKT_CODE_WIDTH                            6            
+#define CHN_NO_WIDTH                              2  
+#define ERROR_INFO_WIDTH                          8
+  
+#define LONG_PKTCODE_MAX                          63
+#define LONG_PKTCODE_MIN                          16
+#define SHORT_PKTCODE_MAX                         15
+
+#define EOF_CODE                                  1
+
+/* --------------------------------------------------*/
+/* Packet Info */
+/* --------------------------------------------------*/
+#define ACQ_START_OF_FRAME                        0
+#define ACQ_END_OF_FRAME                          1
+#define ACQ_START_OF_LINE                         2
+#define ACQ_END_OF_LINE                           3
+#define ACQ_LINE_PAYLOAD                          4
+#define ACQ_GEN_SH_PKT                            5
+
+
+/* bit definition */
+#define ACQ_PKT_TYPE_IDX                          16
+#define ACQ_PKT_TYPE_BITS                         6
+#define ACQ_PKT_SOP_IDX                           32
+#define ACQ_WORD_CNT_IDX                          0
+#define ACQ_WORD_CNT_BITS                         16
+#define ACQ_PKT_INFO_IDX                          16
+#define ACQ_PKT_INFO_BITS                         8
+#define ACQ_HEADER_DATA_IDX                       0
+#define ACQ_HEADER_DATA_BITS                      16
+#define ACQ_ACK_TOKEN_ID_IDX                      ACQ_TOKEN_ID_IDX
+#define ACQ_ACK_TOKEN_ID_BITS                     ACQ_TOKEN_ID_BITS
+#define ACQ_ACK_NOFWORDS_IDX                      13
+#define ACQ_ACK_NOFWORDS_BITS                     9
+#define ACQ_ACK_PKT_LEN_IDX                       4
+#define ACQ_ACK_PKT_LEN_BITS                      16
+
+
+/* --------------------------------------------------*/
+/* Packet Data Type */
+/* --------------------------------------------------*/
+
+
+#define ACQ_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
+#define ACQ_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
+#define ACQ_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
+#define ACQ_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
+#define ACQ_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
+#define ACQ_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
+#define ACQ_RGB555_DATA              					 33   /* 10 0001   RGB555                                            */
+#define ACQ_RGB565_DATA              					 34   /* 10 0010   RGB565                                            */
+#define ACQ_RGB666_DATA              					 35   /* 10 0011   RGB666                                            */
+#define ACQ_RGB888_DATA              					 36   /* 10 0100   RGB888                                            */
+#define ACQ_RAW6_DATA                					 40   /* 10 1000   RAW6                                              */
+#define ACQ_RAW7_DATA                					 41   /* 10 1001   RAW7                                              */
+#define ACQ_RAW8_DATA                					 42   /* 10 1010   RAW8                                              */
+#define ACQ_RAW10_DATA               					 43   /* 10 1011   RAW10                                             */
+#define ACQ_RAW12_DATA               					 44   /* 10 1100   RAW12                                             */
+#define ACQ_RAW14_DATA               					 45   /* 10 1101   RAW14                                             */
+#define ACQ_USR_DEF_1_DATA           					 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define ACQ_USR_DEF_2_DATA           					 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define ACQ_USR_DEF_3_DATA           					 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define ACQ_USR_DEF_4_DATA           					 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define ACQ_USR_DEF_5_DATA           					 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define ACQ_USR_DEF_6_DATA           					 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define ACQ_USR_DEF_7_DATA           					 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define ACQ_USR_DEF_8_DATA           					 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define ACQ_Emb_DATA                 					 18   /* 01 0010    embedded eight bit non image data                */
+#define ACQ_SOF_DATA                 					 0   /* 00 0000    frame start                                      */
+#define ACQ_EOF_DATA                 					 1   /* 00 0001    frame end                                        */
+#define ACQ_SOL_DATA                 					 2   /* 00 0010    line start                                       */
+#define ACQ_EOL_DATA                 					 3   /* 00 0011    line end                                         */
+#define ACQ_GEN_SH1_DATA             					 8   /* 00 1000  Generic Short Packet Code 1                        */
+#define ACQ_GEN_SH2_DATA             					 9   /* 00 1001    Generic Short Packet Code 2                      */
+#define ACQ_GEN_SH3_DATA             					 10   /* 00 1010    Generic Short Packet Code 3                      */
+#define ACQ_GEN_SH4_DATA             					 11   /* 00 1011    Generic Short Packet Code 4                      */
+#define ACQ_GEN_SH5_DATA             					 12   /* 00 1100    Generic Short Packet Code 5                      */
+#define ACQ_GEN_SH6_DATA             					 13   /* 00 1101    Generic Short Packet Code 6                      */
+#define ACQ_GEN_SH7_DATA             					 14   /* 00 1110    Generic Short Packet Code 7                      */
+#define ACQ_GEN_SH8_DATA             					 15   /* 00 1111    Generic Short Packet Code 8                      */
+#define ACQ_YUV420_8_CSPS_DATA       					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define ACQ_YUV420_10_CSPS_DATA      					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define ACQ_RESERVED_DATA_TYPE_MIN              56
+#define ACQ_RESERVED_DATA_TYPE_MAX              63
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
+#define ACQ_YUV_RESERVED_DATA_TYPE              27
+#define ACQ_RGB_RESERVED_DATA_TYPE_MIN          37
+#define ACQ_RGB_RESERVED_DATA_TYPE_MAX          39
+#define ACQ_RAW_RESERVED_DATA_TYPE_MIN          46
+#define ACQ_RAW_RESERVED_DATA_TYPE_MAX          47
+
+/* --------------------------------------------------*/
+
+#endif /* _isp_acquisition_defs_h */ 
diff --git a/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h b/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h
new file mode 100644
index 0000000..0e7cf54
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h
@@ -0,0 +1,319 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _isp_capture_defs_h
+#define _isp_capture_defs_h
+
+#define _ISP_CAPTURE_REG_ALIGN                    4  /* assuming 32 bit control bus width */
+#define _ISP_CAPTURE_BITS_PER_ELEM                32  /* only for data, not SOP */						           
+#define _ISP_CAPTURE_BYTES_PER_ELEM               (_ISP_CAPTURE_BITS_PER_ELEM/8	)				           
+#define _ISP_CAPTURE_BYTES_PER_WORD               32		/* 256/8 */	
+#define _ISP_CAPTURE_ELEM_PER_WORD                _ISP_CAPTURE_BYTES_PER_WORD / _ISP_CAPTURE_BYTES_PER_ELEM		           
+
+//#define CAPT_RCV_ACK                              1
+//#define CAPT_WRT_ACK                              2               
+//#define CAPT_IRQ_ACK                              3                        
+
+/* --------------------------------------------------*/
+
+#define NOF_IRQS                                  2
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+// Number of registers
+#define CAPT_NOF_REGS                             16
+
+// Register id's of MMIO slave accesible registers
+#define CAPT_START_MODE_REG_ID                    0
+#define CAPT_START_ADDR_REG_ID                    1 
+#define CAPT_MEM_REGION_SIZE_REG_ID               2 
+#define CAPT_NUM_MEM_REGIONS_REG_ID               3 
+#define CAPT_INIT_REG_ID                          4 
+#define CAPT_START_REG_ID                         5
+#define CAPT_STOP_REG_ID                          6  
+
+#define CAPT_PACKET_LENGTH_REG_ID                 7
+#define CAPT_RECEIVED_LENGTH_REG_ID               8 
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_ID        9 
+#define CAPT_RECEIVED_LONG_PACKETS_REG_ID         10 
+#define CAPT_LAST_COMMAND_REG_ID                  11        
+#define CAPT_NEXT_COMMAND_REG_ID                  12
+#define CAPT_LAST_ACKNOWLEDGE_REG_ID              13
+#define CAPT_NEXT_ACKNOWLEDGE_REG_ID              14
+#define CAPT_FSM_STATE_INFO_REG_ID                15
+
+// Register width
+#define CAPT_START_MODE_REG_WIDTH                 1 
+#define CAPT_START_ADDR_REG_WIDTH                 9
+#define CAPT_MEM_REGION_SIZE_REG_WIDTH            9
+#define CAPT_NUM_MEM_REGIONS_REG_WIDTH            9
+#define CAPT_INIT_REG_WIDTH                       (18 + 4)
+
+#define CAPT_START_REG_WIDTH                      1
+#define CAPT_STOP_REG_WIDTH                       1
+
+/* --------------------------------------------------*/
+/* FSM */
+/* --------------------------------------------------*/
+#define CAPT_WRITE2MEM_FSM_STATE_BITS             2
+#define CAPT_SYNCHRONIZER_FSM_STATE_BITS          3
+
+
+#define CAPT_PACKET_LENGTH_REG_WIDTH              17
+#define CAPT_RECEIVED_LENGTH_REG_WIDTH            17   
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_WIDTH     32
+#define CAPT_RECEIVED_LONG_PACKETS_REG_WIDTH      32
+#define CAPT_LAST_COMMAND_REG_WIDTH               32
+/* #define CAPT_NEXT_COMMAND_REG_WIDTH               32 */  
+#define CAPT_LAST_ACKNOWLEDGE_REG_WIDTH           32
+#define CAPT_NEXT_ACKNOWLEDGE_REG_WIDTH           32
+#define CAPT_FSM_STATE_INFO_REG_WIDTH             ((CAPT_WRITE2MEM_FSM_STATE_BITS * 3) + (CAPT_SYNCHRONIZER_FSM_STATE_BITS * 3))
+
+#define CAPT_INIT_RESTART_MEM_ADDR_WIDTH          9   
+#define CAPT_INIT_RESTART_MEM_REGION_WIDTH        9 
+
+/* register reset value */
+#define CAPT_START_MODE_REG_RSTVAL                0   
+#define CAPT_START_ADDR_REG_RSTVAL                0
+#define CAPT_MEM_REGION_SIZE_REG_RSTVAL           128
+#define CAPT_NUM_MEM_REGIONS_REG_RSTVAL           3 
+#define CAPT_INIT_REG_RSTVAL                      0
+
+#define CAPT_START_REG_RSTVAL                     0
+#define CAPT_STOP_REG_RSTVAL                      0
+
+#define CAPT_PACKET_LENGTH_REG_RSTVAL             0
+#define CAPT_RECEIVED_LENGTH_REG_RSTVAL           0
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_RSTVAL    0
+#define CAPT_RECEIVED_LONG_PACKETS_REG_RSTVAL     0
+#define CAPT_LAST_COMMAND_REG_RSTVAL              0
+#define CAPT_NEXT_COMMAND_REG_RSTVAL              0
+#define CAPT_LAST_ACKNOWLEDGE_REG_RSTVAL          0
+#define CAPT_NEXT_ACKNOWLEDGE_REG_RSTVAL          0
+#define CAPT_FSM_STATE_INFO_REG_RSTVAL            0
+
+/* bit definitions */
+#define CAPT_INIT_RST_REG_BIT                     0
+#define CAPT_INIT_FLUSH_BIT                       1
+#define CAPT_INIT_RESYNC_BIT                      2
+#define CAPT_INIT_RESTART_BIT                     3
+#define CAPT_INIT_RESTART_MEM_ADDR_LSB            4
+#define CAPT_INIT_RESTART_MEM_ADDR_MSB            12
+#define CAPT_INIT_RESTART_MEM_REGION_LSB          13
+#define CAPT_INIT_RESTART_MEM_REGION_MSB          21
+
+
+#define CAPT_INIT_RST_REG_IDX                     CAPT_INIT_RST_REG_BIT
+#define CAPT_INIT_RST_REG_BITS                    1
+#define CAPT_INIT_FLUSH_IDX                       CAPT_INIT_FLUSH_BIT
+#define CAPT_INIT_FLUSH_BITS                      1
+#define CAPT_INIT_RESYNC_IDX                      CAPT_INIT_RESYNC_BIT
+#define CAPT_INIT_RESYNC_BITS                     1
+#define CAPT_INIT_RESTART_IDX                     CAPT_INIT_RESTART_BIT
+#define CAPT_INIT_RESTART_BITS					  				1
+#define CAPT_INIT_RESTART_MEM_ADDR_IDX            CAPT_INIT_RESTART_MEM_ADDR_LSB
+#define CAPT_INIT_RESTART_MEM_ADDR_BITS           (CAPT_INIT_RESTART_MEM_ADDR_MSB - CAPT_INIT_RESTART_MEM_ADDR_LSB + 1)
+#define CAPT_INIT_RESTART_MEM_REGION_IDX          CAPT_INIT_RESTART_MEM_REGION_LSB
+#define CAPT_INIT_RESTART_MEM_REGION_BITS         (CAPT_INIT_RESTART_MEM_REGION_MSB - CAPT_INIT_RESTART_MEM_REGION_LSB + 1)
+
+
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+#define CAPT_TOKEN_ID_LSB                         0
+#define CAPT_TOKEN_ID_MSB                         3            
+#define CAPT_TOKEN_WIDTH                         (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB  + 1) /* 4 */
+
+/* Command tokens IDs */
+#define CAPT_START_TOKEN_ID                       0 /* 0000b */
+#define CAPT_STOP_TOKEN_ID                        1 /* 0001b */
+#define CAPT_FREEZE_TOKEN_ID                      2 /* 0010b */  
+#define CAPT_RESUME_TOKEN_ID                      3 /* 0011b */
+#define CAPT_INIT_TOKEN_ID                        8 /* 1000b */
+
+#define CAPT_START_TOKEN_BIT                      0      
+#define CAPT_STOP_TOKEN_BIT                       0
+#define CAPT_FREEZE_TOKEN_BIT                     0
+#define CAPT_RESUME_TOKEN_BIT                     0
+#define CAPT_INIT_TOKEN_BIT                       0
+
+/* Acknowledge token IDs */
+#define CAPT_END_OF_PACKET_RECEIVED_TOKEN_ID      0 /* 0000b */
+#define CAPT_END_OF_PACKET_WRITTEN_TOKEN_ID       1 /* 0001b */
+#define CAPT_END_OF_REGION_WRITTEN_TOKEN_ID       2 /* 0010b */
+#define CAPT_FLUSH_DONE_TOKEN_ID                  3 /* 0011b */
+#define CAPT_PREMATURE_SOP_TOKEN_ID               4 /* 0100b */
+#define CAPT_MISSING_SOP_TOKEN_ID                 5 /* 0101b */
+#define CAPT_UNDEF_PH_TOKEN_ID                    6 /* 0110b */
+#define CAPT_STOP_ACK_TOKEN_ID                    7 /* 0111b */
+
+#define CAPT_PACKET_LENGTH_TOKEN_MSB             19
+#define CAPT_PACKET_LENGTH_TOKEN_LSB              4
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB       20
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB        4
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB     25
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB     20
+#define CAPT_PACKET_CH_ID_TOKEN_MSB              27
+#define CAPT_PACKET_CH_ID_TOKEN_LSB              26
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB      29		
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB      21		
+
+/*  bit definition */
+#define CAPT_CMD_IDX                              CAPT_TOKEN_ID_LSB
+#define	CAPT_CMD_BITS                             (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB + 1)
+#define CAPT_SOP_IDX                              32
+#define CAPT_SOP_BITS                             1
+#define CAPT_PKT_INFO_IDX                         16
+#define CAPT_PKT_INFO_BITS                        8
+#define CAPT_PKT_TYPE_IDX                         0
+#define CAPT_PKT_TYPE_BITS                        6
+#define CAPT_HEADER_DATA_IDX                      0
+#define CAPT_HEADER_DATA_BITS                     16
+#define CAPT_PKT_DATA_IDX                         0
+#define CAPT_PKT_DATA_BITS                        32
+#define CAPT_WORD_CNT_IDX                         0
+#define CAPT_WORD_CNT_BITS                        16
+#define CAPT_ACK_TOKEN_ID_IDX                     0
+#define CAPT_ACK_TOKEN_ID_BITS                    4
+//#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
+//#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
+//#define CAPT_ACK_PKT_INFO_IDX                     20
+//#define CAPT_ACK_PKT_INFO_BITS                    8
+//#define CAPT_ACK_MEM_REG_ID1_IDX                  20			/* for capt_end_of_packet_written */
+//#define CAPT_ACK_MEM_REG_ID2_IDX                  4       /* for capt_end_of_region_written */
+#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_SUPER_PKT_LEN_IDX                CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_SUPER_PKT_LEN_BITS               (CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB - CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_INFO_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_INFO_BITS                    (CAPT_PACKET_CH_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_MEM_REGION_ID_IDX                CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB
+#define CAPT_ACK_MEM_REGION_ID_BITS               (CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB - CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_TYPE_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_TYPE_BITS                    (CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_INIT_TOKEN_INIT_IDX                  4
+#define CAPT_INIT_TOKEN_INIT_BITS                 22
+
+
+/* --------------------------------------------------*/
+/* MIPI */
+/* --------------------------------------------------*/
+
+#define CAPT_WORD_COUNT_WIDTH                     16      
+#define CAPT_PKT_CODE_WIDTH                       6                  
+#define CAPT_CHN_NO_WIDTH                         2        
+#define CAPT_ERROR_INFO_WIDTH                     8       
+
+#define LONG_PKTCODE_MAX                          63
+#define LONG_PKTCODE_MIN                          16
+#define SHORT_PKTCODE_MAX                         15
+
+
+/* --------------------------------------------------*/
+/* Packet Info */
+/* --------------------------------------------------*/
+#define CAPT_START_OF_FRAME                       0
+#define CAPT_END_OF_FRAME                         1
+#define CAPT_START_OF_LINE                        2
+#define CAPT_END_OF_LINE                          3
+#define CAPT_LINE_PAYLOAD                         4
+#define CAPT_GEN_SH_PKT                           5
+
+
+/* --------------------------------------------------*/
+/* Packet Data Type */
+/* --------------------------------------------------*/
+
+#define CAPT_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
+#define CAPT_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
+#define CAPT_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
+#define CAPT_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
+#define CAPT_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
+#define CAPT_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
+#define CAPT_RGB555_DATA              					 33   /* 10 0001   RGB555                                            */
+#define CAPT_RGB565_DATA              					 34   /* 10 0010   RGB565                                            */
+#define CAPT_RGB666_DATA              					 35   /* 10 0011   RGB666                                            */
+#define CAPT_RGB888_DATA              					 36   /* 10 0100   RGB888                                            */
+#define CAPT_RAW6_DATA                					 40   /* 10 1000   RAW6                                              */
+#define CAPT_RAW7_DATA                					 41   /* 10 1001   RAW7                                              */
+#define CAPT_RAW8_DATA                					 42   /* 10 1010   RAW8                                              */
+#define CAPT_RAW10_DATA               					 43   /* 10 1011   RAW10                                             */
+#define CAPT_RAW12_DATA               					 44   /* 10 1100   RAW12                                             */
+#define CAPT_RAW14_DATA               					 45   /* 10 1101   RAW14                                             */
+#define CAPT_USR_DEF_1_DATA           					 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define CAPT_USR_DEF_2_DATA           					 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define CAPT_USR_DEF_3_DATA           					 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define CAPT_USR_DEF_4_DATA           					 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define CAPT_USR_DEF_5_DATA           					 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define CAPT_USR_DEF_6_DATA           					 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define CAPT_USR_DEF_7_DATA           					 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define CAPT_USR_DEF_8_DATA           					 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define CAPT_Emb_DATA                 					 18   /* 01 0010    embedded eight bit non image data                */
+#define CAPT_SOF_DATA                 					 0   /* 00 0000    frame start                                      */
+#define CAPT_EOF_DATA                 					 1   /* 00 0001    frame end                                        */
+#define CAPT_SOL_DATA                 					 2   /* 00 0010    line start                                       */
+#define CAPT_EOL_DATA                 					 3   /* 00 0011    line end                                         */
+#define CAPT_GEN_SH1_DATA             					 8   /* 00 1000  Generic Short Packet Code 1                        */
+#define CAPT_GEN_SH2_DATA             					 9   /* 00 1001    Generic Short Packet Code 2                      */
+#define CAPT_GEN_SH3_DATA             					 10   /* 00 1010    Generic Short Packet Code 3                      */
+#define CAPT_GEN_SH4_DATA             					 11   /* 00 1011    Generic Short Packet Code 4                      */
+#define CAPT_GEN_SH5_DATA             					 12   /* 00 1100    Generic Short Packet Code 5                      */
+#define CAPT_GEN_SH6_DATA             					 13   /* 00 1101    Generic Short Packet Code 6                      */
+#define CAPT_GEN_SH7_DATA             					 14   /* 00 1110    Generic Short Packet Code 7                      */
+#define CAPT_GEN_SH8_DATA             					 15   /* 00 1111    Generic Short Packet Code 8                      */
+#define CAPT_YUV420_8_CSPS_DATA       					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define CAPT_YUV420_10_CSPS_DATA      					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define CAPT_RESERVED_DATA_TYPE_MIN              56
+#define CAPT_RESERVED_DATA_TYPE_MAX              63
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
+#define CAPT_YUV_RESERVED_DATA_TYPE              27
+#define CAPT_RGB_RESERVED_DATA_TYPE_MIN          37
+#define CAPT_RGB_RESERVED_DATA_TYPE_MAX          39
+#define CAPT_RAW_RESERVED_DATA_TYPE_MIN          46
+#define CAPT_RAW_RESERVED_DATA_TYPE_MAX          47
+
+
+/* --------------------------------------------------*/
+/* Capture Unit State */
+/* --------------------------------------------------*/
+#define CAPT_FREE_RUN                             0
+#define CAPT_NO_SYNC                              1
+#define CAPT_SYNC_SWP                             2
+#define CAPT_SYNC_MWP                             3
+#define CAPT_SYNC_WAIT                            4
+#define CAPT_FREEZE                               5
+#define CAPT_RUN                                  6
+
+
+/* --------------------------------------------------*/
+
+#endif /* _isp_capture_defs_h */ 
+
+
+
+
+
diff --git a/drivers/media/atomisp2/css2400/hrt/mmu_defs.h b/drivers/media/atomisp2/css2400/hrt/mmu_defs.h
new file mode 100644
index 0000000..6aa8ed5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/mmu_defs.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _mmu_defs_h
+#define _mmu_defs_h
+
+#define _HRT_MMU_INVALIDATE_TLB_REG_IDX          0
+#define _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX 1
+
+#define _HRT_MMU_REG_ALIGN 4
+
+#endif /* _mmu_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h b/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h
new file mode 100644
index 0000000..c1a4d23
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _scalar_processor_2400_params_h
+#define _scalar_processor_2400_params_h
+
+#include "cell_params.h"
+
+#endif /* _scalar_processor_2400_params_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/sp_hrt.h b/drivers/media/atomisp2/css2400/hrt/sp_hrt.h
new file mode 100644
index 0000000..a3ad0bc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/sp_hrt.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _sp_hrt_h_
+#define _sp_hrt_h_
+
+#define hrt_sp_dmem(cell) HRT_PROC_TYPE_PROP(cell, _dmem)
+
+#define hrt_sp_dmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_sp_dmem(cell))
+
+#endif /* _sp_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h b/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h
new file mode 100644
index 0000000..754cf32
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ST2MEM_DEFS_H
+#define _ST2MEM_DEFS_H
+
+#define _STR2MEM_CRUN_BIT               0x100000
+#define _STR2MEM_CMD_BITS               0x0F0000
+#define _STR2MEM_COUNT_BITS             0x00FFFF
+
+#define _STR2MEM_BLOCKS_CMD             0xA0000
+#define _STR2MEM_PACKETS_CMD            0xB0000
+#define _STR2MEM_BYTES_CMD              0xC0000
+#define _STR2MEM_BYTES_FROM_PACKET_CMD  0xD0000
+
+#define _STR2MEM_SOFT_RESET_REG_ID                   0
+#define _STR2MEM_INPUT_ENDIANNESS_REG_ID             1
+#define _STR2MEM_OUTPUT_ENDIANNESS_REG_ID            2
+#define _STR2MEM_BIT_SWAPPING_REG_ID                 3
+#define _STR2MEM_BLOCK_SYNC_LEVEL_REG_ID             4
+#define _STR2MEM_PACKET_SYNC_LEVEL_REG_ID            5
+#define _STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID  6
+#define _STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID     7
+#define _STR2MEM_EN_STAT_UPDATE_ID                   8
+
+#define _STR2MEM_REG_ALIGN      4
+
+#endif /* _ST2MEM_DEFS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h b/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h
new file mode 100644
index 0000000..2826ce8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _streaming_to_mipi_defs_h
+#define _streaming_to_mipi_defs_h
+
+#define HIVE_STR_TO_MIPI_VALID_A_BIT 0
+#define HIVE_STR_TO_MIPI_VALID_B_BIT 1
+#define HIVE_STR_TO_MIPI_SOL_BIT     2
+#define HIVE_STR_TO_MIPI_EOL_BIT     3
+#define HIVE_STR_TO_MIPI_SOF_BIT     4
+#define HIVE_STR_TO_MIPI_EOF_BIT     5
+#define HIVE_STR_TO_MIPI_CH_ID_LSB   6
+
+#define HIVE_STR_TO_MIPI_DATA_A_LSB  (HIVE_STR_TO_MIPI_VALID_B_BIT + 1)
+
+#endif /* _streaming_to_mipi_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h b/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h
new file mode 100644
index 0000000..b2b796d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _timed_controller_defs_h
+#define _timed_controller_defs_h
+
+#define _HRT_TIMED_CONTROLLER_CMD_REG_IDX 0
+
+#define _HRT_TIMED_CONTROLLER_REG_ALIGN 4
+
+#endif /* _timed_controller_defs_h */   
diff --git a/drivers/media/atomisp2/css2400/hrt/var.h b/drivers/media/atomisp2/css2400/hrt/var.h
new file mode 100644
index 0000000..02a2710
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/var.h
@@ -0,0 +1,106 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_VAR_H
+#define _HRT_VAR_H
+
+#include "version.h"
+#include "system_api.h"
+#include "hive_types.h"
+
+#define hrt_int_type_of_char   char
+#define hrt_int_type_of_uchar  unsigned char
+#define hrt_int_type_of_short  short
+#define hrt_int_type_of_ushort unsigned short
+#define hrt_int_type_of_int    int
+#define hrt_int_type_of_uint   unsigned int
+#define hrt_int_type_of_long   long
+#define hrt_int_type_of_ulong  unsigned long
+#define hrt_int_type_of_ptr    unsigned int
+
+#define hrt_host_type_of_char   char
+#define hrt_host_type_of_uchar  unsigned char
+#define hrt_host_type_of_short  short
+#define hrt_host_type_of_ushort unsigned short
+#define hrt_host_type_of_int    int
+#define hrt_host_type_of_uint   unsigned int
+#define hrt_host_type_of_long   long
+#define hrt_host_type_of_ulong  unsigned long
+#define hrt_host_type_of_ptr    void*
+
+#define HRT_TYPE_BYTES(cell, type) (HRT_TYPE_BITS(cell, type)/8)
+#define HRT_HOST_TYPE(cell_type)   HRTCAT(hrt_host_type_of_, cell_type)
+#define HRT_INT_TYPE(type)         HRTCAT(hrt_int_type_of_, type)
+
+#ifdef C_RUN
+
+#ifdef C_RUN_DYNAMIC_LINK_PROGRAMS
+extern void *csim_processor_get_crun_symbol(hive_proc_id p, const char *sym);
+#define _hrt_cell_get_crun_symbol(cell,sym)          csim_processor_get_crun_symbol(cell,HRTSTR(sym))
+#define _hrt_cell_get_crun_indexed_symbol(cell,sym)  csim_processor_get_crun_symbol(cell,HRTSTR(sym))
+#else
+#define _hrt_cell_get_crun_symbol(cell,sym)         (&sym)
+#define _hrt_cell_get_crun_indexed_symbol(cell,sym) (sym)
+#endif //  C_RUN_DYNAMIC_LINK_PROGRAMS
+
+#define hrt_scalar_store(cell, type, var, data) \
+	((*(HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_symbol(cell,var)) = (data))
+#define hrt_scalar_load(cell, type, var) \
+	((*(HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_symbol(cell,var)))
+
+#define hrt_indexed_store(cell, type, array, index, data) \
+	((((HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_indexed_symbol(cell,array))[index]) = (data))
+#define hrt_indexed_load(cell, type, array, index) \
+	(((HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_indexed_symbol(cell,array))[index])
+
+#else /* C_RUN */
+
+#define hrt_scalar_store(cell, type, var, data) \
+  HRTCAT(hrt_mem_store_,HRT_TYPE_BITS(cell, type))(\
+	       cell, \
+	       HRTCAT(HIVE_MEM_,var), \
+	       HRTCAT(HIVE_ADDR_,var), \
+	       (HRT_INT_TYPE(type))(data))
+
+#define hrt_scalar_load(cell, type, var) \
+  (HRT_HOST_TYPE(type))(HRTCAT4(_hrt_mem_load_,HRT_PROC_TYPE(cell),_,type) ( \
+	       cell, \
+	       HRTCAT(HIVE_MEM_,var), \
+	       HRTCAT(HIVE_ADDR_,var)))
+
+#define hrt_indexed_store(cell, type, array, index, data) \
+  HRTCAT(hrt_mem_store_,HRT_TYPE_BITS(cell, type))(\
+	       cell, \
+	       HRTCAT(HIVE_MEM_,array), \
+	       (HRTCAT(HIVE_ADDR_,array))+((index)*HRT_TYPE_BYTES(cell, type)), \
+	       (HRT_INT_TYPE(type))(data))
+
+#define hrt_indexed_load(cell, type, array, index) \
+  (HRT_HOST_TYPE(type))(HRTCAT4(_hrt_mem_load_,HRT_PROC_TYPE(cell),_,type) ( \
+         cell, \
+	       HRTCAT(HIVE_MEM_,array), \
+	       (HRTCAT(HIVE_ADDR_,array))+((index)*HRT_TYPE_BYTES(cell, type))))
+
+#endif /* C_RUN */
+
+#endif /* _HRT_VAR_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/version.h b/drivers/media/atomisp2/css2400/hrt/version.h
new file mode 100644
index 0000000..5e7dc29
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/version.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef HRT_VERSION_H
+#define HRT_VERSION_H
+#define HRT_VERSION_MAJOR 1
+#define HRT_VERSION_MINOR 4
+#define HRT_VERSION 1_4
+#endif
diff --git a/drivers/media/atomisp2/css2400/ia_css.h b/drivers/media/atomisp2/css2400/ia_css.h
new file mode 100644
index 0000000..bc9e397
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css.h
@@ -0,0 +1,1653 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+/*! \file */
+
+#ifndef _IA_CSS_H_
+#define _IA_CSS_H_
+
+/* Move to "platform_support.h" */
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#else
+#include <stdbool.h>
+#include <stdint.h>
+//#include <stdarg.h>
+#endif
+
+#include "ia_css_types.h"
+
+/** Enumeration of pipe modes. This mode can be used to create
+ *  an image pipe for this mode. These pipes can be combined
+ *  to configure and run streams on the ISP.
+ *
+ *  For example, one can create a preview and capture pipe to
+ *  create a continuous capture stream.
+ */
+enum ia_css_pipe_mode {
+	IA_CSS_PIPE_MODE_PREVIEW,      /**< Preview pipe */
+	IA_CSS_PIPE_MODE_VIDEO,        /**< Video pipe */
+	IA_CSS_PIPE_MODE_CAPTURE,      /**< Still capture pipe */
+	IA_CSS_PIPE_MODE_ACC,          /**< Accelerated pipe */
+};
+/* Temporary define  */
+#define IA_CSS_PIPE_MODE_NUM (IA_CSS_PIPE_MODE_ACC + 1)
+
+/** Input modes, these enumerate all supported input modes.
+ *  Note that not all ISP modes support all input modes.
+ */
+enum ia_css_input_mode {
+	IA_CSS_INPUT_MODE_SENSOR, /**< data from sensor */
+	IA_CSS_INPUT_MODE_FIFO,   /**< data from input-fifo */
+	IA_CSS_INPUT_MODE_TPG,    /**< data from test-pattern generator */
+	IA_CSS_INPUT_MODE_PRBS,   /**< data from pseudo-random bit stream */
+	IA_CSS_INPUT_MODE_MEMORY, /**< data from a frame in memory */
+	IA_CSS_INPUT_MODE_BUFFERED_SENSOR /**< data is sent through mipi buffer */ 
+};
+
+enum ia_css_irq_type {
+	IA_CSS_IRQ_TYPE_EDGE,  /**< Edge (level) sensitive interrupt */
+	IA_CSS_IRQ_TYPE_PULSE  /**< Pulse-shaped interrupt */
+};
+
+/** The ISP streaming input interface supports the following formats.
+ *  These match the corresponding MIPI formats.
+ */
+enum ia_css_stream_format {
+	IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY,    /**< 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV420_8,  /**< 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV420_10, /**< 10 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV422_8,  /**< UYVY..UVYV, 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV422_10, /**< UYVY..UVYV, 10 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_444,  /**< BGR..BGR, 4 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_555,  /**< BGR..BGR, 5 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_565,  /**< BGR..BGR, 5 bits B and R, 6 bits G */
+	IA_CSS_STREAM_FORMAT_RGB_666,  /**< BGR..BGR, 6 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_888,  /**< BGR..BGR, 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RAW_6,    /**< RAW data, 6 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_7,    /**< RAW data, 7 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_8,    /**< RAW data, 8 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_10,   /**< RAW data, 10 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_12,   /**< RAW data, 12 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_14,   /**< RAW data, 14 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_16,   /**< RAW data, 16 bits per pixel */
+	IA_CSS_STREAM_FORMAT_BINARY_8, /**< Binary byte stream. */
+};
+
+/** For RAW input, the bayer order needs to be specified separately. There
+ *  are 4 possible orders. The name is constructed by taking the first two
+ *  colors on the first line and the first two colors from the second line.
+ */
+enum ia_css_bayer_order {
+	IA_CSS_BAYER_ORDER_GRBG, /**< GRGRGRGRGR .. BGBGBGBGBG */
+	IA_CSS_BAYER_ORDER_RGGB, /**< RGRGRGRGRG .. GBGBGBGBGB */
+	IA_CSS_BAYER_ORDER_BGGR, /**< BGBGBGBGBG .. GRGRGRGRGR */
+	IA_CSS_BAYER_ORDER_GBRG, /**< GBGBGBGBGB .. RGRGRGRGRG */
+};
+#define IA_CSS_BAYER_ORDER_NUM (IA_CSS_BAYER_ORDER_GBRG + 1)
+
+/** Frame formats, some of these come from fourcc.org, others are
+   better explained by video4linux2. The NV11 seems to be described only
+   on MSDN pages, but even those seem to be gone now.
+   Frames can come in many forms, the main categories are RAW, RGB and YUV
+   (or YCbCr). The YUV frames come in 4 flavors, determined by how the U and V
+   values are subsampled:
+   1. YUV420: hor = 2, ver = 2
+   2. YUV411: hor = 4, ver = 1
+   3. YUV422: hor = 2, ver = 1
+   4. YUV444: hor = 1, ver = 1
+ */
+enum ia_css_frame_format {
+	IA_CSS_FRAME_FORMAT_NV11,       /**< 12 bit YUV 411, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV12,       /**< 12 bit YUV 420, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV16,       /**< 16 bit YUV 422, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV21,       /**< 12 bit YUV 420, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_NV61,       /**< 16 bit YUV 422, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_YV12,       /**< 12 bit YUV 420, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YV16,       /**< 16 bit YUV 422, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YUV420,     /**< 12 bit YUV 420, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV420_16,  /**< yuv420, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_YUV422,     /**< 16 bit YUV 422, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV422_16,  /**< yuv422, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_UYVY,       /**< 16 bit YUV 422, UYVY interleaved */
+	IA_CSS_FRAME_FORMAT_YUYV,       /**< 16 bit YUV 422, YUYV interleaved */
+	IA_CSS_FRAME_FORMAT_YUV444,     /**< 24 bit YUV 444, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV_LINE,   /**< Internal format, 2 y lines followed
+					     by a uvinterleaved line */
+	IA_CSS_FRAME_FORMAT_RAW,	/**< RAW, 1 plane */
+	IA_CSS_FRAME_FORMAT_RGB565,     /**< 16 bit RGB, 1 plane. Each 3 sub
+					     pixels are packed into one 16 bit
+					     value, 5 bits for R, 6 bits for G
+					     and 5 bits for B. */
+	IA_CSS_FRAME_FORMAT_PLANAR_RGB888, /**< 24 bit RGB, 3 planes */
+	IA_CSS_FRAME_FORMAT_RGBA888,	/**< 32 bit RGBA, 1 plane, A=Alpha
+					     (alpha is unused) */
+	IA_CSS_FRAME_FORMAT_QPLANE6, /**< Internal, for advanced ISP */
+	IA_CSS_FRAME_FORMAT_BINARY_8,	/**< byte stream, used for jpeg. For
+					     frames of this type, we set the
+					     height to 1 and the width to the
+					     number of allocated bytes. */
+	IA_CSS_FRAME_FORMAT_MIPI,	/**< MIPI frame, 1 plane */     
+};
+/* This one is hardcoded because the ISP firmware requires it known at
+ * compile time (preprocessor time in fact). */
+#define IA_CSS_FRAME_FORMAT_NUM 21
+
+/* We include acc_types.h here because it uses the frame_format enum above.
+ * This needs to be fixed, we do not want to have #include statements halfway
+ * a file.
+ */
+#include "ia_css_acc_types.h"
+
+enum ia_css_tpg_mode {
+	IA_CSS_TPG_MODE_RAMP,
+	IA_CSS_TPG_MODE_CHECKERBOARD,
+	IA_CSS_TPG_MODE_FRAME_BASED_COLOR
+};
+
+/** @brief Configure the test pattern generator.
+ *
+ * Configure the Test Pattern Generator, the way these values are used to
+ * generate the pattern can be seen in the HRT extension for the test pattern
+ * generator:
+ * devices/test_pat_gen/hrt/include/test_pat_gen.h: hrt_calc_tpg_data().
+ *
+ * This interface is deprecated, it is not portable -> move to input system API
+ *
+@code
+unsigned int test_pattern_value(unsigned int x, unsigned int y)
+{
+ unsigned int x_val, y_val;
+ if (x_delta > 0) (x_val = (x << x_delta) & x_mask;
+ else (x_val = (x >> -x_delta) & x_mask;
+ if (y_delta > 0) (y_val = (y << y_delta) & y_mask;
+ else (y_val = (y >> -y_delta) & x_mask;
+ return (x_val + y_val) & xy_mask;
+}
+@endcode
+ */
+struct ia_css_tpg_config {
+	enum ia_css_tpg_mode mode;
+	unsigned int         x_mask;
+	int                  x_delta;
+	unsigned int         y_mask;
+	int                  y_delta;
+	unsigned int         xy_mask;
+};
+
+/**
+ * PRBS configuration structure.
+ *
+ * Seed the for the Pseudo Random Bit Sequence.
+ *
+ * This interface is deprecated, it is not portable -> move to input system API
+ */
+struct ia_css_prbs_config {
+	int seed;
+};
+
+/** Generic resolution structure.
+ */
+struct ia_css_resolution {
+	unsigned int width;  /**< Width */
+	unsigned int height; /**< Height */
+};
+
+/** Enumeration of the physical input ports on the CSS hardware.
+ *  There are 2 MIPI CSI-2 ports, a 1-lane port and a 4-lane port.
+ */
+enum ia_css_csi2_port {
+	IA_CSS_CSI2_PORT_4LANE, /* 4-lane MIPI CSI-2 port */
+	IA_CSS_CSI2_PORT_1LANE, /* 1-lane MIPI CSI-2 port */
+	IA_CSS_CSI2_PORT_2LANE  /* 2-lane MIPI CSI-2 port */
+};
+
+/** The CSI2 interface supports 2 types of compression or can
+ *  be run without compression.
+ */
+enum ia_css_csi2_compression_type {
+	IA_CSS_CSI2_COMPRESSION_TYPE_NONE, /**< No compression */
+	IA_CSS_CSI2_COMPRESSION_TYPE_1,    /**< Compression scheme 1 */
+	IA_CSS_CSI2_COMPRESSION_TYPE_2     /**< Compression scheme 2 */
+};
+
+struct ia_css_csi2_compression {
+	enum ia_css_csi2_compression_type type;
+	/**< Compression used */
+	unsigned int                      compressed_bits_per_pixel;
+	/**< Compressed bits per pixel (only when compression is enabled) */
+	unsigned int                      uncompressed_bits_per_pixel;
+	/**< Uncompressed bits per pixel (only when compression is enabled) */
+};
+
+/** Input port structure.
+ */
+struct ia_css_input_port {
+	enum ia_css_csi2_port port; /**< Physical CSI-2 port */
+	unsigned int num_lanes; /**< Number of lanes used (4-lane port only) */
+	unsigned int timeout;   /**< Timeout value */
+	struct ia_css_csi2_compression compression; /**< Compression used */
+};
+
+/** Input stream description. This describes how input will flow into the
+ *  CSS. This is used to program the CSS hardware.
+ */
+struct ia_css_stream_config {
+	enum ia_css_input_mode    mode; /**< Input mode */
+	union {
+		struct ia_css_input_port  port; /**< Port, for sensor only. */
+		struct ia_css_tpg_config  tpg;  /**< TPG configuration */
+		struct ia_css_prbs_config prbs; /**< PRBS configuration */
+	} source; /**< Source of input data */
+	unsigned int              channel_id; /**< Channel on which input data
+						   will arrive */
+	struct ia_css_resolution  input_res; /**< Resolution of input data */
+	struct ia_css_resolution  effective_res; /**< Resolution of input data */
+	enum ia_css_stream_format format; /**< Format of input stream */
+	enum ia_css_bayer_order bayer_order; /**< Bayer order for RAW streams */
+	unsigned int sensor_binning_factor; /**< Binning factor used by sensor
+					         to produce image data. This is
+						 used for shading correction. */
+	bool two_pixels_per_clock; /**< Enable/disable 2 pixels per clock */
+	bool online; /**< offline will activate RAW copy on SP, use this for
+		          continuous capture. */
+	bool continuous; /**< Use SP copy feature to continuously capture frames
+			      to system memory and run pipes in offline mode */
+	int32_t flash_gpio_pin; /**< pin on which the flash is connected, -1 for no flash */
+};
+
+struct ia_css_stream;
+struct ia_css_pipe;
+
+/** Interrupt request type.
+ *  When the CSS hardware generates an interrupt, a function in this API
+ *  needs to be called to retrieve information about the interrupt.
+ *  This interrupt type is part of this information and indicates what
+ *  type of information the interrupt signals.
+ *
+ *  Note that one interrupt can carry multiple interrupt types. For
+ *  example: the online video ISP will generate only 2 interrupts, one to
+ *  signal that the statistics (3a and DIS) are ready and one to signal
+ *  that all output frames are done (output and viewfinder).
+ *
+ * DEPRECATED, this interface is not portable it should only define user
+ * (SW) interrupts
+ */
+enum ia_css_irq_info {
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR            = 1 << 0,
+	/**< the css receiver has encountered an error */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW    = 1 << 1,
+	/**< the FIFO in the csi receiver has overflown */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF              = 1 << 2,
+	/**< the css receiver received the start of frame */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF              = 1 << 3,
+	/**< the css receiver received the end of frame */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL              = 1 << 4,
+	/**< the css receiver received the start of line */
+	IA_CSS_IRQ_INFO_EVENTS_READY                  = 1 << 5,
+	/**< One or more events are available in the event queue */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL              = 1 << 6,
+	/**< the css receiver received the end of line */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED = 1 << 7,
+	/**< the css receiver received a change in side band signals */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0      = 1 << 8,
+	/**< generic short packets (0) */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1      = 1 << 9,
+	/**< generic short packets (1) */
+	IA_CSS_IRQ_INFO_IF_PRIM_ERROR                 = 1 << 10,
+	/**< the primary input formatter (A) has encountered an error */
+	IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR               = 1 << 11,
+	/**< the primary input formatter (B) has encountered an error */
+	IA_CSS_IRQ_INFO_IF_SEC_ERROR                  = 1 << 12,
+	/**< the secondary input formatter has encountered an error */
+	IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR           = 1 << 13,
+	/**< the stream-to-memory device has encountered an error */
+	IA_CSS_IRQ_INFO_SW_0                          = 1 << 14,
+	/**< software interrupt 0 */
+	IA_CSS_IRQ_INFO_SW_1                          = 1 << 15,
+	/**< software interrupt 1 */
+	IA_CSS_IRQ_INFO_SW_2                          = 1 << 16,
+	/**< software interrupt 2 */
+	IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY   = 1 << 17,
+	/**< ISP binary statistics are ready */
+	IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR            = 1 << 18,
+	/**< the input system in in error */
+	IA_CSS_IRQ_INFO_IF_ERROR                      = 1 << 19,
+	/**< the input formatter in in error */
+	IA_CSS_IRQ_INFO_DMA_ERROR                     = 1 << 20,
+	/**< the dma in in error */
+};
+
+/** CSS receiver error types. Whenever the CSS receiver has encountered
+ *  an error, this enumeration is used to indicate which errors have occurred.
+ *
+ *  Note that multiple error flags can be enabled at once and that this is in
+ *  fact common (whenever an error occurs, it usually results in multiple
+ *  errors).
+ *
+ * DEPRECATED: This interface is not portable, different systems have
+ * different receiver types, or possibly none in case of tests systems.
+ */
+enum ia_css_rx_irq_info {
+	IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN   = 1U << 0, /**< buffer overrun */
+	IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE = 1U << 1, /**< entering sleep mode */
+	IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1U << 2, /**< exited sleep mode */
+	IA_CSS_RX_IRQ_INFO_ECC_CORRECTED    = 1U << 3, /**< ECC corrected */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT          = 1U << 4,
+						/**< Start of transmission */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC     = 1U << 5, /**< SOT sync (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_CONTROL      = 1U << 6, /**< Control (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1U << 7, /**< Double ECC */
+	IA_CSS_RX_IRQ_INFO_ERR_CRC          = 1U << 8, /**< CRC error */
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1U << 9, /**< Unknown ID */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC   = 1U << 10,/**< Frame sync error */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA   = 1U << 11,/**< Frame data error */
+	IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1U << 12,/**< Timeout occurred */
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1U << 13,/**< Unknown escape seq. */
+	IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC    = 1U << 14,/**< Line Sync error */
+	IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT     = 1U << 15,
+};
+
+/** Errors, these values are used as the return value for most
+ *  functions in this API.
+ */
+enum ia_css_err {
+	IA_CSS_SUCCESS,
+	IA_CSS_ERR_INTERNAL_ERROR,
+	IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY,
+	IA_CSS_ERR_INVALID_ARGUMENTS,
+	IA_CSS_ERR_SYSTEM_NOT_IDLE,
+	IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER,
+	IA_CSS_ERR_QUEUE_IS_FULL,
+	IA_CSS_ERR_QUEUE_IS_EMPTY,
+	IA_CSS_ERR_RESOURCE_NOT_AVAILABLE,
+	IA_CSS_ERR_RESOURCE_LIST_TO_SMALL,
+	IA_CSS_ERR_RESOURCE_ITEMS_STILL_ALLOCATED,
+	IA_CSS_ERR_RESOURCE_EXHAUSTED,
+	IA_CSS_ERR_RESOURCE_ALREADY_ALLOCATED
+};
+
+/** Frame plane structure. This describes one plane in an image
+ *  frame buffer.
+ */
+struct ia_css_frame_plane {
+	unsigned int height; /**< height of a plane in lines */
+	unsigned int width;  /**< width of a line, in DMA elements, note that
+				  for RGB565 the three subpixels are stored in
+				  one element. For all other formats this is
+				   the number of subpixels per line. */
+	unsigned int stride; /**< stride of a line in bytes */
+	unsigned int offset; /**< offset in bytes to start of frame data.
+				  offset is wrt data field in ia_css_frame */
+};
+
+/** Binary "plane". This is used to story binary streams such as jpeg
+ *  images. This is not actually a real plane.
+ */
+struct ia_css_frame_binary_plane {
+	unsigned int		  size; /**< number of bytes in the stream */
+	struct ia_css_frame_plane data; /**< plane */
+};
+
+/** Container for planar YUV frames. This contains 3 planes.
+ */
+struct ia_css_frame_yuv_planes {
+	struct ia_css_frame_plane y; /**< Y plane */
+	struct ia_css_frame_plane u; /**< U plane */
+	struct ia_css_frame_plane v; /**< V plane */
+};
+
+/** Container for semi-planar YUV frames.
+  */
+struct ia_css_frame_nv_planes {
+	struct ia_css_frame_plane y;  /**< Y plane */
+	struct ia_css_frame_plane uv; /**< UV plane */
+};
+
+/** Container for planar RGB frames. Each color has its own plane.
+ */
+struct ia_css_frame_rgb_planes {
+	struct ia_css_frame_plane r; /**< Red plane */
+	struct ia_css_frame_plane g; /**< Green plane */
+	struct ia_css_frame_plane b; /**< Blue plane */
+};
+
+/** Container for 6-plane frames. These frames are used internally
+ *  in the advanced ISP only.
+ */
+struct ia_css_frame_plane6_planes {
+	struct ia_css_frame_plane r;	  /**< Red plane */
+	struct ia_css_frame_plane r_at_b; /**< Red at blue plane */
+	struct ia_css_frame_plane gr;	  /**< Red-green plane */
+	struct ia_css_frame_plane gb;	  /**< Blue-green plane */
+	struct ia_css_frame_plane b;	  /**< Blue plane */
+	struct ia_css_frame_plane b_at_r; /**< Blue at red plane */
+};
+
+/** Frame info struct. This describes the contents of an image frame buffer.
+  */
+struct ia_css_frame_info {
+	struct ia_css_resolution res; /**< Frame resolution (valid data) */
+	unsigned int padded_width; /**< stride of line in memory (in pixels) */
+	enum ia_css_frame_format format; /**< format of the frame data */
+	unsigned int raw_bit_depth; /**< number of valid bits per pixel,
+					 only valid for RAW bayer frames */
+	enum ia_css_bayer_order raw_bayer_order; /**< bayer order, only valid
+						      for RAW bayer frames */
+};
+
+/** 
+ *  Specifies the DVS loop delay in "frame periods"  
+ */
+enum ia_css_frame_delay {
+	IA_CSS_FRAME_DELAY_0, /**< Frame delay = 0 */
+	IA_CSS_FRAME_DELAY_1, /**< Frame delay = 1 */
+	IA_CSS_FRAME_DELAY_2  /**< Frame delay = 2 */
+};
+
+/* Temporary hack, hivecc fails to properly compile if this struct is
+ * included. */
+#ifndef __HIVECC__
+
+/**
+ * Pipe configuration structure.
+ */
+struct ia_css_pipe_config {
+	enum ia_css_pipe_mode mode;
+	/**< mode, indicates which mode the pipe should use. */
+	unsigned int isp_pipe_version;
+	/**< pipe version, indicates which imaging pipeline the pipe should use. */
+	struct ia_css_resolution bin_out_res;
+	/**< binning, used in continuous capture */
+	struct ia_css_resolution bayer_ds_out_res;
+	/**< bayer down scaling */
+	struct ia_css_resolution dvs_crop_out_res;
+	/**< dvs crop, video only, not in use yet. Use dvs_envelope below. */
+	struct ia_css_frame_info output_info;
+	/**< output of YUV scaling */
+	struct ia_css_frame_info vf_output_info;
+	/**< output of VF YUV scaling */
+	struct ia_css_fw_info *acc_extension;
+	/**< Pipeline extension accelerator */
+	struct ia_css_fw_info **acc_stages;
+	/**< Standalone accelerator stages */
+	uint32_t num_acc_stages;
+	/**< Number of standalone accelerator stages */
+	struct ia_css_capture_config default_capture_config;
+	/**< Default capture config for initial capture pipe configuration. */
+	struct ia_css_resolution dvs_envelope; /**< temporary */
+	enum ia_css_frame_delay dvs_frame_delay;
+	/**< indicates the DVS loop delay in frame periods */
+
+};
+#else
+struct ia_css_pipe_config;
+#endif
+
+enum ia_css_frame_flash_state {
+	IA_CSS_FRAME_FLASH_STATE_NONE,
+	IA_CSS_FRAME_FLASH_STATE_PARTIAL,
+	IA_CSS_FRAME_FLASH_STATE_FULL
+};
+
+/** Frame structure. This structure describes an image buffer or frame.
+ *  This is the main structure used for all input and output images.
+ */
+struct ia_css_frame {
+	struct ia_css_frame_info info; /**< info struct describing the frame */
+	ia_css_ptr   data;	       /**< pointer to start of image data */
+	unsigned int data_bytes;       /**< size of image data in bytes */
+	/* LA: move this to ia_css_buffer */
+	/*
+	 * -1 if data address is static during life time of pipeline
+	 * >=0 if data address can change per pipeline/frame iteration
+	 *     index to dynamic data: ia_css_frame_in, ia_css_frame_out
+	 *                            ia_css_frame_out_vf
+	 */
+	int dynamic_data_index;
+	enum ia_css_frame_flash_state flash_state;
+	unsigned int exp_id; /**< exposure id, only valid for continuous
+				capture cases */
+	unsigned int frame_nr;	/* frame number for detecting interlacing stream */
+	bool valid; /**< First video output frame is not valid */
+	bool contiguous; /**< memory is allocated physically contiguously */
+	union {
+		unsigned int	_initialisation_dummy;
+		struct ia_css_frame_plane raw;
+		struct ia_css_frame_plane rgb;
+		struct ia_css_frame_rgb_planes planar_rgb;
+		struct ia_css_frame_plane yuyv;
+		struct ia_css_frame_yuv_planes yuv;
+		struct ia_css_frame_nv_planes nv;
+		struct ia_css_frame_plane6_planes plane6;
+		struct ia_css_frame_binary_plane binary;
+	} planes; /**< frame planes, select the right one based on
+		       info.format */
+};
+
+/** CSS firmware package structure.
+ */
+struct ia_css_fw {
+	void	    *data;  /**< pointer to the firmware data */
+	unsigned int bytes; /**< length in bytes of firmware data */
+};
+
+/** Structure that holds 3A statistics in the ISP internal
+ * format. Use ia_css_get_3a_statistics() to translate
+ * this to the format used on the host (3A library).
+ * */
+struct ia_css_isp_3a_statistics {
+	union {
+		struct {
+			ia_css_ptr s3a_tbl;
+		} dmem;
+		struct {
+			ia_css_ptr s3a_tbl_hi;
+			ia_css_ptr s3a_tbl_lo;
+		} vmem;
+	} data;
+	struct {
+		ia_css_ptr rgby_tbl;
+	} data_hmem;
+};
+
+/** Structure that holds DVS statistics in the ISP internal
+ * format. Use ia_css_get_dvs_statistics() to translate
+ * this to the format used on the host (DVS engine).
+ * */
+struct ia_css_isp_dvs_statistics {
+	ia_css_ptr hor_proj;
+	ia_css_ptr ver_proj;
+};
+
+struct ia_css_properties {
+	int  gdc_coord_one;
+	bool l1_base_is_index; /**< Indicate whether the L1 page base
+				    is a page index or a byte address. */
+	enum ia_css_vamem_type vamem_type;
+};
+
+/** Enumeration of buffer types. Buffers can be queued and de-queued
+ *  to hand them over between IA and ISP.
+ */
+enum ia_css_buffer_type {
+	IA_CSS_BUFFER_TYPE_3A_STATISTICS,
+	IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
+	IA_CSS_BUFFER_TYPE_INPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_CUSTOM_INPUT,
+	IA_CSS_BUFFER_TYPE_CUSTOM_OUTPUT,
+	IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+};
+#define IA_CSS_BUFFER_TYPE_NUM (IA_CSS_BUFFER_TYPE_PARAMETER_SET + 1)
+
+/** Pipe info, this struct describes properties of a pipe after it's stream has
+ * been created.
+ */
+struct ia_css_pipe_info {
+	struct ia_css_frame_info output_info;
+	/**< Info about output resolution. This contains the stride which
+	     should be used for memory allocation. */
+	struct ia_css_frame_info vf_output_info;
+	/**< Info about viewfinder output resolution (optional). This contains
+	     the stride that should be used for memory allocation. */
+	struct ia_css_frame_info raw_output_info;
+	/**< Raw output resolution. This indicates the resolution of the
+	     RAW bayer output for pipes that support this. Currently, only the
+	     still capture pipes support this feature. When this resolution is
+	     smaller than the input resolution, cropping will be performed by
+	     the ISP. The first cropping that will be performed is on the upper
+	     left corner where we crop 8 lines and 8 columns to remove the
+	     pixels normally used to initialize the ISP filters.
+	     This is why the raw output resolution should normally be set to
+	     the input resolution - 8x8. */
+	struct ia_css_grid_info  grid_info;
+	/**< After register an image pipe, this field will contain the grid
+	     info for 3A and DVS. */
+};
+
+/** Stream info, this struct describes properties of a stream after it has been
+ *  created.
+ */
+struct ia_css_stream_info {
+	struct ia_css_resolution raw_info;
+	/**< Info about raw buffer resolution. Mainly for continuous capture */
+	struct ia_css_resolution effective_info;
+	/**< Info about effective input buffer resolution. */
+};
+
+/** Memory allocation attributes, for use in ia_css_css_mem_env. */
+enum ia_css_mem_attr {
+	IA_CSS_MEM_ATTR_CACHED = 1 << 0,
+	IA_CSS_MEM_ATTR_ZEROED = 1 << 1,
+	IA_CSS_MEM_ATTR_PAGEALIGN = 1 << 2,
+	IA_CSS_MEM_ATTR_CONTIGUOUS = 1 << 3,
+};
+
+struct ia_css_acc_fw;
+
+/** Environment with function pointers for local IA memory allocation.
+ *  This provides the CSS code with environment specific functionality
+ *  for memory allocation of small local buffers such as local data structures.
+ *  This is never expected to allocate more than one page of memory (4K bytes).
+ */
+struct ia_css_cpu_mem_env {
+	void *(*alloc)(size_t bytes, bool zero_mem);
+	/**< Allocation function with boolean argument to indicate whether
+	     the allocated memory should be zeroed out or not. */
+	void (*free)(void *ptr); /**< Corresponding free function. */
+	void (*flush) (struct ia_css_acc_fw *fw);
+	/**< Flush function to flush the cache for given accelerator. */
+};
+
+/** Environment with function pointers for allocation of memory for the CSS.
+ *  The CSS uses its own MMU which has its own set of page tables. These
+ *  functions are expected to use and/or update those page tables.
+ *  This type of memory allocation is expected to be used for large buffers
+ *  for images and statistics.
+ *  ISP pointers are always 32 bits whereas IA pointer widths will depend
+ *  on the platform.
+ *  Attributes can be a combination (OR'ed) of ia_css_mem_attr values.
+ */
+struct ia_css_css_mem_env {
+	ia_css_ptr (*alloc)(size_t bytes, uint32_t attributes);
+	/**< Allocate memory, cached or uncached, zeroed ut or not. */
+	void     (*free)(ia_css_ptr ptr);
+	/**< Free ISP shared memory. */
+	int      (*load)(ia_css_ptr ptr, void *data, size_t bytes);
+	/**< Load from ISP shared memory. This function is necessary because
+	     the IA MMU does not share page tables with the ISP MMU. This means
+	     that the IA needs to do the virtual-to-physical address
+	     translation in software. This function performs this translation.*/
+	int      (*store)(ia_css_ptr ptr, const void *data, size_t bytes);
+	/**< Same as the above load function but then to write data into ISP
+	     shared memory. */
+	int      (*set)(ia_css_ptr ptr, int c, size_t bytes);
+	/**< Set an ISP shared memory region to a particular value. Each byte
+	     in this region will be set to this value. In most cases this is
+	     used to zero-out memory sections in which case the argument c
+	     would have the value zero. */
+	ia_css_ptr (*mmap)(const void *ptr, const size_t size,
+			   uint16_t attribute, void *context);
+	/**< Map an pre-allocated memory region to an address. */
+};
+
+/** Environment with function pointers to access the CSS hardware. This includes
+ *  registers and local memories.
+ */
+struct ia_css_hw_access_env {
+	void     (*store_8)(hrt_address addr, uint8_t data);
+	/**< Store an 8 bit value into an address in the CSS HW address space.
+	     The address must be an 8 bit aligned address. */
+	void     (*store_16)(hrt_address addr, uint16_t data);
+	/**< Store a 16 bit value into an address in the CSS HW address space.
+	     The address must be a 16 bit aligned address. */
+	void     (*store_32)(hrt_address addr, uint32_t data);
+	/**< Store a 32 bit value into an address in the CSS HW address space.
+	     The address must be a 32 bit aligned address. */
+	uint8_t (*load_8)(hrt_address addr);
+	/**< Load an 8 bit value from an address in the CSS HW address
+	     space. The address must be an 8 bit aligned address. */
+	uint16_t (*load_16)(hrt_address addr);
+	/**< Load a 16 bit value from an address in the CSS HW address
+	     space. The address must be a 16 bit aligned address. */
+	uint32_t (*load_32)(hrt_address addr);
+	/**< Load a 32 bit value from an address in the CSS HW address
+	     space. The address must be a 32 bit aligned address. */
+	void     (*store)(hrt_address addr, const void *data, uint32_t bytes);
+	/**< Store a number of bytes into a byte-aligned address in the CSS HW
+	     address space. */
+	void     (*load)(hrt_address addr, void *data, uint32_t bytes);
+	/**< Load a number of bytes from a byte-aligned address in the CSS HW
+	     address space. */
+};
+
+/** Environment with function pointers to print error and debug messages.
+ */
+struct ia_css_print_env {
+	int (*debug_print)(const char *fmt, va_list args);
+	/**< Print a debug message. */
+	int (*error_print)(const char *fmt, va_list args);
+	/**< Print an error message.*/
+};
+
+/** Environment structure. This includes function pointers to access several
+ *  features provided by the environment in which the CSS API is used.
+ *  This is used to run the camera IP in multiple platforms such as Linux,
+ *  Windows and several simulation environments.
+ */
+struct ia_css_env {
+	struct ia_css_cpu_mem_env   cpu_mem_env;   /**< local malloc and free. */
+	struct ia_css_css_mem_env   css_mem_env;   /**< CSS/ISP buffer alloc/free */
+	struct ia_css_hw_access_env hw_access_env; /**< CSS HW access functions */
+	struct ia_css_print_env     print_env;     /**< Message printing env. */
+};
+
+/** Buffer structure. This is a container structure that enables content
+ *  independent buffer queues and access functions.
+ */
+struct ia_css_buffer {
+	enum ia_css_buffer_type type; /**< Buffer type. */
+	union {
+		struct ia_css_isp_3a_statistics  *stats_3a; /**< 3A statistics & optionally RGBY statistics. */
+		struct ia_css_isp_dvs_statistics *stats_dvs;/**< DVS statistics. */
+		struct ia_css_frame	         *frame;    /**< Frame buffer. */
+		struct ia_css_acc_param          *custom_data; /**< Custom buffer. */
+	} data; /**< Buffer data pointer. */
+};
+
+/** The event type, distinguishes the kind of events that
+ * can are generated by the CSS system.
+ */
+enum ia_css_event_type {
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE    = 1 << 0,
+	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE = 1 << 1,
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE   = 1 << 2,
+	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE  = 1 << 3,
+	IA_CSS_EVENT_TYPE_PIPELINE_DONE        = 1 << 4,
+	IA_CSS_EVENT_TYPE_FRAME_TAGGED	       = 1 << 5, /**< Frame tagged. */
+	IA_CSS_EVENT_TYPE_PORT_EOF	       = 1 << 6, /**< End Of Frame event, sent when in buffered sensor mode.  MUST BE LAST */
+};
+#define IA_CSS_EVENT_TYPE_NUM (IA_CSS_EVENT_TYPE_PORT_EOF + 1)
+#define IA_CSS_EVENT_TYPE_NONE 0
+/* IA_CSS_EVENT_TYPE_ALL is a mask for alle events except IA_CSS_EVENT_TYPE_PORT_EOF
+ * we create it by sbutracting 1 from IA_CSS_EVENT_TYPE_PORT_EOF
+ * alternate implementation could be or-ing of all the events.
+ * (IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE | IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE | ... | IA_CSS_EVENT_TYPE_FRAME_TAGGED)
+ */
+#define IA_CSS_EVENT_TYPE_ALL  (IA_CSS_EVENT_TYPE_PORT_EOF - 1)
+
+/** The event struct, container for the event type and its related values.
+ * Depending on the event type, either pipe or port will be filled.
+ * Pipeline related events (like buffer/frame events) will return a valid and filled pipe handle.
+ * For non pipeline related events (but i.e. stream specific, like EOF event), the port will be 
+ * filled.
+ */
+struct ia_css_event {
+	struct ia_css_pipe    *pipe;
+	enum ia_css_event_type type;
+	uint8_t                port; /**< Port number for EOF event (not valid/filled for other events). */
+	uint8_t                exp_id; /**< Exposure id for EOF/TAGGED_FRAME event (not valid for other events). */
+};
+
+/** Interrupt info structure. This structure contains information about an
+ *  interrupt. This needs to be used after an interrupt is received on the IA
+ *  to perform the correct action.
+ */
+struct ia_css_irq {
+	enum ia_css_irq_info type; /**< Interrupt type. */
+	unsigned int sw_irq_0_val; /**< In case of SW interrupt 0, value. */
+	unsigned int sw_irq_1_val; /**< In case of SW interrupt 1, value. */
+	unsigned int sw_irq_2_val; /**< In case of SW interrupt 2, value. */
+	struct ia_css_pipe *pipe;
+	/**< The image pipe that generated the interrupt. */
+};
+
+/* ===== GENERIC ===== */
+
+/** @brief Initialize the CSS API.
+ * @param[in]	env		Environment, provides functions to access the
+ *				environment in which the CSS code runs. This is
+ *				used for host side memory access and message
+ *				printing.
+ * @param[in]	fw		Firmware package containing the firmware for all
+ *				predefined ISP binaries.
+ * @param[in]	l1_base         Base index (isp2400)
+ *                              of the L1 page table. This is a physical
+ *                              address or index.
+ * @return			Returns IA_CSS_ERR_INTERNAL_ERROR in case of any
+ *				errors and IA_CSS_SUCCESS otherwise.
+ *
+ * This function initializes the API which includes allocating and initializing
+ * internal data structures. This also interprets the firmware package. All
+ * contents of this firmware package are copied into local data structures, so
+ * this pointer could be freed after this function completes.
+ */
+enum ia_css_err ia_css_init(
+	const struct ia_css_env *env,
+	const struct ia_css_fw  *fw,
+	uint32_t                 l1_base,
+	enum ia_css_irq_type     irq_type);
+
+/** @brief Un-initialize the CSS API.
+ *
+ * This function deallocates all memory that has been allocated by the CSS
+ * API. After this function is called, no other CSS functions should be called
+ * with the exception of ia_css_init which will re-initialize the CSS code.
+ *
+ * @return None
+ */
+void
+ia_css_uninit(void);
+
+/** @brief Suspend CSS API for power down.
+ *
+ * This function prepares the CSS API for a power down of the CSS hardware.
+ * This will make sure the hardware is idle. After this function is called,
+ * always call ia_css_resume before calling any other CSS functions.
+ * This assumes that all buffers allocated in DDR will remain alive during
+ * power down. If this is not the case, use ia_css_unit() followed by
+ * ia_css_init() at power up.
+ */
+void
+ia_css_suspend(void);
+
+/** @brief Resume CSS API from power down
+ *
+ * After a power cycle, this function will bring the CSS API back into
+ * a state where it can be started. This will re-initialize the hardware.
+ * Call this function only after ia_css_suspend() has been called.
+ */
+void
+ia_css_resume(void);
+
+/** @brief Get hardware properties
+ *
+ * This function returns a number of hardware properties.
+ */
+void
+ia_css_get_properties(struct ia_css_properties *properties);
+
+/** @brief Obtain interrupt information.
+ *
+ * @param[out] info	Pointer to the interrupt info. The interrupt
+ *			information wil be written to this info.
+ * @return		If an error is encountered during the interrupt info
+ *			and no interrupt could be translated successfully, this
+ *			will return IA_CSS_INTERNAL_ERROR. Otherwise
+ *			IA_CSS_SUCCESS.
+ *
+ * This function is expected to be executed after an interrupt has been sent
+ * to the IA from the CSS. This function returns information about the interrupt
+ * which is needed by the IA code to properly handle the interrupt. This
+ * information includes the image pipe, buffer type etc.
+ */
+enum ia_css_err
+ia_css_irq_translate(unsigned int *info);
+
+/** @brief Get CSI receiver error info.
+ *
+ * @param[out] irq_bits	Pointer to the interrupt bits. The interrupt
+ *			bits will be written this info.
+ *			This will be the error bits that are enabled in the CSI
+ *			receiver error register.
+ * This function should be used whenever a CSI receiver error interrupt is
+ * generated. It provides the detailed information (bits) on the exact error
+ * that occurred.
+ */
+void
+ia_css_rx_get_irq_info(unsigned int *irq_bits);
+
+/** @brief Clear CSI receiver error info.
+ *
+ * @param[in] irq_bits	The bits that should be cleared from the CSI receiver
+ *			interrupt bits register.
+ *
+ * This function should be called after ia_css_rx_get_irq_info has been called
+ * and the error bits have been interpreted. It is advised to use the return
+ * value of that function as the argument to this function to make sure no new
+ * error bits get overwritten.
+ */
+void
+ia_css_rx_clear_irq_info(unsigned int irq_bits);
+
+/** @brief Enable or disable specific interrupts.
+ *
+ * @param[in] type	The interrupt type that will be enabled/disabled.
+ * @param[in] enable	enable or disable.
+ * @return		Returns IA_CSS_INTERNAL_ERROR if this interrupt
+ *			type cannot be enabled/disabled which is true for
+ *			CSS internal interrupts. Otherwise returns
+ *			IA_CSS_SUCCESS.
+ */
+enum ia_css_err
+ia_css_irq_enable(enum ia_css_irq_info type, bool enable);
+
+/** @brief Invalidate the MMU internal cache.
+ *
+ * This function triggers an invalidation of the translate-look-aside
+ * buffer (TLB) that's inside the CSS MMU. This function should be called
+ * every time the page tables used by the MMU change.
+ */
+void
+ia_css_mmu_invalidate_cache(void);
+
+/**
+ * create the internal structures and fill in the configuration data
+ */
+void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config);
+
+enum ia_css_err
+ia_css_pipe_create(const struct ia_css_pipe_config *config,
+		   struct ia_css_pipe **pipe);
+
+enum ia_css_err
+ia_css_pipe_destroy(struct ia_css_pipe *pipe);
+
+enum ia_css_err
+ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+		     struct ia_css_pipe_info *pipe_info);
+
+void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config);
+
+/**
+ * create the internal structures and fill in the configuration data and pipes
+ */
+enum ia_css_err
+ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+					 int num_pipes,
+					 struct ia_css_pipe *pipes[],
+					 struct ia_css_stream **stream);
+
+enum ia_css_err
+ia_css_stream_destroy(struct ia_css_stream *stream);
+
+enum ia_css_err
+ia_css_stream_get_info(const struct ia_css_stream *stream,
+		       struct ia_css_stream_info *stream_info);
+
+enum ia_css_err
+ia_css_stream_load(struct ia_css_stream *stream);
+
+/** @brief Starts the stream.
+ *
+ * The dynamic data in
+ * the buffers are not used and need to be queued with a seperate call
+ * to ia_css_pipe_enqueue_buffer.
+ * NOTE: this function will only send start event to corresponding
+ * thread and will not start SP any more.
+ */
+enum ia_css_err
+ia_css_stream_start(struct ia_css_stream *stream);
+
+/** @brief Stop the stream.
+ *
+ * NOTE: this function will send stop event to pipes belong to this
+ * stream but will not terminate threads.
+ */
+
+enum ia_css_err
+ia_css_stream_stop(struct ia_css_stream *stream);
+
+bool
+ia_css_stream_has_stopped(struct ia_css_stream *stream);
+
+enum ia_css_err
+ia_css_stream_unload(struct ia_css_stream *stream);
+
+enum ia_css_stream_format
+ia_css_stream_get_format(const struct ia_css_stream *stream);
+
+bool
+ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream);
+
+/** @brief Queue a buffer for an image pipe.
+ *
+ * @param[in] pipe	The pipe that will own the buffer.
+ * @param[in] buffer	Pointer to the buffer.
+ *                      Note that the caller remains owner of the buffer
+ *                      structure. Only the data pointer within it will
+ *                      be passed into the internal queues.
+ * @return		IA_CSS_INTERNAL_ERROR in case of unexpected errors,
+ *			IA_CSS_SUCCESS otherwise.
+ *
+ * This function adds a buffer (which has a certain buffer type) to the queue
+ * for this type. This queue is owned by the image pipe. After this function
+ * completes successfully, the buffer is now owned by the image pipe and should
+ * no longer be accessed by any other code until it gets dequeued. The image
+ * pipe will dequeue buffers from this queue, use them and return them to the
+ * host code via an interrupt. Buffers will be consumed in the same order they
+ * get queued, but may be returned to the host out of order.
+ */
+enum ia_css_err
+ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			   const struct ia_css_buffer *buffer);
+
+/** @brief Dequeue a buffer from an image pipe.
+ *
+ * @param[in]    pipe	The pipeline that the buffer queue belongs to.
+ * @param[inout] buffer The buffer is used to lookup the type which determines
+ *                      which internal queue to use.
+ *                      The resulting buffer pointer is written into the dta
+ *                      field.
+ * @return		IA_CSS_ERR_NO_BUFFER if the queue is empty or
+ *			IA_CSS_SUCCESS otherwise.
+ *
+ * This function dequeues a buffer from a buffer queue. The queue is indicated
+ * by the buffer type argument. This function can be called after an interrupt
+ * has been generated that signalled that a new buffer was available and can
+ * be used in a polling-like situation where the NO_BUFFER return value is used
+ * to determine whether a buffer was available or not.
+ */
+enum ia_css_err
+ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			   struct ia_css_buffer *buffer);
+
+/** @brief Dequeue an event from the CSS system. An event consists of pipe
+ * and event_id.
+ *
+ * @param[out]	event   Pointer to the event struct which will be filled by
+ *                      this function if an event is available.
+ * @return		IA_CSS_ERR_QUEUE_IS_EMPTY if no events are
+ *			available or
+ *			IA_CSS_SUCCESS otherwise.
+ *
+ * This function dequeues an event from an event queue. The queue is inbetween
+ * the Host (i.e. the Atom processosr) and the CSS system. This function can be
+ * called after an interrupt has been generated that signalled that a new event
+ * was available and can be used in a polling-like situation where the NO_EVENT
+ * return value is used to determine whether an event was available or not.
+ */
+enum ia_css_err
+ia_css_dequeue_event(struct ia_css_event *event);
+
+/** @brief Controls when the Event generator raises an IRQ to the Host.
+ *
+ * @param[in]	pipe	The pipe.
+ * @param[in]	or_mask	Binary or of enum ia_css_event_irq_mask_type. Each pipe
+ 			related event that is part of this mask will directly
+ 			raise an IRQ to	the Host when the event occurs in the
+ 			CSS.
+ * @param[in]	and_mask Binary or of enum ia_css_event_irq_mask_type. An event
+			IRQ for the Host is only raised after all pipe related
+			events have occurred at least once for all the active
+			pipes. Events are remembered and don't need to occure
+			at the same moment in time. There is no control over
+			the order of these events. Once an IRQ has been raised
+			all remembered events are reset.
+ * @return		IA_CSS_SUCCESS.
+ *
+ Controls when the Event generator in the CSS raises an IRQ to the Host.
+ The main purpose of this function is to reduce the amount of interrupts
+ between the CSS and the Host. This will help saving power as it wakes up the
+ Host less often. In case both or_mask and and_mask are
+ IA_CSS_EVENT_TYPE_NONE for all pipes, no event IRQ's will be raised. An
+ exception holds for IA_CSS_EVENT_TYPE_PORT_EOF, for this event an IRQ is always
+ raised.
+ Note that events are still queued and the Host can poll for them. The
+ or_mask and and_mask may be be active at the same time\n
+ \n
+ Default values, for all pipe id's, after ia_css_init:\n
+ or_mask = IA_CSS_EVENT_TYPE_ALL\n
+ and_mask = IA_CSS_EVENT_TYPE_NONE\n
+ \n
+ Examples\n
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe,
+ IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE |
+ IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE ,
+ IA_CSS_EVENT_TYPE_NONE);
+ \endcode
+ The event generator will only raise an interrupt to the Host when there are
+ 3A or DIS statistics available from the preview pipe. It will not generate
+ an interrupt for any other event of the preview pipe e.g when there is an
+ output frame available.
+
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe_preview,
+	IA_CSS_EVENT_TYPE_NONE,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE |
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE );
+
+ ia_css_pipe_set_irq_mask(h_pipe_capture,
+	IA_CSS_EVENT_TYPE_NONE,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE );
+ \endcode
+ The event generator will only raise an interrupt to the Host when there is
+ both a frame done and 3A event available from the preview pipe AND when there
+ is a frame done available from the capture pipe. Note that these events
+ may occur at different moments in time. Also the order of the events is not
+ relevant.
+
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe_preview,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,
+	IA_CSS_EVENT_TYPE_ALL );
+
+ ia_css_pipe_set_irq_mask(h_pipe_capture,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,
+	IA_CSS_EVENT_TYPE_ALL );
+ \endcode
+ The event generator will only raise an interrupt to the Host when there is an
+ output frame from the preview pipe OR an output frame from the capture pipe.
+ All other events (3A, VF output, pipeline done) will not raise an interrupt
+ to the Host. These events are not lost but always stored in the event queue.
+ */
+enum ia_css_err
+ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
+			 unsigned int or_mask,
+			 unsigned int and_mask);
+
+/** @brief Reads the current event IRQ mask from the CSS.
+ *
+ * @param[in]	The pipe.
+ * @param[out]	or_mask	Current or_mask. The bits in this mask are a binary or
+		of enum ia_css_event_irq_mask_type. Pointer may be NULL.
+ * @param[out]	and_mask Current and_mask.The bits in this mask are a binary or
+		of enum ia_css_event_irq_mask_type. Pointer may be NULL.
+ * @return	IA_CSS_SUCCESS.
+ *
+ Reads the current event IRQ mask from the CSS. Reading returns the actual
+ values as used by the SP and not any mirrored values stored at the Host.\n
+\n
+Precondition:\n
+SP must be running.\n
+
+*/
+enum ia_css_err
+ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			  unsigned int *or_mask,
+			  unsigned int *and_mask);
+
+/* ===== FRAMES ===== */
+
+/** @brief Fill a frame with zeros
+ *
+ * @param	frame		The frame.
+ *
+ * Fill a frame with pixel values of zero
+ */
+void ia_css_frame_zero(struct ia_css_frame *frame);
+
+/** @brief Allocate a CSS frame structure
+ *
+ * @param	frame		The allocated frame.
+ * @param	width		The width (in pixels) of the frame.
+ * @param	height		The height (in lines) of the frame.
+ * @param	format		The frame format.
+ * @param	stride		The padded stride, in pixels.
+ * @param	raw_bit_depth	The raw bit depth, in bits.
+ * @return			The error code.
+ *
+ * Allocate a CSS frame structure. The memory for the frame data will be
+ * allocated in the CSS address space.
+ */
+enum ia_css_err
+ia_css_frame_allocate(struct ia_css_frame **frame,
+		      unsigned int width,
+		      unsigned int height,
+		      enum ia_css_frame_format format,
+		      unsigned int stride,
+		      unsigned int raw_bit_depth);
+
+/** @brief Allocate a CSS frame structure using a frame info structure.
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	info	The frame info structure.
+ * @return		The error code.
+ *
+ * Allocate a frame using the resolution and format from a frame info struct.
+ * This is a convenience function, implemented on top of
+ * ia_css_frame_allocate().
+ */
+enum ia_css_err
+ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
+				const struct ia_css_frame_info *info);
+/** @brief Free a CSS frame structure.
+ *
+ * @param[in]	frame	Pointer to the frame.
+ *
+ * Free a CSS frame structure. This will free both the frame structure
+ * and the pixel data pointer contained within the frame structure.
+ */
+void
+ia_css_frame_free(struct ia_css_frame *frame);
+
+/* ===== FPGA display frames ====== */
+
+/** @brief Allocate a contiguous CSS frame structure
+ *
+ * @param	frame		The allocated frame.
+ * @param	width		The width (in pixels) of the frame.
+ * @param	height		The height (in lines) of the frame.
+ * @param	format		The frame format.
+ * @param	stride		The padded stride, in pixels.
+ * @param	raw_bit_depth	The raw bit depth, in bits.
+ * @return			The error code.
+ *
+ * Contiguous frame allocation, only for FPGA display driver which needs
+ * physically contiguous memory.
+ * Deprecated.
+ */
+enum ia_css_err
+ia_css_frame_allocate_contiguous(struct ia_css_frame **frame,
+				 unsigned int width,
+				 unsigned int height,
+				 enum ia_css_frame_format format,
+				 unsigned int stride,
+				 unsigned int raw_bit_depth);
+
+/** @brief Allocate a contiguous CSS frame from a frame info structure.
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	info	The frame info structure.
+ * @return		The error code.
+ *
+ * Allocate a frame using the resolution and format from a frame info struct.
+ * This is a convenience function, implemented on top of
+ * ia_css_frame_allocate_contiguous().
+ * Only for FPGA display driver which needs physically contiguous memory.
+ * Deprecated.
+ */
+enum ia_css_err
+ia_css_frame_allocate_contiguous_from_info(struct ia_css_frame **frame,
+					  const struct ia_css_frame_info *info);
+
+/** @brief Map an existing frame data pointer to a CSS frame.
+ *
+ * @param[in]	info		The frame info.
+ * @param[in]	data		Pointer to the allocated frame data.
+ * @param[in]	attribute	Attributes to be passed to mmgr_mmap.
+ * @param[in]	context		Pointer to the a context to be passed to mmgr_mmap.
+ * @return			The allocated frame structure.
+ *
+ * This function maps a pre-allocated pointer into a CSS frame. This can be
+ * used when an upper software layer is responsible for allocating the frame
+ * data and it wants to share that frame pointer with the CSS code.
+ * This function will fill the CSS frame structure just like
+ * ia_css_frame_allocate() does, but instead of allocating the memory, it will
+ * map the pre-allocated memory into the CSS address space.
+ */
+enum ia_css_err
+ia_css_frame_map(struct ia_css_frame **frame,
+                 const struct ia_css_frame_info *info,
+                 const void *data,
+                 uint16_t attribute,
+                 void *context);
+
+/** @brief Unmap a CSS frame structure.
+ *
+ * @param[in]	frame	Pointer to the CSS frame.
+ *
+ * This function unmaps the frame data pointer within a CSS frame and
+ * then frees the CSS frame structure. Use this for frame pointers created
+ * using ia_css_frame_map().
+ */
+void
+ia_css_frame_unmap(struct ia_css_frame *frame);
+
+/** @brief Return max nr of continuous RAW frames.
+ *
+ * @return	Max nr of continuous RAW frames.
+ *
+ * Return the maximum nr of continuous RAW frames the system can support.
+ */
+enum ia_css_err
+ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
+
+/** @brief Set nr of continuous RAW frames to use.
+ *
+ * @param 	num_frames	Number of frames.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ * Set the number of continuous frames to use during continuous modes.
+ */
+enum ia_css_err
+ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth);
+
+/** @brief Get nr of continuous RAW frames to use.
+ *
+ * @return 	Number of frames to use.
+
+ *
+ * Get the currently set number of continuous frames
+ * to use during continuous modes.
+ */
+enum ia_css_err
+ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
+
+/* ===== CAPTURE ===== */
+
+/** @brief Configure the continuous capture
+ *
+ * @param	num_captures	The number of RAW frames to be processed to
+ *                              YUV. Setting this to -1 will make continuous
+ *                              capture run until it is stopped.
+ *                              This number will also be used to allocate RAW
+ *                              buffers. To allow the viewfinder to also
+ *                              keep operating, 2 extra buffers will always be
+ *                              allocated.
+ *                              If the offset is negative and the skip setting
+ *                              is greater than 0, additional buffers may be
+ *                              needed.
+ * @param	skip		Skip N frames in between captures. This can be
+ *                              used to select a slower capture frame rate than
+ *                              the sensor output frame rate.
+ * @param	offset		Start the RAW-to-YUV processing at RAW buffer
+ *                              with this offset. This allows the user to
+ *                              process RAW frames that were captured in the
+ *                              past or future.
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ *  For example, to capture the current frame plus the 2 previous
+ *  frames and 2 subsequent frames, you would call
+ *  ia_css_stream_capture(5, 0, -2).
+ */
+enum ia_css_err
+ia_css_stream_capture(struct ia_css_stream *stream,
+			int num_captures,
+			unsigned int skip,
+			int offset);
+
+/** @brief Specify which raw frame to tag based on exp_id found in frame info
+ *
+ * @param	exp_id	The exposure id of the raw frame to tag.
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function allows the user to tag a raw frame based on the exposure id
+ * found in the viewfinder frames' frame info.
+ */
+enum ia_css_err
+ia_css_stream_capture_frame(struct ia_css_stream *stream,
+			unsigned int exp_id);
+
+/* ===== VIDEO ===== */
+
+/** @brief Send streaming data into the css input FIFO
+ *
+ * @param	data	Pointer to the pixels to be send.
+ * @param	width	Width of the input frame.
+ * @param	height	Height of the input frame.
+ *
+ * Send streaming data into the css input FIFO. This is for testing purposes
+ * only. This uses the channel ID and input format as set by the user with
+ * the regular functions for this.
+ * This function blocks until the entire frame has been written into the
+ * input FIFO.
+ */
+void
+ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+			       const unsigned short *data,
+			       unsigned int width,
+			       unsigned int height);
+
+/*
+ * For higher flexibility the ia_css_stream_send_input_frame is replaced by
+ * three seperate functions:
+ * 1) ia_css_stream_start_input_frame
+ * 2) ia_css_stream_send_input_line
+ * 3) ia_css_stream_end_input_frame
+ * In this way it is possible to stream multiple frames on different
+ * channel ID's on a line basis. It will be possible to simulate
+ * line-interleaved Stereo 3D muxed on 1 mipi port.
+ * These 3 functions are for testing purpose only and can be used in
+ * conjunction with ia_css_stream_send_input_frame
+ */
+
+/** @brief Start an input frame on the CSS input FIFO.
+ *
+ * @param[in]	channel_id		The channel id.
+ * @param[in]	input_format		The input format.
+ * @param[in]	two_pixels_per_clock	Use 2 pixels per clock.
+ *
+ * Starts the streaming to mipi frame by sending SoF for channel channel_id.
+ * It will use the input_format and two_pixels_per_clock as provided by
+ * the user.
+ * For the "correct" use-case, input_format and two_pixels_per_clock must match
+ * with the values as set by the user with the regular functions.
+ * To simulate an error, the user can provide "incorrect" values for
+ * input_format and/or two_pixels_per_clock.
+ */
+void
+ia_css_stream_start_input_frame(const struct ia_css_stream *stream);
+
+/** @brief Send a line of input data into the CSS input FIFO.
+ *
+ * @param[in]	channel_id		The channel id.
+ * @param[in]	data	Array of the first line of image data.
+ * @param	width	The width (in pixels) of the first line.
+ * @param[in]	data2	Array of the second line of image data.
+ * @param	width2	The width (in pixels) of the second line.
+ *
+ * Sends 1 frame line. Start with SoL followed by width bytes of data, followed
+ * by width2 bytes of data2 and followed by and EoL
+ * It will use the input_format and two_pixels_per_clock settings as provided
+ * with the ia_css_stream_start_input_frame function call.
+ *
+ * This function blocks until the entire line has been written into the
+ * input FIFO.
+ */
+void
+ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+			      const unsigned short *data,
+			      unsigned int width,
+			      const unsigned short *data2,
+			      unsigned int width2);
+
+
+/** @brief End an input frame on the CSS input FIFO.
+ *
+ * @param[in]	channel_id	The channel id.
+ *
+ * Send the end-of-frame signal into the CSS input FIFO.
+ */
+void
+ia_css_stream_end_input_frame(const struct ia_css_stream *stream);
+
+/** @brief Test whether the ISP has started.
+ *
+ * @return	The ISP has started.
+ *
+ * Temporary function to poll whether the ISP has been started. Once it has,
+ * the sensor can also be started. */
+bool
+ia_css_isp_has_started(void);
+
+/** @brief Test whether the SP has initialized.
+ *
+ * @return	The SP has initialized.
+ *
+ * Temporary function to poll whether the SP has been initilized. Once it has,
+ * we can enqueue buffers. */
+bool
+ia_css_sp_has_initialized(void);
+
+/** @brief Test whether the SP has terminated.
+ *
+ * @return	The SP has terminated.
+ *
+ * Temporary function to poll whether the SP has been terminated. Once it has,
+ * we can switch mode. */
+bool
+ia_css_sp_has_terminated(void);
+
+/** @brief send a request flash command to SP
+ *
+ * Driver needs to call this function to send a flash request command
+ * to SP, SP will be responsible for switching on/off the flash at proper
+ * time. Due to the SP multi-threading environment, this request may have
+ * one-frame delay, the driver needs to check the flashed flag in frame info
+ * to determine which frame is being flashed.
+ */
+void
+ia_css_stream_request_flash(struct ia_css_stream *stream);
+
+/** @brief Configure a stream with filter coefficients.
+ *
+ * @param[in]	config	The set of filter coefficients.
+ * @return		IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function configures the filter coefficients for an image
+ * stream. For image pipes that do not execute any ISP filters, this
+ * function will have no effect.
+ * It is safe to call this function while the image stream is running,
+ * in fact this is the expected behavior most of the time. Proper
+ * resource locking and double buffering is in place to allow for this.
+ */
+void
+ia_css_stream_set_isp_config(struct ia_css_stream *stream,
+			     const struct ia_css_isp_config *config);
+
+/** @brief Get selected configuration settings
+ */
+void
+ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
+			     struct ia_css_isp_config *config);
+
+/* Copy DVS statistics from an ISP buffer to a host buffer.
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats);
+
+/* Copy DVS 2.0 statistics from an ISP buffer to a host buffer.
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats);
+
+/* Copy 3A statistics from an ISP buffer to a host buffer.
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
+			 const struct ia_css_isp_3a_statistics *isp_stats);
+
+/* Convenience functions for alloc/free of certain datatypes */
+
+/* Morphing table */
+struct ia_css_morph_table *
+ia_css_morph_table_allocate(unsigned int width, unsigned int height);
+
+void
+ia_css_morph_table_free(struct ia_css_morph_table *me);
+
+/* Shading table */
+void
+ia_css_shading_table_free(struct ia_css_shading_table *table);
+
+struct ia_css_shading_table *
+ia_css_shading_table_alloc(unsigned int width,
+			   unsigned int height);
+
+struct ia_css_isp_3a_statistics *
+ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
+
+void
+ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me);
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me);
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me);
+
+struct ia_css_3a_statistics *
+ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
+
+void
+ia_css_3a_statistics_free(struct ia_css_3a_statistics *me);
+
+struct ia_css_dvs_statistics *
+ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me);
+
+struct ia_css_dvs_coefficients *
+ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me);
+
+struct ia_css_dvs2_statistics *
+ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me);
+
+struct ia_css_dvs2_coefficients *
+ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
+
+void
+ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me);
+
+struct ia_css_dvs_6axis_config *
+ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream);
+
+void
+ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config);
+
+/** @brief start SP hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * It will boot the SP hardware and start multi-threading infrastructure.
+ * All threads will be started and blocked by semaphore. This function should
+ * be called before any ia_css_stream_start().
+ */
+enum ia_css_err
+ia_css_start_sp(void);
+
+
+/** @brief stop SP hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function will terminate all threads and shut down SP. It should be
+ * called after all ia_css_stream_stop().
+ */
+enum ia_css_err
+ia_css_stop_sp(void);
+
+/** @brief Specify a CSS MIPI frame buffer.
+ *
+ * @param[in]	size_mem_words	The frame size in memory words (32B).
+ * @param[in]	contiguous	Allocate memory physically contiguously or not.
+ * @return		The error code.
+ *
+ * Specifies a CSS MIPI frame buffer: size in memory words (32B).
+ */
+enum ia_css_err
+ia_css_mipi_frame_specify(const unsigned int	size_mem_words,
+				const bool contiguous);
+
+/** @Dequeue param buffers from sp2host_queue
+ *
+ * @return                                       no return code
+ *
+ * This function must be called at every driver interrupt handler to prevent
+ * overflow of sp2host_queue.
+ */
+void
+ia_css_dequeue_param_buffers(void);
+
+#endif /* _IA_CSS_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_acc.h b/drivers/media/atomisp2/css2400/ia_css_acc.h
new file mode 100644
index 0000000..116b8b9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_acc.h
@@ -0,0 +1,108 @@
+#ifndef _IA_CSS_ACC_H_
+#define _IA_CSS_ACC_H_
+
+#include "ia_css.h"
+#include "ia_css_acc_types.h"
+#include "sh_css_legacy.h"
+
+/* Acceleration API.
+ * This file is still in CSS 1.5 style, it will be converted to the
+ * 2.0 API and naming conventions soon.
+ * Do not start any new code on this API until the 2.0 version is
+ * available.
+ */
+
+#include "ia_css_acc_v1.h"
+
+struct ia_css_pipe;
+struct sh_css_pipeline;
+
+
+/** @brief Unload firmware for acceleration.
+ *
+ * @param	firmware	Firmware to be unloaded.
+ *
+ * Unload firmware for acceleration.
+ */
+void
+sh_css_unload_acceleration(struct ia_css_acc_fw *firmware);
+
+/** @brief Stop the acceleration pipe
+ *
+ * @return	       IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function stops the acceleration pipe that's running. Note that any
+ * dependent pipes will also be stopped automatically since otherwise
+ * they would starve because they no longer receive input data.
+ */
+enum ia_css_err
+sh_css_acceleration_stop(struct ia_css_pipe *pipe);
+
+
+/** @brief Set isp dmem parameters for acceleration.
+ *
+ * @param       firmware        Firmware of acceleration.
+ * @param       val             Parameter value.
+ * @return                      IA_CSS_SUCCESS or error code upon error.
+ *
+ * Set acceleration parameter to value <val>.
+ * The parameter value is an isp pointer, i.e. allocated in DDR and mapped
+ * to the CSS virtual address space.
+ */
+enum ia_css_err
+sh_css_set_firmware_dmem_parameters(struct ia_css_fw_info *firmware,
+                                    enum ia_css_isp_memories mem,
+                                    ia_css_ptr val, size_t size);
+
+/** @brief Append a stage to pipeline.
+ *
+ * @param	pipeline	Pointer to the pipeline to be extended.
+ * @param[in]	isp_fw		ISP firmware of new stage.
+ * @param[in]	in		The input frame to the stage.
+ * @param[in]	out		The output frame of the stage.
+ * @param[in]	vf		The viewfinder frame of the stage.
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * Append a new stage to *pipeline. When *pipeline is NULL, it will be created.
+ * The stage consists of an ISP binary <isp_fw> and input and output arguments.
+*/
+enum ia_css_err
+sh_css_append_stage(struct sh_css_pipeline **pipeline,
+		    const char *isp_fw,
+		    struct ia_css_frame *in,
+		    struct ia_css_frame *out,
+		    struct ia_css_frame *vf);
+
+/** @brief Create an empty pipeline.
+ */
+struct sh_css_pipeline *
+sh_css_create_pipeline(void);
+
+/** @brief Add an accelerator stage to a pipeline.
+ *
+ * @param	pipeline	The pipeline to be appended to.
+ * @param	acc_fw		The fw descriptor of the new stage
+ */
+enum ia_css_err
+sh_css_pipeline_add_acc_stage(struct sh_css_pipeline *pipeline,
+			      const void             *acc_fw);
+/** @brief Start a pipeline.
+ *
+ * @param	pipe_id		The pipe id where to run the pipeline. (Huh ?)
+ * @param	pipeline	The pipeline to be executed.
+ *
+ * Start a pipeline, does not wait until the pipeline completes.
+ */
+void
+sh_css_start_pipeline(enum ia_css_pipe_id pipe_id, struct sh_css_pipeline *pipeline);
+
+/** @brief Close a pipeline.
+ *
+ * @param	pipeline	The pipeline to be closed.
+ *
+ * Close a pipeline and free all memory allocated to it.
+ */
+void
+sh_css_close_pipeline(struct sh_css_pipeline *pipeline);
+
+#endif /* _IA_CSS_ACC_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_acc_types.h b/drivers/media/atomisp2/css2400/ia_css_acc_types.h
new file mode 100644
index 0000000..39e0d0a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_acc_types.h
@@ -0,0 +1,438 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _IA_CSS_ACC_TYPES_H_
+#define _IA_CSS_ACC_TYPES_H_
+
+/*! \file */
+
+/** @file ia_css_types.h
+ * This file contains types used for the ia_css parameters.
+ * These types are in a separate file because they are expected
+ * to be used in software layers that do not access the CSS API
+ * directly but still need to forward parameters for it.
+ */
+
+/* This code is also used by Silicon Hive in a simulation environment
+ * Therefore, the following macro is used to differentiate when this
+ * code is being included from within the Linux kernel source
+ */
+#include <system_types.h>	/* HAS_IRQ_MAP_VERSION_# */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/string.h>       /* memcpy() */
+#else
+#include <stdarg.h>             /* printf() */
+#include <stdlib.h>             /* size_t */
+#include <string.h>             /* memcpy() */
+#include "math_support.h"		/* min(), max() */
+#endif
+
+#include "ia_css.h"
+#include "ia_css_types.h"
+
+/* Types for the acceleration API.
+ * These should be moved to sh_css_internal.h once the old acceleration
+ * argument handling has been completed.
+ * After that, interpretation of these structures is no longer needed
+ * in the kernel and HAL.
+*/
+
+/** Blob descriptor.
+ * This structure describes an SP or ISP blob.
+ * It describes the test, data and bss sections as well as position in a
+ * firmware file.
+ * For convenience, it contains dynamic data after loading.
+ */
+struct ia_css_blob_info {
+	/**< Static blob data */
+	uint32_t offset;		/**< Blob offset in fw file */
+	uint32_t prog_name_offset;  /**< offset wrt hdr in bytes */
+	uint32_t size;			/**< Size of blob */
+	uint32_t padding_size;	/**< total cummulative of bytes added due to section alignment */
+	uint32_t icache_source;	/**< Position of icache in blob */
+	uint32_t icache_size;		/**< Size of icache section */
+	uint32_t icache_padding;/**< bytes added due to icache section alignment */
+	uint32_t text_source;	/**< Position of text in blob */
+	uint32_t text_size;		/**< Size of text section */
+	uint32_t text_padding;	/**< bytes added due to text section alignment */
+	uint32_t data_source;	/**< Position of data in blob */
+	uint32_t data_target;	/**< Start of data in SP dmem */
+	uint32_t data_size;		/**< Size of text section */
+	uint32_t data_padding;	/**< bytes added due to data section alignment */
+	uint32_t bss_target;	/**< Start position of bss in SP dmem */
+	uint32_t bss_size;		/**< Size of bss section */
+	/**< Dynamic data filled by loader */
+	const void  *code;		/**< Code section absolute pointer within fw, code = icache + text */
+	const void  *data;		/**< Sp data section */
+};
+
+/** Type of acceleration.
+ */
+enum ia_css_acc_type {
+	IA_CSS_ACC_NONE,	/**< Normal binary */
+	IA_CSS_ACC_OUTPUT,	/**< Accelerator stage on output frame */
+	IA_CSS_ACC_VIEWFINDER,	/**< Accelerator stage on viewfinder frame */
+	IA_CSS_ACC_STANDALONE,	/**< Stand-alone acceleration */
+};
+
+/** Firmware types.
+ */
+enum ia_css_fw_type {
+	ia_css_sp_firmware,	/**< Firmware for the SP */
+	ia_css_isp_firmware,	/**< Firmware for the ISP */
+	ia_css_acc_firmware	/**< Firmware for accelrations */
+};
+
+#if defined(IS_ISP_2400_SYSTEM)
+enum ia_css_isp_memories {
+	IA_CSS_ISP_PMEM0 = 0,
+	IA_CSS_ISP_DMEM0,
+	IA_CSS_ISP_VMEM0,
+	IA_CSS_ISP_VAMEM0,
+	IA_CSS_ISP_VAMEM1,
+	IA_CSS_ISP_VAMEM2,
+	IA_CSS_ISP_HMEM0,
+	N_IA_CSS_ISP_MEMORIES
+};
+
+#define IA_CSS_NUM_ISP_MEMORIES 7
+
+#else
+#error "ia_css_types.h:  SYSTEM must be one of {ISP_2400_SYSTEM}"
+#endif
+
+/** CSS data descriptor */
+struct ia_css_data {
+	ia_css_ptr address;
+	uint32_t   size; /* Disabled if 0 */
+};
+
+struct ia_css_blob_descr;
+
+/** Structure describing an ISP binary.
+ * It describes the capabilities of a binary, like the maximum resolution,
+ * support features, dma channels, uds features, etc.
+ */
+struct ia_css_binary_info {
+	uint32_t		id; /* IA_CSS_BINARY_ID_* */
+	uint32_t		mode;
+	enum ia_css_acc_type	 type;
+	const struct ia_css_blob_descr *blob;
+	int32_t			num_output_formats;
+	enum ia_css_frame_format output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	uint32_t		min_input_width;
+	uint32_t		min_input_height;
+	uint32_t		max_input_width;
+	uint32_t		max_input_height;
+	uint32_t		min_output_width;
+	uint32_t		min_output_height;
+	uint32_t		max_output_width;
+	uint32_t		max_output_height;
+	uint32_t		max_internal_width;
+	uint32_t		max_internal_height;
+	uint32_t		max_dvs_envelope_width;
+	uint32_t		max_dvs_envelope_height;
+	uint32_t		variable_resolution;
+	uint32_t		variable_output_format;
+	uint32_t		variable_vf_veceven;
+	uint32_t		max_vf_log_downscale;
+	uint32_t		top_cropping;
+	uint32_t		left_cropping;
+	uint32_t		s3atbl_use_dmem;
+	int32_t			input;
+	ia_css_ptr		xmem_addr;
+	uint32_t		c_subsampling;
+	uint32_t		output_num_chunks;
+	uint32_t		num_stripes;
+	uint32_t		pipelining;
+	uint32_t		fixed_s3a_deci_log;
+	uint32_t		isp_addresses; /* Address in ISP dmem */
+	uint32_t		main_entry;    /* Address of entry fct */
+	uint32_t		in_frame;  /* Address in ISP dmem */
+	uint32_t		out_frame; /* Address in ISP dmem */
+	uint32_t		in_data;  /* Address in ISP dmem */
+	uint32_t		out_data; /* Address in ISP dmem */
+	uint8_t			block_width;
+	uint8_t			block_height;
+	uint8_t			output_block_height;
+	uint8_t			num_output_pins;
+	uint32_t		dvs_in_block_width;
+	uint32_t		dvs_in_block_height;
+	struct ia_css_data	mem_initializers[IA_CSS_NUM_ISP_MEMORIES];
+	uint32_t		sh_dma_cmd_ptr;     /* In ISP dmem */
+	uint32_t		isp_pipe_version;
+	struct {
+		uint8_t	ctc;   /* enum sh_css_isp_memories */
+		uint8_t	gamma; /* enum sh_css_isp_memories */
+		uint8_t	xnr;   /* enum sh_css_isp_memories */
+		uint8_t	r_gamma; /* enum sh_css_isp_memories */
+		uint8_t	g_gamma; /* enum sh_css_isp_memories */
+		uint8_t	b_gamma; /* enum sh_css_isp_memories */
+		uint8_t	rgby; /* enum sh_css_isp_memories */
+	} memories;
+/* MW: Packing (related) bools in an integer ?? */
+	struct {
+		uint8_t	reduced_pipe;
+		uint8_t	vf_veceven;
+		uint8_t	dis;
+		uint8_t	dvs_envelope;
+		uint8_t	uds;
+		uint8_t	dvs_6axis;
+		uint8_t	block_output;
+		uint8_t	streaming_dma;
+		uint8_t	ds;
+		uint8_t	fixed_bayer_ds;
+		uint8_t	bayer_fir_6db;
+		uint8_t	raw_binning;
+		uint8_t	continuous;
+		uint8_t	s3a;
+		uint8_t	fpnr;
+		uint8_t	sc;
+		uint8_t	dis_crop;
+		uint8_t	dp_2adjacent;
+		uint8_t	macc;
+		uint8_t	ss;
+		uint8_t	output;
+		uint8_t	ref_frame;
+		uint8_t	tnr;
+		uint8_t	xnr;
+		uint8_t	raw;
+		uint8_t	params;
+		uint8_t	gamma;
+		uint8_t	ctc;
+		uint8_t	ca_gdc;
+		uint8_t	isp_addresses;
+		uint8_t	in_frame;
+		uint8_t	out_frame;
+		uint8_t	high_speed;
+		uint8_t	input_chunking;
+		/* uint8_t padding[2]; */
+	} enable;
+	struct {
+/* DMA channel ID: [0,...,HIVE_ISP_NUM_DMA_CHANNELS> */
+		uint8_t	crop_channel;
+		uint8_t	fpntbl_channel;
+		uint8_t	multi_channel;
+		uint8_t	raw_out_channel;
+		uint8_t	sctbl_channel;
+		uint8_t	ref_y_channel;
+		uint8_t	ref_c_channel;
+		uint8_t	tnr_channel;
+		uint8_t	tnr_out_channel;
+		uint8_t	dvs_in_channel;
+		uint8_t	dvs_coords_channel;
+		uint8_t	output_channel;
+		uint8_t	c_channel;
+		uint8_t	vfout_channel;
+		uint8_t	vfout_c_channel;
+		uint8_t	claimed_by_isp;
+		/* uint8_t padding[0]; */
+		struct {
+			uint8_t		channel;  /* Dma channel used */
+			uint8_t		height;   /* Buffer height */
+			uint16_t	stride;   /* Buffer stride */
+		} raw;
+	} dma;
+	struct {
+		uint16_t	bpp;
+		uint16_t	use_bci;
+		uint16_t	woix;
+		uint16_t	woiy;
+		uint16_t	extra_out_vecs;
+		uint16_t	vectors_per_line_in;
+		uint16_t	vectors_per_line_out;
+		uint16_t	vectors_c_per_line_in;
+		uint16_t	vectors_c_per_line_out;
+		uint16_t	vmem_gdc_in_block_height_y;
+		uint16_t	vmem_gdc_in_block_height_c;
+		/* uint16_t padding; */
+	} uds;
+	uint32_t	blob_index;
+	struct ia_css_binary_info *next;
+};
+
+/** Structure describing the SP binary.
+ * It contains several address, either in ddr, sp_dmem or
+ * the entry function in pmem.
+ */
+struct ia_css_sp_info {
+	uint32_t init_dmem_data; /**< data sect config, stored to dmem */
+	uint32_t per_frame_data; /**< Per frame data, stored to dmem */
+	uint32_t group;		/**< Per pipeline data, loaded by dma */
+	uint32_t output;		/**< SP output data, loaded by dmem */
+	uint32_t host_sp_queue;	/**< Host <-> SP queues */
+	uint32_t host_sp_com;/**< Host <-> SP commands */
+	uint32_t isp_started;	/**< Polled from sensor thread, csim only */
+	uint32_t sw_state;	/**< Polled from css */
+	uint32_t host_sp_queues_initialized; /**< Polled from the SP */
+	uint32_t sleep_mode;  /**< different mode to halt SP */
+	uint32_t invalidate_tlb;		/**< inform SP to invalidate mmu TLB */
+	uint32_t request_flash;	/**< inform SP to switch on flash for next frame */
+	uint32_t stop_copy_preview;
+	uint32_t debug_buffer_ddr_address;	/**< inform SP the address
+	of DDR debug queue */
+	uint32_t ddr_parameter_address; /**< acc param ddrptr, sp dmem */
+	uint32_t ddr_parameter_size;    /**< acc param size, sp dmem */
+	/* Entry functions */
+	uint32_t sp_entry;	/**< The SP entry function */
+};
+
+/** Accelerator firmware information.
+ */
+struct ia_css_acc_info {
+	uint32_t per_frame_data; /**< Dummy for now */
+};
+
+/** Firmware information.
+ */
+union ia_css_fw_union {
+	struct ia_css_binary_info	isp; /**< ISP info */
+	struct ia_css_sp_info		sp;  /**< SP info */
+	struct ia_css_acc_info		acc; /**< Accelerator info */
+};
+
+/** Firmware information.
+ */
+struct ia_css_fw_info {
+	size_t			header_size; /**< size of fw header */
+	enum ia_css_fw_type	type; /**< FW type */
+	union ia_css_fw_union	info; /**< Binary info */
+	struct ia_css_blob_info blob; /**< Blob info */
+	/* Dynamic part */
+	struct ia_css_fw_info  *next;
+	uint32_t                loaded;    /**< Firmware has been loaded */
+	const uint8_t          *isp_code;  /**< ISP pointer to code */
+	/**< Firmware handle between user space and kernel */
+	uint32_t		handle;
+	/**< Sections to copy from/to ISP */
+	struct ia_css_data      mem_initializers[IA_CSS_NUM_ISP_MEMORIES];
+	/**< Initializer for local ISP memories */
+};
+
+struct ia_css_blob_descr {
+	const unsigned char  *blob;
+	struct ia_css_fw_info header;
+	const char	     *name;
+};
+
+struct ia_css_acc_fw;
+
+/** Structure describing the SP binary of a stand-alone accelerator.
+ */
+ struct ia_css_acc_sp {
+	void (*init) (struct ia_css_acc_fw *); /**< init for crun */
+	uint32_t      sp_prog_name_offset; /**< program name offset wrt hdr
+						in bytes */
+	uint32_t      sp_blob_offset;	   /**< blob offset wrt hdr in bytes */
+	void	     *entry;		   /**< Address of sp entry point */
+	uint32_t *css_abort;	   /**< SP dmem abort flag */
+	void	     *isp_code;		   /**< SP dmem address holding xmem
+						address of isp code */
+	struct ia_css_fw_info fw;	   /**< SP fw descriptor */
+	const uint8_t *code;	   /**< ISP pointer of allocated
+						SP code */
+};
+
+/** Acceleration firmware descriptor.
+  * This descriptor descibes either SP code (stand-alone), or
+  * ISP code (a separate pipeline stage).
+  */
+struct ia_css_acc_fw_hdr {
+	enum ia_css_acc_type type;	/**< Type of accelerator */
+	uint32_t	isp_prog_name_offset; /**< program name offset wrt
+						   header in bytes */
+	uint32_t	isp_blob_offset;      /**< blob offset wrt header
+						   in bytes */
+	uint32_t	isp_size;	      /**< Size of isp blob */
+	const uint8_t  *isp_code;	      /**< ISP pointer to code */
+	struct ia_css_acc_sp  sp;  /**< Standalone sp code */
+	/**< Firmware handle between user space and kernel */
+	uint32_t	handle;
+	struct ia_css_data parameters; /**< Current SP parameters */
+};
+
+/** Firmware structure.
+  * This contains the header and actual blobs.
+  * For standalone, it contains SP and ISP blob.
+  * For a pipeline stage accelerator, it contains ISP code only.
+  * Since its members are variable size, their offsets are described in the
+  * header and computed using the access macros below.
+  */
+struct ia_css_acc_fw {
+	struct ia_css_acc_fw_hdr header; /**< firmware header */
+	/*
+	int8_t   isp_progname[];	  **< ISP program name
+	int8_t   sp_progname[];	  **< SP program name, stand-alone only
+	uint8_t sp_code[];  **< SP blob, stand-alone only
+	uint8_t isp_code[]; **< ISP blob
+	*/
+};
+
+/* Access macros for firmware */
+#define IA_CSS_ACC_OFFSET(t, f, n) ((t)((uint8_t *)(f)+(f->header.n)))
+#define IA_CSS_ACC_SP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
+						 sp.sp_prog_name_offset)
+#define IA_CSS_ACC_ISP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
+						 isp_prog_name_offset)
+#define IA_CSS_ACC_SP_CODE(f)      IA_CSS_ACC_OFFSET(uint8_t *, f, \
+						 sp.sp_blob_offset)
+#define IA_CSS_ACC_SP_DATA(f)      (IA_CSS_ACC_SP_CODE(f) + \
+					(f)->header.sp.fw.blob.data_source)
+#define IA_CSS_ACC_ISP_CODE(f)     IA_CSS_ACC_OFFSET(uint8_t*, f,\
+						 isp_blob_offset)
+#define IA_CSS_ACC_ISP_SIZE(f)     ((f)->header.isp_size)
+
+/* Binary name follows header immediately */
+#define IA_CSS_EXT_ISP_PROG_NAME(f) ((const char *)(f)+sizeof(*f))
+
+/** Structure to encapsulate required arguments for
+ * initialization of SP DMEM using the SP itself
+ * This is exported for accelerators implementing their own SP code.
+ */
+struct ia_css_sp_init_dmem_cfg {
+	uint32_t   done;	      /**< Init has been done */
+	ia_css_ptr      ddr_code_addr;  /**< code segment address in ddr  */
+	ia_css_ptr ddr_data_addr;  /**< data segment address in ddr  */
+	uint32_t        pmem_text_addr; /**< text segment address in pmem */
+	uint32_t        dmem_data_addr; /**< data segment address in dmem */
+	uint32_t        dmem_bss_addr;  /**< bss segment address in dmem  */
+	uint32_t        text_size;      /**< text segment size            */
+	uint32_t   data_size;      /**< data segment size            */
+	uint32_t   bss_size;       /**< bss segment size             */
+};
+
+enum ia_css_sp_sleep_mode {
+	SP_DISABLE_SLEEP_MODE = 0,
+	SP_SLEEP_AFTER_FRAME = 1 << 0,
+	SP_SLEEP_AFTER_IRQ = 1 << 1
+};
+
+enum ia_css_sp_sw_state {
+	SP_SW_STATE_NULL = 0,
+	SP_SW_INITIALIZED,
+	SP_SW_TERMINATED
+};
+
+#endif /* _IA_CSS_TYPES_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_acc_v1.h b/drivers/media/atomisp2/css2400/ia_css_acc_v1.h
new file mode 100644
index 0000000..69d1e47
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_acc_v1.h
@@ -0,0 +1,70 @@
+#ifndef _IA_CSS_ACC_V1_H_
+#define _IA_CSS_ACC_V1_H_
+
+#include "ia_css.h"
+#include "ia_css_acc_types.h"
+
+/* Acceleration API.
+ * This file is still in CSS 1.0 style, it will be converted to the
+ * 2.0 API and naming conventions soon.
+ * Do not start any new code on this API until the 2.0 version is
+ * available.
+ */
+
+
+/** @brief Unload firmware for acceleration.
+ *
+ * @param   firmware    Firmware to be unloaded.
+ *
+ * Unload firmware for acceleration.
+ */
+void
+sh_css_unload_acceleration(struct ia_css_acc_fw *firmware);
+
+
+/** @brief Set parameter for acceleration.
+ *
+ * @param   firmware    Firmware of acceleration.
+ * @param   val     Parameter value.
+ * @return          IA_CSS_SUCCESS or error code upon error.
+ *
+ * Set acceleration parameter to value <val>.
+ * The parameter value is an isp pointer, i.e. allocated in DDR and mapped
+ * to the CSS virtual address space.
+ */
+enum ia_css_err
+sh_css_set_acceleration_parameter(struct ia_css_acc_fw *firmware,
+                  ia_css_ptr val, size_t size);
+
+
+/** @brief Start acceleration.
+ *
+ * @param   firmware    Firmware of acceleration.
+ * @return          IA_CSS_SUCCESS or error code upon error.
+ *
+ * Start acceleration of firmware.
+ * Load the firmware if not yet loaded.
+ */
+enum ia_css_err
+sh_css_start_acceleration(struct ia_css_acc_fw *firmware);
+
+/** @brief Signal termination of acceleration.
+ *
+ * @param   firmware    Firmware of acceleration.
+ *
+ * To be called when acceleration has terminated.
+ */
+void
+sh_css_acceleration_done(struct ia_css_acc_fw *firmware);
+
+/** @brief Abort current acceleration.
+ *
+ * @param   firmware    Firmware of acceleration.
+ * @param   deadline    Deadline in microseconds.
+ *
+ * Abort acceleration within <deadline> microseconds
+ */
+void
+sh_css_abort_acceleration(struct ia_css_acc_fw *firmware, unsigned deadline);
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/ia_css_accelerate.h b/drivers/media/atomisp2/css2400/ia_css_accelerate.h
new file mode 100644
index 0000000..0de9dca
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_accelerate.h
@@ -0,0 +1,106 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_ACCELERATE_H_
+#define _SH_CSS_ACCELERATE_H_
+
+#include "ia_css.h"
+#include "ia_css_acc_types.h"
+
+
+/* Unload the firmware*/
+void
+sh_css_acc_unload(const struct ia_css_acc_fw *firmware);
+
+/* Set acceleration parameter to value <val> for isp dmem */
+enum ia_css_err
+sh_css_acc_set_parameter(struct ia_css_acc_fw *firmware,
+			 struct ia_css_data parameters);
+
+/* Set acceleration parameters to value <parameters> for memory <mem> */
+enum ia_css_err
+sh_css_acc_set_firmware_parameters(struct ia_css_fw_info *firmware,
+			 enum ia_css_isp_memories mem,
+			 struct ia_css_data parameters);
+
+
+/* Start the sp, which will start the isp.
+   Load the firmware if not yet loaded.
+*/
+enum ia_css_err
+sh_css_acc_start(struct ia_css_acc_fw *firmware);
+
+/* To be called when acceleration has terminated.
+*/
+void
+sh_css_acc_done(struct ia_css_acc_fw *firmware);
+
+/* Wait for the firmware to terminate */
+void
+sh_css_acc_wait(void);
+
+/* Flag abortion of acceleration */
+void sh_css_acc_abort(struct ia_css_acc_fw *firmware);
+
+/* Load the firmware into xmem */
+enum ia_css_err
+sh_css_acc_load_extension(const struct ia_css_fw_info *firmware);
+
+/* Unload the firmware*/
+void
+sh_css_acc_unload_extension(const struct ia_css_fw_info *firmware);
+
+
+#if 0
+/* Get type for argument <num> */
+enum sh_css_acc_arg_type
+sh_css_argument_type(struct ia_css_acc_fw *firmware, unsigned int num);
+
+/* Set host private data for argument <num> */
+enum ia_css_err
+sh_css_argument_set_host(struct ia_css_acc_fw *firmware,
+			 unsigned num, void *host);
+
+/* Get host private data for argument <num> */
+void *
+sh_css_argument_get_host(struct ia_css_acc_fw *firmware, unsigned num);
+
+/* Get size for argument <num> */
+size_t
+sh_css_argument_get_size(struct ia_css_acc_fw *firmware, unsigned num);
+
+/* Get the number of accelerator arguments */
+unsigned
+sh_css_num_accelerator_args(struct ia_css_acc_fw *firmware);
+
+/* Destabilize argument <num>, i.e. flush it from the cache */
+void
+sh_css_acc_stabilize(struct ia_css_acc_fw *firmware, unsigned num, bool stable);
+
+/* Check stability of argument <num> */
+bool
+sh_css_acc_is_stable(struct ia_css_acc_fw *firmware, unsigned num);
+
+#endif
+
+#endif /* _SH_CSS_ACCELERATE_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_device_access.c b/drivers/media/atomisp2/css2400/ia_css_device_access.c
new file mode 100644
index 0000000..2b578a1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_device_access.c
@@ -0,0 +1,75 @@
+#include "ia_css_device_access.h"
+#include "device_access.h"
+#include "assert_support.h"
+
+static struct ia_css_hw_access_env my_env;
+
+void
+ia_css_device_access_init(const struct ia_css_hw_access_env *env)
+{
+	my_env = *env;
+}
+
+uint8_t
+device_load_uint8(const hrt_address addr)
+{
+	return my_env.load_8(addr);
+}
+
+uint16_t
+device_load_uint16(const hrt_address addr)
+{
+	return my_env.load_16(addr);
+}
+
+uint32_t
+device_load_uint32(const hrt_address addr)
+{
+	return my_env.load_32(addr);
+}
+
+uint64_t
+device_load_uint64(const hrt_address addr)
+{
+	(void)addr;
+	assert(0);
+	return 0;
+}
+
+void
+device_store_uint8(const hrt_address addr, const uint8_t data)
+{
+	my_env.store_8(addr, data);
+}
+
+void
+device_store_uint16(const hrt_address addr, const uint16_t data)
+{
+	my_env.store_16(addr, data);
+}
+
+void
+device_store_uint32(const hrt_address addr, const uint32_t data)
+{
+	my_env.store_32(addr, data);
+}
+
+void
+device_store_uint64(const hrt_address addr, const uint64_t data)
+{
+	(void)addr;
+	(void)data;
+	assert(0);
+}
+
+void
+device_load(const hrt_address addr, void *data, const size_t size)
+{
+	my_env.load(addr, data, size);
+}
+
+void
+device_store(const hrt_address addr, const void *data, const size_t size)
+{
+	my_env.store(addr, data, size);
+}
diff --git a/drivers/media/atomisp2/css2400/ia_css_device_access.h b/drivers/media/atomisp2/css2400/ia_css_device_access.h
new file mode 100644
index 0000000..777bb06
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_device_access.h
@@ -0,0 +1,9 @@
+#ifndef _IA_CSS_DEVICE_ACCESS_H_
+#define _IA_CSS_DEVICE_ACCESS_H_
+
+#include <ia_css.h>
+
+void
+ia_css_device_access_init(const struct ia_css_hw_access_env *env);
+
+#endif /* _IA_CSS_DEVICE_ACCESS_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_memory_access.c b/drivers/media/atomisp2/css2400/ia_css_memory_access.c
new file mode 100644
index 0000000..abfe146
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_memory_access.c
@@ -0,0 +1,73 @@
+#include "ia_css_memory_access.h"
+#include "memory_access.h"
+#include "assert_support.h"
+
+const hrt_vaddress mmgr_NULL = (hrt_vaddress)0;
+
+static struct ia_css_css_mem_env my_env;
+
+void
+ia_css_memory_access_init(const struct ia_css_css_mem_env *env)
+{
+	my_env = *env;
+}
+
+hrt_vaddress
+mmgr_malloc(const size_t size)
+{
+	return mmgr_alloc_attr(size, 0);
+}
+
+hrt_vaddress mmgr_alloc_attr(const size_t size, const uint16_t attrs)
+{
+	uint32_t my_attrs = 0;
+	uint16_t masked_attrs = attrs & MMGR_ATTRIBUTE_MASK;
+
+	if (masked_attrs & MMGR_ATTRIBUTE_CACHED)
+		my_attrs |= IA_CSS_MEM_ATTR_CACHED;
+	if (masked_attrs & MMGR_ATTRIBUTE_CLEARED)
+		my_attrs |= IA_CSS_MEM_ATTR_ZEROED;
+	if (masked_attrs & MMGR_ATTRIBUTE_CONTIGUOUS)
+		my_attrs |= IA_CSS_MEM_ATTR_CONTIGUOUS;
+	if (masked_attrs & MMGR_ATTRIBUTE_PAGEALIGN)
+		my_attrs |= IA_CSS_MEM_ATTR_PAGEALIGN;
+
+	return my_env.alloc(size, my_attrs);
+}
+
+hrt_vaddress
+mmgr_calloc(const size_t N, const size_t size)
+{
+	return mmgr_alloc_attr(size * N, MMGR_ATTRIBUTE_CLEARED);
+}
+
+void
+mmgr_free(hrt_vaddress vaddr)
+{
+	my_env.free(vaddr);
+}
+
+void
+mmgr_clear(hrt_vaddress vaddr, const size_t size)
+{
+	my_env.set(vaddr, 0, size);
+}
+
+void
+mmgr_load(const hrt_vaddress vaddr, void *data, const size_t size)
+{
+	my_env.load(vaddr, data, size);
+}
+
+void
+mmgr_store(const hrt_vaddress vaddr, const void *data, const size_t size)
+{
+	my_env.store(vaddr, data, size);
+}
+
+hrt_vaddress
+mmgr_mmap(const void *ptr, const size_t size,
+	  uint16_t attribute, void *context)
+{
+	return my_env.mmap(ptr, size, attribute, context);
+}
diff --git a/drivers/media/atomisp2/css2400/ia_css_memory_access.h b/drivers/media/atomisp2/css2400/ia_css_memory_access.h
new file mode 100644
index 0000000..c0c2779
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_memory_access.h
@@ -0,0 +1,10 @@
+#ifndef _IA_CSS_MEMORY_ACCESS_H_
+#define _IA_CSS_MEMORY_ACCESS_H_
+
+#include "ia_css.h"
+
+void
+ia_css_memory_access_init(const struct ia_css_css_mem_env *env);
+
+#endif /* _IA_CSS_MEMORY_ACCESS_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/ia_css_stream.h b/drivers/media/atomisp2/css2400/ia_css_stream.h
new file mode 100644
index 0000000..44907cc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_stream.h
@@ -0,0 +1,77 @@
+#ifndef _IA_CSS_STREAM_H_
+#define _IA_CSS_STREAM_H_
+
+#include <input_system.h>
+#include "ia_css.h"
+#include "sh_css_params.h"
+/**
+ * structure to hold all internal stream related information
+ */
+struct ia_css_stream {
+	struct ia_css_stream_config    config;
+	struct ia_css_stream_info      info;
+	rx_cfg_t                       csi_rx_config;
+	bool                           reconfigure_css_rx;
+	struct ia_css_pipe            *last_pipe;
+	int                            num_pipes;
+	struct ia_css_pipe           **pipes;
+	struct ia_css_isp_parameters  *isp_params_configs;
+	bool                           continuous;
+	bool                           cont_capt;
+};
+
+struct sh_css_binary *
+ia_css_stream_get_dvs_binary(const struct ia_css_stream *stream);
+
+struct sh_css_binary *
+ia_css_stream_get_3a_binary(const struct ia_css_stream *stream);
+
+unsigned int 
+ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream);
+
+bool
+sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int sensor_binning);
+
+enum ia_css_err
+sh_css_params_write_to_ddr(struct ia_css_stream *stream,
+			   const struct sh_css_binary *binary_info);
+
+void
+sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit);
+
+void
+sh_css_invalidate_params(struct ia_css_stream *stream);
+
+/* The following functions are used for testing purposes only */
+const struct ia_css_fpn_table *
+ia_css_get_fpn_table(struct ia_css_stream *stream);
+
+struct ia_css_shading_table *
+ia_css_get_shading_table(struct ia_css_stream *stream);
+
+const struct sh_css_isp_params *
+ia_css_get_isp_params(struct ia_css_stream *stream);
+
+void
+ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
+				short *horizontal_coefficients,
+				short *vertical_coefficients);
+
+void
+ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
+	short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag,
+	short *hor_coefs_even_real,
+	short *hor_coefs_even_imag,
+	short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag,
+	short *ver_coefs_even_real,
+	short *ver_coefs_even_imag);
+
+enum ia_css_err
+ia_css_stream_isp_parameters_init(struct ia_css_stream *stream);
+
+void
+ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream);
+
+#endif /*_IA_CSS_STREAM_H_*/
diff --git a/drivers/media/atomisp2/css2400/ia_css_types.h b/drivers/media/atomisp2/css2400/ia_css_types.h
new file mode 100644
index 0000000..b568e7a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_types.h
@@ -0,0 +1,684 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _IA_CSS_TYPES_H_
+#define _IA_CSS_TYPES_H_
+
+/*! \file */
+
+/** @file ia_css_types.h
+ * This file contains types used for the ia_css parameters.
+ * These types are in a separate file because they are expected
+ * to be used in software layers that do not access the CSS API
+ * directly but still need to forward parameters for it.
+ */
+
+/* This code is also used by Silicon Hive in a simulation environment
+ * Therefore, the following macro is used to differentiate when this
+ * code is being included from within the Linux kernel source
+ */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#else
+#include <stdint.h>
+#endif
+
+#define IA_CSS_VERSION_MAJOR    2
+#define IA_CSS_VERSION_MINOR    0
+#define IA_CSS_VERSION_REVISION 2
+
+/** Number of axes in the MACC table. */
+#define IA_CSS_MACC_NUM_AXES           16
+/** Number of coefficients per MACC axes. */
+#define IA_CSS_MACC_NUM_COEFS          4
+/** The number of planes in the morphing table. */
+#define IA_CSS_MORPH_TABLE_NUM_PLANES  6
+/** Number of color planes in the shading table. */
+#define IA_CSS_SC_NUM_COLORS           4
+/** Number of DVS coefficient types */
+#define IA_CSS_DVS_NUM_COEF_TYPES      6
+#define IA_CSS_DVS_COEF_TYPES_ON_DMEM  2
+#define IA_CSS_DVS2_NUM_COEF_TYPES     4
+
+/** Fractional bits for CTC gain */
+#define IA_CSS_CTC_COEF_SHIFT          13
+/** Fractional bits for GAMMA gain */
+#define IA_CSS_GAMMA_GAIN_K_SHIFT      13
+
+/** Number of elements in the CTC table. */
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2      8
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE           ((1U<<IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2) + 1)
+/** Number of elements in the gamma table. */
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2    8
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE         ((1U<<IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2) + 1)
+/** Number of elements in the xnr table. */
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE	        (1U<<IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2)
+/** Number of elements in the sRGB gamma table. */
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2    8
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE     ((1U<<IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2) + 1)
+
+/** Number of elements in the CTC table. */
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2      10
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE           (1U<<IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2)
+/** Number of elements in the gamma table. */
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2    10
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE         (1U<<IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2)
+/** Number of elements in the xnr table. */
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE           (1U<<IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2)
+/** Number of elements in the sRGB gamma table. */
+#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2 8
+#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE      (1U<<IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2)
+
+/* Fixed point types.
+ * To comply with Linux coding standards these are #defines instead
+ * of typedefs.
+ * NOTE: the 16 bit fixed point types actually occupy 32 bits
+ * to save on extension operations in the ISP code.
+ */
+/** Unsigned fixed point value, 0 integer bits, 16 fractional bits */
+typedef uint32_t ia_css_u0_16;
+/** Unsigned fixed point value, 5 integer bits, 11 fractional bits */
+typedef uint32_t ia_css_u5_11;
+/** Unsigned fixed point value, 8 integer bits, 8 fractional bits */
+typedef uint32_t ia_css_u8_8;
+/** Signed fixed point value, 0 integer bits, 15 fractional bits */
+typedef int32_t ia_css_s0_15;
+
+/* Virtual address within the CSS address space. */
+typedef uint32_t ia_css_ptr;
+
+enum ia_css_vamem_type {
+	IA_CSS_VAMEM_TYPE_1,
+	IA_CSS_VAMEM_TYPE_2,
+};
+
+/** Vector with signed values. This is used to indicate motion for
+ * Digital Image Stabilization.
+ */
+struct ia_css_vector {
+	int32_t x; /**< horizontal motion (in pixels) */
+	int32_t y; /**< vertical motion (in pixels) */
+};
+
+/** 3A statistics grid */
+struct ia_css_3a_grid_info {
+	uint32_t enable;            /**< 3A statistics enabled */
+	uint32_t use_dmem;          /**< DMEM or VMEM determines layout */
+	uint32_t has_histogram;     /**< Statistics include histogram */
+	uint32_t width;	            /**< Width of 3A grid */
+	uint32_t height;	    /**< Height of 3A grid */
+	uint32_t aligned_width;     /**< Horizontal stride (for alloc) */
+	uint32_t aligned_height;    /**< Vertical stride (for alloc) */
+	uint32_t bqs_per_grid_cell; /**< Grid cell size */
+	uint32_t deci_factor_log2;  /**< log2 of bqs_per_grid_cell */
+	uint32_t elem_bit_depth;    /**< Bit depth of element used to calculate 3A statistics */	
+};
+
+/** DVS statistics grid */
+struct ia_css_dvs_grid_info {
+	uint32_t enable;        /**< DVS statistics enabled */
+	uint32_t width;	    /**< Width of DVS grid, this is equal to the
+					 the number of vertical statistics. */
+	uint32_t aligned_width; /**< Stride of each grid line */
+	uint32_t height;	    /**< Height of DVS grid, this is equal
+					 to the number of horizontal statistics.
+				     */
+	uint32_t aligned_height;/**< Stride of each grid column */
+	uint32_t bqs_per_grid_cell; /**< Grid cell size */
+
+	uint32_t num_hor_coefs;	/**< Number of horizontal coefficients. */
+	uint32_t num_ver_coefs;	/**< Number of vertical coefficients. */
+};
+
+/** structure that describes the 3A and DIS grids */
+struct ia_css_grid_info {
+	/** \name ISP input size
+	  * that is visible for user
+	  * @{
+	  */
+	uint32_t isp_in_width;
+	uint32_t isp_in_height;
+	/** @}*/
+
+	struct ia_css_3a_grid_info  s3a_grid; /**< 3A grid info */
+	struct ia_css_dvs_grid_info dvs_grid; /**< DVS grid info */
+
+	enum ia_css_vamem_type vamem_type;
+};
+
+/** Optical black mode.
+ */
+enum ia_css_ob_mode {
+	IA_CSS_OB_MODE_NONE,
+	IA_CSS_OB_MODE_FIXED,
+	IA_CSS_OB_MODE_RASTER
+};
+
+/** The 4 colors that a shading table consists of.
+ *  For each color we store a grid of values.
+ */
+enum ia_css_sc_color {
+	IA_CSS_SC_COLOR_GR, /**< Green on a green-red line */
+	IA_CSS_SC_COLOR_R,  /**< Red */
+	IA_CSS_SC_COLOR_B,  /**< Blue */
+	IA_CSS_SC_COLOR_GB  /**< Green on a green-blue line */
+};
+
+/** White Balance configuration (Gain Adjust).
+ *  All values are uinteger_bits.16-integer_bits fixed point values.
+ */
+struct ia_css_wb_config {
+	uint32_t integer_bits; /**< */
+	uint32_t gr;	/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t r;		/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t b;		/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+};
+
+/** Color Space Conversion settings.
+ *  The data is s13-fraction_bits.fraction_bits fixed point.
+ */
+struct ia_css_cc_config {
+	uint32_t fraction_bits;
+	int32_t matrix[3 * 3]; /**< RGB2YUV conversion matrix, signed
+				   <13-fraction_bits>.<fraction_bits> */
+};
+
+/** Morping table, used for geometric distortion and chromatic abberration
+ *  correction (GDCAC, also called GDC).
+ *  This table describes the imperfections introduced by the lens, the
+ *  advanced ISP can correct for these imperfections using this table.
+ */
+struct ia_css_morph_table {
+	uint32_t enable; /**< To disable GDC, set this field to false. The
+		          coordinates fields can be set to NULL in this case. */
+	uint32_t height; /**< Table height */
+	uint32_t width;  /**< Table width */
+	uint16_t *coordinates_x[IA_CSS_MORPH_TABLE_NUM_PLANES];
+	/**< X coordinates that describe the sensor imperfection */
+	uint16_t *coordinates_y[IA_CSS_MORPH_TABLE_NUM_PLANES];
+	/**< Y coordinates that describe the sensor imperfection */
+};
+
+/** Fixed pattern noise table. This contains the fixed patterns noise values
+ *  obtained from a black frame capture.
+ */
+struct ia_css_fpn_table {
+	int16_t *data;		/**< Table content */
+	uint32_t width;	/**< Table height */
+	uint32_t height;	/**< Table width */
+	uint32_t shift;	/**< */
+};
+
+/** Lens color shading table. This describes the color shading artefacts
+ *  introduced by lens imperfections.
+ */
+struct ia_css_shading_table {
+	uint32_t enable; /**< set to false for no shading correction.
+		          The data field can be NULL when enable == true */
+	uint32_t sensor_width;  /**< Native sensor width in pixels */
+	uint32_t sensor_height; /**< Native sensor height in lines */
+	uint32_t width;  /**< Number of data points per line per color */
+	uint32_t height; /**< Number of lines of data points per color */
+	uint32_t fraction_bits; /**< Bits of fractional part in the data
+					    points */
+	uint16_t *data[IA_CSS_SC_NUM_COLORS];
+	/**< Table data, one array for each color. Use ia_css_sc_color to
+	     index this array */
+};
+
+/** Gamma table, used for gamma correction.
+ */
+struct ia_css_gamma_table {
+	enum ia_css_vamem_type vamem_type;
+	union {
+		uint16_t vamem_1[IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE];
+		uint16_t vamem_2[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE];
+	} data;
+};
+
+/** CTC table (need to explain CTC)
+ */
+struct ia_css_ctc_table {
+	enum ia_css_vamem_type vamem_type;
+	union {
+		uint16_t vamem_1[IA_CSS_VAMEM_1_CTC_TABLE_SIZE];
+		uint16_t vamem_2[IA_CSS_VAMEM_2_CTC_TABLE_SIZE];
+	} data;
+};
+
+/** sRGB Gamma table, used for sRGB gamma correction.
+ */
+struct ia_css_rgb_gamma_table {
+	enum ia_css_vamem_type vamem_type;
+	union {
+		uint16_t vamem_1[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE];
+		uint16_t vamem_2[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE];
+	} data;
+};
+
+/** XNR table
+ */
+struct ia_css_xnr_table {
+	enum ia_css_vamem_type vamem_type;
+	union {
+		uint16_t vamem_1[IA_CSS_VAMEM_1_XNR_TABLE_SIZE];
+		uint16_t vamem_2[IA_CSS_VAMEM_2_XNR_TABLE_SIZE];
+	} data;
+};
+
+/** Multi-Axes Color Correction (MACC) table. */
+struct ia_css_macc_table {
+	int16_t data[IA_CSS_MACC_NUM_COEFS * IA_CSS_MACC_NUM_AXES];
+};
+
+/** Advanced Noise Reduction (ANR) thresholds */
+struct ia_css_anr_thres {
+	int16_t data[13*64];
+};
+
+/** Temporal noise reduction (TNR) configuration.
+ */
+struct ia_css_tnr_config {
+	ia_css_u0_16 gain;		/**< Gain (strength) of NR */
+	ia_css_u0_16 threshold_y;	/**< Motion sensitivity for Y */
+	ia_css_u0_16 threshold_uv;	/**< Motion sensitivity for U/V */
+};
+
+/** Optical black level configuration.
+ */
+struct ia_css_ob_config {
+	enum ia_css_ob_mode mode; /**< Mode (Fixed / Raster) */
+	ia_css_u0_16 level_gr;    /**< Black level for GR pixels */
+	ia_css_u0_16 level_r;     /**< Black level for R pixels */
+	ia_css_u0_16 level_b;     /**< Black level for B pixels */
+	ia_css_u0_16 level_gb;    /**< Black level for GB pixels */
+	uint16_t start_position; /**< Start position of OB area (used for
+				      raster mode only). Valid range is [0..63]. */
+	uint16_t end_position;  /**< End position of OB area (used for
+				      raster mode only).
+				      Valid range is [start_pos..64]. */
+};
+
+/** Defect pixel correction configuration.
+ */
+struct ia_css_dp_config {
+	ia_css_u0_16 threshold; /**< The threshold of defect Pixel Correction,
+			      representing the permissible difference of
+			      intensity between one pixel and its
+			      surrounding pixels. Smaller values result
+			      in more frequent pixel corrections. */
+	ia_css_u8_8 gain;	 /**< The sensitivity of mis-correction. ISP will
+			      miss a lot of defects if the value is set
+			      too large. */
+};
+
+/** Configuration used by Bayer Noise Reduction (BNR) and
+ *  YCC noise reduction (YNR).
+ */
+struct ia_css_nr_config {
+	ia_css_u0_16 bnr_gain;	    /**< Strength of noise reduction (BNR) */
+	ia_css_u0_16 ynr_gain;	    /**< Strength of noise reduction (YNR */
+	ia_css_u0_16 direction;    /**< Sensitivity of Edge (BNR) */
+	ia_css_u0_16 threshold_cb; /**< Coring threshold for Cb (YNR) */
+	ia_css_u0_16 threshold_cr; /**< Coring threshold for Cr (YNR) */
+};
+
+/** Edge Enhancement (sharpen) configuration.
+ */
+struct ia_css_ee_config {
+	ia_css_u5_11 gain;	   /**< The strength of sharpness. */
+	ia_css_u8_8 threshold;    /**< The threshold that divides noises from
+				       edge. */
+	ia_css_u5_11 detail_gain; /**< The strength of sharpness in pell-mell
+				       area. */
+};
+
+/** Demosaic (bayer-to-rgb) configuration.
+ */
+struct ia_css_de_config {
+	ia_css_u0_16 pixelnoise;	   /**< Pixel noise used in moire elimination */
+	ia_css_u0_16 c1_coring_threshold; /**< Coring threshold for C1 */
+	ia_css_u0_16 c2_coring_threshold; /**< Coring threshold for C2 */
+};
+
+/** Gamma Correction configuration.
+  */
+struct ia_css_gc_config {
+	uint16_t gain_k1; /**< */
+	uint16_t gain_k2; /**< */
+};
+
+struct ia_css_dvs_6axis_config {
+                uint32_t width_y;
+                uint32_t height_y;
+                uint32_t width_uv;
+                uint32_t height_uv;
+                uint32_t *xcoords_y;
+                uint32_t *ycoords_y;
+                uint32_t *xcoords_uv;
+                uint32_t *ycoords_uv;   
+};
+
+/** Advanced Noise Reduction configuration.
+ *  This is also known as Low-Light.
+ */
+struct ia_css_anr_config {
+	int32_t threshold; /**< Threshold */
+	int32_t thresholds[4*4*4];
+	int32_t factors[3];
+};
+
+/** Eigen Color Demosaicing configuration.
+ */
+struct ia_css_ecd_config {
+	uint16_t zip_strength;
+	uint16_t fc_strength;
+	uint16_t fc_debias;
+};
+
+/** Y(Luma) Noise Reduction configuration.
+ */
+struct ia_css_ynr_config {
+	uint16_t edge_sense_gain_0;
+	uint16_t edge_sense_gain_1;
+	uint16_t corner_sense_gain_0;
+	uint16_t corner_sense_gain_1;
+};
+
+/** Fringe Control configuration.
+ */
+struct ia_css_fc_config {
+	uint8_t  gain_exp;
+	uint16_t gain_pos_0;
+	uint16_t gain_pos_1;
+	uint16_t gain_neg_0;
+	uint16_t gain_neg_1;
+	uint16_t crop_pos_0;
+	uint16_t crop_pos_1;
+	int16_t  crop_neg_0;
+	int16_t  crop_neg_1;
+};
+
+/** Chroma Noise Reduction configuration.
+ */
+struct ia_css_cnr_config {
+	uint8_t coring_u;
+	uint8_t coring_v;
+	uint8_t sense_gain_vy;
+	uint8_t sense_gain_vu;
+	uint8_t sense_gain_vv;
+	uint8_t sense_gain_hy;
+	uint8_t sense_gain_hu;
+	uint8_t sense_gain_hv;
+};
+
+/** MACC
+ */
+struct ia_css_macc_config {
+	uint8_t exp; /**< */
+};
+
+/** Chroma Tone Control configuration.
+ */
+struct ia_css_ctc_config {
+	uint16_t y0;
+	uint16_t y1;
+	uint16_t y2;
+	uint16_t y3;
+	uint16_t y4;
+	uint16_t y5;
+	uint16_t ce_gain_exp;
+	uint16_t x1;
+	uint16_t x2;
+	uint16_t x3;
+	uint16_t x4;
+};
+
+/** Anti-Aliasing configuration.
+ */
+struct ia_css_aa_config {
+	uint16_t scale;
+};
+
+/** Chroma Enhancement configuration.
+ */
+struct ia_css_ce_config {
+	ia_css_u0_16 uv_level_min; /**< */
+	ia_css_u0_16 uv_level_max; /**< */
+};
+
+/** Color Correction Matrix (YCgCo to RGB) settings.
+ *  The data is
+ *  s(13-IA_CSS_YUV2RGB_CCM_COEF_SHIFT).IA_CSS_YUV2RGB_CCM_COEF_SHIFT
+ *  fixed point.
+ */
+struct ia_css_yuv2rgb_cc_config {
+	int32_t matrix[3 * 3]; /**< YUV2RGB conversion matrix, signed
+	<13-IA_CSS_YUV2RGB_CCM_COEF_SHIFT>.<IA_CSS_YUV2RGB_CCM_COEF_SHIFT> */
+};
+
+/** Color Space Conversion (RGB to YUV) settings.
+ *  The data is
+ *  s(13-IA_CSS_RGB2YUV_CSC_COEF_SHIFT).IA_CSS_RGB2YUV_CSC_COEF_SHIFT
+ *  fixed point.
+ */
+struct ia_css_rgb2yuv_cc_config {
+	int32_t matrix[3 * 3]; /**< RGB2YUV conversion matrix, signed
+	<13-IA_CSS_RGB2YUV_CSC_COEF_SHIFT>.<IA_CSS_RGB2YUV_CSC_COEF_SHIFT> */
+};
+
+/** 3A configuration. This configures the 3A statistics collection
+ *  module.
+ */
+struct ia_css_3a_config {
+	ia_css_u0_16 ae_y_coef_r;	/**< Weight of R for Y */
+	ia_css_u0_16 ae_y_coef_g;	/**< Weight of G for Y */
+	ia_css_u0_16 ae_y_coef_b;	/**< Weight of B for Y */
+	ia_css_u0_16 awb_lg_high_raw;	/**< AWB level gate high for raw */
+	ia_css_u0_16 awb_lg_low;	/**< AWB level gate low */
+	ia_css_u0_16 awb_lg_high;	/**< AWB level gate high */
+	ia_css_s0_15 af_fir1_coef[7];	/**< AF FIR coefficients of fir1 */
+	ia_css_s0_15 af_fir2_coef[7];	/**< AF FIR coefficients of fir2 */
+};
+
+/** eXtra Noise Reduction configuration.
+ */
+struct ia_css_xnr_config {
+	uint32_t threshold;  /**< Threshold */
+};
+
+/**
+ * Digital zoom:
+ * This feature is currently available only for video, but will become
+ * available for preview and capture as well.
+ * Set the digital zoom factor, this is a logarithmic scale. The actual zoom
+ * factor will be 64/x.
+ * Setting dx or dy to 0 disables digital zoom for that direction.
+ */
+struct ia_css_dz_config {
+	uint32_t dx;
+	uint32_t dy;
+};
+
+/** The still capture mode, this can be RAW (simply copy sensor input to DDR),
+ *  Primary ISP, the Advanced ISP (GDC) or the low-light ISP (ANR).
+ */
+enum ia_css_capture_mode {
+	IA_CSS_CAPTURE_MODE_RAW,      /**< no processing, copy data only */
+	IA_CSS_CAPTURE_MODE_BAYER,    /**< pre ISP (bayer capture) */
+	IA_CSS_CAPTURE_MODE_PRIMARY,  /**< primary ISP */
+	IA_CSS_CAPTURE_MODE_ADVANCED, /**< advanced ISP (GDC) */
+	IA_CSS_CAPTURE_MODE_LOW_LIGHT /**< low light ISP (ANR) */
+};
+
+struct ia_css_capture_config {
+	enum ia_css_capture_mode mode; /**< Still capture mode */
+	uint32_t enable_xnr;	       /**< Enable/disable XNR */
+	uint32_t enable_capture_pp;
+	/**< Enable/disable the post-processing binary.
+	     This is for testing purposes only! */
+	uint32_t enable_raw_output;
+};
+
+/** ISP filter configuration. This is a collection of configurations
+ *  for each of the ISP filters (modules).
+ *
+ *  NOTE! The contents of all pointers is copied when get or set with the
+ *  exception of the shading and morph tables. For these we only copy the
+ *  pointer, so the caller must make sure the memory contents of these pointers
+ *  remain valid as long as they are used by the CSS. This will be fixed in the
+ *  future by copying the contents instead of just the pointer.
+ */
+struct ia_css_isp_config {
+	struct ia_css_wb_config   *wb_config;  /**< White Balance config */
+	struct ia_css_cc_config   *cc_config;  /**< Color Correction config */
+	struct ia_css_tnr_config  *tnr_config; /**< Temporal Noise Reduction */
+	struct ia_css_ecd_config  *ecd_config; /**< Eigen Color Demosaicing */
+	struct ia_css_ynr_config  *ynr_config; /**< Y(Luma) Noise Reduction */
+	struct ia_css_fc_config   *fc_config;  /**< Fringe Control */
+	struct ia_css_cnr_config  *cnr_config; /**< Chroma Noise Reduction */
+	struct ia_css_macc_config *macc_config;  /**< MACC */
+	struct ia_css_ctc_config  *ctc_config; /**< Chroma Tone Control */
+	struct ia_css_aa_config   *aa_config;  /**< Anti-Aliasing */
+	struct ia_css_ce_config   *ce_config;
+	struct ia_css_dvs_6axis_config *dvs_6axis_config;
+	struct ia_css_ob_config   *ob_config;  /**< Objective Black config */
+	struct ia_css_dp_config   *dp_config;  /**< Dead Pixel config */
+	struct ia_css_nr_config   *nr_config;  /**< Noise Reduction config */
+	struct ia_css_ee_config   *ee_config;  /**< Edge Enhancement config */
+	struct ia_css_de_config   *de_config;  /**< Demosaic config */
+	struct ia_css_gc_config   *gc_config;  /**< Gamma Correction config */
+	struct ia_css_anr_config  *anr_config; /**< Advanced Noise Reduction */
+	struct ia_css_3a_config   *s3a_config; /**< 3A Statistics config */
+	struct ia_css_xnr_config  *xnr_config; /**< eXtra Noise Reduction */
+	struct ia_css_dz_config   *dz_config;  /**< Digital Zoom */
+	struct ia_css_cc_config *yuv2rgb_cc_config; /**< Color
+							Correction config */
+	struct ia_css_cc_config *rgb2yuv_cc_config; /**< Color
+							Correction config */
+	struct ia_css_macc_table  *macc_table;
+	struct ia_css_gamma_table *gamma_table;
+	struct ia_css_ctc_table   *ctc_table;
+	struct ia_css_xnr_table   *xnr_table;
+	struct ia_css_rgb_gamma_table *r_gamma_table;
+	struct ia_css_rgb_gamma_table *g_gamma_table;
+	struct ia_css_rgb_gamma_table *b_gamma_table;
+	struct ia_css_vector      *motion_vector; /**< For 2-axis DVS */
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_morph_table   *morph_table;
+	struct ia_css_dvs_coefficients *dvs_coefs; /**< DVS coefficients */
+	struct ia_css_dvs2_coefficients *dvs2_coefs; /**< DVS 2.0 coefficients */
+	struct ia_css_capture_config   *capture_config;
+	struct ia_css_anr_thres   *anr_thres;
+};
+
+/** 3A statistics point. This structure describes the data stored
+ *  in each 3A grid point.
+ */
+struct ia_css_3a_output {
+	int32_t ae_y;    /**< */
+	int32_t awb_cnt; /**< */
+	int32_t awb_gr;  /**< */
+	int32_t awb_r;   /**< */
+	int32_t awb_b;   /**< */
+	int32_t awb_gb;  /**< */
+	int32_t af_hpf1; /**< */
+	int32_t af_hpf2; /**< */
+};
+
+struct ia_css_3a_rgby_output {
+	uint32_t r;    /**< */
+	uint32_t g; /**< */
+	uint32_t b;  /**< */
+	uint32_t y;   /**< */
+};
+
+/** DVS 1.0 Coefficients.
+ */
+
+struct ia_css_dvs_coefficients {
+	struct ia_css_dvs_grid_info grid;
+	int16_t *hor_coefs;
+	int16_t *ver_coefs;
+};
+
+/** DVS 1.0 Statistics
+ */
+
+struct ia_css_dvs_statistics {
+	struct ia_css_dvs_grid_info grid;
+	int32_t *hor_proj;
+	int32_t *ver_proj;
+};
+
+/** DVS 2.0 Coefficient types. This structure contains 4 pointers to
+ *  arrays that contain the coeffients for each type.
+ */
+struct ia_css_dvs2_coef_types {
+  int16_t *odd_real; /**< real part of the odd coefficients*/
+  int16_t *odd_imag; /**< imaginary part of the odd coefficients*/
+  int16_t *even_real;/**< real part of the even coefficients*/
+  int16_t *even_imag;/**< imaginary part of the even coefficients*/
+};
+
+/** DVS 2.0 Coefficients. This structure describes the coefficients that are needed for the dvs statistics.
+ *  e.g. hor_coefs.odd_real is the pointer to int16_t[grid.num_hor_coefs] containing the horizontal odd real 
+ *  coefficients.
+ */
+struct ia_css_dvs2_coefficients {
+	struct ia_css_dvs_grid_info grid;        /**< grid info contains the dimensions of the dvs grid */
+	struct ia_css_dvs2_coef_types hor_coefs; /**< struct with pointers that contain the horizontal coefficients */
+	struct ia_css_dvs2_coef_types ver_coefs; /**< struct with pointers that contain the vertical coefficients */
+};
+
+/** DVS 2.0 Statistic types. This structure contains 4 pointers to
+ *  arrays that contain the statistics for each type.
+ */
+struct ia_css_dvs2_stat_types {
+  int32_t *odd_real; /**< real part of the odd statistics*/
+  int32_t *odd_imag; /**< imaginary part of the odd statistics*/
+  int32_t *even_real;/**< real part of the even statistics*/
+  int32_t *even_imag;/**< imaginary part of the even statistics*/
+};
+
+/** DVS 2.0 Statistics. This structure describes the statistics that are generated using the provided coefficients.
+ *  e.g. hor_prod.odd_real is the pointer to int16_t[grid.aligned_height][grid.aligned_width] containing 
+ *  the horizontal odd real statistics. Valid statistics data area is int16_t[0..grid.height-1][0..grid.width-1]
+ */
+struct ia_css_dvs2_statistics {
+	struct ia_css_dvs_grid_info grid;       /**< grid info contains the dimensions of the dvs grid */
+	struct ia_css_dvs2_stat_types hor_prod; /**< struct with pointers that contain the horizontal statistics */
+	struct ia_css_dvs2_stat_types ver_prod; /**< struct with pointers that contain the vertical statistics */
+};
+
+struct ia_css_3a_statistics {
+	struct ia_css_3a_grid_info    grid;
+	struct ia_css_3a_output      *data;
+	struct ia_css_3a_rgby_output *rgby_data;
+};
+
+#endif /* _IA_CSS_TYPES_H_ */
diff --git a/drivers/media/atomisp2/css2400/input_system_init.c b/drivers/media/atomisp2/css2400/input_system_init.c
new file mode 100644
index 0000000..67b3bbb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/input_system_init.c
@@ -0,0 +1,68 @@
+#include "input_system.h"
+
+#ifdef HAS_INPUT_SYSTEM_VERSION_2
+#include "input_system_init.h"
+#include <linux/string.h>
+
+input_system_error_t ia_css_input_system_init(void)
+{
+	backend_channel_cfg_t	backend_ch0; // AM: Initialize!
+	backend_channel_cfg_t	backend_ch1; // AM: Initialize!
+	target_cfg2400_t 	targetB; // AM: Initialize!
+	target_cfg2400_t 	targetC; // AM: Initialize!
+	uint32_t		acq_mem_region_size = 24;
+	uint32_t		acq_nof_mem_regions = 2;
+	input_system_error_t error=INPUT_SYSTEM_ERR_NO_ERROR;
+
+	memset(&backend_ch0,0,sizeof(backend_channel_cfg_t));
+	memset(&backend_ch1,0,sizeof(backend_channel_cfg_t));
+	memset(&targetB,0,sizeof(targetB));
+	memset(&targetC,0,sizeof(targetC));
+
+	error=(input_system_configuration_reset());
+	if( error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error=(input_system_csi_xmem_channel_cfg(
+		0,						//ch_id 
+		INPUT_SYSTEM_PORT_A,	//port
+		backend_ch0,			//backend_ch
+		32,						//mem_region_size
+		6,						//nof_mem_regions
+		acq_mem_region_size,	//acq_mem_region_size
+		acq_nof_mem_regions,	//acq_nof_mem_regions
+		targetB,				//target
+		3));//nof_xmem_buffers
+	if( error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error=(input_system_csi_xmem_channel_cfg(
+		1,						//ch_id 
+		INPUT_SYSTEM_PORT_B,	//port
+		backend_ch0,			//backend_ch
+		16,						//mem_region_size
+		3,						//nof_mem_regions
+		acq_mem_region_size,	//acq_mem_region_size
+		acq_nof_mem_regions,	//acq_nof_mem_regions
+		targetB,				//target
+		3));//nof_xmem_buffers
+	if(error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error=(input_system_csi_xmem_channel_cfg(
+		2,						
+		INPUT_SYSTEM_PORT_C,	//input_system_csi_port_t port
+		backend_ch1,			//backend_channel_cfg_t	backend_ch
+		32,						//uint32_t 				mem_region_size
+		3,						//uint32_t 				nof_mem_regions
+		acq_mem_region_size,	//uint32_t 				acq_mem_region_size
+		acq_nof_mem_regions,	//uint32_t 				acq_nof_mem_regions
+		targetC,				//target_cfg2400_t 		target
+		2));						//uint32_t 				nof_xmem_buffers
+	if(error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error=(input_system_configuration_commit());
+    return error;
+}
+#endif
diff --git a/drivers/media/atomisp2/css2400/input_system_init.h b/drivers/media/atomisp2/css2400/input_system_init.h
new file mode 100644
index 0000000..55805da
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/input_system_init.h
@@ -0,0 +1,11 @@
+#ifndef __input_system_init__
+#define __input_system_init__
+#include "input_system.h"
+
+#ifdef HAS_INPUT_SYSTEM_VERSION_2
+
+input_system_error_t ia_css_input_system_init(void);
+
+#endif
+
+#endif /*__input_system_init__*/
diff --git a/drivers/media/atomisp2/css2400/sh_css.c b/drivers/media/atomisp2/css2400/sh_css.c
new file mode 100644
index 0000000..c3fe411
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css.c
@@ -0,0 +1,8572 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+/*! \file */
+
+#include "ia_css.h"
+#include "sh_css_hrt.h"		/* only for file 2 MIPI */
+#include "sh_css_binary.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"
+#include "sh_css_sp_start.h"
+#include "sh_css_rx.h"
+#include "sh_css_defs.h"
+#include "sh_css_firmware.h"
+#include "ia_css_accelerate.h"
+#include "sh_css_params.h"
+#include "sh_css_params_internal.h"
+#include "sh_css_param_shading.h"
+#include "sh_css_refcount.h"
+#include "ia_css_i_rmgr.h"
+#include "sh_css_debug.h"
+#include "sh_css_debug_internal.h"
+#include "ia_css_memory_access.h"
+#include "ia_css_device_access.h"
+#include "sh_css_legacy.h"
+#include "ia_css_acc.h"
+#include "ia_css_stream.h"
+//#include "ia_css_stream_manager.h"
+//#include "ia_css_i_host_rmgr_gen_shared.h"
+#include "input_system_init.h"
+
+#include "memory_access.h"
+#include "tag.h"
+#include "assert_support.h"
+#include "queue.h"			/* host2sp_enqueue_frame_data() */
+#include "sw_event.h"			/* encode_sw_event */
+#include "input_formatter.h"/* input_formatter_cfg_t,
+	input_formatter_get_alignment(), ... */
+#include "input_system.h"
+#include "mmu_device.h"		/* mmu_set_page_table_base_index(), ... */
+#include "gdc_device.h"		/* HRT_GDC_N */
+#include "irq.h"			/* virq */
+#include "sp.h"				/* cnd_sp_irq_enable() */
+#include "isp.h"			/* cnd_isp_irq_enable, ISP_VEC_NELEMS */
+#define __INLINE_GPIO__
+#include "gpio.h"
+#include "timed_ctrl.h"
+#include "platform_support.h" /* hrt_sleep() */
+
+#define WITH_PC_MONITORING  0
+#define MAX_NUM_PIPES 20
+#define MAX_NUM_SP_THREADS 4
+#define PIPE_NUM_EMPTY_TOKEN 0xFFFF
+#define PIPE_NUM_RESERVED_TOKEN 0x1
+#define SP_THREAD_EMPTY_TOKEN 0x0
+#define SP_THREAD_RESERVED_TOKEN 0x1
+
+#define SH_CSS_VIDEO_BUFFER_ALIGNMENT 128
+
+#if WITH_PC_MONITORING
+#define MULTIPLE_SAMPLES 1
+#define NOF_SAMPLES      60
+#include "linux/kthread.h"
+#include "linux/sched.h"
+#include "linux/delay.h"
+#include "sh_css_metrics.h"
+static int thread_alive;
+#endif /* WITH_PC_MONITORING */
+
+#define DVS_REF_TESTING 0
+#if DVS_REF_TESTING
+#include <stdio.h>
+#endif
+
+/* Name of the sp program: should not be built-in */
+#define SP_PROG_NAME "sp"
+
+/* for JPEG, we don't know the length of the image upfront,
+ * but since we support sensor upto 16MP, we take this as
+ * upper limit.
+ */
+#define JPEG_BYTES (16 * 1024 * 1024)
+
+#define IS_ODD(a)              ((a) & 0x1)
+
+#define IMPLIES(a, b)           (!(a) || (b))   /* A => B */
+
+#define STATS_ENABLED(stage) (stage && stage->binary && stage->binary->info && \
+	(stage->binary->info->enable.s3a || stage->binary->info->enable.dis))
+
+#define DEFAULT_IF_CONFIG \
+{ \
+	0,          /* start_line */\
+	0,          /* start_column */\
+	0,          /* left_padding */\
+	0,          /* cropped_height */\
+	0,          /* cropped_width */\
+	0,          /* deinterleaving */\
+	0,          /*.buf_vecs */\
+	0,          /* buf_start_index */\
+	0,          /* buf_increment */\
+	0,          /* buf_eol_offset */\
+	false,      /* is_yuv420_format */\
+	false       /* block_no_reqs */\
+}
+
+#define DEFAULT_PLANES { {0, 0, 0, 0} }
+
+#define DEFAULT_FRAME \
+{ \
+	DEFAULT_FRAME_INFO,            /* info */ \
+	0,                             /* data */ \
+	0,                             /* data_bytes */ \
+	-1,                            /* dynamic_data_index */ \
+	IA_CSS_FRAME_FLASH_STATE_NONE, /* flash_state */ \
+	0,                             /* exp_id */ \
+	0,			       /* frame_nr */ \
+	false,                         /* valid */ \
+	false,                         /* contiguous  */ \
+	{ 0 }                          /* planes */ \
+}
+
+#define DEFAULT_PIPELINE \
+{ \
+	IA_CSS_PIPE_ID_PREVIEW, /* pipe_id */ \
+	NULL,                   /* stages */ \
+	true,                   /* reload */ \
+	NULL,                   /* current_stage */ \
+	0,                      /* num_stages */ \
+	DEFAULT_FRAME,          /* in_frame */ \
+	DEFAULT_FRAME,          /* out_frame */ \
+	DEFAULT_FRAME,           /* vf_frame */ \
+	IA_CSS_FRAME_DELAY_1     /* frame_delay */ \
+}
+
+#define DEFAULT_PIPE \
+{ \
+	IA_CSS_PIPE_ID_ACC, \
+	0,                         /* pipe_num */ \
+	false,                     /* zoom_changed */ \
+	NULL,                      /* shading_table */ \
+	DEFAULT_PIPELINE,          /* pipeline */ \
+	DEFAULT_FRAME_INFO,        /* output_info */\
+	DEFAULT_FRAME_INFO,        /* vf_output_info */ \
+	DEFAULT_FRAME_INFO,        /* yuv_ds_input_info */\
+	false,                     /* disable_vf_pp */\
+	false,                     /* disable_capture_pp */ \
+	false,                     /* input_needs_raw_binning */ \
+	NULL,                      /* output_stage */\
+	NULL,                      /* vf_stage */ \
+	IA_CSS_CAPTURE_MODE_PRIMARY,/* capture_mode */ \
+	false,                     /* xnr */ \
+	false,                     /* xnr */ \
+	{ 0, 0 },                  /* dvs_envelope */ \
+	IA_CSS_FRAME_DELAY_1,      /* dvs_frame_delay */ \
+	0,                         /* num_invalid_frames */ \
+	false,                     /* enable_yuv_ds */ \
+	false,                     /* enable_high_speed */ \
+	false,                     /* enable_dvs_6axis */ \
+	true,                      /* enable_viewfinder */ \
+	true,                      /* enable_dz */ \
+	false,                     /* enable_reduced_pipe */ \
+	1,                         /* isp_pipe_version */ \
+	NULL,                      /* stream */ \
+	NULL,                      /* new_pipe */ \
+	DEFAULT_FRAME,             /* out_frame */ \
+	DEFAULT_FRAME,             /* vf_frame */ \
+	{ NULL },                  /* continuous_frames */\
+	{ DEFAULT_PREVIEW_SETTINGS } /* pipe */ \
+}
+
+struct sh_css_preview_settings {
+	struct sh_css_binary copy_binary;
+	struct sh_css_binary preview_binary;
+	struct sh_css_binary vf_pp_binary;
+	struct sh_css_pipe *copy_pipe;
+	struct sh_css_pipe *capture_pipe;
+};
+
+#define DEFAULT_PREVIEW_SETTINGS \
+{ \
+	DEFAULT_BINARY_SETTINGS,  /* copy_binary */\
+	DEFAULT_BINARY_SETTINGS,  /* preview_binary */\
+	DEFAULT_BINARY_SETTINGS,  /* vf_pp_binary */\
+	NULL,                     /* copy_pipe */\
+	NULL,                     /* capture_pipe */\
+}
+
+struct sh_css_capture_settings {
+	struct sh_css_binary copy_binary;
+	struct sh_css_binary primary_binary;
+	struct sh_css_binary pre_isp_binary;
+	struct sh_css_binary gdc_binary;
+	struct sh_css_binary post_isp_binary;
+	struct sh_css_binary pre_anr_binary;
+	struct sh_css_binary anr_binary;
+	struct sh_css_binary post_anr_binary;
+	struct sh_css_binary capture_pp_binary;
+	struct sh_css_binary vf_pp_binary;
+	struct ia_css_frame *capture_pp_frame;
+};
+
+#define DEFAULT_CAPTURE_SETTINGS \
+{ \
+	DEFAULT_BINARY_SETTINGS,     /* copy_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* primary_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* pre_isp_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* gdc_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* post_isp_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* pre_anr_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* anr_binary */\
+        DEFAULT_BINARY_SETTINGS,     /* post_anr_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* capture_pp_binary */\
+	DEFAULT_BINARY_SETTINGS,     /* vf_pp_binary */\
+	NULL,                        /* capture_pp_frame */\
+}
+
+struct sh_css_video_settings {
+	struct sh_css_binary copy_binary;
+	struct sh_css_binary video_binary;
+	struct sh_css_binary vf_pp_binary;
+	struct ia_css_frame *ref_frames[NUM_VIDEO_REF_FRAMES];
+	struct ia_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];
+	struct ia_css_frame *vf_pp_in_frame;
+	struct sh_css_pipe *copy_pipe;
+	struct sh_css_pipe *capture_pipe;
+};
+
+#define DEFAULT_VIDEO_SETTINGS \
+{ \
+	DEFAULT_BINARY_SETTINGS,/* copy_binary */ \
+	DEFAULT_BINARY_SETTINGS,/* video_binary */ \
+	DEFAULT_BINARY_SETTINGS,/* vf_pp_binary */ \
+	{ NULL },                /* ref_frames */ \
+	{ NULL },                /* tnr_frames */ \
+	NULL,                    /* vf_pp_in_frame */ \
+	NULL,                    /* copy_pipe */ \
+	NULL,                    /* capture_pipe */ \
+}
+
+struct ia_css_pipe {
+	uint8_t                         pipe_num;
+	bool                            stop_requested;
+	struct ia_css_pipe_config       config;
+	struct ia_css_pipe_extra_config extra_config;
+	struct ia_css_pipe_info         info;
+	struct sh_css_pipe             *old_pipe;
+};
+
+struct sh_css_pipe {
+	enum ia_css_pipe_id          mode;
+	uint8_t                      pipe_num;
+	bool                         zoom_changed;
+	struct ia_css_shading_table *shading_table;
+	struct sh_css_pipeline       pipeline;
+	struct ia_css_frame_info     output_info;
+	struct ia_css_frame_info     vf_output_info;
+	struct ia_css_frame_info     yuv_ds_input_info;
+	bool                         disable_vf_pp;
+	bool                         disable_capture_pp;
+	bool                         input_needs_raw_binning;
+	struct ia_css_fw_info	    *output_stage; /* extra output stage */
+	struct ia_css_fw_info	    *vf_stage;     /* extra vf stage */
+	enum ia_css_capture_mode     capture_mode;
+	bool 		     	     enable_capture_pp;
+	bool                         xnr;
+	struct ia_css_resolution     dvs_envelope;
+	enum ia_css_frame_delay      dvs_frame_delay; /*is this the best implementation ?? */
+	int                          num_invalid_frames;
+	bool                         enable_yuv_ds;
+	bool                         enable_high_speed;
+	bool                         enable_dvs_6axis;
+	bool                         enable_viewfinder;
+	bool                         enable_dz;
+	bool                         enable_reduced_pipe;
+	unsigned int                 isp_pipe_version;
+	struct ia_css_stream         *stream;
+	struct ia_css_pipe           *new_pipe;
+	struct ia_css_frame          out_frame_struct;
+	struct ia_css_frame          vf_frame_struct;
+	struct ia_css_frame         *continuous_frames[NUM_CONTINUOUS_FRAMES];
+	union {
+		struct sh_css_preview_settings preview;
+		struct sh_css_video_settings   video;
+		struct sh_css_capture_settings capture;
+	} pipe;
+};
+
+struct sh_css {
+	struct ia_css_pipe            *active_pipes[MAX_NUM_PIPES];
+	void *(*malloc) (size_t bytes, bool zero_mem);
+	void (*free) (void *ptr);
+	void (*flush) (struct ia_css_acc_fw *fw);
+	bool                           check_system_idle;
+	bool                           stop_copy_preview;
+	unsigned int                   num_cont_raw_frames;
+	unsigned int                   num_mipi_frames;
+	struct ia_css_frame	      *mipi_frames[NUM_MIPI_FRAMES];
+	bool                           start_sp_copy;
+	hrt_vaddress                   sp_bin_addr;
+	hrt_data                       page_table_base_index;
+	unsigned int                   size_mem_words;
+	bool                           contiguous;
+	enum ia_css_irq_type           irq_type;
+};
+
+#define DEFAULT_CSS \
+{ \
+	{NULL, NULL, NULL, NULL },/* active_pipes */ \
+	NULL,                     /* malloc */ \
+	NULL,                     /* free */ \
+	NULL,                     /* flush */ \
+	true,                     /* check_system_idle */ \
+	false,                    /* stop_copy_preview */ \
+	NUM_CONTINUOUS_FRAMES,    /* num_cont_raw_frames */ \
+	NUM_MIPI_FRAMES,	  /* num_mipi_frames */ \
+	{ NULL }, 		  /* mipi_frames */ \
+	false,                    /* start_sp_copy */ \
+	0,                        /* sp_bin_addr */ \
+	0,                        /* page_table_base_index */ \
+	0,                        /* size_mem_words */ \
+	true,                     /* contiguous */ \
+	IA_CSS_IRQ_TYPE_EDGE      /* irq_type */ \
+}
+
+#if defined(HAS_RX_VERSION_2)
+
+#define DEFAULT_MIPI_CONFIG \
+{ \
+	MONO_4L_1L_0L, \
+	MIPI_PORT0_ID, \
+	0xffff4, \
+	0, \
+	0x28282828, \
+	0x04040404, \
+	MIPI_PREDICTOR_NONE, \
+	false \
+}
+
+#elif defined(HAS_RX_VERSION_1) || defined(HAS_NO_RX)
+
+#define DEFAULT_MIPI_CONFIG \
+{ \
+	MIPI_PORT1_ID, \
+	1, \
+	0xffff4, \
+	0, \
+	0, \
+	MIPI_PREDICTOR_NONE, \
+	false \
+}
+
+#else
+#error "sh_css.c: RX version must be one of {RX_VERSION_1, RX_VERSION_2, NO_RX}"
+#endif
+
+int (*sh_css_printf) (const char *fmt, ...) = NULL;
+
+static struct sh_css my_css;
+
+/* static variables, temporarily used in load_<mode>_binaries.
+   Declaring these inside the functions increases the size of the
+   stack frames beyond the acceptable 128 bytes. */
+static struct sh_css_binary_descr preview_descr,
+				  vf_pp_descr,
+				  copy_descr,
+				  prim_descr,
+				  pre_gdc_descr,
+				  gdc_descr,
+				  post_gdc_descr,
+				  pre_anr_descr,
+				  anr_descr,
+				  post_anr_descr,
+				  video_descr,
+				  capture_pp_descr;
+
+/* pqiao NOTICE: this is for css internal buffer recycling when stopping pipeline,
+   this array is temporary and will be replaced by resource manager*/
+#define MAX_HMM_BUFFER_NUM (SH_CSS_NUM_BUFFER_QUEUES * (SH_CSS_CIRCULAR_BUF_NUM_ELEMS + 2))
+static struct ia_css_i_host_rmgr_vbuf_handle *hmm_buffer_record_h[MAX_HMM_BUFFER_NUM];
+
+static uint32_t pipe_num_counter = 0;
+static uint32_t ref_count_mipi_allocation = 0;
+static uint32_t pipe_num_list[MAX_NUM_PIPES];
+static unsigned int sp_thread_list[MAX_NUM_SP_THREADS];
+static unsigned int pipe_num_to_sp_thread[MAX_NUM_PIPES];
+
+#define GPIO_FLASH_PIN_MASK (1 << HIVE_GPIO_STROBE_TRIGGER_PIN)
+
+static enum sh_css_buffer_queue_id
+	sh_css_buf_type_2_internal_queue_id[IA_CSS_BUFFER_TYPE_NUM] = {
+		sh_css_s3a_buffer_queue,
+		sh_css_dis_buffer_queue,
+		sh_css_input_buffer_queue,
+		sh_css_output_buffer_queue,
+		sh_css_vf_output_buffer_queue,
+		sh_css_output_buffer_queue,
+		sh_css_input_buffer_queue,
+		sh_css_output_buffer_queue,
+		sh_css_param_buffer_queue };
+
+/**
+ * Local prototypes
+ */
+static void
+init_pipe_number(void);
+
+static enum ia_css_err
+ia_css_pipe_dequeue_unused_buffer(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+ia_css_pipe_load_extension(struct ia_css_pipe *pipe,
+			   struct ia_css_fw_info *firmware);
+
+static void
+ia_css_pipe_unload_extension(struct ia_css_pipe *pipe,
+			     struct ia_css_fw_info *firmware);
+
+static void
+sh_css_init_host_sp_control_vars(void);
+
+static void
+sh_css_mmu_set_page_table_base_index(hrt_data base_index);
+
+static bool
+need_capture_pp(const struct sh_css_pipe *pipe);
+
+static enum ia_css_err
+sh_css_pipe_load_binaries(struct sh_css_pipe *pipe);
+
+static
+enum ia_css_err sh_css_pipe_get_viewfinder_frame_info(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *info);
+
+static enum ia_css_err
+sh_css_pipe_get_output_frame_info(struct sh_css_pipe *pipe,
+				  struct ia_css_frame_info *info);
+
+static enum ia_css_err
+capture_start(struct sh_css_pipe *pipe);
+
+static enum ia_css_err
+video_start(struct sh_css_pipe *pipe);
+
+static bool copy_on_sp(
+	struct sh_css_pipe *pipe);
+
+static enum ia_css_err
+construct_copy_pipe(struct sh_css_pipe *pipe,
+		    unsigned max_input_width,
+		    struct ia_css_frame *out_frame);
+
+static enum ia_css_err
+construct_capture_pipe(struct sh_css_pipe *pipe);
+
+static enum ia_css_err
+init_frame_planes(struct ia_css_frame *frame);
+
+
+static void
+free_mipi_frames(struct sh_css_pipe *pipe, bool uninit);
+
+
+#if 0
+static enum ia_css_err
+sh_css_pipeline_stop(struct sh_css_pipe *pipe);
+#endif
+
+static struct sh_css_binary *
+ia_css_pipe_get_3a_binary (const struct ia_css_pipe *pipe);
+
+static void
+sh_css_pipe_free_shading_table(struct sh_css_pipe *pipe)
+{
+	if (pipe->shading_table)
+		ia_css_shading_table_free(pipe->shading_table);
+	pipe->shading_table = NULL;
+}
+
+static enum ia_css_err
+check_frame_info(const struct ia_css_frame_info *info)
+{
+	if (info->res.width == 0 || info->res.height == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+check_vf_info(const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err;
+	err = check_frame_info(info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (info->res.width > sh_css_max_vf_width()*2)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+check_vf_out_info(const struct ia_css_frame_info *out_info,
+		  const struct ia_css_frame_info *vf_info)
+{
+	enum ia_css_err err;
+	err = check_frame_info(out_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = check_vf_info(vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (vf_info->res.width > out_info->res.width ||
+	    vf_info->res.height > out_info->res.height)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+check_res(unsigned int width, unsigned int height)
+{
+	if (width  == 0   ||
+	    height == 0   ||
+	    IS_ODD(width) ||
+	    IS_ODD(height)) {
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	return IA_CSS_SUCCESS;
+}
+#if 0
+static enum ia_css_err
+check_null_res(unsigned int width, unsigned int height)
+{
+	if (IS_ODD(width) || IS_ODD(height))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	return IA_CSS_SUCCESS;
+}
+#endif
+static bool
+input_format_is_raw(enum ia_css_stream_format format)
+{
+	return format == IA_CSS_STREAM_FORMAT_RAW_6 ||
+	    format == IA_CSS_STREAM_FORMAT_RAW_7 ||
+	    format == IA_CSS_STREAM_FORMAT_RAW_8 ||
+	    format == IA_CSS_STREAM_FORMAT_RAW_10 ||
+	    format == IA_CSS_STREAM_FORMAT_RAW_12;
+	/* raw_14 and raw_16 are not supported as input formats to the ISP.
+	 * They can only be copied to a frame in memory using the
+	 * copy binary.
+	 */
+}
+
+static bool
+input_format_is_yuv(enum ia_css_stream_format format)
+{
+	return format == IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY ||
+	    format == IA_CSS_STREAM_FORMAT_YUV420_8 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV420_10 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV422_8 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV422_10;
+}
+
+static enum ia_css_err
+check_input(struct sh_css_pipe *pipe, bool must_be_raw)
+{
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe->stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe->stream->config.effective_res.width == 0 ||
+	    pipe->stream->config.effective_res.height == 0) {
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (must_be_raw &&
+	    !input_format_is_raw(pipe->stream->config.format)) {
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_frame_format yuv420_copy_formats[] = {
+	IA_CSS_FRAME_FORMAT_NV12,
+	IA_CSS_FRAME_FORMAT_NV21,
+	IA_CSS_FRAME_FORMAT_YV12,
+	IA_CSS_FRAME_FORMAT_YUV420,
+	IA_CSS_FRAME_FORMAT_YUV420_16
+};
+/* Input network configuration functions */
+static enum ia_css_frame_format yuv422_copy_formats[] = {
+	IA_CSS_FRAME_FORMAT_NV12,
+	IA_CSS_FRAME_FORMAT_NV16,
+	IA_CSS_FRAME_FORMAT_NV21,
+	IA_CSS_FRAME_FORMAT_NV61,
+	IA_CSS_FRAME_FORMAT_YV12,
+	IA_CSS_FRAME_FORMAT_YV16,
+	IA_CSS_FRAME_FORMAT_YUV420,
+	IA_CSS_FRAME_FORMAT_YUV420_16,
+	IA_CSS_FRAME_FORMAT_YUV422,
+	IA_CSS_FRAME_FORMAT_YUV422_16,
+	IA_CSS_FRAME_FORMAT_UYVY,
+	IA_CSS_FRAME_FORMAT_YUYV
+};
+
+#define array_length(array) (sizeof(array)/sizeof(array[0]))
+
+/* Verify whether the selected output format is can be produced
+ * by the copy binary given the stream format.
+ * */
+static enum ia_css_err
+verify_copy_out_frame_format(struct sh_css_pipe *pipe)
+{
+	enum ia_css_frame_format out_fmt = pipe->output_info.format;
+	unsigned int i, found = 0;	
+
+	switch (pipe->stream->config.format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+		for (i=0; i<array_length(yuv420_copy_formats) && !found; i++)
+			found = (out_fmt == yuv420_copy_formats[i]);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+		for (i=0; i<array_length(yuv422_copy_formats) && !found; i++)
+			found = (out_fmt == yuv422_copy_formats[i]);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_YUV422_16 ||
+			 out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888 ||
+			 out_fmt == IA_CSS_FRAME_FORMAT_RGB565);
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888);
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RAW);
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_BINARY_8);
+		break;
+	default:
+		break;
+	}
+	if (!found)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+/* next function takes care of getting the settings from kernel
+ * commited to hmm / isp
+ * TODO: see if needs to be made public
+ */
+static enum ia_css_err
+sh_css_commit_isp_config(struct ia_css_stream *stream,
+			 struct sh_css_pipeline *pipeline)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_pipeline_stage *stage;
+
+	if (pipeline) {
+		/* walk through pipeline and commit settings */
+		/* TODO: check if this is needed (s3a is handled through this */
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			if (stage && stage->binary) {
+				err = sh_css_params_write_to_ddr(stream,
+								 stage->binary);
+				if (err != IA_CSS_SUCCESS)
+					return err;
+			}
+		}
+	}
+	return err;
+}
+
+static unsigned int
+sh_css_pipe_input_format_bits_per_pixel(const struct sh_css_pipe *pipe)
+{
+	return sh_css_input_format_bits_per_pixel(pipe->stream->config.format,
+						  pipe->stream->config.two_pixels_per_clock);
+}
+
+/* MW: Table look-up ??? */
+unsigned int
+sh_css_input_format_bits_per_pixel(enum ia_css_stream_format format,
+	bool two_ppc)
+{
+	unsigned int rval = 0;
+	switch (format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		rval = 8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+		rval = 10;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+		rval = 4;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+		rval = 5;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		rval = 65;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+		rval = 6;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+		rval = 7;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		rval = 12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+		if (two_ppc)
+			rval = 14;
+		else
+			rval = 12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		if (two_ppc)
+			rval = 16;
+		else
+			rval = 12;
+		break;
+	default:
+		rval = 0;
+		break;
+		
+	}
+	return rval;
+}
+
+unsigned int 
+ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream)
+{
+	int bpp = 0;
+
+	if (stream)
+		bpp = sh_css_input_format_bits_per_pixel(stream->config.format,
+						stream->config.two_pixels_per_clock);
+
+	return bpp;
+}
+/* compute the log2 of the downscale factor needed to get closest
+ * to the requested viewfinder resolution on the upper side. The output cannot
+ * be smaller than the requested viewfinder resolution.
+ */
+enum ia_css_err
+sh_css_vf_downscale_log2(const struct ia_css_frame_info *out_info,
+			 const struct ia_css_frame_info *vf_info,
+			 unsigned int *downscale_log2)
+{
+	unsigned int ds_log2 = 0;
+	unsigned int out_width = out_info ? out_info->padded_width : 0;
+
+	if (out_width == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* downscale until width smaller than the viewfinder width. We don't
+	 * test for the height since the vmem buffers only put restrictions on
+	 * the width of a line, not on the number of lines in a frame.
+	 */
+	while (out_width >= vf_info->res.width) {
+		ds_log2++;
+		out_width /= 2;
+	}
+	/* now width is smaller, so we go up one step */
+	if ((ds_log2 > 0) && (out_width < sh_css_max_vf_width()))
+		ds_log2--;
+	/* TODO: use actual max input resolution of vf_pp binary */
+	if ((out_info->res.width >> ds_log2) >= 2*sh_css_max_vf_width())
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	*downscale_log2 = ds_log2;
+	return IA_CSS_SUCCESS;
+}
+
+/* ISP expects GRBG bayer order, we skip one line and/or one row
+ * to correct in case the input bayer order is different.
+ */
+static unsigned int
+lines_needed_for_bayer_order(const struct sh_css_pipe *pipe)
+{
+	if (pipe->stream->config.bayer_order == IA_CSS_BAYER_ORDER_BGGR ||
+	    pipe->stream->config.bayer_order == IA_CSS_BAYER_ORDER_GBRG) {
+		return 1;
+	}
+	return 0;
+}
+
+static unsigned int
+columns_needed_for_bayer_order(const struct sh_css_pipe *pipe)
+{
+	if (pipe->stream->config.bayer_order == IA_CSS_BAYER_ORDER_RGGB ||
+	    pipe->stream->config.bayer_order == IA_CSS_BAYER_ORDER_GBRG) {
+		return 1;
+	}
+	return 0;
+}
+
+static enum ia_css_err
+input_start_column(struct sh_css_pipe *pipe,
+		   unsigned int bin_in,
+		   unsigned int *start_column)
+{
+	unsigned int in = pipe->stream->config.input_res.width,
+	    for_bayer = columns_needed_for_bayer_order(pipe), start;
+
+	if (bin_in + 2 * for_bayer > in)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* On the hardware, we want to use the middle of the input, so we
+	 * divide the start column by 2. */
+	start = (in - bin_in) / 2;
+	/* in case the number of extra columns is 2 or odd, we round the start
+	 * column down */
+	start &= ~0x1;
+
+	/* now we add the one column (if needed) to correct for the bayer
+	 * order).
+	 */
+	start += for_bayer;
+	*start_column = start;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+input_start_line(struct sh_css_pipe *pipe,
+		 unsigned int bin_in,
+		 unsigned int *start_line)
+{
+	unsigned int in = pipe->stream->config.input_res.height,
+	    for_bayer = lines_needed_for_bayer_order(pipe), start;
+
+	if (bin_in + 2 * for_bayer > in) {
+		sh_css_dtrace(SH_DBG_ERROR, "ERROR in input_start_line, bin_in=%u, for_bayer=%u, in=%u\n",
+			bin_in, for_bayer, in);		
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* On the hardware, we want to use the middle of the input, so we
+	 * divide the start line by 2. On the simulator, we cannot handle extra
+	 * lines at the end of the frame.
+	 */
+	start = (in - bin_in) / 2;
+	/* in case the number of extra lines is 2 or odd, we round the start
+	 * line down.
+	 */
+	start &= ~0x1;
+
+	/* now we add the one line (if needed) to correct for the bayer order*/
+	start += for_bayer;
+	*start_line = start;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+program_input_formatter(struct sh_css_pipe *pipe,
+			struct sh_css_binary *binary)
+{
+	unsigned int start_line, start_column = 0,
+		     cropped_height = binary->in_frame_info.res.height,
+		     cropped_width  = binary->in_frame_info.res.width,
+		     num_vectors,
+		     buffer_height = 2,
+		     buffer_width = binary->info->max_input_width,
+		     two_ppc = pipe->stream->config.two_pixels_per_clock,
+		     vmem_increment = 0,
+		     deinterleaving = 0,
+		     deinterleaving_b = 0,
+		     width_a = 0,
+		     width_b = 0,
+		     bits_per_pixel,
+		     vectors_per_buffer,
+		     vectors_per_line = 0,
+		     buffers_per_line = 0,
+		     buf_offset_b = 0,
+		     line_width = 0,
+		     width_b_factor = 1,
+		     start_column_b,
+		     left_padding = 0;
+	input_formatter_cfg_t	if_a_config, if_b_config;
+	enum ia_css_stream_format input_format = binary->input_format;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	uint8_t if_config_index;
+
+	/* Determine which input formatter config set is targeted. */
+	/* Index is equal to the CSI-2 port used. */
+	enum ia_css_csi2_port port;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ENTER program_input_formatter\n");
+	
+	if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR
+	 || pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR
+	) {
+		port = pipe->stream->config.source.port.port;
+	if_config_index = (uint8_t) (port - IA_CSS_CSI2_PORT_4LANE);
+	}
+	else if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY){
+		if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+	}
+	else{
+		if_config_index = 0;
+	}
+
+	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS || if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);
+
+	if (pipe->input_needs_raw_binning &&
+	    binary->info->enable.raw_binning) {
+		cropped_width *= 2;
+		cropped_width -= binary->info->left_cropping;
+		cropped_height *= 2;
+		cropped_height -= binary->info->left_cropping;
+	}
+
+	/* TODO: check to see if input is RAW and if current mode interprets
+	 * RAW data in any particular bayer order. copy binary with output
+	 * format other than raw should not result in dropping lines and/or
+	 * columns.
+	 */
+	err = input_start_line(pipe, cropped_height, &start_line);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in input_start_line\n");	
+		return err;
+	}
+	err = input_start_column(pipe, cropped_width, &start_column);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in input_start_column\n");
+		return err;
+	}
+
+	if (!left_padding)
+		left_padding = binary->left_padding;
+	if (left_padding) {
+		num_vectors = CEIL_DIV(cropped_width + left_padding,
+				       ISP_VEC_NELEMS);
+	} else {
+		num_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
+		num_vectors *= buffer_height;
+		/* todo: in case of left padding,
+		   num_vectors is vectors per line,
+		   otherwise vectors per line * buffer_height. */
+	}
+
+	start_column_b = start_column;
+
+	bits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)
+		*8 / ISP_VEC_NELEMS;
+	switch (input_format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			deinterleaving_b = 1;
+			/* half lines */
+			width_a = cropped_width * deinterleaving / 2;
+			width_b_factor = 2;
+			/* full lines */
+			width_b = width_a * width_b_factor;
+			buffer_width *= deinterleaving * 2;
+			/* Patch from bayer to yuv */
+			num_vectors *= deinterleaving;
+			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+			vectors_per_line = num_vectors / buffer_height;
+			/* Even lines are half size */
+			line_width = vectors_per_line *
+				input_formatter_get_alignment(
+				INPUT_FORMATTER0_ID) / 2;
+			start_column /= 2;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 3;
+			width_a = cropped_width * deinterleaving / 2;
+			buffer_width = buffer_width * deinterleaving / 2;
+			/* Patch from bayer to yuv */
+			num_vectors = num_vectors / 2 * deinterleaving;
+			start_column = start_column * deinterleaving / 2;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width * deinterleaving / 2;
+			buffer_width *= deinterleaving * 2;
+			num_vectors *= deinterleaving;
+			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+			vectors_per_line = num_vectors / buffer_height;
+			/* Even lines are half size */
+			line_width = vectors_per_line *
+				input_formatter_get_alignment(
+				INPUT_FORMATTER0_ID) / 2;
+			start_column *= deinterleaving;
+			start_column /= 2;
+			start_column_b = start_column;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = cropped_width * deinterleaving;
+			buffer_width  *= deinterleaving * 2;
+			num_vectors  *= deinterleaving;
+			start_column *= deinterleaving;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving * 2;
+			num_vectors  *= deinterleaving;
+			start_column *= deinterleaving;
+			buf_offset_b   = buffer_width / 2 / ISP_VEC_NELEMS;
+			start_column_b = start_column;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving;
+			num_vectors  *= deinterleaving;
+			start_column *= deinterleaving;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		num_vectors *= 2;
+		if (two_ppc) {
+			deinterleaving = 2;	/* BR in if_a, G in if_b */
+			deinterleaving_b = 1;	/* BR in if_a, G in if_b */
+			buffers_per_line = 4;
+			start_column_b = start_column;
+			start_column *= deinterleaving;
+			start_column_b *= deinterleaving_b;
+		} else {
+			deinterleaving = 3;	/* BGR */
+			buffers_per_line = 3;
+			start_column *= deinterleaving;
+		}
+		vmem_increment = 1;
+		width_a = cropped_width * deinterleaving;
+		width_b = cropped_width * deinterleaving_b;
+		buffer_width *= buffers_per_line;
+		/* Patch from bayer to rgb */
+		num_vectors = num_vectors / 2 * deinterleaving;
+		buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		if (two_ppc) {
+			vmem_increment = 2;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width / 2;
+			start_column /= 2;
+			start_column_b = start_column;
+			buf_offset_b = 1;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			if (pipe->stream->config.continuous &&
+			    binary->info->mode == SH_CSS_BINARY_MODE_COPY) {
+				/* No deinterleaving for sp copy */
+				deinterleaving = 1;
+			}
+			width_a = cropped_width;
+			/* Must be multiple of deinterleaving */
+			num_vectors = CEIL_MUL(num_vectors, deinterleaving);
+		}
+		buffer_height *= 2;
+		if (pipe->stream->config.continuous)
+			buffer_height *= 2;
+		vectors_per_line = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
+		vectors_per_line = CEIL_MUL(vectors_per_line, deinterleaving);
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		if (two_ppc) {
+			num_vectors *= 2;
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = width_b = cropped_width;
+			/* B buffer is one line further */
+			buf_offset_b = buffer_width / ISP_VEC_NELEMS;
+			bits_per_pixel *= 2;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = cropped_width;
+			start_column /= deinterleaving;
+		}
+		buffer_height *= 2;
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		break;
+	}
+	if (width_a == 0) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR with width_a\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	if (two_ppc)
+		left_padding /= 2;
+
+	/* Default values */
+	if (left_padding)
+		vectors_per_line = num_vectors;
+	if (!vectors_per_line) {
+		vectors_per_line = CEIL_MUL(num_vectors / buffer_height,
+					    deinterleaving);
+		line_width = 0;
+	}
+	if (!line_width)
+		line_width = vectors_per_line *
+		input_formatter_get_alignment(INPUT_FORMATTER0_ID);
+	if (!buffers_per_line)
+		buffers_per_line = deinterleaving;
+	line_width = CEIL_MUL(line_width,
+		input_formatter_get_alignment(INPUT_FORMATTER0_ID)
+		* vmem_increment);
+
+	vectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;
+
+	if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG &&
+	    binary->info->mode == SH_CSS_BINARY_MODE_VIDEO) {
+		/* workaround for TPG in video mode*/
+		start_line = 0;
+		start_column = 0;
+		cropped_height -= start_line;
+		width_a -= start_column;
+	}
+
+	if_a_config.start_line = start_line;
+	if_a_config.start_column = start_column;
+	if_a_config.left_padding = left_padding / deinterleaving;
+	if_a_config.cropped_height = cropped_height;
+	if_a_config.cropped_width = width_a;
+	if_a_config.deinterleaving = deinterleaving;
+	if_a_config.buf_vecs = vectors_per_buffer;
+	if_a_config.buf_start_index = 0;
+	if_a_config.buf_increment = vmem_increment;
+	if_a_config.buf_eol_offset =
+	    buffer_width * bits_per_pixel / 8 - line_width;
+	if_a_config.is_yuv420_format =
+		(input_format == IA_CSS_STREAM_FORMAT_YUV420_8)
+		|| (input_format == IA_CSS_STREAM_FORMAT_YUV420_10);
+	if_a_config.block_no_reqs =
+		(pipe->stream->config.mode != IA_CSS_INPUT_MODE_SENSOR);
+
+	if (two_ppc) {
+		if (deinterleaving_b) {
+			deinterleaving = deinterleaving_b;
+			width_b = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving;
+			/* Patch from bayer to rgb */
+			num_vectors = num_vectors / 2 *
+					deinterleaving * width_b_factor;
+			vectors_per_line = num_vectors / buffer_height;
+			line_width = vectors_per_line *
+				input_formatter_get_alignment(
+				INPUT_FORMATTER0_ID);
+		}
+		if_b_config.start_line = start_line;
+		if_b_config.start_column = start_column_b;
+		if_b_config.left_padding = left_padding / deinterleaving;
+		if_b_config.cropped_height = cropped_height;
+		if_b_config.cropped_width = width_b;
+		if_b_config.deinterleaving = deinterleaving;
+		if_b_config.buf_vecs = vectors_per_buffer;
+		if_b_config.buf_start_index = buf_offset_b;
+		if_b_config.buf_increment = vmem_increment;
+		if_b_config.buf_eol_offset =
+		    buffer_width * bits_per_pixel/8 - line_width;
+		if_b_config.is_yuv420_format =
+		    input_format == IA_CSS_STREAM_FORMAT_YUV420_8
+		    || input_format == IA_CSS_STREAM_FORMAT_YUV420_10;
+		if_b_config.block_no_reqs =
+			(pipe->stream->config.mode != IA_CSS_INPUT_MODE_SENSOR);
+		sh_css_sp_set_if_configs(&if_a_config, &if_b_config, if_config_index);
+	} else {
+		sh_css_sp_set_if_configs(&if_a_config, NULL, if_config_index);
+	}
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_config_input_network(struct sh_css_pipe *pipe,
+			    struct sh_css_binary *binary)
+{
+	unsigned int fmt_type;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "Enter sh_css_config_input_network()\n");	
+
+	if (pipe && pipe->pipeline.stages)
+		binary = pipe->pipeline.stages->binary;
+
+	err = sh_css_input_format_type(pipe->stream->config.format,
+				       pipe->stream->csi_rx_config.comp,
+				       &fmt_type);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in sh_css_input_format_type()\n");
+		return err;
+	}
+	sh_css_sp_program_input_circuit(fmt_type,
+					pipe->stream->config.channel_id,
+					pipe->stream->config.mode);
+
+	if (binary && (binary->online || pipe->stream->config.continuous)) {
+		if (pipe->stream->config.continuous)
+			my_css.start_sp_copy = true;
+		err = program_input_formatter(pipe, binary);
+		if (err != IA_CSS_SUCCESS) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in program_input_formatter\n");
+			return err;
+		}
+	}
+
+	if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG ||
+	    pipe->stream->config.mode == IA_CSS_INPUT_MODE_PRBS) {
+		unsigned int hblank_cycles = 100,
+			     vblank_lines = 6,
+			     width,
+			     height,
+			     vblank_cycles;
+		width  = (pipe->stream->config.input_res.width) / (1 + (pipe->stream->config.two_pixels_per_clock != 0));
+		height = pipe->stream->config.input_res.height;
+		vblank_cycles = vblank_lines * (width + hblank_cycles);
+		sh_css_sp_configure_sync_gen(width, height, hblank_cycles,
+					     vblank_cycles);
+#if defined(IS_ISP_2400_SYSTEM)
+		if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG) {
+			/* TODO: move define to proper file in tools */
+			#define GP_ISEL_TPG_MODE 0x90058
+			device_store_uint32(GP_ISEL_TPG_MODE, 2);
+		}
+#endif
+	}
+	return IA_CSS_SUCCESS;
+}
+
+#if WITH_PC_MONITORING
+static struct task_struct *my_kthread;    /* Handle for the monitoring thread */
+static int sh_binary_running;         /* Enable sampling in the thread */
+
+static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
+{
+	unsigned i;
+	unsigned cnt_run = 0;
+	unsigned cnt_stall = 0;
+	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
+	sh_css_print("%s PC\trun\tstall\n", core_name);
+
+	for (i = 0; i < hist->length; i++) {
+		if ((hist->run[i] == 0) && (hist->run[i] == hist->stall[i]))
+			continue;
+		sh_css_print("%s %d\t%d\t%d\n",
+				core_name, i, hist->run[i], hist->stall[i]);
+		cnt_run += hist->run[i];
+		cnt_stall += hist->stall[i];
+	}
+
+	sh_css_print(" Statistics for %s, cnt_run = %d, cnt_stall = %d, "
+	       "hist->length = %d\n",
+			core_name, cnt_run, cnt_stall, hist->length);
+}
+
+static void print_pc_histogram(void)
+{
+	struct sh_css_binary_metrics *metrics;
+
+	for (metrics = sh_css_metrics.binary_metrics;
+	     metrics;
+	     metrics = metrics->next) {
+		if (metrics->mode == SH_CSS_BINARY_MODE_PREVIEW ||
+		    metrics->mode == SH_CSS_BINARY_MODE_VF_PP) {
+			sh_css_print("pc_histogram for binary %d is SKIPPED\n",
+				metrics->id);
+			continue;
+		}
+
+		sh_css_print(" pc_histogram for binary %d\n", metrics->id);
+		print_pc_histo("  ISP", &metrics->isp_histogram);
+		print_pc_histo("  SP",   &metrics->sp_histogram);
+		sh_css_print("print_pc_histogram() done for binay->id = %d, "
+			     "done.\n", metrics->id);
+	}
+
+	sh_css_print("PC_MONITORING:print_pc_histogram() -- DONE\n");
+}
+
+static int pc_monitoring(void *data)
+{
+	int i = 0;
+
+	while (true) {
+		if (sh_binary_running) {
+			sh_css_metrics_sample_pcs();
+#if MULTIPLE_SAMPLES
+			for (i = 0; i < NOF_SAMPLES; i++)
+				sh_css_metrics_sample_pcs();
+#endif
+		}
+		usleep_range(10, 50);
+	}
+	return 0;
+}
+
+static void spying_thread_create(void)
+{
+	my_kthread = kthread_run(pc_monitoring, NULL, "sh_pc_monitor");
+	sh_css_metrics_enable_pc_histogram(1);
+}
+
+static void input_frame_info(struct ia_css_frame_info frame_info)
+{
+	sh_css_print("SH_CSS:input_frame_info() -- frame->info.res.width = %d, "
+	       "frame->info.res.height = %d, format = %d\n",
+			frame_info.res.width, frame_info.res.height, frame_info.format);
+}
+#endif /* WITH_PC_MONITORING */
+
+static void
+start_binary(struct sh_css_pipe *pipe,
+	     struct sh_css_binary *binary)
+{
+	struct ia_css_stream *stream = pipe->stream;
+
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+    if (stream && stream->reconfigure_css_rx)
+		sh_css_rx_disable();
+#endif
+
+	sh_css_metrics_start_binary(&binary->metrics);
+
+#if WITH_PC_MONITORING
+	sh_css_print("PC_MONITORING: %s() -- binary id = %d , "
+		     "enable_dvs_envelope = %d\n",
+		     __func__, binary->info->id,
+		     binary->info->enable.dvs_envelope);
+	input_frame_info(binary->in_frame_info);
+
+	if (binary->info->mode == SH_CSS_BINARY_MODE_VIDEO)
+		sh_binary_running = true;
+#endif
+
+	//sh_css_sp_start_isp();
+
+	if (stream && stream->reconfigure_css_rx) {
+		sh_css_rx_configure(&pipe->stream->csi_rx_config, pipe->stream->config.mode);
+		stream->reconfigure_css_rx = false;
+	}
+}
+
+void
+ia_css_frame_zero(struct ia_css_frame *frame)
+{
+	mmgr_clear(frame->data, frame->data_bytes);
+}
+
+/* start the copy function on the SP */
+static enum ia_css_err
+start_copy_on_sp(struct sh_css_pipe *pipe,
+		 struct ia_css_frame *out_frame)
+{
+	struct ia_css_stream *stream = pipe->stream;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ENTER start_copy_on_sp\n");
+
+	if (stream && stream->reconfigure_css_rx)
+		sh_css_rx_disable();
+
+	if (pipe->stream->config.format != IA_CSS_STREAM_FORMAT_BINARY_8) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR config format != BINARY_8\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+	sh_css_sp_start_binary_copy(pipe->pipe_num, out_frame, pipe->stream->config.two_pixels_per_clock);
+
+	//sh_css_sp_start_isp();
+
+	if (stream && stream->reconfigure_css_rx) {
+		sh_css_rx_configure(&pipe->stream->csi_rx_config, pipe->stream->config.mode);
+		stream->reconfigure_css_rx = false;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+/* Pipeline:
+ * To organize the several different binaries for each type of mode,
+ * we use a pipeline. A pipeline contains a number of stages, each with
+ * their own binary and frame pointers.
+ * When stages are added to a pipeline, output frames that are not passed
+ * from outside are automatically allocated.
+ * When input frames are not passed from outside, each stage will use the
+ * output frame of the previous stage as input (the full resolution output,
+ * not the viewfinder output).
+ * Pipelines must be cleaned and re-created when settings of the binaries
+ * change.
+ */
+static void
+sh_css_pipeline_stage_destroy(struct sh_css_pipeline_stage *me)
+{
+	if (me->out_frame_allocated) {
+		ia_css_frame_free(me->args.out_frame);
+		me->args.out_frame = NULL;
+	}
+	if (me->vf_frame_allocated) {
+		ia_css_frame_free(me->args.out_vf_frame);
+		me->args.out_vf_frame = NULL;
+	}
+	sh_css_free(me);
+}
+
+static void
+sh_css_binary_args_reset(struct sh_css_binary_args *args)
+{
+	args->in_frame      = NULL;
+	args->out_frame     = NULL;
+	args->in_ref_frame  = NULL;
+	args->out_ref_frame = NULL;
+	args->extra_ref_frame = NULL;
+	args->in_tnr_frame  = NULL;
+	args->out_tnr_frame = NULL;
+	args->extra_frame   = NULL;
+	args->out_vf_frame  = NULL;
+	args->copy_vf       = false;
+	args->copy_output   = true;
+	args->vf_downscale_log2 = 0;
+}
+
+static enum ia_css_err
+sh_css_pipeline_stage_create(struct sh_css_pipeline_stage **me,
+			     struct sh_css_binary *binary,
+			     const struct ia_css_fw_info *firmware,
+			     enum sh_css_sp_stage_func    sp_func,
+			     unsigned max_input_width,
+			     int    mode,
+			     struct ia_css_frame *cc_frame,
+			     struct ia_css_frame *in_frame,
+			     struct ia_css_frame *out_frame,
+			     struct ia_css_frame *vf_frame)
+{
+	struct sh_css_pipeline_stage *stage = sh_css_malloc(sizeof(*stage));
+	if (!stage)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	stage->binary = firmware ? NULL : binary;
+	stage->binary_info = firmware ?
+				(struct ia_css_binary_info *)
+				&firmware->info.isp :
+			     binary ?
+				(struct ia_css_binary_info *)binary->info :
+			     NULL;
+	stage->firmware = firmware;
+	stage->sp_func  = sp_func;
+	stage->max_input_width  = max_input_width;
+	stage->mode = mode;
+	stage->out_frame_allocated = false;
+	stage->vf_frame_allocated = false;
+	stage->irq_buf_flags = 0x0;
+	stage->next = NULL;
+	sh_css_binary_args_reset(&stage->args);
+
+	if (!in_frame && !firmware && binary && !binary->online)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	if (!out_frame && binary && binary->out_frame_info.res.width) {
+		enum ia_css_err ret =
+		    ia_css_frame_allocate_from_info(&out_frame,
+						    &binary->out_frame_info);
+		if (ret != IA_CSS_SUCCESS) {
+			sh_css_free(stage);
+			return ret;
+		}
+		stage->out_frame_allocated = true;
+	}
+	/* VF frame is not needed in case of need_pp
+	   However, the capture binary needs a vf frame to write to.
+	*/
+	if (!vf_frame) {
+		if ((binary && binary->vf_frame_info.res.width) ||
+		    (firmware &&
+		     firmware->info.isp.enable.vf_veceven)
+		    ) {
+			enum ia_css_err ret =
+			    ia_css_frame_allocate_from_info(&vf_frame,
+						    &binary->vf_frame_info);
+			if (ret != IA_CSS_SUCCESS) {
+				if (stage->out_frame_allocated) {
+					ia_css_frame_free(out_frame);
+					out_frame = NULL;
+				}
+				sh_css_free(stage);
+				return ret;
+			}
+			stage->vf_frame_allocated = true;
+		}
+	} else if (vf_frame && binary && binary->vf_frame_info.res.width) {
+		//assert(vf_frame->data != mmgr_NULL);
+		/* only mark as allocated if buffer pointer available */
+		if (vf_frame->data != mmgr_NULL)
+		stage->vf_frame_allocated = true;
+	}
+
+	stage->args.cc_frame = cc_frame;
+	stage->args.in_frame = in_frame;
+	stage->args.out_frame = out_frame;
+	stage->args.out_vf_frame = vf_frame;
+	*me = stage;
+	return IA_CSS_SUCCESS;
+}
+
+static void
+sh_css_pipeline_init(struct sh_css_pipeline *me, enum ia_css_pipe_id pipe_id)
+{
+	struct ia_css_frame init_frame;
+
+	assert(me != NULL);
+	init_frame.dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipeline_init() enter:\n");
+	me->pipe_id = pipe_id;
+	me->stages = NULL;
+	me->reload = true;
+	me->current_stage = NULL;
+	me->in_frame = init_frame;
+	me->out_frame = init_frame;
+	me->vf_frame = init_frame;
+}
+
+/** @brief Add a stage to pipeline.
+ *
+ * @param	me	Pointer to the pipeline to be added to.
+ * @param[in]	binary		ISP binary of new stage.
+ * @param[in]	firmware	ISP firmware of new stage.
+ * @param[in]	mode		ISP mode of new stage.
+ * @param[in]	cc_frame		The cc frame to the stage.
+ * @param[in]	in_frame		The input frame to the stage.
+ * @param[in]	out_frame		The output frame of the stage.
+ * @param[in]	vf_frame		The viewfinder frame of the stage.
+ * @param[in]	stage			The successor of the stage.
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * Add a new stage to a non-NULL pipeline.
+ * The stage consists of an ISP binary or firmware and input and output arguments.
+*/
+static enum ia_css_err
+sh_css_pipeline_add_stage(struct sh_css_pipeline *me,
+			  struct sh_css_binary *binary,
+			  const struct ia_css_fw_info *firmware,
+			  unsigned int mode,
+			  struct ia_css_frame *cc_frame,
+			  struct ia_css_frame *in_frame,
+			  struct ia_css_frame *out_frame,
+			  struct ia_css_frame *vf_frame,
+			  struct sh_css_pipeline_stage **stage)
+{
+	struct sh_css_pipeline_stage *last = me->stages, *new_stage = NULL;
+	enum ia_css_err err;
+
+/* other arguments can be NULL */
+assert(me != NULL);
+/* assert(stage != NULL); */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_add_stage() enter:\n");
+	if (!binary && !firmware)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	while (last && last->next)
+		last = last->next;
+
+	/* if in_frame is not set, we use the out_frame from the previous
+	 * stage, if no previous stage, it's an error.
+	 */
+	if (!in_frame && !firmware && !binary->online) {
+		if (last)
+			in_frame = last->args.out_frame;
+		if (!in_frame)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+	err = sh_css_pipeline_stage_create(&new_stage, binary, firmware,
+					   SH_CSS_SP_NO_FUNC, 0, mode, cc_frame,
+					   in_frame, out_frame, vf_frame);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (last)
+		last->next = new_stage;
+	else
+		me->stages = new_stage;
+	if (stage)
+		*stage = new_stage;
+	return IA_CSS_SUCCESS;
+}
+
+/** @brief Add a stage to pipeline.
+ *
+ * @param	me	Pointer to the pipeline to be added to.
+ * @param[in]	out_frame		The output frame of the stage.
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * Add a new stage to a non-NULL pipeline.
+ * The stage consists of an SP function and input and output arguments.
+*/
+static enum ia_css_err
+sh_css_pipeline_add_sp_stage(struct sh_css_pipeline *me,
+			  enum sh_css_sp_stage_func func,
+			  unsigned max_input_width,
+			  struct ia_css_frame *out_frame)
+{
+	struct sh_css_pipeline_stage *last = me->stages, *new_stage = NULL;
+	enum ia_css_err err;
+
+/* other arguments can be NULL */
+assert(me != NULL);
+/* assert(stage != NULL); */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_add_sp_stage() enter:\n");
+
+	while (last && last->next)
+		last = last->next;
+
+	err = sh_css_pipeline_stage_create(&new_stage, NULL, NULL,
+					   func, max_input_width, -1, NULL,
+					   NULL, out_frame, NULL);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (last)
+		last->next = new_stage;
+	else
+		me->stages = new_stage;
+	
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_pipeline_get_stage(struct sh_css_pipeline *me,
+			  int mode,
+			  struct sh_css_pipeline_stage **stage)
+{
+	struct sh_css_pipeline_stage *s;
+assert(me != NULL);
+assert(stage != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_get_stage() enter:\n");
+	for (s = me->stages; s; s = s->next) {
+		if (s->mode == mode) {
+			*stage = s;
+			return IA_CSS_SUCCESS;
+		}
+	}
+	return IA_CSS_ERR_INTERNAL_ERROR;
+}
+
+static enum ia_css_err
+sh_css_pipeline_get_output_stage(struct sh_css_pipeline *me,
+				 int mode,
+				 struct sh_css_pipeline_stage **stage)
+{
+	struct sh_css_pipeline_stage *s;
+assert(me != NULL);
+assert(stage != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_get_output_stage() enter:\n");
+
+	*stage = NULL;
+	/* First find acceleration firmware at end of pipe */
+	for (s = me->stages; s; s = s->next) {
+		if (s->firmware && s->mode == mode &&
+		    s->firmware->info.isp.enable.output)
+			*stage = s;
+	}
+	if (*stage)
+		return IA_CSS_SUCCESS;
+	/* If no firmware, find binary in pipe */
+	return sh_css_pipeline_get_stage(me, mode, stage);
+}
+
+static void
+sh_css_pipeline_restart(struct sh_css_pipeline *me)
+{
+assert(me != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_restart() enter:\n");
+	me->current_stage = NULL;
+}
+
+static void
+sh_css_pipeline_clean(struct sh_css_pipeline *me)
+{
+	struct sh_css_pipeline_stage *s = me->stages;
+assert(me != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipeline_clean() enter:\n");
+
+	while (s) {
+		struct sh_css_pipeline_stage *next = s->next;
+		sh_css_pipeline_stage_destroy(s);
+		s = next;
+	}
+	sh_css_pipeline_init(me, me->pipe_id);
+}
+
+static void
+pipe_start(struct sh_css_pipe *pipe)
+{
+	struct sh_css_pipeline_stage *stage = pipe->pipeline.stages;
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"pipe_start() enter:\n");
+	if (!stage)
+		return;
+	pipe->pipeline.current_stage = stage;
+
+	start_binary(pipe, stage->binary);
+}
+
+static void start_pipe(
+	struct sh_css_pipe *me,
+	enum sh_css_pipe_config_override copy_ovrd,
+	enum ia_css_input_mode input_mode)
+{
+	bool low_light = me->mode == IA_CSS_PIPE_ID_CAPTURE &&
+			 (me->capture_mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT ||
+			  me->capture_mode == IA_CSS_CAPTURE_MODE_BAYER);
+	bool is_preview = me->mode == IA_CSS_PIPE_ID_PREVIEW;
+	assert(me != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"start_pipe() enter:\n");
+
+	sh_css_sp_init_pipeline(&me->pipeline,
+				me->mode,
+				me->pipe_num,
+				is_preview,
+				low_light,
+				me->xnr,
+				me->stream->config.two_pixels_per_clock,
+				me->stream->config.continuous,
+				false,
+				me->input_needs_raw_binning,
+				copy_ovrd,
+				input_mode,
+				(input_mode==IA_CSS_INPUT_MODE_MEMORY)?
+					(mipi_port_ID_t)0:
+				me->stream->config.source.port.port);
+
+	/* prepare update of params to ddr */
+	sh_css_commit_isp_config(me->stream, &me->pipeline);
+
+	pipe_start(me);
+}
+
+static void
+sh_css_set_irq_buffer(struct sh_css_pipeline_stage *stage,
+			enum sh_css_frame_id frame_id,
+			struct ia_css_frame *frame)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_set_irq_buffer() enter:\n");
+	if (stage && frame)
+		stage->irq_buf_flags |= 1<<frame_id;
+}
+
+void sh_css_frame_info_set_width(
+	struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int aligned)
+{
+	assert(info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_frame_info_set_width() enter: "
+		"width=%d, aligned=%d\n",
+		width, aligned);
+	info->res.width = width;
+	/* frames with a U and V plane of 8 bits per pixel need to have
+	   all planes aligned, this means double the alignment for the
+	   Y plane if the horizontal decimation is 2. */
+	if (info->format == IA_CSS_FRAME_FORMAT_YUV420 ||
+	    info->format == IA_CSS_FRAME_FORMAT_YV12)
+		info->padded_width = CEIL_MUL(width, 2*HIVE_ISP_DDR_WORD_BYTES);
+	else if (info->format == IA_CSS_FRAME_FORMAT_YUV_LINE)
+		info->padded_width = CEIL_MUL(width, 2*ISP_VEC_NELEMS);
+	else if (info->format == IA_CSS_FRAME_FORMAT_RAW)
+		info->padded_width = CEIL_MUL(width, 2*ISP_VEC_NELEMS);
+	else
+	    {
+		info->padded_width = CEIL_MUL(width, HIVE_ISP_DDR_WORD_BYTES);
+}
+
+	if (aligned) {
+    info->padded_width = CEIL_MUL(info->padded_width, aligned);
+	}
+}
+
+static void sh_css_frame_info_set_format(
+	struct ia_css_frame_info *info,
+	enum ia_css_frame_format format)
+{
+	assert(info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_frame_info_set_format() enter:\n");
+	/* yuv_line has 2*NWAY alignment */
+	info->format = format;
+	/* HACK: this resets the padded width incorrectly.
+	   Lex needs to fix this in the vf_veceven module. */
+	info->padded_width =  CEIL_MUL(info->padded_width, 2*ISP_VEC_NELEMS);
+}
+
+void sh_css_frame_info_init(
+	struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int aligned)\
+{
+	assert(info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_frame_info_init() enter: "
+		"width=%d, "
+		"height=%d, "
+		"format=%d, "
+		"aligned=%d\n",
+		width, height,
+		format, aligned);
+	info->res.height = height;
+	info->format = format;
+	sh_css_frame_info_set_width(info, width, aligned);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_frame_info_init() leave: return_void\n");
+}
+
+static void invalidate_video_binaries(
+	struct sh_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"invalidate_video_binaries() enter:\n");
+	pipe->pipeline.reload   = true;
+	pipe->pipe.video.copy_binary.info = NULL;
+	pipe->pipe.video.video_binary.info = NULL;
+	pipe->pipe.video.vf_pp_binary.info = NULL;
+	if (pipe->shading_table) {
+		ia_css_shading_table_free(pipe->shading_table);
+		pipe->shading_table = NULL;
+	}
+}
+
+void
+sh_css_invalidate_shading_tables(struct ia_css_stream *stream)
+{
+	int i;
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_invalidate_shading_tables() enter:\n");
+
+	for (i=0; i<stream->num_pipes; i++) {
+		struct sh_css_pipe *old_pipe = stream->pipes[i]->old_pipe;
+		sh_css_pipe_free_shading_table(old_pipe);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_invalidate_shading_tables() leave: return_void\n");
+}
+
+/* CSS receiver programming */
+/* currently, the capture pp binary requires an internal frame. This will
+   be removed in the future. */
+static enum ia_css_err alloc_capture_pp_frame(
+	struct sh_css_pipe *pipe,
+	const struct sh_css_binary *binary)
+{
+	struct ia_css_frame_info cpp_info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	assert(pipe != NULL);
+	assert(binary != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "alloc_capture_pp_frame() enter:\n");
+
+	cpp_info = binary->internal_frame_info;
+	cpp_info.format = IA_CSS_FRAME_FORMAT_YUV420;
+	if (pipe->pipe.capture.capture_pp_frame) {
+		ia_css_frame_free(pipe->pipe.capture.capture_pp_frame);
+		pipe->pipe.capture.capture_pp_frame = NULL;
+	}
+	err = ia_css_frame_allocate_from_info(
+			&pipe->pipe.capture.capture_pp_frame, &cpp_info);
+	return err;
+}
+
+static void invalidate_preview_binaries(
+	struct sh_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "invalidate_preview_binaries() enter:\n");
+	pipe->pipeline.reload     = true;
+	pipe->pipe.preview.preview_binary.info = NULL;
+	pipe->pipe.preview.vf_pp_binary.info   = NULL;
+	pipe->pipe.preview.copy_binary.info    = NULL;
+	if (pipe->shading_table) {
+		ia_css_shading_table_free(pipe->shading_table);
+		pipe->shading_table = NULL;
+	}
+}
+
+static void invalidate_capture_binaries(
+	struct sh_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "invalidate_capture_binaries() enter:\n");
+	pipe->pipeline.reload        = true;
+	pipe->pipe.capture.copy_binary.info       = NULL;
+	pipe->pipe.capture.primary_binary.info    = NULL;
+	pipe->pipe.capture.pre_isp_binary.info    = NULL;
+	pipe->pipe.capture.gdc_binary.info        = NULL;
+	pipe->pipe.capture.post_isp_binary.info   = NULL;
+	pipe->pipe.capture.pre_anr_binary.info    = NULL;
+	pipe->pipe.capture.anr_binary.info        = NULL;
+	pipe->pipe.capture.post_anr_binary.info   = NULL;
+	pipe->pipe.capture.capture_pp_binary.info = NULL;
+	pipe->pipe.capture.vf_pp_binary.info      = NULL;
+	if (pipe->shading_table) {
+		ia_css_shading_table_free(pipe->shading_table);
+		pipe->shading_table = NULL;
+	}
+}
+
+static void sh_css_pipe_invalidate_binaries(
+	struct sh_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_invalidate_binaries() enter:\n");
+	switch (pipe->mode) {
+	case IA_CSS_PIPE_ID_VIDEO:
+		invalidate_video_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		invalidate_capture_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_PREVIEW:
+		invalidate_preview_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_COPY:
+		return;
+	default:
+		break;
+	}
+	/* Temporarily, not every sh_css_pipe has a new_pipe. */
+	if (pipe->new_pipe && pipe->new_pipe->config.acc_extension) {
+		ia_css_pipe_unload_extension(pipe->new_pipe,
+				pipe->new_pipe->config.acc_extension);
+	}
+}
+
+static void
+enable_interrupts(enum ia_css_irq_type irq_type)
+{
+	bool enable_pulse = irq_type != IA_CSS_IRQ_TYPE_EDGE;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "enable_interrupts() enter:\n");
+/* Enable IRQ on the SP which signals that SP goes to idle (aka ready state) */
+	cnd_sp_irq_enable(SP0_ID, true);
+/* Set the IRQ device 0 to either level or pulse */
+	irq_enable_pulse(IRQ0_ID, enable_pulse);
+	cnd_virq_enable_channel(virq_sp, true);
+	/* Triggered by SP to signal Host that there are new statistics */
+	cnd_virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET), true);
+	/* Triggered by SP to signal Host that there is data in one of the
+	 * SP->Host queues.*/
+#if !defined(HAS_IRQ_MAP_VERSION_2)
+/* IRQ_SW_CHANNEL2_ID does not exist on 240x systems */
+	cnd_virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL2_ID + IRQ_SW_CHANNEL_OFFSET), true);
+	virq_clear_all();
+#endif
+
+	sh_css_rx_enable_all_interrupts();
+
+#if defined(HRT_CSIM)
+/*
+ * Enable IRQ on the SP which signals that SP goes to idle 
+ * to get statistics for each binary
+ */
+	cnd_isp_irq_enable(ISP0_ID, true);
+	cnd_virq_enable_channel(virq_isp, true);
+#endif
+}
+
+enum ia_css_err
+ia_css_init(const struct ia_css_env *env,
+	    const struct ia_css_fw  *fw,
+	    uint32_t                 mmu_l1_base,
+	    enum ia_css_irq_type     irq_type)
+{
+	enum ia_css_err err;
+	//uint32_t i = 0;
+	void *(*malloc_func) (size_t size, bool zero_mem) = env->cpu_mem_env.alloc;
+	void (*free_func) (void *ptr) = env->cpu_mem_env.free;
+	void (*flush_func) (struct ia_css_acc_fw *fw) = env->cpu_mem_env.flush;
+	static struct sh_css default_css = DEFAULT_CSS;
+	hrt_data select, enable;
+
+	init_pipe_number();
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() enter: void\n");
+
+	ia_css_device_access_init(&env->hw_access_env);
+	ia_css_memory_access_init(&env->css_mem_env);
+	select = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select)
+						& (~GPIO_FLASH_PIN_MASK);
+	enable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e)
+							| GPIO_FLASH_PIN_MASK;
+	sh_css_mmu_set_page_table_base_index(mmu_l1_base);
+
+	if (malloc_func == NULL || free_func == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	memcpy(&my_css, &default_css, sizeof(my_css));
+
+	my_css.malloc = malloc_func;
+	my_css.free = free_func;
+	my_css.flush = flush_func;
+	sh_css_printf = env->print_env.debug_print;
+
+	ia_css_i_host_rmgr_init();
+
+	sh_css_set_dtrace_level(2);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init()\n");
+
+	ref_count_mipi_allocation = 0;
+	/* In case this has been programmed already, update internal
+	   data structure ... DEPRECATED */
+	my_css.page_table_base_index = mmu_get_page_table_base_index(MMU0_ID);
+
+	my_css.irq_type = irq_type;
+	enable_interrupts(my_css.irq_type);
+
+	/* configure GPIO to output mode */
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_select, select);
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_e, enable);
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_0, 0);
+
+	err = sh_css_refcount_init();
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = sh_css_params_init();
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = sh_css_load_firmware(fw->data, fw->bytes);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	sh_css_init_binary_infos();
+	my_css.sp_bin_addr = sh_css_sp_load_program(&sh_css_sp_fw,
+						    SP_PROG_NAME,
+						    my_css.sp_bin_addr);
+	if (!my_css.sp_bin_addr) {
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+#if defined(HRT_CSIM)
+	/**
+	 * In compiled simulator context include debug support by default.
+	 * In all other cases (e.g. Android phone), the user (e.g. driver)
+	 * must explicitly enable debug support by calling this function.
+	 */
+	if (!sh_css_debug_mode_init()) {
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",IA_CSS_ERR_INTERNAL_ERROR);
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+#endif
+
+#if WITH_PC_MONITORING
+	if (!thread_alive) {
+		thread_alive++;
+		sh_css_print("PC_MONITORING: %s() -- create thread DISABLED\n",
+			     __func__);
+		spying_thread_create();
+	}
+	sh_css_printf = printk;
+#endif
+	if (!sh_css_hrt_system_is_idle()) {
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",IA_CSS_ERR_SYSTEM_NOT_IDLE);
+		return IA_CSS_ERR_SYSTEM_NOT_IDLE;
+	}
+	/* can be called here, queuing works, but:
+	   - when sp is started later, it will wipe queued items
+	   so for now we leave it for later and make sure
+	   updates are not called to frequently.
+	sh_css_init_buffer_queues();
+	*/
+
+    //ia_css_stream_manager_init();
+
+#ifdef HAS_INPUT_SYSTEM_VERSION_2
+	if(ia_css_input_system_init() != INPUT_SYSTEM_ERR_NO_ERROR)
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+#endif
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",err);
+
+	return err;
+}
+
+/* Suspend does not need to do anything for now, this may change
+   in the future though. */
+void
+ia_css_suspend(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_suspend() enter & leave\n");
+}
+
+void
+ia_css_resume(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_resume() enter: void\n");
+
+	sh_css_sp_set_sp_running(false);
+	/* reload the SP binary. ISP binaries are automatically
+	   reloaded by the ISP upon execution. */
+	sh_css_mmu_set_page_table_base_index(my_css.page_table_base_index);
+	sh_css_params_reconfigure_gdc_lut();
+
+	sh_css_sp_activate_program(&sh_css_sp_fw, my_css.sp_bin_addr,
+				   SP_PROG_NAME);
+
+	enable_interrupts(my_css.irq_type);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_resume() leave: return_void\n");
+}
+
+void *
+sh_css_malloc(size_t size)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_malloc() enter: size=%d\n",size);
+	if (size > 0 && my_css.malloc)
+		return my_css.malloc(size, false);
+	return NULL;
+}
+
+void *
+sh_css_calloc(size_t N, size_t size)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_calloc() enter: N=%d, size=%d\n",N,size);
+	if (size > 0 && my_css.malloc) {
+		return my_css.malloc(N*size, true);
+	}
+	return NULL;
+}
+
+void
+sh_css_free(void *ptr)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_free() enter:\n");
+	if (ptr && my_css.free)
+		my_css.free(ptr);
+}
+
+/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
+void
+sh_css_flush(struct ia_css_acc_fw *fw)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_flush() enter:\n");
+	if ((fw != NULL) && (my_css.flush != NULL))
+		my_css.flush(fw);
+}
+
+static void
+init_sp_thread_mapping(void)
+{
+	unsigned int i;
+
+	for (i = 1; i < MAX_NUM_SP_THREADS; i++) {
+		sp_thread_list[i] = SP_THREAD_EMPTY_TOKEN;
+	}
+
+	for (i = 0; i < MAX_NUM_PIPES; i++) {
+		pipe_num_to_sp_thread[i] = 0xFFFF;
+	}
+}
+
+static void
+map_pipe_num_to_sp_thread(unsigned int pipe_num)
+{
+	unsigned int i;
+	assert(pipe_num_to_sp_thread[pipe_num] == 0xFFFF); /* pipe is not mapped to any thread */
+
+	for (i = 0; i < MAX_NUM_SP_THREADS; i++) {
+		if (sp_thread_list[i] == SP_THREAD_EMPTY_TOKEN) {
+			sp_thread_list[i] = SP_THREAD_RESERVED_TOKEN;
+			pipe_num_to_sp_thread[pipe_num] = i;
+			break;
+		}
+	}
+}
+
+static void
+unmap_pipe_num_to_sp_thread(unsigned int pipe_num)
+{
+	unsigned int thread_id;
+	assert(pipe_num_to_sp_thread[pipe_num] != 0xFFFF);
+
+	thread_id = pipe_num_to_sp_thread[pipe_num];
+	pipe_num_to_sp_thread[pipe_num] = 0xFFFF;
+	sp_thread_list[thread_id] = SP_THREAD_EMPTY_TOKEN;
+}
+
+static void
+init_pipe_number(void)
+{
+	unsigned int i;
+	pipe_num_counter = 0;
+	for (i = 0; i < MAX_NUM_PIPES; i++)
+		pipe_num_list[i] = PIPE_NUM_EMPTY_TOKEN;
+
+	init_sp_thread_mapping();
+}
+
+static unsigned int
+generate_pipe_number(void)
+{
+	unsigned int i;
+	unsigned int pipe_num;
+	/*Assign a new pipe_num .... search for empty place */
+	for (i = 0; i < MAX_NUM_PIPES; i++)
+	{
+		if (pipe_num_list[i] == PIPE_NUM_EMPTY_TOKEN){
+			pipe_num_list[i] = PIPE_NUM_RESERVED_TOKEN; /*position is reserved */
+			pipe_num = i;
+			break;
+		}
+	}
+	pipe_num_counter++;
+	map_pipe_num_to_sp_thread(pipe_num);
+	return pipe_num;
+}
+
+static void
+release_pipe_num(unsigned int pipe_num)
+{
+	pipe_num_list[pipe_num] = PIPE_NUM_EMPTY_TOKEN;
+	pipe_num_counter--;
+	unmap_pipe_num_to_sp_thread(pipe_num);
+}
+
+static enum ia_css_err
+create_old_pipe(enum ia_css_pipe_mode mode,
+	       struct sh_css_pipe **pipe,
+	       bool copy_pipe)
+{
+	struct sh_css_pipe *me = sh_css_malloc(sizeof(*me));
+	static struct sh_css_pipe default_pipe = DEFAULT_PIPE;
+	static struct sh_css_preview_settings prev  = DEFAULT_PREVIEW_SETTINGS;
+	static struct sh_css_capture_settings capt  = DEFAULT_CAPTURE_SETTINGS;
+	static struct sh_css_video_settings   video = DEFAULT_VIDEO_SETTINGS;
+
+	if (!me)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	memset(me, 0, sizeof(*me));
+
+	*me = default_pipe;
+	/* TODO: JB should not be needed, but temporary backward reference */
+	switch (mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		me->mode = IA_CSS_PIPE_ID_PREVIEW;
+		me->pipe.preview = prev;
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+		if (copy_pipe) {
+			me->mode = IA_CSS_PIPE_ID_COPY;
+		} else {
+			me->mode = IA_CSS_PIPE_ID_CAPTURE;
+		}
+		me->pipe.capture = capt;
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		me->mode = IA_CSS_PIPE_ID_VIDEO;
+		me->pipe.video = video;
+		break;
+	case IA_CSS_PIPE_MODE_ACC:
+		me->mode = IA_CSS_PIPE_ID_ACC;
+		break;
+	default:
+		sh_css_free(me);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	sh_css_pipeline_init(&me->pipeline, me->mode);
+	me->new_pipe = NULL;
+	*pipe = me;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+create_pipe(enum ia_css_pipe_mode mode,
+	    struct ia_css_pipe **pipe,
+	    bool copy_pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipe *me = sh_css_malloc(sizeof(*me));
+
+	if (!me)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	err = create_old_pipe(mode, &me->old_pipe, copy_pipe);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	me->pipe_num = generate_pipe_number();
+	my_css.active_pipes[me->pipe_num] = me;
+	me->old_pipe->new_pipe = me;
+	me->old_pipe->pipe_num = me->pipe_num;
+	*pipe = me;
+	return IA_CSS_SUCCESS;
+}
+
+static struct ia_css_pipe *
+find_pipe_by_num(uint8_t pipe_num)
+{
+	unsigned int i;
+	for (i = 0; i < pipe_num_counter; i++){
+		if (my_css.active_pipes[i] != NULL && my_css.active_pipes[i]->pipe_num == pipe_num) {
+			return  my_css.active_pipes[i];
+		}
+	}
+	return NULL;
+}
+
+static void
+destroy_frames(unsigned int num_frames, struct ia_css_frame **frames)
+{
+	unsigned int i;
+	for (i = 0; i < num_frames; i++) {
+		if (frames[i]) {
+			ia_css_frame_free(frames[i]);
+			frames[i] = NULL;
+		}
+	}
+}
+
+enum ia_css_err
+ia_css_pipe_destroy(struct ia_css_pipe *pipe)
+{
+	struct sh_css_pipe *old_pipe = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_destroy() enter\n");
+
+	if (pipe == NULL) return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	old_pipe = pipe->old_pipe;
+
+	if (old_pipe->stream != NULL) {
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_destroy(): "
+				"ia_css_stream_destroy not called!\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	release_pipe_num(pipe->pipe_num);
+
+	switch (pipe->config.mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		/* need to take into account that this function is also called
+		   on the internal copy pipe */
+		if (old_pipe->mode == IA_CSS_PIPE_MODE_PREVIEW) {
+		destroy_frames(NUM_CONTINUOUS_FRAMES,
+				old_pipe->continuous_frames);
+		if (old_pipe->pipe.preview.copy_pipe) {
+				err = ia_css_pipe_destroy(old_pipe->pipe.preview.copy_pipe->new_pipe);
+				sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_destroy(): "
+					"destroyed internal copy pipe err=%d\n", err);
+			}
+		}
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		if (old_pipe->mode == IA_CSS_PIPE_MODE_VIDEO) {
+			destroy_frames(NUM_CONTINUOUS_FRAMES,
+				old_pipe->continuous_frames);
+			if (old_pipe->pipe.video.copy_pipe) {
+				err = ia_css_pipe_destroy(old_pipe->pipe.video.copy_pipe->new_pipe);
+				sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_destroy(): "
+					"destroyed internal copy pipe err=%d\n", err);
+			}
+		}
+		destroy_frames(NUM_TNR_FRAMES, old_pipe->pipe.video.tnr_frames);
+		destroy_frames((old_pipe->dvs_frame_delay + 1), old_pipe->pipe.video.ref_frames);
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+		destroy_frames(1, &old_pipe->pipe.capture.capture_pp_frame);
+#if 0
+		/* Do not destroy, these are shared with preview */
+		destroy_frames(NUM_CONTINUOUS_FRAMES,
+				old_pipe->pipe.capture.continuous_frames);
+#endif
+		break;
+	case IA_CSS_PIPE_MODE_ACC:
+		break;
+	}
+
+	my_css.active_pipes[pipe->pipe_num] = NULL;
+	sh_css_pipe_free_shading_table(old_pipe);
+	sh_css_pipe_invalidate_binaries(old_pipe);
+	sh_css_pipeline_clean(&old_pipe->pipeline);
+	sh_css_free(old_pipe);
+	old_pipe = NULL;
+	sh_css_free(pipe);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_destroy() exit, err=%d\n", err);
+	return err;
+}
+
+void
+ia_css_uninit(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_uninit() enter: void\n");
+#if WITH_PC_MONITORING
+	sh_css_print("PC_MONITORING: %s() -- started\n", __func__);
+	print_pc_histogram();
+#endif
+	/* TODO: JB: implement decent check and handling of freeing mipi frames */
+	//assert(ref_count_mipi_allocation == 0); //mipi frames are not freed
+	/* cleanup generic data */
+	sh_css_params_uninit();
+	sh_css_refcount_uninit();
+
+	ia_css_i_host_rmgr_uninit();
+
+	sh_css_binary_uninit();
+	sh_css_unload_firmware();
+	if (my_css.sp_bin_addr) {
+		mmgr_free(my_css.sp_bin_addr);
+		my_css.sp_bin_addr = mmgr_NULL;
+	}
+
+	sh_css_sp_set_sp_running(false);
+	/* check and free any remaining mipi frames */
+	free_mipi_frames(NULL, true);
+	
+	sh_css_sp_reset_global_vars();
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_uninit() leave: return_void\n");
+}
+
+static unsigned int translate_sw_interrupt(unsigned value)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt() enter:\n");
+	/* previous versions of sp would put info in the upper word
+	   better safe than sorry so mask that away
+	*/
+	value = value & 0xffff;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt() leave: return %d\n", value);
+	return value;
+}
+
+static unsigned int translate_sw_interrupt1(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt1() enter:\n");
+	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(1));
+}
+
+#if 0
+static unsigned int translate_sw_interrupt2(void)
+{
+	/* By smart coding the flag/bits in value (on the SP side),
+	 * no translation is required. The returned value can be
+	 * binary ORed with existing interrupt info
+	 * (it is compatible with enum ia_css_irq_info)
+	 */
+/* MW: No smart coding required, we should just keep interrupt info
+   and local context info separated */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt2() enter:\n");
+	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(2));
+}
+#endif
+
+/* Deprecated, this is an HRT backend function (memory_access.h) */
+static void
+sh_css_mmu_set_page_table_base_index(hrt_data base_index)
+{
+	int i;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_set_page_table_base_index() enter: base_index=0x%08x\n",base_index);
+	my_css.page_table_base_index = base_index;
+	for (i = 0; i < (int)N_MMU_ID; i++) {
+		mmu_ID_t mmu_id = (mmu_ID_t)i;
+		mmu_set_page_table_base_index(mmu_id, base_index);
+		mmu_invalidate_cache(mmu_id);
+	}
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_set_page_table_base_index() leave: return_void\n");
+}
+
+void
+ia_css_mmu_invalidate_cache(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_invalidate_tlb;
+
+	sh_css_dtrace(SH_DBG_INFO, "ia_css_mmu_invalidate_cache() enter\n");
+	/* indicate to sp start that invalidation must occur */
+	sh_css_sp_invalidate_mmu();
+
+	HIVE_ADDR_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+
+	(void)HIVE_ADDR_sp_invalidate_tlb; /* Suppres warnings in CRUN */
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_invalidate_tlb),
+		true);
+	sh_css_dtrace(SH_DBG_INFO, "ia_css_mmu_invalidate_cache() leave\n");
+}
+
+#if defined(HAS_IRQ_MAP_VERSION_1) || defined(HAS_IRQ_MAP_VERSION_1_DEMO)
+enum ia_css_err ia_css_irq_translate(
+	unsigned int *irq_infos)
+{
+	virq_id_t	irq;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
+	unsigned int infos = 0;
+
+/* irq_infos can be NULL, but that would make the function useless */
+/* assert(irq_infos != NULL); */
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_translate() enter: irq_infos=%p\n",irq_infos);
+
+	while (status == hrt_isp_css_irq_status_more_irqs) {
+		status = virq_get_channel_id(&irq);
+		if (status == hrt_isp_css_irq_status_error)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+#if WITH_PC_MONITORING
+		sh_css_print("PC_MONITORING: %s() irq = %d, "
+			     "sh_binary_running set to 0\n", __func__, irq);
+		sh_binary_running = 0 ;
+#endif
+
+		switch (irq) {
+		case virq_sp:
+			infos |= IA_CSS_IRQ_INFO_EVENTS_READY;
+			break;
+		case virq_isp:
+#ifdef HRT_CSIM
+			/* Enable IRQ which signals that ISP goes to idle
+			 * to get statistics for each binary */
+			infos |= IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
+#endif
+			break;
+		case virq_isys_csi:
+			/* css rx interrupt, read error bits from css rx */
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR;
+			break;
+		case virq_isys_fifo_full:
+			infos |=
+			    IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW;
+			break;
+		case virq_isys_sof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
+			break;
+		case virq_isys_eof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
+			break;
+/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
+#if 0
+/* hmm, an interrupt mask, why would we have that ? */
+		case virq_isys_sol:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL;
+			break;
+#endif
+		case virq_isys_eol:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL;
+			break;
+/*
+ * MW: The 2300 demo system does not have a receiver, and it
+ * does not have the following three IRQ channels defined
+ */
+#if defined(HAS_IRQ_MAP_VERSION_1)
+		case virq_ifmt_sideband_changed:
+			infos |=
+			    IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED;
+			break;
+		case virq_gen_short_0:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0;
+			break;
+		case virq_gen_short_1:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1;
+			break;
+#endif
+		case virq_ifmt0_id:
+			infos |= IA_CSS_IRQ_INFO_IF_PRIM_ERROR;
+			break;
+		case virq_ifmt1_id:
+			infos |= IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR;
+			break;
+		case virq_ifmt2_id:
+			infos |= IA_CSS_IRQ_INFO_IF_SEC_ERROR;
+			break;
+		case virq_ifmt3_id:
+			infos |= IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR;
+			break;
+		case virq_sw_pin_0:
+			infos |= IA_CSS_IRQ_INFO_SW_0;
+			break;
+		case virq_sw_pin_1:
+			infos |= translate_sw_interrupt1();
+			/* pqiao TODO: also assumption here */
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (irq_infos)
+		*irq_infos = infos;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_translate() "
+		"leave: irq_infos=0x%08x\n", infos);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_irq_enable(enum ia_css_irq_info info,
+		  bool enable)
+{
+	virq_id_t	irq = N_virq_id;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() enter: info=%d, enable=%d\n",info,enable);
+
+	switch (info) {
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR:
+		irq = virq_isys_csi;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW:
+		irq = virq_isys_fifo_full;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
+		irq = virq_isys_sof;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
+		irq = virq_isys_eof;
+		break;
+/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
+#if 0
+/* hmm, an interrupt mask, why would we have that ? */
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL:
+		irq = virq_isys_sol;
+		break;
+#endif
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL:
+		irq = virq_isys_eol;
+		break;
+#if defined(HAS_IRQ_MAP_VERSION_1)
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED:
+		irq = virq_ifmt_sideband_changed;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0:
+		irq = virq_gen_short_0;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1:
+		irq = virq_gen_short_1;
+		break;
+#endif
+	case IA_CSS_IRQ_INFO_IF_PRIM_ERROR:
+		irq = virq_ifmt0_id;
+		break;
+	case IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR:
+		irq = virq_ifmt1_id;
+		break;
+	case IA_CSS_IRQ_INFO_IF_SEC_ERROR:
+		irq = virq_ifmt2_id;
+		break;
+	case IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR:
+		irq = virq_ifmt3_id;
+		break;
+	case IA_CSS_IRQ_INFO_SW_0:
+		irq = virq_sw_pin_0;
+		break;
+	case IA_CSS_IRQ_INFO_SW_1:
+		irq = virq_sw_pin_1;
+		break;
+	case IA_CSS_IRQ_INFO_SW_2:
+		irq = virq_sw_pin_2;
+		break;
+	default:
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	cnd_virq_enable_channel(irq, enable);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+#elif defined(HAS_IRQ_MAP_VERSION_2)
+
+enum ia_css_err ia_css_irq_translate(
+	unsigned int *irq_infos)
+{
+	virq_id_t	irq;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
+	unsigned int infos = 0;
+
+/* irq_infos can be NULL, but that would make the function useless */
+/* assert(irq_infos != NULL); */
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_translate() enter: irq_infos=%u\n",irq_infos);
+
+	while (status == hrt_isp_css_irq_status_more_irqs) {
+		status = virq_get_channel_id(&irq);
+		if (status == hrt_isp_css_irq_status_error)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+#if WITH_PC_MONITORING
+		sh_css_print("PC_MONITORING: %s() irq = %d, "
+			     "sh_binary_running set to 0\n", __func__, irq);
+		sh_binary_running = 0 ;
+#endif
+
+		switch (irq) {
+		case virq_sp:
+			infos |= IA_CSS_IRQ_INFO_EVENTS_READY;
+			break;
+		case virq_isp:
+#ifdef HRT_CSIM
+			/* Enable IRQ which signals that ISP goes to idle
+			 * to get statistics for each binary */
+			infos |= IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
+#endif
+			break;
+		case IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR:
+			irq = virq_isys_csi;
+			break;
+		case virq_isys_sof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
+			break;
+		case virq_isys_eof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
+			break;
+		case virq_isys_csi:
+			infos |= IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR;
+			break;
+		case virq_ifmt0_id:
+			infos |= IA_CSS_IRQ_INFO_IF_ERROR;
+			break;
+		case virq_dma:
+			infos |= IA_CSS_IRQ_INFO_DMA_ERROR;
+			break;
+		case virq_sw_pin_0:
+			infos |= IA_CSS_IRQ_INFO_SW_0;
+			break;
+		case virq_sw_pin_1:
+			infos |= translate_sw_interrupt1();
+			/* pqiao TODO: also assumption here */
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (irq_infos)
+		*irq_infos = infos;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_translate() "
+		"leave: irq_infos=0x%08x\n", infos);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_irq_enable(
+	enum ia_css_irq_info info,
+	bool enable)
+{
+	virq_id_t	irq = N_virq_id;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() enter: info=%d, enable=%d\n",info,enable);
+
+	switch (info) {
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
+		irq = virq_isys_sof;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
+		irq = virq_isys_eof;
+		break;
+	case IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR:
+		irq = virq_isys_csi;
+		break;
+	case IA_CSS_IRQ_INFO_IF_ERROR:
+		irq = virq_ifmt0_id;
+		break;
+	case IA_CSS_IRQ_INFO_DMA_ERROR:
+		irq = virq_dma;
+		break;
+	case IA_CSS_IRQ_INFO_SW_0:
+		irq = virq_sw_pin_0;
+		break;
+	case IA_CSS_IRQ_INFO_SW_1:
+		irq = virq_sw_pin_1;
+		break;
+	default:
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	cnd_virq_enable_channel(irq, enable);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+#else
+#error "sh_css.c: IRQ MAP must be one of \
+	{IRQ_MAP_VERSION_1, IRQ_MAP_VERSION_1_DEMO, IRQ_MAP_VERSION_2}"
+#endif
+
+unsigned int sh_css_get_sw_interrupt_value(
+	unsigned int irq)
+{
+unsigned int	irq_value;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_sw_interrupt_value() enter: irq=%d\n",irq);
+	irq_value = sh_css_sp_get_sw_interrupt_value(irq);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_sw_interrupt_value() leave: irq_value=%d\n",irq_value);
+return irq_value;
+}
+
+void
+sh_css_uv_offset_is_zero(bool *uv_offset_is_zero)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_uv_offset_is_zero() enter:\n");
+	if (uv_offset_is_zero != NULL) {
+		*uv_offset_is_zero = SH_CSS_UV_OFFSET_IS_0;
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_uv_offset_is_zero() leave: uv_offset_is_zero=%d\n",
+		*uv_offset_is_zero);
+	}
+}
+
+#if 0
+/* Disabled because it is currently unused. */
+static void
+sh_css_pipe_get_extra_pixels_count(const struct sh_css_pipe *pipe,
+				   struct ia_css_resolution *extra)
+{
+	int rows = SH_CSS_MAX_LEFT_CROPPING,
+	    cols = SH_CSS_MAX_LEFT_CROPPING;
+
+	assert(pipe != NULL);
+	assert(extra != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_get_extra_pixels_count() enter: void\n");
+
+	if (lines_needed_for_bayer_order(pipe))
+		rows += 2;
+
+	if (columns_needed_for_bayer_order(pipe))
+		cols  += 2;
+
+	extra->width  = cols;
+	extra->height = rows;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_get_extra_pixels_count() leave: extra_rows=%d, extra_cols=%d\n",
+		rows, cols);
+}
+#endif
+
+static void init_copy_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+/* out_info can be NULL */
+assert(pipe != NULL);
+assert(in_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"init_copy_descr() enter:\n");
+
+	*in_info = *out_info;
+
+	copy_descr.mode          = SH_CSS_BINARY_MODE_COPY;
+	copy_descr.online        = true;
+	copy_descr.stream_format = pipe->stream->config.format;
+	copy_descr.binning       = false;
+	copy_descr.two_ppc       = pipe->stream->config.two_pixels_per_clock;
+	copy_descr.in_info       = in_info;
+	copy_descr.out_info      = out_info;
+	copy_descr.vf_info       = NULL;
+	copy_descr.isp_pipe_version = 1;
+}
+
+static void init_offline_descr(
+	struct sh_css_pipe *pipe,
+	struct sh_css_binary_descr *descr,
+	int mode,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+/* in_info, out_info, vf_info can be NULL */
+assert(pipe != NULL);
+assert(descr != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"init_offline_descr() enter:\n");
+
+	descr->mode          = mode;
+	descr->online        = false;
+	descr->continuous    = pipe->stream->config.continuous;
+	descr->stream_format = pipe->stream->config.format;
+	descr->binning       = false;
+	descr->two_ppc       = false;
+	descr->in_info       = in_info;
+	descr->out_info      = out_info;
+	descr->vf_info       = vf_info;
+	descr->isp_pipe_version = pipe->isp_pipe_version;
+	descr->enable_yuv_ds = false;
+	descr->enable_high_speed = false;
+	descr->enable_reduced_pipe = false;
+	descr->enable_dvs_6axis = false;
+	descr->enable_dz     = false;
+	descr->dvs_env.width = 0;
+	descr->dvs_env.height = 0;
+}
+
+static void
+init_vf_pp_descr(struct sh_css_pipe *pipe,
+		 struct ia_css_frame_info *in_info,
+		 struct ia_css_frame_info *out_info)
+{
+/* out_info can be NULL ??? */
+assert(pipe != NULL);
+assert(in_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"init_vf_pp_descr() enter:\n");
+
+	in_info->raw_bit_depth = 0;
+	init_offline_descr(pipe,
+			   &vf_pp_descr, SH_CSS_BINARY_MODE_VF_PP,
+			   in_info, out_info, NULL);
+}
+
+static void init_preview_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	int mode = SH_CSS_BINARY_MODE_PREVIEW;
+
+/* out_info can be NULL ??? */
+assert(pipe != NULL);
+assert(in_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"init_preview_descr() enter:\n");
+
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	if (input_format_is_yuv(pipe->stream->config.format))
+		mode = SH_CSS_BINARY_MODE_COPY;
+	else
+		in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+
+	init_offline_descr(pipe,
+			   &preview_descr, mode,
+			   in_info, out_info, NULL);
+	if (pipe->stream->config.online) {
+		preview_descr.online	    = pipe->stream->config.online;
+		preview_descr.two_ppc       = pipe->stream->config.two_pixels_per_clock;
+	}
+	preview_descr.stream_format = pipe->stream->config.format;
+	preview_descr.binning	    = pipe->input_needs_raw_binning;
+	preview_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+/* configure and load the copy binary, the next binary is used to
+   determine whether the copy binary needs to do left padding. */
+static enum ia_css_err load_copy_binary(
+	struct sh_css_pipe *pipe,
+	struct sh_css_binary *copy_binary,
+	struct sh_css_binary *next_binary)
+{
+	struct ia_css_frame_info copy_out_info, copy_in_info;
+	unsigned int left_padding;
+	enum ia_css_err err;
+	int mode = SH_CSS_BINARY_MODE_COPY;
+
+/* next_binary can be NULL */
+assert(pipe != NULL);
+assert(copy_binary != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"load_copy_binary() enter:\n");
+
+	if (next_binary != NULL) {
+		copy_out_info = next_binary->in_frame_info;
+		left_padding = next_binary->left_padding;
+	} else {
+		copy_out_info = pipe->output_info;
+		left_padding = 0;
+	}
+
+	init_copy_descr(pipe, &copy_in_info, &copy_out_info);
+	copy_descr.mode = mode;
+	err = sh_css_binary_find(&copy_descr, copy_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	copy_binary->left_padding = left_padding;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+alloc_continuous_frames(
+	struct sh_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame_info ref_info;
+	enum ia_css_pipe_id pipe_id = pipe->mode;
+	bool continuous = pipe->stream->config.continuous;
+	bool input_needs_raw_binning = pipe->input_needs_raw_binning;
+	unsigned int i;
+	unsigned int left_cropping;
+	uint8_t raw_binning = 0;
+
+	if (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
+		left_cropping = pipe->pipe.preview.preview_binary.info->left_cropping;
+	ref_info = pipe->pipe.preview.preview_binary.in_frame_info;
+		raw_binning = pipe->pipe.preview.preview_binary.info->enable.raw_binning;
+	} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {
+		left_cropping = pipe->pipe.video.video_binary.info->left_cropping;
+		ref_info = pipe->pipe.video.video_binary.in_frame_info;
+		raw_binning = pipe->pipe.video.video_binary.info->enable.raw_binning;
+	}
+
+	if (input_needs_raw_binning && raw_binning) {
+		/* TODO: Remove this; when the decimated
+		 * resolution is available */
+		/* Only for continuous preview/video mode
+		 * where we need 2xOut resolution */
+		ref_info.padded_width *= 2;
+		ref_info.res.width -= left_cropping;
+		ref_info.res.width *= 2;
+		/* In case of left-cropping, add 2 vectors */
+		ref_info.res.width += left_cropping ? 2*ISP_VEC_NELEMS : 0;
+		/* Must be even amount of vectors */
+		ref_info.res.width  = CEIL_MUL(ref_info.res.width,2*ISP_VEC_NELEMS);
+		ref_info.res.height -= left_cropping;
+		ref_info.res.height *= 2;
+		ref_info.res.height += left_cropping;
+	} else if (continuous) {
+		ref_info.res.width -= left_cropping;
+		/* In case of left-cropping, add 2 vectors */
+		ref_info.res.width += left_cropping ? 2*ISP_VEC_NELEMS : 0;
+		/* Must be even amount of vectors */
+		ref_info.res.width  = CEIL_MUL(ref_info.res.width,2*ISP_VEC_NELEMS);
+	}
+
+	ref_info.format = IA_CSS_FRAME_FORMAT_RAW;
+
+	for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
+		/* free previous frame */
+		if (pipe->continuous_frames[i]) {
+			ia_css_frame_free(pipe->continuous_frames[i]);
+			pipe->continuous_frames[i] = NULL;
+		}
+		/* check if new frame needed */
+		if (i < my_css.num_cont_raw_frames) {
+			/* allocate new frame */
+			err = ia_css_frame_allocate_from_info(
+				&pipe->continuous_frames[i],
+				&ref_info);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+	}
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+allocate_mipi_frames(struct sh_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	unsigned int i;
+	struct ia_css_frame_info mipi_intermediate_info;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"allocate_mipi_frames(%p) enter:\n", pipe);
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL); 
+	
+	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: no buffers needed for pipe mode\n",
+			pipe);
+		return IA_CSS_SUCCESS;
+	}
+
+	assert(my_css.size_mem_words != 0);
+	if (my_css.size_mem_words == 0) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: mipi frame size not specified\n",
+			pipe);
+		return err;
+	}
+
+
+	ref_count_mipi_allocation++;	
+	if (ref_count_mipi_allocation > 1) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: already allocated\n",
+			pipe);
+		return IA_CSS_SUCCESS;
+	}
+	assert(ref_count_mipi_allocation == 1);
+	
+// This code needs to modified to allocate the MIPI frames in the correct normal way with a allocate from info
+// by justin
+	mipi_intermediate_info = pipe->pipe.video.video_binary.internal_frame_info;
+	mipi_intermediate_info.res.width = 0;
+	mipi_intermediate_info.res.height = 0;
+	// To indicate it is not (yet) valid format.
+	mipi_intermediate_info.format = IA_CSS_FRAME_FORMAT_NUM;
+	mipi_intermediate_info.padded_width = 0;
+	mipi_intermediate_info.raw_bit_depth = 0;
+	//mipi_intermediate_info.data_bytes = my_css.size_mem_words * HIVE_ISP_DDR_WORD_BYTES;
+	//mipi_intermediate_info.contiguous = my_css.contiguous;
+	// To indicate it is not valid frame.
+	//mipi_intermediate_info.dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+
+	for (i = 0; i < my_css.num_mipi_frames; i++) {
+		/* free previous frame */
+		if (my_css.mipi_frames[i]) {
+			ia_css_frame_free(my_css.mipi_frames[i]);
+			my_css.mipi_frames[i] = NULL;
+		}
+		/* check if new frame needed */
+		if (i < my_css.num_mipi_frames) {
+			/* allocate new frame */
+			err = ia_css_mipi_frame_allocate(
+				&my_css.mipi_frames[i],
+				my_css.size_mem_words * HIVE_ISP_DDR_WORD_BYTES,
+				my_css.contiguous);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			if (SH_CSS_PREVENT_UNINIT_READS)
+				ia_css_frame_zero(my_css.mipi_frames[i]);
+		}
+	}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"allocate_mipi_frames(%p) exit:\n", pipe);
+
+	return err;
+}
+
+static void
+free_mipi_frames(struct sh_css_pipe *pipe, bool uninit)
+{
+	unsigned int i;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"free_mipi_frames(%p, %d) enter:\n", pipe, uninit);
+	if (!uninit) {
+		assert(pipe != NULL); 
+		assert(pipe->stream != NULL); 
+
+		if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"free_mipi_frames() exit: wrong mode\n");
+		return;
+		}
+
+		assert(ref_count_mipi_allocation > 0);
+		ref_count_mipi_allocation--;
+		
+		if (ref_count_mipi_allocation > 0) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"free_mipi_frames(%p, %d) exit: "
+				"not last pipe (ref_count=%d):\n", 
+				pipe, uninit, ref_count_mipi_allocation);
+			return; 
+		}
+	}	
+
+	for (i = 0; i < my_css.num_mipi_frames; i++) {
+		if (my_css.mipi_frames[i] != NULL)
+		{
+			ia_css_frame_free(my_css.mipi_frames[i]);
+			pr_err("free mipi_frames.\n");
+			my_css.mipi_frames[i] = NULL;
+		}
+	}
+	/* TODO: change into return error value instead of assert
+	 * task is pending, disable for now
+	 */
+	//assert(ref_count_mipi_allocation == 0);
+	ref_count_mipi_allocation = 0;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"free_mipi_frames(%p, %d) exit (deallocated):\n", pipe, uninit);
+}
+
+
+static void
+send_mipi_frames (struct sh_css_pipe *pipe)
+{
+	unsigned int i;
+	/* multi stream video needs mipi buffers */
+	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+		return;
+
+	/* Hand-over the SP-internal mipi buffers */
+	for (i = 0; i < my_css.num_mipi_frames; i++) {
+		sh_css_update_host2sp_mipi_frame(i,
+			my_css.mipi_frames[i]);
+	}
+	sh_css_update_host2sp_cont_num_mipi_frames
+		(my_css.num_mipi_frames);
+
+	/**********************************
+	 *
+	 * Hack for Baytrail.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * TIME: 2013-01-19, 14:38.
+	 * LOCATION: Santa Clara, U.S.A.
+	 * COMMENT:
+	 * Send an event to inform the SP
+	 * that all MIPI frames are passed.
+	 *
+	 **********************************/
+	{
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_6,	/* the event ID  */
+			0,				/* not used */
+			0,				/* not used */
+			0				/* not used */);
+	}
+	/** End of hack of Baytrail **/
+}
+
+static enum ia_css_err
+load_preview_binaries(struct sh_css_pipe *pipe)
+{
+	struct ia_css_frame_info prev_in_info,
+				 prev_out_info;
+	bool online = pipe->stream->config.online;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool continuous = pipe->stream->config.continuous;
+	unsigned int left_cropping;
+
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"load_preview_binaries() enter:\n");
+
+	if (pipe->pipe.preview.preview_binary.info &&
+	    pipe->pipe.preview.vf_pp_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = check_input(pipe, false);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = check_frame_info(&pipe->output_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Preview */
+	if (pipe->yuv_ds_input_info.res.width)
+		prev_out_info = pipe->yuv_ds_input_info;
+	else
+		prev_out_info = pipe->output_info;
+	sh_css_frame_info_set_format(&prev_out_info,
+				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+	init_preview_descr(pipe, &prev_in_info, &prev_out_info);
+	err = sh_css_binary_find(&preview_descr,
+				 &pipe->pipe.preview.preview_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Viewfinder post-processing */
+	init_vf_pp_descr(pipe,
+			&pipe->pipe.preview.preview_binary.out_frame_info,
+			&pipe->output_info);
+	err = sh_css_binary_find(&vf_pp_descr,
+				 &pipe->pipe.preview.vf_pp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Copy */
+	if (!online && !continuous) {
+		err = load_copy_binary(pipe,
+				       &pipe->pipe.preview.copy_binary,
+				       &pipe->pipe.preview.preview_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	left_cropping = pipe->pipe.preview.preview_binary.info->left_cropping;
+
+	err = alloc_continuous_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (SH_CSS_PREVENT_UNINIT_READS)
+		ia_css_frame_zero(pipe->continuous_frames[0]);
+
+	if (pipe->shading_table) {
+		ia_css_shading_table_free(pipe->shading_table);
+		pipe->shading_table = NULL;
+	}
+
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return IA_CSS_SUCCESS;
+}
+
+static const struct ia_css_fw_info *last_output_firmware(
+	const struct ia_css_fw_info *fw)
+{
+	const struct ia_css_fw_info *last_fw = NULL;
+/* fw can be NULL */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"last_output_firmware() enter:\n");
+
+	for (; fw; fw = fw->next) {
+		const struct ia_css_fw_info *info = fw;
+		if (info->info.isp.enable.output)
+			last_fw = fw;
+	}
+	return last_fw;
+}
+
+static enum ia_css_err add_firmwares(
+	struct sh_css_pipeline *me,
+	struct sh_css_binary *binary,
+	const struct ia_css_fw_info *fw,
+	const struct ia_css_fw_info *last_fw,
+	unsigned int binary_mode,
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *out_frame,
+	struct ia_css_frame *vf_frame,
+	struct sh_css_pipeline_stage **my_stage,
+	struct sh_css_pipeline_stage **vf_stage)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_pipeline_stage *extra_stage = NULL;
+
+/* all args can be NULL ??? */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"add_firmwares() enter:\n");
+
+	for (; fw; fw = fw->next) {
+		struct ia_css_frame *out = NULL;
+		struct ia_css_frame *in = NULL;
+		struct ia_css_frame *vf = NULL;
+		if ((fw == last_fw) && (fw->info.isp.enable.out_frame  != 0)) {
+			out = out_frame;
+		}
+		if (fw->info.isp.enable.in_frame != 0) {
+			in = in_frame;
+		}
+		if (fw->info.isp.enable.out_frame != 0) {
+			vf = vf_frame;
+		}
+
+		err = sh_css_pipeline_add_stage(me, binary, fw,
+				binary_mode, NULL,
+				in, out,
+				vf, &extra_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (fw->info.isp.enable.output != 0)
+			in_frame = extra_stage->args.out_frame;
+		if (my_stage && !*my_stage && extra_stage)
+			*my_stage = extra_stage;
+		if (vf_stage && !*vf_stage && extra_stage &&
+		    fw->info.isp.enable.vf_veceven)
+			*vf_stage = extra_stage;
+	}
+	return err;
+}
+
+static enum ia_css_err add_vf_pp_stage(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame *out_frame,
+	struct sh_css_binary *vf_pp_binary,
+	struct sh_css_pipeline_stage *post_stage,
+	struct sh_css_pipeline_stage **vf_pp_stage)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+	const struct ia_css_fw_info *last_fw;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *in_frame = post_stage->args.out_vf_frame;
+
+/* out_frame can be NULL ??? */
+assert(pipe != NULL);
+assert(vf_pp_binary != NULL);
+assert(post_stage != NULL);
+assert(vf_pp_stage != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"add_vf_pp_stage() enter:\n");
+
+	*vf_pp_stage = NULL;
+
+	if (in_frame == NULL)
+		in_frame = post_stage->args.out_frame;
+
+	last_fw = last_output_firmware(pipe->vf_stage);
+	if (!pipe->disable_vf_pp) {
+		err = sh_css_pipeline_add_stage(me, vf_pp_binary, NULL,
+				vf_pp_binary->info->mode, NULL,
+				in_frame,
+				last_fw ? NULL : out_frame,
+				NULL, vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_frame = (*vf_pp_stage)->args.out_frame;
+	}
+	err = add_firmwares(me, vf_pp_binary, pipe->vf_stage, last_fw,
+			    SH_CSS_BINARY_MODE_VF_PP,
+			    in_frame, out_frame, NULL,
+			    vf_pp_stage, NULL);
+	return err;
+}
+
+static enum ia_css_err add_capture_pp_stage(
+	struct sh_css_pipe *pipe,
+	struct sh_css_pipeline *me,
+	struct ia_css_frame *out_frame,
+	struct sh_css_binary *capture_pp_binary,
+	struct sh_css_pipeline_stage *capture_stage,
+	struct sh_css_pipeline_stage **pre_vf_pp_stage)
+{
+	const struct ia_css_fw_info *last_fw;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *in_frame = capture_stage->args.out_frame;
+	struct ia_css_frame *vf_frame = NULL;
+
+/* out_frame can be NULL ??? */
+assert(pipe != NULL);
+assert(me != NULL);
+assert(capture_pp_binary != NULL);
+assert(capture_stage != NULL);
+assert(pre_vf_pp_stage != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"add_capture_pp_stage() enter:\n");
+
+	*pre_vf_pp_stage = NULL;
+
+	if (in_frame == NULL)
+		in_frame = capture_stage->args.out_frame;
+
+	last_fw = last_output_firmware(pipe->output_stage);
+	if (!pipe->disable_capture_pp &&
+	    need_capture_pp(pipe)) {
+		err = ia_css_frame_allocate_from_info(&vf_frame,
+					    &capture_pp_binary->vf_frame_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		err = sh_css_pipeline_add_stage(me, capture_pp_binary, NULL,
+				capture_pp_binary->info->mode, NULL,
+				NULL,
+				last_fw ? NULL : out_frame,
+				vf_frame, pre_vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_frame = (*pre_vf_pp_stage)->args.out_frame;
+	}
+	err = add_firmwares(me, capture_pp_binary, pipe->output_stage, last_fw,
+			    SH_CSS_BINARY_MODE_CAPTURE_PP,
+			    in_frame, out_frame, vf_frame,
+			    NULL, pre_vf_pp_stage);
+	/* If a firmware produce vf_pp output, we set that as vf_pp input */
+	if (*pre_vf_pp_stage) {
+		(*pre_vf_pp_stage)->args.extra_frame =
+		  pipe->pipe.capture.capture_pp_frame;
+		(*pre_vf_pp_stage)->args.vf_downscale_log2 =
+		  capture_pp_binary->vf_downscale_log2;
+	} else {
+		*pre_vf_pp_stage = capture_stage;
+	}
+	return err;
+}
+
+static void
+number_stages(
+	struct sh_css_pipe *pipe)
+{
+	unsigned i = 0;
+	struct sh_css_pipeline_stage *stage;
+	for (stage = pipe->pipeline.stages; stage; stage = stage->next) {
+		stage->stage_num = i;
+		i++;
+	}
+	pipe->pipeline.num_stages = i;
+}
+
+void
+sh_css_init_buffer_queues(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_queues_initialized;
+	unsigned int i;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init_buffer_queues() enter:\n");
+
+	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++)
+		hmm_buffer_record_h[i] = NULL;
+
+
+	sh_css_event_init_irq_mask();
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queues_initialized =
+		fw->info.sp.host_sp_queues_initialized;
+
+	/* initialize the "sp2host" queues */
+	init_sp2host_queues();
+
+	/* initialize the "host2sp" queues */
+	init_host2sp_queues();
+
+	/* set "host_sp_queues_initialized" to "true" */
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(1));
+
+	
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init_buffer_queues() leave:\n");
+}
+
+static enum ia_css_err
+preview_start(struct sh_css_pipe *pipe)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+	struct sh_css_pipeline_stage *preview_stage, *copy_stage;
+	struct sh_css_pipeline_stage *vf_pp_stage;
+	struct ia_css_frame *in_frame = NULL, *cc_frame = NULL;
+	struct sh_css_binary *copy_binary, *preview_binary, *vf_pp_binary;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_pipe *copy_pipe, *capture_pipe;
+	enum sh_css_pipe_config_override copy_ovrd;
+	enum ia_css_input_mode preview_pipe_input_mode;
+
+	/**
+	 * rvanimme: raw_out_frame support is broken and forced to NULL
+	 * TODO: add a way to tell the pipeline construction that a
+	 * raw_out_frame is used.
+	 */
+	struct ia_css_frame *raw_out_frame = NULL;
+	struct ia_css_frame *out_frame = &me->out_frame;
+	
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"preview_start() enter: void\n");
+
+	preview_pipe_input_mode = pipe->stream->config.mode;
+
+	copy_pipe    = pipe->pipe.preview.copy_pipe;
+	capture_pipe = pipe->pipe.preview.capture_pipe;
+	
+	sh_css_pipeline_clean(me);
+
+	sh_css_pipe_get_output_frame_info(pipe, &out_frame->info);
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	out_frame->dynamic_data_index = sh_css_frame_out;
+	err = init_frame_planes(out_frame);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	copy_stage = NULL;
+
+	if (pipe->zoom_changed) {
+		sh_css_pipe_invalidate_binaries(pipe);
+		pipe->zoom_changed = false;
+	}
+
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	copy_binary    = &pipe->pipe.preview.copy_binary;
+	preview_binary = &pipe->pipe.preview.preview_binary;
+	vf_pp_binary   = &pipe->pipe.preview.vf_pp_binary;
+
+	sh_css_metrics_start_frame();
+
+	if (me->reload) {
+		struct sh_css_pipeline_stage *post_stage;
+		if (pipe->pipe.preview.copy_binary.info) {
+			err = sh_css_pipeline_add_stage(me, copy_binary, NULL,
+					copy_binary->info->mode,
+					NULL, NULL, raw_out_frame, NULL,
+					&post_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			in_frame = me->stages->args.out_frame;
+		} else {
+			in_frame = pipe->continuous_frames[0];
+		}
+		err = sh_css_pipeline_add_stage(me, preview_binary, NULL,
+						preview_binary->info->mode,
+						cc_frame, in_frame, NULL, NULL,
+						&post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		/* If we use copy iso preview, the input must be yuv iso raw */
+		post_stage->args.copy_vf =
+			preview_binary->info->mode == SH_CSS_BINARY_MODE_COPY;
+		post_stage->args.copy_output = !post_stage->args.copy_vf;
+		if (post_stage->args.copy_vf) {
+			/* in case of copy, use the vf frame as output frame */
+			post_stage->args.out_vf_frame =
+				post_stage->args.out_frame;
+		}
+
+		err = add_vf_pp_stage(pipe, out_frame, vf_pp_binary,
+				      post_stage, &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		number_stages(pipe);
+	} else {
+		sh_css_pipeline_restart(me);
+	}
+
+	err = sh_css_pipeline_get_output_stage(me, SH_CSS_BINARY_MODE_VF_PP,
+					       &vf_pp_stage);
+
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = sh_css_pipeline_get_stage(me, preview_binary->info->mode,
+					&preview_stage);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* multi stream video needs mipi buffers */
+	send_mipi_frames(pipe);
+
+	vf_pp_stage->args.out_frame = out_frame;
+
+	if (pipe->stream->config.continuous) {
+		int i;
+		in_frame = pipe->continuous_frames[0];
+		preview_stage->args.in_frame = in_frame;
+
+		/* Hand-over all the SP-internal buffers */
+		for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
+			sh_css_update_host2sp_offline_frame(i,
+				pipe->continuous_frames[i]);
+		}
+	}
+	/* update the arguments with the latest info */
+
+	sh_css_set_irq_buffer(preview_stage, sh_css_frame_in,  raw_out_frame);
+	sh_css_set_irq_buffer(vf_pp_stage,   sh_css_frame_out, out_frame);
+
+	{
+		unsigned int thread_id;
+		
+		sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+		copy_ovrd = 1 << thread_id;
+		
+		if (pipe->stream->cont_capt) {
+			sh_css_query_sp_thread_id(capture_pipe->pipe_num, &thread_id);
+			copy_ovrd |= 1 << thread_id;
+		}
+	}
+
+	/* Construct and load the copy pipe */
+	if (pipe->stream->config.continuous) {
+		err = construct_copy_pipe(copy_pipe,
+					  preview_binary->info->max_input_width,
+					  pipe->continuous_frames[0]);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		sh_css_sp_init_pipeline(&copy_pipe->pipeline, IA_CSS_PIPE_ID_COPY,
+			copy_pipe->pipe_num,
+			false, false, false,
+			pipe->stream->config.two_pixels_per_clock, false,
+			false, pipe->input_needs_raw_binning,
+			copy_ovrd,
+			pipe->stream->config.mode,
+			pipe->stream->config.source.port.port);
+
+		/* make the preview pipe start with mem mode input, copy handles
+		   the actual mode */
+		preview_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;
+	}
+	
+	/* Construct and load the capture pipe */
+	if (pipe->stream->cont_capt) {
+		bool low_light;
+
+		err = construct_capture_pipe(capture_pipe);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		low_light = (capture_pipe->capture_mode ==
+				IA_CSS_CAPTURE_MODE_LOW_LIGHT) ||
+				(capture_pipe->capture_mode ==
+				IA_CSS_CAPTURE_MODE_BAYER);
+
+		sh_css_sp_init_pipeline(&capture_pipe->pipeline, IA_CSS_PIPE_ID_CAPTURE,
+			capture_pipe->pipe_num,
+			false, low_light, pipe->xnr,
+			capture_pipe->stream->config.two_pixels_per_clock,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->input_needs_raw_binning,
+			0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			(mipi_port_ID_t)0);
+	}
+
+	err = sh_css_config_input_network(pipe, copy_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	start_pipe(pipe, copy_ovrd, preview_pipe_input_mode);
+
+	me->reload = false;
+
+	return IA_CSS_SUCCESS;
+}
+
+static bool
+sh_css_pipe_has_stopped(struct ia_css_pipe *pipe)
+{
+	unsigned int thread_id;
+	struct sh_css_sp_group sp_group;
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_group;
+	
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_group = fw->info.sp.group;
+
+	sh_css_query_sp_thread_id(pipe->old_pipe->pipe_num, &thread_id);
+	sp_dmem_load(SP0_ID,
+		     (unsigned int)sp_address_of(sp_group),
+		     &sp_group,
+		     sizeof(struct sh_css_sp_group));
+	return sp_group.pipe[thread_id].num_stages == 0;
+}
+
+static enum ia_css_err
+sh_css_pipe_request_stop(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id;
+
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_request_stop() enter: pipe=%p\n",
+		pipe);
+	pipe->stop_requested = true;
+	
+	// Send stop event to the sp
+	// This needs improvement, stop on all the pipes available in the stream
+	sh_css_query_sp_thread_id(pipe->old_pipe->pipe_num, &thread_id);
+	sh_css_sp_snd_event(SP_SW_EVENT_ID_5, thread_id, 0,  0);
+	sh_css_sp_uninit_pipeline(pipe->old_pipe->pipe_num);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_request_stop() leave: return_err=%d\n",err);
+	return err;
+}
+
+static enum ia_css_err
+sh_css_pipe_stop(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err;
+
+	err = sh_css_pipe_request_stop(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	/* synchronization here, otherwise we cannot map new pipe to the same thread */
+	while (!sh_css_pipe_has_stopped(pipe))
+		hrt_sleep();
+
+	ia_css_pipe_dequeue_unused_buffer(pipe);
+	
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_stop() leave: return_err=%d\n",err);
+	return err;
+}
+
+enum ia_css_err
+ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			   const struct ia_css_buffer *buffer)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id, i;
+	enum sh_css_buffer_queue_id queue_id;
+	struct sh_css_pipeline *pipeline;
+	struct sh_css_pipeline_stage *stage;
+	struct ia_css_i_host_rmgr_vbuf_handle p_vbuf;
+	struct ia_css_i_host_rmgr_vbuf_handle *h_vbuf;
+	struct sh_css_hmm_buffer ddr_buffer;
+	bool rc = true;
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id pipe_id;
+
+	if (buffer == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (pipe != NULL && pipe->old_pipe)
+		pipe_id = pipe->old_pipe->mode;
+	else
+		pipe_id = IA_CSS_PIPE_ID_COPY;
+
+	assert(buffer != NULL);
+
+	buf_type = buffer->type;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_enqueue_buffer() enter: pipe_id=%d, buf_type=%d, buffer=%p\n",
+		pipe_id, buf_type, buffer);
+
+
+	assert(pipe_id < IA_CSS_PIPE_ID_NUM);
+	assert(buf_type < IA_CSS_BUFFER_TYPE_NUM);
+
+	//sh_css_query_sp_thread_id(pipe_id, &thread_id);
+	sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+	
+	sh_css_query_internal_queue_id(buf_type, &queue_id);
+
+	if (pipe != NULL && pipe->old_pipe != NULL)
+		pipeline = &pipe->old_pipe->pipeline;
+	else
+		pipeline = NULL;
+
+	assert(pipeline != NULL ||
+	       pipe_id == IA_CSS_PIPE_ID_COPY ||
+	       pipe_id == IA_CSS_PIPE_ID_ACC);
+
+	if (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS) {
+		if (buffer->data.stats_3a == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+/* MW: I don't think "ddr_buffer.kernel_ptr" is an hrt_vaddress ?! */
+		ddr_buffer.kernel_ptr = (hrt_vaddress)HOST_ADDRESS(buffer->data.stats_3a);
+		ddr_buffer.payload.s3a = *buffer->data.stats_3a;
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS) {
+		if (buffer->data.stats_dvs == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = (hrt_vaddress)HOST_ADDRESS(buffer->data.stats_dvs);
+		ddr_buffer.payload.dis = *buffer->data.stats_dvs;
+	} else if ((buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)) {
+		if (buffer->data.frame == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = (hrt_vaddress)HOST_ADDRESS(buffer->data.frame);
+		ddr_buffer.payload.frame.frame_data = buffer->data.frame->data;
+		ddr_buffer.payload.frame.flashed = 0;
+	}
+/* start of test for using rmgr for acq/rel memory */
+	p_vbuf.vptr = 0;
+	p_vbuf.count = 0;
+	p_vbuf.size = sizeof(struct sh_css_hmm_buffer);
+	h_vbuf = &p_vbuf;
+	// TODO: change next to correct pool for optimization
+	ia_css_i_host_rmgr_acq_vbuf(hmm_buffer_pool, &h_vbuf);
+
+	assert(h_vbuf != NULL);
+	assert(h_vbuf->vptr != 0x0);
+	if (h_vbuf == NULL || h_vbuf->vptr == mmgr_NULL)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	mmgr_store(h_vbuf->vptr,
+				(void *)(&ddr_buffer),
+				sizeof(struct sh_css_hmm_buffer));
+	if ((buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS)) {
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			/* The SP will read the params
+				after it got empty 3a and dis */
+			if (STATS_ENABLED(stage)) {
+				/* there is a stage that needs it */
+				rc = host2sp_enqueue_buffer(thread_id, 0,
+						queue_id,
+						(uint32_t)h_vbuf->vptr);
+			}
+		}
+	} else if ((buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)) {
+			rc = host2sp_enqueue_buffer(thread_id,
+				0,
+				queue_id,
+				(uint32_t)h_vbuf->vptr);
+	}
+
+	err = (rc == true) ?
+		IA_CSS_SUCCESS : IA_CSS_ERR_QUEUE_IS_FULL;
+
+	if (err == IA_CSS_SUCCESS) {
+		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+			if (hmm_buffer_record_h[i] == NULL) {
+				hmm_buffer_record_h[i] = h_vbuf;
+				sh_css_dtrace(SH_DBG_TRACE,
+					     "ia_css_pipe_enqueue_buffer()"
+					     " send vbuf=%x\n",h_vbuf);
+				break;
+			}
+		}
+	} else {
+		ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);
+	}
+
+		/*
+		 * Tell the SP which queues are not empty,
+		 * by sending the software event.
+		 */
+	if (err == IA_CSS_SUCCESS)
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_1,
+				thread_id,
+				queue_id,
+				0);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_enqueue_buffer() leave: return_err=%d\n",err);
+	return err;
+}
+
+/*
+ * TODO: Free up the hmm memory space.
+	 */
+enum ia_css_err
+ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			   struct ia_css_buffer *buffer)
+{
+	enum ia_css_err err;
+	enum sh_css_buffer_queue_id queue_id;
+	hrt_vaddress ddr_buffer_addr;
+	struct sh_css_hmm_buffer ddr_buffer;
+	bool rc;
+	unsigned int i, found_record;
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id pipe_id;
+	struct sh_css_pipe *old_pipe = NULL;
+
+	assert(buffer != NULL);
+
+	if (pipe)
+		old_pipe = pipe->old_pipe;
+
+	if (old_pipe)
+		pipe_id = old_pipe->mode;
+	else
+		pipe_id = IA_CSS_PIPE_ID_COPY;
+
+	buf_type = buffer->type;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_dequeue_buffer() enter: pipe_id=%d, buf_type=%d\n",
+		(int)pipe_id, buf_type);
+
+	ddr_buffer.kernel_ptr = 0;
+
+	sh_css_query_internal_queue_id(buf_type, &queue_id);
+
+	rc = sp2host_dequeue_buffer(0,
+				0,
+				queue_id,
+				&ddr_buffer_addr);
+	if (rc) {
+		struct ia_css_frame *frame;
+		sh_css_dtrace(SH_DBG_TRACE,
+			     "ia_css_pipe_dequeue_buffer() receive vbuf=%x\n",
+			     (int)ddr_buffer_addr);
+
+		found_record = 0;
+		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+			if (hmm_buffer_record_h[i] != NULL && hmm_buffer_record_h[i]->vptr == ddr_buffer_addr) {
+				ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
+				hmm_buffer_record_h[i] = NULL;
+				found_record = 1;
+				break;
+			}
+		}
+		assert(found_record == 1);
+
+		mmgr_load(ddr_buffer_addr,
+				&ddr_buffer,
+				sizeof(struct sh_css_hmm_buffer));
+
+		assert(ddr_buffer.kernel_ptr != 0);
+
+		if (ddr_buffer.kernel_ptr == 0)
+			rc = false;
+
+		switch (buf_type) {
+		case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
+			if (pipe->stop_requested == true)
+			{
+				free_mipi_frames(old_pipe, false);
+				pipe->stop_requested = false;
+			}
+		case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
+			frame = (struct ia_css_frame*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+			buffer->data.frame = frame;
+			if (ddr_buffer.payload.frame.exp_id)
+				frame->exp_id = ddr_buffer.payload.frame.exp_id;
+			/* JWU */
+			frame->frame_nr= ddr_buffer.payload.frame.frame_nr;
+			
+			if (ddr_buffer.payload.frame.flashed == 1)
+				frame->flash_state =
+					IA_CSS_FRAME_FLASH_STATE_PARTIAL;
+			if (ddr_buffer.payload.frame.flashed == 2)
+				frame->flash_state =
+					IA_CSS_FRAME_FLASH_STATE_FULL;
+			if (old_pipe) {
+				frame->valid = old_pipe->num_invalid_frames == 0;
+				if (!frame->valid)
+					old_pipe->num_invalid_frames--;
+				if (frame->info.format ==
+						IA_CSS_FRAME_FORMAT_BINARY_8) {
+					frame->planes.binary.size =
+					    sh_css_sp_get_binary_copy_size();
+				}
+			}
+		
+			sh_css_dtrace(SH_DBG_DEBUG,
+				"ia_css_pipe_dequeue_buffer() pipe number=%d, frame number=%p\n", pipe->pipe_num, frame->frame_nr);
+		
+			break;
+		case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
+			buffer->data.stats_3a =
+				(struct ia_css_isp_3a_statistics*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+			break;
+		case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
+			buffer->data.stats_dvs =
+				(struct ia_css_isp_dvs_statistics*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+			break;
+		default:
+			rc = false;
+			break;
+		}
+	}
+
+	err = rc ? IA_CSS_SUCCESS : IA_CSS_ERR_QUEUE_IS_EMPTY;
+
+	/*
+	 * Tell the SP which queues are not full,
+	 * by sending the software event.
+	 */
+	if (err == IA_CSS_SUCCESS)
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_2,
+				0,
+				queue_id,
+				0);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_dequeue_buffer() leave: buffer=%p\n", buffer);
+
+	return err;
+}
+
+static enum ia_css_err
+ia_css_pipe_dequeue_unused_buffer(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum sh_css_buffer_queue_id queue_id;
+	hrt_vaddress ddr_buffer_addr;
+	struct sh_css_hmm_buffer ddr_buffer;
+	bool rc;
+	unsigned int i, found_record, thread_id;
+	enum ia_css_pipe_id pipe_id;
+	struct sh_css_pipe *old_pipe = NULL;
+	struct sh_css_ddr_address_map map;
+	hrt_vaddress *addrs = (hrt_vaddress *)&map;
+
+	if (pipe)
+	       old_pipe = pipe->old_pipe;
+
+	if (old_pipe)
+		pipe_id = old_pipe->mode;
+	else
+		pipe_id = IA_CSS_PIPE_ID_COPY;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_dequeue_unused_buffer() enter: pipe_id=%d\n",
+		(int)pipe_id);
+
+	ddr_buffer.kernel_ptr = 0;
+
+	sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+
+    /* for frame buffers */
+    for (queue_id = 0; queue_id < (SH_CSS_NUM_BUFFER_QUEUES - 2); queue_id++) {
+		rc = host2sp_dequeue_buffer(thread_id,
+				0,
+				queue_id,
+				&ddr_buffer_addr);
+		if (rc) {
+			mmgr_load(ddr_buffer_addr,
+				&ddr_buffer,
+				sizeof(struct sh_css_hmm_buffer));
+			found_record = 0;
+			for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+				if (hmm_buffer_record_h[i] != NULL && hmm_buffer_record_h[i]->vptr == ddr_buffer_addr) {
+					ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
+					hmm_buffer_record_h[i] = NULL;
+					found_record = 1;
+					break;
+				}
+			}
+			assert(found_record == 1);
+			assert(ddr_buffer.kernel_ptr != 0);
+
+			if (ddr_buffer.kernel_ptr == 0)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+		} else {
+			continue;
+		}
+	}
+
+	/* for param buffers */
+	rc = host2sp_dequeue_buffer(thread_id,
+				0,
+				queue_id,
+				&ddr_buffer_addr);
+	if (rc) {
+		mmgr_load(ddr_buffer_addr, &map, sizeof(struct sh_css_ddr_address_map));
+		/* copy map using size info */
+		for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+			if (addrs[i] == mmgr_NULL)
+				continue;
+			sh_css_refcount_release(PARAM_BUFFER, addrs[i]);
+		}
+		sh_css_refcount_release(PARAM_SET_POOL, ddr_buffer_addr);
+	}
+
+	/* for tag command */
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_dequeue_buffer() leave:\n");
+
+	return err;
+}
+
+static void decode_sp_event(
+	uint32_t event,
+ 	enum ia_css_event_type *event_id,
+ 	uint8_t *arg1,
+ 	uint8_t *arg2,
+ 	uint8_t *arg3)
+{
+	enum ia_css_event_type event_code;
+
+ 	assert(arg1 != NULL);
+ 	assert(arg2 != NULL);
+ 	assert(arg3 != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "decode_sp_event() enter:\n");
+
+	/* First decode according to the common case
+	 * In case of a PORT_EOF event we overwrite with 
+	 * the specific values
+	 * This is somewhat ugly but probably somewhat efficient 
+	 * (and it avoids some code duplication)
+	 */
+ 	*arg1 = (event >> 8) & 0xff;
+ 	*arg2 = (event >> 16) & 0xff;
+ 	*arg3 = 0;
+	event_code = event & 0xff;
+
+	/* convert event_code from sp (SH) domain to host (IA) domain */
+	switch (event_code) {
+	case SH_CSS_SP_EVENT_OUTPUT_FRAME_DONE:
+		event_code = IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE;
+		break;
+	case SH_CSS_SP_EVENT_VF_OUTPUT_FRAME_DONE:
+		event_code = IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE;
+		break;
+	case SH_CSS_SP_EVENT_3A_STATISTICS_DONE:
+		event_code = IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE;
+		break;
+	case SH_CSS_SP_EVENT_DIS_STATISTICS_DONE:
+		event_code = IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE;
+		break;
+	case SH_CSS_SP_EVENT_PIPELINE_DONE:
+		event_code = IA_CSS_EVENT_TYPE_PIPELINE_DONE;
+		break;
+	case SH_CSS_SP_EVENT_PORT_EOF:
+		event_code = IA_CSS_EVENT_TYPE_PORT_EOF;
+ 		*arg2 = 0;
+ 		*arg3 = (event >> 24) & 0xff;
+ 		break;
+ 	case SH_CSS_SP_EVENT_FRAME_TAGGED:
+ 		event_code = IA_CSS_EVENT_TYPE_FRAME_TAGGED;
+ 		*arg3 = (event >> 24) & 0xff;
+		break;
+	default:
+		break;
+	}
+	*event_id = event_code;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "decode_sp_event() leave:\n");
+}
+
+
+enum ia_css_err
+ia_css_dequeue_event(struct ia_css_event *event)
+{
+	bool is_event_available;
+	uint32_t sp_event;
+	enum ia_css_pipe_id pipe_id;
+	uint8_t arg1 = 0;
+	uint8_t arg2 = 0;
+	uint8_t arg3 = 0;
+
+	assert(event);
+
+	/* dequeue the IRQ event */
+	is_event_available = sp2host_dequeue_irq_event(&sp_event);
+
+	/* check whether the IRQ event is available or not */
+	if (!is_event_available) {
+		//sh_css_dtrace(SH_DBG_TRACE,
+		//      "ia_css_dequeue_event() out: EVENT_QUEUE_EMPTY\n");
+		return IA_CSS_ERR_QUEUE_IS_EMPTY;
+	} else {
+		/*
+		 * Tell the SP which queues are not full,
+		 * by sending the software event.
+		 */
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_3, 0, 0, 0);
+	}
+
+ 	decode_sp_event(sp_event, &event->type, &arg1, &arg2, &arg3);
+ 	pipe_id = (enum ia_css_pipe_id)arg2;
+	
+	if (event->type != IA_CSS_EVENT_TYPE_PORT_EOF) {
+		/* pipe related events */
+		event->pipe = find_pipe_by_num(arg1);
+	if (!event->pipe)
+	{
+		/* an event is generated of a port that is not longer available*/
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+		}
+ 		event->port = 0; 
+ 		event->exp_id = 0; 
+ 		if (event->type == IA_CSS_EVENT_TYPE_FRAME_TAGGED)
+ 		{
+			/* find the capture pipe that goes with this */
+ 			int i, n;
+ 			n = event->pipe->old_pipe->stream->num_pipes;
+ 			for (i = 0; i < n; i++)
+ 			{
+ 				if (event->pipe->old_pipe->stream->pipes[i]->config.mode == IA_CSS_PIPE_MODE_CAPTURE)
+ 				{
+ 					event->pipe = event->pipe->old_pipe->stream->pipes[i];
+ 					break;
+ 				}
+ 			}
+ 			event->exp_id = arg3;
+	}
+	}
+	else {
+
+		/* event is not directly correlated to a pipe */
+		event->pipe = NULL;
+ 		event->port = arg1;
+ 		event->exp_id = arg3;
+	}
+#if 0
+  /* temporary debug code to dump the intermediate vf buffer to raw file*/
+	if (event->type == IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE)
+	{
+	  static int count = 0;
+	  FILE* fp;
+    char *xmem_y_addr  = (char*)(event->pipe->old_pipe->pipeline.stages->args.out_vf_frame->data + event->pipe->old_pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.offset);
+    unsigned stride = event->pipe->old_pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.stride;
+    unsigned height = event->pipe->old_pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.height;
+    //printf ("init_frame_pointers format %d\n", stage->frames.in.info.format);
+    //if (stage->frames.in.info.format == IA_CSS_FRAME_FORMAT_YUV_LINE) {
+    unsigned char pixel;
+    unsigned char buf[5000];
+    unsigned int i;
+    mmgr_load(xmem_y_addr, &pixel, sizeof(char));
+    printf ("vf_pp: line 0 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 1 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+2*stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 2 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+3*stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 3 pixel %d\n", pixel);
+
+    fp = fopen("dump.raw", "w+");
+
+    for (i=0; i< height/2; i++)
+    {
+      mmgr_load(xmem_y_addr, buf, stride);
+      fwrite(buf, 1, stride, fp);
+      xmem_y_addr += stride;
+      mmgr_load(xmem_y_addr, buf, stride);
+      fwrite(buf, 1, stride, fp);
+      xmem_y_addr += stride;
+      xmem_y_addr += stride;
+
+    }
+    fclose(fp);
+  
+    count++;
+	}
+#endif
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_dequeue_event() leave: pipe_id=%d, event_id=%d\n",
+				pipe_id, event->type);
+
+	return IA_CSS_SUCCESS;
+}
+
+static void
+acc_start(struct sh_css_pipe *pipe)
+{
+	sh_css_start_pipeline(pipe->mode, &pipe->pipeline);
+//	while(!ia_css_sp_has_initialized())
+//		hrt_sleep();
+//	sh_css_init_host_sp_control_vars();
+//	sh_css_init_buffer_queues();
+	start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD, pipe->stream->config.mode);
+}
+
+static enum ia_css_err
+sh_css_pipe_start(struct ia_css_stream *stream)
+{
+	enum ia_css_err err;
+	struct ia_css_pipe *pipe = stream->last_pipe;
+	struct sh_css_pipe *old_pipe = pipe->old_pipe;
+	enum ia_css_pipe_id pipe_id = old_pipe->mode;
+	unsigned int thread_id;
+	//static bool init_queues = true; /* Workaround */
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_start() enter: pipe_id=%d\n", pipe_id);
+#ifdef __KERNEL__
+	printk("sh_css_pipe_start() enter: pipe_id=%d\n", pipe_id);
+#endif
+
+	old_pipe->pipe_num = pipe->pipe_num;
+	pipe->stop_requested = false;
+
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		err = preview_start(old_pipe);
+		break;
+	case IA_CSS_PIPE_ID_VIDEO:
+		err = video_start(old_pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		err = capture_start(old_pipe);
+		break;
+	case IA_CSS_PIPE_ID_ACC:
+		acc_start(old_pipe);
+		err = IA_CSS_SUCCESS;
+		break;
+	default:
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (err != IA_CSS_SUCCESS) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_start() leave: return_err=%d\n", err);
+		return err;
+	}
+	
+	/* Force ISP parameter calculation after a mode change 
+	 * Acceleration API examples pass NULL for stream but they
+	 * don't use ISP parameters anyway. So this should be okay.
+	 * The SP binary (jpeg) copy does not use any parameters.
+	 */
+	if (stream && !copy_on_sp(old_pipe)) {
+		sh_css_invalidate_params(stream);
+		sh_css_param_update_isp_params(stream, true);
+	}
+
+	sh_css_debug_pipe_graph_dump_epilogue();
+
+	sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+	sh_css_sp_snd_event(SP_SW_EVENT_ID_4, thread_id, 0,  0);
+
+	/* in case of continuous capture mode, we also start capture thread and copy thread*/
+	if (old_pipe->stream->config.continuous) {
+		struct sh_css_pipe *copy_pipe = NULL;
+		if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			copy_pipe = pipe->old_pipe->pipe.preview.copy_pipe;
+		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
+			copy_pipe = pipe->old_pipe->pipe.video.copy_pipe;
+		
+		assert(copy_pipe != NULL);
+		sh_css_query_sp_thread_id(copy_pipe->pipe_num, &thread_id);
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_4, thread_id, 0,  0);
+	}
+	if (old_pipe->stream->cont_capt) {
+		struct sh_css_pipe *capture_pipe = NULL;
+		if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			capture_pipe = pipe->old_pipe->pipe.preview.capture_pipe;
+		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
+			capture_pipe = pipe->old_pipe->pipe.video.capture_pipe;
+
+		assert(capture_pipe != NULL);
+		sh_css_query_sp_thread_id(capture_pipe->pipe_num, &thread_id);
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_4, thread_id, 0,  0);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_start() leave: return_err=%d\n", err);
+	return err;
+}
+
+#if 0
+static enum ia_css_err sh_css_pipeline_stop(
+	struct sh_css_pipe *pipe)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipeline_stop() enter\n");
+	(void)pipe;
+	/* TO BE IMPLEMENTED */
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipeline_stop() exit\n");
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+static enum ia_css_err
+sh_css_pipe_get_input_resolution(struct sh_css_pipe *pipe,
+				 unsigned int *width,
+				 unsigned int *height)
+{
+	enum ia_css_err err;
+
+	assert(width != NULL);
+	assert(height != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_get_input_resolution() enter: void\n");
+	if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE && copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		*width = JPEG_BYTES;
+		*height = 1;
+		return IA_CSS_SUCCESS;
+	}
+
+
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err == IA_CSS_SUCCESS) {
+		const struct sh_css_binary *binary = NULL;
+		if (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {
+			sh_css_dtrace(SH_DBG_TRACE,
+				"sh_css_pipe_get_input_resolution: preview\n");
+			if (pipe->pipe.preview.copy_binary.info)
+				binary = &pipe->pipe.preview.copy_binary;
+			else
+				binary = &pipe->pipe.preview.preview_binary;
+
+		}
+		else if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {
+			sh_css_dtrace(SH_DBG_TRACE,
+				"sh_css_pipe_get_input_resolution: video\n");
+			if (pipe->pipe.video.copy_binary.info)
+				binary = &pipe->pipe.video.copy_binary;
+			else
+				binary = &pipe->pipe.video.video_binary;
+		}
+		else if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE) {
+			sh_css_dtrace(SH_DBG_TRACE,
+				"sh_css_pipe_get_input_resolution: capture\n");
+			if (pipe->pipe.capture.copy_binary.info)
+				binary = &pipe->pipe.capture.copy_binary;
+			else if (pipe->pipe.capture.primary_binary.info)
+				binary = &pipe->pipe.capture.primary_binary;
+			else
+				binary = &pipe->pipe.capture.pre_isp_binary;
+		}
+		*width  = binary->in_frame_info.res.width +
+			columns_needed_for_bayer_order(pipe);
+		*height = binary->in_frame_info.res.height +
+			lines_needed_for_bayer_order(pipe);
+	/* TODO: Remove this when the decimated resolution is available */
+	/* Only for continuous preview mode where we need 2xOut resolution */
+		if (pipe->input_needs_raw_binning &&
+		pipe->pipe.preview.preview_binary.info->enable.raw_binning) {
+			*width *= 2;
+			*width -= binary->info->left_cropping;
+			*height *= 2;
+			*height -= binary->info->left_cropping;
+		}
+	}
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_get_input_resolution() leave: width=%d, height=%d err=%d\n",
+		*width, *height, err);
+	return err;
+}
+
+void
+sh_css_enable_cont_capt(bool enable, bool stop_copy_preview)
+{
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_enable_cont_capt() enter: enable=%d\n", enable);
+	//my_css.cont_capt = enable;
+	my_css.stop_copy_preview = stop_copy_preview;
+}
+
+bool
+sh_css_continuous_is_enabled(uint8_t pipe_num)
+{
+	struct ia_css_pipe *pipe;
+	bool continuous;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_is_enabled() enter: void\n");
+	
+	pipe = find_pipe_by_num(pipe_num);
+	continuous = pipe && pipe->old_pipe->stream->config.continuous;
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_continuous_is_enabled() leave: enable=%d\n",
+		continuous);
+	return continuous;
+}
+
+enum ia_css_err
+ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream, int *buffer_depth)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_get_max_buffer_depth() enter: void\n");
+(void)stream;
+	*buffer_depth = NUM_CONTINUOUS_FRAMES;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_set_buffer_depth() enter: num_frames=%d\n",buffer_depth);
+(void)stream;
+	if (buffer_depth > NUM_CONTINUOUS_FRAMES || buffer_depth < 1)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	/* ok, value allowed */
+	my_css.num_cont_raw_frames = buffer_depth;
+	// TODO: check what to regarding initialization
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_get_buffer_depth() enter: void\n");
+(void)stream;
+	*buffer_depth = my_css.num_cont_raw_frames;
+	return IA_CSS_SUCCESS;
+}
+
+bool
+sh_css_continuous_start_sp_copy(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_start_sp_copy() enter: void\n");
+	return my_css.start_sp_copy;
+}
+
+static enum ia_css_err sh_css_pipe_configure_output(
+	struct sh_css_pipe *pipe,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_configure_output() enter:\n");
+
+	err = check_res(width, height);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (pipe->output_info.res.width != width ||
+	    pipe->output_info.res.height != height ||
+	    pipe->output_info.format != format) {
+		sh_css_frame_info_init(&pipe->output_info, width, height, format, pipe->mode==IA_CSS_PIPE_ID_VIDEO ? SH_CSS_VIDEO_BUFFER_ALIGNMENT : 0);
+		sh_css_pipe_invalidate_binaries(pipe);
+	}
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_pipe_get_grid_info(struct sh_css_pipe *pipe,
+			  struct ia_css_grid_info *info)
+{
+	enum ia_css_err err;
+	struct sh_css_binary *s3a_binary = NULL;
+
+	assert(pipe != NULL);
+	assert(info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_get_grid_info() enter:\n");
+
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err == IA_CSS_SUCCESS) {	
+		s3a_binary = ia_css_pipe_get_3a_binary(pipe->new_pipe);
+		if (s3a_binary)
+			sh_css_binary_grid_info(s3a_binary, info);
+		else
+			memset(info, 0, sizeof(*info));
+	}
+	return err;
+}
+
+static void init_video_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *vf_info)
+{
+	int mode = SH_CSS_BINARY_MODE_VIDEO;
+	bool stream_dz_config = false;
+/* vf_info can be NULL */
+assert(pipe != NULL);
+assert(in_info != NULL);
+/* assert(vf_info != NULL); */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_video_descr() enter:\n");
+
+	if (input_format_is_yuv(pipe->stream->config.format))
+		mode = SH_CSS_BINARY_MODE_COPY;
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	init_offline_descr(pipe,
+			   &video_descr,
+			   mode,
+			   in_info,
+			   &pipe->output_info,
+			   vf_info);
+	if (pipe->stream->config.online) {
+		video_descr.online	    = pipe->stream->config.online;
+		video_descr.two_ppc       = pipe->stream->config.two_pixels_per_clock;
+	}
+	if (mode == SH_CSS_BINARY_MODE_VIDEO) {
+		stream_dz_config = ((pipe->stream->isp_params_configs->dz_config.dx != HRT_GDC_N)
+				 || (pipe->stream->isp_params_configs->dz_config.dy != HRT_GDC_N));
+
+		video_descr.enable_dz           = pipe->enable_dz || stream_dz_config;
+		video_descr.dvs_env             = pipe->dvs_envelope;
+		video_descr.enable_yuv_ds       = pipe->enable_yuv_ds;
+		video_descr.enable_high_speed   = pipe->enable_high_speed;
+		video_descr.enable_dvs_6axis    = pipe->enable_dvs_6axis;
+		video_descr.enable_reduced_pipe = pipe->enable_reduced_pipe;
+		video_descr.isp_pipe_version    = pipe->isp_pipe_version;
+		video_descr.binning             = pipe->input_needs_raw_binning;
+	}
+}
+
+
+/*
+ * @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
+ * PLEASE DO NOT REMOVE IT!
+ */
+#if DVS_REF_TESTING
+static enum ia_css_err alloc_frame_from_file(
+	struct sh_css_pipe *pipe,
+	int width,
+	int height)
+{
+	FILE *fp;
+	int len = 0, err;
+	int bytes_per_pixel;
+	const char *file = "../File_input/dvs_input2.yuv";
+	char *y_buf, *u_buf, *v_buf;
+	char *uv_buf;
+	int offset = 0;
+	int h, w;
+	hrt_vaddress out_base_addr = pipe->pipe.video.ref_frames[0]->data;
+	hrt_vaddress out_y_addr  = out_base_addr
+		+ pipe->pipe.video.ref_frames[0]->planes.yuv.y.offset;
+	hrt_vaddress out_uv_addr = out_base_addr
+		+ pipe->pipe.video.ref_frames[0]->planes.yuv.u.offset;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "alloc_frame_from_file() enter:\n");
+
+	bytes_per_pixel = sizeof(char);
+
+	if (!file) {printf("Error: Input file for dvs is not specified\n"); return 1;}
+	fp = fopen(file, "rb");
+	if (!fp) {printf("Error: Input file for dvs is not found\n"); return 1;}
+
+	err = fseek(fp, 0, SEEK_END);
+	if (err) {
+		fclose(fp);
+	  	printf("Error: Fseek error\n");
+	  	return 1;
+	}
+	len = ftell(fp);
+
+	err = fseek(fp, 0, SEEK_SET);
+	if (err) {
+		fclose(fp);
+		printf("Error: Fseek error2\n");
+		return 1;
+	}
+
+	len = 2 * len / 3;
+	if (len != width * height * bytes_per_pixel) {
+		fclose(fp);
+		printf("Error: File size mismatches with the internal resolution\n");
+		return 1;
+	}
+
+	y_buf = (char *) malloc(len);
+	u_buf = (char *) malloc(len/4);
+	v_buf = (char *) malloc(len/4);
+	uv_buf= (char *) malloc(len/2);
+
+	fread(y_buf, 1, len, fp);
+	fread(u_buf, 1, len/4, fp);
+	fread(v_buf, 1, len/4, fp);
+
+	for (h=0; h<height/2; h++) {
+		for (w=0; w<width/2; w++) {
+			*(uv_buf + offset + w) = *(u_buf++);
+			*(uv_buf + offset + w + width/2) = *(v_buf++);
+			//printf("width: %d\n", width);
+			//printf("offset_u: %d\n", offset+w);
+			//printf("offset_v: %d\n", offset+w+width/2);
+		}
+		offset += width;
+	}
+
+	mmgr_store(out_y_addr, y_buf, len);
+	mmgr_store(out_uv_addr, uv_buf, len/2);
+
+	out_base_addr = pipe->pipe.video.ref_frames[1]->data;
+	out_y_addr  = out_base_addr + pipe->pipe.video.ref_frames[1]->planes.yuv.y.offset;
+	out_uv_addr = out_base_addr + pipe->pipe.video.ref_frames[1]->planes.yuv.u.offset;
+	mmgr_store(out_y_addr, y_buf, len);
+	mmgr_store(out_uv_addr, uv_buf, len/2);
+
+	fclose(fp);
+
+	return IA_CSS_SUCCESS;
+}
+
+/* MW: Why do we not pass the pointer to the struct ? */
+static enum ia_css_err fill_ref_frame_for_dvs(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info ref_info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "fill_ref_frame_for_dvs() enter:\n");
+	/* Allocate tmp_frame which is used to store YUV420 input.
+	 * Read YUV420 input from the file to tmp_frame.
+	 * Convert from YUV420 to NV12 format */
+	err = alloc_frame_from_file(pipe, ref_info.res.width, ref_info.res.height);
+
+	return err;
+}
+#endif
+
+#define SH_CSS_TNR_BIT_DEPTH 8
+#define SH_CSS_REF_BIT_DEPTH 8
+
+static enum ia_css_err load_video_binaries(
+	struct sh_css_pipe *pipe)
+{
+	struct ia_css_frame_info video_in_info, ref_info, tnr_info,
+				 *video_vf_info;
+	bool online;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool continuous = pipe->stream->config.continuous;
+	unsigned int i;
+	unsigned num_output_pins;
+	bool resolution_differs = false;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_video_binaries() enter:\n");
+	/* we only test the video_binary because offline video doesn't need a
+	 * vf_pp binary and online does not (always use) the copy_binary.
+	 * All are always reset at the same time anyway.
+	 */
+	if (pipe->pipe.video.video_binary.info)
+		return IA_CSS_SUCCESS;
+
+	online = pipe->stream->config.online;
+	err = check_input(pipe, !online);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	/* cannot have online video and input_mode memory */
+	if (online && pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe->enable_viewfinder) {
+		err = check_vf_out_info(&pipe->output_info,
+					&pipe->vf_output_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		err = check_frame_info(&pipe->output_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Video */
+	if (pipe->enable_viewfinder){
+		video_vf_info = &pipe->vf_output_info;
+		resolution_differs = (video_vf_info->res.width != pipe->output_info.res.width) || (video_vf_info->res.height != pipe->output_info.res.height);
+	}
+	else {
+		video_vf_info = NULL;
+	}
+	init_video_descr(pipe, &video_in_info, video_vf_info);
+
+	err = sh_css_binary_find(&video_descr,
+				 &pipe->pipe.video.video_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	num_output_pins = pipe->pipe.video.video_binary.info->num_output_pins;
+	/* This is where we set the flag for invalid first frame */
+	if (video_vf_info || (pipe->dvs_frame_delay == IA_CSS_FRAME_DELAY_2) )
+		pipe->num_invalid_frames = 2;
+	else
+		pipe->num_invalid_frames = 1;
+
+	/* Copy */
+	if (!online && !continuous) {
+		/* TODO: what exactly needs doing, prepend the copy binary to
+		 *	 video base this only on !online?
+		 */
+		err = load_copy_binary(pipe,
+				       &pipe->pipe.video.copy_binary,
+				       &pipe->pipe.video.video_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Viewfinder post-processing */
+	if (pipe->enable_viewfinder &&  // only when viewfinder is enabled.
+	   ((num_output_pins == 1)        // when the binary has a single output pin, we need vf_pp
+      || ((num_output_pins == 2) && resolution_differs)) ) { // when the binary has dual output pin, we only need vf_pp in case the resolution is different.
+		init_vf_pp_descr(pipe,
+			&pipe->pipe.video.video_binary.vf_frame_info,
+			&pipe->vf_output_info);
+		err = sh_css_binary_find(&vf_pp_descr,
+				&pipe->pipe.video.vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* yuv copy does not use reference frames */
+	if (input_format_is_yuv(pipe->stream->config.format))
+		return IA_CSS_SUCCESS;
+
+	ref_info = pipe->pipe.video.video_binary.internal_frame_info;
+	ref_info.format = IA_CSS_FRAME_FORMAT_YUV420;
+	ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+
+	/*Allocate the exact number of required reference buffers */
+	for (i = 0; i <= pipe->dvs_frame_delay ; i++){
+		if (pipe->pipe.video.ref_frames[i]) {
+			ia_css_frame_free(pipe->pipe.video.ref_frames[i]);
+			pipe->pipe.video.ref_frames[i] = NULL;
+		}
+		err = ia_css_frame_allocate_from_info(
+				&pipe->pipe.video.ref_frames[i],
+				&ref_info);
+		if (SH_CSS_PREVENT_UNINIT_READS) {
+			ia_css_frame_zero(pipe->pipe.video.ref_frames[i]);
+		}
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+
+#if DVS_REF_TESTING
+	/* @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
+	 * To test dvs-6axis:
+	 * 1. Enable this function call
+	 * 2. Set "reqs.ref_out_requests" to "0" in lineloop.hive.c
+	 */
+	err = fill_ref_frame_for_dvs(pipe, ref_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+#endif
+
+
+  if (pipe->pipe.video.video_binary.info->enable.block_output){
+    tnr_info = pipe->pipe.video.video_binary.out_frame_info;
+  }
+  else {
+    tnr_info = pipe->pipe.video.video_binary.internal_frame_info;
+  }
+	tnr_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+	tnr_info.raw_bit_depth = SH_CSS_TNR_BIT_DEPTH;
+
+	for (i = 0; i < NUM_TNR_FRAMES; i++) {
+		if (pipe->pipe.video.tnr_frames[i]) {
+			ia_css_frame_free(pipe->pipe.video.tnr_frames[i]);
+			pipe->pipe.video.tnr_frames[i] = NULL;
+		}
+		err = ia_css_frame_allocate_from_info(
+				&pipe->pipe.video.tnr_frames[i],
+				&tnr_info);
+		if (SH_CSS_PREVENT_UNINIT_READS) {
+			ia_css_frame_zero(pipe->pipe.video.tnr_frames[i]);
+		}
+		
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	if (pipe->stream->cont_capt) {
+		err = alloc_continuous_frames(pipe);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	
+		if (SH_CSS_PREVENT_UNINIT_READS)
+			ia_css_frame_zero(pipe->continuous_frames[0]);
+	}
+	
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err video_start(
+	struct sh_css_pipe *pipe)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+	struct sh_css_pipeline_stage *copy_stage  = NULL;
+	struct sh_css_pipeline_stage *video_stage = NULL;
+	struct sh_css_pipeline_stage *vf_pp_stage = NULL;
+	struct sh_css_pipeline_stage *in_stage    = NULL;
+	struct sh_css_binary *copy_binary, *video_binary, *vf_pp_binary;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_pipe *copy_pipe, *capture_pipe;
+	enum sh_css_pipe_config_override copy_ovrd;
+	enum ia_css_input_mode video_pipe_input_mode;
+	/**
+	 * rvanimme: in_frame support is broken and forced to NULL
+	 * TODO: add a way to tell the pipeline construction that an in_frame
+	 * is used.
+	 */
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *out_frame = &pipe->out_frame_struct;
+	struct ia_css_frame *vf_frame = &pipe->vf_frame_struct;
+	unsigned num_output_pins;
+	bool need_vf_pp;
+	bool resolution_differs;
+
+	pipe->out_frame_struct.data = 0;
+	pipe->vf_frame_struct.data = 0;
+
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "video_start() enter:\n");
+	me->dvs_frame_delay = pipe->dvs_frame_delay;
+	video_pipe_input_mode = pipe->stream->config.mode;
+
+	copy_pipe    = pipe->pipe.video.copy_pipe;
+	capture_pipe = pipe->pipe.video.capture_pipe;
+
+	sh_css_pipe_get_output_frame_info(pipe, &out_frame->info);
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	out_frame->dynamic_data_index = sh_css_frame_out;
+	err = init_frame_planes(out_frame);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (!pipe->enable_viewfinder || in_frame) {
+		/* These situations don't support viewfinder output */
+		vf_frame = NULL;
+	} else {
+		sh_css_pipe_get_viewfinder_frame_info(pipe, &vf_frame->info);
+		vf_frame->contiguous = false;
+		vf_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+		vf_frame->dynamic_data_index = sh_css_frame_out_vf;
+		err = init_frame_planes(vf_frame);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	copy_stage = NULL;
+	in_stage = NULL;
+
+	if (pipe->zoom_changed) {
+		sh_css_pipe_invalidate_binaries(pipe);
+		pipe->zoom_changed = false;
+	}
+
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	copy_binary  = &pipe->pipe.video.copy_binary;
+	video_binary = &pipe->pipe.video.video_binary;
+	vf_pp_binary = &pipe->pipe.video.vf_pp_binary;
+	num_output_pins = video_binary->info->num_output_pins;
+
+	sh_css_metrics_start_frame();
+
+	if (me->reload) {
+		sh_css_pipeline_clean(me);
+		if (pipe->pipe.video.copy_binary.info) {
+			err = sh_css_pipeline_add_stage(me, copy_binary,
+				/* TODO: check next params */
+				/* const struct ia_css_acc_fw *firmware, */
+				NULL,
+				/* unsigned int mode, */
+				copy_binary->info->mode, /* unsigned int mode,*/
+				/* struct ia_css_frame *cc_frame, */
+				NULL,
+				/* struct ia_css_frame *in_frame, */
+				NULL,
+				/* struct ia_css_frame *out_frame, */
+				NULL,
+				/* struct ia_css_frame *vf_frame, */
+				NULL,
+				/* struct sh_css_pipeline_stage **stage) */
+				&copy_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			in_frame = me->stages->args.out_frame;
+			in_stage = copy_stage;
+		} else if (pipe->stream->cont_capt) {
+			in_frame = pipe->continuous_frames[0];
+		}
+
+		resolution_differs = (pipe->vf_output_info.res.width != pipe->output_info.res.width) || (pipe->vf_output_info.res.height != pipe->output_info.res.height);
+		need_vf_pp = pipe->enable_viewfinder && ((num_output_pins == 1) || ((num_output_pins == 2) && resolution_differs));
+		
+		err = sh_css_pipeline_add_stage(me, video_binary, NULL,
+						video_binary->info->mode, NULL,
+						in_frame, out_frame, !need_vf_pp ? vf_frame : NULL,// when the video binary supports a second output pin, it can directly produce the vf_frame.
+						&video_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		/* If we use copy iso video, the input must be yuv iso raw */
+		video_stage->args.copy_vf =
+			video_binary->info->mode == SH_CSS_BINARY_MODE_COPY;
+		video_stage->args.copy_output = video_stage->args.copy_vf;
+		if (!in_frame && need_vf_pp) { // when the video binary supports only 1 output pin, vf_pp is needed to produce the vf_frame.
+			err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
+					      video_stage, &vf_pp_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		number_stages(pipe);
+	} else {
+		sh_css_pipeline_restart(me);
+	}
+
+	err = sh_css_pipeline_get_stage(me, video_binary->info->mode,
+					&video_stage);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (!in_stage)
+		in_stage = video_stage;
+
+
+	if (!in_frame && need_vf_pp) {// when the video binary supports only 1 output pin, vf_pp is needed to produce the vf_frame.
+		err = sh_css_pipeline_get_output_stage(me,
+						       vf_pp_binary->info->mode,
+						       &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	video_stage->args.in_ref_frame = pipe->pipe.video.ref_frames[0];
+	video_stage->args.out_ref_frame = pipe->pipe.video.ref_frames[1];
+	video_stage->args.extra_ref_frame = pipe->pipe.video.ref_frames[2];	
+	video_stage->args.in_tnr_frame = pipe->pipe.video.tnr_frames[0];
+	video_stage->args.out_tnr_frame = pipe->pipe.video.tnr_frames[1];
+
+	/* multi stream video needs mipi buffers */
+	send_mipi_frames(pipe);
+
+	/* update the arguments with the latest info */
+	video_stage->args.out_frame = out_frame;
+
+	if (vf_pp_stage)
+		vf_pp_stage->args.out_frame = vf_frame;
+
+	if (pipe->stream->config.continuous) {
+		int i;
+		in_frame = pipe->continuous_frames[0];
+		video_stage->args.in_frame = in_frame;
+
+		/* Hand-over all the SP-internal buffers */
+		for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
+			sh_css_update_host2sp_offline_frame(i,
+				pipe->continuous_frames[i]);
+		}
+	}
+
+	if (pipe->stream->config.online)
+		sh_css_set_irq_buffer(in_stage, sh_css_frame_in, in_frame);
+	sh_css_set_irq_buffer(video_stage, sh_css_frame_out,    out_frame);
+	if (vf_pp_stage)
+		sh_css_set_irq_buffer(vf_pp_stage, sh_css_frame_out_vf,
+					vf_frame);
+
+	{
+		unsigned int thread_id;
+		
+		sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+		copy_ovrd = 1 << thread_id;
+		
+		if (pipe->stream->cont_capt) {
+			sh_css_query_sp_thread_id(capture_pipe->pipe_num, &thread_id);
+			copy_ovrd |= 1 << thread_id;
+		}
+	}
+
+	/* Construct and load the copy pipe */
+	if (pipe->stream->config.continuous) {
+		err = construct_copy_pipe(copy_pipe,
+					  video_binary->info->max_input_width,
+					  pipe->continuous_frames[0]);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		sh_css_sp_init_pipeline(&copy_pipe->pipeline, IA_CSS_PIPE_ID_COPY,
+			copy_pipe->pipe_num,
+			false, false, false,
+			pipe->stream->config.two_pixels_per_clock, false,
+			false, pipe->input_needs_raw_binning,
+			copy_ovrd,
+			pipe->stream->config.mode,
+			pipe->stream->config.source.port.port);
+
+		/* make the video pipe start with mem mode input, copy handles
+		   the actual mode */
+		video_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;
+	}
+	
+	/* Construct and load the capture pipe */
+	if (pipe->stream->cont_capt) {
+		bool low_light;
+
+		err = construct_capture_pipe(capture_pipe);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		low_light = (capture_pipe->capture_mode ==
+				IA_CSS_CAPTURE_MODE_LOW_LIGHT) ||
+				(capture_pipe->capture_mode ==
+				IA_CSS_CAPTURE_MODE_BAYER);
+
+		sh_css_sp_init_pipeline(&capture_pipe->pipeline, IA_CSS_PIPE_ID_CAPTURE,
+			capture_pipe->pipe_num,
+			false, low_light, pipe->xnr,
+			capture_pipe->stream->config.two_pixels_per_clock,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->input_needs_raw_binning,
+			0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			(mipi_port_ID_t)0);
+	}
+
+	err = sh_css_config_input_network(pipe, copy_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	start_pipe(pipe, copy_ovrd, video_pipe_input_mode);
+	me->reload = false;
+
+	return IA_CSS_SUCCESS;
+}
+
+static
+enum ia_css_err sh_css_pipe_get_viewfinder_frame_info(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *info)
+{
+	enum ia_css_err err;
+assert(info != NULL);
+/* We could print the pointer as input arg, and the values as output */
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_get_viewfinder_frame_info() enter: void\n");
+
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err != IA_CSS_SUCCESS) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_get_viewfinder_frame_info() leave: return_err=%d\n",
+			err);
+		return err;
+	}
+	if ( pipe->mode == IA_CSS_PIPE_ID_CAPTURE &&
+	    (pipe->capture_mode == IA_CSS_CAPTURE_MODE_RAW ||
+	     pipe->capture_mode == IA_CSS_CAPTURE_MODE_BAYER))
+		return IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER;
+	/* offline video does not generate viewfinder output */
+	if ( pipe->mode == IA_CSS_PIPE_ID_VIDEO &&
+	    !pipe->stream->config.online && !pipe->stream->config.continuous) {
+		sh_css_dtrace(SH_DBG_TRACE,
+			"sh_css_pipe_get_viewfinder_frame_info() leave: return_err=%d\n",
+			IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER);
+		return IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER;
+	} else {
+		*info = pipe->vf_output_info;
+	}
+		
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_get_viewfinder_frame_info() leave: \
+		info.res.width=%d, info.res.height=%d, \
+		info.padded_width=%d, info.format=%d, \
+		info.raw_bit_depth=%d, info.raw_bayer_order=%d\n",
+		info->res.width,info->res.height,
+		info->padded_width,info->format,
+		info->raw_bit_depth,info->raw_bayer_order);
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_pipe_configure_viewfinder(struct sh_css_pipe *pipe,
+				 unsigned int width,
+				 unsigned int height,
+				 enum ia_css_frame_format format)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipe_configure_viewfinder() enter: \
+		width=%d, height=%d format=%d\n",
+		width, height, format);
+
+	err = check_res(width, height);
+	if (err != IA_CSS_SUCCESS) {
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",err);
+		return err;
+	}
+	if (pipe->vf_output_info.res.width != width ||
+	    pipe->vf_output_info.res.height != height ||
+	    pipe->vf_output_info.format != format) {
+		sh_css_frame_info_init(&pipe->vf_output_info,
+				       width, height, format, pipe->mode==IA_CSS_PIPE_ID_VIDEO ? SH_CSS_VIDEO_BUFFER_ALIGNMENT : 0);
+		sh_css_pipe_invalidate_binaries(pipe);
+	}
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_copy_binaries(
+	struct sh_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_copy_binaries() enter:\n");
+
+	if (pipe->pipe.capture.copy_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = check_frame_info(&pipe->output_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = verify_copy_out_frame_format(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = load_copy_binary(pipe,
+				&pipe->pipe.capture.copy_binary,
+				NULL);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	
+	err = allocate_mipi_frames(pipe);
+	
+	return err;
+}
+
+static bool need_capture_pp(
+	const struct sh_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	assert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "need_capture_pp() enter:\n");
+	/* determine whether we need to use the capture_pp binary.
+	 * This is needed for:
+	 *   1. XNR or
+	 *   2. Digital Zoom or
+	 *   3. YUV downscaling
+	 *   4. in continuous capture mode
+	 *   5. explicit request to enable_capture_pp ON
+	 */
+	if (pipe->yuv_ds_input_info.res.width &&
+	    ((pipe->yuv_ds_input_info.res.width != pipe->output_info.res.width) ||
+	     (pipe->yuv_ds_input_info.res.height != pipe->output_info.res.height)))
+		return true;
+	if (pipe->xnr)
+		return true;
+
+	if ((pipe->stream->isp_params_configs->dz_config.dx < HRT_GDC_N) ||
+	    (pipe->stream->isp_params_configs->dz_config.dy < HRT_GDC_N))
+		return true;
+
+        if(pipe->enable_capture_pp)
+		return true;
+
+
+	return false;
+}
+
+static void init_capture_pp_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *vf_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(vf_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_capture_pp_descr() enter:\n");
+
+	/* the in_info is only used for resolution to enable
+	   bayer down scaling. */
+	if (pipe->yuv_ds_input_info.res.width)
+		*in_info = pipe->yuv_ds_input_info;
+	else
+		*in_info = pipe->output_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420;
+	in_info->raw_bit_depth = 0;
+	sh_css_frame_info_set_width(in_info, in_info->res.width, 0);
+	init_offline_descr(pipe,
+			   &capture_pp_descr,
+			   SH_CSS_BINARY_MODE_CAPTURE_PP,
+			   in_info,
+			   &pipe->output_info,
+			   vf_info);
+}
+
+static void init_primary_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	int mode = SH_CSS_BINARY_MODE_PRIMARY;
+
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+assert(vf_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_primary_descr() enter:\n");
+
+	if (input_format_is_yuv(pipe->stream->config.format))
+		mode = SH_CSS_BINARY_MODE_COPY;
+
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	init_offline_descr(pipe,
+			   &prim_descr,
+			   mode,
+			   in_info,
+			   out_info,
+			   vf_info);
+	if (pipe->stream->config.online) {
+		prim_descr.online        = true;
+		prim_descr.two_ppc       = pipe->stream->config.two_pixels_per_clock;
+		prim_descr.stream_format = pipe->stream->config.format;
+	}
+	if (mode == SH_CSS_BINARY_MODE_PRIMARY) {
+		prim_descr.isp_pipe_version = pipe->isp_pipe_version;
+	}
+}
+
+static void init_pre_gdc_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_pre_gdc_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	init_offline_descr(pipe,
+			   &pre_gdc_descr, SH_CSS_BINARY_MODE_PRE_ISP,
+			   in_info, out_info, NULL);
+	pre_gdc_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+static void
+init_gdc_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_gdc_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_QPLANE6;
+	init_offline_descr(pipe,
+			   &gdc_descr, SH_CSS_BINARY_MODE_GDC,
+			   in_info, out_info, NULL);
+}
+
+static void init_post_gdc_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+assert(vf_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_post_gdc_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420_16;
+	init_offline_descr(pipe,
+			   &post_gdc_descr, SH_CSS_BINARY_MODE_POST_ISP,
+			   in_info, out_info, vf_info);
+	post_gdc_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+static void init_pre_anr_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_pre_anr_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	if (pipe->isp_pipe_version == 1) {
+	init_offline_descr(pipe,
+			   &pre_anr_descr, SH_CSS_BINARY_MODE_PRE_ISP,
+			   in_info, out_info, NULL);
+	} else {
+		init_offline_descr(pipe,
+			   &pre_anr_descr, SH_CSS_BINARY_MODE_PRE_ANR,
+			   in_info, out_info, NULL);
+	}
+	if (pipe->stream->config.online) {
+		pre_anr_descr.online        = true;
+		pre_anr_descr.two_ppc       = pipe->stream->config.two_pixels_per_clock;
+		pre_anr_descr.stream_format = pipe->stream->config.format;
+	}
+	pre_anr_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+static void init_anr_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_anr_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	init_offline_descr(pipe,
+			   &anr_descr, SH_CSS_BINARY_MODE_ANR,
+			   in_info, out_info, NULL);
+	anr_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+static void init_post_anr_descr(
+	struct sh_css_pipe *pipe,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+assert(pipe != NULL);
+assert(in_info != NULL);
+assert(out_info != NULL);
+assert(vf_info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_post_anr_descr() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
+	if (pipe->isp_pipe_version == 1) {
+	init_offline_descr(pipe,
+			   &post_anr_descr, SH_CSS_BINARY_MODE_POST_ISP,
+			   in_info, out_info, vf_info);
+	} else {
+		init_offline_descr(pipe,
+			   &post_anr_descr, SH_CSS_BINARY_MODE_POST_ANR,
+			   in_info, out_info, vf_info);
+	}
+	post_anr_descr.isp_pipe_version    = pipe->isp_pipe_version;
+}
+
+static enum ia_css_err load_primary_binaries(
+	struct sh_css_pipe *pipe)
+{
+	bool online = pipe->stream->config.online;
+	bool continuous = pipe->stream->config.continuous;
+	bool need_pp = false;
+	struct ia_css_frame_info prim_in_info,
+				 prim_out_info, vf_info,
+				 *vf_pp_in_info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_capture_settings *mycs = &pipe->pipe.capture;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_primary_binaries() enter:\n");
+
+	if (mycs->primary_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = check_vf_out_info(&pipe->output_info, &pipe->vf_output_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	/* we use the vf output info to get the primary/capture_pp binary
+	   configured for vf_veceven. It will select the closest downscaling
+	   factor. */
+	vf_info = pipe->vf_output_info;
+	sh_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		init_capture_pp_descr(pipe, &prim_out_info, &vf_info);
+		err = sh_css_binary_find(&capture_pp_descr,
+					&mycs->capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		prim_out_info = pipe->output_info;
+	}
+
+	/* Primary */
+	init_primary_descr(pipe, &prim_in_info, &prim_out_info, &vf_info);
+	err = sh_css_binary_find(&prim_descr, &mycs->primary_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &mycs->capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &mycs->primary_binary.vf_frame_info;
+	}
+
+	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
+	err = sh_css_binary_find(&vf_pp_descr,
+				 &mycs->vf_pp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* ISP Copy */
+	if (!online && !continuous) {
+		err = load_copy_binary(pipe,
+				       &mycs->copy_binary,
+				       &mycs->primary_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (need_pp)
+		return alloc_capture_pp_frame(pipe, &mycs->capture_pp_binary);
+	else
+		return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_advanced_binaries(
+	struct sh_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_in_info, gdc_in_info,
+				 post_in_info, post_out_info,
+				 vf_info, *vf_pp_in_info;
+	bool need_pp;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_advanced_binaries() enter:\n");
+
+	if (pipe->pipe.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+
+	vf_info = pipe->vf_output_info;
+	err = check_vf_out_info(&pipe->output_info,
+				&vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	sh_css_frame_info_set_format(&vf_info,
+				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		init_capture_pp_descr(pipe, &post_out_info, &vf_info);
+		err = sh_css_binary_find(&capture_pp_descr,
+				&pipe->pipe.capture.capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		post_out_info = pipe->output_info;
+	}
+
+	/* Post-gdc */
+	init_post_gdc_descr(pipe, &post_in_info, &post_out_info, &vf_info);
+	err = sh_css_binary_find(&post_gdc_descr,
+				 &pipe->pipe.capture.post_isp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Gdc */
+	init_gdc_descr(pipe, &gdc_in_info,
+		       &pipe->pipe.capture.post_isp_binary.in_frame_info);
+	err = sh_css_binary_find(&gdc_descr,
+				 &pipe->pipe.capture.gdc_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	pipe->pipe.capture.gdc_binary.left_padding =
+		pipe->pipe.capture.post_isp_binary.left_padding;
+
+	/* Pre-gdc */
+	init_pre_gdc_descr(pipe, &pre_in_info,
+			   &pipe->pipe.capture.gdc_binary.in_frame_info);
+	err = sh_css_binary_find(&pre_gdc_descr,
+				 &pipe->pipe.capture.pre_isp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	pipe->pipe.capture.pre_isp_binary.left_padding =
+		pipe->pipe.capture.gdc_binary.left_padding;
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &pipe->pipe.capture.capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &pipe->pipe.capture.post_isp_binary.vf_frame_info;
+	}
+
+	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
+	err = sh_css_binary_find(&vf_pp_descr,
+				 &pipe->pipe.capture.vf_pp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Copy */
+	err = load_copy_binary(pipe,
+			       &pipe->pipe.capture.copy_binary,
+			       &pipe->pipe.capture.pre_isp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (need_pp)
+		return alloc_capture_pp_frame(pipe,
+				&pipe->pipe.capture.capture_pp_binary);
+	else
+		return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_pre_isp_binaries(
+	struct sh_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_isp_in_info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_pre_isp_binaries() enter:\n");
+
+	if (pipe->pipe.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = check_frame_info(&pipe->output_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	init_pre_anr_descr(pipe, &pre_isp_in_info,
+			   &pipe->output_info);
+
+	err = sh_css_binary_find(&pre_anr_descr,
+				 &pipe->pipe.capture.pre_isp_binary);
+
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return err;
+}
+
+static enum ia_css_err load_low_light_binaries(
+	struct sh_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_in_info, anr_in_info,
+				 post_in_info, post_out_info,
+				 vf_info, *vf_pp_in_info;
+	bool need_pp;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_low_light_binaries() enter:\n");
+
+	if (pipe->isp_pipe_version == 1) {
+	if (pipe->pipe.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+	} else {
+		if (pipe->pipe.capture.pre_anr_binary.info)
+			return IA_CSS_SUCCESS;
+	}
+
+	vf_info = pipe->vf_output_info;
+	err = check_vf_out_info(&pipe->output_info,
+				&vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	sh_css_frame_info_set_format(&vf_info,
+				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		init_capture_pp_descr(pipe, &post_out_info, &vf_info);
+		err = sh_css_binary_find(&capture_pp_descr,
+				&pipe->pipe.capture.capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		post_out_info = pipe->output_info;
+	}
+
+	/* Post-anr */
+	init_post_anr_descr(pipe, &post_in_info, &post_out_info, &vf_info);
+	if (pipe->isp_pipe_version == 1) {
+	err = sh_css_binary_find(&post_anr_descr,
+				 &pipe->pipe.capture.post_isp_binary);
+	} else {
+		err = sh_css_binary_find(&post_anr_descr,
+				 &pipe->pipe.capture.post_anr_binary);
+	}
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Anr */
+	if (pipe->isp_pipe_version == 1) {
+	init_anr_descr(pipe, &anr_in_info,
+		       &pipe->pipe.capture.post_isp_binary.in_frame_info);
+	} else {
+		init_anr_descr(pipe, &anr_in_info,
+		       &pipe->pipe.capture.post_anr_binary.in_frame_info);
+	}
+	err = sh_css_binary_find(&anr_descr,
+				 &pipe->pipe.capture.anr_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (pipe->isp_pipe_version == 1) {
+	pipe->pipe.capture.anr_binary.left_padding =
+		pipe->pipe.capture.post_isp_binary.left_padding;
+	} else {
+		pipe->pipe.capture.anr_binary.left_padding =
+			pipe->pipe.capture.post_anr_binary.left_padding;
+	}
+
+	/* Pre-anr */
+	init_pre_anr_descr(pipe, &pre_in_info,
+			   &pipe->pipe.capture.anr_binary.in_frame_info);
+	if (pipe->isp_pipe_version == 1) {
+	err = sh_css_binary_find(&pre_anr_descr,
+				 &pipe->pipe.capture.pre_isp_binary);
+	} else {
+		err = sh_css_binary_find(&pre_anr_descr,
+				 &pipe->pipe.capture.pre_anr_binary);
+	}
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (pipe->isp_pipe_version == 1) {
+	pipe->pipe.capture.pre_isp_binary.left_padding =
+		pipe->pipe.capture.anr_binary.left_padding;
+	} else {
+		pipe->pipe.capture.pre_anr_binary.left_padding =
+			pipe->pipe.capture.anr_binary.left_padding;
+	}
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &pipe->pipe.capture.capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &pipe->pipe.capture.post_isp_binary.vf_frame_info;
+	}
+
+	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
+	err = sh_css_binary_find(&vf_pp_descr,
+				 &pipe->pipe.capture.vf_pp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Copy */
+	if (pipe->isp_pipe_version == 1) {
+	err = load_copy_binary(pipe,
+			       &pipe->pipe.capture.copy_binary,
+			       &pipe->pipe.capture.pre_isp_binary);
+	} else {
+		err = load_copy_binary(pipe,
+			       &pipe->pipe.capture.copy_binary,
+			       &pipe->pipe.capture.pre_anr_binary);
+	}
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = allocate_mipi_frames(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (need_pp)
+		return alloc_capture_pp_frame(pipe,
+				&pipe->pipe.capture.capture_pp_binary);
+	else
+		return IA_CSS_SUCCESS;
+}
+
+static bool copy_on_sp(
+	struct sh_css_pipe *pipe)
+{
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "copy_on_sp() enter:\n");
+
+	if (pipe->mode != IA_CSS_PIPE_ID_CAPTURE)
+		return false;
+	if (pipe->capture_mode != IA_CSS_CAPTURE_MODE_RAW)
+		return false;
+	return pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8;
+}
+
+static enum ia_css_err load_capture_binaries(
+	struct sh_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool must_be_raw;
+
+assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_capture_binaries() enter:\n");
+
+	if (pipe->pipe.preview.preview_binary.info &&
+	    pipe->pipe.preview.vf_pp_binary.info)
+		return IA_CSS_SUCCESS;
+
+	/* in primary, advanced,low light or bayer,
+						the input format must be raw */
+	must_be_raw =
+		pipe->capture_mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
+		pipe->capture_mode == IA_CSS_CAPTURE_MODE_BAYER ||
+		pipe->capture_mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT;
+	err = check_input(pipe, must_be_raw);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		sh_css_frame_info_init(
+			&pipe->output_info,
+			JPEG_BYTES, 1, IA_CSS_FRAME_FORMAT_BINARY_8, 0);
+		return IA_CSS_SUCCESS;
+	}
+
+	switch (pipe->capture_mode) {
+	case IA_CSS_CAPTURE_MODE_RAW:
+		err = load_copy_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_BAYER:
+		err = load_pre_isp_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_PRIMARY:
+		err = load_primary_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_ADVANCED:
+		err = load_advanced_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_LOW_LIGHT:
+		err = load_low_light_binaries(pipe);
+		break;
+	}
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return err;
+}
+
+static enum ia_css_err
+sh_css_pipe_load_binaries(struct sh_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_binaries() enter:\n");
+
+	switch (pipe->mode) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		err = load_preview_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_VIDEO:
+		err = load_video_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		err = load_capture_binaries(pipe);
+		break;
+	default:
+		err = IA_CSS_ERR_INTERNAL_ERROR;
+		break;
+	}
+	if (pipe->new_pipe->config.acc_extension) {
+		ia_css_pipe_load_extension(pipe->new_pipe,
+				pipe->new_pipe->config.acc_extension);
+	}
+	return err;
+}
+
+static enum ia_css_err
+construct_copy_pipe(struct sh_css_pipe *pipe,
+		    unsigned max_input_width,
+		    struct ia_css_frame *out_frame)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "construct_copy_pipe() enter:\n");
+	sh_css_pipeline_clean(me);
+
+	/* Construct out_frame info */
+	sh_css_pipe_get_output_frame_info(pipe, &out_frame->info);
+
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	out_frame->dynamic_data_index = sh_css_frame_out;
+
+	me->num_stages = 1;
+	me->pipe_id = IA_CSS_PIPE_ID_COPY;
+	pipe->mode  = IA_CSS_PIPE_ID_COPY;
+
+	err = sh_css_pipeline_add_sp_stage(me, SH_CSS_SP_RAW_COPY, max_input_width, out_frame);
+	return err;
+}
+
+static enum ia_css_err
+construct_capture_pipe(struct sh_css_pipe *pipe)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum ia_css_capture_mode mode = pipe->capture_mode;
+	struct sh_css_pipeline_stage *out_stage = NULL,
+				     *vf_pp_stage = NULL,
+				     *copy_stage = NULL,
+				     *in_stage = NULL,
+				     *post_stage = NULL;
+	struct ia_css_frame *cc_frame = NULL;
+	struct sh_css_binary *copy_binary,
+			     *primary_binary,
+			     *vf_pp_binary,
+			     *pre_isp_binary,
+			     *gdc_binary,
+			     *post_isp_binary,
+			     *pre_anr_binary,
+			     *anr_binary,
+			     *post_anr_binary,
+			     *capture_pp_binary,
+			     *sc_binary = NULL;
+	bool need_pp = false;
+	bool raw = mode == IA_CSS_CAPTURE_MODE_RAW;
+
+	/**
+	 * rvanimme: in_frame support is broken and forced to NULL
+	 * TODO: add a way to tell the pipeline construction that an in_frame
+	 * is used.
+	 */
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *out_frame = &me->out_frame;
+	struct ia_css_frame *vf_frame = &me->vf_frame;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "construct_capture_pipe() enter:\n");
+	sh_css_pipeline_clean(me);
+
+	
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Construct out_frame info */
+	sh_css_pipe_get_output_frame_info(pipe, &out_frame->info);
+
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	out_frame->dynamic_data_index = sh_css_frame_out;
+	err = init_frame_planes(out_frame);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR with init_frame_planes out_frame\n");
+		return err;
+	}
+
+	/* Construct vf_frame info (only in case we have VF) */
+	if (mode == IA_CSS_CAPTURE_MODE_RAW ||
+			mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		/* These modes don't support viewfinder output */
+		vf_frame = NULL;
+	} else {
+		sh_css_pipe_get_viewfinder_frame_info(pipe, &vf_frame->info);
+		vf_frame->contiguous = false;
+		vf_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+		vf_frame->dynamic_data_index = sh_css_frame_out_vf;
+		err = init_frame_planes(vf_frame);
+		if (err != IA_CSS_SUCCESS) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR with init_frame_planes\n");
+			return err;
+		}
+	}
+
+	copy_stage = NULL;
+	in_stage = NULL;
+
+	copy_binary       = &pipe->pipe.capture.copy_binary;
+	primary_binary    = &pipe->pipe.capture.primary_binary;
+	vf_pp_binary      = &pipe->pipe.capture.vf_pp_binary;
+	pre_isp_binary    = &pipe->pipe.capture.pre_isp_binary;
+	gdc_binary        = &pipe->pipe.capture.gdc_binary;
+	post_isp_binary   = &pipe->pipe.capture.post_isp_binary;
+	pre_anr_binary    = &pipe->pipe.capture.pre_anr_binary;
+	anr_binary        = &pipe->pipe.capture.anr_binary;
+	post_anr_binary   = &pipe->pipe.capture.post_anr_binary;
+	capture_pp_binary = &pipe->pipe.capture.capture_pp_binary;
+	need_pp = need_capture_pp(pipe) || pipe->output_stage;
+
+	if (pipe->pipe.capture.copy_binary.info) {
+		err = sh_css_pipeline_add_stage(me, copy_binary, NULL,
+				copy_binary->info->mode, NULL, NULL,
+				raw ? out_frame : in_frame,
+				NULL, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_stage = post_stage;
+	} else if (pipe->stream->config.continuous) {
+		in_frame = pipe->stream->last_pipe->old_pipe->continuous_frames[0];//pipe->pipe.capture.continuous_frames[0];
+	}
+
+	if (mode == IA_CSS_CAPTURE_MODE_PRIMARY) {
+		err = sh_css_pipeline_add_stage(me, primary_binary,
+				NULL, primary_binary->info->mode,
+				cc_frame, in_frame,
+				need_pp ? NULL : out_frame,
+				NULL, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		/* If we use copy iso primary,
+		   the input must be yuv iso raw */
+		post_stage->args.copy_vf =
+			primary_binary->info->mode ==
+			SH_CSS_BINARY_MODE_COPY;
+		post_stage->args.copy_output = post_stage->args.copy_vf;
+		sc_binary = primary_binary;
+	} else if (mode == IA_CSS_CAPTURE_MODE_ADVANCED) {
+		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
+				NULL, pre_isp_binary->info->mode,
+				cc_frame, in_frame, NULL, NULL, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		err = sh_css_pipeline_add_stage(me, gdc_binary,
+				NULL, gdc_binary->info->mode,
+				NULL, NULL, NULL, NULL, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		err = sh_css_pipeline_add_stage(me, post_isp_binary,
+				NULL, post_isp_binary->info->mode,
+				NULL, NULL,
+				need_pp ? NULL : out_frame,
+				NULL, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		sc_binary = pre_isp_binary;
+	} else if (mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+		if (pipe->isp_pipe_version == 1) {
+		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
+				NULL, pre_isp_binary->info->mode,
+				cc_frame, in_frame, NULL, NULL, NULL);
+		} else {
+			err = sh_css_pipeline_add_stage(me, pre_anr_binary,
+				NULL, pre_anr_binary->info->mode,
+				cc_frame, in_frame, NULL, NULL, NULL);
+		}
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		err = sh_css_pipeline_add_stage(me, anr_binary,
+				NULL, anr_binary->info->mode,
+				NULL, NULL, NULL, NULL, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (pipe->isp_pipe_version == 1) {
+		err = sh_css_pipeline_add_stage(me, post_isp_binary,
+				NULL, post_isp_binary->info->mode,
+				NULL, NULL,
+				need_pp ? NULL : out_frame,
+				NULL, &post_stage);
+		} else {
+			err = sh_css_pipeline_add_stage(me, post_anr_binary,
+				NULL, post_anr_binary->info->mode,
+				NULL, NULL,
+				need_pp ? NULL : out_frame,
+				NULL, &post_stage);
+		}
+		if (err != IA_CSS_SUCCESS) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR with sh_css_pipeline_add_stage\n");
+			return err;
+		}
+		if (pipe->isp_pipe_version == 1) {
+		sc_binary = pre_isp_binary;
+		} else {
+			sc_binary = pre_anr_binary;
+		}
+	} else if (mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
+				NULL, pre_isp_binary->info->mode,
+				cc_frame, in_frame, out_frame,
+				NULL, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		sc_binary = pre_isp_binary;
+	}
+	if (!in_stage)
+		in_stage = post_stage;
+
+	if (need_pp) {
+		err = add_capture_pp_stage(pipe, me, out_frame,
+					   capture_pp_binary,
+					   post_stage, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	if (mode != IA_CSS_CAPTURE_MODE_RAW &&
+		mode != IA_CSS_CAPTURE_MODE_BAYER) {
+		err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
+				      post_stage, &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	number_stages(pipe);
+
+	/**
+	 * Maybe we can return earlier but this was the original position
+	 * in the original version of capture_start()
+	 */
+	if (pipe->capture_mode == IA_CSS_CAPTURE_MODE_RAW ||
+	    pipe->capture_mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		if (copy_on_sp(pipe))
+			return IA_CSS_SUCCESS;
+	}
+
+	if (mode == IA_CSS_CAPTURE_MODE_RAW) {
+		err = sh_css_pipeline_get_stage(me, copy_binary->info->mode,
+						&out_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		copy_stage = out_stage;
+	} else if (mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		err = sh_css_pipeline_get_stage(me,
+				pre_isp_binary->info->mode,
+				&out_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		if (copy_binary->info) {
+			err = sh_css_pipeline_get_stage(me,
+							copy_binary->info->mode,
+							&copy_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if (capture_pp_binary->info) {
+			err = sh_css_pipeline_get_stage(me,
+					capture_pp_binary->info->mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else if (mode ==
+			   IA_CSS_CAPTURE_MODE_PRIMARY) {
+			err = sh_css_pipeline_get_stage(me,
+					primary_binary->info->mode, &out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else if (mode ==
+			   IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+			if (pipe->isp_pipe_version == 1) {
+			err = sh_css_pipeline_get_stage(me,
+					post_isp_binary->info->mode,
+					&out_stage);
+			} else {
+				err = sh_css_pipeline_get_stage(me,
+					post_anr_binary->info->mode,
+					&out_stage);
+			}
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else {
+			err = sh_css_pipeline_get_stage(me,
+					post_isp_binary->info->mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		err = sh_css_pipeline_get_output_stage(me,
+						       vf_pp_binary->info->mode,
+						       &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	if (mode != IA_CSS_CAPTURE_MODE_RAW &&
+	    mode != IA_CSS_CAPTURE_MODE_BAYER)
+		vf_pp_stage->args.out_frame = vf_frame;
+
+	/* rvanimme: why is this? */
+	/* TODO: investigate if this can be removed */
+	if (!pipe->output_stage)
+		out_stage->args.out_frame = out_frame;
+
+	if (copy_stage && in_frame)
+		copy_stage->args.out_frame = in_frame;
+
+	sh_css_set_irq_buffer(in_stage,    sh_css_frame_in,  in_frame);
+	sh_css_set_irq_buffer(out_stage,   sh_css_frame_out, out_frame);
+	sh_css_set_irq_buffer(vf_pp_stage, sh_css_frame_in,  vf_frame);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "construct_capture_pipe() EXIT with success\n");
+	return IA_CSS_SUCCESS;
+
+}
+
+static enum ia_css_err capture_start(
+	struct sh_css_pipe *pipe)
+{
+	struct sh_css_pipeline *me = &pipe->pipeline;
+
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum sh_css_pipe_config_override copy_ovrd;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "capture_start() enter:\n");
+
+	err = construct_capture_pipe(pipe);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in construct_capture_pipe\n");
+		return err;
+	}
+
+	err = sh_css_config_input_network(pipe, &pipe->pipe.capture.copy_binary);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ERROR in sh_css_config_input_network\n");
+		return err;
+	}
+
+	if (pipe->capture_mode == IA_CSS_CAPTURE_MODE_RAW ||
+	    pipe->capture_mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		if (copy_on_sp(pipe)) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "(CAPTURE_MODE_RAW || MODE_BAYER), calling start_copy_on_sp\n");
+			return start_copy_on_sp(pipe,
+				&me->out_frame);
+		}
+	}
+
+	/* multi stream video needs mipi buffers */
+	send_mipi_frames(pipe);
+
+	{
+		unsigned int thread_id;
+		
+		sh_css_query_sp_thread_id(pipe->pipe_num, &thread_id);
+		copy_ovrd = 1 << thread_id;
+		
+	}
+	start_pipe(pipe, copy_ovrd, pipe->stream->config.mode);
+
+	return IA_CSS_SUCCESS;
+
+}
+
+static enum ia_css_err
+sh_css_pipe_get_output_frame_info(struct sh_css_pipe *pipe,
+				  struct ia_css_frame_info *info)
+{
+	enum ia_css_err err;
+
+	assert(pipe != NULL);
+	assert(info != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_get_output_frame_info() enter:\n");
+	err = sh_css_pipe_load_binaries(pipe);
+	if (err == IA_CSS_SUCCESS)
+		*info = pipe->output_info;
+	if (copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		sh_css_frame_info_init(info, JPEG_BYTES, 1,
+				IA_CSS_FRAME_FORMAT_BINARY_8, 0);
+	} else if (info->format == IA_CSS_FRAME_FORMAT_RAW) {
+		info->raw_bit_depth =
+			sh_css_pipe_input_format_bits_per_pixel(pipe);
+	}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_get_output_frame_info() leave:\n");
+	return err;
+}
+
+void
+ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+			       const unsigned short *data,
+			       unsigned int width,
+			       unsigned int height)
+{
+	sh_css_hrt_send_input_frame(
+			data, width, height,
+			stream->config.channel_id,
+			stream->config.format,
+			stream->config.two_pixels_per_clock);
+}
+
+void
+ia_css_stream_start_input_frame(const struct ia_css_stream *stream)
+{
+	sh_css_hrt_streaming_to_mipi_start_frame(
+			stream->config.channel_id,
+			stream->config.format,
+			stream->config.two_pixels_per_clock);
+}
+
+void
+ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+			      const unsigned short *data,
+			      unsigned int width,
+			      const unsigned short *data2,
+			      unsigned int width2)
+{
+	sh_css_hrt_streaming_to_mipi_send_line(stream->config.channel_id,
+					       data, width, data2, width2);
+}
+
+
+void
+ia_css_stream_end_input_frame(const struct ia_css_stream *stream)
+{
+	sh_css_hrt_streaming_to_mipi_end_frame(stream->config.channel_id);
+}
+
+static enum ia_css_err allocate_frame_data(
+	struct ia_css_frame *frame)
+{
+	frame->data = mmgr_alloc_attr(frame->data_bytes,
+		frame->contiguous ?
+			MMGR_ATTRIBUTE_CONTIGUOUS : MMGR_ATTRIBUTE_DEFAULT);
+
+	if (frame->data == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	return IA_CSS_SUCCESS;
+}
+
+static void init_plane(
+	struct ia_css_frame_plane *plane,
+	unsigned int width,
+	unsigned int stride,
+	unsigned int height,
+	unsigned int offset)
+{
+	plane->height = height;
+	plane->width = width;
+	plane->stride = stride;
+	plane->offset = offset;
+}
+
+static void init_single_plane(
+	struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel)
+{
+	unsigned int stride;
+
+	stride = subpixels_per_line * bytes_per_pixel;
+	frame->data_bytes = stride * height;
+	init_plane(plane, subpixels_per_line, stride, height, 0);
+	return;
+}
+
+
+static void init_mipi_plane(
+	struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel)
+{
+	unsigned int stride;
+
+	stride = subpixels_per_line * bytes_per_pixel;
+	frame->data_bytes = 8388608;
+	frame->valid = false;
+	frame->contiguous = true;
+	init_plane(plane, subpixels_per_line, stride, height, 0);
+	return;
+	}
+
+
+static void init_nv_planes(
+	struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation)
+{
+	unsigned int y_width = frame->info.padded_width,
+		     y_height = frame->info.res.height,
+		     uv_width = 2 * (y_width / horizontal_decimation),
+		     uv_height = y_height / vertical_decimation,
+		     y_bytes, uv_bytes;
+
+	y_bytes   = y_width * y_height;
+	uv_bytes  = uv_width * uv_height;
+
+	frame->data_bytes = y_bytes + uv_bytes;
+	init_plane(&frame->planes.nv.y, y_width, y_width, y_height, 0);
+	init_plane(&frame->planes.nv.uv, uv_width,
+			uv_width, uv_height, y_bytes);
+	return;
+}
+
+static void init_yuv_planes(
+	struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation,
+	bool swap_uv,
+	unsigned int bytes_per_element)
+{
+	unsigned int y_width = frame->info.padded_width,
+		     y_height = frame->info.res.height,
+		     uv_width = y_width / horizontal_decimation,
+		     uv_height = y_height / vertical_decimation,
+		     y_stride, y_bytes, uv_bytes, uv_stride;
+
+	y_stride  = y_width * bytes_per_element;
+	uv_stride = uv_width * bytes_per_element;
+	y_bytes   = y_stride * y_height;
+	uv_bytes  = uv_stride * uv_height;
+
+	frame->data_bytes = y_bytes + 2 * uv_bytes;
+	init_plane(&frame->planes.yuv.y, y_width, y_stride, y_height, 0);
+		if (swap_uv) {
+			init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
+				   uv_height, y_bytes);
+			init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
+				   uv_height, y_bytes + uv_bytes);
+		} else {
+			init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
+				   uv_height, y_bytes);
+			init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
+				   uv_height, y_bytes + uv_bytes);
+		}
+	return;
+	}
+
+static void init_rgb_planes(
+	struct ia_css_frame *frame,
+	unsigned int bytes_per_element)
+{
+	unsigned int width = frame->info.res.width,
+		     height = frame->info.res.height, stride, bytes;
+
+	stride = width * bytes_per_element;
+	bytes  = stride * height;
+	frame->data_bytes = 3 * bytes;
+	init_plane(&frame->planes.planar_rgb.r,
+			width, stride, height, 0);
+	init_plane(&frame->planes.planar_rgb.g,
+			width, stride, height, 1 * bytes);
+	init_plane(&frame->planes.planar_rgb.b,
+			width, stride, height, 2 * bytes);
+	return;
+	}
+
+static void init_qplane6_planes(
+	struct ia_css_frame *frame)
+{
+	unsigned int width = frame->info.padded_width / 2,
+		     height = frame->info.res.height / 2,
+		     bytes, stride;
+
+	stride = width * 2;
+	bytes  = stride * height;
+
+	frame->data_bytes = 6 * bytes;
+	init_plane(&frame->planes.plane6.r,
+			width, stride, height, 0 * bytes);
+	init_plane(&frame->planes.plane6.r_at_b,
+			width, stride, height, 1 * bytes);
+	init_plane(&frame->planes.plane6.gr,
+			width, stride, height, 2 * bytes);
+	init_plane(&frame->planes.plane6.gb,
+			width, stride, height, 3 * bytes);
+	init_plane(&frame->planes.plane6.b,
+			width, stride, height, 4 * bytes);
+	init_plane(&frame->planes.plane6.b_at_r,
+			width, stride, height, 5 * bytes);
+	return;
+}
+
+static enum ia_css_err init_frame_planes(
+	struct ia_css_frame *frame)
+{
+assert(frame != NULL);
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_MIPI:
+		init_mipi_plane(frame, &frame->planes.raw,
+				frame->info.res.height,
+				frame->info.padded_width,
+				frame->info.raw_bit_depth <= 8 ? 1 : 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW:
+		init_single_plane(frame, &frame->planes.raw,
+				frame->info.res.height,
+				frame->info.padded_width,
+				frame->info.raw_bit_depth <= 8 ? 1 : 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		init_single_plane(frame, &frame->planes.rgb,
+				    frame->info.res.height,
+				    frame->info.padded_width, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		init_single_plane(frame, &frame->planes.rgb,
+				    frame->info.res.height,
+				    frame->info.padded_width * 4, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+		init_rgb_planes(frame, 1);
+		break;
+		/* yuyv and uyvu have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+		init_single_plane(frame, &frame->planes.yuyv,
+				    frame->info.res.height,
+				    frame->info.padded_width * 2, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		/* Needs 3 extra lines to allow vf_pp prefetching */
+		init_single_plane(frame, &frame->planes.yuyv,
+				    frame->info.res.height * 3/2 + 3,
+				    frame->info.padded_width, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_NV11:
+		init_nv_planes(frame, 4, 1);
+		break;
+		/* nv12 and nv21 have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV21:
+		init_nv_planes(frame, 2, 2);
+		break;
+		/* nv16 and nv61 have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		init_nv_planes(frame, 2, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+		init_yuv_planes(frame, 2, 2, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV422:
+		init_yuv_planes(frame, 2, 1, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV444:
+		init_yuv_planes(frame, 1, 1, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+		init_yuv_planes(frame, 2, 2, false, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+		init_yuv_planes(frame, 2, 1, false, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_YV12:
+		init_yuv_planes(frame, 2, 2, true, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YV16:
+		init_yuv_planes(frame, 2, 1, true, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		init_qplane6_planes(frame);
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		init_single_plane(frame, &frame->planes.binary.data,
+				    frame->info.res.height,
+				    frame->info.padded_width, 1);
+		frame->planes.binary.size = 0;
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+
+static enum ia_css_err allocate_frame_and_data(
+	struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth,
+	bool contiguous)
+{
+	enum ia_css_err err;
+	struct ia_css_frame *me = sh_css_malloc(sizeof(*me));
+
+	if (me == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	me->info.res.width = width;
+	me->info.res.height = height;
+	me->info.format = format;
+	me->info.padded_width = padded_width;
+	me->info.raw_bit_depth = raw_bit_depth;
+	me->contiguous = contiguous;
+	me->valid = true;
+	me->dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+
+	err = init_frame_planes(me);
+
+	if (err == IA_CSS_SUCCESS)
+		err = allocate_frame_data(me);
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+		*frame = me;
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate(
+	struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	if (frame == NULL || width == 0||height == 0) return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate() enter: width=%d, height=%d, format=%d\n",
+		width, height, format);
+
+
+	err = allocate_frame_and_data(frame, width, height, format,
+			      padded_width, raw_bit_depth, false);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate() leave: frame=%p\n",
+		frame ? *frame : (void *)-1);
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate_from_info(
+	struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	if (frame == NULL || info == NULL) return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_frame_allocate_from_info() enter:\n");
+	err = ia_css_frame_allocate(frame,
+				     info->res.width,
+				     info->res.height,
+				     info->format,
+				     info->padded_width,
+				     info->raw_bit_depth);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_frame_allocate_from_info() leave:\n");
+	return err;
+}
+
+enum ia_css_err
+ia_css_frame_map(struct ia_css_frame **frame,
+                 const struct ia_css_frame_info *info,
+                 const void *data,
+                 uint16_t attribute,
+                 void *context)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *me = sh_css_malloc(sizeof(*me));
+
+	if (me == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	me->info.res.width = info->res.width;
+	me->info.res.height = info->res.height;
+	me->info.format = info->format;
+	me->info.padded_width = info->padded_width;
+	me->info.raw_bit_depth = info->raw_bit_depth;
+	me->contiguous = false; /* doublecheck */
+	me->valid = true;
+	me->dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+
+	err = init_frame_planes(me);
+
+	if (err == IA_CSS_SUCCESS) {
+		/* use mmgr_mmap to map */
+		me->data = (ia_css_ptr)mmgr_mmap(
+					     data,
+					     me->data_bytes,
+					     attribute,
+					     context);
+		if (me->data == mmgr_NULL)
+			err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	};
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+	*frame = me;
+
+	return err;
+}
+
+enum ia_css_err
+ia_css_mipi_frame_allocate(struct	ia_css_frame **frame,
+				const unsigned int	size_bytes,
+				const bool			contiguous)
+{
+	/* AM: Body coppied from allocate_frame_and_data().*/
+	enum ia_css_err err;
+	struct ia_css_frame *me = sh_css_malloc(sizeof(*me));
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_mipi_frame_allocate()\n");
+	
+	if (me == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	me->info.res.width = 0;
+	me->info.res.height = 0;
+	// To indicate it is not (yet) valid format.
+	me->info.format = IA_CSS_FRAME_FORMAT_NUM;
+	me->info.padded_width = 0;
+	me->info.raw_bit_depth = 0;
+	me->data_bytes = size_bytes;
+	me->contiguous = contiguous;
+	// To indicate it is not valid frame.
+	me->dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+
+	err = allocate_frame_data(me);
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+		*frame = me;
+
+	return err;
+}
+
+enum ia_css_err
+ia_css_mipi_frame_specify(const unsigned int size_mem_words,
+				const bool contiguous)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	my_css.size_mem_words 	= size_mem_words;
+	my_css.contiguous		= contiguous;		
+
+
+	return err;
+}
+
+/* Assumptions:
+ *	- A line is multiple of 4 bytes = 1 word.
+ *	- Each frame has SOF and EOF (each 1 word).
+ *	- Each line has format header and optionally SOL and EOL (each 1 word).
+ *	- Odd and even lines of YUV420 format are different in bites per pixel size.
+ *	- Custom size of embedded data.
+ *  -- Interleaved frames are not taken into account.
+ *  -- Lines are multiples of 8B, and not necessary of (custom 3B, or 7B
+ *  etc.). 
+ * Result is given in DDR mem words, 32B or 256 bits
+ */
+enum ia_css_err
+ia_css_mipi_frame_calculate_size(const unsigned int width,
+				const unsigned int height,
+				const enum ia_css_stream_format format,
+				const bool hasSOLandEOL,
+				const unsigned int embedded_data_size_words,
+				unsigned int *size_mem_words)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	unsigned int bits_per_pixel = 0; 
+	unsigned int even_line_bytes = 0;
+	unsigned int odd_line_bytes = 0;
+	unsigned int words_per_odd_line = 0;
+	unsigned int words_for_first_line = 0;
+	unsigned int words_per_even_line = 0;
+	unsigned int mem_words_per_even_line = 0;
+	unsigned int mem_words_per_odd_line = 0;
+	unsigned int mem_words_for_first_line = 0;
+	unsigned int mem_words_for_EOF = 0;
+	unsigned int mem_words = 0;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_mipi_frame_calculate_size() "
+		"enter: width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\n",
+		width, height, format, hasSOLandEOL, embedded_data_size_words);
+
+	switch (format) {
+		case IA_CSS_STREAM_FORMAT_RAW_6:			/* 4p, 3B, 24bits */
+			bits_per_pixel = 6; 	break;
+		case IA_CSS_STREAM_FORMAT_RAW_7:			/* 8p, 7B, 56bits */
+			bits_per_pixel = 7;		break;
+		case IA_CSS_STREAM_FORMAT_RAW_8:			/* 1p, 1B, 8bits */
+		case IA_CSS_STREAM_FORMAT_BINARY_8:      /*  8bits, TODO: check. */
+		case IA_CSS_STREAM_FORMAT_YUV420_8:		/* odd 2p, 2B, 16bits, even 2p, 4B, 32bits */
+			bits_per_pixel = 8;		break;
+		case IA_CSS_STREAM_FORMAT_YUV420_10:		/* odd 4p, 5B, 40bits, even 4p, 10B, 80bits */
+		case IA_CSS_STREAM_FORMAT_RAW_10:		/* 4p, 5B, 40bits */
+			bits_per_pixel = 10;	break;
+		case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:	/* 2p, 3B, 24bits */	
+		case IA_CSS_STREAM_FORMAT_RAW_12:			/* 2p, 3B, 24bits */			
+			bits_per_pixel = 12;	break;
+		case IA_CSS_STREAM_FORMAT_RAW_14:		/* 4p, 7B, 56bits */
+			bits_per_pixel = 14;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_444:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_RGB_555:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_RGB_565:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_YUV422_8:		/* 2p, 4B, 32bits */
+			bits_per_pixel = 16;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_666:		/* 4p, 9B, 72bits */
+			bits_per_pixel = 18;	break;
+		case IA_CSS_STREAM_FORMAT_YUV422_10:		/* 2p, 5B, 40bits */
+			bits_per_pixel = 20;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_888:		/* 1p, 3B, 24bits */
+			bits_per_pixel = 24;	break;
+		
+		case IA_CSS_STREAM_FORMAT_RAW_16:        /* TODO: not specified in MIPI SPEC, check */
+		default:
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	
+	odd_line_bytes = (width * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8 ) */
+
+	/* Even lines for YUV420 formats are double in bits_per_pixel. */
+	if (format == IA_CSS_STREAM_FORMAT_YUV420_8
+		|| format == IA_CSS_STREAM_FORMAT_YUV420_10) {
+		even_line_bytes = (width * 2 * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8 ) */
+	} else {
+		even_line_bytes = odd_line_bytes; 
+	}
+
+   /*  a frame represented in memory:  ()- optional; data - payload words.
+	*  addr		0		1		2		3		4		5		6		7:
+	*  first	SOF		(SOL)	PACK_H	data	data	data	data	data
+	*          	data	data	data	data	data	data	data	data
+	*           ...              
+	*			data 	data	0		0		0		0		0		0
+	*  second   (EOL)	(SOL)	PACK_H	data	data	data	data	data			
+	*          	data	data	data	data	data	data	data	data
+	*           ...              
+	*			data 	data	0		0		0		0		0		0
+	*  ...
+	*  last		(EOL)	EOF		0		0		0		0		0		0
+	*
+	*  Embedded lines are regular lines stored before the first and after
+	*  payload lines.
+	*/
+
+
+	words_per_odd_line 	 = ((odd_line_bytes   + 3) >> 2 ); 		/* ceil(odd_line_bytes/4); word = 4 bytes */
+	words_per_even_line  = ((even_line_bytes  + 3) >> 2 );
+    words_for_first_line = words_per_odd_line + 2 + (hasSOLandEOL ? 1 : 0); /* + SOF +packet header + optionally (SOL), but (EOL) is not in the first line */
+	words_per_odd_line 	+= (1 + (hasSOLandEOL ? 2 : 0));  /* each non-first line has format header, and optionally (SOL) and (EOL). */
+	words_per_even_line += (1 + (hasSOLandEOL ? 2 : 0));
+
+	mem_words_per_odd_line 	 = ((words_per_odd_line + 7) >> 3); 	/* ceil(words_per_odd_line/8); mem_word = 32 bytes, 8 words */
+	mem_words_for_first_line = ((words_for_first_line + 7) >> 3);
+	mem_words_per_even_line  = ((words_per_even_line + 7) >> 3);
+	mem_words_for_EOF        = 1; /* last line consisit of the optional (EOL) and EOF */
+
+	mem_words = ((embedded_data_size_words + 7) >> 3) +
+                mem_words_for_first_line + 
+				(((height + 1) >> 1) - 1) * mem_words_per_odd_line + /* ceil (height/2) - 1 (first line is calculated separatelly) */
+				(  height      >> 1     ) * mem_words_per_even_line + /* floor(height/2) */
+				mem_words_for_EOF;
+	
+	*size_mem_words = mem_words; /* ceil(words/8); mem word is 32B = 8words. */ //Check if this is still needed.
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_mipi_frame_calculate_size() leave: return_err=%d\n",err);
+	
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate_contiguous(
+	struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate_contiguous() "
+		"enter: width=%d, height=%d, format=%d\n",
+		width, height, format);
+
+	err = allocate_frame_and_data(frame, width, height, format,
+					padded_width, raw_bit_depth, true);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate_contiguous() leave: frame=%p\n",
+		frame ? *frame : (void *)-1);
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate_contiguous_from_info(
+	struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+assert(frame != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate_contiguous_from_info() enter:\n");
+	err = ia_css_frame_allocate_contiguous(frame,
+						info->res.width,
+						info->res.height,
+						info->format,
+						info->padded_width,
+						info->raw_bit_depth);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_allocate_contiguous_from_info() leave:\n");
+return err;
+}
+
+void
+ia_css_frame_free(struct ia_css_frame *frame)
+{
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_free() enter: frame=%p\n", frame);
+
+	if (frame != NULL) {
+		mmgr_free(frame->data);
+		sh_css_free(frame);
+	}
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_frame_free() leave: return_void\n");
+}
+
+bool sh_css_frame_info_equal_resolution(
+	const struct ia_css_frame_info *info_a,
+	const struct ia_css_frame_info *info_b)
+{
+	if (!info_a || !info_b)
+		return false;
+	return (info_a->res.width == info_b->res.width) &&
+	    (info_a->res.height == info_b->res.height);
+}
+
+bool sh_css_frame_equal_types(
+	const struct ia_css_frame *frame_a,
+	const struct ia_css_frame *frame_b)
+{
+	bool is_equal = false;
+	const struct ia_css_frame_info *info_a = &frame_a->info,
+	    *info_b = &frame_b->info;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_frame_equal_types() enter:\n");
+
+	if (!info_a || !info_b)
+		return false;
+	if (info_a->format != info_b->format)
+		return false;
+	if (info_a->padded_width != info_b->padded_width)
+		return false;
+	is_equal = sh_css_frame_info_equal_resolution(info_a, info_b);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_frame_equal_types() leave:\n");
+return is_equal;
+}
+
+static void
+append_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "append_firmware() enter:\n");
+	while (*l)
+		l = &(*l)->next;
+	*l = firmware;
+	firmware->next = NULL;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "append_firmware() leave:\n");
+}
+
+static void
+remove_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "remove_firmware() enter:\n");
+	while (*l && *l != firmware)
+		l = &(*l)->next;
+	if (!*l)
+		return;
+	*l = firmware->next;
+	firmware->next = NULL;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "remove_firmware() leave:\n");
+}
+
+/* Load firmware for acceleration */
+
+/* Unload firmware for acceleration */
+//fix me, to be removed 
+void
+sh_css_unload_acceleration(struct ia_css_acc_fw *firmware)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_unload_acceleration() enter:\n");
+	sh_css_acc_unload(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_unload_acceleration() leave:\n");
+}
+
+/* Load firmware for extension */
+static enum ia_css_err
+ia_css_pipe_load_extension(struct ia_css_pipe *pipe,
+			   struct ia_css_fw_info *firmware)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_extension() enter:\n");
+	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
+		append_firmware(&pipe->old_pipe->output_stage, firmware);
+	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER)
+		append_firmware(&pipe->old_pipe->vf_stage, firmware);
+	err = sh_css_acc_load_extension(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_extension() leave:\n");
+	return err;
+}
+
+/* Unload firmware for extension */
+static void
+ia_css_pipe_unload_extension(struct ia_css_pipe *pipe,
+			     struct ia_css_fw_info *firmware)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() enter:\n");
+	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
+		remove_firmware(&pipe->old_pipe->output_stage, firmware);
+	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER)
+		remove_firmware(&pipe->old_pipe->vf_stage, firmware);
+	sh_css_acc_unload_extension(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() leave:\n");
+}
+
+/* Set acceleration parameter to value <val> */
+enum ia_css_err
+sh_css_set_acceleration_parameter(struct ia_css_acc_fw *firmware,
+				  hrt_vaddress val, size_t size)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_data par; 
+	par.address =  val;
+	par.size = size ;
+	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_acceleration_parameter() enter:\n");
+	err = sh_css_acc_set_parameter(firmware, par);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_acceleration_parameter() leave:\n");
+return err;
+}
+
+/* Set acceleration parameters to value <val> */
+enum ia_css_err
+sh_css_set_firmware_dmem_parameters(struct ia_css_fw_info *firmware,
+				    enum ia_css_isp_memories mem,
+				  hrt_vaddress val, size_t size)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_data par; 
+	par.address =  val;
+	par.size = size ;
+	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_firmware_dmem_parameters() enter:\n");
+	err = sh_css_acc_set_firmware_parameters(firmware, mem, par);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_firmware_dmem_parameters() leave:\n");
+return err;
+}
+
+/* Start acceleration of firmware with sp-args as SP arguments. */
+enum ia_css_err
+sh_css_start_acceleration(struct ia_css_acc_fw *firmware)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_start_acceleration() enter:\n");
+	err = sh_css_acc_start(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_start_acceleration() leave:\n");
+	return err;
+}
+
+/* To be called when acceleration has terminated.
+*/
+void
+sh_css_acceleration_done(struct ia_css_acc_fw *firmware)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_acceleration_done() enter: firmware=%p\n", firmware);
+	sh_css_acc_wait();
+	sh_css_acc_done(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_acceleration_done() leave: return_void\n");
+}
+
+/* Abort acceleration within <deadline> microseconds
+*/
+void
+sh_css_abort_acceleration(struct ia_css_acc_fw *firmware, unsigned deadline)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_abort_acceleration() enter:\n");
+	/* TODO: implement time-out */
+	(void)deadline;
+	sh_css_acc_abort(firmware);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_abort_acceleration() leave:\n");
+}
+
+bool
+sh_css_pipe_uses_params(struct sh_css_pipeline *me)
+{
+	struct sh_css_pipeline_stage *stage;
+
+assert(me != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipe_uses_params() enter: me=%p\n", me);
+
+	for (stage = me->stages; stage; stage = stage->next)
+		if (stage->binary_info && stage->binary_info->enable.params) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"sh_css_pipe_uses_params() leave: "
+				"return_bool=true\n");
+			return true;
+		}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_pipe_uses_params() leave: return_bool=false\n");
+	return false;
+}
+
+/* Create a pipeline stage for firmware <isp_fw>
+ * with input and output arguments.
+*/
+static enum ia_css_err sh_css_create_stage(
+	struct sh_css_pipeline_stage **stage,
+	const char *isp_fw,
+	struct ia_css_frame *in,
+	struct ia_css_frame *out,
+	struct ia_css_frame *vf)
+{
+	struct sh_css_binary *binary;
+	struct ia_css_blob_descr *blob;
+	struct ia_css_binary_info *info;
+	unsigned size;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(stage != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_create_stage() enter:\n");
+
+	*stage = sh_css_malloc(sizeof(**stage));
+	if (*stage == NULL) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_create_stage() leave: return_err=%d\n",
+			IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	binary = sh_css_malloc(sizeof(*binary));
+	if (binary == NULL) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_create_stage() leave: return_err=%d\n",
+			IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	blob = sh_css_malloc(sizeof(*blob));
+	if (blob == NULL) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_create_stage() leave: return_err=%d\n",
+			IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	memset(&(*stage)->args, 0, sizeof((*stage)->args));
+	(*stage)->args.in_frame = in;
+	(*stage)->args.out_frame = out;
+	(*stage)->args.out_vf_frame = vf;
+
+	err = sh_css_load_blob_info(isp_fw, blob);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_create_stage() leave: return_err=%d\n",
+			err);
+		return err;
+	}
+	err = sh_css_fill_binary_info(&blob->header.info.isp, false, false,
+			    IA_CSS_STREAM_FORMAT_RAW_10,
+			    in  ? &in->info  : NULL,
+			    out ? &out->info : NULL,
+			    vf  ? &vf->info  : NULL,
+			    binary, false, NULL);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_create_stage() leave: return_err=%d\n",
+			err);
+		return err;
+	}
+	blob->header.info.isp.xmem_addr = 0;
+	size = blob->header.blob.size;
+	if (size) {
+		blob->header.info.isp.xmem_addr =
+			sh_css_load_blob(blob->blob, size);
+		if (!blob->header.info.isp.xmem_addr) {
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"sh_css_create_stage() leave: return_err=%d\n",
+				IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+	}
+
+	info = (struct ia_css_binary_info *)binary->info;
+	info->blob = blob;
+	(*stage)->binary = binary;
+	(*stage)->binary_info = &blob->header.info.isp;
+	(*stage)->firmware = NULL;
+	(*stage)->mode = binary->info->mode;
+	(*stage)->out_frame_allocated = false;
+	(*stage)->vf_frame_allocated = false;
+	(*stage)->next = NULL;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_create_stage() leave: return_err=%d\n", err);
+
+	return err;
+}
+
+/* Append a new stage to *pipeline. When *pipeline is NULL, it will be created.
+ * The stage consists of an ISP binary <isp_fw> and input and output arguments.
+*/
+enum ia_css_err
+sh_css_append_stage(struct sh_css_pipeline **pipeline,
+		    const char *isp_fw,
+		    struct ia_css_frame *in,
+		    struct ia_css_frame *out,
+		    struct ia_css_frame *vf)
+{
+	struct sh_css_pipeline_stage *stage;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_append_stage() enter: "
+		"pipeline=%p, isp_f=%p, in=%p, out=%p, vf=%p\n",
+		pipeline, isp_fw, in, out, vf);
+
+	if (!*pipeline) {
+		*pipeline = sh_css_create_pipeline();
+		if (*pipeline == NULL) {
+
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"sh_css_append_stage() leave: return_err=%d\n",
+				IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+	}
+
+	err = sh_css_create_stage(&stage, isp_fw, in, out, vf);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"sh_css_append_stage() leave: return_err=%d\n", err);
+
+		return err;
+	}
+
+	stage->stage_num = (*pipeline)->num_stages++;
+	if ((*pipeline)->current_stage)
+		(*pipeline)->current_stage->next = stage;
+	else
+		(*pipeline)->stages = stage;
+
+	(*pipeline)->current_stage = stage;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_append_stage() leave: return_err=%d\n", err);
+
+	return err;
+}
+
+/* #error return of function is not consistent with implementation */
+struct sh_css_pipeline *
+sh_css_create_pipeline(void)
+{
+	struct sh_css_pipeline *pipeline = sh_css_malloc(sizeof(struct sh_css_pipeline));
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_create_pipeline() enter:\n");
+
+	if (pipeline != NULL) {
+		pipeline->num_stages = 0;
+		pipeline->stages = NULL;
+		pipeline->current_stage = NULL;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_create_pipeline() leave: pipeline=%p\n");
+	return pipeline;
+}
+
+enum ia_css_err
+sh_css_pipeline_add_acc_stage(struct sh_css_pipeline *pipeline,
+			      const void *acc_fw)
+{
+	struct ia_css_fw_info *fw = (struct ia_css_fw_info *)acc_fw;
+	enum ia_css_err	err = sh_css_acc_load_extension(fw);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipeline_add_acc_stage() enter: pipeline=%p,"
+		" acc_fw=%p\n", pipeline, acc_fw);
+
+	if (err == IA_CSS_SUCCESS) {
+		err = sh_css_pipeline_add_stage(
+			pipeline, NULL, fw,
+			SH_CSS_BINARY_MODE_VF_PP, NULL,
+			NULL, NULL,
+			NULL,NULL);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_pipeline_add_acc_stage() leave: return_err=%d\n",err);
+	return err;
+}
+
+/* Run a pipeline and wait till it completes. */
+void
+sh_css_start_pipeline(enum ia_css_pipe_id pipe_id, struct sh_css_pipeline *pipeline)
+{
+	uint8_t pipe_num = 0;
+	unsigned int thread_id;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_start_pipeline() enter: pipe_id=%d, pipeline=%p\n",
+		pipe_id, pipeline);
+	pipeline->pipe_id = pipe_id;
+	sh_css_sp_init_pipeline(pipeline, pipe_id, pipe_num,
+				false, true, false, false, false, true, false,
+				SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
+				IA_CSS_INPUT_MODE_MEMORY,
+				(mipi_port_ID_t) 0);
+	//sh_css_sp_start_isp();
+
+	//TODO: fix here, pipe_num
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	sh_css_sp_snd_event(SP_SW_EVENT_ID_4, thread_id, 0,  0);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_start_pipeline() leave: return_void\n");
+}
+
+/* Run a pipeline and free all memory allocated to it. */
+void
+sh_css_close_pipeline(struct sh_css_pipeline *pipeline)
+{
+	struct sh_css_pipeline_stage *stage;
+	struct sh_css_pipeline_stage *next;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_close_pipeline() enter: pipeline=%p\n", pipeline);
+
+	for (stage = pipeline->stages; stage; stage = next) {
+		struct ia_css_blob_descr *blob;
+		next = stage->next;
+		blob = (struct ia_css_blob_descr *)stage->binary->info->blob;
+		if (blob->header.info.isp.xmem_addr)
+			mmgr_free(blob->header.info.isp.xmem_addr);
+		sh_css_free(blob);
+		sh_css_free(stage->binary);
+		sh_css_pipeline_stage_destroy(stage);
+	}
+	sh_css_free(pipeline);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_close_pipeline() leave: return_void\n");
+}
+
+/**
+ * @brief Query the SP thread ID.
+ * Refer to "sh_css_internal.h" for details.
+ */
+bool
+sh_css_query_sp_thread_id(unsigned int key,
+			  unsigned int *val)
+{
+assert(key < MAX_NUM_PIPES);
+assert(key < IA_CSS_PIPE_ID_NUM);
+assert(val != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_query_sp_thread_id() enter: key=%d\n", key);
+	*val = pipe_num_to_sp_thread[key];
+		assert(*val != 0xFFFF);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_query_sp_thread_id() leave: return_val=%d\n", *val);
+	return true;
+}
+
+/**
+ * @brief Query the internal frame ID.
+ * Refer to "sh_css_internal.h" for details.
+ */
+bool sh_css_query_internal_queue_id(
+	enum ia_css_buffer_type key,
+	enum sh_css_buffer_queue_id *val)
+{
+assert(key < IA_CSS_BUFFER_TYPE_NUM);
+assert(val != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_query_internal_queue_id() enter: key=%d\n", key);
+	*val = sh_css_buf_type_2_internal_queue_id[key];
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+		"sh_css_query_internal_queue_id() leave: return_val=%d\n",
+		*val);
+	return true;
+}
+
+/**
+ * @brief Tag a specific frame in continuous capture.
+ * Refer to "sh_css_internal.h" for details.
+ */
+enum ia_css_err ia_css_stream_capture_frame(struct ia_css_stream *stream,
+				unsigned int exp_id)
+{
+	struct sh_css_tag_descr tag_descr;
+	unsigned int encoded_tag_descr;
+
+	bool enqueue_successful = false;
+	assert(stream != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture_frame() enter: exp_id=%d\n",
+		exp_id);
+
+	if (exp_id == 0) {
+		sh_css_dtrace(SH_DBG_TRACE,
+			"ia_css_stream_capture_frame() "
+			"leave: return_err=%d\n",
+			IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* Create the tag descriptor from the parameters */
+	sh_css_create_tag_descr(0, 0, 0, exp_id, &tag_descr);
+
+
+	/* Encode the tag descriptor into a 32-bit value */
+	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
+
+
+	/* Enqueue the encoded tag to the host2sp queue.
+	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
+	 * on both host and the SP side.
+	 * It is mainly because it is enough to have only one tag_cmd queue */
+	enqueue_successful = host2sp_enqueue_buffer(0, 0,
+				sh_css_tag_cmd_queue,
+				(uint32_t)encoded_tag_descr);
+
+
+	/* Give an error if the tag command cannot be issued
+	 * (because the cmd queue is full) */
+	if (!enqueue_successful) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture_frame() leave: return_err=%d\n",
+		IA_CSS_ERR_QUEUE_IS_FULL);
+		return IA_CSS_ERR_QUEUE_IS_FULL;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture_frame() leave: return_err=%d\n",
+		IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+/**
+ * @brief Configure the continuous capture.
+ * Refer to "sh_css_internal.h" for details.
+ */
+enum ia_css_err ia_css_stream_capture(
+	struct ia_css_stream *stream,
+	int num_captures,
+	unsigned int skip,
+	int offset)
+{
+	struct sh_css_tag_descr tag_descr;
+	unsigned int encoded_tag_descr;
+
+	bool enqueue_successful = false;
+	assert(stream != NULL);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture() enter: num_captures=%d,"
+		" skip=%d, offset=%d\n", num_captures, skip,offset);
+
+	/* Check if the tag descriptor is valid */
+	if (num_captures < SH_CSS_MINIMUM_TAG_ID) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture() leave: return_err=%d\n",
+		IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* Create the tag descriptor from the parameters */
+	sh_css_create_tag_descr(num_captures, skip, offset, 0, &tag_descr);
+
+
+	/* Encode the tag descriptor into a 32-bit value */
+	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
+
+
+	/* Enqueue the encoded tag to the host2sp queue.
+	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
+	 * on both host and the SP side.
+	 * It is mainly because it is enough to have only one tag_cmd queue */
+	enqueue_successful = host2sp_enqueue_buffer(0, 0,
+				sh_css_tag_cmd_queue,
+				(uint32_t)encoded_tag_descr);
+
+
+	/* Give an error if the tag command cannot be issued
+	 * (because the cmd queue is full) */
+	if (!enqueue_successful) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture() leave: return_err=%d\n",
+		IA_CSS_ERR_QUEUE_IS_FULL);
+		return IA_CSS_ERR_QUEUE_IS_FULL;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_capture() leave: return_err=%d\n",
+		IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+void ia_css_stream_request_flash(struct ia_css_stream *stream)
+{
+	const struct ia_css_fw_info *fw= &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_request_flash;
+	assert(stream != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_request_flash() enter: void\n");
+	HIVE_ADDR_sp_request_flash = fw->info.sp.request_flash;
+
+	(void)HIVE_ADDR_sp_request_flash;
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_request_flash),
+		1);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_request_flash() leave: return_void\n");
+}
+
+enum ia_css_err
+sh_css_acceleration_stop(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_acceleration_stop() enter: void\n");
+	err = sh_css_pipe_stop(pipe);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_acceleration_stop() leave: return_err=%d\n",err);
+	return err;
+}
+
+static void
+sh_css_init_host_sp_control_vars(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_isp_started;
+	
+	unsigned int HIVE_ADDR_host_sp_queues_initialized;
+	unsigned int HIVE_ADDR_sp_sleep_mode;
+	unsigned int HIVE_ADDR_sp_invalidate_tlb;
+	unsigned int HIVE_ADDR_sp_request_flash;
+	unsigned int HIVE_ADDR_sp_stop_copy_preview;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_init_host_sp_control_vars() enter: void\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_isp_started = fw->info.sp.isp_started;
+	
+	HIVE_ADDR_host_sp_queues_initialized =
+		fw->info.sp.host_sp_queues_initialized;
+	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
+	HIVE_ADDR_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+	HIVE_ADDR_sp_request_flash = fw->info.sp.request_flash;
+	HIVE_ADDR_sp_stop_copy_preview = fw->info.sp.stop_copy_preview;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+
+	(void)HIVE_ADDR_sp_isp_started; /* Suppres warnings in CRUN */
+	
+	(void)HIVE_ADDR_sp_sleep_mode;
+	(void)HIVE_ADDR_sp_invalidate_tlb;
+	(void)HIVE_ADDR_sp_request_flash;
+	(void)HIVE_ADDR_sp_stop_copy_preview;
+	(void)HIVE_ADDR_host_sp_com;
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_isp_started),
+		(uint32_t)(0));
+	
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_sleep_mode),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_invalidate_tlb),
+		(uint32_t)(false));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_request_flash),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_stop_copy_preview),
+		my_css.stop_copy_preview?(uint32_t)(1):(uint32_t)(0));
+	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
+	sh_css_update_host2sp_cont_num_raw_frames
+			(my_css.num_cont_raw_frames);
+	sh_css_update_host2sp_cont_num_mipi_frames
+			(my_css.num_mipi_frames);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_init_host_sp_control_vars() leave: return_void\n");
+}
+
+void
+ia_css_get_properties(struct ia_css_properties *properties)
+{
+#if defined(HAS_GDC_VERSION_2)
+/*
+ * MW: We don't want to store the coordinates
+ * full range in memory: Truncate
+ */
+	properties->gdc_coord_one = gdc_get_unity(GDC0_ID)/HRT_GDC_COORD_SCALE;
+#elif defined(HAS_GDC_VERSION_1)
+	properties->gdc_coord_one = gdc_get_unity(GDC0_ID);
+#else
+#error "Unknown GDC version"
+#endif
+
+#if defined(IS_ISP_2300_SYSTEM)
+	properties->l1_base_is_index = false;
+#else
+	properties->l1_base_is_index = true;
+#endif
+
+#if defined(HAS_VAMEM_VERSION_1)
+	properties->vamem_type = IA_CSS_VAMEM_TYPE_1;
+#elif defined(HAS_VAMEM_VERSION_2)
+	properties->vamem_type = IA_CSS_VAMEM_TYPE_2;
+#else
+#error "Unknown VAMEM version"
+#endif
+}
+
+/**
+ * create the internal structures and fill in the configuration data
+ */
+void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config)
+{
+  struct ia_css_pipe_config def_config = {
+    0,
+    1, /* isp_pipe_version */
+    {0, 0},
+    {0, 0},
+    {0, 0},
+    {{0, 0}, 0, 0, 0, 0}, /* output_info */
+    {{0, 0}, 0, 0, 0, 0}, /* vf_output_info */
+    NULL, /* acc_extension */
+    NULL, /* acc_stages */
+    0,    /* num_acc_stages */
+    {
+      0,
+      false,
+      false,
+      false
+    },
+    {0, 0},
+  };
+  sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_config_defaults()\n");
+  *pipe_config = def_config;
+}
+
+void
+ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)
+{
+	extra_config->enable_raw_binning = false;
+	extra_config->enable_yuv_ds = false;
+	extra_config->enable_high_speed = false;
+	extra_config->enable_dvs_6axis = false;
+	extra_config->enable_reduced_pipe = false;
+	extra_config->disable_vf_pp = false;
+	extra_config->disable_capture_pp = false;
+	extra_config->enable_dz = true;
+}
+
+void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_config_defaults()\n");
+	assert(stream_config != NULL);
+	memset(stream_config, 0, sizeof(*stream_config));
+	stream_config->online = true;
+}
+
+static enum ia_css_err
+ia_css_acc_pipe_create(struct ia_css_pipe *pipe)
+{
+	unsigned int i;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_pipeline *pipeline = &pipe->old_pipe->pipeline;
+
+	for (i=0; i<pipe->config.num_acc_stages; i++) {
+		struct ia_css_fw_info *fw = pipe->config.acc_stages[i];
+		err = sh_css_pipeline_add_acc_stage(pipeline, fw);
+		if (err != IA_CSS_SUCCESS)
+			break;
+	}
+	return err;
+}
+
+enum ia_css_err
+ia_css_pipe_create(const struct ia_css_pipe_config *config,
+		   struct ia_css_pipe **pipe)
+{
+	return ia_css_pipe_create_extra(config, NULL, pipe);
+}
+
+enum ia_css_err
+ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			 const struct ia_css_pipe_extra_config *extra_config,
+			 struct ia_css_pipe **pipe)
+{
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	struct ia_css_pipe *internal_pipe;
+
+	(void)extra_config;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_create()\n");
+	assert(pipe!=NULL);
+	assert(*pipe==NULL);
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (*pipe != NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	
+	err = create_pipe(config->mode, &internal_pipe, false);
+	if (internal_pipe == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	
+	if (pipe_num_counter > MAX_NUM_PIPES) return IA_CSS_ERR_RESOURCE_LIST_TO_SMALL;
+
+	/* now we have a pipe structure to fill */
+	internal_pipe->config = *config;
+	if (extra_config)
+		internal_pipe->extra_config = *extra_config;
+	else
+		ia_css_pipe_extra_config_defaults(&internal_pipe->extra_config);
+
+	if (config->mode == IA_CSS_PIPE_MODE_ACC) {
+		/* Temporary hack to migrate acceleration to CSS 2.0.
+		 * In the future the code for all pipe types should be
+		 * unified. */
+		*pipe = internal_pipe;
+		return ia_css_acc_pipe_create(internal_pipe);
+	}
+	/* handle the mode, for now select the correct pipe instance */
+	internal_pipe->old_pipe->capture_mode =
+		internal_pipe->config.default_capture_config.mode;
+	internal_pipe->old_pipe->xnr =
+		(bool)internal_pipe->config.default_capture_config.enable_xnr;
+	internal_pipe->old_pipe->enable_capture_pp = 
+		(bool)internal_pipe->config.default_capture_config.enable_capture_pp;	
+	/* DVS envelope */
+	internal_pipe->old_pipe->dvs_envelope =
+		internal_pipe->config.dvs_envelope;
+	/* YUV downscaling */
+	/*Use config value when dvs_frame_delay setting equal to 2, otherwise always 1 by default */
+	internal_pipe->old_pipe->dvs_frame_delay = 
+		(internal_pipe->config.dvs_frame_delay == IA_CSS_FRAME_DELAY_2) ? 
+		IA_CSS_FRAME_DELAY_2 : IA_CSS_FRAME_DELAY_1;
+		
+	/* YUV downscaling */
+	if (internal_pipe->config.bayer_ds_out_res.width &&
+	    (internal_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW ||
+	     internal_pipe->config.mode == IA_CSS_PIPE_MODE_CAPTURE)) {
+		enum ia_css_frame_format format;
+		if (internal_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+			format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+		else
+			format = IA_CSS_FRAME_FORMAT_YUV420;
+		sh_css_frame_info_init(
+				&internal_pipe->old_pipe->yuv_ds_input_info,
+				internal_pipe->config.bayer_ds_out_res.width,
+				internal_pipe->config.bayer_ds_out_res.height,
+				format, 0);
+	}
+	/* handle output info, asume always needed */
+	if (internal_pipe->config.output_info.res.width) {
+		err = sh_css_pipe_configure_output(
+				internal_pipe->old_pipe,
+				internal_pipe->config.output_info.res.width,
+				internal_pipe->config.output_info.res.height,
+				internal_pipe->config.output_info.format);
+		if (err != IA_CSS_SUCCESS) {
+			sh_css_dtrace(SH_DBG_ERROR, "ia_css_pipe_create: "
+							"invalid output info\n");
+			sh_css_free(internal_pipe);
+			internal_pipe = NULL;
+			return err;
+		}
+	}
+	/* handle vf output info, when configured */
+	internal_pipe->old_pipe->enable_viewfinder = (internal_pipe->config.vf_output_info.res.width != 0);
+	if (internal_pipe->config.vf_output_info.res.width) {
+		err = sh_css_pipe_configure_viewfinder(
+				internal_pipe->old_pipe,
+				internal_pipe->config.vf_output_info.res.width,
+				internal_pipe->config.vf_output_info.res.height,
+				internal_pipe->config.vf_output_info.format);
+		if (err != IA_CSS_SUCCESS) {
+			sh_css_dtrace(SH_DBG_ERROR, "ia_css_pipe_create: "
+							"invalid vf output info\n");
+			sh_css_free(internal_pipe);
+			internal_pipe = NULL;
+			return err;
+		}
+	}
+	internal_pipe->old_pipe->input_needs_raw_binning =
+		internal_pipe->extra_config.enable_raw_binning;
+	internal_pipe->old_pipe->enable_yuv_ds =
+		internal_pipe->extra_config.enable_yuv_ds;
+	internal_pipe->old_pipe->enable_high_speed =
+		internal_pipe->extra_config.enable_high_speed;
+	internal_pipe->old_pipe->enable_dvs_6axis =
+		internal_pipe->extra_config.enable_dvs_6axis;
+	internal_pipe->old_pipe->enable_reduced_pipe =
+		internal_pipe->extra_config.enable_reduced_pipe;
+	internal_pipe->old_pipe->enable_dz =
+		internal_pipe->extra_config.enable_dz;
+	internal_pipe->old_pipe->isp_pipe_version =
+		internal_pipe->config.isp_pipe_version;
+	internal_pipe->old_pipe->disable_vf_pp =
+		internal_pipe->extra_config.disable_vf_pp;
+	internal_pipe->old_pipe->disable_capture_pp =
+		internal_pipe->extra_config.disable_capture_pp;
+	if (internal_pipe->config.acc_extension) {
+		ia_css_pipe_load_extension(internal_pipe,
+			internal_pipe->config.acc_extension);
+	}
+	/* set all info to zeroes first */
+	memset(&internal_pipe->info, 0, sizeof(internal_pipe->info));
+
+	/* all went well, return the pipe */
+	*pipe = internal_pipe;
+	return IA_CSS_SUCCESS;
+}
+
+
+enum ia_css_err
+ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+		     struct ia_css_pipe_info *pipe_info)
+{
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_pipe_get_info()\n");
+	assert(pipe_info != NULL);
+	if (pipe_info == NULL) {
+		sh_css_dtrace(SH_DBG_ERROR,
+			"ia_css_pipe_get_info: pipe_info cannot be NULL\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (pipe->old_pipe->stream == NULL) {
+		sh_css_dtrace(SH_DBG_ERROR,
+			"ia_css_pipe_get_info: ia_css_stream_create needs to"
+			" be called before ia_css_[stream/pipe]_get_info\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	/* we succeeded return the info */
+	*pipe_info = pipe->info;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+ia_css_stream_configure_rx(struct ia_css_stream *stream)
+{
+#if defined(HAS_RX_VERSION_1)
+	struct ia_css_input_port *config = &stream->config.source.port;
+
+	if (config->port == IA_CSS_CSI2_PORT_1LANE)
+		stream->csi_rx_config.port = MIPI_PORT1_ID;
+	else if (config->port == IA_CSS_CSI2_PORT_4LANE)
+		stream->csi_rx_config.port = MIPI_PORT0_ID;
+	else if (config->port == IA_CSS_CSI2_PORT_2LANE)
+		stream->csi_rx_config.port = MIPI_PORT2_ID;
+	else
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	stream->csi_rx_config.num_lanes  = config->num_lanes;
+	stream->csi_rx_config.timeout    = config->timeout;
+	stream->csi_rx_config.uncomp_bpp =
+		config->compression.uncompressed_bits_per_pixel;
+	stream->csi_rx_config.comp_bpp   =
+		config->compression.compressed_bits_per_pixel;
+	if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_NONE)
+		stream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;
+	else if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_1)
+		stream->csi_rx_config.comp = MIPI_PREDICTOR_TYPE1;
+	else if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_2)
+		stream->csi_rx_config.comp = MIPI_PREDICTOR_TYPE2;
+	else
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	stream->csi_rx_config.is_two_ppc = stream->config.two_pixels_per_clock;
+	stream->reconfigure_css_rx = true;
+#elif defined(HAS_RX_VERSION_2)
+	struct ia_css_input_port *config = &stream->config.source.port;
+
+// AM: this code is not reliable, especially for 2400
+	if (config->num_lanes == 1)
+		stream->csi_rx_config.mode = MONO_1L_1L_0L;
+	else if (config->num_lanes == 2)
+		stream->csi_rx_config.mode = STEREO_2L_1L_2L;
+	else if (config->num_lanes == 3)
+		stream->csi_rx_config.mode = MONO_3L_1L_0L;
+	else if (config->num_lanes == 4)
+		stream->csi_rx_config.mode = MONO_4L_1L_0L;
+	else if (config->num_lanes != 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (config->port == IA_CSS_CSI2_PORT_1LANE)
+		stream->csi_rx_config.port = MIPI_PORT1_ID;
+	else if (config->port == IA_CSS_CSI2_PORT_2LANE)
+		stream->csi_rx_config.port = MIPI_PORT2_ID;
+	else if (config->port == IA_CSS_CSI2_PORT_4LANE)
+		stream->csi_rx_config.port = MIPI_PORT0_ID;
+	else
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	stream->csi_rx_config.timeout    = config->timeout;
+	stream->csi_rx_config.initcount  = 0;
+	stream->csi_rx_config.synccount  = 0x28282828;
+	stream->csi_rx_config.rxcount    = 0x04040404;
+	if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_NONE)
+		stream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;
+	else {
+		/* not implemented yet, requires extension of the rx_cfg_t
+		 * struct */
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	stream->csi_rx_config.is_two_ppc = stream->config.two_pixels_per_clock;
+	stream->reconfigure_css_rx = true;
+#else
+	/* No CSS receiver */
+	(void)stream;
+#endif
+	return IA_CSS_SUCCESS;
+}
+
+static struct ia_css_pipe *
+find_pipe(struct ia_css_pipe *pipes[],
+		unsigned int num_pipes,
+		enum ia_css_pipe_mode mode,
+		bool copy_pipe)
+{
+	unsigned i;
+	for (i = 0; i < num_pipes; i++) {
+		if (pipes[i]->config.mode != mode)
+			continue;
+		if (copy_pipe && pipes[i]->old_pipe->mode != IA_CSS_PIPE_ID_COPY)
+			continue;
+		return pipes[i];
+	}
+	return NULL;
+}
+
+static enum ia_css_err
+ia_css_acc_stream_create(struct ia_css_stream *stream)
+{
+	int i;
+	for (i=0; i< stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		pipe->old_pipe->stream = stream;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+					 int num_pipes,
+					 struct ia_css_pipe *pipes[],
+					 struct ia_css_stream **stream)
+{
+	struct ia_css_pipe *curr_pipe;
+	struct ia_css_stream *curr_stream = NULL;
+	bool sensor_binning_changed;
+	int i;
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_stream_create() enter, num_pipes=%d\n", num_pipes);
+	/* some checks */
+	assert(num_pipes != 0);
+	assert(stream != NULL);
+	assert(*stream == NULL);
+	assert(pipes != NULL);
+	/* check if mipi size specified */
+	if (stream_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		if (my_css.size_mem_words == 0) {
+			sh_css_dtrace(SH_DBG_TRACE,
+				"ia_css_stream_create() exit, need to set mipi frame size\n");
+			assert(my_css.size_mem_words != 0);
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
+	}
+	/* allocate the stream instance */
+	curr_stream = sh_css_malloc(sizeof(struct ia_css_stream));
+	if (curr_stream == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	/* default mipi config */
+	memset(curr_stream, 0, sizeof(struct ia_css_stream));
+	/* default mipi config */
+#if defined(HAS_RX_VERSION_2)
+	curr_stream->csi_rx_config.mode = MONO_4L_1L_0L; /* The HW config */
+	curr_stream->csi_rx_config.port = MIPI_PORT0_ID; /* The port ID to apply the control on */
+	curr_stream->csi_rx_config.timeout = 0xffff4;
+	curr_stream->csi_rx_config.initcount = 0;
+	curr_stream->csi_rx_config.synccount = 0x28282828;
+	curr_stream->csi_rx_config.rxcount = 0x04040404;
+	curr_stream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;	/* Just for backward compatibility */
+	curr_stream->csi_rx_config.is_two_ppc = false;
+    curr_stream->reconfigure_css_rx = true;
+#else
+	curr_stream->csi_rx_config = (rx_cfg_t)DEFAULT_MIPI_CONFIG;
+#endif
+	/* allocate pipes */
+	curr_stream->num_pipes = num_pipes;
+	curr_stream->pipes = sh_css_malloc(num_pipes * sizeof(struct ia_css_pipe *));
+	if (curr_stream->pipes == NULL) {
+		sh_css_free(curr_stream);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+	/* store pipes */
+	for (i = 0; i < num_pipes; i++)
+		curr_stream->pipes [i] = pipes[i];
+	curr_stream->last_pipe = curr_stream->pipes[0];
+	/* take over stream config */
+	curr_stream->config = *stream_config;
+	
+	/* copy mode specific stuff */
+	switch (curr_stream->config.mode) {
+		case IA_CSS_INPUT_MODE_SENSOR:
+		case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: mode port\n");
+		/* CSI RX configuration */
+		ia_css_stream_configure_rx(curr_stream);
+		break;
+	case IA_CSS_INPUT_MODE_TPG:
+		sh_css_dtrace(SH_DBG_TRACE,
+			"ia_css_stream_create tpg_configuration: "
+			"x_mask=%d, y_mask=%d, x_delta=%d, "
+			"y_delta=%d, xy_mask=%d\n",
+			curr_stream->config.source.tpg.x_mask,
+			curr_stream->config.source.tpg.y_mask,
+			curr_stream->config.source.tpg.x_delta,
+			curr_stream->config.source.tpg.y_delta,
+			curr_stream->config.source.tpg.xy_mask);
+		sh_css_sp_configure_tpg(
+			curr_stream->config.source.tpg.x_mask,
+			curr_stream->config.source.tpg.y_mask,
+			curr_stream->config.source.tpg.x_delta,
+			curr_stream->config.source.tpg.y_delta,
+			curr_stream->config.source.tpg.xy_mask);
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: mode prbs\n");
+		sh_css_sp_configure_prbs(curr_stream->config.source.prbs.seed);
+		break;
+	default:
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: mode sensor/default\n");
+	}
+	err = ia_css_stream_isp_parameters_init(curr_stream);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: isp_params_configs: %p\n",curr_stream->isp_params_configs);
+
+	if (num_pipes == 1 && pipes[0]->config.mode == IA_CSS_PIPE_MODE_ACC) {
+		*stream = curr_stream;
+		return ia_css_acc_stream_create(curr_stream);
+	}
+	/* sensor binning */
+	sensor_binning_changed =
+		sh_css_params_set_binning_factor(curr_stream, curr_stream->config.sensor_binning_factor);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: sensor_binning=%d, changed=%d\n",
+		curr_stream->config.sensor_binning_factor, sensor_binning_changed);
+	/* loop over pipes */
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: num_pipes=%d\n",
+		num_pipes);
+	curr_stream->cont_capt = false;
+	/* Temporary hack: we give the preview pipe a reference to the capture
+	 * pipe in continuous capture mode. */
+	if (curr_stream->config.continuous && num_pipes >= 2) {
+		/* Search for the preview pipe and create the copy pipe */
+		struct ia_css_pipe *preview_pipe;
+		struct ia_css_pipe *video_pipe;
+		struct ia_css_pipe *capture_pipe;
+		struct ia_css_pipe *copy_pipe;
+
+		curr_stream->cont_capt = true;
+
+		/* Create copy pipe here, since it may not be exposed to the driver */
+		preview_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_PREVIEW, false);
+		video_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_VIDEO, false);
+		capture_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_CAPTURE, false);
+		/* We do not support preview and video pipe at the same time */
+		if (preview_pipe && video_pipe)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+		if (preview_pipe && !preview_pipe->old_pipe->pipe.preview.copy_pipe) {
+			create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+			ia_css_pipe_config_defaults(&copy_pipe->config);
+			preview_pipe->old_pipe->pipe.preview.copy_pipe =
+				copy_pipe->old_pipe;
+			copy_pipe->old_pipe->stream = curr_stream;
+		}
+		if (preview_pipe) {
+		preview_pipe->old_pipe->pipe.preview.capture_pipe =
+			capture_pipe->old_pipe;
+		}
+		if (video_pipe && !video_pipe->old_pipe->pipe.video.copy_pipe) {
+			create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+			ia_css_pipe_config_defaults(&copy_pipe->config);
+			video_pipe->old_pipe->pipe.video.copy_pipe =
+				copy_pipe->old_pipe;
+			copy_pipe->old_pipe->stream = curr_stream;
+		}
+		if (video_pipe) {
+			video_pipe->old_pipe->pipe.video.capture_pipe =
+				capture_pipe->old_pipe;
+		}
+	}
+	for (i = 0; i < num_pipes; i++) {
+		curr_pipe = pipes[i];
+		/* set current stream */
+		curr_pipe->old_pipe->stream = curr_stream;
+		/* take over effective info */
+		sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create: effective_res=%dx%d\n",
+			curr_stream->config.effective_res.width,
+			curr_stream->config.effective_res.height);
+		err = check_res(curr_stream->config.effective_res.width,
+			curr_stream->config.effective_res.height);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		if (curr_stream->info.effective_info.width != curr_stream->config.effective_res.width ||
+			curr_stream->info.effective_info.height != curr_stream->config.effective_res.height) {
+			curr_stream->info.effective_info.width = curr_stream->config.effective_res.width;
+			curr_stream->info.effective_info.height = curr_stream->config.effective_res.height;
+			sh_css_pipe_invalidate_binaries(curr_pipe->old_pipe);
+		}
+		/* sensor binning per pipe */
+		if (sensor_binning_changed)
+			sh_css_pipe_free_shading_table(curr_pipe->old_pipe);
+	}
+	/* now pipes have been configured, info should be available */
+	for (i = 0; i < num_pipes; i++) {
+		struct sh_css_pipe *old_pipe = NULL;
+		struct ia_css_pipe_info *pipe_info = NULL;
+		curr_pipe = pipes[i];
+		/* handle each pipe */
+		old_pipe = curr_pipe->old_pipe;
+		old_pipe->pipe_num = curr_pipe->pipe_num;
+		pipe_info = &curr_pipe->info;
+		sh_css_pipe_get_output_frame_info(old_pipe,
+					&pipe_info->output_info);
+		sh_css_pipe_get_grid_info(old_pipe,
+					&pipe_info->grid_info);
+		sh_css_pipe_get_viewfinder_frame_info(old_pipe,
+					&pipe_info->vf_output_info);
+	}
+	/* stream has been configured, info should be available */
+	{
+		/* use first pipe in list, should be identical anyway */
+		// TODO: should come from stream something
+		struct sh_css_pipe *old_pipe = pipes[0]->old_pipe;
+		struct ia_css_stream_info *stream_info = &curr_stream->info;
+		// TODO: JB implement stream info
+		sh_css_pipe_get_input_resolution(old_pipe,
+			&stream_info->raw_info.width,
+			&stream_info->raw_info.height);
+		
+	}
+
+	/* assign curr_stream */
+	*stream = curr_stream;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_create() leave, err=%d\n",
+			err);
+	return err;
+}
+
+enum ia_css_err
+ia_css_stream_destroy(struct ia_css_stream *stream)
+{
+	int i;
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_destroy: enter\n");
+	assert(stream != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ia_css_stream_isp_parameters_uninit(stream);
+
+	/* remove references from pipes to stream */
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *entry = stream->pipes[i];
+		assert(entry != NULL);
+		if (entry->old_pipe != NULL) {
+			/* clear reference to stream */
+			entry->old_pipe->stream = NULL;
+			/* check internal copy pipe */
+			if (entry->old_pipe->mode == IA_CSS_PIPE_MODE_PREVIEW &&
+			    entry->old_pipe->pipe.preview.copy_pipe) {
+				sh_css_dtrace(SH_DBG_TRACE,
+					"ia_css_stream_destroy: "
+					"clearing stream on internal copy pipe\n");
+				entry->old_pipe->pipe.preview.copy_pipe->stream = NULL;
+			}
+		}
+	}
+	/* free associated memory of stream struct */
+	sh_css_free(stream->pipes);
+	stream->pipes = NULL;
+	stream->num_pipes = 0;
+	sh_css_free(stream);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_destroy: leave\n");
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_get_info(const struct ia_css_stream *stream,
+		       struct ia_css_stream_info *stream_info)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_get_info: enter/exit\n");
+	assert(stream != NULL);
+	assert(stream_info != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (stream_info == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	*stream_info = stream->info;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_load(struct ia_css_stream *stream)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_load() enter/exit\n");
+	assert(stream != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_start(struct ia_css_stream *stream)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_start()\n");
+	assert(stream != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	/* for now simple implementation, just start what seems right */
+	assert(stream->last_pipe != NULL);
+	assert(stream->last_pipe->old_pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_start: starting %d\n",
+		stream->last_pipe->old_pipe->mode);
+	return sh_css_pipe_start(stream);
+}
+
+enum ia_css_err
+ia_css_stream_stop(struct ia_css_stream *stream)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_stop() enter/exit\n");
+	assert(stream != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	/* for now simple implementation, just start what seems right */
+	assert(stream->last_pipe != NULL);
+	assert(stream->last_pipe->old_pipe != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_stop: stopping %d\n",
+		stream->last_pipe->old_pipe->mode);
+
+	// Check if this is the last pipe, if not return else stop everything
+	//if (pipe_num_counter > 1) return IA_CSS_SUCCESS;
+	return sh_css_pipe_request_stop(stream->last_pipe);
+}
+
+bool
+ia_css_stream_has_stopped(struct ia_css_stream *stream)
+{
+	return sh_css_pipe_has_stopped(stream->last_pipe);
+}
+
+enum ia_css_err
+ia_css_stream_unload(struct ia_css_stream *stream)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_unload() enter/exit\n");
+	assert(stream != NULL);
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe, enum ia_css_pipe_id *pipe_id)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_temp_pipe_to_pipe_id() enter/exit\n");
+	if (pipe != NULL && pipe->old_pipe != NULL)
+		*pipe_id = pipe->old_pipe->mode;
+	else
+		*pipe_id = IA_CSS_PIPE_ID_COPY;
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_stream_format
+ia_css_stream_get_format(const struct ia_css_stream *stream)
+{
+	return stream->config.format;
+}
+
+bool
+ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream)
+{
+	return stream->config.two_pixels_per_clock;
+}
+
+struct sh_css_binary *
+ia_css_stream_get_dvs_binary(const struct ia_css_stream *stream)
+{
+	int i;
+	struct ia_css_pipe *video_pipe = NULL;
+
+	/* First we find the video pipe */
+	for (i=0; i<stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		if (pipe->config.mode == IA_CSS_PIPE_MODE_VIDEO) {
+			video_pipe = pipe;
+			break;
+		}
+	}
+	if (video_pipe)
+		return &video_pipe->old_pipe->pipe.video.video_binary;
+	return NULL;
+}
+
+struct sh_css_binary *
+ia_css_stream_get_3a_binary(const struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *pipe = stream->pipes[0];
+
+	if (stream->num_pipes == 2) {
+		if (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||
+		    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+			pipe = stream->pipes[1];
+	}
+
+	return ia_css_pipe_get_3a_binary(pipe);
+}
+
+static struct sh_css_binary *
+ia_css_pipe_get_3a_binary (const struct ia_css_pipe *pipe)
+{
+	struct sh_css_binary *s3a_binary = NULL;
+	switch (pipe->config.mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		s3a_binary = &pipe->old_pipe->pipe.preview.preview_binary;
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		s3a_binary = &pipe->old_pipe->pipe.video.video_binary;
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+		if (pipe->old_pipe->capture_mode == IA_CSS_CAPTURE_MODE_PRIMARY)
+			s3a_binary = &pipe->old_pipe->pipe.capture.primary_binary;
+		else if (pipe->old_pipe->capture_mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
+			 pipe->old_pipe->capture_mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT ||
+			 pipe->old_pipe->capture_mode == IA_CSS_CAPTURE_MODE_BAYER) {
+			if (pipe->config.isp_pipe_version == 1) {
+				s3a_binary 
+				= &pipe->old_pipe->pipe.capture.pre_isp_binary;
+			} else {
+				s3a_binary
+				= &pipe->old_pipe->pipe.capture.pre_anr_binary;
+			}
+			}
+		break;
+	default:
+		break;
+	}
+
+	if (s3a_binary && s3a_binary->info->enable.s3a)
+		return s3a_binary;
+
+	return NULL;
+}
+
+struct sh_css_pipeline *
+ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe)
+{
+	return &pipe->old_pipe->pipeline;
+}
+
+unsigned int
+ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)
+{
+	return pipe->pipe_num;
+}
+
+unsigned int
+ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)
+{
+	return pipe->config.isp_pipe_version;
+}
+
+enum ia_css_err
+ia_css_start_sp(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_start_sp() enter\n");
+	sh_css_sp_start_isp();
+
+	/* waiting for the SP is completely started */
+	while (!ia_css_sp_has_initialized())
+		hrt_sleep();
+
+	//ia_css_stream_manager_create_id(&pipe->pipeline ,&stream_id);
+
+	//ia_css_stream_manager_create(&pipe->pipeline ,stream_id);
+
+	/* Workaround, in order to run two streams in parallel. See TASK 4271*/
+	/* TODO: Fix this. */
+
+	sh_css_init_host_sp_control_vars();
+
+	/* buffers should be initialized only when sp is started */
+	/* AM: At the moment it will be done only when there is no stream active. */
+	sh_css_init_buffer_queues();
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_start_sp() exit\n");
+	return IA_CSS_SUCCESS;
+}
+
+/**
+ *	Time to wait SP for termincate. Only condition when this can happen
+ *	is a fatal hw failure, but we must be able to detect this and emit
+ *	a proper error trace.
+ */
+#define SP_SHUTDOWN_TIMEOUT_US 200000
+
+enum ia_css_err
+ia_css_stop_sp(void)
+{
+	unsigned int i;
+	unsigned long timeout;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_stop_sp() enter\n");
+	/* For now, stop whole SP */
+	sh_css_write_host2sp_command(host2sp_cmd_terminate);
+	sh_css_sp_set_sp_running(false);
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 1\n");
+#endif
+	timeout = SP_SHUTDOWN_TIMEOUT_US;
+	while (!ia_css_sp_has_terminated() && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		sh_css_dump_debug_info("sh_css_stop_sp point1");
+		sh_css_dump_sp_sw_debug_info();
+#ifdef __KERNEL__
+		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
+#endif
+	}
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 2\n");
+#endif
+	while (!isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		sh_css_dump_debug_info("sh_css_stop_sp point2");
+		sh_css_dump_sp_sw_debug_info();
+#ifdef __KERNEL__
+		printk(KERN_ERR "%s poll timeout point 2!!!\n", __func__);
+#endif
+	}
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 3\n");
+#endif
+
+	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+		if (hmm_buffer_record_h[i] != NULL) {
+			ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
+		}
+	}
+
+	/* clear pending param sets from refcount */
+	sh_css_param_clear_param_sets();
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_stop_sp() exit\n");
+	return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_accelerate.c b/drivers/media/atomisp2/css2400/sh_css_accelerate.c
new file mode 100644
index 0000000..f75519e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_accelerate.c
@@ -0,0 +1,257 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "ia_css_accelerate.h"
+
+#include "sh_css_hrt.h"		/* sh_css_hrt_sp_wait() */
+#include "sh_css_sp_start.h"
+#include "sh_css_sp.h"
+#include "sh_css_internal.h"
+
+#include "memory_access.h"
+#include "mmu_device.h"
+
+#define __INLINE_SP__
+#include "sp.h"
+
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+static const unsigned char *
+upload_isp_code(const struct ia_css_fw_info *firmware)
+{
+	const unsigned char *binary = firmware->isp_code;
+	if (!binary) {
+		unsigned size = firmware->blob.size;
+		const unsigned char *blob;
+		const unsigned char *binary_name;
+		binary_name =
+			(const unsigned char *)(IA_CSS_EXT_ISP_PROG_NAME(
+						firmware));
+		blob = binary_name +
+			strlen((const char *)binary_name) +
+			1;
+		binary = (const unsigned char *)HOST_ADDRESS(
+			sh_css_load_blob(blob, size));
+		((struct ia_css_fw_info *)firmware)->isp_code = binary;
+		((struct ia_css_fw_info *)firmware)->info.isp.xmem_addr =
+			(hrt_vaddress)HOST_ADDRESS(binary);
+	}
+
+	if (!binary)
+		return NULL;
+	return binary;
+}
+
+static const unsigned char *
+sh_css_acc_upload_isp_code(const struct ia_css_acc_fw *firmware)
+{
+	struct ia_css_acc_fw_hdr *header
+		= (struct ia_css_acc_fw_hdr *)&firmware->header;
+	const unsigned char *binary = firmware->header.isp_code;
+
+	if (!binary) {
+		const unsigned char *blob = IA_CSS_ACC_ISP_CODE(firmware);
+		unsigned size		  = IA_CSS_ACC_ISP_SIZE(firmware);
+		binary = (const unsigned char *)HOST_ADDRESS(
+			sh_css_load_blob(blob, size));
+		header->isp_code = binary;
+	}
+
+	if (!binary)
+		return NULL;
+	sp_dmem_store(SP0_ID, HOST_ADDRESS(header->sp.isp_code),
+			     &binary, sizeof(binary));
+	return binary;
+}
+#endif
+
+static void
+upload_var(void *sp_address, void *val, size_t size)
+{
+	if (!sp_address)
+		return;
+	sp_dmem_store(SP0_ID, HOST_ADDRESS(sp_address), val, size);
+}
+
+static void
+upload_int(unsigned *sp_address, unsigned *val)
+{
+	upload_var(sp_address, val, sizeof(unsigned));
+}
+
+void
+sh_css_acc_unload(const struct ia_css_acc_fw *firmware)
+{
+	struct ia_css_acc_fw_hdr *header
+		= (struct ia_css_acc_fw_hdr *)&firmware->header;
+	struct ia_css_acc_sp *sp = &header->sp;
+	if (sp->code)
+		mmgr_free(HOST_ADDRESS(sp->code));
+	if (header->isp_code)
+		mmgr_free(HOST_ADDRESS(header->isp_code));
+	sp->code  = NULL;
+	header->isp_code = NULL;
+}
+
+/* Load the firmware into xmem */
+enum ia_css_err
+sh_css_acc_load_extension(const struct ia_css_fw_info *firmware)
+{
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	const unsigned char *isp_program
+			= upload_isp_code(firmware);
+	if (isp_program == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+#endif
+
+	((struct ia_css_fw_info *)firmware)->loaded = true;
+	return IA_CSS_SUCCESS;
+}
+
+void
+sh_css_acc_unload_extension(const struct ia_css_fw_info *firmware)
+{
+	if (firmware->isp_code)
+		mmgr_free(HOST_ADDRESS(firmware->isp_code));
+	((struct ia_css_fw_info *)firmware)->isp_code = NULL;
+	((struct ia_css_fw_info *)firmware)->loaded = false;
+}
+
+/* Set acceleration parameter to value <val> */
+enum ia_css_err
+sh_css_acc_set_parameter(struct ia_css_acc_fw *firmware,
+			 struct ia_css_data parameters)
+{
+	firmware->header.parameters = parameters;
+	return IA_CSS_SUCCESS;
+}
+
+/* Set firmware parameters to value <parameters> */
+enum ia_css_err
+sh_css_acc_set_firmware_parameters(struct ia_css_fw_info *firmware,
+			 enum ia_css_isp_memories mem,
+			 struct ia_css_data parameters)
+{
+	firmware->mem_initializers[mem] = parameters;
+	return IA_CSS_SUCCESS;
+}
+
+static void
+sh_css_acc_init(struct ia_css_acc_fw *firmware)
+{
+	struct ia_css_acc_sp *sp = &firmware->header.sp;
+	unsigned sp_address = (unsigned)HOST_ADDRESS(
+			sp->fw.info.sp.ddr_parameter_address);
+	unsigned sp_size = (unsigned)HOST_ADDRESS(
+			sp->fw.info.sp.ddr_parameter_size);
+	unsigned value = firmware->header.parameters.address;
+	unsigned size  = firmware->header.parameters.size;
+/* MW: "sp_address" is an offset address, 0 is a legal value*/
+	if (sp_address != 0) {
+		sp_dmem_store(SP0_ID, sp_address, &value, sizeof(value));
+		sp_dmem_store(SP0_ID, sp_size, &size, sizeof(size));
+	}
+}
+
+/* Start the sp, which will start the isp.
+*/
+enum ia_css_err
+sh_css_acc_start(struct ia_css_acc_fw *firmware)
+{
+	struct ia_css_acc_fw_hdr *header
+		= (struct ia_css_acc_fw_hdr *)&firmware->header;
+	struct ia_css_acc_sp *sp = &header->sp;
+	bool is_extension = header->type != IA_CSS_ACC_STANDALONE;
+	const struct ia_css_fw_info *sp_fw = &sp->fw;
+	const unsigned char *sp_program;
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	const unsigned char *isp_program;
+#endif
+
+	*(const void **)&sp_fw->blob.code = IA_CSS_ACC_SP_CODE(firmware);
+	*(const void **)&sp_fw->blob.data = IA_CSS_ACC_SP_DATA(firmware);
+
+	if (is_extension)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* NOTE: sp accelerators have their (shared buffer pointer)
+	 * arguments flushed in "atomisp_acc_start()"
+	 */
+	if (is_extension)
+		sh_css_flush(firmware);
+
+	sp_program = (const unsigned char *)HOST_ADDRESS(
+		sh_css_sp_load_program(sp_fw,
+		IA_CSS_ACC_SP_PROG_NAME(firmware),
+		(hrt_vaddress)HOST_ADDRESS(sp->code)));
+	if (sp_program == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	sp->code = sp_program;
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	isp_program = sh_css_acc_upload_isp_code(firmware);
+	if (isp_program == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+#endif
+
+#ifdef C_RUN
+	sp->init(firmware);
+#endif
+	sh_css_acc_init(firmware);
+
+	/* Start the firmware on the sp, which will start the isp */
+#ifdef C_RUN
+	/* No need to run the dmem_init in crun */
+	sh_css_sp_do_invalidate_mmu();
+	csim_processor_set_crun_func(SP, sp->entry);
+	hrt_ctl_run(SP, 1);
+	hrt_ctl_start(SP);
+	hrt_sleep();
+/* MW: sp->entry is a pointer, yet the entry points are relative addresses and thus 32-bit */
+#elif defined(HRT_CSIM)
+	sh_css_sp_do_invalidate_mmu();
+	_hrt_cell_start(SP, HOST_ADDRESS(sp->entry));
+#else
+	sh_css_sp_start((unsigned int)HOST_ADDRESS(sp->entry));
+#endif
+	return IA_CSS_SUCCESS;
+}
+
+/* To be called when acceleration has terminated.
+*/
+void
+sh_css_acc_done(struct ia_css_acc_fw *firmware)
+{
+	(void)firmware;
+}
+
+void
+sh_css_acc_wait(void)
+{
+	sh_css_hrt_sp_wait();
+}
+
+/* Flag abortion of acceleration */
+void sh_css_acc_abort(struct ia_css_acc_fw *firmware)
+{
+	unsigned int t = true;
+	upload_int(firmware->header.sp.css_abort, &t);
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_binary.c b/drivers/media/atomisp2/css2400/sh_css_binary.c
new file mode 100644
index 0000000..0ac7180
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_binary.c
@@ -0,0 +1,857 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include <gdc_device.h>	/* HR_GDC_N */
+
+#include "sh_css_binary.h"
+#include "ia_css.h"
+#include "sh_css_debug.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"
+#include "sh_css_firmware.h"
+#include "sh_css_defs.h"
+#include "sh_css_legacy.h"
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+
+static struct ia_css_binary_info *all_binaries; /* ISP binaries only (no SP) */
+static struct ia_css_binary_info *binary_infos[SH_CSS_BINARY_NUM_MODES] = {NULL, };
+
+void
+sh_css_binary_grid_info(const struct sh_css_binary *binary,
+			struct ia_css_grid_info *info)
+{
+	struct ia_css_3a_grid_info *s3a_info;
+	struct ia_css_dvs_grid_info *dvs_info;
+
+	assert(binary != NULL);
+	assert(info != NULL);
+	s3a_info = &info->s3a_grid;
+	dvs_info = &info->dvs_grid;
+
+	info->isp_in_width = binary->internal_frame_info.res.width;
+	info->isp_in_height = binary->internal_frame_info.res.height;
+
+	/* for DIS, we use a division instead of a ceil_div. If this is smaller
+	 * than the 3a grid size, it indicates that the outer values are not
+	 * valid for DIS.
+	 */
+	dvs_info->enable            = binary->info->enable.dis;
+	dvs_info->width             = binary->dis_hor_grid_num_3a;
+	dvs_info->height            = binary->dis_ver_grid_num_3a;
+	dvs_info->aligned_width     = binary->dis_hor_grid_num_isp;
+	dvs_info->aligned_height    = binary->dis_ver_grid_num_isp;
+	dvs_info->bqs_per_grid_cell = 1 << binary->dis_deci_factor_log2;
+	dvs_info->num_hor_coefs     = binary->dis_hor_coef_num_3a;
+	dvs_info->num_ver_coefs     = binary->dis_ver_coef_num_3a;
+
+	/* 3A statistics grid */
+	s3a_info->enable            = binary->info->enable.s3a;
+	s3a_info->width             = binary->s3atbl_width;
+	s3a_info->height            = binary->s3atbl_height;
+	s3a_info->aligned_width     = binary->s3atbl_isp_width;
+	s3a_info->aligned_height    = binary->s3atbl_isp_height;
+	s3a_info->bqs_per_grid_cell = (1 << binary->deci_factor_log2);
+	s3a_info->deci_factor_log2  = binary->deci_factor_log2;
+	s3a_info->elem_bit_depth    = SH_CSS_BAYER_BITS;
+	s3a_info->use_dmem          = binary->info->s3atbl_use_dmem;
+#if defined(HAS_NO_HMEM)
+	s3a_info->has_histogram     = 1;
+#else
+	s3a_info->has_histogram     = 0;
+#endif
+
+#if defined(HAS_VAMEM_VERSION_2)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
+#elif defined(HAS_VAMEM_VERSION_1)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_1;
+#else
+#error "Unknown VAMEM version"
+#endif
+}
+
+static void
+init_pc_histogram(struct sh_css_pc_histogram *histo)
+{
+assert(histo != NULL);
+
+	histo->length = 0;
+	histo->run = NULL;
+	histo->stall = NULL;
+}
+
+static void
+init_metrics(struct sh_css_binary_metrics *metrics,
+	     const struct ia_css_binary_info *info)
+{
+assert(metrics != NULL);
+assert(info != NULL);
+
+	metrics->mode = info->mode;
+	metrics->id   = info->id;
+	metrics->next = NULL;
+	init_pc_histogram(&metrics->isp_histogram);
+	init_pc_histogram(&metrics->sp_histogram);
+}
+
+static bool
+supports_output_format(const struct ia_css_binary_info *info,
+		       enum ia_css_frame_format format)
+{
+	int i;
+
+assert(info != NULL);
+
+	for (i = 0; i < info->num_output_formats; i++) {
+		if (info->output_formats[i] == format)
+			return true;
+	}
+	return false;
+}
+
+static enum ia_css_err
+init_binary_info(struct ia_css_binary_info *info, unsigned int i,
+		 bool *binary_found)
+{
+	const unsigned char *blob = sh_css_blob_info[i].blob;
+	unsigned size = sh_css_blob_info[i].header.blob.size;
+
+assert(info != NULL);
+assert(binary_found != NULL);
+
+	*info = sh_css_blob_info[i].header.info.isp;
+	*binary_found = blob != NULL;
+	info->blob_index = i;
+	/* we don't have this binary, skip it */
+	if (!size)
+		return IA_CSS_SUCCESS;
+
+	info->xmem_addr = sh_css_load_blob(blob, size);
+	if (!info->xmem_addr)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	return IA_CSS_SUCCESS;
+}
+
+/* When binaries are put at the beginning, they will only
+ * be selected if no other primary matches.
+ */
+enum ia_css_err
+sh_css_init_binary_infos(void)
+{
+	unsigned int i;
+	unsigned int num_of_isp_binaries = sh_css_num_binaries - 1;
+
+	all_binaries = sh_css_malloc(num_of_isp_binaries *
+						sizeof(*all_binaries));
+
+	for (i = 0; i < num_of_isp_binaries; i++) {
+		enum ia_css_err ret;
+		struct ia_css_binary_info *binary = &all_binaries[i];
+		bool binary_found;
+
+		ret = init_binary_info(binary, i, &binary_found);
+		if (ret != IA_CSS_SUCCESS)
+			return ret;
+		if (!binary_found)
+			continue;
+		/* Prepend new binary information */
+		binary->next = binary_infos[binary->mode];
+		binary_infos[binary->mode] = binary;
+		binary->blob = &sh_css_blob_info[i];
+	}
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+sh_css_binary_uninit(void)
+{
+	unsigned int i;
+	struct ia_css_binary_info *b;
+
+	for (i = 0; i < SH_CSS_BINARY_NUM_MODES; i++) {
+		for (b = binary_infos[i]; b; b = b->next) {
+			if (b->xmem_addr)
+				mmgr_free(b->xmem_addr);
+			b->xmem_addr = mmgr_NULL;
+		}
+		binary_infos[i] = NULL;
+	}
+	sh_css_free(all_binaries);
+	return IA_CSS_SUCCESS;
+}
+
+static int
+sh_css_grid_deci_factor_log2(int width, int height)
+{
+	int fact, fact1;
+	fact = 5;
+	while (ISP_BQ_GRID_WIDTH(width, fact - 1) <= SH_CSS_MAX_BQ_GRID_WIDTH &&
+	       ISP_BQ_GRID_HEIGHT(height, fact - 1) <= SH_CSS_MAX_BQ_GRID_HEIGHT
+	       && fact > 3)
+		fact--;
+
+	/* fact1 satisfies the specification of grid size. fact and fact1 is
+	   not the same for some resolution (fact=4 and fact1=5 for 5mp). */
+	if (width >= 2560)
+		fact1 = 5;
+	else if (width >= 1280)
+		fact1 = 4;
+	else
+		fact1 = 3;
+	return max(fact, fact1);
+}
+
+enum ia_css_err
+sh_css_fill_binary_info(const struct ia_css_binary_info *info,
+		 bool online,
+		 bool two_ppc,
+		 enum ia_css_stream_format stream_format,
+		 const struct ia_css_frame_info *in_info, /* can be NULL */
+		 const struct ia_css_frame_info *out_info, /* can be NULL */
+		 const struct ia_css_frame_info *vf_info, /* can be NULL */
+		 struct sh_css_binary *binary,
+		 bool continuous,
+		 struct ia_css_resolution *dvs_env)
+{
+	unsigned int dvs_env_width = 0,
+		     dvs_env_height = 0,
+		     vf_log_ds = 0,
+		     s3a_log_deci = 0,
+		     bits_per_pixel = 0,
+		     ds_input_width = 0,
+		     ds_input_height = 0,
+		     isp_input_width,
+		     isp_input_height,
+		     isp_internal_width,
+		     isp_internal_height,
+		     isp_output_width = 0,
+		     isp_output_height = 0,
+		     s3a_isp_width;
+	unsigned char enable_ds = info->enable.ds;
+	bool enable_yuv_ds = enable_ds & 2;
+	bool enable_hus = false;
+	bool enable_vus = false;
+	bool is_out_format_rgba888 = false;
+	unsigned int tmp_width, tmp_height;
+
+assert(info != NULL);
+assert(binary != NULL);
+
+	if (in_info != NULL) {
+		bits_per_pixel = in_info->raw_bit_depth;
+		if (out_info != NULL) {
+			enable_hus = in_info->res.width < out_info->res.width;
+			enable_vus = in_info->res.height < out_info->res.height;
+		}
+	}
+	if (out_info != NULL) {
+		isp_output_width  = out_info->padded_width;
+		isp_output_height = out_info->res.height;
+		is_out_format_rgba888 =
+			out_info->format == IA_CSS_FRAME_FORMAT_RGBA888;
+	}
+	if (info->enable.dvs_envelope) {
+		assert(dvs_env);
+		dvs_env_width  = max(dvs_env->width, SH_CSS_MIN_DVS_ENVELOPE);
+		dvs_env_height = max(dvs_env->height, SH_CSS_MIN_DVS_ENVELOPE);
+	}
+	binary->dvs_envelope.width  = dvs_env_width;
+	binary->dvs_envelope.height = dvs_env_height;
+	if (vf_info != NULL) {
+		enum ia_css_err err;
+		err = sh_css_vf_downscale_log2(out_info, vf_info, &vf_log_ds);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		vf_log_ds = min(vf_log_ds, info->max_vf_log_downscale);
+	}
+	if (online) {
+		bits_per_pixel = sh_css_input_format_bits_per_pixel(
+			stream_format, two_ppc);
+	}
+	if (in_info != NULL) {
+		ds_input_width  = in_info->padded_width + info->left_cropping;
+		ds_input_height = in_info->res.height + info->top_cropping;
+	}
+	if (enable_hus) /* { */
+		ds_input_width  += dvs_env_width;
+	/* } */
+	if (enable_vus) /* { */
+		ds_input_height += dvs_env_height;
+	/* } */
+	tmp_width  = (enable_yuv_ds && (ds_input_width > isp_output_width)) ?
+			ds_input_width  : isp_output_width;
+	tmp_height = (enable_yuv_ds && (ds_input_height > isp_output_height)) ?
+			ds_input_height : isp_output_height;
+
+	/* We first calculate the resolutions used by the ISP. After that,
+	 * we use those resolutions to compute sizes for tables etc. */
+	isp_internal_width = __ISP_INTERNAL_WIDTH(tmp_width,
+		dvs_env_width,
+		info->left_cropping, info->mode,
+		info->c_subsampling,
+		info->output_num_chunks, info->pipelining,
+		is_out_format_rgba888);
+	isp_internal_height = __ISP_INTERNAL_HEIGHT(tmp_height,
+		info->top_cropping,
+		dvs_env_height);
+	isp_input_width = _ISP_INPUT_WIDTH(isp_internal_width,
+		ds_input_width,
+		enable_ds || enable_hus);
+	isp_input_height = _ISP_INPUT_HEIGHT(isp_internal_height,
+		ds_input_height,
+		enable_ds || enable_vus);
+	s3a_isp_width = _ISP_S3A_ELEMS_ISP_WIDTH(isp_input_width,
+		isp_internal_width, enable_hus || enable_yuv_ds,
+		info->left_cropping);
+	if (info->fixed_s3a_deci_log) {
+/* */
+		s3a_log_deci = info->fixed_s3a_deci_log;
+	}
+	else {
+/* */
+		s3a_log_deci = sh_css_grid_deci_factor_log2(s3a_isp_width,
+							    isp_input_height);
+	}
+
+	binary->vf_downscale_log2 = vf_log_ds;
+	binary->deci_factor_log2  = s3a_log_deci;
+	binary->input_buf_vectors =
+			SH_CSS_NUM_INPUT_BUF_LINES * _ISP_VECS(isp_input_width);
+	binary->online            = online;
+	binary->input_format      = stream_format;
+	/* input info */
+	if (in_info != NULL) {
+		binary->in_frame_info.format = in_info->format;
+		binary->in_frame_info.res.width = in_info->res.width +
+			info->left_cropping + dvs_env_width;
+	}
+	binary->in_frame_info.padded_width  = isp_input_width;
+	binary->in_frame_info.res.height    = isp_input_height;
+	binary->in_frame_info.raw_bit_depth = bits_per_pixel;
+	/* internal frame info */
+	if (out_info != NULL) /* { */
+		binary->internal_frame_info.format          = out_info->format;
+	/* } */
+	binary->internal_frame_info.res.width       = isp_internal_width;
+	binary->internal_frame_info.padded_width    = isp_internal_width;
+	binary->internal_frame_info.res.height      = isp_internal_height;
+	binary->internal_frame_info.raw_bit_depth   = bits_per_pixel;
+	/* output info */
+	if (out_info != NULL) {
+		binary->out_frame_info.format        = out_info->format;
+		binary->out_frame_info.res.width     = out_info->res.width;
+	}
+	binary->out_frame_info.padded_width  = isp_output_width;
+	binary->out_frame_info.res.height    = isp_output_height;
+	binary->out_frame_info.raw_bit_depth = bits_per_pixel;
+
+	/* viewfinder output info */
+	binary->vf_frame_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+	if (vf_info != NULL) {
+		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
+		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(isp_output_width,
+			vf_log_ds);
+		vf_out_width = _ISP_VF_OUTPUT_WIDTH(vf_out_vecs);
+		vf_out_height = _ISP_VF_OUTPUT_HEIGHT(isp_output_height,
+			vf_log_ds);
+		/* If we are in continuous preview mode, then out port is
+		 * active instead of vfout port
+		 */
+		if (info->enable.raw_binning && continuous) {
+			binary->out_frame_info.res.width =
+				(in_info->res.width >> vf_log_ds);
+			binary->out_frame_info.padded_width = vf_out_width;
+			binary->out_frame_info.res.height   = vf_out_height;
+		} else {
+		/* we also store the raw downscaled width. This is used for
+		 * digital zoom in preview to zoom only on the width that
+		 * we actually want to keep, not on the aligned width. */
+			if (out_info == NULL) 
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			binary->vf_frame_info.res.width =
+				(out_info->res.width >> vf_log_ds);
+			binary->vf_frame_info.padded_width = vf_out_width;
+			binary->vf_frame_info.res.height   = vf_out_height;
+		}
+	} else {
+		binary->vf_frame_info.res.width    = 0;
+		binary->vf_frame_info.padded_width = 0;
+		binary->vf_frame_info.res.height   = 0;
+	}
+
+	if (info->enable.ca_gdc) {
+		binary->morph_tbl_width =
+			_ISP_MORPH_TABLE_WIDTH(isp_internal_width);
+		binary->morph_tbl_aligned_width  =
+			_ISP_MORPH_TABLE_ALIGNED_WIDTH(isp_internal_width);
+		binary->morph_tbl_height =
+			_ISP_MORPH_TABLE_HEIGHT(isp_internal_height);
+	} else {
+		binary->morph_tbl_width  = 0;
+		binary->morph_tbl_aligned_width  = 0;
+		binary->morph_tbl_height = 0;
+	}
+	if (info->enable.sc)
+		binary->sctbl_width_per_color =
+			SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR;
+	else
+		binary->sctbl_width_per_color = 0;
+
+	if (info->enable.s3a) {
+		binary->s3atbl_width  =
+			_ISP_S3ATBL_WIDTH(binary->in_frame_info.res.width,
+				s3a_log_deci);
+		binary->s3atbl_height =
+			_ISP_S3ATBL_HEIGHT(binary->in_frame_info.res.height,
+				s3a_log_deci);
+		binary->s3atbl_isp_width =
+			_ISP_S3ATBL_ISP_WIDTH(
+				_ISP_S3A_ELEMS_ISP_WIDTH(isp_input_width,
+					isp_internal_width,
+					enable_hus || enable_yuv_ds,
+					info->left_cropping),
+					s3a_log_deci);
+		binary->s3atbl_isp_height =
+			_ISP_S3ATBL_ISP_HEIGHT(
+				_ISP_S3A_ELEMS_ISP_HEIGHT(isp_input_height,
+				isp_internal_height,
+				enable_vus || enable_yuv_ds),
+				s3a_log_deci);
+	} else {
+		binary->s3atbl_width  = 0;
+		binary->s3atbl_height = 0;
+		binary->s3atbl_isp_width  = 0;
+		binary->s3atbl_isp_height = 0;
+	}
+
+	if (info->enable.sc) {
+		binary->sctbl_width_per_color  =
+			_ISP_SCTBL_WIDTH_PER_COLOR(isp_input_width,
+				s3a_log_deci);
+		binary->sctbl_aligned_width_per_color =
+			SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR;
+		binary->sctbl_height =
+			_ISP_SCTBL_HEIGHT(isp_input_height, s3a_log_deci);
+	} else {
+		binary->sctbl_width_per_color         = 0;
+		binary->sctbl_aligned_width_per_color = 0;
+		binary->sctbl_height                  = 0;
+	}
+	if (info->enable.dis) {
+		binary->dis_deci_factor_log2 = SH_CSS_DIS_DECI_FACTOR_LOG2;
+
+		binary->dis_hor_grid_num_3a  =
+			_ISP_SDIS_HOR_GRID_NUM_3A(binary->in_frame_info.res.width,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_grid_num_3a  =
+			_ISP_SDIS_VER_GRID_NUM_3A(binary->in_frame_info.res.height,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_hor_grid_num_isp =
+			_ISP_SDIS_HOR_GRID_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_width,
+				isp_internal_width,
+				enable_hus || enable_yuv_ds),
+						SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_grid_num_isp =
+			_ISP_SDIS_VER_GRID_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_height,
+				isp_internal_height,
+				enable_vus || enable_yuv_ds),
+						SH_CSS_DIS_DECI_FACTOR_LOG2);
+
+		binary->dis_hor_coef_num_3a  =
+			_ISP_SDIS_HOR_COEF_NUM_3A(binary->in_frame_info.res.width,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_coef_num_3a  =
+			_ISP_SDIS_VER_COEF_NUM_3A(binary->in_frame_info.res.height,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_hor_coef_num_isp =
+			_ISP_SDIS_HOR_COEF_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_width,
+				isp_internal_width,
+				enable_hus || enable_yuv_ds));
+		binary->dis_ver_coef_num_isp =
+			_ISP_SDIS_VER_COEF_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_height,
+				isp_internal_height,
+				enable_vus || enable_yuv_ds));
+		binary->dis_hor_proj_num_3a  =
+			_ISP_SDIS_HOR_PROJ_NUM_3A(
+				binary->in_frame_info.res.width,
+				binary->in_frame_info.res.height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_ver_proj_num_3a  =
+			_ISP_SDIS_VER_PROJ_NUM_3A(
+				binary->in_frame_info.res.width,
+				binary->in_frame_info.res.height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_hor_proj_num_isp =
+			__ISP_SDIS_HOR_PROJ_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_width,
+				isp_internal_width,
+				enable_hus || enable_yuv_ds),
+				_ISP_SDIS_ELEMS_ISP(isp_input_height,
+				isp_internal_height,
+				enable_vus || enable_yuv_ds),
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_ver_proj_num_isp =
+			__ISP_SDIS_VER_PROJ_NUM_ISP(
+				_ISP_SDIS_ELEMS_ISP(isp_input_width,
+				isp_internal_width,
+				enable_hus || enable_yuv_ds),
+				_ISP_SDIS_ELEMS_ISP(isp_input_height,
+				isp_internal_height,
+				enable_vus || enable_yuv_ds),
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+	} else {
+		binary->dis_deci_factor_log2 = 0;
+		binary->dis_hor_coef_num_3a  = 0;
+		binary->dis_ver_coef_num_3a  = 0;
+		binary->dis_hor_coef_num_isp = 0;
+		binary->dis_ver_coef_num_isp = 0;
+		binary->dis_hor_proj_num_3a  = 0;
+		binary->dis_ver_proj_num_3a  = 0;
+		binary->dis_hor_proj_num_isp = 0;
+		binary->dis_ver_proj_num_isp = 0;
+	}
+	if (info->left_cropping)
+		binary->left_padding = 2 * ISP_VEC_NELEMS - info->left_cropping;
+	else
+		binary->left_padding = 0;
+
+	binary->info = info;
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+sh_css_binary_find(struct sh_css_binary_descr *descr,
+		   struct sh_css_binary *binary)
+{
+	int mode = descr->mode;
+	bool online = descr->online;
+	bool two_ppc = descr->two_ppc;
+	enum ia_css_stream_format stream_format = descr->stream_format;
+	const struct ia_css_frame_info *req_in_info = descr->in_info,
+				       *req_out_info = descr->out_info,
+				       *req_vf_info = descr->vf_info;
+
+	struct ia_css_frame_info *cc_in_info
+				= sh_css_malloc(sizeof(*req_in_info));
+	struct ia_css_frame_info *cc_out_info
+				= sh_css_malloc(sizeof(*req_out_info));
+	struct ia_css_frame_info *cc_vf_info
+				= sh_css_malloc(sizeof(*req_vf_info));
+
+	struct ia_css_binary_info *candidate;
+	bool need_ds = false,
+	     need_dz = false,
+	     need_dvs = false,
+	     need_outputdeci = false;
+	bool enable_yuv_ds = descr->enable_yuv_ds;
+	bool enable_high_speed = descr->enable_high_speed;
+	bool enable_dvs_6axis  = descr->enable_dvs_6axis;
+	bool enable_reduced_pipe = descr->enable_reduced_pipe;
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	bool continuous = descr->continuous;
+	unsigned int isp_pipe_version = descr->isp_pipe_version;
+	struct ia_css_resolution dvs_env;
+
+	dvs_env.width = 0;
+	dvs_env.height = 0;
+
+assert(descr != NULL);
+/* MW: used after an error check, may accept NULL, but doubtfull */
+assert(binary != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() enter: "
+		"descr=%p, (mode=%d), "
+		"binary=%p\n",
+		descr, descr->mode,
+		binary);
+
+
+	if (cc_in_info == NULL || cc_out_info == NULL || cc_vf_info == NULL) {
+		sh_css_free(cc_in_info);
+		sh_css_free(cc_out_info);
+		sh_css_free(cc_vf_info);
+		return err;
+	}
+
+	if (mode == SH_CSS_BINARY_MODE_VIDEO) {
+		dvs_env = descr->dvs_env;
+		need_dz = descr->enable_dz;
+		/* Video is the only mode that has a nodz variant. */
+		need_dvs = dvs_env.width || dvs_env.height;
+	}
+
+	need_ds = req_in_info->res.width > req_out_info->res.width ||
+		  req_in_info->res.height > req_out_info->res.height;
+
+	/* In continuous mode, ds is not possible. Instead we are
+	 * allowed to have output decimation (vf_veceven) */
+	if (need_ds && continuous) {
+		need_ds = false;
+		need_outputdeci = true;
+	}
+//printf("sh_css_binary_find: pipe version %d\n", isp_pipe_version);
+	for (candidate = binary_infos[mode]; candidate;
+	     candidate = candidate->next) {
+	  //printf("sh_css_binary_find: evaluating candidate: %d\n",candidate->id);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() candidate = %p, mode = %d ID = %d\n",candidate, candidate->mode, candidate->id);
+
+/* 
+ * MW: Only a limited set of jointly configured binaries can be used in a continuous preview/video mode
+ * unless it is the copy mode and copy runs on SP
+ */
+		if (!candidate->enable.continuous && continuous && (mode != SH_CSS_BINARY_MODE_COPY)) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d && (%d != %d)\n", __LINE__, candidate->enable.continuous, continuous, mode, SH_CSS_BINARY_MODE_COPY);
+			continue;
+		}
+
+		if (candidate->isp_pipe_version != isp_pipe_version && (mode != SH_CSS_BINARY_MODE_COPY) && (mode != SH_CSS_BINARY_MODE_CAPTURE_PP) && (mode != SH_CSS_BINARY_MODE_VF_PP)) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d != %d)\n", __LINE__,
+			candidate->isp_pipe_version, isp_pipe_version);
+			continue;
+		}
+		if (!candidate->enable.reduced_pipe && enable_reduced_pipe) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.reduced_pipe, enable_reduced_pipe);
+			continue;
+		}
+		if (!candidate->enable.dvs_6axis && enable_dvs_6axis) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.dvs_6axis, enable_dvs_6axis);
+			continue;
+		}
+		if (candidate->enable.high_speed && !enable_high_speed) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: %d && !%d\n", __LINE__, candidate->enable.high_speed, enable_high_speed);
+			continue;
+		}
+		if (!(candidate->enable.ds & 2) && enable_yuv_ds) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
+			continue;
+		}
+		if ((candidate->enable.ds & 2) && !enable_yuv_ds) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: %d && !%d\n", __LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
+			continue;
+		}
+
+		if (mode == SH_CSS_BINARY_MODE_VIDEO &&
+		    candidate->enable.ds && need_ds)
+			need_dz = false;
+#if 0
+		if (mode != SH_CSS_BINARY_MODE_PREVIEW &&
+		    mode != SH_CSS_BINARY_MODE_COPY &&
+		    candidate->enable.vf_veceven && (req_vf_info == NULL)) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d != %d) && (%d != %d) && %d && (%p == NULL)\n", __LINE__,
+			mode, SH_CSS_BINARY_MODE_PREVIEW, mode, SH_CSS_BINARY_MODE_COPY,
+			candidate->enable.vf_veceven, req_vf_info);
+			continue;
+		}
+#endif
+		if ((req_vf_info != NULL) && !(candidate->enable.vf_veceven ||   // when we require vf output, we need to have vf_veceven 
+				                 candidate->variable_vf_veceven || // or variable vf vec even
+				candidate->num_output_pins > 1)) { // or more than one output pin.
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%p != NULL) && !(%d || %d || (%d >%d))\n", __LINE__, req_vf_info, candidate->enable.vf_veceven, candidate->variable_vf_veceven,candidate->num_output_pins, 1);
+			continue;
+		}
+		if (!candidate->enable.dvs_envelope && need_dvs) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.dvs_envelope, (int)need_dvs);
+			continue;
+		}
+		if (dvs_env.width > candidate->max_dvs_envelope_width) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, dvs_env.width, candidate->max_dvs_envelope_width);
+			continue;
+		}
+		if (dvs_env.height > candidate->max_dvs_envelope_height) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, dvs_env.height, candidate->max_dvs_envelope_height);
+			continue;
+		}
+		if (!candidate->enable.ds && need_ds) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.ds, (int)need_ds);
+			continue;
+		}
+		if (!candidate->enable.uds && need_dz) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.uds, (int)need_dz);
+			continue;
+		}
+		if (online && candidate->input == SH_CSS_BINARY_INPUT_MEMORY) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: %d && (%d == %d)\n", __LINE__, online, candidate->input, SH_CSS_BINARY_INPUT_MEMORY);
+			continue;
+		}
+		if (!online && candidate->input == SH_CSS_BINARY_INPUT_SENSOR) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && (%d == %d)\n", __LINE__, online, candidate->input, SH_CSS_BINARY_INPUT_SENSOR);
+			continue;
+		}
+		if (req_out_info->padded_width < candidate->min_output_width ||
+		    req_out_info->padded_width > candidate->max_output_width) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d > %d) || (%d < %d)\n", __LINE__,
+			req_out_info->padded_width, candidate->min_output_width,
+			req_out_info->padded_width, candidate->max_output_width);
+			continue;
+		}
+
+		if (req_in_info->padded_width > candidate->max_input_width) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, req_in_info->padded_width, candidate->max_input_width);
+			continue;
+		}
+		if (!supports_output_format(candidate, req_out_info->format)) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d\n", __LINE__, supports_output_format(candidate, req_out_info->format));
+			continue;
+		}
+
+		if (candidate->num_output_pins > 1 && // in case we have a second output pin,
+		     req_vf_info                   && // and we need vf output.
+		      !supports_output_format(candidate, req_vf_info->format)) { // check if the required vf format is supported.
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: (%d > %d) && (%p != NULL) && !%d\n", __LINE__, candidate->num_output_pins, 1, req_vf_info, supports_output_format(candidate, req_vf_info->format));
+			continue;
+		}
+
+/*
+ * Select either a binary with conditional decimation or one with fixed decimation
+ */
+		if (descr->binning && !(candidate->enable.raw_binning || candidate->enable.fixed_bayer_ds)) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: %d && !(%d || %d)\n", __LINE__, descr->binning, candidate->enable.raw_binning, candidate->enable.fixed_bayer_ds);
+			continue;
+		}
+/*
+ * "candidate->enable.fixed_bayer_ds" is also used to get the correct buffer size reservation in the still capture and capture_pp binaries
+ */
+		if (!descr->binning && candidate->enable.fixed_bayer_ds && ((mode == SH_CSS_BINARY_MODE_PREVIEW) || (mode == SH_CSS_BINARY_MODE_VIDEO))) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && %d && ((%d == %d) || (%d == %d))\n", __LINE__,
+		descr->binning, candidate->enable.fixed_bayer_ds, mode, SH_CSS_BINARY_MODE_PREVIEW, mode, SH_CSS_BINARY_MODE_VIDEO);
+			continue;
+		}
+
+		if (descr->binning) { // This code needs to be fixed CR2298; for now exclude this code for isp pipe version 2
+			/* Only use decimation above a certain limit */
+			unsigned in_width_limit = 3264; /* Decimation for 8Mp and up */
+			if (!candidate->enable.fixed_bayer_ds && req_in_info->res.width >= in_width_limit) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: !%d && (%d > %d)\n", __LINE__, candidate->enable.fixed_bayer_ds,req_in_info->res.width, 3264);
+				continue;
+			}
+			if (candidate->enable.fixed_bayer_ds && req_in_info->res.width < in_width_limit) {
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() [%d] continue: %d && (%d <= %d)\n", __LINE__, candidate->enable.fixed_bayer_ds,req_in_info->res.width, 3264);
+				continue;
+			}
+		}
+
+		/* If we are in continuous preview mode, it is possible to have
+		 * an output decimation. If output decimation is needed, the
+		 * decimation factor is calculated output->vf. So, we switch
+		 * the ports to share the same calculation module */
+		if (candidate->enable.raw_binning
+				&& continuous && need_outputdeci) {
+			*cc_in_info = *req_in_info;
+			*cc_out_info = *req_out_info;
+			*cc_vf_info = *req_out_info;
+
+		if (descr->binning) {
+			/* Take into account that we have (currently implicit)
+			 * a decimation on preview-ISP which halves the
+			 * resolution. Therefore, here we specify this. */
+			cc_out_info->res.width    = req_in_info->res.width/2;
+			cc_out_info->padded_width = req_in_info->padded_width/2;
+			cc_out_info->res.height   = req_in_info->res.height/2;
+
+			cc_in_info->res.width    = req_in_info->res.width/2;
+			cc_in_info->padded_width = req_in_info->padded_width/2;
+			cc_in_info->res.height   = req_in_info->res.height/2;
+		} else {
+			cc_out_info->res.width    = req_in_info->res.width;
+			cc_out_info->padded_width = req_in_info->padded_width;
+			cc_out_info->res.height   = req_in_info->res.height;
+		}
+		} else {
+			*cc_in_info  = *req_in_info;
+			*cc_out_info = *req_out_info;
+			if (req_vf_info != NULL) {
+				*cc_vf_info  = *req_vf_info;
+			} else {
+				sh_css_free(cc_vf_info);
+				cc_vf_info  = NULL;
+			}
+		}
+
+		/* reconfigure any variable properties of the binary */
+		err = sh_css_fill_binary_info(candidate, online, two_ppc,
+				       stream_format, cc_in_info,
+				       cc_out_info, cc_vf_info,
+				       binary, continuous, &dvs_env);
+		if (err)
+			break;
+		init_metrics(&binary->metrics, binary->info);
+		break;
+	}
+/* MW: In case we haven't found a binary and hence the binary_info is uninitialised */
+assert(candidate != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() selected = %p, mode = %d ID = %d\n",candidate, candidate->mode, candidate->id);
+
+	sh_css_free(cc_in_info);
+	sh_css_free(cc_out_info);
+	sh_css_free(cc_vf_info);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_binary_find() leave: return_err=%d\n", err);
+
+	return err;
+}
+
+unsigned
+sh_css_max_vf_width(void)
+{
+  return binary_infos[SH_CSS_BINARY_MODE_VF_PP]->max_output_width;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_binary.h b/drivers/media/atomisp2/css2400/sh_css_binary.h
new file mode 100644
index 0000000..253ee3d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_binary.h
@@ -0,0 +1,194 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_BINARY_H_
+#define _SH_CSS_BINARY_H_
+
+/* The binary mode is used in pre-processor expressions so we cannot
+ * use an enum here. */
+#define SH_CSS_BINARY_MODE_COPY       0
+#define SH_CSS_BINARY_MODE_PREVIEW    1
+#define SH_CSS_BINARY_MODE_PRIMARY    2
+#define SH_CSS_BINARY_MODE_VIDEO      3
+#define SH_CSS_BINARY_MODE_PRE_ISP    4
+#define SH_CSS_BINARY_MODE_GDC        5
+#define SH_CSS_BINARY_MODE_POST_ISP   6
+#define SH_CSS_BINARY_MODE_PRE_ANR    7
+#define SH_CSS_BINARY_MODE_ANR        8
+#define SH_CSS_BINARY_MODE_POST_ANR   9
+#define SH_CSS_BINARY_MODE_CAPTURE_PP 10
+#define SH_CSS_BINARY_MODE_VF_PP      11 
+#define SH_CSS_BINARY_NUM_MODES       12
+
+/* Indicate where binaries can read input from */
+#define SH_CSS_BINARY_INPUT_SENSOR   0
+#define SH_CSS_BINARY_INPUT_MEMORY   1
+#define SH_CSS_BINARY_INPUT_VARIABLE 2
+
+#include "ia_css.h"
+#include "sh_css_metrics.h"
+
+struct sh_css_binary_descr {
+	int mode;
+	bool online;
+	bool continuous;
+	bool binning;
+	bool two_ppc;
+	bool enable_yuv_ds;
+	bool enable_high_speed;
+	bool enable_dvs_6axis;
+	bool enable_reduced_pipe;
+	bool enable_dz;
+	struct ia_css_resolution dvs_env;
+	enum ia_css_stream_format stream_format;
+	struct ia_css_frame_info *in_info;
+	struct ia_css_frame_info *out_info;
+	struct ia_css_frame_info *vf_info;
+	unsigned int isp_pipe_version;
+};
+
+struct sh_css_binary {
+	const struct ia_css_binary_info *info;
+	enum ia_css_stream_format input_format;
+	struct ia_css_frame_info in_frame_info;
+	struct ia_css_frame_info internal_frame_info;
+	struct ia_css_frame_info out_frame_info;
+	struct ia_css_frame_info vf_frame_info;
+	int                      input_buf_vectors;
+	int                      deci_factor_log2;
+	int                      dis_deci_factor_log2;
+	int                      vf_downscale_log2;
+	int                      s3atbl_width;
+	int                      s3atbl_height;
+	int                      s3atbl_isp_width;
+	int                      s3atbl_isp_height;
+	unsigned int             morph_tbl_width;
+	unsigned int             morph_tbl_aligned_width;
+	unsigned int             morph_tbl_height;
+	int                      sctbl_width_per_color;
+	int                      sctbl_aligned_width_per_color;
+	int                      sctbl_height;
+	int                      dis_hor_grid_num_3a;
+	int                      dis_ver_grid_num_3a;
+	int                      dis_hor_grid_num_isp;
+	int                      dis_ver_grid_num_isp;
+	int                      dis_hor_coef_num_3a;
+	int                      dis_ver_coef_num_3a;
+	int                      dis_hor_coef_num_isp;
+	int                      dis_ver_coef_num_isp;
+	int                      dis_hor_proj_num_3a;
+	int                      dis_ver_proj_num_3a;
+	int                      dis_hor_proj_num_isp;
+	int                      dis_ver_proj_num_isp;
+	struct ia_css_resolution dvs_envelope;
+	bool                     online;
+	unsigned int             uds_xc;
+	unsigned int             uds_yc;
+	unsigned int             left_padding;
+	struct sh_css_binary_metrics metrics;
+};
+
+#define DEFAULT_FRAME_INFO \
+{ \
+	{0,                      /* width */ \
+	 0},                     /* height */ \
+	0,                       /* padded_width */ \
+	IA_CSS_FRAME_FORMAT_NUM, /* format */ \
+	0,                       /* raw_bit_depth */ \
+	IA_CSS_BAYER_ORDER_NUM   /* raw_bayer_order */ \
+}
+
+#define DEFAULT_BINARY_SETTINGS \
+{ \
+	NULL, \
+	IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY, \
+	DEFAULT_FRAME_INFO, \
+	DEFAULT_FRAME_INFO, \
+	DEFAULT_FRAME_INFO, \
+	DEFAULT_FRAME_INFO, \
+	0,	/* input_buf_vectors */  		\
+	0,	/* deci_factor_log2 */  		\
+	0,	/* dis_deci_factor_log2 */  		\
+	0,	/* vf_downscale_log2 */ 		\
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	0, \
+	{ 0,0 },		/* dvs_envelope_info */			\
+	false,			/* online */				\
+	0, 			/* uds_xc */				\
+	0, 			/* uds_yc */				\
+	0, 			/* left_padding */			\
+	DEFAULT_BINARY_METRICS	/* metrics */				\
+}
+
+enum ia_css_err
+sh_css_init_binary_infos(void);
+
+enum ia_css_err
+sh_css_binary_uninit(void);
+
+enum ia_css_err
+sh_css_fill_binary_info(const struct ia_css_binary_info *info,
+		 bool online,
+		 bool two_ppc,
+		 enum ia_css_stream_format stream_format,
+		 const struct ia_css_frame_info *in_info,
+		 const struct ia_css_frame_info *out_info,
+		 const struct ia_css_frame_info *vf_info,
+		 struct sh_css_binary *binary,
+		 bool continuous,
+		 struct ia_css_resolution *dvs_env);
+
+enum ia_css_err
+sh_css_binary_find(struct sh_css_binary_descr *descr,
+		   struct sh_css_binary *binary);
+
+void
+sh_css_binary_grid_info(const struct sh_css_binary *binary,
+			struct ia_css_grid_info *info);
+
+unsigned
+sh_css_max_vf_width(void);
+
+void sh_css_binary_init(struct sh_css_binary *binary);
+
+#endif /* _SH_CSS_BINARY_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_debug.c b/drivers/media/atomisp2/css2400/sh_css_debug.c
new file mode 100644
index 0000000..1ef0e66
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_debug.c
@@ -0,0 +1,2452 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+#include "debug.h"
+#include "memory_access.h"
+
+#include "sh_css_debug.h"
+#include "sh_css_debug_internal.h"
+#include "ia_css_stream.h"
+
+#include "assert_support.h"
+#include "print_support.h"
+#if !defined(__KERNEL__) && !defined(_MSC_VER)
+#include <stdio.h>	/* snprintf() */
+#endif
+
+#include "fifo_monitor.h"
+#include "input_formatter.h"
+#include "dma.h"
+#include "irq.h"
+#include "gp_device.h"
+#include "sp.h"
+#include "isp.h"
+#include "mmu_device.h"
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+#include "input_system.h"	/* input_formatter_reg_load */
+#include "gp_device.h"		/* gp_device_reg_load */
+#endif
+
+#include "ia_css.h"
+#include "sh_css_internal.h"
+#include "sh_css_rx.h"
+#include "sh_css_sp.h"	/* sh_css_sp_get_debug_state() */
+
+/* snprintf is a C99 feature, MS visual studio defines _snprintf */
+#if defined(_MSC_VER)
+#define snprintf _snprintf
+#endif
+
+/* Global variable to store the dtrace verbosity level */
+unsigned int sh_css_trace_level;
+
+void sh_css_set_dtrace_level(
+	const unsigned int	trace_level)
+{
+	sh_css_trace_level = trace_level;
+return;
+}
+
+static void print_sp_state(
+	const sp_state_t	*state,
+	const char			*cell)
+{
+	sh_css_dtrace(2, "%s state:\n", cell);
+	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
+	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
+			state->status_register);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is sleeping", state->is_sleeping);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is stalling", state->is_stalling);
+return;
+}
+
+static void print_isp_state(
+	const isp_state_t	*state,
+	const char			*cell)
+{
+	sh_css_dtrace(2, "%s state:\n", cell);
+	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
+	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
+			state->status_register);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is sleeping", state->is_sleeping);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "Is stalling", state->is_stalling);
+return;
+}
+
+void sh_css_dump_isp_state(void)
+{
+	isp_state_t		state;
+	isp_stall_t		stall;
+
+	isp_get_state(ISP0_ID, &state, &stall);
+
+	print_isp_state(&state, "ISP");
+
+	if (state.is_stalling) {
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[0] if_prim_a_FIFO stalled",
+				stall.fifo0);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[1] if_prim_b_FIFO stalled",
+				stall.fifo1);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[2] dma_FIFO stalled",
+				stall.fifo2);
+#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2400A0_MAMOIADA) || defined(HAS_ISP_2401_MAMOIADA)
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[3] gdc0_FIFO stalled",
+				stall.fifo3);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[4] gdc1_FIFO stalled",
+				stall.fifo4);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[5] gpio_FIFO stalled",
+				stall.fifo5);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[6] sp_FIFO stalled",
+				stall.fifo6);
+#elif defined(HAS_ISP_2300_MEDFIELD) || defined(HAS_ISP_2300_MEDFIELD_DEMO)
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[3] gdc_FIFO stalled",
+				stall.fifo3);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[4] gpio_FIFO stalled",
+				stall.fifo4);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "[5] sp_FIFO stalled",
+				stall.fifo5);
+#else
+#error "sh_css_debug: ISP cell must be \
+	one of {2300_MEDFIELD, 2300_MEDFIELD_DEMO, 2400_MAMOIADA,, 2400A0_MAMOIADA, 2401_MAMOIADA}"
+#endif
+		sh_css_dtrace(2, "\t%-32s: %d\n", "status & control stalled",
+				stall.stat_ctrl);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
+				stall.dmem);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "vmem stalled",
+				stall.vmem);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem1 stalled",
+				stall.vamem1);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem2 stalled",
+				stall.vamem2);
+#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2400A0_MAMOIADA) || defined(HAS_ISP_2401_MAMOIADA)
+		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem3 stalled",
+				stall.vamem3);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "hmem stalled",
+				stall.hmem);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "pmem stalled",
+				stall.pmem);
+#endif
+	}
+return;
+}
+
+void sh_css_dump_sp_state(void)
+{
+	sp_state_t		state;
+	sp_stall_t		stall;
+	sp_get_state(SP0_ID, &state, &stall);
+	print_sp_state(&state, "SP");
+	if (state.is_stalling) {
+#if defined(HAS_SP_2400) || defined(HAS_SP_2400A0)
+		sh_css_dtrace(2, "\t%-32s: %d\n", "isys_FIFO stalled",
+				stall.fifo0);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_sec_FIFO stalled",
+				stall.fifo1);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "str_to_mem_FIFO stalled",
+				stall.fifo2);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "dma_FIFO stalled",
+				stall.fifo3);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_a_FIFO stalled",
+				stall.fifo4);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "isp_FIFO stalled",
+				stall.fifo5);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "gp_FIFO stalled",
+				stall.fifo6);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_b_FIFO stalled",
+				stall.fifo7);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc0_FIFO stalled",
+				stall.fifo8);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc1_FIFO stalled",
+				stall.fifo9);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "irq FIFO stalled",
+				stall.fifoa);
+#elif defined(HAS_SP_2300) || defined(HAS_SP_2300_DEMO)
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_a_FIFO stalled",
+				stall.fifo0);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_sec_FIFO stalled",
+				stall.fifo1);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "str_to_mem_FIFO stalled",
+				stall.fifo2);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "dma_FIFO stalled",
+				stall.fifo3);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc_FIFO stalled",
+				stall.fifo4);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "isp_FIFO stalled",
+				stall.fifo5);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "gp_FIFO stalled",
+				stall.fifo6);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_b_FIFO stalled",
+				stall.fifo7);
+#else
+#error "sh_css_debug: SP cell must be \
+	one of {SP_2300, SP_2300_DEMO, SP2400, SP2400A0}"
+#endif
+		sh_css_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
+				stall.dmem);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "control master stalled",
+				stall.control_master);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "i-cache master stalled",
+				stall.icache_master);
+	}
+return;
+}
+
+static void print_if_state(
+	input_formatter_state_t		*state)
+{
+	unsigned int val;
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_1)
+	const char *st_reset  = (state->reset ? "Active" : "Not active");
+#endif
+	const char *st_vsync_active_low =
+		(state->vsync_active_low ? "low" : "high");
+	const char *st_hsync_active_low = 
+		(state->hsync_active_low ? "low" : "high");
+
+	const char *fsm_sync_status_str    = "unknown";
+	const char *fsm_crop_status_str    = "unknown";
+	const char *fsm_padding_status_str = "unknown";
+
+	int st_stline = state->start_line;
+	int st_stcol  = state->start_column;
+	int st_crpht  = state->cropped_height;
+	int st_crpwd  = state->cropped_width;
+	int st_verdcm = state->ver_decimation;
+	int st_hordcm = state->hor_decimation;
+	int st_ver_deinterleaving = state->ver_deinterleaving;
+	int st_hor_deinterleaving = state->hor_deinterleaving;
+	int st_leftpd = state->left_padding;
+	int st_eoloff = state->eol_offset;
+	int st_vmstartaddr = state->vmem_start_address;
+	int st_vmendaddr = state->vmem_end_address;
+	int st_vmincr = state->vmem_increment;
+	int st_yuv420 = state->is_yuv420;
+	int st_allow_fifo_overflow = state->allow_fifo_overflow;
+	int st_block_fifo_when_no_req = state->block_fifo_when_no_req;
+
+	sh_css_dtrace(2, "InputFormatter State:\n");
+
+	sh_css_dtrace(2, "\tConfiguration:\n");
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_1)
+	sh_css_dtrace(2, "\t\t%-32s: %s\n"       ,
+			"Software reset"         , st_reset);
+#endif
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Start line"             , st_stline);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Start column"           , st_stcol);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Cropped height"         , st_crpht);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Cropped width"          , st_crpwd);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Ver decimation"         , st_verdcm);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Hor decimation"         , st_hordcm);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Ver deinterleaving"         , st_ver_deinterleaving);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Hor deinterleaving"         , st_hor_deinterleaving);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Left padding"           , st_leftpd);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"EOL offset (bytes)"     , st_eoloff);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
+			"VMEM start address"     , st_vmstartaddr);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
+			"VMEM end address"       , st_vmendaddr);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
+			"VMEM increment"         , st_vmincr);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"YUV 420 format"         , st_yuv420);
+	sh_css_dtrace(2, "\t\t%-32s: Active %s\n",
+			"Vsync"                  , st_vsync_active_low);
+	sh_css_dtrace(2, "\t\t%-32s: Active %s\n",
+			"Hsync"                  , st_hsync_active_low);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Allow FIFO overflow", st_allow_fifo_overflow);
+/* Flag that tells whether the IF gives backpressure on frames */
+/*
+ * FYI, this is only on the frame request (indicate), when the IF has
+ * synch'd on a frame it will always give back pressure
+ */
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
+			"Block when no request", st_block_fifo_when_no_req);
+
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	/***********************************************************
+	 * Hack for WHQL.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * DATE: 2013-01-16
+	 * TIME: 12:35
+	 * LOCATION: Santa Clara
+	 * COMMENT: Print out the value of the register that tells
+	 * whehter the IF is set to the blocked mode (i.e. "1") or
+	 * not (i.e. "0").
+	 ***********************************************************/	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+			"IF_BLOCKED_FIFO_NO_REQ_ADDRESS",
+			input_formatter_reg_load(INPUT_FORMATTER0_ID, 							HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS)
+			);
+	/** End of hack for WHQL ***********************************/
+
+	/***********************************************************
+	 * Hack for WHQL.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * DATE: 2013-01-23
+	 * TIME: 20:14
+	 * LOCATION: Santa Clara
+	 * COMMENT: Print out the input switch states.
+	 * not (i.e. "0").
+	 ***********************************************************/	
+	sh_css_dtrace(2, "\t%-32s:\n",
+		"InputSwitch State");
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg0",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg0));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg1",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg1));
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg2",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg2));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg3",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg3));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg4",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg4));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg5",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg5));
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg6",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg6));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_lut_reg7",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg7));
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_input_switch_fsync_lut",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_fsync_lut));
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_srst",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_srst));
+		
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		"_REG_GP_IFMT_slv_reg_srst",
+		gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_slv_reg_srst));
+	/** End of Hack for WHQL **********************************/
+
+#endif
+
+	sh_css_dtrace(2, "\tFSM Status:\n");
+
+	val = state->fsm_sync_status;
+
+	if (val > 7)
+		fsm_sync_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_sync_status_str = "idle";
+		break;
+	case 1:
+		fsm_sync_status_str = "request frame";
+		break;
+	case 2:
+		fsm_sync_status_str = "request lines";
+		break;
+	case 3:
+		fsm_sync_status_str = "request vectors";
+		break;
+	case 4:
+		fsm_sync_status_str = "send acknowledge";
+		break;
+	default:
+		fsm_sync_status_str = "unknown";
+		break;
+	}
+
+	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
+		     "FSM Synchronization Status", val, fsm_sync_status_str);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM Synchronization Counter", state->fsm_sync_counter);
+
+	val = state->fsm_crop_status;
+
+	if (val > 7)
+		fsm_crop_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_crop_status_str = "idle";
+		break;
+	case 1:
+		fsm_crop_status_str = "wait line";
+		break;
+	case 2:
+		fsm_crop_status_str = "crop line";
+		break;
+	case 3:
+		fsm_crop_status_str = "crop pixel";
+		break;
+	case 4:
+		fsm_crop_status_str = "pass pixel";
+		break;
+	case 5:
+		fsm_crop_status_str = "pass line";
+		break;
+	case 6:
+		fsm_crop_status_str = "lost line";
+		break;
+	default:
+		fsm_crop_status_str = "unknown";
+		break;
+	}
+	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
+		     "FSM Crop Status", val, fsm_crop_status_str);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM Crop Line Counter",
+		     state->fsm_crop_line_counter);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM Crop Pixel Counter",
+		     state->fsm_crop_pixel_counter);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM Deinterleaving idx buffer",
+		     state->fsm_deinterleaving_index);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM H decimation counter",
+		     state->fsm_dec_h_counter);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM V decimation counter",
+		     state->fsm_dec_v_counter);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n",
+		     "FSM block V decimation counter",
+		     state->fsm_dec_block_v_counter);
+
+	val = state->fsm_padding_status;
+
+	if (val > 7)
+		fsm_padding_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_padding_status_str = "idle";
+		break;
+	case 1:
+		fsm_padding_status_str = "left pad";
+		break;
+	case 2:
+		fsm_padding_status_str = "write";
+		break;
+	case 3:
+		fsm_padding_status_str = "right pad";
+		break;
+	case 4:
+		fsm_padding_status_str = "send end of line";
+		break;
+	default:
+		fsm_padding_status_str = "unknown";
+		break;
+	}
+
+	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n", "FSM Padding Status",
+		     val, fsm_padding_status_str);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Padding element idx counter",
+		     state->fsm_padding_elem_counter);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support error",
+		     state->fsm_vector_support_error);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support buf full",
+		     state->fsm_vector_buffer_full);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support",
+		     state->vector_support);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "Fifo sensor data lost",
+		     state->sensor_data_lost);
+return;
+}
+
+void sh_css_dump_if_state(void)
+{
+	input_formatter_state_t		state;
+	input_formatter_get_state(INPUT_FORMATTER0_ID, &state);
+	print_if_state(&state);
+	sh_css_dump_pif_isp_fifo_state();
+return;
+}
+
+void sh_css_dump_dma_state(void)
+{
+	dma_state_t		state;
+	int i, ch_id;
+
+	const char *fsm_cmd_st_lbl = "FSM Command flag state";
+	const char *fsm_ctl_st_lbl = "FSM Control flag state";
+	const char *fsm_ctl_state  = NULL;
+	const char *fsm_ctl_flag   = NULL;
+	const char *fsm_pack_st    = NULL;
+	const char *fsm_read_st    = NULL;
+	const char *fsm_write_st   = NULL;
+	char last_cmd_str[64];
+
+	dma_get_state(DMA0_ID, &state);
+	/* Print header for DMA dump status */
+	sh_css_dtrace(2, "DMA dump status:\n");
+
+	/* Print FSM command flag state */
+	if (state.fsm_command_idle)
+		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "IDLE");
+	if (state.fsm_command_run)
+		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "RUN");
+	if (state.fsm_command_stalling)
+		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "STALL");
+	if (state.fsm_command_error)
+		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "ERROR");
+
+	/* Print last command along with the channel */
+	ch_id = state.last_command_channel;
+
+	switch (state.last_command) {
+	case DMA_COMMAND_READ:
+		snprintf(last_cmd_str, 64,
+		  "Read 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_WRITE:
+		snprintf(last_cmd_str, 64,
+		  "Write 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_SET_CHANNEL:
+		snprintf(last_cmd_str, 64,
+		  "Set Channel [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_SET_PARAM:
+		snprintf(last_cmd_str, 64,
+		  "Set Param: %d [Channel: %d]",
+		  state.last_command_param, ch_id);
+		break;
+	case DMA_COMMAND_READ_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+		  "Read Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_WRITE_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+		  "Write Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_INIT:
+		snprintf(last_cmd_str, 64,
+		  "Init 2D Block on Device A [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_INIT_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+		  "Init Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_RST:
+		snprintf(last_cmd_str, 64,
+		  "DMA SW Reset");
+		break;
+	case N_DMA_COMMANDS:
+		snprintf(last_cmd_str, 64,
+		  "UNKNOWN");
+		break;
+	}
+	sh_css_dtrace(2, "\t%-32s: (0x%X : %s)\n", "last command received",
+		     state.last_command, last_cmd_str);
+
+	/* Print DMA registers */
+	sh_css_dtrace(2, "\t%-32s\n", "DMA registers, connection group 0");
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Command",
+			state.current_command);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address A",
+			state.current_addr_a);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address B",
+			state.current_addr_b);
+
+	if (state.fsm_ctrl_idle)
+		fsm_ctl_flag = "IDLE";
+	else if (state.fsm_ctrl_run)
+		fsm_ctl_flag = "RUN";
+	else if (state.fsm_ctrl_stalling)
+		fsm_ctl_flag = "STAL";
+	else if (state.fsm_ctrl_error)
+		fsm_ctl_flag = "ERROR";
+	else
+		fsm_ctl_flag = "UNKNOWN";
+
+	switch (state.fsm_ctrl_state) {
+	case DMA_CTRL_STATE_IDLE:
+		fsm_ctl_state = "Idle state";
+		break;
+	case DMA_CTRL_STATE_REQ_RCV:
+		fsm_ctl_state = "Req Rcv state";
+		break;
+	case DMA_CTRL_STATE_RCV:
+		fsm_ctl_state = "Rcv state";
+		break;
+	case DMA_CTRL_STATE_RCV_REQ:
+		fsm_ctl_state = "Rcv Req state";
+		break;
+	case DMA_CTRL_STATE_INIT:
+		fsm_ctl_state = "Init state";
+		break;
+	case N_DMA_CTRL_STATES:
+		fsm_ctl_state = "Unknown";
+		break;
+	}
+
+	sh_css_dtrace(2, "\t\t%-32s: %s -> %s\n", fsm_ctl_st_lbl,
+		     fsm_ctl_flag, fsm_ctl_state);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source dev",
+			state.fsm_ctrl_source_dev);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source addr",
+			state.fsm_ctrl_source_addr);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source stride",
+			state.fsm_ctrl_source_stride);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source width",
+			state.fsm_ctrl_source_width);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source height",
+			state.fsm_ctrl_source_height);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source dev",
+			state.fsm_ctrl_pack_source_dev);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest dev",
+			state.fsm_ctrl_pack_dest_dev);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest addr",
+			state.fsm_ctrl_dest_addr);
+	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest stride",
+			state.fsm_ctrl_dest_stride);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source width",
+			state.fsm_ctrl_pack_source_width);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest height",
+			state.fsm_ctrl_pack_dest_height);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest width",
+			state.fsm_ctrl_pack_dest_width);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source elems",
+			state.fsm_ctrl_pack_source_elems);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest elems",
+			state.fsm_ctrl_pack_dest_elems);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack extension",
+			state.fsm_ctrl_pack_extension);
+
+	if (state.pack_idle)
+		fsm_pack_st = "IDLE";
+	if (state.pack_run)
+		fsm_pack_st = "RUN";
+	if (state.pack_stalling)
+		fsm_pack_st = "STALL";
+	if (state.pack_error)
+		fsm_pack_st = "ERROR";
+
+	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Pack flag state", fsm_pack_st);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack cnt height",
+			state.pack_cnt_height);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack src cnt width",
+			state.pack_src_cnt_width);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack dest cnt width",
+			state.pack_dest_cnt_width);
+
+	if (state.read_state == DMA_RW_STATE_IDLE)
+		fsm_read_st = "Idle state";
+	if (state.read_state == DMA_RW_STATE_REQ)
+		fsm_read_st = "Req state";
+	if (state.read_state == DMA_RW_STATE_NEXT_LINE)
+		fsm_read_st = "Next line";
+	if (state.read_state == DMA_RW_STATE_UNLOCK_CHANNEL)
+		fsm_read_st = "Unlock channel";
+
+	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Read state", fsm_read_st);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt height",
+			state.read_cnt_height);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt width",
+			state.read_cnt_width);
+
+	if (state.write_state == DMA_RW_STATE_IDLE)
+		fsm_write_st = "Idle state";
+	if (state.write_state == DMA_RW_STATE_REQ)
+		fsm_write_st = "Req state";
+	if (state.write_state == DMA_RW_STATE_NEXT_LINE)
+		fsm_write_st = "Next line";
+	if (state.write_state == DMA_RW_STATE_UNLOCK_CHANNEL)
+		fsm_write_st = "Unlock channel";
+
+	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Write state", fsm_write_st);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Write height",
+			state.write_height);
+	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Write width",
+			state.write_width);
+
+	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
+		dma_port_state_t	*port = &(state.port_states[i]);
+		sh_css_dtrace(2, "\tDMA device interface %d\n", i);
+		sh_css_dtrace(2, "\t\tDMA internal side state\n");
+		sh_css_dtrace(2, "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
+				port->req_cs,
+				port->req_we_n,
+				port->req_run,
+				port->req_ack);
+		sh_css_dtrace(2, "\t\tMaster Output side state\n");
+		sh_css_dtrace(2, "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
+				port->send_cs,
+				port->send_we_n,
+				port->send_run,
+				port->send_ack);
+		sh_css_dtrace(2, "\t\tFifo state\n");
+		if (port->fifo_state == DMA_FIFO_STATE_WILL_BE_FULL)
+			sh_css_dtrace(2, "\t\t\tFiFo will be full\n");
+		else if (port->fifo_state == DMA_FIFO_STATE_FULL)
+			sh_css_dtrace(2, "\t\t\tFifo Full\n");
+		else if (port->fifo_state == DMA_FIFO_STATE_EMPTY)
+			sh_css_dtrace(2, "\t\t\tFifo Empty\n");
+		else
+			sh_css_dtrace(2, "\t\t\tFifo state unknown\n");
+
+		sh_css_dtrace(2, "\t\tFifo counter %d\n\n",
+				port->fifo_counter);
+	}
+
+	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
+		dma_channel_state_t	*ch = &(state.channel_states[i]);
+		sh_css_dtrace(2, "\t%-32s: %d\n", "DMA channel register",
+				i);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Connection",
+				ch->connection);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Sign extend",
+				ch->sign_extend);
+#if defined(IS_DMA_VERSION_1)
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Reverse elems",
+				ch->reverse_elem_order);
+#endif
+		sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev A",
+				ch->stride_a);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev A",
+				ch->elems_a);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev A",
+				ch->cropping_a);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Width Dev A",
+				ch->width_a);
+		sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev B",
+				ch->stride_b);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev B",
+				ch->elems_b);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev B",
+				ch->cropping_b);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Width Dev B",
+				ch->width_b);
+		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Height",
+				ch->height);
+	}
+	sh_css_dtrace(2, "\n");
+return;
+}
+
+static void print_fifo_channel_state(
+	const fifo_channel_state_t	*state,
+	const char					*descr)
+{
+	sh_css_dtrace(2, "FIFO channel: %s\n", descr);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "source valid", state->src_valid);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "fifo accept" , state->fifo_accept);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "fifo valid"  , state->fifo_valid);
+	sh_css_dtrace(2, "\t%-32s: %d\n", "sink accept" , state->sink_accept);
+return;
+}
+
+void sh_css_dump_pif_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
+	print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A)");
+return;
+}
+
+void sh_css_dump_dma_sp_fifo_state(void)
+{
+	fifo_channel_state_t dma_to_sp, sp_to_dma;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_DMA0_TO_SP0, &dma_to_sp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_SP0_TO_DMA0, &sp_to_dma);
+	print_fifo_channel_state(&dma_to_sp, "DMA to SP");
+	print_fifo_channel_state(&sp_to_dma, "SP to DMA");
+return;
+}
+
+void sh_css_dump_dma_isp_fifo_state(void)
+{
+	fifo_channel_state_t dma_to_isp, isp_to_dma;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_DMA0_TO_ISP0, &dma_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_ISP0_TO_DMA0, &isp_to_dma);
+	print_fifo_channel_state(&dma_to_isp, "DMA to ISP");
+	print_fifo_channel_state(&isp_to_dma, "ISP to DMA");
+return;
+}
+
+void sh_css_dump_isp_sp_fifo_state(void)
+{
+	fifo_channel_state_t sp_to_isp, isp_to_sp;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_SP0_TO_ISP0, &sp_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_ISP0_TO_SP0, &isp_to_sp);
+	print_fifo_channel_state(&sp_to_isp, "SP to ISP");
+	print_fifo_channel_state(&isp_to_sp, "ISP to SP");
+return;
+}
+
+void sh_css_dump_isp_gdc_fifo_state(void)
+{
+	fifo_channel_state_t gdc_to_isp, isp_to_gdc;
+
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_GDC0_TO_ISP0, &gdc_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+		FIFO_CHANNEL_ISP0_TO_GDC0, &isp_to_gdc);
+	print_fifo_channel_state(&gdc_to_isp, "GDC to ISP");
+	print_fifo_channel_state(&isp_to_gdc, "ISP to GDC");
+return;
+}
+
+void sh_css_dump_all_fifo_state(void)
+{
+	int	i;
+	fifo_monitor_state_t	state;
+	fifo_monitor_get_state(FIFO_MONITOR0_ID, &state);
+
+	for (i = 0; i < N_FIFO_CHANNEL; i++)
+		print_fifo_channel_state(&(state.fifo_channels[i]),
+			"squepfstqkt");
+return;
+}
+
+static void sh_css_binary_info_print(
+	const struct ia_css_binary_info *info)
+{
+	sh_css_dtrace(2, "id = %d\n", info->id);
+	sh_css_dtrace(2, "mode = %d\n", info->mode);
+	sh_css_dtrace(2, "max_input_width = %d\n", info->max_input_width);
+	sh_css_dtrace(2, "min_output_width = %d\n", info->min_output_width);
+	sh_css_dtrace(2, "max_output_width = %d\n", info->max_output_width);
+	sh_css_dtrace(2, "top_cropping = %d\n", info->top_cropping);
+	sh_css_dtrace(2, "left_cropping = %d\n", info->left_cropping);
+	sh_css_dtrace(2, "xmem_addr = %d\n", info->xmem_addr);
+	sh_css_dtrace(2, "enable_vf_veceven = %d\n", info->enable.vf_veceven);
+	sh_css_dtrace(2, "enable_dis = %d\n", info->enable.dis);
+	sh_css_dtrace(2, "enable_uds = %d\n", info->enable.uds);
+	sh_css_dtrace(2, "enable ds = %d\n", info->enable.ds);
+	sh_css_dtrace(2, "s3atbl_use_dmem = %d\n", info->s3atbl_use_dmem);
+return;
+}
+
+void sh_css_binary_print(
+	const struct sh_css_binary *bi)
+{
+	sh_css_binary_info_print(bi->info);
+	sh_css_dtrace(2, "input:  %dx%d, format = %d, padded width = %d\n",
+		     bi->in_frame_info.res.width, bi->in_frame_info.res.height,
+		     bi->in_frame_info.format, bi->in_frame_info.padded_width);
+	sh_css_dtrace(2, "internal :%dx%d, format = %d, padded width = %d\n",
+		     bi->internal_frame_info.res.width,
+		     bi->internal_frame_info.res.height,
+		     bi->internal_frame_info.format,
+		     bi->internal_frame_info.padded_width);
+	sh_css_dtrace(2, "out:    %dx%d, format = %d, padded width = %d\n",
+		     bi->out_frame_info.res.width, bi->out_frame_info.res.height,
+		     bi->out_frame_info.format,
+		     bi->out_frame_info.padded_width);
+	sh_css_dtrace(2, "vf out: %dx%d, format = %d, padded width = %d\n",
+		     bi->vf_frame_info.res.width, bi->vf_frame_info.res.height,
+		     bi->vf_frame_info.format, bi->vf_frame_info.padded_width);
+	sh_css_dtrace(2, "online = %d\n", bi->online);
+	sh_css_dtrace(2, "input_buf_vectors = %d\n", bi->input_buf_vectors);
+	sh_css_dtrace(2, "deci_factor_log2 = %d\n", bi->deci_factor_log2);
+	sh_css_dtrace(2, "vf_downscale_log2 = %d\n", bi->vf_downscale_log2);
+	sh_css_dtrace(2, "dis_deci_factor_log2 = %d\n",
+			bi->dis_deci_factor_log2);
+	sh_css_dtrace(2, "dis hor coef num = %d\n", bi->dis_hor_coef_num_isp);
+	sh_css_dtrace(2, "dis ver coef num = %d\n", bi->dis_ver_coef_num_isp);
+	sh_css_dtrace(2, "dis hor proj num = %d\n", bi->dis_ver_proj_num_isp);
+	sh_css_dtrace(2, "sctbl_width_per_color = %d\n",
+			bi->sctbl_width_per_color);
+	sh_css_dtrace(2, "s3atbl_width = %d\n", bi->s3atbl_width);
+	sh_css_dtrace(2, "s3atbl_height = %d\n", bi->s3atbl_height);
+return;
+}
+
+void sh_css_frame_print(
+	const struct ia_css_frame	*frame,
+	const char					*descr)
+{
+	char *data = (char *)HOST_ADDRESS(frame->data);
+	sh_css_dtrace(2, "frame %s (%p):\n", descr, frame);
+	sh_css_dtrace(2, "  resolution    = %dx%d\n",
+		     frame->info.res.width, frame->info.res.height);
+	sh_css_dtrace(2, "  padded width  = %d\n", frame->info.padded_width);
+	sh_css_dtrace(2, "  format        = %d\n", frame->info.format);
+	sh_css_dtrace(2, "  is contiguous = %s\n",
+		     frame->contiguous ? "yes" : "no");
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		sh_css_dtrace(2, "  Y = %p\n",
+				data + frame->planes.nv.y.offset);
+		sh_css_dtrace(2, "  UV = %p\n",
+				data + frame->planes.nv.uv.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		sh_css_dtrace(2, "  YUYV = %p\n",
+				data + frame->planes.yuyv.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+		sh_css_dtrace(2, "  Y = %p\n",
+				data + frame->planes.yuv.y.offset);
+		sh_css_dtrace(2, "  U = %p\n",
+				data + frame->planes.yuv.u.offset);
+		sh_css_dtrace(2, "  V = %p\n",
+				data + frame->planes.yuv.v.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW:
+		sh_css_dtrace(2, "  RAW = %p\n",
+				data + frame->planes.raw.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		sh_css_dtrace(2, "  RGB = %p\n",
+				data + frame->planes.rgb.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		sh_css_dtrace(2, "  R    = %p\n",
+				data + frame->planes.plane6.r.offset);
+		sh_css_dtrace(2, "  RatB = %p\n",
+				data + frame->planes.plane6.r_at_b.offset);
+		sh_css_dtrace(2, "  Gr   = %p\n",
+				data + frame->planes.plane6.gr.offset);
+		sh_css_dtrace(2, "  Gb   = %p\n",
+				data + frame->planes.plane6.gb.offset);
+		sh_css_dtrace(2, "  B    = %p\n",
+				data + frame->planes.plane6.b.offset);
+		sh_css_dtrace(2, "  BatR = %p\n",
+				data + frame->planes.plane6.b_at_r.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		sh_css_dtrace(2, "  Binary data = %p\n",
+				data + frame->planes.binary.data.offset);
+		break;
+	default:
+		sh_css_dtrace(2, "  unknown frame type\n");
+		break;
+	}
+return;
+}
+
+#if SP_DEBUG !=SP_DEBUG_NONE
+
+void sh_css_print_sp_debug_state(
+	const struct sh_css_sp_debug_state	*state)
+{
+
+#endif
+
+#if SP_DEBUG == SP_DEBUG_DUMP
+
+	sh_css_dtrace(SH_DBG_DEBUG, "current SP software counter: %d\n",
+				state->debug[0]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty output buffer queue head: 0x%x\n",
+				state->debug[1]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty output buffer queue tail: 0x%x\n",
+				state->debug[2]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a buffer queue head: 0x%x\n",
+				state->debug[3]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a buffer queue tail: 0x%x\n",
+				state->debug[4]);
+	sh_css_dtrace(SH_DBG_DEBUG, "full output buffer queue head: 0x%x\n",
+				state->debug[5]);
+	sh_css_dtrace(SH_DBG_DEBUG, "full output buffer queue tail: 0x%x\n",
+				state->debug[6]);
+	sh_css_dtrace(SH_DBG_DEBUG, "full s3a buffer queue head: 0x%x\n",
+				state->debug[7]);
+	sh_css_dtrace(SH_DBG_DEBUG, "full s3a buffer queue tail: 0x%x\n",
+				state->debug[8]);
+	sh_css_dtrace(SH_DBG_DEBUG, "event queue head: 0x%x\n",
+				state->debug[9]);
+	sh_css_dtrace(SH_DBG_DEBUG, "event queue tail: 0x%x\n",
+				state->debug[10]);
+	sh_css_dtrace(SH_DBG_DEBUG, "num of stages of current pipeline: 0x%x\n",
+				state->debug[11]);
+	sh_css_dtrace(SH_DBG_DEBUG, "DDR address of stage 1: 0x%x\n",
+				state->debug[12]);
+	sh_css_dtrace(SH_DBG_DEBUG, "DDR address of stage 2: 0x%x\n",
+				state->debug[13]);
+	sh_css_dtrace(SH_DBG_DEBUG, "current stage out_vf buffer idx: 0x%x\n",
+				state->debug[14]);
+	sh_css_dtrace(SH_DBG_DEBUG, "current stage output buffer idx: 0x%x\n",
+				state->debug[15]);
+	sh_css_dtrace(SH_DBG_DEBUG, "current stage s3a buffer idx: 0x%x\n",
+				state->debug[16]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first char of current stage name: 0x%x\n",
+				state->debug[17]);
+	sh_css_dtrace(SH_DBG_DEBUG, "current SP thread id: 0x%x\n",
+				state->debug[18]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty output buffer address 1: 0x%x\n",
+				state->debug[19]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty output buffer address 2: 0x%x\n",
+				state->debug[20]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty out_vf buffer address 1: 0x%x\n",
+				state->debug[21]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty out_vf buffer address 2: 0x%x\n",
+				state->debug[22]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a_hi buffer address 1: 0x%x\n",
+				state->debug[23]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a_hi buffer address 2: 0x%x\n",
+				state->debug[24]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a_lo buffer address 1: 0x%x\n",
+				state->debug[25]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty s3a_lo buffer address 2: 0x%x\n",
+				state->debug[26]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty dis_hor buffer address 1: 0x%x\n",
+				state->debug[27]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty dis_hor buffer address 2: 0x%x\n",
+				state->debug[28]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty dis_ver buffer address 1: 0x%x\n",
+				state->debug[29]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty dis_ver buffer address 2: 0x%x\n",
+				state->debug[30]);
+	sh_css_dtrace(SH_DBG_DEBUG, "empty param buffer address: 0x%x\n",
+				state->debug[31]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect frame address: 0x%x\n",
+				state->debug[32]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect frame container address: 0x%x\n",
+				state->debug[33]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect frame container payload: 0x%x\n",
+				state->debug[34]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_hi address: 0x%x\n",
+				state->debug[35]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_hi container address: 0x%x\n",
+				state->debug[36]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_hi container payload: 0x%x\n",
+				state->debug[37]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_lo address: 0x%x\n",
+				state->debug[38]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_lo container address: 0x%x\n",
+				state->debug[39]);
+	sh_css_dtrace(SH_DBG_DEBUG, "first incorrect s3a_lo container payload: 0x%x\n",
+				state->debug[40]);
+	sh_css_dtrace(SH_DBG_DEBUG, "number of calling flash start function: 0x%x\n",
+				state->debug[41]);
+	sh_css_dtrace(SH_DBG_DEBUG, "number of calling flash close function: 0x%x\n",
+				state->debug[42]);
+	sh_css_dtrace(SH_DBG_DEBUG, "number of flashed frame: 0x%x\n",
+				state->debug[43]);
+	sh_css_dtrace(SH_DBG_DEBUG, "flash in use flag: 0x%x\n",
+				state->debug[44]);
+	sh_css_dtrace(SH_DBG_DEBUG, "number of update frame flashed flag: 0x%x\n",
+				state->debug[46]);
+	sh_css_dtrace(SH_DBG_DEBUG, "number of active threads: 0x%x\n",
+				state->debug[45]);
+
+
+#elif SP_DEBUG == SP_DEBUG_COPY
+
+	/* Remember last_index because we only want to print new entries */
+	static int last_index = 0;
+	int sp_index = state->index;
+	int n;
+
+	if (sp_index < last_index) {
+		/* SP has been reset */
+		last_index = 0;
+	}
+
+	if (last_index == 0) {
+		sh_css_dtrace(SH_DBG_DEBUG, 
+		  "copy-trace init: sp_dbg_if_start_line=%d, sp_dbg_if_start_column=%d, "
+		  "sp_dbg_if_cropped_height=%d, sp_debg_if_cropped_width=%d\n",
+		  state->if_start_line,
+		  state->if_start_column,
+		  state->if_cropped_height,
+		  state->if_cropped_width
+		  );
+	}
+
+	if ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {
+		/* last index can be multiple rounds behind */
+		/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
+		last_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;
+	}
+
+	for (n = last_index; n < sp_index; n++) {
+		int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+		if (state->trace[i].frame != 0) {
+			sh_css_dtrace(SH_DBG_DEBUG, 
+			  "copy-trace: frame=%d, line=%d, "
+			  "pixel_distance=%d, mipi_used_dword=%d, sp_index=%d\n",
+			  state->trace[i].frame,
+			  state->trace[i].line,
+			  state->trace[i].pixel_distance,
+			  state->trace[i].mipi_used_dword,
+			  state->trace[i].sp_index
+			  );
+		}
+	}
+
+	last_index = sp_index;
+
+#elif SP_DEBUG == SP_DEBUG_TRACE
+
+#if 1
+
+	static char const *id2filename[8] = {
+		"N.A.", "sp.hive.c", "event.sp.c", "sp_raw_copy.hive.c",
+		"buffer_queue.sp.c", "event_proxy_sp.hive.c", "ERROR", "ERROR"
+		};
+
+#if 0
+	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
+				"copy", "preview/video", "capture",
+				"acceleration", "control", "TBD" };
+#else
+	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
+				"copy", "preview/video", "event_ext_io",
+				"event_PIF_A" };
+#endif
+	int t, d;
+
+	for (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {
+		/* base contains the "oldest" index */
+		int base = state->index[t];
+		for (d = 0; d < SH_CSS_SP_DBG_TRACE_DEPTH; d++) {
+			int i = (base + d) % SH_CSS_SP_DBG_TRACE_DEPTH;
+			int l = state->trace[t][i].location &
+				((1<<SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS)-1);
+			int fid = state->trace[t][i].location >>
+				SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;
+			int ts = state->trace[t][i].time_stamp;
+
+			if (ts) {
+				sh_css_dtrace(SH_DBG_DEBUG, 
+				  "%05d trace=%s, file=%s:%d, data=0x%08x\n",
+				  ts,
+				  trace_name[t],
+				  id2filename[fid], l,
+				  state->trace[t][i].data);
+			}
+		}
+	}
+
+
+#endif
+
+#elif SP_DEBUG == SP_DEBUG_MINIMAL
+	int i;
+	int base = 0;
+	int limit = SH_CSS_NUM_SP_DEBUG;
+	int step = 1;
+	
+	for (i = base; i < limit; i += step) {
+		sh_css_dtrace(SH_DBG_DEBUG,
+			"sp_dbg_trace[%d] = %d\n",
+			i,
+			state->debug[i]);
+	}
+#endif
+
+#if SP_DEBUG !=SP_DEBUG_NONE
+
+	return;
+}
+#endif
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+static void print_rx_mipi_port_state(
+		mipi_port_state_t *state)
+{
+	int i;
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"device_ready"		, state->device_ready);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"irq_status"		, state->irq_status);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"irq_enable"		, state->irq_enable);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"timeout_count"		, state->timeout_count);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"init_count"		, state->init_count);
+
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"raw16_18"		, state->raw16_18);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"sync_count"		, state->sync_count);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"rx_count"		, state->rx_count);
+
+
+	for (i = 0; i < MIPI_4LANE_CFG; i++) {
+		sh_css_dtrace(2, "\t\t%-32s%d%-32s: %d\n"	,
+				"lane_sync_count[", i, "]", state->lane_sync_count[i]);
+	}
+
+	for (i = 0; i < MIPI_4LANE_CFG; i++) {
+		sh_css_dtrace(2, "\t\t%-32s%d%-32s: %d\n"	,
+				"lane_rx_count[", i, "]", state->lane_rx_count[i]);		
+	}
+
+	return;
+}
+
+static void print_rx_channel_state(
+		rx_channel_state_t *state)
+{
+	int i;
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"compression_scheme0"	, state->comp_scheme0);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"compression_scheme1"	, state->comp_scheme1);
+
+	for (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		sh_css_dtrace(2, "\t\t%-32s%d: %d\n"	,
+				"MIPI Predictor ", i, state->pred[i]);
+	}
+
+	for (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		sh_css_dtrace(2, "\t\t%-32s%d: %d\n"	,
+				"MIPI Compressor ", i, state->comp[i]);
+	}	
+
+	return;
+}
+
+static void print_rx_state(
+		receiver_state_t *state)
+{
+	int i;
+
+	sh_css_dtrace(2, "CSI Receiver State:\n");
+
+	sh_css_dtrace(2, "\tConfiguration:\n");
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"fs_to_ls_delay"	, state->fs_to_ls_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"ls_to_data_delay"	, state->ls_to_data_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"data_to_le_delay"	, state->data_to_le_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"le_to_fe_delay"	, state->le_to_fe_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"fe_to_fs_delay"	, state->fe_to_fs_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"le_to_fs_delay"	, state->le_to_fs_delay);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"is_two_ppc"		, state->is_two_ppc);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"backend_rst"		, state->backend_rst);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"raw18"			, state->raw18);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"force_raw8"		, state->force_raw8);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"raw16"	, state->raw16);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_gsp_acc_ovl"	, state->be_gsp_acc_ovl);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_srst"		, state->be_srst);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_is_two_ppc"		, state->be_is_two_ppc);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_comp_format0"	, state->be_comp_format0);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_comp_format1"	, state->be_comp_format1);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_comp_format2"	, state->be_comp_format2);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_comp_format3"	, state->be_comp_format3);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_sel"		, state->be_sel);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_raw16_config"	, state->be_raw16_config);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_raw18_config"	, state->be_raw18_config);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_force_raw8"		, state->be_force_raw8);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_irq_status"		, state->be_irq_status);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"be_irq_clear"		, state->be_irq_clear);
+
+	/* mipi port state */
+	for (i = 0; i < N_MIPI_PORT_ID; i++) {
+		sh_css_dtrace(2, "\tMIPI Port %d State:\n",
+				i);
+
+		print_rx_mipi_port_state(&state->mipi_port_state[i]);
+	}
+	/* end of mipi port state */
+
+	/* rx channel state */
+	for (i = 0; i < N_RX_CHANNEL_ID; i++) {
+		sh_css_dtrace(2, "\tRX Channel %d State:\n",
+				i);
+		
+		print_rx_channel_state(&state->rx_channel_state[i]);
+	}
+	/* end of rx channel state */
+
+	return;
+}
+#endif
+
+void sh_css_dump_rx_state(void)
+{
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	receiver_state_t state;
+#endif
+	unsigned int infos = 0, bits;
+	bits = sh_css_rx_get_interrupt_reg();
+	ia_css_rx_get_irq_info(&infos);
+
+	sh_css_dtrace(2, "CSI Receiver errors: (irq reg = 0x%X)\n", bits);
+
+	if (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		sh_css_dtrace(2, "\tbuffer overrun\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		sh_css_dtrace(2, "\tstart-of-transmission error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		sh_css_dtrace(2, "\tstart-of-transmission sync error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		sh_css_dtrace(2, "\tcontrol error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		sh_css_dtrace(2, "\t2 or more ECC errors\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		sh_css_dtrace(2, "\tCRC mismatch\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		sh_css_dtrace(2, "\tunknown error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		sh_css_dtrace(2, "\tframe sync error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		sh_css_dtrace(2, "\tframe data error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		sh_css_dtrace(2, "\tdata timeout\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		sh_css_dtrace(2, "\tunknown escape command entry\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		sh_css_dtrace(2, "\tline sync error\n");
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	receiver_get_state(RX0_ID, &state);
+	print_rx_state(&state);
+#endif
+return;
+}
+
+void
+sh_css_dump_sp_sw_debug_info(void)
+{
+#if SP_DEBUG !=SP_DEBUG_NONE
+	struct sh_css_sp_debug_state state;
+
+	sh_css_sp_get_debug_state(&state);
+	sh_css_print_sp_debug_state(&state);
+#endif
+return;
+}
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+static void print_isys_capture_unit_state(
+	capture_unit_state_t *state)
+{
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Packet_Length"		, state->Packet_Length);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Received_Length"	, state->Received_Length);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"		,
+			"Received_Short_Packets"	, state->Received_Short_Packets);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Received_Long_Packets"	, state->Received_Long_Packets);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Last_Command"		, state->Last_Command);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Next_Command"		, state->Next_Command);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Last_Acknowledge"	, state->Last_Acknowledge);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Next_Acknowledge"	, state->Next_Acknowledge);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"FSM_State_Info"	, state->FSM_State_Info);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"StartMode"		, state->StartMode);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Start_Addr"		, state->Start_Addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Mem_Region_Size"	, state->Mem_Region_Size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Num_Mem_Regions"	, state->Num_Mem_Regions);
+#if 0	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Init"			, state->Init);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Start"			, state->Start);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Stop"			, state->Stop);
+#endif
+	return;
+}
+
+static void print_isys_acquisition_unit_state(
+	acquisition_unit_state_t *state)
+{
+#if 0
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Init"			, state->Init);
+#endif
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"		,
+			"Received_Short_Packets"	, state->Received_Short_Packets);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Received_Long_Packets"	, state->Received_Long_Packets);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Last_Command"		, state->Last_Command);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Next_Command"		, state->Next_Command);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Last_Acknowledge"	, state->Last_Acknowledge);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Next_Acknowledge"	, state->Next_Acknowledge);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"FSM_State_Info"	, state->FSM_State_Info);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Int_Cntr_Info"		, state->Int_Cntr_Info);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Start_Addr"		, state->Start_Addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Mem_Region_Size"	, state->Mem_Region_Size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"Num_Mem_Regions"	, state->Num_Mem_Regions);
+}
+
+static void print_isys_ctrl_unit_state(
+	ctrl_unit_state_t *state)
+{
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"last_cmd"		, state->last_cmd);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"next_cmd"		, state->next_cmd);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"last_ack"		, state->last_ack);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"next_ack"		, state->next_ack);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"top_fsm_state"		, state->top_fsm_state);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captA_fsm_state"	, state->captA_fsm_state);	
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captB_fsm_state"	, state->captB_fsm_state);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captC_fsm_state"	, state->captC_fsm_state);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"acq_fsm_state"		, state->acq_fsm_state);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captA_start_addr"	, state->captA_start_addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captB_start_addr"	, state->captB_start_addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captC_start_addr"	, state->captC_start_addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captA_mem_region_size"	, state->captA_mem_region_size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captB_mem_region_size"	, state->captB_mem_region_size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captC_mem_region_size"	, state->captC_mem_region_size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captA_num_mem_regions"	, state->captA_num_mem_regions);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captB_num_mem_regions"	, state->captB_num_mem_regions);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"captC_num_mem_regions"	, state->captC_num_mem_regions);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"acq_start_addr"	, state->acq_start_addr);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"acq_mem_region_size"	, state->acq_mem_region_size);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"acq_num_mem_regions"	, state->acq_num_mem_regions);
+#if 0
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"ctrl_init"		, state->ctrl_init);
+#endif
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"		,
+			"capt_reserve_one_mem_region"	, state->capt_reserve_one_mem_region);
+
+	return;
+}
+
+static void print_isys_state(
+	input_system_state_t *state)
+{
+	int i;
+
+	sh_css_dtrace(2, "InputSystem State:\n");
+
+	/* configuration */
+	sh_css_dtrace(2, "\tConfiguration:\n");
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_multiCastA_sel"	, state->str_multicastA_sel);
+	
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_multicastB_sel"	, state->str_multicastB_sel);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_multicastC_sel"	, state->str_multicastC_sel);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_mux_sel"		, state->str_mux_sel);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_mon_status"	, state->str_mon_status);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_mon_irq_cond"	, state->str_mon_irq_cond);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_mon_irq_en"	, state->str_mon_irq_en);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"isys_srst"		, state->isys_srst);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"isys_slv_reg_srst"	, state->isys_slv_reg_srst);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_deint_portA_cnt"	, state->str_deint_portA_cnt);
+
+	sh_css_dtrace(2, "\t\t%-32s: %d\n"	,
+			"str_deint_portB_cnd"	, state->str_deint_portB_cnt);
+	/* end of configuration */
+
+	/* capture unit state */
+	for (i = 0; i < N_CAPTURE_UNIT_ID; i++) {
+		capture_unit_state_t *capture_unit_state;
+
+		sh_css_dtrace(2, "\tCaptureUnit %d State:\n",
+				i);
+
+		capture_unit_state = &state->capture_unit[i];
+		print_isys_capture_unit_state(capture_unit_state);
+	}
+	/* end of capture unit state */
+
+	/* acquisition unit state */
+	for (i = 0; i < N_ACQUISITION_UNIT_ID; i++) {
+		acquisition_unit_state_t *acquisition_unit_state;
+
+		sh_css_dtrace(2, "\tAcquisitionUnit %d State:\n",
+				i);
+
+		acquisition_unit_state = &state->acquisition_unit[i];
+		print_isys_acquisition_unit_state(acquisition_unit_state);
+	}
+	/* end of acquisition unit state */
+
+	/* control unit state */
+	for (i = 0; i < N_CTRL_UNIT_ID; i++) {
+		sh_css_dtrace(2, "\tControlUnit %d State:\n",
+				i);
+
+		print_isys_ctrl_unit_state(&state->ctrl_unit_state[i]);
+	}
+	/* end of control unit state */
+}
+
+void sh_css_dump_isys_state(void)
+{
+	input_system_state_t state;	
+	
+	input_system_get_state(INPUT_SYSTEM0_ID, &state);
+	print_isys_state(&state);
+
+	return;
+}
+#endif
+
+void sh_css_dump_debug_info(
+	const char	*context)
+{
+	if (context == NULL)
+		context = "No Context provided";
+
+	sh_css_dtrace(2, "CSS Debug Info dump [Context = %s]\n", context);
+	sh_css_dump_rx_state();
+	sh_css_dump_if_state();
+	sh_css_dump_isp_state();
+	sh_css_dump_isp_sp_fifo_state();
+	sh_css_dump_isp_gdc_fifo_state();
+	sh_css_dump_sp_state();
+	sh_css_dump_dma_isp_fifo_state();
+	sh_css_dump_dma_sp_fifo_state();
+	sh_css_dump_dma_state();
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	sh_css_dump_isys_state();
+	
+    {
+        irq_controller_state_t state;
+        irq_controller_get_state(IRQ2_ID, &state);
+    
+        sh_css_dtrace(2, "\t%-32s:\n" ,
+         "Input System IRQ Controller State");
+
+        sh_css_dtrace(2, "\t\t%-32s: %d\n"  ,
+                                "irq_edge"  , state.irq_edge);
+
+        sh_css_dtrace(2, "\t\t%-32s: %d\n"  ,
+                                "irq_mask"  , state.irq_mask);
+        
+        sh_css_dtrace(2, "\t\t%-32s: %d\n"  ,
+                               "irq_status" , state.irq_status);
+        
+        sh_css_dtrace(2, "\t\t%-32s: %d\n"  ,
+                               "irq_enable" , state.irq_enable);
+
+        sh_css_dtrace(2, "\t\t%-32s: %d\n"  ,
+                               "irq_level_not_pulse", state.irq_level_not_pulse);
+    }
+#endif
+return;
+}
+
+#if SP_DEBUG == SP_DEBUG_TRACE
+
+void
+sh_css_sp_debug_dump_mipi_fifo_high_water(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int mfhw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned offset = offsetof(struct sh_css_sp_output, debug.mipi_fifo_high_water);
+
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+
+	load_sp_var_with_offset(sp_output, offset, &mfhw, sizeof(mfhw));
+
+	sh_css_dtrace(SH_DBG_DEBUG, "Mipi fifo high water mark: %d, line %d\n",mfhw&0xFFFF, mfhw>>16);
+}
+
+#endif
+
+
+/* this function is for debug use, it can make SP go to sleep
+  state after each frame, then user can dump the stable SP dmem.
+  this function can be called after sh_css_start()
+  and before sh_css_init_buffer_queues() */
+void sh_css_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_sleep_mode;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
+
+	(void)HIVE_ADDR_sp_sleep_mode; /* Suppres warnings in CRUN */
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_sleep_mode),
+		(uint32_t)mode);
+}
+
+void sh_css_wake_up_sp(void)
+{
+	/*hrt_ctl_start(SP);*/
+	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
+}
+
+void sh_css_dump_isp_params(struct ia_css_stream *stream, unsigned int enable)
+{
+	const struct sh_css_isp_params *isp_params = ia_css_get_isp_params(stream);
+
+	sh_css_dtrace(SH_DBG_DEBUG, "ISP PARAMETERS:\n");
+	if ((enable & SH_CSS_DEBUG_DUMP_FPN)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Fixed Pattern Noise Reduction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"fpn_shift", isp_params->fpn_shift);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"fpn_enabled", isp_params->fpn_enabled);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_OB)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Optical Black:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"ob_blacklevel_gr", isp_params->ob_blacklevel_gr);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"ob_blacklevel_r", isp_params->ob_blacklevel_r);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"ob_blacklevel_b", isp_params->ob_blacklevel_b);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"ob_blacklevel_gb", isp_params->ob_blacklevel_gb);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"obarea_start_bq", isp_params->obarea_start_bq);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"obarea_length_bq", isp_params->obarea_length_bq);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"obarea_length_bq_inverse",
+			isp_params->obarea_length_bq_inverse);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_SC)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Shading Correction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"sc_gain_shift", isp_params->sc_gain_shift);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_WB)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "White Balance:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"wb_gain_shift", isp_params->wb_gain_shift);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"wb_gain_gr", isp_params->wb_gain_gr);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"wb_gain_r", isp_params->wb_gain_r);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"wb_gain_b", isp_params->wb_gain_b);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"wb_gain_gb", isp_params->wb_gain_gb);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_DP)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Defect Pixel Correction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dp_threshold_single_w_2adj_on",
+			isp_params->dp_threshold_single_when_2adjacent_on);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dp_threshold_2adj_w_2adj_on",
+			isp_params->dp_threshold_2adjacent_when_2adjacent_on);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dp_threshold_single_w_2adj_off",
+			isp_params->dp_threshold_single_when_2adjacent_off);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dp_threshold_2adj_w_2adj_off",
+			isp_params->dp_threshold_2adjacent_when_2adjacent_off);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dp_gain", isp_params->dp_gain);
+#if SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_rr_gr", isp_params->dpc_coef_rr_gr);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_rr_gb", isp_params->dpc_coef_rr_gb);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_bb_gb", isp_params->dpc_coef_bb_gb);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_bb_gr", isp_params->dpc_coef_bb_gr);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_gr_rr", isp_params->dpc_coef_gr_rr);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_gr_bb", isp_params->dpc_coef_gr_bb);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_gb_bb", isp_params->dpc_coef_gb_bb);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+			"dpc_coef_gb_rr", isp_params->dpc_coef_gb_rr);
+#endif
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_BNR)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Bayer Noise Reduction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_gain_all", isp_params->bnr_gain_all);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_gain_dir", isp_params->bnr_gain_dir);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_threshold_low",
+				isp_params->bnr_threshold_low);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_threshold_width_log2",
+				isp_params->bnr_threshold_width_log2);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_threshold_width",
+				isp_params->bnr_threshold_width);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"bnr_clip", isp_params->bnr_clip);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_S3A)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "S3A Support:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ae_y_coef_r", isp_params->ae_y_coef_r);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ae_y_coef_g", isp_params->ae_y_coef_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ae_y_coef_b", isp_params->ae_y_coef_b);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"awb_lg_high_raw", isp_params->awb_lg_high_raw);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"awb_lg_low", isp_params->awb_lg_low);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"awb_lg_high", isp_params->awb_lg_high);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[0]", isp_params->af_fir1[0]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[1]", isp_params->af_fir1[1]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[2]", isp_params->af_fir1[2]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[3]", isp_params->af_fir1[3]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[4]", isp_params->af_fir1[4]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[5]", isp_params->af_fir1[5]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir1[6]", isp_params->af_fir1[6]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[0]", isp_params->af_fir2[0]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[1]", isp_params->af_fir2[1]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[2]", isp_params->af_fir2[2]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[3]", isp_params->af_fir2[3]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[4]", isp_params->af_fir2[4]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[5]", isp_params->af_fir2[5]);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"af_fir2[6]", isp_params->af_fir2[6]);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_DE)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Demosaic:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"de_pixelnoise", isp_params->de_pixelnoise);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"de_c1_coring_threshold",
+				isp_params->de_c1_coring_threshold);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"de_c2_coring_threshold",
+				isp_params->de_c2_coring_threshold);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_YNR)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG,
+			"Y Noise Reduction and Edge Enhancement:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynr_threshold", isp_params->ynr_threshold);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynr_gain_all", isp_params->ynr_gain_all);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynr_gain_dir", isp_params->ynr_gain_dir);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynryee_dirthreshold_s",
+				isp_params->ynryee_dirthreshold_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynryee_dirthreshold_g",
+				isp_params->ynryee_dirthreshold_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynryee_dirthreshold_width_log2",
+				isp_params->ynryee_dirthreshold_width_log2);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynryee_dirthreshold_width",
+				isp_params->ynryee_dirthreshold_width);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_detailgain",
+				isp_params->yee_detailgain);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_coring_s",
+				isp_params->yee_coring_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_coring_g",
+				isp_params->yee_coring_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_scale_plus_s",
+				isp_params->yee_scale_plus_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_scale_plus_g",
+				isp_params->yee_scale_plus_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_scale_minus_s",
+				isp_params->yee_scale_minus_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_scale_minus_g",
+				isp_params->yee_scale_minus_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_clip_plus_s",
+				isp_params->yee_clip_plus_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_clip_plus_g",
+				isp_params->yee_clip_plus_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_clip_minus_s",
+				isp_params->yee_clip_minus_s);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"yee_clip_minus_g",
+				isp_params->yee_clip_minus_g);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ynryee_Yclip",
+				isp_params->ynryee_Yclip);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_CSC)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		int	i;
+		for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
+			sh_css_dtrace(SH_DBG_DEBUG, "Color Space Conversion [%d]:\n",i);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m_shift",
+				isp_params->csc_kernel_param[i].m_shift);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m00",
+				isp_params->csc_kernel_param[i].m00);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m01",
+				isp_params->csc_kernel_param[i].m01);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m02",
+				isp_params->csc_kernel_param[i].m02);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m10",
+				isp_params->csc_kernel_param[i].m10);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m11",
+				isp_params->csc_kernel_param[i].m11);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m12",
+				isp_params->csc_kernel_param[i].m12);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m20",
+				isp_params->csc_kernel_param[i].m20);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m21",
+				isp_params->csc_kernel_param[i].m21);
+			sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"m22",
+				isp_params->csc_kernel_param[i].m22);
+		}
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_GC)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Gamma Correction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"gamma_gain_k1", isp_params->gamma_gain_k1);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"gamma_gain_k2", isp_params->gamma_gain_k2);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_TNR)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Temporal Noise Reduction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"tnr_coef", isp_params->tnr_coef);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"tnr_threshold_Y", isp_params->tnr_threshold_Y);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"tnr_threshold_C", isp_params->tnr_threshold_C);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_ANR)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Advance Noise Reduction:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"anr_threshold", isp_params->anr_threshold);
+	}
+	if ((enable & SH_CSS_DEBUG_DUMP_CE)
+			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
+		sh_css_dtrace(SH_DBG_DEBUG, "Chroma Enhancement:\n");
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ce_uv_level_min", isp_params->ce_uv_level_min);
+		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
+				"ce_uv_level_max", isp_params->ce_uv_level_max);
+	}
+}
+
+
+
+/*
+
+void sh_css_init_ddr_debug_queue(void)
+{
+	hrt_vaddress ddr_debug_queue_addr =
+			mmgr_malloc(sizeof(debug_data_ddr_t));
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_debug_buffer_ddr_address;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_debug_buffer_ddr_address =
+			fw->info.sp.debug_buffer_ddr_address;
+
+	(void)HIVE_ADDR_debug_buffer_ddr_address;
+
+	debug_buffer_ddr_init(ddr_debug_queue_addr);
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(debug_buffer_ddr_address),
+		(uint32_t)(ddr_debug_queue_addr));
+}
+
+void sh_css_load_ddr_debug_queue(void)
+{
+	debug_synch_queue_ddr();
+}
+
+void sh_css_dump_ddr_debug_queue(void)
+{
+	int i;
+	sh_css_load_ddr_debug_queue();
+#ifdef __KERNEL__
+	for (i = 0; i < DEBUG_BUF_SIZE; i++)
+		printk(KERN_DEBUG, "ddr_debug_queue[%d] = 0x%x\n",
+				i, debug_data_ptr->buf[i]);
+#else
+	for (i = 0; i < DEBUG_BUF_SIZE; i++)
+		printf("ddr_debug_queue[%d] = 0x%x\n",
+				i, debug_data_ptr->buf[i]);
+#endif
+}
+*/
+
+/**
+ * @brief Initialize the debug mode.
+ * Refer to "sh_css_debug.h" for more details.
+ */
+bool
+sh_css_debug_mode_init(void)
+{
+	bool rc;
+	rc = sh_css_sp_init_dma_sw_reg(0);
+	return	rc;
+}
+
+/**
+ * @brief Disable the DMA channel.
+ * Refer to "sh_css_debug.h" for more details.
+ */
+bool
+sh_css_debug_mode_disable_dma_channel(int dma_id,
+		int channel_id,
+		int request_type)
+{
+	bool rc;
+
+	rc = sh_css_sp_set_dma_sw_reg(dma_id,
+			channel_id,
+			request_type,
+			false);
+
+	return rc;
+}
+
+/**
+ * @brief Enable the DMA channel.
+ * Refer to "sh_css_debug.h" for more details.
+ */
+bool
+sh_css_debug_mode_enable_dma_channel(int dma_id,
+		int channel_id,
+		int request_type)
+{
+	bool rc;
+
+	rc = sh_css_sp_set_dma_sw_reg(dma_id,
+			channel_id,
+			request_type,
+			true);
+
+	return rc;
+}
+
+static bool debug_pipe_graph_do_init = true;
+
+static const char *format2str[] = {
+	/*[IA_CSS_FRAME_FORMAT_NV11]          =*/ "NV11",
+	/*[IA_CSS_FRAME_FORMAT_NV12]          =*/ "NV12",
+	/*[IA_CSS_FRAME_FORMAT_NV16]          =*/ "NV16",
+	/*[IA_CSS_FRAME_FORMAT_NV21]          =*/ "NV21",
+	/*[IA_CSS_FRAME_FORMAT_NV61]          =*/ "NV61",
+	/*[IA_CSS_FRAME_FORMAT_YV12]          =*/ "YV12",
+	/*[IA_CSS_FRAME_FORMAT_YV16]          =*/ "YV16",
+	/*[IA_CSS_FRAME_FORMAT_YUV420]        =*/ "YUV420",
+	/*[IA_CSS_FRAME_FORMAT_YUV420_16]     =*/ "YUV420_16",
+	/*[IA_CSS_FRAME_FORMAT_YUV422]        =*/ "YUV422",
+	/*[IA_CSS_FRAME_FORMAT_YUV422_16]     =*/ "YUV422_16",
+	/*[IA_CSS_FRAME_FORMAT_UYVY]          =*/ "UYVY",
+	/*[IA_CSS_FRAME_FORMAT_YUYV]          =*/ "YUYV",
+	/*[IA_CSS_FRAME_FORMAT_YUV444]        =*/ "YUV444",
+	/*[IA_CSS_FRAME_FORMAT_YUV_LINE]      =*/ "YUV_LINE",
+	/*[IA_CSS_FRAME_FORMAT_RAW]           =*/ "RAW",
+	/*[IA_CSS_FRAME_FORMAT_RGB565]        =*/ "RGB565",
+	/*[IA_CSS_FRAME_FORMAT_PLANAR_RGB888] =*/ "PLANAR_RGB888",
+	/*[IA_CSS_FRAME_FORMAT_RGBA888]       =*/ "RGBA888",
+	/*[IA_CSS_FRAME_FORMAT_QPLANE6]       =*/ "QPLANE6",
+	/*[IA_CSS_FRAME_FORMAT_BINARY_8]      =*/ "BINARY_8"
+};
+
+#define DPG_START "sh_css_pipe_graph_dump_start "
+#define DPG_END   " sh_css_pipe_graph_dump_end\n"
+
+#if 0
+//STORAGE_CLASS_INLINE void
+#define dtrace_dot(fmt, args...) \
+	sh_css_dtrace(SH_DBG_INFO, "%s", DPG_START); \
+	sh_css_vdtrace(SH_DBG_INFO, fmt, ## args); \
+	sh_css_dtrace(SH_DBG_INFO, "%s", DPG_END); \
+#ifdef HRT_CSIM \
+	sh_css_dtrace(SH_DBG_INFO, "%s", DPG_START); \
+	sh_css_vdtrace(SH_DBG_INFO, fmt, ## args); \
+	sh_css_dtrace(SH_DBG_INFO, "%s", DPG_END); \
+#endif 
+//	va_end(ap);
+#else
+#define dtrace_dot(fmt, args...) 
+#endif
+
+void
+sh_css_debug_pipe_graph_dump_prologue(void)
+{
+
+	dtrace_dot("digraph sh_css_pipe_graph {" );
+	dtrace_dot("rankdir=LR;" );
+}
+
+void
+sh_css_debug_pipe_graph_dump_epilogue(void)
+{
+
+	dtrace_dot("}");
+	debug_pipe_graph_do_init = true;
+}
+
+void
+sh_css_debug_pipe_graph_dump_stage(
+	struct sh_css_pipeline_stage *stage,
+	enum ia_css_pipe_id id)
+{
+
+	char const *blob_name = "<unknow name>";
+	char const *bin_type = "<unknow type>";
+
+	if (debug_pipe_graph_do_init) {
+		sh_css_debug_pipe_graph_dump_prologue();
+		debug_pipe_graph_do_init = false;
+	}
+
+	if (stage->binary) {
+		bin_type= "binary";
+		if (stage->binary_info->blob)
+			blob_name = stage->binary_info->blob->name;
+	} else if (stage->firmware){
+		bin_type= "firmware";
+		blob_name =
+			(char const *)IA_CSS_EXT_ISP_PROG_NAME(stage->firmware);
+	}
+
+	dtrace_dot("node [shape = circle, fixedsize=true, width=2, "
+		"label=\"%s\\n%s\\np:%d, s:%d\"]; \"%s_%d\"",
+		bin_type, blob_name, id, stage->stage_num, blob_name, id);
+
+	if (stage->args.cc_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.cc_frame),
+			format2str[stage->args.cc_frame->info.format],
+			stage->args.cc_frame->info.res.width,
+			stage->args.cc_frame->info.padded_width,
+			stage->args.cc_frame->info.res.height,
+			stage->args.cc_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"0x%08lx\"->\"%s_%d\" "
+			"[label = in_frame];",
+			HOST_ADDRESS(stage->args.cc_frame), blob_name, id);
+
+
+	} else if (stage->args.in_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.in_frame),
+			format2str[stage->args.in_frame->info.format],
+			stage->args.in_frame->info.res.width,
+			stage->args.in_frame->info.padded_width,
+			stage->args.in_frame->info.res.height,
+			stage->args.in_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"0x%08lx\"->\"%s_%d\" "
+			"[label = in_frame];",
+			HOST_ADDRESS(stage->args.in_frame), blob_name, id);
+	}
+
+	if (stage->args.in_ref_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.in_ref_frame),
+			format2str[stage->args.in_ref_frame->info.format],
+			stage->args.in_ref_frame->info.res.width,
+			stage->args.in_ref_frame->info.padded_width,
+			stage->args.in_ref_frame->info.res.height,
+			stage->args.in_ref_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"0x%08lx\"->\"%s_%d\" "
+			"[label = in_ref_frame];",
+			HOST_ADDRESS(stage->args.in_ref_frame), blob_name, id);
+	}
+
+	if (stage->args.in_tnr_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.in_tnr_frame),
+			format2str[stage->args.in_tnr_frame->info.format],
+			stage->args.in_tnr_frame->info.res.width,
+			stage->args.in_tnr_frame->info.padded_width,
+			stage->args.in_tnr_frame->info.res.height,
+			stage->args.in_tnr_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"0x%08lx\"->\"%s_%d\" "
+			"[label = in_tnr_frame];",
+			HOST_ADDRESS(stage->args.in_tnr_frame), blob_name, id);
+	}
+
+	if (stage->args.out_ref_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.out_ref_frame),
+			format2str[stage->args.out_ref_frame->info.format],
+			stage->args.out_ref_frame->info.res.width,
+			stage->args.out_ref_frame->info.padded_width,
+			stage->args.out_ref_frame->info.res.height,
+			stage->args.out_ref_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"%s_%d\"->\"0x%08lx\" "
+			"[label = out_ref_frame];",
+			blob_name, id, HOST_ADDRESS(stage->args.out_ref_frame));
+	}
+
+	if (stage->args.out_tnr_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.out_tnr_frame),
+			format2str[stage->args.out_tnr_frame->info.format],
+			stage->args.out_tnr_frame->info.res.width,
+			stage->args.out_tnr_frame->info.padded_width,
+			stage->args.out_tnr_frame->info.res.height,
+			stage->args.out_tnr_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"%s_%d\"->\"0x%08lx\" "
+			"[label = out_tnr_frame];",
+			blob_name, id, HOST_ADDRESS(stage->args.out_tnr_frame));
+	}
+
+	if (stage->args.out_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.out_frame),
+			format2str[stage->args.out_frame->info.format],
+			stage->args.out_frame->info.res.width,
+			stage->args.out_frame->info.padded_width,
+			stage->args.out_frame->info.res.height,
+			stage->args.out_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"%s_%d\"->\"0x%08lx\" "
+			"[label = out_frame];",
+			blob_name, id, HOST_ADDRESS(stage->args.out_frame));
+	}
+
+	if (stage->args.out_vf_frame) {
+		dtrace_dot(
+			"node [shape = box, "
+			"fixedsize=true, width=2]; \"0x%08lx\" "
+			"[label = \"%s\\n%d(%d) x %d x %d\"];",
+			HOST_ADDRESS(stage->args.out_vf_frame),
+			format2str[stage->args.out_vf_frame->info.format],
+			stage->args.out_vf_frame->info.res.width,
+			stage->args.out_vf_frame->info.padded_width,
+			stage->args.out_vf_frame->info.res.height,
+			stage->args.out_vf_frame->info.raw_bit_depth);
+		dtrace_dot(
+			"\"%s_%d\"->\"0x%08lx\" "
+			"[label = out_vf_frame];",
+			blob_name, id, HOST_ADDRESS(stage->args.out_vf_frame));
+	}
+
+}
+
+void
+sh_css_debug_pipe_graph_dump_sp_raw_copy(
+	struct ia_css_frame *cc_frame)
+{
+	dtrace_dot(
+		"node [shape = circle, "
+		"fixedsize=true, width=2]; \"%s\"",
+		"sp_raw_copy_1");
+
+	dtrace_dot("node [shape = circle, fixedsize=true, width=2, "
+		"label=\"%s\\n%s\\np:%d, s:%d\"]; \"%s_%d\"",
+		"sp-binary", "sp_raw_copy", 1, 0, "sp_raw_copy", 1);
+
+
+	dtrace_dot(
+		"node [shape = box, "
+		"fixedsize=true, width=2]; \"0x%08lx\" "
+		"[label = \"%s\\n%d(%d) x %d x %d\"];",
+		HOST_ADDRESS(cc_frame),
+		format2str[cc_frame->info.format],
+		cc_frame->info.res.width,
+		cc_frame->info.padded_width,
+		cc_frame->info.res.height,
+		cc_frame->info.raw_bit_depth);
+
+
+	dtrace_dot(
+		"\"%s_%d\"->\"0x%08lx\" "
+		"[label = cc_frame];",
+		"sp_raw_copy", 1, HOST_ADDRESS(cc_frame));
+
+}
+
+
+
+#if defined(HRT_SCHED) || defined(SH_CSS_DEBUG_SPMEM_DUMP_SUPPORT)
+#ifdef SYSTEM_hive_isp_css_2400_system
+#include "spmem_dump.c"
+#else
+#include "spmem_dumpA0.c"
+#endif
+#endif
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_debug.h b/drivers/media/atomisp2/css2400/sh_css_debug.h
new file mode 100644
index 0000000..d0910b8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_debug.h
@@ -0,0 +1,292 @@
+#ifndef _SH_CSS_DEBUG_H_
+#define _SH_CSS_DEBUG_H_
+
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+/*! \file */
+
+#include "ia_css.h"
+#include "sh_css_internal.h"
+
+/* available levels */
+/*! Level for tracing errors */
+#define SH_DBG_ERROR   1
+/*! Level for tracing warnings */
+#define SH_DBG_WARNING 3
+/*! Level for tracing debug messages */
+#define SH_DBG_DEBUG   5
+/*! Level for tracing trace messages a.o. sh_css public function calls */
+#define SH_DBG_TRACE   6
+/*! Level for tracing trace messages a.o. sh_css private function calls */
+#define SH_DBG_TRACE_PRIVATE   7
+/*! Level for tracing parameter messages e.g. in and out params of functions */
+#define SH_DBG_PARAM   8
+/*! Level for tracing info messages */
+#define SH_DBG_INFO    9
+/* Global variable which controls the verbosity levels of the debug tracing */
+extern unsigned int sh_css_trace_level;
+
+/*! \brief Function for tracing to the provided printf function in the environment.
+ * \param[in]	level		Level of the message.
+ * \param[in]	format		printf like format string
+ * \param[in]	args		arguments for the format string
+ */
+#if 0
+STORAGE_CLASS_INLINE void
+sh_css_vdtrace(unsigned int level, const char *fmt, va_list args)
+{
+	if (sh_css_trace_level >= level)
+		sh_css_vprint(fmt, args);
+}
+
+STORAGE_CLASS_INLINE void
+sh_css_dtrace(unsigned int level, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	sh_css_vdtrace(level, fmt, ap);
+	va_end(ap);
+}
+#else
+
+#define sh_css_dtrace(level, format, args...)          \
+        do {                                           \
+                if (sh_css_trace_level >= level)       \
+                        printk(KERN_ALERT format, ## args); \
+        } while (0)
+
+#define sh_css_vdtrace(level, format, args...)          \
+        if (sh_css_trace_level >= level)       \
+                sh_css_vprint(format, ## args);
+#endif
+
+
+
+/*! \brief Enum defining the different isp parameters to dump.
+ *  Values can be combined to dump a combination of sets.
+ */
+enum sh_css_debug_enable_param_dump {
+	SH_CSS_DEBUG_DUMP_FPN = 1 << 0, /**< FPN table */
+	SH_CSS_DEBUG_DUMP_OB = 1 << 1,  /**< OB table */
+	SH_CSS_DEBUG_DUMP_SC = 1 << 2,  /**< Shading table */
+	SH_CSS_DEBUG_DUMP_WB = 1 << 3,  /**< White balance */
+	SH_CSS_DEBUG_DUMP_DP = 1 << 4,  /**< Defect Pixel */
+	SH_CSS_DEBUG_DUMP_BNR = 1 << 5,  /**< Bayer Noise Reductions */
+	SH_CSS_DEBUG_DUMP_S3A = 1 << 6,  /**< 3A Statistics */
+	SH_CSS_DEBUG_DUMP_DE = 1 << 7,  /**< De Mosaicing */
+	SH_CSS_DEBUG_DUMP_YNR = 1 << 8,  /**< Luma Noise Reduction */
+	SH_CSS_DEBUG_DUMP_CSC = 1 << 9,  /**< Color Space Conversion */
+	SH_CSS_DEBUG_DUMP_GC = 1 << 10,  /**< Gamma Correction */
+	SH_CSS_DEBUG_DUMP_TNR = 1 << 11,  /**< Temporal Noise Reduction */
+	SH_CSS_DEBUG_DUMP_ANR = 1 << 12,  /**< Advanced Noise Reduction */
+	SH_CSS_DEBUG_DUMP_CE = 1 << 13,  /**< Chroma Enhancement */
+	SH_CSS_DEBUG_DUMP_ALL = 1 << 14  /**< Dump all device parameters */
+};
+
+
+/*! \brief Function to set the global dtrace verbosity level.
+ * \param[in]	trace_level		Maximum level of the messages to be traced.
+ * \return	None
+ */
+void sh_css_set_dtrace_level(
+	const unsigned int	trace_level);
+
+/*! \brief Dump input formatter state.
+ * Dumps the input formatter state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_if_state(void);
+
+/*! \brief Dump isp hardware state.
+ * Dumps the isp hardware state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_isp_state(void);
+
+/*! \brief Dump sp hardware state.
+ * Dumps the sp hardware state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_sp_state(void);
+
+/*! \brief Dump dma controller state.
+ * Dumps the dma controller state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_dma_state(void);
+
+/*! \brief Dump internal sp software state.
+ * Dumps the sp software state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_sp_sw_debug_info(void);
+
+/*! \brief Dump all related hardware state to the trace output
+ * \param[in]  context	String to identify context in output.
+ * \return	None
+ */
+extern void sh_css_dump_debug_info(
+	const char	*context);
+
+void
+sh_css_sp_debug_dump_mipi_fifo_high_water(void);
+
+/*! \brief Dump isp gdc fifo state to the trace output
+ * Dumps the isp gdc fifo state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_isp_gdc_fifo_state(void);
+
+/*! \brief Dump dma isp fifo state
+ * Dumps the dma isp fifo state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_dma_isp_fifo_state(void);
+
+/*! \brief Dump dma sp fifo state
+ * Dumps the dma sp fifo state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_dma_sp_fifo_state(void);
+
+/*! \brief Dump pif isp fifo state
+ * Dumps the primary input formatter state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_pif_isp_fifo_state(void);
+
+/*! \brief Dump isp sp fifo state
+ * Dumps the isp sp fifo state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_isp_sp_fifo_state(void);
+
+/*! \brief Dump all fifo state info to the output
+ * Dumps all fifo state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_all_fifo_state(void);
+
+/*! \brief Dump the rx state to the output
+ * Dumps the rx state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_rx_state(void);
+
+/*! \brief Dump the input system state to the output
+ * Dumps the input system state to tracing output.
+ * \return	None
+ */
+extern void sh_css_dump_isys_state(void);
+
+/*! \brief Dump the frame info to the trace output
+ * Dumps the frame info to tracing output.
+ * \param[in]	frame		pointer to struct ia_css_frame
+ * \param[in]	descr		description output along with the frame info
+ * \return	None
+ */
+extern void sh_css_frame_print(
+	const struct ia_css_frame	*frame,
+	const char	*descr);
+
+/*! \brief Function to enable sp sleep mode.
+ * Function that enables sp sleep mode
+ * \param[in]	mode		indicates when to put sp to sleep
+ * \return	None
+ */
+extern void
+sh_css_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode);
+
+/*! \brief Function to wake up sp when in sleep mode.
+ * After sp has been put to sleep, use this function to let it continue
+ * to run again.
+ * \return	None
+ */
+extern void
+sh_css_wake_up_sp(void);
+
+/*! \brief Function to dump isp parameters.
+ * Dump isp parameters to tracing output
+ * \param[in]	enable		flag indicating which parameters to dump.
+ * \return	None
+ */
+extern void
+sh_css_dump_isp_params(struct ia_css_stream *stream, unsigned int enable);
+
+/*
+extern void sh_css_init_ddr_debug_queue(void);
+extern void sh_css_load_ddr_debug_queue(void);
+extern void sh_css_dump_ddr_debug_queue(void); */
+
+/**
+ * @brief Initialize the debug mode.
+ *
+ * WARNING:
+ * This API should be called ONLY once in the debug mode.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_debug_mode_init(void);
+
+/**
+ * @brief Disable the DMA channel.
+ *
+ * @param[in]	dma_ID		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ * This is part of the DMA API -> dma.h
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_debug_mode_disable_dma_channel(
+	int dma_ID,
+		int channel_id,
+		int request_type);
+/**
+ * @brief Enable the DMA channel.
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_debug_mode_enable_dma_channel(
+	int dma_ID,
+		int channel_id,
+		int request_type);
+
+#endif /* _SH_CSS_DEBUG_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_debug_internal.h b/drivers/media/atomisp2/css2400/sh_css_debug_internal.h
new file mode 100644
index 0000000..0b0366b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_debug_internal.h
@@ -0,0 +1,67 @@
+#ifndef _SH_CSS_DEBUG_INTERNAL_H_
+#define _SH_CSS_DEBUG_INTERNAL_H_
+
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+/*! \file */
+
+#include "ia_css.h"
+#include "sh_css_internal.h"
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ *
+ * @return	None
+ */
+extern void sh_css_debug_pipe_graph_dump_prologue(void);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ *
+ * @return	None
+ */
+extern void sh_css_debug_pipe_graph_dump_epilogue(void);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ * @param[in]	stage		Pipeline stage.
+ * @param[in]	id		Pipe id.
+ *
+ * @return	None
+ */
+extern void sh_css_debug_pipe_graph_dump_stage(
+		struct sh_css_pipeline_stage *stage,
+		enum ia_css_pipe_id id);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ * @param[in]	cc_frame	Output frame of SP raw copy.
+ *
+ * @return	None
+ */
+extern void sh_css_debug_pipe_graph_dump_sp_raw_copy(
+		struct ia_css_frame *cc_frame);
+
+
+
+#endif /* _SH_CSS_DEBUG_INTERNAL_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_defs.h b/drivers/media/atomisp2/css2400/sh_css_defs.h
new file mode 100644
index 0000000..e08e1c2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_defs.h
@@ -0,0 +1,423 @@
+#ifndef _SH_CSS_DEFS_H_
+#define _SH_CSS_DEFS_H_
+
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "isp.h"
+/*#include "vamem.h"*/ /* Cannot include for VAMEM properties this file is visible on ISP -> pipeline generator */
+
+/* System dependent versions
+   ia_css_types.h exports a system independent version. MW: Yeah, really...
+*/
+#if defined(HAS_VAMEM_VERSION_2)
+#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_CTC_TABLE_SIZE            IA_CSS_VAMEM_2_CTC_TABLE_SIZE
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2     IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE          IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE
+#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_XNR_TABLE_SIZE            IA_CSS_VAMEM_2_XNR_TABLE_SIZE
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE      IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE
+#elif defined(HAS_VAMEM_VERSION_1)
+#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2       IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_CTC_TABLE_SIZE            IA_CSS_VAMEM_1_CTC_TABLE_SIZE
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2     IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE          IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE
+#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2       IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_XNR_TABLE_SIZE            IA_CSS_VAMEM_1_XNR_TABLE_SIZE
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE      IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE
+#else
+#error "sh_css_defs: Unknown VAMEM version"
+#endif
+
+#include"math_support.h"	/* max(), min, etc etc */
+
+/* Digital Image Stabilization */
+#define SH_CSS_DIS_DECI_FACTOR_LOG2       6
+
+/* UV offset: 1:uv=-128...127, 0:uv=0...255 */
+#define SH_CSS_UV_OFFSET_IS_0             0
+
+/* Bits of bayer is adjusted as 13 in ISP */
+#define SH_CSS_BAYER_BITS                 13
+/* Max value of bayer data (unsigned 13bit in ISP) */
+#define SH_CSS_BAYER_MAXVAL               ((1U << SH_CSS_BAYER_BITS) - 1)
+
+/* Bits of yuv in ISP */
+#define SH_CSS_ISP_YUV_BITS               8
+
+#define SH_CSS_DP_GAIN_SHIFT              5
+#define SH_CSS_BNR_GAIN_SHIFT             13
+#define SH_CSS_YNR_GAIN_SHIFT             13
+#define SH_CSS_AE_YCOEF_SHIFT             13
+#define SH_CSS_AF_FIR_SHIFT               13
+#define SH_CSS_YEE_DETAIL_GAIN_SHIFT      8  /* [u5.8] */
+#define SH_CSS_YEE_SCALE_SHIFT            8
+#define SH_CSS_TNR_COEF_SHIFT                    13
+#define SH_CSS_MACC_COEF_SHIFT            11 /* [s2.11] */
+#define SH_CSS_DIS_COEF_SHIFT             13
+
+/*--------------- sRGB Gamma -----------------
+CCM        : YCgCo[0,8191] -> RGB[0,4095]
+sRGB Gamma : RGB  [0,4095] -> RGB[0,8191]
+CSC        : RGB  [0,8191] -> YUV[0,8191]
+
+CCM:
+Y[0,8191],CgCo[-4096,4095],coef[-8192,8191] -> RGB[0,4095]
+
+sRGB Gamma:
+RGB[0,4095] -(interpolation step16)-> RGB[0,255] -(LUT 12bit)-> RGB[0,4095] -> RGB[0,8191]
+
+CSC:
+RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
+--------------------------------------------*/
+/* Bits of input/output of sRGB Gamma */
+#define SH_CSS_RGB_GAMMA_INPUT_BITS       12 /* [0,4095] */
+#define SH_CSS_RGB_GAMMA_OUTPUT_BITS      13 /* [0,8191] */
+
+/* Bits of fractional part of interpolation in vamem, [0,4095]->[0,255] */
+#define SH_CSS_RGB_GAMMA_FRAC_BITS        \
+	(SH_CSS_RGB_GAMMA_INPUT_BITS - SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2)
+#define SH_CSS_RGB_GAMMA_ONE              (1 << SH_CSS_RGB_GAMMA_FRAC_BITS)
+
+/* Bits of input of CCM,  = 13, Y[0,8191],CgCo[-4096,4095] */
+#define SH_CSS_YUV2RGB_CCM_INPUT_BITS     SH_CSS_BAYER_BITS
+
+/* Bits of output of CCM,  = 12, RGB[0,4095] */
+#define SH_CSS_YUV2RGB_CCM_OUTPUT_BITS    SH_CSS_RGB_GAMMA_INPUT_BITS
+
+/* Bits of fractional part of coefficient of CCM, =12, [-1,1]=[-4096,4096] */
+#define SH_CSS_YUV2RGB_CCM_COEF_SHIFT     12
+
+/* Bits of shift in calculation of CCM, =12, [-1,1]=[-4096,4096] */
+#define SH_CSS_YUV2RGB_CCM_CALC_SHIFT     (SH_CSS_YUV2RGB_CCM_COEF_SHIFT \
+	+ (SH_CSS_YUV2RGB_CCM_INPUT_BITS - SH_CSS_YUV2RGB_CCM_OUTPUT_BITS))
+
+/* Maximum value of output of CCM */
+#define SH_CSS_YUV2RGB_CCM_MAX_OUTPUT     \
+	((1 << SH_CSS_YUV2RGB_CCM_OUTPUT_BITS) - 1)
+
+/* Bits of fractional part of coefficient of CSC */
+#define SH_CSS_RGB2YUV_CSC_COEF_SHIFT     13
+
+#define SH_CSS_NUM_INPUT_BUF_LINES        4
+
+/* Left cropping only applicable for sufficiently large nway */
+#if ISP_VEC_NELEMS == 16
+#define SH_CSS_MAX_LEFT_CROPPING          0
+#else
+#define SH_CSS_MAX_LEFT_CROPPING          12
+#endif
+
+#define	SH_CSS_SP_MAX_WIDTH               1280
+
+/* This is the maximum grid we can handle in the ISP binaries.
+ * The host code makes sure no bigger grid is ever selected. */
+#define SH_CSS_MAX_BQ_GRID_WIDTH          80
+#define SH_CSS_MAX_BQ_GRID_HEIGHT         60
+
+/* The minimum dvs envelope is 8x8 to make sure the invalid rows/columns
+   that result from filter initialization are skipped. */
+#define SH_CSS_MIN_DVS_ENVELOPE           12
+
+/* The FPGA system (vec_nelems == 16) only supports upto 5MP */
+#if ISP_VEC_NELEMS == 16
+#define SH_CSS_MAX_SENSOR_WIDTH           2560
+#define SH_CSS_MAX_SENSOR_HEIGHT          1920
+#else
+#define SH_CSS_MAX_SENSOR_WIDTH           4608
+#define SH_CSS_MAX_SENSOR_HEIGHT          3450
+#endif
+
+/* Limited to reduce vmem pressure */
+#if ISP_VMEM_DEPTH >= 3072
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT SH_CSS_MAX_SENSOR_HEIGHT
+#else
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  3264
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT 2448
+#endif
+
+/*
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  4224
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC 3168
+*/
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC SH_CSS_MAX_SENSOR_HEIGHT
+
+#define SH_CSS_MIN_SENSOR_WIDTH           2
+#define SH_CSS_MIN_SENSOR_HEIGHT          2
+
+#if defined(IS_ISP_2400_SYSTEM)
+#define SH_CSS_MAX_VF_WIDTH               1920
+#define SH_CSS_MAX_VF_HEIGHT              1080
+#else
+#define SH_CSS_MAX_VF_WIDTH               1280
+#define SH_CSS_MAX_VF_HEIGHT              960
+#endif
+/*
+#define SH_CSS_MAX_VF_WIDTH_DEC               1920
+#define SH_CSS_MAX_VF_HEIGHT_DEC              1080
+*/
+#define SH_CSS_MAX_VF_WIDTH_DEC               SH_CSS_MAX_VF_WIDTH
+#define SH_CSS_MAX_VF_HEIGHT_DEC              SH_CSS_MAX_VF_HEIGHT
+
+/* We use 16 bits per coordinate component, including integer
+   and fractional bits */
+#define SH_CSS_MORPH_TABLE_GRID               ISP_VEC_NELEMS
+#define SH_CSS_MORPH_TABLE_ELEM_BYTES         2
+#define SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD \
+	(HIVE_ISP_DDR_WORD_BYTES/SH_CSS_MORPH_TABLE_ELEM_BYTES)
+
+#define SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR   (SH_CSS_MAX_BQ_GRID_WIDTH + 1)
+#define SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR   (SH_CSS_MAX_BQ_GRID_HEIGHT + 1)
+#define SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR \
+	CEIL_MUL(SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR, ISP_VEC_NELEMS)
+
+/* Each line of this table is aligned to the maximum line width. */
+#define SH_CSS_MAX_S3ATBL_WIDTH              SH_CSS_MAX_BQ_GRID_WIDTH
+
+/* Rules: these implement logic shared between the host code and ISP firmware.
+   The ISP firmware needs these rules to be applied at pre-processor time,
+   that's why these are macros, not functions. */
+#define _ISP_BQS(num)  ((num)/2)
+#define _ISP_VECS(width) CEIL_DIV(width, ISP_VEC_NELEMS)
+
+#define ISP_BQ_GRID_WIDTH(elements_per_line, deci_factor_log2) \
+	CEIL_SHIFT(elements_per_line/2,  deci_factor_log2)
+#define ISP_BQ_GRID_HEIGHT(lines_per_frame, deci_factor_log2) \
+	CEIL_SHIFT(lines_per_frame/2,  deci_factor_log2)
+#define ISP_C_VECTORS_PER_LINE(elements_per_line) \
+	_ISP_VECS(elements_per_line/2)
+
+/* The morphing table is similar to the shading table in the sense that we
+   have 1 more value than we have cells in the grid. */
+#define _ISP_MORPH_TABLE_WIDTH(int_width) \
+	(CEIL_DIV(int_width, SH_CSS_MORPH_TABLE_GRID) + 1)
+#define _ISP_MORPH_TABLE_HEIGHT(int_height) \
+	(CEIL_DIV(int_height, SH_CSS_MORPH_TABLE_GRID) + 1)
+#define _ISP_MORPH_TABLE_ALIGNED_WIDTH(width) \
+	CEIL_MUL(_ISP_MORPH_TABLE_WIDTH(width), \
+		 SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD)
+
+#define _ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
+	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + 1)
+#define _ISP_SCTBL_HEIGHT(input_height, deci_factor_log2) \
+	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + 1)
+#define _ISP_SCTBL_ALIGNED_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
+	CEIL_MUL(_ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2), \
+		 ISP_VEC_NELEMS)
+
+/* ********************************************************
+ * Statistics for Digital Image Stabilization
+ * ********************************************************/
+/* Some binaries put the vertical coefficients in DMEM instead
+   of VMEM to save VMEM. */
+#define _SDIS_VER_COEF_TBL_USE_DMEM(mode, enable_sdis, isp_pipe_version) \
+	(mode == SH_CSS_BINARY_MODE_VIDEO \
+	&& enable_sdis && isp_pipe_version == 1)
+
+/* For YUV upscaling, the internal size is used for DIS statistics */
+#define _ISP_SDIS_ELEMS_ISP(input, internal, enable_us) \
+	((enable_us) ? (internal) : (input))
+
+/* SDIS Number of Grid */
+#define _ISP_SDIS_HOR_GRID_NUM_ISP(in_width, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
+#define _ISP_SDIS_VER_GRID_NUM_ISP(in_height, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
+
+#define _ISP_SDIS_HOR_GRID_NUM_3A(in_width, deci_factor_log2) \
+	(_ISP_BQS(in_width) >> deci_factor_log2)
+#define _ISP_SDIS_VER_GRID_NUM_3A(in_height, deci_factor_log2) \
+	(_ISP_BQS(in_height) >> deci_factor_log2)
+
+/* SDIS Projections:
+ * SDIS1: Horizontal projections are calculated for each line.
+ * Vertical projections are calculated for each column.
+ * SDIS2: Projections are calculated for each grid cell.
+ * Grid cells that do not fall completely within the image are not
+ * valid. The host needs to use the bigger one for the stride but
+ * should only return the valid ones to the 3A. */
+#define __ISP_SDIS_HOR_PROJ_NUM_ISP(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2) : \
+		(CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) * \
+		 CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)))
+
+#define __ISP_SDIS_VER_PROJ_NUM_ISP(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) : \
+		(CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) * \
+		 CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)))
+
+#define _ISP_SDIS_HOR_PROJ_NUM_3A(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		(_ISP_BQS(in_height) >> deci_factor_log2) : \
+		((_ISP_BQS(in_width) >> deci_factor_log2) * \
+		 (_ISP_BQS(in_height) >> deci_factor_log2)))
+
+#define _ISP_SDIS_VER_PROJ_NUM_3A(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		(_ISP_BQS(in_width) >> deci_factor_log2) : \
+		((_ISP_BQS(in_width) >> deci_factor_log2) * \
+		 (_ISP_BQS(in_height) >> deci_factor_log2)))
+
+/* SDIS Coefficients: */
+/* The ISP uses vectors to store the coefficients, so we round
+   the number of coefficients up to vectors. */
+#define __ISP_SDIS_HOR_COEF_NUM_VECS(in_width)  _ISP_VECS(_ISP_BQS(in_width))
+#define __ISP_SDIS_VER_COEF_NUM_VECS(in_height) _ISP_VECS(_ISP_BQS(in_height))
+
+/* The number of coefficients produced by the ISP */
+#define _ISP_SDIS_HOR_COEF_NUM_ISP(in_width) \
+	(__ISP_SDIS_HOR_COEF_NUM_VECS(in_width) * ISP_VEC_NELEMS)
+#define _ISP_SDIS_VER_COEF_NUM_ISP(in_height) \
+	(__ISP_SDIS_VER_COEF_NUM_VECS(in_height) * ISP_VEC_NELEMS)
+
+/* The number of coefficients used by the 3A library. This excludes
+   coefficients from grid cells that do not fall completely within the image. */
+#define _ISP_SDIS_HOR_COEF_NUM_3A(in_width, deci_factor_log2) \
+	((_ISP_BQS(in_width) >> deci_factor_log2) << deci_factor_log2)
+#define _ISP_SDIS_VER_COEF_NUM_3A(in_height, deci_factor_log2) \
+	((_ISP_BQS(in_height) >> deci_factor_log2) << deci_factor_log2)
+
+/* *****************************************************************
+ * Statistics for 3A (Auto Focus, Auto White Balance, Auto Exposure)
+ * *****************************************************************/
+/* if left cropping is used, 3A statistics are also cropped by 2 vectors. */
+#define _ISP_S3ATBL_WIDTH(in_width, deci_factor_log2) \
+	(_ISP_BQS(in_width) >> deci_factor_log2)
+#define _ISP_S3ATBL_HEIGHT(in_height, deci_factor_log2) \
+	(_ISP_BQS(in_height) >> deci_factor_log2)
+
+#define _ISP_S3A_ELEMS_ISP_WIDTH(in_width, int_width, enable_hus, left_crop) \
+	(((enable_hus) ? (int_width) : (in_width)) \
+	 - ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
+#define _ISP_S3A_ELEMS_ISP_HEIGHT(in_height, int_height, enable_vus) \
+	((enable_vus) ? (int_height) : (in_height))
+
+#define _ISP_S3ATBL_ISP_WIDTH(in_width, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
+#define _ISP_S3ATBL_ISP_HEIGHT(in_height, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
+#define ISP_S3ATBL_VECTORS \
+	_ISP_VECS(SH_CSS_MAX_S3ATBL_WIDTH * \
+		  (sizeof(struct ia_css_3a_output)/sizeof(int)))
+#define ISP_S3ATBL_HI_LO_STRIDE \
+	(ISP_S3ATBL_VECTORS * ISP_VEC_NELEMS)
+#define ISP_S3ATBL_HI_LO_STRIDE_BYTES \
+	(sizeof(unsigned short) * ISP_S3ATBL_HI_LO_STRIDE)
+
+/* Viewfinder support */
+#define __ISP_MAX_VF_OUTPUT_WIDTH(width, left_crop) \
+	(width - 2*ISP_VEC_NELEMS + ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
+
+/* Number of vectors per vf line is determined by the chroma width,
+ * the luma width is derived from that. That's why we have the +1. */
+#define __ISP_VF_OUTPUT_WIDTH_VECS(out_width, vf_log_downscale) \
+	(_ISP_VECS((out_width) >> ((vf_log_downscale)+1)) * 2)
+
+#define _ISP_VF_OUTPUT_WIDTH(vf_out_vecs) ((vf_out_vecs) * ISP_VEC_NELEMS)
+#define _ISP_VF_OUTPUT_HEIGHT(out_height, vf_log_ds) \
+	((out_height) >> (vf_log_ds))
+
+#define _ISP_LOG_VECTOR_STEP(mode) \
+	((mode) == SH_CSS_BINARY_MODE_CAPTURE_PP ? 2 : 1)
+
+/* Rules for computing the internal width. This is extremely complicated
+ * and definitely needs to be commented and explained. */
+#define _ISP_LEFT_CROP_EXTRA(left_crop) ((left_crop) > 0 ? 2*ISP_VEC_NELEMS : 0)
+
+#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode) \
+	((num_chunks) * (pipelining) * (1<<_ISP_LOG_VECTOR_STEP(mode)) * \
+	 ISP_VEC_NELEMS)
+#define __ISP_PADDED_OUTPUT_WIDTH(out_width, dvs_env_width, left_crop) \
+	((out_width) + MAX(dvs_env_width, _ISP_LEFT_CROP_EXTRA(left_crop)))
+
+#define __ISP_CHUNK_STRIDE_ISP(mode) \
+	((1<<_ISP_LOG_VECTOR_STEP(mode)) * ISP_VEC_NELEMS)
+
+#define __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
+	((c_subsampling) * (num_chunks) * HIVE_ISP_DDR_WORD_BYTES)
+#if 0
+#define __ISP_RGBA_WIDTH(rgba, num_chunks) \
+	((rgba) ? (num_chunks)*4*2*ISP_VEC_NELEMS : 0)
+#else
+#define __ISP_RGBA_WIDTH(rgba, num_chunks) \
+	(0)
+#endif
+#define __ISP_INTERNAL_WIDTH(out_width, \
+			     dvs_env_width, \
+			     left_crop, \
+			     mode, \
+			     c_subsampling, \
+			     num_chunks, \
+			     pipelining, \
+			     rgba) \
+	CEIL_MUL2(CEIL_MUL2(MAX(MAX(__ISP_PADDED_OUTPUT_WIDTH(out_width, \
+							    dvs_env_width, \
+							    left_crop), \
+				  __ISP_MIN_INTERNAL_WIDTH(num_chunks, \
+							   pipelining, \
+							   mode) \
+				 ), \
+			      __ISP_RGBA_WIDTH(rgba, num_chunks) \
+			     ), \
+			  __ISP_CHUNK_STRIDE_ISP(mode) \
+			 ), \
+		 __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
+		)
+
+#define __ISP_INTERNAL_HEIGHT(out_height, dvs_env_height, top_crop) \
+	((out_height) + (dvs_env_height) + top_crop)
+
+/* @GC: Input can be up to sensor resolution when either bayer downscaling
+ *	or raw binning is enabled.
+ *	Also, during continuous mode, we need to align to 4*NWAY since input
+ *	should support binning */
+#define _ISP_MAX_INPUT_WIDTH(max_internal_width, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
+				enable_continuous) \
+	((enable_ds) ? \
+	   SH_CSS_MAX_SENSOR_WIDTH :\
+	 (enable_fixed_bayer_ds) ? \
+	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC,4*ISP_VEC_NELEMS) : \
+	 (enable_raw_bin) ? \
+	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH,4*ISP_VEC_NELEMS) : \
+	 (enable_continuous) ? \
+	   SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH \
+	   : max_internal_width)
+
+#define _ISP_INPUT_WIDTH(internal_width, ds_input_width, enable_ds) \
+	((enable_ds) ? (ds_input_width) : (internal_width))
+
+#define _ISP_INPUT_HEIGHT(internal_height, ds_input_height, enable_ds) \
+	((enable_ds) ? (ds_input_height) : (internal_height))
+
+#endif /* _SH_CSS_DEFS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_firmware.c b/drivers/media/atomisp2/css2400/sh_css_firmware.c
new file mode 100644
index 0000000..12ad11e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_firmware.c
@@ -0,0 +1,159 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "sh_css_firmware.h"
+
+#include "sh_css_defs.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp_start.h"
+
+#include "memory_access.h"
+
+#include "isp.h"				/* PMEM_WIDTH_LOG2 */
+
+struct ia_css_fw_info	  sh_css_sp_fw;
+struct ia_css_blob_descr *sh_css_blob_info; /* Only ISP blob info (no SP) */
+unsigned		  sh_css_num_binaries; /* This includes 1 SP binary */
+
+/*
+ * Split the loaded firmware into blobs
+ */
+
+/* Setup sp binary */
+static void
+setup_sp(struct ia_css_fw_info *fw, const char *fw_data)
+{
+	const char  *blob_data = fw_data + fw->blob.offset;
+
+	sh_css_sp_fw = *fw;
+	/* MW: code starts at "offset" */
+	sh_css_sp_fw.blob.code = blob_data /* + fw->blob.text_source */;
+	sh_css_sp_fw.blob.data = blob_data + fw->blob.data_source;
+}
+
+enum ia_css_err
+sh_css_load_firmware(const char *fw_data,
+		     unsigned int fw_size)
+{
+	unsigned i;
+	struct ia_css_fw_info *binaries;
+	struct sh_css_fw_bi_file_h *file_header;
+
+	file_header = (struct sh_css_fw_bi_file_h *)fw_data;
+	binaries = (struct ia_css_fw_info *)(&file_header[1]);
+
+	/* some sanity checks */
+	if (!fw_data || fw_size < sizeof(struct sh_css_fw_bi_file_h))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	if (file_header->h_size != sizeof(struct sh_css_fw_bi_file_h))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+#ifdef ATOMISP_FASTBOOT
+	sh_css_num_binaries = ATOMISP_BINARY_NUM;
+#else
+	sh_css_num_binaries = file_header->binary_nr;
+#endif
+	/* Only allocate memory for ISP blob info */
+	sh_css_blob_info = sh_css_malloc((sh_css_num_binaries - 1) *
+						sizeof(*sh_css_blob_info));
+
+	for (i = 0; i < sh_css_num_binaries; i++) {
+		struct ia_css_fw_info *bi = &binaries[i];
+		const char *name;
+
+		name = (const char *)fw_data + bi->blob.prog_name_offset;
+		trace_printk("%d: firmware name=%s.\n", i, name);
+
+		if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size + bi->blob.data_size + bi->blob.padding_size) {
+		/* sanity check */
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
+		if (bi->blob.offset + bi->blob.size > fw_size)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+		if ((bi->blob.offset % (1UL<<(ISP_PMEM_WIDTH_LOG2-3))) != 0)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+		if (bi->type == ia_css_sp_firmware) {
+			/* The first binary (i==0) is always the SP firmware */
+			if (i != 0)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			setup_sp(bi, fw_data);
+		} else {
+			/* All subsequent binaries (i>=1) are ISP firmware */
+			const unsigned char *blob =
+				(const unsigned char *)fw_data +
+				bi->blob.offset;
+			if (bi->type != ia_css_isp_firmware)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			sh_css_blob_info[i-1].blob = blob;
+			sh_css_blob_info[i-1].header = *bi;
+			sh_css_blob_info[i-1].name = name;
+		}
+	}
+	return IA_CSS_SUCCESS;
+}
+
+void sh_css_unload_firmware(void)
+{
+	if (sh_css_blob_info) {
+		sh_css_free(sh_css_blob_info);
+		sh_css_blob_info = NULL;
+	}
+}
+
+hrt_vaddress
+sh_css_load_blob(const unsigned char *blob, unsigned size)
+{
+	hrt_vaddress target_addr = mmgr_malloc(size);
+	/* this will allocate memory aligned to a DDR word boundary which
+	   is required for the CSS DMA to read the instructions. */
+	mmgr_store(target_addr, blob, size);
+	if (SH_CSS_PREVENT_UNINIT_READS) {
+		unsigned padded_size = CEIL_MUL(size, HIVE_ISP_DDR_WORD_BYTES);
+		mmgr_clear(target_addr + size, padded_size - size);
+	}
+	return target_addr;
+}
+
+enum ia_css_err
+sh_css_load_blob_info(const char *fw, struct ia_css_blob_descr *bd)
+{
+	const char *name;
+	const unsigned char *blob;
+	struct ia_css_fw_info *bi = (struct ia_css_fw_info *)fw;
+
+	name = fw + sizeof(*bi);
+	blob = (const unsigned char *)name + strlen(name)+1;
+
+	/* sanity check */
+	if (bi->header_size != sizeof(*bi))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size + bi->blob.data_size)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	bd->blob = blob;
+	bd->header = *bi;
+	bd->name = name;
+	return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_firmware.h b/drivers/media/atomisp2/css2400/sh_css_firmware.h
new file mode 100644
index 0000000..1110116
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_firmware.h
@@ -0,0 +1,56 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_FIRMWARE_H_
+#define _SH_CSS_FIRMWARE_H_
+
+#include "system_types.h"
+
+#include "ia_css_types.h"
+#include "ia_css_acc_types.h"
+
+#define ATOMISP_BINARY_NUM 2
+
+/* This is for the firmware loaded from user space */
+struct  sh_css_fw_bi_file_h {
+	int version;			/* Date in the form YYYYMMDD */
+	int binary_nr;			/* Number of binaries */
+	unsigned int h_size;		/* sizeof(struct sh_css_fw_bi_file_h) */
+};
+
+extern struct ia_css_fw_info     sh_css_sp_fw;
+extern struct ia_css_blob_descr *sh_css_blob_info;
+extern unsigned			 sh_css_num_binaries;
+
+enum ia_css_err
+sh_css_load_firmware(const char *fw_data,
+		     unsigned int fw_size);
+
+void sh_css_unload_firmware(void);
+
+hrt_vaddress sh_css_load_blob(const unsigned char *blob, unsigned size);
+
+enum ia_css_err
+sh_css_load_blob_info(const char *fw, struct ia_css_blob_descr *bd);
+
+#endif /* _SH_CSS_FIRMWARE_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_hrt.c b/drivers/media/atomisp2/css2400/sh_css_hrt.c
new file mode 100644
index 0000000..726ca1f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_hrt.c
@@ -0,0 +1,623 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "platform_support.h"
+
+#include "sh_css_hrt.h"
+
+#include "device_access.h"
+
+#define __INLINE_SP__
+#include "sp.h"
+#define __INLINE_ISP__
+#include "isp.h"
+#define __INLINE_IRQ__
+#include "irq.h"
+#define __INLINE_FIFO_MONITOR__
+#include "fifo_monitor.h"
+
+#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
+
+/* System independent */
+#include "sh_css_internal.h"
+#include "sh_css_sp_start.h"	/* sh_css_sp_start_function() */
+#include "sh_css_rx.h"
+
+#define HBLANK_CYCLES (187)
+#define MARKER_CYCLES (6)
+
+#include <hive_isp_css_streaming_to_mipi_types_hrt.h>
+
+/* The data type is used to send special cases:
+ * yuv420: odd lines (1, 3 etc) are twice as wide as even
+ *         lines (0, 2, 4 etc).
+ * rgb: for two pixels per clock, the R and B values are sent
+ *      to output_0 while only G is sent to output_1. This means
+ *      that output_1 only gets half the number of values of output_0.
+ *      WARNING: This type should also be used for Legacy YUV420.
+ * regular: used for all other data types (RAW, YUV422, etc)
+ */
+enum sh_css_mipi_data_type {
+	sh_css_mipi_data_type_regular,
+	sh_css_mipi_data_type_yuv420,
+	sh_css_mipi_data_type_yuv420_legacy,
+	sh_css_mipi_data_type_rgb565,
+	sh_css_mipi_data_type_rgb888,
+	sh_css_mipi_data_type_yuv422,
+};
+
+static hrt_address gp_fifo_base_address     = GP_FIFO_BASE;
+static unsigned int curr_ch_id, curr_fmt_type;
+
+struct streaming_to_mipi_instance {
+	unsigned int				ch_id;
+	enum ia_css_stream_format	input_format;
+	bool						two_ppc;
+	bool						streaming;
+	unsigned int				hblank_cycles;
+	unsigned int				marker_cycles;
+	unsigned int				fmt_type;
+	enum sh_css_mipi_data_type	type;
+};
+
+/*
+ * Maintain a basic streaming to Mipi administration with ch_id as index
+ * ch_id maps on the "Mipi virtual channel ID" and can have value 0..3
+ */
+#define NR_OF_S2M_CHANNELS	(4)
+static struct streaming_to_mipi_instance s2m_inst_admin[NR_OF_S2M_CHANNELS];
+
+void sh_css_hrt_sp_start_isp(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_start_isp_entry =
+					fw->info.sp.sp_entry;
+	(void)HIVE_ADDR_sp_start_isp_entry;
+	sh_css_sp_start_function(sp_start_isp);
+return;
+}
+
+bool sh_css_hrt_system_is_idle(void)
+{
+	hrt_data	status;
+	bool not_idle = false;
+
+	not_idle |= !isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT);
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_SP_STREAM_STAT_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_MASK) != 0);
+
+#if defined(HAS_FIFO_MONITORS_VERSION_2)
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_SP_STREAM_STAT_B_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_B_MASK) != 0);
+#endif
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_ISP_STREAM_STAT_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_ISP_VALID_MASK) != 0);
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_MOD_STREAM_STAT_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_MOD_VALID_MASK) != 0);
+
+return !not_idle;
+}
+
+enum ia_css_err sh_css_hrt_sp_wait(void)
+{
+#if defined(HAS_IRQ_MAP_VERSION_2)
+	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL0_ID;
+#else
+	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL2_ID;
+#endif
+	/*
+	 * Wait till SP is idle or till there is a SW2 interrupt
+	 * The SW2 interrupt will be used when frameloop runs on SP
+	 * and signals an event with similar meaning as SP idle
+	 * (e.g. frame_done)
+	 */
+	while (!sp_ctrl_getbit(SP0_ID, SP_SC_REG, SP_IDLE_BIT) &&
+		((irq_reg_load(IRQ0_ID,
+			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX) &
+			(1U<<(irq_id + IRQ_SW_CHANNEL_OFFSET))) == 0)) {
+		hrt_sleep();
+	}
+
+return IA_CSS_SUCCESS;
+}
+
+/* Streaming to MIPI */
+static unsigned _sh_css_wrap_marker(
+/* STORAGE_CLASS_INLINE unsigned _sh_css_wrap_marker( */
+	unsigned marker)
+{
+return marker |
+	(curr_ch_id << HIVE_STR_TO_MIPI_CH_ID_LSB) |
+	(curr_fmt_type << _HIVE_STR_TO_MIPI_FMT_TYPE_LSB);
+}
+
+static void sh_css_streaming_to_mipi_send_data_a(
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data_a( */
+	unsigned int data)
+{
+	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
+			     (data << HIVE_STR_TO_MIPI_DATA_A_LSB);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_data_b(
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data_b( */
+	unsigned int data)
+{
+	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
+			     (data << _HIVE_STR_TO_MIPI_DATA_B_LSB);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_data(
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data( */
+	unsigned int a,
+	unsigned int b)
+{
+	unsigned int token = ((1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
+			      (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
+			      (a << HIVE_STR_TO_MIPI_DATA_A_LSB) |
+			      (b << _HIVE_STR_TO_MIPI_DATA_B_LSB));
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_sol(void)
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_sol(void) */
+{
+	hrt_data	token = _sh_css_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_SOL_BIT);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_eol(void)
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_eol(void) */
+{
+	hrt_data	token = _sh_css_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_EOL_BIT);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_sof(void)
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_sof(void) */
+{
+	hrt_data	token = _sh_css_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_SOF_BIT);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_eof(void)
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_eof(void) */
+{
+	hrt_data	token = _sh_css_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_EOF_BIT);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+#ifdef __ON__
+static void sh_css_streaming_to_mipi_send_ch_id(
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_ch_id( */
+	unsigned int ch_id)
+{
+	hrt_data	token;
+	curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = _sh_css_wrap_marker(0);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_fmt_type(
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_fmt_type( */
+	unsigned int fmt_type)
+{
+	hrt_data	token;
+	curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = _sh_css_wrap_marker(0);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+#endif /*  __ON__ */
+
+static void sh_css_streaming_to_mipi_send_ch_id_and_fmt_type(
+/* STORAGE_CLASS_INLINE
+void sh_css_streaming_to_mipi_send_ch_id_and_fmt_type( */
+	unsigned int ch_id,
+	unsigned int fmt_type)
+{
+	hrt_data	token;
+	curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
+	curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = _sh_css_wrap_marker(0);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_streaming_to_mipi_send_empty_token(void)
+/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_empty_token(void) */
+{
+	hrt_data	token = _sh_css_wrap_marker(0);
+	device_store_uint32(gp_fifo_base_address, token);
+return;
+}
+
+static void sh_css_hrt_s2m_start_frame(
+/* STORAGE_CLASS_INLINE void sh_css_hrt_s2m_start_frame( */
+	unsigned int ch_id,
+	unsigned int fmt_type)
+{
+	sh_css_streaming_to_mipi_send_ch_id_and_fmt_type(ch_id, fmt_type);
+	sh_css_streaming_to_mipi_send_sof();
+return;
+}
+
+static void sh_css_hrt_s2m_end_frame(
+	unsigned int marker_cycles)
+{
+	unsigned int i;
+	for (i = 0; i < marker_cycles; i++)
+		sh_css_streaming_to_mipi_send_empty_token();
+	sh_css_streaming_to_mipi_send_eof();
+return;
+}
+
+static void sh_css_hrt_s2m_send_line2(
+	const unsigned short *data,
+	unsigned int width,
+	const unsigned short *data2,
+	unsigned int width2,
+	unsigned int hblank_cycles,
+	unsigned int marker_cycles,
+	unsigned int two_ppc,
+	enum sh_css_mipi_data_type type)
+{
+	unsigned int i, is_rgb565 = 0, is_rgb888 = 0, is_legacy = 0, is_yuv422 = 0;
+	unsigned short tempA, tempB, tempC = 0;
+
+	if (type == sh_css_mipi_data_type_rgb565)
+		is_rgb565 = 1;
+	if (type == sh_css_mipi_data_type_rgb888)
+		is_rgb888 = 1;
+	if (type == sh_css_mipi_data_type_yuv420_legacy)
+		is_legacy = 1;
+	if (type == sh_css_mipi_data_type_yuv422)
+		is_yuv422 = 1;
+	
+	for (i = 0; i < hblank_cycles; i++)
+		sh_css_streaming_to_mipi_send_empty_token();
+	sh_css_streaming_to_mipi_send_sol();
+	for (i = 0; i < marker_cycles; i++)
+		sh_css_streaming_to_mipi_send_empty_token();
+	for (i = 0; i < width; i++, data++) {
+		/* for RGB in two_ppc, we only actually send 2 pixels per
+		 * clock in the even pixels (0, 2 etc). In the other cycles,
+		 * we only send 1 pixel, to data[0].
+		 */
+		unsigned int send_two_pixels = two_ppc;
+		if ((is_rgb565 || is_legacy) && (i % 3 == 2))
+			send_two_pixels = 0;
+		if (send_two_pixels) {
+			if (i + 1 == width) {
+				/* for jpg (binary) copy, this can occur
+				 * if the file contains an odd number of bytes.
+				 */
+				sh_css_streaming_to_mipi_send_data(
+							data[0], 0);
+			} else {
+				sh_css_streaming_to_mipi_send_data(
+							data[0], data[1]);
+			}
+			/* Additional increment because we send 2 pixels */
+			data++;
+			i++;
+		} else if (two_ppc && is_legacy) {
+			sh_css_streaming_to_mipi_send_data_b(data[0]);
+		} else if (is_yuv422){
+			//Only support UYVY order for now
+			tempA = data[0] &0x00FF;
+			tempB = (data[0]>>8) &0x00FF;
+			sh_css_streaming_to_mipi_send_data_a(tempA);
+			sh_css_streaming_to_mipi_send_data_a(tempB);
+		} else if (is_rgb565 || is_rgb888){
+			if (is_rgb565) {
+				tempA = (data[0] &0xF800) >> 11; //red
+				tempB = (data[0] &0x07E0) >> 5; //green
+				tempC = data[0] &0x001F; //blue
+			} else if (is_rgb888) {
+				if (i%2==0) {  // First pixel and every other pixel
+					tempA = (data[1] & 0xFF); //red
+					tempB = (data[0] & 0xFF00) >> 8; // green
+					tempC = (data[0] & 0xFF); //blue
+				} else {
+					tempA = (data[1] & 0xFF00) >> 8; //red
+					tempB = (data[1] & 0xFF); //green
+					tempC = (data[0] &  0xFF00) >> 8; //blue
+					data++; //extra increment to catch up
+				}
+			}
+			sh_css_streaming_to_mipi_send_data_a(tempC);
+			sh_css_streaming_to_mipi_send_data_a(tempB);
+			sh_css_streaming_to_mipi_send_data_a(tempA);
+		}
+		else {
+		  sh_css_streaming_to_mipi_send_data_a(data[0]);
+		}
+	}
+
+	for (i = 0; i < width2; i++, data2++) {
+		/* for RGB in two_ppc, we only actually send 2 pixels per
+		 * clock in the even pixels (0, 2 etc). In the other cycles,
+		 * we only send 1 pixel, to data2[0].
+		 */
+		unsigned int send_two_pixels = two_ppc;
+		if ((is_rgb565 || is_legacy) && (i % 3 == 2))
+			send_two_pixels = 0;
+		if (send_two_pixels) {
+			if (i + 1 == width2) {
+				/* for jpg (binary) copy, this can occur
+				 * if the file contains an odd number of bytes.
+				 */
+				sh_css_streaming_to_mipi_send_data(
+							data2[0], 0);
+			} else {
+				sh_css_streaming_to_mipi_send_data(
+							data2[0], data2[1]);
+			}
+			/* Additional increment because we send 2 pixels */
+			data2++;
+			i++;
+		} else if (two_ppc && is_legacy) {
+			sh_css_streaming_to_mipi_send_data_b(data2[0]);
+		} else {
+			sh_css_streaming_to_mipi_send_data_a(data2[0]);
+		}
+	}
+	for (i = 0; i < hblank_cycles; i++)
+		sh_css_streaming_to_mipi_send_empty_token();
+	sh_css_streaming_to_mipi_send_eol();
+return;
+}
+
+static void
+sh_css_hrt_s2m_send_line(const unsigned short *data,
+			 unsigned int width,
+			 unsigned int hblank_cycles,
+			 unsigned int marker_cycles,
+			 unsigned int two_ppc,
+			 enum sh_css_mipi_data_type type)
+{
+	sh_css_hrt_s2m_send_line2(data, width, NULL, 0,
+					hblank_cycles,
+					marker_cycles,
+					two_ppc,
+					type);
+}
+
+/* Send a frame of data into the input network via the GP FIFO.
+ *  Parameters:
+ *   - data: array of 16 bit values that contains all data for the frame.
+ *   - width: width of a line in number of subpixels, for yuv420 it is the
+ *            number of Y components per line.
+ *   - height: height of the frame in number of lines.
+ *   - ch_id: channel ID.
+ *   - fmt_type: format type.
+ *   - hblank_cycles: length of horizontal blanking in cycles.
+ *   - marker_cycles: number of empty cycles after start-of-line and before
+ *                    end-of-frame.
+ *   - two_ppc: boolean, describes whether to send one or two pixels per clock
+ *              cycle. In this mode, we sent pixels N and N+1 in the same cycle,
+ *              to IF_PRIM_A and IF_PRIM_B respectively. The caller must make
+ *              sure the input data has been formatted correctly for this.
+ *              For example, for RGB formats this means that unused values
+ *              must be inserted.
+ *   - yuv420: boolean, describes whether (non-legacy) yuv420 data is used. In
+ *             this mode, the odd lines (1,3,5 etc) are half as long as the
+ *             even lines (2,4,6 etc).
+ *             Note that the first line is odd (1) and the second line is even
+ *             (2).
+ *
+ * This function does not do any reordering of pixels, the caller must make
+ * sure the data is in the righ format. Please refer to the CSS receiver
+ * documentation for details on the data formats.
+ */
+static void sh_css_hrt_s2m_send_frame(
+	const unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	unsigned int ch_id,
+	unsigned int fmt_type,
+	unsigned int hblank_cycles,
+	unsigned int marker_cycles,
+	unsigned int two_ppc,
+	enum sh_css_mipi_data_type type)
+{
+	unsigned int i;
+
+	sh_css_hrt_s2m_start_frame(ch_id, fmt_type);
+	for (i = 0; i < height; i++) {
+		sh_css_dtrace(2, "%s: sending line %d|%d \n", __func__, i, height);
+#if defined(__KERNEL__)
+/* add some delay to avoid FIFO overflow*/
+		usleep_range(1000, 1500);
+#endif
+		if ((type == sh_css_mipi_data_type_yuv420) &&
+		    (i & 1) == 1) {
+			sh_css_hrt_s2m_send_line(data, 2 * width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+			data += 2 * width;
+		} else if (type == sh_css_mipi_data_type_rgb888) {
+			sh_css_hrt_s2m_send_line(data, width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+				data += (3*width)/2;
+		} else {
+			sh_css_hrt_s2m_send_line(data, width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+			data += width;
+		}
+	}
+	sh_css_hrt_s2m_end_frame(marker_cycles);
+return;
+}
+
+static enum sh_css_mipi_data_type sh_css_hrt_s2m_determine_type(
+	enum ia_css_stream_format input_format)
+{
+	enum sh_css_mipi_data_type type;
+
+	type = sh_css_mipi_data_type_regular;
+	if (input_format == IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY) {
+		type =
+			sh_css_mipi_data_type_yuv420_legacy;
+	} else if (input_format == IA_CSS_STREAM_FORMAT_YUV420_8 ||
+		   input_format == IA_CSS_STREAM_FORMAT_YUV420_10) {
+		type = 
+			sh_css_mipi_data_type_yuv420;
+	} else if (input_format >= IA_CSS_STREAM_FORMAT_RGB_444 &&
+		   input_format <= IA_CSS_STREAM_FORMAT_RGB_565) {
+		type = sh_css_mipi_data_type_rgb565;
+	} else if (input_format == IA_CSS_STREAM_FORMAT_RGB_888) {
+		type = sh_css_mipi_data_type_rgb888;
+	} else if (input_format == IA_CSS_STREAM_FORMAT_YUV422_8 ||
+		   input_format == IA_CSS_STREAM_FORMAT_YUV422_10) {
+		type =
+			sh_css_mipi_data_type_yuv422;
+	}
+return type;
+}
+
+static struct streaming_to_mipi_instance *sh_css_hrt_s2m_get_inst(
+	unsigned int ch_id)
+{
+return &s2m_inst_admin[ch_id];
+}
+
+void sh_css_hrt_send_input_frame(
+	const unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	unsigned int ch_id,
+	enum ia_css_stream_format input_format,
+	bool two_ppc)
+{
+	unsigned int fmt_type, hblank_cycles, marker_cycles;
+	enum sh_css_mipi_data_type type;
+
+	hblank_cycles = HBLANK_CYCLES;
+	marker_cycles = MARKER_CYCLES;
+	sh_css_input_format_type(input_format,
+				 MIPI_PREDICTOR_NONE,
+				 &fmt_type);
+
+	type = sh_css_hrt_s2m_determine_type(input_format);
+
+	sh_css_hrt_s2m_send_frame(data, width, height,
+			ch_id, fmt_type, hblank_cycles, marker_cycles,
+			two_ppc, type);
+}
+
+void sh_css_hrt_streaming_to_mipi_start_frame(
+	unsigned int ch_id,
+	enum ia_css_stream_format input_format,
+	bool two_ppc)
+{
+	struct streaming_to_mipi_instance *s2mi;
+	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
+
+	s2mi->ch_id = ch_id;
+	sh_css_input_format_type(input_format, MIPI_PREDICTOR_NONE,
+				&s2mi->fmt_type);
+	s2mi->two_ppc = two_ppc;
+	s2mi->type = sh_css_hrt_s2m_determine_type(input_format);
+	s2mi->hblank_cycles = HBLANK_CYCLES;
+	s2mi->marker_cycles = MARKER_CYCLES;
+	s2mi->streaming = true;
+
+	sh_css_hrt_s2m_start_frame(ch_id, s2mi->fmt_type);
+return;
+}
+
+void sh_css_hrt_streaming_to_mipi_send_line(
+	unsigned int ch_id,
+	const unsigned short *data,
+	unsigned int width,
+	const unsigned short *data2,
+	unsigned int width2)
+{
+	struct streaming_to_mipi_instance *s2mi;
+	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
+
+	/* Set global variables that indicate channel_id and format_type */
+	curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
+	curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
+
+	sh_css_hrt_s2m_send_line2(data, width, data2, width2,
+					s2mi->hblank_cycles,
+					s2mi->marker_cycles,
+					s2mi->two_ppc,
+					s2mi->type);
+}
+
+void sh_css_hrt_streaming_to_mipi_end_frame(
+	unsigned int	ch_id)
+{
+	struct streaming_to_mipi_instance *s2mi;
+	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
+
+	/* Set global variables that indicate channel_id and format_type */
+	curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
+	curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
+
+	/* Call existing HRT function */
+	sh_css_hrt_s2m_end_frame(s2mi->marker_cycles);
+
+	s2mi->streaming = false;
+return;
+}
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_hrt.h b/drivers/media/atomisp2/css2400/sh_css_hrt.h
new file mode 100644
index 0000000..a98c589
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_hrt.h
@@ -0,0 +1,66 @@
+#ifndef _SH_CSS_HRT_H_
+#define _SH_CSS_HRT_H_
+
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include <sp.h>
+#include <isp.h>
+
+#include "ia_css.h"	/* enum ia_css_stream_format */
+
+/* SP access */
+void sh_css_hrt_sp_start_si(void);
+
+void sh_css_hrt_sp_start_copy_frame(void);
+
+void sh_css_hrt_sp_start_isp(void);
+
+enum ia_css_err sh_css_hrt_sp_wait(void);
+
+bool sh_css_hrt_system_is_idle(void);
+
+void sh_css_hrt_send_input_frame(
+	const unsigned short	*data,
+	unsigned int	width,
+	unsigned int	height,
+	unsigned int	ch_id,
+	enum ia_css_stream_format	input_format,
+	bool			two_ppc);
+
+void sh_css_hrt_streaming_to_mipi_start_frame(
+	unsigned int	ch_id,
+	enum ia_css_stream_format	input_format,
+	bool			two_ppc);
+
+void sh_css_hrt_streaming_to_mipi_send_line(
+	unsigned int	ch_id,
+	const unsigned short	*data,
+	unsigned int	width,
+	const unsigned short	*data2,
+	unsigned int	width2);
+
+void sh_css_hrt_streaming_to_mipi_end_frame(
+	unsigned int	ch_id);
+
+#endif /* _SH_CSS_HRT_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_internal.h b/drivers/media/atomisp2/css2400/sh_css_internal.h
new file mode 100644
index 0000000..db70bcc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_internal.h
@@ -0,0 +1,928 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_INTERNAL_H_
+#define _SH_CSS_INTERNAL_H_
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#else
+#include <stdbool.h>
+#include <stdint.h>
+#endif
+
+#include "input_formatter.h"
+#include "input_system.h"
+
+#include "pipeline.h"
+#include "csc_kernel.h"
+
+#include "ia_css_types.h"
+#include "ia_css_acc_types.h"
+//#include "sh_css_internal.h"
+#include "sh_css_binary.h"
+#include "sh_css_firmware.h"
+#include "sh_css_legacy.h"
+#include "sh_css_defs.h"
+#include "dma.h"	/* N_DMA_CHANNEL_ID */
+
+#define SH_CSS_MAX_BINARY_NAME	32
+
+#define SP_DEBUG_NONE	(0)
+#define SP_DEBUG_DUMP	(1)
+#define SP_DEBUG_COPY	(2)
+#define SP_DEBUG_TRACE	(3) /* not yet functional */
+#define SP_DEBUG_MINIMAL (4)
+
+#define SP_DEBUG SP_DEBUG_NONE
+#define SP_DEBUG_MINIMAL_OVERWRITE 1
+
+
+#ifdef __DISABLE_UNUSED_THREAD__
+#define SH_CSS_MAX_SP_THREADS	1 /* preview */
+#else
+#define SH_CSS_MAX_SP_THREADS	4 /* raw_copy, preview, capture, acceleration */
+#endif
+
+#define NUM_REF_FRAMES		(3)
+
+/* keep next up to date with the definition for MAX_CB_ELEMS_FOR_TAGGER in tagger.sp.c */
+#if defined(HAS_SP_2400)
+#define NUM_CONTINUOUS_FRAMES	15
+#else
+#define NUM_CONTINUOUS_FRAMES	10
+#endif
+
+#define NUM_MIPI_FRAMES		8
+
+#define NUM_TNR_FRAMES		2
+
+#define NUM_VIDEO_REF_FRAMES	(3)  /* SN: Should this not always match NUM_REF_FRAMES ?*/
+#define NUM_VIDEO_TNR_FRAMES	2
+#define NR_OF_PIPELINES			5 /* Must match with IA_CSS_PIPE_ID_NUM */
+
+#define SH_CSS_MAX_IF_CONFIGS	3 /* Must match with IA_CSS_NR_OF_CONFIGS (not defined yet).*/
+#define SH_CSS_IF_CONFIG_NOT_NEEDED	0xFF
+
+/* MW: This has to be moved to the "pipeline" file set */
+/*#define SH_CSS_MAX_STAGES 6 *//* copy, preisp, anr, postisp, capture_pp, vf_pp */
+
+/*
+ * JB: keep next enum in sync with thread id's
+ * and pipe id's
+ */
+enum sh_css_pipe_config_override {
+	SH_CSS_PIPE_CONFIG_OVRD_NONE     = 0,
+	SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD  = 0xffff
+};
+
+enum host2sp_commands {
+	host2sp_cmd_error = 0,
+	/*
+	 * The host2sp_cmd_ready command is the only command written by the SP
+	 * It acknowledges that is previous command has been received.
+	 * (this does not mean that the command has been executed)
+	 * It also indicates that a new command can be send (it is a queue
+	 * with depth 1).
+	 */
+	host2sp_cmd_ready = 1,
+	/* Command written by the Host */
+	host2sp_cmd_dummy,		/* No action, can be used as watchdog */
+	host2sp_cmd_terminate,		/* SP should terminate itself */
+	N_host2sp_cmd
+};
+
+/** Enumeration used to indicate the events that are produced by
+ *  the SP and consumed by the Host.
+ */
+enum sh_css_sp_event_type {
+	SH_CSS_SP_EVENT_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_VF_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_3A_STATISTICS_DONE,
+	SH_CSS_SP_EVENT_DIS_STATISTICS_DONE,
+	SH_CSS_SP_EVENT_PIPELINE_DONE,
+	SH_CSS_SP_EVENT_FRAME_TAGGED,
+	SH_CSS_SP_EVENT_PORT_EOF,
+	SH_CSS_SP_EVENT_NR_OF_TYPES,		/* must be last */
+};
+
+/* xmem address map allocation */
+struct sh_css_ddr_address_map {
+	hrt_vaddress isp_param;
+	hrt_vaddress ctc_tbl;
+	hrt_vaddress xnr_tbl;
+	hrt_vaddress gamma_tbl;
+	hrt_vaddress macc_tbl;
+	hrt_vaddress fpn_tbl;
+	hrt_vaddress sc_tbl;
+	hrt_vaddress sdis_hor_coef;
+	hrt_vaddress sdis_ver_coef;
+	hrt_vaddress tetra_r_x;
+	hrt_vaddress tetra_r_y;
+	hrt_vaddress tetra_gr_x;
+	hrt_vaddress tetra_gr_y;
+	hrt_vaddress tetra_gb_x;
+	hrt_vaddress tetra_gb_y;
+	hrt_vaddress tetra_b_x;
+	hrt_vaddress tetra_b_y;
+	hrt_vaddress tetra_ratb_x;
+	hrt_vaddress tetra_ratb_y;
+	hrt_vaddress tetra_batr_x;
+	hrt_vaddress tetra_batr_y;
+	hrt_vaddress dvs_6axis_params_y;
+	hrt_vaddress r_gamma_tbl;
+	hrt_vaddress g_gamma_tbl;
+	hrt_vaddress b_gamma_tbl;
+	hrt_vaddress anr_thres;
+};
+
+/* xmem address map allocation */
+struct sh_css_ddr_address_map_size {
+	size_t isp_param;
+	size_t ctc_tbl;
+	size_t gamma_tbl;
+	size_t xnr_tbl;
+	size_t macc_tbl;
+	size_t fpn_tbl;
+	size_t sc_tbl;
+	size_t sdis_hor_coef;
+	size_t sdis_ver_coef;
+	size_t tetra_r_x;
+	size_t tetra_r_y;
+	size_t tetra_gr_x;
+	size_t tetra_gr_y;
+	size_t tetra_gb_x;
+	size_t tetra_gb_y;
+	size_t tetra_b_x;
+	size_t tetra_b_y;
+	size_t tetra_ratb_x;
+	size_t tetra_ratb_y;
+	size_t tetra_batr_x;
+	size_t tetra_batr_y;
+	size_t dvs_6axis_params_y;
+	size_t r_gamma_tbl;
+	size_t g_gamma_tbl;
+	size_t b_gamma_tbl;
+	size_t anr_thres;
+};
+
+struct sh_css_ddr_address_map_compound {
+	struct sh_css_ddr_address_map		map;
+	struct sh_css_ddr_address_map_size	size;
+};
+
+/* this struct contains all arguments that can be passed to
+   a binary. It depends on the binary which ones are used. */
+struct sh_css_binary_args {
+	struct ia_css_frame *cc_frame;       /* continuous capture frame */
+	struct ia_css_frame *in_frame;	     /* input frame */
+	struct ia_css_frame *in_ref_frame;   /* reference input frame */
+	struct ia_css_frame *in_tnr_frame;   /* tnr input frame */
+	struct ia_css_frame *out_frame;      /* output frame */
+	struct ia_css_frame *out_ref_frame;  /* reference output frame */
+	struct ia_css_frame *out_tnr_frame;  /* tnr output frame */
+	struct ia_css_frame *extra_frame;    /* intermediate frame */
+	struct ia_css_frame *out_vf_frame;   /* viewfinder output frame */
+	struct ia_css_frame *extra_ref_frame;    /* reference extra frame */
+	bool                 copy_vf;
+	bool                 copy_output;
+	unsigned             vf_downscale_log2;
+};
+
+enum sh_css_sp_stage_func {
+  SH_CSS_SP_RAW_COPY  = 0,
+  SH_CSS_SP_BIN_COPY  = 1,
+  SH_CSS_SP_ISYS_COPY = 2,
+  SH_CSS_SP_NO_FUNC   = 3,
+};
+#define SH_CSS_NUM_STAGE_FUNCS 3
+
+/* Pipeline stage to be executed on SP/ISP */
+struct sh_css_pipeline_stage {
+	unsigned int		     stage_num;
+	struct sh_css_binary	    *binary;      /* built-in binary */
+	struct ia_css_binary_info   *binary_info;
+	const struct ia_css_fw_info *firmware; /* acceleration binary */
+	enum sh_css_sp_stage_func    sp_func; /* SP function for SP stage */
+	unsigned		     max_input_width; /* For SP raw copy */
+	struct sh_css_binary_args    args;
+	int			     mode;
+	bool			     out_frame_allocated;
+	bool			     vf_frame_allocated;
+	/* Indicate which buffers require an IRQ */
+	unsigned int		     irq_buf_flags;
+	struct sh_css_pipeline_stage *next;
+};
+
+/* Pipeline of n stages to be executed on SP/ISP per stage */
+struct sh_css_pipeline {
+	enum ia_css_pipe_id pipe_id;
+	struct sh_css_pipeline_stage *stages;
+	bool reload;
+	struct sh_css_pipeline_stage *current_stage;
+	unsigned num_stages;
+	struct ia_css_frame in_frame;
+	struct ia_css_frame out_frame;
+	struct ia_css_frame vf_frame;
+	enum ia_css_frame_delay dvs_frame_delay;
+};
+
+
+#if SP_DEBUG == SP_DEBUG_DUMP
+
+#define SH_CSS_NUM_SP_DEBUG 48
+
+struct sh_css_sp_debug_state {
+	unsigned int error;
+	unsigned int debug[SH_CSS_NUM_SP_DEBUG];
+};
+
+#elif SP_DEBUG == SP_DEBUG_COPY
+
+#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
+
+struct sh_css_sp_debug_trace {
+	uint16_t frame;
+	uint16_t line;
+	uint16_t pixel_distance;
+	uint16_t mipi_used_dword;
+	uint16_t sp_index;
+};
+
+struct sh_css_sp_debug_state {
+	uint16_t if_start_line;
+	uint16_t if_start_column;
+	uint16_t if_cropped_height;
+	uint16_t if_cropped_width;
+	unsigned int index;
+	struct sh_css_sp_debug_trace
+		trace[SH_CSS_SP_DBG_TRACE_DEPTH];
+};
+
+#elif SP_DEBUG == SP_DEBUG_TRACE
+
+#define SH_CSS_SP_DBG_NR_OF_TRACES	(4)
+#define SH_CSS_SP_DBG_TRACE_DEPTH	(20)
+
+#define SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS (13)
+
+/* trace id 0..3 are used by the SP threads */
+#define SH_CSS_SP_DBG_TRACE_ID_CONTROL (3) /* Re-use accl thread */
+#define SH_CSS_SP_DBG_TRACE_ID_TBD  (5)
+
+struct sh_css_sp_debug_trace {
+	uint16_t time_stamp;
+	uint16_t location;	/* bit 15..13 = file_id, 12..0 = line */
+	uint32_t data;
+};
+
+struct sh_css_sp_debug_state {
+	unsigned int mipi_fifo_high_water;
+	struct sh_css_sp_debug_trace
+		trace[SH_CSS_SP_DBG_NR_OF_TRACES][SH_CSS_SP_DBG_TRACE_DEPTH];
+	uint8_t index[SH_CSS_SP_DBG_NR_OF_TRACES];
+};
+
+
+#elif SP_DEBUG == SP_DEBUG_MINIMAL
+
+#define SH_CSS_NUM_SP_DEBUG 128
+
+struct sh_css_sp_debug_state {
+	unsigned int error;
+	unsigned int debug[SH_CSS_NUM_SP_DEBUG];
+};
+
+#endif
+
+
+struct sh_css_sp_debug_command {
+	/*
+	 * The DMA software-mask,
+	 *	Bit 31...24: unused.
+	 *	Bit 23...16: unused.
+	 *	Bit 15...08: reading-request enabling bits for DMA channel 7..0
+	 *	Bit 07...00: writing-reqeust enabling bits for DMA channel 7..0
+	 *
+	 * For example, "0...0 0...0 11111011 11111101" indicates that the
+	 * writing request through DMA Channel 1 and the reading request
+	 * through DMA channel 2 are both disabled. The others are enabled.
+	 */
+	uint32_t dma_sw_reg;
+};
+
+/* SP input formatter configuration.*/
+struct sh_css_sp_input_formatter_set {
+	uint32_t				stream_format;
+	input_formatter_cfg_t	config_a;
+	input_formatter_cfg_t	config_b;
+};
+
+/* SP configuration information */
+struct sh_css_sp_config {
+	uint8_t			is_offline;  /* Run offline, with continuous copy */
+	uint8_t			input_needs_raw_binning;
+	uint8_t			no_isp_sync; /* Signal host immediately after start */
+	struct {
+		uint8_t					a_changed;
+		uint8_t					b_changed;
+		uint8_t					isp_2ppc;
+		struct sh_css_sp_input_formatter_set	set[SH_CSS_MAX_IF_CONFIGS]; /* CSI-2 port is used as index. */
+	} input_formatter;
+	sync_generator_cfg_t	sync_gen;
+	tpg_cfg_t				tpg;
+	prbs_cfg_t				prbs;
+	input_system_cfg_t		input_circuit;
+	uint8_t					input_circuit_cfg_changed;
+};
+
+enum sh_css_stage_type {
+  SH_CSS_SP_STAGE_TYPE  = 0,
+  SH_CSS_ISP_STAGE_TYPE = 1
+};
+#define SH_CSS_NUM_STAGE_TYPES 2
+
+#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS 	(1 << 0)
+#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS_MASK \
+	((SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << SH_CSS_MAX_SP_THREADS)-1)
+
+/* Information for a pipeline */
+struct sh_css_sp_pipeline {
+	uint32_t	pipe_id;	/* the pipe ID */
+	uint32_t	pipe_num;	/* the dynamic pipe number */
+	uint32_t	thread_id;	/* the sp thread ID */
+	uint32_t	pipe_config;	/* the pipe config */
+	uint32_t	input_system_mode;	/* enum ia_css_input_mode */
+	mipi_port_ID_t	port_id;	/* port_id for input system */
+	uint32_t	num_stages;		/* the pipe config */
+	uint32_t	running;	/* needed for pipe termination */
+	uint32_t	dvs_frame_delay;
+	hrt_vaddress	sp_stage_addr[SH_CSS_MAX_STAGES];
+	struct sh_css_sp_stage *stage; /* Current stage for this pipeline */
+	union {
+		struct {
+			unsigned int	bytes_available;
+		} bin;
+		struct {
+			unsigned int	height;
+			unsigned int	width;
+			unsigned int	padded_width;
+			unsigned int	max_input_width;
+			unsigned int	raw_bit_depth;
+		} raw;
+	} copy;
+};
+
+/*
+ * These structs are derived from structs defined in ia_css_types.h
+ * (just take out the "_sp" from the struct name to get the "original")
+ * All the fields that are not needed by the SP are removed.
+ */
+struct sh_css_sp_frame_plane {
+	unsigned int offset;	/* offset in bytes to start of frame data */
+				/* offset is wrt data in sh_css_sp_sp_frame */
+};
+
+struct sh_css_sp_frame_binary_plane {
+	unsigned int size;
+	struct sh_css_sp_frame_plane data;
+};
+
+struct sh_css_sp_frame_yuv_planes {
+	struct sh_css_sp_frame_plane y;
+	struct sh_css_sp_frame_plane u;
+	struct sh_css_sp_frame_plane v;
+};
+
+struct sh_css_sp_frame_nv_planes {
+	struct sh_css_sp_frame_plane y;
+	struct sh_css_sp_frame_plane uv;
+};
+
+struct sh_css_sp_frame_rgb_planes {
+	struct sh_css_sp_frame_plane r;
+	struct sh_css_sp_frame_plane g;
+	struct sh_css_sp_frame_plane b;
+};
+
+struct sh_css_sp_frame_plane6_planes {
+	struct sh_css_sp_frame_plane r;
+	struct sh_css_sp_frame_plane r_at_b;
+	struct sh_css_sp_frame_plane gr;
+	struct sh_css_sp_frame_plane gb;
+	struct sh_css_sp_frame_plane b;
+	struct sh_css_sp_frame_plane b_at_r;
+};
+
+/* MW: ALL CAPS, and is it too much trouble to suffix an ID with ID ? */
+enum sh_css_frame_id {
+	sh_css_frame_in,		/* Dynamic */
+	sh_css_frame_out,		/* Dynamic */
+	sh_css_frame_out_vf,		/* Dynamic */
+	sh_css_frame_s3a,		/* Dynamic */
+	sh_css_frame_dis,		/* Dynamic */
+	sh_css_frame_ref_in,
+	sh_css_frame_ref_out,
+	sh_css_frame_ref_extra,
+	sh_css_frame_tnr_in,
+	sh_css_frame_tnr_out,
+	sh_css_frame_extra,
+	sh_css_frame_raw_out,
+	sh_css_frame_cust_in,
+	sh_css_frame_cust_out,
+};
+/*
+ * The first frames (with comment Dynamic) can be dynamic or static
+ * The other frames (ref_in and below) can only be static
+ * Static means that the data addres will not change during the life time
+ * of the associated pipe. Dynamic means that the data address can
+ * change with every (frame) iteration of the associated pipe
+ *
+ * s3a and dis are now also dynamic but (stil) handled seperately
+ */
+#define SH_CSS_NUM_FRAME_IDS (14)
+#define SH_CSS_NUM_DYNAMIC_BUFFER_IDS (5)
+#define SH_CSS_NUM_DYNAMIC_FRAME_IDS (3)
+#define SH_CSS_INVALID_FRAME_ID (-1)
+
+
+/** Frame info struct. This describes the contents of an image frame buffer.
+  */
+struct sh_css_sp_frame_info {
+	uint16_t width;  /**< width of valid data in pixels */
+	uint16_t height; /**< Height of valid data in lines */
+	uint16_t padded_width; /**< stride of line in memory (in pixels) */
+	unsigned char format; /**< format of the frame data */
+	unsigned char raw_bit_depth; /**< number of valid bits per pixel,
+					 only valid for RAW bayer frames */
+	unsigned char raw_bayer_order; /**< bayer order, only valid
+						      for RAW bayer frames */
+	unsigned char padding;
+};
+
+
+struct sh_css_sp_frame {
+	struct sh_css_sp_frame_info info;
+	union {
+		struct sh_css_sp_frame_plane raw;
+		struct sh_css_sp_frame_plane rgb;
+		struct sh_css_sp_frame_rgb_planes planar_rgb;
+		struct sh_css_sp_frame_plane yuyv;
+		struct sh_css_sp_frame_yuv_planes yuv;
+		struct sh_css_sp_frame_nv_planes nv;
+		struct sh_css_sp_frame_plane6_planes plane6;
+		struct sh_css_sp_frame_binary_plane binary;
+	} planes;
+};
+
+struct sh_css_sp_frames {
+	struct sh_css_sp_frame	in;
+	struct sh_css_sp_frame	out;
+	struct sh_css_sp_frame	out_vf;
+	struct sh_css_sp_frame	ref_in;
+	/* ref_out_frame is same as ref_in_frame */
+	struct sh_css_sp_frame	tnr_in;
+	/* trn_out_frame is same as tnr_in_frame */
+	struct sh_css_sp_frame	extra;
+	struct sh_css_sp_frame_info internal_frame_info;
+	hrt_vaddress static_frame_data[SH_CSS_NUM_FRAME_IDS];
+};
+
+/* Information for a single pipeline stage for an ISP */
+struct sh_css_isp_stage {
+	/*
+	 * For compatability and portabilty, only types
+	 * from "stdint.h" are allowed
+	 *
+	 * Use of "enum" and "bool" is prohibited
+	 * Multiple boolean flags can be stored in an
+	 * integer
+	 */
+	struct ia_css_blob_info	  blob_info;
+	struct ia_css_binary_info binary_info;
+	char			  binary_name[SH_CSS_MAX_BINARY_NAME];
+	struct ia_css_data        mem_initializers[IA_CSS_NUM_ISP_MEMORIES];
+};
+
+/* Information for a single pipeline stage */
+struct sh_css_sp_stage {
+	/*
+	 * For compatability and portabilty, only types
+	 * from "stdint.h" are allowed
+	 *
+	 * Use of "enum" and "bool" is prohibited
+	 * Multiple boolean flags can be stored in an
+	 * integer
+	 */
+	uint8_t			num; /* Stage number */
+	uint8_t			isp_online;
+	uint8_t			isp_copy_vf;
+	uint8_t			isp_copy_output;
+	uint8_t			sp_enable_xnr;
+	uint8_t			isp_deci_log_factor;
+	uint8_t			isp_vf_downscale_bits;
+	uint8_t			anr;
+	uint8_t			deinterleaved;
+/*
+ * NOTE: Programming the input circuit can only be done at the
+ * start of a session. It is illegal to program it during execution
+ * The input circuit defines the connectivity
+ */
+	uint8_t			program_input_circuit;
+/* enum sh_css_sp_stage_func	func; */
+	uint8_t			func;
+	/* The type of the pipe-stage */
+	/* enum sh_css_stage_type	stage_type; */
+	uint8_t			stage_type;
+	uint8_t			num_stripes;
+	uint8_t			isp_pipe_version;
+	struct {
+		uint8_t		vf_output;
+		uint8_t		s3a;
+		uint8_t		sdis;
+	} enable;
+	/* Add padding to come to a word boundary */
+	/* unsigned char			padding[0]; */
+
+	struct sh_css_crop_pos		sp_out_crop_pos;
+	/* Indicate which buffers require an IRQ */
+	uint32_t					irq_buf_flags;
+	struct sh_css_sp_frames		frames;
+	struct ia_css_resolution	dvs_envelope;
+	struct sh_css_uds_info		uds;
+	hrt_vaddress			isp_stage_addr;
+	hrt_vaddress			xmem_bin_addr;
+	hrt_vaddress			xmem_map_addr;
+
+	uint8_t			if_config_index; /* Which should be applied by this stage. */
+};
+
+/*
+ * Time: 2012-07-19, 17:40.
+ * Author: zhengjie.lu@intel.com
+ * Note: Add a new data memeber "debug" in "sh_css_sp_group". This
+ * data member is used to pass the debugging command from the
+ * Host to the SP.
+ *
+ * Time: Before 2012-07-19.
+ * Author: unknown
+ * Note:
+ * Group all host initialized SP variables into this struct.
+ * This is initialized every stage through dma.
+ * The stage part itself is transfered through sh_css_sp_stage.
+*/
+struct sh_css_sp_group {
+	struct sh_css_sp_config		config;
+	struct sh_css_sp_pipeline	pipe[SH_CSS_MAX_SP_THREADS];
+
+	struct sh_css_sp_debug_command	debug;
+};
+
+/* Data in SP dmem that is set from the host every stage. */
+struct sh_css_sp_per_frame_data {
+	/* ddr address of sp_group and sp_stage */
+	hrt_vaddress			sp_group_addr;
+};
+
+#define SH_CSS_NUM_SDW_IRQS 3
+
+/* Output data from SP to css */
+struct sh_css_sp_output {
+	unsigned int			bin_copy_bytes_copied;
+#if SP_DEBUG != SP_DEBUG_NONE
+	struct sh_css_sp_debug_state	debug;
+#endif
+	unsigned int		sw_interrupt_value[SH_CSS_NUM_SDW_IRQS];
+};
+
+/**
+ * @brief Data structure for the circular buffer.
+ * The circular buffer is empty if "start == end". The
+ * circular buffer is full if "(end + 1) % size == start".
+ */
+#if defined(HAS_SP_2400)
+#define  SH_CSS_CIRCULAR_BUF_NUM_ELEMS             13
+#else
+#define  SH_CSS_CIRCULAR_BUF_NUM_ELEMS	6
+#endif
+struct sh_css_circular_buf {
+	/*
+	 * WARNING: Do NOT change the memeber orders below,
+	 * unless you are the expert of either the CSS API
+	 * or the SP code.
+	 */
+
+	uint8_t size;  /* maximum number of elements */
+	uint8_t step;  /* number of bytes per element */
+	uint8_t start; /* index of the oldest element */
+	uint8_t end;   /* index at which to write the new element */
+
+	uint32_t elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS]; /* array of elements */
+};
+
+struct sh_css_hmm_buffer {
+	hrt_vaddress kernel_ptr;
+	union {
+		struct ia_css_isp_3a_statistics  s3a;
+		struct ia_css_isp_dvs_statistics dis;
+//		hrt_vaddress frame_data;
+		struct {
+			hrt_vaddress	frame_data;
+			unsigned int	flashed;
+			unsigned int	exp_id;
+			unsigned int	frame_nr;
+		} frame;
+		hrt_vaddress ddr_ptrs;
+	} payload;
+};
+
+enum sh_css_buffer_queue_id {
+	sh_css_invalid_buffer_queue = -1,
+	sh_css_input_buffer_queue,
+	sh_css_output_buffer_queue,
+	sh_css_vf_output_buffer_queue,
+	sh_css_s3a_buffer_queue,
+	sh_css_dis_buffer_queue,
+	sh_css_param_buffer_queue,
+	sh_css_tag_cmd_queue
+};
+
+struct sh_css_event_irq_mask {
+	uint16_t or_mask;
+	uint16_t and_mask;
+};
+
+#define SH_CSS_NUM_BUFFER_QUEUES 7
+
+struct host_sp_communication {
+	/*
+	 * Don't use enum host2sp_commands, because the sizeof an enum is
+	 * compiler dependant and thus non-portable
+	 */
+	uint32_t host2sp_command;
+
+	/*
+	 * The frame buffers that are reused by the
+	 * copy pipe in the offline preview mode.
+	 *
+	 * host2sp_offline_frames[0]: the input frame of the preview pipe.
+	 * host2sp_offline_frames[1]: the output frame of the copy pipe.
+	 *
+	 * TODO:
+	 *   Remove it when the Host and the SP is decoupled.
+	 */
+	hrt_vaddress host2sp_offline_frames[NUM_CONTINUOUS_FRAMES];
+	hrt_vaddress host2sp_mipi_frames[NUM_MIPI_FRAMES];
+	uint32_t host2sp_cont_num_raw_frames;
+	uint32_t host2sp_cont_num_mipi_frames;
+	struct sh_css_event_irq_mask host2sp_event_irq_mask[NR_OF_PIPELINES];
+
+};
+
+struct host_sp_queues {
+	/*
+	 * Queues for the dynamic frame information,
+	 * i.e. the "in_frame" buffer, the "out_frame"
+	 * buffer and the "vf_out_frame" buffer.
+	 */
+	struct sh_css_circular_buf host2sp_buffer_queues
+		[SH_CSS_MAX_SP_THREADS][SH_CSS_NUM_BUFFER_QUEUES];
+	struct sh_css_circular_buf sp2host_buffer_queues
+		[SH_CSS_NUM_BUFFER_QUEUES];
+
+	/*
+	 * The queue for the events.
+	 */
+	struct sh_css_circular_buf host2sp_event_queue;
+	struct sh_css_circular_buf sp2host_event_queue;
+};
+
+struct ia_css_isp_gamma_table {
+	uint16_t data[SH_CSS_ISP_GAMMA_TABLE_SIZE];
+};
+
+struct ia_css_isp_ctc_table {
+	uint16_t data[SH_CSS_ISP_CTC_TABLE_SIZE];
+};
+
+struct ia_css_isp_rgb_gamma_table {
+	uint16_t data[SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE];
+};
+
+struct ia_css_isp_xnr_table {
+	uint16_t data[SH_CSS_ISP_XNR_TABLE_SIZE];
+};
+
+extern int (*sh_css_printf) (const char *fmt, ...);
+
+#if 0
+#ifdef __HIVECC
+/* inline functions in hivecc cannot use varargs */
+static void
+#else
+STORAGE_CLASS_INLINE void
+#endif
+sh_css_print(const char *fmt, ...)
+{
+	va_list ap;
+
+	if (sh_css_printf) {
+		va_start(ap, fmt);
+		sh_css_printf(fmt, ap);
+		va_end(ap);
+	}
+}
+#else
+#define sh_css_print(fmt, s...) \
+        do { \
+                if (sh_css_printf) { \
+                        sh_css_printf(fmt, ## s); \
+                } \
+        } while (0)
+#endif
+
+#if 0
+#ifdef __HIVECC
+/* inline functions in hivecc cannot use varargs */
+static void
+#else
+STORAGE_CLASS_INLINE void
+#endif
+sh_css_vprint(const char *fmt, va_list args)
+{
+	if (sh_css_printf)
+		sh_css_printf(fmt, args);
+}
+#else
+#define sh_css_vprint(fmt, s...) \
+        if (sh_css_printf) { \
+                sh_css_printf(fmt, ## s); \
+        }
+#endif
+
+hrt_vaddress
+sh_css_params_ddr_address_map(void);
+
+enum ia_css_err
+sh_css_params_init(void);
+
+void
+sh_css_params_uninit(void);
+
+void
+sh_css_params_reconfigure_gdc_lut(void);
+
+void *
+sh_css_malloc(size_t size);
+
+void *
+sh_css_calloc(size_t N, size_t size);
+
+void
+sh_css_free(void *ptr);
+
+/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
+extern void
+sh_css_flush(struct ia_css_acc_fw *fw);
+
+/* Check two frames for equality (format, resolution, bits per element) */
+bool
+sh_css_frame_equal_types(const struct ia_css_frame *frame_a,
+			 const struct ia_css_frame *frame_b);
+
+bool
+sh_css_frame_info_equal_resolution(const struct ia_css_frame_info *info_a,
+				   const struct ia_css_frame_info *info_b);
+
+unsigned int
+sh_css_input_format_bits_per_pixel(enum ia_css_stream_format format,
+				   bool two_ppc);
+
+enum ia_css_err
+sh_css_vf_downscale_log2(const struct ia_css_frame_info *out_info,
+			 const struct ia_css_frame_info *vf_info,
+			 unsigned int *downscale_log2);
+
+void
+sh_css_capture_enable_bayer_downscaling(bool enable);
+
+void
+sh_css_binary_print(const struct sh_css_binary *binary);
+
+#if SP_DEBUG !=SP_DEBUG_NONE
+
+void
+sh_css_print_sp_debug_state(const struct sh_css_sp_debug_state *state);
+
+#endif
+
+void
+sh_css_frame_info_set_width(struct ia_css_frame_info *info,
+			    unsigned int width,
+			    unsigned int aligned); // this can be used for an extra alignemt requirement. when 0, no extra alignment is done.
+
+/* Return whether the sp copy process should be started */
+bool
+sh_css_continuous_start_sp_copy(void);
+
+bool
+sh_css_pipe_uses_params(struct sh_css_pipeline *me);
+
+hrt_vaddress
+sh_css_store_sp_group_to_ddr(void);
+
+hrt_vaddress
+sh_css_store_sp_stage_to_ddr(unsigned pipe, unsigned stage);
+
+hrt_vaddress
+sh_css_store_isp_stage_to_ddr(unsigned pipe, unsigned stage);
+
+void
+sh_css_frame_info_init(struct ia_css_frame_info *info,
+		       unsigned int width,
+		       unsigned int height,
+		       enum ia_css_frame_format format,
+		       unsigned int aligned);
+
+bool
+sh_css_enqueue_frame(unsigned int pipe_num,
+		     enum sh_css_frame_id frame_id,
+		     struct ia_css_frame *frame);
+
+/**
+ * @brief Query the SP thread ID.
+ *
+ * @param[in]	key	The query key, typical use is pipe_num.
+ * @param[out]	val	The query value.
+ *
+ * @return
+ *	true, if the query succeeds;
+ *	false, if the query fails.
+ */
+bool
+sh_css_query_sp_thread_id(unsigned int key,
+			  unsigned int *val);
+
+/**
+ * @brief Query the internal frame ID.
+ *
+ * @param[in]	key	The query key.
+ * @param[out]	val	The query value.
+ *
+ * @return
+ *	true, if the query succeeds;
+ *	false, if the query fails.
+ */
+bool
+sh_css_query_internal_queue_id(enum ia_css_buffer_type key,
+		enum sh_css_buffer_queue_id *val);
+
+void
+sh_css_update_uds_and_crop_info(
+		const struct ia_css_binary_info *info,
+		const struct ia_css_frame_info *in_frame_info,
+		const struct ia_css_frame_info *out_frame_info,
+		const struct ia_css_resolution *dvs_env,
+		bool preview_mode,
+		const struct ia_css_dz_config *zoom,
+		const struct ia_css_vector *motion_vector,
+		struct sh_css_uds_info *uds,		/* out */
+		struct sh_css_crop_pos *sp_out_crop_pos	/* out */
+		);
+
+void
+sh_css_invalidate_shading_tables(struct ia_css_stream *stream);
+
+struct sh_css_pipeline *
+ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe);
+
+unsigned int
+ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe);
+
+unsigned int
+ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe);
+
+bool
+sh_css_continuous_is_enabled(uint8_t pipe_num);
+
+#endif /* _SH_CSS_INTERNAL_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_legacy.h b/drivers/media/atomisp2/css2400/sh_css_legacy.h
new file mode 100644
index 0000000..3b146f0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_legacy.h
@@ -0,0 +1,119 @@
+#ifndef _SH_CSS_LEGACY_H_
+#define _SH_CSS_LEGACY_H_
+
+#include "ia_css.h"
+
+/** The pipe id type, distinguishes the kind of pipes that
+ *  can be run in parallel.
+ */
+enum ia_css_pipe_id {
+	IA_CSS_PIPE_ID_PREVIEW,
+	IA_CSS_PIPE_ID_COPY,
+	IA_CSS_PIPE_ID_VIDEO,
+	IA_CSS_PIPE_ID_CAPTURE,
+	IA_CSS_PIPE_ID_ACC,
+};
+#define IA_CSS_PIPE_ID_NUM (IA_CSS_PIPE_ID_ACC + 1)
+
+struct ia_css_pipe_extra_config {
+	bool enable_raw_binning;
+	bool enable_yuv_ds;
+	bool enable_high_speed;
+	bool enable_dvs_6axis;
+	bool enable_reduced_pipe;
+	bool enable_dz;
+	bool disable_vf_pp;
+	bool disable_capture_pp;
+};
+
+enum ia_css_err
+ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			 const struct ia_css_pipe_extra_config *extra_config,
+			 struct ia_css_pipe **pipe);
+
+void
+ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config);
+
+enum ia_css_err
+ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
+			    enum ia_css_pipe_id *pipe_id);
+
+/** @brief Return the value of a SW interrupt.
+ *
+ * @param[in] irq	The software interrupt id.
+ * @return		The value for the software interrupt.
+ */
+unsigned int
+sh_css_get_sw_interrupt_value(unsigned int irq);
+
+/** @brief Return whether UV range starts at 0.
+ *
+ * @param[out]	uv_offset_is_zero	Pointer to the result value.
+
+ *  Return true if UV values range from 0 to 255 and false if UV values
+ *  range from -127 to 128.
+ */
+void
+sh_css_uv_offset_is_zero(bool *uv_offset_is_zero);
+
+/** @brief Enable cont_capt mode (continuous preview+capture running together).
+ *
+ * @param	enable	Enabling value.
+ *
+ * Enable or disable continuous binaries if available. Default is disabled.
+ */
+void
+sh_css_enable_cont_capt(bool enable, bool stop_copy_preview);
+
+/** @brief Initialize the buffer queues in SP dmem
+ *
+ */
+void
+sh_css_init_buffer_queues(void);
+
+enum ia_css_err
+ia_css_pipe_id_set_irq_mask(enum ia_css_pipe_id pipe_id,
+			    unsigned int or_mask,
+			    unsigned int and_mask);
+
+/* DEPRECATED. FPN is not supported. */
+enum ia_css_err
+sh_css_set_black_frame(struct ia_css_stream *stream,
+			const struct ia_css_frame *raw_black_frame);
+
+/** @brief Allocate a CSS MIPI frame structure of given size in bytes..
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	size_bytes	The frame size in bytes.
+ * @param[in]	contiguous	Allocate memory physically contiguously or not.
+ * @return		The error code.
+ *
+ * Allocate a frame using the given size in bytes.
+ * The frame structure is partially null initialized.
+ */
+enum ia_css_err
+ia_css_mipi_frame_allocate(struct	ia_css_frame **frame,
+				const unsigned int	size_bytes,
+				const bool			contiguous);
+
+/** @brief Calculate the size of a mipi frame.
+ *
+ * @param[in]	width		The width (in pixels) of the frame.
+ * @param[in]	height		The height (in lines) of the frame.
+ * @param[in]	format		The frame (MIPI) format.
+ * @param[in]	hasSOLandEOL	Whether frame (MIPI) contains (optional) SOL and EOF packets.
+ * @param[in]	embedded_data_size_words		Embedded data size in memory words.
+ * @param		size_mem_words					The mipi frame size in memory words (32B).
+ * @return		The error code.
+ *
+ * Calculate the size of a mipi frame, based on the resolution and format. 
+ */
+enum ia_css_err
+ia_css_mipi_frame_calculate_size(const unsigned int width,
+				const unsigned int height,
+				const enum ia_css_stream_format format,
+				const bool hasSOLandEOL,
+				const unsigned int embedded_data_size_words,
+				unsigned int *size_mem_words);
+
+#endif /* _SH_CSS_LEGACY_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_metrics.c b/drivers/media/atomisp2/css2400/sh_css_metrics.c
new file mode 100644
index 0000000..66505e0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_metrics.c
@@ -0,0 +1,180 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sh_css_metrics.h"
+
+#include "sp.h"
+#include "isp.h"
+
+#include "sh_css_internal.h"
+
+#define MULTIPLE_PCS 0
+#define SUSPEND      0
+#define NOF_PCS      1
+#define RESUME_MASK  0x8
+#define STOP_MASK    0x0
+
+static bool pc_histogram_enabled;
+static struct sh_css_pc_histogram *isp_histogram;
+static struct sh_css_pc_histogram *sp_histogram;
+
+struct sh_css_metrics sh_css_metrics;
+
+void
+sh_css_metrics_start_frame(void)
+{
+	sh_css_metrics.frame_metrics.num_frames++;
+}
+
+static void
+clear_histogram(struct sh_css_pc_histogram *histogram)
+{
+	unsigned i;
+	for (i = 0; i < histogram->length; i++) {
+		histogram->run[i] = 0;
+		histogram->stall[i] = 0;
+		histogram->msink[i] = 0xFFFF;
+	}
+}
+
+void
+sh_css_metrics_enable_pc_histogram(bool enable)
+{
+	pc_histogram_enabled = enable;
+}
+
+static void
+make_histogram(struct sh_css_pc_histogram *histogram, unsigned length)
+{
+	if (histogram->length)
+		return;
+	if (histogram->run)
+		return;
+	histogram->run = sh_css_malloc(length * sizeof(*histogram->run));
+	if (!histogram->run)
+		return;
+	histogram->stall = sh_css_malloc(length * sizeof(*histogram->stall));
+	if (!histogram->stall)
+		return;
+	histogram->msink = sh_css_malloc(length * sizeof(*histogram->msink));
+	if (!histogram->msink)
+		return;
+
+	histogram->length = length;
+	clear_histogram(histogram);
+}
+
+static void
+insert_binary_metrics(struct sh_css_binary_metrics **l,
+			struct sh_css_binary_metrics *metrics)
+{
+	for (; *l; l = &(*l)->next)
+		if (*l == metrics)
+			return;
+
+	*l = metrics;
+	metrics->next = NULL;
+}
+
+void
+sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
+{
+	if (!pc_histogram_enabled)
+		return;
+
+	isp_histogram = &metrics->isp_histogram;
+	sp_histogram = &metrics->sp_histogram;
+	make_histogram(isp_histogram, ISP_PMEM_DEPTH);
+	make_histogram(sp_histogram, SP_PMEM_DEPTH);
+	insert_binary_metrics(&sh_css_metrics.binary_metrics, metrics);
+}
+
+void
+sh_css_metrics_sample_pcs(void)
+{
+	bool stall;
+	unsigned int pc;
+	unsigned int msink;
+
+#if SUSPEND
+	unsigned int sc = 0;
+	unsigned int stopped_sc = 0;
+	unsigned int resume_sc = 0;
+#endif
+
+
+#if MULTIPLE_PCS
+	int i;
+	unsigned int pc_tab[NOF_PCS] ;
+
+	for (i = 0; i < NOF_PCS; i++)
+		pc_tab[i] = 0;
+#endif
+
+	if (!pc_histogram_enabled)
+		return;
+
+	if (isp_histogram) {
+#if SUSPEND
+		/* STOP the ISP */
+		isp_ctrl_store(ISP0_ID, ISP_SC_REG, STOP_MASK);
+#endif
+		msink = isp_ctrl_load(ISP0_ID, ISP_CTRL_SINK_REG);
+#if MULTIPLE_PCS
+		for (i = 0; i < NOF_PCS; i++)
+			pc_tab[i] = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
+#else
+		pc = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
+#endif
+
+#if SUSPEND
+		/* RESUME the ISP */
+		isp_ctrl_store(ISP0_ID, ISP_SC_REG, RESUME_MASK);
+#endif
+		isp_histogram->msink[pc] &= msink;
+		stall = (msink != 0x7FF);
+
+		if (stall)
+			isp_histogram->stall[pc]++;
+		else
+			isp_histogram->run[pc]++;
+
+#if MULTIPLE_PCS
+		printk(KERN_INFO "msink = 0%X\n", msink);
+		for (i = 0; i < NOF_PCS; i++)
+			printk(KERN_INFO "PC = %d  ", pc_tab[i]);
+		printk(KERN_INFO "\n");
+#endif
+	}
+
+	if (sp_histogram && 0) {
+		msink = sp_ctrl_load(SP0_ID, SP_CTRL_SINK_REG);
+		pc = sp_ctrl_load(SP0_ID, SP_PC_REG);
+		sp_histogram->msink[pc] &= msink;
+		stall = (msink != 0x7FF);
+		if (stall)
+			sp_histogram->stall[pc]++;
+		else
+			sp_histogram->run[pc]++;
+	}
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_metrics.h b/drivers/media/atomisp2/css2400/sh_css_metrics.h
new file mode 100644
index 0000000..260333b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_metrics.h
@@ -0,0 +1,89 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_METRICS_H_
+#define _SH_CSS_METRICS_H_
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#else
+#include <stdbool.h>
+#endif
+
+struct sh_css_pc_histogram {
+	unsigned length;
+	unsigned *run;
+	unsigned *stall;
+	unsigned *msink;
+};
+
+#if !defined(__USE_DESIGNATED_INITIALISERS__)
+#define DEFAULT_PC_HISTOGRAM \
+{ \
+	0, \
+	NULL, \
+	NULL, \
+	NULL \
+}
+#endif
+
+struct sh_css_binary_metrics {
+	unsigned mode;
+	unsigned id;
+	struct sh_css_pc_histogram isp_histogram;
+	struct sh_css_pc_histogram sp_histogram;
+	struct sh_css_binary_metrics *next;
+};
+
+#if !defined(__USE_DESIGNATED_INITIALISERS__)
+#define DEFAULT_BINARY_METRICS \
+{ \
+	0, \
+	0, \
+	DEFAULT_PC_HISTOGRAM, \
+	DEFAULT_PC_HISTOGRAM, \
+	NULL \
+}
+#endif
+
+struct ia_css_frame_metrics {
+	unsigned num_frames;
+};
+
+struct sh_css_metrics {
+	struct sh_css_binary_metrics *binary_metrics;
+	struct ia_css_frame_metrics   frame_metrics;
+};
+
+extern struct sh_css_metrics sh_css_metrics;
+
+/* includes sh_css_binary.h, which depends on sh_css_metrics.h */
+#include "ia_css_types.h"
+
+/* Sample ISP and SP pc and add to histogram */
+void sh_css_metrics_enable_pc_histogram(bool enable);
+void sh_css_metrics_start_frame(void);
+void sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics);
+void sh_css_metrics_sample_pcs(void);
+
+#endif /* _SH_CSS_METRICS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_dvs.c b/drivers/media/atomisp2/css2400/sh_css_param_dvs.c
new file mode 100644
index 0000000..915b1a7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_dvs.c
@@ -0,0 +1,226 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+
+#include "ia_css.h"
+#include "sh_css_param_dvs.h"
+#include "sh_css_debug.h"
+
+#include <linux/string.h>		/* memcpy() */
+
+
+struct ia_css_dvs_6axis_config *
+generate_dvs_6axis_table(const struct ia_css_resolution	*frame_res, const struct ia_css_resolution *dvs_offset)
+{
+
+	unsigned int x,y;
+	unsigned int width_y;
+	unsigned int height_y;
+	unsigned int width_uv;
+	unsigned int height_uv;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_dvs_6axis_config  *dvs_config = NULL;
+
+	dvs_config = (struct ia_css_dvs_6axis_config *)sh_css_malloc(sizeof(struct ia_css_dvs_6axis_config));
+	if(dvs_config == NULL)
+	{
+		sh_css_dtrace(SH_DBG_TRACE, "out of memory\n");
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+	else
+	{	/*Initialize new struct with latest config settings*/
+		dvs_config->width_y = width_y = DVS_TABLE_IN_BLOCKDIM_X_LUMA(frame_res->width);
+		dvs_config->height_y = height_y = DVS_TABLE_IN_BLOCKDIM_Y_LUMA(frame_res->height);
+		dvs_config->width_uv = width_uv = DVS_TABLE_IN_BLOCKDIM_X_CHROMA(frame_res->width / 2); /* UV = Y/2, depens on colour format YUV 4.2.0*/
+		dvs_config->height_uv = height_uv = DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(frame_res->height / 2);
+
+		sh_css_dtrace(SH_DBG_TRACE, "generate_dvs_6axis_table: Env_X %d Env_Y %d\n",dvs_offset->width,dvs_offset->height);
+		sh_css_dtrace(SH_DBG_TRACE, "generate_dvs_6axis_table Y: W %d H %d\n",width_y,height_y);
+
+		dvs_config->xcoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+		if(dvs_config->xcoords_y == NULL)
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_y; y++)
+			{
+				for(x=0;x<width_y;x++)
+				{
+					dvs_config->xcoords_y[y*width_y + x] =  (  ( dvs_offset->width + x*DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS );
+			}
+		}
+		}
+
+		dvs_config->ycoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+		if(dvs_config->ycoords_y == NULL)
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_y; y++)
+			{
+				for(x=0;x<width_y;x++)
+				{
+					dvs_config->ycoords_y[y*width_y + x] =  (  ( dvs_offset->height + y*DVS_BLOCKDIM_Y_LUMA) << DVS_COORD_FRAC_BITS );
+			}
+		}
+		}
+
+		/* TODO : generate UV buffers  */
+		sh_css_dtrace(SH_DBG_TRACE, "generate_dvs_6axis_table UV W %d H %d\n",width_uv,height_uv);
+		
+		dvs_config->xcoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));	
+		if(dvs_config->xcoords_uv == NULL)
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{			
+			for(y = 0; y < height_uv; y++)
+			{
+				for(x=0;x<width_uv;x++)
+				{	/* Envelope dimesions set in Ypixels hence offset UV = offset Y/2 */
+					dvs_config->xcoords_uv[y*width_uv + x] =  (  ( (dvs_offset->width / 2) + x*DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS ); 
+				}
+			}
+		}
+		    
+		dvs_config->ycoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+		if(dvs_config->ycoords_uv == NULL)
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{	
+			for(y = 0; y < height_uv; y++)
+			{
+				for(x=0;x<width_uv;x++)
+				{ 	/* Envelope dimesions set in Ypixels hence offset UV = offset Y/2 */
+					dvs_config->ycoords_uv[y*width_uv + x] =  (  ( (dvs_offset->height / 2) + y*DVS_BLOCKDIM_Y_CHROMA) << DVS_COORD_FRAC_BITS );
+				}
+			}
+		}
+		
+#if 0
+		for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_y;x++)
+				sh_css_dtrace(SH_DBG_TRACE, "xcoords_y: %d \n",dvs_config->xcoords_y[y*width_y + x]);
+			sh_css_dtrace(SH_DBG_TRACE, "\n");
+		}
+
+		for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_y;x++)
+				sh_css_dtrace(SH_DBG_TRACE, "ycoords_y: %d \n",dvs_config->ycoords_y[y*width_y + x]);
+			sh_css_dtrace(SH_DBG_TRACE, "\n");
+		}
+
+		for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_uv;x++)
+				sh_css_dtrace(SH_DBG_TRACE, "xcoords_uv: %d \n",dvs_config->xcoords_uv[y*width_uv + x]); 
+			sh_css_dtrace(SH_DBG_TRACE, "\n");
+		}
+		
+		for(y = 0; y < height_uv; y++)
+		{
+			for(x=0;x<width_uv;x++)
+				sh_css_dtrace(SH_DBG_TRACE, "ycoords_uv: %d \n",dvs_config->ycoords_uv[y*width_uv + x]); 
+			sh_css_dtrace(SH_DBG_TRACE, "\n");
+		}				
+#endif		    
+		if (err != IA_CSS_SUCCESS)
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "generate_dvs_6axis_table: err %d\n, leave() ",(int)err);	
+			dvs_config = NULL;
+		}
+		else
+		{
+			sh_css_dtrace(SH_DBG_TRACE, "generate_dvs_6axis_table leave() , dvs_config %p\n",dvs_config);
+		}
+	}
+
+	return dvs_config;
+}
+
+void
+free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config)
+{
+	if( (dvs_6axis_config != NULL) && (*dvs_6axis_config != NULL) ) 
+	{
+		sh_css_dtrace(SH_DBG_TRACE, "-> free_dvs_6axis_table dvs_6axis_config %p\n",(*dvs_6axis_config));
+		if((*dvs_6axis_config)->xcoords_y != NULL)
+		{
+			 sh_css_free((*dvs_6axis_config)->xcoords_y);
+			 (*dvs_6axis_config)->xcoords_y = NULL;
+		}
+		
+		if((*dvs_6axis_config)->ycoords_y != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->ycoords_y);
+			(*dvs_6axis_config)->ycoords_y = NULL;
+		}
+
+
+		if((*dvs_6axis_config)->xcoords_uv != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->xcoords_uv);
+			(*dvs_6axis_config)->xcoords_uv = NULL;
+		}
+		
+		if((*dvs_6axis_config)->ycoords_uv != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->ycoords_uv);
+			(*dvs_6axis_config)->ycoords_uv = NULL;
+		}
+		
+		sh_css_free(*dvs_6axis_config);
+		*dvs_6axis_config = NULL;
+	}
+	sh_css_dtrace(SH_DBG_TRACE, "<- free_dvs_6axis_table dvs_6axis_config %p\n",(*dvs_6axis_config));
+}
+
+void copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
+			const struct ia_css_dvs_6axis_config *dvs_config_src)
+{
+	unsigned int width_y = dvs_config_src->width_y;
+	unsigned int height_y =  dvs_config_src->height_y;
+	unsigned int width_uv = dvs_config_src->width_uv; /* = Y/2, depens on colour format YUV 4.2.0*/
+	unsigned int height_uv = dvs_config_src->height_uv;   
+
+	memcpy(dvs_config_dst->xcoords_y,dvs_config_src->xcoords_y, (width_y * height_y * sizeof(uint32_t)));
+	memcpy(dvs_config_dst->ycoords_y,dvs_config_src->ycoords_y, (width_y * height_y * sizeof(uint32_t)));
+
+	memcpy(dvs_config_dst->xcoords_uv,dvs_config_src->xcoords_uv, (width_uv * height_uv * sizeof(uint32_t)));
+	memcpy(dvs_config_dst->ycoords_uv,dvs_config_src->ycoords_uv, (width_uv * height_uv * sizeof(uint32_t)));
+
+}
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_dvs.h b/drivers/media/atomisp2/css2400/sh_css_param_dvs.h
new file mode 100644
index 0000000..5335055
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_dvs.h
@@ -0,0 +1,73 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_PARAMS_DVS_H_
+#define _SH_CSS_PARAMS_DVS_H_
+
+#include "ia_css.h"
+
+#define DVS_ENV_MIN_X (12)
+#define DVS_ENV_MIN_Y (12)
+ 
+#define DVS_BLOCKDIM_X (64)        /* X block height*/
+#define DVS_BLOCKDIM_Y_LUMA (64)   /* Y block height*/
+#define DVS_BLOCKDIM_Y_CHROMA (32) /* UV height block size is half the Y block height*/
+
+#define DVS_NUM_BLOCKS_X(X)    (CEIL_MUL(CEIL_DIV((X), DVS_BLOCKDIM_X), 2))      // horizontal 64x64 blocks round up to DVS_BLOCKDIM_X, make even
+#define DVS_NUM_BLOCKS_Y(X)             (CEIL_DIV((X), DVS_BLOCKDIM_Y_LUMA))     // vertical   64x64 blocks round up to DVS_BLOCKDIM_Y
+#define DVS_NUM_BLOCKS_X_CHROMA(X)      (CEIL_DIV((X), DVS_BLOCKDIM_X))
+#define DVS_NUM_BLOCKS_Y_CHROMA(X)      (CEIL_DIV((X), DVS_BLOCKDIM_Y_CHROMA))
+
+
+#define DVS_TABLE_IN_BLOCKDIM_X_LUMA(X)   	(DVS_NUM_BLOCKS_X(X) + 1)  // N blocks have N + 1 set of coords 
+#define DVS_TABLE_IN_BLOCKDIM_X_CHROMA(X)   (DVS_NUM_BLOCKS_X_CHROMA(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_LUMA(X)		(DVS_NUM_BLOCKS_Y(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(X)	(DVS_NUM_BLOCKS_Y_CHROMA(X) + 1)
+
+#define DVS_ENVELOPE_X(X) (((X) == 0) ? (DVS_ENV_MIN_X) : (X))
+#define DVS_ENVELOPE_Y(X) (((X) == 0) ? (DVS_ENV_MIN_Y) : (X))
+
+#define DVS_COORD_FRAC_BITS (10)
+#define DVS_INPUT_BYTES_PER_PIXEL (1)
+#define XMEM_ALIGN_LOG2 (5)
+
+#define DVS_6AXIS_COORDS_ELEMS CEIL_MUL(sizeof(gdc_warp_param_mem_t) \
+					, HIVE_ISP_DDR_WORD_BYTES)
+
+#define DVS_6AXIS_BYTES(binary) \
+	(DVS_6AXIS_COORDS_ELEMS \
+     *  DVS_NUM_BLOCKS_X((binary)->out_frame_info.res.width) \
+     *  DVS_NUM_BLOCKS_Y((binary)->out_frame_info.res.height)   )
+
+struct ia_css_dvs_6axis_config *
+generate_dvs_6axis_table(const struct ia_css_resolution	*frame_res, const struct ia_css_resolution *dvs_offset);
+
+void
+free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config);
+
+void 
+copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
+			 const struct ia_css_dvs_6axis_config *dvs_config_src);
+
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_shading.c b/drivers/media/atomisp2/css2400/sh_css_param_shading.c
new file mode 100644
index 0000000..3a7cefe
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_shading.c
@@ -0,0 +1,279 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "sh_css_param_shading.h"
+#include "ia_css.h"
+#include "sh_css_defs.h"
+
+#include "sh_css_hrt.h"
+
+#include "platform_support.h"
+
+/* Bilinear interpolation on shading tables:
+ * For each target point T, we calculate the 4 surrounding source points:
+ * ul (upper left), ur (upper right), ll (lower left) and lr (lower right).
+ * We then calculate the distances from the T to the source points: x0, x1,
+ * y0 and y1.
+ * We then calculate the value of T:
+ *   dx0*dy0*Slr + dx0*dy1*Sur + dx1*dy0*Sll + dx1*dy1*Sul.
+ * We choose a grid size of 1x1 which means:
+ *   dx1 = 1-dx0
+ *   dy1 = 1-dy0
+ *
+ *   Sul dx0         dx1      Sur
+ *    .<----->|<------------->.
+ *    ^
+ * dy0|
+ *    v        T
+ *    -        .
+ *    ^
+ *    |
+ * dy1|
+ *    v
+ *    .                        .
+ *   Sll                      Slr
+ *
+ * Padding:
+ * The area that the ISP operates on can include padding both on the left
+ * and the right. We need to padd the shading table such that the shading
+ * values end up on the correct pixel values. This means we must padd the
+ * shading table to match the ISP padding.
+ * We can have 5 cases:
+ * 1. All 4 points fall in the left padding.
+ * 2. The left 2 points fall in the left padding.
+ * 3. All 4 points fall in the cropped (target) region.
+ * 4. The right 2 points fall in the right padding.
+ * 5. All 4 points fall in the right padding.
+ * Cases 1 and 5 are easy to handle: we simply use the
+ * value 1 in the shading table.
+ * Cases 2 and 4 require interpolation that takes into
+ * account how far into the padding area the pixels
+ * fall. We extrapolate the shading table into the
+ * padded area and then interpolate.
+ */
+static void
+crop_and_interpolate(unsigned int cropped_width,
+		     unsigned int cropped_height,
+		     unsigned int left_padding,
+		     unsigned int right_padding,
+		     const struct ia_css_shading_table *in_table,
+		     struct ia_css_shading_table *out_table,
+		     enum ia_css_sc_color color)
+{
+	unsigned int i, j,
+		     sensor_width  = in_table->sensor_width,
+		     sensor_height = in_table->sensor_height,
+		     table_width   = in_table->width,
+		     table_height  = in_table->height,
+		     table_cell_h,
+		     out_cell_size,
+		     in_cell_size,
+		     out_start_row,
+		     padded_width;
+	int out_start_col, /* can be negative to indicate padded space */
+	    table_cell_w;
+	unsigned short *in_ptr = in_table->data[color],
+		       *out_ptr = out_table->data[color];
+
+	padded_width = cropped_width + left_padding + right_padding;
+	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
+	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
+
+	out_start_col = (sensor_width - cropped_width)/2 - left_padding;
+	out_start_row = (sensor_height - cropped_height)/2;
+	table_cell_w = (int)((table_width-1) * in_cell_size);
+	table_cell_h = (table_height-1) * in_cell_size;
+
+	for (i = 0; i < out_table->height; i++) {
+		unsigned int ty, src_y0, src_y1, sy0, sy1, dy0, dy1, divy;
+
+		/* calculate target point and make sure it falls within
+		   the table */
+		ty = out_start_row + i * out_cell_size;
+		ty = min(ty, sensor_height-1);
+		ty = min(ty, table_cell_h);
+
+		/* calculate closest source points in shading table and
+		   make sure they fall within the table */
+		src_y0 = ty / in_cell_size;
+		if (in_cell_size < out_cell_size)
+			src_y1 = (ty + out_cell_size) / in_cell_size;
+		else
+			src_y1 = src_y0 + 1;
+		src_y0 = min(src_y0, table_height-1);
+		src_y1 = min(src_y1, table_height-1);
+		/* calculate closest source points for distance computation */
+		sy0 = min(src_y0 * in_cell_size, sensor_height-1);
+		sy1 = min(src_y1 * in_cell_size, sensor_height-1);
+		/* calculate distance between source and target pixels */
+		dy0 = ty - sy0;
+		dy1 = sy1 - ty;
+		divy = sy1 - sy0;
+		if (divy == 0) {
+			dy0 = 1;
+			divy = 1;
+		}
+
+		for (j = 0; j < out_table->width; j++, out_ptr++) {
+			int tx, src_x0, src_x1;
+			unsigned int sx0, sx1, dx0, dx1, divx;
+			unsigned short s_ul, s_ur, s_ll, s_lr;
+
+			/* calculate target point */
+			tx = out_start_col + j * out_cell_size;
+			/* calculate closest source points. */
+			src_x0 = tx / (int)in_cell_size;
+			if (in_cell_size < out_cell_size) {
+				src_x1 = (tx + out_cell_size) /
+					 (int)in_cell_size;
+			} else {
+				src_x1 = src_x0 + 1;
+			}
+			/* if src points fall in padding, select closest ones.*/
+			src_x0 = clamp(src_x0, 0, (int)table_width-1);
+			src_x1 = clamp(src_x1, 0, (int)table_width-1);
+			tx = min(clamp(tx, 0, (int)sensor_width-1),
+				 (int)table_cell_w);
+			/* calculate closest source points for distance
+			   computation */
+			sx0 = min(src_x0 * in_cell_size, sensor_width-1);
+			sx1 = min(src_x1 * in_cell_size, sensor_width-1);
+			/* calculate distances between source and target
+			   pixels */
+			dx0 = tx - sx0;
+			dx1 = sx1 - tx;
+			divx = sx1 - sx0;
+			/* if we're at the edge, we just use the closest
+			   point still in the grid. We make up for the divider
+			   in this case by setting the distance to
+			   out_cell_size, since it's actually 0. */
+			if (divx == 0) {
+				dx0 = 1;
+				divx = 1;
+			}
+
+			/* get source pixel values */
+			s_ul = in_ptr[(table_width*src_y0)+src_x0];
+			s_ur = in_ptr[(table_width*src_y0)+src_x1];
+			s_ll = in_ptr[(table_width*src_y1)+src_x0];
+			s_lr = in_ptr[(table_width*src_y1)+src_x1];
+
+			*out_ptr = (dx0*dy0*s_lr +
+				    dx0*dy1*s_ur +
+				    dx1*dy0*s_ll +
+				    dx1*dy1*s_ul) / (divx*divy);
+		}
+	}
+}
+
+static void
+generate_id_shading_table(struct ia_css_shading_table **target_table,
+			  const struct sh_css_binary *binary)
+{
+	/* initialize table with ones, shift becomes zero */
+	unsigned int i, j, table_width, table_height;
+	struct ia_css_shading_table *result;
+
+	table_width  = binary->sctbl_width_per_color;
+	table_height = binary->sctbl_height;
+	result = ia_css_shading_table_alloc(table_width, table_height);
+	if (result == NULL) {
+		*target_table = NULL;
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		for (j = 0; j < table_height * table_width; j++)
+			result->data[i][j] = 1;
+	}
+	result->fraction_bits = 0;
+	*target_table = result;
+}
+
+void
+prepare_shading_table(const struct ia_css_shading_table *in_table,
+		      unsigned int sensor_binning,
+		      struct ia_css_shading_table **target_table,
+		      const struct sh_css_binary *binary)
+{
+	unsigned int input_width,
+		     input_height,
+		     table_width,
+		     table_height,
+		     left_padding,
+		     right_padding,
+		     i;
+	struct ia_css_shading_table *result;
+
+	if (!in_table) {
+		generate_id_shading_table(target_table, binary);
+		return;
+	}
+
+	/* We use the ISP input resolution for the shading table because
+	   shading correction is performed in the bayer domain (before bayer
+	   down scaling). */
+	input_height  = binary->in_frame_info.res.height;
+	input_width   = binary->in_frame_info.res.width;
+	left_padding  = binary->left_padding;
+	right_padding = binary->in_frame_info.padded_width -
+			(input_width + left_padding);
+
+	/* We take into account the binning done by the sensor. We do this
+	   by cropping the non-binned part of the shading table and then
+	   increasing the size of a grid cell with this same binning factor. */
+	input_width  <<= sensor_binning;
+	input_height <<= sensor_binning;
+	/* We also scale the padding by the same binning factor. This will
+	   make it much easier later on to calculate the padding of the
+	   shading table. */
+	left_padding  <<= sensor_binning;
+	right_padding <<= sensor_binning;
+
+	/* during simulation, the used resolution can exceed the sensor
+	   resolution, so we clip it. */
+	input_width  = min(input_width,  in_table->sensor_width);
+	input_height = min(input_height, in_table->sensor_height);
+
+	table_width  = binary->sctbl_width_per_color;
+	table_height = binary->sctbl_height;
+
+	result = ia_css_shading_table_alloc(table_width, table_height);
+	if (result == NULL) {
+		*target_table = NULL;
+		return;
+	}
+	result->sensor_width  = in_table->sensor_width;
+	result->sensor_height = in_table->sensor_height;
+	result->fraction_bits = in_table->fraction_bits;
+
+	/* now we crop the original shading table and then interpolate to the
+	   requested resolution and decimation factor. */
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		crop_and_interpolate(input_width, input_height,
+				     left_padding, right_padding,
+				     in_table,
+				     result, i);
+	}
+	*target_table = result;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_shading.h b/drivers/media/atomisp2/css2400/sh_css_param_shading.h
new file mode 100644
index 0000000..5f3886e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_shading.h
@@ -0,0 +1,36 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_PARAMS_SHADING_H_
+#define _SH_CSS_PARAMS_SHADING_H_
+
+#include "ia_css.h"
+#include "sh_css_binary.h"
+
+void
+prepare_shading_table(const struct ia_css_shading_table *in_table,
+		      unsigned int sensor_binning,
+		      struct ia_css_shading_table **target_table,
+		      const struct sh_css_binary *binary);
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_params.c b/drivers/media/atomisp2/css2400/sh_css_params.c
new file mode 100644
index 0000000..8d35043
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params.c
@@ -0,0 +1,6685 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "gdc_device.h"		/* gdc_lut_store(), ... */
+#include "isp.h"			/* ISP_VEC_ELEMBITS */
+#include "vamem.h"
+#if !defined(HAS_NO_HMEM)
+#ifndef __INLINE_HMEM__
+#define __INLINE_HMEM__
+#endif
+#include "hmem.h"
+#endif /* !defined(HAS_NO_HMEM) */
+#include "queue.h"			/* host2sp_enqueue_frame_data() */
+#include "sw_event.h"		/* encode_sw_event */
+
+#include "assert_support.h"
+#include "math_support.h"	/* max(), min() */
+
+#include "sh_css_params.h"
+#include "ia_css_stream.h"
+#include "sh_css_params_internal.h"
+#include "sh_css_param_shading.h"
+#include "sh_css_param_dvs.h"
+#include "sh_css_refcount.h"
+#include "sh_css_internal.h"
+#include "sh_css_defs.h"
+#include "sh_css_sp.h"
+#include "sh_css_sp_start.h"	/* SH_CSS_PREVENT_UNINIT_READS */
+#include "sh_css_debug.h"
+#include "memory_access.h"
+
+#include "platform_support.h"
+
+#define NOT_USED(a)                ((a) = (a))
+
+#define sISP_REG_BIT		      ISP_VEC_ELEMBITS
+#define uISP_REG_BIT		      ((unsigned)(sISP_REG_BIT-1))
+#define sSHIFT				    (16-sISP_REG_BIT)
+#define uSHIFT				    ((unsigned)(16-uISP_REG_BIT))
+#define sFRACTION_BITS_FITTING(a) (a-sSHIFT)
+#define uFRACTION_BITS_FITTING(a) ((unsigned)(a-uSHIFT))
+#define sISP_VAL_MIN		      (-(1<<uISP_REG_BIT))
+#define sISP_VAL_MAX		      ((1<<uISP_REG_BIT)-1)
+#define uISP_VAL_MIN		      ((unsigned)0)
+#define uISP_VAL_MAX		      ((unsigned)((1<<uISP_REG_BIT)-1))
+
+/* Convenience macro to force a value to a lower even value.
+ *  We do not want to (re)use the kernel macro round_down here
+ *  because the same code base is used internally by Silicon Hive
+ *  simulation environment, where the kernel macro is not available
+ */
+#define EVEN_FLOOR(x)	(x & ~1)
+
+/* a:fraction bits for 16bit precision, b:fraction bits for ISP precision */
+#define sDIGIT_FITTING(v, a, b) \
+	min(max((((v)>>sSHIFT) >> (sFRACTION_BITS_FITTING(a)-(b))), \
+	  sISP_VAL_MIN), sISP_VAL_MAX)
+#define uDIGIT_FITTING(v, a, b) \
+	min((unsigned)max((unsigned)(((v)>>uSHIFT) \
+	>> (uFRACTION_BITS_FITTING(a)-(b))), \
+	  uISP_VAL_MIN), uISP_VAL_MAX)
+
+#define FPNTBL_BYTES(binary) \
+	(sizeof(char) * (binary)->in_frame_info.res.height * \
+	 (binary)->in_frame_info.padded_width)
+#define SCTBL_BYTES(binary) \
+	(sizeof(unsigned short) * (binary)->sctbl_height * \
+	 (binary)->sctbl_aligned_width_per_color * IA_CSS_SC_NUM_COLORS)
+#if 0
+#define S3ATBL_BYTES(binary) \
+	(sizeof(struct ia_css_3a_output) * (binary)->s3atbl_isp_width * \
+	 (binary)->s3atbl_isp_height)
+#endif
+/* TODO: check if the stride is always the same max value or whether
+ * it varies per resolution. */
+#if 0
+#define S3ATBL_HI_LO_BYTES(binary) \
+	(ISP_S3ATBL_HI_LO_STRIDE_BYTES * (binary)->s3atbl_isp_height)
+#endif
+/* SDIS */
+#define SDIS_VER_COEF_TBL__IN_DMEM(b) \
+	_SDIS_VER_COEF_TBL_USE_DMEM(b->info->mode, b->info->enable.dis, b->info->isp_pipe_version)
+
+#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
+  (((b)->info->isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : \
+	(SDIS_VER_COEF_TBL__IN_DMEM(b) ? \
+		IA_CSS_DVS_COEF_TYPES_ON_DMEM : \
+		IA_CSS_DVS_NUM_COEF_TYPES))
+
+#define SDIS_HOR_COEF_TBL_BYTES(b) \
+	(sizeof(short) * (((b)->info->isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : IA_CSS_DVS_NUM_COEF_TYPES) * (b)->dis_hor_coef_num_isp)
+#define SDIS_VER_COEF_TBL_BYTES(b) \
+	(sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(b) * \
+		(b)->dis_ver_coef_num_isp)
+#if 0
+#define SDIS_HOR_PROJ_TBL_BYTES(b) \
+	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_hor_proj_num_isp)
+#define SDIS_VER_PROJ_TBL_BYTES(b) \
+	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_ver_proj_num_isp)
+#endif
+#define MORPH_PLANE_BYTES(binary) \
+	(SH_CSS_MORPH_TABLE_ELEM_BYTES * (binary)->morph_tbl_aligned_width * \
+	 (binary)->morph_tbl_height)
+
+/* We keep a second copy of the ptr struct for the SP to access.
+   Again, this would not be necessary on the chip. */
+static hrt_vaddress sp_ddr_ptrs;
+
+/* sp group address on DDR */
+static hrt_vaddress xmem_sp_group_ptrs;
+
+static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
+						[SH_CSS_MAX_STAGES];
+static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
+						[SH_CSS_MAX_STAGES];
+
+/* END DO NOT MOVE INTO VIMALS_WORLD */
+
+#if defined(HAS_VAMEM_VERSION_2)
+
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE] = {
+  0,   4,   8,  12,  17,  21,  27,  32,
+ 38,  44,  49,  55,  61,  66,  71,  76,
+ 80,  84,  88,  92,  95,  98, 102, 105,
+108, 110, 113, 116, 118, 121, 123, 126,
+128, 130, 132, 135, 137, 139, 141, 143,
+145, 146, 148, 150, 152, 153, 155, 156,
+158, 160, 161, 162, 164, 165, 166, 168,
+169, 170, 171, 172, 174, 175, 176, 177,
+178, 179, 180, 181, 182, 183, 184, 184,
+185, 186, 187, 188, 189, 189, 190, 191,
+192, 192, 193, 194, 195, 195, 196, 197,
+197, 198, 198, 199, 200, 200, 201, 201,
+202, 203, 203, 204, 204, 205, 205, 206,
+206, 207, 207, 208, 208, 209, 209, 210,
+210, 210, 211, 211, 212, 212, 213, 213,
+214, 214, 214, 215, 215, 216, 216, 216,
+217, 217, 218, 218, 218, 219, 219, 220,
+220, 220, 221, 221, 222, 222, 222, 223,
+223, 223, 224, 224, 225, 225, 225, 226,
+226, 226, 227, 227, 227, 228, 228, 228,
+229, 229, 229, 230, 230, 230, 231, 231,
+231, 232, 232, 232, 233, 233, 233, 234,
+234, 234, 234, 235, 235, 235, 236, 236,
+236, 237, 237, 237, 237, 238, 238, 238,
+239, 239, 239, 239, 240, 240, 240, 241,
+241, 241, 241, 242, 242, 242, 242, 243,
+243, 243, 243, 244, 244, 244, 245, 245,
+245, 245, 246, 246, 246, 246, 247, 247,
+247, 247, 248, 248, 248, 248, 249, 249,
+249, 249, 250, 250, 250, 250, 251, 251,
+251, 251, 252, 252, 252, 252, 253, 253,
+253, 253, 254, 254, 254, 254, 255, 255,
+255
+};
+
+static const uint16_t
+default_ctc_table_data[IA_CSS_VAMEM_2_CTC_TABLE_SIZE] = {
+   0,  384,  837,  957, 1011, 1062, 1083, 1080,
+1078, 1077, 1053, 1039, 1012,  992,  969,  951,
+ 929,  906,  886,  866,  845,  823,  809,  790,
+ 772,  758,  741,  726,  711,  701,  688,  675,
+ 666,  656,  648,  639,  633,  626,  618,  612,
+ 603,  594,  582,  572,  557,  545,  529,  516,
+ 504,  491,  480,  467,  459,  447,  438,  429,
+ 419,  412,  404,  397,  389,  382,  376,  368,
+ 363,  357,  351,  345,  340,  336,  330,  326,
+ 321,  318,  312,  308,  304,  300,  297,  294,
+ 291,  286,  284,  281,  278,  275,  271,  268,
+ 261,  257,  251,  245,  240,  235,  232,  225,
+ 223,  218,  213,  209,  206,  204,  199,  197,
+ 193,  189,  186,  185,  183,  179,  177,  175,
+ 172,  170,  169,  167,  164,  164,  162,  160,
+ 158,  157,  156,  154,  154,  152,  151,  150,
+ 149,  148,  146,  147,  146,  144,  143,  143,
+ 142,  141,  140,  141,  139,  138,  138,  138,
+ 137,  136,  136,  135,  134,  134,  134,  133,
+ 132,  132,  131,  130,  131,  130,  129,  128,
+ 129,  127,  127,  127,  127,  125,  125,  125,
+ 123,  123,  122,  120,  118,  115,  114,  111,
+ 110,  108,  106,  105,  103,  102,  100,   99,
+  97,   97,   96,   95,   94,   93,   93,   91,
+  91,   91,   90,   90,   89,   89,   88,   88,
+  89,   88,   88,   87,   87,   87,   87,   86,
+  87,   87,   86,   87,   86,   86,   84,   84,
+  82,   80,   78,   76,   74,   72,   70,   68,
+  67,   65,   62,   60,   58,   56,   55,   54,
+  53,   51,   49,   49,   47,   45,   45,   45,
+  41,   40,   39,   39,   34,   33,   34,   32,
+  25,   23,   24,   20,   13,    9,   12,    0,
+   0
+};
+
+static const uint16_t
+default_r_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
+4095
+};
+
+static const uint16_t
+default_g_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
+4095
+};
+
+static const uint16_t
+default_b_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
+4095
+};
+
+static const uint16_t
+default_xnr_table_data[IA_CSS_VAMEM_2_XNR_TABLE_SIZE] = {
+  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
+  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
+    546>>1, 512>>1,
+
+  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
+  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
+    256>>1,
+
+  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
+  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
+    170>>1,
+
+  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
+  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
+};
+
+#elif defined(HAS_VAMEM_VERSION_1)
+
+/* Default Parameters */
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE] = {
+		0, 1, 2, 3, 4, 5, 6, 7,
+		8, 9, 10, 11, 12, 13, 14, 16,
+		17, 18, 19, 20, 21, 23, 24, 25,
+		27, 28, 29, 31, 32, 33, 35, 36,
+		38, 39, 41, 42, 44, 45, 47, 48,
+		49, 51, 52, 54, 55, 57, 58, 60,
+		61, 62, 64, 65, 66, 68, 69, 70,
+		71, 72, 74, 75, 76, 77, 78, 79,
+		80, 81, 82, 83, 84, 85, 86, 87,
+		88, 89, 90, 91, 92, 93, 93, 94,
+		95, 96, 97, 98, 98, 99, 100, 101,
+		102, 102, 103, 104, 105, 105, 106, 107,
+		108, 108, 109, 110, 110, 111, 112, 112,
+		113, 114, 114, 115, 116, 116, 117, 118,
+		118, 119, 120, 120, 121, 121, 122, 123,
+		123, 124, 125, 125, 126, 126, 127, 127,	/* 128 */
+		128, 129, 129, 130, 130, 131, 131, 132,
+		132, 133, 134, 134, 135, 135, 136, 136,
+		137, 137, 138, 138, 139, 139, 140, 140,
+		141, 141, 142, 142, 143, 143, 144, 144,
+		145, 145, 145, 146, 146, 147, 147, 148,
+		148, 149, 149, 150, 150, 150, 151, 151,
+		152, 152, 152, 153, 153, 154, 154, 155,
+		155, 155, 156, 156, 156, 157, 157, 158,
+		158, 158, 159, 159, 160, 160, 160, 161,
+		161, 161, 162, 162, 162, 163, 163, 163,
+		164, 164, 164, 165, 165, 165, 166, 166,
+		166, 167, 167, 167, 168, 168, 168, 169,
+		169, 169, 170, 170, 170, 170, 171, 171,
+		171, 172, 172, 172, 172, 173, 173, 173,
+		174, 174, 174, 174, 175, 175, 175, 176,
+		176, 176, 176, 177, 177, 177, 177, 178,	/* 256 */
+		178, 178, 178, 179, 179, 179, 179, 180,
+		180, 180, 180, 181, 181, 181, 181, 182,
+		182, 182, 182, 182, 183, 183, 183, 183,
+		184, 184, 184, 184, 184, 185, 185, 185,
+		185, 186, 186, 186, 186, 186, 187, 187,
+		187, 187, 187, 188, 188, 188, 188, 188,
+		189, 189, 189, 189, 189, 190, 190, 190,
+		190, 190, 191, 191, 191, 191, 191, 192,
+		192, 192, 192, 192, 192, 193, 193, 193,
+		193, 193, 194, 194, 194, 194, 194, 194,
+		195, 195, 195, 195, 195, 195, 196, 196,
+		196, 196, 196, 196, 197, 197, 197, 197,
+		197, 197, 198, 198, 198, 198, 198, 198,
+		198, 199, 199, 199, 199, 199, 199, 200,
+		200, 200, 200, 200, 200, 200, 201, 201,
+		201, 201, 201, 201, 201, 202, 202, 202,	/* 384 */
+		202, 202, 202, 202, 203, 203, 203, 203,
+		203, 203, 203, 204, 204, 204, 204, 204,
+		204, 204, 204, 205, 205, 205, 205, 205,
+		205, 205, 205, 206, 206, 206, 206, 206,
+		206, 206, 206, 207, 207, 207, 207, 207,
+		207, 207, 207, 208, 208, 208, 208, 208,
+		208, 208, 208, 209, 209, 209, 209, 209,
+		209, 209, 209, 209, 210, 210, 210, 210,
+		210, 210, 210, 210, 210, 211, 211, 211,
+		211, 211, 211, 211, 211, 211, 212, 212,
+		212, 212, 212, 212, 212, 212, 212, 213,
+		213, 213, 213, 213, 213, 213, 213, 213,
+		214, 214, 214, 214, 214, 214, 214, 214,
+		214, 214, 215, 215, 215, 215, 215, 215,
+		215, 215, 215, 216, 216, 216, 216, 216,
+		216, 216, 216, 216, 216, 217, 217, 217,	/* 512 */
+		217, 217, 217, 217, 217, 217, 217, 218,
+		218, 218, 218, 218, 218, 218, 218, 218,
+		218, 219, 219, 219, 219, 219, 219, 219,
+		219, 219, 219, 220, 220, 220, 220, 220,
+		220, 220, 220, 220, 220, 221, 221, 221,
+		221, 221, 221, 221, 221, 221, 221, 221,
+		222, 222, 222, 222, 222, 222, 222, 222,
+		222, 222, 223, 223, 223, 223, 223, 223,
+		223, 223, 223, 223, 223, 224, 224, 224,
+		224, 224, 224, 224, 224, 224, 224, 224,
+		225, 225, 225, 225, 225, 225, 225, 225,
+		225, 225, 225, 226, 226, 226, 226, 226,
+		226, 226, 226, 226, 226, 226, 226, 227,
+		227, 227, 227, 227, 227, 227, 227, 227,
+		227, 227, 228, 228, 228, 228, 228, 228,
+		228, 228, 228, 228, 228, 228, 229, 229,
+		229, 229, 229, 229, 229, 229, 229, 229,
+		229, 229, 230, 230, 230, 230, 230, 230,
+		230, 230, 230, 230, 230, 230, 231, 231,
+		231, 231, 231, 231, 231, 231, 231, 231,
+		231, 231, 231, 232, 232, 232, 232, 232,
+		232, 232, 232, 232, 232, 232, 232, 233,
+		233, 233, 233, 233, 233, 233, 233, 233,
+		233, 233, 233, 233, 234, 234, 234, 234,
+		234, 234, 234, 234, 234, 234, 234, 234,
+		234, 235, 235, 235, 235, 235, 235, 235,
+		235, 235, 235, 235, 235, 235, 236, 236,
+		236, 236, 236, 236, 236, 236, 236, 236,
+		236, 236, 236, 236, 237, 237, 237, 237,
+		237, 237, 237, 237, 237, 237, 237, 237,
+		237, 237, 238, 238, 238, 238, 238, 238,
+		238, 238, 238, 238, 238, 238, 238, 238,
+		239, 239, 239, 239, 239, 239, 239, 239,
+		239, 239, 239, 239, 239, 239, 240, 240,
+		240, 240, 240, 240, 240, 240, 240, 240,
+		240, 240, 240, 240, 241, 241, 241, 241,
+		241, 241, 241, 241, 241, 241, 241, 241,
+		241, 241, 241, 242, 242, 242, 242, 242,
+		242, 242, 242, 242, 242, 242, 242, 242,
+		242, 242, 243, 243, 243, 243, 243, 243,
+		243, 243, 243, 243, 243, 243, 243, 243,
+		243, 244, 244, 244, 244, 244, 244, 244,
+		244, 244, 244, 244, 244, 244, 244, 244,
+		245, 245, 245, 245, 245, 245, 245, 245,
+		245, 245, 245, 245, 245, 245, 245, 246,
+		246, 246, 246, 246, 246, 246, 246, 246,
+		246, 246, 246, 246, 246, 246, 246, 247,
+		247, 247, 247, 247, 247, 247, 247, 247,
+		247, 247, 247, 247, 247, 247, 247, 248,
+		248, 248, 248, 248, 248, 248, 248, 248,
+		248, 248, 248, 248, 248, 248, 248, 249,
+		249, 249, 249, 249, 249, 249, 249, 249,
+		249, 249, 249, 249, 249, 249, 249, 250,
+		250, 250, 250, 250, 250, 250, 250, 250,
+		250, 250, 250, 250, 250, 250, 250, 251,
+		251, 251, 251, 251, 251, 251, 251, 251,
+		251, 251, 251, 251, 251, 251, 251, 252,
+		252, 252, 252, 252, 252, 252, 252, 252,
+		252, 252, 252, 252, 252, 252, 252, 253,
+		253, 253, 253, 253, 253, 253, 253, 253,
+		253, 253, 253, 253, 253, 253, 253, 253,
+		254, 254, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 254, 254, 254, 254,
+		255, 255, 255, 255, 255, 255, 255, 255
+};
+
+static const uint16_t
+default_ctc_table_data[IA_CSS_VAMEM_1_CTC_TABLE_SIZE] = {
+		0, 0, 256, 384, 384, 497, 765, 806,
+		837, 851, 888, 901, 957, 981, 993, 1001,
+		1011, 1029, 1028, 1039, 1062, 1059, 1073, 1080,
+		1083, 1085, 1085, 1098, 1080, 1084, 1085, 1093,
+		1078, 1073, 1070, 1069, 1077, 1066, 1072, 1063,
+		1053, 1044, 1046, 1053, 1039, 1028, 1025, 1024,
+		1012, 1013, 1016, 996, 992, 990, 990, 980,
+		969, 968, 961, 955, 951, 949, 933, 930,
+		929, 925, 921, 916, 906, 901, 895, 893,
+		886, 877, 872, 869, 866, 861, 857, 849,
+		845, 838, 836, 832, 823, 821, 815, 813,
+		809, 805, 796, 793, 790, 785, 784, 778,
+		772, 768, 766, 763, 758, 752, 749, 745,
+		741, 740, 736, 730, 726, 724, 723, 718,
+		711, 709, 706, 704, 701, 698, 691, 689,
+		688, 683, 683, 678, 675, 673, 671, 669,
+		666, 663, 661, 660, 656, 656, 653, 650,
+		648, 647, 646, 643, 639, 638, 637, 635,
+		633, 632, 629, 627, 626, 625, 622, 621,
+		618, 618, 614, 614, 612, 609, 606, 606,
+		603, 600, 600, 597, 594, 591, 590, 586,
+		582, 581, 578, 575, 572, 569, 563, 560,
+		557, 554, 551, 548, 545, 539, 536, 533,
+		529, 527, 524, 519, 516, 513, 510, 507,
+		504, 501, 498, 493, 491, 488, 485, 484,
+		480, 476, 474, 471, 467, 466, 464, 460,
+		459, 455, 453, 449, 447, 446, 443, 441,
+		438, 435, 432, 432, 429, 427, 426, 422,
+		419, 418, 416, 414, 412, 410, 408, 406,
+		404, 402, 401, 398, 397, 395, 393, 390,
+		389, 388, 387, 384, 382, 380, 378, 377,
+		376, 375, 372, 370, 368, 368, 366, 364,
+		363, 361, 360, 358, 357, 355, 354, 352,
+		351, 350, 349, 346, 345, 344, 344, 342,
+		340, 339, 337, 337, 336, 335, 333, 331,
+		330, 329, 328, 326, 326, 324, 324, 322,
+		321, 320, 318, 318, 318, 317, 315, 313,
+		312, 311, 311, 310, 308, 307, 306, 306,
+		304, 304, 302, 301, 300, 300, 299, 297,
+		297, 296, 296, 294, 294, 292, 291, 291,
+		291, 290, 288, 287, 286, 286, 287, 285,
+		284, 283, 282, 282, 281, 281, 279, 278,
+		278, 278, 276, 276, 275, 274, 274, 273,
+		271, 270, 269, 268, 268, 267, 265, 262,
+		261, 260, 260, 259, 257, 254, 252, 252,
+		251, 251, 249, 246, 245, 244, 243, 242,
+		240, 239, 239, 237, 235, 235, 233, 231,
+		232, 230, 229, 226, 225, 224, 225, 224,
+		223, 220, 219, 219, 218, 217, 217, 214,
+		213, 213, 212, 211, 209, 209, 209, 208,
+		206, 205, 204, 203, 204, 203, 201, 200,
+		199, 197, 198, 198, 197, 195, 194, 194,
+		193, 192, 192, 191, 189, 190, 189, 188,
+		186, 187, 186, 185, 185, 184, 183, 181,
+		183, 182, 181, 180, 179, 178, 178, 178,
+		177, 176, 175, 176, 175, 174, 174, 173,
+		172, 173, 172, 171, 170, 170, 169, 169,
+		169, 168, 167, 166, 167, 167, 166, 165,
+		164, 164, 164, 163, 164, 163, 162, 163,
+		162, 161, 160, 161, 160, 160, 160, 159,
+		158, 157, 158, 158, 157, 157, 156, 156,
+		156, 156, 155, 155, 154, 154, 154, 154,
+		154, 153, 152, 153, 152, 152, 151, 152,
+		151, 152, 151, 150, 150, 149, 149, 150,
+		149, 149, 148, 148, 148, 149, 148, 147,
+		146, 146, 147, 146, 147, 146, 145, 146,
+		146, 145, 144, 145, 144, 145, 144, 144,
+		143, 143, 143, 144, 143, 142, 142, 142,
+		142, 142, 142, 141, 141, 141, 141, 140,
+		140, 141, 140, 140, 141, 140, 139, 139,
+		139, 140, 139, 139, 138, 138, 137, 139,
+		138, 138, 138, 137, 138, 137, 137, 137,
+		137, 136, 137, 136, 136, 136, 136, 135,
+		136, 135, 135, 135, 135, 136, 135, 135,
+		134, 134, 133, 135, 134, 134, 134, 133,
+		134, 133, 134, 133, 133, 132, 133, 133,
+		132, 133, 132, 132, 132, 132, 131, 131,
+		131, 132, 131, 131, 130, 131, 130, 132,
+		131, 130, 130, 129, 130, 129, 130, 129,
+		129, 129, 130, 129, 128, 128, 128, 128,
+		129, 128, 128, 127, 127, 128, 128, 127,
+		127, 126, 126, 127, 127, 126, 126, 126,
+		127, 126, 126, 126, 125, 125, 126, 125,
+		125, 124, 124, 124, 125, 125, 124, 124,
+		123, 124, 124, 123, 123, 122, 122, 122,
+		122, 122, 121, 120, 120, 119, 118, 118,
+		118, 117, 117, 116, 115, 115, 115, 114,
+		114, 113, 113, 112, 111, 111, 111, 110,
+		110, 109, 109, 108, 108, 108, 107, 107,
+		106, 106, 105, 105, 105, 104, 104, 103,
+		103, 102, 102, 102, 102, 101, 101, 100,
+		100, 99, 99, 99, 99, 99, 99, 98,
+		97, 98, 97, 97, 97, 96, 96, 95,
+		96, 95, 96, 95, 95, 94, 94, 95,
+		94, 94, 94, 93, 93, 92, 93, 93,
+		93, 93, 92, 92, 91, 92, 92, 92,
+		91, 91, 90, 90, 91, 91, 91, 90,
+		90, 90, 90, 91, 90, 90, 90, 89,
+		89, 89, 90, 89, 89, 89, 89, 89,
+		88, 89, 89, 88, 88, 88, 88, 87,
+		89, 88, 88, 88, 88, 88, 87, 88,
+		88, 88, 87, 87, 87, 87, 87, 88,
+		87, 87, 87, 87, 87, 87, 88, 87,
+		87, 87, 87, 86, 86, 87, 87, 87,
+		87, 86, 86, 86, 87, 87, 86, 87,
+		86, 86, 86, 87, 87, 86, 86, 86,
+		86, 86, 87, 87, 86, 85, 85, 85,
+		84, 85, 85, 84, 84, 83, 83, 82,
+		82, 82, 81, 81, 80, 79, 79, 79,
+		78, 77, 77, 76, 76, 76, 75, 74,
+		74, 74, 73, 73, 72, 71, 71, 71,
+		70, 70, 69, 69, 68, 68, 67, 67,
+		67, 66, 66, 65, 65, 64, 64, 63,
+		62, 62, 62, 61, 60, 60, 59, 59,
+		58, 58, 57, 57, 56, 56, 56, 55,
+		55, 54, 55, 55, 54, 53, 53, 52,
+		53, 53, 52, 51, 51, 50, 51, 50,
+		49, 49, 50, 49, 49, 48, 48, 47,
+		47, 48, 46, 45, 45, 45, 46, 45,
+		45, 44, 45, 45, 45, 43, 42, 42,
+		41, 43, 41, 40, 40, 39, 40, 41,
+		39, 39, 39, 39, 39, 38, 35, 35,
+		34, 37, 36, 34, 33, 33, 33, 35,
+		34, 32, 32, 31, 32, 30, 29, 26,
+		25, 25, 27, 26, 23, 23, 23, 25,
+		24, 24, 22, 21, 20, 19, 16, 14,
+		13, 13, 13, 10, 9, 7, 7, 7,
+		12, 12, 12, 7, 0, 0, 0, 0
+};
+
+static const uint16_t
+default_r_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
+};
+
+static const uint16_t
+default_g_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
+};
+
+static const uint16_t
+default_b_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
+};
+
+static const uint16_t
+default_xnr_table_data[IA_CSS_VAMEM_1_XNR_TABLE_SIZE] = {
+  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
+  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
+    546>>1, 512>>1,
+
+  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
+  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
+    256>>1,
+
+  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
+  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
+    170>>1,
+
+  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
+  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
+};
+
+#else
+#error "sh_css_params.c: VAMEM version must \
+	be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
+#endif
+
+static struct ia_css_gamma_table     default_gamma_table;
+static struct ia_css_ctc_table       default_ctc_table;
+static struct ia_css_xnr_table       default_xnr_table;
+static struct ia_css_rgb_gamma_table default_r_gamma_table;
+static struct ia_css_rgb_gamma_table default_g_gamma_table;
+static struct ia_css_rgb_gamma_table default_b_gamma_table;
+
+#if 1
+static const struct ia_css_anr_thres default_anr_thres = {
+{128, 384, 640, 896, 896, 640, 384, 128, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 128, 384, 640, 896, 896, 640, 384, 128,
+0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20,
+0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40,
+0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60,
+30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50,
+60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100,
+90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150,
+10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30,
+20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60,
+30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90,
+20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40,
+40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80,
+60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120}
+};
+#else
+static const struct ia_css_anr_thres default_anr_thres = {
+{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+};
+#endif
+
+/* multiple axis color correction table,
+ * 64values = 2x2matrix for 16area, [s2.11].
+ */
+static const struct ia_css_macc_table default_macc_table = {
+		{ 8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192 }
+};
+
+/* Digital Zoom lookup table. See documentation for more details about the
+ * contents of this table.
+ */
+#if defined(HAS_GDC_VERSION_2)
+static const int zoom_table[4][HRT_GDC_N] = {
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4},
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+	 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4},
+	{256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
+		 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4},
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+	    -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+	    -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+	     -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
+		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4}
+};
+#else
+#error "sh_css_params.c: GDC version must be \
+	one of {GDC_VERSION_2}"
+#endif
+
+static const struct ia_css_3a_config default_3a_config = {
+	25559,
+	32768,
+	7209,
+	65535,
+	0,
+	65535,
+	{-3344, -6104, -19143, 19143, 6104, 3344, 0},
+	{1027, 0, -9219, 16384, -9219, 1027, 0}
+};
+
+static const struct ia_css_wb_config default_wb_config = {
+	1,
+	32768,
+	32768,
+	32768,
+	32768
+};
+
+static const struct ia_css_cc_config default_cc_config = {
+	8,
+	{255, 29, 120, 0, -374, -342, 0, -672, 301},
+};
+
+static const struct ia_css_tnr_config default_tnr_config = {
+	32768,
+	32,
+	32,
+};
+
+static const struct ia_css_ob_config default_ob_config = {
+	IA_CSS_OB_MODE_NONE,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0
+};
+
+static const struct ia_css_dp_config default_dp_config = {
+	8192,
+	2048
+};
+
+static const struct ia_css_nr_config default_nr_config = {
+	16384,
+	8192,
+	1280,
+	0,
+	0
+};
+
+static const struct ia_css_ee_config default_ee_config = {
+	8192,
+	128,
+	2048
+};
+
+static const struct ia_css_de_config default_de_config = {
+	0,
+	0,
+	0
+};
+
+static const struct ia_css_gc_config default_gc_config = {
+	0,
+	0
+};
+
+static const struct ia_css_anr_config default_anr_config = {
+	10,
+	{ 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4},
+	{10, 20, 30}
+};
+
+static const struct ia_css_ce_config default_ce_config = {
+	0,
+	255
+};
+
+static const struct ia_css_dz_config default_dz_config = {
+	HRT_GDC_N,
+	HRT_GDC_N
+};
+
+static const struct ia_css_vector default_motion_config = {
+	0,
+	0
+};
+
+static const struct ia_css_ecd_config default_ecd_config = {
+	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3,	/* 2/3 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1.0 */
+	0,					/* 0.0 */
+};
+
+static const struct ia_css_ynr_config default_ynr_config = {
+	0,
+	0,
+	0,
+	0,
+};
+
+static const struct ia_css_fc_config default_fc_config = {
+	1,
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
+	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
+	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
+};
+
+static const struct ia_css_cnr_config default_cnr_config = {
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0
+};
+
+static const struct ia_css_macc_config default_macc_config = {
+	0,
+};
+
+static const struct ia_css_ctc_config default_ctc_config = {
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	1,
+	SH_CSS_BAYER_MAXVAL / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 2 / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 3 / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 4 / 5,	/* To be implemented */
+};
+
+static const struct ia_css_aa_config default_aa_config = {
+	8191,
+};
+
+/*static const struct ia_css_yuv2rgb_cc_config */
+static const struct ia_css_cc_config default_yuv2rgb_cc_config = {
+	12,
+	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
+};
+
+static const struct ia_css_cc_config default_rgb2yuv_cc_config = {
+	13,
+	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
+};
+
+static enum ia_css_err
+ref_sh_css_ddr_address_map(
+		struct sh_css_ddr_address_map *map,
+		struct sh_css_ddr_address_map *out);
+
+static enum ia_css_err
+write_sh_css_address_map_to_ddr(
+		struct sh_css_ddr_address_map *map,
+		hrt_vaddress *out);
+
+static enum ia_css_err
+free_sh_css_ddr_address_map(hrt_vaddress ptr);
+
+static enum ia_css_err
+sh_css_params_write_to_ddr_internal(
+		struct ia_css_isp_parameters *params,
+		const struct sh_css_binary *binary,
+		struct sh_css_ddr_address_map *ddr_map,
+		struct sh_css_ddr_address_map_size *ddr_map_size);
+
+static void
+ia_css_set_dvs_coefficients(struct ia_css_isp_parameters *params,
+				const struct ia_css_dvs_coefficients *coefs)
+{
+	assert(coefs);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dis_coefficients() enter: \
+		hcoef=%p, vcoef=%p", coefs->hor_coefs, coefs->ver_coefs);
+	params->dis_hor_coef_tbl = coefs->hor_coefs;
+	params->dis_ver_coef_tbl = coefs->ver_coefs;
+	params->dis_coef_table_changed = true;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dis_coefficients() leave: void\n");
+}
+
+void
+ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats)
+{
+	unsigned int hor_num_isp, ver_num_isp,
+#ifdef __KERNEL__
+		     hor_bytes, ver_bytes;
+#else
+		     hor_num_dvs, ver_num_dvs, i;
+#endif
+	int *hor_ptr_dvs,
+	    *ver_ptr_dvs;
+	hrt_vaddress hor_ptr_isp,
+		     ver_ptr_isp;
+
+	assert(host_stats);
+	assert(host_stats->hor_proj);
+	assert(host_stats->ver_proj);
+	assert(isp_stats);
+	assert(isp_stats->hor_proj);
+	assert(isp_stats->ver_proj);
+
+	hor_num_isp = host_stats->grid.aligned_height;
+	ver_num_isp = host_stats->grid.aligned_width;
+	hor_ptr_isp = isp_stats->hor_proj;
+	ver_ptr_isp = isp_stats->ver_proj;
+	hor_ptr_dvs = host_stats->hor_proj;
+	ver_ptr_dvs = host_stats->ver_proj;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_projections() enter: \
+		hproj=%p, vproj=%p, \
+		haddr=%x, vaddr=%x\n",
+		host_stats->hor_proj, host_stats->ver_proj,
+		isp_stats->hor_proj, isp_stats->ver_proj);
+
+#ifdef __KERNEL__
+	/* This is the optimized code that uses the aligned_width and
+	 * aligned_height for the projections. This should be enabled in the
+	 * same patch set that adds the correct handling of these strides to
+	 * the DVS engine */
+	hor_bytes = hor_num_isp * sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES;
+	ver_bytes = ver_num_isp * sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES;
+
+	mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_bytes);
+	mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_bytes);
+#else
+	hor_num_dvs = host_stats->grid.height;
+	ver_num_dvs = host_stats->grid.width;
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_num_dvs * sizeof(int));
+		hor_ptr_isp += hor_num_isp * sizeof(int);
+		hor_ptr_dvs += hor_num_dvs;
+
+		mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_num_dvs * sizeof(int));
+		ver_ptr_isp += ver_num_isp * sizeof(int);
+		ver_ptr_dvs += ver_num_dvs;
+	}
+#endif
+
+	sh_css_dtrace(SH_DBG_TRACE,
+			"sh_css_get_dis_projections() leave: void\n");
+}
+
+static void
+ia_css_set_dvs2_coefficients(struct ia_css_isp_parameters *params,
+				const struct ia_css_dvs2_coefficients *coefs)
+{
+	assert(coefs);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs2_coefficients() enter: \
+		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
+		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
+		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
+		ver_coefs.even_real=%p, ver_coefs.even_imag=%p", 
+		coefs->hor_coefs.odd_real, coefs->hor_coefs.odd_imag,
+		coefs->hor_coefs.even_real, coefs->hor_coefs.even_imag,
+		coefs->ver_coefs.odd_real, coefs->ver_coefs.odd_imag,
+		coefs->ver_coefs.even_real, coefs->ver_coefs.even_imag);
+		
+	params->dvs2_hor_coefs = coefs->hor_coefs;
+	params->dvs2_ver_coefs = coefs->ver_coefs;
+
+	params->dvs2_coef_table_changed = true;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs2_coefficients() leave: void\n");
+}
+
+void
+ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats)
+{
+	unsigned int hor_num_isp, ver_num_isp, hor_bytes, ver_bytes;
+	hrt_vaddress hor_ptr_isp, ver_ptr_isp;
+
+	assert(host_stats);
+	assert(host_stats->hor_prod.odd_real );
+	assert(host_stats->hor_prod.odd_imag );
+	assert(host_stats->hor_prod.even_real);
+	assert(host_stats->hor_prod.even_imag);
+	assert(host_stats->ver_prod.odd_real );
+	assert(host_stats->ver_prod.odd_imag );
+	assert(host_stats->ver_prod.even_real);
+	assert(host_stats->ver_prod.even_imag);
+	assert(isp_stats);
+	assert(isp_stats->hor_proj);
+	assert(isp_stats->ver_proj);
+
+	hor_num_isp =
+	ver_num_isp = host_stats->grid.aligned_width
+		    * host_stats->grid.aligned_height;
+
+	hor_ptr_isp = isp_stats->hor_proj;
+	ver_ptr_isp = isp_stats->ver_proj;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dvs2_statistics() enter: \
+		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
+		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
+		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
+		ver_coefs.even_real=%p, ver_coefs.even_imag=%p\
+		haddr=%x, vaddr=%x\n",
+		host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
+		host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
+		host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
+		host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
+		isp_stats->hor_proj, isp_stats->ver_proj);
+
+	hor_bytes = hor_num_isp * sizeof(int);
+	ver_bytes = ver_num_isp * sizeof(int);
+
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_real, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_imag, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_real, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_imag, hor_bytes);
+	
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_real, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_imag, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_real, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_imag, ver_bytes);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+			"sh_css_get_dvs2_statistics() leave: void\n");
+}
+
+#if !defined(HAS_NO_HMEM)
+static void get_3a_stats_from_hmem(
+	struct ia_css_3a_statistics	*host_stats,
+	hrt_vaddress				ddr_ptr)
+{
+	hmem_data_t	*hmem_buf = sh_css_malloc(sizeof_hmem(HMEM0_ID));
+	struct ia_css_3a_rgby_output	*out_ptr;
+	int			i;
+
+	/* pixel counts(BQ) for 3A area */
+	int count_for_3a
+	  = host_stats->grid.width * host_stats->grid.height
+	    * host_stats->grid.bqs_per_grid_cell
+	    * host_stats->grid.bqs_per_grid_cell;
+	int sum_r, diff;
+
+assert(host_stats  != NULL);
+assert(host_stats->rgby_data != NULL);
+assert(ddr_ptr != mmgr_NULL);
+assert(hmem_buf != NULL);
+
+	out_ptr = host_stats->rgby_data;
+/*
+ * No weighted histogram, hence no grid definition
+ */
+	mmgr_load(ddr_ptr, (void *)hmem_buf, sizeof_hmem(HMEM0_ID));
+/* Deinterleave */
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		out_ptr[i].r = hmem_buf[i];
+		out_ptr[i].g = hmem_buf[i+HMEM_UNIT_SIZE];
+		out_ptr[i].b = hmem_buf[i+HMEM_UNIT_SIZE*2];
+		out_ptr[i].y = hmem_buf[i+HMEM_UNIT_SIZE*3];
+	}
+
+/* Calculate sum of histogram of R,
+   which should not be less than count_for_3a */
+	sum_r = 0;
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		sum_r += out_ptr[i].r;
+	}
+	if (sum_r < count_for_3a) {
+		/* histogram is invalid */
+		if(hmem_buf != NULL)
+ 			sh_css_free(hmem_buf);
+		return;
+	}
+
+/* Verify for sum of histogram of R/G/B/Y */
+#if 0
+{
+	int sum_g = 0;
+	int sum_b = 0;
+	int sum_y = 0;
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		sum_g += out_ptr[i].g;
+		sum_b += out_ptr[i].b;
+		sum_y += out_ptr[i].y;
+	}
+	if (sum_g != sum_r || sum_b != sum_r || sum_y != sum_r) {
+		/* histogram is invalid */
+		if(hmem_buf != NULL)
+ 			sh_css_free(hmem_buf);
+		return;
+	}
+}
+#endif
+
+/*
+ * Limit the histogram area only to 3A area.
+ * In DSP, the histogram of 0 is incremented for pixels
+ * which are outside of 3A area. That amount should be subtracted here.
+ *   hist[0] = hist[0] - ((sum of all hist[]) - (pixel count for 3A area))
+ */
+
+	diff = sum_r - count_for_3a;
+	out_ptr[0].r -= diff;
+	out_ptr[0].g -= diff;
+	out_ptr[0].b -= diff;
+	out_ptr[0].y -= diff;
+
+	sh_css_free(hmem_buf);
+return;
+}
+#endif
+
+static void
+get_3a_stats_from_dmem(struct ia_css_3a_statistics *host_stats,
+		       hrt_vaddress ddr_ptr)
+{
+	int ddr_width,
+	    out_width,
+	    out_height,
+	    i;
+	struct ia_css_3a_output *out_ptr;
+
+	assert(host_stats);
+	assert(host_stats->data);
+	assert(ddr_ptr);
+
+	ddr_width  = host_stats->grid.aligned_width;
+	out_width  = host_stats->grid.width;
+	out_height = host_stats->grid.height;
+	out_ptr    = host_stats->data;
+
+	for (i = 0; i < out_height; i++) {
+		mmgr_load(ddr_ptr, out_ptr, out_width * sizeof(*out_ptr));
+		ddr_ptr += ddr_width * sizeof(*out_ptr);
+		out_ptr += out_width;
+	}
+}
+
+/* MW: this is an ISP function */
+STORAGE_CLASS_INLINE int
+merge_hi14bit_lo14bit(unsigned short hi, unsigned short lo)
+{
+	int val = (int) ((((unsigned int) hi << 14) & 0xfffc000) |
+			((unsigned int) lo & 0x3fff));
+	return val;
+}
+
+static void
+get_3a_stats_from_vmem(struct ia_css_3a_statistics *host_stats,
+		       hrt_vaddress ddr_ptr_hi,
+		       hrt_vaddress ddr_ptr_lo)
+{
+	int out_width,
+	    out_height,
+	    chunk, rest, kmax, y, x, k, elm_start, elm, ofs, bytes;
+	unsigned short *hi, *lo;
+	struct ia_css_3a_output *output;
+	/* struct size > 128 bytes should not be stored on stack (see checkpatch) */
+	static unsigned short s3a_tbl_hi_buf[ISP_S3ATBL_HI_LO_STRIDE *
+				     SH_CSS_MAX_BQ_GRID_HEIGHT],
+		      s3a_tbl_lo_buf[ISP_S3ATBL_HI_LO_STRIDE *
+				     SH_CSS_MAX_BQ_GRID_HEIGHT];
+
+	assert(host_stats!= NULL);
+	assert(host_stats->data);
+	assert(ddr_ptr_hi != mmgr_NULL);
+	assert(ddr_ptr_lo != mmgr_NULL);
+
+	output = host_stats->data;
+	out_width  = host_stats->grid.width;
+	out_height = host_stats->grid.height;
+	hi = s3a_tbl_hi_buf;
+	lo = s3a_tbl_lo_buf;
+
+	chunk = (ISP_VEC_NELEMS >> host_stats->grid.deci_factor_log2);
+	chunk = max(chunk, 1);
+	bytes = ISP_S3ATBL_HI_LO_STRIDE_BYTES * out_height;
+
+	mmgr_load(ddr_ptr_hi, hi, bytes);
+	mmgr_load(ddr_ptr_lo, lo, bytes);
+
+	for (y = 0; y < out_height; y++) {
+		elm_start = y * ISP_S3ATBL_HI_LO_STRIDE;
+		rest = out_width;
+		x = 0;
+		while (x < out_width) {
+			kmax = (rest > chunk) ? chunk : rest;
+			ofs = y * out_width + x;
+			elm = elm_start + x * sizeof(*output) / sizeof(int);
+			for (k = 0; k < kmax; k++, elm++) {
+				output[ofs + k].ae_y =
+				    merge_hi14bit_lo14bit
+				    (hi[elm], lo[elm]);
+				output[ofs + k].awb_cnt =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk], lo[elm + chunk]);
+				output[ofs + k].awb_gr =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 2],
+				     lo[elm + chunk * 2]);
+				output[ofs + k].awb_r =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 3],
+				     lo[elm + chunk * 3]);
+				output[ofs + k].awb_b =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 4],
+				     lo[elm + chunk * 4]);
+				output[ofs + k].awb_gb =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 5],
+				     lo[elm + chunk * 5]);
+				output[ofs + k].af_hpf1 =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 6],
+				     lo[elm + chunk * 6]);
+				output[ofs + k].af_hpf2 =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 7],
+				     lo[elm + chunk * 7]);
+			}
+			x += chunk;
+			rest -= chunk;
+		}
+	}
+}
+
+static void
+sh_css_process_3a(struct ia_css_isp_parameters *params,
+		  unsigned int raw_bit_depth)
+{
+	unsigned int i;
+
+	/* coefficients to calculate Y */
+	params->isp_parameters.ae_y_coef_r =
+	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
+	params->isp_parameters.ae_y_coef_g =
+	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
+	params->isp_parameters.ae_y_coef_b =
+	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
+
+	/* AWB level gate */
+	params->isp_parameters.awb_lg_high_raw =
+		uDIGIT_FITTING(params->s3a_config.awb_lg_high_raw, 16, raw_bit_depth);
+	params->isp_parameters.awb_lg_low =
+		uDIGIT_FITTING(params->s3a_config.awb_lg_low, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.awb_lg_high =
+		uDIGIT_FITTING(params->s3a_config.awb_lg_high, 16, SH_CSS_BAYER_BITS);
+
+	/* af fir coefficients */
+	for (i = 0; i < 7; ++i) {
+		params->isp_parameters.af_fir1[i] =
+		  sDIGIT_FITTING(params->s3a_config.af_fir1_coef[i], 15,
+				 SH_CSS_AF_FIR_SHIFT);
+		params->isp_parameters.af_fir2[i] =
+		  sDIGIT_FITTING(params->s3a_config.af_fir2_coef[i], 15,
+				 SH_CSS_AF_FIR_SHIFT);
+	}
+	params->isp_params_changed = true;
+	params->s3a_config_changed = false;
+}
+
+hrt_vaddress
+sh_css_params_ddr_address_map(void)
+{
+	return sp_ddr_ptrs;
+}
+
+/*
+ * @GC:
+ */
+static void
+convert_coords_to_ispparams(
+	hrt_vaddress ddr_addr,
+	const struct ia_css_dvs_6axis_config *config,
+	unsigned int i_stride,
+	unsigned int o_width,
+	unsigned int o_height,
+	unsigned int uv_flag)
+{
+	unsigned int i, j;
+	gdc_warp_param_mem_t s;
+	unsigned int x00, x01, x10, x11,
+		     y00, y01, y10, y11;
+
+	unsigned int xmin, ymin;
+	unsigned int topleft_x, topleft_y,
+		     topleft_x_frac, topleft_y_frac;
+
+	/* number of blocks per height and width */
+	unsigned int num_blocks_y =  (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(o_height) : DVS_NUM_BLOCKS_Y(o_height) );
+	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width)  : DVS_NUM_BLOCKS_X(o_width)  ); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even 
+	/* number of blocks per height and width */
+
+	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
+	unsigned width, height;
+	unsigned int *xbuff = NULL;
+	unsigned int *ybuff = NULL;	                  
+
+assert(config != NULL);
+assert(ddr_addr != mmgr_NULL);
+
+	ddr_addr += (2* DVS_6AXIS_COORDS_ELEMS * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */
+
+	if(uv_flag == 0)
+	{
+		xbuff = config->xcoords_y;
+		ybuff = config->ycoords_y;
+		width = config->width_y;
+		height = config->height_y;
+	}
+	else
+	{
+		xbuff = config->xcoords_uv;
+		ybuff = config->ycoords_uv;
+		width = config->width_uv;
+		height = config->height_uv;
+	}
+	
+	sh_css_dtrace(SH_DBG_TRACE, "convert_coords_to_ispparams blockdim_x %d blockdim_y %d\n", DVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);
+	sh_css_dtrace(SH_DBG_TRACE, "convert_coords_to_ispparams num_blocks_x %d num_blocks_y %d\n",num_blocks_x,num_blocks_y);
+	sh_css_dtrace(SH_DBG_TRACE, "convert_coords_to_ispparams width %d height %d\n",width,height);
+
+	assert(width == num_blocks_x + 1); // the width and height of the provided morphing table should be 1 more than the number of blocks
+	assert(height == num_blocks_y + 1);
+
+	for (j = 0; j < num_blocks_y; j++) {
+		for (i = 0; i < num_blocks_x; i++) {
+
+		      x00 = xbuff[j * width + i];
+		      x01 = xbuff[j * width + (i+1)];
+		      x10 = xbuff[(j+1) * width + i];
+		      x11 = xbuff[(j+1) * width + (i+1)];
+		
+		      y00 = ybuff[j * width + i];
+		      y01 = ybuff[j * width + (i+1)];
+		      y10 = ybuff[(j+1) * width + i];
+		      y11 = ybuff[(j+1) * width + (i+1)];
+			/* TODO: Assert that right column's X is greater */
+			xmin = min(x00, x10);
+			/* TODO: Assert that bottom row's Y is greater */
+			ymin = min(y00, y01);
+
+/* Assert that right column's X is greater */
+assert ( x01 >= xmin);
+assert ( x11 >= xmin);
+/* Assert that bottom row's Y is greater */
+assert ( y10 >= ymin);
+assert ( y11 >= ymin);
+
+#if 0
+			/* TODO: Round width to the multiple of bus width */
+			xmax = max(x01, x11);
+			ymax = max(y10, y11);
+			in_block_width  = xmax - xmin;
+			in_block_height = ymax - ymin;
+#else
+			/*
+			 * For initial testing, we are using constant input
+			 * block size
+			 * */
+			s.in_block_width  = 128;
+			s.in_block_height = 96 >> uv_flag;
+#endif
+
+			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
+			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
+					>> XMEM_ALIGN_LOG2)
+					<< (XMEM_ALIGN_LOG2);
+
+			s.in_addr_offset = topleft_y * in_stride + topleft_x;
+
+			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
+			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);
+
+			s.p0_x = x00 - topleft_x_frac;
+			s.p1_x = x01 - topleft_x_frac;
+			s.p2_x = x10 - topleft_x_frac;
+			s.p3_x = x11 - topleft_x_frac;
+
+			s.p0_y = y00 - topleft_y_frac;
+			s.p1_y = y01 - topleft_y_frac;
+			s.p2_y = y10 - topleft_y_frac;
+			s.p3_y = y11 - topleft_y_frac;
+
+      // block should fit within the boundingbox.
+      assert (s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+      assert (s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+      assert (s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+      assert (s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+      assert (s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+      assert (s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+      assert (s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+      assert (s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+
+      // block size should be greater than zero.
+      assert (s.p0_x < s.p1_x);
+      assert (s.p2_x < s.p3_x);
+      assert (s.p0_y < s.p2_y);
+      assert (s.p1_y < s.p3_y);
+      
+#if 0
+			printf("j: %d\ti:%d\n", j, i);
+			printf("offset: %d\n", s.in_addr_offset);
+			printf("p0_x: %d\n", s.p0_x);
+			printf("p0_y: %d\n", s.p0_y);
+			printf("p1_x: %d\n", s.p1_x);
+			printf("p1_y: %d\n", s.p1_y);
+			printf("p2_x: %d\n", s.p2_x);
+			printf("p2_y: %d\n", s.p2_y);
+			printf("p3_x: %d\n", s.p3_x);
+			printf("p3_y: %d\n", s.p3_y);
+			
+			printf("p0_x_nofrac[0]: %d\n", s.p0_x>>DVS_COORD_FRAC_BITS);
+		        printf("p0_y_nofrac[1]: %d\n", s.p0_y>>DVS_COORD_FRAC_BITS);
+		        printf("p1_x_nofrac[2]: %d\n", s.p1_x>>DVS_COORD_FRAC_BITS);
+		        printf("p1_y_nofrac[3]: %d\n", s.p1_y>>DVS_COORD_FRAC_BITS);
+		        printf("p2_x_nofrac[0]: %d\n", s.p2_x>>DVS_COORD_FRAC_BITS);
+		        printf("p2_y_nofrac[1]: %d\n", s.p2_y>>DVS_COORD_FRAC_BITS);
+		        printf("p3_x_nofrac[2]: %d\n", s.p3_x>>DVS_COORD_FRAC_BITS);
+		        printf("p3_y_nofrac[3]: %d\n", s.p3_y>>DVS_COORD_FRAC_BITS);
+			printf("\n");
+#endif
+
+			/* HMM STORE the struct "s" */
+			mmgr_store(ddr_addr,
+				   (void *)(&s),
+				   sizeof(gdc_warp_param_mem_t));
+
+			// storage format:
+			// Y0 Y1 UV0 Y2 Y3 UV1
+			if (uv_flag) {
+				ddr_addr += DVS_6AXIS_COORDS_ELEMS * 3;
+		}
+			else {
+        ddr_addr += DVS_6AXIS_COORDS_ELEMS * (1 + (i&1)); // increment with 2 incase x is odd, this to skip the uv position.
+	}
+			
+}
+	}
+}
+
+static void
+store_dvs_6axis_config(
+	struct ia_css_isp_parameters *params,
+	const struct sh_css_binary *binary,
+	hrt_vaddress ddr_addr_y)
+{
+	unsigned int i_stride  = binary->in_frame_info.padded_width; // bgz115: replaced binary->in_frame_info.res.width for 'padded_width=stride'
+	unsigned int o_width  = binary->out_frame_info.res.width;
+	unsigned int o_height = binary->out_frame_info.res.height;
+
+	assert(binary != NULL);
+	assert(ddr_addr_y != mmgr_NULL);
+	assert(params->dvs_6axis_config != NULL);
+
+	/* Y plane */
+	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
+				    i_stride, o_width, o_height, 0);
+	/* UV plane (packed inside the y plane) */
+	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
+				    i_stride/2, o_width/2, o_height/2, 1);
+				    
+
+	params->isp_params_changed = true;
+}
+/* ****************************************************
+ * Each coefficient is stored as 7bits to fit 2 of them into one
+ * ISP vector element, so we will store 4 coefficents on every
+ * memory word (32bits)
+ *
+ * 0: Coefficient 0 used bits
+ * 1: Coefficient 1 used bits
+ * 2: Coefficient 2 used bits
+ * 3: Coefficient 3 used bit3
+ * x: not used
+ *
+ * xx33333332222222 | xx11111110000000
+ *
+ * ***************************************************
+ */
+static void
+store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
+{
+	unsigned int i, j;
+	short *data_ptr = params->fpn_table.data;
+
+assert(ptr != mmgr_NULL);
+
+	for (i = 0; i < params->fpn_table.height; i++) {
+		for (j = 0;
+		     j < params->fpn_table.width;
+		     j += 4, ptr += 4, data_ptr += 4) {
+			int data = data_ptr[0] << 0 |
+				   data_ptr[1] << 7 |
+				   data_ptr[2] << 16 |
+				   data_ptr[3] << 23;
+			mmgr_store(ptr, (void *)(&data), sizeof(data));
+		}
+	}
+}
+
+static void
+convert_raw_to_fpn(struct ia_css_isp_parameters *params)
+{
+	short maxval = 0;
+	unsigned int i;
+
+	/* Find the maximum value in the table */
+	for (i = 0; i < params->fpn_table.height * params->fpn_table.width; i++) {
+		short val = params->fpn_table.data[i];
+		/* Make sure FPN value can be represented in 13-bit unsigned
+		 * number (ISP precision - 1), but note that actual input range
+		 * depends on precision of input frame data.
+		 */
+		if (val < 0) {
+/* Checkpatch patch */
+			val = 0;
+		} else if (val >= (1 << 13)) {
+/* Checkpatch patch */
+/* MW: BUG, is "13" a system or application property */
+			val = (1 << 13) - 1;
+		}
+		maxval = max(maxval, val);
+	}
+	/* Find the lowest shift value to remap the values in the range
+	 * 0..maxval to 0..2^shiftval*63.
+	 */
+	params->fpn_table.shift = 0;
+	while (maxval > 63) {
+/* MW: BUG, is "63" a system or application property */
+		maxval /= 2;
+		params->fpn_table.shift++;
+	}
+	/* Adjust the values in the table for the shift value */
+	for (i = 0; i < params->fpn_table.height * params->fpn_table.width; i++)
+		((unsigned short *) params->fpn_table.data)[i] >>= params->fpn_table.shift;
+}
+
+enum ia_css_err
+sh_css_set_black_frame(struct ia_css_stream *stream,
+	const struct ia_css_frame *raw_black_frame)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	/* this function desperately needs to be moved to the ISP or SP such
+	 * that it can use the DMA.
+	 */
+	unsigned int height = raw_black_frame->info.res.height,
+		     width = raw_black_frame->info.padded_width,
+		     y, x, k, data;
+	hrt_vaddress ptr = raw_black_frame->data
+		+ raw_black_frame->planes.raw.offset;
+
+assert(raw_black_frame != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() enter: \
+		black_frame=%p\n",raw_black_frame);
+
+	if (params->fpn_table.data &&
+	    (params->fpn_table.width != width || params->fpn_table.height != height)) {
+		sh_css_free(params->fpn_table.data);
+		params->fpn_table.data = NULL;
+	}
+	if (params->fpn_table.data == NULL) {
+		params->fpn_table.data = sh_css_malloc(height * width * sizeof(short));
+		if (!params->fpn_table.data) {
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() leave: \
+		return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		params->fpn_table.width = width;
+		params->fpn_table.height = height;
+		params->fpn_table.shift = 0;
+	}
+
+	/* store raw to fpntbl */
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x += (ISP_VEC_NELEMS * 2)) {
+			int ofs = y * width + x;
+			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
+				mmgr_load(ptr, (void *)(&data), sizeof(int));
+				params->fpn_table.data[ofs + 2 * k] =
+				    (short) (data & 0xFFFF);
+				params->fpn_table.data[ofs + 2 * k + 2] =
+				    (short) ((data >> 16) & 0xFFFF);
+	ptr += sizeof(int);	/* byte system address */
+			}
+			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
+				mmgr_load(ptr, (void *)(&data), sizeof(int));
+				params->fpn_table.data[ofs + 2 * k + 1] =
+				    (short) (data & 0xFFFF);
+				params->fpn_table.data[ofs + 2 * k + 3] =
+				    (short) ((data >> 16) & 0xFFFF);
+	ptr += sizeof(int);	/* byte system address */
+			}
+		}
+	}
+
+	/* raw -> fpn */
+	convert_raw_to_fpn(params);
+
+	/* overwrite isp parameter */
+	params->isp_parameters.fpn_shift = params->fpn_table.shift;
+	params->isp_parameters.fpn_enabled = 1;
+	params->fpn_table_changed = true;
+	params->isp_params_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() leave: \
+		return_err=%d\n",IA_CSS_SUCCESS);
+
+	return IA_CSS_SUCCESS;
+}
+
+struct ia_css_shading_table *ia_css_shading_table_alloc(
+	unsigned int width,
+	unsigned int height)
+{
+	unsigned int i;
+	struct ia_css_shading_table *me = sh_css_malloc(sizeof(*me));
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_alloc() enter:\n");
+
+	if (me == NULL) {
+/* Checkpatch patch */
+		return me;
+	}
+	me->width		 = width;
+	me->height		= height;
+	me->sensor_width  = 0;
+	me->sensor_height = 0;
+	me->fraction_bits = 0;
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		me->data[i] =
+		    sh_css_malloc(width * height * sizeof(*me->data[0]));
+		if (me->data[i] == NULL) {
+			unsigned int j;
+			for (j = 0; j < i; j++)
+				sh_css_free(me->data[j]);
+			sh_css_free(me);
+			return NULL;
+		}
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_alloc() leave:\n");
+
+	return me;
+}
+
+void
+ia_css_shading_table_free(struct ia_css_shading_table *table)
+{
+	unsigned int i;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() enter:\n");
+
+	if (table == NULL) {
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() leave:\n");
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		if (table->data[i])
+			sh_css_free(table->data[i]);
+	}
+	sh_css_free(table);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() leave:\n");
+}
+
+bool
+sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int binning_fact)
+{	
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_binning_factor() enter:\n");
+
+	if (params->sensor_binning != binning_fact) {
+		params->sensor_binning = binning_fact;
+		params->sc_table_changed = true;
+	}
+	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_binning_factor() leave:\n");
+
+	return params->sc_table_changed;
+}
+
+static void
+sh_css_set_shading_table(struct ia_css_stream *stream,
+			 const struct ia_css_shading_table *table)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_shading_table() enter:\n");
+	if (!table->enable)
+		table = NULL;
+
+	if (table != params->sc_table) {
+		params->sc_table = table;
+		params->sc_table_changed = true;
+		/* Not very clean, this goes to sh_css.c to invalidate the
+		 * shading table for all pipes. Should replaced by a loop
+		 * and a pipe-specific call.
+		 */
+		sh_css_invalidate_shading_tables(stream);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_shading_table() leave:\n");
+}
+
+static void
+store_sctbl(
+	    struct ia_css_isp_parameters *params,
+	    const struct sh_css_binary *binary,
+	    hrt_vaddress ddr_addr,
+	    const struct ia_css_shading_table *shading_table)
+{
+	unsigned int i, j, aligned_width, row_padding;
+
+assert(binary != NULL);
+assert(ddr_addr != mmgr_NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() enter:\n");
+
+	if (shading_table == NULL) {
+/* Checkpatch patch */
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() leave:\n");
+		return;
+	}
+
+	aligned_width = binary->sctbl_aligned_width_per_color;
+	params->isp_parameters.sc_gain_shift = shading_table->fraction_bits;
+	row_padding = aligned_width - shading_table->width;
+
+	for (i = 0; i < shading_table->height; i++) {
+		for (j = 0; j < IA_CSS_SC_NUM_COLORS; j++) {
+			mmgr_store(ddr_addr,
+				   &shading_table->data[j]
+					[i*shading_table->width],
+				   shading_table->width * sizeof(short));
+			ddr_addr += shading_table->width * sizeof(short);
+			mmgr_clear(ddr_addr,
+				   row_padding * sizeof(short));
+			ddr_addr += row_padding * sizeof(short);
+		}
+	}
+	params->isp_params_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() leave:\n");
+}
+
+static void
+sh_css_process_wb(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() enter:\n");
+
+	params->isp_parameters.wb_gain_shift =
+	    uISP_REG_BIT - params->wb_config.integer_bits;
+	params->isp_parameters.wb_gain_gr =
+	    uDIGIT_FITTING(params->wb_config.gr, 16 - params->wb_config.integer_bits,
+			   params->isp_parameters.wb_gain_shift);
+	params->isp_parameters.wb_gain_r =
+	    uDIGIT_FITTING(params->wb_config.r, 16 - params->wb_config.integer_bits,
+			   params->isp_parameters.wb_gain_shift);
+	params->isp_parameters.wb_gain_b =
+	    uDIGIT_FITTING(params->wb_config.b, 16 - params->wb_config.integer_bits,
+			   params->isp_parameters.wb_gain_shift);
+	params->isp_parameters.wb_gain_gb =
+	    uDIGIT_FITTING(params->wb_config.gb, 16 - params->wb_config.integer_bits,
+			   params->isp_parameters.wb_gain_shift);
+	params->isp_params_changed = true;
+	params->wb_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() leave:\n");
+}
+
+static void
+sh_css_process_cc(struct ia_css_isp_parameters *params)
+{
+	int	i;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() enter:\n");
+
+	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
+		if (params->cc_config_changed[i]) {
+			params->isp_parameters.csc_kernel_param[i].m_shift    = (int) params->cc_config[i].fraction_bits;
+			params->isp_parameters.csc_kernel_param[i].m00 = (int) params->cc_config[i].matrix[0];
+			params->isp_parameters.csc_kernel_param[i].m01 = (int) params->cc_config[i].matrix[1];
+			params->isp_parameters.csc_kernel_param[i].m02 = (int) params->cc_config[i].matrix[2];
+			params->isp_parameters.csc_kernel_param[i].m10 = (int) params->cc_config[i].matrix[3];
+			params->isp_parameters.csc_kernel_param[i].m11 = (int) params->cc_config[i].matrix[4];
+			params->isp_parameters.csc_kernel_param[i].m12 = (int) params->cc_config[i].matrix[5];
+			params->isp_parameters.csc_kernel_param[i].m20 = (int) params->cc_config[i].matrix[6];
+			params->isp_parameters.csc_kernel_param[i].m21 = (int) params->cc_config[i].matrix[7];
+			params->isp_parameters.csc_kernel_param[i].m22 = (int) params->cc_config[i].matrix[8];
+			params->isp_params_changed = true;
+			params->cc_config_changed[i] = false;
+		}
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() leave:\n");
+}
+
+static void
+sh_css_process_tnr(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() enter:\n");
+
+	params->isp_parameters.tnr_coef =
+	    uDIGIT_FITTING(params->tnr_config.gain, 16, SH_CSS_TNR_COEF_SHIFT);
+	params->isp_parameters.tnr_threshold_Y =
+	    uDIGIT_FITTING(params->tnr_config.threshold_y, 16, SH_CSS_ISP_YUV_BITS);
+	params->isp_parameters.tnr_threshold_C =
+	    uDIGIT_FITTING(params->tnr_config.threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
+	params->isp_params_changed = true;
+	params->tnr_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() leqave:\n");
+}
+
+static void
+sh_css_process_ob(struct ia_css_isp_parameters *params,
+		  unsigned int isp_pipe_version,
+		  unsigned int raw_bit_depth)
+{
+	unsigned int ob_bit_depth
+		= isp_pipe_version == 2 ? SH_CSS_BAYER_BITS : raw_bit_depth;
+	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() enter: "
+		"isp_pipe_version=%d, raw_bit_depth=%d, ob_bit_depth=%d\n",
+		isp_pipe_version, raw_bit_depth, ob_bit_depth);
+
+	switch (params->ob_config.mode) {
+	case IA_CSS_OB_MODE_FIXED:
+		params->isp_parameters.ob_blacklevel_gr
+			= params->ob_config.level_gr >> (16 - ob_bit_depth);
+		params->isp_parameters.ob_blacklevel_r
+			= params->ob_config.level_r  >> (16 - ob_bit_depth);
+		params->isp_parameters.ob_blacklevel_b
+			= params->ob_config.level_b  >> (16 - ob_bit_depth);
+		params->isp_parameters.ob_blacklevel_gb
+			= params->ob_config.level_gb >> (16 - ob_bit_depth);
+		params->isp_parameters.obarea_start_bq = 0;
+		params->isp_parameters.obarea_length_bq = 0;
+		params->isp_parameters.obarea_length_bq_inverse = 0;
+		break;
+	case IA_CSS_OB_MODE_RASTER:
+		params->isp_parameters.ob_blacklevel_gr = 0;
+		params->isp_parameters.ob_blacklevel_r = 0;
+		params->isp_parameters.ob_blacklevel_b = 0;
+		params->isp_parameters.ob_blacklevel_gb = 0;
+		params->isp_parameters.obarea_start_bq =
+		    params->ob_config.start_position;
+		params->isp_parameters.obarea_length_bq =
+		    ((params->ob_config.end_position - params->ob_config.start_position) + 1);
+		params->isp_parameters.obarea_length_bq_inverse =
+		    (1 << 12) / params->isp_parameters.obarea_length_bq;
+		break;
+	default:
+		params->isp_parameters.ob_blacklevel_gr = 0;
+		params->isp_parameters.ob_blacklevel_r = 0;
+		params->isp_parameters.ob_blacklevel_b = 0;
+		params->isp_parameters.ob_blacklevel_gb = 0;
+		params->isp_parameters.obarea_start_bq = 0;
+		params->isp_parameters.obarea_length_bq = 0;
+		params->isp_parameters.obarea_length_bq_inverse = 0;
+		break;
+	}
+	params->isp_params_changed = true;
+	params->ob_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() leaev:\n");
+}
+
+static void
+sh_css_process_dp(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() enter:\n");
+
+	params->isp_parameters.dp_threshold_single_when_2adjacent_on =
+	    SH_CSS_BAYER_MAXVAL;
+	params->isp_parameters.dp_threshold_2adjacent_when_2adjacent_on =
+	    uDIGIT_FITTING(params->dp_config.threshold, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.dp_threshold_single_when_2adjacent_off =
+	    uDIGIT_FITTING(params->dp_config.threshold, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.dp_threshold_2adjacent_when_2adjacent_off =
+	    SH_CSS_BAYER_MAXVAL;
+	params->isp_parameters.dp_gain =
+	    uDIGIT_FITTING(params->dp_config.gain, 8, SH_CSS_DP_GAIN_SHIFT);
+
+#if SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB
+	{
+		int gain = params->dp_config.gain;
+		int gr   = params->wb_config.gr;
+		int r    = params->wb_config.r;
+		int b    = params->wb_config.b;
+		int gb   = params->wb_config.gb;
+
+		params->isp_parameters.dpc_coef_rr_gr =
+		  uDIGIT_FITTING (gain * gr / r, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_rr_gb =
+		  uDIGIT_FITTING (gain * gb / r, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_bb_gb =
+		  uDIGIT_FITTING (gain * gb / b, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_bb_gr =
+		  uDIGIT_FITTING (gain * gr / b, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_gr_rr =
+		  uDIGIT_FITTING (gain * r / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_gr_bb =
+		  uDIGIT_FITTING (gain * b / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_gb_bb =
+		  uDIGIT_FITTING (gain * b / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+		params->isp_parameters.dpc_coef_gb_rr =
+		  uDIGIT_FITTING (gain * r / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+	}
+#endif
+	params->isp_params_changed = true;
+	params->dp_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() leave:\n");
+}
+
+static void
+sh_css_process_nr_ee(struct ia_css_isp_parameters *params)
+{
+	int asiWk1, asiWk2, asiWk3;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() enter:\n");
+
+	/* BNR (Bayer Noise Reduction) */
+	params->isp_parameters.bnr_threshold_low =
+	    uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.bnr_threshold_width_log2 = uFRACTION_BITS_FITTING(8);
+	params->isp_parameters.bnr_threshold_width =
+	    1 << params->isp_parameters.bnr_threshold_width_log2;
+	params->isp_parameters.bnr_gain_all =
+	    uDIGIT_FITTING(params->nr_config.bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+	params->isp_parameters.bnr_gain_dir =
+	    uDIGIT_FITTING(params->nr_config.bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+	params->isp_parameters.bnr_clip = uDIGIT_FITTING(
+					(unsigned)16384, 16, SH_CSS_BAYER_BITS);
+
+	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
+	asiWk1 = (int) params->ee_config.gain;
+	asiWk2 = asiWk1 / 8;
+	asiWk3 = asiWk1 / 4;
+	params->isp_parameters.ynr_threshold =
+		uDIGIT_FITTING((unsigned)8192, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.ynr_gain_all =
+	    uDIGIT_FITTING(params->nr_config.ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+	params->isp_parameters.ynr_gain_dir =
+	    uDIGIT_FITTING(params->nr_config.ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+	params->isp_parameters.ynryee_dirthreshold_s =
+	    min((uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS)
+				    << 1),
+		SH_CSS_BAYER_MAXVAL);
+	params->isp_parameters.ynryee_dirthreshold_g =
+	    min((uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS)
+				    << 4),
+		SH_CSS_BAYER_MAXVAL);
+	params->isp_parameters.ynryee_dirthreshold_width_log2 =
+	    uFRACTION_BITS_FITTING(8);
+	params->isp_parameters.ynryee_dirthreshold_width =
+	    1 << params->isp_parameters.ynryee_dirthreshold_width_log2;
+	params->isp_parameters.yee_detailgain =
+	    uDIGIT_FITTING(params->ee_config.detail_gain, 11,
+			   SH_CSS_YEE_DETAIL_GAIN_SHIFT);
+	params->isp_parameters.yee_coring_s =
+	    (uDIGIT_FITTING((unsigned)56, 16, SH_CSS_BAYER_BITS) *
+	     params->ee_config.threshold) >> 8;
+	params->isp_parameters.yee_coring_g =
+	    (uDIGIT_FITTING((unsigned)224, 16, SH_CSS_BAYER_BITS) *
+	     params->ee_config.threshold) >> 8;
+	/* 8; // *1.125 ->[s4.8] */
+	params->isp_parameters.yee_scale_plus_s =
+	    (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // ( * -.25)->[s4.8] */
+	params->isp_parameters.yee_scale_plus_g =
+	    (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // *0.875 ->[s4.8] */
+	params->isp_parameters.yee_scale_minus_s =
+	    (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // ( *.25 ) ->[s4.8] */
+	params->isp_parameters.yee_scale_minus_g =
+	    (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	params->isp_parameters.yee_clip_plus_s =
+	    uDIGIT_FITTING((unsigned)32760, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.yee_clip_plus_g = 0;
+	params->isp_parameters.yee_clip_minus_s =
+	    uDIGIT_FITTING((unsigned)504, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.yee_clip_minus_g =
+	    uDIGIT_FITTING((unsigned)32256, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.ynryee_Yclip = SH_CSS_BAYER_MAXVAL;
+	params->isp_params_changed = true;
+	params->nr_config_changed = false;
+	params->ee_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() leave:\n");
+}
+
+static void
+sh_css_process_de(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() enter:\n");
+
+	params->isp_parameters.de_pixelnoise =
+	    uDIGIT_FITTING(params->de_config.pixelnoise, 16, SH_CSS_BAYER_BITS);
+	params->isp_parameters.de_c1_coring_threshold =
+	    uDIGIT_FITTING(params->de_config.c1_coring_threshold, 16,
+			   SH_CSS_BAYER_BITS);
+	params->isp_parameters.de_c2_coring_threshold =
+	    uDIGIT_FITTING(params->de_config.c2_coring_threshold, 16,
+			   SH_CSS_BAYER_BITS);
+	params->isp_params_changed = true;
+	params->de_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() leave:\n");
+}
+
+static void
+sh_css_process_gc(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() enter:\n");
+
+	params->isp_parameters.gamma_gain_k1 =
+	    uDIGIT_FITTING((int)params->gc_config.gain_k1, 16,
+		IA_CSS_GAMMA_GAIN_K_SHIFT);
+	params->isp_parameters.gamma_gain_k2 =
+	    uDIGIT_FITTING((int)params->gc_config.gain_k2, 16,
+		IA_CSS_GAMMA_GAIN_K_SHIFT);
+	params->isp_params_changed = true;
+	params->gc_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() leave:\n");
+}
+
+static void
+sh_css_process_anr(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() enter:\n");
+
+	params->isp_parameters.anr_threshold = params->anr_config.threshold;
+	params->isp_params_changed = true;
+	params->anr_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() leave:\n");
+}
+
+static void
+sh_css_process_ce(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() enter:\n");
+
+	params->isp_parameters.ce_uv_level_min = params->ce_config.uv_level_min;
+	params->isp_parameters.ce_uv_level_max = params->ce_config.uv_level_max;
+	params->isp_params_changed = true;
+	params->ce_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() leave:\n");
+}
+
+static void sh_css_process_zoom_and_motion(
+	struct ia_css_isp_parameters *params,
+	enum ia_css_pipe_id pipe_id,
+	const struct sh_css_pipeline_stage *first_stage)
+{
+/* first_stage can be  NULL */
+	const struct sh_css_pipeline_stage *stage;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_zoom_and_motion() enter:\n");
+
+	/* Go through all stages to udate uds and cropping */
+	for (stage = first_stage; stage; stage = stage->next) {
+
+		struct sh_css_binary *binary;
+		struct sh_css_binary tmp_binary;
+
+		const struct ia_css_binary_info *info = NULL;
+
+		binary = stage->binary;
+		if (binary) {
+			info = binary->info;
+		} else {
+			const struct sh_css_binary_args *args = &stage->args;
+			info = &stage->firmware->info.isp;
+			sh_css_fill_binary_info(info, false, false,
+				IA_CSS_STREAM_FORMAT_RAW_10,
+				args->in_frame  ? &args->in_frame->info  : NULL,
+				args->out_frame ? &args->out_frame->info : NULL,
+				args->out_vf_frame ? &args->out_vf_frame->info
+									: NULL,
+				&tmp_binary,
+				false,
+				NULL);
+			binary = &tmp_binary;
+			binary->info = info;
+		}
+
+		assert(stage->stage_num < SH_CSS_MAX_STAGES);
+		sh_css_update_uds_and_crop_info(
+			info,
+			&binary->in_frame_info,
+			&binary->out_frame_info,
+			&binary->dvs_envelope,
+			pipe_id == IA_CSS_PIPE_ID_PREVIEW,
+			&(params->dz_config),
+			&(params->motion_config),
+			&(params->isp_parameters.uds[stage->stage_num]),
+			&(params->isp_parameters.sp_out_crop_pos[stage->stage_num]));
+	}
+	params->isp_params_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_zoom_and_motion() leave:\n");
+}
+
+static void
+sh_css_process_ecd(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.ecd_zip_strength = params->ecd_config.zip_strength;
+	params->isp_parameters.ecd_fc_strength  = params->ecd_config.fc_strength;
+	params->isp_parameters.ecd_fc_debias    = params->ecd_config.fc_debias;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+}
+
+static void
+sh_css_process_ynr(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() enter:\n");
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.yee_edge_sense_gain_0   = params->ynr_config.edge_sense_gain_0;
+	params->isp_parameters.yee_edge_sense_gain_1   = params->ynr_config.edge_sense_gain_1;
+	params->isp_parameters.yee_corner_sense_gain_0 = params->ynr_config.corner_sense_gain_0;
+	params->isp_parameters.yee_corner_sense_gain_1 = params->ynr_config.corner_sense_gain_1;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() leave:\n");
+}
+
+static void
+sh_css_process_fc(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() enter:\n");
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.fc_gain_exp   = params->fc_config.gain_exp;
+
+	params->isp_parameters.fc_gain_pos_0 = params->fc_config.gain_pos_0;
+	params->isp_parameters.fc_gain_pos_1 = params->fc_config.gain_pos_1;
+	params->isp_parameters.fc_gain_neg_0 = params->fc_config.gain_neg_0;
+	params->isp_parameters.fc_gain_neg_1 = params->fc_config.gain_neg_1;
+
+	params->isp_parameters.fc_crop_pos_0 = params->fc_config.crop_pos_0;
+	params->isp_parameters.fc_crop_pos_1 = params->fc_config.crop_pos_1;
+	params->isp_parameters.fc_crop_neg_0 = params->fc_config.crop_neg_0;
+	params->isp_parameters.fc_crop_neg_1 = params->fc_config.crop_neg_1;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() leave:\n");
+}
+
+static void
+sh_css_process_cnr(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() enter:\n");
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.cnr_coring_u = params->cnr_config.coring_u;
+	params->isp_parameters.cnr_coring_v = params->cnr_config.coring_v;
+	params->isp_parameters.cnr_sense_gain_vy = params->cnr_config.sense_gain_vy;
+	params->isp_parameters.cnr_sense_gain_vu = params->cnr_config.sense_gain_vu;
+	params->isp_parameters.cnr_sense_gain_vv = params->cnr_config.sense_gain_vv;
+	params->isp_parameters.cnr_sense_gain_hy = params->cnr_config.sense_gain_hy;
+	params->isp_parameters.cnr_sense_gain_hu = params->cnr_config.sense_gain_hu;
+	params->isp_parameters.cnr_sense_gain_hv = params->cnr_config.sense_gain_hv;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() leave:\n");
+}
+
+static void
+sh_css_process_macc(struct ia_css_isp_parameters *params)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() enter:\n");
+
+	params->isp_parameters.exp = params->macc_config.exp;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() leave:\n");
+}
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+static void ctc_gradient(
+	int *dydx, int *shift,
+	int y1, int y0, int x1, int x0)
+{
+	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int dydx_int = dy / dx;
+	int dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
+	int sft;
+
+	/* max_dydx = the maxinum gradient = the maximum y (gain) */
+	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+
+	assert(y0 >= 0 && y0 <= max_dydx);
+	assert(y1 >= 0 && y1 <= max_dydx);
+	assert(x0 < x1);
+	assert(dydx != NULL);
+	assert(shift != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+	
+	/* search "sft" which meets this condition:
+		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
+		<= (((float)dy / (float)dx) * (1 << sft))
+		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
+	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
+		int tmp_dydx = (dydx_int << sft)
+			     + (dydx_frc >> (frc_bits - sft));
+		if (tmp_dydx <= max_dydx) {
+			*dydx = tmp_dydx;
+			*shift = sft;
+		}
+		if (tmp_dydx >= max_dydx)
+			break;		
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+}
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+static void
+sh_css_process_ctc(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() enter:\n");
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.ctc_y0 = params->ctc_config.y0;
+	params->isp_parameters.ctc_y1 = params->ctc_config.y1;
+	params->isp_parameters.ctc_y2 = params->ctc_config.y2;
+	params->isp_parameters.ctc_y3 = params->ctc_config.y3;
+	params->isp_parameters.ctc_y4 = params->ctc_config.y4;
+	params->isp_parameters.ctc_y5 = params->ctc_config.y5;
+
+	params->isp_parameters.ctc_ce_gain_exp = params->ctc_config.ce_gain_exp;
+
+	params->isp_parameters.ctc_x1 = params->ctc_config.x1;
+	params->isp_parameters.ctc_x2 = params->ctc_config.x2;
+	params->isp_parameters.ctc_x3 = params->ctc_config.x3;
+	params->isp_parameters.ctc_x4 = params->ctc_config.x4;
+
+	ctc_gradient(&(params->isp_parameters.ctc_dydx0),
+		     &(params->isp_parameters.ctc_dydx0_shift),
+		     params->ctc_config.y1, params->ctc_config.y0,
+		     params->ctc_config.x1, 0);
+
+	ctc_gradient(&(params->isp_parameters.ctc_dydx1),
+		     &(params->isp_parameters.ctc_dydx1_shift),
+		     params->ctc_config.y2, params->ctc_config.y1,
+		     params->ctc_config.x2, params->ctc_config.x1);
+
+	ctc_gradient(&params->isp_parameters.ctc_dydx2,
+		     &params->isp_parameters.ctc_dydx2_shift,
+		     params->ctc_config.y3, params->ctc_config.y2,
+		     params->ctc_config.x3, params->ctc_config.x2);
+
+	ctc_gradient(&params->isp_parameters.ctc_dydx3,
+		     &params->isp_parameters.ctc_dydx3_shift,
+		     params->ctc_config.y4, params->ctc_config.y3,
+		     params->ctc_config.x4, params->ctc_config.x3);
+
+	ctc_gradient(&(params->isp_parameters.ctc_dydx4),
+		     &(params->isp_parameters.ctc_dydx4_shift),
+		     params->ctc_config.y5, params->ctc_config.y4,
+		     SH_CSS_BAYER_MAXVAL, params->ctc_config.x4);
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() leave:\n");
+}
+
+static void
+sh_css_process_aa(struct ia_css_isp_parameters *params)
+{
+	(void) params;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() enter:\n");
+
+#if SH_CSS_ISP_PARAMS_VERSION == 2
+	params->isp_parameters.aa_scale = params->aa_config.scale;
+#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() leave:\n");
+}
+
+static void
+sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_gamma_table *table)
+{
+	assert(table);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gamma_table() enter: "
+		"table=%p\n",table);
+
+	params->gamma_table = *table;
+	params->gamma_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gamma_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_gamma_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gamma_table() enter: "
+		"table=%p\n",table);
+
+	*table = params->gamma_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gamma_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_ctc_table *table)
+{
+	assert(table);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_table() enter: "
+		"table=%p\n",table);
+
+	params->ctc_table = *table;
+	params->ctc_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_ctc_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() enter: "
+		"table=%p\n",table);
+
+	*table = params->ctc_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_xnr_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_xnr_table *table)
+{
+	assert(table);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_table() enter: "
+		"table=%p\n",table);
+
+	params->xnr_table = *table;
+	params->xnr_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_xnr_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_xnr_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() enter: "
+		"table=%p\n",table);
+
+	*table = params->xnr_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_macc_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_macc_table *table)
+{
+	assert(table);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_table() enter: "
+		"table=%p\n",table);
+
+	params->macc_table = *table;
+	params->macc_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_macc_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_table() enter: "
+		"table=%p\n",table);
+
+	*table = params->macc_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_anr_thres(struct ia_css_isp_parameters *params,
+			const struct ia_css_anr_thres *thres)
+{
+	assert(thres);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_thres() enter: "
+		"thres=%p\n",thres);
+
+	params->anr_thres = *thres;
+	params->anr_thres_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_thres() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_anr_thres(const struct ia_css_isp_parameters *params,
+			struct ia_css_anr_thres *thres)
+{
+	assert(thres != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_thres() enter: "
+		"thres=%p\n",thres);
+
+	*thres = params->anr_thres;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_thres() leave: "
+		"*thres=%p\n",*thres);
+}
+
+void ia_css_morph_table_free(
+	struct ia_css_morph_table *me)
+{
+	unsigned int i;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_morph_table_free() enter:\n");
+
+	if (me == NULL) {
+/* Checkpatch patch */
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		if (me->coordinates_x[i])
+			sh_css_free(me->coordinates_x[i]);
+		if (me->coordinates_y[i])
+			sh_css_free(me->coordinates_y[i]);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_morph_table_free() leave:\n");
+
+	sh_css_free(me);
+}
+
+struct ia_css_morph_table *ia_css_morph_table_allocate(
+	unsigned int width,
+	unsigned int height)
+{
+	unsigned int i;
+	struct ia_css_morph_table *me = sh_css_malloc(sizeof(*me));
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_morph_table_allocate() enter:\n");
+
+	if (me == NULL) {
+/* Checkpatch patch */
+		return me;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		me->coordinates_x[i] = NULL;
+		me->coordinates_y[i] = NULL;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		me->coordinates_x[i] =
+		    sh_css_malloc(height * width *
+				  sizeof(*me->coordinates_x[i]));
+		me->coordinates_y[i] =
+		    sh_css_malloc(height * width *
+				  sizeof(*me->coordinates_y[i]));
+
+		if ((me->coordinates_x[i] == NULL) ||
+			(me->coordinates_y[i] == NULL)) {
+/*
+ * MW: Potential memory leak, need to free all previous pointers
+ *
+			sh_css_free(me->coordinates_x[i]);
+			sh_css_free(me->coordinates_y[i]);
+ */
+			ia_css_morph_table_free(me);
+			me = NULL;
+			return me;
+		}
+	}
+	me->width = width;
+	me->height = height;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_morph_table_allocate() leave:\n");
+
+	return me;
+}
+
+static enum ia_css_err sh_css_params_default_morph_table(
+	struct ia_css_morph_table **table,
+	const struct sh_css_binary *binary)
+{
+/* MW 2400 advanced requires different scaling */
+	unsigned int i, j, k,
+		     step = (ISP_VEC_NELEMS / 16) * 128,
+		     width = binary->morph_tbl_width,
+		     height = binary->morph_tbl_height;
+	short start_x[IA_CSS_MORPH_TABLE_NUM_PLANES] = { -8, 0, -8, 0, 0, -8 },
+	      start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
+	struct ia_css_morph_table *tab;
+
+assert(table != NULL);
+assert(binary != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_default_morph_table() enter:\n");
+
+	tab = ia_css_morph_table_allocate(width, height);
+	if (tab == NULL) {
+
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		short val_y = start_y[i];
+		for (j = 0; j < height; j++) {
+			short val_x = start_x[i];
+			unsigned short *x_ptr, *y_ptr;
+
+			x_ptr = &tab->coordinates_x[i][j * width];
+			y_ptr = &tab->coordinates_y[i][j * width];
+			for (k = 0; k < width;
+			     k++, x_ptr++, y_ptr++, val_x += step) {
+				if (k == 0)
+					*x_ptr = 0;
+				else if (k == width - 1)
+					*x_ptr = val_x + 2 * start_x[i];
+				else
+					*x_ptr = val_x;
+				if (j == 0)
+					*y_ptr = 0;
+				else
+					*y_ptr = val_y;
+			}
+			val_y += step;
+		}
+	}
+	*table = tab;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_default_morph_table() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+static void
+sh_css_set_morph_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_morph_table *table)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() enter: "
+		"table=%p\n",table);
+
+	if (table->enable == false)
+		table = NULL;
+	params->morph_table = table;
+	params->morph_table_changed = true;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() leave: "
+		"return_void\n");
+}
+#if 0
+/* TODO: connect this properly. The table would have to be copied
+ * out.
+ * */
+static void
+sh_css_get_morph_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_morph_table **table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() enter: "
+		"table=%p\n",table);
+
+	*table = params->morph_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() leave: "
+		"*table=%p\n",*table);
+
+}
+#endif
+
+void
+ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
+			 const struct ia_css_isp_3a_statistics *isp_stats)
+{
+	assert(host_stats != NULL);
+	assert(isp_stats != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_get_3a_statistics() enter: "
+		"host_stats=%p, isp_stats=%p\n",
+		host_stats, isp_stats);
+
+	if (host_stats->grid.use_dmem) {
+		get_3a_stats_from_dmem(host_stats,
+				       isp_stats->data.dmem.s3a_tbl);
+	} else {
+		get_3a_stats_from_vmem(host_stats,
+				       isp_stats->data.vmem.s3a_tbl_hi,
+				       isp_stats->data.vmem.s3a_tbl_lo);
+	}
+#if !defined(HAS_NO_HMEM)
+		get_3a_stats_from_hmem(host_stats,
+				       isp_stats->data_hmem.rgby_tbl);
+#endif
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"ia_css_get_3a_statistics() leave: return_void\n");
+}
+
+static void
+sh_css_set_3a_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_3a_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_3a_config() enter: "
+		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
+		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
+		"config.awb_lg_low=%d, config.awb_lg_high=%d\n",
+		config->ae_y_coef_r, config->ae_y_coef_g,
+		config->ae_y_coef_b, config->awb_lg_high_raw,
+		config->awb_lg_low, config->awb_lg_high);
+
+	params->s3a_config = *config;
+	params->s3a_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_3a_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_3a_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_3a_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->s3a_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() leave: "
+		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
+		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
+		"config.awb_lg_low=%d,  config.awb_lg_high=%d\n",
+		config->ae_y_coef_r, config->ae_y_coef_g,
+		config->ae_y_coef_b, config->awb_lg_high_raw,
+		config->awb_lg_low, config->awb_lg_high);
+}
+
+static void
+sh_css_set_wb_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_wb_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_wb_config() enter: "
+		"config.integer_bits=%d, "
+		"config.gr=%d, config.r=%d, "
+		"config.b=%d, config.gb=%d\n",
+		config->integer_bits,
+		config->gr, config->r,
+		config->b, config->gb);
+	params->wb_config = *config;
+	params->wb_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_wb_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_wb_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_wb_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->wb_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() leave: "
+		"config.integer_bits=%d, "
+		"config.gr=%d, config.r=%d, "
+		"config.b=%d,  config.gb=%d\n",
+		config->integer_bits,
+		config->gr, config->r,
+		config->b, config->gb);
+}
+
+static void
+sh_css_set_cc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config)
+{
+	assert (config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cc_config() enter: "
+		"config.fraction_bits=%d, config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->fraction_bits, config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+
+/* Copy the values */
+	params->cc_config[CSC_KERNEL_PARAM_SET0] = *config;
+	params->cc_config_changed[CSC_KERNEL_PARAM_SET0] = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_cc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_cc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cc_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->cc_config[CSC_KERNEL_PARAM_SET0];
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() leave: "
+		"config.fraction_bits=%d, config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->fraction_bits, config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+}
+
+static void
+sh_css_set_tnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_tnr_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_tnr_config() enter: "
+		"config.gain=%d, "
+		"config.threshold_y=%d, config.threshold_uv=%d\n",
+		config->gain,
+		config->threshold_y, config->threshold_uv);
+	params->tnr_config = *config;
+	params->tnr_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_tnr_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_tnr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_tnr_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_tnr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->tnr_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_tnr_config() leave: "
+		"config.gain=%d, "
+		"config.threshold_y=%d, config.threshold_uv=%d\n",
+		config->gain,
+		config->threshold_y, config->threshold_uv);
+}
+
+static void
+sh_css_set_ob_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ob_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ob_config() enter: "
+		"config.mode=%d, "
+		"config.level_gr=%d, config.level_r=%d, "
+		"config.level_b=%d,  config.level_gb=%d, "
+		"config.start_position=%d, config.end_position=%d\n",
+		config->mode,
+		config->level_gr, config->level_r,
+		config->level_b, config->level_gb,
+		config->start_position, config->end_position);
+
+	params->ob_config = *config;
+	params->ob_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_ob_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ob_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ob_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ob_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ob_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ob_config() leave: "
+		"config.mode=%d, "
+		"config.level_gr=%d, config.level_r=%d, "
+		"config.level_b=%d,  config.level_gb=%d, "
+		"config.start_position=%d, config.end_position=%d\n",
+		config->mode,
+		config->level_gr, config->level_r,
+		config->level_b,  config->level_gb,
+		config->start_position, config->end_position);
+}
+
+static void
+sh_css_set_dp_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dp_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dp_config() enter: "
+		"config.threshold=%d, config.gain=%d\n",
+		config->threshold, config->gain);
+	params->dp_config = *config;
+	params->dp_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_dp_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_dp_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_dp_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dp_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->dp_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dp_config() enter: "
+		"config.threshold=%d, config.gain=%d\n",
+		config->threshold, config->gain);
+}
+
+static void
+sh_css_set_nr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_nr_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_nr_config() enter: "
+		"config.direction=%d, "
+		"config.bnr_gain=%d, config.ynr_gain=%d, "
+		"config.threshold_cb=%d, config.threshold_cr=%d\n",
+		config->direction,
+		config->bnr_gain, config->ynr_gain,
+		config->threshold_cb, config->threshold_cr);
+	params->nr_config = *config;
+	params->nr_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_nr_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_nr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_nr_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_nr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->nr_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_nr_config() leave: "
+		"config.direction=%d, "
+		"config.bnr_gain=%d, config.ynr_gain=%d, "
+		"config.threshold_cb=%d, config.threshold_cr=%d\n",
+		config->direction,
+		config->bnr_gain, config->ynr_gain,
+		config->threshold_cb, config->threshold_cr);
+}
+
+static void
+sh_css_set_ee_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ee_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ee_config() enter: "
+		"config.threshold=%d, "
+		"config.gain=%d, config.detail_gain=%d\n",
+		config->threshold,
+		config->gain, config->detail_gain);
+	params->ee_config = *config;
+	params->ee_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_ee_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ee_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ee_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ee_config;
+	
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ee_config() enter: "
+		"config.threshold=%d, "
+		"config.gain=%d, config.detail_gain=%d\n",
+		config->threshold,
+		config->gain, config->detail_gain);
+}
+
+static void
+sh_css_set_de_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_de_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_de_config() enter: "
+		"config.pixelnoise=%d, "
+		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
+		config->pixelnoise,
+		config->c1_coring_threshold, config->c2_coring_threshold);
+	params->de_config = *config;
+	params->de_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_de_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_de_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_de_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_de_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->de_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_de_config() leave: "
+		"config.pixelnoise=%d, "
+		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
+		config->pixelnoise,
+		config->c1_coring_threshold,
+		config->c2_coring_threshold);
+}
+
+static void
+sh_css_set_gc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_gc_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gc_config() enter: "
+		"config.gain_k1=%d, config.gain_k2=%d\n",
+		config->gain_k1, config->gain_k2);
+	params->gc_config = *config;
+	params->gc_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_gc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_gc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_gc_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->gc_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() leave: "
+		"config.gain_k1=%d, config.gain_k2=%d\n",
+		config->gain_k1, config->gain_k2);
+}
+
+static void
+sh_css_set_anr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_anr_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_config() enter: "
+		"config.threshold=%d\n",
+		config->threshold);
+	params->anr_config = *config;
+	params->anr_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_anr_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_anr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_anr_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->anr_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() leave: "
+		"config.threshold=%d\n",
+		config->threshold);
+}
+
+static void
+sh_css_set_ce_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ce_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ce_config() enter: "
+		"config.uv_level_min=%d, config.uv_level_max=%d\n",
+		config->uv_level_min, config->uv_level_max);
+	params->ce_config = *config;
+	params->ce_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_ce_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ce_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ce_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ce_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() leave: "
+		"config.uv_level_min=%d, config.uv_level_max=%d\n",
+		config->uv_level_min, config->uv_level_max);
+}
+
+static void
+sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
+				const struct ia_css_dvs_6axis_config *dvs_config)
+{
+	
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs_config() enter: "
+	"dvs_config=%p\n",dvs_config);
+
+	assert(dvs_config != NULL);
+	assert(dvs_config->height_y == dvs_config->height_uv);
+    assert( (dvs_config->width_y - 1) == 2 * (dvs_config->width_uv - 1));
+
+	copy_dvs_6axis_table(params->dvs_6axis_config,dvs_config);
+	
+	params->dvs_6axis_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_dvs_6axis_config() leave: "
+		"return_void\n");
+	
+}
+
+static void
+sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
+				struct ia_css_dvs_6axis_config *dvs_config)
+{
+	assert(dvs_config != NULL);
+	assert(dvs_config->height_y == dvs_config->height_uv);
+	assert( (dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dvs_6axis_config() enter: "
+		"dvs_config=%p\n",dvs_config);
+
+	if((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
+	(dvs_config->height_y == params->dvs_6axis_config->height_y) &&
+	(dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
+	(dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
+	dvs_config->xcoords_y &&
+        dvs_config->ycoords_y &&
+        dvs_config->xcoords_uv &&
+	dvs_config->ycoords_uv)
+	{
+		copy_dvs_6axis_table(dvs_config,params->dvs_6axis_config);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_get_dvs_6axis_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_set_ecd_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ecd_config *config)
+{
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config()\n");
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
+		"config.zip_strength=%d, "
+		"config.fc_strength=%d, config.fc_debias=%d\n",
+		config->zip_strength,
+		config->fc_strength, config->fc_debias);
+	params->ecd_config = *config;
+	params->ecd_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ecd_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ecd_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ecd_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ecd_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() enter: "
+		"config.zip_strength=%d, "
+		"config.fc_strength=%d, config.fc_debias=%d\n",
+		config->zip_strength,
+		config->fc_strength, config->fc_debias);
+}
+
+static void
+sh_css_set_ynr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ynr_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
+		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
+		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
+		config->edge_sense_gain_0, config->edge_sense_gain_1,
+		config->corner_sense_gain_0, config->corner_sense_gain_1);
+
+	params->ynr_config = *config;
+	params->ynr_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_ynr_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ynr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ynr_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ynr_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() leave: "
+		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
+		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
+		config->edge_sense_gain_0, config->edge_sense_gain_1,
+		config->corner_sense_gain_0, config->corner_sense_gain_1);
+}
+
+static void
+sh_css_set_fc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_fc_config *config)
+{
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_fc_config() enter: "
+		"config.gain_exp=%d, "
+		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
+		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
+		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
+		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
+		config->gain_exp,
+		config->gain_pos_0, config->gain_pos_1,
+		config->gain_neg_0, config->gain_neg_1,
+		config->crop_pos_0, config->crop_pos_1,
+		config->crop_neg_0, config->crop_neg_1);
+	params->fc_config = *config;
+	params->fc_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_fc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_fc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_fc_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->fc_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() leave: "
+		"config.gain_exp=%d, "
+		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
+		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
+		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
+		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
+		config->gain_exp,
+		config->gain_pos_0, config->gain_pos_1,
+		config->gain_neg_0, config->gain_neg_1,
+		config->crop_pos_0, config->crop_pos_1,
+		config->crop_neg_0, config->crop_neg_1);
+}
+
+static void
+sh_css_set_cnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cnr_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cnr_config() enter: "
+		"config.coring_u=%d, config.coring_v=%d, "
+		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
+		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
+		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
+		config->coring_u, config->coring_v,
+		config->sense_gain_vy, config->sense_gain_hy,
+		config->sense_gain_vu, config->sense_gain_hu,
+		config->sense_gain_vv, config->sense_gain_hv);
+
+	params->cnr_config = *config;
+	params->cnr_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_cnr_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_cnr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cnr_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->cnr_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() leave: "
+		"config.coring_u=%d, config.coring_v=%d, "
+		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
+		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
+		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
+		config->coring_u, config->coring_v,
+		config->sense_gain_vy, config->sense_gain_hy,
+		config->sense_gain_vu, config->sense_gain_hu,
+		config->sense_gain_vv, config->sense_gain_hv);
+}
+
+static void
+sh_css_set_macc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_macc_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_config() enter: "
+		"config.exp=%d\n",
+		config->exp);
+	params->macc_config = *config;
+	params->macc_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_macc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_macc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_macc_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->macc_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() leave: "
+		"config.exp=%d\n",
+		config->exp);
+}
+
+static void
+sh_css_set_ctc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ctc_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_config() enter: "
+		"config.ce_gain_exp=%d, config.y0=%d, "
+		"config.x1=%d, config.y1=%d, "
+		"config.x2=%d, config.y2=%d, "
+		"config.x3=%d, config.y3=%d, "
+		"config.x4=%d, config.y4=%d\n",
+		config->ce_gain_exp, config->y0,
+		config->x1, config->y1,
+		config->x2, config->y2,
+		config->x3, config->y3,
+		config->x4, config->y4);
+
+	params->ctc_config = *config;
+	params->ctc_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_ctc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_ctc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ctc_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ctc_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() leave: "
+		"config.ce_gain_exp=%d, config.y0=%d, "
+		"config.x1=%d, config.y1=%d, "
+		"config.x2=%d, config.y2=%d, "
+		"config.x3=%d, config.y3=%d, "
+		"config.x4=%d, config.y4=%d\n",
+		config->ce_gain_exp, config->y0,
+		config->x1, config->y1,
+		config->x2, config->y2,
+		config->x3, config->y3,
+		config->x4, config->y4);
+}
+
+static void
+sh_css_set_aa_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_aa_config *config)
+{
+	assert (config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_aa_config() enter: "
+		"config.scale=%d\n",
+		config->scale);
+
+	params->aa_config = *config;
+	params->aa_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_aa_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_aa_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_aa_config *config)
+{
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->aa_config;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() leave: "
+		"config.scale=%d\n",
+		config->scale);
+}
+
+static void
+sh_css_set_r_gamma_table(struct ia_css_isp_parameters *params,
+				const struct ia_css_rgb_gamma_table *table)
+{
+	assert(table);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_r_gamma_table() enter: "
+		"table=%p\n",table);
+
+	params->r_gamma_table = *table;
+	params->r_gamma_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_r_gamma_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_r_gamma_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() enter:\n");
+
+	*table = params->r_gamma_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_g_gamma_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *table)
+{
+	assert(table);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_g_gamma_table() enter: "
+		"table=%p\n",table);
+
+	params->g_gamma_table = *table;
+	params->g_gamma_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_g_gamma_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_g_gamma_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *table)
+{
+	assert(table != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() enter:\n");
+
+	*table = params->g_gamma_table;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_b_gamma_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *table)
+{
+	assert(table);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_b_gamma_table() enter: "
+		"table=%p\n",table);
+
+	params->b_gamma_table = *table;
+	params->b_gamma_table_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_b_gamma_table() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_b_gamma_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *table)
+{
+	assert(table != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_b_gamma_table() enter:\n");
+
+	*table = params->b_gamma_table;
+	
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
+		"*table=%p\n",*table);
+}
+
+static void
+sh_css_set_yuv2rgb_cc_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_cc_config *config)
+{
+	assert(params != NULL);
+	assert (config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() enter: "
+		"config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+/*
+	params->yuv2rgb_cc_config = *config;
+	params->yuv2rgb_cc_config_changed = true;
+ */
+	params->cc_config[CSC_KERNEL_PARAM_SET2] = *config;
+	params->cc_config_changed[CSC_KERNEL_PARAM_SET2] = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_yuv2rgb_cc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_yuv2rgb_cc_config(
+	const struct ia_css_isp_parameters *params,
+	struct ia_css_cc_config *config)
+{
+	assert(params != NULL);
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_yuv2rgb_cc_config() enter:\n");
+
+/*	*config = params->yuv2rgb_cc_config; */
+	*config = params->cc_config[CSC_KERNEL_PARAM_SET2];
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() leave: "
+		"config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+}
+
+static void
+sh_css_set_rgb2yuv_cc_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_cc_config *config)
+{
+	assert(params != NULL);
+	assert(config != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_rgb2yuv_cc_config() enter: "
+		"config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+/*
+	params->rgb2yuv_cc_config = *config;
+	params->rgb2yuv_cc_config_changed = true;
+ */
+	params->cc_config[CSC_KERNEL_PARAM_SET1] = *config;
+	params->cc_config_changed[CSC_KERNEL_PARAM_SET1] = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_rgb2yuv_cc_config() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_rgb2yuv_cc_config(
+	const struct ia_css_isp_parameters *params,
+	struct ia_css_cc_config *config)
+{
+	assert(params != NULL);
+	assert(config != NULL);
+
+/*	*config = params->rgb2yuv_cc_config; */
+	*config = params->cc_config[CSC_KERNEL_PARAM_SET1];
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_rgb2yuv_cc_config() leave: "
+		"config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+}
+
+static void
+sh_css_set_dz_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dz_config *config)
+{
+	assert(config);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_zoom_factor() enter: dx=%d, dy=%d\n",
+		config->dx, config->dy);
+
+	assert(config->dx <= HRT_GDC_N);
+	assert(config->dy <= HRT_GDC_N);
+
+	params->dz_config = *config;
+	params->dz_config_changed = true;
+	/* JK: Why isp params changed?? */
+	params->isp_params_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_zoom_factor() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_dz_config *config)
+{
+	assert(config);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dz_config() enter:\n");
+
+	*config = params->dz_config;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_get_dz_config() leave: dx=%d, dy=%d\n",
+		config->dx, config->dy);
+}
+
+static void
+sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
+			const struct ia_css_vector *motion)
+{
+	assert(motion);
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_motion_vector() enter: x=%d, y=%d\n",
+		motion->x, motion->y);
+
+	params->motion_config = *motion;
+	/* JK: Why do isp params change? */
+	params->motion_config_changed = true;
+	params->isp_params_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_motion_vector() leave: "
+		"return_void\n");
+}
+
+static void
+sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
+			struct ia_css_vector *motion)
+{
+	assert(motion);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_motion_vector() enter\n");
+
+	*motion = params->motion_config;
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_get_motion_vector() leave: x=%d, y=%d\n",
+		motion->x, motion->y);
+}
+
+/* TODO: make a direct implementation and remove the partial ones */
+void
+ia_css_stream_set_isp_config(
+	struct ia_css_stream *stream,
+	const struct ia_css_isp_config *config)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_isp_config() enter: "
+		"stream=%p, config=%p\n", stream, config);
+
+	if (config->wb_config)
+		sh_css_set_wb_config(params, config->wb_config);
+	if (config->cc_config)
+		sh_css_set_cc_config(params, config->cc_config);
+	if (config->tnr_config)
+		sh_css_set_tnr_config(params, config->tnr_config);
+	if (config->ob_config)
+		sh_css_set_ob_config(params, config->ob_config);
+	if (config->nr_config)
+		sh_css_set_nr_config(params, config->nr_config);
+	if (config->ee_config)
+		sh_css_set_ee_config(params, config->ee_config);
+	if (config->de_config)
+		sh_css_set_de_config(params, config->de_config);
+	if (config->gc_config)
+		sh_css_set_gc_config(params, config->gc_config);
+	if (config->ecd_config)
+		sh_css_set_ecd_config(params, config->ecd_config);
+	if (config->ynr_config)
+		sh_css_set_ynr_config(params, config->ynr_config);
+	if (config->fc_config)
+		sh_css_set_fc_config(params, config->fc_config);
+	if (config->cnr_config)
+		sh_css_set_cnr_config(params, config->cnr_config);
+	if (config->macc_config)
+		sh_css_set_macc_config(params, config->macc_config);
+	if (config->ctc_config)
+		sh_css_set_ctc_config(params, config->ctc_config);
+	if (config->aa_config)
+		sh_css_set_aa_config(params, config->aa_config);
+	if (config->ce_config)
+		sh_css_set_ce_config(params, config->ce_config);
+	if (config->dvs_6axis_config)
+		sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
+	if (config->yuv2rgb_cc_config)
+		sh_css_set_yuv2rgb_cc_config(params, config->yuv2rgb_cc_config);
+	if (config->rgb2yuv_cc_config)
+		sh_css_set_rgb2yuv_cc_config(params, config->rgb2yuv_cc_config);
+	if (config->anr_config)
+		sh_css_set_anr_config(params, config->anr_config);
+	if (config->s3a_config)
+		sh_css_set_3a_config(params, config->s3a_config);
+	if (config->macc_table)
+		sh_css_set_macc_table(params, config->macc_table);
+	if (config->gamma_table)
+		sh_css_set_gamma_table(params, config->gamma_table);
+	if (config->ctc_table)
+		sh_css_set_ctc_table(params, config->ctc_table);
+	if (config->xnr_table)
+		sh_css_set_xnr_table(params, config->xnr_table);
+	if (config->r_gamma_table)
+		sh_css_set_r_gamma_table(params, config->r_gamma_table);
+	if (config->g_gamma_table)
+		sh_css_set_g_gamma_table(params, config->g_gamma_table);
+	if (config->b_gamma_table)
+		sh_css_set_b_gamma_table(params, config->b_gamma_table);
+	if (config->dz_config)
+		sh_css_set_dz_config(params, config->dz_config);
+	if (config->motion_vector)
+		sh_css_set_motion_vector(params, config->motion_vector);
+	if (config->shading_table)
+		sh_css_set_shading_table(stream, config->shading_table);
+	if (config->morph_table)
+		sh_css_set_morph_table(params, config->morph_table);
+	if (config->dvs_coefs)
+		ia_css_set_dvs_coefficients(params, config->dvs_coefs);
+	if (config->dvs2_coefs)
+		ia_css_set_dvs2_coefficients(params, config->dvs2_coefs);
+	/*
+	   if (config->_config)
+	   sh_css_set_xnr_config(config->xnr_config);
+	*/
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_set_isp_config() leave: "
+		"return_void\n");
+
+	/* Now commit all changes to the SP */
+	sh_css_param_update_isp_params(stream, sh_css_sp_is_running());
+}
+
+/* TODO: make a direct implementation and remove the partial ones */
+void
+ia_css_stream_get_isp_config(
+	const struct ia_css_stream *stream,
+	struct ia_css_isp_config *config)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	assert(config != NULL);
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_isp_config() enter: "
+		"config=%p\n", config);
+
+	(void) stream;
+
+	if (config->wb_config)
+		sh_css_get_wb_config(params, config->wb_config);
+	if (config->cc_config)
+		sh_css_get_cc_config(params, config->cc_config);
+	if (config->tnr_config)
+		sh_css_get_tnr_config(params, config->tnr_config);
+	if (config->ob_config)
+		sh_css_get_ob_config(params, config->ob_config);
+	if (config->dp_config)
+		sh_css_get_dp_config(params, config->dp_config);
+	if (config->nr_config)
+		sh_css_get_nr_config(params, config->nr_config);
+	if (config->ee_config)
+		sh_css_get_ee_config(params, config->ee_config);
+	if (config->de_config)
+		sh_css_get_de_config(params, config->de_config);
+	if (config->gc_config)
+		sh_css_get_gc_config(params, config->gc_config);
+	if (config->anr_config)
+		sh_css_get_anr_config(params, config->anr_config);
+	if (config->s3a_config)
+		sh_css_get_3a_config(params, config->s3a_config);
+	if (config->ecd_config)
+		sh_css_get_ecd_config(params, config->ecd_config);
+	if (config->ynr_config)
+		sh_css_get_ynr_config(params, config->ynr_config);
+	if (config->fc_config)
+		sh_css_get_fc_config(params, config->fc_config);
+	if (config->cnr_config)
+		sh_css_get_cnr_config(params, config->cnr_config);
+	if (config->macc_config)
+		sh_css_get_macc_config(params, config->macc_config);
+	if (config->ctc_config)
+		sh_css_get_ctc_config(params, config->ctc_config);
+	if (config->aa_config)
+		sh_css_get_aa_config(params, config->aa_config);
+	if (config->ce_config)
+		sh_css_get_ce_config(params, config->ce_config);
+	if (config->dvs_6axis_config)
+		sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
+	if (config->yuv2rgb_cc_config)
+		sh_css_get_yuv2rgb_cc_config(params, config->yuv2rgb_cc_config);
+	if (config->rgb2yuv_cc_config)
+		sh_css_get_rgb2yuv_cc_config(params, config->rgb2yuv_cc_config);
+	if (config->macc_table)
+		sh_css_get_macc_table(params, config->macc_table);
+	if (config->gamma_table)
+		sh_css_get_gamma_table(params, config->gamma_table);
+	if (config->ctc_table)
+		sh_css_get_ctc_table(params, config->ctc_table);
+	if (config->xnr_table)
+		sh_css_get_xnr_table(params, config->xnr_table);
+	if (config->r_gamma_table)
+		sh_css_get_r_gamma_table(params, config->r_gamma_table);
+	if (config->g_gamma_table)
+		sh_css_get_g_gamma_table(params, config->g_gamma_table);
+	if (config->b_gamma_table)
+		sh_css_get_b_gamma_table(params, config->b_gamma_table);
+	if (config->dz_config)
+		sh_css_get_dz_config(params, config->dz_config);
+	if (config->motion_vector)
+		sh_css_get_motion_vector(params, config->motion_vector);
+	if (config->anr_thres)
+		sh_css_get_anr_thres(params, config->anr_thres);
+
+/*
+	if (config->xnr_config != NULL)
+		sh_css_get_xnr_config(config->xnr_config);
+*/
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_get_isp_config() leave: "
+		"return_void\n");
+}
+
+/*
+ * coding style says the return of "mmgr_NULL" is the error signal
+ *
+ * Deprecated: Implement mmgr_realloc()
+ */
+static bool realloc_isp_css_mm_buf(
+/* STORAGE_CLASS_INLINE bool realloc_isp_css_mm_buf( */
+	hrt_vaddress *curr_buf, size_t *curr_size,
+	size_t needed_size, bool force, enum ia_css_err *err,
+	uint16_t	mmgr_attribute)
+{
+	int32_t id;
+	*err = IA_CSS_SUCCESS;
+	/* Possible optimization: add a function sh_css_isp_css_mm_realloc()
+	 * and implement on top of hmm. */
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() enter:\n");
+
+	if (!force && *curr_size >= needed_size) {
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+		return false;
+	}
+	/* don't reallocate if single ref to buffer and same size */
+	if (*curr_size == needed_size && sh_css_refcount_is_single(*curr_buf)) {
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+		return false;
+	}
+
+	id = PARAM_BUFFER;//sh_css_refcount_get_id(*curr_buf);
+	sh_css_refcount_release(id, *curr_buf);
+	*curr_buf = sh_css_refcount_retain(id, mmgr_alloc_attr(needed_size,
+							mmgr_attribute));
+
+	if (!*curr_buf) {
+		*err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		*curr_size = 0;
+	} else {
+		*curr_size = needed_size;
+	}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+	return true;
+}
+
+static bool reallocate_buffer(
+/* STORAGE_CLASS_INLINE bool reallocate_buffer( */
+	hrt_vaddress *curr_buf,
+	size_t *curr_size,
+	size_t needed_size,
+	bool force,
+	enum ia_css_err *err)
+{
+	bool ret;
+	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() enter:\n");
+
+	ret = realloc_isp_css_mm_buf(curr_buf,
+		curr_size, needed_size, force, err, mmgr_attribute);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() leave:\n");
+	return ret;
+}
+
+#if 0
+static bool reallocate_cached_buffer(
+/* STORAGE_CLASS_INLINE bool reallocate_cached_buffer( */
+	hrt_vaddress *curr_buf,
+	size_t *curr_size,
+	size_t needed_size,
+	enum ia_css_err *err)
+{
+	bool ret;
+	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT |
+		MMGR_ATTRIBUTE_CACHED;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() enter:\n");
+
+	ret = realloc_isp_css_mm_buf(curr_buf,
+		curr_size, needed_size, false, err, mmgr_attribute);
+		
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() leave:\n");
+
+	return ret;
+}
+#endif
+
+struct ia_css_isp_3a_statistics *
+ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
+{
+	struct ia_css_isp_3a_statistics *me;
+
+assert(grid != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() enter: grid=%p\n",grid);
+
+/* MW: Does "grid->enable" also control the histogram output ?? */
+	if (!grid->enable)
+		return NULL;
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	if (grid->use_dmem) {
+		int s3a_table_size = sizeof(struct ia_css_3a_output) *
+					grid->aligned_width * 
+					grid->aligned_height;
+		me->data.dmem.s3a_tbl = mmgr_malloc(s3a_table_size);
+		if (me->data.dmem.s3a_tbl == mmgr_NULL)
+			goto err;
+	} else {
+		int s3a_table_size = ISP_S3ATBL_HI_LO_STRIDE_BYTES *
+					grid->aligned_height;
+		me->data.vmem.s3a_tbl_hi = mmgr_malloc(s3a_table_size);
+		if (me->data.vmem.s3a_tbl_hi == mmgr_NULL)
+			goto err;
+		me->data.vmem.s3a_tbl_lo = mmgr_malloc(s3a_table_size);
+		if (me->data.vmem.s3a_tbl_lo == mmgr_NULL)
+			goto err;
+	}
+#if !defined(HAS_NO_HMEM)
+	if ((me->data_hmem.rgby_tbl = mmgr_malloc(sizeof_hmem(HMEM0_ID))) == mmgr_NULL)
+		goto err;
+#else
+	me->data_hmem.rgby_tbl = mmgr_NULL;
+#endif
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+
+err:
+	ia_css_isp_3a_statistics_free(me);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
+{
+	if (me != NULL) {
+/* mmgr_free() accepts (mmgr_)NULL, but the pointer are in a union, don't free twice */
+		mmgr_free(me->data.dmem.s3a_tbl);
+		me->data.dmem.s3a_tbl = mmgr_NULL;
+		mmgr_free(me->data.vmem.s3a_tbl_hi);
+		me->data.vmem.s3a_tbl_hi = mmgr_NULL;
+		mmgr_free(me->data.vmem.s3a_tbl_lo);
+		me->data.vmem.s3a_tbl_lo = mmgr_NULL;
+#if !defined(HAS_NO_HMEM)
+		mmgr_free(me->data_hmem.rgby_tbl);
+		me->data_hmem.rgby_tbl = mmgr_NULL;
+#endif
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_isp_dvs_statistics *me;
+	int hor_size, ver_size;
+
+	assert(grid != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() enter: grid=%p\n",grid);
+
+	if (!grid->enable)
+		return NULL;
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	hor_size =
+		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_height;
+	ver_size =
+		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_width;
+
+	me->hor_proj = mmgr_malloc(hor_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+	me->ver_proj = mmgr_malloc(ver_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_isp_dvs_statistics_free(me);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
+{
+	if (me != NULL) {
+		mmgr_free(me->hor_proj);
+		mmgr_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_isp_dvs_statistics *me;
+	int hor_size, ver_size;
+
+	assert(grid != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() enter: grid=%p\n",grid);
+
+	if (!grid->enable)
+		return NULL;
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	hor_size =
+	ver_size = sizeof(int) * IA_CSS_DVS2_NUM_COEF_TYPES
+		* grid->aligned_width * grid->aligned_height;
+
+	me->hor_proj = mmgr_malloc(hor_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+	me->ver_proj = mmgr_malloc(ver_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_isp_dvs2_statistics_free(me);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
+{
+	if (me != NULL) {
+		mmgr_free(me->hor_proj);
+		mmgr_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+unsigned g_param_buffer_dequeue_count = 0;
+unsigned g_param_buffer_enqueue_count = 0;
+
+enum ia_css_err
+ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
+{
+	bool succ = true;
+	unsigned i;
+	struct sh_css_ddr_address_map *ddr_ptrs;
+	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
+	struct ia_css_isp_parameters *params;
+       
+	/* TMP: tracking of paramsets */
+	g_param_buffer_dequeue_count = 0;
+	g_param_buffer_enqueue_count = 0;
+       
+	stream->isp_params_configs = sh_css_malloc(sizeof(*stream->isp_params_configs));
+	if (!stream->isp_params_configs)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	params = stream->isp_params_configs;
+	ddr_ptrs = &params->ddr_ptrs;
+	ddr_ptrs_size = &params->ddr_ptrs_size;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		memset(&params->pipe_ddr_ptrs[i], 0,
+			sizeof(params->pipe_ddr_ptrs[i]));
+		memset(&params->pipe_ddr_ptrs_size[i], 0,
+			sizeof(params->pipe_ddr_ptrs_size[i]));
+	}
+
+	memset(ddr_ptrs, 0, sizeof(*ddr_ptrs));
+	memset(ddr_ptrs_size, 0, sizeof(*ddr_ptrs_size));
+
+	ddr_ptrs_size->isp_param = sizeof(struct sh_css_isp_params);
+	ddr_ptrs->isp_param = sh_css_refcount_retain(PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct sh_css_isp_params)));
+	succ &= (ddr_ptrs->isp_param != mmgr_NULL);
+
+	ddr_ptrs_size->ctc_tbl = sizeof(struct ia_css_ctc_table);
+	ddr_ptrs->ctc_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct ia_css_isp_ctc_table)));
+	succ &= (ddr_ptrs->ctc_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->gamma_tbl = sizeof(struct ia_css_gamma_table);
+	ddr_ptrs->gamma_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct ia_css_isp_gamma_table)));
+	succ &= (ddr_ptrs->gamma_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->xnr_tbl = sizeof(struct ia_css_xnr_table);
+	ddr_ptrs->xnr_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct ia_css_isp_xnr_table)));
+	succ &= (ddr_ptrs->xnr_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->macc_tbl = sizeof(struct ia_css_macc_table);
+	ddr_ptrs->macc_tbl = sh_css_refcount_retain(PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct ia_css_macc_table)));
+	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->r_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
+	ddr_ptrs->r_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
+			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
+	succ &= (ddr_ptrs->r_gamma_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->g_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
+	ddr_ptrs->g_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
+			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
+	succ &= (ddr_ptrs->g_gamma_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->b_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
+	ddr_ptrs->b_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
+			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
+	succ &= (ddr_ptrs->b_gamma_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->anr_thres = sizeof(struct ia_css_anr_thres);
+	ddr_ptrs->anr_thres = sh_css_refcount_retain(PARAM_BUFFER,
+			mmgr_malloc(sizeof(struct ia_css_anr_thres)));
+	succ &= (ddr_ptrs->anr_thres != mmgr_NULL);
+
+		
+	sh_css_set_3a_config(params, &default_3a_config);
+	sh_css_set_wb_config(params, &default_wb_config);
+	sh_css_set_cc_config(params, &default_cc_config);
+	sh_css_set_tnr_config(params, &default_tnr_config);
+	sh_css_set_ob_config(params, &default_ob_config);
+	sh_css_set_dp_config(params, &default_dp_config);
+	sh_css_set_nr_config(params, &default_nr_config);
+	sh_css_set_ee_config(params, &default_ee_config);
+	sh_css_set_de_config(params, &default_de_config);
+	sh_css_set_gc_config(params, &default_gc_config);
+	sh_css_set_anr_config(params, &default_anr_config);
+	sh_css_set_ce_config(params, &default_ce_config);
+	sh_css_set_macc_table(params, &default_macc_table);
+	sh_css_set_gamma_table(params, &default_gamma_table);
+	sh_css_set_ctc_table(params, &default_ctc_table);
+	sh_css_set_xnr_table(params, &default_xnr_table);
+	sh_css_set_anr_thres(params, &default_anr_thres);
+	sh_css_set_ecd_config(params, &default_ecd_config);
+	sh_css_set_ynr_config(params, &default_ynr_config);
+	sh_css_set_fc_config(params, &default_fc_config);
+	sh_css_set_cnr_config(params, &default_cnr_config);
+	sh_css_set_macc_config(params, &default_macc_config);
+	sh_css_set_ctc_config(params, &default_ctc_config);
+	sh_css_set_aa_config(params, &default_aa_config);
+	sh_css_set_r_gamma_table(params, &default_r_gamma_table);
+	sh_css_set_g_gamma_table(params, &default_g_gamma_table);
+	sh_css_set_b_gamma_table(params, &default_b_gamma_table);
+	sh_css_set_yuv2rgb_cc_config(params, &default_yuv2rgb_cc_config);
+	sh_css_set_rgb2yuv_cc_config(params, &default_rgb2yuv_cc_config);
+	sh_css_set_dz_config(params, &default_dz_config);
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store((gdc_ID_t)i, zoom_table);
+	params->fpn_table.data = NULL;
+	params->fpn_table_changed = true;
+	params->isp_parameters.fpn_enabled = 0;
+	params->morph_table = NULL;
+	params->morph_table_changed = true;
+	params->sc_table = NULL;
+	params->sc_table_changed = true;
+	params->motion_config = default_motion_config;
+	params->motion_config_changed = true;
+	params->dvs2_hor_coefs.odd_real = NULL;
+	params->dvs2_hor_coefs.odd_imag = NULL;
+	params->dvs2_hor_coefs.even_real = NULL;
+	params->dvs2_hor_coefs.even_imag = NULL;
+	params->dvs2_ver_coefs.odd_real = NULL;
+	params->dvs2_ver_coefs.odd_imag = NULL;
+	params->dvs2_ver_coefs.even_real = NULL;
+	params->dvs2_ver_coefs.even_imag = NULL;
+	params->dvs2_coef_table_changed = true;
+	
+	params->dis_hor_coef_tbl = NULL;
+	params->dis_ver_coef_tbl = NULL;
+	params->dis_coef_table_changed = true;
+	
+	/*Initialise and generate table later in star*/
+	params->dvs_6axis_config = NULL;
+	params->dvs_6axis_config_changed = true; 
+
+	/* now commit to ddr */
+	sh_css_param_update_isp_params(stream, false);
+ 
+	/* create per pipe reference to general ddr_ptrs */
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
+		params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE,
+		"sh_css_params_init() leave: "
+		"return_err=%d\n",IA_CSS_SUCCESS);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+sh_css_params_init(void)
+{
+	int i, p;
+	enum ia_css_vamem_type vamem_type;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_init() enter: void\n");
+
+	/* TMP: tracking of paramsets */
+	g_param_buffer_dequeue_count = 0;
+	g_param_buffer_enqueue_count = 0;
+
+	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++) {
+		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
+			xmem_sp_stage_ptrs[p][i] =
+					sh_css_refcount_retain(-1,
+					    mmgr_calloc(1,
+					    sizeof(struct sh_css_sp_stage)));
+/* MW: memory leak, if you don't want a nice object_free(), then assert */
+			if (xmem_sp_stage_ptrs[p][i] == mmgr_NULL)
+				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			xmem_isp_stage_ptrs[p][i] =
+					sh_css_refcount_retain(-1,
+					    mmgr_calloc(1,
+					    sizeof(struct sh_css_isp_stage)));
+/* MW: memory leak, if you don't want a nice object_free(), then assert */
+			if (xmem_isp_stage_ptrs[p][i] == mmgr_NULL)
+				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+	}
+
+	/* We need to use memcpy to initialize the default tables
+	 * because we cannot initialize union fields in C89. */
+#if defined(HAS_VAMEM_VERSION_2)
+	vamem_type = IA_CSS_VAMEM_TYPE_2;
+	memcpy(default_gamma_table.data.vamem_2, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_ctc_table.data.vamem_2, default_ctc_table_data,
+	       sizeof(default_ctc_table_data));
+	memcpy(default_xnr_table.data.vamem_2, default_xnr_table_data,
+	       sizeof(default_xnr_table_data));
+	memcpy(default_r_gamma_table.data.vamem_2, default_r_gamma_table_data,
+	       sizeof(default_r_gamma_table_data));
+	memcpy(default_g_gamma_table.data.vamem_2, default_g_gamma_table_data,
+	       sizeof(default_g_gamma_table_data));
+	memcpy(default_b_gamma_table.data.vamem_2, default_b_gamma_table_data,
+	       sizeof(default_b_gamma_table_data));
+#else
+	vamem_type = IA_CSS_VAMEM_TYPE_1;
+	memcpy(default_gamma_table.data.vamem_1, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_ctc_table.data.vamem_1, default_ctc_table_data,
+	       sizeof(default_ctc_table_data));
+	memcpy(default_xnr_table.data.vamem_1, default_xnr_table_data,
+	       sizeof(default_xnr_table_data));
+	memcpy(default_r_gamma_table.data.vamem_1, default_r_gamma_table_data,
+	       sizeof(default_r_gamma_table_data));
+	memcpy(default_g_gamma_table.data.vamem_1, default_g_gamma_table_data,
+	       sizeof(default_g_gamma_table_data));
+	memcpy(default_b_gamma_table.data.vamem_1, default_b_gamma_table_data,
+	       sizeof(default_b_gamma_table_data));
+#endif
+	default_gamma_table.vamem_type   = vamem_type;
+	default_ctc_table.vamem_type     = vamem_type;
+	default_xnr_table.vamem_type     = vamem_type;
+	default_r_gamma_table.vamem_type = vamem_type;
+	default_g_gamma_table.vamem_type = vamem_type;
+	default_b_gamma_table.vamem_type = vamem_type;
+
+	sp_ddr_ptrs = sh_css_refcount_retain(-1, mmgr_calloc(1,
+		CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
+			 HIVE_ISP_DDR_WORD_BYTES)));
+	xmem_sp_group_ptrs = sh_css_refcount_retain(-1, mmgr_calloc(1,
+		sizeof(struct sh_css_sp_group)));
+
+	if ((sp_ddr_ptrs == mmgr_NULL) ||
+	    (xmem_sp_group_ptrs == mmgr_NULL)) {
+		ia_css_uninit();
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+void sh_css_params_reconfigure_gdc_lut(void)
+{
+	unsigned i;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() enter: void\n");
+
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store(GDC0_ID, zoom_table);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() leave: return_void\n");
+}
+
+static void free_map_callback(
+	hrt_vaddress ptr)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() enter:\n");
+
+	free_sh_css_ddr_address_map(ptr);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() leave:\n");
+}
+
+static void free_buffer_callback(
+	hrt_vaddress ptr)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() enter:\n");
+
+	mmgr_free(ptr);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() leave:\n");
+}
+
+void
+sh_css_param_clear_param_sets(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() enter:\n");
+
+	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() leave:\n");
+}
+
+/*
+ * MW: we can define mmgr_free() to return a NULL
+ * then you can write ptr = mmgr_free(ptr);
+ */
+#define safe_free(id, x)      \
+	do {                  \
+		sh_css_refcount_release(id, x);     \
+		(x) = mmgr_NULL;  \
+	} while (0)
+
+static void free_map(struct sh_css_ddr_address_map *map)
+{
+	unsigned int i;
+
+	hrt_vaddress *addrs = (hrt_vaddress *)map;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() enter:\n");
+
+	/* free buffers */
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		if (addrs[i] == mmgr_NULL)
+			continue;
+		safe_free(PARAM_BUFFER, addrs[i]);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() leave:\n");
+}
+
+void
+ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
+{
+	int i;
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_isp_parameters_uninit() enter\n");
+	/* free existing ddr_ptr maps */
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		free_map(&params->pipe_ddr_ptrs[i]);
+	free_map(&params->ddr_ptrs);
+
+	if (params->fpn_table.data)
+		sh_css_free(params->fpn_table.data);
+
+	/*Free up theDVS table memory blocks before recomputing new table  */
+	if(params->dvs_6axis_config)
+		free_dvs_6axis_table(&(params->dvs_6axis_config));
+	
+	sh_css_free(params);
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_isp_parameters_uninit() leave\n");
+}
+
+void
+sh_css_params_uninit(void)
+{
+	unsigned p, i;
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() enter:\n");
+
+	safe_free(-1, sp_ddr_ptrs);
+	safe_free(-1, xmem_sp_group_ptrs);
+
+	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++)
+		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
+			safe_free(-1, xmem_sp_stage_ptrs[p][i]);
+			safe_free(-1, xmem_isp_stage_ptrs[p][i]);
+		}
+
+	/* go through the pools to clear references */
+	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);
+	sh_css_refcount_clear(PARAM_BUFFER, &free_buffer_callback);
+	sh_css_refcount_clear(-1, &free_buffer_callback);
+
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() leave: return_void\n");
+}
+
+static void write_morph_plane(
+	unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	hrt_vaddress dest,
+	unsigned int aligned_width)
+{
+	unsigned int i, padding, w;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() enter:\n");
+
+	/* currently we don't have morph table interpolation yet,
+	 * so we allow a wider table to be used. This will be removed
+	 * in the future. */
+	if (width > aligned_width) {
+		padding = 0;
+		w = aligned_width;
+	} else {
+		padding = aligned_width - width;
+		w = width;
+	}
+
+	for (i = 0; i < height; i++) {
+		mmgr_store(dest, data, w * sizeof(short));
+		dest += w * sizeof(short);
+		mmgr_clear(dest, padding * sizeof(short));
+		dest += padding * sizeof(short);
+		data += width;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() leave:\n");
+}
+
+/* Store the DIS coefficients from the 3A library to DDR where the ISP
+   will read them from. The ISP works on a grid that can be larger than
+   that of the 3a library. If that is the case, we padd the difference
+   with zeroes. */
+static void store_dis_coefficients(
+	struct ia_css_isp_parameters *params,
+	const struct sh_css_binary *binary,
+	hrt_vaddress ddr_addr_hor,
+	hrt_vaddress ddr_addr_ver)
+{
+	unsigned int hor_num_isp = binary->dis_hor_coef_num_isp,
+		     ver_num_isp = binary->dis_ver_coef_num_isp,
+		     hor_num_3a  = binary->dis_hor_coef_num_3a,
+		     ver_num_3a  = binary->dis_ver_coef_num_3a,
+		     hor_padding = hor_num_isp - hor_num_3a,
+		     ver_padding = ver_num_isp - ver_num_3a,
+		     i;
+	const short *hor_ptr_3a = params->dis_hor_coef_tbl,
+		*ver_ptr_3a = params->dis_ver_coef_tbl;
+	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
+		ver_ptr_isp = ddr_addr_ver;
+
+assert(binary != NULL);
+assert(ddr_addr_hor != mmgr_NULL);
+assert(ddr_addr_ver != mmgr_NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() enter:\n");
+
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		if (params->dis_hor_coef_tbl != NULL) {
+			mmgr_store(hor_ptr_isp,
+				hor_ptr_3a, hor_num_3a * sizeof(*hor_ptr_3a));
+			hor_ptr_3a  += hor_num_3a;
+		} else {
+			mmgr_clear(hor_ptr_isp,
+				hor_num_3a * sizeof(*hor_ptr_3a));
+		}
+		hor_ptr_isp += hor_num_3a * sizeof(short);
+		mmgr_clear(hor_ptr_isp, hor_padding * sizeof(short));
+		hor_ptr_isp += hor_padding * sizeof(short);
+	}
+	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(binary); i++) {
+		if (params->dis_ver_coef_tbl != NULL) {
+			mmgr_store(ver_ptr_isp,
+				ver_ptr_3a, ver_num_3a * sizeof(*ver_ptr_3a));
+			ver_ptr_3a  += ver_num_3a;
+		} else {
+			mmgr_clear(ver_ptr_isp,
+				ver_num_3a * sizeof(*ver_ptr_3a));
+		}
+		ver_ptr_isp += ver_num_3a * sizeof(short);
+		mmgr_clear(ver_ptr_isp, ver_padding * sizeof(short));
+		ver_ptr_isp += ver_padding * sizeof(short);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() leave:\n");
+}
+
+static void storedvs2_coef(const short *ptr_3a, hrt_vaddress ptr_isp, unsigned num_3a, unsigned padding)
+{
+  if (ptr_3a != NULL) {
+    mmgr_store(ptr_isp, ptr_3a, num_3a * sizeof(*ptr_3a));
+  } else {
+    mmgr_clear(ptr_isp, num_3a * sizeof(*ptr_3a));
+  }
+  ptr_isp += num_3a * sizeof(short);
+  mmgr_clear(ptr_isp, padding * sizeof(short));
+
+}
+
+static void store_dvs2_coefficients(
+	struct ia_css_isp_parameters *params,
+	const struct sh_css_binary *binary,
+	hrt_vaddress ddr_addr_hor,
+	hrt_vaddress ddr_addr_ver)
+{
+	unsigned int hor_num_isp = binary->dis_hor_coef_num_isp,
+		     ver_num_isp = binary->dis_ver_coef_num_isp,
+		     hor_num_3a  = binary->dis_hor_coef_num_3a,
+		     ver_num_3a  = binary->dis_ver_coef_num_3a,
+		     hor_padding = hor_num_isp - hor_num_3a,
+		     ver_padding = ver_num_isp - ver_num_3a;
+	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
+		ver_ptr_isp = ddr_addr_ver;
+
+assert(binary != NULL);
+assert(ddr_addr_hor != mmgr_NULL);
+assert(ddr_addr_ver != mmgr_NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dvs2_coefficients() enter:\n");
+
+  storedvs2_coef(params->dvs2_hor_coefs.odd_real, hor_ptr_isp, hor_num_3a, hor_padding);
+  hor_ptr_isp += hor_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_hor_coefs.odd_imag, hor_ptr_isp, hor_num_3a, hor_padding);
+  hor_ptr_isp += hor_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_hor_coefs.even_real, hor_ptr_isp, hor_num_3a, hor_padding);
+  hor_ptr_isp += hor_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_hor_coefs.even_imag, hor_ptr_isp, hor_num_3a, hor_padding);
+
+  storedvs2_coef(params->dvs2_ver_coefs.odd_real, ver_ptr_isp, ver_num_3a, ver_padding);
+  ver_ptr_isp += ver_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_ver_coefs.odd_imag, ver_ptr_isp, ver_num_3a, ver_padding);
+  ver_ptr_isp += ver_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_ver_coefs.even_real, ver_ptr_isp, ver_num_3a, ver_padding);
+  ver_ptr_isp += ver_num_isp * sizeof(short);
+  storedvs2_coef(params->dvs2_ver_coefs.even_imag, ver_ptr_isp, ver_num_3a, ver_padding);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dvs2_coefficients() leave:\n");
+}
+
+static void sh_css_update_isp_params_to_ddr(
+	struct ia_css_isp_parameters *params,
+	hrt_vaddress ddr_ptr)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() enter:\n");
+
+	if (SH_CSS_PREVENT_UNINIT_READS) {
+		/* ispparm struct is read with DMA which reads
+		 * multiples of the DDR word with (32 bytes):
+		 * So we pad with zeroes to prevent warnings in csim.
+		 */
+		unsigned int aligned_width, padding_bytes;
+		hrt_vaddress pad_ptr;
+
+		aligned_width = CEIL_MUL(
+				  sizeof(struct sh_css_isp_params),
+				  HIVE_ISP_DDR_WORD_BYTES);
+		padding_bytes = aligned_width -
+				sizeof(struct sh_css_isp_params);
+		pad_ptr = ddr_ptr +
+				sizeof(struct sh_css_isp_params);
+		mmgr_clear(pad_ptr, padding_bytes);
+	}
+	mmgr_store(ddr_ptr,
+	     &(params->isp_parameters),
+	     sizeof(struct sh_css_isp_params));
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() leave:\n");
+}
+
+void ia_css_dequeue_param_buffers(void)
+{
+	hrt_vaddress cpy;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_dequeue_param_buffers() enter\n");
+
+	/* clean-up old copy */
+	while (sp2host_dequeue_buffer(0, 0,
+				sh_css_param_buffer_queue,
+				&cpy)) {
+		/* TMP: keep track of dequeued param set count
+		 */
+		g_param_buffer_dequeue_count++;
+		/*
+		 * Tell the SP which queues are not full,
+		 * by sending the software event.
+		 */
+		sh_css_sp_snd_event(SP_SW_EVENT_ID_2,
+				0,
+				sh_css_param_buffer_queue,
+				0);
+
+		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+			"ia_css_dequeue_param_buffers: "
+			"dequeued param set %x from %d\n",
+			cpy, 0);
+			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
+				"ia_css_dequeue_param_buffers: "
+				"release ref on param set %x\n",
+				cpy);
+			free_sh_css_ddr_address_map(cpy);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_dequeue_param_buffers() leave\n");
+}
+
+void
+sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	hrt_vaddress cpy;
+	int i;
+	unsigned int raw_bit_depth = 10;
+	unsigned int isp_pipe_version = 1;
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	bool	any_cc_config_changed = false;
+
+	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(stream);
+	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
+	// this code assuemes that all the pipes have the same pipeversion.
+	for(i=1; i< stream->num_pipes; i++) {
+	  assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
+	}
+	
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() enter:\n");
+
+	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
+/* */
+		any_cc_config_changed = any_cc_config_changed || params->cc_config_changed[i];
+	}
+
+	if (params->s3a_config_changed)
+		sh_css_process_3a(params, raw_bit_depth);
+	if (params->wb_config_changed)
+		sh_css_process_wb(params);
+	if (any_cc_config_changed)
+		sh_css_process_cc(params);
+	if (params->tnr_config_changed)
+		sh_css_process_tnr(params);
+	if (params->ob_config_changed)
+		sh_css_process_ob(params, isp_pipe_version, raw_bit_depth);
+	if (params->dp_config_changed)
+		sh_css_process_dp(params);
+	if (params->nr_config_changed || params->ee_config_changed)
+		sh_css_process_nr_ee(params);
+	if (params->de_config_changed)
+		sh_css_process_de(params);
+	if (params->gc_config_changed)
+		sh_css_process_gc(params);
+	if (params->anr_config_changed)
+		sh_css_process_anr(params);
+	if (params->ce_config_changed)
+		sh_css_process_ce(params);
+	if (params->ecd_config_changed)
+		sh_css_process_ecd(params);
+	if (params->ynr_config_changed)
+		sh_css_process_ynr(params);
+	if (params->fc_config_changed)
+		sh_css_process_fc(params);
+	if (params->cnr_config_changed)
+		sh_css_process_cnr(params);
+	if (params->macc_config_changed)
+		sh_css_process_macc(params);
+	if (params->ctc_config_changed)
+		sh_css_process_ctc(params);
+	if (params->aa_config_changed)
+		sh_css_process_aa(params);
+/*
+	if (params->yuv2rgb_cc_config_changed)
+		sh_css_process_yuv2rgb_cc(params);
+	if (params->rgb2yuv_cc_config_changed)
+		sh_css_process_rgb2yuv_cc(params);
+*/
+	/* now make the map available to the sp */
+	if (!commit) {
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
+		return;
+	}
+	/* enqueue a copies of the mem_map to
+	   the designated pipelines */
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe;
+		struct sh_css_ddr_address_map *cur_map;
+		struct sh_css_ddr_address_map_size *cur_map_size;
+		struct sh_css_ddr_address_map tmp_map;
+		struct sh_css_ddr_address_map_size tmp_map_size;
+		struct sh_css_pipeline *pipeline;
+		struct sh_css_pipeline_stage *stage;
+		unsigned int thread_id, pipe_num;
+
+		pipe = stream->pipes[i];
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		pipe_num = ia_css_pipe_get_pipe_num(pipe);
+		sh_css_query_sp_thread_id(pipe_num, &thread_id);
+
+		cur_map = &params->pipe_ddr_ptrs[pipeline->pipe_id];
+		cur_map_size = &params->pipe_ddr_ptrs_size[pipeline->pipe_id];
+
+		/* TODO: Normally, zoom and motion parameters shouldn't
+		 * be part of "isp_params" as it is resolution/pipe dependant
+		 * Therefore, move the zoom config elsewhere (e.g. shading
+		 * table can be taken as an example! @GC
+		 * */
+		if (params->isp_params_changed || params->dz_config_changed ||
+				params->motion_config_changed) {
+			/* we have to do this per pipeline because */
+			/* the processing is a.o. resolution dependent */
+			sh_css_process_zoom_and_motion(params,
+							pipeline->pipe_id,
+							pipeline->stages);
+		}
+
+		/* update isp_params to pipe specific copies */
+		if (params->isp_params_changed) {
+			reallocate_buffer(&cur_map->isp_param,
+				  &cur_map_size->isp_param,
+				  cur_map_size->isp_param,
+				  true,
+				  &err);
+			sh_css_update_isp_params_to_ddr(params, cur_map->isp_param);
+		}
+		/* update the other buffers to the pipe specific copies */
+		for (stage = pipeline->stages; stage;
+			stage = stage->next) {
+			if (stage && stage->binary) {
+				err =
+				  sh_css_params_write_to_ddr_internal(
+							params,
+							stage->binary,
+							cur_map,
+							cur_map_size);
+				if (err != IA_CSS_SUCCESS)
+					break;
+			}
+		}
+		/* last make referenced copy */
+		err = ref_sh_css_ddr_address_map(
+					cur_map,
+					&tmp_map);
+		tmp_map_size = *cur_map_size;
+		/* now write the copy to ddr */
+		write_sh_css_address_map_to_ddr(&tmp_map, &cpy);
+
+		/* enqueue the set to sp */
+		if (err == IA_CSS_SUCCESS) {
+			bool rc;
+			sh_css_dtrace(SH_DBG_TRACE,
+				"sh_css_param_update_isp_params: "
+				"queue param set %x to %d\n",
+				cpy, thread_id);
+
+			rc = host2sp_enqueue_buffer(thread_id, 0,
+				sh_css_param_buffer_queue,
+				cpy);
+			if (!rc) {
+				free_sh_css_ddr_address_map(cpy);
+			}
+			else {
+				/* TMP: check discrepancy between nr of enqueued
+				 * parameter sets and dequeued sets
+				 */
+				g_param_buffer_enqueue_count++;
+				assert(g_param_buffer_enqueue_count < g_param_buffer_dequeue_count+50);                                                        
+				/*
+				 * Tell the SP which queues are not empty,
+				 * by sending the software event.
+				 */
+				sh_css_sp_snd_event(SP_SW_EVENT_ID_1,
+						thread_id,
+						sh_css_param_buffer_queue,
+						0);
+			}
+		}
+		/* clean-up old copy */
+		ia_css_dequeue_param_buffers();
+	} /* end for each 'active' pipeline */
+	/* clear the changed flags after all params
+	   for all pipelines have been updated */
+	params->isp_params_changed = false;
+	params->fpn_table_changed = false;
+	params->dz_config_changed = false;
+	params->motion_config_changed = false;
+	params->sc_table_changed = false;
+	params->ctc_table_changed = false;
+	params->xnr_table_changed = false;
+	params->anr_thres_changed = false;
+	params->gamma_table_changed = false;
+	params->macc_table_changed = false;
+	params->dis_coef_table_changed = false;
+	params->dvs2_coef_table_changed = false;
+	params->morph_table_changed = false;
+	params->ecd_config_changed = false;
+	params->ynr_config_changed = false;
+	params->fc_config_changed = false;
+	params->cnr_config_changed = false;
+	params->macc_config_changed = false;
+	params->ctc_config_changed = false;
+	params->aa_config_changed = false;
+	params->r_gamma_table_changed = false;
+	params->g_gamma_table_changed = false;
+	params->b_gamma_table_changed = false;
+	params->dvs_6axis_config_changed = false;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
+}
+
+static enum ia_css_err sh_css_params_write_to_ddr_internal(
+	struct ia_css_isp_parameters *params,
+	const struct sh_css_binary *binary,
+	struct sh_css_ddr_address_map *ddr_map,
+	struct sh_css_ddr_address_map_size *ddr_map_size)
+{
+	enum ia_css_err err;
+	bool buff_realloced;
+	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
+	static struct ia_css_macc_table converted_macc_table;
+
+assert(binary != NULL);
+assert(ddr_map != NULL);
+assert(ddr_map_size != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() enter:\n");
+
+	if (binary->info->enable.fpnr) {
+		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
+			&ddr_map_size->fpn_tbl,
+			(size_t)(FPNTBL_BYTES(binary)),
+			params->fpn_table_changed,
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->fpn_table_changed || buff_realloced) {
+			if (params->isp_parameters.fpn_enabled) {
+				store_fpntbl(params, ddr_map->fpn_tbl);
+			} else if (SH_CSS_PREVENT_UNINIT_READS) {
+				hrt_vaddress ptr =
+					(hrt_vaddress)ddr_map->fpn_tbl;
+				/* prevent warnings when reading fpn table
+				 * in csim.*/
+				/* Actual values are not used when fpn is
+				 * disabled. */
+				/* MW: fpn_tbl_size*sizeof(whatever)? */
+				mmgr_clear(ptr, ddr_map_size->fpn_tbl);
+			}
+		}
+	}
+	if (binary->info->enable.sc) {
+		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
+			&ddr_map_size->sc_tbl,
+			(size_t)(SCTBL_BYTES(binary)),
+			params->sc_table_changed,
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->sc_table_changed || buff_realloced) {
+			/* shading table is full resolution, reduce */
+			struct ia_css_shading_table *tmp_sc_table;
+
+			prepare_shading_table(
+				(const struct ia_css_shading_table *)params->sc_table,
+				params->sensor_binning,
+				&tmp_sc_table,
+				binary);
+
+			store_sctbl(params, binary, ddr_map->sc_tbl, tmp_sc_table);
+
+			ia_css_shading_table_free(tmp_sc_table);
+		}
+	}
+
+	if (params->ctc_table_changed) {
+		reallocate_buffer(&ddr_map->ctc_tbl,
+				  &ddr_map_size->ctc_tbl,
+				  ddr_map_size->ctc_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->ctc_tbl,
+				     &(params->ctc_table.data),
+				     ddr_map_size->ctc_tbl);
+	}
+	if (params->gamma_table_changed) {
+		reallocate_buffer(&ddr_map->gamma_tbl,
+				  &ddr_map_size->gamma_tbl,
+				  ddr_map_size->gamma_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->gamma_tbl,
+				     &(params->gamma_table.data),
+				     ddr_map_size->gamma_tbl);
+	}
+	if (params->xnr_table_changed) {
+		reallocate_buffer(&ddr_map->xnr_tbl,
+				  &ddr_map_size->xnr_tbl,
+				  ddr_map_size->xnr_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->xnr_tbl,
+				     &(params->xnr_table.data),
+				     ddr_map_size->xnr_tbl);
+	}
+	if (params->anr_thres_changed) {
+		reallocate_buffer(&ddr_map->anr_thres,
+				  &ddr_map_size->anr_thres,
+				  ddr_map_size->anr_thres,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->anr_thres,
+				     &(params->anr_thres.data),
+				     ddr_map_size->anr_thres);
+	}
+	if (params->macc_table_changed) {
+		unsigned int i, j, idx;
+		unsigned int idx_map[] = {
+			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8};
+
+		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
+			idx = 4*idx_map[i];
+			j   = 4*i;
+
+			converted_macc_table.data[idx] =
+			    sDIGIT_FITTING(params->macc_table.data[j], 13,
+			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
+			converted_macc_table.data[idx+1] =
+			    sDIGIT_FITTING(params->macc_table.data[j+1], 13,
+			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
+			converted_macc_table.data[idx+2] =
+			    sDIGIT_FITTING(params->macc_table.data[j+2], 13,
+			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
+			converted_macc_table.data[idx+3] =
+			    sDIGIT_FITTING(params->macc_table.data[j+3], 13,
+			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
+		}
+		reallocate_buffer(&ddr_map->macc_tbl,
+				  &ddr_map_size->macc_tbl,
+				  ddr_map_size->macc_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->macc_tbl,
+				     converted_macc_table.data,
+				     sizeof(converted_macc_table.data));
+	}
+	
+	if (binary->info->enable.dvs_6axis) {
+		buff_realloced = reallocate_buffer(
+				&ddr_map->dvs_6axis_params_y,
+				&ddr_map_size->dvs_6axis_params_y,
+				(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3), // because UV is packed into the Y plane, calc total YYU size = /2 gives size of UV-only, total YYU size = UV-only * 3
+				params->dvs_6axis_config_changed,
+				&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->dvs_6axis_config_changed || buff_realloced) {
+			if(params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
+			{				
+				struct ia_css_resolution dvs_offset;
+				dvs_offset.width  = binary->dvs_envelope.width / 2;
+				dvs_offset.height = binary->dvs_envelope.height / 2;
+
+				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info.res,
+										&dvs_offset);
+				if(params->dvs_6axis_config == NULL)
+					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			}
+			
+			store_dvs_6axis_config(params,
+				binary,
+				ddr_map->dvs_6axis_params_y);
+		}
+	}
+
+	if (binary->info->enable.dis) {
+		buff_realloced = reallocate_buffer(&ddr_map->sdis_hor_coef,
+				  &ddr_map_size->sdis_hor_coef,
+				  (size_t)(SDIS_HOR_COEF_TBL_BYTES(binary)),
+				  params->dis_coef_table_changed,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		buff_realloced |= reallocate_buffer(&ddr_map->sdis_ver_coef,
+				  &ddr_map_size->sdis_ver_coef,
+				  (size_t)(SDIS_VER_COEF_TBL_BYTES(binary)),
+				  params->dis_coef_table_changed,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (binary->info->isp_pipe_version == 2) {
+			if (params->dvs2_coef_table_changed || buff_realloced) {
+				store_dvs2_coefficients(params, binary,
+					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
+			}
+		} else {
+		if (params->dis_coef_table_changed || buff_realloced) {
+			store_dis_coefficients(params, binary,
+				ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
+		}
+	}
+	}
+
+	if (binary->info->enable.ca_gdc) {
+		unsigned int i;
+		hrt_vaddress *virt_addr_tetra_x[
+			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
+			&ddr_map->tetra_r_x,
+			&ddr_map->tetra_gr_x,
+			&ddr_map->tetra_gb_x,
+			&ddr_map->tetra_b_x,
+			&ddr_map->tetra_ratb_x,
+			&ddr_map->tetra_batr_x
+		};
+		size_t *virt_size_tetra_x[
+			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
+			&ddr_map_size->tetra_r_x,
+			&ddr_map_size->tetra_gr_x,
+			&ddr_map_size->tetra_gb_x,
+			&ddr_map_size->tetra_b_x,
+			&ddr_map_size->tetra_ratb_x,
+			&ddr_map_size->tetra_batr_x
+		};
+		hrt_vaddress *virt_addr_tetra_y[
+			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
+			&ddr_map->tetra_r_y,
+			&ddr_map->tetra_gr_y,
+			&ddr_map->tetra_gb_y,
+			&ddr_map->tetra_b_y,
+			&ddr_map->tetra_ratb_y,
+			&ddr_map->tetra_batr_y
+		};
+		size_t *virt_size_tetra_y[
+			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
+			&ddr_map_size->tetra_r_y,
+			&ddr_map_size->tetra_gr_y,
+			&ddr_map_size->tetra_gb_y,
+			&ddr_map_size->tetra_b_y,
+			&ddr_map_size->tetra_ratb_y,
+			&ddr_map_size->tetra_batr_y
+		};
+		buff_realloced = false;
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			buff_realloced |=
+					reallocate_buffer(virt_addr_tetra_x[i],
+						virt_size_tetra_x[i],
+						(size_t)
+						  (MORPH_PLANE_BYTES(binary)),
+						params->morph_table_changed,
+						&err);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			buff_realloced |=
+					reallocate_buffer(virt_addr_tetra_y[i],
+						virt_size_tetra_y[i],
+						(size_t)
+						  (MORPH_PLANE_BYTES(binary)),
+						params->morph_table_changed,
+						&err);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if (params->morph_table_changed || buff_realloced) {
+			const struct ia_css_morph_table *table = params->morph_table;
+			struct ia_css_morph_table *id_table = NULL;
+
+			if ((table != NULL) &&
+			    (table->width < binary->morph_tbl_width ||
+			     table->height < binary->morph_tbl_height)) {
+				table = NULL;
+			}
+			if (table == NULL) {
+				sh_css_params_default_morph_table(&id_table,
+								  binary);
+				table = id_table;
+			}
+
+			for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+				write_morph_plane(table->coordinates_x[i],
+					table->width,
+					table->height,
+					*virt_addr_tetra_x[i],
+					binary->morph_tbl_aligned_width);
+				write_morph_plane(table->coordinates_y[i],
+					table->width,
+					table->height,
+					*virt_addr_tetra_y[i],
+					binary->morph_tbl_aligned_width);
+			}
+			if (id_table != NULL)
+				ia_css_morph_table_free(id_table);
+		}
+	}
+	if (params->r_gamma_table_changed) {
+		reallocate_buffer(&ddr_map->r_gamma_tbl,
+				  &ddr_map_size->r_gamma_tbl,
+				  ddr_map_size->r_gamma_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->r_gamma_tbl,
+				     &(params->r_gamma_table.data),
+				     ddr_map_size->r_gamma_tbl);
+	}
+	if (params->g_gamma_table_changed) {
+		reallocate_buffer(&ddr_map->g_gamma_tbl,
+				  &ddr_map_size->g_gamma_tbl,
+				  ddr_map_size->g_gamma_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->g_gamma_tbl,
+				     &(params->g_gamma_table.data),
+				     ddr_map_size->g_gamma_tbl);
+	}
+	if (params->b_gamma_table_changed) {
+		reallocate_buffer(&ddr_map->b_gamma_tbl,
+				  &ddr_map_size->b_gamma_tbl,
+				  ddr_map_size->b_gamma_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->b_gamma_tbl,
+				     &(params->b_gamma_table.data),
+				     ddr_map_size->b_gamma_tbl);
+	}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() leave:\n");
+
+return IA_CSS_SUCCESS;
+}
+
+/**
+ * Currently this function is called from:
+ *  - sh_css_commit_isp_config
+ *    (loops through the stages in a pipe to reconfigure settings)
+ */
+enum ia_css_err
+sh_css_params_write_to_ddr(struct ia_css_stream *stream,
+			   const struct sh_css_binary *binary)
+{
+	int i;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+
+	assert(binary != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() enter:\n");
+
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct sh_css_pipeline *pipeline;
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		err = sh_css_params_write_to_ddr_internal(
+				params,
+				binary,
+				&params->pipe_ddr_ptrs[pipeline->pipe_id],
+				&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
+		if (err != IA_CSS_SUCCESS)
+			break;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() leave:\n");
+
+	return err;
+}
+
+const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream *stream)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;	
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_fpn_table() enter & leave:\n");
+	return &(params->fpn_table);
+}
+
+struct ia_css_shading_table * ia_css_get_shading_table(struct ia_css_stream *stream)
+{
+	struct ia_css_shading_table *tmp_sc_table = NULL;
+	struct sh_css_binary *binary = NULL;
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	int i;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_shading_table() enter:\n");
+
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct sh_css_pipeline *pipeline;
+		struct sh_css_pipeline_stage *stage;
+		//unsigned int thread_id;
+
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		assert(pipeline != NULL);
+
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			if (stage && stage->binary) {
+				if (stage->binary->info->enable.sc) {
+					binary = stage->binary;
+					break;
+				}
+			}
+		}
+		if (binary)
+			break;
+	}
+	if (binary)
+		prepare_shading_table(
+			(const struct ia_css_shading_table *)params->sc_table,
+			params->sensor_binning,
+			&tmp_sc_table,
+			binary);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_shading_table() leave:\n");
+
+	return tmp_sc_table;
+}
+
+const struct sh_css_isp_params *ia_css_get_isp_params(struct ia_css_stream *stream)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_params() enter & leave:\n");
+	return &(params->isp_parameters);
+}
+
+void ia_css_get_isp_dis_coefficients(
+	struct ia_css_stream *stream,
+	short *horizontal_coefficients,
+	short *vertical_coefficients)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	unsigned int hor_num_isp, ver_num_isp, i;
+	short *hor_ptr = horizontal_coefficients,
+	      *ver_ptr = vertical_coefficients;
+	hrt_vaddress hor_ptr_isp;
+	hrt_vaddress ver_ptr_isp;
+	struct sh_css_binary *dvs_binary;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dis_coefficients() enter\n");
+	assert(horizontal_coefficients != NULL);
+	assert(vertical_coefficients != NULL);
+
+	/* Only video pipe supports DVS */
+	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
+	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
+	dvs_binary = ia_css_stream_get_dvs_binary(stream);
+	if (!dvs_binary)
+		return;
+
+	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
+	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;
+
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		mmgr_load(hor_ptr_isp, hor_ptr, hor_num_isp * sizeof(short));
+		hor_ptr_isp += hor_num_isp * sizeof(short);
+		hor_ptr     += hor_num_isp;
+	}
+	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(dvs_binary); i++) {
+		mmgr_load(ver_ptr_isp, ver_ptr, ver_num_isp * sizeof(short));
+		ver_ptr_isp += ver_num_isp * sizeof(short);
+		ver_ptr     += ver_num_isp;
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dis_coefficients() leave\n");
+}
+
+void ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
+	short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag,
+	short *hor_coefs_even_real,
+	short *hor_coefs_even_imag,
+	short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag,
+	short *ver_coefs_even_real,
+	short *ver_coefs_even_imag)
+{
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	unsigned int hor_num_3a, ver_num_3a;
+	unsigned int hor_num_isp, ver_num_isp;
+	hrt_vaddress hor_ptr_isp;
+	hrt_vaddress ver_ptr_isp;
+	struct sh_css_binary *dvs_binary;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dvs2_coefficients() enter\n");
+	assert(hor_coefs_odd_real != NULL);
+	assert(hor_coefs_odd_imag != NULL);
+	assert(hor_coefs_even_real != NULL);
+	assert(hor_coefs_even_imag != NULL);
+	assert(ver_coefs_odd_real != NULL);
+	assert(ver_coefs_odd_imag != NULL);
+	assert(ver_coefs_even_real != NULL);
+	assert(ver_coefs_even_imag != NULL);
+
+	/* Only video pipe supports DVS */
+	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
+	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
+	dvs_binary = ia_css_stream_get_dvs_binary(stream);
+	if (!dvs_binary)
+		return;
+
+	hor_num_3a  = dvs_binary->dis_hor_coef_num_3a;
+	ver_num_3a  = dvs_binary->dis_ver_coef_num_3a;
+	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
+	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;
+
+	mmgr_load(hor_ptr_isp, hor_coefs_odd_real, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_odd_imag, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_even_real, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_even_imag, hor_num_3a * sizeof(short));
+
+	mmgr_load(ver_ptr_isp, ver_coefs_odd_real, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_odd_imag, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_even_real, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_even_imag, ver_num_3a * sizeof(short));
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dvs2_coefficients() leave\n");
+}
+
+hrt_vaddress sh_css_store_sp_group_to_ddr(void)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_group_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_sp_group_ptrs,
+			     &sh_css_sp_group,
+			     sizeof(struct sh_css_sp_group));
+	return xmem_sp_group_ptrs;
+}
+
+hrt_vaddress sh_css_store_sp_stage_to_ddr(
+	unsigned pipe,
+	unsigned stage)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_stage_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_sp_stage_ptrs[pipe][stage],
+			     &sh_css_sp_stage,
+			     sizeof(struct sh_css_sp_stage));
+	return xmem_sp_stage_ptrs[pipe][stage];
+}
+
+hrt_vaddress sh_css_store_isp_stage_to_ddr(
+	unsigned pipe,
+	unsigned stage)
+{
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_isp_stage_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_isp_stage_ptrs[pipe][stage],
+			     &sh_css_isp_stage,
+			     sizeof(struct sh_css_isp_stage));
+	return xmem_isp_stage_ptrs[pipe][stage];
+}
+
+static enum ia_css_err ref_sh_css_ddr_address_map(
+	struct sh_css_ddr_address_map *map,
+	struct sh_css_ddr_address_map *out)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int i;
+
+	hrt_vaddress *in_addrs = (hrt_vaddress *)map;
+	hrt_vaddress *to_addrs = (hrt_vaddress *)out;
+
+assert(map != NULL);
+assert(out != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() enter:\n");
+
+	/* copy map using size info */
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		to_addrs[i] = mmgr_NULL;
+		if (in_addrs[i] == mmgr_NULL)
+			continue;
+
+		to_addrs[i] = sh_css_refcount_retain(PARAM_BUFFER, in_addrs[i]);
+	}
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err write_sh_css_address_map_to_ddr(
+	struct sh_css_ddr_address_map *me,
+	hrt_vaddress *out)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool succ;
+
+assert(me != NULL);
+assert(out != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() enter:\n");
+
+	*out = sh_css_refcount_retain(PARAM_SET_POOL, mmgr_malloc(
+				sizeof(struct sh_css_ddr_address_map)));
+	succ = (*out != mmgr_NULL);
+	if (succ)
+		mmgr_store(*out,
+			me, sizeof(struct sh_css_ddr_address_map));
+	else
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err free_sh_css_ddr_address_map(
+	hrt_vaddress ptr)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct sh_css_ddr_address_map map;
+	unsigned int i;
+	hrt_vaddress *addrs = (hrt_vaddress *)&map;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() enter:\n");
+
+	mmgr_load(ptr, &map, sizeof(struct sh_css_ddr_address_map));
+	/* copy map using size info */
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		if (addrs[i] == mmgr_NULL)
+			continue;
+		sh_css_refcount_release(PARAM_BUFFER, addrs[i]);
+	}
+	sh_css_refcount_release(PARAM_SET_POOL, ptr);
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() leave:\n");
+
+	return err;
+}
+
+/* Mark all parameters as changed to force recomputing the derived ISP parameters */
+void sh_css_invalidate_params(struct ia_css_stream *stream)
+{
+	int	i;
+
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_invalidate_params() enter:\n");
+
+	params->isp_params_changed = true;
+	params->fpn_table_changed = true;
+	params->dis_coef_table_changed = true;
+	params->dvs2_coef_table_changed = true;
+	params->morph_table_changed = true;
+	params->sc_table_changed = true;
+	params->macc_table_changed = true;
+	params->gamma_table_changed = true;
+	params->ctc_table_changed = true;
+	params->xnr_table_changed = true;
+	params->anr_thres_changed = true;
+	params->s3a_config_changed = true;
+	params->wb_config_changed = true;
+	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
+/* */
+	params->cc_config_changed[i] = true;
+	}
+	params->tnr_config_changed = true;
+	params->ob_config_changed = true;
+	params->dp_config_changed = true;
+	params->nr_config_changed = true;
+	params->ee_config_changed = true;
+	params->de_config_changed = true;
+	params->gc_config_changed = true;
+	params->anr_config_changed = true;
+	params->ce_config_changed = true;
+	params->dz_config_changed = true;
+	params->motion_config_changed = true;
+	
+	/*Free up theDVS table memory blocks before recomputing new table  */
+	if(params->dvs_6axis_config)
+		free_dvs_6axis_table(&(params->dvs_6axis_config));
+	params->dvs_6axis_config_changed = true;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_invalidate_params() leave:\n");
+}
+
+void sh_css_update_uds_and_crop_info(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	bool preview_mode,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds,		/* out */
+	struct sh_css_crop_pos *sp_out_crop_pos)/* out */
+{
+assert(info != NULL);
+assert(in_frame_info != NULL);
+assert(out_frame_info != NULL);
+assert(dvs_env != NULL);
+assert(zoom != NULL);
+assert(motion_vector != NULL);
+assert(uds != NULL);
+assert(sp_out_crop_pos != NULL);
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_uds_and_crop_info() enter:\n");
+
+	if (info->mode == SH_CSS_BINARY_MODE_VF_PP && !preview_mode) {
+		/* in non-preview modes, VF_PP does not do
+		   the zooming, capture_pp or video do. */
+		uds->curr_dx = HRT_GDC_N;
+		uds->curr_dy = HRT_GDC_N;
+	} else {
+		uds->curr_dx   = zoom->dx;
+		uds->curr_dy   = zoom->dy;
+	}
+
+	if (info->enable.dvs_envelope) {
+		unsigned int crop_x = 0,
+			     crop_y = 0,
+			     uds_xc = 0,
+			     uds_yc = 0,
+			     env_width, env_height;
+		int half_env_x, half_env_y;
+		int motion_x = motion_vector->x;
+		int motion_y = motion_vector->y;
+		bool upscale_x = in_frame_info->res.width < out_frame_info->res.width;
+		bool upscale_y = in_frame_info->res.height < out_frame_info->res.height;
+
+		if (info->enable.uds && !info->enable.ds) {
+			/**
+			 * we calculate with the envelope that we can actually
+			 * use, the min dvs envelope is for the filter
+			 * initialization.
+			 */
+			env_width  = dvs_env->width -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			/**
+			 * for digital zoom, we use the dvs envelope and make
+			 * sure that we don't include the 8 leftmost pixels or
+			 * 8 topmost rows.
+			 */
+			if (upscale_x) {
+				uds_xc = (in_frame_info->res.width
+					+ env_width
+					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
+			} else {
+				uds_xc = (out_frame_info->res.width
+							+ env_width) / 2
+					+ SH_CSS_MIN_DVS_ENVELOPE;
+			}
+			if (upscale_y) {
+				uds_yc = (in_frame_info->res.height
+					+ env_height
+					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
+			} else {
+				uds_yc = (out_frame_info->res.height
+							+ env_height) / 2
+					+ SH_CSS_MIN_DVS_ENVELOPE;
+			}
+			/* clip the motion vector to +/- half the envelope */
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			uds_xc += motion_x;
+			uds_yc += motion_y;
+			/* uds can be pipelined, remove top lines */
+			crop_y = 2;
+		} else if (info->enable.ds) {
+			env_width  = dvs_env->width;
+			env_height = dvs_env->height;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			/* clip the motion vector to +/- half the envelope */
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			/* for video with downscaling, the envelope is included
+			    in the input resolution. */
+			uds_xc = in_frame_info->res.width/2 + motion_x;
+			uds_yc = in_frame_info->res.height/2 + motion_y;
+			crop_x = info->left_cropping;
+			/* ds == 2 (yuv_ds) can be pipelined, remove top
+			   lines */
+			if (info->enable.ds & 1)
+				crop_y = info->top_cropping;
+			else
+				crop_y = 2;
+		} else {
+			/* video nodz: here we can only crop. We make sure we
+			   crop at least the first 8x8 pixels away. */
+			env_width  = dvs_env->width -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			crop_x = SH_CSS_MIN_DVS_ENVELOPE
+						+ half_env_x + motion_x;
+			crop_y = SH_CSS_MIN_DVS_ENVELOPE
+						+ half_env_y + motion_y;
+		}
+
+		/* Must enforce that the crop position is even */
+		crop_x = EVEN_FLOOR(crop_x);
+		crop_y = EVEN_FLOOR(crop_y);
+		uds_xc = EVEN_FLOOR(uds_xc);
+		uds_yc = EVEN_FLOOR(uds_yc);
+
+		uds->xc = uds_xc;
+		uds->yc = uds_yc;
+		sp_out_crop_pos->x = crop_x;
+		sp_out_crop_pos->y = crop_y;
+	}
+	else {
+		/* for down scaling, we always use the center of the image */
+		uds->xc = in_frame_info->res.width / 2;
+		uds->yc = in_frame_info->res.height / 2;
+		sp_out_crop_pos->x = info->left_cropping;
+		sp_out_crop_pos->y = info->top_cropping;
+	}
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_uds_and_crop_info() leave:\n");
+}
+
+struct ia_css_3a_statistics *
+ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
+{
+	struct ia_css_3a_statistics *me;
+	int grid_size;
+
+	assert(grid != NULL);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() enter: grid=%p\n",grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+	grid_size = grid->width * grid->height;
+	me->data = sh_css_malloc(grid_size * sizeof(*me->data));
+	if (!me->data)
+		goto err;
+#if !defined(HAS_NO_HMEM)
+	/* No weighted histogram, no structure, treat the histogram data as a byte dump in a byte array */
+	me->rgby_data = (struct ia_css_3a_rgby_output *)sh_css_malloc(sizeof_hmem(HMEM0_ID));
+#else
+	me->rgby_data = NULL;
+#endif
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_3a_statistics_free(me);
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->rgby_data);
+		sh_css_free(me->data);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_statistics *
+ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs_statistics *me;
+
+	assert(grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+	me->hor_proj = sh_css_malloc(grid->height * IA_CSS_DVS_NUM_COEF_TYPES *
+					sizeof(*me->hor_proj));
+	if (!me->hor_proj)
+		goto err;
+
+	me->ver_proj = sh_css_malloc(grid->width * IA_CSS_DVS_NUM_COEF_TYPES *
+					sizeof(*me->ver_proj));
+	if (!me->ver_proj)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs_statistics_free(me);
+	return NULL;
+
+}
+
+void
+ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->hor_proj);
+		sh_css_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_coefficients *
+ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs_coefficients *me;
+
+	assert(grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+
+	me->hor_coefs = sh_css_malloc(grid->num_hor_coefs *
+				IA_CSS_DVS_NUM_COEF_TYPES *
+				sizeof(*me->hor_coefs));
+	if (!me->hor_coefs)
+		goto err;
+
+	me->ver_coefs = sh_css_malloc(grid->num_ver_coefs *
+				IA_CSS_DVS_NUM_COEF_TYPES *
+				sizeof(*me->ver_coefs));
+	if (!me->ver_coefs)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs_coefficients_free(me);
+	return NULL;
+}
+
+void
+ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
+{
+	if (me) {
+		sh_css_free(me->hor_coefs);
+		sh_css_free(me->ver_coefs);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs2_statistics *
+ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs2_statistics *me;
+
+	assert(grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+	
+	me->hor_prod.odd_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.odd_real));
+	if (!me->hor_prod.odd_real)
+		goto err;
+
+	me->hor_prod.odd_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.odd_imag));
+	if (!me->hor_prod.odd_imag)
+		goto err;
+
+	me->hor_prod.even_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.even_real));
+	if (!me->hor_prod.even_real)
+		goto err;
+
+	me->hor_prod.even_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.even_imag));
+	if (!me->hor_prod.even_imag)
+		goto err;
+
+	me->ver_prod.odd_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.odd_real));
+	if (!me->ver_prod.odd_real)
+		goto err;
+
+	me->ver_prod.odd_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.odd_imag));
+	if (!me->ver_prod.odd_imag)
+		goto err;
+
+	me->ver_prod.even_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.even_real));
+	if (!me->ver_prod.even_real)
+		goto err;
+
+	me->ver_prod.even_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.even_imag));
+	if (!me->ver_prod.even_imag)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs2_statistics_free(me);
+	return NULL;
+
+}
+
+void
+ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->hor_prod.odd_real);
+		sh_css_free(me->hor_prod.odd_imag);
+		sh_css_free(me->hor_prod.even_real);
+		sh_css_free(me->hor_prod.even_imag);
+		sh_css_free(me->ver_prod.odd_real);
+		sh_css_free(me->ver_prod.odd_imag);
+		sh_css_free(me->ver_prod.even_real);
+		sh_css_free(me->ver_prod.even_imag);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs2_coefficients *
+ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs2_coefficients *me;
+
+	assert(grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+
+	me->hor_coefs.odd_real = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.odd_real));
+	if (!me->hor_coefs.odd_real)
+		goto err;
+
+	me->hor_coefs.odd_imag = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.odd_imag));
+	if (!me->hor_coefs.odd_imag)
+		goto err;
+
+	me->hor_coefs.even_real = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.even_real));
+	if (!me->hor_coefs.even_real)
+		goto err;
+
+	me->hor_coefs.even_imag = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.even_imag));
+	if (!me->hor_coefs.even_imag)
+		goto err;
+
+	me->ver_coefs.odd_real = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.odd_real));
+	if (!me->ver_coefs.odd_real)
+		goto err;
+
+	me->ver_coefs.odd_imag = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.odd_imag));
+	if (!me->ver_coefs.odd_imag)
+		goto err;
+
+	me->ver_coefs.even_real = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.even_real));
+	if (!me->ver_coefs.even_real)
+		goto err;
+
+	me->ver_coefs.even_imag = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.even_imag));
+	if (!me->ver_coefs.even_imag)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs2_coefficients_free(me);
+	return NULL;
+}
+
+void
+ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
+{
+	if (me) {
+		sh_css_free(me->hor_coefs.odd_real);
+		sh_css_free(me->hor_coefs.odd_imag);
+		sh_css_free(me->hor_coefs.even_real);
+		sh_css_free(me->hor_coefs.even_imag);
+		sh_css_free(me->ver_coefs.odd_real);
+		sh_css_free(me->ver_coefs.odd_imag);
+		sh_css_free(me->ver_coefs.even_real);
+		sh_css_free(me->ver_coefs.even_imag);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_6axis_config *
+ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
+{
+    struct ia_css_dvs_6axis_config *dvs_config = NULL;
+    struct ia_css_isp_parameters *params = NULL;
+    unsigned int width_y;
+    unsigned int height_y;
+    unsigned int width_uv;
+    unsigned int height_uv;
+
+    assert(stream);
+    params = stream->isp_params_configs;
+    assert(params);
+    assert(params->dvs_6axis_config);
+
+    dvs_config = (struct ia_css_dvs_6axis_config *)sh_css_calloc(1, sizeof(struct ia_css_dvs_6axis_config));
+    if(!dvs_config)
+          goto err;
+
+    dvs_config->width_y = width_y = params->dvs_6axis_config->width_y;
+    dvs_config->height_y = height_y = params->dvs_6axis_config->height_y;
+    dvs_config->width_uv = width_uv = params->dvs_6axis_config->width_uv;
+    dvs_config->height_uv = height_uv = params->dvs_6axis_config->height_uv;
+    sh_css_dtrace(SH_DBG_TRACE, "config_allocate table Y: W %d H %d\n",width_y,height_y); 
+    sh_css_dtrace(SH_DBG_TRACE, "config_allocate table UV: W %d H %d\n",width_uv,height_uv); 
+    dvs_config->xcoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+    if(!dvs_config->xcoords_y)
+        goto err;
+
+    dvs_config->ycoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+    if(!dvs_config->ycoords_y)
+        goto err;
+
+    dvs_config->xcoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+    if(!dvs_config->xcoords_uv)
+        goto err;
+
+    dvs_config->ycoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+    if(!dvs_config->ycoords_uv)
+        goto err;
+
+    return dvs_config;
+err:
+        ia_css_dvs2_6axis_config_free(dvs_config);
+        return NULL;
+}
+
+void
+ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config)
+{
+    if(dvs_6axis_config)
+    {
+        sh_css_free(dvs_6axis_config->xcoords_y);
+        sh_css_free(dvs_6axis_config->ycoords_y);
+        sh_css_free(dvs_6axis_config->xcoords_uv);
+        sh_css_free(dvs_6axis_config->ycoords_uv);
+        sh_css_free(dvs_6axis_config);
+	}
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_params.h b/drivers/media/atomisp2/css2400/sh_css_params.h
new file mode 100644
index 0000000..eec188c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params.h
@@ -0,0 +1,127 @@
+#ifndef _SH_CSS_PARAMS_H_
+#define _SH_CSS_PARAMS_H_
+
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+/*! \file */
+
+#include "ia_css_types.h"
+#include "ia_css.h"
+#include "sh_css_internal.h"
+#include "sh_css_legacy.h"
+
+struct ia_css_isp_parameters {
+	struct sh_css_isp_params isp_parameters;
+	struct ia_css_fpn_table fpn_table;
+	struct ia_css_vector motion_config;
+	const struct ia_css_morph_table   *morph_table;
+	const struct ia_css_shading_table *sc_table;
+	struct ia_css_macc_table    macc_table;
+	struct ia_css_gamma_table   gamma_table;
+	struct ia_css_ctc_table     ctc_table;
+	struct ia_css_xnr_table     xnr_table;
+	struct ia_css_dz_config     dz_config;
+	struct ia_css_3a_config     s3a_config;
+	struct ia_css_wb_config     wb_config;
+	struct ia_css_cc_config     cc_config[N_CSC_KERNEL_PARAM_SET];
+	struct ia_css_tnr_config    tnr_config;
+	struct ia_css_ob_config     ob_config;
+	struct ia_css_dp_config     dp_config;
+	struct ia_css_nr_config     nr_config;
+	struct ia_css_ee_config     ee_config;
+	struct ia_css_de_config     de_config;
+	struct ia_css_gc_config     gc_config;
+	struct ia_css_anr_config    anr_config;
+	struct ia_css_ce_config     ce_config;
+	
+	struct ia_css_dvs_6axis_config	*dvs_6axis_config;
+	
+	struct ia_css_ecd_config    ecd_config;
+	struct ia_css_ynr_config    ynr_config;
+	struct ia_css_fc_config     fc_config;
+	struct ia_css_cnr_config    cnr_config;
+	struct ia_css_macc_config   macc_config;
+	struct ia_css_ctc_config    ctc_config;
+	struct ia_css_aa_config     aa_config;
+	struct ia_css_rgb_gamma_table     r_gamma_table;
+	struct ia_css_rgb_gamma_table     g_gamma_table;
+	struct ia_css_rgb_gamma_table     b_gamma_table;
+	struct ia_css_anr_thres     anr_thres;
+/*
+	struct ia_css_yuv2rgb_cc_config   yuv2rgb_cc_config;
+	struct ia_css_rgb2yuv_cc_config   rgb2yuv_cc_config;
+*/
+	bool isp_params_changed;
+	bool fpn_table_changed;
+	bool dz_config_changed;
+	bool motion_config_changed;
+	bool dis_coef_table_changed;
+	bool dvs2_coef_table_changed;
+	bool morph_table_changed;
+	bool sc_table_changed;
+	bool macc_table_changed;
+	bool gamma_table_changed;
+	bool ctc_table_changed;
+	bool xnr_table_changed;
+	bool s3a_config_changed;
+	bool wb_config_changed;
+	bool cc_config_changed[N_CSC_KERNEL_PARAM_SET];
+	bool tnr_config_changed;
+	bool ob_config_changed;
+	bool dp_config_changed;
+	bool nr_config_changed;
+	bool ee_config_changed;
+	bool de_config_changed;
+	bool gc_config_changed;
+	bool anr_config_changed;
+	bool ce_config_changed;
+	bool dvs_6axis_config_changed;
+	bool ecd_config_changed;
+	bool ynr_config_changed;
+	bool fc_config_changed;
+	bool cnr_config_changed;
+	bool macc_config_changed;
+	bool ctc_config_changed;
+	bool aa_config_changed;
+	bool r_gamma_table_changed;
+	bool g_gamma_table_changed;
+	bool b_gamma_table_changed;
+	bool anr_thres_changed;
+/*
+	bool yuv2rgb_cc_config_changed;
+	bool rgb2yuv_cc_config_changed;
+*/
+	unsigned int sensor_binning;
+	/* local buffers, used to re-order the 3a statistics in vmem-format */
+	const short *dis_hor_coef_tbl;
+	const short *dis_ver_coef_tbl;
+	struct ia_css_dvs2_coef_types dvs2_hor_coefs;
+	struct ia_css_dvs2_coef_types dvs2_ver_coefs;
+	struct sh_css_ddr_address_map pipe_ddr_ptrs[IA_CSS_PIPE_ID_NUM];
+	struct sh_css_ddr_address_map_size pipe_ddr_ptrs_size[IA_CSS_PIPE_ID_NUM];
+	struct sh_css_ddr_address_map ddr_ptrs;
+	struct sh_css_ddr_address_map_size ddr_ptrs_size;
+};
+
+#endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_params_internal.h b/drivers/media/atomisp2/css2400/sh_css_params_internal.h
new file mode 100644
index 0000000..5a60a0b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params_internal.h
@@ -0,0 +1,30 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_PARAMS_INTERNAL_H_
+#define _SH_CSS_PARAMS_INTERNAL_H_
+
+void
+sh_css_param_clear_param_sets(void);
+
+#endif /* _SH_CSS_PARAMS_INTERNAL_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_refcount.c b/drivers/media/atomisp2/css2400/sh_css_refcount.c
new file mode 100644
index 0000000..8a3b7ec
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_refcount.c
@@ -0,0 +1,239 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "sh_css_refcount.h"
+#include "memory_access/memory_access.h"
+#include "sh_css_defs.h"
+
+#include "platform_support.h"
+
+#include "assert_support.h"
+
+#include "sh_css_debug.h"
+
+/* TODO: enable for other memory aswell
+	 now only for hrt_vaddress */
+struct sh_css_refcount_entry {
+	uint32_t count;
+	hrt_vaddress data;
+	int32_t id;
+};
+
+struct sh_css_refcount_list {
+	uint32_t size;
+	struct sh_css_refcount_entry *items;
+};
+
+static struct sh_css_refcount_list myrefcount;
+
+int sh_css_refcount_used(void)
+{
+	uint32_t i;
+	int used = 0;
+	for (i = 0; i < myrefcount.size; i++) {
+		if ((&myrefcount.items[i])->data != mmgr_NULL)
+			++used;
+	}
+	return used;
+}
+
+static struct sh_css_refcount_entry *find_entry(hrt_vaddress ptr,
+		bool firstfree)
+{
+	uint32_t i;
+
+assert(ptr != 0);
+assert(myrefcount.items != NULL);
+
+	for (i = 0; i < myrefcount.size; i++) {
+
+		if ((&myrefcount.items[i])->data == 0) {
+			if (firstfree) {
+				/* for new entry */
+				return &myrefcount.items[i];
+			}
+		}
+		if ((&myrefcount.items[i])->data == ptr) {
+			/* found entry */
+			return &myrefcount.items[i];
+		}
+	}
+	return NULL;
+}
+
+enum ia_css_err sh_css_refcount_init(void)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	int size = 1000;
+
+assert(myrefcount.items == NULL);
+
+	myrefcount.items =
+		sh_css_malloc(sizeof(struct sh_css_refcount_entry)*size);
+	if (!myrefcount.items)
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	if (err == IA_CSS_SUCCESS) {
+		memset(myrefcount.items, 0,
+			   sizeof(struct sh_css_refcount_entry)*size);
+		myrefcount.size = size;
+	}
+	return err;
+}
+
+void sh_css_refcount_uninit(void)
+{
+	struct sh_css_refcount_entry *entry;
+	uint32_t i;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_refcount_uninit() entry\n");
+	for (i = 0; i < myrefcount.size; i++) {
+		entry = &myrefcount.items[i];
+		if (entry->data != mmgr_NULL) {
+/*			sh_css_dtrace(SH_DBG_TRACE,
+				"sh_css_refcount_uninit: freeing (%x)\n",
+				entry->data);*/
+			mmgr_free(entry->data);
+			entry->data = mmgr_NULL;
+			entry->count = 0;
+			entry->id = 0;
+		}
+	}
+	sh_css_free(myrefcount.items);
+	myrefcount.items = NULL;
+	myrefcount.size = 0;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_refcount_uninit() leave\n");
+}
+
+hrt_vaddress sh_css_refcount_retain(int32_t id, hrt_vaddress ptr)
+{
+	struct sh_css_refcount_entry *entry;
+
+	entry = find_entry(ptr, false);
+
+	sh_css_dtrace(SH_DBG_INFO, "sh_css_refcount_retain(%x) 0x%x\n", id, ptr);
+
+	if (!entry) {
+		entry = find_entry(ptr, true);
+		entry->id = id;
+	}
+
+	assert(entry != NULL);
+	assert(entry->id == id);
+
+	if (entry->data == ptr)
+		entry->count += 1;
+	else if (entry->data == mmgr_NULL) {
+		entry->data = ptr;
+		entry->count = 1;
+	} else
+		return mmgr_NULL;
+
+	return ptr;
+}
+
+bool sh_css_refcount_release(int32_t id, hrt_vaddress ptr)
+{
+	struct sh_css_refcount_entry *entry;
+
+	sh_css_dtrace(SH_DBG_INFO, "sh_css_refcount_release(%x) 0x%x\n", id, ptr);
+
+	if (ptr == mmgr_NULL)
+		return false;
+
+	entry = find_entry(ptr, false);
+
+	if (entry) {
+		assert(entry->id == id);
+		if (entry->count > 0) {
+			entry->count -= 1;
+			if (entry->count == 0) {
+/*				sh_css_dtrace(SH_DBG_TRACE,
+					"sh_css_refcount_release: freeing\n");*/
+				mmgr_free(ptr);
+				entry->data = mmgr_NULL;
+				entry->id = 0;
+			}
+			return true;
+		}
+	}
+
+/* SHOULD NOT HAPPEN: ptr not managed by refcount, or not valid anymore */
+assert(false);
+
+	return false;
+}
+
+bool sh_css_refcount_is_single(hrt_vaddress ptr)
+{
+	struct sh_css_refcount_entry *entry;
+
+	if (ptr == mmgr_NULL)
+		return false;
+
+	entry = find_entry(ptr, false);
+
+	if (entry)
+		return (entry->count == 1);
+
+	return true;
+}
+
+int32_t sh_css_refcount_get_id(hrt_vaddress ptr)
+{
+	struct sh_css_refcount_entry *entry;
+	assert(ptr != mmgr_NULL);
+	entry = find_entry(ptr, false);
+	assert(entry != NULL);
+	return entry->id;
+}
+
+void sh_css_refcount_clear(int32_t id, void (*clear_func)(hrt_vaddress ptr))
+{
+	struct sh_css_refcount_entry *entry;
+	uint32_t i;
+	uint32_t count = 0;
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_refcount_clear(%x)\n", id);
+	for (i = 0; i < myrefcount.size; i++) {
+		entry = &myrefcount.items[i];
+		if ((entry->data != mmgr_NULL) && (entry->id == id)) {
+			sh_css_dtrace(SH_DBG_TRACE, "sh_css_refcount_clear:"
+					" %x: 0x%x\n", id, entry->data);
+			if (clear_func) {
+				/* clear using provided function */
+				clear_func(entry->data);
+			}
+			else {
+				sh_css_dtrace(SH_DBG_TRACE,
+						"sh_css_refcount_clear: "
+						"using mmgr_free: no clear_func\n");
+				mmgr_free(entry->data);
+			}
+			assert(entry->count == 0);
+			entry->data = mmgr_NULL;
+			entry->count = 0;
+			entry->id = 0;
+			count++;
+		}
+	}
+	sh_css_dtrace(SH_DBG_TRACE, "sh_css_refcount_clear(%x): cleared %d\n",
+		id, count);
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_refcount.h b/drivers/media/atomisp2/css2400/sh_css_refcount.h
new file mode 100644
index 0000000..b253f5f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_refcount.h
@@ -0,0 +1,50 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_REFCOUNT_H_
+#define _SH_CSS_REFCOUNT_H_
+
+#include "ia_css.h"
+#include "sh_css_binary.h"
+#include "sh_css_internal.h"
+
+#define PARAM_SET_POOL  0xCAFE0001
+#define PARAM_BUFFER    0xCAFE0002
+
+enum ia_css_err sh_css_refcount_init(void);
+
+void sh_css_refcount_uninit(void);
+
+hrt_vaddress sh_css_refcount_retain(int32_t id, hrt_vaddress ptr);
+
+bool sh_css_refcount_release(int32_t id, hrt_vaddress ptr);
+
+bool sh_css_refcount_is_single(hrt_vaddress ptr);
+
+int32_t sh_css_refcount_get_id(hrt_vaddress ptr);
+
+void sh_css_refcount_clear(int32_t id, void (*clear_func)(hrt_vaddress ptr));
+
+int sh_css_refcount_used(void);
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_rx.c b/drivers/media/atomisp2/css2400/sh_css_rx.c
new file mode 100644
index 0000000..37d724f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_rx.c
@@ -0,0 +1,498 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#define __INLINE_INPUT_SYSTEM__
+#include "input_system.h"
+
+#include "ia_css.h"
+#include "sh_css_rx.h"
+#include "sh_css_internal.h"
+
+void
+sh_css_rx_enable_all_interrupts(void)
+{
+	hrt_data	bits = receiver_port_reg_load(RX0_ID,
+		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+
+	bits |= (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT) |
+#if defined(HAS_RX_VERSION_2)
+		(1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT) |
+#endif
+		(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT) |
+/*		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT) | */
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT) |
+		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT);
+/*		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT); */
+
+	receiver_port_reg_store(RX0_ID,
+		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
+
+/*
+ * The CSI is nested into the Iunit IRQ's
+ */
+	ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR, true);
+
+return;
+}
+
+unsigned int sh_css_rx_get_interrupt_reg(void)
+{
+return receiver_port_reg_load(RX0_ID,
+	MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+}
+
+void
+ia_css_rx_get_irq_info(unsigned int *irq_infos)
+{
+	unsigned long	infos = 0;
+
+	hrt_data	bits = receiver_port_reg_load(RX0_ID,
+		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN;
+#if defined(HAS_RX_VERSION_2)
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT;
+#endif
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ECC_CORRECTED;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_SOT;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_CONTROL;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_CRC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC;
+
+	*irq_infos = infos;
+}
+
+void
+ia_css_rx_clear_irq_info(unsigned int irq_infos)
+{
+	hrt_data	bits = receiver_port_reg_load(RX0_ID,
+		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+
+/* MW: Why do we remap the receiver bitmap */
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT;
+#if defined(HAS_RX_VERSION_2)
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT;
+#endif
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ECC_CORRECTED)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT;
+
+	receiver_port_reg_store(RX0_ID,
+		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
+return;
+}
+
+enum ia_css_err sh_css_input_format_type(
+	enum ia_css_stream_format input_format,
+	mipi_predictor_t compression,
+	unsigned int *fmt_type)
+{
+/*
+ * Custom (user defined) modes. Used for compressed
+ * MIPI transfers
+ *
+ * Checkpatch thinks the indent before "if" is suspect
+ * I think the only suspect part is the missing "else"
+ * because of the return.
+ */
+	if (compression != MIPI_PREDICTOR_NONE) {
+		switch (input_format) {
+		case IA_CSS_STREAM_FORMAT_RAW_6:
+			*fmt_type = 6;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_7:
+			*fmt_type = 7;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_8:
+			*fmt_type = 8;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_10:
+			*fmt_type = 10;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_12:
+			*fmt_type = 12;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_14:
+			*fmt_type = 14;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_16:
+			*fmt_type = 16;
+			break;
+		default:
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
+		return IA_CSS_SUCCESS;
+	}
+/*
+ * This mapping comes from the Arasan CSS function spec
+ * (CSS_func_spec1.08_ahb_sep29_08.pdf).
+ *
+ * MW: For some reason the mapping is not 1-to-1
+ */
+	switch (input_format) {
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		*fmt_type = MIPI_FORMAT_RGB888;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+		*fmt_type = MIPI_FORMAT_RGB555;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+		*fmt_type = MIPI_FORMAT_RGB444;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		*fmt_type = MIPI_FORMAT_RGB565;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+		*fmt_type = MIPI_FORMAT_RGB666;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+		*fmt_type = MIPI_FORMAT_RAW8;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+		*fmt_type = MIPI_FORMAT_RAW10;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+		*fmt_type = MIPI_FORMAT_RAW6;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+		*fmt_type = MIPI_FORMAT_RAW7;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		*fmt_type = MIPI_FORMAT_RAW12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+		*fmt_type = MIPI_FORMAT_RAW14;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+		*fmt_type = MIPI_FORMAT_YUV420_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		*fmt_type = MIPI_FORMAT_YUV420_10;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+		*fmt_type = MIPI_FORMAT_YUV422_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		*fmt_type = MIPI_FORMAT_YUV422_10;
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		*fmt_type = MIPI_FORMAT_BINARY_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		*fmt_type = MIPI_FORMAT_YUV420_8_LEGACY;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		/* This is not specified by Arasan, so we use
+		 * 17 for now.
+		 */
+		*fmt_type = MIPI_FORMAT_RAW16;
+		break;
+#if defined(HAS_RX_VERSION_2)
+	default:
+		if (input_format > (enum ia_css_stream_format)N_MIPI_FORMAT)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		*fmt_type = input_format;
+		break;
+#else
+	default:
+		return IA_CSS_ERR_INTERNAL_ERROR;
+#endif
+	}
+return IA_CSS_SUCCESS;
+}
+
+#if defined(HAS_RX_VERSION_1)
+
+/* This is a device function, shouldn't be here */
+static void sh_css_rx_set_bits(
+	const mipi_port_ID_t	port,
+	const unsigned int		reg,
+	const unsigned int		lsb,
+	const unsigned int		bits,
+	const unsigned int		val)
+{
+	hrt_data	data = receiver_port_reg_load(RX0_ID, port, reg);
+/* prevent writing out of range */
+	hrt_data	tmp = val & ((1U << bits) - 1);
+/* shift into place */
+	data |= (tmp << lsb);
+	receiver_port_reg_store(RX0_ID, port, reg, data);
+return;
+}
+
+static void sh_css_rx_set_num_lanes(
+	const mipi_port_ID_t	port,
+	const unsigned int		lanes)
+{
+	sh_css_rx_set_bits(port,
+		_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
+		_HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_IDX,
+		_HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_BITS,
+		lanes);
+return;
+}
+
+static void sh_css_rx_set_timeout(
+	const mipi_port_ID_t	port,
+	const unsigned int		timeout)
+{
+	sh_css_rx_set_bits(port,
+		_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
+		_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX,
+		_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS,
+		timeout);
+return;
+}
+
+static void sh_css_rx_set_compression(
+	const mipi_port_ID_t				port,
+	const mipi_predictor_t				comp)
+{
+	unsigned int reg = _HRT_CSS_RECEIVER_COMP_PREDICT_REG_IDX;
+
+assert(comp < N_MIPI_PREDICTOR_TYPES);
+
+	receiver_port_reg_store(RX0_ID, port, reg, comp);
+return;
+}
+
+static void sh_css_rx_set_uncomp_size(
+	const mipi_port_ID_t	port,
+	const unsigned int		size)
+{
+	sh_css_rx_set_bits(port,
+		_HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX,
+		_HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_IDX,
+		_HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_BITS,
+		size);
+return;
+}
+
+static void sh_css_rx_set_comp_size(
+	const mipi_port_ID_t	port,
+	const unsigned int		size)
+{
+	sh_css_rx_set_bits(port,
+		_HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX,
+		_HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_IDX,
+		_HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_BITS,
+		size);
+return;
+}
+#endif /* defined(HAS_RX_VERSION_1) */
+
+void sh_css_rx_configure(
+	const rx_cfg_t		*config,
+	const enum ia_css_input_mode input_mode)
+{
+#if defined(HAS_RX_VERSION_2)
+	bool	port_enabled[N_MIPI_PORT_ID];
+	bool	any_port_enabled = false;
+	mipi_port_ID_t	port;
+
+	for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
+		if (is_receiver_port_enabled(RX0_ID, port))
+			any_port_enabled = true;
+	}
+/* AM: Check whether this is a problem with multiple streams. MS: This is the case.*/
+
+/* Must turn off all ports because of the 2ppc setting */
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+    for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
+		port_enabled[port] = is_receiver_port_enabled(RX0_ID, port);
+		receiver_port_enable(RX0_ID, port, false);
+	}
+#else
+	port = config->port;
+	receiver_port_enable(RX0_ID, port, false);
+#endif
+
+	port = config->port;
+
+	/* AM: Check whether this is a problem with multiple streams. */
+	if (MIPI_PORT_LANES[config->mode][port] != MIPI_0LANE_CFG) {
+		receiver_port_reg_store(RX0_ID, port,
+			_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
+			config->timeout);
+		receiver_port_reg_store(RX0_ID, port,
+			_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,
+			config->initcount);
+		receiver_port_reg_store(RX0_ID, port,
+			_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,
+			config->synccount);
+		receiver_port_reg_store(RX0_ID, port,
+			_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX,
+			config->rxcount);
+		
+		port_enabled[port] = true;
+		
+		if (input_mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+
+		/* MW: A bit of a hack, straight wiring of the capture units,assuming they are linearly enumerated. */
+		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MULTICAST_A_IDX +
+			(unsigned int)port, INPUT_SYSTEM_CSI_BACKEND);
+		/* MW: Like the integration test example we overwite, the GPREG_MUX register */	
+		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MUX_IDX,
+			(input_system_multiplex_t)port);
+		} else {
+/*
+ * AM: A bit of a hack, wiring the input system.
+ */
+		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MULTICAST_A_IDX +
+			(unsigned int)port, INPUT_SYSTEM_INPUT_BUFFER);
+		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MUX_IDX,
+			INPUT_SYSTEM_ACQUISITION_UNIT);
+		}
+	}
+/*
+ * The 2ppc is shared for all ports, so we cannot disable->configure->enable individual ports
+ */
+/* AM: Check whether this is a problem with multiple streams. */
+/* MS: 2ppc should be a property per binary and should be enabled/disabled per binary.
+       Currently it is implemented as a system wide setting due to effort and risks. */
+	if (!any_port_enabled) {
+	receiver_reg_store(RX0_ID,
+		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX, config->is_two_ppc);
+	receiver_reg_store(RX0_ID,
+		_HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX, config->is_two_ppc);
+	}
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+/* enable the selected port(s) */
+	for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
+		receiver_port_enable(RX0_ID, port, port_enabled[port]);
+	}
+#else
+     receiver_port_enable(RX0_ID, port, true);
+#endif
+// TODO: JB: need to add the beneath used define to mizuchi
+// sh_css_sw_hive_isp_css_2400A0_system_20121224_0125\css\hrt\input_system_defs.h
+// #define INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG 0X207
+// TODO: need better name for define
+//input_system_reg_store(INPUT_SYSTEM0_ID, INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG, 1);
+input_system_reg_store(INPUT_SYSTEM0_ID, 0x207, 1);
+
+#elif defined(HAS_RX_VERSION_1)
+	mipi_port_ID_t	port = config->port;
+    
+	(void) input_mode;  //AM: just to satisfy the compiler.
+
+/* turn off all ports just in case */
+	sh_css_rx_disable();
+	
+/* All settings are per port */
+	sh_css_rx_set_timeout(port, config->timeout);
+/* configure the selected port */
+	sh_css_rx_set_num_lanes(port, config->num_lanes);
+	sh_css_rx_set_compression(port, config->comp);
+	sh_css_rx_set_uncomp_size(port, config->uncomp_bpp);
+	sh_css_rx_set_comp_size(port, config->comp_bpp);
+
+	receiver_port_reg_store(RX0_ID, port,
+		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX, config->is_two_ppc);
+
+/* enable the selected port */
+	receiver_port_reg_store(RX0_ID, port,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, true);
+#else
+#error "sh_css_rx.c: RX version must be one of {RX_VERSION_1, RX_VERSION_2}"
+#endif
+
+return;
+}
+
+void sh_css_rx_disable(void)
+{
+	mipi_port_ID_t	port;
+	for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
+		receiver_port_reg_store(RX0_ID, port,
+			_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, false);
+	}
+return;
+}
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_rx.h b/drivers/media/atomisp2/css2400/sh_css_rx.h
new file mode 100644
index 0000000..4a75764
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_rx.h
@@ -0,0 +1,57 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_RX_H_
+#define _SH_CSS_RX_H_
+
+#include "input_system.h"
+
+/* CSS Receiver */
+
+void sh_css_rx_configure(
+	const rx_cfg_t	*config,
+	const enum ia_css_input_mode input_mode);
+
+void sh_css_rx_disable(void);
+
+void sh_css_rx_enable_all_interrupts(void);
+
+unsigned int sh_css_rx_get_interrupt_reg(void);
+
+/** @brief Translate format and compression to format type.
+ *
+ * @param[in]	input_format	The input format.
+ * @param[in]	compression	The compression scheme.
+ * @param[out]	fmt_type	Pointer to the resulting format type.
+ * @return			Error code.
+ *
+ * Translate an input format and mipi compression pair to the fmt_type.
+ * This is normally done by the sensor, but when using the input fifo, this
+ * format type must be sumitted correctly by the application.
+ */
+enum ia_css_err sh_css_input_format_type(
+	enum ia_css_stream_format input_format,
+	mipi_predictor_t	compression,
+	unsigned int		*fmt_type);
+
+#endif /* _SH_CSS_RX_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp.c b/drivers/media/atomisp2/css2400/sh_css_sp.c
new file mode 100644
index 0000000..913e2b9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp.c
@@ -0,0 +1,1516 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "sh_css_sp.h"
+
+#include "input_formatter.h"
+
+#include "dma.h"	/* N_DMA_CHANNEL_ID */
+
+#include "ia_css.h"
+#include "sh_css_binary.h"
+#include "sh_css_sp_start.h"
+#include "sh_css_hrt.h"
+#include "sh_css_defs.h"
+#include "sh_css_internal.h"
+#include "sh_css_debug.h"
+#include "sh_css_debug_internal.h"
+#include "sh_css_legacy.h"
+
+#include "gdc_device.h"				/* HRT_GDC_N */
+
+/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+#include "platform_support.h"	/* hrt_sleep() */
+
+#include "queue.h"	/* host_sp_enqueue_XXX */
+#include "sw_event.h"	/* encode_sw_event */
+
+#define UINT16_MAX (65535U)
+
+#ifndef offsetof
+#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
+#endif
+
+struct sh_css_sp_group		sh_css_sp_group;
+struct sh_css_sp_stage		sh_css_sp_stage;
+struct sh_css_isp_stage		sh_css_isp_stage;
+struct sh_css_sp_output		sh_css_sp_output;
+static struct sh_css_sp_per_frame_data per_frame_data;
+
+/* true if SP supports frame loop and host2sp_commands */
+/* For the moment there is only code that sets this bool to true */
+/* TODO: add code that sets this bool to false */
+static bool sp_running;
+
+static enum ia_css_err
+set_output_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num);
+
+/* This data is stored every frame */
+void
+store_sp_group_data(void)
+{
+	per_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();
+}
+
+static void
+copy_isp_stage_to_sp_stage(void)
+{
+	sh_css_sp_stage.num_stripes = sh_css_isp_stage.binary_info.num_stripes;
+// moved to sh_css_sp_init_stage
+//	sh_css_sp_stage.enable.vf_output =
+//		sh_css_isp_stage.binary_info.enable.vf_veceven ||
+//		sh_css_isp_stage.binary_info.num_output_pins > 1;
+	sh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;
+	sh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;
+}
+
+void
+store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num, unsigned stage)
+{
+	unsigned int thread_id;
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	copy_isp_stage_to_sp_stage();
+	if (id != IA_CSS_PIPE_ID_COPY)
+		sh_css_sp_stage.isp_stage_addr =
+			sh_css_store_isp_stage_to_ddr(pipe_num, stage);
+	sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =
+		sh_css_store_sp_stage_to_ddr(pipe_num, stage);
+
+	/* Clear for next frame */
+	sh_css_sp_stage.program_input_circuit = false;
+}
+
+static void
+store_sp_per_frame_data(const struct ia_css_fw_info *fw)
+{
+	unsigned int HIVE_ADDR_sp_per_frame_data = 0;
+	switch (fw->type) {
+	case ia_css_sp_firmware:
+		HIVE_ADDR_sp_per_frame_data = fw->info.sp.per_frame_data;
+		break;
+	case ia_css_acc_firmware:
+		HIVE_ADDR_sp_per_frame_data = fw->info.acc.per_frame_data;
+		break;
+	case ia_css_isp_firmware:
+		return;
+	}
+
+	sp_dmem_store(SP0_ID,
+		(unsigned int)sp_address_of(sp_per_frame_data),
+		&per_frame_data,
+			sizeof(per_frame_data));
+}
+
+static void
+sh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,
+				   unsigned int pipe_num,
+			       const struct ia_css_fw_info *sp_fw)
+{
+	if (!sp_fw)
+		sp_fw = &sh_css_sp_fw;
+
+	store_sp_stage_data(pipe_id, pipe_num, 0);
+	store_sp_group_data();
+	store_sp_per_frame_data(sp_fw);
+}
+
+#if SP_DEBUG !=SP_DEBUG_NONE
+
+void
+sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned i;
+	unsigned o = offsetof(struct sh_css_sp_output, debug)/sizeof(int);
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	for (i = 0; i < sizeof(*state)/sizeof(int); i++)
+		((unsigned *)state)[i] = load_sp_array_uint(sp_output, i+o);
+}
+
+#endif
+
+void
+sh_css_sp_start_binary_copy(unsigned int pipe_num, struct ia_css_frame *out_frame,
+			    unsigned two_ppc)
+{
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+	struct sh_css_sp_pipeline *pipe;
+	unsigned stage_num = 0;
+
+assert(out_frame != NULL);
+	pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	pipe = &sh_css_sp_group.pipe[thread_id];
+
+	pipe->copy.bin.bytes_available = out_frame->data_bytes;
+	pipe->num_stages = 1;
+	pipe->pipe_id = pipe_id;
+	pipe->pipe_num = pipe_num;
+	pipe->thread_id = thread_id;
+	pipe->pipe_config = 0x0; /* No parameters */
+
+	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
+
+	sh_css_sp_stage.num = stage_num;
+	sh_css_sp_stage.irq_buf_flags = 1 << sh_css_frame_out;
+	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
+	sh_css_sp_stage.func =
+		(unsigned int)SH_CSS_SP_BIN_COPY;
+
+	set_output_frame_buffer(out_frame,pipe_num, stage_num);
+
+	/* sp_bin_copy_init on the SP does not deal with dynamica/static yet */
+	/* For now always update the dynamic data from out frames. */
+	sh_css_store_sp_per_frame_data(pipe_id, pipe_num, &sh_css_sp_fw);
+}
+
+static void
+sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
+			 unsigned pipe_num,
+			 unsigned two_ppc,
+			 bool input_needs_raw_binning,
+			 unsigned max_input_width,
+			 enum sh_css_pipe_config_override pipe_conf_override,
+			 unsigned int if_config_index)
+{
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+	unsigned stage_num = 0;
+	struct sh_css_sp_pipeline *pipe;
+
+assert(out_frame != NULL);
+
+	{
+		/**
+		 * Clear sh_css_sp_stage for easy debugging.
+		 * program_input_circuit must be saved as it is set outside
+		 * this function.
+		 */
+		unsigned int program_input_circuit;
+		program_input_circuit = sh_css_sp_stage.program_input_circuit;
+		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
+		sh_css_sp_stage.program_input_circuit = program_input_circuit;
+	}
+
+	pipe_id = IA_CSS_PIPE_ID_COPY;
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	pipe = &sh_css_sp_group.pipe[thread_id];
+
+	pipe->copy.raw.height	    = out_frame->info.res.height;
+	pipe->copy.raw.width	    = out_frame->info.res.width;
+	pipe->copy.raw.padded_width  = out_frame->info.padded_width;
+	pipe->copy.raw.raw_bit_depth = out_frame->info.raw_bit_depth;
+	pipe->copy.raw.max_input_width = max_input_width;
+	pipe->num_stages = 1;
+	pipe->pipe_id = pipe_id;
+	/* TODO: next indicates from which queues parameters need to be
+		 sampled, needs checking/improvement */
+	if (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)
+		pipe->pipe_config =
+			(SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);
+	else
+		pipe->pipe_config = pipe_conf_override;
+
+	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
+	sh_css_sp_group.config.input_needs_raw_binning =
+						input_needs_raw_binning;
+
+	sh_css_sp_stage.num = stage_num;
+	sh_css_sp_stage.irq_buf_flags = 1 << sh_css_frame_out;
+#if 0
+	sh_css_sp_stage.xmem_bin_addr = binary->info->xmem_addr;
+#else
+	sh_css_sp_stage.xmem_bin_addr = 0x0;
+#endif
+	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
+	sh_css_sp_stage.func = (unsigned int)SH_CSS_SP_RAW_COPY;
+	sh_css_sp_stage.if_config_index = (uint8_t) if_config_index;
+	set_output_frame_buffer(out_frame, (unsigned)pipe_id, stage_num);
+
+#if 0
+	/* sp_raw_copy_init on the SP does not deal with dynamica/static yet */
+	/* For now always update the dynamic data from out frames. */
+	sh_css_store_sp_per_frame_data(pipe_id, 0, &sh_css_sp_fw);
+#endif
+	sh_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);
+}
+
+unsigned int
+sh_css_sp_get_binary_copy_size(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned int o = offsetof(struct sh_css_sp_output,
+				bin_copy_bytes_copied) / sizeof(int);
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	return load_sp_array_uint(sp_output, o);
+}
+
+unsigned int
+sh_css_sp_get_sw_interrupt_value(unsigned int irq)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned int o = offsetof(struct sh_css_sp_output, sw_interrupt_value)
+				/ sizeof(int);
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	return load_sp_array_uint(sp_output, o+irq);
+}
+
+static void
+sh_css_frame_info_to_sp(struct sh_css_sp_frame_info *sp,
+			const struct ia_css_frame_info *host)
+{
+  sp->width	      = host->res.width;
+  sp->height	      = host->res.height;
+  sp->padded_width    = host->padded_width;
+  sp->format	      = host->format;
+  sp->raw_bit_depth   = host->raw_bit_depth;
+  sp->raw_bayer_order = host->raw_bayer_order;
+}
+
+static void
+sh_css_copy_frame_to_spframe(struct sh_css_sp_frame *sp_frame_out,
+				const struct ia_css_frame *frame_in,
+				unsigned pipe_num, unsigned stage_num,
+				enum sh_css_frame_id id)
+{
+	/* TODO: remove pipe and stage from interface */
+	(void)pipe_num;
+	(void)stage_num;
+
+	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, 
+		"sh_css_copy_frame_to_spframe frame id %d ptr 0x%08x\n",id,
+		sh_css_sp_stage.frames.static_frame_data[id]);
+
+
+	if (frame_in->dynamic_data_index >= 0) {
+		assert((id == sh_css_frame_in) ||
+				(id == sh_css_frame_out) ||
+				(id == sh_css_frame_out_vf));
+		/*
+		 * value >=0 indicates that function init_frame_pointers()
+		 * should use the dynamic data address
+		 */
+		assert(frame_in->dynamic_data_index <
+					SH_CSS_NUM_DYNAMIC_FRAME_IDS);
+		/*
+		 * static_frame_data is overloaded, small values (<3) are
+		 * the dynamic index, large values are the static address
+		 */
+		sh_css_sp_stage.frames.static_frame_data[id] =
+						frame_in->dynamic_data_index;
+	} else {
+		sh_css_sp_stage.frames.static_frame_data[id] = frame_in->data;
+	}
+
+	if (!sp_frame_out)
+		return;
+
+	sh_css_frame_info_to_sp(&sp_frame_out->info, &frame_in->info);
+
+	switch (frame_in->info.format) {
+	case IA_CSS_FRAME_FORMAT_RAW:
+		sp_frame_out->planes.raw.offset = frame_in->planes.raw.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_RGB565:
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		sp_frame_out->planes.rgb.offset = frame_in->planes.rgb.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+		sp_frame_out->planes.planar_rgb.r.offset =
+			frame_in->planes.planar_rgb.r.offset;
+		sp_frame_out->planes.planar_rgb.g.offset =
+			frame_in->planes.planar_rgb.g.offset;
+		sp_frame_out->planes.planar_rgb.b.offset =
+			frame_in->planes.planar_rgb.b.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		sp_frame_out->planes.yuyv.offset = frame_in->planes.yuyv.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		sp_frame_out->planes.nv.y.offset =
+			frame_in->planes.nv.y.offset;
+		sp_frame_out->planes.nv.uv.offset =
+			frame_in->planes.nv.uv.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+		sp_frame_out->planes.yuv.y.offset =
+			frame_in->planes.yuv.y.offset;
+		sp_frame_out->planes.yuv.u.offset =
+			frame_in->planes.yuv.u.offset;
+		sp_frame_out->planes.yuv.v.offset =
+			frame_in->planes.yuv.v.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		sp_frame_out->planes.plane6.r.offset =
+			frame_in->planes.plane6.r.offset;
+		sp_frame_out->planes.plane6.r_at_b.offset =
+			frame_in->planes.plane6.r_at_b.offset;
+		sp_frame_out->planes.plane6.gr.offset =
+			frame_in->planes.plane6.gr.offset;
+		sp_frame_out->planes.plane6.gb.offset =
+			frame_in->planes.plane6.gb.offset;
+		sp_frame_out->planes.plane6.b.offset =
+			frame_in->planes.plane6.b.offset;
+		sp_frame_out->planes.plane6.b_at_r.offset =
+			frame_in->planes.plane6.b_at_r.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		sp_frame_out->planes.binary.data.offset =
+			frame_in->planes.binary.data.offset;
+		break;
+	default:
+		/* This should not happen, but in case it does,
+		 * nullify the planes
+		 */
+		memset(&sp_frame_out->planes, 0, sizeof(sp_frame_out->planes));
+		break;
+	}
+
+}
+
+static enum ia_css_err
+set_input_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_NV12:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.in, frame,
+					pipe_num, stage_num,
+					sh_css_frame_in);
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_output_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out, frame,
+					pipe_num, stage_num,
+					sh_css_frame_out);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_ref_in_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV420)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.ref_in, frame,
+					pipe_num, stage_num,
+					sh_css_frame_ref_in);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_ref_out_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV420)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(NULL, frame,
+					pipe_num, stage_num,
+					sh_css_frame_ref_out);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_ref_extra_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "set_ref_extra_frame_buffer() %08x\n",
+			frame);		
+
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV420)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(NULL, frame,
+					pipe_num, stage_num,
+					sh_css_frame_ref_extra);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_tnr_in_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV_LINE)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.tnr_in, frame,
+					pipe_num, stage_num,
+					sh_css_frame_tnr_in);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_tnr_out_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV_LINE)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(NULL, frame,
+					pipe_num, stage_num,
+					sh_css_frame_tnr_out);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_capture_pp_frame_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV420)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.extra, frame,
+					pipe_num, stage_num,
+					sh_css_frame_extra);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_view_finder_buffer(const struct ia_css_frame *frame,
+			unsigned pipe_num, unsigned stage_num)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	// the dual output pin
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+  case IA_CSS_FRAME_FORMAT_UYVY:
+
+	// for vf_veceven
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out_vf, frame,
+					pipe_num, stage_num,
+					sh_css_frame_out_vf);
+	return IA_CSS_SUCCESS;
+}
+/* AM: this should fill the if_configs properly. */
+void sh_css_sp_set_if_configs(
+	const input_formatter_cfg_t const		*config_a,
+	const input_formatter_cfg_t	const		*config_b,
+	const uint8_t 		if_config_index
+	)
+{
+	int i;
+	static bool reset = true;
+#if defined(IS_ISP_2300_SYSTEM)
+	bool	block[N_INPUT_FORMATTER_ID] = {false, false};
+#elif defined(IS_ISP_2400_SYSTEM)
+	bool	block[N_INPUT_FORMATTER_ID] = {false, false, false};
+#else
+#error "sh_css_sp_set_if_configs: ISP_SYSTEM must be one of \
+	{IS_ISP_2300_SYSTEM, IS_ISP_2400_SYSTEM}"
+#endif
+
+	if  (if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED) return;
+
+	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);
+
+	block[INPUT_FORMATTER0_ID] = config_a->block_no_reqs;
+	if (config_b != NULL)
+		block[INPUT_FORMATTER1_ID] = config_b->block_no_reqs;
+
+	/* TODO: next could cause issues when streams are started after eachother
+		IF should not be reconfigured/reset from host */
+if (reset) {
+	reset = false;
+	for (i = 0; i < N_INPUT_FORMATTER_ID; i++) {
+		input_formatter_ID_t id = (input_formatter_ID_t)i;
+		input_formatter_rst(id);
+		input_formatter_set_fifo_blocking_mode(id, block[id]);
+	}
+}
+	sh_css_sp_group.config.input_formatter.set[if_config_index].config_a = *config_a;
+	sh_css_sp_group.config.input_formatter.a_changed = true;
+
+	if (config_b != NULL) {
+		sh_css_sp_group.config.input_formatter.set[if_config_index].config_b = *config_b;
+		sh_css_sp_group.config.input_formatter.b_changed = true;
+	}
+
+return;
+}
+
+void
+sh_css_sp_program_input_circuit(int fmt_type,
+				int ch_id,
+				enum ia_css_input_mode input_mode)
+{
+	sh_css_sp_group.config.input_circuit.no_side_band = false;
+	sh_css_sp_group.config.input_circuit.fmt_type     = fmt_type;
+	sh_css_sp_group.config.input_circuit.ch_id	      = ch_id;
+	sh_css_sp_group.config.input_circuit.input_mode   = input_mode;
+/*
+ * The SP group is only loaded at SP boot time and is read once
+ * change flags as "input_circuit_cfg_changed" must be reset on the SP
+ */
+	sh_css_sp_group.config.input_circuit_cfg_changed = true;
+	sh_css_sp_stage.program_input_circuit = true;
+}
+
+void
+sh_css_sp_configure_sync_gen(int width, int height,
+			     int hblank_cycles,
+			     int vblank_cycles)
+{
+	sh_css_sp_group.config.sync_gen.width	       = width;
+	sh_css_sp_group.config.sync_gen.height	       = height;
+	sh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;
+	sh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;
+}
+
+void
+sh_css_sp_configure_tpg(int x_mask,
+			int y_mask,
+			int x_delta,
+			int y_delta,
+			int xy_mask)
+{
+	sh_css_sp_group.config.tpg.x_mask  = x_mask;
+	sh_css_sp_group.config.tpg.y_mask  = y_mask;
+	sh_css_sp_group.config.tpg.x_delta = x_delta;
+	sh_css_sp_group.config.tpg.y_delta = y_delta;
+	sh_css_sp_group.config.tpg.xy_mask = xy_mask;
+}
+
+void
+sh_css_sp_configure_prbs(int seed)
+{
+	sh_css_sp_group.config.prbs.seed = seed;
+}
+
+enum ia_css_err
+sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args,
+				unsigned pipe_num, unsigned stage_num)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	if (args->in_frame)
+		err = set_input_frame_buffer(args->in_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->in_ref_frame)
+		err = set_ref_in_frame_buffer(args->in_ref_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->in_tnr_frame)
+		err = set_tnr_in_frame_buffer(args->in_tnr_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->out_vf_frame)
+		err = set_view_finder_buffer(args->out_vf_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->extra_frame)
+		err = set_capture_pp_frame_buffer(args->extra_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->out_ref_frame)
+		err = set_ref_out_frame_buffer(args->out_ref_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->out_tnr_frame)
+		err = set_tnr_out_frame_buffer(args->out_tnr_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->out_frame)
+		err = set_output_frame_buffer(args->out_frame,
+						pipe_num, stage_num);
+	if (err == IA_CSS_SUCCESS && args->extra_ref_frame)
+		err = set_ref_extra_frame_buffer(args->extra_ref_frame,
+						pipe_num, stage_num);
+	return err;
+}
+
+void
+sh_css_sp_init_group(bool two_ppc,
+			 enum ia_css_stream_format input_format,
+		     bool no_isp_sync,
+			 uint8_t if_config_index
+			 )
+{
+
+	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
+
+	sh_css_sp_group.config.no_isp_sync = no_isp_sync;
+	/* decide whether the frame is processed online or offline */
+	sh_css_sp_group.config.is_offline  = sh_css_continuous_start_sp_copy();
+	if (if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED) return; 
+	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);
+	sh_css_sp_group.config.input_formatter.set[if_config_index].stream_format = input_format;
+
+}
+
+void
+sh_css_stage_write_binary_info(struct ia_css_binary_info *info)
+{
+	sh_css_isp_stage.binary_info = *info;
+}
+
+static bool
+is_sp_stage(struct sh_css_pipeline_stage *stage)
+{
+	return stage->sp_func != SH_CSS_SP_NO_FUNC;
+}
+
+static enum ia_css_err
+sh_css_sp_init_stage(struct sh_css_binary *binary,
+		    const char *binary_name,
+		    const struct ia_css_blob_info *blob_info,
+		    const struct sh_css_binary_args *args,
+		    unsigned int pipe_num,
+		    unsigned stage,
+		    bool preview_mode,
+		    bool low_light,
+		    bool xnr,
+		    unsigned irq_buf_flags,
+		    const struct ia_css_data *isp_mem_if,
+		    unsigned int if_config_index)
+{
+	const struct ia_css_binary_info *info = binary->info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	int i;
+
+	unsigned int thread_id;
+	bool continuous = sh_css_continuous_is_enabled(pipe_num);
+	{
+		/**
+		 * Clear sh_css_sp_stage for easy debugging.
+		 * program_input_circuit must be saved as it is set outside
+		 * this function.
+		 */
+		unsigned int program_input_circuit;
+		program_input_circuit = sh_css_sp_stage.program_input_circuit;
+		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
+		sh_css_sp_stage.program_input_circuit = program_input_circuit;
+	}
+
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+
+	if (info == NULL) {
+		sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;
+		return IA_CSS_SUCCESS;
+	}
+
+	sh_css_sp_stage.deinterleaved = stage == 0 && continuous;
+
+	/*
+	 * TODO: Make the Host dynamically determine
+	 * the stage type.
+	 */
+	sh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;
+	sh_css_sp_stage.num		= stage;
+	sh_css_sp_stage.isp_online	= binary && binary->online;
+	sh_css_sp_stage.isp_copy_vf     = args->copy_vf;
+	sh_css_sp_stage.isp_copy_output = args->copy_output;
+	sh_css_sp_stage.enable.vf_output = (args->out_vf_frame != NULL);
+	/* These flags wil be set from the css top level */
+	sh_css_sp_stage.irq_buf_flags   = irq_buf_flags;
+
+	/* Copy the frame infos first, to be overwritten by the frames,
+	   if these are present.
+	*/
+	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.in.info,
+				&binary->in_frame_info);
+	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.out.info,
+				&binary->out_frame_info);
+	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.internal_frame_info,
+				&binary->internal_frame_info);
+	sh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;
+	sh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;
+	sh_css_sp_stage.isp_pipe_version      = info->isp_pipe_version;
+	sh_css_sp_stage.isp_deci_log_factor   = binary->deci_factor_log2;
+	sh_css_sp_stage.isp_vf_downscale_bits = binary->vf_downscale_log2;
+	
+	sh_css_sp_stage.if_config_index = (uint8_t) if_config_index;
+
+	sh_css_sp_stage.sp_enable_xnr = xnr;
+	sh_css_sp_stage.xmem_bin_addr = info->xmem_addr;
+	sh_css_sp_stage.xmem_map_addr = sh_css_params_ddr_address_map();
+	sh_css_sp_stage.anr	      = low_light;
+	sh_css_isp_stage.blob_info = *blob_info;
+	sh_css_stage_write_binary_info((struct ia_css_binary_info *)info);
+	memcpy(sh_css_isp_stage.binary_name, binary_name,
+		strlen(binary_name)+1);
+	memcpy(&sh_css_isp_stage.mem_initializers, isp_mem_if,
+		sizeof(sh_css_isp_stage.mem_initializers));
+
+	/**
+	 * Even when a stage does not need uds and does not params,
+	 * sp_uds_init() seems to be called (needs further investigation)
+	 * This function can not deal with dx, dy = {0, 0}
+	 */
+	(void)preview_mode;
+
+	/* Clean static frame info before we update it */
+	/*
+	 * TODO: Initialize the static frame data with
+	 * "sh_css_frame_null".
+	 */
+	for (i = 0; i < SH_CSS_NUM_FRAME_IDS; i++)
+		/* Here, we do not initialize it to zero for now */
+		/* to be able to recognize non-updated elements  */
+		sh_css_sp_stage.frames.static_frame_data[i] = -1;
+
+	err = sh_css_sp_write_frame_pointers(args, pipe_num, stage);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (continuous &&  binary->info->enable.raw_binning) {
+		/* TODO: Remove this after preview output decimation is fixed
+		 * by configuring out&vf info fiels properly */
+		sh_css_sp_stage.frames.out.info.padded_width
+			<<= binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out.info.width
+			<<= binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out.info.height
+			<<= binary->vf_downscale_log2;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sp_init_stage(struct sh_css_pipeline_stage *stage,
+	      unsigned int pipe_num,
+	      unsigned stage_num,
+	      bool preview_mode,
+	      bool low_light,
+	      bool xnr,
+	      unsigned int if_config_index)
+{
+	struct sh_css_binary *binary = stage->binary;
+	const struct ia_css_fw_info *firmware = stage->firmware;
+	const struct sh_css_binary_args *args = &stage->args;
+/*
+ * Initialiser required because of the "else" path below.
+ * Is this a valid path ?
+ */
+	const char *binary_name = "";
+	const struct ia_css_binary_info *info = NULL;
+	struct sh_css_binary tmp_binary;
+	const struct ia_css_blob_info *blob_info = NULL;
+	struct ia_css_data isp_mem_if[IA_CSS_NUM_ISP_MEMORIES];
+	const struct ia_css_data *mem_if = isp_mem_if;
+
+	memset(isp_mem_if, 0, sizeof(isp_mem_if));
+
+	if (binary) {
+		info = binary->info;
+		binary_name =
+			(const char *)(info->blob->name);
+		blob_info = &info->blob->header.blob;
+	} else if (firmware) {
+		info = &firmware->info.isp;
+		sh_css_fill_binary_info(info, false, false,
+			    IA_CSS_STREAM_FORMAT_RAW_10,
+			    args->in_frame  ? &args->in_frame->info  : NULL,
+			    args->out_frame ? &args->out_frame->info : NULL,
+			    args->out_vf_frame ? &args->out_vf_frame->info
+						: NULL,
+			    &tmp_binary,
+			    false,
+			    NULL);
+		binary = &tmp_binary;
+		binary->info = info;
+		binary_name = IA_CSS_EXT_ISP_PROG_NAME(firmware);
+		blob_info = &firmware->blob;
+		mem_if = firmware->mem_initializers;
+	} else {
+	  /* SP stage */
+	  assert (stage->sp_func != SH_CSS_SP_NO_FUNC);
+	}
+
+#ifdef __KERNEL__
+	printk(KERN_ERR "load binary: %s\n", binary_name);
+#endif
+
+	sh_css_sp_init_stage(binary,
+			     (const char *)binary_name,
+			     blob_info,
+			     args,
+			     pipe_num,
+			     stage_num,
+			     preview_mode,
+			     low_light,
+			     xnr,
+			     stage->irq_buf_flags,
+			     mem_if,
+				 if_config_index);
+	return IA_CSS_SUCCESS;
+}
+
+static void
+sp_init_sp_stage(struct sh_css_pipeline_stage *stage,
+		 unsigned pipe_num,
+		 bool two_ppc,
+		 bool input_needs_raw_binning,
+		 enum sh_css_pipe_config_override copy_ovrd,
+		 unsigned int if_config_index)
+{
+	const struct sh_css_binary_args *args = &stage->args;
+
+	switch (stage->sp_func) {
+	case SH_CSS_SP_RAW_COPY:
+		sh_css_sp_start_raw_copy(args->out_frame,
+				pipe_num, two_ppc, input_needs_raw_binning,
+				stage->max_input_width,
+				copy_ovrd, if_config_index);
+		break;
+	case SH_CSS_SP_BIN_COPY:
+		assert(false); /* TBI */
+	case SH_CSS_SP_ISYS_COPY:
+		assert(false); /* TBI */
+	case SH_CSS_SP_NO_FUNC:
+		assert(false);
+	}
+}
+
+void
+sh_css_sp_init_pipeline(struct sh_css_pipeline *me,
+			enum ia_css_pipe_id id,
+			uint8_t pipe_num,
+			bool preview_mode,
+			bool low_light,
+			bool xnr,
+			bool two_ppc,
+			bool continuous,
+			bool offline,
+			bool input_needs_raw_binning,
+			enum sh_css_pipe_config_override copy_ovrd,
+			enum ia_css_input_mode input_mode,
+			const mipi_port_ID_t port_id)
+{
+	/* Get first stage */
+	struct sh_css_pipeline_stage *stage;
+	struct sh_css_binary	     *first_binary = me->stages->binary;
+	unsigned num;
+
+	enum ia_css_pipe_id pipe_id = id;
+	unsigned int thread_id;
+	uint8_t if_config_index;
+
+	if (input_mode == IA_CSS_INPUT_MODE_SENSOR
+		|| input_mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		if_config_index  = (uint8_t) (port_id - MIPI_PORT0_ID);
+	} else if (input_mode == IA_CSS_INPUT_MODE_MEMORY){
+		if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+	} else if_config_index = 0x0;
+
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));
+
+	/* Count stages */
+	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
+		stage->stage_num = num;
+		sh_css_debug_pipe_graph_dump_stage(stage, id);
+	}
+	me->num_stages = num;
+
+	if (first_binary != NULL) {
+	/* Init pipeline data */
+		sh_css_sp_init_group(two_ppc, first_binary->input_format, offline, if_config_index);
+	/* for Capture, do we need to add more modes like */
+		if (continuous &&
+			(first_binary->info->mode == SH_CSS_BINARY_MODE_PREVIEW ||
+			 first_binary->info->mode == SH_CSS_BINARY_MODE_PRIMARY)) {
+#if 0
+			sh_css_sp_start_raw_copy(first_binary, first_args->cc_frame,
+				two_ppc, input_needs_raw_binning,
+				copy_ovrd);
+			sh_css_debug_pipe_graph_dump_sp_raw_copy(first_args->cc_frame);
+#endif
+		}
+	} /* if (first_binary != NULL) */
+
+	/* Init stage data */
+	sh_css_init_host2sp_frame_data();
+
+	sh_css_sp_group.pipe[thread_id].num_stages = 0;
+	sh_css_sp_group.pipe[thread_id].pipe_id = pipe_id;
+	sh_css_sp_group.pipe[thread_id].thread_id = thread_id;
+	sh_css_sp_group.pipe[thread_id].pipe_num = pipe_num;
+	sh_css_sp_group.pipe[thread_id].input_system_mode
+						= (uint32_t)input_mode;
+	sh_css_sp_group.pipe[thread_id].port_id = port_id;
+	sh_css_sp_group.pipe[thread_id].dvs_frame_delay = (uint32_t)me->dvs_frame_delay;
+
+	/* TODO: next indicates from which queues parameters need to be
+		 sampled, needs checking/improvement */
+	if (sh_css_pipe_uses_params(me)) {
+		sh_css_sp_group.pipe[thread_id].pipe_config =
+			SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
+	}
+
+	/* For continuous use-cases, SP copy is responsible for sampling the
+	 * parameters */
+	if (continuous)
+		sh_css_sp_group.pipe[thread_id].pipe_config = 0;
+
+	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
+		sh_css_sp_group.pipe[thread_id].num_stages++;
+		if (is_sp_stage(stage)) {
+			sp_init_sp_stage(stage, pipe_num, two_ppc, input_needs_raw_binning,
+				copy_ovrd, if_config_index);
+		} else {
+			sp_init_stage(stage, pipe_num, num, preview_mode,
+					low_light, xnr, if_config_index);
+		}
+
+		store_sp_stage_data(pipe_id, pipe_num, num);
+	}
+	store_sp_group_data();
+
+}
+
+void
+sh_css_sp_uninit_pipeline(unsigned int pipe_num)
+{
+	unsigned int thread_id;
+	sh_css_query_sp_thread_id(pipe_num, &thread_id);
+	/*memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));*/
+	sh_css_sp_group.pipe[thread_id].num_stages = 0;
+}
+#if 0
+static void
+init_host2sp_command(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
+}
+#endif
+
+void
+sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Previous command must be handled by SP (by design) */
+assert(load_sp_array_uint(host_sp_com, o) == host2sp_cmd_ready);
+
+	store_sp_array_uint(host_sp_com, o, host2sp_command);
+}
+
+enum host2sp_commands
+sh_css_read_host2sp_command(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	return (enum host2sp_commands)load_sp_array_uint(host_sp_com, o);
+}
+
+
+/*
+ * Frame data is no longer part of the sp_stage structure but part of a
+ * seperate structure. The aim is to make the sp_data struct static
+ * (it defines a pipeline) and that the dynamic (per frame) data is stored
+ * separetly.
+ *
+ * This function must be called first every where were you start constructing
+ * a new pipeline by defining one or more stages with use of variable
+ * sh_css_sp_stage. Even the special cases like accelerator and copy_frame
+ * These have a pipeline of just 1 stage.
+ */
+void
+sh_css_init_host2sp_frame_data(void)
+{
+	/* Clean table */
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	/*
+	 * rvanimme: don't clean it to save static frame info line ref_in
+	 * ref_out, tnr_in and tnr_out. Once this static data is in a
+	 * seperate data struct, this may be enable (but still, there is
+	 * no need for it)
+	 */
+#if 0
+	unsigned i;
+	for (i = 0; i < SH_CSS_MAX_PIPELINES*SH_CSS_NUM_FRAME_IDS; i++)
+		store_sp_array_uint(host_sp_com, i+o, 0);
+#endif
+}
+
+
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+void
+sh_css_update_host2sp_offline_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+assert(frame_num < NUM_CONTINUOUS_FRAMES);
+
+	/* Write new frame data into SP DMEM */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_offline_frames)
+		/ sizeof(int);
+	o += frame_num;
+
+	store_sp_array_uint(host_sp_com, o,
+				frame ? frame->data : 0);
+}
+
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+void
+sh_css_update_host2sp_mipi_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+assert(frame_num < NUM_MIPI_FRAMES);
+
+	/* Write new frame data into SP DMEM */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_mipi_frames)
+		/ sizeof(int);
+	o += frame_num;
+
+	store_sp_array_uint(host_sp_com, o,
+				frame ? frame->data : 0);
+}
+
+void
+sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Write new frame data into SP DMEM */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_cont_num_raw_frames)
+		/ sizeof(int);
+
+	store_sp_array_uint(host_sp_com, o,
+				num_frames);
+}
+
+void
+sh_css_update_host2sp_cont_num_mipi_frames(unsigned num_frames)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Write new frame data into SP DMEM */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_cont_num_mipi_frames)
+		/ sizeof(int);
+
+	store_sp_array_uint(host_sp_com, o,
+				num_frames);
+}
+
+void
+sh_css_event_init_irq_mask(void)
+{
+	int i;
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask_init;
+
+	event_irq_mask_init.or_mask  = IA_CSS_EVENT_TYPE_ALL;
+	event_irq_mask_init.and_mask = IA_CSS_EVENT_TYPE_NONE;
+	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
+
+	assert(sizeof(event_irq_mask_init) % HRT_BUS_BYTES == 0);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		offset = offsetof(struct host_sp_communication,
+						host2sp_event_irq_mask[i]);
+		assert(offset % HRT_BUS_BYTES == 0);
+		sp_dmem_store(SP0_ID,
+			(unsigned int)sp_address_of(host_sp_com) + offset,
+			&event_irq_mask_init, sizeof(event_irq_mask_init));
+	}
+
+}
+
+enum ia_css_err
+ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
+	unsigned int or_mask,
+	unsigned int and_mask)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_pipe_set_irq_mask("
+				"or_mask=%x, and_mask=%x)\n",
+				or_mask, and_mask);
+
+	assert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);
+	assert(or_mask <= UINT16_MAX);
+	assert(and_mask <= UINT16_MAX);
+
+	event_irq_mask.or_mask  = (uint16_t)or_mask;
+	event_irq_mask.and_mask = (uint16_t)and_mask;
+
+	offset = offsetof(struct host_sp_communication,
+					host2sp_event_irq_mask[ia_css_pipe_get_pipe_num(pipe)]);
+	assert(offset % HRT_BUS_BYTES == 0);
+	sp_dmem_store(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_com) + offset,
+		&event_irq_mask, sizeof(event_irq_mask));
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			  unsigned int *or_mask,
+			  unsigned int *and_mask)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	sh_css_dtrace(SH_DBG_TRACE, "ia_css_event_get_irq_mask()\n");
+
+	assert(pipe);
+	assert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);
+	
+	offset = offsetof(struct host_sp_communication,
+					host2sp_event_irq_mask[ia_css_pipe_get_pipe_num(pipe)]);
+	assert(offset % HRT_BUS_BYTES == 0);
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_com) + offset,
+		&event_irq_mask, sizeof(event_irq_mask));
+
+	if (or_mask)
+		*or_mask = event_irq_mask.or_mask;
+
+	if (and_mask)
+		*and_mask = event_irq_mask.and_mask;
+
+	return IA_CSS_SUCCESS;
+}
+
+void
+sh_css_sp_set_sp_running(bool flag)
+{
+	sp_running = flag;
+}
+
+bool
+sh_css_sp_is_running(void)
+{
+	return sp_running;
+}
+
+void
+sh_css_sp_start_isp(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_sw_state;
+	
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
+	
+
+	if (sp_running)
+		return;
+
+	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
+	
+	/* no longer here, sp started immediately */
+	/*sh_css_debug_pipe_graph_dump_epilogue();*/
+
+	store_sp_group_data();
+	store_sp_per_frame_data(fw);
+	
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_sw_state),
+		(uint32_t)(SP_SW_STATE_NULL));
+
+
+	//init_host2sp_command();
+	/* Note 1: The sp_start_isp function contains a wait till
+	 * the input network is configured by the SP.
+	 * Note 2: Not all SP binaries supports host2sp_commands.
+	 * In case a binary does support it, the host2sp_command
+	 * will have status cmd_ready after return of the function
+	 * sh_css_hrt_sp_start_isp. There is no race-condition here
+	 * because only after the process_frame command has been
+	 * received, the SP starts configuring the input network.
+	 */
+	ia_css_mmu_invalidate_cache();
+	sh_css_hrt_sp_start_isp();
+
+	sp_running = true;
+}
+
+bool
+ia_css_isp_has_started(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_isp_started = fw->info.sp.isp_started;
+	(void)HIVE_ADDR_sp_isp_started; /* Suppres warnings in CRUN */
+
+	return load_sp_uint(sp_isp_started);
+}
+
+bool
+ia_css_sp_has_initialized(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
+	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
+
+	return (load_sp_uint(sp_sw_state) == SP_SW_INITIALIZED);
+}
+
+bool
+ia_css_sp_has_terminated(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
+	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
+	return (load_sp_uint(sp_sw_state) == SP_SW_TERMINATED);
+}
+
+/**
+ * @brief Initialize the DMA software-mask in the debug mode.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+bool
+sh_css_sp_init_dma_sw_reg(int dma_id)
+{
+	int i;
+
+	/* enable all the DMA channels */
+	for (i = 0; i < N_DMA_CHANNEL_ID; i++) {
+		/* enable the writing request */
+		sh_css_sp_set_dma_sw_reg(dma_id,
+				i,
+				0,
+				true);
+		/* enable the reading request */
+		sh_css_sp_set_dma_sw_reg(dma_id,
+				i,
+				1,
+				true);
+	}
+
+	return true;
+}
+
+/**
+ * @brief Set the DMA software-mask in the debug mode.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+bool
+sh_css_sp_set_dma_sw_reg(int dma_id,
+		int channel_id,
+		int request_type,
+		bool enable)
+{
+	uint32_t sw_reg;
+	uint32_t bit_val;
+	uint32_t bit_offset;
+	uint32_t bit_mask;
+
+	(void)dma_id;
+
+assert(channel_id >= 0 && channel_id < N_DMA_CHANNEL_ID);
+assert(request_type >= 0);
+
+	/* get the software-mask */
+	sw_reg =
+		sh_css_sp_group.debug.dma_sw_reg;
+
+	/* get the offest of the target bit */
+	bit_offset = (8 * request_type) + channel_id;
+
+	/* clear the value of the target bit */
+	bit_mask = ~(1 << bit_offset);
+	sw_reg &= bit_mask;
+
+	/* set the value of the bit for the DMA channel */
+	bit_val = enable ? 1 : 0;
+	bit_val <<= bit_offset;
+	sw_reg |= bit_val;
+
+	/* update the software status of DMA channels */
+	sh_css_sp_group.debug.dma_sw_reg = sw_reg;
+
+	return true;
+}
+
+/**
+ * @brief The Host sends the event to the SP.
+ * Refer to "sh_css_sp.h" for details.
+ */
+void
+sh_css_sp_snd_event(int evt_id, int evt_payload_0, int evt_payload_1, int evt_payload_2)
+{
+	uint32_t tmp[4];
+	uint32_t sw_event;
+
+	/*
+	 * Encode the queue type, the thread ID and
+	 * the queue ID into the event.
+	 */
+	tmp[0] = (uint32_t)evt_id;
+	tmp[1] = (uint32_t)evt_payload_0;
+	tmp[2] = (uint32_t)evt_payload_1;
+	tmp[3] = (uint32_t)evt_payload_2;
+	encode_sw_event(tmp, 4, &sw_event);
+
+	/* queue the software event (busy-waiting) */
+	while (!host2sp_enqueue_sp_event(sw_event))
+		hrt_sleep();
+}
+
+void
+sh_css_sp_reset_global_vars(void)
+{
+	memset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));
+	memset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));
+	memset(&sh_css_isp_stage, 0, sizeof(struct sh_css_isp_stage));
+	memset(&sh_css_sp_output, 0, sizeof(struct sh_css_sp_output));
+	memset(&per_frame_data, 0, sizeof(struct sh_css_sp_per_frame_data));
+}
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp.h b/drivers/media/atomisp2/css2400/sh_css_sp.h
new file mode 100644
index 0000000..960fe14
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp.h
@@ -0,0 +1,253 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_SP_H_
+#define _SH_CSS_SP_H_
+
+#include "input_formatter.h"
+
+#include "sh_css_binary.h"
+#include "sh_css_internal.h"
+#include "ia_css_types.h"
+
+/* Function to initialize the data and bss section descr of the binary */
+void
+sh_css_sp_store_init_dmem(const struct ia_css_fw_info *fw);
+
+void
+store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num, unsigned stage);
+
+void
+sh_css_stage_write_binary_info(struct ia_css_binary_info *info);
+
+void
+sh_css_sp_init_group(bool two_ppc, enum ia_css_stream_format input_format,
+		     bool no_isp_sync, uint8_t if_config_index);
+
+void
+store_sp_group_data(void);
+
+/* Start binary (jpeg) copy on the SP */
+void
+sh_css_sp_start_binary_copy(unsigned int pipe_num, struct ia_css_frame *out_frame,
+			    unsigned two_ppc);
+
+unsigned int
+sh_css_sp_get_binary_copy_size(void);
+
+/* Return the value of a SW interrupt */
+unsigned int
+sh_css_sp_get_sw_interrupt_value(unsigned int irq);
+
+void
+sh_css_sp_init_pipeline(struct sh_css_pipeline *me,
+			enum ia_css_pipe_id id,
+			uint8_t pipe_num,
+			bool preview_mode,
+			bool low_light,
+			bool xnr,
+			bool two_ppc,
+			bool continuous,
+			bool offline,
+			bool input_needs_raw_binning,
+			enum sh_css_pipe_config_override copy_ovrd,
+			enum ia_css_input_mode input_mode,
+			const mipi_port_ID_t port_id);
+
+void
+sh_css_sp_uninit_pipeline(unsigned int pipe_num);
+
+void
+sh_css_write_host2sp_command(enum host2sp_commands host2sp_command);
+
+enum host2sp_commands
+sh_css_read_host2sp_command(void);
+
+void
+sh_css_init_host2sp_frame_data(void);
+
+#if 0
+/* Temporarily prototypes till we have the proper header files and final
+ * function names
+ */
+extern bool
+host2sp_enqueue_frame_data(
+			unsigned int pipe_num,
+			enum sh_css_frame_id frame_id,
+			void *frame_data);	/* IN */
+
+extern bool sp2host_dequeue_irq_event(void *irq_event);
+#endif
+
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ *
+ * @param[in] frame_num The offline frame number.
+ * @param[in] frame The pointer to the offline frame.
+ */
+void
+sh_css_update_host2sp_offline_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame);
+
+/**
+ * @brief Update the mipi frame information in host_sp_communication.
+ *
+ * @param[in] frame_num The mipi frame number.
+ * @param[in] frame The pointer to the mipi frame.
+ */
+void
+sh_css_update_host2sp_mipi_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame);
+
+/**
+ * @brief Update the nr of offline frames to use in host_sp_communication.
+ *
+ * @param[in] num_frames The number of raw frames to use.
+ */
+void
+sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames);
+
+/**
+ * @brief Update the nr of mipi frames to use in host_sp_communication.
+ *
+ * @param[in] num_frames The number of mipi frames to use.
+ */
+void
+sh_css_update_host2sp_cont_num_mipi_frames(unsigned num_frames);
+
+void
+sh_css_event_init_irq_mask(void);
+
+void
+sh_css_sp_start_isp(void);
+
+void
+sh_css_sp_set_sp_running(bool flag);
+
+bool
+sh_css_sp_is_running(void);
+
+#if SP_DEBUG !=SP_DEBUG_NONE
+
+void
+sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state);
+
+#endif
+
+extern void sh_css_sp_set_if_configs(
+	const input_formatter_cfg_t const		*config_a,
+	const input_formatter_cfg_t	const		*config_b,
+	const uint8_t		if_config_index);
+
+void
+sh_css_sp_program_input_circuit(int fmt_type,
+				int ch_id,
+				enum ia_css_input_mode input_mode);
+
+void
+sh_css_sp_configure_sync_gen(int width,
+			     int height,
+			     int hblank_cycles,
+			     int vblank_cycles);
+
+void
+sh_css_sp_configure_tpg(int x_mask,
+			int y_mask,
+			int x_delta,
+			int y_delta,
+			int xy_mask);
+
+void
+sh_css_sp_configure_prbs(int seed);
+
+void
+sh_css_sp_reset_global_vars(void);
+
+enum ia_css_err
+sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args,
+				unsigned pipe_num, unsigned stage_num);
+
+/**
+ * @brief Initialize the DMA software-mask in the debug mode.
+ * This API should be ONLY called in the debugging mode.
+ * And it should be always called before the first call of
+ * "sh_css_set_dma_sw_reg(...)".
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_sp_init_dma_sw_reg(int dma_id);
+
+/**
+ * @brief Set the DMA software-mask in the debug mode.
+ * This API should be ONLYL called in the debugging mode. Must
+ * call "sh_css_set_dma_sw_reg(...)" before this
+ * API is called for the first time.
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ * @param[in]	enable		If it is "true", the target DMA
+ *				channel is enabled in the software.
+ *				Otherwise, the target DMA channel
+ *				is disabled in the software.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_sp_set_dma_sw_reg(int dma_id,
+		int channel_id,
+		int request_type,
+		bool enable);
+
+/**
+ * @brief The Host sends the event to the SP.
+ * The caller of this API will be blocked until the event
+ * is sent.
+ *
+ * @param[in]	evt_id		The event ID.
+ * @param[in]	evt_payload_0	The event payload.
+ * @param[in]	evt_payload_1	The event payload.
+ * @param[in]	evt_payload_2	The event payload.
+ */
+extern void sh_css_sp_snd_event(int evt_id,
+		int evt_payload_0,
+		int evt_payload_1,
+		int evt_payload_2);
+
+extern struct sh_css_sp_group sh_css_sp_group;
+extern struct sh_css_sp_stage sh_css_sp_stage;
+extern struct sh_css_isp_stage sh_css_isp_stage;
+
+#endif /* _SH_CSS_SP_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp_start.c b/drivers/media/atomisp2/css2400/sh_css_sp_start.c
new file mode 100644
index 0000000..e8c5dc7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp_start.c
@@ -0,0 +1,127 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#include "sh_css_sp_start.h"
+#include "sh_css_sp.h"
+#include "sh_css_firmware.h"
+
+#define __INLINE_SP__
+#include "sp.h"
+
+#include "mmu_device.h"
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+
+static bool invalidate_mmu;
+static struct ia_css_sp_init_dmem_cfg init_dmem_cfg;
+static uint32_t init_dmem_data;
+
+void
+sh_css_sp_invalidate_mmu(void)
+{
+	invalidate_mmu = true;
+}
+
+void sh_css_sp_start(
+	unsigned int start_address)
+{
+assert(sizeof(unsigned int) <= sizeof(hrt_data));
+
+	if (invalidate_mmu) {
+		mmu_ID_t	mmu_id;
+		for (mmu_id = (mmu_ID_t)0;mmu_id < N_MMU_ID; mmu_id++) {
+			mmu_invalidate_cache(mmu_id);
+		}
+		invalidate_mmu = false;
+	}
+	sp_dmem_store(SP0_ID, init_dmem_data, &init_dmem_cfg, sizeof(init_dmem_cfg));
+	/* set the start address */
+	sp_ctrl_store(SP0_ID, SP_START_ADDR_REG, (hrt_data)start_address);
+	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_RUN_BIT);
+	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
+}
+
+
+hrt_vaddress sh_css_sp_load_program(
+	const struct ia_css_fw_info *fw,
+	const char *sp_prog,
+	hrt_vaddress code_addr)
+{
+	if (code_addr == mmgr_NULL) {
+		/* store code (text + icache) and data to DDR
+		 *
+		 * Data used to be stored separately, because of access alignment constraints,
+		 * fix the FW generation instead
+		 */
+		code_addr = mmgr_malloc(fw->blob.size);
+		if (code_addr == mmgr_NULL)
+			return code_addr;
+		mmgr_store(code_addr, fw->blob.code, fw->blob.size);
+
+		assert((fw->blob.icache_source % HIVE_ISP_DDR_WORD_BYTES) == 0);
+		assert((fw->blob.text_source % HIVE_ISP_DDR_WORD_BYTES) == 0);
+		assert((fw->blob.data_source % HIVE_ISP_DDR_WORD_BYTES) == 0);
+	}
+
+	/* Set the correct start address for the SP program */
+	sh_css_sp_activate_program(fw, code_addr, sp_prog);
+
+return code_addr;
+}
+
+void sh_css_sp_activate_program(
+	const struct ia_css_fw_info *fw,
+	hrt_vaddress code_addr,
+	const char *sp_prog)
+{
+	(void)sp_prog; /* not used on hardware, only for simulation */
+
+assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+	/* now we program the base address into the icache and
+	 * invalidate the cache.
+	 */
+	sp_ctrl_store(SP0_ID, SP_ICACHE_ADDR_REG, (hrt_data)code_addr);
+	sp_ctrl_setbit(SP0_ID, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);
+
+	/* Set descr in the SP to initialize the SP DMEM */
+	/*
+	 * The FW stores user-space pointers to the FW, the ISP pointer
+	 * is only available here
+	 *
+	 */
+
+	/* Configure the data structure to initialize dmem */
+	init_dmem_cfg.done	     = false;
+	init_dmem_cfg.ddr_code_addr  = code_addr;
+	init_dmem_cfg.ddr_data_addr  = code_addr + fw->blob.data_source;
+	init_dmem_cfg.pmem_text_addr = 0; /* fw->blob.text_target; */
+	init_dmem_cfg.dmem_data_addr = fw->blob.data_target;
+	init_dmem_cfg.dmem_bss_addr  = fw->blob.bss_target;
+	init_dmem_cfg.text_size      = fw->blob.text_size;
+	init_dmem_cfg.data_size      = fw->blob.data_size;
+	init_dmem_cfg.bss_size       = fw->blob.bss_size;
+
+	init_dmem_data =  fw->info.sp.init_dmem_data;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp_start.h b/drivers/media/atomisp2/css2400/sh_css_sp_start.h
new file mode 100644
index 0000000..d1c5182
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp_start.h
@@ -0,0 +1,60 @@
+/*
+* Support for Medfield PNW Camera Imaging ISP subsystem.
+*
+* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+*
+* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version
+* 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+* 02110-1301, USA.
+*
+*/
+
+#ifndef _SH_CSS_SP_START_H_
+#define _SH_CSS_SP_START_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define __INLINE_SP__
+#include "sp.h"
+
+#include "mmu_device.h"
+
+#include "sh_css_firmware.h"
+
+#define sh_css_sp_start_function(func) \
+	sh_css_sp_start(HIVE_ADDR_ ## func ## _entry)
+
+#define SH_CSS_PREVENT_UNINIT_READS 0
+
+void
+sh_css_sp_start(unsigned int start_address);
+
+hrt_vaddress
+sh_css_sp_load_program(const struct ia_css_fw_info *fw, const char *sp_prog,
+		       hrt_vaddress code_addr);
+
+void
+sh_css_sp_activate_program(const struct ia_css_fw_info *fw,
+			   hrt_vaddress code_addr,
+			   const char *sp_prog);
+
+void
+sh_css_sp_invalidate_mmu(void);
+
+#endif /* _SH_CSS_SP_START_H_ */
diff --git a/drivers/media/atomisp2/css2400/spmem_dump.c b/drivers/media/atomisp2/css2400/spmem_dump.c
new file mode 100644
index 0000000..275545a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/spmem_dump.c
@@ -0,0 +1,3092 @@
+#ifndef _sp_map_h_
+#define _sp_map_h_
+
+
+#ifndef _hrt_dummy_use_blob_sp
+#define _hrt_dummy_use_blob_sp()
+#endif
+
+#define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vectors_per_input_line
+#define HIVE_MEM_isp_vectors_per_input_line scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_vectors_per_input_line 0x3448
+#define HIVE_SIZE_isp_vectors_per_input_line 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vectors_per_input_line scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_vectors_per_input_line 0x3448
+#define HIVE_SIZE_sp_isp_vectors_per_input_line 4
+
+/* function sp_tagger_propagate_frame: 3F3C */
+
+/* function input_system_acquisition_stop: 2ACB */
+
+/* function longjmp: 49AA */
+
+/* function ia_css_sp_backend_push: 448B */
+
+/* function sp_tagger_tag_exp_id: 3EA0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_MASK
+#define HIVE_MEM_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_MASK 0x300
+#define HIVE_SIZE_HIVE_IF_SRST_MASK 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x300
+#define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
+
+/* function sp_dma_proxy_read: 31BF */
+
+/* function ia_css_sp_backend_release: 4552 */
+
+/* function sp_dma_proxy_is_idle: 331A */
+
+/* function debug_buffer_set_ddr_addr: 68 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_mipi
+#define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_mipi 0xD8
+#define HIVE_SIZE_vbuf_mipi 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_mipi 0xD8
+#define HIVE_SIZE_sp_vbuf_mipi 4
+
+/* function setjmp: 49B3 */
+
+/* function decode_sw_event: 5F2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_map
+#define HIVE_MEM_map scalar_processor_2400_dmem
+#define HIVE_ADDR_map 0x4A9C
+#define HIVE_SIZE_map 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_map scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_map 0x4A9C
+#define HIVE_SIZE_sp_map 64
+
+/* function initialize_sp_stage: 2C65 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stage
+#define HIVE_MEM_isp_stage scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_stage 0x4770
+#define HIVE_SIZE_isp_stage 560
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_stage 0x4770
+#define HIVE_SIZE_sp_isp_stage 560
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_raw
+#define HIVE_MEM_vbuf_raw scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_raw 0xD4
+#define HIVE_SIZE_vbuf_raw 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_raw scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_raw 0xD4
+#define HIVE_SIZE_sp_vbuf_raw 4
+
+/* function release_in_param: 3CB8 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_proxy_status
+#define HIVE_MEM_dma_proxy_status scalar_processor_2400_dmem
+#define HIVE_ADDR_dma_proxy_status 0x1BC
+#define HIVE_SIZE_dma_proxy_status 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_proxy_status scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_proxy_status 0x1BC
+#define HIVE_SIZE_sp_dma_proxy_status 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_do_mmu_invalidation
+#define HIVE_MEM_do_mmu_invalidation scalar_processor_2400_dmem
+#define HIVE_ADDR_do_mmu_invalidation 0x384C
+#define HIVE_SIZE_do_mmu_invalidation 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_do_mmu_invalidation scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_do_mmu_invalidation 0x384C
+#define HIVE_SIZE_sp_do_mmu_invalidation 4
+
+/* function sp_start_isp: 24D1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_binary_group
+#define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_binary_group 0x3180
+#define HIVE_SIZE_sp_binary_group 72
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_binary_group 0x3180
+#define HIVE_SIZE_sp_sp_binary_group 72
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sw_state
+#define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sw_state 0x344C
+#define HIVE_SIZE_sp_sw_state 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_sw_state 0x344C
+#define HIVE_SIZE_sp_sp_sw_state 4
+
+/* function sp_circular_buf_destroy: 3A93 */
+
+/* function sp_circular_buf_destroy: 39AC */
+
+/* function sp_circular_buf_pop: 3977 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_stop_copy_preview
+#define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_stop_copy_preview 0x3824
+#define HIVE_SIZE_sp_stop_copy_preview 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x3824
+#define HIVE_SIZE_sp_sp_stop_copy_preview 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_params_capture_pipe
+#define HIVE_MEM_cb_elems_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_elems_params_capture_pipe 0x45F0
+#define HIVE_SIZE_cb_elems_params_capture_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_elems_params_capture_pipe 0x45F0
+#define HIVE_SIZE_sp_cb_elems_params_capture_pipe 16
+
+/* function sh_css_stride_from_info: 124D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_mipi_frame_sem
+#define HIVE_MEM_mipi_frame_sem scalar_processor_2400_dmem
+#define HIVE_ADDR_mipi_frame_sem 0x30A4
+#define HIVE_SIZE_mipi_frame_sem 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_mipi_frame_sem scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_mipi_frame_sem 0x30A4
+#define HIVE_SIZE_sp_mipi_frame_sem 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_thread_ready_queue
+#define HIVE_MEM_sp_thread_ready_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_thread_ready_queue 0x220
+#define HIVE_SIZE_sp_thread_ready_queue 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_thread_ready_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_thread_ready_queue 0x220
+#define HIVE_SIZE_sp_sp_thread_ready_queue 12
+
+/* function sp_debug_mode_update_command: 43C2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_is_pending_mask
+#define HIVE_MEM_event_is_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_is_pending_mask 0x5C
+#define HIVE_SIZE_event_is_pending_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_is_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_is_pending_mask 0x5C
+#define HIVE_SIZE_sp_event_is_pending_mask 44
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_com
+#define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
+#define HIVE_ADDR_host_sp_com 0x3450
+#define HIVE_SIZE_host_sp_com 124
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host_sp_com 0x3450
+#define HIVE_SIZE_sp_host_sp_com 124
+
+/* function dma_proxy_dma_set_exception0: 32EC */
+
+/* function exec_image_pipe: 2680 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_init_dmem_data
+#define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_init_dmem_data 0x34CC
+#define HIVE_SIZE_sp_init_dmem_data 36
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x34CC
+#define HIVE_SIZE_sp_sp_init_dmem_data 36
+
+/* function stop_threads: 2679 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_flash_in_use
+#define HIVE_MEM_sp_flash_in_use scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_flash_in_use 0x12B8
+#define HIVE_SIZE_sp_flash_in_use 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_flash_in_use scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_flash_in_use 0x12B8
+#define HIVE_SIZE_sp_sp_flash_in_use 4
+
+/* function ia_css_sp_backend_rcv_acquire_ack: 444E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_flashed_frame_cnt
+#define HIVE_MEM_flashed_frame_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_flashed_frame_cnt 0x12C0
+#define HIVE_SIZE_flashed_frame_cnt 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_flashed_frame_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_flashed_frame_cnt 0x12C0
+#define HIVE_SIZE_sp_flashed_frame_cnt 4
+
+/* function is_isp_debug_buffer_full: 2B1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_stack_sizes
+#define HIVE_MEM_stack_sizes scalar_processor_2400_dmem
+#define HIVE_ADDR_stack_sizes 0x250
+#define HIVE_SIZE_stack_sizes 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_stack_sizes scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_stack_sizes 0x250
+#define HIVE_SIZE_sp_stack_sizes 20
+
+/* function ia_css_sp_backend_destroy: 457C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ph
+#define HIVE_MEM_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_ph 0x3030
+#define HIVE_SIZE_ph 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ph 0x3030
+#define HIVE_SIZE_sp_ph 28
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_params_preview_pipe
+#define HIVE_MEM_sem_for_writing_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_writing_cb_params_preview_pipe 0x4600
+#define HIVE_SIZE_sem_for_writing_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_params_preview_pipe 0x4600
+#define HIVE_SIZE_sp_sem_for_writing_cb_params_preview_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_per_frame_data
+#define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_per_frame_data 0x34F0
+#define HIVE_SIZE_sp_per_frame_data 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_per_frame_data 0x34F0
+#define HIVE_SIZE_sp_sp_per_frame_data 4
+
+/* function dma_proxy_channel_acquire: 5049 */
+
+/* function sp_tagger_connect_pipes: 41A5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_copy_pipe_thread
+#define HIVE_MEM_sp_copy_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_copy_pipe_thread 0x3864
+#define HIVE_SIZE_sp_copy_pipe_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_copy_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_copy_pipe_thread 0x3864
+#define HIVE_SIZE_sp_sp_copy_pipe_thread 64
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_xmem_bin_addr
+#define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
+#define HIVE_ADDR_xmem_bin_addr 0x34F4
+#define HIVE_SIZE_xmem_bin_addr 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_xmem_bin_addr 0x34F4
+#define HIVE_SIZE_sp_xmem_bin_addr 4
+
+/* function memcpy: 4A3D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_threads
+#define HIVE_MEM_pipe_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_threads 0x22C
+#define HIVE_SIZE_pipe_threads 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_threads 0x22C
+#define HIVE_SIZE_sp_pipe_threads 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GP_DEVICE_BASE
+#define HIVE_MEM_GP_DEVICE_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GP_DEVICE_BASE 0x32C
+#define HIVE_SIZE_GP_DEVICE_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GP_DEVICE_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x32C
+#define HIVE_SIZE_sp_GP_DEVICE_BASE 4
+
+/* function sp_dma_proxy_set_width_ab: 310F */
+
+/* function __divu: 4D53 */
+
+/* function __divu: 49BB */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_stop
+#define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x4614
+#define HIVE_SIZE_sem_for_cont_capt_stop 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4614
+#define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
+
+/* function sp_dma_proxy_func: 4AE2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_started
+#define HIVE_MEM_sp_isp_started scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_started 0x34F8
+#define HIVE_SIZE_sp_isp_started 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_started scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_started 0x34F8
+#define HIVE_SIZE_sp_sp_isp_started 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_pipe_thread
+#define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_pipe_thread 0x38A4
+#define HIVE_SIZE_sp_isp_pipe_thread 192
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x38A4
+#define HIVE_SIZE_sp_sp_isp_pipe_thread 192
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_obarea_start_bq
+#define HIVE_MEM_sp_obarea_start_bq scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_obarea_start_bq 0x34FC
+#define HIVE_SIZE_sp_obarea_start_bq 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_obarea_start_bq scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_obarea_start_bq 0x34FC
+#define HIVE_SIZE_sp_sp_obarea_start_bq 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_IRQ_BASE
+#define HIVE_MEM_IRQ_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_IRQ_BASE 0x2C
+#define HIVE_SIZE_IRQ_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_IRQ_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_IRQ_BASE 0x2C
+#define HIVE_SIZE_sp_IRQ_BASE 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_TIMED_CTRL_BASE
+#define HIVE_MEM_TIMED_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_TIMED_CTRL_BASE 0x40
+#define HIVE_SIZE_TIMED_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_TIMED_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
+#define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_is_isp_requested
+#define HIVE_MEM_is_isp_requested scalar_processor_2400_dmem
+#define HIVE_ADDR_is_isp_requested 0x1290
+#define HIVE_SIZE_is_isp_requested 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_is_isp_requested scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_is_isp_requested 0x1290
+#define HIVE_SIZE_sp_is_isp_requested 4
+
+/* function ia_css_i_sp_rmgr_init: 357 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_sp_thread
+#define HIVE_MEM_current_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_current_sp_thread 0x21C
+#define HIVE_SIZE_current_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_current_sp_thread 0x21C
+#define HIVE_SIZE_sp_current_sp_thread 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_h_pipe_private_ddr_ptrs
+#define HIVE_MEM_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
+#define HIVE_ADDR_h_pipe_private_ddr_ptrs 0x3A04
+#define HIVE_SIZE_h_pipe_private_ddr_ptrs 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_h_pipe_private_ddr_ptrs 0x3A04
+#define HIVE_SIZE_sp_h_pipe_private_ddr_ptrs 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_capture_thread_id
+#define HIVE_MEM_sp_capture_thread_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_capture_thread_id 0x5BC
+#define HIVE_SIZE_sp_capture_thread_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_capture_thread_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_capture_thread_id 0x5BC
+#define HIVE_SIZE_sp_sp_capture_thread_id 4
+
+/* function ia_css_sp_input_system_token_map_is_full: 4880 */
+
+/* function sp_turn_off_flash: 34C1 */
+
+/* function _sp_dma_proxy_init_isp_vector: 3123 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sh_dma_cmd_buffer
+#define HIVE_MEM_isp_sh_dma_cmd_buffer scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_sh_dma_cmd_buffer 0x3850
+#define HIVE_SIZE_isp_sh_dma_cmd_buffer 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sh_dma_cmd_buffer scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_sh_dma_cmd_buffer 0x3850
+#define HIVE_SIZE_sp_isp_sh_dma_cmd_buffer 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_start
+#define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_cont_capt_start 0x4628
+#define HIVE_SIZE_sem_for_cont_capt_start 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4628
+#define HIVE_SIZE_sp_sem_for_cont_capt_start 20
+
+/* function host2sp_event_queue_is_empty: 4A80 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_pipe_start_semaphore
+#define HIVE_MEM_sp_pipe_start_semaphore scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_start_semaphore 0x3964
+#define HIVE_SIZE_sp_pipe_start_semaphore 80
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_pipe_start_semaphore scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_pipe_start_semaphore 0x3964
+#define HIVE_SIZE_sp_sp_pipe_start_semaphore 80
+
+/* function debug_buffer_init_isp: 6F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_preview_thread_id
+#define HIVE_MEM_sp_preview_thread_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_preview_thread_id 0x5B8
+#define HIVE_SIZE_sp_preview_thread_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_preview_thread_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_preview_thread_id 0x5B8
+#define HIVE_SIZE_sp_sp_preview_thread_id 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_frames_capture_pipe
+#define HIVE_MEM_sem_for_reading_cb_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_frames_capture_pipe 0x463C
+#define HIVE_SIZE_sem_for_reading_cb_frames_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_frames_capture_pipe 0x463C
+#define HIVE_SIZE_sp_sem_for_reading_cb_frames_capture_pipe 20
+
+/* function sp_event_proxy_func: 332F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_fibers
+#define HIVE_MEM_fibers scalar_processor_2400_dmem
+#define HIVE_ADDR_fibers 0x264
+#define HIVE_SIZE_fibers 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_fibers scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_fibers 0x264
+#define HIVE_SIZE_sp_fibers 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_params_preview_pipe
+#define HIVE_MEM_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_params_preview_pipe 0x4650
+#define HIVE_SIZE_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_params_preview_pipe 0x4650
+#define HIVE_SIZE_sp_cb_params_preview_pipe 20
+
+/* function sp_semaphore_init: 52C3 */
+
+/* function initialize_sp_group: 2C43 */
+
+/* function start_binary: 12F3 */
+
+/* function sp_tagger_configure: 3EED */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_invalidate_tlb
+#define HIVE_MEM_sp_invalidate_tlb scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_invalidate_tlb 0x3854
+#define HIVE_SIZE_sp_invalidate_tlb 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_invalidate_tlb scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_invalidate_tlb 0x3854
+#define HIVE_SIZE_sp_sp_invalidate_tlb 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_DMEM_BASE
+#define HIVE_MEM_ISP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_ISP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_sp_ISP_DMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_DMEM_BASE
+#define HIVE_MEM_SP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_SP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_sp_SP_DMEM_BASE 4
+
+/* function ia_css_sp_frontend_stop: 4688 */
+
+/* function bin_spec_init_ifs: 6CB */
+
+/* function dma_proxy_channel_release: 5035 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_sp_frontend_states
+#define HIVE_MEM_ia_css_sp_frontend_states scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_sp_frontend_states 0x4A54
+#define HIVE_SIZE_ia_css_sp_frontend_states 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_sp_frontend_states scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_sp_frontend_states 0x4A54
+#define HIVE_SIZE_sp_ia_css_sp_frontend_states 12
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_frames_preview_pipe
+#define HIVE_MEM_sem_for_writing_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_writing_cb_frames_preview_pipe 0x4664
+#define HIVE_SIZE_sem_for_writing_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_frames_preview_pipe 0x4664
+#define HIVE_SIZE_sp_sem_for_writing_cb_frames_preview_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_can_send_token_mask
+#define HIVE_MEM_event_can_send_token_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_can_send_token_mask 0x88
+#define HIVE_SIZE_event_can_send_token_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_can_send_token_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_can_send_token_mask 0x88
+#define HIVE_SIZE_sp_event_can_send_token_mask 44
+
+/* function sp_dma_proxy_wait_for_ack: 4E4C */
+
+/* function sp_thread_yield: 5182 */
+
+/* function sp_circular_buf_peek: 3746 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_thread
+#define HIVE_MEM_isp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_thread 0x49A0
+#define HIVE_SIZE_isp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_thread 0x49A0
+#define HIVE_SIZE_sp_isp_thread 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_obarea_length_bq
+#define HIVE_MEM_sp_obarea_length_bq scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_obarea_length_bq 0x3500
+#define HIVE_SIZE_sp_obarea_length_bq 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_obarea_length_bq scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_obarea_length_bq 0x3500
+#define HIVE_SIZE_sp_sp_obarea_length_bq 4
+
+/* function is_ddr_debug_buffer_full: 2B5 */
+
+/* function is_ddr_debug_buffer_full: 24B */
+
+/* function sp_uds_init: 8BE */
+
+/* function sp_dma_proxy_isp_write_addr: 3166 */
+
+/* function sp_circular_buf_create: 39B8 */
+
+/* function debug_enqueue_ddr: 79 */
+
+/* function host2sp_dequeue_buffer: 334 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_buf_swap
+#define HIVE_MEM_buf_swap scalar_processor_2400_dmem
+#define HIVE_ADDR_buf_swap 0x534
+#define HIVE_SIZE_buf_swap 96
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_buf_swap scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_buf_swap 0x534
+#define HIVE_SIZE_sp_buf_swap 96
+
+/* function is_dynamic_buffer: 3BD2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_curr_nr_of_copied_frames
+#define HIVE_MEM_curr_nr_of_copied_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_curr_nr_of_copied_frames 0x3828
+#define HIVE_SIZE_curr_nr_of_copied_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_curr_nr_of_copied_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_curr_nr_of_copied_frames 0x3828
+#define HIVE_SIZE_sp_curr_nr_of_copied_frames 4
+
+/* function sp2host_enqueue_buffer: 315 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_block_width_b
+#define HIVE_MEM_sp_dma_crop_block_width_b scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_crop_block_width_b 0x3108
+#define HIVE_SIZE_sp_dma_crop_block_width_b 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_block_width_b scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_block_width_b 0x3108
+#define HIVE_SIZE_sp_sp_dma_crop_block_width_b 4
+
+/* function sp_event_proxy_init: 3354 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_params_preview_pipe
+#define HIVE_MEM_cb_elems_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_elems_params_preview_pipe 0x4678
+#define HIVE_SIZE_cb_elems_params_preview_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_elems_params_preview_pipe 0x4678
+#define HIVE_SIZE_sp_cb_elems_params_preview_pipe 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_output
+#define HIVE_MEM_sp_output scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_output 0x3504
+#define HIVE_SIZE_sp_output 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_output 0x3504
+#define HIVE_SIZE_sp_sp_output 16
+
+/* function init_buffer_queues: 3E8D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_CTRL_BASE
+#define HIVE_MEM_ISP_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_ISP_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_sp_ISP_CTRL_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_INPUT_FORMATTER_BASE
+#define HIVE_MEM_INPUT_FORMATTER_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_INPUT_FORMATTER_BASE 0x4C
+#define HIVE_SIZE_INPUT_FORMATTER_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_INPUT_FORMATTER_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
+#define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
+
+/* function __sp_dma_proxy_configure_channel_text: 3210 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp2host_event_queue
+#define HIVE_MEM_sem_for_sp2host_event_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_sp2host_event_queue 0x45DC
+#define HIVE_SIZE_sem_for_sp2host_event_queue 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp2host_event_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_sp2host_event_queue 0x45DC
+#define HIVE_SIZE_sp_sem_for_sp2host_event_queue 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_tagger
+#define HIVE_MEM_tagger scalar_processor_2400_dmem
+#define HIVE_ADDR_tagger 0x382C
+#define HIVE_SIZE_tagger 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_tagger scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_tagger 0x382C
+#define HIVE_SIZE_sp_tagger 24
+
+/* function host2sp_dequeue_sp_event: 2F2 */
+
+/* function sp_start_isp_entry: 24C7 */
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifdef HIVE_ADDR_sp_start_isp_entry
+#endif
+#define HIVE_ADDR_sp_start_isp_entry 0x26C7
+#endif
+#define HIVE_ADDR_sp_sp_start_isp_entry 0x26C7
+
+/* function __sp_raw_copy_func_critical: 4A8A */
+
+/* function add_sp_command: 5019 */
+
+/* function sp2host_enqueue_irq_event: 2D5 */
+
+/* function create_sp_fibers: 3429 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_s3a_bufs
+#define HIVE_MEM_pipe_private_s3a_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_private_s3a_bufs 0x3A14
+#define HIVE_SIZE_pipe_private_s3a_bufs 48
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_private_s3a_bufs 0x3A14
+#define HIVE_SIZE_sp_pipe_private_s3a_bufs 48
+
+/* function sp_debug_mode_init: 43CC */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_block_width_a
+#define HIVE_MEM_sp_dma_crop_block_width_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_crop_block_width_a 0x310C
+#define HIVE_SIZE_sp_dma_crop_block_width_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_block_width_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_block_width_a 0x310C
+#define HIVE_SIZE_sp_sp_dma_crop_block_width_a 4
+
+/* function sp_bin_copy_func: 61C */
+
+/* function ia_css_i_sp_rmgr_acq_gen: 3B1 */
+
+/* function sp_turn_on_flash: 34D5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sems_for_sp2host_buf_queues
+#define HIVE_MEM_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sems_for_sp2host_buf_queues 0x3A44
+#define HIVE_SIZE_sems_for_sp2host_buf_queues 140
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sems_for_sp2host_buf_queues 0x3A44
+#define HIVE_SIZE_sp_sems_for_sp2host_buf_queues 140
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vectors_per_line
+#define HIVE_MEM_isp_vectors_per_line scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_vectors_per_line 0x3514
+#define HIVE_SIZE_isp_vectors_per_line 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vectors_per_line scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_vectors_per_line 0x3514
+#define HIVE_SIZE_sp_isp_vectors_per_line 4
+
+/* function __sp_dma_proxy_func_text: 3089 */
+
+/* function sp_thread_join: 35E0 */
+
+/* function sp_dma_proxy_configure_channel: 4E79 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_do_irq_raise
+#define HIVE_MEM_do_irq_raise scalar_processor_2400_dmem
+#define HIVE_ADDR_do_irq_raise 0xE14
+#define HIVE_SIZE_do_irq_raise 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_do_irq_raise scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_do_irq_raise 0xE14
+#define HIVE_SIZE_sp_do_irq_raise 4
+
+/* function ia_css_sp_backend_flush: 44DA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_group
+#define HIVE_MEM_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_group 0x3518
+#define HIVE_SIZE_sp_group 740
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_group 0x3518
+#define HIVE_SIZE_sp_sp_group 740
+
+/* function sp2host_buffer_queue_get_size: 309 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_event_proxy_thread
+#define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_proxy_thread 0x39B4
+#define HIVE_SIZE_sp_event_proxy_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x39B4
+#define HIVE_SIZE_sp_sp_event_proxy_thread 64
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_pool
+#define HIVE_MEM_dma_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_dma_pool 0xC8
+#define HIVE_SIZE_dma_pool 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_pool 0xC8
+#define HIVE_SIZE_sp_dma_pool 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_uv_internal_width_vecs
+#define HIVE_MEM_isp_uv_internal_width_vecs scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_uv_internal_width_vecs 0x37FC
+#define HIVE_SIZE_isp_uv_internal_width_vecs 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_uv_internal_width_vecs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_uv_internal_width_vecs 0x37FC
+#define HIVE_SIZE_sp_isp_uv_internal_width_vecs 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_exp_id
+#define HIVE_MEM_pipe_private_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_private_exp_id 0x3AD0
+#define HIVE_SIZE_pipe_private_exp_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_private_exp_id 0x3AD0
+#define HIVE_SIZE_sp_pipe_private_exp_id 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_MMU_BASE
+#define HIVE_MEM_MMU_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_MMU_BASE 0x24
+#define HIVE_SIZE_MMU_BASE 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_MMU_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_MMU_BASE 0x24
+#define HIVE_SIZE_sp_MMU_BASE 8
+
+/* function sp_dma_proxy_configure_init_dmem_channel: 31D8 */
+
+/* function ia_css_sp_backend_create: 458D */
+
+/* function sp2host_event_queue_get_size: 2CC */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_sp_frontend_idle
+#define HIVE_MEM_ia_css_sp_frontend_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_sp_frontend_idle 0x4A60
+#define HIVE_SIZE_ia_css_sp_frontend_idle 60
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_sp_frontend_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_sp_frontend_idle 0x4A60
+#define HIVE_SIZE_sp_ia_css_sp_frontend_idle 60
+
+/* function isp_hmem_load: 479B */
+
+/* function sp_dma_proxy_read_byte_addr: 4E63 */
+
+/* function sp_thread_fork: 35F1 */
+
+/* function sp_semaphore_wait: 523D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_debug_buffer_ddr_address
+#define HIVE_MEM_debug_buffer_ddr_address scalar_processor_2400_dmem
+#define HIVE_ADDR_debug_buffer_ddr_address 0xBC
+#define HIVE_SIZE_debug_buffer_ddr_address 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_debug_buffer_ddr_address scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
+#define HIVE_SIZE_sp_debug_buffer_ddr_address 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_i_mipi_exp_id
+#define HIVE_MEM_ia_css_i_mipi_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_i_mipi_exp_id 0xDC
+#define HIVE_SIZE_ia_css_i_mipi_exp_id 1
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_i_mipi_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_i_mipi_exp_id 0xDC
+#define HIVE_SIZE_sp_ia_css_i_mipi_exp_id 1
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_frames_preview_pipe
+#define HIVE_MEM_sem_for_reading_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_frames_preview_pipe 0x4688
+#define HIVE_SIZE_sem_for_reading_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_frames_preview_pipe 0x4688
+#define HIVE_SIZE_sp_sem_for_reading_cb_frames_preview_pipe 20
+
+/* function encode_sp_event: 445F */
+
+/* function sizeof_hmem: 4836 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_request_flash
+#define HIVE_MEM_sp_request_flash scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_request_flash 0x385C
+#define HIVE_SIZE_sp_request_flash 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_request_flash scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_request_flash 0x385C
+#define HIVE_SIZE_sp_sp_request_flash 4
+
+/* function sp_debug_mode_is_dma_request_enabled: 43A2 */
+
+/* function cnd_input_system_cfg: 2B04 */
+
+/* function sp_generate_events: 4299 */
+
+/* function sp_uds_configure: 747 */
+
+/* function sp_dma_proxy_execute: 31AB */
+
+/* function __modu: 4A01 */
+
+/* function sp_circular_buf_push_marked: 37B7 */
+
+/* function isp_vamem_store: 0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_horiproj_num
+#define HIVE_MEM_isp_sdis_horiproj_num scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_sdis_horiproj_num 0x3800
+#define HIVE_SIZE_isp_sdis_horiproj_num 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_horiproj_num scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_sdis_horiproj_num 0x3800
+#define HIVE_SIZE_sp_isp_sdis_horiproj_num 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GDC_BASE
+#define HIVE_MEM_GDC_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GDC_BASE 0x44
+#define HIVE_SIZE_GDC_BASE 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GDC_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GDC_BASE 0x44
+#define HIVE_SIZE_sp_GDC_BASE 8
+
+/* function sp_event_proxy_callout_func: 3344 */
+
+/* function sp_fiber_init: 34B0 */
+
+/* function ia_css_sp_input_system_token_map_destroy: 4935 */
+
+/* function ia_css_i_sp_rmgr_uninit: 350 */
+
+/* function wait_for_in_frame: 3BED */
+
+/* function ia_css_sp_input_system_token_map_init: 4976 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_isys_token_handler
+#define HIVE_MEM_sem_for_isys_token_handler scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_isys_token_handler 0x469C
+#define HIVE_SIZE_sem_for_isys_token_handler 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_isys_token_handler scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_isys_token_handler 0x469C
+#define HIVE_SIZE_sp_sem_for_isys_token_handler 20
+
+/* function sp_thread_init: 3618 */
+
+/* function ia_css_sp_frontend_destroy: 4729 */
+
+/* function irq_raise_set_token: 41 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GPIO_BASE
+#define HIVE_MEM_GPIO_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GPIO_BASE 0x3C
+#define HIVE_SIZE_GPIO_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GPIO_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GPIO_BASE 0x3C
+#define HIVE_SIZE_sp_GPIO_BASE 4
+
+/* function _dma_proxy_dma_read_write: 4F08 */
+
+/* function sp_dma_proxy_configure_init_vmem_channel: 31F4 */
+
+/* function sp_acquire_dynamic_buf: 3B2F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_ph
+#define HIVE_MEM_isp_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_ph 0x306C
+#define HIVE_SIZE_isp_ph 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_ph 0x306C
+#define HIVE_SIZE_sp_isp_ph 28
+
+/* function sp_tagger_destroy: 41AF */
+
+/* function init_isp_internal_buffers: 1407 */
+
+/* function dma_proxy_dma_set_addr_B: 3235 */
+
+/* function ia_css_sp_input_system_token_map_snd_capture_req: 48EA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_target_nr_of_captured_frames
+#define HIVE_MEM_target_nr_of_captured_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_target_nr_of_captured_frames 0x3844
+#define HIVE_SIZE_target_nr_of_captured_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_target_nr_of_captured_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_target_nr_of_captured_frames 0x3844
+#define HIVE_SIZE_sp_target_nr_of_captured_frames 4
+
+/* function sp_dma_proxy_write: 34A4 */
+
+/* function sp_dma_proxy_write: 3192 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp_group
+#define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_sp_group 0x46B0
+#define HIVE_SIZE_sem_for_sp_group 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_sp_group 0x46B0
+#define HIVE_SIZE_sp_sem_for_sp_group 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_i_raw_exp_id
+#define HIVE_MEM_ia_css_i_raw_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_i_raw_exp_id 0x338
+#define HIVE_SIZE_ia_css_i_raw_exp_id 1
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_i_raw_exp_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_i_raw_exp_id 0x338
+#define HIVE_SIZE_sp_ia_css_i_raw_exp_id 1
+
+/* function ia_css_i_sp_refcount_init_vbuf: 3F2 */
+
+/* function isp_hmem_clear: 476C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_params_preview_pipe
+#define HIVE_MEM_sem_for_reading_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_params_preview_pipe 0x46C4
+#define HIVE_SIZE_sem_for_reading_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_params_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_params_preview_pipe 0x46C4
+#define HIVE_SIZE_sp_sem_for_reading_cb_params_preview_pipe 20
+
+/* function input_system_acquisition_run: 2AE6 */
+
+/* function sp_dma_proxy_vmem_read: 314F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_params_capture_pipe
+#define HIVE_MEM_sem_for_reading_cb_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_params_capture_pipe 0x46D8
+#define HIVE_SIZE_sem_for_reading_cb_params_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_params_capture_pipe 0x46D8
+#define HIVE_SIZE_sp_sem_for_reading_cb_params_capture_pipe 20
+
+/* function release_in_frame: 3C29 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_params_capture_pipe
+#define HIVE_MEM_cb_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_params_capture_pipe 0x46EC
+#define HIVE_SIZE_cb_params_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_params_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_params_capture_pipe 0x46EC
+#define HIVE_SIZE_sp_cb_params_capture_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_vertproj_num
+#define HIVE_MEM_isp_sdis_vertproj_num scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_sdis_vertproj_num 0x3804
+#define HIVE_SIZE_isp_sdis_vertproj_num 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_vertproj_num scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_sdis_vertproj_num 0x3804
+#define HIVE_SIZE_sp_isp_sdis_vertproj_num 4
+
+/* function wait_for_in_param: 3C56 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_frames_capture_pipe
+#define HIVE_MEM_cb_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_frames_capture_pipe 0x4700
+#define HIVE_SIZE_cb_frames_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_frames_capture_pipe 0x4700
+#define HIVE_SIZE_sp_cb_frames_capture_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_queue
+#define HIVE_MEM_host_sp_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_host_sp_queue 0x3AD4
+#define HIVE_SIZE_host_sp_queue 2072
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host_sp_queue 0x3AD4
+#define HIVE_SIZE_sp_host_sp_queue 2072
+
+/* function sp_thread_main: 3630 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_pool
+#define HIVE_MEM_isp_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_pool 0xCC
+#define HIVE_SIZE_isp_pool 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_pool 0xCC
+#define HIVE_SIZE_sp_isp_pool 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_busy_frame
+#define HIVE_MEM_busy_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_busy_frame 0x4ADC
+#define HIVE_SIZE_busy_frame 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_busy_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_busy_frame 0x4ADC
+#define HIVE_SIZE_sp_busy_frame 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_is_done_flag
+#define HIVE_MEM_isp_is_done_flag scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_is_done_flag 0xE10
+#define HIVE_SIZE_isp_is_done_flag 1
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_is_done_flag scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_is_done_flag 0xE10
+#define HIVE_SIZE_sp_isp_is_done_flag 1
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_any_pending_mask
+#define HIVE_MEM_event_any_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_any_pending_mask 0x330
+#define HIVE_SIZE_event_any_pending_mask 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_any_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_any_pending_mask 0x330
+#define HIVE_SIZE_sp_event_any_pending_mask 8
+
+/* function ia_css_sp_frontend_has_empty_mipi_buffer_cb: 45C1 */
+
+/* function ia_css_i_sp_refcount_release_vbuf: 48F */
+
+/* function init_isp_data_segment: 14B4 */
+
+/* function ia_css_sp_frontend_start: 46B6 */
+
+/* function sh_css_decode_tag_descr: 5C5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_configs
+#define HIVE_MEM_dma_configs scalar_processor_2400_dmem
+#define HIVE_ADDR_dma_configs 0x30B8
+#define HIVE_SIZE_dma_configs 80
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_configs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_configs 0x30B8
+#define HIVE_SIZE_sp_dma_configs 80
+
+/* function debug_enqueue_isp: 1FA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_cropping_a
+#define HIVE_MEM_sp_dma_crop_cropping_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_crop_cropping_a 0x3110
+#define HIVE_SIZE_sp_dma_crop_cropping_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_cropping_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_cropping_a 0x3110
+#define HIVE_SIZE_sp_sp_dma_crop_cropping_a 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
+#define HIVE_MEM_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SWITCH_CODE 0x310
+#define HIVE_SIZE_HIVE_IF_SWITCH_CODE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SWITCH_CODE 0x310
+#define HIVE_SIZE_sp_HIVE_IF_SWITCH_CODE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_isp_idle
+#define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_isp_idle 0x4714
+#define HIVE_SIZE_sem_for_isp_idle 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x4714
+#define HIVE_SIZE_sp_sem_for_isp_idle 20
+
+/* function sp_thread_get_state: 3564 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_channels
+#define HIVE_MEM_channels scalar_processor_2400_dmem
+#define HIVE_ADDR_channels 0x304C
+#define HIVE_SIZE_channels 32
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_channels scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_channels 0x304C
+#define HIVE_SIZE_sp_channels 32
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_vf_downscale_bits
+#define HIVE_MEM_sp_vf_downscale_bits scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vf_downscale_bits 0x3808
+#define HIVE_SIZE_sp_vf_downscale_bits 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_vf_downscale_bits scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_vf_downscale_bits 0x3808
+#define HIVE_SIZE_sp_sp_vf_downscale_bits 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_vertcoef_vectors
+#define HIVE_MEM_isp_sdis_vertcoef_vectors scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_sdis_vertcoef_vectors 0x380C
+#define HIVE_SIZE_isp_sdis_vertcoef_vectors 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_vertcoef_vectors scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_sdis_vertcoef_vectors 0x380C
+#define HIVE_SIZE_sp_isp_sdis_vertcoef_vectors 4
+
+/* function dma_configure: 904 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_pipe_stop
+#define HIVE_MEM_sp_pipe_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_stop 0x39F4
+#define HIVE_SIZE_sp_pipe_stop 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_pipe_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_pipe_stop 0x39F4
+#define HIVE_SIZE_sp_sp_pipe_stop 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_VAMEM_BASE
+#define HIVE_MEM_ISP_VAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_ISP_VAMEM_BASE 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_VAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_sp_ISP_VAMEM_BASE 12
+
+/* function handle_parameter_sets: 3F8C */
+
+/* function handle_parameter_sets: 3CEC */
+
+/* function ia_css_sp_frontend_create: 473F */
+
+/* function sp_tagger_create: 41D0 */
+
+/* function sp_dma_proxy_vmem_write: 3139 */
+
+/* function sp_thread_set_priority: 35AF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_dis_bufs
+#define HIVE_MEM_pipe_private_dis_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_private_dis_bufs 0x42EC
+#define HIVE_SIZE_pipe_private_dis_bufs 32
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_private_dis_bufs 0x42EC
+#define HIVE_SIZE_sp_pipe_private_dis_bufs 32
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_callout_sp_thread
+#define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_callout_sp_thread 0x3860
+#define HIVE_SIZE_callout_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_callout_sp_thread 0x3860
+#define HIVE_SIZE_sp_callout_sp_thread 4
+
+/* function sp_semaphore_signal: 51F7 */
+
+/* function ia_css_sp_input_system_token_map_snd_acquire_req: 48D7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_ref_out_buf
+#define HIVE_MEM_sp_ref_out_buf scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ref_out_buf 0x518
+#define HIVE_SIZE_sp_ref_out_buf 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_ref_out_buf scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_ref_out_buf 0x518
+#define HIVE_SIZE_sp_sp_ref_out_buf 4
+
+/* function sp_dma_proxy_write_byte_addr: 317C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_PMEM_BASE
+#define HIVE_MEM_SP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_SP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_sp_SP_PMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_input_stream_format
+#define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3810
+#define HIVE_SIZE_sp_isp_input_stream_format 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3810
+#define HIVE_SIZE_sp_sp_isp_input_stream_format 4
+
+/* function sp_circular_buf_push_unmarked: 36C1 */
+
+/* function __mod: 49ED */
+
+/* function __sp_event_proxy_func_critical: 505D */
+
+/* function sp_circular_buf_mark: 388E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_target_nr_of_copied_frames
+#define HIVE_MEM_target_nr_of_copied_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_target_nr_of_copied_frames 0x3848
+#define HIVE_SIZE_target_nr_of_copied_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_target_nr_of_copied_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_target_nr_of_copied_frames 0x3848
+#define HIVE_SIZE_sp_target_nr_of_copied_frames 4
+
+/* function ia_css_sp_input_system_token_map_reset_capturing_buffer_on_error: 4B99 */
+
+/* function irq_raise: 53 */
+
+/* function sp_circular_buf_unmark: 3866 */
+
+/* function ia_css_i_sp_rmgr_vbuf_dequeue: 44D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
+#define HIVE_MEM_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_ADDRESS 0x2F0
+#define HIVE_SIZE_HIVE_IF_SRST_ADDRESS 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x2F0
+#define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_frames_preview_pipe
+#define HIVE_MEM_cb_elems_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_elems_frames_preview_pipe 0x4728
+#define HIVE_SIZE_cb_elems_frames_preview_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_elems_frames_preview_pipe 0x4728
+#define HIVE_SIZE_sp_cb_elems_frames_preview_pipe 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_frames_preview_pipe
+#define HIVE_MEM_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_frames_preview_pipe 0x4738
+#define HIVE_SIZE_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_frames_preview_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_frames_preview_pipe 0x4738
+#define HIVE_SIZE_sp_cb_frames_preview_pipe 20
+
+/* function set_sp_sleep_for_debug: 43D7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_sp_fiber
+#define HIVE_MEM_current_sp_fiber scalar_processor_2400_dmem
+#define HIVE_ADDR_current_sp_fiber 0x12AC
+#define HIVE_SIZE_current_sp_fiber 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_sp_fiber scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_current_sp_fiber 0x12AC
+#define HIVE_SIZE_sp_current_sp_fiber 4
+
+/* function ia_css_sp_input_system_token_map_create: 49A3 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_vfout_cropping_a
+#define HIVE_MEM_sp_dma_vfout_cropping_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dma_vfout_cropping_a 0x3114
+#define HIVE_SIZE_sp_dma_vfout_cropping_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_vfout_cropping_a scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_dma_vfout_cropping_a 0x3114
+#define HIVE_SIZE_sp_sp_dma_vfout_cropping_a 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_frames_capture_pipe
+#define HIVE_MEM_cb_elems_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_cb_elems_frames_capture_pipe 0x474C
+#define HIVE_SIZE_cb_elems_frames_capture_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_frames_capture_pipe scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cb_elems_frames_capture_pipe 0x474C
+#define HIVE_SIZE_sp_cb_elems_frames_capture_pipe 16
+
+/* function sp_dma_proxy_init: 30A9 */
+
+/* function sp_release_dynamic_buf: 39CF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_HMEM_BASE
+#define HIVE_MEM_ISP_HMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_ISP_HMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_HMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_sp_ISP_HMEM_BASE 4
+
+/* function ia_css_i_sp_rmgr_vbuf_enqueue: 478 */
+
+/* function __sp_event_proxy_callout_func_critical: 5070 */
+
+/* function ia_css_sp_input_system_isr: 483D */
+
+/* function end_binary: 125C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_stacks
+#define HIVE_MEM_stacks scalar_processor_2400_dmem
+#define HIVE_ADDR_stacks 0x23C
+#define HIVE_SIZE_stacks 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_stacks scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_stacks 0x23C
+#define HIVE_SIZE_sp_stacks 20
+
+/* function ia_css_i_sp_refcount_dump: 428 */
+
+/* function ia_css_i_sp_rmgr_rel_gen: 399 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_irq_sw_interrupt_token
+#define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
+#define HIVE_ADDR_irq_sw_interrupt_token 0x302C
+#define HIVE_SIZE_irq_sw_interrupt_token 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x302C
+#define HIVE_SIZE_sp_irq_sw_interrupt_token 4
+
+/* function sp_thread_kill: 35B7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_buffer_bufs
+#define HIVE_MEM_pipe_private_buffer_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_private_buffer_bufs 0x430C
+#define HIVE_SIZE_pipe_private_buffer_bufs 112
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_private_buffer_bufs 0x430C
+#define HIVE_SIZE_sp_pipe_private_buffer_bufs 112
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_addresses
+#define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_addresses 0x49A4
+#define HIVE_SIZE_sp_isp_addresses 176
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_addresses 0x49A4
+#define HIVE_SIZE_sp_sp_isp_addresses 176
+
+/* function sp_fiber_main: 34BA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isps
+#define HIVE_MEM_isps scalar_processor_2400_dmem
+#define HIVE_ADDR_isps 0x3088
+#define HIVE_SIZE_isps 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isps scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isps 0x3088
+#define HIVE_SIZE_sp_isps 28
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_queues_initialized
+#define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
+#define HIVE_ADDR_host_sp_queues_initialized 0x3814
+#define HIVE_SIZE_host_sp_queues_initialized 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3814
+#define HIVE_SIZE_sp_host_sp_queues_initialized 4
+
+/* function _dma_proxy_dma_read_write_inline: 327A */
+
+/* function dma_proxy_dma_set_increments: 3227 */
+
+/* function __sp_dma_proxy_wait_for_ack_text: 30EF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_spref
+#define HIVE_MEM_vbuf_spref scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_spref 0xD0
+#define HIVE_SIZE_vbuf_spref 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_spref scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_spref 0xD0
+#define HIVE_SIZE_sp_vbuf_spref 4
+
+/* function sp_circular_buf_extract: 38B6 */
+
+/* function output_compute_dma_info: 1EFD */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_ref_in_buf
+#define HIVE_MEM_sp_ref_in_buf scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ref_in_buf 0x514
+#define HIVE_SIZE_sp_ref_in_buf 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_ref_in_buf scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_ref_in_buf 0x514
+#define HIVE_SIZE_sp_sp_ref_in_buf 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_horicoef_vectors
+#define HIVE_MEM_isp_sdis_horicoef_vectors scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_sdis_horicoef_vectors 0x3818
+#define HIVE_SIZE_isp_sdis_horicoef_vectors 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_horicoef_vectors scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_sdis_horicoef_vectors 0x3818
+#define HIVE_SIZE_sp_isp_sdis_horicoef_vectors 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_if
+#define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_if 0x475C
+#define HIVE_SIZE_sem_for_reading_if 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_if 0x475C
+#define HIVE_SIZE_sp_sem_for_reading_if 20
+
+/* function sp_circular_buf_pop_marked: 376B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_frames
+#define HIVE_MEM_pipe_private_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_pipe_private_frames 0x437C
+#define HIVE_SIZE_pipe_private_frames 48
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_private_frames 0x437C
+#define HIVE_SIZE_sp_pipe_private_frames 48
+
+/* function ia_css_sp_frontend_rcv_capture_ack: 460D */
+
+/* function sp_generate_interrupts: 41F8 */
+
+/* function init_isp_vars: 21B6 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sems_for_host2sp_buf_queues
+#define HIVE_MEM_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sems_for_host2sp_buf_queues 0x43AC
+#define HIVE_SIZE_sems_for_host2sp_buf_queues 560
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sems_for_host2sp_buf_queues 0x43AC
+#define HIVE_SIZE_sp_sems_for_host2sp_buf_queues 560
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_data
+#define HIVE_MEM_sp_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_data 0x31C8
+#define HIVE_SIZE_sp_data 640
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_data 0x31C8
+#define HIVE_SIZE_sp_sp_data 640
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_BAMEM_BASE
+#define HIVE_MEM_ISP_BAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_BAMEM_BASE 0x328
+#define HIVE_SIZE_ISP_BAMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_BAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x328
+#define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
+
+/* function sp_circular_buf_is_marked: 3841 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_mem_map
+#define HIVE_MEM_mem_map scalar_processor_2400_dmem
+#define HIVE_ADDR_mem_map 0x3118
+#define HIVE_SIZE_mem_map 104
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_mem_map scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_mem_map 0x3118
+#define HIVE_SIZE_sp_mem_map 104
+
+/* function sp_init_dmem: 2BD9 */
+
+/* function ia_css_i_sp_refcount_retain_vbuf: 4B0 */
+
+/* function init_isp_code_segment: 1315 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_PMEM_BASE
+#define HIVE_MEM_ISP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_ISP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_sp_ISP_PMEM_BASE 4
+
+/* function run_sp_threads: 3647 */
+
+/* function ia_css_sp_backend_snd_acquire_request: 4464 */
+
+/* function sp_thread_queue_print: 3664 */
+
+/* function done_isp_data_segment: 1496 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_flash_in_service
+#define HIVE_MEM_sp_flash_in_service scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_flash_in_service 0x12BC
+#define HIVE_SIZE_sp_flash_in_service 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_flash_in_service scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_flash_in_service 0x12BC
+#define HIVE_SIZE_sp_sp_flash_in_service 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vf_output_width_vecs
+#define HIVE_MEM_isp_vf_output_width_vecs scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_vf_output_width_vecs 0x381C
+#define HIVE_SIZE_isp_vf_output_width_vecs 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vf_output_width_vecs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_vf_output_width_vecs 0x381C
+#define HIVE_SIZE_sp_isp_vf_output_width_vecs 4
+
+/* function sp_circular_buf_pop_unmarked: 367D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sleep_mode
+#define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sleep_mode 0x3820
+#define HIVE_SIZE_sp_sleep_mode 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_sleep_mode 0x3820
+#define HIVE_SIZE_sp_sp_sleep_mode 4
+
+/* function mmu_invalidate_cache: 5E */
+
+/* function ia_css_sp_input_system_token_map_receive_ack: 489E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stop_req
+#define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_stop_req 0x3858
+#define HIVE_SIZE_isp_stop_req 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_stop_req 0x3858
+#define HIVE_SIZE_sp_isp_stop_req 4
+
+#define HIVE_ICACHE_sp_critical_SEGMENT_START 0
+#define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
+
+#endif /* _sp_map_h_ */
+extern void sh_css_dump_sp_init_dmem_data (void);
+void sh_css_dump_sp_init_dmem_data (void)
+{
+  static struct ia_css_sp_init_dmem_cfg sp_init_dmem_data;
+  assert(sizeof(sp_init_dmem_data) ==
+         HIVE_SIZE_sp_init_dmem_data);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_init_dmem_data),
+    (char*)&sp_init_dmem_data,
+    sizeof(sp_init_dmem_data));
+  sh_css_print("sp_init_dmem_data.done ="
+    "                                  0x%x\n",
+    sp_init_dmem_data.done);
+  sh_css_print("sp_init_dmem_data.ddr_code_addr ="
+    "                         0x%x\n",
+    sp_init_dmem_data.ddr_code_addr);
+  sh_css_print("sp_init_dmem_data.ddr_data_addr ="
+    "                         0x%x\n",
+    sp_init_dmem_data.ddr_data_addr);
+  sh_css_print("sp_init_dmem_data.pmem_text_addr ="
+    "                        0x%x\n",
+    sp_init_dmem_data.pmem_text_addr);
+  sh_css_print("sp_init_dmem_data.dmem_data_addr ="
+    "                        0x%x\n",
+    sp_init_dmem_data.dmem_data_addr);
+  sh_css_print("sp_init_dmem_data.dmem_bss_addr ="
+    "                         0x%x\n",
+    sp_init_dmem_data.dmem_bss_addr);
+  sh_css_print("sp_init_dmem_data.text_size ="
+    "                             0x%x\n",
+    sp_init_dmem_data.text_size);
+  sh_css_print("sp_init_dmem_data.data_size ="
+    "                             0x%x\n",
+    sp_init_dmem_data.data_size);
+  sh_css_print("sp_init_dmem_data.bss_size ="
+    "                              0x%x\n",
+    sp_init_dmem_data.bss_size);
+}
+
+extern void sh_css_dump_xmem_bin_addr (void);
+void sh_css_dump_xmem_bin_addr (void)
+{
+  hrt_vaddress xmem_bin_addr;
+  assert(sizeof(xmem_bin_addr) ==
+         HIVE_SIZE_xmem_bin_addr);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(xmem_bin_addr),
+    (char*)&xmem_bin_addr,
+    sizeof(xmem_bin_addr));
+  sh_css_print("xmem_bin_addr ="
+    "                                           0x%x\n",
+    xmem_bin_addr);
+}
+
+extern void sh_css_dump_sp_vf_downscale_bits (void);
+void sh_css_dump_sp_vf_downscale_bits (void)
+{
+  unsigned int sp_vf_downscale_bits;
+  assert(sizeof(sp_vf_downscale_bits) ==
+         HIVE_SIZE_sp_vf_downscale_bits);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_vf_downscale_bits),
+    (char*)&sp_vf_downscale_bits,
+    sizeof(sp_vf_downscale_bits));
+  sh_css_print("sp_vf_downscale_bits ="
+    "                                    0x%x\n",
+    sp_vf_downscale_bits);
+}
+
+extern void sh_css_dump_sp_per_frame_data (void);
+void sh_css_dump_sp_per_frame_data (void)
+{
+  static struct sh_css_sp_per_frame_data sp_per_frame_data;
+  assert(sizeof(sp_per_frame_data) ==
+         HIVE_SIZE_sp_per_frame_data);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_per_frame_data),
+    (char*)&sp_per_frame_data,
+    sizeof(sp_per_frame_data));
+  sh_css_print("sp_per_frame_data.sp_group_addr ="
+    "                         0x%x\n",
+    sp_per_frame_data.sp_group_addr);
+}
+
+extern void sh_css_dump_sp_group (void);
+void sh_css_dump_sp_group (void)
+{
+  static struct sh_css_sp_group sp_group;
+  assert(sizeof(sp_group) ==
+         HIVE_SIZE_sp_group);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_group),
+    (char*)&sp_group,
+    sizeof(sp_group));
+  sh_css_print("sp_group.config.is_offline ="
+    "                              0x%x\n",
+    sp_group.config.is_offline);
+  sh_css_print("sp_group.config.input_needs_raw_binning ="
+    "                 0x%x\n",
+    sp_group.config.input_needs_raw_binning);
+  sh_css_print("sp_group.config.no_isp_sync ="
+    "                             0x%x\n",
+    sp_group.config.no_isp_sync);
+  sh_css_print("sp_group.config.input_formatter.a_changed ="
+    "               0x%x\n",
+    sp_group.config.input_formatter.a_changed);
+  sh_css_print("sp_group.config.input_formatter.b_changed ="
+    "               0x%x\n",
+    sp_group.config.input_formatter.b_changed);
+  sh_css_print("sp_group.config.input_formatter.isp_2ppc ="
+    "                0x%x\n",
+    sp_group.config.input_formatter.isp_2ppc);
+  sh_css_print("sp_group.config.input_formatter.set[0].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[0].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[1].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[1].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[2].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[2].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.sync_gen.width ="
+    "                          0x%x\n",
+    sp_group.config.sync_gen.width);
+  sh_css_print("sp_group.config.sync_gen.height ="
+    "                         0x%x\n",
+    sp_group.config.sync_gen.height);
+  sh_css_print("sp_group.config.sync_gen.hblank_cycles ="
+    "                  0x%x\n",
+    sp_group.config.sync_gen.hblank_cycles);
+  sh_css_print("sp_group.config.sync_gen.vblank_cycles ="
+    "                  0x%x\n",
+    sp_group.config.sync_gen.vblank_cycles);
+  sh_css_print("sp_group.config.tpg.x_mask ="
+    "                              0x%x\n",
+    sp_group.config.tpg.x_mask);
+  sh_css_print("sp_group.config.tpg.y_mask ="
+    "                              0x%x\n",
+    sp_group.config.tpg.y_mask);
+  sh_css_print("sp_group.config.tpg.x_delta ="
+    "                             0x%x\n",
+    sp_group.config.tpg.x_delta);
+  sh_css_print("sp_group.config.tpg.y_delta ="
+    "                             0x%x\n",
+    sp_group.config.tpg.y_delta);
+  sh_css_print("sp_group.config.tpg.xy_mask ="
+    "                             0x%x\n",
+    sp_group.config.tpg.xy_mask);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.width ="
+    "                  0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.width);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.height ="
+    "                 0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.height);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.hblank_cycles ="
+    "          0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.hblank_cycles);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.vblank_cycles ="
+    "          0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.vblank_cycles);
+  sh_css_print("sp_group.config.prbs.seed ="
+    "                               0x%x\n",
+    sp_group.config.prbs.seed);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.width ="
+    "                 0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.width);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.height ="
+    "                0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.height);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.hblank_cycles ="
+    "         0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.hblank_cycles);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.vblank_cycles ="
+    "         0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.vblank_cycles);
+  sh_css_print("sp_group.config.input_circuit.no_side_band ="
+    "              0x%x\n",
+    sp_group.config.input_circuit.no_side_band);
+  sh_css_print("sp_group.config.input_circuit.fmt_type ="
+    "                  0x%x\n",
+    sp_group.config.input_circuit.fmt_type);
+  sh_css_print("sp_group.config.input_circuit.ch_id ="
+    "                     0x%x\n",
+    sp_group.config.input_circuit.ch_id);
+  sh_css_print("sp_group.config.input_circuit.input_mode ="
+    "                0x%x\n",
+    sp_group.config.input_circuit.input_mode);
+  sh_css_print("sp_group.config.input_circuit_cfg_changed ="
+    "               0x%x\n",
+    sp_group.config.input_circuit_cfg_changed);
+  sh_css_print("sp_group.pipe[0].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[0].pipe_id);
+  sh_css_print("sp_group.pipe[0].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[0].pipe_num);
+  sh_css_print("sp_group.pipe[0].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[0].thread_id);
+  sh_css_print("sp_group.pipe[0].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[0].pipe_config);
+  sh_css_print("sp_group.pipe[0].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[0].input_system_mode);
+  sh_css_print("sp_group.pipe[0].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[0].port_id);
+  sh_css_print("sp_group.pipe[0].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[0].num_stages);
+  sh_css_print("sp_group.pipe[0].running ="
+    "                                0x%x\n",
+    sp_group.pipe[0].running);
+  sh_css_print("sp_group.pipe[0].dvs_frame_delay ="
+    "                        0x%x\n",
+    sp_group.pipe[0].dvs_frame_delay);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[0].stage ="
+    "                                    %p\n",
+    sp_group.pipe[0].stage);
+  sh_css_print("sp_group.pipe[0].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[0].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[0].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[0].copy.raw.height);
+  sh_css_print("sp_group.pipe[0].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[0].copy.raw.width);
+  sh_css_print("sp_group.pipe[0].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[0].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[0].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[0].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[0].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[0].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[1].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[1].pipe_id);
+  sh_css_print("sp_group.pipe[1].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[1].pipe_num);
+  sh_css_print("sp_group.pipe[1].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[1].thread_id);
+  sh_css_print("sp_group.pipe[1].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[1].pipe_config);
+  sh_css_print("sp_group.pipe[1].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[1].input_system_mode);
+  sh_css_print("sp_group.pipe[1].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[1].port_id);
+  sh_css_print("sp_group.pipe[1].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[1].num_stages);
+  sh_css_print("sp_group.pipe[1].running ="
+    "                                0x%x\n",
+    sp_group.pipe[1].running);
+  sh_css_print("sp_group.pipe[1].dvs_frame_delay ="
+    "                        0x%x\n",
+    sp_group.pipe[1].dvs_frame_delay);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[1].stage ="
+    "                                    %p\n",
+    sp_group.pipe[1].stage);
+  sh_css_print("sp_group.pipe[1].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[1].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[1].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[1].copy.raw.height);
+  sh_css_print("sp_group.pipe[1].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[1].copy.raw.width);
+  sh_css_print("sp_group.pipe[1].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[1].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[1].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[1].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[1].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[1].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[2].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[2].pipe_id);
+  sh_css_print("sp_group.pipe[2].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[2].pipe_num);
+  sh_css_print("sp_group.pipe[2].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[2].thread_id);
+  sh_css_print("sp_group.pipe[2].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[2].pipe_config);
+  sh_css_print("sp_group.pipe[2].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[2].input_system_mode);
+  sh_css_print("sp_group.pipe[2].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[2].port_id);
+  sh_css_print("sp_group.pipe[2].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[2].num_stages);
+  sh_css_print("sp_group.pipe[2].running ="
+    "                                0x%x\n",
+    sp_group.pipe[2].running);
+  sh_css_print("sp_group.pipe[2].dvs_frame_delay ="
+    "                        0x%x\n",
+    sp_group.pipe[2].dvs_frame_delay);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[2].stage ="
+    "                                    %p\n",
+    sp_group.pipe[2].stage);
+  sh_css_print("sp_group.pipe[2].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[2].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[2].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[2].copy.raw.height);
+  sh_css_print("sp_group.pipe[2].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[2].copy.raw.width);
+  sh_css_print("sp_group.pipe[2].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[2].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[2].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[2].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[2].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[2].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[3].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[3].pipe_id);
+  sh_css_print("sp_group.pipe[3].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[3].pipe_num);
+  sh_css_print("sp_group.pipe[3].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[3].thread_id);
+  sh_css_print("sp_group.pipe[3].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[3].pipe_config);
+  sh_css_print("sp_group.pipe[3].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[3].input_system_mode);
+  sh_css_print("sp_group.pipe[3].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[3].port_id);
+  sh_css_print("sp_group.pipe[3].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[3].num_stages);
+  sh_css_print("sp_group.pipe[3].running ="
+    "                                0x%x\n",
+    sp_group.pipe[3].running);
+  sh_css_print("sp_group.pipe[3].dvs_frame_delay ="
+    "                        0x%x\n",
+    sp_group.pipe[3].dvs_frame_delay);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[3].stage ="
+    "                                    %p\n",
+    sp_group.pipe[3].stage);
+  sh_css_print("sp_group.pipe[3].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[3].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[3].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[3].copy.raw.height);
+  sh_css_print("sp_group.pipe[3].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[3].copy.raw.width);
+  sh_css_print("sp_group.pipe[3].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[3].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[3].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[3].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[3].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[3].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.debug.dma_sw_reg ="
+    "                               0x%x\n",
+    sp_group.debug.dma_sw_reg);
+}
+
+extern void sh_css_dump_sp_output (void);
+void sh_css_dump_sp_output (void)
+{
+  static struct sh_css_sp_output sp_output;
+  assert(sizeof(sp_output) ==
+         HIVE_SIZE_sp_output);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_output),
+    (char*)&sp_output,
+    sizeof(sp_output));
+  sh_css_print("sp_output.bin_copy_bytes_copied ="
+    "                         0x%x\n",
+    sp_output.bin_copy_bytes_copied);
+  sh_css_print("sp_output.sw_interrupt_value[0] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[0]);
+  sh_css_print("sp_output.sw_interrupt_value[1] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[1]);
+  sh_css_print("sp_output.sw_interrupt_value[2] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[2]);
+}
+
+extern void sh_css_dump_host_sp_com (void);
+void sh_css_dump_host_sp_com (void)
+{
+  static volatile struct host_sp_communication host_sp_com;
+  assert(sizeof(host_sp_com) ==
+         HIVE_SIZE_host_sp_com);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(host_sp_com),
+    (char*)&host_sp_com,
+    sizeof(host_sp_com));
+  sh_css_print("host_sp_com.host2sp_command ="
+    "                             0x%x\n",
+    host_sp_com.host2sp_command);
+  sh_css_print("host_sp_com.host2sp_offline_frames[0] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[0]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[1] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[1]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[2] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[2]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[3] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[3]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[4] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[4]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[5] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[5]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[6] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[6]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[7] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[7]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[8] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[8]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[9] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[9]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[10] ="
+    "                  0x%x\n",
+    host_sp_com.host2sp_offline_frames[10]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[11] ="
+    "                  0x%x\n",
+    host_sp_com.host2sp_offline_frames[11]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[12] ="
+    "                  0x%x\n",
+    host_sp_com.host2sp_offline_frames[12]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[13] ="
+    "                  0x%x\n",
+    host_sp_com.host2sp_offline_frames[13]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[14] ="
+    "                  0x%x\n",
+    host_sp_com.host2sp_offline_frames[14]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[0] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[0]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[1] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[1]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[2] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[2]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[3] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[3]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[4] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[4]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[5] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[5]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[6] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[6]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[7] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[7]);
+  sh_css_print("host_sp_com.host2sp_cont_num_raw_frames ="
+    "                 0x%x\n",
+    host_sp_com.host2sp_cont_num_raw_frames);
+  sh_css_print("host_sp_com.host2sp_cont_num_mipi_frames ="
+    "                0x%x\n",
+    host_sp_com.host2sp_cont_num_mipi_frames);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[0].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[0].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[0].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[0].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[1].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[1].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[1].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[1].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[2].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[2].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[2].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[2].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[3].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[3].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[3].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[3].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[4].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[4].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[4].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[4].and_mask);
+}
+
+extern void sh_css_dump_sp_isp_started (void);
+void sh_css_dump_sp_isp_started (void)
+{
+  volatile int sp_isp_started;
+  assert(sizeof(sp_isp_started) ==
+         HIVE_SIZE_sp_isp_started);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_isp_started),
+    (char*)&sp_isp_started,
+    sizeof(sp_isp_started));
+  sh_css_print("sp_isp_started ="
+    "                                          0x%x\n",
+    sp_isp_started);
+}
+
+extern void sh_css_dump_sp_sw_state (void);
+void sh_css_dump_sp_sw_state (void)
+{
+  volatile int sp_sw_state;
+  assert(sizeof(sp_sw_state) ==
+         HIVE_SIZE_sp_sw_state);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_sw_state),
+    (char*)&sp_sw_state,
+    sizeof(sp_sw_state));
+  sh_css_print("sp_sw_state ="
+    "                                             0x%x\n",
+    sp_sw_state);
+}
+
+extern void sh_css_dump_host_sp_queues_initialized (void);
+void sh_css_dump_host_sp_queues_initialized (void)
+{
+  volatile int host_sp_queues_initialized;
+  assert(sizeof(host_sp_queues_initialized) ==
+         HIVE_SIZE_host_sp_queues_initialized);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(host_sp_queues_initialized),
+    (char*)&host_sp_queues_initialized,
+    sizeof(host_sp_queues_initialized));
+  sh_css_print("host_sp_queues_initialized ="
+    "                              0x%x\n",
+    host_sp_queues_initialized);
+}
+
+extern void sh_css_dump_sp_sleep_mode (void);
+void sh_css_dump_sp_sleep_mode (void)
+{
+  volatile int sp_sleep_mode;
+  assert(sizeof(sp_sleep_mode) ==
+         HIVE_SIZE_sp_sleep_mode);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_sleep_mode),
+    (char*)&sp_sleep_mode,
+    sizeof(sp_sleep_mode));
+  sh_css_print("sp_sleep_mode ="
+    "                                           0x%x\n",
+    sp_sleep_mode);
+}
+
+extern void sh_css_dump_isp_uv_internal_width_vecs (void);
+void sh_css_dump_isp_uv_internal_width_vecs (void)
+{
+  unsigned int isp_uv_internal_width_vecs;
+  assert(sizeof(isp_uv_internal_width_vecs) ==
+         HIVE_SIZE_isp_uv_internal_width_vecs);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_uv_internal_width_vecs),
+    (char*)&isp_uv_internal_width_vecs,
+    sizeof(isp_uv_internal_width_vecs));
+  sh_css_print("isp_uv_internal_width_vecs ="
+    "                              0x%x\n",
+    isp_uv_internal_width_vecs);
+}
+
+extern void sh_css_dump_isp_vf_output_width_vecs (void);
+void sh_css_dump_isp_vf_output_width_vecs (void)
+{
+  unsigned int isp_vf_output_width_vecs;
+  assert(sizeof(isp_vf_output_width_vecs) ==
+         HIVE_SIZE_isp_vf_output_width_vecs);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vf_output_width_vecs),
+    (char*)&isp_vf_output_width_vecs,
+    sizeof(isp_vf_output_width_vecs));
+  sh_css_print("isp_vf_output_width_vecs ="
+    "                                0x%x\n",
+    isp_vf_output_width_vecs);
+}
+
+extern void sh_css_dump_isp_vectors_per_line (void);
+void sh_css_dump_isp_vectors_per_line (void)
+{
+  unsigned int isp_vectors_per_line;
+  assert(sizeof(isp_vectors_per_line) ==
+         HIVE_SIZE_isp_vectors_per_line);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vectors_per_line),
+    (char*)&isp_vectors_per_line,
+    sizeof(isp_vectors_per_line));
+  sh_css_print("isp_vectors_per_line ="
+    "                                    0x%x\n",
+    isp_vectors_per_line);
+}
+
+extern void sh_css_dump_isp_vectors_per_input_line (void);
+void sh_css_dump_isp_vectors_per_input_line (void)
+{
+  unsigned int isp_vectors_per_input_line;
+  assert(sizeof(isp_vectors_per_input_line) ==
+         HIVE_SIZE_isp_vectors_per_input_line);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vectors_per_input_line),
+    (char*)&isp_vectors_per_input_line,
+    sizeof(isp_vectors_per_input_line));
+  sh_css_print("isp_vectors_per_input_line ="
+    "                              0x%x\n",
+    isp_vectors_per_input_line);
+}
+
+extern void sh_css_dump_isp_sdis_horiproj_num (void);
+void sh_css_dump_isp_sdis_horiproj_num (void)
+{
+  unsigned int isp_sdis_horiproj_num;
+  assert(sizeof(isp_sdis_horiproj_num) ==
+         HIVE_SIZE_isp_sdis_horiproj_num);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_horiproj_num),
+    (char*)&isp_sdis_horiproj_num,
+    sizeof(isp_sdis_horiproj_num));
+  sh_css_print("isp_sdis_horiproj_num ="
+    "                                   0x%x\n",
+    isp_sdis_horiproj_num);
+}
+
+extern void sh_css_dump_isp_sdis_vertproj_num (void);
+void sh_css_dump_isp_sdis_vertproj_num (void)
+{
+  unsigned int isp_sdis_vertproj_num;
+  assert(sizeof(isp_sdis_vertproj_num) ==
+         HIVE_SIZE_isp_sdis_vertproj_num);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_vertproj_num),
+    (char*)&isp_sdis_vertproj_num,
+    sizeof(isp_sdis_vertproj_num));
+  sh_css_print("isp_sdis_vertproj_num ="
+    "                                   0x%x\n",
+    isp_sdis_vertproj_num);
+}
+
+extern void sh_css_dump_isp_sdis_horicoef_vectors (void);
+void sh_css_dump_isp_sdis_horicoef_vectors (void)
+{
+  unsigned int isp_sdis_horicoef_vectors;
+  assert(sizeof(isp_sdis_horicoef_vectors) ==
+         HIVE_SIZE_isp_sdis_horicoef_vectors);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_horicoef_vectors),
+    (char*)&isp_sdis_horicoef_vectors,
+    sizeof(isp_sdis_horicoef_vectors));
+  sh_css_print("isp_sdis_horicoef_vectors ="
+    "                               0x%x\n",
+    isp_sdis_horicoef_vectors);
+}
+
+extern void sh_css_dump_isp_sdis_vertcoef_vectors (void);
+void sh_css_dump_isp_sdis_vertcoef_vectors (void)
+{
+  unsigned int isp_sdis_vertcoef_vectors;
+  assert(sizeof(isp_sdis_vertcoef_vectors) ==
+         HIVE_SIZE_isp_sdis_vertcoef_vectors);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_vertcoef_vectors),
+    (char*)&isp_sdis_vertcoef_vectors,
+    sizeof(isp_sdis_vertcoef_vectors));
+  sh_css_print("isp_sdis_vertcoef_vectors ="
+    "                               0x%x\n",
+    isp_sdis_vertcoef_vectors);
+}
+
+extern void sh_css_dump_sp_isp_input_stream_format (void);
+void sh_css_dump_sp_isp_input_stream_format (void)
+{
+  enum sh_stream_format{ sh_stream_format_yuv420_legacy, sh_stream_format_yuv420, sh_stream_format_yuv422, sh_stream_format_rgb, sh_stream_format_raw, sh_stream_format_binary} sp_isp_input_stream_format;
+  assert(sizeof(sp_isp_input_stream_format) ==
+         HIVE_SIZE_sp_isp_input_stream_format);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_isp_input_stream_format),
+    (char*)&sp_isp_input_stream_format,
+    sizeof(sp_isp_input_stream_format));
+  sh_css_print("sp_isp_input_stream_format ="
+    "                              0x%x\n",
+    sp_isp_input_stream_format);
+}
+
+extern void sh_css_dump_sp_obarea_start_bq (void);
+void sh_css_dump_sp_obarea_start_bq (void)
+{
+  unsigned int sp_obarea_start_bq;
+  assert(sizeof(sp_obarea_start_bq) ==
+         HIVE_SIZE_sp_obarea_start_bq);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_obarea_start_bq),
+    (char*)&sp_obarea_start_bq,
+    sizeof(sp_obarea_start_bq));
+  sh_css_print("sp_obarea_start_bq ="
+    "                                      0x%x\n",
+    sp_obarea_start_bq);
+}
+
+extern void sh_css_dump_sp_obarea_length_bq (void);
+void sh_css_dump_sp_obarea_length_bq (void)
+{
+  unsigned int sp_obarea_length_bq;
+  assert(sizeof(sp_obarea_length_bq) ==
+         HIVE_SIZE_sp_obarea_length_bq);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_obarea_length_bq),
+    (char*)&sp_obarea_length_bq,
+    sizeof(sp_obarea_length_bq));
+  sh_css_print("sp_obarea_length_bq ="
+    "                                     0x%x\n",
+    sp_obarea_length_bq);
+}
+
+extern void sh_css_dump_sp_preview_thread_id (void);
+void sh_css_dump_sp_preview_thread_id (void)
+{
+  unsigned int sp_preview_thread_id;
+  assert(sizeof(sp_preview_thread_id) ==
+         HIVE_SIZE_sp_preview_thread_id);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_preview_thread_id),
+    (char*)&sp_preview_thread_id,
+    sizeof(sp_preview_thread_id));
+  sh_css_print("sp_preview_thread_id ="
+    "                                    0x%x\n",
+    sp_preview_thread_id);
+}
+
+extern void sh_css_dump_sp_capture_thread_id (void);
+void sh_css_dump_sp_capture_thread_id (void)
+{
+  unsigned int sp_capture_thread_id;
+  assert(sizeof(sp_capture_thread_id) ==
+         HIVE_SIZE_sp_capture_thread_id);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_capture_thread_id),
+    (char*)&sp_capture_thread_id,
+    sizeof(sp_capture_thread_id));
+  sh_css_print("sp_capture_thread_id ="
+    "                                    0x%x\n",
+    sp_capture_thread_id);
+}
+
+extern void sh_css_dump_sp_dmem(void);
+void sh_css_dump_sp_dmem(void)
+{
+  sh_css_dump_sp_init_dmem_data();
+  sh_css_dump_xmem_bin_addr();
+  sh_css_dump_sp_vf_downscale_bits();
+  sh_css_dump_sp_per_frame_data();
+  sh_css_dump_sp_group();
+  sh_css_dump_sp_output();
+  sh_css_dump_host_sp_com();
+  sh_css_dump_sp_isp_started();
+  sh_css_dump_sp_sw_state();
+  sh_css_dump_host_sp_queues_initialized();
+  sh_css_dump_sp_sleep_mode();
+  sh_css_dump_isp_uv_internal_width_vecs();
+  sh_css_dump_isp_vf_output_width_vecs();
+  sh_css_dump_isp_vectors_per_line();
+  sh_css_dump_isp_vectors_per_input_line();
+  sh_css_dump_isp_sdis_horiproj_num();
+  sh_css_dump_isp_sdis_vertproj_num();
+  sh_css_dump_isp_sdis_horicoef_vectors();
+  sh_css_dump_isp_sdis_vertcoef_vectors();
+  sh_css_dump_sp_isp_input_stream_format();
+  sh_css_dump_sp_obarea_start_bq();
+  sh_css_dump_sp_obarea_length_bq();
+  sh_css_dump_sp_preview_thread_id();
+  sh_css_dump_sp_capture_thread_id();
+}
diff --git a/drivers/media/atomisp2/css2400/spmem_dumpA0.c b/drivers/media/atomisp2/css2400/spmem_dumpA0.c
new file mode 100644
index 0000000..ca8b02d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/spmem_dumpA0.c
@@ -0,0 +1,3015 @@
+#ifndef _sp_map_h_
+#define _sp_map_h_
+
+
+#ifndef _hrt_dummy_use_blob_sp
+#define _hrt_dummy_use_blob_sp()
+#endif
+
+#define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vectors_per_input_line
+#define HIVE_MEM_isp_vectors_per_input_line scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_vectors_per_input_line 0x2A2C
+#define HIVE_SIZE_isp_vectors_per_input_line 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vectors_per_input_line scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_vectors_per_input_line 0x2A2C
+#define HIVE_SIZE_sp_isp_vectors_per_input_line 4
+
+/* function sp_tagger_propagate_frame: 3E79 */
+
+/* function input_system_acquisition_stop: 29E9 */
+
+/* function longjmp: 48E7 */
+
+/* function ia_css_sp_backend_push: 43C8 */
+
+/* function sp_tagger_tag_exp_id: 3DDD */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_MASK
+#define HIVE_MEM_HIVE_IF_SRST_MASK scalar_processor_2400A0_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_MASK 0x310
+#define HIVE_SIZE_HIVE_IF_SRST_MASK 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_MASK scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x310
+#define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
+
+/* function sp_dma_proxy_read: 30FC */
+
+/* function ia_css_sp_backend_release: 448F */
+
+/* function sp_dma_proxy_is_idle: 3257 */
+
+/* function debug_buffer_set_ddr_addr: 68 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_mipi
+#define HIVE_MEM_vbuf_mipi scalar_processor_2400A0_dmem
+#define HIVE_ADDR_vbuf_mipi 0xD4
+#define HIVE_SIZE_vbuf_mipi 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_vbuf_mipi 0xD4
+#define HIVE_SIZE_sp_vbuf_mipi 4
+
+/* function setjmp: 48F0 */
+
+/* function decode_sw_event: 5F2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_map
+#define HIVE_MEM_map scalar_processor_2400A0_dmem
+#define HIVE_ADDR_map 0x3C20
+#define HIVE_SIZE_map 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_map scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_map 0x3C20
+#define HIVE_SIZE_sp_map 64
+
+/* function initialize_sp_stage: 2BA2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stage
+#define HIVE_MEM_isp_stage scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_stage 0x3904
+#define HIVE_SIZE_isp_stage 544
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stage scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_stage 0x3904
+#define HIVE_SIZE_sp_isp_stage 544
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_raw
+#define HIVE_MEM_vbuf_raw scalar_processor_2400A0_dmem
+#define HIVE_ADDR_vbuf_raw 0xD0
+#define HIVE_SIZE_vbuf_raw 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_raw scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_vbuf_raw 0xD0
+#define HIVE_SIZE_sp_vbuf_raw 4
+
+/* function release_in_param: 3BF5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_proxy_status
+#define HIVE_MEM_dma_proxy_status scalar_processor_2400A0_dmem
+#define HIVE_ADDR_dma_proxy_status 0x1B4
+#define HIVE_SIZE_dma_proxy_status 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_proxy_status scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_proxy_status 0x1B4
+#define HIVE_SIZE_sp_dma_proxy_status 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_do_mmu_invalidation
+#define HIVE_MEM_do_mmu_invalidation scalar_processor_2400A0_dmem
+#define HIVE_ADDR_do_mmu_invalidation 0x2DE8
+#define HIVE_SIZE_do_mmu_invalidation 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_do_mmu_invalidation scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_do_mmu_invalidation 0x2DE8
+#define HIVE_SIZE_sp_do_mmu_invalidation 4
+
+/* function sp_start_isp: 23EF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_binary_group
+#define HIVE_MEM_sp_binary_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_binary_group 0x2764
+#define HIVE_SIZE_sp_binary_group 72
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_binary_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_binary_group 0x2764
+#define HIVE_SIZE_sp_sp_binary_group 72
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sw_state
+#define HIVE_MEM_sp_sw_state scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sw_state 0x2A30
+#define HIVE_SIZE_sp_sw_state 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sw_state scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_sw_state 0x2A30
+#define HIVE_SIZE_sp_sp_sw_state 4
+
+/* function sp_circular_buf_destroy: 38E9 */
+
+/* function sp_circular_buf_pop: 38B4 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_stop_copy_preview
+#define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_stop_copy_preview 0x2DC4
+#define HIVE_SIZE_sp_stop_copy_preview 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x2DC4
+#define HIVE_SIZE_sp_sp_stop_copy_preview 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_params_capture_pipe
+#define HIVE_MEM_cb_elems_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_elems_params_capture_pipe 0x3784
+#define HIVE_SIZE_cb_elems_params_capture_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_elems_params_capture_pipe 0x3784
+#define HIVE_SIZE_sp_cb_elems_params_capture_pipe 16
+
+/* function sh_css_stride_from_info: 1163 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_mipi_frame_sem
+#define HIVE_MEM_mipi_frame_sem scalar_processor_2400A0_dmem
+#define HIVE_ADDR_mipi_frame_sem 0x2688
+#define HIVE_SIZE_mipi_frame_sem 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_mipi_frame_sem scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_mipi_frame_sem 0x2688
+#define HIVE_SIZE_sp_mipi_frame_sem 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_thread_ready_queue
+#define HIVE_MEM_sp_thread_ready_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_thread_ready_queue 0x23C
+#define HIVE_SIZE_sp_thread_ready_queue 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_thread_ready_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_thread_ready_queue 0x23C
+#define HIVE_SIZE_sp_sp_thread_ready_queue 12
+
+/* function sp_debug_mode_update_command: 42FF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_is_pending_mask
+#define HIVE_MEM_event_is_pending_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_event_is_pending_mask 0x58
+#define HIVE_SIZE_event_is_pending_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_is_pending_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_event_is_pending_mask 0x58
+#define HIVE_SIZE_sp_event_is_pending_mask 44
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_com
+#define HIVE_MEM_host_sp_com scalar_processor_2400A0_dmem
+#define HIVE_ADDR_host_sp_com 0x2A34
+#define HIVE_SIZE_host_sp_com 84
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_com scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_host_sp_com 0x2A34
+#define HIVE_SIZE_sp_host_sp_com 84
+
+/* function exec_image_pipe: 259E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_init_dmem_data
+#define HIVE_MEM_sp_init_dmem_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_init_dmem_data 0x2A88
+#define HIVE_SIZE_sp_init_dmem_data 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x2A88
+#define HIVE_SIZE_sp_sp_init_dmem_data 24
+
+/* function stop_threads: 2597 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_flash_in_use
+#define HIVE_MEM_sp_flash_in_use scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_flash_in_use 0x1224
+#define HIVE_SIZE_sp_flash_in_use 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_flash_in_use scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_flash_in_use 0x1224
+#define HIVE_SIZE_sp_sp_flash_in_use 4
+
+/* function ia_css_sp_backend_rcv_acquire_ack: 438B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_flashed_frame_cnt
+#define HIVE_MEM_flashed_frame_cnt scalar_processor_2400A0_dmem
+#define HIVE_ADDR_flashed_frame_cnt 0x122C
+#define HIVE_SIZE_flashed_frame_cnt 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_flashed_frame_cnt scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_flashed_frame_cnt 0x122C
+#define HIVE_SIZE_sp_flashed_frame_cnt 4
+
+/* function is_isp_debug_buffer_full: 2B1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_stack_sizes
+#define HIVE_MEM_stack_sizes scalar_processor_2400A0_dmem
+#define HIVE_ADDR_stack_sizes 0x26C
+#define HIVE_SIZE_stack_sizes 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_stack_sizes scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_stack_sizes 0x26C
+#define HIVE_SIZE_sp_stack_sizes 20
+
+/* function ia_css_sp_backend_destroy: 44B9 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ph
+#define HIVE_MEM_ph scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ph 0x2614
+#define HIVE_SIZE_ph 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ph scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ph 0x2614
+#define HIVE_SIZE_sp_ph 28
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_params_preview_pipe
+#define HIVE_MEM_sem_for_writing_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_writing_cb_params_preview_pipe 0x3794
+#define HIVE_SIZE_sem_for_writing_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_params_preview_pipe 0x3794
+#define HIVE_SIZE_sp_sem_for_writing_cb_params_preview_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_per_frame_data
+#define HIVE_MEM_sp_per_frame_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_per_frame_data 0x2AA0
+#define HIVE_SIZE_sp_per_frame_data 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_per_frame_data 0x2AA0
+#define HIVE_SIZE_sp_sp_per_frame_data 4
+
+/* function dma_proxy_channel_acquire: 4F86 */
+
+/* function sp_tagger_connect_pipes: 40E2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_copy_pipe_thread
+#define HIVE_MEM_sp_copy_pipe_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_copy_pipe_thread 0x2E00
+#define HIVE_SIZE_sp_copy_pipe_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_copy_pipe_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_copy_pipe_thread 0x2E00
+#define HIVE_SIZE_sp_sp_copy_pipe_thread 64
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_xmem_bin_addr
+#define HIVE_MEM_xmem_bin_addr scalar_processor_2400A0_dmem
+#define HIVE_ADDR_xmem_bin_addr 0x2AA4
+#define HIVE_SIZE_xmem_bin_addr 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_xmem_bin_addr 0x2AA4
+#define HIVE_SIZE_sp_xmem_bin_addr 4
+
+/* function memcpy: 497A */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_threads
+#define HIVE_MEM_pipe_threads scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_threads 0x248
+#define HIVE_SIZE_pipe_threads 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_threads scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_threads 0x248
+#define HIVE_SIZE_sp_pipe_threads 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GP_DEVICE_BASE
+#define HIVE_MEM_GP_DEVICE_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_GP_DEVICE_BASE 0x338
+#define HIVE_SIZE_GP_DEVICE_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GP_DEVICE_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x338
+#define HIVE_SIZE_sp_GP_DEVICE_BASE 4
+
+/* function sp_dma_proxy_set_width_ab: 304C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_i_exp_id
+#define HIVE_MEM_ia_css_i_exp_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ia_css_i_exp_id 0x344
+#define HIVE_SIZE_ia_css_i_exp_id 1
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_i_exp_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ia_css_i_exp_id 0x344
+#define HIVE_SIZE_sp_ia_css_i_exp_id 1
+
+/* function __divu: 48F8 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_stop
+#define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x37A8
+#define HIVE_SIZE_sem_for_cont_capt_stop 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x37A8
+#define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
+
+/* function sp_dma_proxy_func: 4A1F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_started
+#define HIVE_MEM_sp_isp_started scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_started 0x2AA8
+#define HIVE_SIZE_sp_isp_started 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_started scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_isp_started 0x2AA8
+#define HIVE_SIZE_sp_sp_isp_started 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_pipe_thread
+#define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_pipe_thread 0x2E40
+#define HIVE_SIZE_sp_isp_pipe_thread 192
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x2E40
+#define HIVE_SIZE_sp_sp_isp_pipe_thread 192
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_obarea_start_bq
+#define HIVE_MEM_sp_obarea_start_bq scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_obarea_start_bq 0x2AAC
+#define HIVE_SIZE_sp_obarea_start_bq 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_obarea_start_bq scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_obarea_start_bq 0x2AAC
+#define HIVE_SIZE_sp_sp_obarea_start_bq 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_IRQ_BASE
+#define HIVE_MEM_IRQ_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_IRQ_BASE 0x28
+#define HIVE_SIZE_IRQ_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_IRQ_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_IRQ_BASE 0x28
+#define HIVE_SIZE_sp_IRQ_BASE 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_TIMED_CTRL_BASE
+#define HIVE_MEM_TIMED_CTRL_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_TIMED_CTRL_BASE 0x3C
+#define HIVE_SIZE_TIMED_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_TIMED_CTRL_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x3C
+#define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_is_isp_requested
+#define HIVE_MEM_is_isp_requested scalar_processor_2400A0_dmem
+#define HIVE_ADDR_is_isp_requested 0x11FC
+#define HIVE_SIZE_is_isp_requested 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_is_isp_requested scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_is_isp_requested 0x11FC
+#define HIVE_SIZE_sp_is_isp_requested 4
+
+/* function ia_css_i_sp_rmgr_init: 357 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_sp_thread
+#define HIVE_MEM_current_sp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_current_sp_thread 0x238
+#define HIVE_SIZE_current_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_sp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_current_sp_thread 0x238
+#define HIVE_SIZE_sp_current_sp_thread 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_h_pipe_private_ddr_ptrs
+#define HIVE_MEM_h_pipe_private_ddr_ptrs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_h_pipe_private_ddr_ptrs 0x2FA0
+#define HIVE_SIZE_h_pipe_private_ddr_ptrs 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_h_pipe_private_ddr_ptrs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_h_pipe_private_ddr_ptrs 0x2FA0
+#define HIVE_SIZE_sp_h_pipe_private_ddr_ptrs 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_capture_thread_id
+#define HIVE_MEM_sp_capture_thread_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_capture_thread_id 0x508
+#define HIVE_SIZE_sp_capture_thread_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_capture_thread_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_capture_thread_id 0x508
+#define HIVE_SIZE_sp_sp_capture_thread_id 4
+
+/* function ia_css_sp_input_system_token_map_is_full: 47BD */
+
+/* function sp_turn_off_flash: 33FE */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_internal_event
+#define HIVE_MEM_sp_internal_event scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_internal_event 0x376C
+#define HIVE_SIZE_sp_internal_event 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_internal_event scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_internal_event 0x376C
+#define HIVE_SIZE_sp_sp_internal_event 4
+
+/* function _sp_dma_proxy_init_isp_vector: 3060 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sh_dma_cmd_buffer
+#define HIVE_MEM_isp_sh_dma_cmd_buffer scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_sh_dma_cmd_buffer 0x2DEC
+#define HIVE_SIZE_isp_sh_dma_cmd_buffer 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sh_dma_cmd_buffer scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_sh_dma_cmd_buffer 0x2DEC
+#define HIVE_SIZE_sp_isp_sh_dma_cmd_buffer 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_start
+#define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_cont_capt_start 0x37BC
+#define HIVE_SIZE_sem_for_cont_capt_start 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x37BC
+#define HIVE_SIZE_sp_sem_for_cont_capt_start 20
+
+/* function host2sp_event_queue_is_empty: 49BD */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_pipe_start_semaphore
+#define HIVE_MEM_sp_pipe_start_semaphore scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_start_semaphore 0x2F00
+#define HIVE_SIZE_sp_pipe_start_semaphore 80
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_pipe_start_semaphore scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_pipe_start_semaphore 0x2F00
+#define HIVE_SIZE_sp_sp_pipe_start_semaphore 80
+
+/* function debug_buffer_init_isp: 6F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_preview_thread_id
+#define HIVE_MEM_sp_preview_thread_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_preview_thread_id 0x504
+#define HIVE_SIZE_sp_preview_thread_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_preview_thread_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_preview_thread_id 0x504
+#define HIVE_SIZE_sp_sp_preview_thread_id 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_frames_capture_pipe
+#define HIVE_MEM_sem_for_reading_cb_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_reading_cb_frames_capture_pipe 0x37D0
+#define HIVE_SIZE_sem_for_reading_cb_frames_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_frames_capture_pipe 0x37D0
+#define HIVE_SIZE_sp_sem_for_reading_cb_frames_capture_pipe 20
+
+/* function sp_event_proxy_func: 326C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_fibers
+#define HIVE_MEM_fibers scalar_processor_2400A0_dmem
+#define HIVE_ADDR_fibers 0x280
+#define HIVE_SIZE_fibers 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_fibers scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_fibers 0x280
+#define HIVE_SIZE_sp_fibers 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_params_preview_pipe
+#define HIVE_MEM_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_params_preview_pipe 0x37E4
+#define HIVE_SIZE_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_params_preview_pipe 0x37E4
+#define HIVE_SIZE_sp_cb_params_preview_pipe 20
+
+/* function sp_semaphore_init: 5200 */
+
+/* function initialize_sp_group: 2B80 */
+
+/* function start_binary: 1209 */
+
+/* function sp_tagger_configure: 3E2A */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_invalidate_tlb
+#define HIVE_MEM_sp_invalidate_tlb scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_invalidate_tlb 0x2DF0
+#define HIVE_SIZE_sp_invalidate_tlb 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_invalidate_tlb scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_invalidate_tlb 0x2DF0
+#define HIVE_SIZE_sp_sp_invalidate_tlb 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_DMEM_BASE
+#define HIVE_MEM_ISP_DMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_ISP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_DMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_sp_ISP_DMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_DMEM_BASE
+#define HIVE_MEM_SP_DMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_SP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_DMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_sp_SP_DMEM_BASE 4
+
+/* function ia_css_sp_frontend_stop: 45C5 */
+
+/* function bin_spec_init_ifs: 6CD */
+
+/* function dma_proxy_channel_release: 4F72 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_sp_frontend_states
+#define HIVE_MEM_ia_css_sp_frontend_states scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ia_css_sp_frontend_states 0x3BD8
+#define HIVE_SIZE_ia_css_sp_frontend_states 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_sp_frontend_states scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ia_css_sp_frontend_states 0x3BD8
+#define HIVE_SIZE_sp_ia_css_sp_frontend_states 12
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_frames_preview_pipe
+#define HIVE_MEM_sem_for_writing_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_writing_cb_frames_preview_pipe 0x37F8
+#define HIVE_SIZE_sem_for_writing_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_frames_preview_pipe 0x37F8
+#define HIVE_SIZE_sp_sem_for_writing_cb_frames_preview_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_can_send_token_mask
+#define HIVE_MEM_event_can_send_token_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_event_can_send_token_mask 0x84
+#define HIVE_SIZE_event_can_send_token_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_can_send_token_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_event_can_send_token_mask 0x84
+#define HIVE_SIZE_sp_event_can_send_token_mask 44
+
+/* function sp_dma_proxy_wait_for_ack: 4D89 */
+
+/* function sp_thread_yield: 50BF */
+
+/* function sp_circular_buf_peek: 3683 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_thread
+#define HIVE_MEM_isp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_thread 0x3B24
+#define HIVE_SIZE_isp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_thread 0x3B24
+#define HIVE_SIZE_sp_isp_thread 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_obarea_length_bq
+#define HIVE_MEM_sp_obarea_length_bq scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_obarea_length_bq 0x2AB0
+#define HIVE_SIZE_sp_obarea_length_bq 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_obarea_length_bq scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_obarea_length_bq 0x2AB0
+#define HIVE_SIZE_sp_sp_obarea_length_bq 4
+
+/* function is_ddr_debug_buffer_full: 24B */
+
+/* function sp_uds_init: 8C0 */
+
+/* function sp_dma_proxy_isp_write_addr: 30A3 */
+
+/* function sp_circular_buf_create: 38F5 */
+
+/* function debug_enqueue_ddr: 79 */
+
+/* function host2sp_dequeue_buffer: 334 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_buf_swap
+#define HIVE_MEM_buf_swap scalar_processor_2400A0_dmem
+#define HIVE_ADDR_buf_swap 0x498
+#define HIVE_SIZE_buf_swap 96
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_buf_swap scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_buf_swap 0x498
+#define HIVE_SIZE_sp_buf_swap 96
+
+/* function is_dynamic_buffer: 3B0F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_curr_nr_of_copied_frames
+#define HIVE_MEM_curr_nr_of_copied_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_curr_nr_of_copied_frames 0x2DC8
+#define HIVE_SIZE_curr_nr_of_copied_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_curr_nr_of_copied_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_curr_nr_of_copied_frames 0x2DC8
+#define HIVE_SIZE_sp_curr_nr_of_copied_frames 4
+
+/* function sp2host_enqueue_buffer: 315 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_block_width_b
+#define HIVE_MEM_sp_dma_crop_block_width_b scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_crop_block_width_b 0x26EC
+#define HIVE_SIZE_sp_dma_crop_block_width_b 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_block_width_b scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_block_width_b 0x26EC
+#define HIVE_SIZE_sp_sp_dma_crop_block_width_b 4
+
+/* function sp_event_proxy_init: 3291 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_params_preview_pipe
+#define HIVE_MEM_cb_elems_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_elems_params_preview_pipe 0x380C
+#define HIVE_SIZE_cb_elems_params_preview_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_elems_params_preview_pipe 0x380C
+#define HIVE_SIZE_sp_cb_elems_params_preview_pipe 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_output
+#define HIVE_MEM_sp_output scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_output 0x2AB4
+#define HIVE_SIZE_sp_output 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_output scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_output 0x2AB4
+#define HIVE_SIZE_sp_sp_output 16
+
+/* function init_buffer_queues: 3DCA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_CTRL_BASE
+#define HIVE_MEM_ISP_CTRL_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_ISP_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_CTRL_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_sp_ISP_CTRL_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_INPUT_FORMATTER_BASE
+#define HIVE_MEM_INPUT_FORMATTER_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_INPUT_FORMATTER_BASE 0x48
+#define HIVE_SIZE_INPUT_FORMATTER_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_INPUT_FORMATTER_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x48
+#define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
+
+/* function sp_raw_copy_func: 2BE5 */
+
+/* function __sp_dma_proxy_configure_channel_text: 314D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp2host_event_queue
+#define HIVE_MEM_sem_for_sp2host_event_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_sp2host_event_queue 0x3770
+#define HIVE_SIZE_sem_for_sp2host_event_queue 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp2host_event_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_sp2host_event_queue 0x3770
+#define HIVE_SIZE_sp_sem_for_sp2host_event_queue 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_tagger
+#define HIVE_MEM_tagger scalar_processor_2400A0_dmem
+#define HIVE_ADDR_tagger 0x2DCC
+#define HIVE_SIZE_tagger 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_tagger scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_tagger 0x2DCC
+#define HIVE_SIZE_sp_tagger 20
+
+/* function host2sp_dequeue_sp_event: 2F2 */
+
+/* function sp_start_isp_entry: 23E5 */
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifdef HIVE_ADDR_sp_start_isp_entry
+#endif
+#define HIVE_ADDR_sp_start_isp_entry 0x24D1
+#endif
+#define HIVE_ADDR_sp_sp_start_isp_entry 0x24D1
+
+/* function __sp_raw_copy_func_critical: 49C7 */
+
+/* function add_sp_command: 4F56 */
+
+/* function sp2host_enqueue_irq_event: 2D5 */
+
+/* function create_sp_fibers: 3366 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_s3a_bufs
+#define HIVE_MEM_pipe_private_s3a_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_private_s3a_bufs 0x2FB0
+#define HIVE_SIZE_pipe_private_s3a_bufs 48
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_s3a_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_private_s3a_bufs 0x2FB0
+#define HIVE_SIZE_sp_pipe_private_s3a_bufs 48
+
+/* function sp_debug_mode_init: 4309 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_block_width_a
+#define HIVE_MEM_sp_dma_crop_block_width_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_crop_block_width_a 0x26F0
+#define HIVE_SIZE_sp_dma_crop_block_width_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_block_width_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_block_width_a 0x26F0
+#define HIVE_SIZE_sp_sp_dma_crop_block_width_a 4
+
+/* function sp_bin_copy_func: 61C */
+
+/* function ia_css_i_sp_rmgr_acq_gen: 3B1 */
+
+/* function sp_turn_on_flash: 3412 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sems_for_sp2host_buf_queues
+#define HIVE_MEM_sems_for_sp2host_buf_queues scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sems_for_sp2host_buf_queues 0x2FE0
+#define HIVE_SIZE_sems_for_sp2host_buf_queues 140
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sems_for_sp2host_buf_queues scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sems_for_sp2host_buf_queues 0x2FE0
+#define HIVE_SIZE_sp_sems_for_sp2host_buf_queues 140
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vectors_per_line
+#define HIVE_MEM_isp_vectors_per_line scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_vectors_per_line 0x2AC4
+#define HIVE_SIZE_isp_vectors_per_line 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vectors_per_line scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_vectors_per_line 0x2AC4
+#define HIVE_SIZE_sp_isp_vectors_per_line 4
+
+/* function __sp_dma_proxy_func_text: 2FC6 */
+
+/* function sp_thread_join: 351D */
+
+/* function sp_dma_proxy_configure_channel: 4DB6 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_do_irq_raise
+#define HIVE_MEM_do_irq_raise scalar_processor_2400A0_dmem
+#define HIVE_ADDR_do_irq_raise 0xD30
+#define HIVE_SIZE_do_irq_raise 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_do_irq_raise scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_do_irq_raise 0xD30
+#define HIVE_SIZE_sp_do_irq_raise 4
+
+/* function ia_css_sp_backend_flush: 4417 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_group
+#define HIVE_MEM_sp_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_group 0x2AC8
+#define HIVE_SIZE_sp_group 724
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_group 0x2AC8
+#define HIVE_SIZE_sp_sp_group 724
+
+/* function sp2host_buffer_queue_get_size: 309 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_event_proxy_thread
+#define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_event_proxy_thread 0x2F50
+#define HIVE_SIZE_sp_event_proxy_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x2F50
+#define HIVE_SIZE_sp_sp_event_proxy_thread 64
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_pool
+#define HIVE_MEM_dma_pool scalar_processor_2400A0_dmem
+#define HIVE_ADDR_dma_pool 0xC4
+#define HIVE_SIZE_dma_pool 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_pool scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_pool 0xC4
+#define HIVE_SIZE_sp_dma_pool 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_uv_internal_width_vecs
+#define HIVE_MEM_isp_uv_internal_width_vecs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_uv_internal_width_vecs 0x2D9C
+#define HIVE_SIZE_isp_uv_internal_width_vecs 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_uv_internal_width_vecs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_uv_internal_width_vecs 0x2D9C
+#define HIVE_SIZE_sp_isp_uv_internal_width_vecs 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_exp_id
+#define HIVE_MEM_pipe_private_exp_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_private_exp_id 0x306C
+#define HIVE_SIZE_pipe_private_exp_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_exp_id scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_private_exp_id 0x306C
+#define HIVE_SIZE_sp_pipe_private_exp_id 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_MMU_BASE
+#define HIVE_MEM_MMU_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_MMU_BASE 0x24
+#define HIVE_SIZE_MMU_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_MMU_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_MMU_BASE 0x24
+#define HIVE_SIZE_sp_MMU_BASE 4
+
+/* function sp_dma_proxy_configure_init_dmem_channel: 3115 */
+
+/* function ia_css_sp_backend_create: 44CA */
+
+/* function sp2host_event_queue_get_size: 2CC */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_sp_frontend_idle
+#define HIVE_MEM_ia_css_sp_frontend_idle scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ia_css_sp_frontend_idle 0x3BE4
+#define HIVE_SIZE_ia_css_sp_frontend_idle 60
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_sp_frontend_idle scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ia_css_sp_frontend_idle 0x3BE4
+#define HIVE_SIZE_sp_ia_css_sp_frontend_idle 60
+
+/* function isp_hmem_load: 46D8 */
+
+/* function sp_dma_proxy_read_byte_addr: 4DA0 */
+
+/* function sp_thread_fork: 352E */
+
+/* function sp_semaphore_wait: 517A */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_debug_buffer_ddr_address
+#define HIVE_MEM_debug_buffer_ddr_address scalar_processor_2400A0_dmem
+#define HIVE_ADDR_debug_buffer_ddr_address 0xB8
+#define HIVE_SIZE_debug_buffer_ddr_address 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_debug_buffer_ddr_address scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_debug_buffer_ddr_address 0xB8
+#define HIVE_SIZE_sp_debug_buffer_ddr_address 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_frames_preview_pipe
+#define HIVE_MEM_sem_for_reading_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_reading_cb_frames_preview_pipe 0x381C
+#define HIVE_SIZE_sem_for_reading_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_frames_preview_pipe 0x381C
+#define HIVE_SIZE_sp_sem_for_reading_cb_frames_preview_pipe 20
+
+/* function sizeof_hmem: 4773 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_request_flash
+#define HIVE_MEM_sp_request_flash scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_request_flash 0x2DF8
+#define HIVE_SIZE_sp_request_flash 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_request_flash scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_request_flash 0x2DF8
+#define HIVE_SIZE_sp_sp_request_flash 4
+
+/* function sp_debug_mode_is_dma_request_enabled: 42DF */
+
+/* function cnd_input_system_cfg: 2A29 */
+
+/* function sp_generate_events: 41D6 */
+
+/* function sp_uds_configure: 749 */
+
+/* function sp_dma_proxy_execute: 30E8 */
+
+/* function __modu: 493E */
+
+/* function sp_circular_buf_push_marked: 36F4 */
+
+/* function isp_vamem_store: 0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_horiproj_num
+#define HIVE_MEM_isp_sdis_horiproj_num scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_sdis_horiproj_num 0x2DA0
+#define HIVE_SIZE_isp_sdis_horiproj_num 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_horiproj_num scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_sdis_horiproj_num 0x2DA0
+#define HIVE_SIZE_sp_isp_sdis_horiproj_num 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GDC_BASE
+#define HIVE_MEM_GDC_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_GDC_BASE 0x40
+#define HIVE_SIZE_GDC_BASE 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GDC_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_GDC_BASE 0x40
+#define HIVE_SIZE_sp_GDC_BASE 8
+
+/* function sp_event_proxy_callout_func: 3281 */
+
+/* function sp_fiber_init: 33ED */
+
+/* function ia_css_sp_input_system_token_map_destroy: 4872 */
+
+/* function ia_css_i_sp_rmgr_uninit: 350 */
+
+/* function wait_for_in_frame: 3B2A */
+
+/* function ia_css_sp_input_system_token_map_init: 48B3 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_isys_token_handler
+#define HIVE_MEM_sem_for_isys_token_handler scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_isys_token_handler 0x3830
+#define HIVE_SIZE_sem_for_isys_token_handler 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_isys_token_handler scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_isys_token_handler 0x3830
+#define HIVE_SIZE_sp_sem_for_isys_token_handler 20
+
+/* function sp_thread_init: 3555 */
+
+/* function ia_css_sp_frontend_destroy: 4666 */
+
+/* function irq_raise_set_token: 41 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GPIO_BASE
+#define HIVE_MEM_GPIO_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_GPIO_BASE 0x38
+#define HIVE_SIZE_GPIO_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GPIO_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_GPIO_BASE 0x38
+#define HIVE_SIZE_sp_GPIO_BASE 4
+
+/* function _dma_proxy_dma_read_write: 4E45 */
+
+/* function sp_dma_proxy_configure_init_vmem_channel: 3131 */
+
+/* function sp_acquire_dynamic_buf: 3A6C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_ph
+#define HIVE_MEM_isp_ph scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_ph 0x2650
+#define HIVE_SIZE_isp_ph 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_ph scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_ph 0x2650
+#define HIVE_SIZE_sp_isp_ph 28
+
+/* function sp_tagger_destroy: 40EC */
+
+/* function init_isp_internal_buffers: 1325 */
+
+/* function dma_proxy_dma_set_addr_B: 3172 */
+
+/* function ia_css_sp_input_system_token_map_snd_capture_req: 4827 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_target_nr_of_captured_frames
+#define HIVE_MEM_target_nr_of_captured_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_target_nr_of_captured_frames 0x2DE0
+#define HIVE_SIZE_target_nr_of_captured_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_target_nr_of_captured_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_target_nr_of_captured_frames 0x2DE0
+#define HIVE_SIZE_sp_target_nr_of_captured_frames 4
+
+/* function sp_dma_proxy_write: 30CF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp_group
+#define HIVE_MEM_sem_for_sp_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_sp_group 0x3844
+#define HIVE_SIZE_sem_for_sp_group 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_sp_group 0x3844
+#define HIVE_SIZE_sp_sem_for_sp_group 20
+
+/* function ia_css_i_sp_refcount_init_vbuf: 3F2 */
+
+/* function isp_hmem_clear: 46A9 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_params_preview_pipe
+#define HIVE_MEM_sem_for_reading_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_reading_cb_params_preview_pipe 0x3858
+#define HIVE_SIZE_sem_for_reading_cb_params_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_params_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_params_preview_pipe 0x3858
+#define HIVE_SIZE_sp_sem_for_reading_cb_params_preview_pipe 20
+
+/* function input_system_acquisition_run: 2A07 */
+
+/* function sp_dma_proxy_vmem_read: 308C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_params_capture_pipe
+#define HIVE_MEM_sem_for_reading_cb_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_reading_cb_params_capture_pipe 0x386C
+#define HIVE_SIZE_sem_for_reading_cb_params_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_params_capture_pipe 0x386C
+#define HIVE_SIZE_sp_sem_for_reading_cb_params_capture_pipe 20
+
+/* function release_in_frame: 3B66 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_params_capture_pipe
+#define HIVE_MEM_cb_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_params_capture_pipe 0x3880
+#define HIVE_SIZE_cb_params_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_params_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_params_capture_pipe 0x3880
+#define HIVE_SIZE_sp_cb_params_capture_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_vertproj_num
+#define HIVE_MEM_isp_sdis_vertproj_num scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_sdis_vertproj_num 0x2DA4
+#define HIVE_SIZE_isp_sdis_vertproj_num 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_vertproj_num scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_sdis_vertproj_num 0x2DA4
+#define HIVE_SIZE_sp_isp_sdis_vertproj_num 4
+
+/* function wait_for_in_param: 3B93 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_frames_capture_pipe
+#define HIVE_MEM_cb_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_frames_capture_pipe 0x3894
+#define HIVE_SIZE_cb_frames_capture_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_frames_capture_pipe 0x3894
+#define HIVE_SIZE_sp_cb_frames_capture_pipe 20
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_queue
+#define HIVE_MEM_host_sp_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_host_sp_queue 0x3070
+#define HIVE_SIZE_host_sp_queue 1036
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_queue scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_host_sp_queue 0x3070
+#define HIVE_SIZE_sp_host_sp_queue 1036
+
+/* function sp_thread_main: 356D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_pool
+#define HIVE_MEM_isp_pool scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_pool 0xC8
+#define HIVE_SIZE_isp_pool 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_pool scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_pool 0xC8
+#define HIVE_SIZE_sp_isp_pool 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_busy_frame
+#define HIVE_MEM_busy_frame scalar_processor_2400A0_dmem
+#define HIVE_ADDR_busy_frame 0x3C60
+#define HIVE_SIZE_busy_frame 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_busy_frame scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_busy_frame 0x3C60
+#define HIVE_SIZE_sp_busy_frame 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_is_done_flag
+#define HIVE_MEM_isp_is_done_flag scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_is_done_flag 0xD2C
+#define HIVE_SIZE_isp_is_done_flag 1
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_is_done_flag scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_is_done_flag 0xD2C
+#define HIVE_SIZE_sp_isp_is_done_flag 1
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_any_pending_mask
+#define HIVE_MEM_event_any_pending_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_event_any_pending_mask 0x33C
+#define HIVE_SIZE_event_any_pending_mask 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_any_pending_mask scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_event_any_pending_mask 0x33C
+#define HIVE_SIZE_sp_event_any_pending_mask 8
+
+/* function ia_css_sp_frontend_has_empty_mipi_buffer_cb: 44FE */
+
+/* function ia_css_i_sp_refcount_release_vbuf: 48F */
+
+/* function init_isp_data_segment: 13D2 */
+
+/* function ia_css_sp_frontend_start: 45F3 */
+
+/* function sh_css_decode_tag_descr: 5C5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dma_configs
+#define HIVE_MEM_dma_configs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_dma_configs 0x269C
+#define HIVE_SIZE_dma_configs 80
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dma_configs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_configs 0x269C
+#define HIVE_SIZE_sp_dma_configs 80
+
+/* function debug_enqueue_isp: 1FA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_crop_cropping_a
+#define HIVE_MEM_sp_dma_crop_cropping_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_crop_cropping_a 0x26F4
+#define HIVE_SIZE_sp_dma_crop_cropping_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_crop_cropping_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_dma_crop_cropping_a 0x26F4
+#define HIVE_SIZE_sp_sp_dma_crop_cropping_a 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
+#define HIVE_MEM_HIVE_IF_SWITCH_CODE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_HIVE_IF_SWITCH_CODE 0x320
+#define HIVE_SIZE_HIVE_IF_SWITCH_CODE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SWITCH_CODE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SWITCH_CODE 0x320
+#define HIVE_SIZE_sp_HIVE_IF_SWITCH_CODE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_isp_idle
+#define HIVE_MEM_sem_for_isp_idle scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_isp_idle 0x38A8
+#define HIVE_SIZE_sem_for_isp_idle 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x38A8
+#define HIVE_SIZE_sp_sem_for_isp_idle 20
+
+/* function sp_thread_get_state: 34A1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_channels
+#define HIVE_MEM_channels scalar_processor_2400A0_dmem
+#define HIVE_ADDR_channels 0x2630
+#define HIVE_SIZE_channels 32
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_channels scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_channels 0x2630
+#define HIVE_SIZE_sp_channels 32
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_vf_downscale_bits
+#define HIVE_MEM_sp_vf_downscale_bits scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_vf_downscale_bits 0x2DA8
+#define HIVE_SIZE_sp_vf_downscale_bits 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_vf_downscale_bits scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_vf_downscale_bits 0x2DA8
+#define HIVE_SIZE_sp_sp_vf_downscale_bits 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_vertcoef_vectors
+#define HIVE_MEM_isp_sdis_vertcoef_vectors scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_sdis_vertcoef_vectors 0x2DAC
+#define HIVE_SIZE_isp_sdis_vertcoef_vectors 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_vertcoef_vectors scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_sdis_vertcoef_vectors 0x2DAC
+#define HIVE_SIZE_sp_isp_sdis_vertcoef_vectors 4
+
+/* function dma_configure: 906 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_pipe_stop
+#define HIVE_MEM_sp_pipe_stop scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_stop 0x2F90
+#define HIVE_SIZE_sp_pipe_stop 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_pipe_stop scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_pipe_stop 0x2F90
+#define HIVE_SIZE_sp_sp_pipe_stop 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_VAMEM_BASE
+#define HIVE_MEM_ISP_VAMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_ISP_VAMEM_BASE 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_VAMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_sp_ISP_VAMEM_BASE 12
+
+/* function handle_parameter_sets: 3C29 */
+
+/* function ia_css_sp_frontend_create: 467C */
+
+/* function sp_tagger_create: 410D */
+
+/* function sp_dma_proxy_vmem_write: 3076 */
+
+/* function sp_thread_set_priority: 34EC */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_dis_bufs
+#define HIVE_MEM_pipe_private_dis_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_private_dis_bufs 0x347C
+#define HIVE_SIZE_pipe_private_dis_bufs 32
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_dis_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_private_dis_bufs 0x347C
+#define HIVE_SIZE_sp_pipe_private_dis_bufs 32
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_callout_sp_thread
+#define HIVE_MEM_callout_sp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_callout_sp_thread 0x2DFC
+#define HIVE_SIZE_callout_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_callout_sp_thread 0x2DFC
+#define HIVE_SIZE_sp_callout_sp_thread 4
+
+/* function sp_semaphore_signal: 5134 */
+
+/* function ia_css_sp_input_system_token_map_snd_acquire_req: 4814 */
+
+/* function sp_dma_proxy_write_byte_addr: 30B9 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_PMEM_BASE
+#define HIVE_MEM_SP_PMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_SP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_PMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_sp_SP_PMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_input_stream_format
+#define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_input_stream_format 0x2DB0
+#define HIVE_SIZE_sp_isp_input_stream_format 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x2DB0
+#define HIVE_SIZE_sp_sp_isp_input_stream_format 4
+
+/* function sp_circular_buf_push_unmarked: 35FE */
+
+/* function __mod: 492A */
+
+/* function __sp_event_proxy_func_critical: 4F9A */
+
+/* function sp_circular_buf_mark: 37CB */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_target_nr_of_copied_frames
+#define HIVE_MEM_target_nr_of_copied_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_target_nr_of_copied_frames 0x2DE4
+#define HIVE_SIZE_target_nr_of_copied_frames 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_target_nr_of_copied_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_target_nr_of_copied_frames 0x2DE4
+#define HIVE_SIZE_sp_target_nr_of_copied_frames 4
+
+/* function irq_raise: 53 */
+
+/* function sp_circular_buf_unmark: 37A3 */
+
+/* function ia_css_i_sp_rmgr_vbuf_dequeue: 44D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
+#define HIVE_MEM_HIVE_IF_SRST_ADDRESS scalar_processor_2400A0_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_ADDRESS 0x300
+#define HIVE_SIZE_HIVE_IF_SRST_ADDRESS 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_ADDRESS scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x300
+#define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
+
+/* function _dma_proxy_dma_execute: 4F1F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_frames_preview_pipe
+#define HIVE_MEM_cb_elems_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_elems_frames_preview_pipe 0x38BC
+#define HIVE_SIZE_cb_elems_frames_preview_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_elems_frames_preview_pipe 0x38BC
+#define HIVE_SIZE_sp_cb_elems_frames_preview_pipe 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_frames_preview_pipe
+#define HIVE_MEM_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_frames_preview_pipe 0x38CC
+#define HIVE_SIZE_cb_frames_preview_pipe 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_frames_preview_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_frames_preview_pipe 0x38CC
+#define HIVE_SIZE_sp_cb_frames_preview_pipe 20
+
+/* function set_sp_sleep_for_debug: 4314 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_sp_fiber
+#define HIVE_MEM_current_sp_fiber scalar_processor_2400A0_dmem
+#define HIVE_ADDR_current_sp_fiber 0x1218
+#define HIVE_SIZE_current_sp_fiber 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_sp_fiber scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_current_sp_fiber 0x1218
+#define HIVE_SIZE_sp_current_sp_fiber 4
+
+/* function ia_css_sp_input_system_token_map_create: 48E0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_dma_vfout_cropping_a
+#define HIVE_MEM_sp_dma_vfout_cropping_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_dma_vfout_cropping_a 0x26F8
+#define HIVE_SIZE_sp_dma_vfout_cropping_a 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_dma_vfout_cropping_a scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_dma_vfout_cropping_a 0x26F8
+#define HIVE_SIZE_sp_sp_dma_vfout_cropping_a 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cb_elems_frames_capture_pipe
+#define HIVE_MEM_cb_elems_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_cb_elems_frames_capture_pipe 0x38E0
+#define HIVE_SIZE_cb_elems_frames_capture_pipe 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cb_elems_frames_capture_pipe scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_cb_elems_frames_capture_pipe 0x38E0
+#define HIVE_SIZE_sp_cb_elems_frames_capture_pipe 16
+
+/* function sp_dma_proxy_init: 2FE6 */
+
+/* function sp_release_dynamic_buf: 390C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_HMEM_BASE
+#define HIVE_MEM_ISP_HMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_ISP_HMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_HMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_sp_ISP_HMEM_BASE 4
+
+/* function ia_css_sp_input_system_token_map_flush: 4855 */
+
+/* function ia_css_i_sp_rmgr_vbuf_enqueue: 478 */
+
+/* function __sp_event_proxy_callout_func_critical: 4FAD */
+
+/* function ia_css_sp_input_system_isr: 477A */
+
+/* function end_binary: 1172 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_stacks
+#define HIVE_MEM_stacks scalar_processor_2400A0_dmem
+#define HIVE_ADDR_stacks 0x258
+#define HIVE_SIZE_stacks 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_stacks scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_stacks 0x258
+#define HIVE_SIZE_sp_stacks 20
+
+/* function dma_proxy_dma_execute_split: 3210 */
+
+/* function ia_css_i_sp_refcount_dump: 428 */
+
+/* function ia_css_i_sp_rmgr_rel_gen: 399 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_irq_sw_interrupt_token
+#define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400A0_dmem
+#define HIVE_ADDR_irq_sw_interrupt_token 0x2610
+#define HIVE_SIZE_irq_sw_interrupt_token 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x2610
+#define HIVE_SIZE_sp_irq_sw_interrupt_token 4
+
+/* function sp_thread_kill: 34F4 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_buffer_bufs
+#define HIVE_MEM_pipe_private_buffer_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_private_buffer_bufs 0x349C
+#define HIVE_SIZE_pipe_private_buffer_bufs 112
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_buffer_bufs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_private_buffer_bufs 0x349C
+#define HIVE_SIZE_sp_pipe_private_buffer_bufs 112
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_addresses
+#define HIVE_MEM_sp_isp_addresses scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_addresses 0x3B28
+#define HIVE_SIZE_sp_isp_addresses 176
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_isp_addresses 0x3B28
+#define HIVE_SIZE_sp_sp_isp_addresses 176
+
+/* function sp_fiber_main: 33F7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isps
+#define HIVE_MEM_isps scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isps 0x266C
+#define HIVE_SIZE_isps 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isps scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isps 0x266C
+#define HIVE_SIZE_sp_isps 28
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_queues_initialized
+#define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400A0_dmem
+#define HIVE_ADDR_host_sp_queues_initialized 0x2DB4
+#define HIVE_SIZE_host_sp_queues_initialized 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x2DB4
+#define HIVE_SIZE_sp_host_sp_queues_initialized 4
+
+/* function ia_css_sp_backend_acquire: 44A8 */
+
+/* function _dma_proxy_dma_read_write_inline: 31B7 */
+
+/* function dma_proxy_dma_set_increments: 3164 */
+
+/* function __sp_dma_proxy_wait_for_ack_text: 302C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_spref
+#define HIVE_MEM_vbuf_spref scalar_processor_2400A0_dmem
+#define HIVE_ADDR_vbuf_spref 0xCC
+#define HIVE_SIZE_vbuf_spref 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_spref scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_vbuf_spref 0xCC
+#define HIVE_SIZE_sp_vbuf_spref 4
+
+/* function sp_circular_buf_extract: 37F3 */
+
+/* function output_compute_dma_info: 1E1B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_sdis_horicoef_vectors
+#define HIVE_MEM_isp_sdis_horicoef_vectors scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_sdis_horicoef_vectors 0x2DB8
+#define HIVE_SIZE_isp_sdis_horicoef_vectors 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_sdis_horicoef_vectors scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_sdis_horicoef_vectors 0x2DB8
+#define HIVE_SIZE_sp_isp_sdis_horicoef_vectors 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_if
+#define HIVE_MEM_sem_for_reading_if scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sem_for_reading_if 0x38F0
+#define HIVE_SIZE_sem_for_reading_if 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sem_for_reading_if 0x38F0
+#define HIVE_SIZE_sp_sem_for_reading_if 20
+
+/* function sp_circular_buf_pop_marked: 36A8 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipe_private_frames
+#define HIVE_MEM_pipe_private_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_pipe_private_frames 0x350C
+#define HIVE_SIZE_pipe_private_frames 48
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipe_private_frames scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_pipe_private_frames 0x350C
+#define HIVE_SIZE_sp_pipe_private_frames 48
+
+/* function ia_css_sp_frontend_rcv_capture_ack: 454A */
+
+/* function sp_generate_interrupts: 4135 */
+
+/* function init_isp_vars: 20D4 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sems_for_host2sp_buf_queues
+#define HIVE_MEM_sems_for_host2sp_buf_queues scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sems_for_host2sp_buf_queues 0x353C
+#define HIVE_SIZE_sems_for_host2sp_buf_queues 560
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sems_for_host2sp_buf_queues scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sems_for_host2sp_buf_queues 0x353C
+#define HIVE_SIZE_sp_sems_for_host2sp_buf_queues 560
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_data
+#define HIVE_MEM_sp_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_data 0x27AC
+#define HIVE_SIZE_sp_data 640
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_data scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_data 0x27AC
+#define HIVE_SIZE_sp_sp_data 640
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_BAMEM_BASE
+#define HIVE_MEM_ISP_BAMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_BAMEM_BASE 0x334
+#define HIVE_SIZE_ISP_BAMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_BAMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x334
+#define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
+
+/* function acquire_isp: 433B */
+
+/* function sp_circular_buf_is_marked: 377E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_mem_map
+#define HIVE_MEM_mem_map scalar_processor_2400A0_dmem
+#define HIVE_ADDR_mem_map 0x26FC
+#define HIVE_SIZE_mem_map 104
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_mem_map scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_mem_map 0x26FC
+#define HIVE_SIZE_sp_mem_map 104
+
+/* function sp_init_dmem: 2B16 */
+
+/* function ia_css_i_sp_refcount_retain_vbuf: 4B0 */
+
+/* function init_isp_code_segment: 122C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_PMEM_BASE
+#define HIVE_MEM_ISP_PMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_ISP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_PMEM_BASE scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_sp_ISP_PMEM_BASE 4
+
+/* function run_sp_threads: 3584 */
+
+/* function ia_css_sp_backend_snd_acquire_request: 43A1 */
+
+/* function sp_thread_queue_print: 35A1 */
+
+/* function done_isp_data_segment: 13B4 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_flash_in_service
+#define HIVE_MEM_sp_flash_in_service scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_flash_in_service 0x1228
+#define HIVE_SIZE_sp_flash_in_service 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_flash_in_service scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_flash_in_service 0x1228
+#define HIVE_SIZE_sp_sp_flash_in_service 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_vf_output_width_vecs
+#define HIVE_MEM_isp_vf_output_width_vecs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_vf_output_width_vecs 0x2DBC
+#define HIVE_SIZE_isp_vf_output_width_vecs 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_vf_output_width_vecs scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_vf_output_width_vecs 0x2DBC
+#define HIVE_SIZE_sp_isp_vf_output_width_vecs 4
+
+/* function sp_circular_buf_pop_unmarked: 35BA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sleep_mode
+#define HIVE_MEM_sp_sleep_mode scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sleep_mode 0x2DC0
+#define HIVE_SIZE_sp_sleep_mode 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_sp_sleep_mode 0x2DC0
+#define HIVE_SIZE_sp_sp_sleep_mode 4
+
+/* function mmu_invalidate_cache: 5E */
+
+/* function ia_css_sp_input_system_token_map_receive_ack: 47DB */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stop_req
+#define HIVE_MEM_isp_stop_req scalar_processor_2400A0_dmem
+#define HIVE_ADDR_isp_stop_req 0x2DF4
+#define HIVE_SIZE_isp_stop_req 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stop_req scalar_processor_2400A0_dmem
+#define HIVE_ADDR_sp_isp_stop_req 0x2DF4
+#define HIVE_SIZE_sp_isp_stop_req 4
+
+/* function release_isp: 4326 */
+
+#define HIVE_ICACHE_sp_critical_SEGMENT_START 0
+#define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
+
+#endif /* _sp_map_h_ */
+extern void sh_css_dump_sp_init_dmem_data (void);
+void sh_css_dump_sp_init_dmem_data (void)
+{
+  static struct ia_css_sp_init_dmem_cfg sp_init_dmem_data;
+  assert(sizeof(sp_init_dmem_data) ==
+         HIVE_SIZE_sp_init_dmem_data);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_init_dmem_data),
+    (char*)&sp_init_dmem_data,
+    sizeof(sp_init_dmem_data));
+  sh_css_print("sp_init_dmem_data.done ="
+    "                                  0x%x\n",
+    sp_init_dmem_data.done);
+  sh_css_print("sp_init_dmem_data.ddr_data_addr ="
+    "                         0x%x\n",
+    sp_init_dmem_data.ddr_data_addr);
+  sh_css_print("sp_init_dmem_data.dmem_data_addr ="
+    "                        0x%x\n",
+    sp_init_dmem_data.dmem_data_addr);
+  sh_css_print("sp_init_dmem_data.dmem_bss_addr ="
+    "                         0x%x\n",
+    sp_init_dmem_data.dmem_bss_addr);
+  sh_css_print("sp_init_dmem_data.data_size ="
+    "                             0x%x\n",
+    sp_init_dmem_data.data_size);
+  sh_css_print("sp_init_dmem_data.bss_size ="
+    "                              0x%x\n",
+    sp_init_dmem_data.bss_size);
+}
+
+extern void sh_css_dump_xmem_bin_addr (void);
+void sh_css_dump_xmem_bin_addr (void)
+{
+  hrt_vaddress xmem_bin_addr;
+  assert(sizeof(xmem_bin_addr) ==
+         HIVE_SIZE_xmem_bin_addr);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(xmem_bin_addr),
+    (char*)&xmem_bin_addr,
+    sizeof(xmem_bin_addr));
+  sh_css_print("xmem_bin_addr ="
+    "                                           0x%x\n",
+    xmem_bin_addr);
+}
+
+extern void sh_css_dump_sp_vf_downscale_bits (void);
+void sh_css_dump_sp_vf_downscale_bits (void)
+{
+  unsigned int sp_vf_downscale_bits;
+  assert(sizeof(sp_vf_downscale_bits) ==
+         HIVE_SIZE_sp_vf_downscale_bits);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_vf_downscale_bits),
+    (char*)&sp_vf_downscale_bits,
+    sizeof(sp_vf_downscale_bits));
+  sh_css_print("sp_vf_downscale_bits ="
+    "                                    0x%x\n",
+    sp_vf_downscale_bits);
+}
+
+extern void sh_css_dump_sp_per_frame_data (void);
+void sh_css_dump_sp_per_frame_data (void)
+{
+  static struct sh_css_sp_per_frame_data sp_per_frame_data;
+  assert(sizeof(sp_per_frame_data) ==
+         HIVE_SIZE_sp_per_frame_data);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_per_frame_data),
+    (char*)&sp_per_frame_data,
+    sizeof(sp_per_frame_data));
+  sh_css_print("sp_per_frame_data.sp_group_addr ="
+    "                         0x%x\n",
+    sp_per_frame_data.sp_group_addr);
+}
+
+extern void sh_css_dump_sp_group (void);
+void sh_css_dump_sp_group (void)
+{
+  static struct sh_css_sp_group sp_group;
+  assert(sizeof(sp_group) ==
+         HIVE_SIZE_sp_group);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_group),
+    (char*)&sp_group,
+    sizeof(sp_group));
+  sh_css_print("sp_group.config.is_offline ="
+    "                              0x%x\n",
+    sp_group.config.is_offline);
+  sh_css_print("sp_group.config.input_needs_raw_binning ="
+    "                 0x%x\n",
+    sp_group.config.input_needs_raw_binning);
+  sh_css_print("sp_group.config.no_isp_sync ="
+    "                             0x%x\n",
+    sp_group.config.no_isp_sync);
+  sh_css_print("sp_group.config.input_formatter.a_changed ="
+    "               0x%x\n",
+    sp_group.config.input_formatter.a_changed);
+  sh_css_print("sp_group.config.input_formatter.b_changed ="
+    "               0x%x\n",
+    sp_group.config.input_formatter.b_changed);
+  sh_css_print("sp_group.config.input_formatter.isp_2ppc ="
+    "                0x%x\n",
+    sp_group.config.input_formatter.isp_2ppc);
+  sh_css_print("sp_group.config.input_formatter.set[0].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[0].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[0].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[0].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[1].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[1].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[1].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[1].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[2].stream_format ="
+    "    0x%x\n",
+    sp_group.config.input_formatter.set[2].stream_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_a.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_a.block_no_reqs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.start_line ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.start_line);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.start_column ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.start_column);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.left_padding ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.left_padding);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.cropped_height ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.cropped_height);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.cropped_width ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.cropped_width);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.deinterleaving ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.deinterleaving);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_vecs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_vecs);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_start_index ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_start_index);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_increment ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_increment);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.buf_eol_offset ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.buf_eol_offset);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.is_yuv420_format ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.is_yuv420_format);
+  sh_css_print("sp_group.config.input_formatter.set[2].config_b.block_no_reqs ="
+    "0x%x\n",
+    sp_group.config.input_formatter.set[2].config_b.block_no_reqs);
+  sh_css_print("sp_group.config.sync_gen.width ="
+    "                          0x%x\n",
+    sp_group.config.sync_gen.width);
+  sh_css_print("sp_group.config.sync_gen.height ="
+    "                         0x%x\n",
+    sp_group.config.sync_gen.height);
+  sh_css_print("sp_group.config.sync_gen.hblank_cycles ="
+    "                  0x%x\n",
+    sp_group.config.sync_gen.hblank_cycles);
+  sh_css_print("sp_group.config.sync_gen.vblank_cycles ="
+    "                  0x%x\n",
+    sp_group.config.sync_gen.vblank_cycles);
+  sh_css_print("sp_group.config.tpg.x_mask ="
+    "                              0x%x\n",
+    sp_group.config.tpg.x_mask);
+  sh_css_print("sp_group.config.tpg.y_mask ="
+    "                              0x%x\n",
+    sp_group.config.tpg.y_mask);
+  sh_css_print("sp_group.config.tpg.x_delta ="
+    "                             0x%x\n",
+    sp_group.config.tpg.x_delta);
+  sh_css_print("sp_group.config.tpg.y_delta ="
+    "                             0x%x\n",
+    sp_group.config.tpg.y_delta);
+  sh_css_print("sp_group.config.tpg.xy_mask ="
+    "                             0x%x\n",
+    sp_group.config.tpg.xy_mask);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.width ="
+    "                  0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.width);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.height ="
+    "                 0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.height);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.hblank_cycles ="
+    "          0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.hblank_cycles);
+  sh_css_print("sp_group.config.tpg.sync_gen_cfg.vblank_cycles ="
+    "          0x%x\n",
+    sp_group.config.tpg.sync_gen_cfg.vblank_cycles);
+  sh_css_print("sp_group.config.prbs.seed ="
+    "                               0x%x\n",
+    sp_group.config.prbs.seed);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.width ="
+    "                 0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.width);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.height ="
+    "                0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.height);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.hblank_cycles ="
+    "         0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.hblank_cycles);
+  sh_css_print("sp_group.config.prbs.sync_gen_cfg.vblank_cycles ="
+    "         0x%x\n",
+    sp_group.config.prbs.sync_gen_cfg.vblank_cycles);
+  sh_css_print("sp_group.config.input_circuit.no_side_band ="
+    "              0x%x\n",
+    sp_group.config.input_circuit.no_side_band);
+  sh_css_print("sp_group.config.input_circuit.fmt_type ="
+    "                  0x%x\n",
+    sp_group.config.input_circuit.fmt_type);
+  sh_css_print("sp_group.config.input_circuit.ch_id ="
+    "                     0x%x\n",
+    sp_group.config.input_circuit.ch_id);
+  sh_css_print("sp_group.config.input_circuit.input_mode ="
+    "                0x%x\n",
+    sp_group.config.input_circuit.input_mode);
+  sh_css_print("sp_group.config.input_circuit_cfg_changed ="
+    "               0x%x\n",
+    sp_group.config.input_circuit_cfg_changed);
+  sh_css_print("sp_group.pipe[0].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[0].pipe_id);
+  sh_css_print("sp_group.pipe[0].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[0].pipe_num);
+  sh_css_print("sp_group.pipe[0].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[0].thread_id);
+  sh_css_print("sp_group.pipe[0].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[0].pipe_config);
+  sh_css_print("sp_group.pipe[0].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[0].input_system_mode);
+  sh_css_print("sp_group.pipe[0].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[0].port_id);
+  sh_css_print("sp_group.pipe[0].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[0].num_stages);
+  sh_css_print("sp_group.pipe[0].running ="
+    "                                0x%x\n",
+    sp_group.pipe[0].running);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[0].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[0].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[0].stage ="
+    "                                    %p\n",
+    sp_group.pipe[0].stage);
+  sh_css_print("sp_group.pipe[0].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[0].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[0].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[0].copy.raw.height);
+  sh_css_print("sp_group.pipe[0].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[0].copy.raw.width);
+  sh_css_print("sp_group.pipe[0].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[0].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[0].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[0].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[0].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[0].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[1].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[1].pipe_id);
+  sh_css_print("sp_group.pipe[1].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[1].pipe_num);
+  sh_css_print("sp_group.pipe[1].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[1].thread_id);
+  sh_css_print("sp_group.pipe[1].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[1].pipe_config);
+  sh_css_print("sp_group.pipe[1].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[1].input_system_mode);
+  sh_css_print("sp_group.pipe[1].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[1].port_id);
+  sh_css_print("sp_group.pipe[1].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[1].num_stages);
+  sh_css_print("sp_group.pipe[1].running ="
+    "                                0x%x\n",
+    sp_group.pipe[1].running);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[1].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[1].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[1].stage ="
+    "                                    %p\n",
+    sp_group.pipe[1].stage);
+  sh_css_print("sp_group.pipe[1].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[1].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[1].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[1].copy.raw.height);
+  sh_css_print("sp_group.pipe[1].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[1].copy.raw.width);
+  sh_css_print("sp_group.pipe[1].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[1].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[1].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[1].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[1].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[1].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[2].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[2].pipe_id);
+  sh_css_print("sp_group.pipe[2].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[2].pipe_num);
+  sh_css_print("sp_group.pipe[2].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[2].thread_id);
+  sh_css_print("sp_group.pipe[2].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[2].pipe_config);
+  sh_css_print("sp_group.pipe[2].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[2].input_system_mode);
+  sh_css_print("sp_group.pipe[2].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[2].port_id);
+  sh_css_print("sp_group.pipe[2].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[2].num_stages);
+  sh_css_print("sp_group.pipe[2].running ="
+    "                                0x%x\n",
+    sp_group.pipe[2].running);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[2].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[2].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[2].stage ="
+    "                                    %p\n",
+    sp_group.pipe[2].stage);
+  sh_css_print("sp_group.pipe[2].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[2].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[2].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[2].copy.raw.height);
+  sh_css_print("sp_group.pipe[2].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[2].copy.raw.width);
+  sh_css_print("sp_group.pipe[2].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[2].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[2].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[2].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[2].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[2].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.pipe[3].pipe_id ="
+    "                                0x%x\n",
+    sp_group.pipe[3].pipe_id);
+  sh_css_print("sp_group.pipe[3].pipe_num ="
+    "                               0x%x\n",
+    sp_group.pipe[3].pipe_num);
+  sh_css_print("sp_group.pipe[3].thread_id ="
+    "                              0x%x\n",
+    sp_group.pipe[3].thread_id);
+  sh_css_print("sp_group.pipe[3].pipe_config ="
+    "                            0x%x\n",
+    sp_group.pipe[3].pipe_config);
+  sh_css_print("sp_group.pipe[3].input_system_mode ="
+    "                      0x%x\n",
+    sp_group.pipe[3].input_system_mode);
+  sh_css_print("sp_group.pipe[3].port_id ="
+    "                                0x%x\n",
+    sp_group.pipe[3].port_id);
+  sh_css_print("sp_group.pipe[3].num_stages ="
+    "                             0x%x\n",
+    sp_group.pipe[3].num_stages);
+  sh_css_print("sp_group.pipe[3].running ="
+    "                                0x%x\n",
+    sp_group.pipe[3].running);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[0] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[0]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[1] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[1]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[2] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[2]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[3] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[3]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[4] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[4]);
+  sh_css_print("sp_group.pipe[3].sp_stage_addr[5] ="
+    "                       0x%x\n",
+    sp_group.pipe[3].sp_stage_addr[5]);
+  sh_css_print("sp_group.pipe[3].stage ="
+    "                                    %p\n",
+    sp_group.pipe[3].stage);
+  sh_css_print("sp_group.pipe[3].copy.bin.bytes_available ="
+    "               0x%x\n",
+    sp_group.pipe[3].copy.bin.bytes_available);
+  sh_css_print("sp_group.pipe[3].copy.raw.height ="
+    "                        0x%x\n",
+    sp_group.pipe[3].copy.raw.height);
+  sh_css_print("sp_group.pipe[3].copy.raw.width ="
+    "                         0x%x\n",
+    sp_group.pipe[3].copy.raw.width);
+  sh_css_print("sp_group.pipe[3].copy.raw.padded_width ="
+    "                  0x%x\n",
+    sp_group.pipe[3].copy.raw.padded_width);
+  sh_css_print("sp_group.pipe[3].copy.raw.max_input_width ="
+    "               0x%x\n",
+    sp_group.pipe[3].copy.raw.max_input_width);
+  sh_css_print("sp_group.pipe[3].copy.raw.raw_bit_depth ="
+    "                 0x%x\n",
+    sp_group.pipe[3].copy.raw.raw_bit_depth);
+  sh_css_print("sp_group.debug.dma_sw_reg ="
+    "                               0x%x\n",
+    sp_group.debug.dma_sw_reg);
+}
+
+extern void sh_css_dump_sp_output (void);
+void sh_css_dump_sp_output (void)
+{
+  static struct sh_css_sp_output sp_output;
+  assert(sizeof(sp_output) ==
+         HIVE_SIZE_sp_output);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_output),
+    (char*)&sp_output,
+    sizeof(sp_output));
+  sh_css_print("sp_output.bin_copy_bytes_copied ="
+    "                         0x%x\n",
+    sp_output.bin_copy_bytes_copied);
+  sh_css_print("sp_output.sw_interrupt_value[0] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[0]);
+  sh_css_print("sp_output.sw_interrupt_value[1] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[1]);
+  sh_css_print("sp_output.sw_interrupt_value[2] ="
+    "                         0x%x\n",
+    sp_output.sw_interrupt_value[2]);
+}
+
+extern void sh_css_dump_host_sp_com (void);
+void sh_css_dump_host_sp_com (void)
+{
+  static volatile struct host_sp_communication host_sp_com;
+  assert(sizeof(host_sp_com) ==
+         HIVE_SIZE_host_sp_com);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(host_sp_com),
+    (char*)&host_sp_com,
+    sizeof(host_sp_com));
+  sh_css_print("host_sp_com.host2sp_command ="
+    "                             0x%x\n",
+    host_sp_com.host2sp_command);
+  sh_css_print("host_sp_com.host2sp_offline_frames[0] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[0]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[1] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[1]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[2] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[2]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[3] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[3]);
+  sh_css_print("host_sp_com.host2sp_offline_frames[4] ="
+    "                   0x%x\n",
+    host_sp_com.host2sp_offline_frames[4]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[0] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[0]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[1] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[1]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[2] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[2]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[3] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[3]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[4] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[4]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[5] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[5]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[6] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[6]);
+  sh_css_print("host_sp_com.host2sp_mipi_frames[7] ="
+    "                      0x%x\n",
+    host_sp_com.host2sp_mipi_frames[7]);
+  sh_css_print("host_sp_com.host2sp_cont_num_raw_frames ="
+    "                 0x%x\n",
+    host_sp_com.host2sp_cont_num_raw_frames);
+  sh_css_print("host_sp_com.host2sp_cont_num_mipi_frames ="
+    "                0x%x\n",
+    host_sp_com.host2sp_cont_num_mipi_frames);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[0].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[0].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[0].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[0].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[1].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[1].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[1].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[1].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[2].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[2].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[2].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[2].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[3].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[3].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[3].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[3].and_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[4].or_mask ="
+    "           0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[4].or_mask);
+  sh_css_print("host_sp_com.host2sp_event_irq_mask[4].and_mask ="
+    "          0x%x\n",
+    host_sp_com.host2sp_event_irq_mask[4].and_mask);
+}
+
+extern void sh_css_dump_sp_isp_started (void);
+void sh_css_dump_sp_isp_started (void)
+{
+  volatile int sp_isp_started;
+  assert(sizeof(sp_isp_started) ==
+         HIVE_SIZE_sp_isp_started);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_isp_started),
+    (char*)&sp_isp_started,
+    sizeof(sp_isp_started));
+  sh_css_print("sp_isp_started ="
+    "                                          0x%x\n",
+    sp_isp_started);
+}
+
+extern void sh_css_dump_sp_sw_state (void);
+void sh_css_dump_sp_sw_state (void)
+{
+  volatile int sp_sw_state;
+  assert(sizeof(sp_sw_state) ==
+         HIVE_SIZE_sp_sw_state);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_sw_state),
+    (char*)&sp_sw_state,
+    sizeof(sp_sw_state));
+  sh_css_print("sp_sw_state ="
+    "                                             0x%x\n",
+    sp_sw_state);
+}
+
+extern void sh_css_dump_host_sp_queues_initialized (void);
+void sh_css_dump_host_sp_queues_initialized (void)
+{
+  volatile int host_sp_queues_initialized;
+  assert(sizeof(host_sp_queues_initialized) ==
+         HIVE_SIZE_host_sp_queues_initialized);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(host_sp_queues_initialized),
+    (char*)&host_sp_queues_initialized,
+    sizeof(host_sp_queues_initialized));
+  sh_css_print("host_sp_queues_initialized ="
+    "                              0x%x\n",
+    host_sp_queues_initialized);
+}
+
+extern void sh_css_dump_sp_sleep_mode (void);
+void sh_css_dump_sp_sleep_mode (void)
+{
+  volatile int sp_sleep_mode;
+  assert(sizeof(sp_sleep_mode) ==
+         HIVE_SIZE_sp_sleep_mode);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_sleep_mode),
+    (char*)&sp_sleep_mode,
+    sizeof(sp_sleep_mode));
+  sh_css_print("sp_sleep_mode ="
+    "                                           0x%x\n",
+    sp_sleep_mode);
+}
+
+extern void sh_css_dump_isp_uv_internal_width_vecs (void);
+void sh_css_dump_isp_uv_internal_width_vecs (void)
+{
+  unsigned int isp_uv_internal_width_vecs;
+  assert(sizeof(isp_uv_internal_width_vecs) ==
+         HIVE_SIZE_isp_uv_internal_width_vecs);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_uv_internal_width_vecs),
+    (char*)&isp_uv_internal_width_vecs,
+    sizeof(isp_uv_internal_width_vecs));
+  sh_css_print("isp_uv_internal_width_vecs ="
+    "                              0x%x\n",
+    isp_uv_internal_width_vecs);
+}
+
+extern void sh_css_dump_isp_vf_output_width_vecs (void);
+void sh_css_dump_isp_vf_output_width_vecs (void)
+{
+  unsigned int isp_vf_output_width_vecs;
+  assert(sizeof(isp_vf_output_width_vecs) ==
+         HIVE_SIZE_isp_vf_output_width_vecs);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vf_output_width_vecs),
+    (char*)&isp_vf_output_width_vecs,
+    sizeof(isp_vf_output_width_vecs));
+  sh_css_print("isp_vf_output_width_vecs ="
+    "                                0x%x\n",
+    isp_vf_output_width_vecs);
+}
+
+extern void sh_css_dump_isp_vectors_per_line (void);
+void sh_css_dump_isp_vectors_per_line (void)
+{
+  unsigned int isp_vectors_per_line;
+  assert(sizeof(isp_vectors_per_line) ==
+         HIVE_SIZE_isp_vectors_per_line);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vectors_per_line),
+    (char*)&isp_vectors_per_line,
+    sizeof(isp_vectors_per_line));
+  sh_css_print("isp_vectors_per_line ="
+    "                                    0x%x\n",
+    isp_vectors_per_line);
+}
+
+extern void sh_css_dump_isp_vectors_per_input_line (void);
+void sh_css_dump_isp_vectors_per_input_line (void)
+{
+  unsigned int isp_vectors_per_input_line;
+  assert(sizeof(isp_vectors_per_input_line) ==
+         HIVE_SIZE_isp_vectors_per_input_line);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_vectors_per_input_line),
+    (char*)&isp_vectors_per_input_line,
+    sizeof(isp_vectors_per_input_line));
+  sh_css_print("isp_vectors_per_input_line ="
+    "                              0x%x\n",
+    isp_vectors_per_input_line);
+}
+
+extern void sh_css_dump_isp_sdis_horiproj_num (void);
+void sh_css_dump_isp_sdis_horiproj_num (void)
+{
+  unsigned int isp_sdis_horiproj_num;
+  assert(sizeof(isp_sdis_horiproj_num) ==
+         HIVE_SIZE_isp_sdis_horiproj_num);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_horiproj_num),
+    (char*)&isp_sdis_horiproj_num,
+    sizeof(isp_sdis_horiproj_num));
+  sh_css_print("isp_sdis_horiproj_num ="
+    "                                   0x%x\n",
+    isp_sdis_horiproj_num);
+}
+
+extern void sh_css_dump_isp_sdis_vertproj_num (void);
+void sh_css_dump_isp_sdis_vertproj_num (void)
+{
+  unsigned int isp_sdis_vertproj_num;
+  assert(sizeof(isp_sdis_vertproj_num) ==
+         HIVE_SIZE_isp_sdis_vertproj_num);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_vertproj_num),
+    (char*)&isp_sdis_vertproj_num,
+    sizeof(isp_sdis_vertproj_num));
+  sh_css_print("isp_sdis_vertproj_num ="
+    "                                   0x%x\n",
+    isp_sdis_vertproj_num);
+}
+
+extern void sh_css_dump_isp_sdis_horicoef_vectors (void);
+void sh_css_dump_isp_sdis_horicoef_vectors (void)
+{
+  unsigned int isp_sdis_horicoef_vectors;
+  assert(sizeof(isp_sdis_horicoef_vectors) ==
+         HIVE_SIZE_isp_sdis_horicoef_vectors);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_horicoef_vectors),
+    (char*)&isp_sdis_horicoef_vectors,
+    sizeof(isp_sdis_horicoef_vectors));
+  sh_css_print("isp_sdis_horicoef_vectors ="
+    "                               0x%x\n",
+    isp_sdis_horicoef_vectors);
+}
+
+extern void sh_css_dump_isp_sdis_vertcoef_vectors (void);
+void sh_css_dump_isp_sdis_vertcoef_vectors (void)
+{
+  unsigned int isp_sdis_vertcoef_vectors;
+  assert(sizeof(isp_sdis_vertcoef_vectors) ==
+         HIVE_SIZE_isp_sdis_vertcoef_vectors);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(isp_sdis_vertcoef_vectors),
+    (char*)&isp_sdis_vertcoef_vectors,
+    sizeof(isp_sdis_vertcoef_vectors));
+  sh_css_print("isp_sdis_vertcoef_vectors ="
+    "                               0x%x\n",
+    isp_sdis_vertcoef_vectors);
+}
+
+extern void sh_css_dump_sp_isp_input_stream_format (void);
+void sh_css_dump_sp_isp_input_stream_format (void)
+{
+  enum sh_stream_format{ sh_stream_format_yuv420_legacy, sh_stream_format_yuv420, sh_stream_format_yuv422, sh_stream_format_rgb, sh_stream_format_raw, sh_stream_format_binary} sp_isp_input_stream_format;
+  assert(sizeof(sp_isp_input_stream_format) ==
+         HIVE_SIZE_sp_isp_input_stream_format);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_isp_input_stream_format),
+    (char*)&sp_isp_input_stream_format,
+    sizeof(sp_isp_input_stream_format));
+  sh_css_print("sp_isp_input_stream_format ="
+    "                              0x%x\n",
+    sp_isp_input_stream_format);
+}
+
+extern void sh_css_dump_sp_obarea_start_bq (void);
+void sh_css_dump_sp_obarea_start_bq (void)
+{
+  unsigned int sp_obarea_start_bq;
+  assert(sizeof(sp_obarea_start_bq) ==
+         HIVE_SIZE_sp_obarea_start_bq);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_obarea_start_bq),
+    (char*)&sp_obarea_start_bq,
+    sizeof(sp_obarea_start_bq));
+  sh_css_print("sp_obarea_start_bq ="
+    "                                      0x%x\n",
+    sp_obarea_start_bq);
+}
+
+extern void sh_css_dump_sp_obarea_length_bq (void);
+void sh_css_dump_sp_obarea_length_bq (void)
+{
+  unsigned int sp_obarea_length_bq;
+  assert(sizeof(sp_obarea_length_bq) ==
+         HIVE_SIZE_sp_obarea_length_bq);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_obarea_length_bq),
+    (char*)&sp_obarea_length_bq,
+    sizeof(sp_obarea_length_bq));
+  sh_css_print("sp_obarea_length_bq ="
+    "                                     0x%x\n",
+    sp_obarea_length_bq);
+}
+
+extern void sh_css_dump_sp_preview_thread_id (void);
+void sh_css_dump_sp_preview_thread_id (void)
+{
+  unsigned int sp_preview_thread_id;
+  assert(sizeof(sp_preview_thread_id) ==
+         HIVE_SIZE_sp_preview_thread_id);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_preview_thread_id),
+    (char*)&sp_preview_thread_id,
+    sizeof(sp_preview_thread_id));
+  sh_css_print("sp_preview_thread_id ="
+    "                                    0x%x\n",
+    sp_preview_thread_id);
+}
+
+extern void sh_css_dump_sp_capture_thread_id (void);
+void sh_css_dump_sp_capture_thread_id (void)
+{
+  unsigned int sp_capture_thread_id;
+  assert(sizeof(sp_capture_thread_id) ==
+         HIVE_SIZE_sp_capture_thread_id);
+  sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_capture_thread_id),
+    (char*)&sp_capture_thread_id,
+    sizeof(sp_capture_thread_id));
+  sh_css_print("sp_capture_thread_id ="
+    "                                    0x%x\n",
+    sp_capture_thread_id);
+}
+
+extern void sh_css_dump_sp_dmem(void);
+void sh_css_dump_sp_dmem(void)
+{
+  sh_css_dump_sp_init_dmem_data();
+  sh_css_dump_xmem_bin_addr();
+  sh_css_dump_sp_vf_downscale_bits();
+  sh_css_dump_sp_per_frame_data();
+  sh_css_dump_sp_group();
+  sh_css_dump_sp_output();
+  sh_css_dump_host_sp_com();
+  sh_css_dump_sp_isp_started();
+  sh_css_dump_sp_sw_state();
+  sh_css_dump_host_sp_queues_initialized();
+  sh_css_dump_sp_sleep_mode();
+  sh_css_dump_isp_uv_internal_width_vecs();
+  sh_css_dump_isp_vf_output_width_vecs();
+  sh_css_dump_isp_vectors_per_line();
+  sh_css_dump_isp_vectors_per_input_line();
+  sh_css_dump_isp_sdis_horiproj_num();
+  sh_css_dump_isp_sdis_vertproj_num();
+  sh_css_dump_isp_sdis_horicoef_vectors();
+  sh_css_dump_isp_sdis_vertcoef_vectors();
+  sh_css_dump_sp_isp_input_stream_format();
+  sh_css_dump_sp_obarea_start_bq();
+  sh_css_dump_sp_obarea_length_bq();
+  sh_css_dump_sp_preview_thread_id();
+  sh_css_dump_sp_capture_thread_id();
+}
diff --git a/drivers/media/atomisp2/hmm/hmm.c b/drivers/media/atomisp2/hmm/hmm.c
new file mode 100644
index 0000000..f3d76ea
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm.c
@@ -0,0 +1,490 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains entry functions for memory management of ISP driver
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>	/* for kmap */
+#include <linux/io.h>		/* for page_to_phys */
+
+#include "hmm/hmm.h"
+#include "hmm/hmm_pool.h"
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_bo_dev.h"
+
+#include "mmu/isp_mmu.h"
+
+#include "mmu/sh_mmu_mrfld.h"
+#include "mmu/sh_mmu_mfld.h"
+
+#include "atomisp_internal.h"
+#include "asm/cacheflush.h"
+
+#include "atomisp_common.h"
+
+#ifdef USE_SSSE3
+#include <asm/ssse3.h>
+#endif
+
+static struct hmm_bo_device bo_device;
+struct hmm_pool	dynamic_pool;
+struct hmm_pool	reserved_pool;
+static void *dummy_ptr;
+
+int hmm_init(void)
+{
+	int ret;
+
+	if (IS_MRFLD)
+		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld,
+					 ISP_VM_START, ISP_VM_SIZE);
+	else
+		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mfld,
+					 ISP_VM_START, ISP_VM_SIZE);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_device_init failed.\n");
+
+	ret = hmm_pool_register((unsigned int)dypool_enable,
+						HMM_POOL_TYPE_DYNAMIC);
+	if (ret)
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			    "Failed to register dynamic memory pool.\n");
+
+	/*
+	 * As hmm use NULL to indicate invalid ISP virtual address,
+	 * and ISP_VM_START is defined to 0 too, so we allocate
+	 * one piece of dummy memory, which should return value 0,
+	 * at the beginning, to avoid hmm_alloc return 0 in the
+	 * further allocation.
+	 */
+	dummy_ptr = hmm_alloc(1, HMM_BO_PRIVATE, 0, 0, HMM_UNCACHED, NULL);
+	return ret;
+}
+
+int hmm_get_mmu_base_addr(void)
+{
+	if (sh_mmu_mrfld.get_pd_base == NULL) {
+		v4l2_err(&atomisp_dev,
+			 "get mmu base address failed.\n");
+		return -EINVAL;
+	}
+	return sh_mmu_mrfld.get_pd_base(&bo_device.mmu,
+					bo_device.mmu.base_address);
+}
+
+void hmm_cleanup(void)
+{
+	/*
+	 * free dummy memory first
+	 */
+	hmm_free(dummy_ptr);
+	dummy_ptr = NULL;
+
+	hmm_bo_device_exit(&bo_device);
+	hmm_pool_unregister(HMM_POOL_TYPE_DYNAMIC);
+}
+
+void *hmm_alloc(size_t bytes, enum hmm_bo_type type,
+		int from_highmem, unsigned int userptr, bool cached, void *priv)
+{
+	unsigned int pgnr;
+	struct hmm_buffer_object *bo;
+	int ret;
+
+	/*Get page number from size*/
+	pgnr = size_to_pgnr_ceil(bytes);
+
+	/*Buffer object structure init*/
+	bo = hmm_bo_create(&bo_device, pgnr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev, "hmm_bo_create failed.\n");
+		goto create_bo_err;
+	}
+
+	/*Allocate virtual address in ISP virtual space*/
+	ret = hmm_bo_alloc_vm(bo);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_alloc_vm failed.\n");
+		goto alloc_vm_err;
+	}
+
+	/*Allocate pages for memory*/
+	ret = hmm_bo_alloc_pages(bo, type, from_highmem, userptr, cached, priv);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_alloc_pages failed.\n");
+		goto alloc_page_err;
+	}
+
+	/*Combind the virtual address and pages togather*/
+	ret = hmm_bo_bind(bo);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_bo_bind failed.\n");
+		goto bind_err;
+	}
+	return (void *)bo->vm_node->start;
+
+bind_err:
+	hmm_bo_free_pages(bo);
+alloc_page_err:
+	hmm_bo_free_vm(bo);
+alloc_vm_err:
+	hmm_bo_unref(bo);
+create_bo_err:
+	return NULL;
+}
+
+void hmm_free(void *virt)
+{
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, (unsigned int)virt);
+
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", (unsigned int)virt);
+		return;
+	}
+
+	hmm_bo_unbind(bo);
+
+	hmm_bo_free_pages(bo);
+
+	hmm_bo_free_vm(bo);
+
+	hmm_bo_unref(bo);
+}
+
+static inline int hmm_check_bo(struct hmm_buffer_object *bo, unsigned int ptr)
+{
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object contains "
+			    "address 0x%x\n", ptr);
+		return -EINVAL;
+	}
+
+	if (!hmm_bo_page_allocated(bo)) {
+		v4l2_err(&atomisp_dev,
+			    "buffer object has no page allocated.\n");
+		return -EINVAL;
+	}
+
+	if (!hmm_bo_vm_allocated(bo)) {
+		v4l2_err(&atomisp_dev,
+			    "buffer object has no virtual address"
+			    " space allocated.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*Read function in ISP memory management*/
+static int load_and_flush(void *virt, void *data, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *src, *des;
+	int ret;
+
+	ptr = (unsigned int)virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	des = (char *)data;
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		src = (char *)kmap(bo->page_obj[idx].page);
+		if (!src) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+
+		src += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;	/* update ptr for next loop */
+
+		if (des) {
+
+#ifdef USE_SSSE3
+			_ssse3_memcpy(des, src, len);
+#else
+			memcpy(des, src, len);
+#endif
+			des += len;
+		}
+
+		clflush_cache_range(src, len);
+
+		kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*Read function in ISP memory management*/
+int hmm_load(void *virt, void *data, unsigned int bytes)
+{
+	if (!data) {
+		v4l2_err(&atomisp_dev,
+			 "hmm_load NULL argument\n");
+		return -EINVAL;
+	}
+	return load_and_flush(virt, data, bytes);
+}
+
+/*Flush hmm data from the data cache*/
+int hmm_flush(void *virt, unsigned int bytes)
+{
+	return load_and_flush(virt, NULL, bytes);
+}
+
+/*Write function in ISP memory management*/
+int hmm_store(void *virt, const void *data, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *src, *des;
+	int ret;
+
+	ptr = (unsigned int)virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	src = (char *)data;
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		if (in_atomic())
+			des = (char *)kmap_atomic(bo->page_obj[idx].page);
+		else
+			des = (char *)kmap(bo->page_obj[idx].page);
+
+		if (!des) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+
+		des += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;
+
+#ifdef USE_SSSE3
+		_ssse3_memcpy(des, src, len);
+#else
+		memcpy(des, src, len);
+#endif
+		src += len;
+
+		clflush_cache_range(des, len);
+
+		if (in_atomic())
+			/*
+			 * Note: kunmap_atomic requires return addr from
+			 * kmap_atomic, not the page. See linux/highmem.h
+			 */
+			kunmap_atomic(des - offset);
+		else
+			kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*memset function in ISP memory management*/
+int hmm_set(void *virt, int c, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *des;
+	int ret;
+
+	ptr = (unsigned int)virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		des = (char *)kmap(bo->page_obj[idx].page);
+		if (!des) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+		des += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;
+
+		memset(des, c, len);
+
+		clflush_cache_range(des, len);
+
+		kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*Virtual address to physical address convert*/
+phys_addr_t hmm_virt_to_phys(void *virt)
+{
+	unsigned int ptr = (unsigned int)virt;
+	unsigned int idx, offset;
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object contains "
+			    "address 0x%x\n", ptr);
+		return -1;
+	}
+
+	idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+	offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+	return page_to_phys(bo->page_obj[idx].page) + offset;
+}
+
+int hmm_mmap(struct vm_area_struct *vma, void *virt)
+{
+	unsigned int ptr = (unsigned int)virt;
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, ptr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", (unsigned int)virt);
+		return -EINVAL;
+	}
+
+	return hmm_bo_mmap(vma, bo);
+}
+
+/*Map ISP virtual address into IA virtual address*/
+void *hmm_vmap(void *virt)
+{
+	unsigned int ptr = (unsigned int)virt;
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, ptr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", (unsigned int)virt);
+		return NULL;
+	}
+
+	return hmm_bo_vmap(bo);
+}
+
+int hmm_pool_register(unsigned int pool_size,
+			enum hmm_pool_type pool_type)
+{
+	switch (pool_type) {
+	case HMM_POOL_TYPE_RESERVED:
+		reserved_pool.pops = &reserved_pops;
+		return reserved_pool.pops->pool_init(&reserved_pool.pool_info,
+							pool_size);
+	case HMM_POOL_TYPE_DYNAMIC:
+		dynamic_pool.pops = &dynamic_pops;
+		return dynamic_pool.pops->pool_init(&dynamic_pool.pool_info,
+							pool_size);
+	default:
+		v4l2_err(&atomisp_dev, "invalid pool type.\n");
+		return -EINVAL;
+	}
+}
+
+void hmm_pool_unregister(enum hmm_pool_type pool_type)
+{
+	switch (pool_type) {
+	case HMM_POOL_TYPE_RESERVED:
+		if (reserved_pool.pops->pool_exit)
+			reserved_pool.pops->pool_exit(&reserved_pool.pool_info);
+		break;
+	case HMM_POOL_TYPE_DYNAMIC:
+		if (dynamic_pool.pops->pool_exit)
+			dynamic_pool.pops->pool_exit(&dynamic_pool.pool_info);
+		break;
+	default:
+		v4l2_err(&atomisp_dev, "invalid pool type.\n");
+		break;
+	}
+
+	return;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_bo.c b/drivers/media/atomisp2/hmm/hmm_bo.c
new file mode 100644
index 0000000..733ae79
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_bo.c
@@ -0,0 +1,1268 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for buffer object structure management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>		/* for GFP_ATOMIC */
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/hugetlb.h>
+#include <linux/highmem.h>
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <asm/cacheflush.h>
+#include <linux/io.h>
+#include <asm/current.h>
+#include <linux/sched.h>
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_pool.h"
+#include "hmm/hmm_bo_dev.h"
+#include "hmm/hmm_common.h"
+#include "atomisp_internal.h"
+#include <linux/scatterlist.h>
+#ifdef CONFIG_ION
+#include <linux/ion.h>
+#endif
+
+static unsigned int order_to_nr(unsigned int order)
+{
+	return 1U << order;
+}
+
+static unsigned int nr_to_order_bottom(unsigned int nr)
+{
+	return fls(nr) - 1;
+}
+
+static void free_bo_internal(struct hmm_buffer_object *bo)
+{
+	kfree(bo);
+}
+
+/*
+ * use these functions to dynamically alloc hmm_buffer_object.
+ * hmm_bo_init will called for that allocated buffer object, and
+ * the release callback is set to kfree.
+ */
+struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev, int pgnr)
+{
+	struct hmm_buffer_object *bo;
+	int ret;
+
+	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
+	if (!bo) {
+		v4l2_err(&atomisp_dev, "out of memory for bo\n");
+		return NULL;
+	}
+
+	ret = hmm_bo_init(bdev, bo, pgnr, free_bo_internal);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_bo_init failed\n");
+		kfree(bo);
+		return NULL;
+	}
+
+	return bo;
+}
+
+/*
+ * use this function to initialize pre-allocated hmm_buffer_object.
+ * as hmm_buffer_object may be used as an embedded object in an upper
+ * level object, a release callback must be provided. if it is
+ * embedded in upper level object, set release call back to release
+ * function of that object. if no upper level object, set release
+ * callback to NULL.
+ *
+ * bo->kref is inited to 1.
+ */
+int hmm_bo_init(struct hmm_bo_device *bdev,
+		struct hmm_buffer_object *bo,
+		unsigned int pgnr, void (*release) (struct hmm_buffer_object *))
+{
+	unsigned long flags;
+
+	if (bdev == NULL) {
+		v4l2_warn(&atomisp_dev,
+			    "NULL hmm_bo_device.\n");
+		return -EINVAL;
+	}
+
+	/* hmm_bo_device must be already inited */
+	var_equal_return(hmm_bo_device_inited(bdev), 0, -EINVAL,
+			   "hmm_bo_device not inited yet.\n");
+
+	/* prevent zero size buffer object */
+	if (pgnr == 0) {
+		v4l2_err(&atomisp_dev,
+			    "0 size buffer is not allowed.\n");
+		return -EINVAL;
+	}
+
+	memset(bo, 0, sizeof(*bo));
+
+	kref_init(&bo->kref);
+
+	mutex_init(&bo->mutex);
+
+	INIT_LIST_HEAD(&bo->list);
+
+	bo->pgnr = pgnr;
+	bo->bdev = bdev;
+
+	bo->release = release;
+
+	if (!bo->release)
+		v4l2_warn(&atomisp_dev,
+			    "no release callback specified.\n");
+
+	/*
+	 * add to active_bo_list
+	 */
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_add_tail(&bo->list, &bdev->active_bo_list);
+	bo->status |= HMM_BO_ACTIVE;
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return 0;
+}
+
+static void hmm_bo_release(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+	unsigned long flags;
+
+	check_bo_null_return_void(bo);
+
+	bdev = bo->bdev;
+
+	/*
+	 * remove it from buffer device's buffer object list.
+	 */
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	/*
+	 * FIX ME:
+	 *
+	 * how to destroy the bo when it is stilled MMAPED?
+	 *
+	 * ideally, this will not happened as hmm_bo_release
+	 * will only be called when kref reaches 0, and in mmap
+	 * operation the hmm_bo_ref will eventually be called.
+	 * so, if this happened, something goes wrong.
+	 */
+	if (bo->status & HMM_BO_MMAPED) {
+		v4l2_err(&atomisp_dev,
+			     "destroy bo which is MMAPED, do nothing\n");
+		goto err;
+	}
+
+	if (bo->status & HMM_BO_BINDED) {
+		v4l2_warn(&atomisp_dev,
+			     "the bo is still binded, unbind it first...\n");
+		hmm_bo_unbind(bo);
+	}
+	if (bo->status & HMM_BO_PAGE_ALLOCED) {
+		v4l2_warn(&atomisp_dev,
+			     "the pages is not freed, free pages first\n");
+		hmm_bo_free_pages(bo);
+	}
+	if (bo->status & HMM_BO_VM_ALLOCED) {
+		v4l2_warn(&atomisp_dev,
+			     "the vm is still not freed, free vm first...\n");
+		hmm_bo_free_vm(bo);
+	}
+
+	if (bo->release)
+		bo->release(bo);
+err:
+	return;
+}
+
+int hmm_bo_activated(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return(bo, 0);
+
+	return bo->status & HMM_BO_ACTIVE;
+}
+
+void hmm_bo_unactivate(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+	unsigned long flags;
+
+	check_bo_null_return_void(bo);
+
+	check_bo_status_no_goto(bo, HMM_BO_ACTIVE, status_err);
+
+	bdev = bo->bdev;
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_del(&bo->list);
+	list_add_tail(&bo->list, &bdev->free_bo_list);
+	bo->status &= (~HMM_BO_ACTIVE);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer object already unactivated.\n");
+	return;
+}
+
+int hmm_bo_alloc_vm(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_no_goto(bo, HMM_BO_VM_ALLOCED, status_err);
+
+	bdev = bo->bdev;
+	bo->vm_node = hmm_vm_alloc_node(&bdev->vaddr_space, bo->pgnr);
+	if (unlikely(!bo->vm_node)) {
+		v4l2_err(&atomisp_dev,
+				"hmm_vm_alloc_node err.\n");
+		goto null_vm;
+	}
+
+	bo->status |= HMM_BO_VM_ALLOCED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+null_vm:
+	mutex_unlock(&bo->mutex);
+	return -ENOMEM;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object already has vm allocated.\n");
+	return -EINVAL;
+}
+
+void hmm_bo_free_vm(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_VM_ALLOCED, status_err);
+
+	bdev = bo->bdev;
+
+	bo->status &= (~HMM_BO_VM_ALLOCED);
+	hmm_vm_free_node(bo->vm_node);
+	bo->vm_node = NULL;
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object has no vm allocated.\n");
+}
+
+int hmm_bo_vm_allocated(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	ret = (bo->status & HMM_BO_VM_ALLOCED);
+
+	return ret;
+}
+
+static void free_private_bo_pages(struct hmm_buffer_object *bo,
+				  struct hmm_pool *dypool,
+				  struct hmm_pool *repool, int free_pgnr)
+{
+	int i, ret;
+
+	for (i = 0; i < free_pgnr; i++) {
+		switch (bo->page_obj[i].type) {
+		case HMM_PAGE_TYPE_RESERVED:
+			if (repool->pops->pool_free_pages)
+				repool->pops->pool_free_pages(repool->pool_info,
+							&bo->page_obj[i]);
+			break;
+		case HMM_PAGE_TYPE_DYNAMIC:
+			if (dypool->pops->pool_free_pages)
+				dypool->pops->pool_free_pages(dypool->pool_info,
+							&bo->page_obj[i]);
+			break;
+		/*
+		 * HMM_PAGE_TYPE_GENERAL indicates that pages are from system
+		 * memory, so when free them, they should be put into dynamic
+		 * pool.
+		 */
+		case HMM_PAGE_TYPE_GENERAL:
+			if (dypool->pops->pool_inited
+			    && dypool->pops->pool_inited(dypool->pool_info)) {
+				if (dypool->pops->pool_free_pages)
+					dypool->pops->pool_free_pages(
+							      dypool->pool_info,
+							      &bo->page_obj[i]);
+				break;
+			}
+
+			/*
+			 * if dynamic memory pool doesn't exist, need to free
+			 * pages to system directly.
+			 */
+		default:
+			ret = set_pages_wb(bo->page_obj[i].page, 1);
+			if (ret)
+				v4l2_err(&atomisp_dev,
+						"set page to WB err ...\n");
+			__free_pages(bo->page_obj[i].page, 0);
+			break;
+		}
+	}
+
+	return;
+}
+
+/*Allocate pages which will be used only by ISP*/
+static int alloc_private_pages(struct hmm_buffer_object *bo, int from_highmem,
+				bool cached, struct hmm_pool *dypool,
+				struct hmm_pool *repool)
+{
+	int ret;
+	unsigned int pgnr, order, blk_pgnr, alloc_pgnr;
+	struct page *pages;
+	gfp_t gfp = GFP_NOWAIT | __GFP_NOWARN; /* REVISIT: need __GFP_FS too? */
+	int i, j;
+	int failure_number = 0;
+	bool reduce_order = false;
+	bool lack_mem = true;
+
+	if (from_highmem)
+		gfp |= __GFP_HIGHMEM;
+
+	pgnr = bo->pgnr;
+
+	bo->page_obj = atomisp_kernel_malloc(
+				sizeof(struct hmm_page_object) * pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj\n");
+		return -ENOMEM;
+	}
+
+	i = 0;
+	alloc_pgnr = 0;
+
+	/*
+	 * get physical pages from dynamic pages pool.
+	 */
+	if (dypool != NULL && dypool->pops != NULL && dypool->pops->pool_alloc_pages) {
+		alloc_pgnr = dypool->pops->pool_alloc_pages(dypool->pool_info,
+							bo->page_obj, pgnr,
+							cached);
+		if (alloc_pgnr == pgnr)
+			return 0;
+	}
+
+	pgnr -= alloc_pgnr;
+	i += alloc_pgnr;
+
+	/*
+	 * get physical pages from reserved pages pool for atomisp.
+	 */
+	if (repool != NULL && repool->pops != NULL && repool->pops->pool_alloc_pages) {
+		alloc_pgnr = repool->pops->pool_alloc_pages(repool->pool_info,
+							&bo->page_obj[i], pgnr,
+							cached);
+		if (alloc_pgnr == pgnr)
+			return 0;
+	}
+
+	pgnr -= alloc_pgnr;
+	i += alloc_pgnr;
+
+	while (pgnr) {
+		order = nr_to_order_bottom(pgnr);
+		/*
+		 * if be short of memory, we will set order to 0
+		 * everytime.
+		 */
+		if (lack_mem)
+			order = HMM_MIN_ORDER;
+		else if (order > HMM_MAX_ORDER)
+			order = HMM_MAX_ORDER;
+retry:
+		/*
+		 * When order > HMM_MIN_ORDER, for performance reasons we don't
+		 * want alloc_pages() to sleep. In case it fails and fallbacks
+		 * to HMM_MIN_ORDER or in case the requested order is originally
+		 * the minimum value, we can allow alloc_pages() to sleep for
+		 * robustness purpose.
+		 *
+		 * REVISIT: why __GFP_FS is necessary?
+		 */
+		if (order == HMM_MIN_ORDER) {
+			gfp &= ~GFP_NOWAIT;
+			gfp |= __GFP_WAIT | __GFP_FS;
+		}
+
+		pages = alloc_pages(gfp, order);
+		if (unlikely(!pages)) {
+			/*
+			 * in low memory case, if allocation page fails,
+			 * we turn to try if order=0 allocation could
+			 * succeed. if order=0 fails too, that means there is
+			 * no memory left.
+			 */
+			if (order == HMM_MIN_ORDER) {
+				v4l2_err(&atomisp_dev,
+					 "%s: cannot allocate pages\n",
+					 __func__);
+				goto cleanup;
+			}
+			order = HMM_MIN_ORDER;
+			failure_number++;
+			reduce_order = true;
+			/*
+			 * if fail two times continuously, we think be short
+			 * of memory now.
+			 */
+			if (failure_number == 2) {
+				lack_mem = true;
+				failure_number = 0;
+			}
+			goto retry;
+		} else {
+			blk_pgnr = order_to_nr(order);
+
+			if (!cached) {
+				/*
+				 * set memory to uncacheable -- UC_MINUS
+				 */
+				ret = set_pages_uc(pages, blk_pgnr);
+				if (ret) {
+					v4l2_err(&atomisp_dev,
+						     "set page uncacheable"
+							"failed.\n");
+
+					__free_pages(pages, order);
+
+					goto cleanup;
+				}
+			}
+
+			for (j = 0; j < blk_pgnr; j++) {
+				bo->page_obj[i].page = pages + j;
+				bo->page_obj[i++].type = HMM_PAGE_TYPE_GENERAL;
+			}
+
+			pgnr -= blk_pgnr;
+
+			/*
+			 * if order is not reduced this time, clear
+			 * failure_number.
+			 */
+			if (reduce_order)
+				reduce_order = false;
+			else
+				failure_number = 0;
+		}
+	}
+
+	return 0;
+cleanup:
+	alloc_pgnr = i;
+	free_private_bo_pages(bo, dypool, repool, alloc_pgnr);
+
+	atomisp_kernel_free(bo->page_obj);
+
+	return -ENOMEM;
+}
+
+static void free_private_pages(struct hmm_buffer_object *bo,
+				struct hmm_pool *dypool,
+				struct hmm_pool *repool)
+{
+	free_private_bo_pages(bo, dypool, repool, bo->pgnr);
+
+	atomisp_kernel_free(bo->page_obj);
+}
+
+/*
+ * Hacked from kernel function __get_user_pages in mm/memory.c
+ *
+ * Handle buffers allocated by other kernel space driver and mmaped into user
+ * space, function Ignore the VM_PFNMAP and VM_IO flag in VMA structure
+ *
+ * Get physical pages from user space virtual address and update into page list
+ */
+static int __get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
+			      unsigned long start, int nr_pages,
+			      unsigned int gup_flags, struct page **pages,
+			      struct vm_area_struct **vmas)
+{
+	int i, ret;
+	unsigned long vm_flags;
+
+	if (nr_pages <= 0)
+		return 0;
+
+	VM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));
+
+	/*
+	 * Require read or write permissions.
+	 * If FOLL_FORCE is set, we only require the "MAY" flags.
+	 */
+	vm_flags  = (gup_flags & FOLL_WRITE) ?
+			(VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);
+	vm_flags &= (gup_flags & FOLL_FORCE) ?
+			(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
+	i = 0;
+
+	do {
+		struct vm_area_struct *vma;
+
+		vma = find_vma(mm, start);
+		if (!vma) {
+			v4l2_err(&atomisp_dev, "find_vma failed\n");
+			return i ? : -EFAULT;
+		}
+
+		if (is_vm_hugetlb_page(vma)) {
+			/*
+			i = follow_hugetlb_page(mm, vma, pages, vmas,
+					&start, &nr_pages, i, gup_flags);
+			*/
+			continue;
+		}
+
+		do {
+			struct page *page;
+			unsigned long pfn;
+
+			/*
+			 * If we have a pending SIGKILL, don't keep faulting
+			 * pages and potentially allocating memory.
+			 */
+			if (unlikely(fatal_signal_pending(current))) {
+				v4l2_err(&atomisp_dev,
+					"fatal_signal_pending in %s\n",
+					__func__);
+				return i ? i : -ERESTARTSYS;
+			}
+
+			ret = follow_pfn(vma, start, &pfn);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"follow_pfn() failed\n");
+				return i ? : -EFAULT;
+			}
+
+			page = pfn_to_page(pfn);
+			if (IS_ERR(page))
+				return i ? i : PTR_ERR(page);
+			if (pages) {
+				pages[i] = page;
+
+				flush_anon_page(vma, page, start);
+				flush_dcache_page(page);
+			}
+			if (vmas)
+				vmas[i] = vma;
+			i++;
+			start += PAGE_SIZE;
+			nr_pages--;
+		} while (nr_pages && start < vma->vm_end);
+	} while (nr_pages);
+	return i;
+}
+
+static int get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
+		     unsigned long start, int nr_pages, int write, int force,
+		     struct page **pages, struct vm_area_struct **vmas)
+{
+	int flags = FOLL_TOUCH;
+
+	if (pages)
+		flags |= FOLL_GET;
+	if (write)
+		flags |= FOLL_WRITE;
+	if (force)
+		flags |= FOLL_FORCE;
+
+	return __get_pfnmap_pages(tsk, mm, start, nr_pages, flags, pages, vmas);
+}
+
+static int alloc_dma_pages(struct hmm_buffer_object *bo, struct sg_table *sgt) {
+	struct scatterlist *tmp;
+	int ret, page_nr = 0;
+	if (sgt == NULL) {
+		return -EINVAL;
+	}
+
+	bo->page_obj = atomisp_kernel_malloc(
+			sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		return -ENOMEM;
+	}
+	tmp = sgt->sgl;
+
+	do {
+		bo->page_obj[page_nr++].page = sg_page(tmp);
+		tmp = sg_next(tmp);
+	} while (tmp && (page_nr < bo->pgnr));
+
+	if (page_nr != bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+			 "get_dma_pages err: bo->pgnr = %d, "
+			 "pgnr actually pinned = %d.\n",
+			 bo->pgnr, page_nr);
+		ret = -EINVAL;
+		goto error;
+	}
+	
+	return 0;
+
+error:
+	atomisp_kernel_free(bo->page_obj);
+	return ret;
+}
+
+#ifdef CONFIG_ION
+static int alloc_ion_pages(struct hmm_buffer_object *bo,
+			     unsigned int shared_fd)
+{
+	struct scatterlist *tmp;
+	int ret, page_nr = 0;
+
+	bo->page_obj = atomisp_kernel_malloc(
+			sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		return -ENOMEM;
+	}
+
+	bo->ihandle = ion_import_fd(bo->bdev->iclient, shared_fd);
+	if (IS_ERR_OR_NULL(bo->ihandle)) {
+		v4l2_err(&atomisp_dev, "invalid shared fd to ion.\n");
+		ret = PTR_ERR(bo->ihandle);
+		if (!bo->ihandle)
+			ret = -EINVAL;
+		goto error;
+	}
+
+	tmp = ion_map_dma(bo->bdev->iclient, bo->ihandle);
+	if (IS_ERR_OR_NULL(tmp)) {
+		v4l2_err(&atomisp_dev, "ion map_dma error.\n");
+		ret = PTR_ERR(tmp);
+		if (!tmp)
+			ret = -EINVAL;
+		goto error;
+	}
+
+	do {
+		bo->page_obj[page_nr++].page = sg_page(tmp);
+		tmp = sg_next(tmp);
+	} while (tmp && (page_nr < bo->pgnr));
+
+	if (page_nr != bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+			 "get_ion_pages err: bo->pgnr = %d, "
+			 "pgnr actually pinned = %d.\n",
+			 bo->pgnr, page_nr);
+		ret = -EINVAL;
+		goto error_unmap;
+	}
+
+	return 0;
+error_unmap:
+	ion_unmap_dma(bo->bdev->iclient, bo->ihandle);
+error:
+	atomisp_kernel_free(bo->page_obj);
+	return ret;
+
+
+}
+#endif
+/*
+ * Convert user space virtual address into pages list
+ */
+static int alloc_user_pages(struct hmm_buffer_object *bo,
+			      unsigned int userptr, bool cached)
+{
+	int page_nr;
+	int i;
+	struct vm_area_struct *vma;
+	struct page **pages;
+
+	pages = atomisp_kernel_malloc(sizeof(struct page *) * bo->pgnr);
+	if (unlikely(!pages)) {
+		v4l2_err(&atomisp_dev, "out of memory for pages...\n");
+		return -ENOMEM;
+	}
+
+	bo->page_obj = atomisp_kernel_malloc(
+				sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		atomisp_kernel_free(pages);
+		return -ENOMEM;
+	}
+
+	mutex_unlock(&bo->mutex);
+	down_read(&current->mm->mmap_sem);
+	vma = find_vma(current->mm, userptr);
+	up_read(&current->mm->mmap_sem);
+	if (vma == NULL) {
+		v4l2_err(&atomisp_dev, "find_vma failed\n");
+		atomisp_kernel_free(bo->page_obj);
+		atomisp_kernel_free(pages);
+		return -EFAULT;
+	}
+	mutex_lock(&bo->mutex);
+	/*
+	 * Handle frame buffer allocated in other kerenl space driver
+	 * and map to user space
+	 */
+	if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {
+		page_nr = get_pfnmap_pages(current, current->mm,
+					   (unsigned long)userptr,
+					   (int)(bo->pgnr), 1, 0,
+					   pages, NULL);
+		bo->mem_type = HMM_BO_MEM_TYPE_PFN;
+	} else {
+		/*Handle frame buffer allocated in user space*/
+		mutex_unlock(&bo->mutex);
+		down_read(&current->mm->mmap_sem);
+		page_nr = get_user_pages(current, current->mm,
+					 (unsigned long)userptr,
+					 (int)(bo->pgnr), 1, 0, pages,
+					 NULL);
+		up_read(&current->mm->mmap_sem);
+		mutex_lock(&bo->mutex);
+		bo->mem_type = HMM_BO_MEM_TYPE_USER;
+	}
+
+	/* can be written by caller, not forced */
+	if (page_nr != bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+				"get_user_pages err: bo->pgnr = %d, "
+				"pgnr actually pinned = %d.\n",
+				bo->pgnr, page_nr);
+		goto out_of_mem;
+	}
+
+	for (i = 0; i < bo->pgnr; i++) {
+		bo->page_obj[i].page = pages[i];
+		bo->page_obj[i].type = HMM_PAGE_TYPE_GENERAL;
+	}
+
+	atomisp_kernel_free(pages);
+
+	return 0;
+
+out_of_mem:
+	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
+		for (i = 0; i < page_nr; i++)
+			put_page(pages[i]);
+	atomisp_kernel_free(pages);
+	atomisp_kernel_free(bo->page_obj);
+
+	return -ENOMEM;
+}
+#ifdef CONFIG_ION
+static void free_ion_pages(struct hmm_buffer_object *bo)
+{
+	atomisp_kernel_free(bo->page_obj);
+	ion_unmap_dma(bo->bdev->iclient, bo->ihandle);
+}
+#endif
+
+static void free_dma_pages(struct hmm_buffer_object *bo)
+{
+	atomisp_kernel_free(bo->page_obj);
+}
+
+static void free_user_pages(struct hmm_buffer_object *bo)
+{
+	int i;
+
+	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
+		for (i = 0; i < bo->pgnr; i++)
+			put_page(bo->page_obj[i].page);
+
+	atomisp_kernel_free(bo->page_obj);
+}
+
+/*
+ * allocate/free physical pages for the bo.
+ *
+ * type indicate where are the pages from. currently we have 3 types
+ * of memory: HMM_BO_PRIVATE, HMM_BO_USER, HMM_BO_SHARE.
+ *
+ * from_highmem is only valid when type is HMM_BO_PRIVATE, it will
+ * try to alloc memory from highmem if from_highmem is set.
+ *
+ * userptr is only valid when type is HMM_BO_USER, it indicates
+ * the start address from user space task.
+ *
+ * from_highmem and userptr will both be ignored when type is
+ * HMM_BO_SHARE.
+ */
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
+		       enum hmm_bo_type type, int from_highmem,
+		       unsigned int userptr, bool cached, void *priv)
+{
+	int ret;
+	struct sg_table *sgt = priv;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_no_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	if (type == HMM_BO_PRIVATE)
+		ret = alloc_private_pages(bo, from_highmem,
+				cached, &dynamic_pool, &reserved_pool);
+	else if (type == HMM_BO_USER)
+		ret = alloc_user_pages(bo, userptr, cached);
+	else if (type == HMM_BO_DMA)
+		ret = alloc_dma_pages(bo, sgt);
+#ifdef CONFIG_ION
+	else if (type == HMM_BO_ION)
+		/*
+		 * TODO:
+		 * Add cache flag when ION support it
+		 */
+		ret = alloc_ion_pages(bo, userptr);
+#endif
+	else {
+		v4l2_err(&atomisp_dev, "invalid buffer type.\n");
+		ret = -EINVAL;
+	}
+
+	if (ret)
+		goto alloc_err;
+
+	bo->type = type;
+
+	bo->status |= HMM_BO_PAGE_ALLOCED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+alloc_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev, "alloc pages err...\n");
+	return ret;
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object has already page allocated.\n");
+	return -EINVAL;
+}
+
+/*
+ * free physical pages of the bo.
+ */
+void hmm_bo_free_pages(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err2);
+
+	/* clear the flag anyway. */
+	bo->status &= (~HMM_BO_PAGE_ALLOCED);
+
+	if (bo->type == HMM_BO_PRIVATE)
+		free_private_pages(bo, &dynamic_pool, &reserved_pool);
+	else if (bo->type == HMM_BO_USER)
+		free_user_pages(bo);
+	else if (bo->type == HMM_BO_DMA)
+		free_dma_pages(bo);
+#ifdef CONFIG_ION
+	else if (bo->type == HMM_BO_ION)
+		free_ion_pages(bo);
+#endif
+	else
+		v4l2_err(&atomisp_dev, "invalid buffer type.\n");
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err2:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object not page allocated yet.\n");
+}
+
+int hmm_bo_page_allocated(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	ret = bo->status & HMM_BO_PAGE_ALLOCED;
+
+	return ret;
+}
+
+/*
+ * get physical page info of the bo.
+ */
+int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
+			 struct hmm_page_object **page_obj, int *pgnr)
+{
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	*page_obj = bo->page_obj;
+	*pgnr = bo->pgnr;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer object not page allocated yet.\n");
+	mutex_unlock(&bo->mutex);
+	return -EINVAL;
+}
+
+/*
+ * bind the physical pages to a virtual address space.
+ */
+int hmm_bo_bind(struct hmm_buffer_object *bo)
+{
+	int ret;
+	unsigned int virt;
+	struct hmm_bo_device *bdev;
+	unsigned int i;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo,
+				   HMM_BO_PAGE_ALLOCED | HMM_BO_VM_ALLOCED,
+				   status_err1);
+
+	check_bo_status_no_goto(bo, HMM_BO_BINDED, status_err2);
+
+	bdev = bo->bdev;
+
+	virt = bo->vm_node->start;
+
+	for (i = 0; i < bo->pgnr; i++) {
+		ret =
+		    isp_mmu_map(&bdev->mmu, virt,
+				page_to_phys(bo->page_obj[i].page), 1);
+		if (ret)
+			goto map_err;
+		virt += (1 << PAGE_SHIFT);
+	}
+
+	/*
+	 * flush TBL here.
+	 *
+	 * theoretically, we donot need to flush TLB as we didnot change
+	 * any existed address mappings, but for Silicon Hive's MMU, its
+	 * really a bug here. I guess when fetching PTEs (page table entity)
+	 * to TLB, its MMU will fetch additional INVALID PTEs automatically
+	 * for performance issue. EX, we only set up 1 page address mapping,
+	 * meaning updating 1 PTE, but the MMU fetches 4 PTE at one time,
+	 * so the additional 3 PTEs are invalid.
+	 */
+#ifdef CSS_2
+	if (bo->vm_node->start != 0x0)
+#endif
+		isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
+					(bo->pgnr << PAGE_SHIFT));
+
+	bo->status |= HMM_BO_BINDED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+map_err:
+	/* unbind the physical pages with related virtual address space */
+	virt = bo->vm_node->start;
+	for ( ; i > 0; i--) {
+		isp_mmu_unmap(&bdev->mmu, virt, 1);
+		virt += pgnr_to_size(1);
+	}
+
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"setup MMU address mapping failed.\n");
+	return ret;
+
+status_err2:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev, "buffer object already binded.\n");
+	return -EINVAL;
+status_err1:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+		     "buffer object vm_node or page not allocated.\n");
+	return -EINVAL;
+}
+
+/*
+ * unbind the physical pages with related virtual address space.
+ */
+void hmm_bo_unbind(struct hmm_buffer_object *bo)
+{
+	unsigned int virt;
+	struct hmm_bo_device *bdev;
+	unsigned int i;
+
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo,
+				   HMM_BO_PAGE_ALLOCED |
+				   HMM_BO_VM_ALLOCED |
+				   HMM_BO_BINDED, status_err);
+
+	bdev = bo->bdev;
+
+	virt = bo->vm_node->start;
+
+	for (i = 0; i < bo->pgnr; i++) {
+		isp_mmu_unmap(&bdev->mmu, virt, 1);
+		virt += pgnr_to_size(1);
+	}
+
+	/*
+	 * flush TLB as the address mapping has been removed and
+	 * related TLBs should be invalidated.
+	 */
+#ifdef CSS_2
+	if (bo->vm_node->start != 0x0)
+#endif
+		isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
+					(bo->pgnr << PAGE_SHIFT));
+
+	bo->status &= (~HMM_BO_BINDED);
+
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+		     "buffer vm or page not allocated or not binded yet.\n");
+}
+
+int hmm_bo_binded(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	mutex_lock(&bo->mutex);
+
+	ret = bo->status & HMM_BO_BINDED;
+
+	mutex_unlock(&bo->mutex);
+
+	return ret;
+}
+
+void *hmm_bo_vmap(struct hmm_buffer_object *bo)
+{
+	struct page **pages;
+	void *vmap_addr;
+	int i;
+
+	check_bo_null_return(bo, NULL);
+
+	pages = atomisp_kernel_malloc(sizeof(*pages) * bo->pgnr);
+	if (unlikely(!pages)) {
+		v4l2_err(&atomisp_dev, "out of memory for pages...\n");
+		return NULL;
+	}
+
+	for (i = 0; i < bo->pgnr; i++)
+		pages[i] = bo->page_obj[i].page;
+
+	vmap_addr = vmap(pages, bo->pgnr, VM_MAP, PAGE_KERNEL_NOCACHE);
+
+	atomisp_kernel_free(pages);
+
+	return vmap_addr;
+}
+
+void hmm_bo_ref(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	kref_get(&bo->kref);
+}
+
+static void kref_hmm_bo_release(struct kref *kref)
+{
+	if (!kref)
+		return;
+
+	hmm_bo_release(kref_to_hmm_bo(kref));
+}
+
+void hmm_bo_unref(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	kref_put(&bo->kref, kref_hmm_bo_release);
+}
+
+static void hmm_bo_vm_open(struct vm_area_struct *vma)
+{
+	struct hmm_buffer_object *bo =
+	    (struct hmm_buffer_object *)vma->vm_private_data;
+
+	check_bo_null_return_void(bo);
+
+	hmm_bo_ref(bo);
+
+	mutex_lock(&bo->mutex);
+
+	bo->status |= HMM_BO_MMAPED;
+
+	bo->mmap_count++;
+
+	mutex_unlock(&bo->mutex);
+}
+
+static void hmm_bo_vm_close(struct vm_area_struct *vma)
+{
+	struct hmm_buffer_object *bo =
+	    (struct hmm_buffer_object *)vma->vm_private_data;
+
+	check_bo_null_return_void(bo);
+
+	hmm_bo_unref(bo);
+
+	mutex_lock(&bo->mutex);
+
+	bo->mmap_count--;
+
+	if (!bo->mmap_count) {
+		bo->status &= (~HMM_BO_MMAPED);
+		vma->vm_private_data = NULL;
+	}
+
+	mutex_unlock(&bo->mutex);
+}
+
+static const struct vm_operations_struct hmm_bo_vm_ops = {
+	.open = hmm_bo_vm_open,
+	.close = hmm_bo_vm_close,
+};
+
+/*
+ * mmap the bo to user space.
+ */
+int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
+{
+	unsigned int start, end;
+	unsigned int virt;
+	unsigned int pgnr, i;
+	unsigned int pfn;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	pgnr = bo->pgnr;
+	start = vma->vm_start;
+	end = vma->vm_end;
+
+	/*
+	 * check vma's virtual address space size and buffer object's size.
+	 * must be the same.
+	 */
+	if ((start + pgnr_to_size(pgnr)) != end) {
+		v4l2_warn(&atomisp_dev,
+			     "vma's address space size not equal"
+			     " to buffer object's size");
+		return -EINVAL;
+	}
+
+	virt = vma->vm_start;
+	for (i = 0; i < pgnr; i++) {
+		pfn = page_to_pfn(bo->page_obj[i].page);
+		if (remap_pfn_range(vma, virt, pfn, PAGE_SIZE, PAGE_SHARED)) {
+			v4l2_warn(&atomisp_dev,
+					"remap_pfn_range failed:"
+					" virt = 0x%x, pfn = 0x%x,"
+					" mapped_pgnr = %d\n", virt, pfn, 1);
+			return -EINVAL;
+		}
+		virt += PAGE_SIZE;
+	}
+
+	vma->vm_private_data = bo;
+
+	vma->vm_ops = &hmm_bo_vm_ops;
+	vma->vm_flags |= ((VM_DONTEXPAND | VM_DONTDUMP) | VM_IO);
+
+	/*
+	 * call hmm_bo_vm_open explictly.
+	 */
+	hmm_bo_vm_open(vma);
+
+	return 0;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer page not allocated yet.\n");
+	return -EINVAL;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_bo_dev.c b/drivers/media/atomisp2/hmm/hmm_bo_dev.c
new file mode 100644
index 0000000..b2751e4
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_bo_dev.c
@@ -0,0 +1,309 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>
+#include <linux/mm.h>		/* for GFP_ATOMIC */
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+
+#ifdef CONFIG_ION
+#include <linux/ion.h>
+#endif
+
+#include "hmm/hmm_common.h"
+#include "hmm/hmm_bo_dev.h"
+#include "hmm/hmm_bo.h"
+#include "atomisp_internal.h"
+
+/*
+ * hmm_bo_device functions.
+ */
+int hmm_bo_device_init(struct hmm_bo_device *bdev,
+		       struct isp_mmu_client *mmu_driver,
+		       unsigned int vaddr_start, unsigned int size)
+{
+	int ret;
+
+	check_bodev_null_return(bdev, -EINVAL);
+
+	ret = isp_mmu_init(&bdev->mmu, mmu_driver);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "isp_mmu_init failed.\n");
+		goto isp_mmu_init_err;
+	}
+
+	ret = hmm_vm_init(&bdev->vaddr_space, vaddr_start, size);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_vm_init falied. "
+			     "vaddr_start = 0x%x, size = %d\n", vaddr_start,
+			     size);
+		goto vm_init_err;
+	}
+
+	INIT_LIST_HEAD(&bdev->free_bo_list);
+	INIT_LIST_HEAD(&bdev->active_bo_list);
+
+	spin_lock_init(&bdev->list_lock);
+#ifdef CONFIG_ION
+	/*
+	 * TODO:
+	 * ion driver global variable and heap mask
+	 * should be changed when mrfld ion is ready
+	 */
+	if (!mrfld_ion_driver)
+		goto vm_init_err;
+
+	bdev->iclient = ion_client_create(mrfld_ion_driver,
+					  ION_HEAP_TYPE_SYSTEM_CONTIG |
+					  ION_HEAP_TYPE_SYSTEM |
+					  ION_HEAP_TYPE_CARVEOUT,
+					  "atomisp");
+	if (IS_ERR_OR_NULL(bdev->iclient)) {
+		ret = PTR_ERR(bdev->iclient);
+		if (!bdev->iclient)
+			ret = -EINVAL;
+		goto vm_init_err;
+	}
+#endif
+	bdev->flag = HMM_BO_DEVICE_INITED;
+
+	return 0;
+
+vm_init_err:
+	isp_mmu_exit(&bdev->mmu);
+isp_mmu_init_err:
+	return ret;
+}
+
+void hmm_bo_device_exit(struct hmm_bo_device *bdev)
+{
+	check_bodev_null_return_void(bdev);
+
+	/*
+	 * destroy all bos in the bo list, even they are in use.
+	 */
+	if (!list_empty(&bdev->active_bo_list))
+		v4l2_warn(&atomisp_dev,
+			     "there're still activated bo in use. "
+			     "force to free them.\n");
+
+	while (!list_empty(&bdev->active_bo_list))
+		hmm_bo_unref(list_to_hmm_bo(bdev->active_bo_list.next));
+
+	if (!list_empty(&bdev->free_bo_list))
+		v4l2_warn(&atomisp_dev,
+				"there're still bo in free_bo_list. "
+				"force to free them.\n");
+
+	while (!list_empty(&bdev->free_bo_list))
+		hmm_bo_unref(list_to_hmm_bo(bdev->free_bo_list.next));
+
+	isp_mmu_exit(&bdev->mmu);
+	hmm_vm_clean(&bdev->vaddr_space);
+#ifdef CONFIG_ION
+	if (bdev->iclient != NULL)
+		ion_client_destroy(bdev->iclient);
+#endif
+}
+
+int hmm_bo_device_inited(struct hmm_bo_device *bdev)
+{
+	check_bodev_null_return(bdev, -EINVAL);
+
+	return bdev->flag == HMM_BO_DEVICE_INITED;
+}
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_start(struct hmm_bo_device *bdev,
+						     unsigned int vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->active_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (bo->vm_node->start == vaddr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return bo;
+}
+
+static int in_range(unsigned int start, unsigned int size, unsigned int addr)
+{
+	return (start <= addr) && (start + size > addr);
+}
+
+struct hmm_buffer_object *hmm_bo_device_search_in_range(struct hmm_bo_device
+							*bdev,
+							unsigned int vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->active_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (in_range(bo->vm_node->start, bo->vm_node->size, vaddr))
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return bo;
+}
+
+/*
+ * find a buffer object with pgnr pages from free_bo_list and
+ * activate it (remove from free_bo_list and add to
+ * active_bo_list)
+ *
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_get_bo(struct hmm_bo_device *bdev,
+					       unsigned int pgnr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		if (bo->pgnr == pgnr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	list_del(&bo->list);
+	list_add(&bo->list, &bdev->active_bo_list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return bo;
+}
+
+/*
+ * destroy all buffer objects in the free_bo_list.
+ */
+void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev)
+{
+	struct hmm_buffer_object *bo, *tmp;
+	unsigned long flags;
+	struct list_head new_head;
+
+	check_bodev_null_return_void(bdev);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_replace_init(&bdev->free_bo_list, &new_head);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	list_for_each_entry_safe(bo, tmp, &new_head, list) {
+		list_del(&bo->list);
+		hmm_bo_unref(bo);
+	}
+}
+
+/*
+ * destroy buffer object with start virtual address vaddr.
+ */
+void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
+					unsigned int vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return_void(bdev);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (bo->vm_node->start == vaddr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return;
+found:
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	hmm_bo_unref(bo);
+}
+
+/*
+ * destroy all buffer objects with pgnr pages.
+ */
+void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
+					unsigned int pgnr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return_void(bdev);
+
+retry:
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		if (bo->pgnr == pgnr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return;
+found:
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	hmm_bo_unref(bo);
+	goto retry;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c b/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c
new file mode 100644
index 0000000..fa2016b
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c
@@ -0,0 +1,228 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for dynamic memory pool management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+
+#include "asm/cacheflush.h"
+
+#include "atomisp_internal.h"
+#include "atomisp_common.h"
+#include "hmm/hmm_pool.h"
+
+/*
+ * dynamic memory pool ops.
+ */
+static unsigned int get_pages_from_dynamic_pool(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached)
+{
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	unsigned int i = 0;
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return 0;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (dypool_info->initialized) {
+		while (!list_empty(&dypool_info->pages_list)) {
+			hmm_page = list_entry(dypool_info->pages_list.next,
+						struct hmm_page, list);
+
+			list_del(&hmm_page->list);
+			spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+			page_obj[i].page = hmm_page->page;
+			page_obj[i++].type = HMM_PAGE_TYPE_DYNAMIC;
+#ifdef USE_KMEM_CACHE
+			kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
+#else
+			atomisp_kernel_free(hmm_page);
+#endif
+
+			if (i == size)
+				return i;
+
+			spin_lock_irqsave(&dypool_info->list_lock, flags);
+		}
+	}
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+	return i;
+}
+
+static void free_pages_to_dynamic_pool(void *pool,
+					struct hmm_page_object *page_obj)
+{
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	int ret;
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (!dypool_info->initialized) {
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+	if (page_obj->type == HMM_PAGE_TYPE_RESERVED)
+		return;
+#ifdef USE_KMEM_CACHE
+	hmm_page = kmem_cache_zalloc(dypool_info->pgptr_cache,
+						GFP_KERNEL);
+#else
+	hmm_page = atomisp_kernel_malloc(sizeof(struct hmm_page));
+#endif
+	if (!hmm_page) {
+		v4l2_err(&atomisp_dev, "out of memory for hmm_page.\n");
+
+		/* free page directly */
+		ret = set_pages_wb(page_obj->page, 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+					"set page to WB err ...\n");
+		__free_pages(page_obj->page, 0);
+
+		return;
+	}
+
+	hmm_page->page = page_obj->page;
+
+	/*
+	 * add to pages_list of pages_pool
+	 */
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	list_add_tail(&hmm_page->list, &dypool_info->pages_list);
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+}
+
+static int hmm_dynamic_pool_init(void **pool, unsigned int pool_size)
+{
+	struct hmm_dynamic_pool_info *dypool_info;
+
+	if (pool_size == 0)
+		return -EINVAL;
+
+	dypool_info = atomisp_kernel_malloc(
+					sizeof(struct hmm_dynamic_pool_info));
+	if (unlikely(!dypool_info)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info.\n");
+		return -ENOMEM;
+	}
+
+#ifdef USE_KMEM_CACHE
+	dypool_info->pgptr_cache = kmem_cache_create("pgptr_cache",
+						sizeof(struct hmm_page), 0,
+						SLAB_HWCACHE_ALIGN, NULL);
+	if (!dypool_info->pgptr_cache) {
+		atomisp_kernel_free(dypool_info);
+		return -ENOMEM;
+	}
+#endif
+
+	INIT_LIST_HEAD(&dypool_info->pages_list);
+	spin_lock_init(&dypool_info->list_lock);
+	dypool_info->initialized = true;
+
+	*pool = dypool_info;
+
+	return 0;
+}
+
+static void hmm_dynamic_pool_exit(void **pool)
+{
+	struct hmm_dynamic_pool_info *dypool_info = *pool;
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	int ret;
+
+	if (!dypool_info)
+		return;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (!dypool_info->initialized) {
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+		return;
+	}
+	dypool_info->initialized = false;
+
+	while (!list_empty(&dypool_info->pages_list)) {
+		hmm_page = list_entry(dypool_info->pages_list.next,
+					struct hmm_page, list);
+
+		list_del(&hmm_page->list);
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+		/* can cause thread sleep, so cannot be put into spin_lock */
+		ret = set_pages_wb(hmm_page->page, 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+				"set page to WB err...\n");
+		__free_pages(hmm_page->page, 0);
+
+#ifdef USE_KMEM_CACHE
+		kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
+#else
+		atomisp_kernel_free(hmm_page);
+#endif
+		spin_lock_irqsave(&dypool_info->list_lock, flags);
+	}
+
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_destroy(dypool_info->pgptr_cache);
+#endif
+
+	atomisp_kernel_free(dypool_info);
+
+	*pool = NULL;
+}
+
+static int hmm_dynamic_pool_inited(void *pool)
+{
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return 0;
+
+	return dypool_info->initialized;
+}
+
+struct hmm_pool_ops dynamic_pops = {
+	.pool_init		= hmm_dynamic_pool_init,
+	.pool_exit		= hmm_dynamic_pool_exit,
+	.pool_alloc_pages	= get_pages_from_dynamic_pool,
+	.pool_free_pages	= free_pages_to_dynamic_pool,
+	.pool_inited		= hmm_dynamic_pool_inited,
+};
diff --git a/drivers/media/atomisp2/hmm/hmm_reserved_pool.c b/drivers/media/atomisp2/hmm/hmm_reserved_pool.c
new file mode 100644
index 0000000..102f45e
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_reserved_pool.c
@@ -0,0 +1,245 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for reserved memory pool management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+
+#include "asm/cacheflush.h"
+
+#include "atomisp_internal.h"
+#include "atomisp_common.h"
+#include "hmm/hmm_pool.h"
+
+/*
+ * reserved memory pool ops.
+ */
+static unsigned int get_pages_from_reserved_pool(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached)
+{
+	unsigned long flags;
+	unsigned int i = 0;
+	unsigned int repool_pgnr;
+	int j;
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return 0;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+	if (repool_info->initialized) {
+		repool_pgnr = repool_info->index;
+
+		for (j = repool_pgnr-1; j >= 0; j--) {
+			page_obj[i].page = repool_info->pages[j];
+			page_obj[i].type = HMM_PAGE_TYPE_RESERVED;
+			i++;
+			repool_info->index--;
+			if (i == size)
+				break;
+		}
+	}
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+	return i;
+}
+
+static void free_pages_to_reserved_pool(void *pool,
+					struct hmm_page_object *page_obj)
+{
+	unsigned long flags;
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+
+	if (repool_info->initialized &&
+	    repool_info->index < repool_info->pgnr &&
+	    page_obj->type == HMM_PAGE_TYPE_RESERVED) {
+		repool_info->pages[repool_info->index++] = page_obj->page;
+	}
+
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+}
+
+static int hmm_reserved_pool_setup(struct hmm_reserved_pool_info **repool_info,
+					unsigned int pool_size)
+{
+	struct hmm_reserved_pool_info *pool_info;
+
+	pool_info = atomisp_kernel_malloc(
+					sizeof(struct hmm_reserved_pool_info));
+	if (unlikely(!pool_info)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info.\n");
+		return -ENOMEM;
+	}
+
+	pool_info->pages = atomisp_kernel_malloc(
+					sizeof(struct page *) * pool_size);
+	if (unlikely(!pool_info->pages)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info->pages.\n");
+		atomisp_kernel_free(pool_info);
+		return -ENOMEM;
+	}
+
+	pool_info->index = 0;
+	pool_info->pgnr = 0;
+	spin_lock_init(&pool_info->list_lock);
+	pool_info->initialized = true;
+
+	*repool_info = pool_info;
+
+	return 0;
+}
+
+static int hmm_reserved_pool_init(void **pool, unsigned int pool_size)
+{
+	int ret;
+	unsigned int blk_pgnr;
+	unsigned int pgnr = pool_size;
+	unsigned int order = 0;
+	unsigned int i = 0;
+	int fail_number = 0;
+	struct page *pages;
+	int j;
+	struct hmm_reserved_pool_info *repool_info;
+
+	if (pool_size == 0)
+		return -EINVAL;
+
+	ret = hmm_reserved_pool_setup(&repool_info, pool_size);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_reserved_pool_setup failed.\n");
+		return ret;
+	}
+
+	pgnr = pool_size;
+
+	i = 0;
+	order = 0;
+
+	while (pgnr) {
+		pages = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);
+		if (unlikely(!pages)) {
+			fail_number++;
+			v4l2_err(&atomisp_dev, "%s: alloc_pages failed: %d\n",
+					__func__, fail_number);
+			/* if fail five times, will goto end */
+
+			/* FIXME: whether is the mechanism is ok? */
+			if (fail_number == ALLOC_PAGE_FAIL_NUM)
+				goto end;
+		} else {
+			blk_pgnr = 1U << order;
+
+			ret = set_pages_uc(pages, blk_pgnr);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+						"set pages uncached failed\n");
+				__free_pages(pages, order);
+				goto end;
+			}
+
+			for (j = 0; j < blk_pgnr; j++)
+				repool_info->pages[i++] = pages + j;
+
+			repool_info->index += blk_pgnr;
+			repool_info->pgnr += blk_pgnr;
+
+			pgnr -= blk_pgnr;
+
+			fail_number = 0;
+		}
+	}
+
+end:
+	repool_info->initialized = true;
+
+	*pool = repool_info;
+
+	v4l2_info(&atomisp_dev,
+			"hmm_reserved_pool init successfully,"
+			"hmm_reserved_pool is with %d pages.\n",
+			repool_info->pgnr);
+	return 0;
+}
+
+static void hmm_reserved_pool_exit(void **pool)
+{
+	unsigned long flags;
+	int i, ret;
+	unsigned int pgnr;
+	struct hmm_reserved_pool_info *repool_info = *pool;
+
+	if (!repool_info)
+		return;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+	if (!repool_info->initialized) {
+		spin_unlock_irqrestore(&repool_info->list_lock, flags);
+		return;
+	}
+	pgnr = repool_info->pgnr;
+	repool_info->index = 0;
+	repool_info->pgnr = 0;
+	repool_info->initialized = false;
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+
+	for (i = 0; i < pgnr; i++) {
+		ret = set_pages_wb(repool_info->pages[i], 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+				"set page to WB err...\n");
+		__free_pages(repool_info->pages[i], 0);
+	}
+
+	atomisp_kernel_free(repool_info->pages);
+	atomisp_kernel_free(repool_info);
+
+	*pool = NULL;
+}
+
+static int hmm_reserved_pool_inited(void *pool)
+{
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return 0;
+
+	return repool_info->initialized;
+}
+
+struct hmm_pool_ops reserved_pops = {
+	.pool_init		= hmm_reserved_pool_init,
+	.pool_exit		= hmm_reserved_pool_exit,
+	.pool_alloc_pages	= get_pages_from_reserved_pool,
+	.pool_free_pages	= free_pages_to_reserved_pool,
+	.pool_inited		= hmm_reserved_pool_inited,
+};
diff --git a/drivers/media/atomisp2/hmm/hmm_vm.c b/drivers/media/atomisp2/hmm/hmm_vm.c
new file mode 100644
index 0000000..3884bab
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_vm.c
@@ -0,0 +1,220 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains function for ISP virtual address management in ISP driver
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <asm/page.h>
+
+#include "mmu/isp_mmu.h"
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_common.h"
+#include "atomisp_internal.h"
+
+static unsigned int vm_node_end(unsigned int start, unsigned int pgnr)
+{
+	return start + pgnr_to_size(pgnr);
+}
+
+static int addr_in_vm_node(unsigned int addr,
+		struct hmm_vm_node *node)
+{
+	return (addr >= node->start) && (addr < (node->start + node->size));
+}
+
+int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
+		unsigned int size)
+{
+	if (!vm)
+		return -1;
+
+	vm->start = start;
+	vm->pgnr = size_to_pgnr_ceil(size);
+	vm->size = pgnr_to_size(vm->pgnr);
+
+	INIT_LIST_HEAD(&vm->vm_node_list);
+	spin_lock_init(&vm->lock);
+	vm->cache = kmem_cache_create("atomisp_vm", sizeof(struct hmm_vm_node),
+				      0, 0, NULL);
+
+	return vm->cache != NULL ? 0 : -ENOMEM;
+}
+
+void hmm_vm_clean(struct hmm_vm *vm)
+{
+	struct hmm_vm_node *node, *tmp;
+	struct list_head new_head;
+
+	if (!vm)
+		return;
+
+	spin_lock(&vm->lock);
+	list_replace_init(&vm->vm_node_list, &new_head);
+	spin_unlock(&vm->lock);
+
+	list_for_each_entry_safe(node, tmp, &new_head, list) {
+		list_del(&node->list);
+		kmem_cache_free(vm->cache, node);
+	}
+
+	kmem_cache_destroy(vm->cache);
+}
+
+static struct hmm_vm_node *alloc_hmm_vm_node(unsigned int start,
+					       unsigned int pgnr,
+					       struct hmm_vm *vm)
+{
+	struct hmm_vm_node *node;
+
+	node = kmem_cache_alloc(vm->cache, GFP_KERNEL);
+	if (!node) {
+		v4l2_err(&atomisp_dev, "out of memory.\n");
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&node->list);
+	node->start = start;
+	node->pgnr = pgnr;
+	node->size = pgnr_to_size(pgnr);
+	node->vm = vm;
+
+	return node;
+}
+
+struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm, unsigned int pgnr)
+{
+	struct list_head *head;
+	struct hmm_vm_node *node, *cur, *next;
+	unsigned int vm_start, vm_end;
+	unsigned int addr;
+	unsigned int size;
+
+	if (!vm)
+		return NULL;
+
+	vm_start = vm->start;
+	vm_end = vm_node_end(vm->start, vm->pgnr);
+	size = pgnr_to_size(pgnr);
+
+	addr = vm_start;
+	head = &vm->vm_node_list;
+
+	spin_lock(&vm->lock);
+	/*
+	 * if list is empty, the loop code will not be executed.
+	 */
+	list_for_each_entry(cur, head, list) {
+		/* Add gap between vm areas as helper to not hide overflow */
+		addr = PAGE_ALIGN(vm_node_end(cur->start, cur->pgnr) + 1);
+
+		if (list_is_last(&cur->list, head)) {
+			if (addr + size > vm_end) {
+				/* vm area does not have space anymore */
+				spin_unlock(&vm->lock);
+				v4l2_info(&atomisp_dev,
+					  "no enough virtual address space.\n");
+				return NULL;
+			}
+
+			/* We still have vm space to add new node to tail */
+			break;
+		}
+
+		next = list_entry(cur->list.next, struct hmm_vm_node, list);
+		if ((next->start - addr) > size)
+			break;
+	}
+	spin_unlock(&vm->lock);
+
+	node = alloc_hmm_vm_node(addr, pgnr, vm);
+	if (!node) {
+		v4l2_info(&atomisp_dev, "no memory to allocate hmm vm node.\n");
+		return NULL;
+	}
+
+	spin_lock(&vm->lock);
+	list_add(&node->list, &cur->list);
+	spin_unlock(&vm->lock);
+
+	return node;
+}
+
+void hmm_vm_free_node(struct hmm_vm_node *node)
+{
+	struct hmm_vm *vm;
+
+	if (!node)
+		return;
+
+	vm = node->vm;
+
+	spin_lock(&vm->lock);
+	list_del(&node->list);
+	spin_unlock(&vm->lock);
+
+	kmem_cache_free(vm->cache, node);
+}
+
+struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm, unsigned int addr)
+{
+	struct hmm_vm_node *node;
+
+	if (!vm)
+		return NULL;
+
+	spin_lock(&vm->lock);
+
+	list_for_each_entry(node, &vm->vm_node_list, list) {
+		if (node->start == addr) {
+			spin_unlock(&vm->lock);
+			return node;
+		}
+	}
+
+	spin_unlock(&vm->lock);
+	return NULL;
+}
+
+struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
+					      unsigned int addr)
+{
+	struct hmm_vm_node *node;
+
+	if (!vm)
+		return NULL;
+
+	spin_lock(&vm->lock);
+
+	list_for_each_entry(node, &vm->vm_node_list, list) {
+		if (addr_in_vm_node(addr, node)) {
+			spin_unlock(&vm->lock);
+			return node;
+		}
+	}
+
+	spin_unlock(&vm->lock);
+	return NULL;
+}
diff --git a/drivers/media/atomisp2/hrt/device_access.c b/drivers/media/atomisp2/hrt/device_access.c
new file mode 100644
index 0000000..87a41c7
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/device_access.c
@@ -0,0 +1,128 @@
+
+#include "device_access.h"
+#include "hive_isp_css_custom_host_hrt.h"
+
+#include "assert_support.h"
+
+//#include <hrt/master_port.h>	/* hrt_master_port_load() */
+#ifdef C_RUN
+#include <string.h>				/* memcpy() */
+#endif
+
+/*
+ * This is an HRT backend implementation for CSIM
+ */
+
+static sys_address		base_address = (sys_address)-1;
+
+void device_set_base_address(
+	const sys_address		base_addr)
+{
+	base_address = base_addr;
+return;
+}
+
+
+sys_address device_get_base_address(void)
+{
+return base_address;
+}
+
+uint8_t device_load_uint8(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+return hrt_master_port_uload_8(base_address + addr);
+}
+
+uint16_t device_load_uint16(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x01) == 0);
+return hrt_master_port_uload_16(base_address + addr);
+}
+
+uint32_t device_load_uint32(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x03) == 0);
+return hrt_master_port_uload_32(base_address + addr);
+}
+
+uint64_t device_load_uint64(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x07) == 0);
+assert(0);
+return 0;
+}
+
+void device_store_uint8(
+	const hrt_address		addr,
+	const uint8_t			data)
+{
+assert(base_address != (sys_address)-1);
+hrt_master_port_store_8(base_address + addr, data);
+return;
+}
+
+void device_store_uint16(
+	const hrt_address		addr,
+	const uint16_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x01) == 0);
+hrt_master_port_store_16(base_address + addr, data);
+return;
+}
+
+void device_store_uint32(
+	const hrt_address		addr,
+	const uint32_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x03) == 0);
+hrt_master_port_store_32(base_address + addr, data);
+return;
+}
+
+void device_store_uint64(
+	const hrt_address		addr,
+	const uint64_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x07) == 0);
+assert(0);
+(void)data;
+return;
+}
+
+void device_load(
+	const hrt_address		addr,
+	void					*data,
+	const size_t			size)
+{
+assert(base_address != (sys_address)-1);
+#ifndef C_RUN
+	hrt_master_port_load((uint32_t)(base_address + addr), data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+}
+
+void device_store(
+	const hrt_address		addr,
+	const void				*data,
+	const size_t			size)
+{
+assert(base_address != (sys_address)-1);
+#ifndef C_RUN
+	hrt_master_port_store((uint32_t)(base_address + addr), data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h b/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h
new file mode 100644
index 0000000..b3637f2
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h
@@ -0,0 +1,110 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef _hive_isp_css_custom_host_hrt_h_
+#define _hive_isp_css_custom_host_hrt_h_
+
+#include <linux/delay.h>
+#include "atomisp_helper.h"
+
+/*
+ * _hrt_master_port_store/load/uload -macros using __force attributed
+ * cast to intentional dereferencing __iomem attributed (noderef)
+ * pointer from atomisp_get_io_virt_addr
+ */
+#define _hrt_master_port_store_8(a, d) \
+	(*((s8 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))\
+	= (d))
+
+#define _hrt_master_port_store_16(a, d) \
+	(*((s16 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))\
+	= (d))
+
+#define _hrt_master_port_store_32(a, d) \
+	(*((s32 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))\
+	= (d))
+
+#define _hrt_master_port_load_8(a) \
+	(*(s8 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_load_16(a) \
+	(*(s16 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_load_32(a) \
+	(*(s32 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_uload_8(a) \
+	(*(u8 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_uload_16(a) \
+	(*(u16 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_uload_32(a) \
+	(*(u32 __force *)atomisp_get_io_virt_addr((unsigned int)(a)))
+
+#define _hrt_master_port_store_8_volatile(a, d)  _hrt_master_port_store_8(a, d)
+#define _hrt_master_port_store_16_volatile(a, d) _hrt_master_port_store_16(a, d)
+#define _hrt_master_port_store_32_volatile(a, d) _hrt_master_port_store_32(a, d)
+
+#define _hrt_master_port_load_8_volatile(a)      _hrt_master_port_load_8(a)
+#define _hrt_master_port_load_16_volatile(a)     _hrt_master_port_load_16(a)
+#define _hrt_master_port_load_32_volatile(a)     _hrt_master_port_load_32(a)
+
+#define _hrt_master_port_uload_8_volatile(a)     _hrt_master_port_uload_8(a)
+#define _hrt_master_port_uload_16_volatile(a)    _hrt_master_port_uload_16(a)
+#define _hrt_master_port_uload_32_volatile(a)    _hrt_master_port_uload_32(a)
+
+static inline void hrt_sleep(void)
+{
+	udelay(1);
+}
+
+static inline void *_hrt_mem_store(void *to, const void *from, size_t n)
+{
+	unsigned i;
+	unsigned int _to = (unsigned int)to;
+	const char *_from = (const char *)from;
+	for (i = 0; i < n; i++, _to++, _from++)
+		_hrt_master_port_store_8(_to, *_from);
+	return (void *)_to;
+}
+
+static inline void *_hrt_mem_load(const void *from, void *to, size_t n)
+{
+	unsigned i;
+	char *_to = (char *)to;
+	unsigned int _from = (unsigned int)from;
+	for (i = 0; i < n; i++, _to++, _from++)
+		*_to = _hrt_master_port_load_8(_from);
+	return _to;
+}
+
+static inline void *_hrt_mem_set(void *to, int c, size_t n)
+{
+	unsigned i;
+	unsigned int _to = (unsigned int)to;
+	for (i = 0; i < n; i++, _to++)
+		_hrt_master_port_store_8(_to, c);
+	return (void *)_to;
+}
+
+#endif /* _hive_isp_css_custom_host_hrt_h_ */
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
new file mode 100644
index 0000000..ceaa074
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
@@ -0,0 +1,351 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <hmm/hmm.h>
+#include <ia_css.h>
+/* not sure if we need these two for page related macros,
+ * need to double check */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <hive_isp_css_mm_hrt.h>
+#include "atomisp_internal.h"
+
+#define __page_align(size)	(((size) + (PAGE_SIZE-1)) & (~(PAGE_SIZE-1)))
+
+static unsigned init_done;
+/*
+ * to serialize MMIO access , this is due to ISP2400 silicon issue Sighting
+ * #4684168, if concurrency access happened, system may hard hang. Sighting #4600742 also points to system hard hang upon access to IUNIT MMIO.
+ */
+static DEFINE_SPINLOCK(mmio_lock);
+
+void hrt_isp_css_mm_init(void)
+{
+	if (!init_done) {
+		hmm_init();
+		init_done = 1;
+	}
+}
+
+int hrt_isp_get_mmu_base_address(void)
+{
+	if (init_done)
+		return hmm_get_mmu_base_addr();
+	return -EINVAL;
+
+}
+int hrt_isp_css_mm_set(void *virt_addr, int c, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_set(virt_addr, c, bytes);
+
+	return -EINVAL;
+}
+
+int hrt_isp_css_mm_load(void *virt_addr, void *data, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_load(virt_addr, data, bytes);
+	return -EINVAL;
+}
+
+int hrt_isp_css_mm_store(void *virt_addr, const void *data, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_store(virt_addr, data, bytes);
+	return -EINVAL;
+}
+
+void hrt_isp_css_mm_free(void *virt_addr)
+{
+	if (virt_addr)
+		hmm_free(virt_addr);
+}
+
+void hrt_isp_css_mm_clear(void)
+{
+	if (init_done) {
+		hmm_cleanup();
+		init_done = 0;
+	}
+}
+
+static unsigned int my_userptr, my_num_pages;
+static enum hrt_userptr_type my_usr_type;
+
+void hrt_isp_css_mm_set_user_ptr(unsigned int userptr,
+				 unsigned int num_pages,
+				 enum hrt_userptr_type type)
+{
+	my_userptr = userptr;
+	my_num_pages = num_pages;
+	my_usr_type = type;
+}
+
+static void *__hrt_isp_css_mm_alloc(size_t bytes, unsigned int userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type type,
+						void *priv,
+				    bool cached)
+{
+	if (!init_done)
+		hrt_isp_css_mm_init();
+#ifdef CONFIG_ION
+	if (type == HRT_USR_ION)
+		return (void *)hmm_alloc(bytes, HMM_BO_ION, 0,
+					 userptr, cached, NULL);
+
+#endif
+	if (type == HRT_USR_PTR) {
+		if (userptr == 0)
+			return (void *)hmm_alloc(bytes, HMM_BO_PRIVATE, 0,
+						 0, cached, NULL);
+		else {
+			if (num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+				v4l2_err(&atomisp_dev,
+					 "user space memory size is less"
+					 " than the expected size..\n");
+			else if (num_pages > ((__page_align(bytes))
+					      >> PAGE_SHIFT))
+				v4l2_err(&atomisp_dev,
+					 "user space memory size is"
+					 " large than the expected size..\n");
+
+			return (void *)hmm_alloc(bytes, HMM_BO_USER, 0,
+						 userptr, cached, NULL);
+		}
+	} else if (type == HRT_KERNEL_PTR) {
+		if (num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+        v4l2_err(&atomisp_dev,
+           "kernel space memory size is less"
+           " than the expected size..\n");
+      else if (num_pages > ((__page_align(bytes))
+                >> PAGE_SHIFT))
+        v4l2_err(&atomisp_dev,
+           "kernel space memory size is"
+           " large than the expected size..\n");
+
+      return (void *)hmm_alloc(bytes, HMM_BO_DMA, 0,
+             userptr, cached, priv);
+
+	} else {
+		v4l2_err(&atomisp_dev, "user ptr type is incorrect.\n");
+		return NULL;
+	}
+}
+
+void *hrt_isp_css_mm_alloc(size_t bytes)
+{
+	return __hrt_isp_css_mm_alloc(bytes, my_userptr,
+				      my_num_pages, my_usr_type, NULL, false);
+}
+
+void *hrt_isp_css_mm_alloc_user_ptr(size_t bytes, unsigned int userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type type,
+						void *priv,
+				    bool cached)
+{
+	return __hrt_isp_css_mm_alloc(bytes, userptr, num_pages,
+				      type, priv, cached);
+}
+
+void *hrt_isp_css_mm_alloc_cached(size_t bytes)
+{
+	if (!init_done)
+		hrt_isp_css_mm_init();
+
+	if (my_userptr == 0)
+		return (void *)hmm_alloc(bytes, HMM_BO_PRIVATE, 0, 0,
+						HMM_CACHED, NULL);
+	else {
+		if (my_num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+			v4l2_err(&atomisp_dev,
+					"user space memory size is less"
+					" than the expected size..\n");
+		else if (my_num_pages > ((__page_align(bytes)) >> PAGE_SHIFT))
+			v4l2_err(&atomisp_dev,
+					"user space memory size is"
+					" large than the expected size..\n");
+
+		return (void *)hmm_alloc(bytes, HMM_BO_USER, 0,
+						my_userptr, HMM_CACHED, NULL);
+	}
+}
+
+void *hrt_isp_css_mm_calloc(size_t bytes)
+{
+	void *ptr = hrt_isp_css_mm_alloc(bytes);
+	if (!ptr)
+		hmm_set(ptr, 0, bytes);
+	return ptr;
+}
+
+void *hrt_isp_css_mm_calloc_cached(size_t bytes)
+{
+	void *ptr = hrt_isp_css_mm_alloc_cached(bytes);
+	if (!ptr)
+		hmm_set(ptr, 0, bytes);
+	return ptr;
+}
+
+void *hrt_isp_css_virt_to_phys(void *virt_addr)
+{
+	return (void *)(u32)hmm_virt_to_phys(virt_addr);
+}
+
+void *hrt_isp_css_mm_alloc_contiguous(size_t bytes)
+{
+	BUG_ON(false);
+	return NULL;
+}
+void *hrt_isp_css_mm_calloc_contiguous(size_t bytes)
+{
+	BUG_ON(false);
+	return NULL;
+}
+#ifdef CSS_2
+ia_css_ptr
+atomisp_css2_mm_alloc(size_t bytes, uint32_t attr)
+{
+	if (attr & IA_CSS_MEM_ATTR_CACHED)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc_cached(bytes);
+	else if (attr & IA_CSS_MEM_ATTR_ZEROED)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
+	else if (attr & IA_CSS_MEM_ATTR_CONTIGUOUS)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc_contiguous(bytes);
+	else
+		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
+}
+
+void atomisp_css2_mm_free(ia_css_ptr ptr)
+{
+	hrt_isp_css_mm_free((void *)ptr);
+}
+int atomisp_css2_mm_load(ia_css_ptr ptr, void *data, size_t bytes)
+{
+	return hrt_isp_css_mm_load((void *)ptr, data, bytes);
+}
+int atomisp_css2_mm_store(ia_css_ptr ptr, const void *data, size_t bytes)
+{
+	return hrt_isp_css_mm_store((void *)ptr, data, bytes);
+}
+int atomisp_css2_mm_set(ia_css_ptr ptr, int c, size_t bytes)
+{
+	return hrt_isp_css_mm_set((void *)ptr, c, bytes);
+}
+
+ia_css_ptr atomisp_css2_mm_mmap(const void *ptr, const size_t size,
+		   uint16_t attribute, void *context)
+{
+	struct hrt_userbuffer_attr *userbuffer_attr = context;
+	return (ia_css_ptr)hrt_isp_css_mm_alloc_user_ptr(
+			size, (unsigned int)ptr,
+			userbuffer_attr->pgnr,
+			userbuffer_attr->type,
+			userbuffer_attr->priv,
+			attribute & HRT_BUF_FLAG_CACHED);
+}
+void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	_hrt_master_port_store_8(addr, data);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+}
+void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	_hrt_master_port_store_16(addr, data);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+}
+void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	_hrt_master_port_store_32(addr, data);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+}
+uint8_t atomisp_css2_hw_load_8(hrt_address addr)
+{
+	unsigned long flags;
+	uint8_t ret;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	ret = _hrt_master_port_load_8(addr);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+	return ret;
+}
+uint16_t atomisp_css2_hw_load_16(hrt_address addr)
+{
+	unsigned long flags;
+	uint16_t ret;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	ret = _hrt_master_port_load_16(addr);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+	return ret;
+}
+uint32_t atomisp_css2_hw_load_32(hrt_address addr)
+{
+	unsigned long flags;
+	uint32_t ret;
+
+	spin_lock_irqsave(&mmio_lock, flags);
+	ret = _hrt_master_port_load_32(addr);
+	spin_unlock_irqrestore(&mmio_lock, flags);
+	return ret;
+}
+
+void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n)
+{
+	unsigned i;
+	unsigned long flags;
+	unsigned int _to = (unsigned int)addr;
+	const char *_from = (const char *)from;
+	for (i = 0; i < n; i++, _to++, _from++)
+	{
+		spin_lock_irqsave(&mmio_lock, flags);
+		_hrt_master_port_store_8(_to , *_from);
+		spin_unlock_irqrestore(&mmio_lock, flags);
+	}
+}
+
+void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)
+{
+	unsigned i;
+	unsigned long flags;
+	char *_to = (char *)to;
+	unsigned int _from = (unsigned int)addr;
+	for (i = 0; i < n; i++, _to++, _from++)
+	{
+		spin_lock_irqsave(&mmio_lock, flags);
+		*_to = _hrt_master_port_load_8(_from);
+		spin_unlock_irqrestore(&mmio_lock, flags);
+	}
+}
+#endif
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h
new file mode 100644
index 0000000..1c299da
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h
@@ -0,0 +1,114 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_mm_hrt_h_
+#define _hive_isp_css_mm_hrt_h_
+
+#ifndef HRT_KERNEL
+/* size_t is defined already in kernel mode */
+#include <stdlib.h>
+#endif
+#include <hmm/hmm.h>
+#include <hrt/hive_isp_css_custom_host_hrt.h>
+
+#define HRT_BUF_FLAG_CACHED (1 << 0)
+
+enum hrt_userptr_type {
+	HRT_USR_PTR = 0,
+	HRT_KERNEL_PTR,
+#ifdef CONFIG_ION
+	HRT_USR_ION,
+#endif
+};
+
+struct hrt_userbuffer_attr {
+	enum hrt_userptr_type	type;
+	unsigned int		pgnr;
+	void *priv;
+};
+
+void hrt_isp_css_mm_init(void);
+int hrt_isp_get_mmu_base_address(void);
+void hrt_isp_css_mm_set_user_ptr(unsigned int userptr,
+				unsigned int num_pages, enum hrt_userptr_type);
+
+int hrt_isp_css_mm_set(void *virt_addr, int c, size_t bytes);
+
+/* Allocate memory, returns a virtual address */
+void *hrt_isp_css_mm_alloc(size_t bytes);
+void *hrt_isp_css_mm_alloc_user_ptr(size_t bytes, unsigned int userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type,
+						void *priv,
+				    bool cached);
+void *hrt_isp_css_mm_alloc_cached(size_t bytes);
+
+/* allocate memory and initialize with zeros,
+   returns a virtual address */
+void *hrt_isp_css_mm_calloc(size_t bytes);
+void *hrt_isp_css_mm_calloc_cached(size_t bytes);
+
+/* Free memory, given a virtual address */
+void hrt_isp_css_mm_free(void *virt_addr);
+
+/* Store data to a virtual address */
+int hrt_isp_css_mm_load(void *virt_addr, void *data, size_t bytes);
+
+/* Load data from a virtual address */
+int hrt_isp_css_mm_store(void *virt_addr, const void *data, size_t bytes);
+
+int hrt_isp_css_mm_load_int(void *virt_addr, int *data);
+int hrt_isp_css_mm_load_short(void *virt_addr, short *data);
+int hrt_isp_css_mm_load_char(void *virt_addr, char *data);
+
+int hrt_isp_css_mm_store_char(void *virt_addr, char data);
+int hrt_isp_css_mm_store_short(void *virt_addr, short data);
+int hrt_isp_css_mm_store_int(void *virt_addr, int data);
+
+/* translate a virtual to a physical address, used to program
+   the display driver on  the FPGA system */
+void *hrt_isp_css_virt_to_phys(void *virt_addr);
+
+void *hrt_isp_css_mm_alloc_contiguous(size_t bytes);
+void *hrt_isp_css_mm_calloc_contiguous(size_t bytes);
+
+void hrt_isp_css_mm_clear(void);
+#ifdef CSS_2
+ia_css_ptr
+atomisp_css2_mm_alloc(size_t bytes, uint32_t attr);
+void atomisp_css2_mm_free(ia_css_ptr ptr);
+int atomisp_css2_mm_load(ia_css_ptr ptr, void *data, size_t bytes);
+int atomisp_css2_mm_store(ia_css_ptr ptr, const void *data, size_t bytes);
+int atomisp_css2_mm_set(ia_css_ptr ptr, int c, size_t bytes);
+ia_css_ptr atomisp_css2_mm_mmap(const void *ptr, const size_t size,
+		   uint16_t attribute, void *context);
+void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data);
+void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data);
+void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data);
+uint8_t atomisp_css2_hw_load_8(hrt_address addr);
+uint16_t atomisp_css2_hw_load_16(hrt_address addr);
+uint32_t atomisp_css2_hw_load_32(hrt_address addr);
+void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n);
+void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n);
+#endif
+#endif /* _hive_isp_css_mm_hrt_h_ */
diff --git a/drivers/media/atomisp2/hrt/memory_access.c b/drivers/media/atomisp2/hrt/memory_access.c
new file mode 100644
index 0000000..d736e5d
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/memory_access.c
@@ -0,0 +1,372 @@
+
+#include "memory_access.h"
+
+#include <stddef.h>		/* NULL */
+#include <stdbool.h>
+
+#include "device_access.h"
+
+#include "mmu_device.h"
+
+#include "assert_support.h"
+
+/* Presently system specific */
+#include <hmm/hmm.h>
+/* Presently system specific */
+#include "hive_isp_css_mm_hrt.h"
+
+/*
+ * This is an HRT backend implementation for CSIM
+ * 31 July 2012, rvanimme: this implementation is also used in Android context
+ */
+
+static sys_address	page_table_base_address = (sys_address)-1;
+const hrt_vaddress	mmgr_NULL = (hrt_vaddress)0;
+
+#ifndef SH_CSS_MEMORY_GUARDING
+/* Choose default in case not defined */
+#ifdef HRT_CSIM
+#define SH_CSS_MEMORY_GUARDING (1)
+#else
+#define SH_CSS_MEMORY_GUARDING (0)
+#endif
+#endif
+
+#if SH_CSS_MEMORY_GUARDING
+#define CEIL_DIV(a, b)	((b) ? ((a)+(b)-1)/(b) : 0)
+#define CEIL_MUL(a, b)	(CEIL_DIV(a, b) * (b))
+#define DDR_ALIGN(a)	(CEIL_MUL((a), (HIVE_ISP_DDR_WORD_BYTES)))
+
+#define MEM_GUARD_START		0xABBAABBA
+#define MEM_GUARD_END		0xBEEFBEEF
+#define GUARD_SIZE		sizeof(unsigned long)
+#define GUARD_SIZE_ALIGNED	DDR_ALIGN(GUARD_SIZE)
+
+#define MAX_ALLOC_ENTRIES (256)
+#define INVALID_VBASE ((hrt_vaddress)-1)
+#define INVALID_SIZE ((unsigned long)-1)
+
+struct alloc_info {
+	hrt_vaddress  vbase;
+	unsigned long size;
+};
+
+static struct alloc_info alloc_admin[MAX_ALLOC_ENTRIES];
+
+static struct alloc_info const alloc_info_invalid
+					= { INVALID_VBASE, INVALID_SIZE };
+
+static void alloc_admin_init(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++)
+		alloc_admin[i] = alloc_info_invalid;
+}
+
+static struct alloc_info const *alloc_admin_find(hrt_vaddress vaddr)
+{
+	int i;
+	/**
+	 * Note that we use <= instead of < because we like to accept
+	 * zero-sized operations at the last allocated address
+	 * e.g. mmgr_set(vbase+alloc_size, data, 0)
+	 */
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase != INVALID_VBASE &&
+					vaddr >= alloc_admin[i].vbase &&
+					vaddr <= alloc_admin[i].vbase +
+							alloc_admin[i].size) {
+			return &alloc_admin[i];
+		}
+	}
+	return &alloc_info_invalid;
+}
+
+static bool mem_guard_valid(hrt_vaddress vaddr, unsigned long size)
+{
+	unsigned long mem_guard;
+	struct alloc_info const *info;
+
+	info = alloc_admin_find(vaddr);
+	if (info->vbase == INVALID_VBASE) {
+		assert(false);
+		return false;
+	}
+
+	/* Check if end is in alloc range*/
+	if ((vaddr + size) > (info->vbase + info->size)) {
+		assert(false);
+		return false;
+	}
+
+	hrt_isp_css_mm_load(
+			(hmm_ptr)HOST_ADDRESS(info->vbase - sizeof(mem_guard)),
+			&mem_guard, sizeof(mem_guard));
+	if (mem_guard != MEM_GUARD_START) {
+		assert(false);
+		return false;
+	}
+
+	hrt_isp_css_mm_load((hmm_ptr)HOST_ADDRESS(info->vbase + info->size),
+						&mem_guard, sizeof(mem_guard));
+	if (mem_guard != MEM_GUARD_END) {
+		assert(false);
+		return false;
+	}
+
+	return true;
+
+}
+
+static void alloc_admin_add(hrt_vaddress vbase, unsigned long size)
+{
+	int i;
+	unsigned long mem_guard;
+
+	assert(alloc_admin_find(vbase)->vbase == INVALID_VBASE);
+
+	mem_guard = MEM_GUARD_START;
+	hrt_isp_css_mm_store((hmm_ptr)HOST_ADDRESS(vbase - sizeof(mem_guard)),
+						&mem_guard, sizeof(mem_guard));
+
+	mem_guard = MEM_GUARD_END;
+	hrt_isp_css_mm_store((hmm_ptr)HOST_ADDRESS(vbase + size),
+						&mem_guard, sizeof(mem_guard));
+
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase == INVALID_VBASE) {
+			alloc_admin[i].vbase = vbase;
+			alloc_admin[i].size = size;
+			return;
+		}
+	}
+	assert(false);
+}
+
+static void alloc_admin_remove(hrt_vaddress vbase)
+{
+	int i;
+	assert(mem_guard_valid(vbase, 0));
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase == vbase) {
+			alloc_admin[i] = alloc_info_invalid;
+			return;
+		}
+	}
+	assert(false);
+}
+
+#endif
+
+void mmgr_set_base_address(
+	const sys_address		base_addr)
+{
+	page_table_base_address = base_addr;
+
+#if SH_CSS_MEMORY_GUARDING
+	alloc_admin_init();
+#endif
+/*
+ * This is part of "device_access.h", but it may be
+ * that "hive_isp_css_mm_hrt.h" requires it
+ */
+/* hrt_isp_css_mm_set_ddr_address_offset(offset); */
+/*	mmu_set_page_table_base_index(MMU0_ID, page_table_base_address); */
+return;
+}
+
+sys_address mmgr_get_base_address(void)
+{
+return page_table_base_address;
+}
+
+void mmgr_set_base_index(
+	const hrt_data		base_index)
+{
+/* This system only defines the MMU base address */
+assert(0);
+(void)base_index;
+return;
+}
+
+hrt_data mmgr_get_base_index(void)
+{
+/* This system only defines the MMU base address */
+assert(0);
+return 0;
+}
+
+hrt_vaddress mmgr_malloc(
+	const size_t			size)
+{
+return mmgr_alloc_attr(size, MMGR_ATTRIBUTE_CACHED);
+}
+
+hrt_vaddress mmgr_calloc(
+	const size_t			N,
+	const size_t			size)
+{
+return mmgr_alloc_attr(N * size, MMGR_ATTRIBUTE_CLEARED|MMGR_ATTRIBUTE_CACHED);
+}
+
+hrt_vaddress mmgr_realloc(
+	hrt_vaddress			vaddr,
+	const size_t			size)
+{
+return mmgr_realloc_attr(vaddr, size, MMGR_ATTRIBUTE_DEFAULT);
+}
+
+void mmgr_free(
+	hrt_vaddress			vaddr)
+{
+/* "free()" should accept NULL, "hrt_isp_css_mm_free()" may not */
+	if (vaddr != mmgr_NULL) {
+#if SH_CSS_MEMORY_GUARDING
+		alloc_admin_remove(vaddr);
+		/* Reconstruct the "original" address used with the alloc */
+		vaddr -= GUARD_SIZE_ALIGNED;
+#endif
+		hrt_isp_css_mm_free((hmm_ptr)HOST_ADDRESS(vaddr));
+	}
+return;
+}
+
+hrt_vaddress mmgr_alloc_attr(
+	const size_t			size,
+	const uint16_t			attribute)
+{
+	hmm_ptr	ptr;
+	size_t	extra_space = 0;
+	size_t	aligned_size = size;
+
+assert(page_table_base_address != (sys_address)-1);
+assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
+
+#if SH_CSS_MEMORY_GUARDING
+	/* Add DDR aligned space for a guard at begin and end */
+	/* Begin guard must be DDR aligned, "end" guard not */
+	extra_space = GUARD_SIZE_ALIGNED + GUARD_SIZE;
+	/* SP DMA operates on multiple of 32 bytes, also with writes.
+	 * To prevent that the guard is being overwritten by SP DMA,
+	 * the "end" guard must start DDR aligned.
+	 */
+	aligned_size = DDR_ALIGN(aligned_size);
+#endif
+
+	if (attribute & MMGR_ATTRIBUTE_CLEARED) {
+		if (attribute & MMGR_ATTRIBUTE_CACHED) {
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_calloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_calloc_cached(
+						aligned_size + extra_space);
+			/* } */
+		} else { /* !MMGR_ATTRIBUTE_CACHED */
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_calloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_calloc(
+						aligned_size + extra_space);
+			/* } */
+		}
+	} else { /* MMGR_ATTRIBUTE_CLEARED */
+		if (attribute & MMGR_ATTRIBUTE_CACHED) {
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_alloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_alloc_cached(
+						aligned_size + extra_space);
+			/* } */
+		} else { /* !MMGR_ATTRIBUTE_CACHED */
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_alloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_alloc(
+						aligned_size + extra_space);
+			/* } */
+		}
+	}
+
+#if SH_CSS_MEMORY_GUARDING
+	/* ptr is the user pointer, so we need to skip the "begin" guard */
+	ptr += GUARD_SIZE_ALIGNED;
+	alloc_admin_add(HOST_ADDRESS(ptr), aligned_size);
+#endif
+
+	return HOST_ADDRESS(ptr);
+}
+
+hrt_vaddress mmgr_realloc_attr(
+	hrt_vaddress			vaddr,
+	const size_t			size,
+	const uint16_t			attribute)
+{
+assert(page_table_base_address != (sys_address)-1);
+assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
+/* assert(attribute == MMGR_ATTRIBUTE_DEFAULT); */
+/* Apparently we don't have this one */
+assert(0);
+(void)vaddr;
+(void)size;
+(void)attribute;
+return mmgr_NULL;
+}
+
+hrt_vaddress mmgr_mmap(const void *ptr, const size_t size, uint16_t attribute,
+		void *context)
+{
+	struct hrt_userbuffer_attr *userbuffer_attr = context;
+	return (hrt_vaddress)hrt_isp_css_mm_alloc_user_ptr(
+			size, (unsigned int)ptr,
+			userbuffer_attr->pgnr,
+			userbuffer_attr->type,
+			attribute & HRT_BUF_FLAG_CACHED);
+}
+
+void mmgr_clear(
+	hrt_vaddress			vaddr,
+	const size_t			size)
+{
+	mmgr_set(vaddr, (uint8_t)0, size);
+}
+
+void mmgr_set(
+	hrt_vaddress			vaddr,
+	const uint8_t			data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_set((hmm_ptr)HOST_ADDRESS(vaddr), (int)data, size);
+return;
+}
+
+void mmgr_load(
+	const hrt_vaddress		vaddr,
+	void				*data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_load((hmm_ptr)HOST_ADDRESS(vaddr), data, size);
+return;
+}
+
+void mmgr_store(
+	const hrt_vaddress		vaddr,
+	const void				*data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_store((hmm_ptr)HOST_ADDRESS(vaddr), data, size);
+return;
+}
diff --git a/drivers/media/atomisp2/include/hmm/hmm.h b/drivers/media/atomisp2/include/hmm/hmm.h
new file mode 100644
index 0000000..3026f2f
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm.h
@@ -0,0 +1,83 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_H__
+#define	__HMM_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_pool.h"
+
+#define HMM_CACHED true
+#define HMM_UNCACHED false
+
+typedef void * hmm_ptr;
+int hmm_pool_register(unsigned int pool_size, enum hmm_pool_type pool_type);
+void hmm_pool_unregister(enum hmm_pool_type pool_type);
+
+int hmm_init(void);
+void hmm_cleanup(void);
+
+void *hmm_alloc(size_t bytes, enum hmm_bo_type type,
+		int from_highmem, unsigned int userptr, bool cached, void* priv);
+void hmm_free(void *ptr);
+int hmm_load(void *virt, void *data, unsigned int bytes);
+int hmm_store(void *virt, const void *data, unsigned int bytes);
+int hmm_set(void *virt, int c, unsigned int bytes);
+int hmm_flush(void *virt, unsigned int bytes);
+int hmm_get_mmu_base_addr(void);
+
+/*
+ * get kernel memory physical address from ISP virtual address.
+ */
+phys_addr_t hmm_virt_to_phys(void *virt);
+
+/*
+ * map ISP memory starts with virt to kernel virtual address
+ * by using vmap. return NULL if failed.
+ *
+ * !! user needs to use vunmap to unmap it manually before calling
+ * hmm_free to free the memory.
+ *
+ * virt must be the start address of ISP memory (return by hmm_alloc),
+ * do not pass any other address.
+ */
+void *hmm_vmap(void *virt);
+
+/*
+ * map ISP memory starts with virt to specific vma.
+ *
+ * used for mmap operation.
+ *
+ * virt must be the start address of ISP memory (return by hmm_alloc),
+ * do not pass any other address.
+ */
+int hmm_mmap(struct vm_area_struct *vma, void *virt);
+
+extern bool dypool_enable;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_bo.h b/drivers/media/atomisp2/include/hmm/hmm_bo.h
new file mode 100644
index 0000000..edae7be
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_bo.h
@@ -0,0 +1,310 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_H__
+#define	__HMM_BO_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/kref.h>
+#include "hmm_common.h"
+#include "hmm/hmm_vm.h"
+
+#define	check_bo_status_yes_goto(bo, _status, label) \
+	var_not_equal_goto((bo->status & (_status)), (_status), \
+			label, \
+			"HMM buffer status not contain %s.\n", \
+			#_status)
+
+#define	check_bo_status_no_goto(bo, _status, label) \
+	var_equal_goto((bo->status & (_status)), (_status), \
+			label, \
+			"HMM buffer status contains %s.\n", \
+			#_status)
+#define	list_to_hmm_bo(list_ptr)	\
+	list_entry((list_ptr), struct hmm_buffer_object, list)
+
+#define	kref_to_hmm_bo(kref_ptr)	\
+	list_entry((kref_ptr), struct hmm_buffer_object, kref)
+
+#define	check_bo_null_return(bo, exp)	\
+	check_null_return(bo, exp, "NULL hmm buffer object.\n")
+
+#define	check_bo_null_return_void(bo)	\
+	check_null_return_void(bo, "NULL hmm buffer object.\n")
+
+#define	HMM_MAX_ORDER		3
+#define	HMM_MIN_ORDER		0
+
+struct hmm_bo_device;
+
+/*
+ * buffer object type.
+ *
+ *	HMM_BO_PRIVATE:
+ *	pages are allocated by driver itself.
+ *	HMM_BO_SHARE:
+ *	pages are allocated by other component. currently: video driver.
+ *	HMM_BO_USER:
+ *	pages are allocated in user space process.
+ *	HMM_BO_ION:
+ *	pages are allocated through ION.
+ *
+ */
+enum hmm_bo_type {
+	HMM_BO_PRIVATE,
+	HMM_BO_SHARE,
+	HMM_BO_USER,
+	HMM_BO_DMA,
+#ifdef CONFIG_ION
+	HMM_BO_ION,
+#endif
+};
+
+enum hmm_page_type {
+	HMM_PAGE_TYPE_RESERVED,
+	HMM_PAGE_TYPE_DYNAMIC,
+	HMM_PAGE_TYPE_GENERAL,
+};
+
+#define	HMM_BO_VM_ALLOCED	0x1
+#define	HMM_BO_PAGE_ALLOCED	0x2
+#define	HMM_BO_BINDED		0x4
+#define	HMM_BO_MMAPED		0x8
+#define	HMM_BO_ACTIVE		0x1000
+#define	HMM_BO_MEM_TYPE_USER     0x1
+#define	HMM_BO_MEM_TYPE_PFN      0x2
+
+struct hmm_page_object {
+	struct page		*page;
+	enum hmm_page_type	type;
+};
+
+struct hmm_buffer_object {
+	struct hmm_bo_device	*bdev;
+	struct list_head	list;
+	struct kref		kref;
+
+	/* mutex protecting this BO */
+	struct mutex		mutex;
+	enum hmm_bo_type	type;
+	struct hmm_page_object	*page_obj;	/* physical pages */
+	unsigned int		pgnr;	/* page number */
+	int			from_highmem;
+	int			mmap_count;
+	struct hmm_vm_node	*vm_node;
+#ifdef CONFIG_ION
+	struct ion_handle	*ihandle;
+#endif
+	int			status;
+	int         mem_type;
+
+	/*
+	 * release callback for releasing buffer object.
+	 *
+	 * usually set to the release function to release the
+	 * upper level buffer object which has hmm_buffer_object
+	 * embedded in. if the hmm_buffer_object is dynamically
+	 * created by hmm_bo_create, release will set to kfree.
+	 *
+	 */
+	void (*release)(struct hmm_buffer_object *bo);
+};
+
+/*
+ * use this function to initialize pre-allocated hmm_buffer_object.
+ *
+ * the hmm_buffer_object use reference count to manage its life cycle.
+ *
+ * bo->kref is inited to 1.
+ *
+ * use hmm_bo_ref/hmm_bo_unref increase/decrease the reference count,
+ * and hmm_bo_unref will free resource of buffer object (but not the
+ * buffer object itself as it can be both pre-allocated or dynamically
+ * allocated) when reference reaches 0.
+ *
+ * see detailed description of hmm_bo_ref/hmm_bo_unref below.
+ *
+ * as hmm_buffer_object may be used as an embedded object in an upper
+ * level object, a release callback must be provided. if it is
+ * embedded in upper level object, set release call back to release
+ * function of that object. if no upper level object, set release
+ * callback to NULL.
+ *
+ * ex:
+ *	struct hmm_buffer_object bo;
+ *	hmm_bo_init(bdev, &bo, pgnr, NULL);
+ *
+ * or
+ *	struct my_buffer_object {
+ *		struct hmm_buffer_object bo;
+ *		...
+ *	};
+ *
+ *	void my_buffer_release(struct hmm_buffer_object *bo)
+ *	{
+ *		struct my_buffer_object *my_bo =
+ *			container_of(bo, struct my_buffer_object, bo);
+ *
+ *		...	// release resource in my_buffer_object
+ *
+ *		kfree(my_bo);
+ *	}
+ *
+ *	struct my_buffer_object *my_bo =
+ *		kmalloc(sizeof(*my_bo), GFP_KERNEL);
+ *
+ *	hmm_bo_init(bdev, &my_bo->bo, pgnr, my_buffer_release);
+ *	...
+ *
+ *	hmm_bo_unref(&my_bo->bo);
+ */
+int hmm_bo_init(struct hmm_bo_device *bdev,
+		struct hmm_buffer_object *bo,
+		unsigned int pgnr,
+		void (*release)(struct hmm_buffer_object *));
+
+/*
+ * use these functions to dynamically alloc hmm_buffer_object.
+ *
+ * hmm_bo_init will called for that allocated buffer object, and
+ * the release callback is set to kfree.
+ *
+ * ex:
+ *	hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
+ *	...
+ *	hmm_bo_unref(bo);
+ */
+struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev,
+		int pgnr);
+
+/*
+ * increse buffer object reference.
+ */
+void hmm_bo_ref(struct hmm_buffer_object *bo);
+
+/*
+ * decrese buffer object reference. if reference reaches 0,
+ * release function of the buffer object will be called.
+ *
+ * this call is also used to release hmm_buffer_object or its
+ * upper level object with it embedded in. you need to call
+ * this function when it is no longer used.
+ *
+ * Note:
+ *
+ * user dont need to care about internal resource release of
+ * the buffer object in the release callback, it will be
+ * handled internally.
+ *
+ * this call will only release internal resource of the buffer
+ * object but will not free the buffer object itself, as the
+ * buffer object can be both pre-allocated statically or
+ * dynamically allocated. so user need to deal with the release
+ * of the buffer object itself manually. below example shows
+ * the normal case of using the buffer object.
+ *
+ *	struct hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
+ *	......
+ *	hmm_bo_unref(bo);
+ *
+ * or:
+ *
+ *	struct hmm_buffer_object bo;
+ *
+ *	hmm_bo_init(bdev, &bo, pgnr, NULL);
+ *	...
+ *	hmm_bo_unref(&bo);
+ */
+void hmm_bo_unref(struct hmm_buffer_object *bo);
+
+
+/*
+ * put buffer object to unactivated status, meaning put it into
+ * bo->bdev->free_bo_list, but not destroy it.
+ *
+ * this can be used to instead of hmm_bo_destroy if there are
+ * lots of petential hmm_bo_init/hmm_bo_destroy operations with
+ * the same buffer object size. using this with hmm_bo_device_get_bo
+ * can improve performace as lots of memory allocation/free are
+ * avoided..
+ */
+void hmm_bo_unactivate(struct hmm_buffer_object *bo);
+int hmm_bo_activated(struct hmm_buffer_object *bo);
+
+/*
+ * allocate/free virtual address space for the bo.
+ */
+int hmm_bo_alloc_vm(struct hmm_buffer_object *bo);
+void hmm_bo_free_vm(struct hmm_buffer_object *bo);
+int hmm_bo_vm_allocated(struct hmm_buffer_object *bo);
+
+/*
+ * allocate/free physical pages for the bo. will try to alloc mem
+ * from highmem if from_highmem is set, and type indicate that the
+ * pages will be allocated by using video driver (for share buffer)
+ * or by ISP driver itself.
+ */
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
+		enum hmm_bo_type type, int from_highmem,
+		unsigned int userptr, bool cached, void *priv);
+void hmm_bo_free_pages(struct hmm_buffer_object *bo);
+int hmm_bo_page_allocated(struct hmm_buffer_object *bo);
+
+/*
+ * get physical page info of the bo.
+ */
+int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
+		struct hmm_page_object **page_obj, int *pgnr);
+
+/*
+ * bind/unbind the physical pages to a virtual address space.
+ */
+int hmm_bo_bind(struct hmm_buffer_object *bo);
+void hmm_bo_unbind(struct hmm_buffer_object *bo);
+int hmm_bo_binded(struct hmm_buffer_object *bo);
+
+/*
+ * vmap buffer object's pages to contiguous kernel virtual address.
+ * user needs to call vunmap manually to unmap it.
+ */
+void *hmm_bo_vmap(struct hmm_buffer_object *bo);
+
+/*
+ * mmap the bo's physical pages to specific vma.
+ *
+ * vma's address space size must be the same as bo's size,
+ * otherwise it will return -EINVAL.
+ *
+ * vma->vm_flags will be set to (VM_RESERVED | VM_IO).
+ */
+int hmm_bo_mmap(struct vm_area_struct *vma,
+		struct hmm_buffer_object *bo);
+
+extern struct hmm_pool	dynamic_pool;
+extern struct hmm_pool	reserved_pool;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h b/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h
new file mode 100644
index 0000000..9193917
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h
@@ -0,0 +1,119 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_DEV_H__
+#define	__HMM_BO_DEV_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include "mmu/isp_mmu.h"
+#include "hmm/hmm_common.h"
+#include "hmm/hmm_vm.h"
+
+#define	check_bodev_null_return(bdev, exp)	\
+		check_null_return(bdev, exp, \
+			"NULL hmm_bo_device.\n")
+
+#define	check_bodev_null_return_void(bdev)	\
+		check_null_return_void(bdev, \
+			"NULL hmm_bo_device.\n")
+
+#define	HMM_BO_DEVICE_INITED	0x1
+
+struct hmm_buffer_object;
+
+struct hmm_bo_device {
+	/* isp_mmu provides lock itself */
+	struct isp_mmu		mmu;
+
+	/* hmm_vm provides lock itself */
+	struct hmm_vm		vaddr_space;
+
+	struct list_head	free_bo_list;
+	struct list_head	active_bo_list;
+
+	/* list lock is used to protect both of the buffer object lists */
+	struct spinlock		list_lock;
+#ifdef CONFIG_ION
+	struct ion_client	*iclient;
+#endif
+	int			flag;
+};
+
+int hmm_bo_device_init(struct hmm_bo_device *bdev,
+		       struct isp_mmu_client *mmu_driver,
+		       unsigned int vaddr_start, unsigned int size);
+
+/*
+ * clean up all hmm_bo_device related things.
+ */
+void hmm_bo_device_exit(struct hmm_bo_device *bdev);
+
+/*
+ * whether the bo device is inited or not.
+ */
+int hmm_bo_device_inited(struct hmm_bo_device *bdev);
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_start(
+		struct hmm_bo_device *bdev, unsigned int vaddr);
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_in_range(
+		struct hmm_bo_device *bdev, unsigned int vaddr);
+
+/*
+ * find a buffer object with pgnr pages from free_bo_list and
+ * activate it (remove from free_bo_list and add to
+ * active_bo_list)
+ *
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_get_bo(
+		struct hmm_bo_device *bdev, unsigned int pgnr);
+
+/*
+ * destroy all buffer objects in the free_bo_list.
+ */
+void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev);
+/*
+ * destroy buffer object with start virtual address vaddr.
+ */
+void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
+		unsigned int vaddr);
+/*
+ * destroy all buffer objects with pgnr pages.
+ */
+void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
+		unsigned int pgnr);
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_common.h b/drivers/media/atomisp2/include/hmm/hmm_common.h
new file mode 100644
index 0000000..c35f57f
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_common.h
@@ -0,0 +1,81 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_COMMON_H__
+#define	__HMM_BO_COMMON_H__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-common.h>
+
+#define	HMM_BO_NAME	"HMM"
+
+/*
+ * some common use micros
+ */
+#define	var_equal_return(var1, var2, exp, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			return exp;\
+		} \
+	} while (0)
+
+#define	var_equal_return_void(var1, var2, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			return;\
+		} \
+	} while (0)
+
+#define	var_equal_goto(var1, var2, label, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			goto label;\
+		} \
+	} while (0)
+
+#define	var_not_equal_goto(var1, var2, label, fmt, arg ...)	\
+	do { \
+		if ((var1) != (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			goto label;\
+		} \
+	} while (0)
+
+#define	check_null_return(ptr, exp, fmt, arg ...)	\
+		var_equal_return(ptr, NULL, exp, fmt, ## arg)
+
+#define	check_null_return_void(ptr, fmt, arg ...)	\
+		var_equal_return_void(ptr, NULL, fmt, ## arg)
+
+
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_pool.h b/drivers/media/atomisp2/include/hmm/hmm_pool.h
new file mode 100644
index 0000000..3d278be
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_pool.h
@@ -0,0 +1,119 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __HMM_POOL_H__
+#define __HMM_POOL_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/kref.h>
+#include "hmm_common.h"
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_bo.h"
+
+#define ALLOC_PAGE_FAIL_NUM		5
+
+enum hmm_pool_type {
+	HMM_POOL_TYPE_RESERVED,
+	HMM_POOL_TYPE_DYNAMIC,
+};
+
+/**
+ * struct hmm_pool_ops  -  memory pool callbacks.
+ *
+ * @pool_init:		   initialize the memory pool.
+ * @pool_exit:		   uninitialize the memory pool.
+ * @pool_alloc_pages:	   allocate pages from memory pool.
+ * @pool_free_pages:	   free pages to memory pool.
+ * @pool_inited:	   check whether memory pool is initialized.
+ */
+struct hmm_pool_ops {
+	int (*pool_init)(void **pool, unsigned int pool_size);
+	void (*pool_exit)(void **pool);
+	unsigned int (*pool_alloc_pages)(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached);
+	void (*pool_free_pages)(void *pool,
+				struct hmm_page_object *page_obj);
+	int (*pool_inited)(void *pool);
+};
+
+struct hmm_pool {
+	struct hmm_pool_ops	*pops;
+
+	void			*pool_info;
+};
+
+/**
+ * struct hmm_reserved_pool_info  - represents reserved pool private data.
+ * @pages:			    a array that store physical pages.
+ *				    The array is as reserved memory pool.
+ * @index:			    to indicate the first blank page number
+ *				    in reserved memory pool(pages array).
+ * @pgnr:			    the valid page amount in reserved memory
+ *				    pool.
+ * @list_lock:			    list lock is used to protect the operation
+ *				    to reserved memory pool.
+ * @flag:			    reserved memory pool state flag.
+ */
+struct hmm_reserved_pool_info {
+	struct page		**pages;
+
+	unsigned int		index;
+	unsigned int		pgnr;
+	struct spinlock		list_lock;
+	bool			initialized;
+};
+
+/**
+ * struct hmm_dynamic_pool_info  -  represents dynamic pool private data.
+ * @pages_list:			    a list that store physical pages.
+ *				    The pages list is as dynamic memory pool.
+ * @list_lock:			    list lock is used to protect the operation
+ *				    to dynamic memory pool.
+ * @flag:			    dynamic memory pool state flag.
+ * @pgptr_cache:		    struct kmem_cache, manages a cache.
+ */
+struct hmm_dynamic_pool_info {
+	struct list_head	pages_list;
+
+	/* list lock is used to protect the free pages block lists */
+	struct spinlock		list_lock;
+
+#ifdef USE_KMEM_CACHE
+	struct kmem_cache	*pgptr_cache;
+#endif
+	bool			initialized;
+};
+
+struct hmm_page {
+	struct page		*page;
+	struct list_head	list;
+};
+
+extern struct hmm_pool_ops	reserved_pops;
+extern struct hmm_pool_ops	dynamic_pops;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_vm.h b/drivers/media/atomisp2/include/hmm/hmm_vm.h
new file mode 100644
index 0000000..07d4066
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_vm.h
@@ -0,0 +1,68 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_VM_H__
+#define	__HMM_VM_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+
+struct hmm_vm {
+	unsigned int start;
+	unsigned int pgnr;
+	unsigned int size;
+	struct list_head vm_node_list;
+	spinlock_t lock;
+	struct kmem_cache *cache;
+};
+
+struct hmm_vm_node {
+	struct list_head list;
+	unsigned int start;
+	unsigned int pgnr;
+	unsigned int size;
+	struct hmm_vm *vm;
+};
+#define	ISP_VM_START	0x0
+#define	ISP_VM_SIZE	(0x7FFFFFFF)	/* 2G address space */
+#define	ISP_PTR_NULL	NULL
+
+int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
+		unsigned int size);
+
+void hmm_vm_clean(struct hmm_vm *vm);
+
+struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm,
+		unsigned int pgnr);
+
+void hmm_vm_free_node(struct hmm_vm_node *node);
+
+struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm,
+		unsigned int addr);
+
+struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
+		unsigned int addr);
+
+#endif
diff --git a/drivers/media/atomisp2/include/mmu/isp_mmu.h b/drivers/media/atomisp2/include/mmu/isp_mmu.h
new file mode 100644
index 0000000..8ba8e4c
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/isp_mmu.h
@@ -0,0 +1,177 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * ISP MMU driver for classic two-level page tables
+ */
+#ifndef	__ISP_MMU_H__
+#define	__ISP_MMU_H__
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+/*
+ * do not change these values, the page size for ISP must be the
+ * same as kernel's page size.
+ */
+#define	ISP_PAGE_OFFSET		12
+#define	ISP_PAGE_SIZE		(1U << ISP_PAGE_OFFSET)
+#define	ISP_PAGE_MASK		(~(ISP_PAGE_SIZE - 1))
+
+#define	ISP_L1PT_OFFSET		22
+#define	ISP_L1PT_MASK		(~((1U << ISP_L1PT_OFFSET) - 1))
+
+#define	ISP_L2PT_OFFSET		12
+#define	ISP_L2PT_MASK		(~(ISP_L1PT_MASK|(~(ISP_PAGE_MASK))))
+
+#define	ISP_L1PT_PTES		1024
+#define	ISP_L2PT_PTES		1024
+
+#define	ISP_PTR_TO_L1_IDX(x)	((((x) & ISP_L1PT_MASK)) \
+					>> ISP_L1PT_OFFSET)
+
+#define	ISP_PTR_TO_L2_IDX(x)	((((x) & ISP_L2PT_MASK)) \
+					>> ISP_L2PT_OFFSET)
+
+#define	ISP_PAGE_ALIGN(x)	(((x) + (ISP_PAGE_SIZE-1)) \
+					& ISP_PAGE_MASK)
+
+#define	ISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\
+		((l1_idx) << ISP_L1PT_OFFSET) | \
+		((l2_idx) << ISP_L2PT_OFFSET) | \
+		(offset)\
+} while (0)
+
+#define	pgnr_to_size(pgnr)	((pgnr) << ISP_PAGE_OFFSET)
+#define	size_to_pgnr_ceil(size)	(((size) + (1 << ISP_PAGE_OFFSET) - 1)\
+						>> ISP_PAGE_OFFSET)
+#define	size_to_pgnr_bottom(size)	((size) >> ISP_PAGE_OFFSET)
+
+struct isp_mmu;
+
+struct isp_mmu_client {
+	/*
+	 * const value
+	 *
+	 * @name:
+	 *      driver name
+	 * @pte_valid_mask:
+	 *      should be 1 bit valid data, meaning the value should
+	 *      be power of 2.
+	 */
+	char *name;
+	unsigned int pte_valid_mask;
+	unsigned int null_pte;
+
+	/*
+	 * set page directory base address (physical address).
+	 *
+	 * must be provided.
+	 */
+	int (*set_pd_base) (struct isp_mmu *mmu,
+			phys_addr_t pd_base);
+	unsigned int (*get_pd_base) (struct isp_mmu *mmu,
+			phys_addr_t pd_base);
+	/*
+	 * callback to flush tlb.
+	 *
+	 * tlb_flush_range will at least flush TLBs containing
+	 * address mapping from addr to addr + size.
+	 *
+	 * tlb_flush_all will flush all TLBs.
+	 *
+	 * tlb_flush_all is must be provided. if tlb_flush_range is
+	 * not valid, it will set to tlb_flush_all by default.
+	 */
+	void (*tlb_flush_range) (struct isp_mmu *mmu,
+				 unsigned int addr, unsigned int size);
+	void (*tlb_flush_all) (struct isp_mmu *mmu);
+	unsigned int (*phys_to_pte) (struct isp_mmu *mmu,
+				     phys_addr_t phys);
+	phys_addr_t (*pte_to_phys) (struct isp_mmu *mmu,
+				    unsigned int pte);
+
+};
+
+struct isp_mmu {
+	struct isp_mmu_client *driver;
+	unsigned int l1_pte;
+	unsigned int base_address;
+
+	struct mutex pt_mutex;
+#ifdef USE_KMEM_CACHE
+	struct kmem_cache *tbl_cache;
+#endif
+};
+
+/* flags for PDE and PTE */
+#define	ISP_PTE_VALID_MASK(mmu)	\
+	((mmu)->driver->pte_valid_mask)
+
+#define	ISP_PTE_VALID(mmu, pte)	\
+	((pte) & ISP_PTE_VALID_MASK(mmu))
+
+#define	NULL_PAGE	((phys_addr_t)(-1) & ISP_PAGE_MASK)
+#define	PAGE_VALID(page)	((page) != NULL_PAGE)
+
+/*
+ * init mmu with specific mmu driver.
+ */
+int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver);
+/*
+ * cleanup all mmu related things.
+ */
+void isp_mmu_exit(struct isp_mmu *mmu);
+
+/*
+ * setup/remove address mapping for pgnr continous physical pages
+ * and isp_virt.
+ *
+ * map/unmap is mutex lock protected, and caller does not have
+ * to do lock/unlock operation.
+ *
+ * map/unmap will not flush tlb, and caller needs to deal with
+ * this itself.
+ */
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		phys_addr_t phys, unsigned int pgnr);
+
+void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+		   unsigned int pgnr);
+
+static inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_all)
+		mmu->driver->tlb_flush_all(mmu);
+}
+
+#define isp_mmu_flush_tlb isp_mmu_flush_tlb_all
+
+static inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,
+		unsigned int start, unsigned int size)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_range)
+		mmu->driver->tlb_flush_range(mmu, start, size);
+}
+
+#endif /* ISP_MMU_H_ */
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu.h b/drivers/media/atomisp2/include/mmu/sh_mmu.h
new file mode 100644
index 0000000..06041e9
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu.h
@@ -0,0 +1,76 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef	SH_MMU_H_
+#define	SH_MMU_H_
+
+
+#include <sh_css.h>
+
+#include "mmu/isp_mmu.h"
+
+
+/*
+ * include SH header file here
+ */
+
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+		unsigned int phys)
+{
+	sh_css_mmu_set_page_table_base_address((void *)phys);
+	return 0;
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	sh_css_mmu_invalidate_cache();
+}
+
+static struct isp_mmu_driver sh_mmu_driver = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = 0x1,
+	.set_pd_base = sh_set_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+};
+
+#define	ISP_VM_START	0x0
+#define	ISP_VM_SIZE	(1 << 30)	/* 1G address space */
+#define	ISP_PTR_NULL	NULL
+
+#endif /* SH_MMU_H_ */
+
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h b/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h
new file mode 100644
index 0000000..359deb2
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__SH_MMU_MFLD_H__
+#define	__SH_MMU_MFLD_H__
+
+extern struct isp_mmu_client sh_mmu_mfld;
+#endif
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h b/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h
new file mode 100644
index 0000000..b9bad9f
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Merrifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__SH_MMU_MRFLD_H__
+#define	__SH_MMU_MRFLD_H__
+
+extern struct isp_mmu_client sh_mmu_mrfld;
+#endif
diff --git a/drivers/media/atomisp2/mmu/isp_mmu.c b/drivers/media/atomisp2/mmu/isp_mmu.c
new file mode 100644
index 0000000..cfc2c8d
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/isp_mmu.c
@@ -0,0 +1,578 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * ISP MMU management wrap code
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>
+#include <linux/mm.h>		/* for GFP_ATOMIC */
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/list.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+
+#include "mmu/isp_mmu.h"
+#include "atomisp_internal.h"
+
+static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
+				unsigned int end_isp_virt);
+
+static unsigned int atomisp_get_pte(phys_addr_t pt, unsigned int idx)
+{
+	unsigned int pt_virt = (unsigned int)phys_to_virt(pt);
+	return *(((unsigned int *) pt_virt) + idx);
+}
+
+static void atomisp_set_pte(phys_addr_t pt,
+			    unsigned int idx, unsigned int pte)
+{
+	unsigned int pt_virt = (unsigned int)phys_to_virt(pt);
+	(*(((unsigned int *) pt_virt) + idx)) = pte;
+}
+
+static void *isp_pt_phys_to_virt(phys_addr_t phys)
+{
+	return phys_to_virt(phys);
+}
+
+static phys_addr_t isp_pte_to_pgaddr(struct isp_mmu *mmu,
+				     unsigned int pte)
+{
+	return mmu->driver->pte_to_phys(mmu, pte);
+}
+
+static unsigned int isp_pgaddr_to_pte_valid(struct isp_mmu *mmu,
+					    phys_addr_t phys)
+{
+	unsigned int pte = mmu->driver->phys_to_pte(mmu, phys);
+	return (unsigned int) (pte | ISP_PTE_VALID_MASK(mmu));
+}
+
+/*
+ * allocate a uncacheable page table.
+ * return physical address.
+ */
+static phys_addr_t alloc_page_table(struct isp_mmu *mmu)
+{
+	int i;
+	phys_addr_t page;
+	/*page table lock may needed here*/
+#ifdef USE_KMEM_CACHE
+	void *virt = kmem_cache_zalloc(mmu->tbl_cache, GFP_KERNEL);
+#else
+	void *virt = (void *)__get_free_page(GFP_KERNEL);
+#endif
+	if (!virt)
+		return (phys_addr_t)NULL_PAGE;
+
+	/*
+	 * we need a uncacheable page table.
+	 */
+#ifdef	CONFIG_X86
+	set_memory_uc((unsigned long)virt, 1);
+#endif
+
+	page = virt_to_phys(virt);
+
+	for (i = 0; i < 1024; i++) {
+		/* NEED CHECK */
+		atomisp_set_pte(page, i, mmu->driver->null_pte);
+	}
+
+	return page;
+}
+
+static void free_page_table(struct isp_mmu *mmu, phys_addr_t page)
+{
+	void *virt;
+	page &= ISP_PAGE_MASK;
+	/*
+	 * reset the page to write back before free
+	 */
+	virt = phys_to_virt(page);
+
+#ifdef	CONFIG_X86
+	set_memory_wb((unsigned long)virt, 1);
+#endif
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_free(mmu->tbl_cache, virt);
+#else
+	free_page((unsigned long)virt);
+#endif
+}
+
+static void mmu_remap_error(struct isp_mmu *mmu,
+			    phys_addr_t l1_pt, unsigned int l1_idx,
+			    phys_addr_t l2_pt, unsigned int l2_idx,
+			    unsigned int isp_virt, phys_addr_t old_phys,
+			    phys_addr_t new_phys)
+{
+	v4l2_err(&atomisp_dev, "address remap:\n\n"
+		     "\tL1 PT: virt = 0x%x, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tL2 PT: virt = 0x%x, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\told: isp_virt = 0x%x, phys = 0x%llx\n"
+		     "\tnew: isp_virt = 0x%x, phys = 0x%llx\n",
+		     (unsigned int)isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx,
+		     (unsigned int)isp_pt_phys_to_virt(l2_pt),
+		     (u64)l2_pt, l2_idx, (unsigned int)isp_virt,
+		     (u64)old_phys, (unsigned int)isp_virt,
+		     (u64)new_phys);
+}
+
+static void mmu_unmap_l2_pte_error(struct isp_mmu *mmu,
+				   phys_addr_t l1_pt, unsigned int l1_idx,
+				   phys_addr_t l2_pt, unsigned int l2_idx,
+				   unsigned int isp_virt, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L2 pte:\n\n"
+		     "\tL1 PT: virt = 0x%x, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tL2 PT: virt = 0x%x, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tisp_virt = 0x%x, pte(page phys) = 0x%x\n",
+		     (unsigned int)isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx,
+		     (unsigned int)isp_pt_phys_to_virt(l2_pt),
+		     (u64)l2_pt, l2_idx, (unsigned int)isp_virt,
+		     (unsigned int)pte);
+}
+
+static void mmu_unmap_l1_pte_error(struct isp_mmu *mmu,
+				   phys_addr_t l1_pt, unsigned int l1_idx,
+				   unsigned int isp_virt, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L1 pte (L2 PT):\n\n"
+		     "\tL1 PT: virt = 0x%x, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tisp_virt = 0x%x, l1_pte(L2 PT) = 0x%x\n",
+		     (unsigned int)isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx, (unsigned int)isp_virt,
+		     (unsigned int)pte);
+}
+
+static void mmu_unmap_l1_pt_error(struct isp_mmu *mmu, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L1PT:\n\n"
+		     "L1PT = 0x%x\n", (unsigned int)pte);
+}
+
+/*
+ * Update L2 page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_l2_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
+		      unsigned int l1_idx, phys_addr_t l2_pt,
+		      unsigned int start, unsigned int end, phys_addr_t phys)
+{
+	unsigned int ptr;
+	unsigned int idx;
+	unsigned int pte;
+
+	l2_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+	phys &= ISP_PAGE_MASK;
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L2_IDX(ptr);
+
+		pte = atomisp_get_pte(l2_pt, idx);
+
+		if (ISP_PTE_VALID(mmu, pte)) {
+			mmu_remap_error(mmu, l1_pt, l1_idx,
+					  l2_pt, idx, ptr, pte, phys);
+
+			/* free all mapped pages */
+			free_mmu_map(mmu, start, ptr);
+
+			return -EINVAL;
+		}
+
+		pte = isp_pgaddr_to_pte_valid(mmu, phys);
+
+		atomisp_set_pte(l2_pt, idx, pte);
+		ptr += (1U << ISP_L2PT_OFFSET);
+		phys += (1U << ISP_L2PT_OFFSET);
+	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
+
+	return 0;
+}
+
+/*
+ * Update L1 page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
+		      unsigned int start, unsigned int end,
+		      phys_addr_t phys)
+{
+	phys_addr_t l2_pt;
+	unsigned int ptr, l1_aligned;
+	unsigned int idx;
+	unsigned int l2_pte;
+	int ret;
+
+	l1_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+	phys &= ISP_PAGE_MASK;
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L1_IDX(ptr);
+
+		l2_pte = atomisp_get_pte(l1_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, l2_pte)) {
+			l2_pt = alloc_page_table(mmu);
+			if (l2_pt == NULL_PAGE) {
+				v4l2_err(&atomisp_dev,
+					     "alloc page table fail.\n");
+
+				/* free all mapped pages */
+				free_mmu_map(mmu, start, ptr);
+
+				return -ENOMEM;
+			}
+
+			l2_pte = isp_pgaddr_to_pte_valid(mmu, l2_pt);
+
+			atomisp_set_pte(l1_pt, idx, l2_pte);
+		}
+
+		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
+
+		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
+
+		if (l1_aligned < end) {
+			ret = mmu_l2_map(mmu, l1_pt, idx,
+					   l2_pt, ptr, l1_aligned, phys);
+			phys += (l1_aligned - ptr);
+			ptr = l1_aligned;
+		} else {
+			ret = mmu_l2_map(mmu, l1_pt, idx,
+					   l2_pt, ptr, end, phys);
+			phys += (end - ptr);
+			ptr = end;
+		}
+
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "setup mapping in L2PT fail.\n");
+
+			/* free all mapped pages */
+			free_mmu_map(mmu, start, ptr);
+
+			return -EINVAL;
+		}
+	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
+
+	return 0;
+}
+
+/*
+ * Update page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		   phys_addr_t phys, unsigned int pgnr)
+{
+	unsigned int start, end;
+	phys_addr_t l1_pt;
+	int ret;
+
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		/*
+		 * allocate 1 new page for L1 page table
+		 */
+		l1_pt = alloc_page_table(mmu);
+		if (l1_pt == NULL_PAGE) {
+			v4l2_err(&atomisp_dev,
+				    "alloc page table fail.\n");
+			return -ENOMEM;
+		}
+
+		/*
+		 * setup L1 page table physical addr to MMU
+		 */
+		ret = mmu->driver->set_pd_base(mmu, l1_pt);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				     "set page directory base address "
+				     "fail.\n");
+			return ret;
+		}
+		mmu->base_address = l1_pt;
+		mmu->l1_pte = isp_pgaddr_to_pte_valid(mmu, l1_pt);
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	start = (isp_virt) & ISP_PAGE_MASK;
+	end = start + (pgnr << ISP_PAGE_OFFSET);
+	phys &= ISP_PAGE_MASK;
+
+	ret = mmu_l1_map(mmu, l1_pt, start, end, phys);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "setup mapping in L1PT fail.\n");
+
+	return ret;
+}
+
+/*
+ * Free L2 page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_l2_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
+			   unsigned int l1_idx, phys_addr_t l2_pt,
+			   unsigned int start, unsigned int end)
+{
+
+	unsigned int ptr;
+	unsigned int idx;
+	unsigned int pte;
+
+	l2_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L2_IDX(ptr);
+
+		pte = atomisp_get_pte(l2_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, pte))
+			mmu_unmap_l2_pte_error(mmu, l1_pt, l1_idx,
+						 l2_pt, idx, ptr, pte);
+
+		atomisp_set_pte(l2_pt, idx, mmu->driver->null_pte);
+
+		ptr += (1U << ISP_L2PT_OFFSET);
+	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
+}
+
+/*
+ * Free L1 page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_l1_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
+			   unsigned int start, unsigned int end)
+{
+	phys_addr_t l2_pt;
+	unsigned int ptr, l1_aligned;
+	unsigned int idx;
+	unsigned int l2_pte;
+
+	l1_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L1_IDX(ptr);
+
+		l2_pte = atomisp_get_pte(l1_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, l2_pte)) {
+			mmu_unmap_l1_pte_error(mmu, l1_pt, idx, ptr, l2_pte);
+			continue;
+		}
+
+		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
+
+		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
+
+		if (l1_aligned < end) {
+			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, l1_aligned);
+			ptr = l1_aligned;
+		} else {
+			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, end);
+			ptr = end;
+		}
+		/*
+		 * use the same L2 page next time, so we dont
+		 * need to invalidate and free this PT.
+		 */
+		/*      atomisp_set_pte(l1_pt, idx, NULL_PTE); */
+	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
+}
+
+/*
+ * Free page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+			unsigned int pgnr)
+{
+	unsigned int start, end;
+	phys_addr_t l1_pt;
+
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		mmu_unmap_l1_pt_error(mmu, mmu->l1_pte);
+		return;
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	start = (isp_virt) & ISP_PAGE_MASK;
+	end = start + (pgnr << ISP_PAGE_OFFSET);
+
+	mmu_l1_unmap(mmu, l1_pt, start, end);
+}
+
+/*
+ * Free page tables according to isp start virtual address and end virtual
+ * address.
+ */
+static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
+				unsigned int end_isp_virt)
+{
+	unsigned int pgnr;
+	unsigned int start, end;
+
+	start = (start_isp_virt) & ISP_PAGE_MASK;
+	end = (end_isp_virt) & ISP_PAGE_MASK;
+	pgnr = (end - start) >> ISP_PAGE_OFFSET;
+	mmu_unmap(mmu, start, pgnr);
+}
+
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		phys_addr_t phys, unsigned int pgnr)
+{
+	return mmu_map(mmu, isp_virt, phys, pgnr);
+}
+
+void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+		   unsigned int pgnr)
+{
+	mmu_unmap(mmu, isp_virt, pgnr);
+}
+
+static void isp_mmu_flush_tlb_range_default(struct isp_mmu *mmu,
+					      unsigned int start,
+					      unsigned int size)
+{
+	isp_mmu_flush_tlb(mmu);
+}
+
+/*MMU init for internal structure*/
+int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver)
+{
+	if (!mmu)		/* error */
+		return -EINVAL;
+	if (!driver)		/* error */
+		return -EINVAL;
+
+	if (!driver->name)
+		v4l2_warn(&atomisp_dev,
+			    "NULL name for MMU driver...\n");
+
+	mmu->driver = driver;
+
+	if (!driver->set_pd_base ||
+		!driver->get_pd_base || !driver->tlb_flush_all) {
+		v4l2_err(&atomisp_dev,
+			    "set_pd_base or tlb_flush_all operation "
+			     "not provided.\n");
+		return -EINVAL;
+	}
+
+	if (!driver->tlb_flush_range)
+		driver->tlb_flush_range = isp_mmu_flush_tlb_range_default;
+
+	if (!driver->pte_valid_mask) {
+		v4l2_err(&atomisp_dev,
+			 "PTE_MASK is missing from mmu driver\n");
+		return -EINVAL;
+	}
+
+	mmu->l1_pte = driver->null_pte;
+
+	mutex_init(&mmu->pt_mutex);
+#ifndef CSS_2
+	isp_mmu_flush_tlb(mmu);
+#endif
+#ifdef USE_KMEM_CACHE
+	mmu->tbl_cache = kmem_cache_create("iopte_cache", ISP_PAGE_SIZE,
+						//ISP_L1PT_PTES, SLAB_HWCACHE_ALIGN,
+					   ISP_PAGE_SIZE, SLAB_HWCACHE_ALIGN,
+					   NULL);
+	if (!mmu->tbl_cache)
+		return -ENOMEM;
+#endif
+
+	return 0;
+}
+
+/*Free L1 and L2 page table*/
+void isp_mmu_exit(struct isp_mmu *mmu)
+{
+	unsigned int idx;
+	unsigned int pte;
+	phys_addr_t l1_pt, l2_pt;
+
+	if (!mmu)
+		return;
+
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		v4l2_warn(&atomisp_dev,
+			    "invalid L1PT: pte = 0x%x\n",
+			    (unsigned int)mmu->l1_pte);
+		return;
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	for (idx = 0; idx < ISP_L1PT_PTES; idx++) {
+		pte = atomisp_get_pte(l1_pt, idx);
+
+		if (ISP_PTE_VALID(mmu, pte)) {
+			l2_pt = isp_pte_to_pgaddr(mmu, pte);
+
+			free_page_table(mmu, l2_pt);
+		}
+	}
+
+	free_page_table(mmu, l1_pt);
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_destroy(mmu->tbl_cache);
+#endif
+}
diff --git a/drivers/media/atomisp2/mmu/sh_mmu_mfld.c b/drivers/media/atomisp2/mmu/sh_mmu_mfld.c
new file mode 100644
index 0000000..6b60799
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/sh_mmu_mfld.c
@@ -0,0 +1,82 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include <host/mmu_local.h>
+#include <atomisp_internal.h>
+#include <atomisp_compat.h>
+#include "mmu/isp_mmu.h"
+#include "memory_access/memory_access.h"
+/*
+ * include SH header file here
+ */
+
+static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
+				   phys_addr_t phys)
+{
+	return (unsigned int)phys;
+}
+
+static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
+				  unsigned int pte)
+{
+	return (phys_addr_t)(pte & ISP_PAGE_MASK);
+}
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	/*mmgr_set_base_address(HOST_ADDRESS(u32)phys);*/
+	atomisp_sh_css_mmu_set_page_table_base_index(HOST_ADDRESS(u32)phys);
+	return 0;
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	ia_css_mmu_invalidate_cache();
+}
+
+struct isp_mmu_client sh_mmu_mfld = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = 0x1,
+	.null_pte = (u32)NULL_PAGE,
+	.set_pd_base = sh_set_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+	.phys_to_pte = sh_phys_to_pte,
+	.pte_to_phys = sh_pte_to_phys,
+};
diff --git a/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c b/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c
new file mode 100644
index 0000000..2269b01
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c
@@ -0,0 +1,92 @@
+/*
+ * Support for Merrifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2012 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <host/mmu_local.h>
+#include <atomisp_internal.h>
+#include <atomisp_compat.h>
+#include "mmu/isp_mmu.h"
+#include "memory_access/memory_access.h"
+
+/*
+ * include SH header file here
+ */
+
+static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
+				   phys_addr_t phys)
+{
+	return phys >> ISP_PAGE_OFFSET;
+}
+
+static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
+				  unsigned int pte)
+{
+	unsigned int mask = mmu->driver->pte_valid_mask;
+	return (phys_addr_t)((pte & ~mask) << ISP_PAGE_OFFSET);
+}
+
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	unsigned int pte = sh_phys_to_pte(mmu, phys);
+	/*mmgr_set_base_address(HOST_ADDRESS(pte));*/
+	atomisp_sh_css_mmu_set_page_table_base_index(HOST_ADDRESS(pte));
+	return 0;
+}
+
+static unsigned int sh_get_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	unsigned int pte = sh_phys_to_pte(mmu, phys);
+	return HOST_ADDRESS(pte);
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	ia_css_mmu_invalidate_cache();
+}
+
+struct isp_mmu_client sh_mmu_mrfld = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = 0x80000000,
+	.null_pte = NULL_PAGE >> ISP_PAGE_OFFSET,
+	.set_pd_base = sh_set_pd_base,
+	.get_pd_base = sh_get_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+	.phys_to_pte = sh_phys_to_pte,
+	.pte_to_phys = sh_pte_to_phys,
+};
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 94bce78..8ae008e 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -556,6 +556,20 @@ config VIDEO_S5K6AA
 	  This is a V4L2 sensor-level driver for Samsung S5K6AA(FX) 1.3M
 	  camera sensor with an embedded SoC image signal processor.
 
+config VIDEO_MT9M114
+	tristate "Aptina MT9M114 sensor support"
+	depends on VIDEO_ATOMISP
+	default m
+	---help---
+	  Aptina MT9M114 sensor for ATOMISP
+
+config VIDEO_OV5640
+	tristate "Omnivision OV5640 sensor support"
+	depends on VIDEO_ATOMISP
+	default m
+	---help---
+	  Omnivision OV5640 sensor for ATOMISP
+
 comment "Flash devices"
 
 config VIDEO_ADP1653
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 279cd6a..d7f101f 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -213,6 +213,14 @@ obj-y	+= davinci/
 
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
 
+# For Omnivision camera sensor
+obj-$(CONFIG_VIDEO_OV5640) += ov5640_2.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640_1.o
+
+# For Aptina camera sensor
+obj-$(CONFIG_VIDEO_MT9M114) += mt9m114.o
+
+
 ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb/frontends
 ccflags-y += -I$(srctree)/drivers/media/common/tuners
diff --git a/drivers/media/video/mt9m114.c b/drivers/media/video/mt9m114.c
new file mode 100644
index 0000000..acccbd8
--- /dev/null
+++ b/drivers/media/video/mt9m114.c
@@ -0,0 +1,1632 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "mt9m114.h"
+
+#define to_mt9m114_sensor(sd) container_of(sd, struct mt9m114_device, sd)
+#define CAMERA_FORMAT 0xc86c //colour format output from the sensor
+
+/*
+ * TODO: use debug parameter to actually define when debug messages should
+ * be printed.
+ */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_wait_state(struct i2c_client *client, int timeout);
+
+static const struct sensor_format {
+         enum v4l2_mbus_pixelcode mbus_code;
+ } mt9m114_formats[] = {
+   	 {
+                 .mbus_code      = 0x8003,
+         },
+	 {
+                 .mbus_code      = V4L2_MBUS_FMT_FIXED,
+         },
+         {
+                 .mbus_code      = V4L2_MBUS_FMT_UYVY8_1X16,
+         },
+         {
+                 .mbus_code      = V4L2_MBUS_FMT_UYVY8_2X8,
+         },
+         {
+                 .mbus_code      = V4L2_MBUS_FMT_RGB565_2X8_LE,
+         },
+
+ };
+ 
+static int
+mt9m114_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u16) (reg >> 8);
+	data[1] = (u16) (reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if (err >= 0) {
+		*val = 0;
+		/* high byte comes first */
+		if (data_length == MISENSOR_8BIT)
+			*val = data[0];
+		else if (data_length == MISENSOR_16BIT)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+			    (data[1] << 16) + (data[0] << 24);
+
+		return 0;
+	}
+
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int
+mt9m114_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu((u16)val);
+	} else {
+		/* MISENSOR_32BIT */
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = be32_to_cpu(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * HACK: Need some delay here for Rev 2 sensors otherwise some
+	 * registers do not seem to load correctly.
+	 */
+	mdelay(1);
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/**
+ * misensor_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16/32-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+misensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+		     u32 mask, u32 set)
+{
+	int err;
+	u32 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	switch (data_length) {
+	case MISENSOR_8BIT:
+		if (mask & ~0xff)
+			return -EINVAL;
+		break;
+	case MISENSOR_16BIT:
+		if (mask & ~0xffff)
+			return -EINVAL;
+		break;
+	case MISENSOR_32BIT:
+		break;
+	default:
+		/* Wrong @data_length */
+		return -EINVAL;
+	}
+
+	err = mt9m114_read_reg(client, data_length, reg, &val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, read failed\n");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9m114_write_reg(client, data_length, reg, val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, write failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int __mt9m114_flush_reg_array(struct i2c_client *client,
+				     struct mt9m114_write_ctrl *ctrl)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+	if (ctrl->index == 0)
+		return 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + ctrl->index;
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	msg.buf = (u8 *)&ctrl->buffer;
+
+	ret = i2c_transfer(client->adapter, &msg, num_msg);
+	if (ret != num_msg) {
+		if (++retry <= I2C_RETRY_COUNT) {
+			dev_dbg(&client->dev, "retrying... %d\n", retry);
+			msleep(20);
+			goto again;
+		}
+		dev_err(&client->dev, "%s: i2c transfer error\n", __func__);
+		return -EIO;
+	}
+
+	ctrl->index = 0;
+
+	/*
+	 * REVISIT: Previously we had a delay after writing data to sensor.
+	 * But it was removed as our tests have shown it is not necessary
+	 * anymore.
+	 */
+
+	return 0;
+}
+
+static int __mt9m114_buf_reg_array(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	u16 *data16;
+	u32 *data32;
+	int err;
+
+	/* Insufficient buffer? Let's flush and get more free space. */
+	if (ctrl->index + next->length >= MT9M114_MAX_WRITE_BUF_SIZE) {
+		err = __mt9m114_flush_reg_array(client, ctrl);
+		if (err)
+			return err;
+	}
+
+	switch (next->length) {
+	case MISENSOR_8BIT:
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MISENSOR_16BIT:
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	case MISENSOR_32BIT:
+		data32 = (u32 *)&ctrl->buffer.data[ctrl->index];
+		*data32 = cpu_to_be32(next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += next->length;
+
+	return 0;
+}
+
+static int
+__mt9m114_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+/*
+ * mt9m114_write_reg_array - Initializes a list of mt9m114 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ * @poll: completion polling requirement
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9m114_flush_reg_array, __mt9m114_buf_reg_array() and
+ * __mt9m114_write_reg_is_consecutive() are internal functions to
+ * mt9m114_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int mt9m114_write_reg_array(struct i2c_client *client,
+				const struct misensor_reg *reglist,
+				int poll)
+{
+	const struct misensor_reg *next = reglist;
+	struct mt9m114_write_ctrl ctrl;
+	int err;
+
+	if (poll == PRE_POLLING) {
+		err = mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+		if (err)
+			return err;
+	}
+
+	ctrl.index = 0;
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		switch (next->length & MISENSOR_TOK_MASK) {
+		case MISENSOR_TOK_DELAY:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		case MISENSOR_TOK_RMW:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			err |= misensor_rmw_reg(client,
+						next->length &
+							~MISENSOR_TOK_RMW,
+						next->reg, next->val,
+						next->val2);
+			if (err) {
+				dev_err(&client->dev, "%s read err. aborted\n",
+					__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9m114_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9m114_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9m114_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	err = __mt9m114_flush_reg_array(client, &ctrl);
+	if (err)
+		return err;
+
+	if (poll == POST_POLLING)
+		return mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+
+	return 0;
+}
+
+
+static int mt9m114_wait_3a(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int timeout = 135;
+	int ret;
+	unsigned int status_exp, status_wb;
+
+	while (timeout--) {
+		ret = mt9m114_read_reg(client, MISENSOR_16BIT,
+			MISENSOR_AE_TRACK_STATUS, &status_exp);
+		if (ret)
+			return ret;
+		if (!(status_exp & MISENSOR_AE_READY)) {
+			msleep(20);
+			continue;
+		}
+		ret = mt9m114_read_reg(client,
+			MISENSOR_16BIT, MISENSOR_AWB_STATUS, &status_wb);
+		if (ret)
+			return ret;
+		if (status_wb & MISENSOR_AWB_STEADY) {
+			dev_dbg(&client->dev, "ae/awb stablize retry count  %d.\n",
+				  (135-timeout));
+			printk(KERN_ALERT "ae/awb stablize retry count  %d.\n", (135-timeout));
+			return 0;
+		}
+		msleep(20);
+	}
+
+	return -EINVAL;
+}
+
+static int mt9m114_wait_state(struct i2c_client *client, int timeout)
+{
+	int ret;
+	unsigned int val;
+
+	while (timeout-- > 0) {
+		ret = mt9m114_read_reg(client, MISENSOR_16BIT, 0x0080, &val);
+		if (ret)
+			return ret;
+		if ((val & 0x2) == 0)
+			return 0;
+		msleep(20);
+	}
+
+	return -EINVAL;
+
+}
+
+static int mt9m114_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_suspend, POST_POLLING);
+}
+
+static int mt9m114_set_streaming(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_streaming, POST_POLLING);
+}
+
+static int mt9m114_init_common(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = mt9m114_write_reg_array(client, mt9m114_common, PRE_POLLING);
+	if (ret)
+		return ret;
+	ret = mt9m114_write_reg_array(client, mt9m114_iq, NO_POLLING);
+
+	return ret;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+	/*
+	 * according to DS, 44ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(50);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int mt9m114_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+		if (power_up(sd))
+			return -EINVAL;
+
+		return mt9m114_init_common(sd);
+	}
+}
+
+static int mt9m114_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= *w) &&
+		    (mt9m114_res[i].height >= *h))
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = mt9m114_res[i].width;
+	*h = mt9m114_res[i].height;
+
+	return 0;
+}
+
+static struct mt9m114_res_struct *mt9m114_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if ((mt9m114_res[index].width == w) &&
+		    (mt9m114_res[index].height == h))
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &mt9m114_res[index];
+}
+
+static int mt9m114_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int count = 0;
+
+        for (count = 0; count < ARRAY_SIZE(mt9m114_formats); count++)
+	{
+                if (mt9m114_formats[count].mbus_code == fmt->code)
+		{
+                        break;
+		}
+		else
+		  count = ARRAY_SIZE(mt9m114_formats) + 1; //unsupported format
+	}
+        if (count >= ARRAY_SIZE(mt9m114_formats))
+	{
+                /* default to first format */
+                count = 0;
+                fmt->code = mt9m114_formats[0].mbus_code;
+        }
+ 
+	return mt9m114_try_res(&fmt->width, &fmt->height);
+}
+
+static int mt9m114_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case MT9M114_RES_QCIF:
+		hsize = MT9M114_RES_QCIF_SIZE_H;
+		vsize = MT9M114_RES_QCIF_SIZE_V;
+		break;
+	case MT9M114_RES_QVGA:
+		hsize = MT9M114_RES_QVGA_SIZE_H;
+		vsize = MT9M114_RES_QVGA_SIZE_V;
+		break;
+	case MT9M114_RES_VGA:
+		hsize = MT9M114_RES_VGA_SIZE_H;
+		vsize = MT9M114_RES_VGA_SIZE_V;
+		break;
+	case MT9M114_RES_480P:
+		hsize = MT9M114_RES_480P_SIZE_H;
+		vsize = MT9M114_RES_480P_SIZE_V;
+		break;
+	case MT9M114_RES_720P:
+		hsize = MT9M114_RES_720P_SIZE_H;
+		vsize = MT9M114_RES_720P_SIZE_V;
+		break;
+	case MT9M114_RES_960P:
+		hsize = MT9M114_RES_960P_SIZE_H;
+		vsize = MT9M114_RES_960P_SIZE_V;
+		break;
+	case MT9M114_RES_PAL:
+		hsize = MT9M114_RES_PAL_SIZE_H;
+		vsize = MT9M114_RES_PAL_SIZE_V;
+		break;
+	case MT9M114_RES_800x480:
+		hsize = MT9M114_RES_800x480_SIZE_H;
+		vsize = MT9M114_RES_800x480_SIZE_V;
+		break;
+	case MT9M114_RES_960x540:
+		hsize = MT9M114_RES_960x540_SIZE_H;
+		vsize = MT9M114_RES_960x540_SIZE_V;
+		break;
+	case MT9M114_RES_720x480:
+		hsize = MT9M114_RES_720x480_SIZE_H;
+		vsize = MT9M114_RES_720x480_SIZE_V;
+		break;
+	case MT9M114_RES_736x480:
+		hsize = MT9M114_RES_736x480_SIZE_H;
+		vsize = MT9M114_RES_736x480_SIZE_V;
+		break;
+	case MT9M114_RES_736x576:
+		hsize = MT9M114_RES_736x576_SIZE_H;
+		vsize = MT9M114_RES_736x576_SIZE_V;
+		break;
+	case MT9M114_RES_1280x768:
+		hsize = MT9M114_RES_1280x768_SIZE_H;
+		vsize = MT9M114_RES_1280x768_SIZE_V;
+		break;
+	case MT9M114_RES_1280x800:
+			hsize = MT9M114_RES_1280x800_SIZE_H;
+			vsize = MT9M114_RES_1280x800_SIZE_V;
+			break;
+
+	default:
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+	printk(KERN_ALERT "mt9m114_res2size: hsize=%d, vsize=%d\n", hsize, vsize);
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int mt9m114_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = mt9m114_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+	return 0;
+}
+
+static int mt9m114_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct mt9m114_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 colour_fmt;
+	int ret;
+
+	printk(KERN_ALERT "ENTER mt9m114_set_mbus_fmt, width=%d, height=%d\n", width, height);
+
+	mt9m114_try_res(&width, &height);
+	printk(KERN_ALERT "return from mt9m114_try_res, width=%d, height=%d\n", width, height);
+	res_index = mt9m114_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	switch (res_index->res) {
+	case MT9M114_RES_QCIF:
+		ret = mt9m114_write_reg_array(c, mt9m114_qcif_init, NO_POLLING);
+		break;
+	case MT9M114_RES_QVGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_qvga_init, NO_POLLING);
+		/* set sensor read_mode to Skipping */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SKIPPING_SET);
+		break;
+	case MT9M114_RES_VGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_vga_init, NO_POLLING);
+		/* set sensor read_mode to Summing */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SUMMING_SET);
+		break;
+	case MT9M114_RES_480P:
+		ret = mt9m114_write_reg_array(c, mt9m114_480p_init, NO_POLLING);
+		break;
+	case MT9M114_RES_720P:
+		ret = mt9m114_write_reg_array(c, mt9m114_720p_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_960P:
+		ret = mt9m114_write_reg_array(c, mt9m114_960P_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_PAL:
+		ret = mt9m114_write_reg_array(c, mt9m114_pal_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_800x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_800x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_960x540:
+		ret = mt9m114_write_reg_array(c, mt9m114_960x540_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_720x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_720x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_736x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_736x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_736x576:
+		ret = mt9m114_write_reg_array(c, mt9m114_736x576_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_1280x768:
+		ret = mt9m114_write_reg_array(c, mt9m114_1280x768_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		printk(KERN_ALERT "Case MT9M114_RES_1280x768, ret=%d\n", ret);
+		break;
+	case MT9M114_RES_1280x800:
+			ret = mt9m114_write_reg_array(c, mt9m114_1280x800_init, NO_POLLING);
+			/* set sensor read_mode to Normal */
+			ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+			printk(KERN_ALERT "Case MT9M114_RES_1280x800, ret=%d\n", ret);
+			break;
+	default:
+		v4l2_err(sd, "set resolution: %d failed!\n", res_index->res);
+		printk(KERN_ALERT "ERROR set resolution %d failed!\n", res_index->res);
+		return -EINVAL;
+	}
+
+	if (ret)
+	{
+		return -EINVAL;
+	}
+
+        /* set image format */
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT, (u32)CAMERA_FORMAT, &colour_fmt);
+        if (ret)
+	{
+               return -EINVAL;
+	}
+	
+	colour_fmt &= 0xc0fc;
+	
+        switch (fmt->code) 
+	{
+	  case V4L2_MBUS_FMT_FIXED:
+	  case 0x8003:
+	  case V4L2_MBUS_FMT_UYVY8_1X16:
+	  case V4L2_MBUS_FMT_UYVY8_2X8:
+		colour_fmt = 0x0010;
+                break;
+
+	  case V4L2_MBUS_FMT_RGB565_2X8_LE:
+                 colour_fmt = 0x0100;
+              break;
+	  default:
+		printk("fmt->code default!!\n");
+                 return -EINVAL;
+        }
+  printk("writing CAMERA_FORMAT register = 0x%X\n", colour_fmt);       
+	ret = mt9m114_write_reg(c, MISENSOR_16BIT, (u32)CAMERA_FORMAT, colour_fmt);
+        if (ret)
+               return -EINVAL;
+ 
+	ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg, POST_POLLING);
+	if (ret < 0)
+		return ret;
+
+	if (mt9m114_set_suspend(sd))
+		return -EINVAL;
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/* Switch to different size */
+		if (width <= 640) {
+			dev->nctx = 0x00; /* Set for context A */
+		} else {
+			/*
+			 * Context B is used for resolutions larger than 640x480
+			 * Using YUV for Context B.
+			 */
+			dev->nctx = 0x01; /* set for context B */
+		}
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if ((width == mt9m114_res[index].width) &&
+			    (height == mt9m114_res[index].height)) {
+				mt9m114_res[index].used = 1;
+				continue;
+			}
+			mt9m114_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * mt9m114 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	printk(KERN_ALERT "EXIT mt9m114_set_mbus_fmt(), width=%d, height=%d\n", fmt->width, fmt->height);
+	return 0;
+}
+
+/* TODO: Update to SOC functions, remove exposure and gain */
+static int mt9m114_g_focal(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_FOCAL_LENGTH_NUM << 16) | MT9M114_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber(struct v4l2_subdev *sd, s32 * val)
+{
+	/*const f number for mt9m114*/
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 16) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9M114_F_NUMBER_DEM << 16) |
+		(MT9M114_F_NUMBER_DEFAULT_NUM << 8) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_HFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_VFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_s_freq(struct v4l2_subdev *sd, s32  val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int ret;
+
+	if (val != MT9M114_FLICKER_MODE_50HZ &&
+			val != MT9M114_FLICKER_MODE_60HZ)
+		return -EINVAL;
+
+	if (val == MT9M114_FLICKER_MODE_50HZ) {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_50hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_60hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (ret == 0)
+		dev->lightfreq = val;
+
+	return ret;
+}
+
+static struct mt9m114_control mt9m114_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_vflip,
+		.tweak = mt9m114_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_hflip,
+		.tweak = mt9m114_t_hflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.maximum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = MT9M114_F_NUMBER_DEFAULT,
+			.maximum = MT9M114_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = MT9M114_F_NUMBER_RANGE,
+			.maximum =  MT9M114_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_POWER_LINE_FREQUENCY,
+			.type = V4L2_CTRL_TYPE_MENU,
+			.name = "Light frequency filter",
+			.minimum = 1,
+			.maximum =  2, /* 1: 50Hz, 2:60Hz */
+			.step = 1,
+			.default_value = 1,
+			.flags = 0,
+		},
+		.tweak = mt9m114_s_freq,
+	},
+
+};
+#define N_CONTROLS (ARRAY_SIZE(mt9m114_controls))
+
+static struct mt9m114_control *mt9m114_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (mt9m114_controls[i].qc.id == id)
+			return &mt9m114_controls[i];
+	}
+	return NULL;
+}
+
+static int mt9m114_detect(struct mt9m114_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	mt9m114_read_reg(client, MISENSOR_16BIT, (u32)MT9M114_PID, &retvalue);
+	dev->real_model_id = retvalue;
+
+	if (retvalue != MT9M114_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int
+mt9m114_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			v4l2_err(client, "mt9m114 platform init err\n");
+			return ret;
+		}
+	}
+	ret = mt9m114_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power-up err");
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = mt9m114_detect(dev, client);
+	if (ret) {
+		v4l2_err(client, "mt9m114_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = mt9m114_set_suspend(sd);
+	if (ret) {
+		v4l2_err(client, "mt9m114 suspend err");
+		return ret;
+	}
+
+	ret = mt9m114_s_power(sd, 0);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	mt9m114_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int mt9m114_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9m114_control *ctrl = mt9m114_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value) {
+		/* enable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_EN);
+
+		dev->bpat = MT9M114_BPAT_GRGRBGBG;
+	} else {
+		/* disable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_DIS);
+
+		dev->bpat = MT9M114_BPAT_BGBGGRGR;
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+/* Vertically flip the image */
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value >= 1) {
+		/* enable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_EN);
+	} else {
+		/* disable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_DIS);
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+static int mt9m114_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+
+	if (enable) {
+		ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+
+		ret = mt9m114_set_streaming(sd);
+		/*
+		 * here we wait for sensor's 3A algorithm to be
+		 * stablized, as to fix still capture bad 3A output picture
+		 */
+		if (mt9m114_wait_3a(sd))
+			v4l2_warn(c, "3A can not finish!");
+	} else {
+		ret = mt9m114_set_suspend(sd);
+	}
+
+	return ret;
+}
+
+static int
+mt9m114_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9m114_res[index].width;
+	fsize->discrete.height = mt9m114_res[index].height;
+
+	/* FIXME: Wrong way to know used mode */
+	fsize->reserved[0] = mt9m114_res[index].used;
+
+	return 0;
+}
+
+static int mt9m114_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= fival->width) &&
+		    (mt9m114_res[i].height >= fival->height))
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9m114_res[index].fps;
+
+	return 0;
+}
+
+static int
+mt9m114_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9M114, 0);
+}
+
+static int mt9m114_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int mt9m114_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	unsigned int index = fse->index;
+
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = mt9m114_res[index].width;
+	fse->min_height = mt9m114_res[index].height;
+	fse->max_width = mt9m114_res[index].width;
+	fse->max_height = mt9m114_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9m114_get_pad_format(struct mt9m114_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,  "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9m114_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9m114_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int mt9m114_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < N_RES; index++) {
+		if (mt9m114_res[index].res == snr->res)
+			break;
+	}
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	*frames = mt9m114_res[index].skip_frames;
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
+	.try_mbus_fmt = mt9m114_try_mbus_fmt,
+	.s_mbus_fmt = mt9m114_set_mbus_fmt,
+	.g_mbus_fmt = mt9m114_get_mbus_fmt,
+	.s_stream = mt9m114_s_stream,
+	.enum_framesizes = mt9m114_enum_framesizes,
+	.enum_frameintervals = mt9m114_enum_frameintervals,
+};
+
+static struct v4l2_subdev_sensor_ops mt9m114_sensor_ops = {
+	.g_skip_frames	= mt9m114_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9m114_core_ops = {
+	.g_chip_ident = mt9m114_g_chip_ident,
+	.queryctrl = mt9m114_queryctrl,
+	.g_ctrl = mt9m114_g_ctrl,
+	.s_ctrl = mt9m114_s_ctrl,
+	.s_power = mt9m114_s_power,
+};
+
+/* REVISIT: Do we need pad operations? */
+static const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {
+	.enum_mbus_code = mt9m114_enum_mbus_code,
+	.enum_frame_size = mt9m114_enum_frame_size,
+	.get_fmt = mt9m114_get_pad_format,
+	.set_fmt = mt9m114_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9m114_ops = {
+	.core = &mt9m114_core_ops,
+	.video = &mt9m114_video_ops,
+	.pad = &mt9m114_pad_ops,
+	.sensor = &mt9m114_sensor_ops,
+};
+
+static const struct media_entity_operations mt9m114_entity_ops = {
+	.link_setup = NULL,
+};
+
+
+static int mt9m114_remove(struct i2c_client *client)
+{
+	struct mt9m114_device *dev;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	dev = container_of(sd, struct mt9m114_device, sd);
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+	return 0;
+}
+
+static int mt9m114_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct mt9m114_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &mt9m114_ops);
+	if (client->dev.platform_data) {
+		ret = mt9m114_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* REVISIT: Do we need media controller? */
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9m114_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, mt9m114_id);
+
+static struct i2c_driver mt9m114_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mt9m114"
+	},
+	.probe = mt9m114_probe,
+	.remove = mt9m114_remove,
+	.id_table = mt9m114_id,
+};
+
+static __init int init_mt9m114(void)
+{
+	return i2c_add_driver(&mt9m114_driver);
+}
+
+static __exit void exit_mt9m114(void)
+{
+	i2c_del_driver(&mt9m114_driver);
+}
+
+module_init(init_mt9m114);
+module_exit(exit_mt9m114);
+
+MODULE_AUTHOR("Shuguang Gong <Shuguang.gong@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mt9m114.h b/drivers/media/video/mt9m114.h
new file mode 100644
index 0000000..e4db396
--- /dev/null
+++ b/drivers/media/video/mt9m114.h
@@ -0,0 +1,2030 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __A1040_H__
+#define __A1040_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define V4L2_IDENT_MT9M114 8245
+
+#define MT9P111_REV3
+#define FULLINISUPPORT
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_FWBURST0	0x80
+#define MISENSOR_FWBURST1	0x81
+#define MISENSOR_FWBURST4	0x84
+#define MISENSOR_FWBURST	0x88
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+#define MISENSOR_TOK_RMW	0x0010  /* RMW operation */
+#define MISENSOR_TOK_MASK	0xfff0
+#define MISENSOR_AWB_STEADY	(1<<0)	/* awb steady */
+#define MISENSOR_AE_READY	(1<<3)	/* ae status ready */
+
+/* mask to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_R_MODE_MASK	0x0330
+/* mask to set sensor vert_flip and horz_mirror */
+#define MISENSOR_VFLIP_MASK	0x0002
+#define MISENSOR_HFLIP_MASK	0x0001
+#define MISENSOR_FLIP_EN	1
+#define MISENSOR_FLIP_DIS	0
+
+/* bits set to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_SKIPPING_SET	0x0011
+#define MISENSOR_SUMMING_SET	0x0033
+#define MISENSOR_NORMAL_SET	0x0000
+
+/* sensor register that control sensor read-mode and mirror */
+#define MISENSOR_READ_MODE	0xC834
+/* sensor ae-track status register */
+#define MISENSOR_AE_TRACK_STATUS	0xA800
+/* sensor awb status register */
+#define MISENSOR_AWB_STATUS	0xAC00
+
+#define SENSOR_DETECTED		1
+#define SENSOR_NOT_DETECTED	0
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+#define MAX_FMTS		1
+
+#ifndef MIPI_CONTROL
+#define MIPI_CONTROL		0x3400	/* MIPI_Control */
+#endif
+
+/* GPIO pin on Moorestown */
+#define GPIO_SCLK_25		44
+#define GPIO_STB_PIN		47
+
+#define GPIO_STDBY_PIN		49   /* ab:new */
+#define GPIO_RESET_PIN		50
+
+/* System control register for Aptina A-1040SOC*/
+#define MT9M114_PID		0x0
+
+/* MT9P111_DEVICE_ID */
+#define MT9M114_MOD_ID		0x2481
+
+/* ulBPat; */
+
+#define MT9M114_BPAT_RGRGGBGB	(1 << 0)
+#define MT9M114_BPAT_GRGRBGBG	(1 << 1)
+#define MT9M114_BPAT_GBGBRGRG	(1 << 2)
+#define MT9M114_BPAT_BGBGGRGR	(1 << 3)
+
+#define MT9M114_FOCAL_LENGTH_NUM	208	/*2.08mm*/
+#define MT9M114_FOCAL_LENGTH_DEM	100
+#define MT9M114_F_NUMBER_DEFAULT_NUM	24
+#define MT9M114_F_NUMBER_DEM	10
+#define MT9M114_WAIT_STAT_TIMEOUT	100
+#define MT9M114_FLICKER_MODE_50HZ	1
+#define MT9M114_FLICKER_MODE_60HZ	2
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9M114_F_NUMBER_RANGE 0x180a180a
+
+/* Supported resolutions */
+enum {
+	MT9M114_RES_QCIF,
+	MT9M114_RES_QVGA,
+	MT9M114_RES_VGA,
+	MT9M114_RES_480P,
+	MT9M114_RES_720P,
+	MT9M114_RES_960P,
+	MT9M114_RES_PAL,
+	MT9M114_RES_800x480,
+	MT9M114_RES_960x540,
+	MT9M114_RES_720x480,
+	MT9M114_RES_736x480,
+	MT9M114_RES_736x576,
+	MT9M114_RES_1280x768,
+	MT9M114_RES_1280x800,
+};
+#define MT9M114_RES_960P_SIZE_H		1280
+#define MT9M114_RES_960P_SIZE_V		960
+#define MT9M114_RES_720P_SIZE_H		1280
+#define MT9M114_RES_720P_SIZE_V		720
+#define MT9M114_RES_480P_SIZE_H		768
+#define MT9M114_RES_480P_SIZE_V		480
+#define MT9M114_RES_VGA_SIZE_H		640
+#define MT9M114_RES_VGA_SIZE_V		480
+#define MT9M114_RES_QVGA_SIZE_H		320
+#define MT9M114_RES_QVGA_SIZE_V		240
+#define MT9M114_RES_QCIF_SIZE_H		176
+#define MT9M114_RES_QCIF_SIZE_V		144
+#define MT9M114_RES_PAL_SIZE_H		720
+#define MT9M114_RES_PAL_SIZE_V		576
+#define MT9M114_RES_800x480_SIZE_H		800
+#define MT9M114_RES_800x480_SIZE_V		480
+#define MT9M114_RES_960x540_SIZE_H		960
+#define MT9M114_RES_960x540_SIZE_V		540
+#define MT9M114_RES_720x480_SIZE_H		720
+#define MT9M114_RES_720x480_SIZE_V		480
+#define MT9M114_RES_736x480_SIZE_H		736
+#define MT9M114_RES_736x480_SIZE_V		480
+#define MT9M114_RES_736x576_SIZE_H		736
+#define MT9M114_RES_736x576_SIZE_V		576
+#define MT9M114_RES_1280x768_SIZE_H		1280
+#define MT9M114_RES_1280x768_SIZE_V		768
+#define MT9M114_RES_1280x800_SIZE_H		1280
+#define MT9M114_RES_1280x800_SIZE_V		800
+
+/* completion status polling requirements, usage based on Aptina .INI Rev2 */
+enum poll_reg {
+	NO_POLLING,
+	PRE_POLLING,
+	POST_POLLING,
+};
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u32 length;
+	u32 reg;
+	u32 val;	/* value or for read/mod/write, AND mask */
+	u32 val2;	/* optional; for rmw, OR mask */
+};
+
+/*
+ * struct misensor_fwreg - Firmware burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @valx: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_fwreg {
+	u32	type;	/* type of value, register or FW burst string */
+	u32	addr;	/* target address */
+	u32	val0;
+	u32	val1;
+	u32	val2;
+	u32	val3;
+	u32	val4;
+	u32	val5;
+	u32	val6;
+	u32	val7;
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct mt9m114_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int real_model_id;
+	int nctx;
+	int power;
+
+	unsigned int bus_width;
+	unsigned int mode;
+	unsigned int field_inv;
+	unsigned int field_sel;
+	unsigned int ycseq;
+	unsigned int conv422;
+	unsigned int bpat;
+	unsigned int hpol;
+	unsigned int vpol;
+	unsigned int edge;
+	unsigned int bls;
+	unsigned int gamma;
+	unsigned int cconv;
+	unsigned int res;
+	unsigned int dwn_sz;
+	unsigned int blc;
+	unsigned int agc;
+	unsigned int awb;
+	unsigned int aec;
+	/* extention SENSOR version 2 */
+	unsigned int cie_profile;
+
+	/* extention SENSOR version 3 */
+	unsigned int flicker_freq;
+
+	/* extension SENSOR version 4 */
+	unsigned int smia_mode;
+	unsigned int mipi_mode;
+
+	/* Add name here to load shared library */
+	unsigned int type;
+
+	/*Number of MIPI lanes*/
+	unsigned int mipi_lanes;
+	char name[32];
+
+	u8 lightfreq;
+};
+
+struct mt9m114_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct mt9m114_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+struct mt9m114_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define MT9M114_MAX_WRITE_BUF_SIZE	32
+struct mt9m114_write_buffer {
+	u16 addr;
+	u8 data[MT9M114_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9m114_write_ctrl {
+	int index;
+	struct mt9m114_write_buffer buffer;
+};
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * IMPORTANT: keep them in ascending order.
+ */
+static struct mt9m114_res_struct mt9m114_res[] = {
+	{
+	.desc	= "QCIF",
+	.res	= MT9M114_RES_QCIF,
+	.width	= 176,
+	.height	= 144,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "QVGA",
+	.res	= MT9M114_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "VGA",
+	.res	= MT9M114_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "720x480",
+	.res	= MT9M114_RES_720x480,
+	.width	= 720,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "736x480",
+	.res	= MT9M114_RES_736x480,
+	.width	= 736,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "736x576",
+	.res	= MT9M114_RES_736x576,
+	.width	= 736,
+	.height	= 576,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "480p",
+	.res	= MT9M114_RES_480P,
+	.width	= 768,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "800x480",
+	.res	= MT9M114_RES_800x480,
+	.width	= 800,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "PAL",
+	.res	= MT9M114_RES_PAL,
+	.width	= 720,
+	.height	= 576,
+	.fps	= 25,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "960x540",
+	.res	= MT9M114_RES_960x540,
+	.width	= 960,
+	.height	= 540,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "720p",
+	.res	= MT9M114_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "1280x768",
+	.res	= MT9M114_RES_1280x768,
+	.width	= 1280,
+	.height	= 768,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+		.desc	= "1280x800",
+		.res	= MT9M114_RES_1280x800,
+		.width	= 1280,
+		.height	= 800,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 1,
+	},
+	{
+	.desc	= "960P",
+	.res	= MT9M114_RES_960P,
+	.width	= 1280,
+	.height	= 960,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+};
+#define N_RES (ARRAY_SIZE(mt9m114_res))
+
+static const struct i2c_device_id mt9m114_id[] = {
+	{"mt9m114", 0},
+	{}
+};
+
+static struct misensor_reg const mt9m114_suspend[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x40},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_streaming[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x34},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_standby_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x50},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_wakeup_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x54},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_chgstat_reg[] = {
+	{MISENSOR_16BIT,  0x098E, 0xDC00},
+	{MISENSOR_8BIT,  0xDC00, 0x28},
+	{MISENSOR_16BIT,  0x0080, 0x8002},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+static struct misensor_reg const mt9m114_qcif_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0034},
+	{MISENSOR_16BIT,  0xC802, 0x0074},
+	{MISENSOR_16BIT,  0xC804, 0x039B},
+	{MISENSOR_16BIT,  0xC806, 0x049B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x04D1},
+	{MISENSOR_16BIT,  0xC812, 0x0495},
+	{MISENSOR_16BIT,  0xC814, 0x0554},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0363},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0420},
+	{MISENSOR_16BIT,  0xC85A, 0x0360},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x00B0},
+	{MISENSOR_16BIT,  0xC86A, 0x0090},
+	{MISENSOR_8BIT,  0xC878, 0x0E},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x00AF},
+	{MISENSOR_16BIT,  0xC91A, 0x008F},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0022},
+	{MISENSOR_16BIT,  0xC922, 0x001B},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_qvga_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0000},
+	{MISENSOR_16BIT,  0xC802, 0x0000},
+	{MISENSOR_16BIT,  0xC804, 0x03CD},
+	{MISENSOR_16BIT,  0xC806, 0x050D},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05B3},
+	{MISENSOR_16BIT,  0xC812, 0x03E8},
+	{MISENSOR_16BIT,  0xC814, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x01E3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0x11},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0280},
+	{MISENSOR_16BIT,  0xC85A, 0x01E0},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0140},
+	{MISENSOR_16BIT,  0xC86A, 0x00F0},
+	{MISENSOR_8BIT,  0xC878, 0xE},
+	{MISENSOR_16BIT,  0xC88C, 0x1E03},
+	{MISENSOR_16BIT,  0xC88E, 0x1E03},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x013F},
+	{MISENSOR_16BIT,  0xC91A, 0x00EF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x003F},
+	{MISENSOR_16BIT,  0xC922, 0x002F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_720p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x007C},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x0353},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05BD},
+	{MISENSOR_16BIT,  0xC812, 0x03E8},
+	{MISENSOR_16BIT,  0xC814, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x02D3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0500},
+	{MISENSOR_16BIT,  0xC85A, 0x02D0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0500},
+	{MISENSOR_16BIT,  0xC86A, 0x02D0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x04FF},
+	{MISENSOR_16BIT,  0xC91A, 0x02CF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x00FF},
+	{MISENSOR_16BIT,  0xC922, 0x008F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_480p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0054},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x037B},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05B1},
+	{MISENSOR_16BIT,  0xC812, 0x03EF},
+	{MISENSOR_16BIT,  0xC814, 0x0634},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0323},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0500},
+	{MISENSOR_16BIT,  0xC85A, 0x0320},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0300},
+	{MISENSOR_16BIT,  0xC86A, 0x01E0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E04},
+	{MISENSOR_16BIT,  0xC88E, 0x1E04},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x02FF},
+	{MISENSOR_16BIT,  0xC91A, 0x01DF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0098},
+	{MISENSOR_16BIT,  0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_vga_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,   0xC800, 0x0000},
+	{MISENSOR_16BIT,   0xC802, 0x0000},
+	{MISENSOR_16BIT,   0xC804, 0x03CD},
+	{MISENSOR_16BIT,   0xC806, 0x050D},
+	{MISENSOR_32BIT,   0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,   0xC80C, 0x0001},
+	{MISENSOR_16BIT,   0xC80E, 0x01C3},
+	{MISENSOR_16BIT,   0xC810, 0x03B3},
+	{MISENSOR_16BIT,   0xC812, 0x0549},
+	{MISENSOR_16BIT,   0xC814, 0x049E},
+	{MISENSOR_16BIT,   0xC816, 0x00E0},
+	{MISENSOR_16BIT,   0xC818, 0x01E3},
+	{MISENSOR_16BIT,   0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0x0},
+	{MISENSOR_16BIT,   0xC854, 0x0000},
+	{MISENSOR_16BIT,   0xC856, 0x0000},
+	{MISENSOR_16BIT,   0xC858, 0x0280},
+	{MISENSOR_16BIT,   0xC85A, 0x01E0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,   0xC868, 0x0280},
+	{MISENSOR_16BIT,   0xC86A, 0x01E0},
+	{MISENSOR_8BIT,   0xC878, 0x00},
+	{MISENSOR_16BIT,   0xC88C, 0x1E04},
+	{MISENSOR_16BIT,   0xC88E, 0x1E04},
+	{MISENSOR_16BIT,   0xC914, 0x0000},
+	{MISENSOR_16BIT,   0xC916, 0x0000},
+	{MISENSOR_16BIT,   0xC918, 0x027F},
+	{MISENSOR_16BIT,   0xC91A, 0x01DF},
+	{MISENSOR_16BIT,   0xC91C, 0x0000},
+	{MISENSOR_16BIT,   0xC91E, 0x0000},
+	{MISENSOR_16BIT,   0xC920, 0x007F},
+	{MISENSOR_16BIT,   0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_960P_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x062E},
+	{MISENSOR_16BIT, 0xC812, 0x074C},
+	{MISENSOR_16BIT, 0xC814, 0x06B1},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x03C0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x0500},
+	{MISENSOR_16BIT, 0xC86A, 0x03C0},
+	{MISENSOR_8BIT, 0xC878, 0x0E},
+	{MISENSOR_16BIT, 0xC88C, 0x0F00},
+	{MISENSOR_16BIT, 0xC88E, 0x0F00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x03BF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x00BF},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_pal_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,   0xC800, 0x0004},
+	{MISENSOR_16BIT,   0xC802, 0x0004},
+	{MISENSOR_16BIT,   0xC804, 0x03CB},
+	{MISENSOR_16BIT,   0xC806, 0x050B},
+	{MISENSOR_32BIT,   0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,   0xC80C, 0x0001},
+	{MISENSOR_16BIT,   0xC80E, 0x00DB},
+	{MISENSOR_16BIT,   0xC810, 0x05BD},
+	{MISENSOR_16BIT,   0xC812, 0x04B0},
+	{MISENSOR_16BIT,   0xC814, 0x0640},
+	{MISENSOR_16BIT,   0xC816, 0x0060},
+	{MISENSOR_16BIT,   0xC818, 0x03C3},
+	{MISENSOR_16BIT,   0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,   0xC854, 0x0000},
+	{MISENSOR_16BIT,   0xC856, 0x0000},
+	{MISENSOR_16BIT,   0xC858, 0x0500},
+	{MISENSOR_16BIT,   0xC85A, 0x03C0},
+	{MISENSOR_8BIT,    0xC85C, 0x03},
+	{MISENSOR_16BIT,   0xC868, 0x02D0},
+	{MISENSOR_16BIT,   0xC86A, 0x0240},
+	{MISENSOR_8BIT,    0xC878, 0x00},
+	{MISENSOR_16BIT,   0xC88C, 0x1900},
+	{MISENSOR_16BIT,   0xC88E, 0x1900},
+	{MISENSOR_16BIT,   0xC914, 0x0000},
+	{MISENSOR_16BIT,   0xC916, 0x0000},
+	{MISENSOR_16BIT,   0xC918, 0x02CF},
+	{MISENSOR_16BIT,   0xC91A, 0x023F},
+	{MISENSOR_16BIT,   0xC91C, 0x0000},
+	{MISENSOR_16BIT,   0xC91E, 0x0000},
+	{MISENSOR_16BIT,   0xC920, 0x008F},
+	{MISENSOR_16BIT,   0xC922, 0x0072},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_800x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	{MISENSOR_16BIT, 0xC812, 0x03EE},
+	{MISENSOR_16BIT, 0xC814, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x0320},
+	{MISENSOR_16BIT, 0xC86A, 0x01E0},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x031F},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x009F},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_960x540_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	{MISENSOR_16BIT, 0xC812, 0x03EE},
+	{MISENSOR_16BIT, 0xC814, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0078},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x02D0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x03C0},
+	{MISENSOR_16BIT, 0xC86A, 0x021C},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x03BF},
+	{MISENSOR_16BIT, 0xC91A, 0x021B},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00BF},
+	{MISENSOR_16BIT, 0xC922, 0x006B},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_720x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	{MISENSOR_16BIT, 0xC812, 0x03EE},
+	{MISENSOR_16BIT, 0xC814, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0001},
+	{MISENSOR_16BIT, 0xC856, 0x0036},
+	{MISENSOR_16BIT, 0xC858, 0x04FE},
+	{MISENSOR_16BIT, 0xC85A, 0x0354},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x02D0},
+	{MISENSOR_16BIT, 0xC86A, 0x01E0},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02CF},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x008F},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_736x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0064},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x036B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05BD},
+	{MISENSOR_16BIT, 0xC812, 0x03E8},
+	{MISENSOR_16BIT, 0xC814, 0x0640},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0303},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x049A},
+	{MISENSOR_16BIT, 0xC85A, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 736},
+	{MISENSOR_16BIT, 0xC86A, 480},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E00},
+	{MISENSOR_16BIT, 0xC88E, 0x1E00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02DF},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x0092},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_736x576_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	{MISENSOR_16BIT, 0xC812, 0x03EE},
+	{MISENSOR_16BIT, 0xC814, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x001B},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x04CA},
+	{MISENSOR_16BIT, 0xC85A, 0x03C0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 736},
+	{MISENSOR_16BIT, 0xC86A, 576},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02DF},
+	{MISENSOR_16BIT, 0xC91A, 0x023F},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x0092},
+	{MISENSOR_16BIT, 0xC922, 0x0072},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_1280x768_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0064},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x036B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05B1},
+	{MISENSOR_16BIT, 0xC812, 0x03EF},
+	{MISENSOR_16BIT, 0xC814, 0x0634},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0303},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x0500},
+	{MISENSOR_16BIT, 0xC86A, 0x0300},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E04},
+	{MISENSOR_16BIT, 0xC88E, 0x1E04},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x02FF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x0098},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_1280x800_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0054},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x037B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x05BD},
+	{MISENSOR_16BIT, 0xC812, 0x03E8},
+	{MISENSOR_16BIT, 0xC814, 0x0640},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0323},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0000, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x0320},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x0500},
+	{MISENSOR_16BIT, 0xC86A, 0x0320},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E00},
+	{MISENSOR_16BIT, 0xC88E, 0x1E00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x031F},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x009F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_common[] = {
+	/* reset */
+	{MISENSOR_16BIT,  0x301A, 0x0234},
+	/* pll settings for MT9M114 */
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_8BIT,   0xC97E, 0x01},
+	{MISENSOR_16BIT,   0xC980, 0x0128},
+	{MISENSOR_16BIT,   0xC982, 0x0700},
+	/*MIPI settings for MT9M114*/
+	{MISENSOR_16BIT,  0xC984, 0x8041},
+	{MISENSOR_16BIT,  0xC988, 0x0F00},
+	{MISENSOR_16BIT,  0xC98A, 0x0B07},
+	{MISENSOR_16BIT,  0xC98C, 0x0D01},
+	{MISENSOR_16BIT,  0xC98E, 0x071D},
+	{MISENSOR_16BIT,  0xC990, 0x0006},
+	{MISENSOR_16BIT,  0xC992, 0x0A0C},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_50hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x32},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_60hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x3C},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_iq[] = {
+	/* [Step3-Recommended] [Sensor optimization] */
+	{MISENSOR_16BIT,	0x316A, 0x8270},
+	{MISENSOR_16BIT,	0x316C, 0x8270},
+	{MISENSOR_16BIT,	0x3ED0, 0x2305},
+	{MISENSOR_16BIT,	0x3ED2, 0x77CF},
+	{MISENSOR_16BIT,	0x316E, 0x8202},
+	{MISENSOR_16BIT,	0x3180, 0x87FF},
+	{MISENSOR_16BIT,	0x30D4, 0x6080},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+
+	/* LOAD=Errata item 1 */
+	{MISENSOR_16BIT,	0x3E14, 0xFF39},
+
+	/* LOAD=Errata item 2 */
+	{MISENSOR_16BIT,	0x301A, 0x8234},
+
+	/*
+	 * LOAD=Errata item 3
+	 * LOAD=Patch 0202;
+	 * Feature Recommended; Black level correction fix
+	 */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x5000},
+	{MISENSOR_16BIT,	0xD000, 0x70CF},
+	{MISENSOR_16BIT,	0xD002, 0xFFFF},
+	{MISENSOR_16BIT,	0xD004, 0xC5D4},
+	{MISENSOR_16BIT,	0xD006, 0x903A},
+	{MISENSOR_16BIT,	0xD008, 0x2144},
+	{MISENSOR_16BIT,	0xD00A, 0x0C00},
+	{MISENSOR_16BIT,	0xD00C, 0x2186},
+	{MISENSOR_16BIT,	0xD00E, 0x0FF3},
+	{MISENSOR_16BIT,	0xD010, 0xB844},
+	{MISENSOR_16BIT,	0xD012, 0xB948},
+	{MISENSOR_16BIT,	0xD014, 0xE082},
+	{MISENSOR_16BIT,	0xD016, 0x20CC},
+	{MISENSOR_16BIT,	0xD018, 0x80E2},
+	{MISENSOR_16BIT,	0xD01A, 0x21CC},
+	{MISENSOR_16BIT,	0xD01C, 0x80A2},
+	{MISENSOR_16BIT,	0xD01E, 0x21CC},
+	{MISENSOR_16BIT,	0xD020, 0x80E2},
+	{MISENSOR_16BIT,	0xD022, 0xF404},
+	{MISENSOR_16BIT,	0xD024, 0xD801},
+	{MISENSOR_16BIT,	0xD026, 0xF003},
+	{MISENSOR_16BIT,	0xD028, 0xD800},
+	{MISENSOR_16BIT,	0xD02A, 0x7EE0},
+	{MISENSOR_16BIT,	0xD02C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD02E, 0x08BA},
+
+	{MISENSOR_16BIT,	0xD030, 0x0600},
+	{MISENSOR_16BIT,	0xD032, 0xC1A1},
+	{MISENSOR_16BIT,	0xD034, 0x76CF},
+	{MISENSOR_16BIT,	0xD036, 0xFFFF},
+	{MISENSOR_16BIT,	0xD038, 0xC130},
+	{MISENSOR_16BIT,	0xD03A, 0x6E04},
+	{MISENSOR_16BIT,	0xD03C, 0xC040},
+	{MISENSOR_16BIT,	0xD03E, 0x71CF},
+	{MISENSOR_16BIT,	0xD040, 0xFFFF},
+	{MISENSOR_16BIT,	0xD042, 0xC790},
+	{MISENSOR_16BIT,	0xD044, 0x8103},
+	{MISENSOR_16BIT,	0xD046, 0x77CF},
+	{MISENSOR_16BIT,	0xD048, 0xFFFF},
+	{MISENSOR_16BIT,	0xD04A, 0xC7C0},
+	{MISENSOR_16BIT,	0xD04C, 0xE001},
+	{MISENSOR_16BIT,	0xD04E, 0xA103},
+	{MISENSOR_16BIT,	0xD050, 0xD800},
+	{MISENSOR_16BIT,	0xD052, 0x0C6A},
+	{MISENSOR_16BIT,	0xD054, 0x04E0},
+	{MISENSOR_16BIT,	0xD056, 0xB89E},
+	{MISENSOR_16BIT,	0xD058, 0x7508},
+	{MISENSOR_16BIT,	0xD05A, 0x8E1C},
+	{MISENSOR_16BIT,	0xD05C, 0x0809},
+	{MISENSOR_16BIT,	0xD05E, 0x0191},
+
+	{MISENSOR_16BIT,	0xD060, 0xD801},
+	{MISENSOR_16BIT,	0xD062, 0xAE1D},
+	{MISENSOR_16BIT,	0xD064, 0xE580},
+	{MISENSOR_16BIT,	0xD066, 0x20CA},
+	{MISENSOR_16BIT,	0xD068, 0x0022},
+	{MISENSOR_16BIT,	0xD06A, 0x20CF},
+	{MISENSOR_16BIT,	0xD06C, 0x0522},
+	{MISENSOR_16BIT,	0xD06E, 0x0C5C},
+	{MISENSOR_16BIT,	0xD070, 0x04E2},
+	{MISENSOR_16BIT,	0xD072, 0x21CA},
+	{MISENSOR_16BIT,	0xD074, 0x0062},
+	{MISENSOR_16BIT,	0xD076, 0xE580},
+	{MISENSOR_16BIT,	0xD078, 0xD901},
+	{MISENSOR_16BIT,	0xD07A, 0x79C0},
+	{MISENSOR_16BIT,	0xD07C, 0xD800},
+	{MISENSOR_16BIT,	0xD07E, 0x0BE6},
+	{MISENSOR_16BIT,	0xD080, 0x04E0},
+	{MISENSOR_16BIT,	0xD082, 0xB89E},
+	{MISENSOR_16BIT,	0xD084, 0x70CF},
+	{MISENSOR_16BIT,	0xD086, 0xFFFF},
+	{MISENSOR_16BIT,	0xD088, 0xC8D4},
+	{MISENSOR_16BIT,	0xD08A, 0x9002},
+	{MISENSOR_16BIT,	0xD08C, 0x0857},
+	{MISENSOR_16BIT,	0xD08E, 0x025E},
+
+	{MISENSOR_16BIT,	0xD090, 0xFFDC},
+	{MISENSOR_16BIT,	0xD092, 0xE080},
+	{MISENSOR_16BIT,	0xD094, 0x25CC},
+	{MISENSOR_16BIT,	0xD096, 0x9022},
+	{MISENSOR_16BIT,	0xD098, 0xF225},
+	{MISENSOR_16BIT,	0xD09A, 0x1700},
+	{MISENSOR_16BIT,	0xD09C, 0x108A},
+	{MISENSOR_16BIT,	0xD09E, 0x73CF},
+	{MISENSOR_16BIT,	0xD0A0, 0xFF00},
+	{MISENSOR_16BIT,	0xD0A2, 0x3174},
+	{MISENSOR_16BIT,	0xD0A4, 0x9307},
+	{MISENSOR_16BIT,	0xD0A6, 0x2A04},
+	{MISENSOR_16BIT,	0xD0A8, 0x103E},
+	{MISENSOR_16BIT,	0xD0AA, 0x9328},
+	{MISENSOR_16BIT,	0xD0AC, 0x2942},
+	{MISENSOR_16BIT,	0xD0AE, 0x7140},
+	{MISENSOR_16BIT,	0xD0B0, 0x2A04},
+	{MISENSOR_16BIT,	0xD0B2, 0x107E},
+	{MISENSOR_16BIT,	0xD0B4, 0x9349},
+	{MISENSOR_16BIT,	0xD0B6, 0x2942},
+	{MISENSOR_16BIT,	0xD0B8, 0x7141},
+	{MISENSOR_16BIT,	0xD0BA, 0x2A04},
+	{MISENSOR_16BIT,	0xD0BC, 0x10BE},
+	{MISENSOR_16BIT,	0xD0BE, 0x934A},
+
+	{MISENSOR_16BIT,	0xD0C0, 0x2942},
+	{MISENSOR_16BIT,	0xD0C2, 0x714B},
+	{MISENSOR_16BIT,	0xD0C4, 0x2A04},
+	{MISENSOR_16BIT,	0xD0C6, 0x10BE},
+	{MISENSOR_16BIT,	0xD0C8, 0x130C},
+	{MISENSOR_16BIT,	0xD0CA, 0x010A},
+	{MISENSOR_16BIT,	0xD0CC, 0x2942},
+	{MISENSOR_16BIT,	0xD0CE, 0x7142},
+	{MISENSOR_16BIT,	0xD0D0, 0x2250},
+	{MISENSOR_16BIT,	0xD0D2, 0x13CA},
+	{MISENSOR_16BIT,	0xD0D4, 0x1B0C},
+	{MISENSOR_16BIT,	0xD0D6, 0x0284},
+	{MISENSOR_16BIT,	0xD0D8, 0xB307},
+	{MISENSOR_16BIT,	0xD0DA, 0xB328},
+	{MISENSOR_16BIT,	0xD0DC, 0x1B12},
+	{MISENSOR_16BIT,	0xD0DE, 0x02C4},
+	{MISENSOR_16BIT,	0xD0E0, 0xB34A},
+	{MISENSOR_16BIT,	0xD0E2, 0xED88},
+	{MISENSOR_16BIT,	0xD0E4, 0x71CF},
+	{MISENSOR_16BIT,	0xD0E6, 0xFF00},
+	{MISENSOR_16BIT,	0xD0E8, 0x3174},
+	{MISENSOR_16BIT,	0xD0EA, 0x9106},
+	{MISENSOR_16BIT,	0xD0EC, 0xB88F},
+	{MISENSOR_16BIT,	0xD0EE, 0xB106},
+
+	{MISENSOR_16BIT,	0xD0F0, 0x210A},
+	{MISENSOR_16BIT,	0xD0F2, 0x8340},
+	{MISENSOR_16BIT,	0xD0F4, 0xC000},
+	{MISENSOR_16BIT,	0xD0F6, 0x21CA},
+	{MISENSOR_16BIT,	0xD0F8, 0x0062},
+	{MISENSOR_16BIT,	0xD0FA, 0x20F0},
+	{MISENSOR_16BIT,	0xD0FC, 0x0040},
+	{MISENSOR_16BIT,	0xD0FE, 0x0B02},
+	{MISENSOR_16BIT,	0xD100, 0x0320},
+	{MISENSOR_16BIT,	0xD102, 0xD901},
+	{MISENSOR_16BIT,	0xD104, 0x07F1},
+	{MISENSOR_16BIT,	0xD106, 0x05E0},
+	{MISENSOR_16BIT,	0xD108, 0xC0A1},
+	{MISENSOR_16BIT,	0xD10A, 0x78E0},
+	{MISENSOR_16BIT,	0xD10C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD10E, 0x71CF},
+	{MISENSOR_16BIT,	0xD110, 0xFFFF},
+	{MISENSOR_16BIT,	0xD112, 0xC7C0},
+	{MISENSOR_16BIT,	0xD114, 0xD840},
+	{MISENSOR_16BIT,	0xD116, 0xA900},
+	{MISENSOR_16BIT,	0xD118, 0x71CF},
+	{MISENSOR_16BIT,	0xD11A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD11C, 0xD02C},
+	{MISENSOR_16BIT,	0xD11E, 0xD81E},
+
+	{MISENSOR_16BIT,	0xD120, 0x0A5A},
+	{MISENSOR_16BIT,	0xD122, 0x04E0},
+	{MISENSOR_16BIT,	0xD124, 0xDA00},
+	{MISENSOR_16BIT,	0xD126, 0xD800},
+	{MISENSOR_16BIT,	0xD128, 0xC0D1},
+	{MISENSOR_16BIT,	0xD12A, 0x7EE0},
+
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x010C},
+	{MISENSOR_16BIT,	0xE002, 0x0202},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* LOAD=Patch 0302; Feature Recommended; Adaptive Sensitivity */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x512C},
+	{MISENSOR_16BIT,	0xD12C, 0x70CF},
+	{MISENSOR_16BIT,	0xD12E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD130, 0xC5D4},
+	{MISENSOR_16BIT,	0xD132, 0x903A},
+	{MISENSOR_16BIT,	0xD134, 0x2144},
+	{MISENSOR_16BIT,	0xD136, 0x0C00},
+	{MISENSOR_16BIT,	0xD138, 0x2186},
+	{MISENSOR_16BIT,	0xD13A, 0x0FF3},
+	{MISENSOR_16BIT,	0xD13C, 0xB844},
+	{MISENSOR_16BIT,	0xD13E, 0x262F},
+	{MISENSOR_16BIT,	0xD140, 0xF008},
+	{MISENSOR_16BIT,	0xD142, 0xB948},
+	{MISENSOR_16BIT,	0xD144, 0x21CC},
+	{MISENSOR_16BIT,	0xD146, 0x8021},
+	{MISENSOR_16BIT,	0xD148, 0xD801},
+	{MISENSOR_16BIT,	0xD14A, 0xF203},
+	{MISENSOR_16BIT,	0xD14C, 0xD800},
+	{MISENSOR_16BIT,	0xD14E, 0x7EE0},
+	{MISENSOR_16BIT,	0xD150, 0xC0F1},
+	{MISENSOR_16BIT,	0xD152, 0x71CF},
+	{MISENSOR_16BIT,	0xD154, 0xFFFF},
+	{MISENSOR_16BIT,	0xD156, 0xC610},
+	{MISENSOR_16BIT,	0xD158, 0x910E},
+	{MISENSOR_16BIT,	0xD15A, 0x208C},
+	{MISENSOR_16BIT,	0xD15C, 0x8014},
+	{MISENSOR_16BIT,	0xD15E, 0xF418},
+	{MISENSOR_16BIT,	0xD160, 0x910F},
+	{MISENSOR_16BIT,	0xD162, 0x208C},
+	{MISENSOR_16BIT,	0xD164, 0x800F},
+	{MISENSOR_16BIT,	0xD166, 0xF414},
+	{MISENSOR_16BIT,	0xD168, 0x9116},
+	{MISENSOR_16BIT,	0xD16A, 0x208C},
+	{MISENSOR_16BIT,	0xD16C, 0x800A},
+	{MISENSOR_16BIT,	0xD16E, 0xF410},
+	{MISENSOR_16BIT,	0xD170, 0x9117},
+	{MISENSOR_16BIT,	0xD172, 0x208C},
+	{MISENSOR_16BIT,	0xD174, 0x8807},
+	{MISENSOR_16BIT,	0xD176, 0xF40C},
+	{MISENSOR_16BIT,	0xD178, 0x9118},
+	{MISENSOR_16BIT,	0xD17A, 0x2086},
+	{MISENSOR_16BIT,	0xD17C, 0x0FF3},
+	{MISENSOR_16BIT,	0xD17E, 0xB848},
+	{MISENSOR_16BIT,	0xD180, 0x080D},
+	{MISENSOR_16BIT,	0xD182, 0x0090},
+	{MISENSOR_16BIT,	0xD184, 0xFFEA},
+	{MISENSOR_16BIT,	0xD186, 0xE081},
+	{MISENSOR_16BIT,	0xD188, 0xD801},
+	{MISENSOR_16BIT,	0xD18A, 0xF203},
+	{MISENSOR_16BIT,	0xD18C, 0xD800},
+	{MISENSOR_16BIT,	0xD18E, 0xC0D1},
+	{MISENSOR_16BIT,	0xD190, 0x7EE0},
+	{MISENSOR_16BIT,	0xD192, 0x78E0},
+	{MISENSOR_16BIT,	0xD194, 0xC0F1},
+	{MISENSOR_16BIT,	0xD196, 0x71CF},
+	{MISENSOR_16BIT,	0xD198, 0xFFFF},
+	{MISENSOR_16BIT,	0xD19A, 0xC610},
+	{MISENSOR_16BIT,	0xD19C, 0x910E},
+	{MISENSOR_16BIT,	0xD19E, 0x208C},
+	{MISENSOR_16BIT,	0xD1A0, 0x800A},
+	{MISENSOR_16BIT,	0xD1A2, 0xF418},
+	{MISENSOR_16BIT,	0xD1A4, 0x910F},
+	{MISENSOR_16BIT,	0xD1A6, 0x208C},
+	{MISENSOR_16BIT,	0xD1A8, 0x8807},
+	{MISENSOR_16BIT,	0xD1AA, 0xF414},
+	{MISENSOR_16BIT,	0xD1AC, 0x9116},
+	{MISENSOR_16BIT,	0xD1AE, 0x208C},
+	{MISENSOR_16BIT,	0xD1B0, 0x800A},
+	{MISENSOR_16BIT,	0xD1B2, 0xF410},
+	{MISENSOR_16BIT,	0xD1B4, 0x9117},
+	{MISENSOR_16BIT,	0xD1B6, 0x208C},
+	{MISENSOR_16BIT,	0xD1B8, 0x8807},
+	{MISENSOR_16BIT,	0xD1BA, 0xF40C},
+	{MISENSOR_16BIT,	0xD1BC, 0x9118},
+	{MISENSOR_16BIT,	0xD1BE, 0x2086},
+	{MISENSOR_16BIT,	0xD1C0, 0x0FF3},
+	{MISENSOR_16BIT,	0xD1C2, 0xB848},
+	{MISENSOR_16BIT,	0xD1C4, 0x080D},
+	{MISENSOR_16BIT,	0xD1C6, 0x0090},
+	{MISENSOR_16BIT,	0xD1C8, 0xFFD9},
+	{MISENSOR_16BIT,	0xD1CA, 0xE080},
+	{MISENSOR_16BIT,	0xD1CC, 0xD801},
+	{MISENSOR_16BIT,	0xD1CE, 0xF203},
+	{MISENSOR_16BIT,	0xD1D0, 0xD800},
+	{MISENSOR_16BIT,	0xD1D2, 0xF1DF},
+	{MISENSOR_16BIT,	0xD1D4, 0x9040},
+	{MISENSOR_16BIT,	0xD1D6, 0x71CF},
+	{MISENSOR_16BIT,	0xD1D8, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1DA, 0xC5D4},
+	{MISENSOR_16BIT,	0xD1DC, 0xB15A},
+	{MISENSOR_16BIT,	0xD1DE, 0x9041},
+	{MISENSOR_16BIT,	0xD1E0, 0x73CF},
+	{MISENSOR_16BIT,	0xD1E2, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1E4, 0xC7D0},
+	{MISENSOR_16BIT,	0xD1E6, 0xB140},
+	{MISENSOR_16BIT,	0xD1E8, 0x9042},
+	{MISENSOR_16BIT,	0xD1EA, 0xB141},
+	{MISENSOR_16BIT,	0xD1EC, 0x9043},
+	{MISENSOR_16BIT,	0xD1EE, 0xB142},
+	{MISENSOR_16BIT,	0xD1F0, 0x9044},
+	{MISENSOR_16BIT,	0xD1F2, 0xB143},
+	{MISENSOR_16BIT,	0xD1F4, 0x9045},
+	{MISENSOR_16BIT,	0xD1F6, 0xB147},
+	{MISENSOR_16BIT,	0xD1F8, 0x9046},
+	{MISENSOR_16BIT,	0xD1FA, 0xB148},
+	{MISENSOR_16BIT,	0xD1FC, 0x9047},
+	{MISENSOR_16BIT,	0xD1FE, 0xB14B},
+	{MISENSOR_16BIT,	0xD200, 0x9048},
+	{MISENSOR_16BIT,	0xD202, 0xB14C},
+	{MISENSOR_16BIT,	0xD204, 0x9049},
+	{MISENSOR_16BIT,	0xD206, 0x1958},
+	{MISENSOR_16BIT,	0xD208, 0x0084},
+	{MISENSOR_16BIT,	0xD20A, 0x904A},
+	{MISENSOR_16BIT,	0xD20C, 0x195A},
+	{MISENSOR_16BIT,	0xD20E, 0x0084},
+	{MISENSOR_16BIT,	0xD210, 0x8856},
+	{MISENSOR_16BIT,	0xD212, 0x1B36},
+	{MISENSOR_16BIT,	0xD214, 0x8082},
+	{MISENSOR_16BIT,	0xD216, 0x8857},
+	{MISENSOR_16BIT,	0xD218, 0x1B37},
+	{MISENSOR_16BIT,	0xD21A, 0x8082},
+	{MISENSOR_16BIT,	0xD21C, 0x904C},
+	{MISENSOR_16BIT,	0xD21E, 0x19A7},
+	{MISENSOR_16BIT,	0xD220, 0x009C},
+	{MISENSOR_16BIT,	0xD222, 0x881A},
+	{MISENSOR_16BIT,	0xD224, 0x7FE0},
+	{MISENSOR_16BIT,	0xD226, 0x1B54},
+	{MISENSOR_16BIT,	0xD228, 0x8002},
+	{MISENSOR_16BIT,	0xD22A, 0x78E0},
+	{MISENSOR_16BIT,	0xD22C, 0x71CF},
+	{MISENSOR_16BIT,	0xD22E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD230, 0xC350},
+	{MISENSOR_16BIT,	0xD232, 0xD828},
+	{MISENSOR_16BIT,	0xD234, 0xA90B},
+	{MISENSOR_16BIT,	0xD236, 0x8100},
+	{MISENSOR_16BIT,	0xD238, 0x01C5},
+	{MISENSOR_16BIT,	0xD23A, 0x0320},
+	{MISENSOR_16BIT,	0xD23C, 0xD900},
+	{MISENSOR_16BIT,	0xD23E, 0x78E0},
+	{MISENSOR_16BIT,	0xD240, 0x220A},
+	{MISENSOR_16BIT,	0xD242, 0x1F80},
+	{MISENSOR_16BIT,	0xD244, 0xFFFF},
+	{MISENSOR_16BIT,	0xD246, 0xD4E0},
+	{MISENSOR_16BIT,	0xD248, 0xC0F1},
+	{MISENSOR_16BIT,	0xD24A, 0x0811},
+	{MISENSOR_16BIT,	0xD24C, 0x0051},
+	{MISENSOR_16BIT,	0xD24E, 0x2240},
+	{MISENSOR_16BIT,	0xD250, 0x1200},
+	{MISENSOR_16BIT,	0xD252, 0xFFE1},
+	{MISENSOR_16BIT,	0xD254, 0xD801},
+	{MISENSOR_16BIT,	0xD256, 0xF006},
+	{MISENSOR_16BIT,	0xD258, 0x2240},
+	{MISENSOR_16BIT,	0xD25A, 0x1900},
+	{MISENSOR_16BIT,	0xD25C, 0xFFDE},
+	{MISENSOR_16BIT,	0xD25E, 0xD802},
+	{MISENSOR_16BIT,	0xD260, 0x1A05},
+	{MISENSOR_16BIT,	0xD262, 0x1002},
+	{MISENSOR_16BIT,	0xD264, 0xFFF2},
+	{MISENSOR_16BIT,	0xD266, 0xF195},
+	{MISENSOR_16BIT,	0xD268, 0xC0F1},
+	{MISENSOR_16BIT,	0xD26A, 0x0E7E},
+	{MISENSOR_16BIT,	0xD26C, 0x05C0},
+	{MISENSOR_16BIT,	0xD26E, 0x75CF},
+	{MISENSOR_16BIT,	0xD270, 0xFFFF},
+	{MISENSOR_16BIT,	0xD272, 0xC84C},
+	{MISENSOR_16BIT,	0xD274, 0x9502},
+	{MISENSOR_16BIT,	0xD276, 0x77CF},
+	{MISENSOR_16BIT,	0xD278, 0xFFFF},
+	{MISENSOR_16BIT,	0xD27A, 0xC344},
+	{MISENSOR_16BIT,	0xD27C, 0x2044},
+	{MISENSOR_16BIT,	0xD27E, 0x008E},
+	{MISENSOR_16BIT,	0xD280, 0xB8A1},
+	{MISENSOR_16BIT,	0xD282, 0x0926},
+	{MISENSOR_16BIT,	0xD284, 0x03E0},
+	{MISENSOR_16BIT,	0xD286, 0xB502},
+	{MISENSOR_16BIT,	0xD288, 0x9502},
+	{MISENSOR_16BIT,	0xD28A, 0x952E},
+	{MISENSOR_16BIT,	0xD28C, 0x7E05},
+	{MISENSOR_16BIT,	0xD28E, 0xB5C2},
+	{MISENSOR_16BIT,	0xD290, 0x70CF},
+	{MISENSOR_16BIT,	0xD292, 0xFFFF},
+	{MISENSOR_16BIT,	0xD294, 0xC610},
+	{MISENSOR_16BIT,	0xD296, 0x099A},
+	{MISENSOR_16BIT,	0xD298, 0x04A0},
+	{MISENSOR_16BIT,	0xD29A, 0xB026},
+	{MISENSOR_16BIT,	0xD29C, 0x0E02},
+	{MISENSOR_16BIT,	0xD29E, 0x0560},
+	{MISENSOR_16BIT,	0xD2A0, 0xDE00},
+	{MISENSOR_16BIT,	0xD2A2, 0x0A12},
+	{MISENSOR_16BIT,	0xD2A4, 0x0320},
+	{MISENSOR_16BIT,	0xD2A6, 0xB7C4},
+	{MISENSOR_16BIT,	0xD2A8, 0x0B36},
+	{MISENSOR_16BIT,	0xD2AA, 0x03A0},
+	{MISENSOR_16BIT,	0xD2AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD2AE, 0x9502},
+	{MISENSOR_16BIT,	0xD2B0, 0x7608},
+	{MISENSOR_16BIT,	0xD2B2, 0xB8A8},
+	{MISENSOR_16BIT,	0xD2B4, 0xB502},
+	{MISENSOR_16BIT,	0xD2B6, 0x70CF},
+	{MISENSOR_16BIT,	0xD2B8, 0x0000},
+	{MISENSOR_16BIT,	0xD2BA, 0x5536},
+	{MISENSOR_16BIT,	0xD2BC, 0x7860},
+	{MISENSOR_16BIT,	0xD2BE, 0x2686},
+	{MISENSOR_16BIT,	0xD2C0, 0x1FFB},
+	{MISENSOR_16BIT,	0xD2C2, 0x9502},
+	{MISENSOR_16BIT,	0xD2C4, 0x78C5},
+	{MISENSOR_16BIT,	0xD2C6, 0x0631},
+	{MISENSOR_16BIT,	0xD2C8, 0x05E0},
+	{MISENSOR_16BIT,	0xD2CA, 0xB502},
+	{MISENSOR_16BIT,	0xD2CC, 0x72CF},
+	{MISENSOR_16BIT,	0xD2CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D0, 0xC5D4},
+	{MISENSOR_16BIT,	0xD2D2, 0x923A},
+	{MISENSOR_16BIT,	0xD2D4, 0x73CF},
+	{MISENSOR_16BIT,	0xD2D6, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D8, 0xC7D0},
+	{MISENSOR_16BIT,	0xD2DA, 0xB020},
+	{MISENSOR_16BIT,	0xD2DC, 0x9220},
+	{MISENSOR_16BIT,	0xD2DE, 0xB021},
+	{MISENSOR_16BIT,	0xD2E0, 0x9221},
+	{MISENSOR_16BIT,	0xD2E2, 0xB022},
+	{MISENSOR_16BIT,	0xD2E4, 0x9222},
+	{MISENSOR_16BIT,	0xD2E6, 0xB023},
+	{MISENSOR_16BIT,	0xD2E8, 0x9223},
+	{MISENSOR_16BIT,	0xD2EA, 0xB024},
+	{MISENSOR_16BIT,	0xD2EC, 0x9227},
+	{MISENSOR_16BIT,	0xD2EE, 0xB025},
+	{MISENSOR_16BIT,	0xD2F0, 0x9228},
+	{MISENSOR_16BIT,	0xD2F2, 0xB026},
+	{MISENSOR_16BIT,	0xD2F4, 0x922B},
+	{MISENSOR_16BIT,	0xD2F6, 0xB027},
+	{MISENSOR_16BIT,	0xD2F8, 0x922C},
+	{MISENSOR_16BIT,	0xD2FA, 0xB028},
+	{MISENSOR_16BIT,	0xD2FC, 0x1258},
+	{MISENSOR_16BIT,	0xD2FE, 0x0101},
+	{MISENSOR_16BIT,	0xD300, 0xB029},
+	{MISENSOR_16BIT,	0xD302, 0x125A},
+	{MISENSOR_16BIT,	0xD304, 0x0101},
+	{MISENSOR_16BIT,	0xD306, 0xB02A},
+	{MISENSOR_16BIT,	0xD308, 0x1336},
+	{MISENSOR_16BIT,	0xD30A, 0x8081},
+	{MISENSOR_16BIT,	0xD30C, 0xA836},
+	{MISENSOR_16BIT,	0xD30E, 0x1337},
+	{MISENSOR_16BIT,	0xD310, 0x8081},
+	{MISENSOR_16BIT,	0xD312, 0xA837},
+	{MISENSOR_16BIT,	0xD314, 0x12A7},
+	{MISENSOR_16BIT,	0xD316, 0x0701},
+	{MISENSOR_16BIT,	0xD318, 0xB02C},
+	{MISENSOR_16BIT,	0xD31A, 0x1354},
+	{MISENSOR_16BIT,	0xD31C, 0x8081},
+	{MISENSOR_16BIT,	0xD31E, 0x7FE0},
+	{MISENSOR_16BIT,	0xD320, 0xA83A},
+	{MISENSOR_16BIT,	0xD322, 0x78E0},
+	{MISENSOR_16BIT,	0xD324, 0xC0F1},
+	{MISENSOR_16BIT,	0xD326, 0x0DC2},
+	{MISENSOR_16BIT,	0xD328, 0x05C0},
+	{MISENSOR_16BIT,	0xD32A, 0x7608},
+	{MISENSOR_16BIT,	0xD32C, 0x09BB},
+	{MISENSOR_16BIT,	0xD32E, 0x0010},
+	{MISENSOR_16BIT,	0xD330, 0x75CF},
+	{MISENSOR_16BIT,	0xD332, 0xFFFF},
+	{MISENSOR_16BIT,	0xD334, 0xD4E0},
+	{MISENSOR_16BIT,	0xD336, 0x8D21},
+	{MISENSOR_16BIT,	0xD338, 0x8D00},
+	{MISENSOR_16BIT,	0xD33A, 0x2153},
+	{MISENSOR_16BIT,	0xD33C, 0x0003},
+	{MISENSOR_16BIT,	0xD33E, 0xB8C0},
+	{MISENSOR_16BIT,	0xD340, 0x8D45},
+	{MISENSOR_16BIT,	0xD342, 0x0B23},
+	{MISENSOR_16BIT,	0xD344, 0x0000},
+	{MISENSOR_16BIT,	0xD346, 0xEA8F},
+	{MISENSOR_16BIT,	0xD348, 0x0915},
+	{MISENSOR_16BIT,	0xD34A, 0x001E},
+	{MISENSOR_16BIT,	0xD34C, 0xFF81},
+	{MISENSOR_16BIT,	0xD34E, 0xE808},
+	{MISENSOR_16BIT,	0xD350, 0x2540},
+	{MISENSOR_16BIT,	0xD352, 0x1900},
+	{MISENSOR_16BIT,	0xD354, 0xFFDE},
+	{MISENSOR_16BIT,	0xD356, 0x8D00},
+	{MISENSOR_16BIT,	0xD358, 0xB880},
+	{MISENSOR_16BIT,	0xD35A, 0xF004},
+	{MISENSOR_16BIT,	0xD35C, 0x8D00},
+	{MISENSOR_16BIT,	0xD35E, 0xB8A0},
+	{MISENSOR_16BIT,	0xD360, 0xAD00},
+	{MISENSOR_16BIT,	0xD362, 0x8D05},
+	{MISENSOR_16BIT,	0xD364, 0xE081},
+	{MISENSOR_16BIT,	0xD366, 0x20CC},
+	{MISENSOR_16BIT,	0xD368, 0x80A2},
+	{MISENSOR_16BIT,	0xD36A, 0xDF00},
+	{MISENSOR_16BIT,	0xD36C, 0xF40A},
+	{MISENSOR_16BIT,	0xD36E, 0x71CF},
+	{MISENSOR_16BIT,	0xD370, 0xFFFF},
+	{MISENSOR_16BIT,	0xD372, 0xC84C},
+	{MISENSOR_16BIT,	0xD374, 0x9102},
+	{MISENSOR_16BIT,	0xD376, 0x7708},
+	{MISENSOR_16BIT,	0xD378, 0xB8A6},
+	{MISENSOR_16BIT,	0xD37A, 0x2786},
+	{MISENSOR_16BIT,	0xD37C, 0x1FFE},
+	{MISENSOR_16BIT,	0xD37E, 0xB102},
+	{MISENSOR_16BIT,	0xD380, 0x0B42},
+	{MISENSOR_16BIT,	0xD382, 0x0180},
+	{MISENSOR_16BIT,	0xD384, 0x0E3E},
+	{MISENSOR_16BIT,	0xD386, 0x0180},
+	{MISENSOR_16BIT,	0xD388, 0x0F4A},
+	{MISENSOR_16BIT,	0xD38A, 0x0160},
+	{MISENSOR_16BIT,	0xD38C, 0x70C9},
+	{MISENSOR_16BIT,	0xD38E, 0x8D05},
+	{MISENSOR_16BIT,	0xD390, 0xE081},
+	{MISENSOR_16BIT,	0xD392, 0x20CC},
+	{MISENSOR_16BIT,	0xD394, 0x80A2},
+	{MISENSOR_16BIT,	0xD396, 0xF429},
+	{MISENSOR_16BIT,	0xD398, 0x76CF},
+	{MISENSOR_16BIT,	0xD39A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD39C, 0xC84C},
+	{MISENSOR_16BIT,	0xD39E, 0x082D},
+	{MISENSOR_16BIT,	0xD3A0, 0x0051},
+	{MISENSOR_16BIT,	0xD3A2, 0x70CF},
+	{MISENSOR_16BIT,	0xD3A4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD3A6, 0xC90C},
+	{MISENSOR_16BIT,	0xD3A8, 0x8805},
+	{MISENSOR_16BIT,	0xD3AA, 0x09B6},
+	{MISENSOR_16BIT,	0xD3AC, 0x0360},
+	{MISENSOR_16BIT,	0xD3AE, 0xD908},
+	{MISENSOR_16BIT,	0xD3B0, 0x2099},
+	{MISENSOR_16BIT,	0xD3B2, 0x0802},
+	{MISENSOR_16BIT,	0xD3B4, 0x9634},
+	{MISENSOR_16BIT,	0xD3B6, 0xB503},
+	{MISENSOR_16BIT,	0xD3B8, 0x7902},
+	{MISENSOR_16BIT,	0xD3BA, 0x1523},
+	{MISENSOR_16BIT,	0xD3BC, 0x1080},
+	{MISENSOR_16BIT,	0xD3BE, 0xB634},
+	{MISENSOR_16BIT,	0xD3C0, 0xE001},
+	{MISENSOR_16BIT,	0xD3C2, 0x1D23},
+	{MISENSOR_16BIT,	0xD3C4, 0x1002},
+	{MISENSOR_16BIT,	0xD3C6, 0xF00B},
+	{MISENSOR_16BIT,	0xD3C8, 0x9634},
+	{MISENSOR_16BIT,	0xD3CA, 0x9503},
+	{MISENSOR_16BIT,	0xD3CC, 0x6038},
+	{MISENSOR_16BIT,	0xD3CE, 0xB614},
+	{MISENSOR_16BIT,	0xD3D0, 0x153F},
+	{MISENSOR_16BIT,	0xD3D2, 0x1080},
+	{MISENSOR_16BIT,	0xD3D4, 0xE001},
+	{MISENSOR_16BIT,	0xD3D6, 0x1D3F},
+	{MISENSOR_16BIT,	0xD3D8, 0x1002},
+	{MISENSOR_16BIT,	0xD3DA, 0xFFA4},
+	{MISENSOR_16BIT,	0xD3DC, 0x9602},
+	{MISENSOR_16BIT,	0xD3DE, 0x7F05},
+	{MISENSOR_16BIT,	0xD3E0, 0xD800},
+	{MISENSOR_16BIT,	0xD3E2, 0xB6E2},
+	{MISENSOR_16BIT,	0xD3E4, 0xAD05},
+	{MISENSOR_16BIT,	0xD3E6, 0x0511},
+	{MISENSOR_16BIT,	0xD3E8, 0x05E0},
+	{MISENSOR_16BIT,	0xD3EA, 0xD800},
+	{MISENSOR_16BIT,	0xD3EC, 0xC0F1},
+	{MISENSOR_16BIT,	0xD3EE, 0x0CFE},
+	{MISENSOR_16BIT,	0xD3F0, 0x05C0},
+	{MISENSOR_16BIT,	0xD3F2, 0x0A96},
+	{MISENSOR_16BIT,	0xD3F4, 0x05A0},
+	{MISENSOR_16BIT,	0xD3F6, 0x7608},
+	{MISENSOR_16BIT,	0xD3F8, 0x0C22},
+	{MISENSOR_16BIT,	0xD3FA, 0x0240},
+	{MISENSOR_16BIT,	0xD3FC, 0xE080},
+	{MISENSOR_16BIT,	0xD3FE, 0x20CA},
+	{MISENSOR_16BIT,	0xD400, 0x0F82},
+	{MISENSOR_16BIT,	0xD402, 0x0000},
+	{MISENSOR_16BIT,	0xD404, 0x190B},
+	{MISENSOR_16BIT,	0xD406, 0x0C60},
+	{MISENSOR_16BIT,	0xD408, 0x05A2},
+	{MISENSOR_16BIT,	0xD40A, 0x21CA},
+	{MISENSOR_16BIT,	0xD40C, 0x0022},
+	{MISENSOR_16BIT,	0xD40E, 0x0C56},
+	{MISENSOR_16BIT,	0xD410, 0x0240},
+	{MISENSOR_16BIT,	0xD412, 0xE806},
+	{MISENSOR_16BIT,	0xD414, 0x0E0E},
+	{MISENSOR_16BIT,	0xD416, 0x0220},
+	{MISENSOR_16BIT,	0xD418, 0x70C9},
+	{MISENSOR_16BIT,	0xD41A, 0xF048},
+	{MISENSOR_16BIT,	0xD41C, 0x0896},
+	{MISENSOR_16BIT,	0xD41E, 0x0440},
+	{MISENSOR_16BIT,	0xD420, 0x0E96},
+	{MISENSOR_16BIT,	0xD422, 0x0400},
+	{MISENSOR_16BIT,	0xD424, 0x0966},
+	{MISENSOR_16BIT,	0xD426, 0x0380},
+	{MISENSOR_16BIT,	0xD428, 0x75CF},
+	{MISENSOR_16BIT,	0xD42A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD42C, 0xD4E0},
+	{MISENSOR_16BIT,	0xD42E, 0x8D00},
+	{MISENSOR_16BIT,	0xD430, 0x084D},
+	{MISENSOR_16BIT,	0xD432, 0x001E},
+	{MISENSOR_16BIT,	0xD434, 0xFF47},
+	{MISENSOR_16BIT,	0xD436, 0x080D},
+	{MISENSOR_16BIT,	0xD438, 0x0050},
+	{MISENSOR_16BIT,	0xD43A, 0xFF57},
+	{MISENSOR_16BIT,	0xD43C, 0x0841},
+	{MISENSOR_16BIT,	0xD43E, 0x0051},
+	{MISENSOR_16BIT,	0xD440, 0x8D04},
+	{MISENSOR_16BIT,	0xD442, 0x9521},
+	{MISENSOR_16BIT,	0xD444, 0xE064},
+	{MISENSOR_16BIT,	0xD446, 0x790C},
+	{MISENSOR_16BIT,	0xD448, 0x702F},
+	{MISENSOR_16BIT,	0xD44A, 0x0CE2},
+	{MISENSOR_16BIT,	0xD44C, 0x05E0},
+	{MISENSOR_16BIT,	0xD44E, 0xD964},
+	{MISENSOR_16BIT,	0xD450, 0x72CF},
+	{MISENSOR_16BIT,	0xD452, 0xFFFF},
+	{MISENSOR_16BIT,	0xD454, 0xC700},
+	{MISENSOR_16BIT,	0xD456, 0x9235},
+	{MISENSOR_16BIT,	0xD458, 0x0811},
+	{MISENSOR_16BIT,	0xD45A, 0x0043},
+	{MISENSOR_16BIT,	0xD45C, 0xFF3D},
+	{MISENSOR_16BIT,	0xD45E, 0x080D},
+	{MISENSOR_16BIT,	0xD460, 0x0051},
+	{MISENSOR_16BIT,	0xD462, 0xD801},
+	{MISENSOR_16BIT,	0xD464, 0xFF77},
+	{MISENSOR_16BIT,	0xD466, 0xF025},
+	{MISENSOR_16BIT,	0xD468, 0x9501},
+	{MISENSOR_16BIT,	0xD46A, 0x9235},
+	{MISENSOR_16BIT,	0xD46C, 0x0911},
+	{MISENSOR_16BIT,	0xD46E, 0x0003},
+	{MISENSOR_16BIT,	0xD470, 0xFF49},
+	{MISENSOR_16BIT,	0xD472, 0x080D},
+	{MISENSOR_16BIT,	0xD474, 0x0051},
+	{MISENSOR_16BIT,	0xD476, 0xD800},
+	{MISENSOR_16BIT,	0xD478, 0xFF72},
+	{MISENSOR_16BIT,	0xD47A, 0xF01B},
+	{MISENSOR_16BIT,	0xD47C, 0x0886},
+	{MISENSOR_16BIT,	0xD47E, 0x03E0},
+	{MISENSOR_16BIT,	0xD480, 0xD801},
+	{MISENSOR_16BIT,	0xD482, 0x0EF6},
+	{MISENSOR_16BIT,	0xD484, 0x03C0},
+	{MISENSOR_16BIT,	0xD486, 0x0F52},
+	{MISENSOR_16BIT,	0xD488, 0x0340},
+	{MISENSOR_16BIT,	0xD48A, 0x0DBA},
+	{MISENSOR_16BIT,	0xD48C, 0x0200},
+	{MISENSOR_16BIT,	0xD48E, 0x0AF6},
+	{MISENSOR_16BIT,	0xD490, 0x0440},
+	{MISENSOR_16BIT,	0xD492, 0x0C22},
+	{MISENSOR_16BIT,	0xD494, 0x0400},
+	{MISENSOR_16BIT,	0xD496, 0x0D72},
+	{MISENSOR_16BIT,	0xD498, 0x0440},
+	{MISENSOR_16BIT,	0xD49A, 0x0DC2},
+	{MISENSOR_16BIT,	0xD49C, 0x0200},
+	{MISENSOR_16BIT,	0xD49E, 0x0972},
+	{MISENSOR_16BIT,	0xD4A0, 0x0440},
+	{MISENSOR_16BIT,	0xD4A2, 0x0D3A},
+	{MISENSOR_16BIT,	0xD4A4, 0x0220},
+	{MISENSOR_16BIT,	0xD4A6, 0xD820},
+	{MISENSOR_16BIT,	0xD4A8, 0x0BFA},
+	{MISENSOR_16BIT,	0xD4AA, 0x0260},
+	{MISENSOR_16BIT,	0xD4AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD4AE, 0x0451},
+	{MISENSOR_16BIT,	0xD4B0, 0x05C0},
+	{MISENSOR_16BIT,	0xD4B2, 0x78E0},
+	{MISENSOR_16BIT,	0xD4B4, 0xD900},
+	{MISENSOR_16BIT,	0xD4B6, 0xF00A},
+	{MISENSOR_16BIT,	0xD4B8, 0x70CF},
+	{MISENSOR_16BIT,	0xD4BA, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4BC, 0xD520},
+	{MISENSOR_16BIT,	0xD4BE, 0x7835},
+	{MISENSOR_16BIT,	0xD4C0, 0x8041},
+	{MISENSOR_16BIT,	0xD4C2, 0x8000},
+	{MISENSOR_16BIT,	0xD4C4, 0xE102},
+	{MISENSOR_16BIT,	0xD4C6, 0xA040},
+	{MISENSOR_16BIT,	0xD4C8, 0x09F1},
+	{MISENSOR_16BIT,	0xD4CA, 0x8114},
+	{MISENSOR_16BIT,	0xD4CC, 0x71CF},
+	{MISENSOR_16BIT,	0xD4CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D0, 0xD4E0},
+	{MISENSOR_16BIT,	0xD4D2, 0x70CF},
+	{MISENSOR_16BIT,	0xD4D4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D6, 0xC594},
+	{MISENSOR_16BIT,	0xD4D8, 0xB03A},
+	{MISENSOR_16BIT,	0xD4DA, 0x7FE0},
+	{MISENSOR_16BIT,	0xD4DC, 0xD800},
+	{MISENSOR_16BIT,	0xD4DE, 0x0000},
+	{MISENSOR_16BIT,	0xD4E0, 0x0000},
+	{MISENSOR_16BIT,	0xD4E2, 0x0500},
+	{MISENSOR_16BIT,	0xD4E4, 0x0500},
+	{MISENSOR_16BIT,	0xD4E6, 0x0200},
+	{MISENSOR_16BIT,	0xD4E8, 0x0330},
+	{MISENSOR_16BIT,	0xD4EA, 0x0000},
+	{MISENSOR_16BIT,	0xD4EC, 0x0000},
+	{MISENSOR_16BIT,	0xD4EE, 0x03CD},
+	{MISENSOR_16BIT,	0xD4F0, 0x050D},
+	{MISENSOR_16BIT,	0xD4F2, 0x01C5},
+	{MISENSOR_16BIT,	0xD4F4, 0x03B3},
+	{MISENSOR_16BIT,	0xD4F6, 0x00E0},
+	{MISENSOR_16BIT,	0xD4F8, 0x01E3},
+	{MISENSOR_16BIT,	0xD4FA, 0x0280},
+	{MISENSOR_16BIT,	0xD4FC, 0x01E0},
+	{MISENSOR_16BIT,	0xD4FE, 0x0109},
+	{MISENSOR_16BIT,	0xD500, 0x0080},
+	{MISENSOR_16BIT,	0xD502, 0x0500},
+	{MISENSOR_16BIT,	0xD504, 0x0000},
+	{MISENSOR_16BIT,	0xD506, 0x0000},
+	{MISENSOR_16BIT,	0xD508, 0x0000},
+	{MISENSOR_16BIT,	0xD50A, 0x0000},
+	{MISENSOR_16BIT,	0xD50C, 0x0000},
+	{MISENSOR_16BIT,	0xD50E, 0x0000},
+	{MISENSOR_16BIT,	0xD510, 0x0000},
+	{MISENSOR_16BIT,	0xD512, 0x0000},
+	{MISENSOR_16BIT,	0xD514, 0x0000},
+	{MISENSOR_16BIT,	0xD516, 0x0000},
+	{MISENSOR_16BIT,	0xD518, 0x0000},
+	{MISENSOR_16BIT,	0xD51A, 0x0000},
+	{MISENSOR_16BIT,	0xD51C, 0x0000},
+	{MISENSOR_16BIT,	0xD51E, 0x0000},
+	{MISENSOR_16BIT,	0xD520, 0xFFFF},
+	{MISENSOR_16BIT,	0xD522, 0xC9B4},
+	{MISENSOR_16BIT,	0xD524, 0xFFFF},
+	{MISENSOR_16BIT,	0xD526, 0xD324},
+	{MISENSOR_16BIT,	0xD528, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52A, 0xCA34},
+	{MISENSOR_16BIT,	0xD52C, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52E, 0xD3EC},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x04B4},
+	{MISENSOR_16BIT,	0xE002, 0x0302},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* PGA parameter and APGA
+	 * [Step4-APGA] [TP101_MT9M114_APGA]
+	 */
+	{MISENSOR_16BIT,	0x098E, 0x495E},
+	{MISENSOR_16BIT,	0xC95E, 0x0000},
+	{MISENSOR_16BIT,	0x3640, 0x02B0},
+	{MISENSOR_16BIT,	0x3642, 0x8063},
+	{MISENSOR_16BIT,	0x3644, 0x78D0},
+	{MISENSOR_16BIT,	0x3646, 0x50CC},
+	{MISENSOR_16BIT,	0x3648, 0x3511},
+	{MISENSOR_16BIT,	0x364A, 0x0110},
+	{MISENSOR_16BIT,	0x364C, 0xBD8A},
+	{MISENSOR_16BIT,	0x364E, 0x0CD1},
+	{MISENSOR_16BIT,	0x3650, 0x24ED},
+	{MISENSOR_16BIT,	0x3652, 0x7C11},
+	{MISENSOR_16BIT,	0x3654, 0x0150},
+	{MISENSOR_16BIT,	0x3656, 0x124C},
+	{MISENSOR_16BIT,	0x3658, 0x3130},
+	{MISENSOR_16BIT,	0x365A, 0x508C},
+	{MISENSOR_16BIT,	0x365C, 0x21F1},
+	{MISENSOR_16BIT,	0x365E, 0x0090},
+	{MISENSOR_16BIT,	0x3660, 0xBFCA},
+	{MISENSOR_16BIT,	0x3662, 0x0A11},
+	{MISENSOR_16BIT,	0x3664, 0x4F4B},
+	{MISENSOR_16BIT,	0x3666, 0x28B1},
+	{MISENSOR_16BIT,	0x3680, 0x50A9},
+	{MISENSOR_16BIT,	0x3682, 0xA04B},
+	{MISENSOR_16BIT,	0x3684, 0x0E2D},
+	{MISENSOR_16BIT,	0x3686, 0x73EC},
+	{MISENSOR_16BIT,	0x3688, 0x164F},
+	{MISENSOR_16BIT,	0x368A, 0xF829},
+	{MISENSOR_16BIT,	0x368C, 0xC1A8},
+	{MISENSOR_16BIT,	0x368E, 0xB0EC},
+	{MISENSOR_16BIT,	0x3690, 0xE76A},
+	{MISENSOR_16BIT,	0x3692, 0x69AF},
+	{MISENSOR_16BIT,	0x3694, 0x378C},
+	{MISENSOR_16BIT,	0x3696, 0xA70D},
+	{MISENSOR_16BIT,	0x3698, 0x884F},
+	{MISENSOR_16BIT,	0x369A, 0xEE8B},
+	{MISENSOR_16BIT,	0x369C, 0x5DEF},
+	{MISENSOR_16BIT,	0x369E, 0x27CC},
+	{MISENSOR_16BIT,	0x36A0, 0xCAAC},
+	{MISENSOR_16BIT,	0x36A2, 0x840E},
+	{MISENSOR_16BIT,	0x36A4, 0xDAA9},
+	{MISENSOR_16BIT,	0x36A6, 0xF00C},
+	{MISENSOR_16BIT,	0x36C0, 0x1371},
+	{MISENSOR_16BIT,	0x36C2, 0x272F},
+	{MISENSOR_16BIT,	0x36C4, 0x2293},
+	{MISENSOR_16BIT,	0x36C6, 0xE6D0},
+	{MISENSOR_16BIT,	0x36C8, 0xEC32},
+	{MISENSOR_16BIT,	0x36CA, 0x11B1},
+	{MISENSOR_16BIT,	0x36CC, 0x7BAF},
+	{MISENSOR_16BIT,	0x36CE, 0x5813},
+	{MISENSOR_16BIT,	0x36D0, 0xB871},
+	{MISENSOR_16BIT,	0x36D2, 0x8913},
+	{MISENSOR_16BIT,	0x36D4, 0x4610},
+	{MISENSOR_16BIT,	0x36D6, 0x7EEE},
+	{MISENSOR_16BIT,	0x36D8, 0x0DF3},
+	{MISENSOR_16BIT,	0x36DA, 0xB84F},
+	{MISENSOR_16BIT,	0x36DC, 0xB532},
+	{MISENSOR_16BIT,	0x36DE, 0x1171},
+	{MISENSOR_16BIT,	0x36E0, 0x13CF},
+	{MISENSOR_16BIT,	0x36E2, 0x22F3},
+	{MISENSOR_16BIT,	0x36E4, 0xE090},
+	{MISENSOR_16BIT,	0x36E6, 0x8133},
+	{MISENSOR_16BIT,	0x3700, 0x88AE},
+	{MISENSOR_16BIT,	0x3702, 0x00EA},
+	{MISENSOR_16BIT,	0x3704, 0x344F},
+	{MISENSOR_16BIT,	0x3706, 0xEC88},
+	{MISENSOR_16BIT,	0x3708, 0x3E91},
+	{MISENSOR_16BIT,	0x370A, 0xF12D},
+	{MISENSOR_16BIT,	0x370C, 0xB0EF},
+	{MISENSOR_16BIT,	0x370E, 0x77CD},
+	{MISENSOR_16BIT,	0x3710, 0x7930},
+	{MISENSOR_16BIT,	0x3712, 0x5C12},
+	{MISENSOR_16BIT,	0x3714, 0x500C},
+	{MISENSOR_16BIT,	0x3716, 0x22CE},
+	{MISENSOR_16BIT,	0x3718, 0x2370},
+	{MISENSOR_16BIT,	0x371A, 0x258F},
+	{MISENSOR_16BIT,	0x371C, 0x3D30},
+	{MISENSOR_16BIT,	0x371E, 0x370C},
+	{MISENSOR_16BIT,	0x3720, 0x03ED},
+	{MISENSOR_16BIT,	0x3722, 0x9AD0},
+	{MISENSOR_16BIT,	0x3724, 0x7ECF},
+	{MISENSOR_16BIT,	0x3726, 0x1093},
+	{MISENSOR_16BIT,	0x3740, 0x2391},
+	{MISENSOR_16BIT,	0x3742, 0xAAD0},
+	{MISENSOR_16BIT,	0x3744, 0x28F2},
+	{MISENSOR_16BIT,	0x3746, 0xBA4F},
+	{MISENSOR_16BIT,	0x3748, 0xC536},
+	{MISENSOR_16BIT,	0x374A, 0x1472},
+	{MISENSOR_16BIT,	0x374C, 0xD110},
+	{MISENSOR_16BIT,	0x374E, 0x2933},
+	{MISENSOR_16BIT,	0x3750, 0xD0D1},
+	{MISENSOR_16BIT,	0x3752, 0x9F37},
+	{MISENSOR_16BIT,	0x3754, 0x34D1},
+	{MISENSOR_16BIT,	0x3756, 0x1C6C},
+	{MISENSOR_16BIT,	0x3758, 0x3FD2},
+	{MISENSOR_16BIT,	0x375A, 0xCB72},
+	{MISENSOR_16BIT,	0x375C, 0xBA96},
+	{MISENSOR_16BIT,	0x375E, 0x1551},
+	{MISENSOR_16BIT,	0x3760, 0xB74F},
+	{MISENSOR_16BIT,	0x3762, 0x1672},
+	{MISENSOR_16BIT,	0x3764, 0x84F1},
+	{MISENSOR_16BIT,	0x3766, 0xC2D6},
+	{MISENSOR_16BIT,	0x3782, 0x01E0},
+	{MISENSOR_16BIT,	0x3784, 0x0280},
+	{MISENSOR_16BIT,	0x37C0, 0xA6EA},
+	{MISENSOR_16BIT,	0x37C2, 0x874B},
+	{MISENSOR_16BIT,	0x37C4, 0x85CB},
+	{MISENSOR_16BIT,	0x37C6, 0x968A},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC960, 0x0AF0},
+	{MISENSOR_16BIT,	0xC962, 0x79E2},
+	{MISENSOR_16BIT,	0xC964, 0x5EC8},
+	{MISENSOR_16BIT,	0xC966, 0x791F},
+	{MISENSOR_16BIT,	0xC968, 0x76EE},
+	{MISENSOR_16BIT,	0xC96A, 0x0FA0},
+	{MISENSOR_16BIT,	0xC96C, 0x7DFA},
+	{MISENSOR_16BIT,	0xC96E, 0x7DAF},
+	{MISENSOR_16BIT,	0xC970, 0x7E02},
+	{MISENSOR_16BIT,	0xC972, 0x7E0A},
+	{MISENSOR_16BIT,	0xC974, 0x1964},
+	{MISENSOR_16BIT,	0xC976, 0x7CDC},
+	{MISENSOR_16BIT,	0xC978, 0x7838},
+	{MISENSOR_16BIT,	0xC97A, 0x7C2F},
+	{MISENSOR_16BIT,	0xC97C, 0x7792},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step4-APGA] */
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step5-AWB_CCM]1: LOAD=CCM */
+	{MISENSOR_16BIT,	0xC892, 0x0267},
+	{MISENSOR_16BIT,	0xC894, 0xFF1A},
+	{MISENSOR_16BIT,	0xC896, 0xFFB3},
+	{MISENSOR_16BIT,	0xC898, 0xFF80},
+	{MISENSOR_16BIT,	0xC89A, 0x0166},
+	{MISENSOR_16BIT,	0xC89C, 0x0003},
+	{MISENSOR_16BIT,	0xC89E, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8A0, 0xFEB4},
+	{MISENSOR_16BIT,	0xC8A2, 0x024D},
+	{MISENSOR_16BIT,	0xC8A4, 0x01BF},
+	{MISENSOR_16BIT,	0xC8A6, 0xFF01},
+	{MISENSOR_16BIT,	0xC8A8, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8AA, 0xFF75},
+	{MISENSOR_16BIT,	0xC8AC, 0x0198},
+	{MISENSOR_16BIT,	0xC8AE, 0xFFFD},
+	{MISENSOR_16BIT,	0xC8B0, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8B2, 0xFEE7},
+	{MISENSOR_16BIT,	0xC8B4, 0x02A8},
+	{MISENSOR_16BIT,	0xC8B6, 0x01D9},
+	{MISENSOR_16BIT,	0xC8B8, 0xFF26},
+	{MISENSOR_16BIT,	0xC8BA, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8BC, 0xFFB3},
+	{MISENSOR_16BIT,	0xC8BE, 0x0132},
+	{MISENSOR_16BIT,	0xC8C0, 0xFFE8},
+	{MISENSOR_16BIT,	0xC8C2, 0xFFDA},
+	{MISENSOR_16BIT,	0xC8C4, 0xFECD},
+	{MISENSOR_16BIT,	0xC8C6, 0x02C2},
+	{MISENSOR_16BIT,	0xC8C8, 0x0075},
+	{MISENSOR_16BIT,	0xC8CA, 0x011C},
+	{MISENSOR_16BIT,	0xC8CC, 0x009A},
+	{MISENSOR_16BIT,	0xC8CE, 0x0105},
+	{MISENSOR_16BIT,	0xC8D0, 0x00A4},
+	{MISENSOR_16BIT,	0xC8D2, 0x00AC},
+	{MISENSOR_16BIT,	0xC8D4, 0x0A8C},
+	{MISENSOR_16BIT,	0xC8D6, 0x0F0A},
+	{MISENSOR_16BIT,	0xC8D8, 0x1964},
+
+	/* LOAD=AWB */
+	{MISENSOR_16BIT,	0xC914, 0x0000},
+	{MISENSOR_16BIT,	0xC916, 0x0000},
+	{MISENSOR_16BIT,	0xC918, 0x04FF},
+	{MISENSOR_16BIT,	0xC91A, 0x02CF},
+	{MISENSOR_16BIT,	0xC904, 0x0033},
+	{MISENSOR_16BIT,	0xC906, 0x0040},
+	{MISENSOR_8BIT,   0xC8F2, 0x03},
+	{MISENSOR_8BIT,   0xC8F3, 0x02},
+	{MISENSOR_16BIT,	0xC906, 0x003C},
+	{MISENSOR_16BIT,	0xC8F4, 0x0000},
+	{MISENSOR_16BIT,	0xC8F6, 0x0000},
+	{MISENSOR_16BIT,	0xC8F8, 0x0000},
+	{MISENSOR_16BIT,	0xC8FA, 0xE724},
+	{MISENSOR_16BIT,	0xC8FC, 0x1583},
+	{MISENSOR_16BIT,	0xC8FE, 0x2045},
+	{MISENSOR_16BIT,	0xC900, 0x05DC},
+	{MISENSOR_16BIT,	0xC902, 0x007C},
+	{MISENSOR_8BIT,   0xC90C, 0x80},
+	{MISENSOR_8BIT,   0xC90D, 0x80},
+	{MISENSOR_8BIT,   0xC90E, 0x80},
+	{MISENSOR_8BIT,   0xC90F, 0x88},
+	{MISENSOR_8BIT,   0xC910, 0x80},
+	{MISENSOR_8BIT,   0xC911, 0x80},
+
+	/* LOAD=Step7-CPIPE_Preference */
+	{MISENSOR_16BIT,	0xC926, 0x0020},
+	{MISENSOR_16BIT,	0xC928, 0x009A},
+	{MISENSOR_16BIT,	0xC946, 0x0070},
+	{MISENSOR_16BIT,	0xC948, 0x00F3},
+	{MISENSOR_16BIT,	0xC952, 0x0020},
+	{MISENSOR_16BIT,	0xC954, 0x009A},
+	{MISENSOR_8BIT,   0xC92A, 0x80},
+	{MISENSOR_8BIT,   0xC92B, 0x4B},
+	{MISENSOR_8BIT,   0xC92C, 0x00},
+	{MISENSOR_8BIT,   0xC92D, 0xFF},
+	{MISENSOR_8BIT,   0xC92E, 0x3C},
+	{MISENSOR_8BIT,   0xC92F, 0x02},
+	{MISENSOR_8BIT,   0xC930, 0x06},
+	{MISENSOR_8BIT,   0xC931, 0x64},
+	{MISENSOR_8BIT,   0xC932, 0x01},
+	{MISENSOR_8BIT,   0xC933, 0x0C},
+	{MISENSOR_8BIT,   0xC934, 0x3C},
+	{MISENSOR_8BIT,   0xC935, 0x3C},
+	{MISENSOR_8BIT,   0xC936, 0x3C},
+	{MISENSOR_8BIT,   0xC937, 0x0F},
+	{MISENSOR_8BIT,   0xC938, 0x64},
+	{MISENSOR_8BIT,   0xC939, 0x64},
+	{MISENSOR_8BIT,   0xC93A, 0x64},
+	{MISENSOR_8BIT,   0xC93B, 0x32},
+	{MISENSOR_16BIT,	0xC93C, 0x0020},
+	{MISENSOR_16BIT,	0xC93E, 0x009A},
+	{MISENSOR_16BIT,	0xC940, 0x00DC},
+	{MISENSOR_8BIT,   0xC942, 0x38},
+	{MISENSOR_8BIT,   0xC943, 0x30},
+	{MISENSOR_8BIT,   0xC944, 0x50},
+	{MISENSOR_8BIT,   0xC945, 0x19},
+	{MISENSOR_16BIT,	0xC94A, 0x0230},
+	{MISENSOR_16BIT,	0xC94C, 0x0010},
+	{MISENSOR_16BIT,	0xC94E, 0x01CD},
+	{MISENSOR_8BIT,   0xC950, 0x05},
+	{MISENSOR_8BIT,   0xC951, 0x40},
+	{MISENSOR_8BIT,   0xC87B, 0x1B},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+	{MISENSOR_16BIT,	0xC890, 0x0080},
+	{MISENSOR_16BIT,	0xC886, 0x0100},
+	{MISENSOR_16BIT,	0xC87C, 0x005A},
+	{MISENSOR_8BIT,   0xB42A, 0x05},
+	{MISENSOR_8BIT,   0xA80A, 0x20},
+
+	/* Speed up AE/AWB */
+	{MISENSOR_16BIT,	0x098E, 0x2802},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+	{MISENSOR_8BIT,   0xC908, 0x01},
+	{MISENSOR_8BIT,   0xC879, 0x01},
+	{MISENSOR_8BIT,   0xC909, 0x02},
+	{MISENSOR_8BIT,   0xA80A, 0x18},
+	{MISENSOR_8BIT,   0xA80B, 0x18},
+	{MISENSOR_8BIT,   0xAC16, 0x18},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+#endif
diff --git a/drivers/media/video/ov5640_1.c b/drivers/media/video/ov5640_1.c
new file mode 100644
index 0000000..506aba1
--- /dev/null
+++ b/drivers/media/video/ov5640_1.c
@@ -0,0 +1,2377 @@
+/*
+ * Support for ov5640_1 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5640_1.h"
+
+#define to_ov5640_1_sensor(sd) container_of(sd, struct ov5640_1_device, sd)
+
+/* #define DEBUG_I2C_COMMAND */
+#define ovprintk(args...) 
+
+static int ov5640_1_set_i2c_addr = 0;
+
+
+static int
+ov5640_1_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int
+ov5640_1_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+	
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+	
+#ifdef DEBUG_I2C_COMMAND
+	printk("%x %02x%02x %02x\n",msg.addr, data[0], data[1], data[2]);
+#endif	    
+	
+	
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	
+	return num_msg;
+}
+
+static int ov5640_1_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == 1)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+/*
+ * __ov5640_1_flush_reg_array() is internal function to make writing reg
+ * faster and should be not used anywhere else.
+ */
+static int __ov5640_1_flush_reg_array(struct i2c_client *client,
+				     struct ov5640_1_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5640_1_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+/*
+ * ov5640_1_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov5640_1_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov5640_1_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct firmware *
+load_firmware(struct device *dev)
+{
+	const struct firmware *fw;
+	int rc;
+
+	rc = request_firmware(&fw, AF_FW_PATH, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			dev_err(dev, "Error AF firmware %s not found.\n",
+					AF_FW_PATH);
+		else
+			dev_err(dev,
+				"Error %d while requesting firmware %s\n",
+				rc, AF_FW_PATH);
+		return NULL;
+	}
+
+	return fw;
+}
+
+static int ov5640_1_af_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	const struct firmware *firmware;
+	struct ov5640_1_write_ctrl ctrl;
+	int err;
+	int i;
+	int group_length;
+
+	return 0;
+	
+	
+	/* reset MCU */
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_SYS_RESET, OV5640_1_MCU_RESET);
+	if (err)
+		return err;
+
+	/* download firmware */
+	if (dev->firmware) {
+		firmware = dev->firmware;
+	} else {
+		firmware = load_firmware(&client->dev);
+		if (!firmware) {
+			dev_err(&client->dev, "Load firmwares failed\n");
+			return -EINVAL;
+		}
+		dev->firmware = firmware;
+	}
+
+	/* download firmware in group */
+	group_length = (firmware->size) / (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	for (i = 0; i < group_length; i++) {
+		ctrl.buffer.addr = OV5640_1_REG_FW_START
+				    + i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+		memcpy(ctrl.buffer.data,
+			&firmware->data[i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2)],
+			(OV5640_1_MAX_WRITE_BUF_SIZE - 2));
+		ctrl.index = (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+		err = __ov5640_1_flush_reg_array(client, &ctrl);
+		if (err) {
+			dev_err(&client->dev, "write firmwares reg failed\n");
+			return err;
+		}
+	}
+
+	/* download firmware less than 1 group */
+	ctrl.buffer.addr = OV5640_1_REG_FW_START +
+				i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	memcpy(ctrl.buffer.data,
+		&firmware->data[i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2)],
+		firmware->size - i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2));
+	ctrl.index = firmware->size - i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	err = __ov5640_1_flush_reg_array(client, &ctrl);
+	if (err) {
+		dev_err(&client->dev, "write firmwares reg failed\n");
+		return err;
+	}
+
+
+	return ov5640_1_write_reg_array(client, ov5640_1_focus_init);
+}
+
+static int ov5640_1_s_focus_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err = 0;
+
+
+	/*
+	 * if sensor streamoff, writing focus mode reg is invalid.
+	 * only writing focus mode reg is valid after streamon.
+	 */
+	if (dev->streaming == false) {
+		dev->focus_mode = mode;
+		dev->focus_mode_change = true;
+		return 0;
+	}
+
+	switch (mode) {
+	case V4L2_CID_AUTO_FOCUS_START:
+		/* start single focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_SINGLE_FOCUS);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		/* start continuous focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_CONTINUE_FOCUS);
+		break;
+	case V4L2_CID_3A_LOCK:
+		/* pause focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_PAUSE_FOCUS);
+		break;
+	case V4L2_CID_AUTO_FOCUS_STOP:
+		/* release focus to infinity */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_RELEASE_FOCUS);
+		break;
+	default:
+		dev_err(&client->dev, "invalid mode.\n");
+		return -EINVAL;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting focus mode fails.\n");
+		return err;
+	}
+
+	dev->focus_mode = mode;
+	dev->focus_mode_change = false;
+
+	return 0;
+}
+
+static int ov5640_1_s_single_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_START);
+}
+
+static int ov5640_1_s_cont_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_FOCUS_AUTO);
+}
+
+static int ov5640_1_pause_focus(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value != V4L2_LOCK_FOCUS) {
+		dev_err(&client->dev, "invalid focus cmd.\n");
+		return -EINVAL;
+	}
+
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_3A_LOCK);
+}
+
+static int ov5640_1_release_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_STOP);
+}
+
+static int ov5640_1_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_normal_effect);
+		break;
+	case V4L2_COLORFX_SEPIA:
+		err = ov5640_1_write_reg_array(client, ov5640_1_sepia_effect);
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_negative_effect);
+		break;
+	case V4L2_COLORFX_BW:
+		err = ov5640_1_write_reg_array(client, ov5640_1_bw_effect);
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_blue_effect);
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		err = ov5640_1_write_reg_array(client, ov5640_1_green_effect);
+		break;
+	default:
+		dev_err(&client->dev, "invalid color effect.\n");
+		return -ERANGE;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting color effect fails.\n");
+		return err;
+	}
+
+	dev->color_effect = effect;
+
+	return 0;
+}
+
+static int ov5640_1_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int ov5640_1_g_focus_status(struct v4l2_subdev *sd, int *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val = 0;
+
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_STATUS, &val);
+	if (err)
+		return err;
+
+	switch (val & 0xff) {
+	case OV5640_1_FOCUS_FW_DL:
+		/* firmware is downloaded and not to be initialized */
+		*status = V4L2_AUTO_FOCUS_STATUS_FAILED;
+		break;
+	case OV5640_1_FOCUS_FW_INIT:
+		/* firmware is initializing */
+	case OV5640_1_FOCUS_FW_IDLE:
+		/* firmware is idle */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+		break;
+	case OV5640_1_FOCUS_FW_RUN:
+		/* focus is running */
+		*status = V4L2_AUTO_FOCUS_STATUS_BUSY;
+		break;
+	case OV5640_1_FOCUS_FW_FINISH:
+		/* focus is finished */
+		*status = V4L2_AUTO_FOCUS_STATUS_REACHED;
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_1_get_sysclk(struct v4l2_subdev *sd, unsigned int *sysclk)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp1 = 0, temp2 = 0;
+	u32 multiplier = 0, prediv = 0, vco = 0, sysdiv = 0;
+	u32 pll_rdiv = 0, bit_div2x = 0, sclk_rdiv = 0;
+
+	static int sclk_rdiv_map[] = {1, 2, 4, 8};
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_0, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 >> 1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_1, &temp1);
+	if (err)
+		return err;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_2, &temp1);
+	if (err)
+		return err;
+	multiplier = temp1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_3, &temp1);
+	if (err)
+		return err;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_CLK_DIVIDER, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if ((prediv && sclk_rdiv && bit_div2x) == 0)
+		return -EINVAL;
+
+	vco = OV5640_1_XVCLK * multiplier / prediv;
+
+	*sysclk = vco / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	if (*sysclk < MIN_SYSCLK)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read HTS from register settings */
+static int ov5640_1_get_hts(struct v4l2_subdev *sd, unsigned int *hts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+				OV5640_1_REG_TIMING_HTS, hts);
+	if (err)
+		return err;
+
+	if (*hts < MIN_HTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read VTS from register settings */
+static int ov5640_1_get_vts(struct v4l2_subdev *sd, unsigned int *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+				OV5640_1_REG_TIMING_VTS, vts);
+	if (err)
+		return err;
+
+	if (*vts < MIN_VTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write VTS to registers */
+static int ov5640_1_set_vts(struct v4l2_subdev *sd, unsigned int vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_TIMING_VTS, vts);
+}
+
+/* read shutter, in number of line period */
+static int ov5640_1_get_shutter(struct v4l2_subdev *sd, unsigned int *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val, temp;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_EXPOSURE_0, &val);
+	if (err)
+		return err;
+	temp = (val & 0x0fff);
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_EXPOSURE_1, &val);
+	if (err)
+		return err;
+
+	*shutter = (temp << 4) + (val >> 4);
+
+	if(*shutter < MIN_SHUTTER)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_1_set_shutter(struct v4l2_subdev *sd, unsigned int shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp << 4;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_EXPOSURE_1, temp);
+	if (err)
+		return err;
+
+	temp = shutter >> 4;
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_EXPOSURE_0, temp);
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_1_get_gain16(struct v4l2_subdev *sd, unsigned int *gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_GAIN, &val);
+	if (err)
+		return err;
+
+	*gain16 = val & 0x3ff;
+
+	if(*gain16 < MIN_GAIN)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_1_set_gain16(struct v4l2_subdev *sd, unsigned int gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gain16 = gain16 & 0x3ff;
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_GAIN, gain16);
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int ov5640_1_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int ov5640_1_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 gain;
+	int err;
+
+	err = ov5640_1_get_gain16(sd, &gain);
+	if (err)
+		return err;
+
+	*value = gain / 16 * 100;
+
+	return 0;
+}
+
+/* get banding filter value */
+static int ov5640_1_get_light_frequency(struct v4l2_subdev *sd,
+				unsigned int *light_frequency)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_0, &temp);
+	if (err)
+		return err;
+
+	if (temp & OV5640_1_AUTO_BAND) {
+		/* manual */
+		err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_1, &temp);
+		if (err)
+			return err;
+		if (temp & 0x04)
+			/* 50Hz */
+			*light_frequency = OV5640_1_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_1_LIGHT_60HZ;
+	} else {
+		/* auto */
+		err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_2, &temp);
+		if (err)
+			return err;
+		if (temp & 0x01)
+			/* 50Hz */
+			*light_frequency = OV5640_1_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_1_LIGHT_60HZ;
+	}
+
+	return 0;
+}
+
+static int ov5640_1_set_bandingfilter(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	u32 band_step60, max_band60, band_step50, max_band50;
+	int err;
+
+	/* read preview PCLK */
+	err = ov5640_1_get_sysclk(sd, &dev->preview_sysclk);
+	if (err)
+		return err;
+
+	/* read preview HTS */
+	err = ov5640_1_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	/* read preview VTS */
+	err = ov5640_1_get_vts(sd, &dev->preview_vts);
+	if (err)
+		return err;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = dev->preview_sysclk * 100 / dev->preview_hts * 100 / 120;
+	if (band_step60 == 0)
+		return -EINVAL;
+
+	err = ov5640_1_write_reg(client, MISENSOR_16BIT, OV5640_1_REG_B60_STEP,
+								band_step60);
+	if (err)
+		return err;
+
+	max_band60 = (dev->preview_vts - 4) / band_step60;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_B60_MAX, max_band60);
+	if (err)
+		return err;
+
+	/* 50Hz */
+	band_step50 = dev->preview_sysclk * 100 / dev->preview_hts;
+	if (band_step50 == 0)
+		return -EINVAL;
+
+	err = ov5640_1_write_reg(client, MISENSOR_16BIT, OV5640_1_REG_B50_STEP,
+								band_step50);
+	if (err)
+		return err;
+
+	max_band50 = (dev->preview_vts - 4) / band_step50;
+
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_B50_MAX, max_band50);
+}
+
+/* stable in high */
+static int ov5640_1_set_ae_target(struct v4l2_subdev *sd, unsigned int target)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;	
+	u32 fast_high, fast_low;
+	dev->ae_low = target * 23 / 25;	 /* 0.92 */
+	dev->ae_high = target * 27 / 25; /* 1.08 */
+
+	
+	fast_high = dev->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = dev->ae_low >> 1;
+
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_IN_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_IN_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_OUT_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_OUT_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_FAST_H, fast_high);
+	if (err)
+		return err;
+
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_FAST_L, fast_low);
+}
+
+static int
+ov5640_1_set_ag_ae(struct i2c_client *client, int enable)
+{
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+			OV5640_1_REG_AE_MODE_CTRL,
+			enable ? OV5640_1_AUTO_AG_AE : OV5640_1_MANUAL_AG_AE);
+}
+
+static int ov5640_1_set_night_mode(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, &temp);
+	if (err)
+		return err;
+
+	if (enable) {
+		temp = temp | 0x04;
+		return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, temp);
+	} else {
+		temp = temp & 0xfb;
+		return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, temp);
+	}
+}
+
+static int ov5640_1_set_awb_gain_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AWB_CTRL, &temp);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case OV5640_1_AWB_GAIN_AUTO:
+		/* set awb gain to auto */
+		temp = temp & 0xfe;
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_AWB_CTRL, temp);
+		break;
+	case OV5640_1_AWB_GAIN_MANUAL:
+		/* set awb gain to manual */
+		temp = temp | 0x01;
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_AWB_CTRL, temp);
+		break;
+	default:
+		dev_err(&client->dev, "invalid awb gain mode.\n");
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_1_start_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int ret;
+
+	dev->preview_ag_ae = false;
+
+	ret = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_gain16(sd, dev->preview_gain16);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_shutter(sd, dev->preview_shutter);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_ag_ae(client, 1);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_bandingfilter(sd);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_ae_target(sd, OV5640_1_AE_TARGET);
+	if (ret)
+		return ret;
+
+	return ov5640_1_set_night_mode(sd, dev->night_mode);
+}
+
+static int ov5640_1_stop_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;
+
+	/* read preview shutter */
+	err = ov5640_1_get_shutter(sd, &dev->preview_shutter);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_gain16(sd, &dev->preview_gain16);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	dev->preview_ag_ae = true;
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_MANUAL);
+	if (err)
+		return err;
+
+	/* get average */
+	return ov5640_1_read_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_AE_AVERAGE, &dev->average);
+}
+
+
+
+#if 0
+static int ov5640_1_start_raw_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	ovprintk("write ov5640_1_800x480_yuv_2lane_192MCLK_30fps to ov5640_1\n");
+	return ov5640_1_write_reg_array(client, ov5640_1_800x480_yuv_2lane_192MCLK_30fps);
+	
+
+}
+#endif
+static int ov5640_1_start_video(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ag_ae(client, 1);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_bandingfilter(sd);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ae_target(sd, OV5640_1_AE_TARGET);
+	if (err)
+		return err;
+
+	return ov5640_1_set_night_mode(sd, 0);
+
+}
+
+static int ov5640_1_start_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	u32 capture_sysclk, capture_hts, capture_vts;
+	u32 capture_shutter, capture_gain16;
+	u32 light_frequency, capture_bandingfilter, capture_max_band;
+	long capture_gain16_shutter;
+	int err;
+
+
+	if (!dev->preview_ag_ae) {
+		dev_err(&client->dev, "preview gain and shutter are not available.\n");
+		return -EINVAL;
+	}
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ag_ae(client, 0);
+	if (err)
+		return err;
+
+	/* read capture VTS */
+	err = ov5640_1_get_vts(sd, &capture_vts);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_hts(sd, &capture_hts);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_sysclk(sd, &capture_sysclk);
+	if (err)
+		return err;
+
+	/* calculate capture banding filter */
+	err = ov5640_1_get_light_frequency(sd, &light_frequency);
+	if (err)
+		return err;
+
+	if (light_frequency == OV5640_1_LIGHT_60HZ) {
+		/* 60Hz */
+		capture_bandingfilter = capture_sysclk * 100 /
+						capture_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		capture_bandingfilter = capture_sysclk * 100 / capture_hts;
+	}
+
+	if (capture_bandingfilter == 0)
+		return -EINVAL;
+
+	capture_max_band = (int)((capture_vts - 4) / capture_bandingfilter);
+	if (capture_max_band == 0)
+		return -EINVAL;
+
+	/* calculate capture shutter/gain16 */
+	if (dev->average > dev->ae_low && dev->average < dev->ae_high) {
+		/* in stable range */
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts *
+					OV5640_1_AE_TARGET / dev->average;
+	} else {
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts;
+	}
+	/* gain to shutter */
+	if (capture_gain16_shutter < (capture_bandingfilter * 16)) {
+		/* shutter < 1/100 */
+		capture_shutter = capture_gain16_shutter / 16;
+		if (capture_shutter < 1)
+			capture_shutter = 1;
+		capture_gain16 = capture_gain16_shutter / capture_shutter;
+		if (capture_gain16 < 16)
+			capture_gain16 = 16;
+	} else {
+		if (capture_gain16_shutter >
+			(capture_bandingfilter * capture_max_band * 16)) {
+			/* exposure reach max */
+			capture_shutter = capture_bandingfilter *
+							capture_max_band;
+			capture_gain16 = capture_gain16_shutter /
+							capture_shutter;
+		} else {
+			/*
+			 * 1/100 < capture_shutter =< max,
+			 * capture_shutter = n/100
+			 */
+			capture_shutter = ((int)(capture_gain16_shutter / 16 /
+						capture_bandingfilter)) *
+						capture_bandingfilter;
+			if (capture_shutter == 0)
+				return -EINVAL;
+
+			capture_gain16 = capture_gain16_shutter /
+						capture_shutter;
+		}
+	}
+
+	/* write capture gain */
+	err = ov5640_1_set_gain16(sd, capture_gain16);
+	if (err)
+		return err;
+
+	/* write capture shutter */
+	if (capture_shutter > (capture_vts - 4)) {
+		capture_vts = capture_shutter + 4;
+		err = ov5640_1_set_vts(sd, capture_vts);
+		if (err)
+			return err;
+	}
+
+	return ov5640_1_set_shutter(sd, capture_shutter);
+
+}
+
+static int ov5640_1_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg_array(client, ov5640_1_standby_reg);
+}
+
+static int ov5640_1_wakeup(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg_array(client, ov5640_1_wakeup_reg);
+}
+
+
+static int ov5640_1_set_new_addr(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, err, val;
+	int addr_to_use = client->addr;
+
+	if(client->addr == OV5640_FACTORY_DEFAULT_ADDR) return 0;
+	if(ov5640_1_set_i2c_addr) return 0;
+	
+	client->addr =  OV5640_FACTORY_DEFAULT_ADDR;	
+	ret = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_SCCB_ID, &val);
+	ovprintk("ov5640_1_set_new_addr: default address is 0x%0x\n", val);
+
+	if (ret) return ret;
+	
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_SCCB_ID, (addr_to_use << 1));
+	if (err) return err;
+	
+	client->addr = addr_to_use;
+
+	ret = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_SCCB_ID, &val);
+	if (ret) return ret;
+	ovprintk("ov5640_1: the new address =0x%x client addr=0x%x\n",val, client->addr);
+	
+	ov5640_1_set_i2c_addr = 1;
+	
+	return 0;
+}
+
+
+static int __ov5640_1_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if(client->addr != OV5640_FACTORY_DEFAULT_ADDR)
+	{
+	  ret = ov5640_1_set_new_addr(sd);
+	  if (ret)
+			return ret;
+	  ovprintk("ov5640_1_init: the client addr=0x%x\n", client->addr);
+	}	
+
+	ret = ov5640_1_write_reg_array(client, ov5640_1_init);
+	if (ret)
+		return ret;
+
+	/*
+	 * delay 5ms to wait for sensor initialization finish.
+	 */
+	usleep_range(5000, 6000);
+
+	ret = ov5640_1_af_init(sd);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	
+	
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		{
+		goto fail_power;
+		}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/*
+	 * according to DS, 20ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int ov5640_1_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+	ovprintk("power on ov5640_1_s_power\n");
+		
+	if(power_up(sd))
+		return -EINVAL;
+	}
+
+	return __ov5640_1_init(sd);
+}
+
+static int ov5640_1_try_res(u32 *w, u32 *h, u32 *code)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_1_res[i].width == *w &&
+		    ov5640_1_res[i].height == *h &&
+		    ov5640_1_res[i].code == *code)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov5640_1_res[i].width;
+	*h = ov5640_1_res[i].height;
+	*code = ov5640_1_res[i].code;
+	
+
+	return 0;
+}
+
+static struct ov5640_1_res_struct *ov5640_1_to_res(u32 w, u32 h, u32 code)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_1_res[index].width == w &&
+		    ov5640_1_res[index].height == h &&
+		    ov5640_1_res[index].code == code)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &ov5640_1_res[index];
+}
+
+static int ov5640_1_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return ov5640_1_try_res(&fmt->width, &fmt->height, &fmt->code);
+}
+
+static int ov5640_1_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case OV5640_1_RES_QVGA:
+		hsize = OV5640_1_RES_QVGA_SIZE_H;
+		vsize = OV5640_1_RES_QVGA_SIZE_V;
+		break;
+	case OV5640_1_RES_DVGA:
+		hsize = OV5640_1_RES_DVGA_SIZE_H;
+		vsize = OV5640_1_RES_DVGA_SIZE_V;
+		break;
+	case OV5640_1_RES_320P:
+		hsize = OV5640_1_RES_320P_SIZE_H;
+		vsize = OV5640_1_RES_320P_SIZE_V;
+		break;
+	case OV5640_1_RES_360P:
+		hsize = OV5640_1_RES_360P_SIZE_H;
+		vsize = OV5640_1_RES_360P_SIZE_V;
+		break;
+	case OV5640_1_RES_VGA:
+		hsize = OV5640_1_RES_VGA_SIZE_H;
+		vsize = OV5640_1_RES_VGA_SIZE_V;
+		break;
+	case OV5640_1_RES_RGB_VGA:
+			hsize = OV5640_1_RES_VGA_SIZE_H;
+			vsize = OV5640_1_RES_VGA_SIZE_V;
+			break;
+	case OV5640_1_RES_480P:
+		hsize = OV5640_1_RES_480P_SIZE_H;
+		vsize = OV5640_1_RES_480P_SIZE_V;
+		break;
+	case OV5640_1_RES_736x480P:
+		hsize = OV5640_1_RES_736x480P_SIZE_H;
+		vsize = OV5640_1_RES_736x480P_SIZE_V;
+		break;
+	case OV5640_1_RES_800x480P:
+		hsize = OV5640_1_RES_800x480P_SIZE_H;
+		vsize = OV5640_1_RES_800x480P_SIZE_V;
+		break;
+	case OV5640_1_RES_720P:
+	case OV5640_1_RGB565_RES_720P:  
+		hsize = OV5640_1_RES_720P_SIZE_H;
+		vsize = OV5640_1_RES_720P_SIZE_V;
+		break;
+	case OV5640_1_RES_1440X720P:
+		hsize = OV5640_1_RES_1440X720P_SIZE_H;
+		vsize = OV5640_1_RES_1440X720P_SIZE_V;
+		break;
+	case OV5640_1_RES_1080P:
+		hsize = OV5640_1_RES_1080P_SIZE_H;
+		vsize = OV5640_1_RES_1080P_SIZE_V;
+		break;
+	case OV5640_1_RES_1080P_RGB:
+			hsize = OV5640_1_RES_1080P_SIZE_H;
+			vsize = OV5640_1_RES_1080P_SIZE_V;
+			break;
+	case OV5640_1_RES_1088P:
+		hsize = OV5640_1_RES_1088P_SIZE_H;
+		vsize = OV5640_1_RES_1088P_SIZE_V;
+		break;
+	case OV5640_1_RES_D3M:
+		hsize = OV5640_1_RES_D3M_SIZE_H;
+		vsize = OV5640_1_RES_D3M_SIZE_V;
+		break;
+	case OV5640_1_RES_3M:
+		hsize = OV5640_1_RES_3M_SIZE_H;
+		vsize = OV5640_1_RES_3M_SIZE_V;
+		break;
+	case OV5640_1_RES_D5M:
+		hsize = OV5640_1_RES_D5M_SIZE_H;
+		vsize = OV5640_1_RES_D5M_SIZE_V;
+		break;
+	case OV5640_1_RES_5M:
+		hsize = OV5640_1_RES_5M_SIZE_H;
+		vsize = OV5640_1_RES_5M_SIZE_V;
+		break;
+		
+	default:
+		/* QVGA mode is still unsupported */
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int ov5640_1_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = ov5640_1_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+	
+	
+
+	return 0;
+}
+
+static int ov5640_1_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct ov5640_1_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 code = fmt->code;
+	int ret;
+
+	ovprintk("ov5640_1_s_mbus_fmt w=%d h=%d code=0x%x\n", fmt->width, fmt->height, fmt->code);
+	
+	ov5640_1_try_res(&width, &height, &code);
+	
+	res_index = ov5640_1_to_res(width, height, code);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	ovprintk("ov5640_1_s_mbus_fmt res_index->res=%d\n", res_index->res);
+
+	switch (res_index->res) {
+	case OV5640_1_RES_QVGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_qvga_init);
+		break;
+	case OV5640_1_RES_DVGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_dvga_init);
+		break;
+	case OV5640_1_RES_320P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_320p_init);
+		break;
+	case OV5640_1_RES_360P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_360p_init);
+		break;
+	case OV5640_1_RES_VGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_vga_init);
+		break;
+	case OV5640_1_RES_RGB_VGA:
+			ret = ov5640_1_write_reg_array(c, ov5640_1_vga_rgb_init);
+			break;
+	case OV5640_1_RES_480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_480p_init);
+		break;
+	case OV5640_1_RES_736x480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_736x480p_init);
+		break;
+	case OV5640_1_RES_800x480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_800x480p_init);
+		break;
+		
+	case OV5640_1_RES_720P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_720p_init);
+		break;
+	case OV5640_1_RGB565_RES_720P:  
+		ret = ov5640_1_write_reg_array(c, ov5640_1_rgb565_1280x720p_init);
+		break;
+	case OV5640_1_RES_1440X720P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1440x720p_init);
+		break;
+
+	case OV5640_1_RES_1080P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1080p_init);
+		break;
+	case OV5640_1_RES_1080P_RGB:
+			ret = ov5640_1_write_reg_array(c, ov5640_1_1080p_rgb);
+			break;
+	case OV5640_1_RES_1088P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1088p_init);
+		break;
+	case OV5640_1_RES_D3M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_D3M_init);
+		break;
+	case OV5640_1_RES_3M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_3M_init);
+		break;
+	case OV5640_1_RES_D5M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_D5M_init);
+		break;
+	case OV5640_1_RES_5M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_5M_init);
+		break;
+	default:
+		/* QVGA is not implemented yet */
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+							res_index->res);
+		return -EINVAL;
+	}
+	if (ret)
+		return -EINVAL;
+
+	
+	if (dev->res != res_index->res) {
+		int index;
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if (width == ov5640_1_res[index].width &&
+			    height == ov5640_1_res[index].height &&
+			    code == ov5640_1_res[index].code) {
+				ov5640_1_res[index].used = 1;
+				continue;
+			}
+			ov5640_1_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * ov5640_1 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = code;
+
+	ovprintk("ov5640_1_s_mbus_fmt width = %d height = %d code =0x%x dev->res=%d\n", 
+	       width, height, code, dev->res);
+	/* relaunch default focus zone */
+
+	ret = ov5640_1_write_reg(c, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_MODE,
+					OV5640_1_RELAUNCH_FOCUS);
+	if (ret) return -EINVAL;
+
+	return ov5640_1_wakeup(sd);
+	
+  
+}
+
+static int ov5640_1_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	if (ov5640_1_read_reg(client, MISENSOR_16BIT,
+		OV5640_1_REG_PID, &retvalue)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", retvalue);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "sensor_id = 0x%x\n", retvalue);
+	if (retvalue != OV5640_1_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	*id = retvalue;
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov5640_1_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+	ret = ov5640_1_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power_ctrl failed");
+		return ret;
+	}
+
+
+	/* config & detect sensor */
+	ret = ov5640_1_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov5640_1_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = ov5640_1_s_power(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	ov5640_1_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+
+static int ov5640_1_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_1_FOCAL_LENGTH_NUM << 16) | OV5640_1_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5640_1_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for OV5640_1 */
+	*val = (OV5640_1_F_NUMBER_DEFAULT_NUM << 16) | OV5640_1_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5640_1_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_1_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5640_1_F_NUMBER_DEM << 16) |
+		(OV5640_1_F_NUMBER_DEFAULT_NUM << 8) | OV5640_1_F_NUMBER_DEM;
+	return 0;
+}
+
+static struct ov5640_1_control ov5640_1_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_START,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "single focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_single_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_AUTO,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "continuous focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_cont_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "pause focus",
+			.minimum = 0,
+			.maximum = 1 << 2,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_pause_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STOP,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "release focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_release_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 0x07,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_1_g_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_color_effect,
+		.query = ov5640_1_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = OV5640_1_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_1_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = OV5640_1_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_1_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  OV5640_1_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5640_1_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5640_1_controls))
+
+static struct ov5640_1_control *ov5640_1_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov5640_1_controls[i].qc.id == id)
+			return &ov5640_1_controls[i];
+	}
+	return NULL;
+}
+
+static int ov5640_1_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5640_1_control *ctrl = ov5640_1_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int ov5640_1_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_1_control *octrl = ov5640_1_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_1_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_1_control *octrl = ov5640_1_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_1_mipi_stream(struct i2c_client *client, int enable)
+{
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+			OV5640_1_REG_FRAME_CTRL,
+			enable ? OV5640_1_FRAME_START : OV5640_1_FRAME_STOP);
+}
+
+static int ov5640_1_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;
+
+	if (enable) {
+		switch (dev->run_mode) {
+		case CI_MODE_PREVIEW:
+			err = ov5640_1_start_preview(sd);
+			break;
+		case CI_MODE_VIDEO:
+			err = ov5640_1_start_video(sd);
+			break;
+		case CI_MODE_STILL_CAPTURE:
+			err = ov5640_1_start_video(sd);
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid run mode = 0x%x\n", dev->run_mode);
+			return -EINVAL;
+		}
+		if (err)
+			dev_warn(&client->dev,
+				"fail to start preview/video/capture.\n");
+
+		err = ov5640_1_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		dev->streaming = true;
+		
+		if (dev->focus_mode_change) {
+			err = ov5640_1_s_focus_mode(sd, dev->focus_mode);
+			if (err) {
+				dev_err(&client->dev,
+					"writing focus mode reg fails.\n");
+				return err;
+			}
+			dev->focus_mode_change = false;
+		}
+		
+	} else {
+
+	  
+		if (dev->run_mode == CI_MODE_PREVIEW) {
+			err = ov5640_1_stop_preview(sd);
+			if (err)
+				dev_warn(&client->dev,
+					"fail to stop preview\n");
+		}
+		err = ov5640_1_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		err = ov5640_1_standby(sd);
+		if (err)
+			return err;		
+		dev->streaming = false;
+		dev->focus_mode = V4L2_CID_3A_LOCK;
+	}
+
+	
+	return 0;
+}
+
+static int
+ov5640_1_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5640_1_res[index].width;
+	fsize->discrete.height = ov5640_1_res[index].height;
+
+	fsize->reserved[0] = ov5640_1_res[index].used;
+
+	return 0;
+}
+
+static int ov5640_1_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_1_res[i].width >= fival->width &&
+		    ov5640_1_res[i].height >= fival->height)
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5640_1_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov5640_1_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640_1, 0);
+}
+
+static int ov5640_1_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5640_1_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5640_1_res[index].width;
+	fse->min_height = ov5640_1_res[index].height;
+	fse->max_width = ov5640_1_res[index].width;
+	fse->max_height = ov5640_1_res[index].height;
+
+	return 0;
+}
+
+static int
+ov5640_1_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_1_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov5640_1_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int focus_width_step, focus_height_step;
+	u32 x_center, y_center;
+	int width = 0, height = 0;
+	int err, index;
+
+	
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_err(&client->dev,
+				"invalid selection format.\n");
+		return -EINVAL;
+	}
+
+	if (sel->target != V4L2_SEL_TGT_COMPOSE) {
+		dev_err(&client->dev,
+				"invalid selection compose.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < N_RES; index++) {
+		if (dev->res == ov5640_1_res[index].res) {
+			width = ov5640_1_res[index].width;
+			height = ov5640_1_res[index].height;
+			break;
+		}
+	}
+
+	focus_width_step = width / OV5640_1_FOCUS_ZONE_ARRAY_WIDTH;
+	focus_height_step = height / OV5640_1_FOCUS_ZONE_ARRAY_HEIGHT;
+
+	/* calculate the center coordinate of selection rectangle */
+	x_center = DIV_ROUND_UP((sel->r.left + sel->r.width / 2),
+						focus_width_step);
+	y_center = DIV_ROUND_UP((sel->r.top + sel->r.height / 2),
+						focus_height_step);
+	
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_ZONE_X,
+					x_center);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_ZONE_Y,
+					y_center);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_S_FOCUS_ZONE);
+	if (err)
+		return err;
+
+	return ov5640_1_s_focus_mode(sd, dev->focus_mode);
+}
+
+
+
+static int
+ov5640_1_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->res >= 0 && dev->res < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5640_1_res[dev->res].fps;
+	}
+	return 0;
+}
+
+static int
+ov5640_1_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+	dev->run_mode = param->parm.capture.capturemode;
+	ovprintk("ov5640_1_s_parm dev->run_mode=0x%x\n", dev->run_mode);
+	
+	return ov5640_1_g_parm(sd, param);
+}
+
+static int
+ov5640_1_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_1_res[index].res == snr->res) {
+			*frames = ov5640_1_res[index].skip_frames;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_1_video_ops = {
+	.try_mbus_fmt = ov5640_1_try_mbus_fmt,
+	.g_mbus_fmt = ov5640_1_g_mbus_fmt,
+	.s_mbus_fmt = ov5640_1_s_mbus_fmt,
+	.s_parm = ov5640_1_s_parm,
+	.g_parm = ov5640_1_g_parm,
+	.s_stream = ov5640_1_s_stream,
+	.enum_framesizes = ov5640_1_enum_framesizes,
+	.enum_frameintervals = ov5640_1_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_1_sensor_ops = {
+	.g_skip_frames	= ov5640_1_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_1_core_ops = {
+	.g_chip_ident = ov5640_1_g_chip_ident,
+	.queryctrl = ov5640_1_queryctrl,
+	.g_ctrl = ov5640_1_g_ctrl,
+	.s_ctrl = ov5640_1_s_ctrl,
+	.s_power = ov5640_1_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_1_pad_ops = {
+	.enum_mbus_code = ov5640_1_enum_mbus_code,
+	.enum_frame_size = ov5640_1_enum_frame_size,
+	.get_fmt = ov5640_1_get_pad_format,
+	.set_fmt = ov5640_1_set_pad_format,
+	.set_selection = ov5640_1_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov5640_1_ops = {
+	.core = &ov5640_1_core_ops,
+	.video = &ov5640_1_video_ops,
+	.sensor = &ov5640_1_sensor_ops,
+	.pad = &ov5640_1_pad_ops,
+};
+
+static const struct media_entity_operations ov5640_1_entity_ops;
+
+static int ov5640_1_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_1_device *dev = container_of(sd,
+					struct ov5640_1_device, sd);
+		
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	power_down(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5640_1_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov5640_1_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &ov5640_1_ops);
+	if (client->dev.platform_data) {
+		ovprintk("ov5640_1_probe has platform data\n");
+		ret = ov5640_1_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+	else {
+		ovprintk("ov5640_1_probe NOOON platform data\n");
+	}
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &ov5640_1_entity_ops;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov5640_1_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	/* set focus mode to be invalid */
+	dev->focus_mode = -1;
+
+	/* set color_effect to be invalid */
+	dev->color_effect = -1;
+	dev->preview_gain16 = OV5640_1_DEFAULT_GAIN;
+	dev->preview_shutter = OV5640_1_DEFAULT_SHUTTER;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5640_1_id);
+static struct i2c_driver ov5640_1_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5640_1_NAME,
+	},
+	.probe = ov5640_1_probe,
+	.remove = __exit_p(ov5640_1_remove),
+	.id_table = ov5640_1_id,
+};
+
+static __init int ov5640_1_init_mod(void)
+{
+	return i2c_add_driver(&ov5640_1_driver);
+}
+
+static __exit void ov5640_1_exit_mod(void)
+{
+	i2c_del_driver(&ov5640_1_driver);
+}
+
+module_init(ov5640_1_init_mod);
+module_exit(ov5640_1_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV5640_1 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/ov5640_1.h b/drivers/media/video/ov5640_1.h
new file mode 100644
index 0000000..a7fd1ac
--- /dev/null
+++ b/drivers/media/video/ov5640_1.h
@@ -0,0 +1,3492 @@
+/*
+ * Support for ov5640_1 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5640_1_H__
+#define __OV5640_1_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV5640_1_NAME	"ov5640-1"
+
+#define V4L2_IDENT_OV5640_1 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+#define OV5640_1_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV5640_1_FOCAL_LENGTH_DEM	100
+#define OV5640_1_F_NUMBER_DEFAULT_NUM	24
+#define OV5640_1_F_NUMBER_DEM	10
+#define OV5640_1_FOCUS_ZONE_ARRAY_WIDTH	80
+#define OV5640_1_FOCUS_ZONE_ARRAY_HEIGHT	60
+
+#define OV5640_1_XVCLK		1920
+#define OV5640_1_AE_TARGET	45
+#define OV5640_1_DEFAULT_GAIN	50
+#define OV5640_1_DEFAULT_SHUTTER	1000
+
+#define OV5640_FACTORY_DEFAULT_ADDR 0x3c
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_1_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_1_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5640_1_F_NUMBER_RANGE 0x180a180a
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#define OV5640_1_REG_SCCB_ID	0x3100
+
+#define OV5640_1_REG_PID		0x300a
+#define OV5640_1_REG_SYS_RESET	0x3000
+#define OV5640_1_REG_FW_START	0x8000
+#define OV5640_1_REG_FOCUS_MODE	0x3022	/* focus mode reg */
+#define OV5640_1_REG_FOCUS_ZONE_X	0x3024	/* X coordinate of focus zone center */
+#define OV5640_1_REG_FOCUS_ZONE_Y	0x3025	/* Y coordinate of focus zone center */
+#define OV5640_1_REG_FOCUS_STATUS	0x3029	/* focus status reg */
+
+/* system pll control reg */
+#define OV5640_1_REG_PLL_CTRL_0	0x3034
+#define OV5640_1_REG_PLL_CTRL_1	0x3035
+#define OV5640_1_REG_PLL_CTRL_2	0x3036
+#define OV5640_1_REG_PLL_CTRL_3	0x3037
+
+/* pad clock divider for SCCB clock */
+#define OV5640_1_REG_CLK_DIVIDER	0x3108
+
+/* total horizontal size reg */
+#define OV5640_1_REG_TIMING_HTS	0x380c
+
+/* total vertical size reg */
+#define OV5640_1_REG_TIMING_VTS	0x380e
+
+/* exposure output reg */
+#define OV5640_1_REG_EXPOSURE_0	0x3500
+#define OV5640_1_REG_EXPOSURE_1	0x3502
+
+/* gain reg */
+#define OV5640_1_REG_GAIN	0x350a
+
+/* light frequency control reg */
+#define OV5640_1_REG_LIGHT_CTRL_0	0x3c01
+#define OV5640_1_REG_LIGHT_CTRL_1	0x3c00
+#define OV5640_1_REG_LIGHT_CTRL_2	0x3c0c
+
+/* light frequency */
+#define OV5640_1_LIGHT_50HZ	50
+#define OV5640_1_LIGHT_60HZ	60
+
+/* automatic banding filter */
+#define OV5640_1_AUTO_BAND	0x80
+
+/* 60HZ band step reg and 60HZ max bands */
+#define OV5640_1_REG_B60_STEP	0x3a0a
+#define OV5640_1_REG_B60_MAX	0x3a0d
+
+/* 50HZ band step reg and 50HZ max bands */
+#define OV5640_1_REG_B50_STEP	0x3a08
+#define OV5640_1_REG_B50_MAX	0x3a0e
+
+/* AEC domain control reg */
+#define OV5640_1_REG_AE_STAB_IN_H	0x3a0f	/* stable in high */
+#define OV5640_1_REG_AE_STAB_IN_L	0x3a10	/* stable in low */
+#define OV5640_1_REG_AE_STAB_OUT_H	0x3a1b	/* stable out high */
+#define OV5640_1_REG_AE_STAB_OUT_L	0x3a1e	/* stable out low */
+#define OV5640_1_REG_AE_FAST_H	0x3a11	/* fast zone high */
+#define OV5640_1_REG_AE_FAST_L	0x3a1f	/* fast zone low */
+
+/* AEC mode control reg */
+#define OV5640_1_REG_AE_MODE_CTRL	0x3503
+
+#define OV5640_1_AUTO_AG_AE	0x00	/* auto AG&AE */
+#define OV5640_1_MANUAL_AG_AE	0x03	/* manual AG&AE */
+
+/* AEC system control reg */
+#define OV5640_1_REG_AE_SYS_CTRL	0x3a00
+
+/* image exposure average readout reg */
+#define OV5640_1_REG_AE_AVERAGE	0x56a1
+
+/* frame control reg */
+#define OV5640_1_REG_FRAME_CTRL	0x4202
+
+#define OV5640_1_FRAME_START	0x00
+#define OV5640_1_FRAME_STOP	0x0f
+
+#define OV5640_1_MCU_RESET	0x20
+#define OV5640_1_SINGLE_FOCUS	0x03
+#define OV5640_1_CONTINUE_FOCUS	0x04
+#define OV5640_1_PAUSE_FOCUS	0x06
+#define OV5640_1_RELEASE_FOCUS	0x08
+#define OV5640_1_RELAUNCH_FOCUS	0x12
+#define OV5640_1_S_FOCUS_ZONE	0x81
+
+/* focus firmware is downloaded but not to be initialized */
+#define OV5640_1_FOCUS_FW_DL	0x7f
+#define OV5640_1_FOCUS_FW_INIT	0x7e	/* focus firmware is initializing */
+#define OV5640_1_FOCUS_FW_IDLE	0x70	/* focus firmware is idle */
+#define OV5640_1_FOCUS_FW_RUN	0x00	/* focus firmware is running */
+#define OV5640_1_FOCUS_FW_FINISH	0x10	/* focus is finished */
+
+#define OV5640_1_REG_AWB_CTRL	0x3406
+
+#define OV5640_1_AWB_GAIN_AUTO	0
+#define OV5640_1_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV5640_1_DEVICE_ID */
+#define OV5640_1_MOD_ID		0x5640
+
+#define AF_FW_PATH	"OV5640_AF_FW.bin"
+
+/* Supported resolutions */
+enum {
+	OV5640_1_RES_QVGA,
+	OV5640_1_RES_DVGA,
+	OV5640_1_RES_320P,
+	OV5640_1_RES_360P,
+	OV5640_1_RES_VGA,
+	OV5640_1_RES_RGB_VGA,
+	OV5640_1_RES_480P,
+	OV5640_1_RES_736x480P,	
+	OV5640_1_RES_800x480P,
+	OV5640_1_RES_720P,
+	OV5640_1_RGB565_RES_720P,
+	OV5640_1_RES_1440X720P,
+	OV5640_1_RES_1080P,
+	OV5640_1_RES_1080P_RGB,
+	OV5640_1_RES_1088P,
+	OV5640_1_RES_D3M,
+	OV5640_1_RES_3M,
+	OV5640_1_RES_D5M,
+	OV5640_1_RES_5M,
+};
+#define OV5640_1_RES_5M_SIZE_H		2560
+#define OV5640_1_RES_5M_SIZE_V		1920
+#define OV5640_1_RES_D5M_SIZE_H		2496
+#define OV5640_1_RES_D5M_SIZE_V		1664
+#define OV5640_1_RES_D3M_SIZE_H		2112
+#define OV5640_1_RES_D3M_SIZE_V		1408
+#define OV5640_1_RES_3M_SIZE_H		2048
+#define OV5640_1_RES_3M_SIZE_V		1536
+#define OV5640_1_RES_1088P_SIZE_H		1920
+#define OV5640_1_RES_1088P_SIZE_V		1088
+#define OV5640_1_RES_1080P_SIZE_H		1920
+#define OV5640_1_RES_1080P_SIZE_V		1080
+#define OV5640_1_RES_720P_SIZE_H		1280
+#define OV5640_1_RES_720P_SIZE_V		720
+
+#define OV5640_1_RGB565_RES_720P_SIZE_H		1280
+#define OV5640_1_RGB565_RES_720P_SIZE_V		720
+
+#define OV5640_1_RES_1440X720P_SIZE_H		1440
+#define OV5640_1_RES_1440X720P_SIZE_V		720
+
+#define OV5640_1_RES_480P_SIZE_H		720
+#define OV5640_1_RES_480P_SIZE_V		480
+
+#define OV5640_1_RES_736x480P_SIZE_H		736
+#define OV5640_1_RES_736x480P_SIZE_V		480
+
+
+#define OV5640_1_RES_VGA_SIZE_H		640
+#define OV5640_1_RES_VGA_SIZE_V		480
+#define OV5640_1_RES_360P_SIZE_H		640
+#define OV5640_1_RES_360P_SIZE_V		360
+#define OV5640_1_RES_320P_SIZE_H		480
+#define OV5640_1_RES_320P_SIZE_V		320
+#define OV5640_1_RES_DVGA_SIZE_H		416
+#define OV5640_1_RES_DVGA_SIZE_V		312
+#define OV5640_1_RES_QVGA_SIZE_H		320
+#define OV5640_1_RES_QVGA_SIZE_V		240
+
+#define OV5640_1_RES_800x480P_SIZE_H		800
+#define OV5640_1_RES_800x480P_SIZE_V		480
+
+
+/* TODO: Definition not available in kernel 3.5 */
+/* Current composing area */
+#define V4L2_SEL_TGT_COMPOSE            0x0100
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5640_1_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int res;
+};
+
+struct ov5640_1_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov5640_1_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov5640_1_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int code;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV5640_1_MAX_WRITE_BUF_SIZE	32
+struct ov5640_1_write_buffer {
+	u16 addr;
+	u8 data[OV5640_1_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5640_1_write_ctrl {
+	int index;
+	struct ov5640_1_write_buffer buffer;
+};
+
+struct ov5640_1_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define N_ov5640_1_FMTS ARRAY_SIZE(ov5640_1_formats)
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct ov5640_1_res_struct ov5640_1_res[] = {
+	{
+	.desc	= "QVGA",
+	.res	= OV5640_1_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "DVGA",
+	.res	= OV5640_1_RES_DVGA,
+	.width	= 416,
+	.height	= 312,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "320P",
+	.res	= OV5640_1_RES_320P,
+	.width	= 480,
+	.height	= 320,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "360P",
+	.res	= OV5640_1_RES_360P,
+	.width	= 640,
+	.height	= 360,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 5,
+	},
+	{
+	.desc	= "VGA",
+	.res	= OV5640_1_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "VGA_RGB",
+		.res	= OV5640_1_RES_RGB_VGA,
+		.width	= 640,
+		.height	= 480,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "480P",
+	.res	= OV5640_1_RES_480P,
+	.width	= 720,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "736x480P",
+	.res	= OV5640_1_RES_736x480P,
+	.width	= 736,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "800x480p",
+	.res	= OV5640_1_RES_800x480P,
+	.width	= 800,
+	.height = 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "720p",
+	.res	= OV5640_1_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	
+	{
+	.desc	= "RGB565_720p",
+	.res	= OV5640_1_RGB565_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x1008,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	
+	{
+	.desc	= "1440x720p",
+	.res	= OV5640_1_RES_1440X720P,
+	.width	= 1440,
+	.height	= 720,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1080P",
+	.res	= OV5640_1_RES_1080P,
+	.width	= 1920,
+	.height	= 1080,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "1080P",
+		.res	= OV5640_1_RES_1080P_RGB,
+		.width	= 1920,
+		.height	= 1080,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "1088P",
+	.res	= OV5640_1_RES_1088P,
+	.width	= 1920,
+	.height	= 1088,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D3M",
+	.res	= OV5640_1_RES_D3M,
+	.width	= 2112,
+	.height	= 1408,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "3M",
+	.res	= OV5640_1_RES_3M,
+	.width	= 2048,
+	.height	= 1536,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D5M",
+	.res	= OV5640_1_RES_D5M,
+	.width	= 2496,
+	.height	= 1664,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "5M",
+	.res	= OV5640_1_RES_5M,
+	.width	= 2560,
+	.height	= 1920,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+};
+#define N_RES (ARRAY_SIZE(ov5640_1_res))
+
+static const struct i2c_device_id ov5640_1_id[] = {
+	{"ov5640-1", 0},
+	{}
+};
+
+static struct misensor_reg const ov5640_1_standby_reg[] = {
+	 {MISENSOR_8BIT,  0x300e, 0x5d},
+	 {MISENSOR_8BIT,  0x3008, 0x42},	/* software powerdown */
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_wakeup_reg[] = {
+	{MISENSOR_8BIT,  0x3008, 0x02},
+	{MISENSOR_8BIT,  0x300e, 0x45},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_normal_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x06},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_sepia_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0xA0},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_negative_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x46},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_bw_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x80},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x80},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_blue_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0xA0},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x40},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_green_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x60},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x60},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 5M, yuv422, 2lanes, mipi, 12fps */
+static struct misensor_reg const ov5640_1_5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x0A},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2560 */
+	{MISENSOR_8BIT, 0x380A, 0x07},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1920 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x06},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x08},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xB4},	/* total H-size is 2740 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xE8},	/* total v-size is 2024 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xE4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xE4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x2F},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFD},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D5M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_D5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x09},
+	{MISENSOR_8BIT, 0x3809, 0xC0},	/* DVP output H_width, value is 2496 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1664 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2048 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x00},	/* DVP output V_heigh, value is 1536 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xA0},	/* total H-size is 2720 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xF6},	/* total v-size is 2038 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xF2},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xF2},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x31},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFE},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_D3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x40},	/* DVP output H_width, value is 2112 */
+	{MISENSOR_8BIT, 0x380A, 0x05},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1408 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xB0},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xB0},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1088p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1088p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06}, /* disable binning */
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of isp input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF9},	/* Y end of isp input size */
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* 1920 */
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x40},	/* 1088 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0x60},
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0x60},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1080p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, rgb565, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1080p_rgb[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+	{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 720p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_720p_init[] = {
+#ifdef ORIGINAL_SETTINGS  
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x05},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x02},
+	{MISENSOR_8BIT, 0x380B, 0xD0},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x97},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x53},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling*/
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},	/* same with 1080p */
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x18},	/* total H-size is 2328 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xA8},	/* total v-size is 1192 */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x66},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2A},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xA4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xA4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else  /* FROM JOSH @OV.COM */
+	/* YUV 1280x720, mclk 19.2mhz 60 fps */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+#endif
+  
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_480p_init[] = {
+#ifdef ORIGINAL_SETTINGS  
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x04},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x3F},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0xD9},
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x0B},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else
+#if 0
+	/* from josh @ov.com */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x22},/*0x21*/
+	{MISENSOR_8BIT,0x3036,0x8c},/*mclk=19.2MHz,0x70*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0x3a},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x07},
+	{MISENSOR_8BIT,0x3807,0x67},
+	{MISENSOR_8BIT,0x3808,0x02},
+	{MISENSOR_8BIT,0x3809,0xd0},
+	{MISENSOR_8BIT,0x380a,0x01},
+	{MISENSOR_8BIT,0x380b,0xe0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x68},
+	{MISENSOR_8BIT,0x380e,0x03},
+	{MISENSOR_8BIT,0x380f,0xd8},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x06},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x03},
+	{MISENSOR_8BIT,0x3a03,0xd8},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x27},
+	{MISENSOR_8BIT,0x3a0a,0x00},
+	{MISENSOR_8BIT,0x3a0b,0xf6},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x03},
+	{MISENSOR_8BIT,0x3a15,0xd8},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x22, *0x10*/},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0xa3},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+#endif
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+
+#endif
+
+};
+
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_736x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+
+/* camera: 320p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_320p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xE0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x40},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x0B},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera: 360p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_360p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x68},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x02},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x4837, 0x2C},	/* PCLK PERIOD */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x05},	/* total H-size is 2309 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total v-size is 1200*/
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x68},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera vga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_vga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera vga 30fps, rgb(640x480),----- 2lanes */
+static struct misensor_reg const ov5640_1_vga_rgb_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+		{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+
+
+/* camera qvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_qvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0x40},
+	{MISENSOR_8BIT, 0x380A, 0x00},
+	{MISENSOR_8BIT, 0x380B, 0xF0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera dvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_dvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xA0},	/* DVP output, value is 416 */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x38},	/* DVP output, value is 312 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x31},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_init[] = {
+	/* init software */
+	{MISENSOR_8BIT, 0x3103, 0x11},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x82},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x42},	/* software power down */
+	{MISENSOR_8BIT, 0x3103, 0x03},	/* SCCB system control */
+	/* set Frex Vsync href PCLK D[9:6} input */
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},	/* set d[5:0] GPIO[1:0] input */
+	{MISENSOR_8BIT, 0x3034, 0x18},	/* MIPI 8-bit mode*/
+	{MISENSOR_8BIT, 0x3037, 0x13},	/* PLL */
+	{MISENSOR_8BIT, 0x3108, 0x01},	/* system divider */
+	{MISENSOR_8BIT, 0x3630, 0x36},
+	{MISENSOR_8BIT, 0x3631, 0x0E},
+	{MISENSOR_8BIT, 0x3632, 0xE2},
+	{MISENSOR_8BIT, 0x3633, 0x12},
+	{MISENSOR_8BIT, 0x3621, 0xE0},
+	{MISENSOR_8BIT, 0x3704, 0xA0},
+	{MISENSOR_8BIT, 0x3703, 0x5A},
+	{MISENSOR_8BIT, 0x3715, 0x78},
+	{MISENSOR_8BIT, 0x3717, 0x01},
+	{MISENSOR_8BIT, 0x370B, 0x60},
+	{MISENSOR_8BIT, 0x3705, 0x1A},
+	{MISENSOR_8BIT, 0x3905, 0x02},
+	{MISENSOR_8BIT, 0x3906, 0x10},
+	{MISENSOR_8BIT, 0x3901, 0x0A},
+	{MISENSOR_8BIT, 0x3731, 0x12},
+	{MISENSOR_8BIT, 0x3600, 0x08},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x3601, 0x33},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x302D, 0x60},	/* system control */
+	{MISENSOR_8BIT, 0x3620, 0x52},
+	{MISENSOR_8BIT, 0x371B, 0x20},
+	{MISENSOR_8BIT, 0x471C, 0x50},
+	{MISENSOR_8BIT, 0x3A13, 0x43},	/* AGC pre-gain 40 = 1x */
+	{MISENSOR_8BIT, 0x3A18, 0x00},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3A19, 0xF8},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3635, 0x13},
+	{MISENSOR_8BIT, 0x3636, 0x03},
+	{MISENSOR_8BIT, 0x3634, 0x40},
+	{MISENSOR_8BIT, 0x3622, 0x01},
+	{MISENSOR_8BIT, 0x3C00, 0x04},	/* 50Hz/60Hz */
+	{MISENSOR_8BIT, 0x3C01, 0xB4},	/* 50/60Hz */
+	{MISENSOR_8BIT, 0x3C04, 0x28},	/* threshold for low sum */
+	{MISENSOR_8BIT, 0x3C05, 0x98},	/* threshold for high sum */
+	{MISENSOR_8BIT, 0x3C06, 0x00},	/* light meter 1 threshold high */
+	{MISENSOR_8BIT, 0x3C08, 0x00},	/* light meter 2 threshold high */
+	{MISENSOR_8BIT, 0x3C09, 0x1C},	/* light meter 2 threshold low */
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},	/* sample number high */
+	{MISENSOR_8BIT, 0x3C0B, 0x40},	/* sample number low */
+	/* timing */
+	{MISENSOR_8BIT, 0x3800, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3802, 0x00},	/* VS */
+	{MISENSOR_8BIT, 0x3804, 0x0A},	/* HW */
+	{MISENSOR_8BIT, 0x3805, 0x3F},	/* HW */
+	{MISENSOR_8BIT, 0x3810, 0x00},	/* H offset high */
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* H offset low */
+	{MISENSOR_8BIT, 0x3812, 0x00},	/* V offset high */
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3A08, 0x01},	/* B50 */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset 0 */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},	/* system reset 2 */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* clock enable 00 */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* clock enable 2 */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI control 2 lane MIPI on */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},	/* YUV 422 UYVY */
+	{MISENSOR_8BIT, 0x501F, 0x00},	/* ISP YUV 422 */
+	{MISENSOR_8BIT, 0x4407, 0x04},	/* JPEG QS */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	/* ISP control LENC on GAMMA on BPC on WPC on CIP on */
+	{MISENSOR_8BIT, 0x5000, 0xA7},
+	/* AWB */
+	{MISENSOR_8BIT, 0x5180, 0xFF},
+	{MISENSOR_8BIT, 0x5181, 0xF2},
+	{MISENSOR_8BIT, 0x5182, 0x00},
+	{MISENSOR_8BIT, 0x5183, 0x14},
+	{MISENSOR_8BIT, 0x5184, 0x25},
+	{MISENSOR_8BIT, 0x5185, 0x24},
+	{MISENSOR_8BIT, 0x5189, 0x8D},
+	{MISENSOR_8BIT, 0x518A, 0x61},
+	{MISENSOR_8BIT, 0x518C, 0x94},
+	{MISENSOR_8BIT, 0x518B, 0xAF},
+	{MISENSOR_8BIT, 0x5187, 0x17},
+	{MISENSOR_8BIT, 0x5188, 0x0F},
+	{MISENSOR_8BIT, 0x518D, 0x41},
+	{MISENSOR_8BIT, 0x518F, 0x75},
+	{MISENSOR_8BIT, 0x518E, 0x34},
+	{MISENSOR_8BIT, 0x5190, 0x43},
+	{MISENSOR_8BIT, 0x5191, 0xF5},
+	{MISENSOR_8BIT, 0x5192, 0x0A},
+	{MISENSOR_8BIT, 0x5186, 0x16},
+	{MISENSOR_8BIT, 0x5193, 0x70},
+	{MISENSOR_8BIT, 0x5194, 0xF0},
+	{MISENSOR_8BIT, 0x5195, 0xF0},
+	{MISENSOR_8BIT, 0x5196, 0x03},
+	{MISENSOR_8BIT, 0x5197, 0x01},
+	{MISENSOR_8BIT, 0x5198, 0x05},
+	{MISENSOR_8BIT, 0x5199, 0xDB},
+	{MISENSOR_8BIT, 0x519A, 0x04},
+	{MISENSOR_8BIT, 0x519B, 0x00},
+	{MISENSOR_8BIT, 0x519C, 0x08},
+	{MISENSOR_8BIT, 0x519D, 0x20},
+	{MISENSOR_8BIT, 0x519E, 0x38},
+	/* color matrix */
+	{MISENSOR_8BIT, 0x5381, 0x1F},
+	{MISENSOR_8BIT, 0x5382, 0x5C},
+	{MISENSOR_8BIT, 0x5383, 0x05},
+	{MISENSOR_8BIT, 0x5384, 0x03},
+	{MISENSOR_8BIT, 0x5385, 0x6C},
+	{MISENSOR_8BIT, 0x5386, 0x6F},
+	{MISENSOR_8BIT, 0x5387, 0x6E},
+	{MISENSOR_8BIT, 0x5388, 0x62},
+	{MISENSOR_8BIT, 0x5389, 0x0C},
+	{MISENSOR_8BIT, 0x538A, 0x01},
+	{MISENSOR_8BIT, 0x538B, 0x98},
+	/* CIP */
+	{MISENSOR_8BIT, 0x5300, 0x08},	/* sharpen MT th1 */
+	{MISENSOR_8BIT, 0x5301, 0x30},	/* sharpen MT th2 */
+	{MISENSOR_8BIT, 0x5302, 0x18},	/* sharpen MT offset 1 */
+	{MISENSOR_8BIT, 0x5303, 0x0E},	/* sharpen MT offset 2 */
+	{MISENSOR_8BIT, 0x5304, 0x08},	/* DNS threshold 1 */
+	{MISENSOR_8BIT, 0x5305, 0x30},	/* DNS threshold 2 */
+	{MISENSOR_8BIT, 0x5306, 0x08},	/* DNS offset 1 */
+	{MISENSOR_8BIT, 0x5307, 0x16},	/* DNS offset 2 */
+	{MISENSOR_8BIT, 0x5308, 0x00},	/* auto de-noise */
+	{MISENSOR_8BIT, 0x5309, 0x08},	/* sharpen TH th1 */
+	{MISENSOR_8BIT, 0x530A, 0x30},	/* sharpen TH th2 */
+	{MISENSOR_8BIT, 0x530B, 0x04},	/* sharpen TH offset 1 */
+	{MISENSOR_8BIT, 0x530C, 0x06},	/* sharpen TH offset 2 */
+	/* gamma */
+	{MISENSOR_8BIT, 0x5480, 0x01},
+	{MISENSOR_8BIT, 0x5481, 0x08},
+	{MISENSOR_8BIT, 0x5482, 0x14},
+	{MISENSOR_8BIT, 0x5483, 0x28},
+	{MISENSOR_8BIT, 0x5484, 0x51},
+	{MISENSOR_8BIT, 0x5485, 0x65},
+	{MISENSOR_8BIT, 0x5486, 0x71},
+	{MISENSOR_8BIT, 0x5487, 0x7D},
+	{MISENSOR_8BIT, 0x5488, 0x87},
+	{MISENSOR_8BIT, 0x5489, 0x91},
+	{MISENSOR_8BIT, 0x548A, 0x9A},
+	{MISENSOR_8BIT, 0x548B, 0xAA},
+	{MISENSOR_8BIT, 0x548C, 0xB8},
+	{MISENSOR_8BIT, 0x548D, 0xCD},
+	{MISENSOR_8BIT, 0x548E, 0xDD},
+	{MISENSOR_8BIT, 0x548F, 0xEA},
+	{MISENSOR_8BIT, 0x5490, 0x1D},
+	/* UV adjust */
+	{MISENSOR_8BIT, 0x5580, 0x06},	/* sat on contrast on */
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat VV */
+	{MISENSOR_8BIT, 0x5589, 0x10},	/* UV adjust th1 */
+	{MISENSOR_8BIT, 0x558A, 0x00},	/* UV adjust th2[8] */
+	{MISENSOR_8BIT, 0x558B, 0xF8},	/* UV adjust th2[7:0] */
+	{MISENSOR_8BIT, 0x501D, 0x40},	/* enable manual offset of contrast */
+	/* lens correction */
+	{MISENSOR_8BIT, 0x5800, 0x3D},
+	{MISENSOR_8BIT, 0x5801, 0x1E},
+	{MISENSOR_8BIT, 0x5802, 0x15},
+	{MISENSOR_8BIT, 0x5803, 0x17},
+	{MISENSOR_8BIT, 0x5804, 0x1E},
+	{MISENSOR_8BIT, 0x5805, 0x3F},
+	{MISENSOR_8BIT, 0x5806, 0x10},
+	{MISENSOR_8BIT, 0x5807, 0x0A},
+	{MISENSOR_8BIT, 0x5808, 0x07},
+	{MISENSOR_8BIT, 0x5809, 0x07},
+	{MISENSOR_8BIT, 0x580A, 0x0B},
+	{MISENSOR_8BIT, 0x580B, 0x13},
+	{MISENSOR_8BIT, 0x580C, 0x0A},
+	{MISENSOR_8BIT, 0x580D, 0x04},
+	{MISENSOR_8BIT, 0x580E, 0x00},
+	{MISENSOR_8BIT, 0x580F, 0x00},
+	{MISENSOR_8BIT, 0x5810, 0x04},
+	{MISENSOR_8BIT, 0x5811, 0x0C},
+	{MISENSOR_8BIT, 0x5812, 0x0A},
+	{MISENSOR_8BIT, 0x5813, 0x04},
+	{MISENSOR_8BIT, 0x5814, 0x00},
+	{MISENSOR_8BIT, 0x5815, 0x00},
+	{MISENSOR_8BIT, 0x5816, 0x04},
+	{MISENSOR_8BIT, 0x5817, 0x0C},
+	{MISENSOR_8BIT, 0x5818, 0x10},
+	{MISENSOR_8BIT, 0x5819, 0x0B},
+	{MISENSOR_8BIT, 0x581A, 0x07},
+	{MISENSOR_8BIT, 0x581B, 0x07},
+	{MISENSOR_8BIT, 0x581C, 0x0A},
+	{MISENSOR_8BIT, 0x581D, 0x14},
+	{MISENSOR_8BIT, 0x581E, 0x37},
+	{MISENSOR_8BIT, 0x581F, 0x1F},
+	{MISENSOR_8BIT, 0x5820, 0x18},
+	{MISENSOR_8BIT, 0x5821, 0x18},
+	{MISENSOR_8BIT, 0x5822, 0x1F},
+	{MISENSOR_8BIT, 0x5823, 0x2F},
+	{MISENSOR_8BIT, 0x5824, 0x48},
+	{MISENSOR_8BIT, 0x5825, 0x2A},
+	{MISENSOR_8BIT, 0x5826, 0x2C},
+	{MISENSOR_8BIT, 0x5827, 0x08},
+	{MISENSOR_8BIT, 0x5828, 0x66},
+	{MISENSOR_8BIT, 0x5829, 0x0A},
+	{MISENSOR_8BIT, 0x582A, 0x26},
+	{MISENSOR_8BIT, 0x582B, 0x24},
+	{MISENSOR_8BIT, 0x582C, 0x26},
+	{MISENSOR_8BIT, 0x582D, 0x08},
+	{MISENSOR_8BIT, 0x582E, 0x08},
+	{MISENSOR_8BIT, 0x582F, 0x42},
+	{MISENSOR_8BIT, 0x5830, 0x40},
+	{MISENSOR_8BIT, 0x5831, 0x22},
+	{MISENSOR_8BIT, 0x5832, 0x06},
+	{MISENSOR_8BIT, 0x5833, 0x0A},
+	{MISENSOR_8BIT, 0x5834, 0x24},
+	{MISENSOR_8BIT, 0x5835, 0x24},
+	{MISENSOR_8BIT, 0x5836, 0x26},
+	{MISENSOR_8BIT, 0x5837, 0x06},
+	{MISENSOR_8BIT, 0x5838, 0x48},
+	{MISENSOR_8BIT, 0x5839, 0x08},
+	{MISENSOR_8BIT, 0x583A, 0x28},
+	{MISENSOR_8BIT, 0x583B, 0x06},
+	{MISENSOR_8BIT, 0x583C, 0x4A},
+	{MISENSOR_8BIT, 0x583D, 0xCE},
+	/* AE */
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	{MISENSOR_8BIT, 0x3A0F, 0x30},	/* stable in high */
+	{MISENSOR_8BIT, 0x3A10, 0x28},	/* stable in low */
+	{MISENSOR_8BIT, 0x3A1B, 0x30},	/* stable out high */
+	{MISENSOR_8BIT, 0x3A1E, 0x26},	/* stable out low */
+	{MISENSOR_8BIT, 0x3A11, 0x60},	/* fast zone high */
+	{MISENSOR_8BIT, 0x3A1F, 0x14},	/* fast zone low */
+	{MISENSOR_8BIT, 0x350A, 0x00},
+	{MISENSOR_8BIT, 0x350B, 0x32},	/* default gain 50 */
+	{MISENSOR_8BIT, 0x3500, 0x00},
+	{MISENSOR_8BIT, 0x3501, 0x03},
+	{MISENSOR_8BIT, 0x3502, 0xE8},	/* default shutter 1000 */
+	/* BLC */
+	{MISENSOR_8BIT, 0x4000, 0x89},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4002, 0x45},
+	{MISENSOR_8BIT, 0x4003, 0x08},
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	{MISENSOR_8BIT, 0x4009, 0x10},
+	{MISENSOR_8BIT, 0x4202, 0x00},	/* stream on */
+	{MISENSOR_8BIT, 0x4202, 0x0F},	/* stream off */
+	{MISENSOR_8BIT, 0x3008, 0x02},	/* wake up */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_focus_init[] = {
+	{MISENSOR_8BIT, 0x3022, 0x00},
+	{MISENSOR_8BIT, 0x3023, 0x00},
+	{MISENSOR_8BIT, 0x3024, 0x00},
+	{MISENSOR_8BIT, 0x3025, 0x00},
+	{MISENSOR_8BIT, 0x3026, 0x00},
+	{MISENSOR_8BIT, 0x3027, 0x00},
+	{MISENSOR_8BIT, 0x3028, 0x00},
+	{MISENSOR_8BIT, 0x3029, 0x7F},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_800x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x03},
+	{MISENSOR_8BIT, 0x3809, 0x20},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};	
+
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_rgb565_1280x720p_init[] = { 
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x6f /*0x32*/},
+	{MISENSOR_8BIT,0x501f,0x01 /*0x00*/},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};	
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_1440x720p_init[] = {
+
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*mclk=19.2MHz*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x40},
+	{MISENSOR_8BIT,0x3821,0x06},
+	{MISENSOR_8BIT,0x3814,0x11},
+	{MISENSOR_8BIT,0x3815,0x11},
+	{MISENSOR_8BIT,0x3800,0x02},
+	{MISENSOR_8BIT,0x3801,0x40},
+	{MISENSOR_8BIT,0x3802,0x02},
+	{MISENSOR_8BIT,0x3803,0x66},
+	{MISENSOR_8BIT,0x3804,0x07},
+	{MISENSOR_8BIT,0x3805,0xff},
+	{MISENSOR_8BIT,0x3806,0x05},
+	{MISENSOR_8BIT,0x3807,0x3d},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0xa0},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x0a}, /*09*/
+	{MISENSOR_8BIT,0x380d,0x58}, /*c8*/
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x04},
+	{MISENSOR_8BIT,0x3612,0x2b},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x12},
+	{MISENSOR_8BIT,0x370c,0x00},
+	{MISENSOR_8BIT,0x3a02,0x04},
+	{MISENSOR_8BIT,0x3a03,0x60},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x50},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x18},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x04},
+	{MISENSOR_8BIT,0x3a15,0x60},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x06},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0a},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+#endif
diff --git a/drivers/media/video/ov5640_2.c b/drivers/media/video/ov5640_2.c
new file mode 100644
index 0000000..b6fe8f0
--- /dev/null
+++ b/drivers/media/video/ov5640_2.c
@@ -0,0 +1,2382 @@
+/*
+ * Support for ov5640_2 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5640_2.h"
+
+#define to_ov5640_2_sensor(sd) container_of(sd, struct ov5640_2_device, sd)
+
+/* #define DEBUG_I2C_COMMAND */
+#define ov2printk(args...) 
+
+
+static int ov5640_2_set_i2c_addr = 0;
+
+
+static int
+ov5640_2_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int
+ov5640_2_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+	
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+	
+#ifdef DEBUG_I2C_COMMAND
+	printk("%x %02x%02x %02x\n",msg.addr, data[0], data[1], data[2]);
+#endif	    
+	
+	
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	
+	return num_msg;
+}
+
+static int ov5640_2_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == 1)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+/*
+ * __ov5640_2_flush_reg_array() is internal function to make writing reg
+ * faster and should be not used anywhere else.
+ */
+static int __ov5640_2_flush_reg_array(struct i2c_client *client, 
+				      struct ov5640_2_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5640_2_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+/*
+ * ov5640_2_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov5640_2_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov5640_2_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct firmware *
+load_firmware(struct device *dev)
+{
+	const struct firmware *fw;
+	int rc;
+
+	rc = request_firmware(&fw, AF_FW_PATH, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			dev_err(dev, "Error AF firmware %s not found.\n",
+					AF_FW_PATH);
+		else
+			dev_err(dev,
+				"Error %d while requesting firmware %s\n",
+				rc, AF_FW_PATH);
+		return NULL;
+	}
+
+	return fw;
+}
+
+static int ov5640_2_af_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	const struct firmware *firmware;
+	struct ov5640_2_write_ctrl ctrl;
+	int err;
+	int i;
+	int group_length;
+
+	return 0;
+	
+	
+	/* reset MCU */
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_SYS_RESET, OV5640_2_MCU_RESET);
+	if (err)
+		return err;
+
+	/* download firmware */
+	if (dev->firmware) {
+		firmware = dev->firmware;
+	} else {
+		firmware = load_firmware(&client->dev);
+		if (!firmware) {
+			dev_err(&client->dev, "Load firmwares failed\n");
+			return -EINVAL;
+		}
+		dev->firmware = firmware;
+	}
+
+	/* download firmware in group */
+	group_length = (firmware->size) / (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	for (i = 0; i < group_length; i++) {
+		ctrl.buffer.addr = OV5640_2_REG_FW_START
+				    + i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+		memcpy(ctrl.buffer.data,
+			&firmware->data[i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2)],
+			(OV5640_2_MAX_WRITE_BUF_SIZE - 2));
+		ctrl.index = (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+		err = __ov5640_2_flush_reg_array(client, &ctrl);
+		if (err) {
+			dev_err(&client->dev, "write firmwares reg failed\n");
+			return err;
+		}
+	}
+
+	/* download firmware less than 1 group */
+	ctrl.buffer.addr = OV5640_2_REG_FW_START +
+				i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	memcpy(ctrl.buffer.data,
+		&firmware->data[i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2)],
+		firmware->size - i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2));
+	ctrl.index = firmware->size - i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	err = __ov5640_2_flush_reg_array(client, &ctrl);
+	if (err) {
+		dev_err(&client->dev, "write firmwares reg failed\n");
+		return err;
+	}
+
+
+	return ov5640_2_write_reg_array(client, ov5640_2_focus_init);
+}
+
+static int ov5640_2_s_focus_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err = 0;
+
+
+	/*
+	 * if sensor streamoff, writing focus mode reg is invalid.
+	 * only writing focus mode reg is valid after streamon.
+	 */
+	if (dev->streaming == false) {
+		dev->focus_mode = mode;
+		dev->focus_mode_change = true;
+		return 0;
+	}
+
+	switch (mode) {
+	case V4L2_CID_AUTO_FOCUS_START:
+		/* start single focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_SINGLE_FOCUS);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		/* start continuous focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_CONTINUE_FOCUS);
+		break;
+	case V4L2_CID_3A_LOCK:
+		/* pause focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_PAUSE_FOCUS);
+		break;
+	case V4L2_CID_AUTO_FOCUS_STOP:
+		/* release focus to infinity */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_RELEASE_FOCUS);
+		break;
+	default:
+		dev_err(&client->dev, "invalid mode.\n");
+		return -EINVAL;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting focus mode fails.\n");
+		return err;
+	}
+
+	dev->focus_mode = mode;
+	dev->focus_mode_change = false;
+
+	return 0;
+}
+
+static int ov5640_2_s_single_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_START);
+}
+
+static int ov5640_2_s_cont_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_FOCUS_AUTO);
+}
+
+static int ov5640_2_pause_focus(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value != V4L2_LOCK_FOCUS) {
+		dev_err(&client->dev, "invalid focus cmd.\n");
+		return -EINVAL;
+	}
+
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_3A_LOCK);
+}
+
+static int ov5640_2_release_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_STOP);
+}
+
+static int ov5640_2_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_normal_effect);
+		break;
+	case V4L2_COLORFX_SEPIA:
+		err = ov5640_2_write_reg_array(client, ov5640_2_sepia_effect);
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_negative_effect);
+		break;
+	case V4L2_COLORFX_BW:
+		err = ov5640_2_write_reg_array(client, ov5640_2_bw_effect);
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_blue_effect);
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		err = ov5640_2_write_reg_array(client, ov5640_2_green_effect);
+		break;
+	default:
+		dev_err(&client->dev, "invalid color effect.\n");
+		return -ERANGE;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting color effect fails.\n");
+		return err;
+	}
+
+	dev->color_effect = effect;
+
+	return 0;
+}
+
+static int ov5640_2_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int ov5640_2_g_focus_status(struct v4l2_subdev *sd, int *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val = 0;
+
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_STATUS, &val);
+	if (err)
+		return err;
+
+	switch (val & 0xff) {
+	case OV5640_2_FOCUS_FW_DL:
+		/* firmware is downloaded and not to be initialized */
+		*status = V4L2_AUTO_FOCUS_STATUS_FAILED;
+		break;
+	case OV5640_2_FOCUS_FW_INIT:
+		/* firmware is initializing */
+	case OV5640_2_FOCUS_FW_IDLE:
+		/* firmware is idle */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+		break;
+	case OV5640_2_FOCUS_FW_RUN:
+		/* focus is running */
+		*status = V4L2_AUTO_FOCUS_STATUS_BUSY;
+		break;
+	case OV5640_2_FOCUS_FW_FINISH:
+		/* focus is finished */
+		*status = V4L2_AUTO_FOCUS_STATUS_REACHED;
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_2_get_sysclk(struct v4l2_subdev *sd, unsigned int *sysclk)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp1 = 0, temp2 = 0;
+	u32 multiplier = 0, prediv = 0, vco = 0, sysdiv = 0;
+	u32 pll_rdiv = 0, bit_div2x = 0, sclk_rdiv = 0;
+
+	static int sclk_rdiv_map[] = {1, 2, 4, 8};
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_0, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 >> 1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_1, &temp1);
+	if (err)
+		return err;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_2, &temp1);
+	if (err)
+		return err;
+	multiplier = temp1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_3, &temp1);
+	if (err)
+		return err;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_CLK_DIVIDER, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if ((prediv && sclk_rdiv && bit_div2x) == 0)
+		return -EINVAL;
+
+	vco = OV5640_2_XVCLK * multiplier / prediv;
+
+	*sysclk = vco / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	if (*sysclk < MIN_SYSCLK)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read HTS from register settings */
+static int ov5640_2_get_hts(struct v4l2_subdev *sd, unsigned int *hts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+				OV5640_2_REG_TIMING_HTS, hts);
+	if (err)
+		return err;
+
+	if (*hts < MIN_HTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read VTS from register settings */
+static int ov5640_2_get_vts(struct v4l2_subdev *sd, unsigned int *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+				OV5640_2_REG_TIMING_VTS, vts);
+	if (err)
+		return err;
+
+	if (*vts < MIN_VTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write VTS to registers */
+static int ov5640_2_set_vts(struct v4l2_subdev *sd, unsigned int vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_TIMING_VTS, vts);
+}
+
+/* read shutter, in number of line period */
+static int ov5640_2_get_shutter(struct v4l2_subdev *sd, unsigned int *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val, temp;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_EXPOSURE_0, &val);
+	if (err)
+		return err;
+	temp = (val & 0x0fff);
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_EXPOSURE_1, &val);
+	if (err)
+		return err;
+
+	*shutter = (temp << 4) + (val >> 4);
+
+	if(*shutter < MIN_SHUTTER)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_2_set_shutter(struct v4l2_subdev *sd, unsigned int shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp << 4;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_EXPOSURE_1, temp);
+	if (err)
+		return err;
+
+	temp = shutter >> 4;
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_EXPOSURE_0, temp);
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_2_get_gain16(struct v4l2_subdev *sd, unsigned int *gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_GAIN, &val);
+	if (err)
+		return err;
+
+	*gain16 = val & 0x3ff;
+
+	if(*gain16 < MIN_GAIN)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_2_set_gain16(struct v4l2_subdev *sd, unsigned int gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gain16 = gain16 & 0x3ff;
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_GAIN, gain16);
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int ov5640_2_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int ov5640_2_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 gain;
+	int err;
+
+	err = ov5640_2_get_gain16(sd, &gain);
+	if (err)
+		return err;
+
+	*value = gain / 16 * 100;
+
+	return 0;
+}
+
+/* get banding filter value */
+static int ov5640_2_get_light_frequency(struct v4l2_subdev *sd,
+				unsigned int *light_frequency)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_0, &temp);
+	if (err)
+		return err;
+
+	if (temp & OV5640_2_AUTO_BAND) {
+		/* manual */
+		err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_1, &temp);
+		if (err)
+			return err;
+		if (temp & 0x04)
+			/* 50Hz */
+			*light_frequency = OV5640_2_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_2_LIGHT_60HZ;
+	} else {
+		/* auto */
+		err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_2, &temp);
+		if (err)
+			return err;
+		if (temp & 0x01)
+			/* 50Hz */
+			*light_frequency = OV5640_2_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_2_LIGHT_60HZ;
+	}
+
+	return 0;
+}
+
+static int ov5640_2_set_bandingfilter(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	u32 band_step60, max_band60, band_step50, max_band50;
+	int err;
+
+	/* read preview PCLK */
+	err = ov5640_2_get_sysclk(sd, &dev->preview_sysclk);
+	if (err)
+		return err;
+
+	/* read preview HTS */
+	err = ov5640_2_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	/* read preview VTS */
+	err = ov5640_2_get_vts(sd, &dev->preview_vts);
+	if (err)
+		return err;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = dev->preview_sysclk * 100 / dev->preview_hts * 100 / 120;
+	if (band_step60 == 0)
+		return -EINVAL;
+
+	err = ov5640_2_write_reg(client, MISENSOR_16BIT, OV5640_2_REG_B60_STEP,
+								band_step60);
+	if (err)
+		return err;
+
+	max_band60 = (dev->preview_vts - 4) / band_step60;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_B60_MAX, max_band60);
+	if (err)
+		return err;
+
+	/* 50Hz */
+	band_step50 = dev->preview_sysclk * 100 / dev->preview_hts;
+	if (band_step50 == 0)
+		return -EINVAL;
+
+	err = ov5640_2_write_reg(client, MISENSOR_16BIT, OV5640_2_REG_B50_STEP,
+								band_step50);
+	if (err)
+		return err;
+
+	max_band50 = (dev->preview_vts - 4) / band_step50;
+
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_B50_MAX, max_band50);
+}
+
+/* stable in high */
+static int ov5640_2_set_ae_target(struct v4l2_subdev *sd, unsigned int target)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;	
+	u32 fast_high, fast_low;
+	dev->ae_low = target * 23 / 25;	 /* 0.92 */
+	dev->ae_high = target * 27 / 25; /* 1.08 */
+
+	
+	fast_high = dev->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = dev->ae_low >> 1;
+
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_IN_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_IN_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_OUT_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_OUT_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_FAST_H, fast_high);
+	if (err)
+		return err;
+
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_FAST_L, fast_low);
+}
+
+static int
+ov5640_2_set_ag_ae(struct i2c_client *client, int enable)
+{
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+			OV5640_2_REG_AE_MODE_CTRL,
+			enable ? OV5640_2_AUTO_AG_AE : OV5640_2_MANUAL_AG_AE);
+}
+
+static int ov5640_2_set_night_mode(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, &temp);
+	if (err)
+		return err;
+
+	if (enable) {
+		temp = temp | 0x04;
+		return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, temp);
+	} else {
+		temp = temp & 0xfb;
+		return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, temp);
+	}
+}
+
+static int ov5640_2_set_awb_gain_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AWB_CTRL, &temp);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case OV5640_2_AWB_GAIN_AUTO:
+		/* set awb gain to auto */
+		temp = temp & 0xfe;
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_AWB_CTRL, temp);
+		break;
+	case OV5640_2_AWB_GAIN_MANUAL:
+		/* set awb gain to manual */
+		temp = temp | 0x01;
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_AWB_CTRL, temp);
+		break;
+	default:
+		dev_err(&client->dev, "invalid awb gain mode.\n");
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_2_start_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int ret;
+
+	dev->preview_ag_ae = false;
+
+	ret = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_gain16(sd, dev->preview_gain16);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_shutter(sd, dev->preview_shutter);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_ag_ae(client, 1);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_bandingfilter(sd);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_ae_target(sd, OV5640_2_AE_TARGET);
+	if (ret)
+		return ret;
+
+	return ov5640_2_set_night_mode(sd, dev->night_mode);
+}
+
+static int ov5640_2_stop_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;
+
+	/* read preview shutter */
+	err = ov5640_2_get_shutter(sd, &dev->preview_shutter);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_gain16(sd, &dev->preview_gain16);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	dev->preview_ag_ae = true;
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_MANUAL);
+	if (err)
+		return err;
+
+	/* get average */
+	return ov5640_2_read_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_AE_AVERAGE, &dev->average);
+}
+
+
+
+#if 0
+static int ov5640_2_start_raw_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	ov2printk("write ov5640_2_800x480_yuv_2lane_192MCLK_30fps to ov5640_2\n");
+	return ov5640_2_write_reg_array(client, ov5640_2_800x480_yuv_2lane_192MCLK_30fps);
+	
+
+}
+#endif
+static int ov5640_2_start_video(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ag_ae(client, 1);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_bandingfilter(sd);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ae_target(sd, OV5640_2_AE_TARGET);
+	if (err)
+		return err;
+
+	return ov5640_2_set_night_mode(sd, 0);
+
+}
+
+static int ov5640_2_start_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	u32 capture_sysclk, capture_hts, capture_vts;
+	u32 capture_shutter, capture_gain16;
+	u32 light_frequency, capture_bandingfilter, capture_max_band;
+	long capture_gain16_shutter;
+	int err;
+
+
+	if (!dev->preview_ag_ae) {
+		dev_err(&client->dev, "preview gain and shutter are not available.\n");
+		return -EINVAL;
+	}
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ag_ae(client, 0);
+	if (err)
+		return err;
+
+	/* read capture VTS */
+	err = ov5640_2_get_vts(sd, &capture_vts);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_hts(sd, &capture_hts);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_sysclk(sd, &capture_sysclk);
+	if (err)
+		return err;
+
+	/* calculate capture banding filter */
+	err = ov5640_2_get_light_frequency(sd, &light_frequency);
+	if (err)
+		return err;
+
+	if (light_frequency == OV5640_2_LIGHT_60HZ) {
+		/* 60Hz */
+		capture_bandingfilter = capture_sysclk * 100 /
+						capture_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		capture_bandingfilter = capture_sysclk * 100 / capture_hts;
+	}
+
+	if (capture_bandingfilter == 0)
+		return -EINVAL;
+
+	capture_max_band = (int)((capture_vts - 4) / capture_bandingfilter);
+	if (capture_max_band == 0)
+		return -EINVAL;
+
+	/* calculate capture shutter/gain16 */
+	if (dev->average > dev->ae_low && dev->average < dev->ae_high) {
+		/* in stable range */
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts *
+					OV5640_2_AE_TARGET / dev->average;
+	} else {
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts;
+	}
+	/* gain to shutter */
+	if (capture_gain16_shutter < (capture_bandingfilter * 16)) {
+		/* shutter < 1/100 */
+		capture_shutter = capture_gain16_shutter / 16;
+		if (capture_shutter < 1)
+			capture_shutter = 1;
+		capture_gain16 = capture_gain16_shutter / capture_shutter;
+		if (capture_gain16 < 16)
+			capture_gain16 = 16;
+	} else {
+		if (capture_gain16_shutter >
+			(capture_bandingfilter * capture_max_band * 16)) {
+			/* exposure reach max */
+			capture_shutter = capture_bandingfilter *
+							capture_max_band;
+			capture_gain16 = capture_gain16_shutter /
+							capture_shutter;
+		} else {
+			/*
+			 * 1/100 < capture_shutter =< max,
+			 * capture_shutter = n/100
+			 */
+			capture_shutter = ((int)(capture_gain16_shutter / 16 /
+						capture_bandingfilter)) *
+						capture_bandingfilter;
+			if (capture_shutter == 0)
+				return -EINVAL;
+
+			capture_gain16 = capture_gain16_shutter /
+						capture_shutter;
+		}
+	}
+
+	/* write capture gain */
+	err = ov5640_2_set_gain16(sd, capture_gain16);
+	if (err)
+		return err;
+
+	/* write capture shutter */
+	if (capture_shutter > (capture_vts - 4)) {
+		capture_vts = capture_shutter + 4;
+		err = ov5640_2_set_vts(sd, capture_vts);
+		if (err)
+			return err;
+	}
+
+	return ov5640_2_set_shutter(sd, capture_shutter);
+
+}
+
+static int ov5640_2_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg_array(client, ov5640_2_standby_reg);
+}
+
+static int ov5640_2_wakeup(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg_array(client, ov5640_2_wakeup_reg);
+}
+
+
+static int ov5640_2_set_new_addr(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, err, val;
+	int addr_to_use = client->addr;
+
+	if(client->addr == OV5640_FACTORY_DEFAULT_ADDR) return 0;
+	if(ov5640_2_set_i2c_addr) return 0;
+	
+	client->addr =  OV5640_FACTORY_DEFAULT_ADDR;	
+	ret = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_SCCB_ID, &val);
+	ov2printk("ov5640_2_set_new_addr: default address is 0x%0x\n", val);
+
+	if (ret) return ret;
+	
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_SCCB_ID, (addr_to_use << 1));
+	if (err) return err;
+	
+	client->addr = addr_to_use;
+
+	ret = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_SCCB_ID, &val);
+	if (ret) return ret;
+	ov2printk("ov5640_2: the new address =0x%x client addr=0x%x\n",val, client->addr);
+	
+	ov5640_2_set_i2c_addr = 1;
+	
+	return 0;
+}
+
+
+static int __ov5640_2_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if(client->addr != OV5640_FACTORY_DEFAULT_ADDR)
+	{
+	  ret = ov5640_2_set_new_addr(sd);
+	  if (ret)
+			return ret;
+	  ov2printk("ov5640_2_init: the client addr=0x%x\n", client->addr);
+	}
+
+	ret = ov5640_2_write_reg_array(client, ov5640_2_init);
+	if (ret)
+		return ret;
+
+	/*
+	 * delay 5ms to wait for sensor initialization finish.
+	 */
+	usleep_range(5000, 6000);
+
+	ret = ov5640_2_af_init(sd);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	
+	
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		{
+		goto fail_power;
+		}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/*
+	 * according to DS, 20ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int ov5640_2_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+
+	ov2printk("power on ov5640_2_s_power\n");
+		
+	if(power_up(sd))
+		return -EINVAL;
+	}
+
+	return __ov5640_2_init(sd);
+}
+
+static int ov5640_2_try_res(u32 *w, u32 *h, u32 *code)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_2_res[i].width == *w &&
+		    ov5640_2_res[i].height == *h &&
+		    ov5640_2_res[i].code == *code)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov5640_2_res[i].width;
+	*h = ov5640_2_res[i].height;
+	*code = ov5640_2_res[i].code;
+	
+
+	return 0;
+}
+
+static struct ov5640_2_res_struct *ov5640_2_to_res(u32 w, u32 h, u32 code)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_2_res[index].width == w &&
+		    ov5640_2_res[index].height == h &&
+		    ov5640_2_res[index].code == code)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &ov5640_2_res[index];
+}
+
+static int ov5640_2_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return ov5640_2_try_res(&fmt->width, &fmt->height, &fmt->code);
+}
+
+static int ov5640_2_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case OV5640_2_RES_QVGA:
+		hsize = OV5640_2_RES_QVGA_SIZE_H;
+		vsize = OV5640_2_RES_QVGA_SIZE_V;
+		break;
+	case OV5640_2_RES_DVGA:
+		hsize = OV5640_2_RES_DVGA_SIZE_H;
+		vsize = OV5640_2_RES_DVGA_SIZE_V;
+		break;
+	case OV5640_2_RES_320P:
+		hsize = OV5640_2_RES_320P_SIZE_H;
+		vsize = OV5640_2_RES_320P_SIZE_V;
+		break;
+	case OV5640_2_RES_360P:
+		hsize = OV5640_2_RES_360P_SIZE_H;
+		vsize = OV5640_2_RES_360P_SIZE_V;
+		break;
+	case OV5640_2_RES_VGA:
+		hsize = OV5640_2_RES_VGA_SIZE_H;
+		vsize = OV5640_2_RES_VGA_SIZE_V;
+		break;
+	case OV5640_2_RES_RGB_VGA:
+			hsize = OV5640_2_RES_VGA_SIZE_H;
+			vsize = OV5640_2_RES_VGA_SIZE_V;
+			break;
+	case OV5640_2_RES_480P:
+		hsize = OV5640_2_RES_480P_SIZE_H;
+		vsize = OV5640_2_RES_480P_SIZE_V;
+		break;
+	case OV5640_2_RES_736x480P:
+		hsize = OV5640_2_RES_736x480P_SIZE_H;
+		vsize = OV5640_2_RES_736x480P_SIZE_V;
+		break;
+	case OV5640_2_RES_800x480P:
+		hsize = OV5640_2_RES_800x480P_SIZE_H;
+		vsize = OV5640_2_RES_800x480P_SIZE_V;
+		break;
+	case OV5640_2_RES_720P:
+	case OV5640_2_RGB565_RES_720P:  
+		hsize = OV5640_2_RES_720P_SIZE_H;
+		vsize = OV5640_2_RES_720P_SIZE_V;
+		break;
+	case OV5640_2_RES_1440X720P:
+		hsize = OV5640_2_RES_1440X720P_SIZE_H;
+		vsize = OV5640_2_RES_1440X720P_SIZE_V;
+		break;
+	case OV5640_2_RES_1080P:
+		hsize = OV5640_2_RES_1080P_SIZE_H;
+		vsize = OV5640_2_RES_1080P_SIZE_V;
+		break;
+	case OV5640_2_RES_1080P_RGB:
+			hsize = OV5640_2_RES_1080P_SIZE_H;
+			vsize = OV5640_2_RES_1080P_SIZE_V;
+			break;
+	case OV5640_2_RES_1088P:
+		hsize = OV5640_2_RES_1088P_SIZE_H;
+		vsize = OV5640_2_RES_1088P_SIZE_V;
+		break;
+	case OV5640_2_RES_D3M:
+		hsize = OV5640_2_RES_D3M_SIZE_H;
+		vsize = OV5640_2_RES_D3M_SIZE_V;
+		break;
+	case OV5640_2_RES_3M:
+		hsize = OV5640_2_RES_3M_SIZE_H;
+		vsize = OV5640_2_RES_3M_SIZE_V;
+		break;
+	case OV5640_2_RES_D5M:
+		hsize = OV5640_2_RES_D5M_SIZE_H;
+		vsize = OV5640_2_RES_D5M_SIZE_V;
+		break;
+	case OV5640_2_RES_5M:
+		hsize = OV5640_2_RES_5M_SIZE_H;
+		vsize = OV5640_2_RES_5M_SIZE_V;
+		break;
+		
+	default:
+		/* QVGA mode is still unsupported */
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int ov5640_2_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = ov5640_2_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+	
+	
+
+	return 0;
+}
+
+static int ov5640_2_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct ov5640_2_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 code = fmt->code;
+	int ret;
+
+	
+	ov2printk("ov5640_2_s_mbus_fmt w=%d h=%d code=0x%x\n", fmt->width, fmt->height, fmt->code);
+	
+	ov5640_2_try_res(&width, &height, &code);
+	
+	res_index = ov5640_2_to_res(width, height, code);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	ov2printk("ov5640_2_s_mbus_fmt res_index->res=%d\n", res_index->res);
+
+	switch (res_index->res) {
+	case OV5640_2_RES_QVGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_qvga_init);
+		break;
+	case OV5640_2_RES_DVGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_dvga_init);
+		break;
+	case OV5640_2_RES_320P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_320p_init);
+		break;
+	case OV5640_2_RES_360P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_360p_init);
+		break;
+	case OV5640_2_RES_VGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_vga_init);
+		break;
+	case OV5640_2_RES_RGB_VGA:
+			ret = ov5640_2_write_reg_array(c, ov5640_2_vga_rgb_init);
+			break;
+	case OV5640_2_RES_480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_480p_init);
+		break;
+	case OV5640_2_RES_736x480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_736x480p_init);
+		break;
+	case OV5640_2_RES_800x480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_800x480p_init);
+		break;
+		
+	case OV5640_2_RES_720P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_720p_init);
+		break;
+	case OV5640_2_RGB565_RES_720P:  
+		ret = ov5640_2_write_reg_array(c, ov5640_2_rgb565_1280x720p_init);
+		break;
+	case OV5640_2_RES_1440X720P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1440x720p_init);
+		break;
+
+	case OV5640_2_RES_1080P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1080p_init);
+		break;
+	case OV5640_2_RES_1080P_RGB:
+			ret = ov5640_2_write_reg_array(c, ov5640_2_1080p_rgb);
+			break;
+	case OV5640_2_RES_1088P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1088p_init);
+		break;
+	case OV5640_2_RES_D3M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_D3M_init);
+		break;
+	case OV5640_2_RES_3M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_3M_init);
+		break;
+	case OV5640_2_RES_D5M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_D5M_init);
+		break;
+	case OV5640_2_RES_5M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_5M_init);
+		break;
+	default:
+		/* QVGA is not implemented yet */
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+							res_index->res);
+		return -EINVAL;
+	}
+	if (ret)
+		return -EINVAL;
+
+	
+	if (dev->res != res_index->res) {
+		int index;
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if (width == ov5640_2_res[index].width &&
+			    height == ov5640_2_res[index].height &&
+			    code == ov5640_2_res[index].code) {
+				ov5640_2_res[index].used = 1;
+				continue;
+			}
+			ov5640_2_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * ov5640_2 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = code;
+
+	ov2printk("ov5640_2_s_mbus_fmt width = %d height = %d code =0x%x dev->res=%d\n", 
+	       width, height, code, dev->res);
+	/* relaunch default focus zone */
+
+	ret = ov5640_2_write_reg(c, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_MODE,
+					OV5640_2_RELAUNCH_FOCUS);
+	if (ret) return -EINVAL;
+
+	return ov5640_2_wakeup(sd);
+	
+  
+}
+
+static int ov5640_2_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	if (ov5640_2_read_reg(client, MISENSOR_16BIT,
+		OV5640_2_REG_PID, &retvalue)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", retvalue);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "sensor_id = 0x%x\n", retvalue);
+	if (retvalue != OV5640_2_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	*id = retvalue;
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov5640_2_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+	ret = ov5640_2_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power_ctrl failed");
+		return ret;
+	}
+
+
+	/* config & detect sensor */
+	ret = ov5640_2_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov5640_2_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = ov5640_2_s_power(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	ov5640_2_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+
+static int ov5640_2_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_2_FOCAL_LENGTH_NUM << 16) | OV5640_2_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5640_2_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for OV5640_2 */
+	*val = (OV5640_2_F_NUMBER_DEFAULT_NUM << 16) | OV5640_2_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5640_2_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_2_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5640_2_F_NUMBER_DEM << 16) |
+		(OV5640_2_F_NUMBER_DEFAULT_NUM << 8) | OV5640_2_F_NUMBER_DEM;
+	return 0;
+}
+
+static struct ov5640_2_control ov5640_2_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_START,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "single focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_single_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_AUTO,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "continuous focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_cont_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "pause focus",
+			.minimum = 0,
+			.maximum = 1 << 2,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_pause_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STOP,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "release focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_release_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 0x07,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_2_g_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_color_effect,
+		.query = ov5640_2_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = OV5640_2_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_2_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = OV5640_2_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_2_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  OV5640_2_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5640_2_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5640_2_controls))
+
+static struct ov5640_2_control *ov5640_2_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov5640_2_controls[i].qc.id == id)
+			return &ov5640_2_controls[i];
+	}
+	return NULL;
+}
+
+static int ov5640_2_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5640_2_control *ctrl = ov5640_2_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int ov5640_2_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_2_control *octrl = ov5640_2_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_2_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_2_control *octrl = ov5640_2_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_2_mipi_stream(struct i2c_client *client, int enable)
+{
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+			OV5640_2_REG_FRAME_CTRL,
+			enable ? OV5640_2_FRAME_START : OV5640_2_FRAME_STOP);
+}
+
+static int ov5640_2_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;
+
+	if (enable) {
+		switch (dev->run_mode) {
+		case CI_MODE_PREVIEW:
+			err = ov5640_2_start_preview(sd);
+			break;
+		case CI_MODE_VIDEO:
+			err = ov5640_2_start_video(sd);
+			break;
+		case CI_MODE_STILL_CAPTURE:
+			err = ov5640_2_start_video(sd);
+
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid run mode = 0x%x\n", dev->run_mode);
+			return -EINVAL;
+		}
+		if (err)
+			dev_warn(&client->dev,
+				"fail to start preview/video/capture.\n");
+
+		err = ov5640_2_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		dev->streaming = true;
+		
+		if (dev->focus_mode_change) {
+			err = ov5640_2_s_focus_mode(sd, dev->focus_mode);
+			if (err) {
+				dev_err(&client->dev,
+					"writing focus mode reg fails.\n");
+				return err;
+			}
+			dev->focus_mode_change = false;
+		}
+		
+	} else {
+
+	  
+		if (dev->run_mode == CI_MODE_PREVIEW) {
+			err = ov5640_2_stop_preview(sd);
+			if (err)
+				dev_warn(&client->dev,
+					"fail to stop preview\n");
+		}
+		err = ov5640_2_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		err = ov5640_2_standby(sd);
+		if (err)
+			return err;		
+		dev->streaming = false;
+		dev->focus_mode = V4L2_CID_3A_LOCK;
+	}
+
+	
+	return 0;
+}
+
+static int
+ov5640_2_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5640_2_res[index].width;
+	fsize->discrete.height = ov5640_2_res[index].height;
+
+	fsize->reserved[0] = ov5640_2_res[index].used;
+
+	return 0;
+}
+
+static int ov5640_2_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_2_res[i].width >= fival->width &&
+		    ov5640_2_res[i].height >= fival->height)
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5640_2_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov5640_2_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640_2, 0);
+}
+
+static int ov5640_2_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5640_2_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5640_2_res[index].width;
+	fse->min_height = ov5640_2_res[index].height;
+	fse->max_width = ov5640_2_res[index].width;
+	fse->max_height = ov5640_2_res[index].height;
+
+	return 0;
+}
+
+static int
+ov5640_2_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_2_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov5640_2_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int focus_width_step, focus_height_step;
+	u32 x_center, y_center;
+	int width = 0, height = 0;
+	int err, index;
+
+	
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_err(&client->dev,
+				"invalid selection format.\n");
+		return -EINVAL;
+	}
+
+	if (sel->target != V4L2_SEL_TGT_COMPOSE) {
+		dev_err(&client->dev,
+				"invalid selection compose.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < N_RES; index++) {
+		if (dev->res == ov5640_2_res[index].res) {
+			width = ov5640_2_res[index].width;
+			height = ov5640_2_res[index].height;
+			break;
+		}
+	}
+
+	focus_width_step = width / OV5640_2_FOCUS_ZONE_ARRAY_WIDTH;
+	focus_height_step = height / OV5640_2_FOCUS_ZONE_ARRAY_HEIGHT;
+
+	/* calculate the center coordinate of selection rectangle */
+	x_center = DIV_ROUND_UP((sel->r.left + sel->r.width / 2),
+						focus_width_step);
+	y_center = DIV_ROUND_UP((sel->r.top + sel->r.height / 2),
+						focus_height_step);
+	
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_ZONE_X,
+					x_center);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_ZONE_Y,
+					y_center);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_S_FOCUS_ZONE);
+	if (err)
+		return err;
+
+	return ov5640_2_s_focus_mode(sd, dev->focus_mode);
+}
+
+
+
+static int
+ov5640_2_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->res >= 0 && dev->res < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5640_2_res[dev->res].fps;
+	}
+	return 0;
+}
+
+static int
+ov5640_2_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	dev->run_mode = param->parm.capture.capturemode;
+	ov2printk("ov5640_2_s_parm dev->run_mode=0x%x\n", dev->run_mode);
+	
+	return ov5640_2_g_parm(sd, param);
+}
+
+static int
+ov5640_2_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_2_res[index].res == snr->res) {
+			*frames = ov5640_2_res[index].skip_frames;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_2_video_ops = {
+	.try_mbus_fmt = ov5640_2_try_mbus_fmt,
+	.g_mbus_fmt = ov5640_2_g_mbus_fmt,
+	.s_mbus_fmt = ov5640_2_s_mbus_fmt,
+	.s_parm = ov5640_2_s_parm,
+	.g_parm = ov5640_2_g_parm,
+	.s_stream = ov5640_2_s_stream,
+	.enum_framesizes = ov5640_2_enum_framesizes,
+	.enum_frameintervals = ov5640_2_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_2_sensor_ops = {
+	.g_skip_frames	= ov5640_2_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_2_core_ops = {
+	.g_chip_ident = ov5640_2_g_chip_ident,
+	.queryctrl = ov5640_2_queryctrl,
+	.g_ctrl = ov5640_2_g_ctrl,
+	.s_ctrl = ov5640_2_s_ctrl,
+	.s_power = ov5640_2_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_2_pad_ops = {
+	.enum_mbus_code = ov5640_2_enum_mbus_code,
+	.enum_frame_size = ov5640_2_enum_frame_size,
+	.get_fmt = ov5640_2_get_pad_format,
+	.set_fmt = ov5640_2_set_pad_format,
+	.set_selection = ov5640_2_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov5640_2_ops = {
+	.core = &ov5640_2_core_ops,
+	.video = &ov5640_2_video_ops,
+	.sensor = &ov5640_2_sensor_ops,
+	.pad = &ov5640_2_pad_ops,
+};
+
+static const struct media_entity_operations ov5640_2_entity_ops;
+
+static int ov5640_2_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_2_device *dev = container_of(sd,
+					struct ov5640_2_device, sd);
+		
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	power_down(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5640_2_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov5640_2_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &ov5640_2_ops);
+	if (client->dev.platform_data) {
+		ov2printk("ov5640_2_probe has platform data\n");
+		ret = ov5640_2_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+	else ov2printk("ov5640_2_probe NOOON platform data\n");
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &ov5640_2_entity_ops;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov5640_2_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	/* set focus mode to be invalid */
+	dev->focus_mode = -1;
+
+	/* set color_effect to be invalid */
+	dev->color_effect = -1;
+	dev->preview_gain16 = OV5640_2_DEFAULT_GAIN;
+	dev->preview_shutter = OV5640_2_DEFAULT_SHUTTER;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5640_2_id);
+static struct i2c_driver ov5640_2_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5640_2_NAME,
+	},
+	.probe = ov5640_2_probe,
+	.remove = __exit_p(ov5640_2_remove),
+	.id_table = ov5640_2_id,
+};
+
+static __init int ov5640_2_init_mod(void)
+{
+	return i2c_add_driver(&ov5640_2_driver);
+}
+
+static __exit void ov5640_2_exit_mod(void)
+{
+	i2c_del_driver(&ov5640_2_driver);
+}
+
+module_init(ov5640_2_init_mod);
+module_exit(ov5640_2_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV5640_2 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/ov5640_2.h b/drivers/media/video/ov5640_2.h
new file mode 100644
index 0000000..68c8a81
--- /dev/null
+++ b/drivers/media/video/ov5640_2.h
@@ -0,0 +1,3487 @@
+/*
+ * Support for ov5640_2 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5640_2_H__
+#define __OV5640_2_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV5640_2_NAME	"ov5640-2"
+
+#define V4L2_IDENT_OV5640_2 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+#define OV5640_2_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV5640_2_FOCAL_LENGTH_DEM	100
+#define OV5640_2_F_NUMBER_DEFAULT_NUM	24
+#define OV5640_2_F_NUMBER_DEM	10
+#define OV5640_2_FOCUS_ZONE_ARRAY_WIDTH	80
+#define OV5640_2_FOCUS_ZONE_ARRAY_HEIGHT	60
+
+#define OV5640_2_XVCLK		1920
+#define OV5640_2_AE_TARGET	45
+#define OV5640_2_DEFAULT_GAIN	50
+#define OV5640_2_DEFAULT_SHUTTER	1000
+
+#define OV5640_FACTORY_DEFAULT_ADDR 0x3c
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_2_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_2_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5640_2_F_NUMBER_RANGE 0x180a180a
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#define OV5640_2_REG_SCCB_ID	0x3100
+
+#define OV5640_2_REG_PID		0x300a
+#define OV5640_2_REG_SYS_RESET	0x3000
+#define OV5640_2_REG_FW_START	0x8000
+#define OV5640_2_REG_FOCUS_MODE	0x3022	/* focus mode reg */
+#define OV5640_2_REG_FOCUS_ZONE_X	0x3024	/* X coordinate of focus zone center */
+#define OV5640_2_REG_FOCUS_ZONE_Y	0x3025	/* Y coordinate of focus zone center */
+#define OV5640_2_REG_FOCUS_STATUS	0x3029	/* focus status reg */
+
+/* system pll control reg */
+#define OV5640_2_REG_PLL_CTRL_0	0x3034
+#define OV5640_2_REG_PLL_CTRL_1	0x3035
+#define OV5640_2_REG_PLL_CTRL_2	0x3036
+#define OV5640_2_REG_PLL_CTRL_3	0x3037
+
+/* pad clock divider for SCCB clock */
+#define OV5640_2_REG_CLK_DIVIDER	0x3108
+
+/* total horizontal size reg */
+#define OV5640_2_REG_TIMING_HTS	0x380c
+
+/* total vertical size reg */
+#define OV5640_2_REG_TIMING_VTS	0x380e
+
+/* exposure output reg */
+#define OV5640_2_REG_EXPOSURE_0	0x3500
+#define OV5640_2_REG_EXPOSURE_1	0x3502
+
+/* gain reg */
+#define OV5640_2_REG_GAIN	0x350a
+
+/* light frequency control reg */
+#define OV5640_2_REG_LIGHT_CTRL_0	0x3c01
+#define OV5640_2_REG_LIGHT_CTRL_1	0x3c00
+#define OV5640_2_REG_LIGHT_CTRL_2	0x3c0c
+
+/* light frequency */
+#define OV5640_2_LIGHT_50HZ	50
+#define OV5640_2_LIGHT_60HZ	60
+
+/* automatic banding filter */
+#define OV5640_2_AUTO_BAND	0x80
+
+/* 60HZ band step reg and 60HZ max bands */
+#define OV5640_2_REG_B60_STEP	0x3a0a
+#define OV5640_2_REG_B60_MAX	0x3a0d
+
+/* 50HZ band step reg and 50HZ max bands */
+#define OV5640_2_REG_B50_STEP	0x3a08
+#define OV5640_2_REG_B50_MAX	0x3a0e
+
+/* AEC domain control reg */
+#define OV5640_2_REG_AE_STAB_IN_H	0x3a0f	/* stable in high */
+#define OV5640_2_REG_AE_STAB_IN_L	0x3a10	/* stable in low */
+#define OV5640_2_REG_AE_STAB_OUT_H	0x3a1b	/* stable out high */
+#define OV5640_2_REG_AE_STAB_OUT_L	0x3a1e	/* stable out low */
+#define OV5640_2_REG_AE_FAST_H	0x3a11	/* fast zone high */
+#define OV5640_2_REG_AE_FAST_L	0x3a1f	/* fast zone low */
+
+/* AEC mode control reg */
+#define OV5640_2_REG_AE_MODE_CTRL	0x3503
+
+#define OV5640_2_AUTO_AG_AE	0x00	/* auto AG&AE */
+#define OV5640_2_MANUAL_AG_AE	0x03	/* manual AG&AE */
+
+/* AEC system control reg */
+#define OV5640_2_REG_AE_SYS_CTRL	0x3a00
+
+/* image exposure average readout reg */
+#define OV5640_2_REG_AE_AVERAGE	0x56a1
+
+/* frame control reg */
+#define OV5640_2_REG_FRAME_CTRL	0x4202
+
+#define OV5640_2_FRAME_START	0x00
+#define OV5640_2_FRAME_STOP	0x0f
+
+#define OV5640_2_MCU_RESET	0x20
+#define OV5640_2_SINGLE_FOCUS	0x03
+#define OV5640_2_CONTINUE_FOCUS	0x04
+#define OV5640_2_PAUSE_FOCUS	0x06
+#define OV5640_2_RELEASE_FOCUS	0x08
+#define OV5640_2_RELAUNCH_FOCUS	0x12
+#define OV5640_2_S_FOCUS_ZONE	0x81
+
+/* focus firmware is downloaded but not to be initialized */
+#define OV5640_2_FOCUS_FW_DL	0x7f
+#define OV5640_2_FOCUS_FW_INIT	0x7e	/* focus firmware is initializing */
+#define OV5640_2_FOCUS_FW_IDLE	0x70	/* focus firmware is idle */
+#define OV5640_2_FOCUS_FW_RUN	0x00	/* focus firmware is running */
+#define OV5640_2_FOCUS_FW_FINISH	0x10	/* focus is finished */
+
+#define OV5640_2_REG_AWB_CTRL	0x3406
+
+#define OV5640_2_AWB_GAIN_AUTO	0
+#define OV5640_2_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV5640_2_DEVICE_ID */
+#define OV5640_2_MOD_ID		0x5640
+
+#define AF_FW_PATH	"OV5640_AF_FW.bin"
+
+/* Supported resolutions */
+enum {
+	OV5640_2_RES_QVGA,
+	OV5640_2_RES_DVGA,
+	OV5640_2_RES_320P,
+	OV5640_2_RES_360P,
+	OV5640_2_RES_VGA,
+	OV5640_2_RES_RGB_VGA,
+	OV5640_2_RES_480P,
+	OV5640_2_RES_736x480P,	
+	OV5640_2_RES_800x480P,
+	OV5640_2_RES_720P,
+	OV5640_2_RGB565_RES_720P,
+	OV5640_2_RES_1440X720P,
+	OV5640_2_RES_1080P,
+	OV5640_2_RES_1080P_RGB,
+	OV5640_2_RES_1088P,
+	OV5640_2_RES_D3M,
+	OV5640_2_RES_3M,
+	OV5640_2_RES_D5M,
+	OV5640_2_RES_5M,
+};
+#define OV5640_2_RES_5M_SIZE_H		2560
+#define OV5640_2_RES_5M_SIZE_V		1920
+#define OV5640_2_RES_D5M_SIZE_H		2496
+#define OV5640_2_RES_D5M_SIZE_V		1664
+#define OV5640_2_RES_D3M_SIZE_H		2112
+#define OV5640_2_RES_D3M_SIZE_V		1408
+#define OV5640_2_RES_3M_SIZE_H		2048
+#define OV5640_2_RES_3M_SIZE_V		1536
+#define OV5640_2_RES_1088P_SIZE_H		1920
+#define OV5640_2_RES_1088P_SIZE_V		1088
+#define OV5640_2_RES_1080P_SIZE_H		1920
+#define OV5640_2_RES_1080P_SIZE_V		1080
+#define OV5640_2_RES_720P_SIZE_H		1280
+#define OV5640_2_RES_720P_SIZE_V		720
+
+#define OV5640_2_RGB565_RES_720P_SIZE_H		1280
+#define OV5640_2_RGB565_RES_720P_SIZE_V		720
+
+#define OV5640_2_RES_1440X720P_SIZE_H		1440
+#define OV5640_2_RES_1440X720P_SIZE_V		720
+
+#define OV5640_2_RES_480P_SIZE_H		720
+#define OV5640_2_RES_480P_SIZE_V		480
+
+#define OV5640_2_RES_736x480P_SIZE_H		736
+#define OV5640_2_RES_736x480P_SIZE_V		480
+
+#define OV5640_2_RES_VGA_SIZE_H		640
+#define OV5640_2_RES_VGA_SIZE_V		480
+#define OV5640_2_RES_360P_SIZE_H		640
+#define OV5640_2_RES_360P_SIZE_V		360
+#define OV5640_2_RES_320P_SIZE_H		480
+#define OV5640_2_RES_320P_SIZE_V		320
+#define OV5640_2_RES_DVGA_SIZE_H		416
+#define OV5640_2_RES_DVGA_SIZE_V		312
+#define OV5640_2_RES_QVGA_SIZE_H		320
+#define OV5640_2_RES_QVGA_SIZE_V		240
+
+#define OV5640_2_RES_800x480P_SIZE_H		800
+#define OV5640_2_RES_800x480P_SIZE_V		480
+
+
+/* TODO: Definition not available in kernel 3.5 */
+/* Current composing area */
+#define V4L2_SEL_TGT_COMPOSE            0x0100
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5640_2_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int res;
+};
+
+struct ov5640_2_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov5640_2_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov5640_2_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int code;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV5640_2_MAX_WRITE_BUF_SIZE	32
+struct ov5640_2_write_buffer {
+	u16 addr;
+	u8 data[OV5640_2_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5640_2_write_ctrl {
+	int index;
+	struct ov5640_2_write_buffer buffer;
+};
+
+struct ov5640_2_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define N_ov5640_2_FMTS ARRAY_SIZE(ov5640_2_formats)
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct ov5640_2_res_struct ov5640_2_res[] = {
+	{
+	.desc	= "QVGA",
+	.res	= OV5640_2_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "DVGA",
+	.res	= OV5640_2_RES_DVGA,
+	.width	= 416,
+	.height	= 312,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "320P",
+	.res	= OV5640_2_RES_320P,
+	.width	= 480,
+	.height	= 320,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "360P",
+	.res	= OV5640_2_RES_360P,
+	.width	= 640,
+	.height	= 360,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 5,
+	},
+	{
+	.desc	= "VGA",
+	.res	= OV5640_2_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "VGA_RGB",
+		.res	= OV5640_2_RES_RGB_VGA,
+		.width	= 640,
+		.height	= 480,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "480P",
+	.res	= OV5640_2_RES_480P,
+	.width	= 720,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "736x480P",
+	.res	= OV5640_2_RES_736x480P,
+	.width	= 736,
+	.height	= 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "800x480p",
+	.res	= OV5640_2_RES_800x480P,
+	.width	= 800,
+	.height = 480,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "720p",
+	.res	= OV5640_2_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	
+	{
+	.desc	= "RGB565_720p",
+	.res	= OV5640_2_RGB565_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x1008,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	
+	{
+	.desc	= "1440x720p",
+	.res	= OV5640_2_RES_1440X720P,
+	.width	= 1440,
+	.height	= 720,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1080P",
+	.res	= OV5640_2_RES_1080P,
+	.width	= 1920,
+	.height	= 1080,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "1080P",
+		.res	= OV5640_2_RES_1080P_RGB,
+		.width	= 1920,
+		.height	= 1080,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "1088P",
+	.res	= OV5640_2_RES_1088P,
+	.width	= 1920,
+	.height	= 1088,
+	.code = 0x8003,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D3M",
+	.res	= OV5640_2_RES_D3M,
+	.width	= 2112,
+	.height	= 1408,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "3M",
+	.res	= OV5640_2_RES_3M,
+	.width	= 2048,
+	.height	= 1536,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D5M",
+	.res	= OV5640_2_RES_D5M,
+	.width	= 2496,
+	.height	= 1664,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "5M",
+	.res	= OV5640_2_RES_5M,
+	.width	= 2560,
+	.height	= 1920,
+	.code = 0x8003,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+};
+#define N_RES (ARRAY_SIZE(ov5640_2_res))
+
+static const struct i2c_device_id ov5640_2_id[] = {
+	{"ov5640-2", 0},
+	{}
+};
+
+static struct misensor_reg const ov5640_2_standby_reg[] = {
+	 {MISENSOR_8BIT,  0x300e, 0x5d},
+	 {MISENSOR_8BIT,  0x3008, 0x42},	/* software powerdown */
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_wakeup_reg[] = {
+	{MISENSOR_8BIT,  0x3008, 0x02},
+	{MISENSOR_8BIT,  0x300e, 0x45},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_normal_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x06},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_sepia_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0xA0},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_negative_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x46},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_bw_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x80},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x80},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_blue_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0xA0},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x40},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_green_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x60},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x60},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 5M, yuv422, 2lanes, mipi, 12fps */
+static struct misensor_reg const ov5640_2_5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x0A},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2560 */
+	{MISENSOR_8BIT, 0x380A, 0x07},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1920 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x06},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x08},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xB4},	/* total H-size is 2740 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xE8},	/* total v-size is 2024 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xE4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xE4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x2F},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFD},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D5M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_D5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x09},
+	{MISENSOR_8BIT, 0x3809, 0xC0},	/* DVP output H_width, value is 2496 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1664 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2048 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x00},	/* DVP output V_heigh, value is 1536 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xA0},	/* total H-size is 2720 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xF6},	/* total v-size is 2038 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xF2},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xF2},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x31},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFE},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_D3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x40},	/* DVP output H_width, value is 2112 */
+	{MISENSOR_8BIT, 0x380A, 0x05},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1408 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xB0},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xB0},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1088p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1088p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06}, /* disable binning */
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of isp input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF9},	/* Y end of isp input size */
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* 1920 */
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x40},	/* 1088 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0x60},
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0x60},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1080p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, rgb565, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1080p_rgb[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+	{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 720p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_720p_init[] = {
+#ifdef ORIGINAL_SETTINGS  
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x05},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x02},
+	{MISENSOR_8BIT, 0x380B, 0xD0},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x97},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x53},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling*/
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},	/* same with 1080p */
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x18},	/* total H-size is 2328 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xA8},	/* total v-size is 1192 */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x66},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2A},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xA4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xA4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else  /* FROM JOSH @OV.COM */
+	/* YUV 1280x720, mclk 19.2mhz 60 fps */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+#endif
+  
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_480p_init[] = {
+#ifdef ORIGINAL_SETTINGS  
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x04},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x3F},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0xD9},
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x0B},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else
+#if 0
+	/* from josh @ov.com */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x22},/*0x21*/
+	{MISENSOR_8BIT,0x3036,0x8c},/*mclk=19.2MHz,0x70*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0x3a},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x07},
+	{MISENSOR_8BIT,0x3807,0x67},
+	{MISENSOR_8BIT,0x3808,0x02},
+	{MISENSOR_8BIT,0x3809,0xd0},
+	{MISENSOR_8BIT,0x380a,0x01},
+	{MISENSOR_8BIT,0x380b,0xe0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x68},
+	{MISENSOR_8BIT,0x380e,0x03},
+	{MISENSOR_8BIT,0x380f,0xd8},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x06},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x03},
+	{MISENSOR_8BIT,0x3a03,0xd8},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x27},
+	{MISENSOR_8BIT,0x3a0a,0x00},
+	{MISENSOR_8BIT,0x3a0b,0xf6},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x03},
+	{MISENSOR_8BIT,0x3a15,0xd8},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x22, *0x10*/},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0xa3},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+#endif
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+
+#endif
+
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_736x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+/* camera: 320p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_320p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xE0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x40},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x0B},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera: 360p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_360p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x68},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x02},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x4837, 0x2C},	/* PCLK PERIOD */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x05},	/* total H-size is 2309 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total v-size is 1200*/
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x68},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera vga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_vga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera vga 30fps, rgb(640x480),----- 2lanes */
+static struct misensor_reg const ov5640_2_vga_rgb_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+		{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera qvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_qvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0x40},
+	{MISENSOR_8BIT, 0x380A, 0x00},
+	{MISENSOR_8BIT, 0x380B, 0xF0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera dvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_dvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xA0},	/* DVP output, value is 416 */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x38},	/* DVP output, value is 312 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x31},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_init[] = {
+	/* init software */
+	{MISENSOR_8BIT, 0x3103, 0x11},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x82},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x42},	/* software power down */
+	{MISENSOR_8BIT, 0x3103, 0x03},	/* SCCB system control */
+	/* set Frex Vsync href PCLK D[9:6} input */
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},	/* set d[5:0] GPIO[1:0] input */
+	{MISENSOR_8BIT, 0x3034, 0x18},	/* MIPI 8-bit mode*/
+	{MISENSOR_8BIT, 0x3037, 0x13},	/* PLL */
+	{MISENSOR_8BIT, 0x3108, 0x01},	/* system divider */
+	{MISENSOR_8BIT, 0x3630, 0x36},
+	{MISENSOR_8BIT, 0x3631, 0x0E},
+	{MISENSOR_8BIT, 0x3632, 0xE2},
+	{MISENSOR_8BIT, 0x3633, 0x12},
+	{MISENSOR_8BIT, 0x3621, 0xE0},
+	{MISENSOR_8BIT, 0x3704, 0xA0},
+	{MISENSOR_8BIT, 0x3703, 0x5A},
+	{MISENSOR_8BIT, 0x3715, 0x78},
+	{MISENSOR_8BIT, 0x3717, 0x01},
+	{MISENSOR_8BIT, 0x370B, 0x60},
+	{MISENSOR_8BIT, 0x3705, 0x1A},
+	{MISENSOR_8BIT, 0x3905, 0x02},
+	{MISENSOR_8BIT, 0x3906, 0x10},
+	{MISENSOR_8BIT, 0x3901, 0x0A},
+	{MISENSOR_8BIT, 0x3731, 0x12},
+	{MISENSOR_8BIT, 0x3600, 0x08},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x3601, 0x33},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x302D, 0x60},	/* system control */
+	{MISENSOR_8BIT, 0x3620, 0x52},
+	{MISENSOR_8BIT, 0x371B, 0x20},
+	{MISENSOR_8BIT, 0x471C, 0x50},
+	{MISENSOR_8BIT, 0x3A13, 0x43},	/* AGC pre-gain 40 = 1x */
+	{MISENSOR_8BIT, 0x3A18, 0x00},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3A19, 0xF8},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3635, 0x13},
+	{MISENSOR_8BIT, 0x3636, 0x03},
+	{MISENSOR_8BIT, 0x3634, 0x40},
+	{MISENSOR_8BIT, 0x3622, 0x01},
+	{MISENSOR_8BIT, 0x3C00, 0x04},	/* 50Hz/60Hz */
+	{MISENSOR_8BIT, 0x3C01, 0xB4},	/* 50/60Hz */
+	{MISENSOR_8BIT, 0x3C04, 0x28},	/* threshold for low sum */
+	{MISENSOR_8BIT, 0x3C05, 0x98},	/* threshold for high sum */
+	{MISENSOR_8BIT, 0x3C06, 0x00},	/* light meter 1 threshold high */
+	{MISENSOR_8BIT, 0x3C08, 0x00},	/* light meter 2 threshold high */
+	{MISENSOR_8BIT, 0x3C09, 0x1C},	/* light meter 2 threshold low */
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},	/* sample number high */
+	{MISENSOR_8BIT, 0x3C0B, 0x40},	/* sample number low */
+	/* timing */
+	{MISENSOR_8BIT, 0x3800, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3802, 0x00},	/* VS */
+	{MISENSOR_8BIT, 0x3804, 0x0A},	/* HW */
+	{MISENSOR_8BIT, 0x3805, 0x3F},	/* HW */
+	{MISENSOR_8BIT, 0x3810, 0x00},	/* H offset high */
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* H offset low */
+	{MISENSOR_8BIT, 0x3812, 0x00},	/* V offset high */
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3A08, 0x01},	/* B50 */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset 0 */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},	/* system reset 2 */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* clock enable 00 */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* clock enable 2 */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI control 2 lane MIPI on */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},	/* YUV 422 UYVY */
+	{MISENSOR_8BIT, 0x501F, 0x00},	/* ISP YUV 422 */
+	{MISENSOR_8BIT, 0x4407, 0x04},	/* JPEG QS */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	/* ISP control LENC on GAMMA on BPC on WPC on CIP on */
+	{MISENSOR_8BIT, 0x5000, 0xA7},
+	/* AWB */
+	{MISENSOR_8BIT, 0x5180, 0xFF},
+	{MISENSOR_8BIT, 0x5181, 0xF2},
+	{MISENSOR_8BIT, 0x5182, 0x00},
+	{MISENSOR_8BIT, 0x5183, 0x14},
+	{MISENSOR_8BIT, 0x5184, 0x25},
+	{MISENSOR_8BIT, 0x5185, 0x24},
+	{MISENSOR_8BIT, 0x5189, 0x8D},
+	{MISENSOR_8BIT, 0x518A, 0x61},
+	{MISENSOR_8BIT, 0x518C, 0x94},
+	{MISENSOR_8BIT, 0x518B, 0xAF},
+	{MISENSOR_8BIT, 0x5187, 0x17},
+	{MISENSOR_8BIT, 0x5188, 0x0F},
+	{MISENSOR_8BIT, 0x518D, 0x41},
+	{MISENSOR_8BIT, 0x518F, 0x75},
+	{MISENSOR_8BIT, 0x518E, 0x34},
+	{MISENSOR_8BIT, 0x5190, 0x43},
+	{MISENSOR_8BIT, 0x5191, 0xF5},
+	{MISENSOR_8BIT, 0x5192, 0x0A},
+	{MISENSOR_8BIT, 0x5186, 0x16},
+	{MISENSOR_8BIT, 0x5193, 0x70},
+	{MISENSOR_8BIT, 0x5194, 0xF0},
+	{MISENSOR_8BIT, 0x5195, 0xF0},
+	{MISENSOR_8BIT, 0x5196, 0x03},
+	{MISENSOR_8BIT, 0x5197, 0x01},
+	{MISENSOR_8BIT, 0x5198, 0x05},
+	{MISENSOR_8BIT, 0x5199, 0xDB},
+	{MISENSOR_8BIT, 0x519A, 0x04},
+	{MISENSOR_8BIT, 0x519B, 0x00},
+	{MISENSOR_8BIT, 0x519C, 0x08},
+	{MISENSOR_8BIT, 0x519D, 0x20},
+	{MISENSOR_8BIT, 0x519E, 0x38},
+	/* color matrix */
+	{MISENSOR_8BIT, 0x5381, 0x1F},
+	{MISENSOR_8BIT, 0x5382, 0x5C},
+	{MISENSOR_8BIT, 0x5383, 0x05},
+	{MISENSOR_8BIT, 0x5384, 0x03},
+	{MISENSOR_8BIT, 0x5385, 0x6C},
+	{MISENSOR_8BIT, 0x5386, 0x6F},
+	{MISENSOR_8BIT, 0x5387, 0x6E},
+	{MISENSOR_8BIT, 0x5388, 0x62},
+	{MISENSOR_8BIT, 0x5389, 0x0C},
+	{MISENSOR_8BIT, 0x538A, 0x01},
+	{MISENSOR_8BIT, 0x538B, 0x98},
+	/* CIP */
+	{MISENSOR_8BIT, 0x5300, 0x08},	/* sharpen MT th1 */
+	{MISENSOR_8BIT, 0x5301, 0x30},	/* sharpen MT th2 */
+	{MISENSOR_8BIT, 0x5302, 0x18},	/* sharpen MT offset 1 */
+	{MISENSOR_8BIT, 0x5303, 0x0E},	/* sharpen MT offset 2 */
+	{MISENSOR_8BIT, 0x5304, 0x08},	/* DNS threshold 1 */
+	{MISENSOR_8BIT, 0x5305, 0x30},	/* DNS threshold 2 */
+	{MISENSOR_8BIT, 0x5306, 0x08},	/* DNS offset 1 */
+	{MISENSOR_8BIT, 0x5307, 0x16},	/* DNS offset 2 */
+	{MISENSOR_8BIT, 0x5308, 0x00},	/* auto de-noise */
+	{MISENSOR_8BIT, 0x5309, 0x08},	/* sharpen TH th1 */
+	{MISENSOR_8BIT, 0x530A, 0x30},	/* sharpen TH th2 */
+	{MISENSOR_8BIT, 0x530B, 0x04},	/* sharpen TH offset 1 */
+	{MISENSOR_8BIT, 0x530C, 0x06},	/* sharpen TH offset 2 */
+	/* gamma */
+	{MISENSOR_8BIT, 0x5480, 0x01},
+	{MISENSOR_8BIT, 0x5481, 0x08},
+	{MISENSOR_8BIT, 0x5482, 0x14},
+	{MISENSOR_8BIT, 0x5483, 0x28},
+	{MISENSOR_8BIT, 0x5484, 0x51},
+	{MISENSOR_8BIT, 0x5485, 0x65},
+	{MISENSOR_8BIT, 0x5486, 0x71},
+	{MISENSOR_8BIT, 0x5487, 0x7D},
+	{MISENSOR_8BIT, 0x5488, 0x87},
+	{MISENSOR_8BIT, 0x5489, 0x91},
+	{MISENSOR_8BIT, 0x548A, 0x9A},
+	{MISENSOR_8BIT, 0x548B, 0xAA},
+	{MISENSOR_8BIT, 0x548C, 0xB8},
+	{MISENSOR_8BIT, 0x548D, 0xCD},
+	{MISENSOR_8BIT, 0x548E, 0xDD},
+	{MISENSOR_8BIT, 0x548F, 0xEA},
+	{MISENSOR_8BIT, 0x5490, 0x1D},
+	/* UV adjust */
+	{MISENSOR_8BIT, 0x5580, 0x06},	/* sat on contrast on */
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat VV */
+	{MISENSOR_8BIT, 0x5589, 0x10},	/* UV adjust th1 */
+	{MISENSOR_8BIT, 0x558A, 0x00},	/* UV adjust th2[8] */
+	{MISENSOR_8BIT, 0x558B, 0xF8},	/* UV adjust th2[7:0] */
+	{MISENSOR_8BIT, 0x501D, 0x40},	/* enable manual offset of contrast */
+	/* lens correction */
+	{MISENSOR_8BIT, 0x5800, 0x3D},
+	{MISENSOR_8BIT, 0x5801, 0x1E},
+	{MISENSOR_8BIT, 0x5802, 0x15},
+	{MISENSOR_8BIT, 0x5803, 0x17},
+	{MISENSOR_8BIT, 0x5804, 0x1E},
+	{MISENSOR_8BIT, 0x5805, 0x3F},
+	{MISENSOR_8BIT, 0x5806, 0x10},
+	{MISENSOR_8BIT, 0x5807, 0x0A},
+	{MISENSOR_8BIT, 0x5808, 0x07},
+	{MISENSOR_8BIT, 0x5809, 0x07},
+	{MISENSOR_8BIT, 0x580A, 0x0B},
+	{MISENSOR_8BIT, 0x580B, 0x13},
+	{MISENSOR_8BIT, 0x580C, 0x0A},
+	{MISENSOR_8BIT, 0x580D, 0x04},
+	{MISENSOR_8BIT, 0x580E, 0x00},
+	{MISENSOR_8BIT, 0x580F, 0x00},
+	{MISENSOR_8BIT, 0x5810, 0x04},
+	{MISENSOR_8BIT, 0x5811, 0x0C},
+	{MISENSOR_8BIT, 0x5812, 0x0A},
+	{MISENSOR_8BIT, 0x5813, 0x04},
+	{MISENSOR_8BIT, 0x5814, 0x00},
+	{MISENSOR_8BIT, 0x5815, 0x00},
+	{MISENSOR_8BIT, 0x5816, 0x04},
+	{MISENSOR_8BIT, 0x5817, 0x0C},
+	{MISENSOR_8BIT, 0x5818, 0x10},
+	{MISENSOR_8BIT, 0x5819, 0x0B},
+	{MISENSOR_8BIT, 0x581A, 0x07},
+	{MISENSOR_8BIT, 0x581B, 0x07},
+	{MISENSOR_8BIT, 0x581C, 0x0A},
+	{MISENSOR_8BIT, 0x581D, 0x14},
+	{MISENSOR_8BIT, 0x581E, 0x37},
+	{MISENSOR_8BIT, 0x581F, 0x1F},
+	{MISENSOR_8BIT, 0x5820, 0x18},
+	{MISENSOR_8BIT, 0x5821, 0x18},
+	{MISENSOR_8BIT, 0x5822, 0x1F},
+	{MISENSOR_8BIT, 0x5823, 0x2F},
+	{MISENSOR_8BIT, 0x5824, 0x48},
+	{MISENSOR_8BIT, 0x5825, 0x2A},
+	{MISENSOR_8BIT, 0x5826, 0x2C},
+	{MISENSOR_8BIT, 0x5827, 0x08},
+	{MISENSOR_8BIT, 0x5828, 0x66},
+	{MISENSOR_8BIT, 0x5829, 0x0A},
+	{MISENSOR_8BIT, 0x582A, 0x26},
+	{MISENSOR_8BIT, 0x582B, 0x24},
+	{MISENSOR_8BIT, 0x582C, 0x26},
+	{MISENSOR_8BIT, 0x582D, 0x08},
+	{MISENSOR_8BIT, 0x582E, 0x08},
+	{MISENSOR_8BIT, 0x582F, 0x42},
+	{MISENSOR_8BIT, 0x5830, 0x40},
+	{MISENSOR_8BIT, 0x5831, 0x22},
+	{MISENSOR_8BIT, 0x5832, 0x06},
+	{MISENSOR_8BIT, 0x5833, 0x0A},
+	{MISENSOR_8BIT, 0x5834, 0x24},
+	{MISENSOR_8BIT, 0x5835, 0x24},
+	{MISENSOR_8BIT, 0x5836, 0x26},
+	{MISENSOR_8BIT, 0x5837, 0x06},
+	{MISENSOR_8BIT, 0x5838, 0x48},
+	{MISENSOR_8BIT, 0x5839, 0x08},
+	{MISENSOR_8BIT, 0x583A, 0x28},
+	{MISENSOR_8BIT, 0x583B, 0x06},
+	{MISENSOR_8BIT, 0x583C, 0x4A},
+	{MISENSOR_8BIT, 0x583D, 0xCE},
+	/* AE */
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	{MISENSOR_8BIT, 0x3A0F, 0x30},	/* stable in high */
+	{MISENSOR_8BIT, 0x3A10, 0x28},	/* stable in low */
+	{MISENSOR_8BIT, 0x3A1B, 0x30},	/* stable out high */
+	{MISENSOR_8BIT, 0x3A1E, 0x26},	/* stable out low */
+	{MISENSOR_8BIT, 0x3A11, 0x60},	/* fast zone high */
+	{MISENSOR_8BIT, 0x3A1F, 0x14},	/* fast zone low */
+	{MISENSOR_8BIT, 0x350A, 0x00},
+	{MISENSOR_8BIT, 0x350B, 0x32},	/* default gain 50 */
+	{MISENSOR_8BIT, 0x3500, 0x00},
+	{MISENSOR_8BIT, 0x3501, 0x03},
+	{MISENSOR_8BIT, 0x3502, 0xE8},	/* default shutter 1000 */
+	/* BLC */
+	{MISENSOR_8BIT, 0x4000, 0x89},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4002, 0x45},
+	{MISENSOR_8BIT, 0x4003, 0x08},
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	{MISENSOR_8BIT, 0x4009, 0x10},
+	{MISENSOR_8BIT, 0x4202, 0x00},	/* stream on */
+	{MISENSOR_8BIT, 0x4202, 0x0F},	/* stream off */
+	{MISENSOR_8BIT, 0x3008, 0x02},	/* wake up */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_focus_init[] = {
+	{MISENSOR_8BIT, 0x3022, 0x00},
+	{MISENSOR_8BIT, 0x3023, 0x00},
+	{MISENSOR_8BIT, 0x3024, 0x00},
+	{MISENSOR_8BIT, 0x3025, 0x00},
+	{MISENSOR_8BIT, 0x3026, 0x00},
+	{MISENSOR_8BIT, 0x3027, 0x00},
+	{MISENSOR_8BIT, 0x3028, 0x00},
+	{MISENSOR_8BIT, 0x3029, 0x7F},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_800x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x03},
+	{MISENSOR_8BIT, 0x3809, 0x20},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};	
+
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_rgb565_1280x720p_init[] = { 
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x6f /*0x32*/},
+	{MISENSOR_8BIT,0x501f,0x01 /*0x00*/},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};	
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_1440x720p_init[] = {
+
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*mclk=19.2MHz*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x40},
+	{MISENSOR_8BIT,0x3821,0x06},
+	{MISENSOR_8BIT,0x3814,0x11},
+	{MISENSOR_8BIT,0x3815,0x11},
+	{MISENSOR_8BIT,0x3800,0x02},
+	{MISENSOR_8BIT,0x3801,0x40},
+	{MISENSOR_8BIT,0x3802,0x02},
+	{MISENSOR_8BIT,0x3803,0x66},
+	{MISENSOR_8BIT,0x3804,0x07},
+	{MISENSOR_8BIT,0x3805,0xff},
+	{MISENSOR_8BIT,0x3806,0x05},
+	{MISENSOR_8BIT,0x3807,0x3d},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0xa0},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x0a}, /*09*/
+	{MISENSOR_8BIT,0x380d,0x58}, /*c8*/
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x04},
+	{MISENSOR_8BIT,0x3612,0x2b},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x12},
+	{MISENSOR_8BIT,0x370c,0x00},
+	{MISENSOR_8BIT,0x3a02,0x04},
+	{MISENSOR_8BIT,0x3a03,0x60},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x50},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x18},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x04},
+	{MISENSOR_8BIT,0x3a15,0x60},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x06},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0a},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+#endif
diff --git a/include/linux/atomisp.h b/include/linux/atomisp.h
new file mode 100644
index 0000000..a1e77b3
--- /dev/null
+++ b/include/linux/atomisp.h
@@ -0,0 +1,901 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ATOM_ISP_H
+#define _ATOM_ISP_H
+
+#include <linux/types.h>
+#include <linux/version.h>
+
+#define ATOMISP_CSS_VERSION_15	KERNEL_VERSION(1, 5, 0)
+#define ATOMISP_CSS_VERSION_17	KERNEL_VERSION(1, 7, 0)
+#define ATOMISP_CSS_VERSION_20	KERNEL_VERSION(2, 0, 0)
+
+/*ISP binary running mode*/
+#define CI_MODE_PREVIEW		0x8000
+#define CI_MODE_VIDEO		0x4000
+#define CI_MODE_STILL_CAPTURE	0x2000
+#define CI_MODE_CONTINUOUS	0x1000
+#define CI_MODE_NONE		0x0000
+
+#define OUTPUT_MODE_FILE 0x0100
+#define OUTPUT_MODE_TEXT 0x0200
+
+//uncomment the below line to see timestamps for the important functions
+//#define TIMING
+
+#ifdef TIMING
+        #define TIMING_ENTER printk("TIMING: %s: ENTRY \n", __func__);
+        #define TIMING_END printk("TIMING: %s: EXIT \n", __func__);
+#else
+        #define TIMING_ENTER
+        #define TIMING_END
+#endif
+
+/* Configuration used by Bayer noise reduction and YCC noise reduction */
+struct atomisp_nr_config {
+	/* [gain] Strength of noise reduction for Bayer NR (Used by Bayer NR) */
+	unsigned int bnr_gain;
+	/* [gain] Strength of noise reduction for YCC NR (Used by YCC NR) */
+	unsigned int ynr_gain;
+	/* [intensity] Sensitivity of Edge (Used by Bayer NR) */
+	unsigned int direction;
+	/* [intensity] coring threshold for Cb (Used by YCC NR) */
+	unsigned int threshold_cb;
+	/* [intensity] coring threshold for Cr (Used by YCC NR) */
+	unsigned int threshold_cr;
+};
+
+/* Temporal noise reduction configuration */
+struct atomisp_tnr_config {
+	unsigned int gain;	 /* [gain] Strength of NR */
+	unsigned int threshold_y;/* [intensity] Motion sensitivity for Y */
+	unsigned int threshold_uv;/* [intensity] Motion sensitivity for U/V */
+};
+
+/* Histogram. This contains num_elements values of type unsigned int.
+ * The data pointer is a DDR pointer (virtual address).
+ */
+struct atomisp_histogram {
+	unsigned int num_elements;
+	void __user *data;
+};
+
+enum atomisp_ob_mode {
+	atomisp_ob_mode_none,
+	atomisp_ob_mode_fixed,
+	atomisp_ob_mode_raster
+};
+
+/* Optical black level configuration */
+struct atomisp_ob_config {
+	/* Obtical black level mode (Fixed / Raster) */
+	enum atomisp_ob_mode mode;
+	/* [intensity] optical black level for GR (relevant for fixed mode) */
+	unsigned int level_gr;
+	/* [intensity] optical black level for R (relevant for fixed mode) */
+	unsigned int level_r;
+	/* [intensity] optical black level for B (relevant for fixed mode) */
+	unsigned int level_b;
+	/* [intensity] optical black level for GB (relevant for fixed mode) */
+	unsigned int level_gb;
+	/* [BQ] 0..63 start position of OB area (relevant for raster mode) */
+	unsigned short start_position;
+	/* [BQ] start..63 end position of OB area (relevant for raster mode) */
+	unsigned short end_position;
+};
+
+/* Edge enhancement (sharpen) configuration */
+struct atomisp_ee_config {
+	/* [gain] The strength of sharpness. u5_11 */
+	unsigned int gain;
+	/* [intensity] The threshold that divides noises from edge. u8_8 */
+	unsigned int threshold;
+	/* [gain] The strength of sharpness in pell-mell area. u5_11 */
+	unsigned int detail_gain;
+};
+
+struct atomisp_3a_output {
+	int ae_y;
+	int awb_cnt;
+	int awb_gr;
+	int awb_r;
+	int awb_b;
+	int awb_gb;
+	int af_hpf1;
+	int af_hpf2;
+};
+
+enum atomisp_calibration_type {
+	calibration_type1,
+	calibration_type2,
+	calibration_type3
+};
+
+struct atomisp_calibration_group {
+	unsigned int size;
+	unsigned int type;
+	unsigned short *calb_grp_values;
+};
+
+struct atomisp_gc_config {
+	__u16 gain_k1;
+	__u16 gain_k2;
+};
+
+struct atomisp_3a_config {
+	unsigned int ae_y_coef_r;	/* [gain] Weight of R for Y */
+	unsigned int ae_y_coef_g;	/* [gain] Weight of G for Y */
+	unsigned int ae_y_coef_b;	/* [gain] Weight of B for Y */
+	unsigned int awb_lg_high_raw;	/* [intensity]
+					   AWB level gate high for raw */
+	unsigned int awb_lg_low;	/* [intensity] AWB level gate low */
+	unsigned int awb_lg_high;	/* [intensity] AWB level gate high */
+	int af_fir1_coef[7];	/* [factor] AF FIR coefficients of fir1 */
+	int af_fir2_coef[7];	/* [factor] AF FIR coefficients of fir2 */
+};
+
+/* structure that describes the 3A and DIS grids shared with 3A lib*/
+struct atomisp_grid_info {
+	/* ISP input size that is visible for user */
+	unsigned int isp_in_width;
+	unsigned int isp_in_height;
+	/* 3A statistics grid: */
+	unsigned int s3a_width;
+	unsigned int s3a_height;
+	unsigned int s3a_bqs_per_grid_cell;
+	/* DIS grid: */
+	unsigned int dis_width;  /* also used for vertical projections */
+	unsigned int dis_aligned_width;
+	unsigned int dis_height; /* also used for horizontal projections */
+	unsigned int dis_aligned_height;
+	unsigned int dis_bqs_per_grid_cell;
+	unsigned int dis_hor_coef_num;
+	unsigned int dis_ver_coef_num;
+};
+
+struct atomisp_dis_vector {
+	int x;
+	int y;
+};
+
+struct atomisp_dis_coefficients {
+	struct atomisp_grid_info grid_info;
+	short __user *vertical_coefficients;
+	short __user *horizontal_coefficients;
+};
+
+struct atomisp_dis_statistics {
+	struct atomisp_grid_info grid_info;
+	int __user *vertical_projections;
+	int __user *horizontal_projections;
+};
+
+struct atomisp_3a_statistics {
+	struct atomisp_grid_info  grid_info;
+	struct atomisp_3a_output __user *data;
+};
+
+/**
+ * struct atomisp_cont_capture_conf - continuous capture parameters
+ * @num_captures: number of still images to capture
+ * @skip_frames: number of frames to skip between 2 captures
+ * @offset: offset in ring buffer to start capture
+ *
+ * For example, to capture 1 frame from past, current, and 1 from future
+ * and skip one frame between each capture, parameters would be:
+ * num_captures:3
+ * skip_frames:1
+ * offset:-2
+ */
+
+struct atomisp_cont_capture_conf {
+	int num_captures;
+	unsigned int skip_frames;
+	int offset;
+	__u32 reserved[5];
+};
+
+/* White Balance (Gain Adjust) */
+struct atomisp_wb_config {
+	unsigned int integer_bits;
+	unsigned int gr;	/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int r;		/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int b;		/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+};
+
+/* Color Space Conversion settings */
+struct atomisp_cc_config {
+	unsigned int fraction_bits;
+	int matrix[3 * 3];	/* RGB2YUV Color matrix, signed
+				   <13-fraction_bits>.<fraction_bits> */
+};
+
+/* De pixel noise configuration */
+struct atomisp_de_config {
+	unsigned int pixelnoise;
+	unsigned int c1_coring_threshold;
+	unsigned int c2_coring_threshold;
+};
+
+/* Chroma enhancement */
+struct atomisp_ce_config {
+	unsigned int uv_level_min;
+	unsigned int uv_level_max;
+};
+
+/* Defect pixel correction configuration */
+struct atomisp_dp_config {
+	/* [intensity] The threshold of defect Pixel Correction, representing
+	 * the permissible difference of intensity between one pixel and its
+	 * surrounding pixels. Smaller values result in more frequent pixel
+	 * corrections. u0_16
+	 */
+	unsigned int threshold;
+	/* [gain] The sensitivity of mis-correction. ISP will miss a lot of
+	 * defects if the value is set too large. u8_8
+	 */
+	unsigned int gain;
+};
+
+/* XNR threshold */
+struct atomisp_xnr_config {
+	unsigned int threshold;
+};
+
+struct atomisp_parm {
+	struct atomisp_grid_info info;
+	struct atomisp_wb_config wb_config;
+	struct atomisp_cc_config cc_config;
+	struct atomisp_ob_config ob_config;
+	struct atomisp_de_config de_config;
+	struct atomisp_ce_config ce_config;
+	struct atomisp_dp_config dp_config;
+	struct atomisp_nr_config nr_config;
+	struct atomisp_ee_config ee_config;
+	struct atomisp_tnr_config tnr_config;
+};
+
+struct atomisp_parameters {
+	struct atomisp_wb_config *wb_config;
+	struct atomisp_cc_config *cc_config;
+	struct atomisp_ob_config *ob_config;
+	struct atomisp_de_config *de_config;
+	struct atomisp_ce_config *ce_config;
+	struct atomisp_dp_config *dp_config;
+	struct atomisp_nr_config *nr_config;
+	struct atomisp_ee_config *ee_config;
+	struct atomisp_tnr_config *tnr_config;
+	struct atomisp_shading_table *shading_table;
+	struct atomisp_morph_table *morph_table;
+	struct atomisp_macc_config *macc_config;
+	struct atomisp_gamma_table *gamma_table;
+	struct atomisp_ctc_table *ctc_table;
+	struct atomisp_xnr_config *xnr_config;
+	struct atomisp_gc_config *gc_config;
+	struct atomisp_3a_config *a3a_config;
+};
+
+#define ATOMISP_GAMMA_TABLE_SIZE        1024
+struct atomisp_gamma_table {
+	unsigned short data[ATOMISP_GAMMA_TABLE_SIZE];
+};
+
+/* Morphing table for advanced ISP.
+ * Each line of width elements takes up COORD_TABLE_EXT_WIDTH elements
+ * in memory.
+ */
+#define ATOMISP_MORPH_TABLE_NUM_PLANES  6
+struct atomisp_morph_table {
+	unsigned int height;
+	unsigned int width;	/* number of valid elements per line */
+	unsigned short __user *coordinates_x[ATOMISP_MORPH_TABLE_NUM_PLANES];
+	unsigned short __user *coordinates_y[ATOMISP_MORPH_TABLE_NUM_PLANES];
+};
+
+#define ATOMISP_NUM_SC_COLORS	4
+#define ATOMISP_SC_FLAG_QUERY	(1 << 0)
+
+struct atomisp_shading_table {
+	/*
+	 * If flag ATOMISP_SC_FLAG_QUERY is set, IOCTL will only query current
+	 * LSC status and return, otherwise it will set LSC according to
+	 * userspace's input.
+	 */
+	__u8 flags;
+	/*
+	 * If ATOMISP_SC_FLAG_QUERY is set, enable is output parameter,
+	 * otherwise it is an input parameter and will enable/disable LSC
+	 * engine
+	 */
+	__u8 enable;
+	/* native sensor resolution */
+	__u32 sensor_width;
+	__u32 sensor_height;
+	/* number of data points per line per color (bayer quads) */
+	__u32 width;
+	/* number of lines of data points per color (bayer quads) */
+	__u32 height;
+	/* bits of fraction part for shading table values */
+	__u32 fraction_bits;
+	/* one table for each color (use sh_css_sc_color to index) */
+	__u16 __user *data[ATOMISP_NUM_SC_COLORS];
+};
+
+struct atomisp_makernote_info {
+	/* bits 31-16: numerator, bits 15-0: denominator */
+	unsigned int focal_length;
+	/* bits 31-16: numerator, bits 15-0: denominator*/
+	unsigned int f_number_curr;
+	/*
+	* bits 31-24: max f-number numerator
+	* bits 23-16: max f-number denominator
+	* bits 15-8: min f-number numerator
+	* bits 7-0: min f-number denominator
+	*/
+	unsigned int f_number_range;
+};
+
+/* parameter for MACC */
+#define ATOMISP_NUM_MACC_AXES           16
+struct atomisp_macc_table {
+	short data[4 * ATOMISP_NUM_MACC_AXES];
+};
+
+struct atomisp_macc_config {
+	int color_effect;
+	struct atomisp_macc_table table;
+};
+
+/* Parameter for ctc parameter control */
+#define ATOMISP_CTC_TABLE_SIZE          1024
+struct atomisp_ctc_table {
+	unsigned short data[ATOMISP_CTC_TABLE_SIZE];
+};
+
+/* Parameter for overlay image loading */
+struct atomisp_overlay {
+	/* the frame containing the overlay data The overlay frame width should
+	 * be the multiples of 2*ISP_VEC_NELEMS. The overlay frame height
+	 * should be the multiples of 2.
+	 */
+	struct v4l2_framebuffer *frame;
+	/* Y value of overlay background */
+	unsigned char bg_y;
+	/* U value of overlay background */
+	char bg_u;
+	/* V value of overlay background */
+	char bg_v;
+	/* the blending percent of input data for Y subpixels */
+	unsigned char blend_input_perc_y;
+	/* the blending percent of input data for U subpixels */
+	unsigned char blend_input_perc_u;
+	/* the blending percent of input data for V subpixels */
+	unsigned char blend_input_perc_v;
+	/* the blending percent of overlay data for Y subpixels */
+	unsigned char blend_overlay_perc_y;
+	/* the blending percent of overlay data for U subpixels */
+	unsigned char blend_overlay_perc_u;
+	/* the blending percent of overlay data for V subpixels */
+	unsigned char blend_overlay_perc_v;
+	/* the overlay start x pixel position on output frame It should be the
+	   multiples of 2*ISP_VEC_NELEMS. */
+	unsigned int overlay_start_x;
+	/* the overlay start y pixel position on output frame It should be the
+	   multiples of 2. */
+	unsigned int overlay_start_y;
+};
+
+/* Sensor resolution specific data for AE calculation.*/
+struct atomisp_sensor_mode_data {
+	unsigned int coarse_integration_time_min;
+	unsigned int coarse_integration_time_max_margin;
+	unsigned int fine_integration_time_min;
+	unsigned int fine_integration_time_max_margin;
+	unsigned int fine_integration_time_def;
+	unsigned int frame_length_lines;
+	unsigned int line_length_pck;
+	unsigned int read_mode;
+	unsigned int vt_pix_clk_freq_mhz;
+	unsigned int crop_horizontal_start; /* Sensor crop start cord. (x0,y0)*/
+	unsigned int crop_vertical_start;
+	unsigned int crop_horizontal_end; /* Sensor crop end cord. (x1,y1)*/
+	unsigned int crop_vertical_end;
+	unsigned int output_width; /* input size to ISP after binning/scaling */
+	unsigned int output_height;
+	uint8_t binning_factor_x; /* horizontal binning factor used */
+	uint8_t binning_factor_y; /* vertical binning factor used */
+	uint8_t reserved[2];
+};
+
+struct atomisp_exposure {
+	unsigned int integration_time[8];
+	unsigned int shutter_speed[8];
+	unsigned int gain[4];
+	unsigned int aperture;
+};
+
+/* For texture streaming. */
+struct atomisp_bc_video_package {
+	int ioctl_cmd;
+	int device_id;
+	int inputparam;
+	int outputparam;
+};
+
+enum atomisp_focus_hp {
+	ATOMISP_FOCUS_HP_IN_PROGRESS = (1U << 2),
+	ATOMISP_FOCUS_HP_COMPLETE    = (2U << 2),
+	ATOMISP_FOCUS_HP_FAILED      = (3U << 2)
+};
+
+/* Masks */
+#define ATOMISP_FOCUS_STATUS_MOVING           (1U << 0)
+#define ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE (1U << 1)
+#define ATOMISP_FOCUS_STATUS_HOME_POSITION    (3U << 2)
+
+enum atomisp_camera_port {
+	ATOMISP_CAMERA_PORT_PRIMARY,
+	ATOMISP_CAMERA_PORT_SECONDARY,
+	ATOMISP_CAMERA_PORT_THIRD,
+	ATOMISP_CAMERA_NR_PORTS
+};
+
+/* Flash modes. Default is off.
+ * Setting a flash to TORCH or INDICATOR mode will automatically
+ * turn it on. Setting it to FLASH mode will not turn on the flash
+ * until the FLASH_STROBE command is sent. */
+enum atomisp_flash_mode {
+	ATOMISP_FLASH_MODE_OFF,
+	ATOMISP_FLASH_MODE_FLASH,
+	ATOMISP_FLASH_MODE_TORCH,
+	ATOMISP_FLASH_MODE_INDICATOR,
+};
+
+/* Flash statuses, used by atomisp driver to check before starting
+ * flash and after having started flash. */
+enum atomisp_flash_status {
+	ATOMISP_FLASH_STATUS_OK,
+	ATOMISP_FLASH_STATUS_HW_ERROR,
+	ATOMISP_FLASH_STATUS_INTERRUPTED,
+	ATOMISP_FLASH_STATUS_TIMEOUT,
+};
+
+/* Frame status. This is used to detect corrupted frames and flash
+ * exposed frames. Usually, the first 2 frames coming out of the sensor
+ * are corrupted. When using flash, the frame before and the frame after
+ * the flash exposed frame may be partially exposed by flash. The ISP
+ * statistics for these frames should not be used by the 3A library.
+ * The frame status value can be found in the "reserved" field in the
+ * v4l2_buffer struct. */
+enum atomisp_frame_status {
+	ATOMISP_FRAME_STATUS_OK,
+	ATOMISP_FRAME_STATUS_CORRUPTED,
+	ATOMISP_FRAME_STATUS_FLASH_EXPOSED,
+	ATOMISP_FRAME_STATUS_FLASH_PARTIAL,
+	ATOMISP_FRAME_STATUS_FLASH_FAILED,
+};
+
+enum atomisp_acc_type {
+	ATOMISP_ACC_STANDALONE,	/* Stand-alone acceleration */
+	ATOMISP_ACC_OUTPUT,	/* Accelerator stage on output frame */
+	ATOMISP_ACC_VIEWFINDER	/* Accelerator stage on viewfinder frame */
+};
+
+enum atomisp_acc_arg_type {
+	ATOMISP_ACC_ARG_SCALAR_IN,    /* Scalar input argument */
+	ATOMISP_ACC_ARG_SCALAR_OUT,   /* Scalar output argument */
+	ATOMISP_ACC_ARG_SCALAR_IO,    /* Scalar in/output argument */
+	ATOMISP_ACC_ARG_PTR_IN,	     /* Pointer input argument */
+	ATOMISP_ACC_ARG_PTR_OUT,	     /* Pointer output argument */
+	ATOMISP_ACC_ARG_PTR_IO,	     /* Pointer in/output argument */
+	ATOMISP_ARG_PTR_NOFLUSH,  /* Pointer argument will not be flushed */
+	ATOMISP_ARG_PTR_STABLE,   /* Pointer input argument that is stable */
+	ATOMISP_ACC_ARG_FRAME	     /* Frame argument */
+};
+
+/** ISP memories */
+enum atomisp_acc_memory {
+	ATOMISP_ACC_MEMORY_PMEM = 0,
+	ATOMISP_ACC_MEMORY_DMEM,
+	ATOMISP_ACC_MEMORY_VMEM,
+	ATOMISP_ACC_MEMORY_VAMEM0,
+	ATOMISP_ACC_MEMORY_VAMEM1,
+	ATOMISP_ACC_MEMORY_VAMEM2,
+	ATOMISP_ACC_MEMORY_HMEM0,
+	ATOMISP_ACC_MEMORY_HMEM1,
+	ATOMISP_ACC_MEMORY_HMEM2,
+	ATOMISP_ACC_MEMORY_HMEM3,
+	ATOMISP_ACC_NR_MEMORY		/* Must be last */
+};
+
+struct atomisp_sp_arg {
+	enum atomisp_acc_arg_type type;	/* Type  of SP argument */
+	void                    *value;	/* Value of SP argument */
+	unsigned int             size;	/* Size  of SP argument */
+};
+
+/* Acceleration API */
+
+/* For CSS 1.0 only */
+struct atomisp_acc_fw_arg {
+	unsigned int fw_handle;
+	unsigned int index;
+	void __user *value;
+	size_t size;
+};
+
+/*
+ * Set arguments after first mapping with ATOMISP_IOC_ACC_S_MAPPED_ARG.
+ * For CSS 1.5 only.
+ */
+struct atomisp_acc_s_mapped_arg {
+	unsigned int fw_handle;
+	__u32 memory;			/* one of enum atomisp_acc_memory */
+	size_t length;
+	unsigned long css_ptr;
+};
+
+struct atomisp_acc_fw_abort {
+	unsigned int fw_handle;
+	/* Timeout in us */
+	unsigned int timeout;
+};
+
+struct atomisp_acc_fw_load {
+	unsigned int size;
+	unsigned int fw_handle;
+	void __user *data;
+};
+
+/*
+ * Load firmware to specified pipeline.
+ * For CSS 1.5 only.
+ */
+struct atomisp_acc_fw_load_to_pipe {
+	__u32 flags;			/* Flags, see below for valid values */
+	unsigned int fw_handle;		/* Handle, filled by kernel. */
+	__u32 size;			/* Firmware binary size */
+	void __user *data;		/* Pointer to firmware */
+	__u32 type;			/* Binary type */
+	__u32 reserved[3];		/* Set to zero */
+};
+
+#define ATOMISP_ACC_FW_LOAD_FL_PREVIEW		(1 << 0)
+#define ATOMISP_ACC_FW_LOAD_FL_COPY		(1 << 1)
+#define ATOMISP_ACC_FW_LOAD_FL_VIDEO		(1 << 2)
+#define ATOMISP_ACC_FW_LOAD_FL_CAPTURE		(1 << 3)
+#define ATOMISP_ACC_FW_LOAD_FL_ACC		(1 << 4)
+
+#define ATOMISP_ACC_FW_LOAD_TYPE_NONE		0 /* Normal binary: don't use */
+#define ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT		1 /* Stage on output */
+#define ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER	2 /* Stage on viewfinder */
+#define ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE	3 /* Stand-alone acceleration */
+
+struct atomisp_acc_map {
+	__u32 flags;			/* Flags, see list below */
+	__u32 length;			/* Length of data in bytes */
+	void __user *user_ptr;		/* Pointer into user space */
+	unsigned long css_ptr;		/* Pointer into CSS address space */
+	__u32 reserved[4];		/* Set to zero */
+};
+
+#define ATOMISP_MAP_FLAG_NOFLUSH	0x0001	/* Do not flush cache */
+
+/*
+ * V4L2 private internal data interface.
+ * -----------------------------------------------------------------------------
+ * struct v4l2_private_int_data - request private data stored in video device
+ * internal memory.
+ * @size: sanity check to ensure userspace's buffer fits whole private data.
+ *	  If not, kernel will make partial copy (or nothing if @size == 0).
+ *	  @size is always corrected for the minimum necessary if IOCTL returns
+ *	  no error.
+ * @data: pointer to userspace buffer.
+ */
+struct v4l2_private_int_data {
+	__u32 size;
+	void __user *data;
+	__u32 reserved[2];
+};
+
+/*Private IOCTLs for ISP */
+#define ATOMISP_IOC_G_XNR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 0, int)
+#define ATOMISP_IOC_S_XNR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 1, int)
+#define ATOMISP_IOC_G_NR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 2, struct atomisp_nr_config)
+#define ATOMISP_IOC_S_NR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 3, struct atomisp_nr_config)
+#define ATOMISP_IOC_G_TNR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 4, struct atomisp_tnr_config)
+#define ATOMISP_IOC_S_TNR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 5, struct atomisp_tnr_config)
+#define ATOMISP_IOC_G_HISTOGRAM \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 6, struct atomisp_histogram)
+#define ATOMISP_IOC_S_HISTOGRAM \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 7, struct atomisp_histogram)
+#define ATOMISP_IOC_G_BLACK_LEVEL_COMP \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 8, struct atomisp_ob_config)
+#define ATOMISP_IOC_S_BLACK_LEVEL_COMP \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 9, struct atomisp_ob_config)
+#define ATOMISP_IOC_G_EE \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 12, struct atomisp_ee_config)
+#define ATOMISP_IOC_S_EE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 13, struct atomisp_ee_config)
+/* Digital Image Stabilization:
+ * 1. get dis statistics: reads DIS statistics from ISP (every frame)
+ * 2. set dis coefficients: set DIS filter coefficients (one time)
+ * 3. set dis motion vecotr: set motion vector (result of DIS, every frame)
+ */
+#define ATOMISP_IOC_G_DIS_STAT \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 14, struct atomisp_dis_statistics)
+#define ATOMISP_IOC_S_DIS_COEFS \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 15, struct atomisp_dis_coefficients)
+#define ATOMISP_IOC_S_DIS_VECTOR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 16, struct atomisp_dis_vector)
+
+#define ATOMISP_IOC_G_3A_STAT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 17, struct atomisp_3a_statistics)
+#define ATOMISP_IOC_G_ISP_PARM \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 18, struct atomisp_parm)
+#define ATOMISP_IOC_S_ISP_PARM \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 19, struct atomisp_parm)
+#define ATOMISP_IOC_G_ISP_GAMMA \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 20, struct atomisp_gamma_table)
+#define ATOMISP_IOC_S_ISP_GAMMA \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 21, struct atomisp_gamma_table)
+#define ATOMISP_IOC_G_ISP_GDC_TAB \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 22, struct atomisp_morph_table)
+#define ATOMISP_IOC_S_ISP_GDC_TAB \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 23, struct atomisp_morph_table)
+#define ATOMISP_IOC_ISP_MAKERNOTE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 24, struct atomisp_makernote_info)
+
+/* macc parameter control*/
+#define ATOMISP_IOC_G_ISP_MACC \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 25, struct atomisp_macc_config)
+#define ATOMISP_IOC_S_ISP_MACC \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 26, struct atomisp_macc_config)
+
+/* Defect pixel detection & Correction */
+#define ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 27, struct atomisp_dp_config)
+#define ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 28, struct atomisp_dp_config)
+
+/* False Color Correction */
+#define ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 29, struct atomisp_de_config)
+#define ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 30, struct atomisp_de_config)
+
+/* ctc parameter control */
+#define ATOMISP_IOC_G_ISP_CTC \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 31, struct atomisp_ctc_table)
+#define ATOMISP_IOC_S_ISP_CTC \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 32, struct atomisp_ctc_table)
+
+/* white balance Correction */
+#define ATOMISP_IOC_G_ISP_WHITE_BALANCE \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 33, struct atomisp_wb_config)
+#define ATOMISP_IOC_S_ISP_WHITE_BALANCE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 34, struct atomisp_wb_config)
+
+/* fpn table loading */
+#define ATOMISP_IOC_S_ISP_FPN_TABLE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 35, struct v4l2_framebuffer)
+
+/* overlay image loading */
+#define ATOMISP_IOC_G_ISP_OVERLAY \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 36, struct atomisp_overlay)
+#define ATOMISP_IOC_S_ISP_OVERLAY \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 37, struct atomisp_overlay)
+
+/* bcd driver bridge */
+#define ATOMISP_IOC_CAMERA_BRIDGE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 38, struct atomisp_bc_video_package)
+
+/* Sensor resolution specific info for AE */
+#define ATOMISP_IOC_G_SENSOR_MODE_DATA \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 39, struct atomisp_sensor_mode_data)
+
+#define ATOMISP_IOC_S_EXPOSURE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 40, struct atomisp_exposure)
+
+/* sensor calibration registers group */
+#define ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 41, struct atomisp_calibration_group)
+
+/* white balance Correction */
+#define ATOMISP_IOC_G_3A_CONFIG \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 42, struct atomisp_3a_config)
+#define ATOMISP_IOC_S_3A_CONFIG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 43, struct atomisp_3a_config)
+
+/* Accelerate ioctls */
+#define ATOMISP_IOC_ACC_LOAD \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 44, struct atomisp_acc_fw_load)
+
+#define ATOMISP_IOC_ACC_UNLOAD \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 45, unsigned int)
+
+/* For CSS 1.0 only */
+#define ATOMISP_IOC_ACC_S_ARG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 46, struct atomisp_acc_fw_arg)
+
+#define ATOMISP_IOC_ACC_START \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 47, unsigned int)
+
+#define ATOMISP_IOC_ACC_WAIT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 48, unsigned int)
+
+#define ATOMISP_IOC_ACC_ABORT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 49, struct atomisp_acc_fw_abort)
+
+/* sensor OTP memory read */
+#define ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 50, struct v4l2_private_int_data)
+
+/* LCS (shading) table write */
+#define ATOMISP_IOC_S_ISP_SHD_TAB \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 51, struct atomisp_shading_table)
+
+/* Gamma Correction */
+#define ATOMISP_IOC_G_ISP_GAMMA_CORRECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 52, struct atomisp_gc_config)
+
+#define ATOMISP_IOC_S_ISP_GAMMA_CORRECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 53, struct atomisp_gc_config)
+
+#define ATOMISP_IOC_ACC_DESTAB \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 54, struct atomisp_acc_fw_arg)
+
+/*
+ * Reserved ioctls. We have customer implementing it internally.
+ * We can't use both numbers to not cause ABI conflict.
+ * Anyway, those ioctls are hacks and not implemented by us:
+ *
+ * #define ATOMISP_IOC_G_SENSOR_REG \
+ *	_IOW('v', BASE_VIDIOC_PRIVATE + 55, struct atomisp_sensor_regs)
+ * #define ATOMISP_IOC_S_SENSOR_REG \
+ *	_IOW('v', BASE_VIDIOC_PRIVATE + 56, struct atomisp_sensor_regs)
+ */
+
+/* motor internal memory read */
+#define ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 57, struct v4l2_private_int_data)
+
+/*
+ * Ioctls to map and unmap user buffers to CSS address space for acceleration.
+ * User fills fields length and user_ptr and sets other fields to zero,
+ * kernel may modify the flags and sets css_ptr.
+ */
+#define ATOMISP_IOC_ACC_MAP \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 58, struct atomisp_acc_map)
+
+/* User fills fields length, user_ptr, and css_ptr and zeroes other fields. */
+#define ATOMISP_IOC_ACC_UNMAP \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 59, struct atomisp_acc_map)
+
+#define ATOMISP_IOC_ACC_S_MAPPED_ARG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 60, struct atomisp_acc_s_mapped_arg)
+
+#define ATOMISP_IOC_S_PARAMETERS \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 61, struct atomisp_parameters)
+
+#define ATOMISP_IOC_S_CONT_CAPTURE_CONFIG \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 62, struct atomisp_cont_capture_conf)
+
+#define ATOMISP_IOC_ACC_LOAD_TO_PIPE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 63, struct atomisp_acc_fw_load_to_pipe)
+
+#define ATOMISP_IOC_S_SINGLE_FUNC_CONFIG \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 100, struct atomisp_single_func_conf)
+
+#define ATOMISP_IOC_S_SINGLE_FUNC_STREAMON \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 101, struct atomisp_single_func_conf)
+
+#define ATOMISP_IOC_ACC_CLEAR_HMEM \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 102, unsigned int)
+	
+/*  ISP Private control IDs */
+#define V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION \
+	(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC \
+	(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_ATOMISP_VIDEO_STABLIZATION \
+	(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_ATOMISP_FIXED_PATTERN_NR \
+	(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION \
+	(V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_CID_ATOMISP_LOW_LIGHT \
+	(V4L2_CID_PRIVATE_BASE + 5)
+
+/* Camera class:
+ * Exposure, Flash and privacy (indicator) light controls, to be upstreamed */
+#define V4L2_CID_CAMERA_LASTP1             (V4L2_CID_CAMERA_CLASS_BASE + 1024)
+
+#define V4L2_CID_FOCAL_ABSOLUTE            (V4L2_CID_CAMERA_LASTP1 + 0)
+#define V4L2_CID_FNUMBER_ABSOLUTE          (V4L2_CID_CAMERA_LASTP1 + 1)
+#define V4L2_CID_FNUMBER_RANGE             (V4L2_CID_CAMERA_LASTP1 + 2)
+
+/* Flash related CIDs, see also:
+ * http://linuxtv.org/downloads/v4l-dvb-apis/extended-controls.html\
+ * #flash-controls */
+
+/* Request a number of flash-exposed frames. The frame status can be
+ * found in the reserved field in the v4l2_buffer struct. */
+#define V4L2_CID_REQUEST_FLASH             (V4L2_CID_FLASH_CLASS_BASE + 13)
+/* Query flash driver status. See enum atomisp_flash_status above. */
+#define V4L2_CID_FLASH_STATUS              (V4L2_CID_FLASH_CLASS_BASE + 14)
+/* Set the flash mode (see enum atomisp_flash_mode) */
+#define V4L2_CID_FLASH_MODE                (V4L2_CID_FLASH_CLASS_BASE + 15)
+
+/* VCM slew control */
+#define V4L2_CID_VCM_SLEW                  (V4L2_CID_CAMERA_LASTP1 + 11)
+/* VCM step time */
+#define V4L2_CID_VCM_TIMEING               (V4L2_CID_CAMERA_LASTP1 + 12)
+/* sensor test pattern */
+//Redefiniton of v4l2-core function in kernel 3.8
+//#define V4L2_CID_TEST_PATTERN              (V4L2_CID_CAMERA_LASTP1 + 13)
+
+/* Query Focus Status */
+#define V4L2_CID_FOCUS_STATUS              (V4L2_CID_CAMERA_LASTP1 + 14)
+
+/* Query sensor's binning factor */
+#define V4L2_CID_BIN_FACTOR_HORZ	   (V4L2_CID_CAMERA_LASTP1 + 15)
+#define V4L2_CID_BIN_FACTOR_VERT	   (V4L2_CID_CAMERA_LASTP1 + 16)
+
+/* number of frames to skip at stream start */
+#define V4L2_CID_G_SKIP_FRAMES		   (V4L2_CID_CAMERA_LASTP1 + 17)
+
+/* Query sensor's 2A status */
+#define V4L2_CID_2A_STATUS                 (V4L2_CID_CAMERA_LASTP1 + 18)
+#define V4L2_2A_STATUS_AE_READY            (1 << 0)
+#define V4L2_2A_STATUS_AWB_READY           (1 << 1)
+
+#define V4L2_CID_FMT_AUTO			(V4L2_CID_CAMERA_LASTP1 + 19)
+#define V4L2_CID_RUN_MODE			(V4L2_CID_CAMERA_LASTP1 + 20)
+#define V4L2_CID_ENABLE_VFPP			(V4L2_CID_CAMERA_LASTP1 + 21)
+
+#define ATOMISP_RUN_MODE_VIDEO			1
+#define ATOMISP_RUN_MODE_STILL_CAPTURE		2
+#define ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE	3
+#define ATOMISP_RUN_MODE_PREVIEW		4
+
+#define V4L2_BUF_FLAG_BUFFER_INVALID       0x0400
+#define V4L2_BUF_FLAG_BUFFER_VALID         0x0800
+
+#define V4L2_BUF_TYPE_VIDEO_CAPTURE_ION  (V4L2_BUF_TYPE_PRIVATE + 1024)
+
+#define V4L2_EVENT_ATOMISP_3A_STATS_READY  (V4L2_EVENT_PRIVATE_START + 1)
+
+/* Nonstandard color effects for V4L2_CID_COLORFX */
+enum {
+	V4L2_COLORFX_SKIN_WHITEN_LOW = 1001,
+	V4L2_COLORFX_SKIN_WHITEN_HIGH = 1002,
+};
+
+#endif /* _ATOM_ISP_H */
diff --git a/include/linux/atomisp_platform.h b/include/linux/atomisp_platform.h
new file mode 100644
index 0000000..c5ca65e
--- /dev/null
+++ b/include/linux/atomisp_platform.h
@@ -0,0 +1,141 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef ATOMISP_PLATFORM_H_
+#define ATOMISP_PLATFORM_H_
+
+#include <linux/i2c.h>
+#include <linux/sfi.h>
+#include <media/v4l2-subdev.h>
+#include "atomisp.h"
+
+enum atomisp_bayer_order {
+	atomisp_bayer_order_grbg,
+	atomisp_bayer_order_rggb,
+	atomisp_bayer_order_bggr,
+	atomisp_bayer_order_gbrg
+};
+
+enum atomisp_input_format {
+	ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY,/* 8 bits per subpixel (legacy) */
+	ATOMISP_INPUT_FORMAT_YUV420_8, /* 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV420_10,/* 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV422_8, /* UYVY..UVYV, 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV422_10,/* UYVY..UVYV, 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_444,  /* BGR..BGR, 4 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_555,  /* BGR..BGR, 5 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_565,  /* BGR..BGR, 5 bits B and $, 6 bits G */
+	ATOMISP_INPUT_FORMAT_RGB_666,  /* BGR..BGR, 6 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_888,  /* BGR..BGR, 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RAW_6,    /* RAW data, 6 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_7,    /* RAW data, 7 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_8,    /* RAW data, 8 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_10,   /* RAW data, 10 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_12,   /* RAW data, 12 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_14,   /* RAW data, 14 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_16,   /* RAW data, 16 bits per pixel */
+	ATOMISP_INPUT_FORMAT_BINARY_8, /* Binary byte stream. */
+};
+
+enum intel_v4l2_subdev_type {
+	RAW_CAMERA = 1,
+	SOC_CAMERA = 2,
+	CAMERA_MOTOR = 3,
+	LED_FLASH = 4,
+	XENON_FLASH = 5,
+	FILE_INPUT = 6,
+	TEST_PATTERN = 7,
+};
+
+struct intel_v4l2_subdev_id {
+	char name[17];
+	enum intel_v4l2_subdev_type type;
+	enum atomisp_camera_port    port;
+	int num_lanes;
+};
+
+struct intel_v4l2_subdev_i2c_board_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+};
+
+struct intel_v4l2_subdev_table {
+	struct intel_v4l2_subdev_i2c_board_info v4l2_subdev;
+	enum intel_v4l2_subdev_type type;
+	enum atomisp_camera_port port;
+	int num_lanes;
+};
+
+struct atomisp_platform_data {
+	struct intel_v4l2_subdev_table *subdevs;
+};
+
+struct camera_sensor_platform_data {
+	int (*gpio_ctrl)(struct v4l2_subdev *subdev, int flag);
+	int (*flisclk_ctrl)(struct v4l2_subdev *subdev, int flag);
+	int (*power_ctrl)(struct v4l2_subdev *subdev, int flag);
+	int (*csi_cfg)(struct v4l2_subdev *subdev, int flag);
+	bool (*low_fps)(void);
+	int (*platform_init)(struct i2c_client *);
+	int (*platform_deinit)(void);
+};
+
+struct camera_af_platform_data {
+	int (*power_ctrl)(struct v4l2_subdev *subdev, int flag);
+};
+
+const struct camera_af_platform_data *camera_get_af_platform_data(void);
+
+struct camera_mipi_info {
+	enum atomisp_camera_port        port;
+	unsigned int                    num_lanes;
+	enum atomisp_input_format       input_format;
+	enum atomisp_bayer_order        raw_bayer_order;
+	struct atomisp_sensor_mode_data data;
+};
+
+extern const struct atomisp_platform_data *atomisp_get_platform_data(void);
+
+/* NOTE: Most of below constants could come from platform data.
+ *  * To be fixed when appropriate ACPI support comes.
+ *   */
+#define VLV2_PMC_CLK_BASE_ADDRESS       0xfed03060
+#define PLT_CLK_CTL_OFFSET(x)           (0x04 * (x))
+
+#define CLK_CONFG_BIT_POS               0
+#define CLK_CONFG_BIT_LEN               2
+#define CLK_CONFG_D3_GATED              0
+#define CLK_CONFG_FORCE_ON              1
+#define CLK_CONFG_FORCE_OFF             2
+
+#define CLK_FREQ_TYPE_BIT_POS           2
+#define CLK_FREQ_TYPE_BIT_LEN           1
+#define CLK_FREQ_TYPE_XTAL              0       /* 25 MHz */
+#define CLK_FREQ_TYPE_PLL               1       /* 19.2 MHz */
+
+#define MAX_CLK_COUNT                   6
+
+int byt_plat_set_clock_freq(int clk_num, int freq_type);
+int byt_plat_get_clock_freq(int clk_num);
+int byt_plat_configure_clock(int clk_num, u32 conf);
+int byt_plat_get_clock_status(int clk_num);
+int byt_plat_clk_init(void);
+
+#endif /* ATOMISP_PLATFORM_H_ */
-- 
1.7.5.4

