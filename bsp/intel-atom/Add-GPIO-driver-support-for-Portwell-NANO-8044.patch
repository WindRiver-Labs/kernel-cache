From fda429dfeb4985217f05803966ac77f65c64901f Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Tue, 15 May 2012 08:51:58 +0800
Subject: [PATCH] Add GPIO driver support for Portwell NANO 8044

Portwell NANO 8044: Portwell NANO 8044 uses a multifunction
hip(w83627DHG) to provide GPIO function, Since add GPIO driver for the
chip

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 drivers/gpio/Kconfig         |    7 ++
 drivers/gpio/Makefile        |    1 +
 drivers/gpio/gpio-nano8044.c |  247 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 255 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpio/gpio-nano8044.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index e03653d..79ddacf 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -178,6 +178,13 @@ config GPIO_SCH
 	  The Intel Tunnel Creek processor has 5 GPIOs powered by the
 	  core power rail and 9 from suspend power supply.
 
+config GPIO_NANO_8044
+	tristate "GPIO Support for NANO 8044 ITX board"
+	depends on X86 && PCI
+	help
+	  The driver provides a GPIO interface to supporting input and outputs.
+
+
 config GPIO_VX855
 	tristate "VIA VX855/VX875 GPIO"
 	depends on PCI
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 007f54b..6845e15 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_GPIO_RDC321X)	+= gpio-rdc321x.o
 obj-$(CONFIG_PLAT_SAMSUNG)	+= gpio-samsung.o
 obj-$(CONFIG_ARCH_SA1100)	+= gpio-sa1100.o
 obj-$(CONFIG_GPIO_SCH)		+= gpio-sch.o
+obj-$(CONFIG_GPIO_NANO_8044)		+= gpio-nano8044.o
 obj-$(CONFIG_GPIO_SODAVILLE)	+= gpio-sodaville.o
 obj-$(CONFIG_GPIO_STMPE)	+= gpio-stmpe.o
 obj-$(CONFIG_GPIO_SX150X)	+= gpio-sx150x.o
diff --git a/drivers/gpio/gpio-nano8044.c b/drivers/gpio/gpio-nano8044.c
new file mode 100644
index 0000000..6ca265e
--- /dev/null
+++ b/drivers/gpio/gpio-nano8044.c
@@ -0,0 +1,247 @@
+/*
+ * Author:      Liang Li <Liang.Li@windriver.com>
+ *
+ * Abstract:    This module supports PortWell NANO8044 ITX board, w83726DHG
+ *            All of the driver functions are provided in this file.
+ *
+ * Copyright(c) 2009 Windriver Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ * Windriver Corporation
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/gpio.h>
+
+#define DRVNAME "8044_gpio"
+/*
+ *  CR means CONFIGURATION REGISTER here,
+ *  LD means Logical Device here.
+ */
+/*
+ * IO PORT 2E is H/W strapped and named as EFIR (Extended Function Index
+ * Register, for identifying CR index number
+ */
+#define IO_EFIR (0x2E)		/* I/O configuration mode address */
+/*
+ * IO port 0x2F is H/W strapped and named as EFDR (Extend Function Data
+ * Register, for accessing desired CR.
+ */
+#define IO_EFDR (0x2F)		/* I/O port's configuration address */
+/*
+ * CR00-2F: Gobal Control Register. (ALL logical devices share these CRs
+ */
+
+#define CR_07 (0x07)		/* Logical Device selection */
+#define CR_2A (0x2A)		/* I2C Pin Select address */
+#define CR_2C (0x2C)		/* Multi-function Pin Select address */
+/*
+ * The ninth Logical Device of Super IO
+ */
+#define LD_09 (0x09)           /* The LD provide GPIO functionality */
+/* The configuration registers of the ninth logical device */
+#define CR_30 (0x30)		/* Enable logical device active address */
+#define CR_E7 (0xE7)		/* Status Register */
+#define CR_F0 (0xF0)		/* GPI or GPO select address */
+#define CR_F1 (0xF1)		/* Output High or Low select address */
+#define CR_F2 (0xF2)		/* Inversion Register */
+#define CR_FE (0xFE)		/* Input detected type Register */
+
+static inline void superio_outb(int ioreg, int reg, int val)
+{
+	outb(reg, ioreg);
+	outb(val, ioreg + 1);
+}
+
+static inline u8 superio_inb(int ioreg, int reg)
+{
+	outb(reg, ioreg);
+	return inb(ioreg + 1);
+}
+
+static inline void superio_enter(int ioreg)
+{
+	outb(0x87, ioreg);
+	outb(0x87, ioreg);
+}
+
+static inline void superio_exit(int ioreg)
+{
+	outb(0x02, ioreg);
+	outb(0x02, ioreg + 1);
+}
+
+static DEFINE_MUTEX(w83627_gpio_lock);
+
+static void nano8044_free(struct gpio_chip *chip, unsigned offset)
+{
+	return;
+}
+
+static int nano8044_gpio_direction_input(struct gpio_chip *chip,
+					 unsigned offset)
+{
+	return 0;
+}
+
+static int nano8044_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+
+	superio_enter(IO_EFIR);
+	superio_outb(IO_EFIR, 0x07, 0x09);
+	/*
+	 * Get the status of active GPI port, and shift it to bit 0,
+	 * clear other bits
+	 */
+	tmp = superio_inb(IO_EFIR, CR_F1);
+	tmp >>= offset;
+	tmp &= 0x01;
+
+	superio_exit(IO_EFIR);
+	mutex_unlock(&w83627_gpio_lock);
+	return tmp;
+}
+
+static int nano8044_gpio_direction_output(struct gpio_chip *chip,
+					  unsigned offset, int value)
+{
+	int res = 0;
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	superio_enter(IO_EFIR);
+	superio_outb(IO_EFIR, 0x07, 0x09);
+	if (offset > 3) {
+		printk(KERN_INFO "NANO-8044: Only *ODD* pins can be GPO.\n");
+		printk(KERN_INFO "NANO-8044: offset value is  %d.\n", offset);
+		printk(KERN_INFO "NANO-8044: The first GPIO pin is '1'.\n");
+		res = -1;
+	} else {
+		tmp = superio_inb(IO_EFIR, CR_F0);
+		tmp &= ~(1 << offset);
+		superio_outb(IO_EFIR, CR_F0, tmp);
+	}
+	superio_exit(IO_EFIR);
+	mutex_unlock(&w83627_gpio_lock);
+	return res;
+}
+
+static void nano8044_gpio_set(struct gpio_chip *chip, unsigned offset,
+			      int value)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	superio_enter(IO_EFIR);
+
+	superio_outb(IO_EFIR, 0x07, 0x09);
+	tmp = superio_inb(IO_EFIR, CR_F1);
+	/* Write the get value to the GPO */
+	if (0 == value)
+		tmp &= ~(1 << offset);	/* Low Bit */
+	else
+		tmp |= 1 << offset;	/* High Bit */
+	superio_outb(IO_EFIR, CR_F1, tmp);
+	tmp = superio_inb(IO_EFIR, CR_F1);
+	printk(KERN_DEBUG "CR_F1 is %d offset is %d\n", tmp, offset);
+	superio_exit(IO_EFIR);
+
+	mutex_unlock(&w83627_gpio_lock);
+}
+
+static int nano8044_request(struct gpio_chip *chip, unsigned offset)
+{
+	return 0;
+}
+
+static struct gpio_chip w83627dhg_gpio_chip = {
+	.label = DRVNAME,
+	.owner = THIS_MODULE,
+	.request = nano8044_request,
+	.free = nano8044_free,
+	.direction_input = nano8044_gpio_direction_input,
+	.get = nano8044_gpio_get,
+	.direction_output = nano8044_gpio_direction_output,
+	.set = nano8044_gpio_set,
+	.base = 0,
+	.ngpio = 8,
+	.can_sleep = 0,
+};
+
+static void detect_chip(u8 ioaddr)
+{
+	u8 tmp;
+	superio_enter(ioaddr);
+
+	tmp = superio_inb(ioaddr, CR_2A);
+	tmp &= 0xFD;
+	superio_outb(ioaddr, CR_2A, tmp);
+
+	tmp = superio_inb(ioaddr, CR_2C);
+	tmp &= ~0xE0;
+	superio_outb(ioaddr, CR_2C, tmp);
+
+	superio_outb(ioaddr, CR_07, LD_09);
+	tmp = superio_inb(ioaddr, CR_30);
+	tmp |= 0x02;
+	superio_outb(ioaddr, CR_30, tmp);
+
+	superio_outb(ioaddr, CR_E7, 0x00);
+	superio_outb(ioaddr, CR_FE, 0x77);
+	superio_outb(ioaddr, CR_F2, 0x00);
+
+	/*'1' for input, '0' for output */
+	superio_outb(ioaddr, CR_F0, 0xF0);
+
+	superio_outb(ioaddr, CR_F1, 0x0A);
+
+	superio_exit(IO_EFIR);
+
+}
+
+static int __init nano8044_gpio_init(void)
+{
+	int err;
+
+	detect_chip(IO_EFIR);
+
+	err = gpiochip_add(&w83627dhg_gpio_chip);
+	if (err < 0)
+		return err;
+
+	printk(KERN_INFO "8044_gpio_init Done.\n");
+	return 0;
+}
+
+static void __exit nano8044_gpio_exit(void)
+{
+	int err;
+	err = gpiochip_remove(&w83627dhg_gpio_chip);
+
+	printk(KERN_INFO "8044_gpio_exit(%d)\n", err);
+}
+
+module_init(nano8044_gpio_init);
+module_exit(nano8044_gpio_exit);
+
+MODULE_AUTHOR("Liang Li");
+MODULE_DESCRIPTION("Portwell 8044 ITX board GPIO DRIVER");
+MODULE_LICENSE("GPL");
-- 
1.7.0.2

