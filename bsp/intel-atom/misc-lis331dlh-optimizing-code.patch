From db648d6e4af3668c7be9f31992cf8c21dffd89c0 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 29 Jun 2012 17:34:05 +0800
Subject: [PATCH 6/8] misc/lis331dlh: optimizing code

* use request_thread_irq to register interrupt handler in order to keep
  the way of reistering irq1 consistent with irq2.

* lis331dlh_th() should be removed since it does not do anything.
* use lis331dlh_acc_disable() instead of lis331dlh_acc_device_power_off()
  since when we want to remove this driver module  it also requires to
  cancel work queue at the same time of powering off the device.
* int2 does not enabled by default.
* powering off device should locate after installing hardware interrupt.

Signed-off-by: Yang Wei <wei.yang@windriver.com>
---
 drivers/misc/lis331dlh/lis331dlh_acc.c |   29 +++++++++++------------------
 1 files changed, 11 insertions(+), 18 deletions(-)

diff --git a/drivers/misc/lis331dlh/lis331dlh_acc.c b/drivers/misc/lis331dlh/lis331dlh_acc.c
index 119a0d1..3d46666 100644
--- a/drivers/misc/lis331dlh/lis331dlh_acc.c
+++ b/drivers/misc/lis331dlh/lis331dlh_acc.c
@@ -1158,10 +1158,6 @@ static int lis331dlh_acc_detect(struct i2c_client *client,
 	strlcpy(info->type, "lis331dlh_acc", I2C_NAME_SIZE);
 	return 0;
 }
-static  irqreturn_t lis331dlh_th(int irq, void *private)
-{
-	return IRQ_WAKE_THREAD;
-}
 static int lis331dlh_acc_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
@@ -1271,13 +1267,13 @@ static int lis331dlh_acc_probe(struct i2c_client *client,
 	acc->resume_state[RES_INT_CFG1] = 0x00;
 	acc->resume_state[RES_INT_THS1] = 0x00;
 	acc->resume_state[RES_INT_DUR1] = 0x00;
-	acc->resume_state[RES_INT_CFG2] = 0x3f;
+	acc->resume_state[RES_INT_CFG2] = 0x00;
 	acc->resume_state[RES_INT_THS2] = 0x00;
 	acc->resume_state[RES_INT_DUR2] = 0x00;
 
-	err = lis331dlh_acc_device_power_on(acc);
+	err = lis331dlh_acc_hw_init(acc);
 	if (err < 0) {
-		dev_err(&client->dev, "power on failed: %d\n", err);
+		dev_err(&client->dev, "hardware init failed: %d\n", err);
 		goto err_pdata_init;
 	}
 
@@ -1311,12 +1307,6 @@ static int lis331dlh_acc_probe(struct i2c_client *client,
 	}
 
 
-	/*
-	lis331dlh_acc_device_power_off(acc);
-	 As default, do not report information
-	atomic_set(&acc->enabled, 0);
-	*/
-
 	if (acc->pdata->gpio_int1 >= 0) {
 		INIT_WORK(&acc->irq1_work, lis331dlh_acc_irq1_work_func);
 		acc->irq1_work_queue =
@@ -1327,7 +1317,7 @@ static int lis331dlh_acc_probe(struct i2c_client *client,
 					"cannot create work queue1: %d\n", err);
 			goto err_remove_sysfs_int;
 		}
-		err = request_irq(acc->irq1, lis331dlh_acc_isr1,
+		err = request_threaded_irq(acc->irq1, NULL, lis331dlh_acc_isr1,
 			IRQF_TRIGGER_RISING, "lis331dlh_acc_irq1", acc);
 		if (err < 0) {
 			dev_err(&client->dev, "request irq1 failed: %d\n", err);
@@ -1343,18 +1333,21 @@ static int lis331dlh_acc_probe(struct i2c_client *client,
 		if (!acc->irq2_work_queue) {
 			err = -ENOMEM;
 			dev_err(&client->dev,
-				"cannot create work queue2: %d\n", err);
+					"cannot create work queue2: %d\n", err);
 			goto err_free_irq1;
 		}
-		err = request_threaded_irq(acc->irq2, lis331dlh_th, lis331dlh_acc_isr2,
+		err = request_threaded_irq(acc->irq2, NULL, lis331dlh_acc_isr2,
 			IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "lis331dlh_acc_irq2", acc);
 		if (err < 0) {
 			dev_err(&client->dev, "request irq2 failed: %d\n", err);
 				goto err_destoyworkqueue2;
 		}
-		disable_irq_nosync(acc->irq2);
 	}
 
+	lis331dlh_acc_device_power_off(acc);
+/*	 As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
 
 
 	mutex_unlock(&acc->lock);
@@ -1406,8 +1399,8 @@ static int __devexit lis331dlh_acc_remove(struct i2c_client *client)
 		destroy_workqueue(acc->irq2_work_queue);
 	}
 
+	lis331dlh_acc_disable(acc);
 	lis331dlh_acc_input_cleanup(acc);
-	lis331dlh_acc_device_power_off(acc);
 	remove_sysfs_interfaces(&client->dev);
 
 	if (acc->pdata->exit)
-- 
1.7.7

