From 96a4b55fb9be1a77605660fe07c857d749b0ab75 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 11:22:49 +0800
Subject: [PATCH 052/134] ACPI / driver core: Introduce struct acpi_dev_node
 and related macros

upstream: 95f8a082b9b1ead0c2859f2a7b1ac91ff63d8765

To avoid adding an ACPI handle pointer to struct device on
architectures that don't use ACPI, or generally when CONFIG_ACPI is
not set, in which cases that pointer is useless, define struct
acpi_dev_node that will contain the handle pointer if CONFIG_ACPI is
set and will be empty otherwise and use it to represent the ACPI
device node field in struct device.

In addition to that define macros for reading and setting the ACPI
handle of a device that don't generate code when CONFIG_ACPI is
unset.  Modify the ACPI subsystem to use those macros instead of
referring to the given device's ACPI handle directly.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/glue.c     |   16 ++++++++--------
 drivers/acpi/scan.c     |    4 ++--
 include/acpi/acpi_bus.h |    2 +-
 include/linux/device.h  |   18 ++++++++++++++++--
 4 files changed, 27 insertions(+), 13 deletions(-)

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 8900404..6edc54f 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -134,12 +134,12 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
 	int retval = -EINVAL;
 
-	if (dev->acpi_handle) {
+	if (ACPI_HANDLE(dev)) {
 		if (handle) {
 			dev_warn(dev, "ACPI handle is already set\n");
 			return -EINVAL;
 		} else {
-			handle = dev->acpi_handle;
+			handle = ACPI_HANDLE(dev);
 		}
 	}
 	if (!handle)
@@ -181,8 +181,8 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
-	if (!dev->acpi_handle)
-		dev->acpi_handle = handle;
+	if (!ACPI_HANDLE(dev))
+		ACPI_HANDLE_SET(dev, acpi_dev->handle);
 
 	if (!physical_node->node_id)
 		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
@@ -200,7 +200,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	return 0;
 
  err:
-	dev->acpi_handle = NULL;
+	ACPI_HANDLE_SET(dev, NULL);
 	put_device(dev);
 	return retval;
 
@@ -217,10 +217,10 @@ static int acpi_unbind_one(struct device *dev)
 	acpi_status status;
 	struct list_head *node, *next;
 
-	if (!dev->acpi_handle)
+	if (!ACPI_HANDLE(dev))
 		return 0;
 
-	status = acpi_bus_get_device(dev->acpi_handle, &acpi_dev);
+	status = acpi_bus_get_device(ACPI_HANDLE(dev), &acpi_dev);
 	if (ACPI_FAILURE(status))
 		goto err;
 
@@ -246,7 +246,7 @@ static int acpi_unbind_one(struct device *dev)
 
 		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
 		sysfs_remove_link(&dev->kobj, "firmware_node");
-		dev->acpi_handle = NULL;
+		ACPI_HANDLE_SET(dev, NULL);
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
 		kfree(entry);
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 158568a..e9c9878 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -300,8 +300,8 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 {
 	struct acpi_device *adev;
 
-	if (!ids || !dev->acpi_handle
-	    || ACPI_FAILURE(acpi_bus_get_device(dev->acpi_handle, &adev)))
+	if (!ids || !ACPI_HANDLE(dev)
+	    || ACPI_FAILURE(acpi_bus_get_device(ACPI_HANDLE(dev), &adev)))
 		return NULL;
 
 	return __acpi_match_device(adev, ids);
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 3703f5c..8e92ac3 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -390,7 +390,7 @@ acpi_handle acpi_get_child(acpi_handle, u64);
 int acpi_is_root_bridge(acpi_handle);
 acpi_handle acpi_get_pci_rootbridge_handle(unsigned int, unsigned int);
 struct acpi_pci_root *acpi_pci_find_root(acpi_handle handle);
-#define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)((dev)->acpi_handle))
+#define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)ACPI_HANDLE(dev))
 
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int state);
 int acpi_disable_wakeup_device_power(struct acpi_device *dev);
diff --git a/include/linux/device.h b/include/linux/device.h
index d7bf873b..2003f32 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -567,6 +567,12 @@ struct device_dma_parameters {
 	unsigned long segment_boundary_mask;
 };
 
+struct acpi_dev_node {
+#ifdef CONFIG_ACPI
+	void	*handle;
+#endif
+};
+
 /**
  * struct device - The basic device structure
  * @parent:	The device's "parent" device, the device to which it is attached.
@@ -607,7 +613,7 @@ struct device_dma_parameters {
  * @dma_mem:	Internal for coherent mem override.
  * @archdata:	For arch-specific additions.
  * @of_node:	Associated device tree node.
- * @acpi_handle: Associated ACPI device node's namespace handle.
+ * @acpi_node:	Associated ACPI device node.
  * @devt:	For creating the sysfs "dev".
  * @id:		device instance
  * @devres_lock: Spinlock to protect the resource of the device.
@@ -672,7 +678,7 @@ struct device {
 	struct dev_archdata	archdata;
 
 	struct device_node	*of_node; /* associated device tree node */
-	void			*acpi_handle; /* associated ACPI device node */
+	struct acpi_dev_node	acpi_node; /* associated ACPI device node */
 
 	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
 	u32			id;	/* device instance */
@@ -687,6 +693,14 @@ struct device {
 	void	(*release)(struct device *dev);
 };
 
+#ifdef CONFIG_ACPI
+#define ACPI_HANDLE(dev)	((dev)->acpi_node.handle)
+#define ACPI_HANDLE_SET(dev, _handle_)	(dev)->acpi_node.handle = (_handle_)
+#else
+#define ACPI_HANDLE(dev)	(NULL)
+#define ACPI_HANDLE_SET(dev, _handle_)	do { } while (0)
+#endif
+
 /* Get the wakeup routines, which depend on struct device */
 #include <linux/pm_wakeup.h>
 
-- 
1.7.5.4

