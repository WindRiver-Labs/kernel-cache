From 083cc8285c1693e2b616c9b5f9bcf1f2fa26f4e5 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Wed, 7 Aug 2013 17:21:36 +0800
Subject: [PATCH 072/134] ACPI: Take power resource initialization errors into
 account

upstream: e88c9c603b2ad0cd0fbe90afedba3f1becbbeb79

Some ACPI power resource initialization errors, like memory
allocation errors, are not taken into account appropriately in some
cases, which may lead to a device having an incomplete list of power
resources that one of its power states depends on, for one example.

Rework the power resource initialization and namespace scanning code
so that power resource initialization errors are treated more
seriously.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 drivers/acpi/internal.h |    7 ++---
 drivers/acpi/power.c    |   43 ++++++++++++++++++++--------------
 drivers/acpi/scan.c     |   57 ++++++++++++++++++++--------------------------
 3 files changed, 53 insertions(+), 54 deletions(-)

diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index cbb8219..bcba519 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -51,10 +51,9 @@ void acpi_free_ids(struct acpi_device *device);
    -------------------------------------------------------------------------- */
 int acpi_power_init(void);
 void acpi_power_resources_list_free(struct list_head *list);
-acpi_status acpi_extract_power_resources(union acpi_object *package,
-					 unsigned int start,
-					 struct list_head *list);
-void acpi_add_power_resource(acpi_handle handle);
+int acpi_extract_power_resources(union acpi_object *package, unsigned int start,
+				 struct list_head *list);
+int acpi_add_power_resource(acpi_handle handle);
 void acpi_power_add_remove_device(struct acpi_device *adev, bool add);
 int acpi_device_sleep_wake(struct acpi_device *dev,
                            int enable, int sleep_state, int dev_state);
diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index b78505a..412e91f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -98,18 +98,18 @@ static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 	return container_of(device, struct acpi_power_resource, device);
 }
 
-static void acpi_power_resources_list_add(acpi_handle handle,
-					  struct list_head *list)
+static int acpi_power_resources_list_add(acpi_handle handle,
+					 struct list_head *list)
 {
 	struct acpi_power_resource *resource = acpi_power_get_context(handle);
 	struct acpi_power_resource_entry *entry;
 
 	if (!resource || !list)
-		return;
+		return -EINVAL;
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
-		return;
+		return -ENOMEM;
 
 	entry->resource = resource;
 	if (!list_empty(list)) {
@@ -118,10 +118,11 @@ static void acpi_power_resources_list_add(acpi_handle handle,
 		list_for_each_entry(e, list, node)
 			if (e->resource->order > resource->order) {
 				list_add_tail(&entry->node, &e->node);
-				return;
+				return 0;
 			}
 	}
 	list_add_tail(&entry->node, list);
+	return 0;
 }
 
 void acpi_power_resources_list_free(struct list_head *list)
@@ -134,33 +135,37 @@ void acpi_power_resources_list_free(struct list_head *list)
 	}
 }
 
-acpi_status acpi_extract_power_resources(union acpi_object *package,
-					 unsigned int start,
-					 struct list_head *list)
+int acpi_extract_power_resources(union acpi_object *package, unsigned int start,
+				 struct list_head *list)
 {
-	acpi_status status = AE_OK;
 	unsigned int i;
+	int err = 0;
 
 	for (i = start; i < package->package.count; i++) {
 		union acpi_object *element = &package->package.elements[i];
 		acpi_handle rhandle;
 
 		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
-			status = AE_BAD_DATA;
+			err = -ENODATA;
 			break;
 		}
 		rhandle = element->reference.handle;
 		if (!rhandle) {
-			status = AE_NULL_ENTRY;
+			err = -ENODEV;
 			break;
 		}
-		acpi_add_power_resource(rhandle);
-		acpi_power_resources_list_add(rhandle, list);
+		err = acpi_add_power_resource(rhandle);
+		if (err)
+			break;
+
+		err = acpi_power_resources_list_add(rhandle, list);
+		if (err)
+			break;
 	}
-	if (ACPI_FAILURE(status))
+	if (err)
 		acpi_power_resources_list_free(list);
 
-	return status;
+	return err;
 }
 
 static int acpi_power_get_state(acpi_handle handle, int *state)
@@ -672,7 +677,7 @@ static void acpi_release_power_resource(struct device *dev)
 	kfree(resource);
 }
 
-void acpi_add_power_resource(acpi_handle handle)
+int acpi_add_power_resource(acpi_handle handle)
 {
 	struct acpi_power_resource *resource;
 	struct acpi_device *device = NULL;
@@ -683,11 +688,11 @@ void acpi_add_power_resource(acpi_handle handle)
 
 	acpi_bus_get_device(handle, &device);
 	if (device)
-		return;
+		return 0;
 
 	resource = kzalloc(sizeof(*resource), GFP_KERNEL);
 	if (!resource)
-		return;
+		return -ENOMEM;
 
 	device = &resource->device;
 	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
@@ -722,8 +727,10 @@ void acpi_add_power_resource(acpi_handle handle)
 	mutex_lock(&power_resource_list_lock);
 	list_add(&resource->list_node, &acpi_power_resource_list);
 	mutex_unlock(&power_resource_list_lock);
+	return 0;
  err:
 	acpi_release_power_resource(&device->dev);
+	return result;
 }
 
 #ifdef CONFIG_ACPI_SLEEP
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 53b5a64..44d07ab 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -788,17 +788,17 @@ void acpi_bus_data_handler(acpi_handle handle, void *context)
 	return;
 }
 
-static acpi_status
-acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
-					     struct acpi_device_wakeup *wakeup)
+static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
+					struct acpi_device_wakeup *wakeup)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
 	union acpi_object *element = NULL;
 	acpi_status status;
+	int err = -ENODATA;
 
 	if (!wakeup)
-		return AE_BAD_PARAMETER;
+		return -EINVAL;
 
 	INIT_LIST_HEAD(&wakeup->resources);
 
@@ -806,29 +806,25 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	status = acpi_evaluate_object(handle, "_PRW", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
-		return status;
+		return err;
 	}
 
 	package = (union acpi_object *)buffer.pointer;
 
-	if (!package || (package->package.count < 2)) {
-		status = AE_BAD_DATA;
+	if (!package || package->package.count < 2)
 		goto out;
-	}
 
 	element = &(package->package.elements[0]);
-	if (!element) {
-		status = AE_BAD_DATA;
+	if (!element)
 		goto out;
-	}
+
 	if (element->type == ACPI_TYPE_PACKAGE) {
 		if ((element->package.count < 2) ||
 		    (element->package.elements[0].type !=
 		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER)) {
-			status = AE_BAD_DATA;
+		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
 			goto out;
-		}
+
 		wakeup->gpe_device =
 		    element->package.elements[0].reference.handle;
 		wakeup->gpe_number =
@@ -837,27 +833,24 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 		wakeup->gpe_device = NULL;
 		wakeup->gpe_number = element->integer.value;
 	} else {
-		status = AE_BAD_DATA;
 		goto out;
 	}
 
 	element = &(package->package.elements[1]);
-	if (element->type != ACPI_TYPE_INTEGER) {
-		status = AE_BAD_DATA;
+	if (element->type != ACPI_TYPE_INTEGER)
 		goto out;
-	}
+
 	wakeup->sleep_state = element->integer.value;
 
-	status = acpi_extract_power_resources(package, 2, &wakeup->resources);
-	if (ACPI_FAILURE(status))
+	err = acpi_extract_power_resources(package, 2, &wakeup->resources);
+	if (err)
 		goto out;
 
 	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
  out:
 	kfree(buffer.pointer);
-
-	return status;
+	return err;
 }
 
 static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
@@ -897,17 +890,17 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
 	acpi_handle temp;
 	acpi_status status = 0;
-	int psw_error;
+	int err;
 
 	/* Presence of _PRW indicates wake capable */
 	status = acpi_get_handle(device->handle, "_PRW", &temp);
 	if (ACPI_FAILURE(status))
 		return;
 
-	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
-							      &device->wakeup);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
+	err = acpi_bus_extract_wakeup_device_power_package(device->handle,
+							   &device->wakeup);
+	if (err) {
+		dev_err(&device->dev, "_PRW evaluation error: %d\n", err);
 		return;
 	}
 
@@ -920,8 +913,8 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	 * So it is necessary to call _DSW object first. Only when it is not
 	 * present will the _PSW object used.
 	 */
-	psw_error = acpi_device_sleep_wake(device, 0, 0, 0);
-	if (psw_error)
+	err = acpi_device_sleep_wake(device, 0, 0, 0);
+	if (err)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				"error in _DSW or _PSW evaluation\n"));
 }
@@ -944,9 +937,9 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 		if (buffer.length && package
 		    && package->type == ACPI_TYPE_PACKAGE
 		    && package->package.count) {
-			status = acpi_extract_power_resources(package, 0,
-							      &ps->resources);
-			if (ACPI_SUCCESS(status))
+			int err = acpi_extract_power_resources(package, 0,
+							       &ps->resources);
+			if (!err)
 				device->power.flags.power_resources = 1;
 		}
 		ACPI_FREE(buffer.pointer);
-- 
1.7.5.4

