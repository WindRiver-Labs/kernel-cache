From 07b031a3350da49506cfb32a125782ed6bc7bdb4 Mon Sep 17 00:00:00 2001
From: Peng Chao <chao.peng@windriver.com>
Date: Tue, 25 Jun 2013 15:43:39 +0800
Subject: [PATCH 125/134] intel-atom: Add baytrail clock support

Create clock tree for peripheral devices on Intel LPSS Baytrail platform.

Signed-off-by: Peng Chao <chao.peng@windriver.com>
---
 arch/ia64/include/asm/Kbuild |    2 +
 arch/x86/Kconfig             |   26 +++++++
 arch/x86/include/asm/Kbuild  |    2 +
 drivers/clk/Makefile         |    4 +
 drivers/clk/x86/Makefile     |    3 +
 drivers/clk/x86/clk-byt.c    |   96 ++++++++++++++++++++++++
 drivers/clk/x86/clk-lpss.c   |  170 ++++++++++++++++++++++++++++++++++++++++++
 drivers/clk/x86/clk-lpss.h   |   47 ++++++++++++
 include/asm-generic/clkdev.h |   28 +++++++
 9 files changed, 378 insertions(+), 0 deletions(-)
 create mode 100644 drivers/clk/x86/Makefile
 create mode 100644 drivers/clk/x86/clk-byt.c
 create mode 100644 drivers/clk/x86/clk-lpss.c
 create mode 100644 drivers/clk/x86/clk-lpss.h
 create mode 100644 include/asm-generic/clkdev.h

diff --git a/arch/ia64/include/asm/Kbuild b/arch/ia64/include/asm/Kbuild
index d4eb938..cab9394 100644
--- a/arch/ia64/include/asm/Kbuild
+++ b/arch/ia64/include/asm/Kbuild
@@ -13,3 +13,5 @@ header-y += ptrace_offsets.h
 header-y += rse.h
 header-y += ucontext.h
 header-y += ustack.h
+
+generic-y += clkdev.h
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 380698d..56fab53 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -453,8 +453,34 @@ config X86_MDFLD
 	  nor standard legacy replacement devices/features. e.g. Medfield does
 	  not contain i8259, i8254, HPET, legacy BIOS, most of the io ports.
 
+config X86_BYT
+	bool "Baytrail platform"
+	 depends on PCI
+	 depends on PCI_GOANY
+	 depends on X86_IO_APIC
+	 select INTEL_SCU_IPC
+	 select X86_PLATFORM_DEVICES
+	 select X86_INTEL_MID
+	 select APB_TIMER
+	 select DW_APB_TIMER
+	 ---help---
+	   Baytrail is Intel's Low Power Intel Architecture (LPIA) based platform.
+
 endif
 
+config X86_INTEL_LPSS
+	bool "Intel Low Power Subsystem Support"
+	select COMMON_CLK
+	---help---
+	  Select to build support for Intel Low Power Subsystem such as
+	  found on Intel Lynxpoint PCH. Selecting this option enables
+	  things like clock tree (common clock framework) which are needed
+	  by the LPSS peripheral drivers.
+
+config BYT_LPSS_BRD
+	bool "PCI mode LPSS support on BYT"
+	depends on X86_INTEL_LPSS
+
 config X86_RDC321X
 	bool "RDC R-321x SoC"
 	depends on X86_32
diff --git a/arch/x86/include/asm/Kbuild b/arch/x86/include/asm/Kbuild
index f9c0d3b..66e5f0e 100644
--- a/arch/x86/include/asm/Kbuild
+++ b/arch/x86/include/asm/Kbuild
@@ -26,3 +26,5 @@ header-y += vsyscall.h
 genhdr-y += unistd_32.h
 genhdr-y += unistd_64.h
 genhdr-y += unistd_x32.h
+
+generic-y += clkdev.h
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 24aa714..1fd4f91 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -2,3 +2,7 @@
 obj-$(CONFIG_CLKDEV_LOOKUP)	+= clkdev.o
 obj-$(CONFIG_COMMON_CLK)	+= clk.o clk-fixed-rate.o clk-gate.o \
 				   clk-mux.o clk-divider.o clk-fixed-factor.o
+# SoCs specific
+ifeq ($(CONFIG_ACPI),y)
+obj-$(CONFIG_X86)		+= x86/
+endif
diff --git a/drivers/clk/x86/Makefile b/drivers/clk/x86/Makefile
new file mode 100644
index 0000000..155a0ac
--- /dev/null
+++ b/drivers/clk/x86/Makefile
@@ -0,0 +1,3 @@
+clk-x86-lpss-objs			:= clk-lpss.o
+obj-$(CONFIG_X86_INTEL_LPSS)		+= clk-x86-lpss.o
+clk-x86-lpss-$(CONFIG_BYT_LPSS_BRD)	+= clk-byt.o
diff --git a/drivers/clk/x86/clk-byt.c b/drivers/clk/x86/clk-byt.c
new file mode 100644
index 0000000..7f92833
--- /dev/null
+++ b/drivers/clk/x86/clk-byt.c
@@ -0,0 +1,96 @@
+/*
+ * Intel BayTrail LPSS clocks.
+ *
+ * Copyright (C) 2013, Intel Corporation
+ * Author: Mika Westerberg <mika.westerberg@linux.intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/processor.h>
+
+#include "clk-lpss.h"
+
+#define PRV_CLOCK_PARAMS_SPI	0x400
+#define PRV_CLOCK_PARAMS	0x800
+
+static int byt_clk_probe(struct platform_device *pdev)
+{
+	struct clk *clk;
+
+	/* SCC / LPSS free running clock */
+	clk = clk_register_fixed_rate(NULL, "lpss_clk", NULL, CLK_IS_ROOT,
+				      100000000);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* Shared DMA controllers */
+	clk_register_clkdev(clk, "hclk", "INTL9C60.0.auto");
+	clk_register_clkdev(clk, "hclk", "INTL9C60.1.auto");
+
+	/* SPI clock */
+	clk = clk_register_fixed_rate(NULL, "spi_clk", "lpss_clk", 0, 50000000);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	clk = clk_register_lpss_gate("spi0_clk", "spi_clk", "80860F0E", NULL,
+				     PRV_CLOCK_PARAMS_SPI);
+	if (!IS_ERR(clk))
+		clk_register_clkdev(clk, NULL, "80860F0E:00");
+
+	/* UART clock */
+	clk = clk_register_fixed_rate(NULL, "uart_clk", "lpss_clk", 0, 44236800);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	clk = clk_register_lpss_gate("uart0_clk", "uart_clk", "80860F0A", "1",
+				     PRV_CLOCK_PARAMS);
+	if (!IS_ERR(clk))
+		clk_register_clkdev(clk, NULL, "80860F0A:00");
+
+	clk = clk_register_lpss_gate("uart1_clk", "uart_clk", "80860F0A", "2",
+				     PRV_CLOCK_PARAMS);
+	if (!IS_ERR(clk))
+		clk_register_clkdev(clk, NULL, "80860F0A:01");
+
+	/* I2C clocks */
+	clk = clk_register_fixed_rate(NULL, "i2c_100_clk", "lpss_clk", 0,
+				      100000000);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	clk_register_clkdev(clk, NULL, "0000:00:1e.5");
+	clk_register_clkdev(clk, "hclk", "dw_dmac.0");
+	clk_register_clkdev(clk, NULL, "80860F41:00");
+	clk_register_clkdev(clk, NULL, "80860F41:01");
+	clk_register_clkdev(clk, NULL, "80860F41:02");
+	clk_register_clkdev(clk, NULL, "80860F41:03");
+	clk_register_clkdev(clk, NULL, "80860F41:04");
+	clk_register_clkdev(clk, NULL, "80860F41:05");
+	clk_register_clkdev(clk, NULL, "80860F41:06");
+
+	return 0;
+}
+
+static struct platform_driver byt_clk_driver = {
+	.driver = {
+		.name = "clk-byt",
+		.owner = THIS_MODULE,
+	},
+	.probe = byt_clk_probe,
+};
+
+static int __init byt_clk_init(void)
+{
+	return platform_driver_register(&byt_clk_driver);
+}
+arch_initcall(byt_clk_init);
diff --git a/drivers/clk/x86/clk-lpss.c b/drivers/clk/x86/clk-lpss.c
new file mode 100644
index 0000000..9a8a939
--- /dev/null
+++ b/drivers/clk/x86/clk-lpss.c
@@ -0,0 +1,170 @@
+/*
+ * Intel Low Power Subsystem clocks.
+ *
+ * Copyright (C) 2013, Intel Corporation
+ * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
+ *	    Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+
+static int clk_lpss_is_mmio_resource(struct acpi_resource *res, void *data)
+{
+	struct resource r;
+	return !acpi_dev_resource_memory(res, &r);
+}
+
+static acpi_status clk_lpss_find_mmio(acpi_handle handle, u32 level,
+				      void *data, void **retval)
+{
+	struct resource_list_entry *rentry;
+	struct list_head resource_list;
+	struct acpi_device *adev;
+	const char *uid = data;
+	int ret;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return AE_OK;
+
+	if (uid) {
+		if (!adev->pnp.unique_id)
+			return AE_OK;
+		if (strcmp(uid, adev->pnp.unique_id))
+			return AE_OK;
+	}
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list,
+				     clk_lpss_is_mmio_resource, NULL);
+	if (ret < 0)
+		return AE_NO_MEMORY;
+
+	list_for_each_entry(rentry, &resource_list, node)
+		if (resource_type(&rentry->res) == IORESOURCE_MEM) {
+			*(struct resource *)retval = rentry->res;
+			break;
+		}
+
+	acpi_dev_free_resource_list(&resource_list);
+	return AE_OK;
+}
+
+/**
+ * clk_register_lpss_gate - register LPSS clock gate
+ * @name: name of this clock gate
+ * @parent_name: parent clock name
+ * @hid: ACPI _HID of the device
+ * @uid: ACPI _UID of the device (optional)
+ * @offset: LPSS PRV_CLOCK_PARAMS offset
+ *
+ * Creates and registers LPSS clock gate.
+ */
+struct clk *clk_register_lpss_gate(const char *name, const char *parent_name,
+				   const char *hid, const char *uid,
+				   unsigned offset)
+{
+	struct resource res = { };
+	void __iomem *mmio_base;
+	acpi_status status;
+	struct clk *clk;
+
+	/*
+	 * First try to look the device and its mmio resource from the
+	 * ACPI namespace.
+	 */
+	status = acpi_get_devices(hid, clk_lpss_find_mmio, (void *)uid,
+				  (void **)&res);
+	if (ACPI_FAILURE(status) || !res.start)
+		return ERR_PTR(-ENODEV);
+
+	mmio_base = ioremap(res.start, resource_size(&res));
+	if (!mmio_base)
+		return ERR_PTR(-ENOMEM);
+
+	clk = clk_register_gate(NULL, name, parent_name, 0, mmio_base + offset,
+				0, 0, NULL);
+	if (IS_ERR(clk))
+		iounmap(mmio_base);
+
+	return clk;
+}
+
+static u8 clk_lpss_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_mux *mux = container_of(hw, struct clk_mux, hw);
+	return readl(mux->reg) & BIT(0);
+}
+
+static const struct clk_ops clk_lpss_mux_ops = {
+	.get_parent = clk_lpss_mux_get_parent,
+};
+
+/**
+ * clk_register_lpss_mux - register LPSS mux clock
+ * @name: name of this mux
+ * @parent_names: array of parent names for this clock
+ * @num_parents: number of parents in the array (max 2)
+ * @hid: ACPI _HID of the device
+ * @offset: LPSS PRV_CLOCK_PARAMS offset
+ *
+ * Creates a binary clock mux that selects between two parents. Most useful
+ * with the I2C clock. You cannot change the parent, only read it.
+ */
+struct clk *clk_register_lpss_mux(const char *name, const char **parent_names,
+				  u8 num_parents, const char *hid,
+				  unsigned offset)
+{
+	struct clk_init_data init = { };
+	struct resource res = { };
+	void __iomem *mmio_base;
+	struct clk_mux *mux;
+	acpi_status status;
+	struct clk *clk;
+
+	if (num_parents > 2)
+		return ERR_PTR(-EINVAL);
+
+	status = acpi_get_devices(hid, clk_lpss_find_mmio, NULL, (void **)&res);
+	if (ACPI_FAILURE(status) || !res.start)
+		return ERR_PTR(-ENODEV);
+
+	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+	if (!mux)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_lpss_mux_ops;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	mmio_base = ioremap(res.start, resource_size(&res));
+	if (!mmio_base) {
+		clk = ERR_PTR(-ENOMEM);
+		goto fail_free;
+	}
+
+	mux->reg = mmio_base + offset;
+	mux->hw.init = &init;
+
+	clk = clk_register(NULL, &mux->hw);
+	if (IS_ERR(clk))
+		goto fail_unmap;
+
+	return clk;
+
+fail_unmap:
+	iounmap(mmio_base);
+fail_free:
+	kfree(mux);
+
+	return clk;
+}
diff --git a/drivers/clk/x86/clk-lpss.h b/drivers/clk/x86/clk-lpss.h
new file mode 100644
index 0000000..bdddeb5f
--- /dev/null
+++ b/drivers/clk/x86/clk-lpss.h
@@ -0,0 +1,47 @@
+/*
+ * Intel Low Power Subsystem clock.
+ *
+ * Copyright (C) 2013, Intel Corporation
+ * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
+ *	    Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __CLK_LPSS_H
+#define __CLK_LPSS_H
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+
+#ifdef CONFIG_ACPI
+extern struct clk *clk_register_lpss_gate(const char *name,
+					  const char *parent_name,
+					  const char *hid, const char *uid,
+					  unsigned offset);
+extern struct clk *clk_register_lpss_mux(const char *name,
+					 const char **parent_names,
+					 u8 num_parents, const char *hid,
+					 unsigned offset);
+#else
+static inline struct clk *clk_register_lpss_gate(const char *name,
+						 const char *parent_name,
+						 const char *hid,
+						 const char *uid,
+						 unsigned offset)
+{
+	return ERR_PTR(-ENODEV);
+}
+static inline struct clk *clk_register_lpss_mux(const char *name,
+						const char **parent_names,
+						u8 num_parents, const char *hid,
+						unsigned offset)
+{
+	return ERR_PTR(-ENODEV);
+}
+#endif
+
+#endif /* __CLK_LPSS_H */
diff --git a/include/asm-generic/clkdev.h b/include/asm-generic/clkdev.h
new file mode 100644
index 0000000..90a32a6
--- /dev/null
+++ b/include/asm-generic/clkdev.h
@@ -0,0 +1,28 @@
+/*
+ *  include/asm-generic/clkdev.h
+ *
+ * Based on the ARM clkdev.h:
+ *  Copyright (C) 2008 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Helper for the clk API to assist looking up a struct clk.
+ */
+#ifndef __ASM_CLKDEV_H
+#define __ASM_CLKDEV_H
+
+#include <linux/slab.h>
+
+struct clk;
+
+static inline int __clk_get(struct clk *clk) { return 1; }
+static inline void __clk_put(struct clk *clk) { }
+
+static inline struct clk_lookup_alloc *__clkdev_alloc(size_t size)
+{
+	return kzalloc(size, GFP_KERNEL);
+}
+
+#endif
-- 
1.7.5.4

