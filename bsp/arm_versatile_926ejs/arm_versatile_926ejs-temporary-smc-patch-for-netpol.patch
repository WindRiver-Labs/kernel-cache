From 7fcab1bb935beb94a542242bda4b1b70742a4d3f Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Sat, 31 Jan 2009 22:53:36 -0600
Subject: [PATCH] arm_versatile_926ejs: temporary smc patch for netpoll

When KGDB and NETPOLL are used, the polling rate is high enough
to cause phy resets and other bad network performance issues.
The temporary fix is to slow things down when both KGDB
and NETPOLL are on.

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 drivers/net/smc91x.c |   61 +++++++++++++++++++++++++++++++++----------------
 1 files changed, 41 insertions(+), 20 deletions(-)

diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index 02c7051..3fbeeeb 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -81,6 +81,7 @@ static const char version[] =
 #include <linux/ethtool.h>
 #include <linux/mii.h>
 #include <linux/workqueue.h>
+#include <linux/kgdb.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -234,11 +235,12 @@ static void PRINT_PKT(u_char *buf, int length)
 /* this disables an interrupt from the interrupt mask register */
 #define SMC_DISABLE_INT(lp, x) do {					\
 	unsigned char mask;						\
-	spin_lock_irq(&lp->lock);					\
+	unsigned long int_flags;					\
+	spin_lock_irqsave(&lp->lock,int_flags);					\
 	mask = SMC_GET_INT_MASK(lp);					\
 	mask &= ~(x);							\
 	SMC_SET_INT_MASK(lp, mask);					\
-	spin_unlock_irq(&lp->lock);					\
+	spin_unlock_irqrestore(&lp->lock, int_flags);			\
 } while (0)
 
 /*
@@ -269,17 +271,18 @@ static void smc_reset(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	unsigned int ctl, cfg;
+	unsigned long int_flags;
 	struct sk_buff *pending_skb;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
 	/* Disable all interrupts, block TX tasklet */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 
 	/* free any pending tx skb */
 	if (pending_skb) {
@@ -397,16 +400,17 @@ static void smc_shutdown(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	struct sk_buff *pending_skb;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
 
 	/* no more interrupts for me */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	if (pending_skb)
 		dev_kfree_skb(pending_skb);
 
@@ -993,9 +997,19 @@ static int smc_phy_reset(struct net_device *dev, int phy)
 	smc_phy_write(dev, phy, MII_BMCR, BMCR_RESET);
 
 	for (timeout = 2; timeout; timeout--) {
+#if defined(CONFIG_NET_POLL_CONTROLLER) && defined(CONFIG_KGDB)
+		if (atomic_read(&kgdb_active)) {
+			mdelay(50);
+		} else {
+			spin_unlock_irq(&lp->lock);
+			msleep(50);
+			spin_lock_irq(&lp->lock);
+		}
+#else
 		spin_unlock_irq(&lp->lock);
 		msleep(50);
 		spin_lock_irq(&lp->lock);
+#endif
 
 		bmcr = smc_phy_read(dev, phy, MII_BMCR);
 		if (!(bmcr & BMCR_RESET))
@@ -1074,10 +1088,11 @@ static void smc_phy_configure(struct work_struct *work)
 	int my_phy_caps; /* My PHY capabilities */
 	int my_ad_caps; /* My Advertised capabilities */
 	int status;
+	unsigned long int_flags;
 
 	DBG(3, "%s:smc_program_phy()\n", dev->name);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 
 	/*
 	 * We should not be called if phy_type is zero.
@@ -1159,7 +1174,7 @@ static void smc_phy_configure(struct work_struct *work)
 
 smc_phy_configure_exit:
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 /*
@@ -1363,10 +1378,11 @@ static void smc_timeout(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	int status, mask, eph_st, meminfo, fifo;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	status = SMC_GET_INT(lp);
 	mask = SMC_GET_INT_MASK(lp);
 	fifo = SMC_GET_FIFO(lp);
@@ -1374,7 +1390,7 @@ static void smc_timeout(struct net_device *dev)
 	eph_st = SMC_GET_EPH_STATUS(lp);
 	meminfo = SMC_GET_MIR(lp);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	PRINTK( "%s: TX timeout (INT 0x%02x INTMASK 0x%02x "
 		"MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",
 		dev->name, status, mask, meminfo, fifo, eph_st );
@@ -1407,6 +1423,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 	void __iomem *ioaddr = lp->base;
 	unsigned char multicast_table[8];
 	int update_multicast = 0;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1489,7 +1506,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		update_multicast = 1;
 	}
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 0);
 	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 	if (update_multicast) {
@@ -1497,7 +1514,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		SMC_SET_MCAST(lp, multicast_table);
 	}
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 
@@ -1510,6 +1527,7 @@ static int
 smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1543,9 +1561,9 @@ smc_open(struct net_device *dev)
 	if (lp->phy_type != 0)
 		smc_phy_configure(&lp->phy_configure);
 	else {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		smc_10bt_check_media(dev, 1);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	netif_start_queue(dev);
@@ -1583,14 +1601,15 @@ smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	cmd->maxtxpkt = 1;
 	cmd->maxrxpkt = 1;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_gset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		cmd->supported = SUPPORTED_10baseT_Half |
 				 SUPPORTED_10baseT_Full |
@@ -1617,11 +1636,12 @@ smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_sset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		if (cmd->autoneg != AUTONEG_DISABLE ||
 		    cmd->speed != SPEED_10 ||
@@ -1653,11 +1673,12 @@ static int smc_ethtool_nwayreset(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret = -EINVAL;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_nway_restart(&lp->mii);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	return ret;
-- 
1.6.0.3

