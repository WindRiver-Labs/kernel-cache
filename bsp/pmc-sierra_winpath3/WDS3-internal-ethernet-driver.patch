From 7c0758d00d59436c9ffb8884805a2c7979ddd6c4 Mon Sep 17 00:00:00 2001
From: Jiang, Bin <bin.jiang@windriver.com>
Date: Wed, 6 Apr 2011 16:45:53 +0800
Subject: [PATCH 08/13] WDS3: internal ethernet driver

Extracted from vendor drop(linux-mti-2.6.29.4-1 with modifications for WDS3).

Ethernet driver for WDS3 board.

Set autoflow control register(ETH_AUTO_FC_REG) with 0 to disable autoflow.
If autoflow control is not disabled, the ethernet driver will produce the
following backtrace:

WpENET: Error when writing packet to controller: skb=9b81d840
------------[ cut here ]------------
WARNING: at
net/sched/sch_generic.c:)
Modules linked in:
Call Trace:
[<85a04d98>] dump_stack+0x8/0x38
[<85a25ca4>] warn_slowpath+0x84/0xf0
[<85b9c098>] dev_watchdog+0x19c/0x2c4
[<85a31088>] run_timer_softirq+0x178/0x22c
[<85a2bcdc>] __do_softirq+0xb0/0x148
[<85a2bdcc>] do_softirq+0x58/0x7c
[<85a2bfcc>] irq_exit+0x54/0x64
[<85a00400>] _stext+0x0/0x4
[<85a08818>] r4k_wait_irqoff+0x20/0x24
[<85a09614>] cpu_idle+0x24/0x5c
---[ end trace e80475a1ef7eaa14 ]---

Signed-off-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/include/asm/wintegra/winpath3.h          |    5 +
 drivers/net/Kconfig                                |    1 +
 drivers/net/Makefile                               |    1 +
 drivers/net/wintegra/Kconfig                       |   23 ++
 drivers/net/wintegra/winpath3/Makefile             |    5 +
 drivers/net/wintegra/winpath3/enet_host/Makefile   |    8 +
 drivers/net/wintegra/winpath3/enet_host/enet_api.c |  282 ++++++++++++++
 .../net/wintegra/winpath3/enet_host/enet_host.c    |  400 ++++++++++++++++++++
 .../net/wintegra/winpath3/enet_host/enet_host.h    |   26 ++
 drivers/net/wintegra/winpath3/enet_host/eth_regs.h |  202 ++++++++++
 .../wintegra/winpath3/enet_host/rx_tx_ctrl_word.h  |   59 +++
 11 files changed, 1012 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/wintegra/Kconfig
 create mode 100644 drivers/net/wintegra/winpath3/Makefile
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/Makefile
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/enet_api.c
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/enet_host.c
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/enet_host.h
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/eth_regs.h
 create mode 100644 drivers/net/wintegra/winpath3/enet_host/rx_tx_ctrl_word.h

diff --git a/arch/mips/include/asm/wintegra/winpath3.h b/arch/mips/include/asm/wintegra/winpath3.h
index e571035..34856f6 100644
--- a/arch/mips/include/asm/wintegra/winpath3.h
+++ b/arch/mips/include/asm/wintegra/winpath3.h
@@ -175,6 +175,11 @@ typedef struct wm_ta {
 
 
 /*
+ *   Ethernet
+ */
+#define WINPATH_ENET_BASE             (0xB000)
+
+/*
  *  Clocks and Reset (CR) registers
  */
 #define MAP_CLK_SIU1_PLLCFG1     (0xfb04)
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index fbb3570..9cfe121 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -180,6 +180,7 @@ if PPC_85xx
 endif
 
 source "drivers/net/arcnet/Kconfig"
+source "drivers/net/wintegra/Kconfig"
 
 source "drivers/net/phy/Kconfig"
 
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 96df0ab..1ea36db 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_ENIC) += enic/
 obj-$(CONFIG_JME) += jme.o
 obj-$(CONFIG_BE2NET) += benet/
 obj-$(CONFIG_VMXNET3) += vmxnet3/
+obj-$(CONFIG_WINTEGRA_WINPATH3) += wintegra/winpath3/
 
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o \
diff --git a/drivers/net/wintegra/Kconfig b/drivers/net/wintegra/Kconfig
new file mode 100644
index 0000000..3aaa60a
--- /dev/null
+++ b/drivers/net/wintegra/Kconfig
@@ -0,0 +1,23 @@
+###########################################################################
+#    Copyright (C) 2002-2008  Wintegra.
+#
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of version 2 of the GNU General Public License
+#    as published by the Free Software Foundation.
+#
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+###########################################################################
+#
+# Wintegra Network device configuration
+#
+config WINTEGRA_INTERNAL_ENET
+	bool "Wintegra Internal Enet driver"
+	depends on WINTEGRA_WDS3
+	---help---
+        Select this option when working with Wintegra Winpath family with the internal ethernet device
diff --git a/drivers/net/wintegra/winpath3/Makefile b/drivers/net/wintegra/winpath3/Makefile
new file mode 100644
index 0000000..4835342
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the Wintegra Winpath3 Linux network device drivers.
+#
+
+obj-$(CONFIG_WINTEGRA_INTERNAL_ENET) += enet_host/
diff --git a/drivers/net/wintegra/winpath3/enet_host/Makefile b/drivers/net/wintegra/winpath3/enet_host/Makefile
new file mode 100644
index 0000000..e51a014
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for network driver - internal management port in Wintegra Winpath3
+#
+obj-$(CONFIG_WINTEGRA_INTERNAL_ENET)	+= wpeth.o
+
+wpeth-objs := enet_api.o enet_host.o
+
+EXTRA_CFLAGS = -I$(PWD)
diff --git a/drivers/net/wintegra/winpath3/enet_host/enet_api.c b/drivers/net/wintegra/winpath3/enet_host/enet_api.c
new file mode 100644
index 0000000..909d5b9
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/enet_api.c
@@ -0,0 +1,282 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * wp ethernet driver.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <asm/dma.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/init.h>
+
+#include "enet_host.h"
+
+#include <asm/wintegra/wds.h>
+#include <asm/wintegra/winpath.h>
+
+
+#define ETH_DEV_NAME             "WpENET"
+
+#define WP_ENET_DEBUG 0
+
+struct net_device *wp_dev;
+static int this_is_a_restart;
+static unsigned char brdcst_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static unsigned char ethernet_addr[6];
+
+static void enet_wp_tx_timeout(struct net_device *dev);
+
+static unsigned int enet_wp_stop(struct net_device *dev)
+{
+   winEth_stop();
+   this_is_a_restart = 1;
+
+   return 0;
+}
+
+
+/******************************************************************
+ * Interrupt handlers
+ ******************************************************************/
+
+
+void enet_wp_rx(struct net_device *dev)
+{
+   struct sk_buff *skb = 0;
+   unsigned int length;
+   unsigned char *pData;
+   unsigned char rx_buff[0x600];
+
+#if WP_ENET_DEBUG
+   printk("%s: Rx event\n", wp_dev->name);
+#endif
+   length = winEth_read(&rx_buff[0]);
+
+   if (length) {
+      if ((memcmp(rx_buff, ethernet_addr, 6) == 0) || (memcmp(rx_buff, brdcst_addr, 6) == 0)) {
+	  skb = dev_alloc_skb(length+4);
+	  if (skb == NULL) {
+	    dev->stats.rx_dropped++;
+	    printk("enet_wp_rx: failed to allocate memory. Dropping rx pack\n");
+	    return;
+	 }
+	 skb->dev = dev;
+	 skb_reserve(skb, 2);
+	 pData = skb_put(skb, length - 4);
+	 memcpy(pData, rx_buff, length);
+	 /* Pass to upper layer */
+	 skb->protocol = eth_type_trans(skb, dev);
+	 netif_rx(skb);
+	 dev->last_rx = jiffies;
+	 dev->stats.rx_packets++;
+	 dev->stats.rx_bytes += length;
+      } else
+	 dev->stats.rx_dropped++;
+   } else {
+      dev->stats.rx_dropped++;
+      dev->stats.rx_errors++;
+   }
+}
+
+
+/******************************************************************
+ * Driver functions
+ ******************************************************************/
+static irqreturn_t enet_wp_irq_handler(int irq, void *dev_id)
+{
+   struct net_device *dev = dev_id;
+   irqreturn_t rc;
+
+   spin_lock(&dev->tx_global_lock);
+   rc = winEth_interrupt(dev);
+   spin_unlock(&dev->tx_global_lock);
+   return rc;
+}
+
+static int enet_wp_open(struct net_device *dev)
+{
+   unsigned long flags = 0;
+
+#if WP_ENET_DEBUG
+   printk("%s: enet_wp_open:\n", dev->name);
+#endif
+
+   if (dev->watchdog_timeo <= 0)
+      dev->watchdog_timeo = (HZ >> 1);
+
+   spin_lock_irqsave(&dev->tx_global_lock, flags);
+   if (winEth_init(dev->base_addr)) {
+      printk("%s: Enet host Init Error\n", dev->name);
+      spin_unlock_irqrestore(&dev->tx_global_lock, flags);
+      return -1;
+   }
+   if (request_irq(dev->irq, &enet_wp_irq_handler, IRQF_DISABLED, dev->name, dev)) {
+      printk("%s: enet_wp_open: Can't get irq %d\n", dev->name, dev->irq);
+      spin_unlock_irqrestore(&dev->tx_global_lock, flags);
+      return -EAGAIN;
+   }
+
+   register_rx_handler(&enet_wp_rx);
+   netif_start_queue(dev);
+   spin_unlock_irqrestore(&dev->tx_global_lock, flags);
+
+   printk("%s: found, using IRQ %d.\n", dev->name, dev->irq);
+   return 0;
+}
+
+
+
+static void enet_wp_tx_timeout(struct net_device *dev)
+{
+
+   /* Transmitter timeout, serious problems */
+   dev->stats.tx_errors++;
+   printk("%s: transmit timed out, reset\n", dev->name);
+
+   dev->trans_start = jiffies;
+   netif_wake_queue(dev);
+}
+
+#define MAX_TX_LOOP_COUNT 10000
+
+static int enet_wp_start_xmit(struct sk_buff *skb,
+				struct net_device *dev)
+{
+   unsigned long flags = 0;
+   unsigned int loop_count = MAX_TX_LOOP_COUNT;
+   unsigned int netif_queue_stoped = 0;
+
+   spin_lock_irqsave(&(dev->tx_global_lock), flags);
+
+
+#if WP_ENET_DEBUG
+   printk("%s: Send packet: skb=%08x\n", dev->name, (unsigned int) skb);
+#endif
+
+   while (loop_count) {
+      if (winEth_isTxFifoFull(skb->len) != 0) {
+	 loop_count--;
+      } else
+	  break;
+   }
+
+   if (loop_count == 0) {
+      spin_unlock_irqrestore(&(dev->tx_global_lock), flags);
+
+      printk("%s: Error when writing packet to controller: skb=%08x\n",
+		dev->name,  (unsigned int) skb);
+      netif_stop_queue(dev);
+      return -1;
+   }
+
+   winEth_write(skb->data, skb->len);
+
+   dev->stats.tx_bytes += skb->len;
+   dev->stats.tx_packets++;
+
+   dev->trans_start = jiffies;
+   netif_wake_queue(dev);
+   dev_kfree_skb(skb);
+
+   spin_unlock_irqrestore(&(dev->tx_global_lock), flags);
+
+   return 0;
+}
+
+
+static int enet_wp_close(struct net_device *dev)
+{
+#if WP_ENET_DEBUG
+   printk("%s: enet_wp_close:\n", dev->name);
+#endif
+
+   netif_stop_queue(dev);
+
+   /* Stop the controller */
+   if (enet_wp_stop(dev))
+      return -1;
+
+   free_irq(dev->irq, (void *) dev);
+
+   return 0;
+}
+
+static struct net_device_stats *enet_wp_get_stats(struct net_device *dev)
+{
+   return &dev->stats;
+}
+
+static void enet_wp_set_multicast(struct net_device *dev)
+{
+}
+
+static const struct net_device_ops wp_netdev_ops = {
+	.ndo_open               = enet_wp_open,
+	.ndo_stop               = enet_wp_close,
+	.ndo_start_xmit         = enet_wp_start_xmit,
+	.ndo_set_multicast_list = enet_wp_set_multicast,
+	.ndo_get_stats          = enet_wp_get_stats,
+	.ndo_tx_timeout         = enet_wp_tx_timeout,
+};
+
+
+static int __init wp_probe(void)
+{
+   struct net_device *dev;
+   int err;
+
+   if (prom_get_ethernet_addr(ethernet_addr)) {
+      printk("wp_probe: Failed to get MAC address\n");
+      return -ENODEV;
+   }
+   dev = alloc_etherdev(0);
+
+   if (!dev)
+      return -ENOMEM;
+   dev->base_addr          = WINPATH_ENET_BASE;
+   dev->irq                = IV_ENET_HOST+WINPATH_IRQ_BASE;
+   dev->netdev_ops = &wp_netdev_ops;
+   dev->dma                = 0;
+   memcpy(dev->dev_addr, ethernet_addr, 6);
+   strcpy(dev->name, ETH_DEV_NAME);
+
+   err = register_netdev(dev);
+   if (err) {
+      free_netdev(dev);
+      return err;
+   }
+   spin_lock_init(&dev->tx_global_lock);
+
+   wp_dev = dev;
+   printk("%s: device found at %#lx, using IRQ %d.\n", ETH_DEV_NAME, dev->base_addr, dev->irq);
+
+   return 0;
+}
+
+
+module_init(wp_probe);
diff --git a/drivers/net/wintegra/winpath3/enet_host/enet_host.c b/drivers/net/wintegra/winpath3/enet_host/enet_host.c
new file mode 100644
index 0000000..d490ddc
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/enet_host.c
@@ -0,0 +1,400 @@
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <asm/dma.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/init.h>
+
+#include "enet_host.h"
+#include "eth_regs.h"
+#include "rx_tx_ctrl_word.h"
+
+#include <asm/wintegra/wds.h>
+#include <asm/wintegra/winpath.h>
+
+#define __DEBUG_WIN_ETH 0
+#define ETH_DEV_NAME             "WpENET"
+#define WIN_DUPLEX PHY_DUPLEX_FULL
+#define WIN_PHY_ADDR ((unsigned char)0x00)
+
+static unsigned int no_of_tx_busy_buffers;
+static unsigned int speed_fast = 1;
+static unsigned int tx_done_cnt;
+static rx_int_handler_t rxHandler;
+static unsigned int iobase;
+
+#define read_register(reg) WDS3_WINPATH_RIF_READ(iobase+(reg))
+#define write_register(reg, val) (WDS3_WINPATH_RIF_WRITE(val, iobase+(reg)))
+
+static void drop_packet(int length)
+{
+   unsigned int data;
+
+#if __DEBUG_WIN_ETH
+   printk("drop_packet: length 0x%08x\n", length);
+#endif
+   while (length > 0) {
+      data = read_register(ETH_RX_DATA_FIFO_ADDR_REG);
+      length -= 4;
+   }
+}
+
+void register_rx_handler(rx_int_handler_t handler)
+{
+   rxHandler = handler;
+}
+
+static void winMac_set_speed(unsigned int speed)
+{
+   unsigned int reg = read_register(ETH_PHY_SUPPORT_REG);
+   switch (speed) {
+   case SPEED_10M:
+	if (reg & ETH_PHY_SPEED_100)
+	   write_register(ETH_PHY_SUPPORT_REG, reg & (~ETH_PHY_SPEED_100));
+	break;
+
+   case SPEED_100M:
+	if ((reg & ETH_PHY_SPEED_100) == 0)
+	    write_register(ETH_PHY_SUPPORT_REG, reg | ETH_PHY_SPEED_100);
+	break;
+
+   default:
+	printk("winMac_set_speed: invalid speed %d\n", speed);
+   }
+}
+
+static void winMac_set_duplex(unsigned int duplex)
+{
+   unsigned int reg = read_register(ETH_MAC_CONF_REG_2);
+   if (duplex == PHY_DUPLEX_FULL) {
+      if ((reg & MAC_CONF_2_FULL_DUPLEX) == 0)
+	write_register(ETH_MAC_CONF_REG_2, reg | MAC_CONF_2_FULL_DUPLEX);
+   } else if (duplex == PHY_DUPLEX_HALF) {
+      if (reg & MAC_CONF_2_FULL_DUPLEX)
+	write_register(ETH_MAC_CONF_REG_2, reg & (~MAC_CONF_2_FULL_DUPLEX));
+   } else {
+      printk("winMac_set_duplex: invalid duplex %d\n", duplex);
+   }
+}
+
+/* after auto neg completed and the phy is configured - set the mac registers with the actual parameters (retrieved from the phy) */
+static int winMac_reinit(unsigned int speed, unsigned int duplex)
+{
+   if (speed == PHY_SPEED_100M) {
+      winMac_set_speed(SPEED_100M);
+   } else {
+      winMac_set_speed(SPEED_10M);
+   }
+
+   if (duplex == PHY_DUPLEX_FULL) {
+      winMac_set_duplex(PHY_DUPLEX_FULL);
+   } else {
+      winMac_set_duplex(PHY_DUPLEX_HALF);
+   }
+   return 0;
+}
+
+#define WAIT_CYCLES_FOR_MII_BUSY 0x5000
+static int winMacInit(unsigned char phy_addr)
+{
+   unsigned int phy_reg;
+   unsigned int delay = 1000;
+   unsigned int speed = PHY_SPEED_100M, duplex = PHY_DUPLEX_FULL;
+
+   /* Read PHY configuration to learn setup after auto-neg completed */
+   write_register(ETH_MCFG, 0x7); /* set slowest clk ratio for mdc */
+   while (delay)
+      delay--;
+
+   do {
+      /* Poll auto-neg completed bit -- till completion */
+      write_register(ETH_MADR, (phy_addr<<8) | 0x5); /* set dst. phy and reg #5 */
+      write_register(ETH_MCMD,  0x0);
+      write_register(ETH_MCMD, 0x1);
+      write_register(ETH_MCMD, 0x0);
+      delay = WAIT_CYCLES_FOR_MII_BUSY;
+      while (delay) {
+	 delay--;
+	 phy_reg = read_register(ETH_MIND);
+	 if ((phy_reg & 0x00000005) == 0) /* wait while busy and read data is not available */
+		break;
+      }
+      if (delay == 0) {
+	 printk("winMacInit: MII busy / read not available is set for %d cycles\n", WAIT_CYCLES_FOR_MII_BUSY);
+	 return -EBUSY;
+      }
+      phy_reg = read_register(ETH_MRDD); /* read the phy register value */
+   }
+   while ((phy_reg & 0x00000020) == 0)
+      ; /* if bit 5 is un-set the auto-neg wasn't completed */
+
+   /* pick the duplex and speed */
+   if (phy_reg & (1<<6 | 1<<8))
+      duplex = PHY_DUPLEX_FULL;
+   else if (phy_reg & (1<<5 | 1<<7))
+      duplex = PHY_DUPLEX_HALF;
+
+   if (phy_reg & (1<<7 | 1<<8))
+      speed = PHY_SPEED_100M;
+   else if (phy_reg & (1<<5 | 1<<6))
+      speed = PHY_SPEED_10M;
+
+   /* Reinitialize MAC according to the change of PHY status after auto-negotiation is complete. */
+   winMac_reinit(speed, duplex);
+
+   return 0;
+}
+
+#define ETH_FC_RHDFT (20 << 1)      /* renable receive */
+#define AUTO_FC_RBTH (23 << 24)     /* number of full buffers (each buffer is 64 bytes) */
+#define AUTO_FC_RPS  (500 << 8)     /* in bytes */
+int winEth_init(unsigned int _iobase)
+{
+   unsigned int reg;
+   unsigned int gen_statistics_reg2;
+   packet_recv_status_word rx_status;
+
+   iobase = _iobase;
+
+   /* soft reset */
+#if __DEBUG_WIN_ETH
+   printk("winEth_init: Aborting receive..\n");
+#endif
+   write_register(ETH_MAC_CONF_REG_1, 0);
+
+   /* diasble IRQ */
+#if __DEBUG_WIN_ETH
+   printk("winEth_init: Masking all interrupts..\n");
+#endif
+   write_register(ETH_TX_MASK_INT_REG, TX_MASK_PKT_TX_END | TX_MASK_FIFO_BUFFER_FREE | TX_MASK_WRITE_FIFO_FULL);
+   write_register(ETH_RX_MASK_INT_REG, RX_MASK_OVERRUN | RX_MASK_PKT_RECV |
+	RX_MASK_PARTIAL_PKT_RECV | RX_MASK_READ_ON_FIFO_EMPTY);
+
+   /* clear any pending IRQs (clear by write) */
+   reg = read_register(ETH_RX_INT_REG);
+   write_register(ETH_RX_INT_REG, reg);
+
+   reg = read_register(ETH_TX_INT_REG);
+   write_register(ETH_TX_INT_REG, reg);
+
+   gen_statistics_reg2 = read_register(ETH_GEN_STS2_REG);
+
+   while (gen_statistics_reg2 & 0x01fc0000) {
+      rx_status.reg = read_register(ETH_RX_STATUS_FIFO_ADDR_REG);
+      drop_packet(rx_status.bits.packet_length);
+      gen_statistics_reg2 = read_register(ETH_GEN_STS2_REG);
+   }
+
+   /* mac reset (Reset the MAC device to its default state) */
+#if __DEBUG_WIN_ETH
+   printk("winEth_init: Resetting mac to default state..\n");
+#endif
+   write_register(ETH_MODE_REG, 0x84802000);
+
+   if (WIN_DUPLEX == PHY_DUPLEX_FULL)
+      write_register(ETH_AUTO_FC_REG, 0);
+   else
+      write_register(ETH_AUTO_FC_REG, 0);
+
+   write_register(ETH_MAC_CONF_REG_2, MAC_CONF_2_FULL_DUPLEX  | MAC_CONF_2_FRAME_LENGTH_CHK
+	| MAC_CONF_2_CRC_ENABLE | MAC_CONF_2_PAD_CRC | MAC_CONF_2_AUTO_DETECT_PAD); /* if a short pkt is
+	untagged it will be padded to 64 bytes. If it carries a vlan tag it will be padded to 68 bytes
+	(as standard requires) */
+   if (WIN_DUPLEX == PHY_DUPLEX_FULL)
+      write_register(Ex_IPGT, 0x15);
+   else
+      write_register(Ex_IPGT, 0x12);
+
+   write_register(Ex_IPGR, 0xc12);
+
+   write_register(ETH_MAX_FRAME_REG, 0x0600);
+
+   write_register(MII_MANAGE_CONF_REG, 0x1c);
+
+   if (speed_fast)
+      write_register(ETH_PHY_SUPPORT_REG, ETH_PHY_SPEED_100);
+   else
+      write_register(ETH_PHY_SUPPORT_REG, 0);
+
+
+   /* mac init (initialise the Phy chip and to copy the desired mac address into the device) */
+   if (winMacInit(WIN_PHY_ADDR)) {
+      printk("winEth_init: Failed when reconfiguring the PHY device!\n");
+      return -EBUSY;
+   }
+
+   /* enable interrupts */
+#if __DEBUG_WIN_ETH
+   printk("winEth_init: enabling interrupts..\n");
+#endif
+   write_register(ETH_TX_MASK_INT_REG, TX_INT_PKT_TX_END | TX_MASK_FIFO_BUFFER_FREE);
+   write_register(ETH_RX_MASK_INT_REG, RX_MASK_PARTIAL_PKT_RECV | RX_MASK_READ_ON_FIFO_EMPTY |
+			RX_MASK_OVERRUN);
+
+   if (WIN_DUPLEX == PHY_DUPLEX_FULL)
+      write_register(ETH_MAC_CONF_REG_1, MAC_CONF_1_PASS_ALL_RECV_FRAMES | MAC_CONF_1_RECV_ENABLE | MAC_CONF_1_RX_FLOW_CTRL | MAC_CONF_1_TX_FLOW_CTRL);
+   else
+      write_register(ETH_MAC_CONF_REG_1, MAC_CONF_1_PASS_ALL_RECV_FRAMES | MAC_CONF_1_RECV_ENABLE);
+
+   return 0;
+}
+
+
+#define TOTAL_NUMBER_OF_TX_BUFFERS 24
+int winEth_isTxFifoFull(unsigned int pkt_length)
+{
+  no_of_tx_busy_buffers = read_register(ETH_GEN_STS2_REG) & ETH_GEN_STS2_BUSY_TX_MASK;
+  no_of_tx_busy_buffers >>= 13;
+  if (((TOTAL_NUMBER_OF_TX_BUFFERS - no_of_tx_busy_buffers) << 6) < pkt_length)
+     return -EBUSY;
+  return 0;
+}
+
+
+void winEth_write(unsigned char *dataPtr, unsigned int pkt_length)
+{
+  unsigned char *pData = dataPtr;
+  int more_to_write = pkt_length;
+  packet_transmit_ctrl_word tx_ctrl;
+
+  while (more_to_write > 0) {
+    write_register(ETH_TX_DATA_FIFO_ADDR_REG, *((unsigned int *)(pData)));
+    more_to_write -= 4;
+    pData += 4;
+  }
+
+  tx_ctrl.reg = 0x0;
+  tx_ctrl.bits.packet_length = pkt_length;
+#if __DEBUG_WIN_ETH
+  printk("winEth_start_xmit: writing Tx control word 0x%08x\n", tx_ctrl.reg);
+#endif
+  write_register(ETH_TX_CTRL_FIFO_ADDR_REG, tx_ctrl.reg);
+}
+
+static void winEth_tx_done(void)
+{
+#if __DEBUG_WIN_ETH
+   printk("WinEth_tx_done()\n");
+#endif
+
+   tx_done_cnt++;
+}
+
+unsigned int winEth_read(unsigned char *pRxBuffer)
+{
+  packet_recv_status_word rx_status;
+  long length;
+
+  rx_status.reg = read_register(ETH_RX_STATUS_FIFO_ADDR_REG);
+
+#if __DEBUG_WIN_ETH
+  printk("winEth_read: recv status word 0x%08x\n", rx_status.reg);
+#endif
+
+  if (rx_status.bits.recv_ok) {
+    length = rx_status.bits.packet_length;
+    while (length > 0) {
+      *((unsigned int *)pRxBuffer) = read_register(ETH_RX_DATA_FIFO_ADDR_REG);
+      pRxBuffer += 4;
+      length -= 4;
+    }
+    return rx_status.bits.packet_length;
+  } else if (rx_status.bits.vlan_detected | rx_status.bits.unsupported_opcode /*| rx_status.bits.pause_control_frame*/ |
+	rx_status.bits.control_frame | rx_status.bits.non_octet | rx_status.bits.lenght_outofrange |
+	rx_status.bits.lenght_err | rx_status.bits.crc_err | rx_status.bits.code_violation) {
+      length = rx_status.bits.packet_length;
+#if __DEBUG_WIN_ETH
+      printk("winEth_read: dropping pkt with Rx status 0x%08x\n", rx_status.reg);
+#endif
+
+      drop_packet(length);
+      return 0;
+   } else {
+      printk("winEth_read: Unsupported event rx_status.reg 0x%08x\n", rx_status.reg);
+      return 0;
+   }
+
+}
+
+void winEth_stop(void)
+{
+   unsigned int reg;
+
+#if __DEBUG_WIN_ETH
+      printk("winEth_stop()\n");
+#endif
+
+   /* disable recv. */
+   reg = read_register(ETH_MAC_CONF_REG_1);
+   write_register(ETH_MAC_CONF_REG_1,  reg & (~MAC_CONF_1_RECV_ENABLE));
+
+   /* diasble IRQ */
+   write_register(ETH_TX_MASK_INT_REG, TX_MASK_PKT_TX_END | TX_MASK_FIFO_BUFFER_FREE | TX_MASK_WRITE_FIFO_FULL);
+   write_register(ETH_RX_MASK_INT_REG, RX_MASK_OVERRUN | RX_MASK_PKT_RECV |
+	RX_MASK_PARTIAL_PKT_RECV | RX_MASK_READ_ON_FIFO_EMPTY);
+}
+
+
+#define BREAK_RECV_LOOP_AFTER_READING_X_PKTS 24/* if the incoming pckts is in steady stream break the recv. loop after X pkts */
+irqreturn_t winEth_interrupt(struct net_device *dev)
+{
+   rx_int_word rx_int;
+   static unsigned int rx_int_cnt;
+   static unsigned int tx_int_cnt;
+
+   tx_int_word tx_int;
+   static unsigned int tx_int_err;
+
+   unsigned int gen_statistics_reg2;
+   unsigned int recv_loop = rx_int_cnt;
+
+   rx_int.reg = read_register(ETH_RX_INT_REG);
+   rx_int.reg &= 0xf0000000;
+
+
+   if (rx_int.bits.pkt_recv) {
+     gen_statistics_reg2 = read_register(ETH_GEN_STS2_REG);
+     while (gen_statistics_reg2 & 0x01fc0000) {
+       if (rxHandler)
+	   rxHandler(dev);
+       rx_int_cnt++;
+       if (rx_int_cnt - recv_loop >= BREAK_RECV_LOOP_AFTER_READING_X_PKTS) {
+#if __DEBUG_WIN_ETH
+	printk("winEth_interrupt: breaking recv. loop after %d successive packets\n",
+			BREAK_RECV_LOOP_AFTER_READING_X_PKTS);
+#endif
+	break;
+	}
+       gen_statistics_reg2 = read_register(ETH_GEN_STS2_REG);
+     }
+   } else
+     printk("winEth_interrupt: NO packet received rx_int.reg 0x%08x\n", rx_int.reg);
+
+   tx_int.reg = read_register(ETH_TX_INT_REG);
+   tx_int.reg &= 0xe0000000;
+
+   if (tx_int.bits.tx_end) {
+     winEth_tx_done();
+     tx_int_cnt++;
+   }
+
+   if (tx_int.bits.write_on_fifo_full) {
+#if __DEBUG_WIN_ETH
+     printk("winEth_interrupt: attempt to tx while there is no free buffer\n");
+#endif
+     tx_int_err++;
+   }
+
+   if (rx_int.reg)
+     write_register(ETH_RX_INT_REG, rx_int.reg);
+
+   if (tx_int.reg)
+     write_register(ETH_TX_INT_REG, tx_int.reg);
+
+   return IRQ_HANDLED;
+}
diff --git a/drivers/net/wintegra/winpath3/enet_host/enet_host.h b/drivers/net/wintegra/winpath3/enet_host/enet_host.h
new file mode 100644
index 0000000..f4396a4
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/enet_host.h
@@ -0,0 +1,26 @@
+#ifndef __WIN_ETH_HOST___H_
+#define __WIN_ETH_HOST___H_
+
+#include <linux/netdevice.h>
+
+#define PHY_SPEED_100M       ((1<<8) | (1<<7))
+#define PHY_SPEED_10M        ((1<<6) | (1<<5))
+#define PHY_DUPLEX_FULL_100M (1<<8)
+#define PHY_DUPLEX_FULL_10M  (1<<6)
+typedef enum {SPEED_10M, SPEED_100M} MAC_SPEED;
+typedef enum {SPEED_10MHD, SPEED_10MFD, SPEED_100MHD, SPEED_100MFD} MAC_MODE;
+#define PHY_DUPLEX_FULL 1
+#define PHY_DUPLEX_HALF 0
+
+typedef void (*rx_int_handler_t)(struct net_device *dev);
+
+
+int winEth_init(unsigned int _iobase);
+unsigned int winEth_read(unsigned char *pRxBuffer);
+int winEth_isTxFifoFull(unsigned int pkt_length);
+void winEth_write(unsigned char *dataPtr, unsigned int pkt_length);
+void winEth_stop(void);
+irqreturn_t winEth_interrupt(struct net_device *dev);
+void register_rx_handler(rx_int_handler_t handler);
+
+#endif /*__WIN_ETH_HOST___H_*/
diff --git a/drivers/net/wintegra/winpath3/enet_host/eth_regs.h b/drivers/net/wintegra/winpath3/enet_host/eth_regs.h
new file mode 100644
index 0000000..d865b8f
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/eth_regs.h
@@ -0,0 +1,202 @@
+#ifndef ___ETH_REGS__H_
+#define ___ETH_REGS__H_
+
+
+#include <asm/wintegra/winpath.h>
+
+#define ETH_MODE_REG	              (0x604)
+
+#define MODE_DISCARD_SMALL_FRAMES	 (1 << 31)
+#define MODE_DISCARD_MULTICAST_FRAMES	 (1 << 30)
+#define MODE_DISCARD_BROADCAST_FRAMES	 (1 << 29)
+#define MODE_DISCARD_NONmySPACE_FRAMES	 (1 << 28)
+#define MODE_DISCARD_LEN_CHECK_ERR	 (1 << 27)
+#define MODE_DISCARD_CRC_ERR		 (1 << 26)
+#define MODE_AUTO_ZERO_STATISTICS   	 (1 << 25)
+#define MODE_CLEAR_STATISTICS		 (1 << 24)
+#define MODE_ENABLE_STATISTICS		 (1 << 23)
+#define MODE_RX_CLEAR_STATUS		 (1 << 22)
+#define MODE_RX_PARTIAL_PKT_TRSHOLD     (0x7f << 15)
+#define MODE_RX_MODE			 (1 << 14)
+#define MODE_FUNCTIONAL_MODE		 (1 << 13)
+#define MODE_MII_MANAGE_SELECT          (3 << 11)
+
+
+
+#define ETH_AUTO_FC_REG	         (0x608)
+
+#define AUTO_FC_SET_FLOW_CTRL		 (1 << 0)
+
+
+#define ETH_RX_INT_REG	              	 (0x60c)
+
+#define RX_INT_OVERRUN		         (1 << 31)
+#define RX_INT_PKT_RECV		 (1 << 30)
+#define RX_INT_PARTIAL_PKT_RECV	 (1 << 29)
+#define RX_INT_READ_FIFO_EMPTY		 (1 << 28)
+
+
+#define ETH_RX_MASK_INT_REG             (0x610)
+
+#define RX_MASK_OVERRUN		 (1 << 31)
+#define RX_MASK_PKT_RECV		 (1 << 30)
+#define RX_MASK_PARTIAL_PKT_RECV	 (1 << 29) /* go hi when treshold of pkt size is reached */
+#define RX_MASK_READ_ON_FIFO_EMPTY	 (1 << 28)
+
+
+#define ETH_TX_INT_REG	                 (0x614)
+
+#define TX_INT_PKT_TX_END		 (1 << 31)
+#define TX_INT_FIFO_BUFFER_FREE	 (1 << 30)
+#define TX_INT_WRITE_ON_FIFO_FULL	 (1 << 29)
+
+
+#define ETH_TX_MASK_INT_REG             (0x618)
+
+#define TX_MASK_PKT_TX_END		 (1 << 31)
+#define TX_MASK_FIFO_BUFFER_FREE	 (1 << 30)
+#define TX_MASK_WRITE_FIFO_FULL	 (1 << 29)
+
+
+#define ETH_GEN_STS1_REG                (0x61c)
+
+#define ETH_GEN_STS2_REG                (0x620)
+
+#define ETH_GEN_STS2_BUSY_TX_MASK       0x0003e000
+
+
+#define ETH_TX_DATA_FIFO_ADDR_REG       (0x1fc)
+
+#define ETH_TX_CTRL_FIFO_ADDR_REG       (0x5fc)
+
+#define ETH_RX_DATA_FIFO_ADDR_REG       (0x3fc)
+
+#define ETH_RX_STATUS_FIFO_ADDR_REG     (0x600)
+
+
+#define MII_MANAGE_CONF_REG             (0x020)
+
+#define MII_MANAGE_COMMAND_REG          (0x024)
+
+#define MII_MANAGE_ADDR_REG             (0x028)
+
+#define MII_MANAGE_WRITE_DATA_REG       (0x02c)
+
+#define MII_MANAGE_READ_DATA_REG        (0x030)
+
+#define MII_MANAGE_INDICATORS           (0x034)
+
+
+#define ETH_MAC_CONF_REG_1	         (0x000)
+
+#define MAC_CONF_1_SOFT_RESET	         (1 << 15)
+#define MAC_CONF_1_SIMULATION_RESET     (1 << 14)
+#define MAC_CONF_1_RX_DOMAIN_RESET      (1 << 11)
+#define MAC_CONF_1_RX_FUNC_LOGIC_RESET  (1 << 10)
+#define MAC_CONF_1_TX_DOMAIN_RESET	 (1 << 9)
+#define MAC_CONF_1_TX_FUNC_LOGIC_RESET  (1 << 8)
+#define MAC_CONF_1_LOOPBACK		 (1 << 4)
+#define MAC_CONF_1_TX_FLOW_CTRL	 (1 << 3)
+#define MAC_CONF_1_RX_FLOW_CTRL	 (1 << 2)
+#define MAC_CONF_1_PASS_ALL_RECV_FRAMES (1 << 1)
+#define MAC_CONF_1_RECV_ENABLE		 (1 << 0)
+
+
+#define ETH_MAC_CONF_REG_2              (0x004)
+
+#define MAC_CONF_2_EXCESS_DEFER	 (1 << 14)
+#define MAC_CONF_2_BACKPRESSURE	 (1 << 13)
+#define MAC_CONF_2_NO_BACKOFF		 (1 << 12)
+#define MAC_CONF_2_LONG_PREAMBLE_ENFORCE   (1 << 9)
+#define MAC_CONF_2_PURE_PREAMBLE_ENFORCE   (1 << 8)
+#define MAC_CONF_2_AUTO_DETECT_PAD 	 (1 << 7)
+#define MAC_CONF_2_VLAN_PAD		 (1 << 6)
+#define MAC_CONF_2_PAD_CRC   		 (1 << 5)
+#define MAC_CONF_2_CRC_ENABLE		 (1 << 4)
+#define MAC_CONF_2_DELAYED_CRC		 (1 << 3)
+#define MAC_CONF_2_HUGE_FRAME_ENABLE    (1 << 2)
+#define MAC_CONF_2_FRAME_LENGTH_CHK     (1 << 1)
+#define MAC_CONF_2_FULL_DUPLEX		 (1 << 0)
+
+
+#define Ex_IPGT                   	 (0x008)
+#define Ex_IPGR                         (0x00c)
+#define ETH_COLLISION_WIN_REG           (0x010)
+#define ETH_MAX_FRAME_REG               (0x014)
+
+#define ETH_PHY_SUPPORT_REG             (0x018)
+
+#define ETH_PHY_RESET_MII_LOGIC         (1 << 15)
+#define ETH_PHY_SPEED_100               (1 << 8)
+
+#define ETH_TEST_REG		         (0x01c)
+#define ETH_STATION_ADDR_LOW_REG        (0x040)
+#define ETH_STATION_ADDR_MIDDLE_REG     (0x044)
+#define ETH_STATION_ADDR_HIGH_REG       (0x048)
+
+#define	ETH_MCFG		 (0x020)
+#define	ETH_MCMD		 (0x024)
+#define	ETH_MADR		 (0x028)
+#define	ETH_MRDD		 (0x030)
+#define	ETH_MIND		 (0x034)
+
+
+
+/*Ethernet Statistics Counters*/
+/******************************/
+
+/*Combined TX and RX Counters*/
+#define Ex_TR64			 (0x080)
+#define Ex_TR127			 (0x084)
+#define Ex_TR255			 (0x088)
+#define Ex_TR511			 (0x08c)
+#define Ex_TR1K			 (0x090)
+#define Ex_TRMAX			 (0x094)
+#define Ex_TRMGV			 (0x098)
+
+/*Receive Statistics Counters*/
+#define Ex_RBYT			 (0x09c)
+#define Ex_RPKT			 (0x0a0)
+#define Ex_RFCS			 (0x0a4)
+#define Ex_RMCA			 (0x0a8)
+#define Ex_RBCA			 (0x0ac)
+#define Ex_RXCF			 (0x0b0)
+#define Ex_RXPF			 (0x0b4)
+#define Ex_RXUO			 (0x0b8)
+#define Ex_RALN			 (0x0bc)
+#define Ex_RFLR			 (0x0c0)
+#define Ex_RCDE			 (0x0c4)
+#define Ex_RCSE			 (0x0c8)
+#define Ex_RUND			 (0x0cc)
+#define Ex_ROVR			 (0x0d0)
+#define Ex_RFRG			 (0x0d4)
+#define Ex_RJBR			 (0x0d8)
+#define Ex_RDRP			 (0x0dc)
+
+/*Transmit Statistics Counters*/
+#define Ex_TBYT			 (0x0e0)
+#define Ex_TPKT			 (0x0e4)
+#define Ex_TMCA			 (0x0e8)
+#define Ex_TBCA			 (0x0ec)
+#define Ex_TXPF			 (0x0f0)
+#define Ex_TDFR			 (0x0f4)
+#define Ex_TEDF			 (0x0f8)
+#define Ex_TSCL			 (0x0fc)
+#define Ex_TMCL			 (0x100)
+#define Ex_TLCL			 (0x104)
+#define Ex_TXCL			 (0x108)
+#define Ex_TNCL			 (0x10c)
+#define Ex_TPFH			 (0x110)
+#define Ex_TDRP			 (0x114)
+#define Ex_TJBR			 (0x118)
+#define Ex_TFCS			 (0x11c)
+#define Ex_TXCF			 (0x120)
+#define Ex_TOVR			 (0x124)
+#define Ex_TUND			 (0x128)
+#define Ex_TFRG			 (0x12c)
+#define Ex_CAR1			 (0x130)
+#define Ex_CAR2			 (0x134)
+#define Ex_CAM1			 (0x138)
+#define Ex_CAM2			 (0x13c)
+
+#endif /*___ETH_REGS__H_*/
diff --git a/drivers/net/wintegra/winpath3/enet_host/rx_tx_ctrl_word.h b/drivers/net/wintegra/winpath3/enet_host/rx_tx_ctrl_word.h
new file mode 100644
index 0000000..6315417
--- /dev/null
+++ b/drivers/net/wintegra/winpath3/enet_host/rx_tx_ctrl_word.h
@@ -0,0 +1,59 @@
+typedef union __packet_recv_status_word{
+  volatile unsigned int  reg;  /* Access full 32-bit */
+  struct {                      /* Bit-field access */
+	  unsigned vlan_detected:1;  /* 31 */
+	  unsigned unsupported_opcode:1;  /* 30 */
+	  unsigned pause_control_frame:1;  /* 29 */
+	  unsigned control_frame:1;  /* 28 */
+	  unsigned non_octet:1;  /* 27 */
+	  unsigned broadcast_packet:1;  /* 26 */
+	  unsigned multicast_packet:1;  /* 25 */
+	  unsigned recv_ok:1;  /* 24 */
+	  unsigned lenght_outofrange:1;  /* 23 */
+	  unsigned lenght_err:1;  /* 22 */
+	  unsigned crc_err:1;  /* 21 */
+	  unsigned code_violation:1;  /* 20 */
+	  unsigned carrier_event_detected:1;  /* 19 */
+	  unsigned RXDV_event_detected:1;  /* 18 */
+	  unsigned packet_previously_ignored:1;  /* 17 */
+	  unsigned overrun:1;  /* 16 */
+	  unsigned packet_length:16; /* 0-15 */
+
+  } volatile bits;         /* For bit-field access */
+} volatile packet_recv_status_word;
+
+
+typedef union __packet_transmit_ctrl_word{
+  volatile unsigned int  reg;  /* Access full 32-bit */
+  struct {                      /* Bit-field access */
+	  unsigned override:1;
+	  unsigned padding_enable:1;
+	  unsigned crc_enable:1;
+	  unsigned reserved:13;
+	  unsigned packet_length:16;
+
+  } volatile bits;         /* For bit-field access */
+} volatile packet_transmit_ctrl_word;
+
+typedef union __rx_int_word{
+  volatile unsigned int  reg;  /* Access full 32-bit */
+  struct {                      /* Bit-field access */
+	  unsigned overrun:1;
+	  unsigned pkt_recv:1;
+	  unsigned partial_pkt:1;
+	  unsigned read_on_fifo_empty:1;
+	  unsigned reserved:28;
+
+  } volatile bits;         /* For bit-field access */
+} volatile rx_int_word;
+
+typedef union __tx_int_word{
+  volatile unsigned int  reg;  /* Access full 32-bit */
+  struct {                      /* Bit-field access */
+	  unsigned tx_end:1;
+	  unsigned buffer_free:1;
+	  unsigned write_on_fifo_full:1;
+	  unsigned reserved:29;
+
+  } volatile bits;         /* For bit-field access */
+} volatile tx_int_word;
-- 
1.7.0.4

