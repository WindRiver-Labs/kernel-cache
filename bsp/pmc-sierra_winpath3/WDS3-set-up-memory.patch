From e123b2a97fa2c7ef9beaad73ce416ab4f02c2b28 Mon Sep 17 00:00:00 2001
From: Jiang, Bin <bin.jiang@windriver.com>
Date: Mon, 21 Mar 2011 11:06:05 +0800
Subject: [PATCH 03/13] WDS3: set up memory

Extracted from vendor drop(linux-mti-2.6.29.4-1 with modifications for WDS3).

Define memory regions of WDS3 board. There are 6 regions defined for WDS3 as
following:

region 		size			note
region1		0x00001000		Reserved. The lowest region.
region2		0x009ff000		Used by WinMon.
region3		0x04fff000		Used by WinMon.
region4		kernel size		Used by linux.
region5		rest of memory		Used by linux.
region6		0x02000000		Used by WDDI. The highest region.

Signed-off-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/wintegra/wds3/Makefile      |    3 +-
 arch/mips/wintegra/wds3/wds3-memory.c |  186 +++++++++++++++++++++++++++++++++
 2 files changed, 188 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/wintegra/wds3/wds3-memory.c

diff --git a/arch/mips/wintegra/wds3/Makefile b/arch/mips/wintegra/wds3/Makefile
index 3dbd9ab..7a6c459 100644
--- a/arch/mips/wintegra/wds3/Makefile
+++ b/arch/mips/wintegra/wds3/Makefile
@@ -5,6 +5,7 @@
 # Copyright (C) 2008 Wind River Systems, Inc.
 #   written by Ralf Baechle <ralf@linux-mips.org>
 #
-obj-y				:= wds3-init.o wds3-int.o
+obj-y				:= wds3-init.o wds3-int.o \
+				   wds3-memory.o
 
 EXTRA_CFLAGS += -Werror
diff --git a/arch/mips/wintegra/wds3/wds3-memory.c b/arch/mips/wintegra/wds3/wds3-memory.c
new file mode 100644
index 0000000..8f2be34
--- /dev/null
+++ b/arch/mips/wintegra/wds3/wds3-memory.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2000-2010 Wintegra, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * PROM library functions for acquiring/using memory descriptors given to
+ * us from the Winmon.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/pfn.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/sections.h>
+
+#include <asm/wintegra/winpath.h>
+#include <asm/wintegra/winmon.h>
+
+enum winmon_memtypes {
+   winmon_dontuse,/*BOOT_MEM_RESERVED: owned by Linux, don't allocate */
+   winmon_prom,   /*BOOT_MEM_ROM_DATA: Owned by bootloader: can be taken by Linux after kernel boot */
+   winmon_free,   /*BOOT_MEM_RAM: free memory, can be allocated */
+   wddi_reserved, /*BOOT_MEM_RESERVED: reserved for WDDI/DPS*/
+};
+static struct prom_pmemblock mdesc[PROM_MAX_PMEMBLOCKS];
+
+#ifdef DEBUG
+static char *mtypes[3] = {
+	"Dont use memory",
+	"WinMon PROM memory",
+	"Free memmory",
+};
+#endif
+
+static char cmdline[COMMAND_LINE_SIZE];
+
+/* determined physical memory size, not overridden by command line args  */
+unsigned long physical_memsize = 0L;
+
+static struct prom_pmemblock * __init prom_getmdesc(void)
+{
+	unsigned int memsize;
+	char *ptr;
+	int           i = 0;
+	 wds_winpath_mem_bank_t *bank = 0;
+
+	/* otherwise look in the environment */
+	bank = &(wds.wds_wp[0].wds_winpath_mem_banks[WDS3_SIU_BUS_HOST_NUM-1]);
+
+	if (wds.wds_chip == WINTEGRA_SPO_ID) {
+		bank = &(wds.wds_wp[0].wds_winpath_mem_banks[WDS3_SIU_BUS_PARAM_NUM-1]);
+	}
+
+	physical_memsize = bank->wp_phys_bank_size;
+	printk(KERN_WARNING
+		"memsize not set in boot prom, set to default (%ldMb)\n", (physical_memsize >> 20));
+
+	/* SOC-it swaps, or perhaps doesn't swap, when DMA'ing the last
+	   word of physical memory */
+	physical_memsize -= PAGE_SIZE;
+
+	/* Check the command line for a memsize directive that overrides
+	   the physical/default amount */
+	strcpy(cmdline, arcs_cmdline);
+	ptr = strstr(cmdline, "memsize=");
+	if (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))
+		ptr = strstr(ptr, " memsize=");
+
+	if (ptr)
+		memsize = memparse(ptr + 8, &ptr);
+	else
+		memsize = physical_memsize;
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[i].type = winmon_dontuse;
+	mdesc[i].base = 0x00000000;
+	mdesc[i].size = 0x00001000;
+	 i++;
+
+	/* Winmon (and Minimon) code */
+	mdesc[i].type = wddi_reserved;/*should be reserved or else minimon image will be erased*/
+	mdesc[i].base = 0x00001000;/*0x00001000 used as base for the RT core (minimon) exception handlers base address */
+	mdesc[i].size = 0x009ff000;
+	i++;
+
+	/* Minimon sand box (heap, stack etc.) */
+	mdesc[i].type = wddi_reserved;
+	mdesc[i].base = 0x00A00000;
+	mdesc[i].size = 0x04fff000;
+	i++;
+
+	/* Linux image */
+	mdesc[i].type = winmon_dontuse;
+	mdesc[i].base = 0x05A00000;
+	mdesc[i].size = CPHYSADDR(PFN_ALIGN((unsigned long)&_end)) - mdesc[i].base;
+	i++;
+
+	/* Linux sand box (heap, stack etc.) */
+	mdesc[i].type = winmon_free;
+	mdesc[i].base = CPHYSADDR(PFN_ALIGN(&_end));
+	mdesc[i].size = memsize - WDS_HOST_SIZE - mdesc[i].base;
+	i++;
+
+	/* Application reserved address space */
+	if (WDS_HOST_SIZE) {
+		mdesc[i].type = wddi_reserved;
+		mdesc[i].base = memsize - WDS_HOST_SIZE;
+		mdesc[i].size = WDS_HOST_SIZE;
+	}
+
+	return &mdesc[0];
+}
+
+static int __init prom_memtype_classify(unsigned int type)
+{
+	switch (type) {
+	case winmon_free:
+		return BOOT_MEM_RAM;
+	case winmon_prom:
+		return BOOT_MEM_ROM_DATA;
+	case wddi_reserved:
+		return BOOT_MEM_RESERVED;
+	default:
+		return BOOT_MEM_RESERVED;
+	}
+}
+
+void __init prom_meminit(void)
+{
+	struct prom_pmemblock *p;
+
+#ifdef DEBUG
+	pr_debug("WinMon MEMORY DESCRIPTOR dump:\n");
+	p = prom_getmdesc();
+	while (p->size) {
+		int i = 0;
+		pr_debug("[%d,%p]: base<%08lx> size<%08lx> type<%s>\n",
+			 i, p, p->base, p->size, mtypes[p->type]);
+		p++;
+		i++;
+	}
+#endif
+	p = prom_getmdesc();
+
+	while (p->size) {
+		long type;
+		unsigned long base, size;
+
+		type = prom_memtype_classify(p->type);
+		base = p->base;
+		size = p->size;
+
+		add_memory_region(base, size, type);
+		p++;
+	}
+}
+
+void __init prom_free_prom_memory(void)
+{
+	unsigned long addr;
+	int i;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		free_init_pages("prom memory",
+				addr, addr + boot_mem_map.map[i].size);
+	}
+}
-- 
1.7.0.4

