From 673beeb3530b6ba81d3c56d96b7ad34bf17df951 Mon Sep 17 00:00:00 2001
From: Jiang, Bin <bin.jiang@windriver.com>
Date: Wed, 6 Apr 2011 16:39:47 +0800
Subject: [PATCH 07/13] WDS3: nand driver

Extracted from vendor drop(linux-mti-2.6.29.4-1 with modifications for WDS3).

NAND flash driver for ST Micro 128M NAND flash.

Signed-off-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/include/asm/wintegra/wds3.h   |    1 +
 arch/mips/wintegra/wds3/Makefile        |    2 +-
 arch/mips/wintegra/wds3/wds3-nand-dev.c |   35 ++++
 drivers/mtd/nand/Kconfig                |    8 +
 drivers/mtd/nand/Makefile               |    1 +
 drivers/mtd/nand/wds_nand.c             |  278 +++++++++++++++++++++++++++++++
 6 files changed, 324 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/wintegra/wds3/wds3-nand-dev.c
 create mode 100644 drivers/mtd/nand/wds_nand.c

diff --git a/arch/mips/include/asm/wintegra/wds3.h b/arch/mips/include/asm/wintegra/wds3.h
index fa47acb..7f8a8db 100644
--- a/arch/mips/include/asm/wintegra/wds3.h
+++ b/arch/mips/include/asm/wintegra/wds3.h
@@ -97,5 +97,6 @@ static inline unsigned int WDS3_GET_WINPATH_RIF_BASE(void)
 
 #define WDS_HOST_SIZE            0x02000000
 #define WDS3_LED_REG            (KSEG1ADDR(0x1f10001c))
+#define WDS3_NAND_BASE           0x1f001000
 
 #endif  /* !(_WINTEGRA_WDS3_H) */
diff --git a/arch/mips/wintegra/wds3/Makefile b/arch/mips/wintegra/wds3/Makefile
index 49c47b9..38c24e7 100644
--- a/arch/mips/wintegra/wds3/Makefile
+++ b/arch/mips/wintegra/wds3/Makefile
@@ -7,6 +7,6 @@
 #
 obj-y				:= wds3-init.o wds3-int.o \
 				   wds3-memory.o wds3-reset.o wds3-time.o \
-				   wds3-cmdline.o
+				   wds3-cmdline.o wds3-nand-dev.o
 
 EXTRA_CFLAGS += -Werror
diff --git a/arch/mips/wintegra/wds3/wds3-nand-dev.c b/arch/mips/wintegra/wds3/wds3-nand-dev.c
new file mode 100644
index 0000000..4c86c05
--- /dev/null
+++ b/arch/mips/wintegra/wds3/wds3-nand-dev.c
@@ -0,0 +1,35 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * NAND device of wds3 board.
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <asm/wintegra/wds.h>
+
+static struct resource nand_res[] = {
+	[0] = {
+		.name	= "nand base",
+		.start	= WDS3_NAND_BASE,
+		.end	= WDS3_NAND_BASE + 0x20000,
+		.flags	= IORESOURCE_MEM
+	}
+};
+
+static struct platform_device nand_device = {
+	.name		= "wds_nand",
+	.id		= -1,
+	.resource 	= nand_res,
+	.num_resources 	= ARRAY_SIZE(nand_res),
+};
+
+static int __init wds_nand_device_init(void)
+{
+        return platform_device_register(&nand_device);
+}
+
+module_init(wds_nand_device_init);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 3aa5142..f660675 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -496,4 +496,12 @@ config MTD_NAND_FSMC
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_WDS
+	bool "WDS NAND driver"
+	default n
+	depends on MTD_NAND && WINTEGRA_WDS3
+	help
+	  This enables the driver for the NAND flash controller on the
+	  WDS processors.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 8abc265..9ae0799 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -43,5 +43,6 @@ obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
+obj-$(CONFIG_MTD_NAND_WDS)		+= wds_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/wds_nand.c b/drivers/mtd/nand/wds_nand.c
new file mode 100644
index 0000000..f18efe0
--- /dev/null
+++ b/drivers/mtd/nand/wds_nand.c
@@ -0,0 +1,278 @@
+/*
+ * drivers/mtd/nand/ts7250.c
+ *
+ * Copyright (C) 2004 Technologic Systems (support@embeddedARM.com)
+ *
+ * Derived from drivers/mtd/nand/edb7312.c
+ *   Copyright (C) 2004 Marius Gr√∂ger (mag@sysgo.de)
+ *
+ * Derived from drivers/mtd/nand/autcpu12.c
+ *   Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   TS-7250 board which utilizes a Samsung 32 Mbyte part.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/wintegra/winmon.h>
+#include <asm/wintegra/winpath.h>
+#include <asm/wintegra/wds.h>
+#include <linux/platform_device.h>
+
+/*
+ * Constants for hardware specific CLE/ALE/NCE function
+*/
+/* Select the chip by setting nCE to low */
+#define NAND_CTL_SETNCE	1
+/* Deselect the chip by setting nCE to high */
+#define NAND_CTL_CLRNCE	2
+/* Select the command latch by setting CLE to high */
+#define NAND_CTL_SETCLE	3
+/* Deselect the command latch by setting CLE to low */
+#define NAND_CTL_CLRCLE	4
+/* Select the address latch by setting ALE to high */
+#define NAND_CTL_SETALE	5
+/* Deselect the address latch by setting ALE to low */
+#define NAND_CTL_CLRALE	6
+/* Set write protection by setting WP to high. Not used! */
+#define NAND_CTL_SETWP		7
+/* Clear write protection by setting WP to low. Not used! */
+#define NAND_CTL_CLRWP		8
+
+
+#define WDS_NAND_DATA  (WDS_NAND_BASE)
+#define WDS_NAND_ADDRLOFFS  (0x10000)
+#define WDS_NAND_CMDLOFFS   (0x20000)
+
+
+/*
+ * MTD structure for TS7250 board
+ */
+static unsigned int command_offset;
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "cmdlinepart", NULL };
+
+#define NUM_PARTITIONS 3
+
+#define readb(addr) (*(volatile unsigned char *)(addr))
+#define readw(addr) __ioswab16((*(volatile unsigned short *)(addr)))
+#define readl(addr) __ioswab32((*(volatile unsigned int *)(addr)))
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+
+#define writeb(b, addr) (*(volatile unsigned char *)(addr)) = (b)
+#define writew(b, addr) (*(volatile unsigned short *)(addr)) = (__ioswab16(b))
+#define writel(b, addr) (*(volatile unsigned int *)(addr)) = (__ioswab32(b))
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+
+/*
+ * Define static partitions for flash device
+ */
+static struct mtd_partition partition_info[] = {
+	{
+		.name		= "boot",
+		.offset		= 0x00000000,
+		.size		= 0x00200000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x00200000,
+		.size		= 0x01400000,
+	}, {
+		.name		= "osfs",
+		.offset		= 0x01600000,
+		.size		= 0x06A00000,
+	},
+};
+
+#endif
+
+static struct nand_ecclayout nand_oob_64 = {
+	.eccbytes = 24,
+	.eccpos = {
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38} }
+};
+
+
+
+static void wds_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *this = mtd->priv;
+#ifdef WDS3_DEBUG
+	printk("writeb off:%x %x\n", command_offset, byte);
+#endif
+	writeb(byte, this->IO_ADDR_W+command_offset);
+}
+
+static unsigned char wds_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned char res;
+
+#ifdef WDS3_DEBUG
+	printk("readb off:%x ", command_offset);
+#endif
+	res = readb(this->IO_ADDR_R+command_offset);
+#ifdef WDS3_DEBUG
+	printk("%x\n", res);
+#endif
+	return res;
+}
+
+static void wds_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+#ifdef WDS3_DEBUG
+	printk("wds_hwcontrol: cmd 0x%08x ctrl 0x%08x\n", cmd, ctrl);
+#endif
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+	   if ((ctrl & ~NAND_CTRL_CHANGE) == NAND_CTL_SETCLE)
+		command_offset = WDS_NAND_CMDLOFFS;
+	   else if ((ctrl & ~NAND_CTRL_CHANGE) == NAND_CTL_SETALE)
+		command_offset = WDS_NAND_ADDRLOFFS;
+	   else
+		command_offset = 0;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+	   wds_write_byte(mtd, cmd);
+}
+
+static int __init wds_init(struct platform_device *pdev)
+{
+	struct mtd_info *wds_mtd;
+	struct nand_chip *this;
+	const char *part_type = 0;
+	int mtd_parts_nb = 0;
+	struct mtd_partition *mtd_parts = 0;
+	struct resource *res;
+	void __iomem *io_base;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	/* Allocate memory for MTD device structure and private data */
+	wds_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
+	if (!wds_mtd) {
+		printk("Unable to allocate WDS NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	io_base = ioremap(res->start, res->end - res->start + 1);
+	if (io_base == NULL) {
+		printk(KERN_ERR "atmel_nand: ioremap failed\n");
+		kfree(wds_mtd);
+		return -EIO;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *)(&wds_mtd[1]);
+
+	/* Initialize structures */
+	memset(wds_mtd, 0, sizeof(struct mtd_info));
+	memset(this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	wds_mtd->priv = this;
+	wds_mtd->owner = THIS_MODULE;
+
+	/* insert callbacks */
+	this->IO_ADDR_R = io_base;
+	this->IO_ADDR_W = io_base;
+	this->cmd_ctrl   = wds_hwcontrol;
+	this->read_byte  = wds_read_byte;
+	this->dev_ready  = NULL;
+	this->chip_delay = /*12*/50;
+	this->ecc.mode   = NAND_ECC_SOFT;
+	this->ecc.layout = &nand_oob_64;
+	this->options = NAND_SAMSUNG_LP_OPTIONS | NAND_USE_FLASH_BBT;
+
+	printk("Searching for NAND flash...\n");
+	/* Scan to find existence of the device */
+	if (nand_scan(wds_mtd, 1)) {
+		kfree(wds_mtd);
+		return -ENXIO;
+	}
+#ifdef CONFIG_MTD_PARTITIONS
+	wds_mtd->name = "wds-nand";
+	mtd_parts_nb = parse_mtd_partitions(wds_mtd, part_probes, &mtd_parts, 0);
+	if (mtd_parts_nb > 0)
+		part_type = "command line";
+	else
+		mtd_parts_nb = 0;
+#endif
+	if (mtd_parts_nb == 0) {
+		mtd_parts = partition_info;
+		mtd_parts_nb = NUM_PARTITIONS;
+		part_type = "static";
+	}
+
+	/* Register the partitions */
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+	add_mtd_partitions(wds_mtd, mtd_parts, mtd_parts_nb);
+
+	platform_set_drvdata(pdev, wds_mtd);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit wds_cleanup(struct platform_device *pdev)
+{
+	struct mtd_info *wds_mtd = platform_get_drvdata(pdev);
+	/* Unregister the device */
+	del_mtd_device(wds_mtd);
+
+	/* Free the MTD device structure */
+	kfree(wds_mtd);
+}
+
+static struct platform_driver wds_nand_driver = {
+	.probe		= wds_init,
+	.remove		= __exit_p(wds_cleanup),
+	.driver		= {
+		.name	= "wds_nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init wds_nand_init(void)
+{
+	return platform_driver_register(&wds_nand_driver);
+}
+
+
+static void __exit wds_nand_exit(void)
+{
+	platform_driver_unregister(&wds_nand_driver);
+}
+
+
+module_init(wds_nand_init);
+module_exit(wds_nand_exit);
+
+MODULE_LICENSE("GPL");
-- 
1.7.0.4

