From 4f7b08d221881b04dfa5834b138c2be242533957 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Fri, 18 Dec 2009 14:06:31 +0800
Subject: [PATCH 09/20] ti_omap3530/mmc: MMC clock enable disable for power management

When there is no operation for mmc controller, it will disable f_clk
and i_clk to save power. While when any operation is in queue, it will
enable f_clk and i_clk in time.

[Original patch taken from OMAP35x-PSP-SDK-02.01.01.08 package.
http://software-dl.ti.com/dsps/dsps_registered_sw/sdo_sb/ \
targetcontent/psp/omap35x/index.html]

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/mmc/host/omap_hsmmc.c |  203 ++++++++++++++++++++++++++++-------------
 1 files changed, 140 insertions(+), 63 deletions(-)

diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 00b1b68..17f50c5 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -148,6 +148,118 @@ struct mmc_omap_host {
 	struct	omap_mmc_platform_data	*pdata;
 };
 
+struct omap_hsmmc_regs {
+	u32 hctl;
+	u32 capa;
+	u32 sysconfig;
+	u32 ise;
+	u32 ie;
+	u32 con;
+	u32 sysctl;
+};
+static struct omap_hsmmc_regs hsmmc_ctx[3];
+static int mmc_clk_counter[3];
+
+
+/*
+ * restore the context
+ */
+static void omap2_hsmmc_restore_ctx(struct mmc_omap_host *host)
+{
+	/* MMC : context restore */
+	OMAP_HSMMC_WRITE(host->base, HCTL, hsmmc_ctx[host->id].hctl);
+	OMAP_HSMMC_WRITE(host->base, CAPA, hsmmc_ctx[host->id].capa);
+	OMAP_HSMMC_WRITE(host->base, CON, hsmmc_ctx[host->id].con);
+	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
+					hsmmc_ctx[host->id].sysconfig);
+	OMAP_HSMMC_WRITE(host->base, ISE, hsmmc_ctx[host->id].ise);
+	OMAP_HSMMC_WRITE(host->base, IE, hsmmc_ctx[host->id].ie);
+	OMAP_HSMMC_WRITE(host->base, SYSCTL, hsmmc_ctx[host->id].sysctl);
+	OMAP_HSMMC_WRITE(host->base, HCTL, OMAP_HSMMC_READ(host->base,
+								HCTL) | SDBP);
+}
+
+
+/*
+ * Save context
+ */
+static void omap2_hsmmc_save_ctx(struct mmc_omap_host *host)
+{
+	/* MMC : context save */
+	hsmmc_ctx[host->id].hctl = OMAP_HSMMC_READ(host->base, HCTL);
+	hsmmc_ctx[host->id].capa = OMAP_HSMMC_READ(host->base, CAPA);
+	hsmmc_ctx[host->id].sysconfig = OMAP_HSMMC_READ(host->base,
+								SYSCONFIG);
+	hsmmc_ctx[host->id].ise = OMAP_HSMMC_READ(host->base, ISE);
+	hsmmc_ctx[host->id].ie = OMAP_HSMMC_READ(host->base, IE);
+	hsmmc_ctx[host->id].con = OMAP_HSMMC_READ(host->base, CON);
+	hsmmc_ctx[host->id].sysctl = OMAP_HSMMC_READ(host->base, SYSCTL);
+}
+
+
+/*
+ *  enable clock to the card
+ */
+static int mmc_clk_enable(struct mmc_omap_host *host)
+{
+	int ret = 0;
+	int hostid = host->id;
+
+	if (host) {
+		if (!mmc_clk_counter[hostid]) {
+			ret = clk_enable(host->fclk);
+			if (ret)
+				goto clk_en_err;
+
+			ret = clk_enable(host->iclk);
+			if (ret) {
+				clk_disable(host->fclk);
+				goto clk_en_err;
+			}
+
+			if (host->dbclk_enabled) {
+				if (clk_enable(host->dbclk) != 0) {
+					clk_disable(host->fclk);
+					clk_disable(host->iclk);
+					dev_dbg(mmc_dev(host->mmc),
+						"Enabling debounce clk failed\n");
+				}
+			}
+			/*omap2_hsmmc_restore_ctx(host);*/
+		}
+		mmc_clk_counter[hostid] = mmc_clk_counter[hostid]+1;
+	}
+	return ret;
+
+clk_en_err:
+	dev_dbg(mmc_dev(host->mmc),
+		"Failed to enable MMC clocks during resume\n");
+	return ret;
+}
+
+
+/*
+ * Disable clock to the card
+ */
+
+static int mmc_clk_disable(struct mmc_omap_host *host)
+{
+	int hostid = host->id;
+
+	if (mmc_clk_counter[hostid])
+		mmc_clk_counter[hostid] = mmc_clk_counter[hostid]-1;
+
+	if (!mmc_clk_counter[hostid]) {
+		/*omap2_hsmmc_save_ctx(host);*/
+		clk_disable(host->fclk);
+		clk_disable(host->iclk);
+
+		if (host->dbclk_enabled)
+			clk_disable(host->dbclk);
+	}
+	return 0;
+}
+
 /*
  * Stop clock to the card
  */
@@ -229,6 +341,7 @@ mmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd,
 		mmc_hostname(host->mmc), cmd->opcode, cmd->arg);
 	host->cmd = cmd;
 
+	mmc_clk_enable(host);
 	/*
 	 * Clear status bits and enable interrupts
 	 */
@@ -286,6 +399,8 @@ mmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)
 	else
 		data->bytes_xfered = 0;
 
+	mmc_clk_disable(host);
+
 	if (!data->stop) {
 		host->mrq = NULL;
 		mmc_request_done(host->mmc, data->mrq);
@@ -316,6 +431,7 @@ mmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)
 	}
 	if (host->data == NULL || cmd->error) {
 		host->mrq = NULL;
+		mmc_clk_disable(host);
 		mmc_request_done(host->mmc, cmd->mrq);
 	}
 }
@@ -449,9 +565,7 @@ static int omap_mmc_switch_opcond(struct mmc_omap_host *host, int vdd)
 	int ret;
 
 	/* Disable the clocks */
-	clk_disable(host->fclk);
-	clk_disable(host->iclk);
-	clk_disable(host->dbclk);
+	mmc_clk_disable(host);
 
 	/* Turn the power off */
 	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
@@ -463,9 +577,7 @@ static int omap_mmc_switch_opcond(struct mmc_omap_host *host, int vdd)
 	if (ret != 0)
 		goto err;
 
-	clk_enable(host->fclk);
-	clk_enable(host->iclk);
-	clk_enable(host->dbclk);
+	mmc_clk_enable(host);
 
 	OMAP_HSMMC_WRITE(host->base, HCTL,
 		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
@@ -504,6 +616,8 @@ static void mmc_omap_detect(struct work_struct *work)
 	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host,
 						mmc_carddetect_work);
 
+	mmc_clk_enable(host);
+
 	sysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");
 	if (host->carddetect) {
 		if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
@@ -522,6 +636,8 @@ static void mmc_omap_detect(struct work_struct *work)
 		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD) ;
 		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
 	}
+
+	mmc_clk_disable(host);
 }
 
 /*
@@ -695,8 +811,10 @@ static void omap_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
 	struct mmc_omap_host *host = mmc_priv(mmc);
 
 	WARN_ON(host->mrq != NULL);
+	mmc_clk_enable(host);
 	host->mrq = req;
 	mmc_omap_prepare_data(host, req);
+	mmc_clk_disable(host);
 	mmc_omap_start_command(host, req->cmd, req->data);
 }
 
@@ -709,6 +827,8 @@ static void omap_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	unsigned long regval;
 	unsigned long timeout;
 
+	mmc_clk_enable(host);
+
 	switch (ios->power_mode) {
 	case MMC_POWER_OFF:
 		mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
@@ -779,6 +899,7 @@ static void omap_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
 		OMAP_HSMMC_WRITE(host->base, CON,
 				OMAP_HSMMC_READ(host->base, CON) | OD);
+	mmc_clk_disable(host);
 }
 /* NOTE: Read only switch not supported yet */
 static struct mmc_host_ops mmc_omap_ops = {
@@ -853,31 +974,16 @@ static int __init omap_mmc_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	if (clk_enable(host->fclk) != 0) {
-		clk_put(host->iclk);
-		clk_put(host->fclk);
-		goto err1;
-	}
-
-	if (clk_enable(host->iclk) != 0) {
-		clk_disable(host->fclk);
-		clk_put(host->iclk);
-		clk_put(host->fclk);
-		goto err1;
-	}
-
-	host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
+	host->dbclk = clk_get(&pdev->dev, "gpt10_fck");
 	/*
 	 * MMC can still work without debounce clock.
 	 */
 	if (IS_ERR(host->dbclk))
 		dev_dbg(mmc_dev(host->mmc), "Failed to get debounce clock\n");
 	else
-		if (clk_enable(host->dbclk) != 0)
-			dev_dbg(mmc_dev(host->mmc), "Enabling debounce"
-							" clk failed\n");
-		else
-			host->dbclk_enabled = 1;
+		host->dbclk_enabled = 1;
+
+	mmc_clk_enable(host);
 
 #ifdef CONFIG_MMC_BLOCK_BOUNCE
 	mmc->max_phys_segs = 1;
@@ -966,6 +1072,8 @@ static int __init omap_mmc_probe(struct platform_device *pdev)
 			goto err_cover_switch;
 	}
 
+	mmc_clk_disable(host);
+
 	return 0;
 
 err_cover_switch:
@@ -977,15 +1085,9 @@ err_irq_cd_init:
 err_irq_cd:
 	free_irq(host->irq, host);
 err_irq:
-	clk_disable(host->fclk);
-	clk_disable(host->iclk);
 	clk_put(host->fclk);
 	clk_put(host->iclk);
-	if (host->dbclk_enabled) {
-		clk_disable(host->dbclk);
-		clk_put(host->dbclk);
-	}
-
+	clk_put(host->dbclk);
 err1:
 	iounmap(host->base);
 err:
@@ -1025,16 +1127,10 @@ static int omap_mmc_remove(struct platform_device *pdev)
 		if (mmc_slot(host).card_detect_irq)
 			free_irq(mmc_slot(host).card_detect_irq, host);
 		flush_scheduled_work();
-
-		clk_disable(host->fclk);
-		clk_disable(host->iclk);
+		mmc_clk_disable(host);
 		clk_put(host->fclk);
 		clk_put(host->iclk);
-		if (host->dbclk_enabled) {
-			clk_disable(host->dbclk);
-			clk_put(host->dbclk);
-		}
-
+		clk_put(host->dbclk);
 		mmc_free_host(host->mmc);
 		iounmap(host->base);
 	}
@@ -1056,6 +1152,8 @@ static int omap_mmc_suspend(struct platform_device *pdev, pm_message_t state)
 		if (ret == 0) {
 			host->suspended = 1;
 
+			mmc_clk_enable(host);
+
 			OMAP_HSMMC_WRITE(host->base, ISE, 0);
 			OMAP_HSMMC_WRITE(host->base, IE, 0);
 
@@ -1079,9 +1177,7 @@ static int omap_mmc_suspend(struct platform_device *pdev, pm_message_t state)
 					| SDBP);
 			}
 
-			clk_disable(host->fclk);
-			clk_disable(host->iclk);
-			clk_disable(host->dbclk);
+			mmc_clk_disable(host);
 		}
 
 	}
@@ -1098,21 +1194,7 @@ static int omap_mmc_resume(struct platform_device *pdev)
 		return 0;
 
 	if (host) {
-
-		ret = clk_enable(host->fclk);
-		if (ret)
-			goto clk_en_err;
-
-		ret = clk_enable(host->iclk);
-		if (ret) {
-			clk_disable(host->fclk);
-			clk_put(host->fclk);
-			goto clk_en_err;
-		}
-
-		if (clk_enable(host->dbclk) != 0)
-			dev_dbg(mmc_dev(host->mmc),
-					"Enabling debounce clk failed\n");
+		mmc_clk_enable(host);
 
 		if (host->pdata->resume) {
 			ret = host->pdata->resume(&pdev->dev, host->slot_id);
@@ -1128,11 +1210,6 @@ static int omap_mmc_resume(struct platform_device *pdev)
 	}
 
 	return ret;
-
-clk_en_err:
-	dev_dbg(mmc_dev(host->mmc),
-		"Failed to enable MMC clocks during resume\n");
-	return ret;
 }
 
 #else
-- 
1.6.5.2

