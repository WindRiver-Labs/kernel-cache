From 2edbcb83124e2799a1fce6329e87673b96746780 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Thu, 15 Jan 2009 18:14:31 -0500
Subject: [PATCH 03/20] Add video drivers from TI.

These drivers are from TI's vendor software drop known as
their PSP.  It is from their version 2.0 of the PSP.  The
display subsystem is based on dss version 1.  Of special
note is that these video drivers only support video on the
omap3evm via the S-video connector only.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/arm/plat-omap/Kconfig                  |    5 +
 arch/arm/plat-omap/Makefile                 |    3 +-
 arch/arm/plat-omap/include/mach/cpu.h       |   24 +
 arch/arm/plat-omap/include/mach/omap-dss.h  |  985 ++++++++
 arch/arm/plat-omap/include/mach/omap-venc.h |  627 +++++
 arch/arm/plat-omap/omap-dss.c               | 2590 ++++++++++++++++++++
 arch/arm/plat-omap/omap-venc.c              |  485 ++++
 drivers/media/video/Kconfig                 |    2 +-
 drivers/media/video/Makefile                |    1 +
 drivers/media/video/omap/Kconfig            |   19 +
 drivers/media/video/omap/Makefile           |    3 +
 drivers/media/video/omap/omap_vout.c        | 3527 +++++++++++++++++++++++++++
 drivers/media/video/omap/omap_voutdef.h     |  196 ++
 drivers/media/video/omap/omap_voutlib.c     |  284 +++
 drivers/media/video/omap/omap_voutlib.h     |   34 +
 include/linux/omap_vout.h                   |   60 +
 16 files changed, 8843 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/plat-omap/include/mach/omap-dss.h
 create mode 100644 arch/arm/plat-omap/include/mach/omap-venc.h
 create mode 100644 arch/arm/plat-omap/omap-dss.c
 create mode 100644 arch/arm/plat-omap/omap-venc.c
 create mode 100644 drivers/media/video/omap/omap_vout.c
 create mode 100644 drivers/media/video/omap/omap_voutdef.h
 create mode 100644 drivers/media/video/omap/omap_voutlib.c
 create mode 100644 drivers/media/video/omap/omap_voutlib.h
 create mode 100644 include/linux/omap_vout.h

diff --git a/arch/arm/plat-omap/Kconfig b/arch/arm/plat-omap/Kconfig
index 960c13f..efb42d7 100644
--- a/arch/arm/plat-omap/Kconfig
+++ b/arch/arm/plat-omap/Kconfig
@@ -245,6 +245,11 @@ config OMAP_SERIAL_WAKE
 	  to data on the serial RX line. This allows you to wake the
 	  system from serial console.
 
+config VIDEO_OMAP_TVOUT
+	bool "TV out support"
+	depends on VIDEO_OMAP3
+	default VIDEO_OMAP3
+
 endmenu
 
 endif
diff --git a/arch/arm/plat-omap/Makefile b/arch/arm/plat-omap/Makefile
index 1259846..14afb27 100644
--- a/arch/arm/plat-omap/Makefile
+++ b/arch/arm/plat-omap/Makefile
@@ -13,7 +13,8 @@ obj-  :=
 obj-$(CONFIG_ARCH_OMAP16XX) += ocpi.o
 
 obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
-
+obj-$(CONFIG_ARCH_OMAP3) += omap-dss.o
+obj-$(CONFIG_VIDEO_OMAP_TVOUT) += omap-venc.o
 obj-$(CONFIG_CPU_FREQ) += cpu-omap.o
 obj-$(CONFIG_OMAP_DM_TIMER) += dmtimer.o
 obj-$(CONFIG_OMAP_BOOT_REASON) += bootreason.o
diff --git a/arch/arm/plat-omap/include/mach/cpu.h b/arch/arm/plat-omap/include/mach/cpu.h
index 4325bbc..50aa62e 100644
--- a/arch/arm/plat-omap/include/mach/cpu.h
+++ b/arch/arm/plat-omap/include/mach/cpu.h
@@ -325,6 +325,30 @@ IS_OMAP_TYPE(3430, 0x3430)
 #define cpu_class_is_omap2()	(cpu_is_omap24xx() || cpu_is_omap34xx())
 
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
+/*
+ * Macros to detect silicon revision of OMAP2/3 processors.
+ * is_sil_rev_greater_than:     true if passed cpu type & its rev is greater.
+ * is_sil_rev_lesser_than:      true if passed cpu type & its rev is lesser.
+ * is_sil_rev_equal_to:         true if passed cpu type & its rev is equal.
+ * get_sil_rev:                 return the silicon rev value.
+ */
+#define get_sil_omap_type(rev)  ((rev & 0xffff0000) >> 16)
+#define get_sil_revision(rev)   ((rev & 0x0000f000) >> 12)
+
+#define is_sil_rev_greater_than(rev) \
+		((get_sil_omap_type(system_rev) == get_sil_omap_type(rev)) && \
+		(get_sil_revision(system_rev) > get_sil_revision(rev)))
+
+#define is_sil_rev_less_than(rev) \
+		((get_sil_omap_type(system_rev) == get_sil_omap_type(rev)) && \
+		(get_sil_revision(system_rev) < get_sil_revision(rev)))
+
+#define is_sil_rev_equal_to(rev) \
+		((get_sil_omap_type(system_rev) == get_sil_omap_type(rev)) && \
+		(get_sil_revision(system_rev) == get_sil_revision(rev)))
+
+#define get_sil_rev() \
+		get_sil_revision(system_rev)
 
 /* Various silicon revisions for omap2 */
 #define OMAP242X_CLASS		0x24200024
diff --git a/arch/arm/plat-omap/include/mach/omap-dss.h b/arch/arm/plat-omap/include/mach/omap-dss.h
new file mode 100644
index 0000000..67e03d3
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/omap-dss.h
@@ -0,0 +1,985 @@
+/*
+ * include/asm-arm/arch-omap/omap-dss.h
+ *
+ * Copyright (C) 2004-2005 Texas Instruments.
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+
+ * Leveraged from original Linux 2.6 framebuffer driver for OMAP24xx
+ * Author: Andy Lowe (source@mvista.com)
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ *
+ */
+
+#ifndef	__ASM_ARCH_OMAP_DISP_H
+#define	__ASM_ARCH_OMAP_DISP_H
+
+/* 16 bit uses LDRH/STRH, base +/- offset_8 */
+typedef struct {
+	volatile u16 offset[256];
+} __regbase16;
+#define __REGV16(vaddr)		(((__regbase16 *)((vaddr)&~0xff)) \
+					->offset[((vaddr)&0xff)>>1])
+#define __REG16(paddr)		 __REGV16(io_p2v(paddr))
+
+/* 8/32 bit uses LDR/STR, base +/- offset_12 */
+typedef struct {
+	volatile u8 offset[4096];
+} __regbase8;
+#define __REGV8(vaddr)		(((__regbase8  *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>0])
+#define __REG8(paddr)		 __REGV8(io_p2v(paddr))
+
+typedef struct {
+	volatile u32 offset[4096];
+} __regbase32;
+#define __REGV32(vaddr)		(((__regbase32 *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>2])
+#define __REG32(paddr)		__REGV32(io_p2v(paddr))
+
+/*physical memory map definitions */
+	/* display subsystem */
+#define DSS_REG_BASE			0x48050000
+#define DSS_REG_SIZE			0x00001000
+	/* DSS */
+#define DSS_REG_OFFSET			0x00000000
+	/* display controller */
+#define DISPC_REG_OFFSET		0x00000400
+	/* remote framebuffer interface */
+#define RFBI_REG_OFFSET			0x00000800
+	/* video encoder */
+#define VENC_REG_OFFSET			0x00000C00
+
+/* display subsystem register offsets */
+#define DSS_REVISION			0x000
+#define DSS_SYSCONFIG			0x010
+#define DSS_SYSSTATUS			0x014
+#define DSS_CONTROL			0x040
+#ifdef CONFIG_ARCH_OMAP3430
+#define DSS_SDI_CONTROL			0x044	/* omap3430 specific */
+#define DSS_PLL_CONTROL			0x048	/* omap3430 specific */
+#endif				/* CONFIG_ARCH_OMAP3430 */
+#define DSS_PSA_LCD_REG_1		0x050
+#define DSS_PSA_LCD_REG_2		0x054
+#define DSS_PSA_VIDEO_REG		0x058
+#define DSS_STATUS			0x05C
+
+/* display controller register offsets */
+#define DISPC_REVISION			0x000
+#define DISPC_SYSCONFIG			0x010
+#define DISPC_SYSSTATUS			0x014
+#define DISPC_IRQSTATUS			0x018
+#define DISPC_IRQENABLE			0x01C
+#define DISPC_CONTROL			0x040
+#define DISPC_CONFIG			0x044
+#define DISPC_CAPABLE			0x048
+#define DISPC_DEFAULT_COLOR0		0x04C
+#define DISPC_DEFAULT_COLOR1		0x050
+#define DISPC_TRANS_COLOR0		0x054
+#define DISPC_TRANS_COLOR1		0x058
+#define DISPC_LINE_STATUS		0x05C
+#define DISPC_LINE_NUMBER		0x060
+#define DISPC_TIMING_H			0x064
+#define DISPC_TIMING_V			0x068
+#define DISPC_POL_FREQ			0x06C
+#define DISPC_DIVISOR			0x070
+#define DISPC_GLOBAL_ALPHA		0x074
+#define DISPC_SIZE_DIG			0x078
+#define DISPC_SIZE_LCD			0x07C
+#define DISPC_GFX_BA0			0x080
+#define DISPC_GFX_BA1			0x084
+#define DISPC_GFX_POSITION		0x088
+#define DISPC_GFX_SIZE			0x08C
+#define DISPC_GFX_ATTRIBUTES		0x0A0
+#define DISPC_GFX_FIFO_THRESHOLD	0x0A4
+#define DISPC_GFX_FIFO_SIZE		0x0A8
+#define DISPC_GFX_ROW_INC		0x0AC
+#define DISPC_GFX_PIXEL_INC		0x0B0
+#define DISPC_GFX_WINDOW_SKIP		0x0B4
+#define DISPC_GFX_TABLE_BA		0x0B8
+
+#define RFBI_SYSCONFIG			0x010
+
+/* The registers for the video pipelines are parameterized by the video pipeline
+ * index: n=0 for VID1 and n=1 for VID2.
+ */
+#define DISPC_VID_BA0(n)		(0x0BC + (n)*0x90)
+#define DISPC_VID_BA1(n)		(0x0C0 + (n)*0x90)
+#define DISPC_VID_POSITION(n)		(0x0C4 + (n)*0x90)
+#define DISPC_VID_SIZE(n)		(0x0C8 + (n)*0x90)
+#define DISPC_VID_ATTRIBUTES(n)		(0x0CC + (n)*0x90)
+#define DISPC_VID_FIFO_THRESHOLD(n)	(0x0D0 + (n)*0x90)
+#define DISPC_VID_FIFO_SIZE(n)		(0x0D4 + (n)*0x90)
+#define DISPC_VID_ROW_INC(n)		(0x0D8 + (n)*0x90)
+#define DISPC_VID_PIXEL_INC(n)		(0x0DC + (n)*0x90)
+#define DISPC_VID_FIR(n)		(0x0E0 + (n)*0x90)
+#define DISPC_VID_PICTURE_SIZE(n)	(0x0E4 + (n)*0x90)
+#define DISPC_VID_ACCU0(n)		(0x0E8 + (n)*0x90)
+#define DISPC_VID_ACCU1(n)		(0x0EC + (n)*0x90)
+
+/* The FIR coefficients are parameterized by the video pipeline index n = {0, 1}
+ * and the coefficient index i = {0, 1, 2, 3, 4, 5, 6, 7}.
+ */
+#define DISPC_VID_FIR_COEF_H(n, i)	(0x0F0 + (i)*0x8 + (n)*0x90)
+#define DISPC_VID_FIR_COEF_HV(n, i)	(0x0F4 + (i)*0x8 + (n)*0x90)
+#define DISPC_VID_FIR_COEF_V(n, i)	(0x1E0 + (i)*0x4 + (n)*0x20)
+#define DISPC_VID_CONV_COEF0(n)		(0x130 + (n)*0x90)
+#define DISPC_VID_CONV_COEF1(n)		(0x134 + (n)*0x90)
+#define DISPC_VID_CONV_COEF2(n)		(0x138 + (n)*0x90)
+#define DISPC_VID_CONV_COEF3(n)		(0x13C + (n)*0x90)
+#define DISPC_VID_CONV_COEF4(n)		(0x140 + (n)*0x90)
+
+#define DISPC_DATA_CYCLE1		0x1D4
+#define DISPC_DATA_CYCLE2		0x1D8
+#define DISPC_DATA_CYCLE3		0x1DC
+
+#define DISPC_CPR_R			0x220
+#define DISPC_CPR_G			0x224
+#define DISPC_CPR_B			0x228
+
+/* bit fields within selected registers */
+#define DSS_CONTROL_VENC_OUT				(1 << 6)
+#define DSS_CONTROL_TV_REF				(1 << 5)
+#define DSS_CONTROL_DAC_DEMEN				(1 << 4)
+#define DSS_CONTROL_VENC_CLOCK_4X_ENABLE		(1 << 3)
+#define DSS_CONTROL_VENC_CLOCK_MODE			(1 << 2)
+#define DSS_CONTROL_CLK					(1 << 0)
+#define DSS_CONTROL_APLL_CLK				1
+#define DSS_CONTROL_DPLL_CLK				0
+#define DSS_SYSCONFIG_SOFTRESET				(1 <<  1)
+#define DSS_SYSSTATUS_RESETDONE				(1 <<  0)
+#define DSS_SYSCONFIG_SIDLEMODE				(3 <<  3)
+#define DSS_SYSCONFIG_SIDLEMODE_FIDLE			(0 <<  3)
+#define DSS_SYSCONFIG_SIDLEMODE_NIDLE			(1 <<  3)
+#define DSS_SYSCONFIG_SIDLEMODE_SIDLE			(2 <<  3)
+#define DSS_SYSCONFIG_SOFTRESET				(1 <<  1)
+#define DSS_SYSCONFIG_AUTOIDLE				(1 <<  0)
+
+#define DISPC_REVISION_MAJOR				(15 << 4)
+#define DISPC_REVISION_MAJOR_SHIFT			4
+#define DISPC_REVISION_MINOR				(15 << 0)
+#define DISPC_REVISION_MINOR_SHIFT			0
+
+#define DISPC_SYSCONFIG_MIDLEMODE			(3 << 12)
+#define DISPC_SYSCONFIG_MIDLEMODE_FSTANDBY		(0 << 12)
+#define DISPC_SYSCONFIG_MIDLEMODE_NSTANDBY		(1 << 12)
+#define DISPC_SYSCONFIG_MIDLEMODE_SSTANDBY		(2 << 12)
+#define DISPC_SYSCONFIG_SIDLEMODE			(3 <<  3)
+#define DISPC_SYSCONFIG_SIDLEMODE_FIDLE			(0 <<  3)
+#define DISPC_SYSCONFIG_SIDLEMODE_NIDLE			(1 <<  3)
+#define DISPC_SYSCONFIG_SIDLEMODE_SIDLE			(2 <<  3)
+#define DISPC_SYSCONFIG_SOFTRESET			(1 <<  1)
+#define DISPC_SYSCONFIG_AUTOIDLE			(1 <<  0)
+#define DISPC_SYSCONFIG_CLKACTIVITY			(2 <<  8)
+#define DISPC_SYSCONFIG_ENABLE_WKUP			(1 <<  2)
+
+#define DISPC_SYSSTATUS_RESETDONE			(1 << 0)
+
+#define DISPC_IRQSTATUS_SYNCLOSTDIGITAL			(1 << 15)
+#define DISPC_IRQSTATUS_SYNCLOST			(1 << 14)
+#define DISPC_IRQSTATUS_VID2ENDWINDOW			(1 << 13)
+#define DISPC_IRQSTATUS_VID2FIFOUNDERFLOW		(1 << 12)
+#define DISPC_IRQSTATUS_VID1ENDWINDOW			(1 << 11)
+#define DISPC_IRQSTATUS_VID1FIFOUNDERFLOW		(1 << 10)
+#define DISPC_IRQSTATUS_OCPERROR			(1 <<  9)
+#define DISPC_IRQSTATUS_PALETTEGAMMALOADING		(1 <<  8)
+#define DISPC_IRQSTATUS_GFXENDWINDOW			(1 <<  7)
+#define DISPC_IRQSTATUS_GFXFIFOUNDERFLOW		(1 <<  6)
+#define DISPC_IRQSTATUS_PROGRAMMEDLINENUMBER		(1 <<  5)
+#define DISPC_IRQSTATUS_ACBIASCOUNTSTATUS		(1 <<  4)
+#define DISPC_IRQSTATUS_EVSYNC_ODD			(1 <<  3)
+#define DISPC_IRQSTATUS_EVSYNC_EVEN			(1 <<  2)
+#define DISPC_IRQSTATUS_VSYNC				(1 <<  1)
+#define DISPC_IRQSTATUS_FRAMEDONE			(1 <<  0)
+
+#define DISPC_IRQENABLE_SYNCLOSTDIGITAL (1 << 15)
+#define DISPC_IRQENABLE_SYNCLOST			(1 << 14)
+#define DISPC_IRQENABLE_VID2ENDWINDOW			(1 << 13)
+#define DISPC_IRQENABLE_VID2FIFOUNDERFLOW		(1 << 12)
+#define DISPC_IRQENABLE_VID1ENDWINDOW			(1 << 11)
+#define DISPC_IRQENABLE_VID1FIFOUNDERFLOW		(1 << 10)
+#define DISPC_IRQENABLE_OCPERROR			(1 <<  9)
+#define DISPC_IRQENABLE_PALETTEGAMMALOADING		(1 <<  8)
+#define DISPC_IRQENABLE_GFXENDWINDOW			(1 <<  7)
+#define DISPC_IRQENABLE_GFXFIFOUNDERFLOW		(1 <<  6)
+#define DISPC_IRQENABLE_PROGRAMMEDLINENUMBER		(1 <<  5)
+#define DISPC_IRQENABLE_ACBIASCOUNTSTATUS		(1 <<  4)
+#define DISPC_IRQENABLE_EVSYNC_ODD			(1 <<  3)
+#define DISPC_IRQENABLE_EVSYNC_EVEN			(1 <<  2)
+#define DISPC_IRQENABLE_VSYNC				(1 <<  1)
+#define DISPC_IRQENABLE_FRAMEDONE			(1 <<  0)
+
+#define DISPC_CONTROL_TDMUNUSEDBITS			(3 << 25)
+#define DISPC_CONTROL_TDMUNUSEDBITS_LOWLEVEL		(0 << 25)
+#define DISPC_CONTROL_TDMUNUSEDBITS_HIGHLEVEL		(1 << 25)
+#define DISPC_CONTROL_TDMUNUSEDBITS_UNCHANGED		(2 << 25)
+#define DISPC_CONTROL_TDMCYCLEFORMAT			(3 << 23)
+#define DISPC_CONTROL_TDMCYCLEFORMAT_1CYCPERPIX		(0 << 23)
+#define DISPC_CONTROL_TDMCYCLEFORMAT_2CYCPERPIX		(1 << 23)
+#define DISPC_CONTROL_TDMCYCLEFORMAT_3CYCPERPIX		(2 << 23)
+#define DISPC_CONTROL_TDMCYCLEFORMAT_3CYCPER2PIX	(3 << 23)
+#define DISPC_CONTROL_TDMPARALLELMODE			(3 << 21)
+#define DISPC_CONTROL_TDMPARALLELMODE_8BPARAINT		(0 << 21)
+#define DISPC_CONTROL_TDMPARALLELMODE_9BPARAINT		(1 << 21)
+#define DISPC_CONTROL_TDMPARALLELMODE_12BPARAINT	(2 << 21)
+#define DISPC_CONTROL_TDMPARALLELMODE_16BPARAINT	(3 << 21)
+#define DISPC_CONTROL_TDMENABLE				(1 << 20)
+#define DISPC_CONTROL_HT				(7 << 17)
+#define DISPC_CONTROL_HT_SHIFT				17
+#define DISPC_CONTROL_GPOUT1				(1 << 16)
+#define DISPC_CONTROL_GPOUT0				(1 << 15)
+#define DISPC_CONTROL_GPIN1				(1 << 14)
+#define DISPC_CONTROL_GPIN0				(1 << 13)
+#define DISPC_CONTROL_OVERLAYOPTIMIZATION		(1 << 12)
+#define DISPC_CONTROL_RFBIMODE				(1 << 11)
+#define DISPC_CONTROL_SECURE				(1 << 10)
+#define DISPC_CONTROL_TFTDATALINES			(3 <<  8)
+#define DISPC_CONTROL_TFTDATALINES_OALSB12B		(0 <<  8)
+#define DISPC_CONTROL_TFTDATALINES_OALSB16B		(1 <<  8)
+#define DISPC_CONTROL_TFTDATALINES_OALSB18B		(2 <<  8)
+#define DISPC_CONTROL_TFTDATALINES_OALSB24B		(3 <<  8)
+#define DISPC_CONTROL_TFTDITHERENABLE			(1 <<  7)
+#define DISPC_CONTROL_GODIGITAL				(1 <<  6)
+#define DISPC_CONTROL_GOLCD				(1 <<  5)
+#define DISPC_CONTROL_M8B				(1 <<  4)
+#define DISPC_CONTROL_STNTFT				(1 <<  3)
+#define DISPC_CONTROL_MONOCOLOR				(1 <<  2)
+#define DISPC_CONTROL_DIGITALENABLE			(1 <<  1)
+#define DISPC_CONTROL_LCDENABLE				(1 <<  0)
+
+#define DISPC_CONFIG_TVALPHAENABLE			(1 << 19)
+#define DISPC_CONFIG_LCDALPHAENABLE			(1 << 18)
+#ifdef CONFIG_ARCH_OMAP3430
+#define DISPC_CONFIG_FIFOMERGE				(1 << 14)
+#endif
+#define DISPC_CONFIG_TCKDIGSELECTION			(1 << 13)
+#define DISPC_CONFIG_TCKDIGENABLE			(1 << 12)
+#define DISPC_CONFIG_TCKLCDSELECTION			(1 << 11)
+#define DISPC_CONFIG_TCKLCDENABLE			(1 << 10)
+#define DISPC_CONFIG_FUNCGATED				(1 <<  9)
+#define DISPC_CONFIG_ACBIASGATED			(1 <<  8)
+#define DISPC_CONFIG_VSYNCGATED				(1 <<  7)
+#define DISPC_CONFIG_HSYNCGATED				(1 <<  6)
+#define DISPC_CONFIG_PIXELCLOCKGATED			(1 <<  5)
+#define DISPC_CONFIG_PIXELDATAGATED			(1 <<  4)
+#define DISPC_CONFIG_PALETTEGAMMATABLE			(1 <<  3)
+#define DISPC_CONFIG_LOADMODE_FRDATLEFR			(1 <<  2)
+#define DISPC_CONFIG_LOADMODE_PGTABUSETB		(1 <<  1)
+#define DISPC_CONFIG_PIXELGATED				(1 <<  0)
+
+#define DISPC_CAPABLE_GFXGAMMATABLECAPABLE		(1 <<  9)
+#define DISPC_CAPABLE_GFXLAYERCAPABLE			(1 <<  8)
+#define DISPC_CAPABLE_GFXTRANSDSTCAPABLE		(1 <<  7)
+#define DISPC_CAPABLE_STNDITHERINGCAPABLE		(1 <<  6)
+#define DISPC_CAPABLE_TFTDITHERINGCAPABLE		(1 <<  5)
+#define DISPC_CAPABLE_VIDTRANSSRCCAPABLE		(1 <<  4)
+#define DISPC_CAPABLE_VIDLAYERCAPABLE			(1 <<  3)
+#define DISPC_CAPABLE_VIDVERTFIRCAPABLE			(1 <<  2)
+#define DISPC_CAPABLE_VIDHORFIRCAPABLE			(1 <<  1)
+#define DISPC_CAPABLE_VIDCAPABLE			(1 <<  0)
+
+#define DISPC_POL_FREQ_ONOFF_SHIFT                      17
+#define DISPC_POL_FREQ_ONOFF				(1 << 17)
+#define DISPC_POL_FREQ_RF				(1 << 16)
+#define DISPC_POL_FREQ_IEO				(1 << 15)
+#define DISPC_POL_FREQ_IPC_SHIFT                        14
+#define DISPC_POL_FREQ_IPC				(1 << 14)
+#define DISPC_POL_FREQ_IHS				(1 << 13)
+#define DISPC_POL_FREQ_IVS				(1 << 12)
+#define DISPC_POL_FREQ_ACBI				(15 << 8)
+#define DISPC_POL_FREQ_ACBI_SHIFT			8
+#define DISPC_POL_FREQ_ACB				0xFF
+#define DISPC_POL_FREQ_ACB_SHIFT			0
+
+#define DISPC_TIMING_H_HBP				(0xFF << 20)
+#define DISPC_TIMING_H_HBP_SHIFT			20
+#define DISPC_TIMING_H_HFP				(0xFF << 8)
+#define DISPC_TIMING_H_HFP_SHIFT			8
+#define DISPC_TIMING_H_HSW				(0x3F << 0)
+#define DISPC_TIMING_H_HSW_SHIFT			0
+
+#define DISPC_TIMING_V_VBP				(0xFF << 20)
+#define DISPC_TIMING_V_VBP_SHIFT			20
+#define DISPC_TIMING_V_VFP				(0xFF << 8)
+#define DISPC_TIMING_V_VFP_SHIFT			8
+#define DISPC_TIMING_V_VSW				(0x3F << 0)
+#define DISPC_TIMING_V_VSW_SHIFT			0
+
+#define DISPC_DIVISOR_LCD				(0xFF << 16)
+#define DISPC_DIVISOR_LCD_SHIFT				16
+#define DISPC_DIVISOR_PCD				0xFF
+#define DISPC_DIVISOR_PCD_SHIFT				0
+
+#define DISPC_GLOBAL_ALPHA_VID2_GALPHA	(0xFF << 16)
+#define DISPC_GLOBAL_ALPHA_VID2_GALPHA_SHIFT		16
+#define DISPC_GLOBAL_ALPHA_GFX_GALPHA	0xFF
+#define DISPC_GLOBAL_ALPHA_GFX_GALPHA_SHIFT		0
+
+#define DISPC_SIZE_LCD_LPP				(0x7FF << 16)
+#define DISPC_SIZE_LCD_LPP_SHIFT			16
+#define DISPC_SIZE_LCD_PPL				0x7FF
+#define DISPC_SIZE_LCD_PPL_SHIFT			0
+
+#define DISPC_SIZE_DIG_LPP				(0x7FF << 16)
+#define DISPC_SIZE_DIG_LPP_SHIFT			16
+#define DISPC_SIZE_DIG_PPL				0x7FF
+#define DISPC_SIZE_DIG_PPL_SHIFT			0
+
+#define DISPC_GFX_POSITION_GFXPOSY			(0x7FF << 16)
+#define DISPC_GFX_POSITION_GFXPOSY_SHIFT		16
+#define DISPC_GFX_POSITION_GFXPOSX			0x7FF
+#define DISPC_GFX_POSITION_GFXPOSX_SHIFT		0
+
+#define DISPC_GFX_SIZE_GFXSIZEY				(0x7FF << 16)
+#define DISPC_GFX_SIZE_GFXSIZEY_SHIFT			16
+#define DISPC_GFX_SIZE_GFXSIZEX				0x7FF
+#define DISPC_GFX_SIZE_GFXSIZEX_SHIFT			0
+
+#define DISPC_GFX_ATTRIBUTES_GFXENDIANNESS		(1 << 10)
+#define DISPC_GFX_ATTRIBUTES_GFXNIBBLEMODE		(1 <<  9)
+#define DISPC_GFX_ATTRIBUTES_GFXCHANNELOUT		(1 <<  8)
+#define DISPC_GFX_ATTRIBUTES_GFXBURSTSIZE		(3 <<  6)
+#define DISPC_GFX_ATTRIBUTES_GFXBURSTSIZE_BURST4X32	(0 <<  6)
+#define DISPC_GFX_ATTRIBUTES_GFXBURSTSIZE_BURST8X32	(1 <<  6)
+#define DISPC_GFX_ATTRIBUTES_GFXBURSTSIZE_BURST16X32	(2 <<  6)
+#define DISPC_GFX_ATTRIBUTES_GFXREPLICATIONENABLE	(1 <<  5)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT			(15 << 1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_BITMAP1		(0 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_BITMAP2		(1 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_BITMAP4		(2 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_BITMAP8		(3 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_RGB12		(4 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_RGB16		(6 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_RGB24		(8 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_ARGB32		(12 <<  1)
+#define DISPC_GFX_ATTRIBUTES_GFXFORMAT_RGBA32		(13 <<  1)
+#define DISPC_GFX_ATTRIBUTES_ENABLE			(1 <<  0)
+#define DISPC_GFX_ATTRIBUTES_GFXREPEN			5
+
+#ifdef CONFIG_ARCH_OMAP3430
+#define DISPC_GFX_FIFO_THRESHOLD_HIGH			(0xFFF << 16)
+#define DISPC_GFX_FIFO_THRESHOLD_HIGH_SHIFT		16
+#define DISPC_GFX_FIFO_THRESHOLD_LOW			0xFFF
+#define DISPC_GFX_FIFO_THRESHOLD_LOW_SHIFT		0
+#else
+#define DISPC_GFX_FIFO_THRESHOLD_HIGH			(0x1FF << 16)
+#define DISPC_GFX_FIFO_THRESHOLD_HIGH_SHIFT		16
+#define DISPC_GFX_FIFO_THRESHOLD_LOW			0x1FF
+#define DISPC_GFX_FIFO_THRESHOLD_LOW_SHIFT		0
+#endif				/* CONFIG_ARCH_OMAP3430 */
+
+#define DISPC_VID_POSITION_VIDPOSY			(0x7FF << 16)
+#define DISPC_VID_POSITION_VIDPOSY_SHIFT		16
+#define DISPC_VID_POSITION_VIDPOSX			0x7FF
+#define DISPC_VID_POSITION_VIDPOSX_SHIFT		0
+
+#define DISPC_VID_SIZE_VIDSIZEY				(0x7FF << 16)
+#define DISPC_VID_SIZE_VIDSIZEY_SHIFT			16
+#define DISPC_VID_SIZE_VIDSIZEX				0x7FF
+#define DISPC_VID_SIZE_VIDSIZEX_SHIFT			0
+
+#define DISPC_VID_ATTRIBUTES_VIDVERTICALTAPS		(1 << 21)
+#define DISPC_VID_ATTRIBUTES_VIDROWREPEATENABLE		(1 << 18)
+#define DISPC_VID_ATTRIBUTES_VIDENDIANNESS		(1 << 17)
+#define DISPC_VID_ATTRIBUTES_VIDCHANNELOUT		(1 << 16)
+#define DISPC_VID_ATTRIBUTES_VIDBURSTSIZE		(3 << 14)
+#define DISPC_VID_ATTRIBUTES_VIDBURSTSIZE_BURST4X32	(0 << 14)
+#define DISPC_VID_ATTRIBUTES_VIDBURSTSIZE_BURST8X32	(1 << 14)
+#define DISPC_VID_ATTRIBUTES_VIDBURSTSIZE_BURST16X32	(2 << 14)
+#define DISPC_VID_ATTRIBUTES_VIDROTATION(n)		((n) << 12)
+#define DISPC_VID_ATTRIBUTES_VIDFULLRANGE		(1 << 11)
+#define DISPC_VID_ATTRIBUTES_VIDREPLICATIONENABLE	(1 << 10)
+#define DISPC_VID_ATTRIBUTES_VIDCOLORCONVENABLE		(1 <<  9)
+#define DISPC_VID_ATTRIBUTES_VIDVRESIZECONF		(1 <<  8)
+#define DISPC_VID_ATTRIBUTES_VIDHRESIZECONF		(1 <<  7)
+#define DISPC_VID_ATTRIBUTES_VIDRESIZEENABLE_VRESIZE	(1 <<  6)
+#define DISPC_VID_ATTRIBUTES_VIDRESIZEENABLE_HRESIZE	(1 <<  5)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT			(15 << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB16		(6  << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB24            (8  << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB24P           (9  << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_YUV2		(10 << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_UYVY		(11 << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_ARGB32		(12 << 1)
+#define DISPC_VID_ATTRIBUTES_VIDFORMAT_RGBA32		(13 << 1)
+#define DISPC_VID_ATTRIBUTES_ENABLE			(1 <<  0)
+
+#define DISPC_VID_PICTURE_SIZE_VIDORGSIZEY		(0x7FF << 16)
+#define DISPC_VID_PICTURE_SIZE_VIDORGSIZEY_SHIFT	16
+#define DISPC_VID_PICTURE_SIZE_VIDORGSIZEX		0x7FF
+#define DISPC_VID_PICTURE_SIZE_VIDORGSIZEX_SHIFT	0
+
+#define DISPC_VID_ATTRIBUTES_VIDROT			12
+#define DISPC_VID_ATTRIBUTES_VIDROWREPEAT		18
+
+/*RFBI Sysconfig values */
+#define RFBI_SYSCONFIG_SIDLEMODE_SIDLE			(2 << 3)
+
+/* VENC register offsets */
+#define VENC_F_CONTROL				0x0008
+#define VENC_VIDOUT_CTRL			0x0010
+#define VENC_SYNC_CONTROL			0x0014
+#define VENC_LLEN				0x001C
+#define VENC_FLENS				0x0020
+#define VENC_HFLTR_CTRL				0x0024
+#define VENC_CC_CARR_WSS_CARR			0x0028
+#define VENC_C_PHASE				0x002C
+#define VENC_GAIN_U				0x0030
+#define VENC_GAIN_V				0x0034
+#define VENC_GAIN_Y				0x0038
+#define VENC_BLACK_LEVEL			0x003C
+#define VENC_BLANK_LEVEL			0x0040
+#define VENC_X_COLOR				0x0044
+#define VENC_M_CONTROL				0x0048
+#define VENC_BSTAMP_WSS_DATA			0x004C
+#define VENC_S_CARR				0x0050
+#define VENC_LINE21				0x0054
+#define VENC_LN_SEL				0x0058
+#define VENC_L21_WC_CTL				0x005C
+#define VENC_HTRIGGER_VTRIGGER			0x0060
+#define VENC_SAVID_EAVID			0x0064
+#define VENC_FLEN_FAL				0x0068
+#define VENC_LAL_PHASE_RESET			0x006C
+#define VENC_HS_INT_START_STOP_X		0x0070
+#define VENC_HS_EXT_START_STOP_X		0x0074
+#define VENC_VS_INT_START_X			0x0078
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y	0x007C
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X	0x0080
+#define VENC_VS_EXT_STOP_X_VS_EXT_START_Y	0x0084
+#define VENC_VS_EXT_STOP_Y			0x0088
+#define VENC_AVID_START_STOP_X			0x0090
+#define VENC_AVID_START_STOP_Y			0x0094
+#define VENC_FID_INT_START_X_FID_INT_START_Y	0x00A0
+#define VENC_FID_INT_OFFSET_Y_FID_EXT_START_X	0x00A4
+#define VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y	0x00A8
+#define VENC_TVDETGP_INT_START_STOP_X		0x00B0
+#define VENC_TVDETGP_INT_START_STOP_Y		0x00B4
+#define VENC_GEN_CTRL				0x00B8
+#define VENC_DAC_TST				0x00C4
+#define VENC_DAC				0x00C8
+
+/* VENC bit fields */
+#define VENC_FCONTROL_RESET			(1<<8)
+
+/* Rotation using VRFB */
+#define SMS_ROT_VIRT_BASE(context, degree)	(0x70000000 		\
+						| 0x4000000 * (context)	\
+						| 0x1000000 * (degree/90))
+#define	SMS_IMAGEHEIGHT_OFFSET			16
+#define	SMS_IMAGEWIDTH_OFFSET			0
+#define	SMS_PH_OFFSET				8
+#define	SMS_PW_OFFSET				4
+#define	SMS_PS_OFFSET				0
+
+#ifdef CONFIG_ARCH_OMAP3
+#define IO_OFFSET               0x90000000
+/* Works for the entire IO Map */
+/*
+#define IO_ADDRESS(pa)          ((pa) + IO_OFFSET)
+*/
+#define io_p2v(pa)              ((pa) + IO_OFFSET)
+#define io_v2p(va)              ((va) - IO_OFFSET)
+
+#define L4_PHYS         L4_34XX_BASE	/* 0x48000000 */
+#define L4_VIRT         (L4_PHYS + IO_OFFSET)	/* 0xD8000000 */
+#define L4_SIZE         SZ_4M	/* 1MB of 128MB used, want 1MB sect */
+
+#define L4_WK_PHYS      L4_WK_34XX_BASE	/* 0x48300000 */
+#define L4_WK_VIRT      (L4_WK_PHYS + IO_OFFSET)	/* 0xD8300000 */
+#define L4_WK_SIZE      SZ_1M
+
+#define L4_PER_PHYS     L4_PER_34XX_BASE	/* 0x49000000 */
+#define L4_PER_VIRT     (L4_PER_PHYS + IO_OFFSET)	/* 0xD9000000 */
+#define L4_PER_SIZE     SZ_1M
+
+#define L4_EMU_PHYS     L4_EMU_34XX_BASE	/* 0x54000000 */
+#define L4_EMU_VIRT     (L4_EMU_PHYS + IO_OFFSET)	/* 0xE4000000 */
+#define L4_EMU_SIZE     SZ_1M
+
+#define GFX_PHYS        GFX_34XX_BASE	/* 0x50000000 */
+#define GFX_VIRT        (GFX_PHYS + IO_OFFSET)	/* 0xE0000000 */
+#define GFX_SIZE        SZ_64K
+
+#define L3_PHYS         L3_34XX_BASE	/* 0x68000000 */
+#define L3_VIRT         (L3_PHYS + IO_OFFSET)	/* 0xF8000000 */
+#define L3_SIZE         SZ_1M	/* 81kB of 128MB used, want 1MB sect */
+
+#define SMS_PHYS        OMAP343X_SMS_BASE	/* 0x6C000000 */
+#define SMS_VIRT        (SMS_PHYS + IO_OFFSET)	/* 0xFC000000 */
+#define SMS_SIZE        SZ_1M
+
+#define SDRC_PHYS       OMAP343X_SDRC_BASE	/* 0x6D000000 */
+#define SDRC_VIRT       (SDRC_PHYS + IO_OFFSET)	/* 0xFD000000 */
+#define SDRC_SIZE       SZ_1M
+
+#define GPMC_PHYS       OMAP34XX_GPMC_BASE	/* 0x6E000000 */
+#define GPMC_VIRT       (GPMC_PHYS + IO_OFFSET)	/* 0xFE000000 */
+#define GPMC_SIZE       SZ_1M
+
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2420
+#define OMAP_SMS_BASE	(L3_24XX_BASE + 0x8000)
+#endif
+#ifdef CONFIG_ARCH_OMAP2430
+#define OMAP_SMS_BASE	OMAP243X_SMS_PHYS
+#endif
+#ifdef CONFIG_ARCH_OMAP3430
+#define OMAP_SMS_BASE	SMS_PHYS
+#endif
+
+#define	SMS_ROT0_PHYSICAL_BA(context)	__REG32(OMAP_SMS_BASE + 0x188 \
+						+ 0x10 * context)
+#define	SMS_ROT_CONTROL(context)	__REG32(OMAP_SMS_BASE + 0x180 \
+						+ 0x10 * context)
+#define	SMS_ROT0_SIZE(context)		__REG32(OMAP_SMS_BASE + 0x184 \
+						+ 0x10 * context)
+#ifdef CONFIG_ARCH_OMAP3430
+#define DSI_PROTO_ENG_REG_BASE		0x4804FC00
+#define DSI_PLL_CONTROLLER_REG_BASE	0x4804FF00
+
+/* DSI PHY registers */
+#define DSI_CLK_CTRL		0x54
+
+/* DSI PLL registers */
+#define DSI_PLL_CONTROL		0x00
+#define DSI_PLL_STATUS		0x04
+#define DSI_PLL_GO		0x08
+#define DSI_PLL_CONFIGURATION1	0x0C
+#define DSI_PLL_CONFIGURATION2	0x10
+
+#endif
+
+/* Structure to store and restore the DSS registers */
+struct omap_dispc_regs {
+	u32 revision;		/* 0x000 */
+	u32 res1[3];
+	u32 sysconfig;		/* 0x010 */
+	u32 sysstatus;		/* 0x014 */
+	u32 irqstatus;		/* 0x018 */
+	u32 irqenable;		/* 0x01C */
+	u32 res2[8];
+	u32 control;		/* 0x040 */
+	u32 config;		/* 0x044 */
+	u32 capable;		/* 0x048 */
+	u32 default_color0;	/* 0x04C */
+	u32 default_color1;	/* 0x050 */
+	u32 trans_color0;	/* 0x054 */
+	u32 trans_color1;	/* 0x058 */
+	u32 line_status;	/* 0x05C */
+	u32 line_number;	/* 0x060 */
+	u32 timing_h;		/* 0x064 */
+	u32 timing_v;		/* 0x068 */
+	u32 pol_freq;		/* 0x06C */
+	u32 divisor;		/* 0x070 */
+	u32 global_alpha;	/* 0x074 */
+	u32 size_dig;		/* 0x078 */
+	u32 size_lcd;		/* 0x07C */
+	u32 gfx_ba0;		/* 0x080 */
+	u32 gfx_ba1;		/* 0x084 */
+	u32 gfx_position;	/* 0x088 */
+	u32 gfx_size;		/* 0x08C */
+	u32 res4[4];
+	u32 gfx_attributes;	/* 0x0A0 */
+	u32 gfx_fifo_threshold;	/* 0x0A4 */
+	u32 gfx_fifo_size;	/* 0x0A8 */
+	u32 gfx_row_inc;	/* 0x0AC */
+	u32 gfx_pixel_inc;	/* 0x0B0 */
+	u32 gfx_window_skip;	/* 0x0B4 */
+	u32 gfx_table_ba;	/* 0x0B8 */
+	u32 vid1_ba0;		/* 0x0BC */
+	u32 vid1_ba1;		/* 0x0C0 */
+	u32 vid1_position;	/* 0x0C4 */
+	u32 vid1_size;		/* 0x0C8 */
+	u32 vid1_attributes;	/* 0x0CC */
+	u32 vid1_fifo_threshold;	/* 0x0D0 */
+	u32 vid1_fifo_size;	/* 0x0D4 */
+	u32 vid1_row_inc;	/* 0x0D8 */
+	u32 vid1_pixel_inc;	/* 0x0DC */
+	u32 vid1_fir;		/* 0x0E0 */
+	u32 vid1_picture_size;	/* 0x0E4 */
+	u32 vid1_accu0;		/* 0x0E8 */
+	u32 vid1_accu1;		/* 0x0EC */
+	u32 vid1_fir_coef_h0;	/* 0x0F0 */
+	u32 vid1_fir_coef_hv0;	/* 0x0F4 */
+	u32 vid1_fir_coef_h1;	/* 0x0F8 */
+	u32 vid1_fir_coef_hv1;	/* 0x0FC */
+	u32 vid1_fir_coef_h2;	/* 0x100 */
+	u32 vid1_fir_coef_hv2;	/* 0x104 */
+	u32 vid1_fir_coef_h3;	/* 0x108 */
+	u32 vid1_fir_coef_hv3;	/* 0x10C */
+	u32 vid1_fir_coef_h4;	/* 0x110 */
+	u32 vid1_fir_coef_hv4;	/* 0x114 */
+	u32 vid1_fir_coef_h5;	/* 0x118 */
+	u32 vid1_fir_coef_hv5;	/* 0x11C */
+	u32 vid1_fir_coef_h6;	/* 0x120 */
+	u32 vid1_fir_coef_hv6;	/* 0x124 */
+	u32 vid1_fir_coef_h7;	/* 0x128 */
+	u32 vid1_fir_coef_hv7;	/* 0x12C */
+	u32 vid1_conv_coef0;	/* 0x130 */
+	u32 vid1_conv_coef1;	/* 0x134 */
+	u32 vid1_conv_coef2;	/* 0x138 */
+	u32 vid1_conv_coef3;	/* 0x13C */
+	u32 vid1_conv_coef4;	/* 0x140 */
+	u32 res5[2];
+	u32 vid2_ba0;		/* 0x14C */
+	u32 vid2_ba1;		/* 0x150 */
+	u32 vid2_position;	/* 0x154 */
+	u32 vid2_size;		/* 0x158 */
+	u32 vid2_attributes;	/* 0x15C */
+	u32 vid2_fifo_threshold;	/* 0x160 */
+	u32 vid2_fifo_size;	/* 0x164 */
+	u32 vid2_row_inc;	/* 0x168 */
+	u32 vid2_pixel_inc;	/* 0x16C */
+	u32 vid2_fir;		/* 0x170 */
+	u32 vid2_picture_size;	/* 0x174 */
+	u32 vid2_accu0;		/* 0x178 */
+	u32 vid2_accu1;		/* 0x17C */
+	u32 vid2_fir_coef_h0;	/* 0x180 */
+	u32 vid2_fir_coef_hv0;	/* 0x184 */
+	u32 vid2_fir_coef_h1;	/* 0x188 */
+	u32 vid2_fir_coef_hv1;	/* 0x18C */
+	u32 vid2_fir_coef_h2;	/* 0x190 */
+	u32 vid2_fir_coef_hv2;	/* 0x194 */
+	u32 vid2_fir_coef_h3;	/* 0x198 */
+	u32 vid2_fir_coef_hv3;	/* 0x19C */
+	u32 vid2_fir_coef_h4;	/* 0x1A0 */
+	u32 vid2_fir_coef_hv4;	/* 0x1A4 */
+	u32 vid2_fir_coef_h5;	/* 0x1A8 */
+	u32 vid2_fir_coef_hv5;	/* 0x1AC */
+	u32 vid2_fir_coef_h6;	/* 0x1B0 */
+	u32 vid2_fir_coef_hv6;	/* 0x1B4 */
+	u32 vid2_fir_coef_h7;	/* 0x1B8 */
+	u32 vid2_fir_coef_hv7;	/* 0x1BC */
+	u32 vid2_conv_coef0;	/* 0x1C0 */
+	u32 vid2_conv_coef1;	/* 0x1C4 */
+	u32 vid2_conv_coef2;	/* 0x1C8 */
+	u32 vid2_conv_coef3;	/* 0x1CC */
+	u32 vid2_conv_coef4;	/* 0x1D0 */
+	u32 data_cycle1;	/* 0x1D4 */
+	u32 data_cycle2;	/* 0x1D8 */
+	u32 data_cycle3;	/* 0x1DC */
+#ifdef CONFIG_ARCH_OMAP3430
+	/* omap3430 specific registers */
+	u32 vid1_fir_coef_v0;	/* 0x1E0 */
+	u32 vid1_fir_coef_v1;	/* 0x1E4 */
+	u32 vid1_fir_coef_v2;	/* 0x1E8 */
+	u32 vid1_fir_coef_v3;	/* 0x1EC */
+	u32 vid1_fir_coef_v4;	/* 0x1F0 */
+	u32 vid1_fir_coef_v5;	/* 0x1F4 */
+	u32 vid1_fir_coef_v6;	/* 0x1F8 */
+	u32 vid1_fir_coef_v7;	/* 0x1FC */
+	u32 vid2_fir_coef_v0;	/* 0x200 */
+	u32 vid2_fir_coef_v1;	/* 0x204 */
+	u32 vid2_fir_coef_v2;	/* 0x208 */
+	u32 vid2_fir_coef_v3;	/* 0x20C */
+	u32 vid2_fir_coef_v4;	/* 0x210 */
+	u32 vid2_fir_coef_v5;	/* 0x214 */
+	u32 vid2_fir_coef_v6;	/* 0x218 */
+	u32 vid2_fir_coef_v7;	/* 0x21C */
+	u32 cpr_coef_r;		/* 0x220 */
+	u32 cpr_coef_g;		/* 0x224 */
+	u32 cpr_coef_b;		/* 0x228 */
+	u32 gfx_preload;	/* 0x22C */
+	u32 vid1_preload;	/* 0x230 */
+	u32 vid2_preload;	/* 0x234 */
+#endif				/* CONFIG_ARCH_OMAP3430 */
+};
+
+/* WARN: read-only registers omitted! */
+struct omap_dss_regs {
+	u32 sysconfig;
+	u32 control;
+#ifdef CONFIG_ARCH_OMAP3430
+	u32 sdi_control;
+	u32 pll_control;
+#endif
+	struct omap_dispc_regs dispc;
+};
+
+struct tvlcd_status_t {
+	int ltype;
+	int output_dev;
+	int status;
+};
+
+/* color space conversion matrices */
+const static short int cc_bt601[3][3] = { {298, 409, 0},
+{298, -208, -100},
+{298, 0, 517}
+};
+const static short int cc_bt709[3][3] = { {298, 459, 0},
+{298, -137, -55},
+{298, 0, 541}
+};
+const static short int cc_bt601_full[3][3] = { {256, 351, 0},
+{256, -179, -86},
+{256, 0, 443}
+};
+
+/*----------- following are exposed values and APIs -------------------------*/
+
+#define OMAP_GRAPHICS		0
+#define OMAP_VIDEO1		1
+#define OMAP_VIDEO2		2
+#define OMAP_DSS_GENERIC	3
+#define OMAP_DSS_DISPC_GENERIC	4
+#define DSS_CTX_NUMBER		(OMAP_DSS_DISPC_GENERIC + 1)
+
+#define OMAP_OUTPUT_LCD	4
+#define OMAP_OUTPUT_TV		5
+
+#define OMAP_DMA_0		0
+#define OMAP_DMA_1		1
+
+/* Dithering enable/disable */
+#define DITHERING_ON		28
+#define DITHERING_OFF		29
+
+/* TVOUT Definitions */
+enum omap_tvstandard {
+	PAL_BDGHI = 0,
+	PAL_NC,
+	PAL_N,
+	PAL_M,
+	PAL_60,
+	NTSC_M,
+	NTSC_J,
+	NTSC_443,
+};
+
+/* TV ref ON/OFF */
+#define TVREF_ON		30
+#define TVREF_OFF		31
+
+/* LCD data lines configuration */
+#define LCD_DATA_LINE_12BIT     32
+#define LCD_DATA_LINE_16BIT     33
+#define LCD_DATA_LINE_18BIT     34
+#define LCD_DATA_LINE_24BIT     35
+
+/* transparent color key types */
+#define OMAP_GFX_DESTINATION 	100
+#define OMAP_VIDEO_SOURCE	101
+
+/* SDRAM page size parameters used for VRFB settings */
+#define PAGE_WIDTH_EXP		5	/* page width = 1 << PAGE_WIDTH_EXP */
+#define PAGE_HEIGHT_EXP		5	/* page height = 1 << PAGE_HEIGHT_EXP */
+
+/* 2048 x 2048 is max res supported by OMAP display controller */
+#define MAX_PIXELS_PER_LINE	2048
+#define MAX_LINES		2048
+
+#define TV_OFF		   	0
+#define TV_ON		   	1
+#define LCD_OFF			0
+#define LCD_ON			1
+
+/* States needed for TV-LCD on the fly */
+#define TVLCD_STOP		1
+#define TVLCD_CONTINUE		2
+
+/* VRFB offset computation parameters */
+#define SIDE_H          1
+#define SIDE_W          0
+
+/* Color Conversion macros */
+#define FULL_COLOR_RANGE 	1
+#define CC_BT601	 	0
+#define CC_BT709		2
+#define CC_BT601_FULL		3
+
+/* GFX FIFO thresholds */
+#define RMODE_GFX_FIFO_HIGH_THRES       0x3FC
+#define RMODE_GFX_FIFO_LOW_THRES        0x3BC
+
+/* Data structures to communicate between HAL and driver files. */
+struct omap_video_params {
+	int video_layer;
+	unsigned long vid_position;
+	unsigned long vid_size;
+	unsigned long vid_picture_size;
+};
+struct omap_scaling_params {
+	int video_layer;
+	int win_height;
+	int win_width;
+	int crop_height;
+	int crop_width;
+	int flicker_filter;
+};
+struct omap_dma_params {
+	int video_layer;
+	int dma_num;
+	int row_inc_value;
+	int pixel_inc_value;
+};
+
+/* Color conversion matrix  */
+extern short int current_colorconv_values[2][3][3];
+
+/* Encoders and Outputs specific Definitions*/
+#define MAX_CHANNEL             2	/* No of Overlays */
+#define MAX_CHAR                20
+#define MAX_ENCODER_DEVICE      3
+#define MAX_MODE		10
+#define MAX_OUTPUT		3
+
+struct omap_encoder_device;
+
+struct omap_enc_output_ops {
+	int count;
+	char *(*enumoutput) (int index, void *data);
+	int (*setoutput) (int index, char *mode_name, void *data);
+	int (*getoutput) (void *data);
+};
+
+struct omap_enc_mode_ops {
+	int (*setmode) (char *mode_name, void *data);
+	char *(*getmode) (void *data);
+};
+
+struct omap_encoder_device {
+	u8 name[MAX_CHAR];
+	int channel_id;
+	struct omap_enc_output_ops *output_ops;
+	struct omap_enc_mode_ops *mode_ops;
+	int current_output;
+	int no_outputs;
+	int (*initialize) (void *data);
+	int (*deinitialize) (void *data);
+};
+
+struct channel_obj {
+	int channel_no;
+	int num_encoders;
+	struct omap_encoder_device *enc_devices[MAX_ENCODER_DEVICE];
+	int current_encoder;
+	int current_mode;
+};
+
+struct omap_mode_info {
+	char name[MAX_CHAR];
+	u32 width, height;
+	u32 clk_rate;
+	u32 clk_div;
+	u16 hfp, hbp, hsw;
+	u16 vfp, vbp, vsw;
+	void *priv_data;
+};
+struct omap_output_info {
+	char name[MAX_CHAR];
+	void *mode;
+	u8 no_modes;
+	u8 current_mode;
+	int data_lines;
+};
+
+/* input layer APIs */
+int omap_disp_request_layer(int ltype);
+void omap_disp_release_layer(int ltype);
+void omap_disp_disable_layer(int ltype);
+void omap_disp_enable_layer(int ltype);
+int omap_disp_reg_sync_bit(int output_dev);
+
+/* output device APIs */
+void omap_disp_get_panel_size(int output_dev, int *witdth, int *height);
+void omap_disp_set_panel_size(int output_dev, int witdth, int height);
+void omap_disp_disable_output_dev(int output_dev);
+void omap_disp_enable_output_dev(int output_dev);
+void omap_disp_set_dssfclk(void);
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+void omap_disp_set_tvref(int tvref_state);
+#endif
+int omap_disp_get_vrfb_offset(u32, u32, int);
+
+/* connection of input layers to output devices */
+int omap_disp_get_output_dev(int ltype);
+void omap_disp_set_dma_params(int ltype, int output_dev,
+			       u32 ba0, u32 ba1, u32 row_inc, u32 pix_inc);
+
+/* DSS power management */
+void omap_disp_get_dss(void);
+void omap_disp_put_dss(void);
+
+/* Color conversion */
+void omap_disp_set_default_colorconv(int ltype, int color_space);
+void omap_disp_set_colorconv(int v, int full_range_conversion);
+/* background color */
+void omap_disp_set_bg_color(int output_dev, int color);
+void omap_disp_get_bg_color(int output_dev, int *color);
+
+/* transparent color key */
+void omap_disp_set_colorkey(int output_dev, int key_type, int key_val);
+void omap_disp_get_colorkey(int output_dev, int *key_type, int *key_val);
+void omap_disp_enable_colorkey(int output_dev);
+void omap_disp_disable_colorkey(int output_dev);
+
+/* alpha blending */
+int omap_disp_get_alphablend(int output_dev);
+void omap_disp_set_alphablend(int output_dev, int value);
+unsigned char omap_disp_get_global_alphablend_value(int ltype);
+void omap_disp_set_global_alphablend_value(int ltype, int value);
+
+/* rotation APIs */
+int omap_disp_set_vrfb(int context, u32 phy_addr,
+			u32 width, u32 height, u32 bytes_per_pixel);
+
+/* display controller register synchronization */
+void omap_disp_reg_sync(int output_dev);
+int omap_disp_reg_sync_done(int output_dev);
+
+/* disable LCD and TV outputs and sync with next frame */
+void omap_disp_disable(unsigned long timeout_ticks);
+
+/* interrupt handling */
+typedef void (*omap_disp_isr_t) (void *arg, struct pt_regs *regs,
+				  u32 irqstatus);
+int omap_disp_register_isr(omap_disp_isr_t isr, void *arg,
+			    unsigned int mask);
+int omap_disp_unregister_isr(omap_disp_isr_t isr);
+int omap_disp_irqenable(omap_disp_isr_t isr, unsigned int mask);
+int omap_disp_irqdisable(omap_disp_isr_t isr, unsigned int mask);
+void omap_disp_save_initstate(int layer);
+
+/* clk functions */
+void omap_disp_put_all_clks(void);
+void omap_disp_get_all_clks(void);
+void omap_disp_start_video_layer(int);
+void omap_disp_set_addr(int ltype, u32 lcd_phys_addr, u32 tv_phys_addr_f0,
+			 u32 tv_phys_addr_f1);
+
+/* Video parameters functions */
+void omap_disp_set_vidattributes(unsigned int video_layer,
+				  unsigned int vid_attributes);
+void omap_disp_set_fifothreshold(unsigned int video_layer);
+void omap_disp_set_scaling(struct omap_scaling_params *scale_params);
+void omap_disp_set_vid_params(struct omap_video_params *vid_params);
+void set_dma_layer_parameters(int dma_num, int video_layer,
+			      int row_inc_value, int pixel_inc_value);
+void omap_disp_set_row_pix_inc_values(int video_layer, int row_inc_value,
+				       int pixel_inc_value);
+void set_crop_layer_parameters(int video_layer, int cropwidth,
+			       int cropheight);
+void omap_set_crop_layer_parameters(int video_layer, int cropwidth,
+				     int cropheight);
+
+/* Output and Standard releated functions */
+int omap_disp_set_mode(int ch_no, char *buffer);
+char *omap_disp_get_mode(int ch_no);
+int omap_disp_set_output(int ch_no, int index);
+int omap_disp_get_output(int ch_no, int *index);
+int omap_disp_enum_output(int ch_no, int index, char *name);
+
+/* Register/Unregister encoders */
+int omap_register_encoder(struct omap_encoder_device
+			   *encoder);
+int omap_unregister_encoder(struct omap_encoder_device
+			     *encoder);
+
+/*------------------ end of exposed values and APIs -------------------------*/
+
+#endif				/* __ASM_ARCH_OMAP_DISP_H */
diff --git a/arch/arm/plat-omap/include/mach/omap-venc.h b/arch/arm/plat-omap/include/mach/omap-venc.h
new file mode 100644
index 0000000..60c1352
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/omap-venc.h
@@ -0,0 +1,627 @@
+/*
+ * include/asm-arm/arch-omap/omap-venc.h
+ *
+ * Copyright (C) 2004-2005 Texas Instruments, Inc.
+ * TV Standard configuration for Video Encoder in OMAP24XX
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+/* TV Encoder initialization for PAL and NTSC */
+
+/* Typical encoder values for different TV tests */
+#define VENC_HFLTR_CTRL_EN			0x00000000
+#define VENC_X_COLOR_VAL			0x00000000
+
+#define VENC_LINE21_VAL				0x00000000
+#define VENC_LN_SEL_VAL				0x00000015
+#define VENC_HTRIGGER_VTRIGGER_VAL		0x00000000
+#define VENC_LN_SEL_VAL_PAL_BDGHI		0x01290015
+
+#define VENC_TVDETGP_INT_START_STOP_X_VAL	0x00140001
+#define VENC_TVDETGP_INT_START_STOP_Y_VAL	0x00010001
+#define VENC_GEN_CTRL_VAL			0x00FF0000
+#define VENC_GEN_CTRL_PAL_VAL			0x00F90000
+
+/* DAC enable and in normal operation */
+#ifdef CONFIG_ARCH_OMAP2420
+#define VENC_DAC_ENABLE				0x00000002
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2430
+#define VENC_DAC_ENABLE				0x0000000A
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3430
+#define VENC_DAC_ENABLE				0x0000000D
+#endif
+
+/*Values that are same for NTSC, PAL-M AND PAL-60 */
+#define F_CONTROL_GEN				0x00000000
+#define SYNC_CONTROL_GEN			0x00001040
+#define VENC_LLEN_GEN				0x00000359
+#define VENC_FLENS_GEN                  	0x0000020C
+#define VENC_C_PHASE_GEN                	0x00000000
+#define VENC_CC_CARR_WSS_CARR_GEN       	0x000025ed
+#define VENC_L21_WC_CTL_GEN             	0x00170000
+#define VENC_SAVID_EAVID_GEN            	0x069300F4
+#define VENC_FLEN_FAL_GEN             		0x0016020C
+#define VENC_HS_EXT_START_STOP_X_GEN    	0x000F0359
+#define VENC_VS_INT_START_X_GEN         	0x01A00000
+#define VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN   0x020D01AC
+#define VENC_VS_EXT_STOP_Y_GEN			0x00000006
+#define VENC_FID_INT_START_X_FID_INT_START_Y_GEN  0x0001008A
+#define VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN 0x01AC0106
+#define VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN 0x01060006
+
+/* Values that are same for PAL-BDGHI, PAL-N, PAL-NC */
+
+#define VENC_LLEN_PAL				0x0000035F
+#define VENC_FLENS_PAL				0x00000270
+
+#define VENC_LLEN_PAL_M				0x00000359
+#define VENC_FLENS_PAL_M			0x0000020C
+
+#define VENC_C_PHASE_PAL		       	0x000000F0 /* N */
+#define VENC_C_PHASE_PAL_BDGHI			0x00000000
+#define VENC_C_PHASE_PAL_NC		       	0x00000000
+
+#define VENC_CC_CARR_WSS_CARR_PAL		0x000025ED
+
+#define VENC_L21_WC_CTL_PAL			0x00000000
+#define VENC_L21_WC_CTL_PAL_BDGHI		0x0000F603
+
+#define VENC_SAVID_EAVID_PAL			0x06A70108
+#define VENC_FLEN_FAL_PAL			0x00170270
+#define VENC_FLEN_FAL_PAL_BDGHI			0x00180270
+#define VENC_HS_EXT_START_STOP_X_PAL		0x000F035F
+#define VENC_VS_INT_START_X_PAL			0x01A70000
+#define VENC_VS_EXT_STOP_Y_PAL			0x00000005
+#define VENC_VS_EXT_STOP_Y_PAL_BDGHI		0x00000025
+#define VENC_VS_EXT_STOP_X_VS_EXT_START_Y_PAL	0x027101AF
+#define VENC_VS_EXT_STOP_X_VS_EXT_START_Y_PAL_BDGHI	0x000101AF
+
+#define VENC_GAIN_U_PAL_BDGHI			0x00000130
+#define VENC_CC_CARR_WSS_CARR_PAL_BDGHI		0x2F7225ED
+
+#define VENC_GAIN_U_PAL_N			0x000000FD
+#define VENC_GAIN_U_PAL_NC			0x00000130
+#define VENC_GAIN_U_PAL_M			0x00000140
+#define VENC_GAIN_U_PAL_60			0x00000140
+
+#define VENC_GAIN_V_PAL_BDGHI			0x000001B0
+
+#define VENC_GAIN_V_PAL_N			0x00000165
+#define VENC_GAIN_V_PAL_NC			0x000001B0
+#define VENC_GAIN_V_PAL_M			0x00000190
+#define VENC_GAIN_V_PAL_60			0x00000190
+
+#define VENC_GAIN_Y_PAL_BDGHI			0x000001B0
+#define VENC_GAIN_Y_PAL_N			0x00000177
+#define VENC_GAIN_Y_PAL_NC			0x000001B0
+#define VENC_GAIN_Y_PAL_M			0x000001C0
+#define VENC_GAIN_Y_PAL_60			0x000001C0
+
+#define VENC_BLACK_LEVEL_PAL_BDGHI		0x0000003B
+
+#define VENC_BLANK_LEVEL_PAL_BDGHI		0x0000003B
+#define VENC_BLACK_LEVEL_PAL_NC			0x00000063
+#define VENC_BLANK_LEVEL_PAL_NC			0x00000063
+
+#define VENC_BLACK_LEVEL_PAL_N			0x00000060
+#define VENC_BLANK_LEVEL_PAL_N			0x00000053
+
+#define VENC_BLACK_LEVEL_PAL_M			0x00000069
+#define VENC_BLANK_LEVEL_PAL_M			0x0000005C
+
+#define VENC_BLACK_LEVEL_PAL_60			0x00000069
+#define VENC_BLANK_LEVEL_PAL_60			0x0000005C
+
+#define VENC_M_CONTROL_PAL			0x00000002
+#define VENC_M_CONTROL_PAL_M			0x00000003
+#define VENC_M_CONTROL_PAL_60			0x00000003
+
+#define VENC_BSTAMP_WSS_DATA_PAL_BDGHI		0x00000043
+
+#define VENC_BSTAMP_WSS_DATA_PAL_N		0x00000038
+#define VENC_BSTAMP_WSS_DATA_PAL_M		0x0000003F
+#define VENC_BSTAMP_WSS_DATA_PAL_NC		0x00000041
+#define VENC_BSTAMP_WSS_DATA_PAL_60		0x0000003F
+
+#define VENC_S_CARR_PAL_M			0x21E6EFE3
+#define VENC_S_CARR_PAL_NC			0x21E6EFE3
+#define VENC_S_CARR_PAL_BDGHI			0x2A098ACB
+#define VENC_S_CARR_PAL_60			0x2A098ACB
+
+#define VENC_LAL_PHASE_RESET_PAL		0x00040136 /* BDGHI & N */
+#define VENC_LAL_PHASE_RESET_PAL_NC		0x00040135
+#define VENC_LAL_PHASE_RESET_PAL_2		0x00040107 /* PAL-M & PAL-60 */
+
+#define VENC_HS_INT_START_STOP_X_PAL		0x00920358 /* BDGHI & N */
+#define VENC_HS_INT_START_STOP_X_NC		0x00880358
+#define VENC_HS_INT_START_STOP_X_PAL_2		0x007e034e /* PAL-M & PAL-60 */
+
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL	0x000601A7
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_2	0x020901a0 /* PAL-M & PAL-60*/
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_NC 0x026F01A7
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_BDGHI	0x000001A7
+
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL	0x01AF0036
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_2	0x01ac0022 /* PAL-M & PAL-60 */
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_NC 0x01AF002E
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_BDGHI	0x01AF0000
+
+#define VENC_AVID_START_STOP_X_PAL		0x03530082 /* BDGHI & N */
+#define VENC_AVID_START_STOP_X_PAL_NC		0x03530083
+#define VENC_AVID_START_STOP_X_PAL_2		0x03530082 /* PAL-M & PAL-60 */
+
+#define VENC_AVID_START_STOP_Y_PAL		0x0270002E
+#define VENC_AVID_START_STOP_Y_PAL_2		0x0270002E /* PAL-M & PAL-60 */
+#define VENC_AVID_START_STOP_Y_PAL_NC		0x026E002E
+#define VENC_AVID_START_STOP_Y_PAL_BDGHI	0x026C002E
+#define VENC_FID_INT_START_X_FID_INT_START_Y_PAL 0x0005008A
+
+#define VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_PAL 0x002E0138
+#define VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_PAL_BDGHI	0x01380001
+
+#define VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_PAL 0x01380005
+
+/* NTSC */
+
+#define VENC_CC_CARR_WSS_CARR_GEN_NTSC_M	0x043F2631
+#define VENC_X_COLOR_VAL_NTSC_M			0x00000007
+#define VENC_LN_SEL_VAL_NTSC_M			0x01310011
+#define VENC_L21_WC_CTL_GEN_NTSC_M		0x0000F003
+#define VENC_HS_INT_START_STOP_X_NTSC_M		0x008E0350
+#define VENC_AVID_START_STOP_Y_NTSC_M		0x02060024
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC_M 0x020701A0
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC_M 0x01AC0024
+#define VENC_AVID_START_STOP_X_NTSC_M		0x03480078
+#define VENC_GAIN_U_NTSC_M			0x00000102
+#define VENC_GAIN_U_NTSC_J			0x00000100
+#define VENC_GAIN_U_NTSC_443			0x00000140
+
+#define VENC_GAIN_V_NTSC_M			0x0000016C
+#define VENC_GAIN_V_NTSC_J			0x0000016D
+#define VENC_GAIN_V_NTSC_443			0x00000190
+
+#define VENC_GAIN_Y_NTSC_M			0x0000012F
+#define VENC_GAIN_Y_NTSC_J			0x00000196
+#define VENC_GAIN_Y_NTSC_443			0x000001C0
+
+#define VENC_BLACK_LEVEL_NTSC_443		0x00000069
+#define VENC_BLANK_LEVEL_NTSC_443		0x0000005C
+
+#define VENC_BLACK_LEVEL_NTSC_M			0x00000043
+#define VENC_BLANK_LEVEL_NTSC_M			0x00000038
+
+#define VENC_BLACK_LEVEL_NTSC_J			0x00000053
+#define VENC_BLANK_LEVEL_NTSC_J			0x00000053
+
+#define VENC_M_CONTROL_NTSC			0x00000001
+
+#define VENC_BSTAMP_WSS_DATA_NTSC		0x00000038
+#define VENC_BSTAMP_WSS_DATA_NTSC_443		0x0000003F
+
+#define VENC_S_CARR_NTSC_443			0x2A098ACB
+#define VENC_S_CARR_NTSC			0x21F07C1F
+
+#define VENC_HTRIGGER_VTRIGGER_VAL		0x00000000
+
+#define VENC_FLEN_FAL_NTSC			0x0001020C
+
+#define VENC_LAL_PHASE_RESET_NTSC		0x00060107
+
+#define VENC_HS_INT_START_STOP_X_NTSC		0x007E034E
+
+#define VENC_HS_INT_START_STOP_X_443		0x007e034e
+
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC	0x020901A0
+#define VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC_443 0x020901a0
+
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC	0x01AC0022
+#define VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC_443 0x01ac0022
+
+#define VENC_AVID_START_STOP_X_NTSC		0x032000A0
+#define VENC_AVID_START_STOP_X_NTSC_443		0x03480079
+
+#define VENC_AVID_START_STOP_Y_NTSC		0x02060026
+#define VENC_AVID_START_STOP_Y_NTSC_443		0x02040024
+
+#define VENC_TVDETGP_INT_START_STOP_X_GEN	0x00140001
+#define VENC_TVDETGP_INT_START_STOP_Y_GEN	0x00010001
+
+struct tv_standard_config{
+	u8 std_name[25];
+	u32 venc_llen;
+	u32 venc_flens;
+	u32 venc_hfltr_ctrl;
+	u32 venc_cc_carr_wss_carr;
+	u32 venc_c_phase;
+	u32 venc_gain_u;
+	u32 venc_gain_v;
+	u32 venc_gain_y;
+	u32 venc_black_level;
+	u32 venc_blank_level;
+	u32 venc_x_color;
+	u32 venc_m_control;
+	u32 venc_bstamp_wss_data;
+	u32 venc_s_carr;
+	u32 venc_line21;
+	u32 venc_ln_sel;
+	u32 venc_l21_wc_ctl;
+	u32 venc_htrigger_vtrigger;
+	u32 venc_savid_eavid;
+	u32 venc_flen_fal;
+	u32 venc_lal_phase_reset;
+	u32 venc_hs_int_start_stop_x;
+	u32 venc_hs_ext_start_stop_x;
+	u32 venc_vs_int_start_x;
+	u32 venc_vs_int_stop_x_vs_int_start_y;
+	u32 venc_vs_int_stop_y_vs_ext_start_x;
+	u32 venc_vs_ext_stop_x_vs_ext_start_y;
+	u32 venc_vs_ext_stop_y;
+	u32 venc_avid_start_stop_x;
+	u32 venc_avid_start_stop_y;
+	u32 venc_fid_int_start_x_fid_int_start_y;
+	u32 venc_fid_int_offset_y_fid_ext_start_x;
+	u32 venc_fid_ext_start_y_fid_ext_offset_y;
+	u32 venc_tvdetgp_int_start_stop_x;
+	u32 venc_tvdetgp_int_start_stop_y;
+	u32 venc_gen_ctrl;
+	u32 venc_dac_tst;
+};
+
+#ifndef CONFIG_ARCH_OMAP3410
+struct tv_standard_config tv_standards[] = {
+	{
+		"pal_bdghi",
+		VENC_LLEN_PAL,
+		VENC_FLENS_PAL,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_PAL_BDGHI,
+		VENC_C_PHASE_PAL_BDGHI,
+		VENC_GAIN_U_PAL_BDGHI,
+		VENC_GAIN_V_PAL_BDGHI,
+		VENC_GAIN_Y_PAL_BDGHI,
+		VENC_BLACK_LEVEL_PAL_BDGHI,
+		VENC_BLANK_LEVEL_PAL_BDGHI,
+		VENC_X_COLOR_VAL_NTSC_M,
+		VENC_M_CONTROL_PAL,
+		VENC_BSTAMP_WSS_DATA_PAL_M,
+		VENC_S_CARR_PAL_BDGHI,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL_PAL_BDGHI,
+		VENC_L21_WC_CTL_PAL,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_PAL,
+		VENC_FLEN_FAL_PAL_BDGHI,
+		VENC_LAL_PHASE_RESET_PAL_NC,
+		VENC_HS_INT_START_STOP_X_NC,
+		VENC_HS_EXT_START_STOP_X_PAL,
+		VENC_VS_INT_START_X_PAL,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_BDGHI,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_BDGHI,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_PAL_BDGHI,
+		VENC_VS_EXT_STOP_Y_PAL,
+		VENC_AVID_START_STOP_X_PAL_NC,
+		VENC_AVID_START_STOP_Y_PAL_BDGHI,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_PAL,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_PAL_BDGHI,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_PAL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"pal_n",
+		VENC_LLEN_PAL,
+		VENC_FLENS_PAL,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_PAL,
+		VENC_C_PHASE_PAL,
+		VENC_GAIN_U_PAL_N,
+		VENC_GAIN_V_PAL_N,
+		VENC_GAIN_Y_PAL_N,
+		VENC_BLACK_LEVEL_PAL_N,
+		VENC_BLANK_LEVEL_PAL_N,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_PAL,
+		VENC_BSTAMP_WSS_DATA_PAL_BDGHI,
+		VENC_S_CARR_PAL_BDGHI,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_PAL,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_PAL,
+		VENC_FLEN_FAL_PAL,
+		VENC_LAL_PHASE_RESET_PAL,
+		VENC_HS_INT_START_STOP_X_PAL,
+		VENC_HS_EXT_START_STOP_X_PAL,
+		VENC_VS_INT_START_X_PAL,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_PAL,
+		VENC_VS_EXT_STOP_Y_PAL,
+		VENC_AVID_START_STOP_X_PAL,
+		VENC_AVID_START_STOP_Y_PAL,
+		VENC_FID_INT_START_X_FID_INT_START_Y_PAL,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_PAL,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_PAL,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_PAL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"pal_nc",
+		VENC_LLEN_PAL,
+		VENC_FLENS_PAL,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_PAL,
+		VENC_C_PHASE_PAL,
+		VENC_GAIN_U_PAL_NC,
+		VENC_GAIN_V_PAL_NC,
+		VENC_GAIN_Y_PAL_NC,
+		VENC_BLACK_LEVEL_PAL_NC,
+		VENC_BLANK_LEVEL_PAL_NC,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_PAL,
+		VENC_BSTAMP_WSS_DATA_PAL_NC,
+		VENC_S_CARR_PAL_NC,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_PAL,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_PAL,
+		VENC_FLEN_FAL_PAL,
+		VENC_LAL_PHASE_RESET_PAL_NC,
+		VENC_HS_INT_START_STOP_X_NC,
+		VENC_HS_EXT_START_STOP_X_PAL,
+		VENC_VS_INT_START_X_PAL,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_NC,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_NC,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_PAL,
+		VENC_VS_EXT_STOP_Y_PAL,
+		VENC_AVID_START_STOP_X_PAL_NC,
+		VENC_AVID_START_STOP_Y_PAL_NC,
+		VENC_FID_INT_START_X_FID_INT_START_Y_PAL,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_PAL,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_PAL,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_PAL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"pal_m",
+		VENC_LLEN_PAL_M,
+		VENC_FLENS_PAL_M,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_GEN,
+		VENC_C_PHASE_GEN,
+		VENC_GAIN_U_PAL_M,
+		VENC_GAIN_V_PAL_M,
+		VENC_GAIN_Y_PAL_M,
+		VENC_BLACK_LEVEL_PAL_M,
+		VENC_BLANK_LEVEL_PAL_M,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_PAL_M,
+		VENC_BSTAMP_WSS_DATA_PAL_M,
+		VENC_S_CARR_PAL_M,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_GEN,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_GEN,
+		VENC_FLEN_FAL_GEN,
+		VENC_LAL_PHASE_RESET_PAL_2,
+		VENC_HS_INT_START_STOP_X_PAL_2,
+		VENC_HS_EXT_START_STOP_X_GEN,
+		VENC_VS_INT_START_X_GEN,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_2,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_2,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN,
+		VENC_VS_EXT_STOP_Y_GEN,
+		VENC_AVID_START_STOP_X_PAL_2,
+		VENC_AVID_START_STOP_Y_PAL_2,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"pal_60",
+		VENC_LLEN_GEN,
+		VENC_FLENS_GEN,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_GEN,
+		VENC_C_PHASE_GEN,
+		VENC_GAIN_U_PAL_60,
+		VENC_GAIN_V_PAL_60,
+		VENC_GAIN_Y_PAL_60,
+		VENC_BLACK_LEVEL_PAL_60,
+		VENC_BLANK_LEVEL_PAL_60,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_PAL_60,
+		VENC_BSTAMP_WSS_DATA_PAL_60,
+		VENC_S_CARR_PAL_60,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_GEN,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_GEN,
+		VENC_FLEN_FAL_GEN,
+		VENC_LAL_PHASE_RESET_PAL_2,
+		VENC_HS_INT_START_STOP_X_PAL_2,
+		VENC_HS_EXT_START_STOP_X_GEN,
+		VENC_VS_INT_START_X_GEN,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_PAL_2,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_PAL_2,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN,
+		VENC_VS_EXT_STOP_Y_GEN,
+		VENC_AVID_START_STOP_X_PAL_2,
+		VENC_AVID_START_STOP_Y_PAL_2,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"ntsc_m",
+		VENC_LLEN_GEN,
+		VENC_FLENS_GEN,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_GEN_NTSC_M,
+		VENC_C_PHASE_GEN,
+		VENC_GAIN_U_NTSC_M,
+		VENC_GAIN_V_NTSC_M,
+		VENC_GAIN_Y_NTSC_M,
+		VENC_BLACK_LEVEL_NTSC_M,
+		VENC_BLANK_LEVEL_NTSC_M,
+		VENC_X_COLOR_VAL_NTSC_M,
+		VENC_M_CONTROL_NTSC,
+		VENC_BSTAMP_WSS_DATA_NTSC,
+		VENC_S_CARR_NTSC,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL_NTSC_M,
+		VENC_L21_WC_CTL_GEN_NTSC_M,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_GEN,
+		VENC_FLEN_FAL_GEN,
+		VENC_LAL_PHASE_RESET_NTSC,
+		VENC_HS_INT_START_STOP_X_NTSC_M,
+		VENC_HS_EXT_START_STOP_X_GEN,
+		VENC_VS_INT_START_X_GEN,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC_M,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC_M,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN,
+		VENC_VS_EXT_STOP_Y_GEN,
+		VENC_AVID_START_STOP_X_NTSC_M,
+		VENC_AVID_START_STOP_Y_NTSC_M,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_PAL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"ntsc_443",
+		VENC_LLEN_GEN,
+		VENC_FLENS_GEN,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_GEN,
+		VENC_C_PHASE_GEN,
+		VENC_GAIN_U_NTSC_443,
+		VENC_GAIN_V_NTSC_443,
+		VENC_GAIN_Y_NTSC_443,
+		VENC_BLACK_LEVEL_NTSC_443,
+		VENC_BLANK_LEVEL_NTSC_443,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_NTSC,
+		VENC_BSTAMP_WSS_DATA_NTSC_443,
+		VENC_S_CARR_NTSC_443,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_GEN,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_GEN,
+		VENC_FLEN_FAL_GEN,
+		VENC_LAL_PHASE_RESET_NTSC,
+		VENC_HS_INT_START_STOP_X_443,
+		VENC_HS_EXT_START_STOP_X_GEN,
+		VENC_VS_INT_START_X_GEN,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC_443,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC_443,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN,
+		VENC_VS_EXT_STOP_Y_GEN,
+		VENC_AVID_START_STOP_X_NTSC_443,
+		VENC_AVID_START_STOP_Y_NTSC_443,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_VAL,
+		VENC_DAC_ENABLE
+	},
+
+	{
+		"ntsc_j",
+		VENC_LLEN_GEN,
+		VENC_FLENS_GEN,
+		VENC_HFLTR_CTRL_EN,
+		VENC_CC_CARR_WSS_CARR_GEN,
+		VENC_C_PHASE_GEN,
+		VENC_GAIN_U_NTSC_J,
+		VENC_GAIN_V_NTSC_J,
+		VENC_GAIN_Y_NTSC_J,
+		VENC_BLACK_LEVEL_NTSC_J,
+		VENC_BLANK_LEVEL_NTSC_J,
+		VENC_X_COLOR_VAL,
+		VENC_M_CONTROL_NTSC,
+		VENC_BSTAMP_WSS_DATA_NTSC,
+		VENC_S_CARR_NTSC,
+		VENC_LINE21_VAL,
+		VENC_LN_SEL_VAL,
+		VENC_L21_WC_CTL_GEN,
+		VENC_HTRIGGER_VTRIGGER_VAL,
+		VENC_SAVID_EAVID_GEN,
+		VENC_FLEN_FAL_GEN,
+		VENC_LAL_PHASE_RESET_NTSC,
+		VENC_HS_INT_START_STOP_X_NTSC,
+		VENC_HS_EXT_START_STOP_X_GEN,
+		VENC_VS_INT_START_X_GEN,
+		VENC_VS_INT_STOP_X_VS_INT_START_Y_NTSC,
+		VENC_VS_INT_STOP_Y_VS_EXT_START_X_NTSC,
+		VENC_VS_EXT_STOP_X_VS_EXT_START_Y_GEN,
+		VENC_VS_EXT_STOP_Y_GEN,
+		VENC_AVID_START_STOP_X_NTSC,
+		VENC_AVID_START_STOP_Y_NTSC,
+		VENC_FID_INT_START_X_FID_INT_START_Y_GEN,
+		VENC_FID_INT_OFFSET_Y_FID_EXT_START_X_GEN,
+		VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y_GEN,
+		VENC_TVDETGP_INT_START_STOP_X_GEN,
+		VENC_TVDETGP_INT_START_STOP_Y_GEN,
+		VENC_GEN_CTRL_VAL,
+		VENC_DAC_ENABLE
+	}
+};
+
+/*
+ * Initialization/Deinitialization function declaration
+ */
+static int tv_initialize(void *data);
+static int tv_deinitialize(void *data);
+
+/*
+ * Standard get/set function declaration
+ */
+static int omap_venc_setstd(char *mode_name, void *data);
+static char *omap_venc_getstd(void *data);
+
+/*
+ * Output set/get/enum function declaration
+ */
+static int omap_venc_setoutput(int index, char *mode_name, void *data);
+static char *omap_venc_enumoutput(int index, void *data);
+
+#endif
diff --git a/arch/arm/plat-omap/omap-dss.c b/arch/arm/plat-omap/omap-dss.c
new file mode 100644
index 0000000..9fb6866
--- /dev/null
+++ b/arch/arm/plat-omap/omap-dss.c
@@ -0,0 +1,2590 @@
+/*
+ * arch/arm/plat-omap2/omap-dss.c
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Leveraged code from the OMAP24xx camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ *
+ * History:
+ * 20-APR-2006  Khasim		Modified VRFB based Rotation equations,
+ *				The image data is always read from 0 degree
+ *				view and written to the virtual space of desired
+ *				rotation angle
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <asm/system.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <mach/hardware.h>
+#include <mach/omap-dss.h>
+#include <mach/clock.h>
+#ifdef CONFIG_TRACK_RESOURCES
+#include <linux/device.h>
+#endif
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt, a...)
+#endif
+
+/* TODO This is a power management macro.  Currently not defined */
+#define CONFIG_OMAP34XX_OFFMODE
+
+/* usage count for DSS power management */
+static int disp_usage;
+static spinlock_t dss_lock;
+short int current_colorconv_values[2][3][3];
+EXPORT_SYMBOL(current_colorconv_values);
+static struct omap_dss_regs dss_ctx;
+
+static struct clk *dss1f_scale;
+static struct clk *dss1f, *dss1i;
+static int m_clk_rate = 24000000 * 4;
+#if defined(CONFIG_OMAP_USE_DSI_PLL) || defined(CONFIG_OMAP_DSI)
+static struct clk *dss2f;
+#endif
+
+struct omap_disp_dma_params {
+	u32 ba0;
+	u32 ba1;
+	int row_inc;
+	int pix_inc;
+};
+
+static struct layer_t {
+	int output_dev;
+	int in_use;
+	int ctx_valid;
+
+	/* one set of dma parameters each for LCD and TV */
+	struct omap_disp_dma_params dma[2];
+
+	int size_x;
+	int size_y;
+} layer[DSS_CTX_NUMBER] = {
+	{
+	.ctx_valid = 0,}, {
+	.ctx_valid = 0,}, {
+	.ctx_valid = 0,}, {
+	.ctx_valid = 0,}, {
+.ctx_valid = 0,},};
+
+#define MAX_ISR_NR   8
+static int omap_disp_irq;
+static struct {
+	omap_disp_isr_t isr;
+	void *arg;
+	unsigned int mask;
+} registered_isr[MAX_ISR_NR];
+
+/* Required function delcalarations */
+static void omap_disp_restore_ctx(int ltype);
+static void disp_save_ctx(int ltype);
+
+/*
+ * Modes and Encoders supported by DSS
+ */
+struct channel_obj channels[] = {
+	{0, 0, {NULL, NULL, NULL}, 0, 0},
+#ifndef CONFIG_ARCH_OMAP3410
+	{0, 0, {NULL, NULL, NULL}, 0, 0}
+#endif
+};
+
+/* This mode structure lists all the modes supported by DSS
+ */
+struct omap_mode_info modes[] = {
+	{"ntsc_m", 720, 482, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"ntsc_j", 720, 482, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"ntsc_443", 720, 482, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"pal_bdghi", 720, 574, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"pal_nc", 720, 574, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"pal_n", 720, 574, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"pal_m", 720, 482, 0, 0, 0, 0, 0, 0, 0, 0, NULL},
+	{"pal_60", 720, 482, 0, 0, 0, 0, 0, 0, 0, 0, NULL}
+};
+
+#ifdef CONFIG_TRACK_RESOURCES
+/* device name needed for resource tracking layer */
+struct device_driver display_drv = {
+	.name = "display",
+};
+struct device display_dev = {
+	.driver = &display_drv,
+};
+#endif
+/*
+ * DSS register I/O routines
+ */
+static inline u32 dss_reg_in(u32 offset)
+{
+	return omap_readl(DSS_REG_BASE + DSS_REG_OFFSET + offset);
+}
+static inline u32 dss_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSS_REG_BASE + DSS_REG_OFFSET + offset);
+	return val;
+}
+static inline u32 dss_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr = DSS_REG_BASE + DSS_REG_OFFSET + offset;
+	u32 new_val = (omap_readl(addr) & ~mask) | (val & mask);
+
+	omap_writel(new_val, addr);
+	return new_val;
+}
+
+/*
+ * Display controller register I/O routines
+ */
+static inline u32 dispc_reg_in(u32 offset)
+{
+	return omap_readl(DSS_REG_BASE + DISPC_REG_OFFSET + offset);
+}
+static inline u32 dispc_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSS_REG_BASE + DISPC_REG_OFFSET + offset);
+	return val;
+}
+static inline u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr = DSS_REG_BASE + DISPC_REG_OFFSET + offset;
+	u32 new_val = (omap_readl(addr) & ~mask) | (val & mask);
+
+	omap_writel(new_val, addr);
+	return new_val;
+}
+
+/*
+ * RFBI controller register I/O routines
+ */
+static inline u32 rfbi_reg_in(u32 offset)
+{
+	return omap_readl(DSS_REG_BASE + RFBI_REG_OFFSET + offset);
+}
+static inline u32 rfbi_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSS_REG_BASE + RFBI_REG_OFFSET + offset);
+	return val;
+}
+
+/*
+ * DSI Proto Engine register I/O routines
+  */
+static inline u32 dsiproto_reg_in(u32 offset)
+{
+	u32 val;
+	val = omap_readl(DSI_PROTO_ENG_REG_BASE + offset);
+	return val;
+}
+static inline u32 dsiproto_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSI_PROTO_ENG_REG_BASE + offset);
+	return val;
+}
+
+/*
+ * DSI PLL register I/O routines
+ */
+static inline u32 dsipll_reg_in(u32 offset)
+{
+	u32 val;
+	val = omap_readl(DSI_PLL_CONTROLLER_REG_BASE + offset);
+	return val;
+}
+static inline u32 dsipll_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSI_PLL_CONTROLLER_REG_BASE + offset);
+	return val;
+}
+
+/*---------------------------------------------------------------------------*/
+/* Local Helper Functions */
+
+/* DSS Interrupt master service routine. */
+static irqreturn_t
+omap_disp_master_isr(int irq, void *arg, struct pt_regs *regs)
+{
+	unsigned long dispc_irqstatus = dispc_reg_in(DISPC_IRQSTATUS);
+	int i;
+
+	for (i = 0; i < MAX_ISR_NR; i++) {
+		if (registered_isr[i].isr == NULL)
+			continue;
+		if (registered_isr[i].mask & dispc_irqstatus)
+			registered_isr[i].isr(registered_isr[i].arg, regs,
+					      dispc_irqstatus);
+	}
+	/* ack the interrupt */
+	dispc_reg_out(DISPC_IRQSTATUS, dispc_irqstatus);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Sync Lost interrupt handler
+ */
+static void
+disp_synclost_isr(void *arg, struct pt_regs *regs, u32 irqstatus)
+{
+	u32 i;
+
+#ifndef CONFIG_ARCH_OMAP3410
+	struct omap_encoder_device *enc_dev;
+#endif
+	i = 0;
+	printk(KERN_WARNING "Sync Lost %x\n",
+	       dispc_reg_in(DISPC_IRQSTATUS));
+	arg = NULL;
+	regs = NULL;
+
+	/*
+	 * Disable and Clear all the interrupts before we start
+	 */
+	dispc_reg_out(DISPC_IRQENABLE, 0x00000000);
+	dispc_reg_out(DISPC_IRQSTATUS, 0x0000FFFF);
+
+	/* disable the display controller */
+	omap_disp_disable(HZ / 2);
+
+	/*
+	 * Update the state of the display controller.
+	 */
+	dss_ctx.dispc.sysconfig &= ~DISPC_SYSCONFIG_SOFTRESET;
+	dss_ctx.dispc.control &= ~(DISPC_CONTROL_GODIGITAL);
+
+	dispc_reg_out(DISPC_SYSCONFIG, DISPC_SYSCONFIG_SOFTRESET);
+	while (!(dispc_reg_in(DISPC_SYSSTATUS) & DISPC_SYSSTATUS_RESETDONE)) {
+		udelay(100);
+		if (i++ > 5) {
+			printk(KERN_WARNING
+			       "Failed to soft reset the DSS !! \n");
+			break;
+		}
+	}
+
+	/* Configure the encoders for the default standard */
+	for (i = 0; i < ARRAY_SIZE(channels); i++) {
+		enc_dev = channels[i].enc_devices[channels[i].
+			current_encoder];
+		if (enc_dev && enc_dev->mode_ops->setmode)
+			enc_dev->mode_ops->setmode(modes[channels[i].
+				current_mode].name, enc_dev);
+	}
+	/* Restore the registers */
+	omap_disp_restore_ctx(OMAP_DSS_DISPC_GENERIC);
+	omap_disp_restore_ctx(OMAP_GRAPHICS);
+	omap_disp_restore_ctx(OMAP_VIDEO1);
+	omap_disp_restore_ctx(OMAP_VIDEO2);
+
+	/* enable the display controller */
+	if (layer[OMAP_DSS_DISPC_GENERIC].ctx_valid)
+		dispc_reg_out(DISPC_CONTROL, dss_ctx.dispc.control);
+
+	omap_disp_reg_sync(OMAP_OUTPUT_TV);
+
+}
+
+/*
+ * Save the DSS state before doing a GO LCD/DIGITAL
+ */
+static void disp_save_ctx(int ltype)
+{
+	int v1 = 0, v2 = 1;
+	struct omap_dispc_regs *dispc = &dss_ctx.dispc;
+
+	switch (ltype) {
+	case OMAP_DSS_GENERIC:
+		dss_ctx.sysconfig = dss_reg_in(DSS_SYSCONFIG);
+		dss_ctx.control = dss_reg_in(DSS_CONTROL);
+#ifdef CONFIG_ARCH_OMAP3430
+		dss_ctx.sdi_control = dss_reg_in(DSS_SDI_CONTROL);
+		dss_ctx.pll_control = dss_reg_in(DSS_PLL_CONTROL);
+#endif
+		break;
+
+	case OMAP_DSS_DISPC_GENERIC:
+		dispc->revision = dispc_reg_in(DISPC_REVISION);
+		dispc->sysconfig = dispc_reg_in(DISPC_SYSCONFIG);
+		dispc->sysstatus = dispc_reg_in(DISPC_SYSSTATUS);
+		dispc->irqstatus = dispc_reg_in(DISPC_IRQSTATUS);
+		dispc->irqenable = dispc_reg_in(DISPC_IRQENABLE);
+		dispc->control = dispc_reg_in(DISPC_CONTROL);
+		dispc->config = dispc_reg_in(DISPC_CONFIG);
+		dispc->capable = dispc_reg_in(DISPC_CAPABLE);
+		dispc->default_color0 = dispc_reg_in(DISPC_DEFAULT_COLOR0);
+		dispc->default_color1 = dispc_reg_in(DISPC_DEFAULT_COLOR1);
+		dispc->trans_color0 = dispc_reg_in(DISPC_TRANS_COLOR0);
+		dispc->trans_color1 = dispc_reg_in(DISPC_TRANS_COLOR1);
+		dispc->line_status = dispc_reg_in(DISPC_LINE_STATUS);
+		dispc->line_number = dispc_reg_in(DISPC_LINE_NUMBER);
+		dispc->data_cycle1 = dispc_reg_in(DISPC_DATA_CYCLE1);
+		dispc->data_cycle2 = dispc_reg_in(DISPC_DATA_CYCLE2);
+		dispc->data_cycle3 = dispc_reg_in(DISPC_DATA_CYCLE3);
+		dispc->timing_h = dispc_reg_in(DISPC_TIMING_H);
+		dispc->timing_v = dispc_reg_in(DISPC_TIMING_V);
+		dispc->pol_freq = dispc_reg_in(DISPC_POL_FREQ);
+		dispc->divisor = dispc_reg_in(DISPC_DIVISOR);
+		dispc->global_alpha = dispc_reg_in(DISPC_GLOBAL_ALPHA);
+		dispc->size_lcd = dispc_reg_in(DISPC_SIZE_LCD);
+		dispc->size_dig = dispc_reg_in(DISPC_SIZE_DIG);
+
+	case OMAP_VIDEO1:
+		dispc->vid1_ba0 = dispc_reg_in(DISPC_VID_BA0(v1));
+		dispc->vid1_ba1 = dispc_reg_in(DISPC_VID_BA0(v1));
+		dispc->vid1_position =
+		    dispc_reg_in(DISPC_VID_POSITION(v1));
+		dispc->vid1_size = dispc_reg_in(DISPC_VID_SIZE(v1));
+		dispc->vid1_attributes =
+		    dispc_reg_in(DISPC_VID_ATTRIBUTES(v1));
+		dispc->vid1_fifo_size =
+		    dispc_reg_in(DISPC_VID_FIFO_SIZE(v1));
+		dispc->vid1_fifo_threshold =
+		    dispc_reg_in(DISPC_VID_FIFO_THRESHOLD(v1));
+		dispc->vid1_row_inc = dispc_reg_in(DISPC_VID_ROW_INC(v1));
+		dispc->vid1_pixel_inc =
+		    dispc_reg_in(DISPC_VID_PIXEL_INC(v1));
+		dispc->vid1_fir = dispc_reg_in(DISPC_VID_FIR(v1));
+		dispc->vid1_accu0 = dispc_reg_in(DISPC_VID_ACCU0(v1));
+		dispc->vid1_accu1 = dispc_reg_in(DISPC_VID_ACCU1(v1));
+		dispc->vid1_picture_size =
+		    dispc_reg_in(DISPC_VID_PICTURE_SIZE(v1));
+		dispc->vid1_fir_coef_h0 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 0));
+		dispc->vid1_fir_coef_h1 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 1));
+		dispc->vid1_fir_coef_h2 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 2));
+		dispc->vid1_fir_coef_h3 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 3));
+		dispc->vid1_fir_coef_h4 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 4));
+		dispc->vid1_fir_coef_h5 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 5));
+		dispc->vid1_fir_coef_h6 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 6));
+		dispc->vid1_fir_coef_h7 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v1, 7));
+		dispc->vid1_fir_coef_hv0 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 0));
+		dispc->vid1_fir_coef_hv1 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 1));
+		dispc->vid1_fir_coef_hv2 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 2));
+		dispc->vid1_fir_coef_hv3 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 3));
+		dispc->vid1_fir_coef_hv4 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 4));
+		dispc->vid1_fir_coef_hv5 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 5));
+		dispc->vid1_fir_coef_hv6 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 6));
+		dispc->vid1_fir_coef_hv7 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v1, 7));
+		dispc->vid1_conv_coef0 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF0(v1));
+		dispc->vid1_conv_coef1 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF1(v1));
+		dispc->vid1_conv_coef2 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF2(v1));
+		dispc->vid1_conv_coef3 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF3(v1));
+		dispc->vid1_conv_coef4 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF4(v1));
+		break;
+
+	case OMAP_VIDEO2:
+		dispc->vid2_ba0 = dispc_reg_in(DISPC_VID_BA0(v2));
+		dispc->vid2_ba1 = dispc_reg_in(DISPC_VID_BA1(v2));
+		dispc->vid2_position =
+		    dispc_reg_in(DISPC_VID_POSITION(v2));
+		dispc->vid2_size = dispc_reg_in(DISPC_VID_SIZE(v2));
+		dispc->vid2_attributes =
+		    dispc_reg_in(DISPC_VID_ATTRIBUTES(v2));
+		dispc->vid2_fifo_size =
+		    dispc_reg_in(DISPC_VID_FIFO_SIZE(v2));
+		dispc->vid2_fifo_threshold =
+		    dispc_reg_in(DISPC_VID_FIFO_THRESHOLD(v2));
+		dispc->vid2_row_inc = dispc_reg_in(DISPC_VID_ROW_INC(v2));
+		dispc->vid2_pixel_inc =
+		    dispc_reg_in(DISPC_VID_PIXEL_INC(v2));
+		dispc->vid2_fir = dispc_reg_in(DISPC_VID_FIR(v2));
+		dispc->vid2_accu0 = dispc_reg_in(DISPC_VID_ACCU0(v2));
+		dispc->vid2_accu1 = dispc_reg_in(DISPC_VID_ACCU1(v2));
+		dispc->vid2_picture_size =
+		    dispc_reg_in(DISPC_VID_PICTURE_SIZE(v2));
+		dispc->vid2_fir_coef_h0 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 0));
+		dispc->vid2_fir_coef_h1 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 1));
+		dispc->vid2_fir_coef_h2 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 2));
+		dispc->vid2_fir_coef_h3 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 3));
+		dispc->vid2_fir_coef_h4 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 4));
+		dispc->vid2_fir_coef_h5 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 5));
+		dispc->vid2_fir_coef_h6 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 6));
+		dispc->vid2_fir_coef_h7 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_H(v2, 7));
+		dispc->vid2_fir_coef_hv0 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 0));
+		dispc->vid2_fir_coef_hv1 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 1));
+		dispc->vid2_fir_coef_hv2 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 2));
+		dispc->vid2_fir_coef_hv3 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 3));
+		dispc->vid2_fir_coef_hv4 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 4));
+		dispc->vid2_fir_coef_hv5 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 5));
+		dispc->vid2_fir_coef_hv6 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 6));
+		dispc->vid2_fir_coef_hv7 =
+		    dispc_reg_in(DISPC_VID_FIR_COEF_HV(v2, 7));
+		dispc->vid2_conv_coef0 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF0(v2));
+		dispc->vid2_conv_coef1 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF1(v2));
+		dispc->vid2_conv_coef2 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF2(v2));
+		dispc->vid2_conv_coef3 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF3(v2));
+		dispc->vid2_conv_coef4 =
+		    dispc_reg_in(DISPC_VID_CONV_COEF4(v2));
+		break;
+	}
+	layer[ltype].ctx_valid = 1;
+}
+
+void config_disp_clocks(int sleep_state)
+{
+#ifdef CONFIG_TRACK_RESOURCES
+	struct device *dev = &display_dev;
+#else
+	struct device *dev = NULL;
+#endif
+	static int start = 1;
+	/*int (*clk_onoff)(struct clk *clk) = NULL; */
+	if (start) {
+#ifndef CONFIG_OMAP_USE_DSI_PLL
+		omap_disp_set_dssfclk();
+#endif
+		dss1i = clk_get(dev, "dss_ick");
+		dss1f =
+		    clk_get(dev,
+			    cpu_is_omap34xx()? "dss1_alwon_fck" :
+			    "dss1_fck");
+		if (IS_ERR(dss1i) || IS_ERR(dss1f)) {
+			printk(KERN_WARNING
+			       "Could not get DSS clocks  \n");
+			return;
+		}
+#if defined(CONFIG_OMAP_USE_DSI_PLL) || defined(CONFIG_OMAP_DSI)
+		dss2f = clk_get(dev, "dss2_fck");
+		if (IS_ERR(dss2f)) {
+			printk(KERN_WARNING "Could not get DSS2 FCLK\n");
+			return;
+		}
+#endif
+		start = 0;
+	}
+	if (sleep_state == 1) {
+		clk_disable(dss1i);
+		clk_disable(dss1f);
+	} else {
+		if (clk_enable(dss1i) != 0) {
+			printk(KERN_WARNING "Unable to enable DSS ICLK\n");
+			return;
+		}
+		if (clk_enable(dss1f) != 0) {
+			printk(KERN_WARNING "Unable to enable DSS FCLK\n");
+			return;
+		}
+#ifndef CONFIG_OMAP_USE_DSI_PLL
+#ifdef CONFIG_OMAP_DSI
+		if (clk_enable(dss2f) != 0) {
+			printk(KERN_WARNING "Unable to enable DSS FCLK\n");
+			return;
+		}
+#endif
+#endif
+	}
+}
+
+/* This function turns on/off the clocks needed for TV-out.
+ *  - 2430SDP: Controls the dss_54m_fck
+ *  - 3430SDP: Controls the dss_tv_fck
+ *  - 3430LAB: Controls both dss_tv_fck and dss_96m_fck.
+ *             By default Labrador turns off the 96MHz DAC clock for
+ *             power saving reasons.
+ */
+#ifndef CONFIG_ARCH_OMAP3410
+static void disp_ll_config_tv_clocks(int sleep_state)
+{
+	static int start = 1;
+	static struct clk *tv_clk;
+#ifdef CONFIG_MACH_OMAP_3430LABRADOR
+	static struct clk *dac_clk;
+#endif
+	static int disabled;
+	static int enabled;
+
+	if (start) {
+#ifdef CONFIG_MACH_OMAP_2430SDP
+		tv_clk = clk_get(NULL, "dss_54m_fck");
+#endif
+#if defined(CONFIG_MACH_OMAP_3430SDP) ||  defined(CONFIG_MACH_OMAP3EVM) \
+	|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
+		tv_clk = clk_get(NULL, "dss_tv_fck");
+#endif
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+		dac_clk = clk_get(NULL, "dss_96m_fck");
+		if (IS_ERR(dac_clk)) {
+			printk(KERN_WARNING
+			       "\n UNABLE to get dss 96MHz fclk \n");
+			return;
+		}
+#endif
+		if (IS_ERR(tv_clk)) {
+			printk(KERN_WARNING
+			       "\n UNABLE to get dss TV fclk \n");
+			return;
+		}
+		start = 0;
+	}
+
+	if (sleep_state == 1) {
+		if (disabled == 0) {
+			clk_disable(tv_clk);
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+			clk_disable(dac_clk);
+#endif
+			disabled = 1;
+		}
+		enabled = 0;
+	} else {
+		if (enabled == 0) {
+			if (clk_enable(tv_clk) != 0) {
+				printk(KERN_WARNING
+				       "\n UNABLE to enable dss TV fclk \n");
+				return;
+			}
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+			if (clk_enable(dac_clk) != 0) {
+				printk(KERN_WARNING
+				       "\n UNABLE to enable dss 96MHz fclk \n");
+				return;
+			}
+#endif
+			enabled = 1;
+		}
+		disabled = 0;
+	}
+}
+#endif
+
+/* Function used to find the VRFB Alignement */
+static inline u32 pages_per_side(u32 img_side, u32 page_exp)
+{
+	/*  page_side = 2 ^ page_exp
+	 * (page_side - 1) is added for rounding up
+	 */
+	return (u32) (img_side + (1 << page_exp) - 1) >> page_exp;
+}
+
+/* Update the color conversion matrix */
+static void update_colorconv_mtx(int v, const short int mtx[3][3])
+{
+	int i, j;
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			current_colorconv_values[v][i][j] = mtx[i][j];
+}
+
+/* Write the horizontal and vertical resizing coefficients to the display
+ * controller registers.  Each coefficient is a signed 8-bit integer in the
+ * range [-128, 127] except for the middle coefficient (vc[1][i] and hc[3][i])
+ * which is an unsigned 8-bit integer in the range [0, 255].  The first index of
+ * the matrix is the coefficient number (0 to 2 vertical or 0 to 4 horizontal)
+ * and the second index is the phase (0 to 7).
+ */
+void disp_set_resize(int v, short int *vc, short int *hc, int v_scale_dir)
+{
+	int i;
+	unsigned long reg;
+
+	for (i = 0; i < 8; i++) {
+		reg =
+		    (*(hc + (8 * 0) + i) & 0xff) |
+		    ((*(hc + (8 * 1) + i) & 0xff)
+		     << 8)
+		    | ((*(hc + (8 * 2) + i) & 0xff) << 16) |
+		    ((*(hc + (8 * 3) + i) & 0xff) << 24);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v, i), reg);
+
+		if (!v_scale_dir) {
+			reg =
+			    (*(hc + (8 * 4) + i) & 0xff) |
+			    ((*(vc + (1 * 8) + i) & 0xff) << 8)
+			    | ((*(vc + (8 * 2) + i) & 0xff) << 16)
+			    | ((*(vc + (3 * 8) + i) & 0xff) << 24);
+			dispc_reg_out(DISPC_VID_FIR_COEF_HV(v, i), reg);
+
+			reg = (*(vc + (8 * 0) + i) & 0xff)
+			    | ((*(vc + (4 * 8) + i) & 0xff) << 8);
+			dispc_reg_out(DISPC_VID_FIR_COEF_V(v, i), reg);
+		} else {
+			reg = (*(hc + (8 * 4) + i) & 0xff)
+			    | ((*(vc + (0 * 8) + i) & 0xff) << 8)
+			    | ((*(vc + (8 * 1) + i) & 0xff) << 16)
+			    | ((*(vc + (2 * 8) + i) & 0xff) << 24);
+			dispc_reg_out(DISPC_VID_FIR_COEF_HV(v, i), reg);
+		}
+	}
+}
+
+#ifdef CONFIG_OMAP_USE_DSI_PLL
+/* DSI Helper Functions */
+int disp_lock_dsi_pll(u32 M, u32 N, u32 M3, u32 M4, u32 freqsel)
+{
+
+	u32 count = 1000, val;
+	val = ((M4 << 23) | (M3 << 19) | (M << 8) | (N << 1) | (1));
+	dsipll_reg_out(DSI_PLL_CONFIGURATION1, val);
+	val =
+	    ((0 << 20) | (0 << 19) | (1 << 18) | (0 << 17) | (1 << 16) |
+	     (0 << 14) | (1 << 13) | (0 << 12) | (0 << 11) | (0 << 8) |
+	     (freqsel << 1));
+
+	dsipll_reg_out(DSI_PLL_CONFIGURATION2, val);
+
+	dsipll_reg_out(DSI_PLL_GO, 1);
+
+	while ((dsipll_reg_in(DSI_PLL_GO) != 0) && (--count))
+		udelay(100);
+
+	if (count == 0) {
+		printk(KERN_WARNING "GO bit not cleared\n");
+		return 0;
+	}
+
+	count = 1000;
+	while (((dsipll_reg_in(DSI_PLL_STATUS) & 0x2) != 0x2) && (--count))
+		udelay(100);
+
+	if (count == 0) {
+		printk(KERN_WARNING "DSI PLL lock request failed = %X\n",
+		       dsipll_reg_in(DSI_PLL_STATUS));
+		return 0;
+	}
+
+	return 1;
+}
+
+void disp_switch_to_dsipll_clk_source(void)
+{
+	u32 val;
+	/*Switch DISPC FCLK to DSI PLL HS divider */
+	val = dss_reg_in(DSS_CONTROL);
+	val = val | (1 << 1) | (1 << 0);
+	dss_reg_out(DSS_CONTROL, val);
+}
+
+int disp_power_dsi_pll(u32 cmd)
+{
+	u32 val, count = 10000;
+	/* send the power command */
+	val = dsiproto_reg_in(DSI_CLK_CTRL);
+	val = ((val & ~(3 << 30)) | (cmd << 30));
+	dsiproto_reg_out(DSI_CLK_CTRL, val);
+
+	/* Check whether the power status is changed */
+	do {
+		val = dsiproto_reg_in(DSI_CLK_CTRL);
+		val = ((val & 0x30000000) >> 28);
+		udelay(100);
+	} while ((val != cmd) && (--count));
+
+	return count;
+}
+
+void disp_enable_dss2fck(void)
+{
+	if (clk_enable(dss2f) != 0) {
+		printk(KERN_WARNING "Unable to enable DSS2 FCLK\n");
+		return;
+	}
+}
+
+void disp_disable_dss2fck(void)
+{
+	clk_disable(dss2f);
+}
+#endif
+
+/* Configure the panel size in the DSS according
+ * to the mode selected in decoder
+ */
+int disp_set_dss_mode(int ch_no, int mode_index)
+{
+	struct omap_dispc_regs *dispc = &dss_ctx.dispc;
+	struct omap_mode_info *mode = NULL;
+	u32 size;
+
+	dispc->control = dispc_reg_in(DISPC_CONTROL);
+
+	mode = &modes[mode_index];
+
+	if (ch_no == 1) {
+		size = ((mode->width - 1) << DISPC_SIZE_DIG_PPL_SHIFT) &
+		    DISPC_SIZE_DIG_PPL;
+		size |=
+		    (((mode->height >> 1) - 1) << DISPC_SIZE_DIG_LPP_SHIFT)
+		    & DISPC_SIZE_DIG_LPP;
+
+		dispc->size_dig = size;
+		dispc_reg_out(DISPC_SIZE_DIG, dispc->size_dig);
+	}
+
+	/* enable the display controller */
+	if (layer[OMAP_DSS_DISPC_GENERIC].ctx_valid)
+		dispc_reg_out(DISPC_CONTROL, dss_ctx.dispc.control);
+
+	omap_disp_reg_sync(OMAP_OUTPUT_TV);
+
+	dispc->size_dig = dispc_reg_in(DISPC_SIZE_DIG);
+
+	return 0;
+}
+
+/* Set the DSS register according to the output selected
+ */
+int disp_set_dss_output(int ch_no, char *buffer)
+{
+	/* Only supported output is S-Video */
+	if (ch_no == 1) {
+		/* Composite and S-Video Related Changes needs to be
+		   done here */
+	}
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+/* Exported Functions */
+
+/* Register the encoder with the DSS */
+int omap_register_encoder(struct omap_encoder_device
+			   *encoder)
+{
+	struct channel_obj *channel = &channels[encoder->channel_id];
+	int err = -EINVAL;
+	struct omap_encoder_device *enc_dev;
+
+	if (channel == NULL)
+		err = -EINVAL;
+	if (channel->num_encoders < MAX_ENCODER_DEVICE) {
+		channel->enc_devices[channel->num_encoders++] = encoder;
+		err = 0;
+	}
+	enc_dev = channel->enc_devices[channel->current_encoder];
+	if (channel->current_encoder == ((channel->num_encoders) - 1))
+		err = enc_dev->initialize(enc_dev);
+	return err;
+}
+EXPORT_SYMBOL(omap_register_encoder);
+/* omap_unregister_decoder : This function will be called by the decoder
+ * driver to un-register its functionalities.
+ */
+int omap_unregister_encoder(struct omap_encoder_device
+			     *encoder)
+{
+	int i, j = 0, err = 0;
+	struct channel_obj *channel = &channels[encoder->channel_id];
+
+	for (i = 0; i < channel->num_encoders; i++) {
+		if (encoder == channel->enc_devices[i]) {
+			if (channel->
+			    enc_devices[channel->current_encoder] ==
+			    encoder)
+				return -EBUSY;
+			channel->enc_devices[i] = NULL;
+			for (j = i; j < channel->num_encoders - 1; j++)
+				channel->enc_devices[j] =
+				    channel->enc_devices[j + 1];
+			channel->num_encoders--;
+			break;
+		}
+	}
+	return err;
+}
+EXPORT_SYMBOL(omap_unregister_encoder);
+
+/* Exported function to select the Mode in
+ * the current selected encoder
+ */
+int omap_disp_set_mode(int ch_no, char *buffer)
+{
+	struct omap_encoder_device *enc_dev = NULL;
+	struct omap_mode_info *mode;
+	int i;
+
+	if (ch_no >= MAX_CHANNEL || ch_no < 0)
+		return -EINVAL;
+
+	if (channels[ch_no].num_encoders <= 0)
+		return -EINVAL;
+	/* Check whether the mode is supported by DSS or not */
+	for (i = 0; i < ARRAY_SIZE(modes); i++) {
+		mode = &modes[i];
+		if (!(strcmp(mode->name, buffer)))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(modes))
+		return -EINVAL;
+	/* Get the handle of the current encoder device */
+	enc_dev =
+	    channels[ch_no].enc_devices[channels[ch_no].current_encoder];
+	/* Set the mode in current encoder device  */
+	if (enc_dev->mode_ops->setmode)
+		if (enc_dev->mode_ops->setmode(buffer, enc_dev))
+			return -EINVAL;
+	/* Set the mode in DSS */
+	disp_set_dss_mode(ch_no, i);
+	channels[ch_no].current_mode = i;
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_disp_set_mode);
+
+/* Exported function to Get the current selected mode */
+char *omap_disp_get_mode(int ch_no)
+{
+	struct omap_encoder_device *enc_dev;
+
+	if (channels[ch_no].num_encoders <= 0)
+		return NULL;
+	/* Get the handle of the current encoder device */
+	enc_dev =
+	    channels[ch_no].enc_devices[channels[ch_no].current_encoder];
+	/* Set the mode in current encoder device  */
+	if (enc_dev->mode_ops->getmode)
+		return enc_dev->mode_ops->getmode(enc_dev);
+	else
+		return NULL;
+}
+EXPORT_SYMBOL(omap_disp_get_mode);
+
+/* Exported Function to enumerate all the outputs supported by DSS */
+int omap_disp_enum_output(int ch_no, int index, char *name)
+{
+	struct omap_encoder_device *enc_dev = NULL;
+	int index_count = 0;
+	int i, j;
+	char *str;
+
+	if (channels[ch_no].num_encoders <= 0)
+		return -EINVAL;
+	/* Reach the encoder from the list of encoders */
+	for (i = 0; i < channels[ch_no].num_encoders; i++) {
+		enc_dev = channels[ch_no].enc_devices[i];
+		index_count += enc_dev->no_outputs;
+		if (index_count > index)
+			break;
+	}
+	if (i == channels[ch_no].num_encoders)
+		return -EINVAL;
+
+	/* Get the output index number of the encoder; */
+	for (j = 0; j < i; j++) {
+		enc_dev = channels[ch_no].enc_devices[j];
+		index = index - enc_dev->no_outputs;
+	}
+
+	if (enc_dev->output_ops->enumoutput) {
+		str = enc_dev->output_ops->enumoutput(index, enc_dev);
+		strcpy(name, str);
+		return 0;
+	} else
+		return -EINVAL;
+}
+EXPORT_SYMBOL(omap_disp_enum_output);
+
+/* Exported function to set the particular output of the DSS
+ * It will iterate through all the encoders for setting the
+ * output
+ */
+int omap_disp_set_output(int ch_no, int index)
+{
+	struct omap_encoder_device *enc_dev = NULL, *prev_enc_dev = NULL;
+	int i, j, index_count = 0;
+	char mode_name[25], *str;
+
+	if (ch_no >= MAX_CHANNEL || ch_no < 0)
+		return -EINVAL;
+
+	/* Find the encoder for the requested output */
+	for (i = 0; i < channels[ch_no].num_encoders; i++) {
+		enc_dev = channels[ch_no].enc_devices[i];
+		index_count += enc_dev->no_outputs;
+		if (index_count > index)
+			break;
+	}
+
+	if (i == channels[ch_no].num_encoders)
+		return -EINVAL;
+	/* Find the index number of the encoder output */
+	for (j = 0; j < i; j++) {
+		enc_dev = channels[ch_no].enc_devices[j];
+		index = index - enc_dev->no_outputs;
+	}
+
+	/* Get the previous encoder device and de-initialize it */
+	prev_enc_dev =
+	    channels[ch_no].enc_devices[channels[ch_no].current_encoder];
+
+	if (prev_enc_dev->deinitialize)
+		prev_enc_dev->deinitialize(enc_dev);
+
+	/* Set the new encoder as the current encoder */
+	channels[ch_no].current_encoder = i;
+
+	str = enc_dev->output_ops->enumoutput(index, enc_dev);
+	disp_set_dss_output(ch_no, str);
+
+	/* Initialize the new encoder */
+	if (enc_dev->initialize)
+		enc_dev->initialize(enc_dev);
+	/* Set the output of the new encoder */
+	if (enc_dev->output_ops->setoutput)
+		if ((enc_dev->output_ops->setoutput(index, mode_name, enc_dev) <
+		     0))
+			return -EINVAL;
+
+	/* Set the DSS panel size according to the mode set in the
+	 * encoder for the selected output
+	 */
+	for (i = 0; i < ARRAY_SIZE(modes); i++) {
+		if (!(strcmp(modes[i].name, mode_name))) {
+			disp_set_dss_mode(ch_no, i);
+			channels[ch_no].current_mode = i;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_disp_set_output);
+
+/* Exported Function to get the output of DSS */
+int omap_disp_get_output(int ch_no, int *index)
+{
+	struct omap_encoder_device *enc_dev;
+	int i;
+	int enc_index = 0;
+
+	if (channels[ch_no].num_encoders <= 0)
+		return -EINVAL;
+	enc_dev =
+	    channels[ch_no].enc_devices[channels[ch_no].current_encoder];
+
+	for (i = 0; i < channels[ch_no].current_encoder; i++) {
+		 enc_index +=
+			channels[ch_no].enc_devices[i]->no_outputs;
+	}
+	enc_index += enc_dev->current_output;
+	*index = enc_index;
+
+	if (enc_dev->output_ops->getoutput)
+		return enc_dev->output_ops->getoutput(enc_dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_disp_get_output);
+/*---------------------------------------------------------------------------*/
+/* Exported Functions */
+/*
+ * Functions for setting video attributes
+ */
+void omap_disp_set_vidattributes(unsigned int video_layer,
+				  unsigned int vid_attributes)
+{
+	dispc_reg_out(DISPC_VID_ATTRIBUTES(video_layer), vid_attributes);
+}
+EXPORT_SYMBOL(omap_disp_set_vidattributes);
+
+/* Function for setting the DMS threshold */
+void omap_disp_set_fifothreshold(unsigned int video_layer)
+{
+	/* Set FIFO threshold to 0xFF (high) and 0xFF -
+	 *(16x4bytes) = 0xC0 (low)
+	 * dispc_reg_out(DISPC_VID_FIFO_THRESHOLD(v),0x00FF00C0);
+	 */
+	dispc_reg_out(DISPC_VID_FIFO_THRESHOLD(video_layer), 0x03FC03BC);
+}
+EXPORT_SYMBOL(omap_disp_set_fifothreshold);
+
+/* Set the scaling parameters */
+void omap_disp_set_scaling(struct omap_scaling_params *scale_params)
+{
+	unsigned long firvinc, firhinc;
+	int v_scale_dir = 0;
+
+	/* horizontal and vertical upscale resizing matrix */
+	const static short int hvc_u[5][8] =
+	    { {0, 0, -1, -2, -9, -5, -2, -1},
+	{0, -8, -11, -11, 73, 51, 30, 13},
+	{128, 124, 112, 95, 73, 95, 112, 124},
+	{0, 13, 30, 51, -9, -11, -11, -8},
+	{0, -1, -2, -5, 0, -2, -1, 0}
+	};
+	/* Vertical downscale resizing matrix */
+	const static short int vc_d[3][8] =
+	    { {36, 40, 45, 50, 18, 23, 27, 31},
+	{56, 57, 56, 55, 55, 55, 56, 57},
+	{36, 31, 27, 23, 55, 50, 45, 40}
+	};
+	/* horizontal down scale resizing matrix */
+	const static short int hc_d[5][8] =
+	    { {0, 4, 8, -12, -9, -7, -5, -2},
+	{36, 40, 44, 48, 17, 22, 27, 31},
+	{56, 55, 54, 53, 52, 53, 54, 55},
+	{36, 31, 27, 22, 51, 48, 44, 40},
+	{0, -2, -5, -7, 17, 12, 8, 4}
+	};
+
+	short int *vc = (short int *) hvc_u;
+	short int *hc = (short int *) hvc_u;
+
+	if (scale_params->win_width < scale_params->crop_width)
+		hc = (short int *) hc_d;
+	if (scale_params->win_height < scale_params->crop_height
+	    || scale_params->flicker_filter == 1) {
+		vc = (short int *) vc_d;
+		v_scale_dir = 1;
+	}
+	disp_set_resize(scale_params->video_layer, vc, hc, v_scale_dir);
+
+	dispc_reg_out(DISPC_VID_ACCU0(scale_params->video_layer), 0);
+	if (scale_params->flicker_filter == 1)
+		dispc_reg_out(DISPC_VID_ACCU1(scale_params->video_layer),
+			      0x01000000);
+	else
+		dispc_reg_out(DISPC_VID_ACCU1(scale_params->video_layer),
+			      0);
+	firhinc = (1024 * (scale_params->crop_width - 1))
+	    / (scale_params->win_width - 1);
+	if (firhinc < 1)
+		firhinc = 1;
+	else if (firhinc > 2047)
+		firhinc = 2047;
+	firvinc = (1024 * (scale_params->crop_height - 1))
+	    / (scale_params->win_height - 1);
+	if (firvinc < 1)
+		firvinc = 1;
+	else if (firvinc > 2047)
+		firvinc = 2047;
+
+	if (scale_params->flicker_filter == 0)
+		dispc_reg_out(DISPC_VID_FIR(scale_params->video_layer),
+			      firhinc | (firvinc << 16));
+	else
+		dispc_reg_out(DISPC_VID_FIR(scale_params->video_layer),
+			      0x08000000);
+}
+EXPORT_SYMBOL(omap_disp_set_scaling);
+
+/* Set the video parameters */
+void omap_disp_set_vid_params(struct omap_video_params *vid_params)
+{
+	dispc_reg_out(DISPC_VID_SIZE(vid_params->video_layer),
+		      vid_params->vid_size);
+	dispc_reg_out(DISPC_VID_PICTURE_SIZE(vid_params->video_layer),
+		      vid_params->vid_picture_size);
+	dispc_reg_out(DISPC_VID_POSITION(vid_params->video_layer),
+		      vid_params->vid_position);
+}
+EXPORT_SYMBOL(omap_disp_set_vid_params);
+
+/* Set the row increment and pixel increment values */
+void omap_disp_set_row_pix_inc_values(int video_layer, int row_inc_value,
+				       int pixel_inc_value)
+{
+	dispc_reg_out(DISPC_VID_ROW_INC(video_layer), row_inc_value);
+	dispc_reg_out(DISPC_VID_PIXEL_INC(video_layer), pixel_inc_value);
+}
+EXPORT_SYMBOL(omap_disp_set_row_pix_inc_values);
+
+/* Set the cropping parameters in the software structure */
+void omap_set_crop_layer_parameters(int video_layer, int cropwidth,
+				     int cropheight)
+{
+	layer[video_layer].size_x = cropwidth;
+	layer[video_layer].size_y = cropheight;
+}
+EXPORT_SYMBOL(omap_set_crop_layer_parameters);
+
+/* Write the color space conversion coefficients to the display controller
+ * registers.  Each coefficient is a signed 11-bit integer in the range
+ * [-1024, 1023].  The matrix coefficients are:
+ *	[ RY  RCr  RCb ]
+ *	[ GY  GCr  GCb ]
+ *	[ BY  BCr  BCb ]
+ */
+
+void omap_disp_set_colorconv(int v, int full_range_conversion)
+{
+	unsigned long ccreg;
+	short int mtx[3][3];
+	int i, j;
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			mtx[i][j] = current_colorconv_values[v][i][j];
+	ccreg = (mtx[0][0] & 0x7ff) | ((mtx[0][1] & 0x7ff) << 16);
+	dispc_reg_out(DISPC_VID_CONV_COEF0(v), ccreg);
+	ccreg = (mtx[0][2] & 0x7ff) | ((mtx[1][0] & 0x7ff) << 16);
+	dispc_reg_out(DISPC_VID_CONV_COEF1(v), ccreg);
+	ccreg = (mtx[1][1] & 0x7ff) | ((mtx[1][2] & 0x7ff) << 16);
+	dispc_reg_out(DISPC_VID_CONV_COEF2(v), ccreg);
+	ccreg = (mtx[2][0] & 0x7ff) | ((mtx[2][1] & 0x7ff) << 16);
+	dispc_reg_out(DISPC_VID_CONV_COEF3(v), ccreg);
+	ccreg = mtx[2][2] & 0x7ff;
+	dispc_reg_out(DISPC_VID_CONV_COEF4(v), ccreg);
+
+	if (full_range_conversion) {
+		dispc_reg_merge(DISPC_VID_ATTRIBUTES(v),
+				DISPC_VID_ATTRIBUTES_VIDFULLRANGE,
+				DISPC_VID_ATTRIBUTES_VIDFULLRANGE);
+	}
+
+}
+EXPORT_SYMBOL(omap_disp_set_colorconv);
+
+void omap_disp_set_default_colorconv(int ltype, int color_space)
+{
+	int v;
+
+	if (ltype == OMAP_VIDEO1)
+		v = 0;
+	else if (ltype == OMAP_VIDEO2)
+		v = 1;
+	else
+		return;
+
+	switch (color_space) {
+	case CC_BT601:
+		/* luma (Y) range lower limit is 16, BT.601 standard */
+		update_colorconv_mtx(v, cc_bt601);
+		omap_disp_set_colorconv(v, !FULL_COLOR_RANGE);
+		break;
+	case CC_BT709:
+		/* luma (Y) range lower limit is 16, BT.709 standard */
+		update_colorconv_mtx(v, cc_bt709);
+		omap_disp_set_colorconv(v, !FULL_COLOR_RANGE);
+		break;
+	case CC_BT601_FULL:
+		/* full luma (Y) range, assume BT.601 standard */
+		update_colorconv_mtx(v, cc_bt601_full);
+		omap_disp_set_colorconv(v, FULL_COLOR_RANGE);
+		break;
+	}
+}
+EXPORT_SYMBOL(omap_disp_set_default_colorconv);
+
+void omap_disp_get_panel_size(int output_dev, int *width, int *height)
+{
+	unsigned long size;
+
+	if (output_dev == OMAP_OUTPUT_TV) {
+		size = dispc_reg_in(DISPC_SIZE_DIG);
+		*width = 1 + ((size & DISPC_SIZE_DIG_PPL)
+			      >> DISPC_SIZE_DIG_PPL_SHIFT);
+		*height = 1 + ((size & DISPC_SIZE_DIG_LPP)
+			       >> DISPC_SIZE_DIG_LPP_SHIFT);
+		*height = *height << 1;
+	}
+}
+EXPORT_SYMBOL(omap_disp_get_panel_size);
+
+void omap_disp_set_panel_size(int output_dev, int width, int height)
+{
+	unsigned long size;
+
+	if (output_dev == OMAP_OUTPUT_TV) {
+		height = height >> 1;
+		size = ((width - 1) << DISPC_SIZE_DIG_PPL_SHIFT)
+		    & DISPC_SIZE_DIG_PPL;
+		size |= ((height - 1) << DISPC_SIZE_DIG_LPP_SHIFT)
+		    & DISPC_SIZE_DIG_LPP;
+		dispc_reg_out(DISPC_SIZE_DIG, size);
+	}
+}
+EXPORT_SYMBOL(omap_disp_set_panel_size);
+
+/* Turn off the video1, or video2 layer. */
+void omap_disp_disable_layer(int ltype)
+{
+	unsigned long attributes;
+	int digital, v;
+
+	if (ltype == OMAP_VIDEO1)
+		v = 0;
+	else if (ltype == OMAP_VIDEO2)
+		v = 1;
+	else
+		return;
+
+	attributes = dispc_reg_merge(DISPC_VID_ATTRIBUTES(v), 0,
+				     DISPC_VID_ATTRIBUTES_ENABLE);
+	digital = attributes & DISPC_VID_ATTRIBUTES_VIDCHANNELOUT;
+
+	if (digital) {
+		/* digital output */
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_GODIGITAL,
+				DISPC_CONTROL_GODIGITAL);
+	}
+	dispc_reg_merge(DISPC_CONTROL, 0,
+			DISPC_CONTROL_OVERLAYOPTIMIZATION);
+}
+EXPORT_SYMBOL(omap_disp_disable_layer);
+
+/* Turn on the GFX, or video1, or video2 layer. */
+void omap_disp_enable_layer(int ltype)
+{
+	unsigned long attributes;
+	int digital, v;
+
+	if (ltype == OMAP_VIDEO1)
+		v = 0;
+	else if (ltype == OMAP_VIDEO2)
+		v = 1;
+	else
+		return;
+
+	attributes = dispc_reg_merge(DISPC_VID_ATTRIBUTES(v),
+				     DISPC_VID_ATTRIBUTES_ENABLE,
+				     DISPC_VID_ATTRIBUTES_ENABLE);
+	digital = attributes & DISPC_VID_ATTRIBUTES_VIDCHANNELOUT;
+
+	if (digital) {
+		/* digital output */
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_GODIGITAL,
+				DISPC_CONTROL_GODIGITAL);
+	}
+}
+EXPORT_SYMBOL(omap_disp_enable_layer);
+
+void omap_disp_save_initstate(int ltype)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dss_lock, flags);
+	disp_save_ctx(ltype);
+	spin_unlock_irqrestore(&dss_lock, flags);
+}
+EXPORT_SYMBOL(omap_disp_save_initstate);
+
+/*
+ *  NOte, that VENC registers are not restored here
+ *  Note, that DISPC_CONTROL register is not restored here
+ */
+static void omap_disp_restore_ctx(int ltype)
+{
+	int v1 = 0, v2 = 1;
+	struct omap_dispc_regs *dispc = &dss_ctx.dispc;
+
+	if (layer[ltype].ctx_valid == 0)
+		return;
+
+	switch (ltype) {
+	case OMAP_DSS_GENERIC:
+		dss_reg_out(DSS_SYSCONFIG, dss_ctx.sysconfig);
+		dss_reg_out(DSS_CONTROL, dss_ctx.control);
+#ifdef CONFIG_ARCH_OMAP3430
+		dss_reg_out(DSS_SDI_CONTROL, dss_ctx.sdi_control);
+		dss_reg_out(DSS_PLL_CONTROL, dss_ctx.pll_control);
+#endif
+		break;
+
+	case OMAP_DSS_DISPC_GENERIC:
+		dispc_reg_out(DISPC_SYSCONFIG, dispc->sysconfig);
+		dispc_reg_out(DISPC_IRQENABLE, dispc->irqenable);
+		dispc_reg_out(DISPC_CONFIG, dispc->config);
+		dispc_reg_out(DISPC_DEFAULT_COLOR0, dispc->default_color0);
+		dispc_reg_out(DISPC_DEFAULT_COLOR1, dispc->default_color1);
+		dispc_reg_out(DISPC_TRANS_COLOR0, dispc->trans_color0);
+		dispc_reg_out(DISPC_TRANS_COLOR1, dispc->trans_color1);
+		dispc_reg_out(DISPC_LINE_NUMBER, dispc->line_number);
+		dispc_reg_out(DISPC_DATA_CYCLE1, dispc->data_cycle1);
+		dispc_reg_out(DISPC_DATA_CYCLE2, dispc->data_cycle2);
+		dispc_reg_out(DISPC_DATA_CYCLE3, dispc->data_cycle3);
+		dispc_reg_out(DISPC_TIMING_H, dispc->timing_h);
+		dispc_reg_out(DISPC_TIMING_V, dispc->timing_v);
+		dispc_reg_out(DISPC_POL_FREQ, dispc->pol_freq);
+		dispc_reg_out(DISPC_DIVISOR, dispc->divisor);
+		dispc_reg_out(DISPC_GLOBAL_ALPHA, dispc->global_alpha);
+		dispc_reg_out(DISPC_SIZE_LCD, dispc->size_lcd);
+		dispc_reg_out(DISPC_SIZE_DIG, dispc->size_dig);
+		break;
+
+	case OMAP_GRAPHICS:
+		dispc_reg_out(DISPC_GFX_BA0, dispc->gfx_ba0);
+		dispc_reg_out(DISPC_GFX_BA1, dispc->gfx_ba1);
+		dispc_reg_out(DISPC_GFX_POSITION, dispc->gfx_position);
+		dispc_reg_out(DISPC_GFX_SIZE, dispc->gfx_size);
+		dispc_reg_out(DISPC_GFX_ATTRIBUTES, dispc->gfx_attributes);
+		dispc_reg_out(DISPC_GFX_FIFO_SIZE, dispc->gfx_fifo_size);
+		dispc_reg_out(DISPC_GFX_FIFO_THRESHOLD,
+			      dispc->gfx_fifo_threshold);
+		dispc_reg_out(DISPC_GFX_ROW_INC, dispc->gfx_row_inc);
+		dispc_reg_out(DISPC_GFX_PIXEL_INC, dispc->gfx_pixel_inc);
+		dispc_reg_out(DISPC_GFX_WINDOW_SKIP,
+			      dispc->gfx_window_skip);
+		dispc_reg_out(DISPC_GFX_TABLE_BA, dispc->gfx_table_ba);
+		break;
+
+	case OMAP_VIDEO1:
+		dispc_reg_out(DISPC_VID_BA0(v1), dispc->vid1_ba0);
+		dispc_reg_out(DISPC_VID_BA1(v1), dispc->vid1_ba1);
+		dispc_reg_out(DISPC_VID_POSITION(v1),
+			      dispc->vid1_position);
+		dispc_reg_out(DISPC_VID_SIZE(v1), dispc->vid1_size);
+		dispc_reg_out(DISPC_VID_ATTRIBUTES(v1),
+			      dispc->vid1_attributes);
+		dispc_reg_out(DISPC_VID_FIFO_THRESHOLD(v1),
+			      dispc->vid1_fifo_threshold);
+		dispc_reg_out(DISPC_VID_ROW_INC(v1), dispc->vid1_row_inc);
+		dispc_reg_out(DISPC_VID_PIXEL_INC(v1),
+			      dispc->vid1_pixel_inc);
+		dispc_reg_out(DISPC_VID_FIR(v1), dispc->vid1_fir);
+		dispc_reg_out(DISPC_VID_ACCU0(v1), dispc->vid1_accu0);
+		dispc_reg_out(DISPC_VID_ACCU1(v1), dispc->vid1_accu1);
+		dispc_reg_out(DISPC_VID_PICTURE_SIZE(v1),
+			      dispc->vid1_picture_size);
+
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 0),
+			      dispc->vid1_fir_coef_h0);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 1),
+			      dispc->vid1_fir_coef_h1);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 2),
+			      dispc->vid1_fir_coef_h2);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 3),
+			      dispc->vid1_fir_coef_h3);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 4),
+			      dispc->vid1_fir_coef_h4);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 5),
+			      dispc->vid1_fir_coef_h5);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 6),
+			      dispc->vid1_fir_coef_h6);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v1, 7),
+			      dispc->vid1_fir_coef_h7);
+
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 0),
+			      dispc->vid1_fir_coef_hv0);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 1),
+			      dispc->vid1_fir_coef_hv1);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 2),
+			      dispc->vid1_fir_coef_hv2);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 3),
+			      dispc->vid1_fir_coef_hv3);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 4),
+			      dispc->vid1_fir_coef_hv4);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 5),
+			      dispc->vid1_fir_coef_hv5);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 6),
+			      dispc->vid1_fir_coef_hv6);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v1, 7),
+			      dispc->vid1_fir_coef_hv7);
+
+		dispc_reg_out(DISPC_VID_CONV_COEF0(v1),
+			      dispc->vid1_conv_coef0);
+		dispc_reg_out(DISPC_VID_CONV_COEF1(v1),
+			      dispc->vid1_conv_coef1);
+		dispc_reg_out(DISPC_VID_CONV_COEF2(v1),
+			      dispc->vid1_conv_coef2);
+		dispc_reg_out(DISPC_VID_CONV_COEF3(v1),
+			      dispc->vid1_conv_coef3);
+		dispc_reg_out(DISPC_VID_CONV_COEF4(v1),
+			      dispc->vid1_conv_coef4);
+		break;
+
+	case OMAP_VIDEO2:
+		dispc_reg_out(DISPC_VID_BA0(v2), dispc->vid2_ba0);
+		dispc_reg_out(DISPC_VID_BA1(v2), dispc->vid2_ba1);
+		dispc_reg_out(DISPC_VID_POSITION(v2),
+			      dispc->vid2_position);
+		dispc_reg_out(DISPC_VID_SIZE(v2), dispc->vid2_size);
+		dispc_reg_out(DISPC_VID_ATTRIBUTES(v2),
+			      dispc->vid2_attributes);
+		dispc_reg_out(DISPC_VID_FIFO_THRESHOLD(v2),
+			      dispc->vid2_fifo_threshold);
+		dispc_reg_out(DISPC_VID_ROW_INC(v2), dispc->vid2_row_inc);
+		dispc_reg_out(DISPC_VID_PIXEL_INC(v2),
+			      dispc->vid2_pixel_inc);
+		dispc_reg_out(DISPC_VID_FIR(v2), dispc->vid2_fir);
+		dispc_reg_out(DISPC_VID_ACCU0(v2), dispc->vid2_accu0);
+		dispc_reg_out(DISPC_VID_ACCU1(v2), dispc->vid2_accu1);
+		dispc_reg_out(DISPC_VID_PICTURE_SIZE(v2),
+			      dispc->vid2_picture_size);
+
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 0),
+			      dispc->vid2_fir_coef_h0);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 1),
+			      dispc->vid2_fir_coef_h1);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 2),
+			      dispc->vid2_fir_coef_h2);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 3),
+			      dispc->vid2_fir_coef_h3);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 4),
+			      dispc->vid2_fir_coef_h4);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 5),
+			      dispc->vid2_fir_coef_h5);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 6),
+			      dispc->vid2_fir_coef_h6);
+		dispc_reg_out(DISPC_VID_FIR_COEF_H(v2, 7),
+			      dispc->vid2_fir_coef_h7);
+
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 0),
+			      dispc->vid2_fir_coef_hv0);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 1),
+			      dispc->vid2_fir_coef_hv1);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 2),
+			      dispc->vid2_fir_coef_hv2);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 3),
+			      dispc->vid2_fir_coef_hv3);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 4),
+			      dispc->vid2_fir_coef_hv4);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 5),
+			      dispc->vid2_fir_coef_hv5);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 6),
+			      dispc->vid2_fir_coef_hv6);
+		dispc_reg_out(DISPC_VID_FIR_COEF_HV(v2, 7),
+			      dispc->vid2_fir_coef_hv7);
+
+		dispc_reg_out(DISPC_VID_CONV_COEF0(v2),
+			      dispc->vid2_conv_coef0);
+		dispc_reg_out(DISPC_VID_CONV_COEF1(v2),
+			      dispc->vid2_conv_coef1);
+		dispc_reg_out(DISPC_VID_CONV_COEF2(v2),
+			      dispc->vid2_conv_coef2);
+		dispc_reg_out(DISPC_VID_CONV_COEF3(v2),
+			      dispc->vid2_conv_coef3);
+		dispc_reg_out(DISPC_VID_CONV_COEF4(v2),
+			      dispc->vid2_conv_coef4);
+		break;
+	}
+}
+
+int omap_disp_get_vrfb_offset(u32 img_len, u32 bytes_per_pixel, int side)
+{
+	int page_width_exp, page_height_exp, pixel_size_exp, offset = 0;
+
+	/* Maximum supported is 4 bytes (RGB32) */
+	if (bytes_per_pixel > 4)
+		return -EINVAL;
+
+	page_width_exp = PAGE_WIDTH_EXP;
+	page_height_exp = PAGE_HEIGHT_EXP;
+	pixel_size_exp = bytes_per_pixel >> 1;
+
+	if (side == SIDE_W) {
+		offset = ((1 << page_width_exp) *
+		(pages_per_side(img_len * bytes_per_pixel, page_width_exp)))
+		>> pixel_size_exp;	/* in pixels */
+	} else {
+		offset = (1 << page_height_exp) *
+		    (pages_per_side(img_len, page_height_exp));
+	}
+
+	return offset;
+}
+EXPORT_SYMBOL(omap_disp_get_vrfb_offset);
+
+void
+omap_disp_set_addr(int ltype, u32 lcd_phys_addr, u32 tv_phys_addr_f0,
+		    u32 tv_phys_addr_f1)
+{
+	int v;
+	v = (ltype == OMAP_VIDEO1) ? 0 : 1;
+	layer[ltype].dma[0].ba0 = lcd_phys_addr;
+	layer[ltype].dma[0].ba1 = lcd_phys_addr;
+
+	/*
+	 * Store BA0 BA1 for TV, BA1 points to the alternate row
+	 */
+	layer[ltype].dma[1].ba0 = tv_phys_addr_f0;
+	layer[ltype].dma[1].ba1 = tv_phys_addr_f1;
+
+	dispc_reg_out(DISPC_VID_BA0(v), tv_phys_addr_f0);
+
+	if (omap_disp_get_output_dev(ltype) == OMAP_OUTPUT_TV) {
+		dispc_reg_out(DISPC_VID_BA0(v), layer[ltype].dma[1].ba0);
+		dispc_reg_out(DISPC_VID_BA1(v), layer[ltype].dma[1].ba1);
+		dispc_reg_merge(DISPC_VID_ATTRIBUTES(v),
+				DISPC_VID_ATTRIBUTES_ENABLE,
+				DISPC_VID_ATTRIBUTES_ENABLE);
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_GODIGITAL,
+				DISPC_CONTROL_GODIGITAL);
+	}
+}
+EXPORT_SYMBOL(omap_disp_set_addr);
+
+void omap_disp_start_video_layer(int ltype)
+{
+
+	if (ltype != OMAP_VIDEO1 && ltype != OMAP_VIDEO2)
+		return;
+
+	/* Enable the Video layer and set the Go Bit */
+	omap_disp_enable_layer(ltype);
+}
+EXPORT_SYMBOL(omap_disp_start_video_layer);
+
+/* Many display controller registers are shadowed. Setting the GO bit causes
+ * changes to these registers to take effect in hardware.
+ */
+void omap_disp_reg_sync(int output_dev)
+{
+	unsigned long timeout;
+	if (output_dev == OMAP_OUTPUT_LCD)
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_GOLCD,
+				DISPC_CONTROL_GOLCD);
+	else
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_GODIGITAL,
+				DISPC_CONTROL_GODIGITAL);
+
+	if ((!in_interrupt()) && (!irqs_disabled())) {
+		timeout = HZ / 3;
+		timeout += jiffies;
+		while (omap_disp_reg_sync_bit(output_dev) &&
+				time_before(jiffies, timeout)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+
+		}
+	}
+}
+EXPORT_SYMBOL(omap_disp_reg_sync);
+
+/* This function provides the status of the GO bit. After the GO bit is set
+ * through software, register changes take affect at the next VFP (vertical
+ * front porch) or EVSYNC. Per the specs, no further register changes
+ * must be done until the GO bit is reset by hardware. This function allows
+ * drivers to poll the status of the GO bit, and wait until it is reset if they
+ * wish to.
+ */
+int omap_disp_reg_sync_done(int output_dev)
+{
+	u32 control = dispc_reg_in(DISPC_CONTROL);
+
+	if (output_dev == OMAP_OUTPUT_LCD)
+		return ~(control & DISPC_CONTROL_GOLCD);
+	else
+		return ~(control & DISPC_CONTROL_GODIGITAL);
+}
+EXPORT_SYMBOL(omap_disp_reg_sync_done);
+
+void omap_disp_disable(unsigned long timeout_ticks)
+{
+	unsigned long timeout;
+
+	if (dispc_reg_in(DISPC_CONTROL)
+	    & (DISPC_CONTROL_DIGITALENABLE | DISPC_CONTROL_LCDENABLE)) {
+		/* disable the display controller */
+		dispc_reg_merge(DISPC_CONTROL, 0,
+				DISPC_CONTROL_DIGITALENABLE |
+				DISPC_CONTROL_LCDENABLE);
+
+		/* wait for any frame in progress to complete */
+		dispc_reg_out(DISPC_IRQSTATUS, DISPC_IRQSTATUS_FRAMEDONE);
+		timeout = jiffies + timeout_ticks;
+		while (!(dispc_reg_in(DISPC_IRQSTATUS)
+			 & DISPC_IRQSTATUS_FRAMEDONE)
+		       && time_before(jiffies, timeout)) {
+			int a_ctx = (in_atomic() || irqs_disabled()
+				     || in_interrupt());
+			if (!a_ctx) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(1);
+			} else
+				udelay(100);
+		}
+#ifdef CONFIG_FB
+		if (!(dispc_reg_in(DISPC_IRQSTATUS)
+		      & DISPC_IRQSTATUS_FRAMEDONE)) {
+			DEBUGP(KERN_WARNING "DSS Library: timeout waiting for "
+			       "frame-done interrupt\n");
+		}
+#endif
+#ifndef CONFIG_ARCH_OMAP3410
+		disp_ll_config_tv_clocks(1);
+#endif
+	}
+
+	return;
+}
+EXPORT_SYMBOL(omap_disp_disable);
+
+#ifndef CONFIG_OMAP_USE_DSI_PLL
+/*
+ * Set the DSS Functional clock
+ * The DSS clock should be 4 times the Panel's Pixel clock
+ * For TV the Pixel clock required is 13.5Mhz
+ * For LCD the Pixel clock is 6Mhz
+ */
+void omap_disp_set_dssfclk(void)
+{
+	/* TODO set the LCD pixel clock rate based on the LCD configuration */
+#ifdef CONFIG_VIDEO_OMAP_TVOUT
+	static int TV_pixel_clk = 14000000;	/* rounded 13.5 to 14 */
+#endif
+	u32 ask_clkrate = 0, sup_clkrate = 0, tgt_clkrate = 0, i;
+
+	/*ask_clkrate = LCD_pixel_clk * 4; */
+	ask_clkrate = m_clk_rate;
+
+#ifdef CONFIG_VIDEO_OMAP_TVOUT
+	if (ask_clkrate < (TV_pixel_clk * 4))
+		ask_clkrate = TV_pixel_clk * 4;
+#endif
+
+	tgt_clkrate = ask_clkrate;
+
+	sup_clkrate = clk_round_rate(dss1f_scale, ask_clkrate);
+	if (is_sil_rev_less_than(OMAP3430_REV_ES2_0)) {
+		if (clk_get_rate(dss1f_scale) == 96000000) {
+			/*96M already, dont do anything for ES 1.0 */
+			return;
+		}
+	} else {
+		for (i = 1; i <= 20; i++) {
+			sup_clkrate =
+			    clk_round_rate(dss1f_scale, ask_clkrate);
+			if (sup_clkrate >= tgt_clkrate)
+				break;
+			ask_clkrate = ask_clkrate + 1000000;
+		}
+		if (clk_set_rate(dss1f_scale, sup_clkrate) == -EINVAL)
+			printk(KERN_ERR "Unable to set the DSS"
+			       "functional clock to %d\n", sup_clkrate);
+	}
+	return;
+}
+EXPORT_SYMBOL(omap_disp_set_dssfclk);
+#else
+void omap_disp_use_dsi_pll(void)
+{
+	disp_enable_dss2fck();
+	/*Command to change to ON state for both PLL and HSDIVISER
+	 * (no clock output to the DSI complex I/O)
+	 */
+	if (!disp_power_dsi_pll(2)) {
+		printk(KERN_WARNING "Unable to power DSI PLL\n");
+		return;
+	}
+#ifndef CONFIG_OMAP_DVI_SUPPORT
+	if (disp_lock_dsi_pll(270, 12, 4, 0, 3)) {	/* Generate 108 MHz */
+#else
+	if (disp_lock_dsi_pll(297, 12, 3, 0, 3)) {	/* Generate 148.5 MHz */
+#endif
+		omap_disp_disable_layer(OMAP_GRAPHICS);
+		disp_switch_to_dsipll_clk_source();
+		omap_disp_enable_layer(OMAP_GRAPHICS);
+	} else {
+		printk(KERN_ERR "FATAL ERROR: DSI PLL lock failed = %X\n",
+		       dsipll_reg_in(DSI_PLL_STATUS));
+	}
+
+}
+#endif
+
+/* This function must be called by any driver that needs to use the display
+ * controller before calling any routine that accesses the display controller
+ * registers. It increments the count of the number of users of the display
+ * controller, and turns the clocks ON only when required.
+ */
+void omap_disp_get_all_clks(void)
+{
+	u32 idle_dispc;
+#ifdef CONFIG_HW_SUP_TRANS
+	u32 idle_dss;
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+#ifndef CONFIG_ARCH_OMAP3410
+	struct omap_encoder_device *enc_dev;
+#endif
+	spin_lock(&dss_lock);
+	if (disp_usage == 0) {
+		/* turn on DSS clock */
+		config_disp_clocks(0);
+#ifndef CONFIG_ARCH_OMAP3410
+		omap_disp_set_tvref(TVREF_ON);
+		disp_ll_config_tv_clocks(0);
+#endif
+#ifdef CONFIG_OMAP34XX_OFFMODE
+#ifndef CONFIG_ARCH_OMAP3410
+		/* Set the TV standard first */
+		if (channels[1].num_encoders > 0) {
+			enc_dev =
+			    channels[1].enc_devices[channels[1]
+						.current_encoder];
+			if (enc_dev && enc_dev->mode_ops->setmode)
+				enc_dev->mode_ops->
+				    setmode(modes[channels[1].current_mode]
+						.name, enc_dev);
+		}
+#endif
+		/* restore dss context */
+		omap_disp_restore_ctx(OMAP_DSS_GENERIC);
+		omap_disp_restore_ctx(OMAP_DSS_DISPC_GENERIC);
+		omap_disp_restore_ctx(OMAP_VIDEO1);
+		omap_disp_restore_ctx(OMAP_VIDEO2);
+
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+#ifdef CONFIG_HW_SUP_TRANS
+		/* Set smart idle for Display subsystem */
+		idle_dss = dss_reg_in(DSS_SYSCONFIG);
+		idle_dss |= DSS_SYSCONFIG_AUTOIDLE;
+		dss_reg_out(DSS_SYSCONFIG, idle_dss);
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		/* Set smart idle, autoidle for Display controller */
+		idle_dispc = dispc_reg_in(DISPC_SYSCONFIG);
+		idle_dispc &= ~(DISPC_SYSCONFIG_MIDLEMODE |
+				DISPC_SYSCONFIG_SIDLEMODE);
+
+#ifdef CONFIG_HW_SUP_TRANS
+		idle_dispc |= (DISPC_SYSCONFIG_MIDLEMODE_SSTANDBY |
+			       DISPC_SYSCONFIG_SIDLEMODE_SIDLE |
+			       DISPC_SYSCONFIG_ENABLE_WKUP);
+		idle_dispc |= DISPC_SYSCONFIG_AUTOIDLE;
+#else
+		idle_dispc |= DISPC_SYSCONFIG_MIDLEMODE_NSTANDBY |
+		    DISPC_SYSCONFIG_SIDLEMODE_NIDLE;
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		dispc_reg_out(DISPC_SYSCONFIG, idle_dispc);
+#ifdef CONFIG_OMAP34XX_OFFMODE
+		dispc_reg_out(DISPC_CONTROL, dss_ctx.dispc.control);
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+	} else {
+		/* enable the TV clocks, since we are not if they are */
+#ifndef CONFIG_ARCH_OMAP3410
+		omap_disp_set_tvref(TVREF_ON);
+		disp_ll_config_tv_clocks(0);
+		enc_dev =
+		    channels[1].enc_devices[channels[1].current_encoder];
+		if (enc_dev && enc_dev->mode_ops->setmode) {
+		/* Set the default standard to ntsc_m */
+			enc_dev->mode_ops->
+				setmode(modes[channels[1].current_mode]
+					.name, enc_dev);
+		}
+#endif
+	}
+	disp_usage++;
+	spin_unlock(&dss_lock);
+}
+EXPORT_SYMBOL(omap_disp_get_all_clks);
+
+/* This function must be called by a driver when it not going to use the
+ * display controller anymore. E.g., when a driver suspends, it must call
+ * omap_disp_put_dss. When it wakes up, it must call omap_disp_get_dss again.
+ * It decrements the count of the number of users of the display
+ * controller, and turns the clocks OFF when not required.
+ */
+void omap_disp_put_all_clks(void)
+{
+#ifndef CONFIG_HW_SUP_TRANS
+	u32 idle_dss;
+#endif				/* #ifndef CONFIG_HW_SUP_TRANS */
+
+	spin_lock(&dss_lock);
+	if (disp_usage == 0) {
+		printk(KERN_ERR
+		       "trying to put DSS when usage count is zero\n");
+		spin_unlock(&dss_lock);
+		return;
+	}
+
+	disp_usage--;
+
+	if (disp_usage == 0) {
+#ifdef CONFIG_OMAP34XX_OFFMODE
+		/* save dss context */
+		disp_save_ctx(OMAP_DSS_GENERIC);
+		disp_save_ctx(OMAP_DSS_DISPC_GENERIC);
+		disp_save_ctx(OMAP_GRAPHICS);
+		disp_save_ctx(OMAP_VIDEO1);
+		disp_save_ctx(OMAP_VIDEO2);
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+#ifndef CONFIG_HW_SUP_TRANS
+		idle_dss = dispc_reg_in(DISPC_SYSCONFIG);
+		idle_dss &=
+		    ~(DISPC_SYSCONFIG_MIDLEMODE |
+		      DISPC_SYSCONFIG_SIDLEMODE);
+		idle_dss |=
+		    DISPC_SYSCONFIG_MIDLEMODE_SSTANDBY |
+		    DISPC_SYSCONFIG_SIDLEMODE_SIDLE;
+		dispc_reg_out(DISPC_SYSCONFIG, idle_dss);
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		omap_disp_disable(HZ / 2);
+		/* turn off TV clocks */
+#ifndef CONFIG_ARCH_OMAP3410
+		disp_ll_config_tv_clocks(1);
+		omap_disp_set_tvref(TVREF_OFF);
+#endif
+		mdelay(4);
+
+		config_disp_clocks(1);
+	}
+	spin_unlock(&dss_lock);
+}
+EXPORT_SYMBOL(omap_disp_put_all_clks);
+
+/* This function must be called by any driver that needs to use the display
+ * controller before calling any routine that accesses the display controller
+ * registers. It increments the count of the number of users of the display
+ * controller, and turns the clocks ON only when required.
+ */
+void omap_disp_get_dss(void)
+{
+	u32 idle_dispc;
+	u32 i;
+#ifdef CONFIG_HW_SUP_TRANS
+	u32 idle_dss;
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+	struct omap_encoder_device *enc_dev;
+	unsigned int panel_width, panel_height, size = 0;
+	struct omap_dispc_regs *dispc = &dss_ctx.dispc;
+	struct channel_obj *channel = &channels[1];
+
+	spin_lock(&dss_lock);
+	if (disp_usage == 0) {
+		/* turn on DSS clock */
+		config_disp_clocks(0);
+#ifndef CONFIG_ARCH_OMAP3410
+
+		omap_disp_set_tvref(TVREF_ON);
+		disp_ll_config_tv_clocks(0);
+#endif
+#ifdef CONFIG_OMAP34XX_OFFMODE
+
+		/* Set the current mode for all the channels and
+		 * Set the panel size accordingly
+		 */
+		for (i = 0; i < ARRAY_SIZE(channels); i++) {
+			enc_dev =
+				channels[i].enc_devices[channels[i].
+						current_encoder];
+			if (enc_dev && enc_dev->mode_ops->setmode) {
+				enc_dev->mode_ops->
+					setmode(modes[channels[i].
+					current_mode].name, enc_dev);
+				panel_width = modes[channel->
+					current_mode].width;
+				panel_height =
+					modes[channel->current_mode]
+						.height;
+				if (i == i) {
+					panel_height = panel_height>>1;
+					size = ((panel_width - 1) <<
+						DISPC_SIZE_DIG_PPL_SHIFT)
+						& DISPC_SIZE_DIG_PPL;
+					size |= ((panel_height - 1)
+						<< DISPC_SIZE_DIG_LPP_SHIFT)
+						& DISPC_SIZE_DIG_LPP;
+					dispc->size_dig = (size);
+				}
+			}
+		}
+		/* restore dss context */
+		omap_disp_restore_ctx(OMAP_DSS_GENERIC);
+		omap_disp_restore_ctx(OMAP_DSS_DISPC_GENERIC);
+		omap_disp_restore_ctx(OMAP_VIDEO1);
+		omap_disp_restore_ctx(OMAP_VIDEO2);
+
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+#ifdef CONFIG_HW_SUP_TRANS
+		/* Set smart idle for Display subsystem */
+		idle_dss = dss_reg_in(DSS_SYSCONFIG);
+		idle_dss |= DSS_SYSCONFIG_AUTOIDLE;
+		dss_reg_out(DSS_SYSCONFIG, idle_dss);
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		/* Set smart idle, autoidle for Display controller */
+		idle_dispc = dispc_reg_in(DISPC_SYSCONFIG);
+		idle_dispc &= ~(DISPC_SYSCONFIG_MIDLEMODE |
+				DISPC_SYSCONFIG_SIDLEMODE);
+
+#ifdef CONFIG_HW_SUP_TRANS
+		idle_dispc |= (DISPC_SYSCONFIG_MIDLEMODE_SSTANDBY |
+			       DISPC_SYSCONFIG_SIDLEMODE_SIDLE |
+			       DISPC_SYSCONFIG_ENABLE_WKUP);
+		idle_dispc |= DISPC_SYSCONFIG_AUTOIDLE;
+#else
+		idle_dispc |= DISPC_SYSCONFIG_MIDLEMODE_NSTANDBY |
+		    DISPC_SYSCONFIG_SIDLEMODE_NIDLE;
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		dispc_reg_out(DISPC_SYSCONFIG, idle_dispc);
+#ifdef CONFIG_OMAP34XX_OFFMODE
+		dispc_reg_out(DISPC_CONTROL, dss_ctx.dispc.control);
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+	}
+	disp_usage++;
+	spin_unlock(&dss_lock);
+}
+EXPORT_SYMBOL(omap_disp_get_dss);
+
+/* This function must be called by a driver when it not going to use the
+ * display controller anymore. E.g., when a driver suspends, it must call
+ * omap_disp_put_dss. When it wakes up, it must call omap_disp_get_dss again.
+ * It decrements the count of the number of users of the display
+ * controller, and turns the clocks OFF when not required.
+ */
+void omap_disp_put_dss(void)
+{
+#ifndef CONFIG_HW_SUP_TRANS
+	u32 idle_dss;
+#endif				/* #ifndef CONFIG_HW_SUP_TRANS */
+
+	spin_lock(&dss_lock);
+	if (disp_usage == 0) {
+		printk(KERN_ERR
+		       "trying to put DSS when usage count is zero\n");
+		spin_unlock(&dss_lock);
+		return;
+	}
+
+	disp_usage--;
+
+	if (disp_usage == 0) {
+#ifdef CONFIG_OMAP34XX_OFFMODE
+		/* save dss context */
+		disp_save_ctx(OMAP_DSS_GENERIC);
+		disp_save_ctx(OMAP_DSS_DISPC_GENERIC);
+		disp_save_ctx(OMAP_GRAPHICS);
+		disp_save_ctx(OMAP_VIDEO1);
+		disp_save_ctx(OMAP_VIDEO2);
+#endif				/* #ifdef CONFIG_OMAP34XX_OFFMODE */
+#ifndef CONFIG_HW_SUP_TRANS
+		idle_dss = dispc_reg_in(DISPC_SYSCONFIG);
+		idle_dss &=
+		    ~(DISPC_SYSCONFIG_MIDLEMODE |
+		      DISPC_SYSCONFIG_SIDLEMODE);
+		idle_dss |=
+		    DISPC_SYSCONFIG_MIDLEMODE_SSTANDBY |
+		    DISPC_SYSCONFIG_SIDLEMODE_SIDLE;
+		dispc_reg_out(DISPC_SYSCONFIG, idle_dss);
+#endif				/* #ifdef CONFIG_HW_SUP_TRANS */
+
+		omap_disp_disable(HZ / 2);
+#ifndef CONFIG_ARCH_OMAP3410
+		{
+			disp_ll_config_tv_clocks(1);
+			omap_disp_set_tvref(TVREF_OFF);
+		}
+#endif
+		mdelay(4);
+		config_disp_clocks(1);
+	}
+	spin_unlock(&dss_lock);
+}
+EXPORT_SYMBOL(omap_disp_put_dss);
+
+/* This function must be called by any driver that wishes to use a particular
+ * display pipeline (layer).
+ */
+int omap_disp_request_layer(int ltype)
+{
+	int ret;
+	ret = 0;
+
+	spin_lock(&dss_lock);
+	if (!layer[ltype].in_use) {
+		layer[ltype].in_use = 1;
+		ret = 1;
+	}
+	spin_unlock(&dss_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(omap_disp_request_layer);
+
+/* This function must be called by a driver when it is done using a particular
+ * display pipeline (layer).
+ */
+void omap_disp_release_layer(int ltype)
+{
+	spin_lock(&dss_lock);
+	layer[ltype].in_use = 0;
+	layer[ltype].ctx_valid = 0;
+	spin_unlock(&dss_lock);
+}
+EXPORT_SYMBOL(omap_disp_release_layer);
+
+/* Used to enable LCDENABLE or DIGITALENABLE of the display controller.
+ */
+void omap_disp_enable_output_dev(int output_dev)
+{
+	if (output_dev == OMAP_OUTPUT_LCD) {
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_LCDENABLE,
+				DISPC_CONTROL_LCDENABLE);
+	}
+#ifndef CONFIG_ARCH_OMAP3410
+	else if (output_dev == OMAP_OUTPUT_TV) {
+		dispc_reg_merge(DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE,
+				DISPC_CONTROL_DIGITALENABLE);
+	}
+#endif
+}
+EXPORT_SYMBOL(omap_disp_enable_output_dev);
+
+/* Used to disable LCDENABLE or DIGITALENABLE of the display controller.
+ */
+void omap_disp_disable_output_dev(int output_dev)
+{
+	if (output_dev == OMAP_OUTPUT_LCD) {
+		dispc_reg_merge(DISPC_CONTROL, ~DISPC_CONTROL_LCDENABLE,
+				DISPC_CONTROL_LCDENABLE);
+	}
+#ifndef CONFIG_ARCH_OMAP3410
+	else if (output_dev == OMAP_OUTPUT_TV) {
+		dispc_reg_merge(DISPC_CONTROL,
+				~DISPC_CONTROL_DIGITALENABLE,
+				DISPC_CONTROL_DIGITALENABLE);
+	}
+#endif
+}
+EXPORT_SYMBOL(omap_disp_disable_output_dev);
+
+int omap_disp_get_output_dev(int ltype)
+{
+	return layer[ltype].output_dev;
+}
+EXPORT_SYMBOL(omap_disp_get_output_dev);
+
+/* Used to save the DMA parameter settings for a particular layer to be
+ * displayed on a particular output device. These values help the
+ * omap_disp_set_output_dev() function to dynamically switch the output of a
+ * layer to any output device.
+ */
+void
+omap_disp_set_dma_params(int ltype, int output_dev,
+			  u32 ba0, u32 ba1, u32 row_inc, u32 pix_inc)
+{
+	struct omap_disp_dma_params *dma;
+
+	if (output_dev == OMAP_OUTPUT_LCD)
+		dma = &layer[ltype].dma[0];
+	else
+		dma = &layer[ltype].dma[1];
+
+	dma->ba0 = ba0;
+	dma->ba1 = ba1;
+	dma->row_inc = row_inc;
+	dma->pix_inc = pix_inc;
+}
+EXPORT_SYMBOL(omap_disp_set_dma_params);
+
+/* Sets the background color */
+void omap_disp_set_bg_color(int output_dev, int color)
+{
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV)
+		dispc_reg_out(DISPC_DEFAULT_COLOR1, color);
+#endif
+
+	omap_disp_reg_sync(output_dev);
+}
+EXPORT_SYMBOL(omap_disp_set_bg_color);
+
+/* Returns the current background color */
+void omap_disp_get_bg_color(int output_dev, int *color)
+{
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV)
+		*color = dispc_reg_in(DISPC_DEFAULT_COLOR1);
+#endif
+}
+EXPORT_SYMBOL(omap_disp_get_bg_color);
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430) \
+	&& !defined(CONFIG_ARCH_OMAP3410)
+/* Turn on/off the TV reference voltage from OMAP */
+void omap_disp_set_tvref(int tvref_state)
+{
+	switch (tvref_state) {
+	case TVREF_ON:
+		dss_reg_out(DSS_CONTROL, (dss_reg_in(DSS_CONTROL)
+					  | DSS_CONTROL_TV_REF));
+		break;
+	case TVREF_OFF:
+		dss_reg_out(DSS_CONTROL, (dss_reg_in(DSS_CONTROL) &
+					  ~(DSS_CONTROL_TV_REF)));
+		break;
+	}
+}
+EXPORT_SYMBOL(omap_disp_set_tvref);
+#endif
+
+/* Sets the SMS settings for rotation using the VRFB.
+ */
+int
+omap_disp_set_vrfb(int context, u32 phy_addr,
+		    u32 width, u32 height, u32 bytes_per_pixel)
+{
+	int page_width_exp, page_height_exp, pixel_size_exp;
+
+	if (bytes_per_pixel > 4)
+		return -EINVAL;
+
+	page_width_exp = PAGE_WIDTH_EXP;
+	page_height_exp = PAGE_HEIGHT_EXP;
+	pixel_size_exp = bytes_per_pixel >> 1;
+
+	width = ((1 << page_width_exp) *
+		 (pages_per_side(width * bytes_per_pixel, page_width_exp))
+	    ) >> pixel_size_exp;
+
+	height = (1 << page_height_exp) *
+	    (pages_per_side(height, page_height_exp));
+
+	SMS_ROT0_PHYSICAL_BA(context) = phy_addr;
+	SMS_ROT0_SIZE(context) = 0;
+	SMS_ROT0_SIZE(context) |= (width << SMS_IMAGEWIDTH_OFFSET)
+	    | (height << SMS_IMAGEHEIGHT_OFFSET);
+	SMS_ROT_CONTROL(context) = 0;
+
+	SMS_ROT_CONTROL(context) |= pixel_size_exp << SMS_PS_OFFSET
+	    | (page_width_exp - pixel_size_exp) << SMS_PW_OFFSET
+	    | page_height_exp << SMS_PH_OFFSET;
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_disp_set_vrfb);
+
+/* Sets the transparency color key type and value.
+*/
+void omap_disp_set_colorkey(int output_dev, int key_type, int key_val)
+{
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV) {
+		if (key_type == OMAP_VIDEO_SOURCE)
+			dispc_reg_merge(DISPC_CONFIG,
+					DISPC_CONFIG_TCKDIGSELECTION,
+					DISPC_CONFIG_TCKDIGSELECTION);
+		else
+			dispc_reg_merge(DISPC_CONFIG, 0,
+					DISPC_CONFIG_TCKDIGSELECTION);
+		dispc_reg_out(DISPC_TRANS_COLOR1, key_val);
+	}
+#endif
+
+	omap_disp_reg_sync(output_dev);
+}
+EXPORT_SYMBOL(omap_disp_set_colorkey);
+
+/* Returns the current transparency color key type and value.
+*/
+void omap_disp_get_colorkey(int output_dev, int *key_type, int *key_val)
+{
+
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV) {
+		if (dispc_reg_in(DISPC_CONFIG) &
+		    DISPC_CONFIG_TCKDIGSELECTION)
+			*key_type = OMAP_VIDEO_SOURCE;
+		else
+			*key_type = OMAP_GFX_DESTINATION;
+		*key_val = dispc_reg_in(DISPC_TRANS_COLOR1);
+	}
+#endif
+}
+EXPORT_SYMBOL(omap_disp_get_colorkey);
+
+void omap_disp_enable_colorkey(int output_dev)
+{
+
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV)
+		dispc_reg_merge(DISPC_CONFIG, DISPC_CONFIG_TCKDIGENABLE,
+				DISPC_CONFIG_TCKDIGENABLE);
+#endif
+
+	omap_disp_reg_sync(output_dev);
+}
+EXPORT_SYMBOL(omap_disp_enable_colorkey);
+
+void omap_disp_disable_colorkey(int output_dev)
+{
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV)
+		dispc_reg_merge(DISPC_CONFIG, ~DISPC_CONFIG_TCKDIGENABLE,
+				DISPC_CONFIG_TCKDIGENABLE);
+#endif
+
+	omap_disp_reg_sync(output_dev);
+}
+EXPORT_SYMBOL(omap_disp_disable_colorkey);
+
+#ifdef CONFIG_ARCH_OMAP34XX
+void omap_disp_set_alphablend(int output_dev, int value)
+{
+
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV) {
+		if (value)
+			dispc_reg_merge(DISPC_CONFIG,
+					DISPC_CONFIG_TVALPHAENABLE,
+					DISPC_CONFIG_TVALPHAENABLE);
+		else
+			dispc_reg_merge(DISPC_CONFIG,
+					~DISPC_CONFIG_TVALPHAENABLE,
+					DISPC_CONFIG_TVALPHAENABLE);
+	}
+#endif
+	omap_disp_reg_sync(output_dev);
+}
+EXPORT_SYMBOL(omap_disp_set_alphablend);
+
+void omap_disp_set_global_alphablend_value(int ltype, int value)
+{
+	u32  alpha_value;
+	alpha_value = 0;
+
+	if (ltype == OMAP_VIDEO2) {
+		alpha_value = dispc_reg_in(DISPC_GLOBAL_ALPHA);
+		alpha_value &= (~DISPC_GLOBAL_ALPHA_VID2_GALPHA);
+		alpha_value |=
+		    (value << DISPC_GLOBAL_ALPHA_VID2_GALPHA_SHIFT);
+		dispc_reg_out(DISPC_GLOBAL_ALPHA, alpha_value);
+
+	}
+#ifndef CONFIG_ARCH_OMAP3410
+	omap_disp_reg_sync(OMAP_OUTPUT_TV);
+#endif
+}
+EXPORT_SYMBOL(omap_disp_set_global_alphablend_value);
+
+unsigned char omap_disp_get_global_alphablend_value(int ltype)
+{
+	u32  alpha_value;
+	alpha_value = 0;
+
+	if (ltype == OMAP_VIDEO2) {
+		alpha_value = dispc_reg_in(DISPC_GLOBAL_ALPHA);
+		alpha_value &= (DISPC_GLOBAL_ALPHA_VID2_GALPHA);
+		alpha_value = alpha_value >>
+		    DISPC_GLOBAL_ALPHA_VID2_GALPHA_SHIFT;
+	}
+	return (unsigned char) alpha_value;
+}
+EXPORT_SYMBOL(omap_disp_get_global_alphablend_value);
+
+int omap_disp_get_alphablend(int output_dev)
+{
+
+#ifndef CONFIG_ARCH_OMAP3410
+	if (output_dev == OMAP_OUTPUT_TV) {
+		if (dispc_reg_in(DISPC_CONFIG) & 0x00080000)
+			return 1;
+		else
+			return 0;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(omap_disp_get_alphablend);
+#endif
+
+int omap_disp_reg_sync_bit(int output_dev)
+{
+	u32 control = dispc_reg_in(DISPC_CONTROL);
+
+	if (output_dev == OMAP_OUTPUT_LCD)
+		return (control & DISPC_CONTROL_GOLCD) >> 5;
+	else
+		return (control & DISPC_CONTROL_GODIGITAL) >> 6;
+}
+EXPORT_SYMBOL(omap_disp_reg_sync_bit);
+
+/*
+ * Enables an IRQ in DSPC_IRQENABLE.
+ */
+int omap_disp_irqenable(omap_disp_isr_t isr, unsigned int mask)
+{
+	int i;
+	unsigned long flags;
+
+	if (omap_disp_irq == 0 || mask == 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dss_lock, flags);
+	for (i = 0; i < MAX_ISR_NR; i++) {
+		if (registered_isr[i].isr == isr) {
+			registered_isr[i].mask |= mask;
+			dispc_reg_out(DISPC_IRQENABLE,
+				      dispc_reg_in(DISPC_IRQENABLE) |
+				      mask);
+			spin_unlock_irqrestore(&dss_lock, flags);
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&dss_lock, flags);
+	return -EBUSY;
+}
+EXPORT_SYMBOL(omap_disp_irqenable);
+
+/*
+ * Disables an IRQ in DISPC_IRQENABLE,
+ * The IRQ will be active if any other ISR is still using the same.
+ * mask : should contain '0' for irq to be disable and rest should be '1'.
+ */
+int omap_disp_irqdisable(omap_disp_isr_t isr, unsigned int mask)
+{
+	int i;
+	unsigned long flags;
+	unsigned int new_mask;
+	new_mask = 0;
+
+	if (omap_disp_irq == 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dss_lock, flags);
+	for (i = 0; i < MAX_ISR_NR; i++)
+		if (registered_isr[i].isr == isr)
+			break;
+
+	if (i == MAX_ISR_NR) {
+		spin_unlock_irqrestore(&dss_lock, flags);
+		return -EINVAL;
+	}
+
+	registered_isr[i].mask &= mask;
+
+	/* disable an IRQ if every one wishes to do so */
+	for (i = 0; i < MAX_ISR_NR; i++)
+		new_mask |= registered_isr[i].mask;
+
+	dispc_reg_out(DISPC_IRQENABLE, new_mask);
+	spin_unlock_irqrestore(&dss_lock, flags);
+	return -EBUSY;
+}
+EXPORT_SYMBOL(omap_disp_irqdisable);
+
+/* Display controller interrupts are handled first by this display library.
+ * Drivers that need to use certain interrupts should register their ISRs and
+ * interrupt enable mask with the display library.
+ */
+int
+omap_disp_register_isr(omap_disp_isr_t isr, void *arg, unsigned int mask)
+{
+	int i;
+	unsigned long flags;
+
+	if (omap_disp_irq == 0 || isr == 0 || arg == 0)
+		return -EINVAL;
+
+	/* Clear all the interrupt, so that you dont get an immediate
+	 * interrupt
+	 */
+	dispc_reg_out(DISPC_IRQSTATUS, 0xFFFFFFFF);
+	spin_lock_irqsave(&dss_lock, flags);
+	for (i = 0; i < MAX_ISR_NR; i++) {
+		if (registered_isr[i].isr == NULL) {
+			registered_isr[i].isr = isr;
+			registered_isr[i].arg = arg;
+			registered_isr[i].mask = mask;
+
+			/* Clear previous interrupts if any */
+			dispc_reg_out(DISPC_IRQSTATUS, mask);
+			dispc_reg_out(DISPC_IRQENABLE,
+				      dispc_reg_in(DISPC_IRQENABLE) |
+				      mask);
+			spin_unlock_irqrestore(&dss_lock, flags);
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&dss_lock, flags);
+	return -EBUSY;
+}
+EXPORT_SYMBOL(omap_disp_register_isr);
+
+int omap_disp_unregister_isr(omap_disp_isr_t isr)
+{
+	int i, j;
+	unsigned long flags;
+	unsigned int new_mask;
+
+	new_mask = 0;
+	if (omap_disp_irq == 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dss_lock, flags);
+	for (i = 0; i < MAX_ISR_NR; i++) {
+		if (registered_isr[i].isr == isr) {
+			registered_isr[i].isr = NULL;
+			registered_isr[i].arg = NULL;
+			registered_isr[i].mask = 0;
+
+			/* The interrupt may no longer be valid, re-set
+			 * the IRQENABLE */
+			for (j = 0; j < MAX_ISR_NR; j++)
+				new_mask |= registered_isr[j].mask;
+
+			dispc_reg_out(DISPC_IRQENABLE, new_mask);
+			spin_unlock_irqrestore(&dss_lock, flags);
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&dss_lock, flags);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(omap_disp_unregister_isr);
+
+int __init omap_disp_init(void)
+{
+	int rev, i;
+	u32 dss_control;
+
+	spin_lock_init(&dss_lock);
+
+	/* Required for scale call */
+#ifdef CONFIG_TRACK_RESOURCES
+	dss1f_scale =
+	    clk_get(&display_dev,
+		    cpu_is_omap34xx()? "dss1_alwon_fck" : "dss1_fck");
+#else
+	dss1f_scale =
+	    clk_get(NULL,
+		    cpu_is_omap34xx()? "dss1_alwon_fck" : "dss1_fck");
+#endif
+	if (IS_ERR(dss1f_scale)) {
+		printk(KERN_WARNING "Could not get DSS1 FCLK\n");
+		return PTR_ERR(dss1f_scale);
+	}
+
+	omap_disp_get_all_clks();
+
+	/* disable the display controller */
+	omap_disp_disable(HZ / 5);
+
+	rev = dss_reg_in(DSS_REVISION);
+	printk(KERN_INFO "OMAP Display hardware version %d.%d\n",
+	       (rev & DISPC_REVISION_MAJOR) >> DISPC_REVISION_MAJOR_SHIFT,
+	       (rev & DISPC_REVISION_MINOR) >> DISPC_REVISION_MINOR_SHIFT);
+
+	/* enable DAC_DEMEN and VENC_4X_CLOCK in DSS for TV operation */
+	dss_control = dss_reg_in(DSS_CONTROL);
+
+	/* Should be replaced by FPGA register read  ADD A 2420 ifdef here */
+
+#ifdef CONFIG_ARCH_OMAP2420
+	dss_control |= (DSS_CONTROL_DAC_DEMEN |
+			DSS_CONTROL_VENC_CLOCK_4X_ENABLE);
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+#ifdef CONFIG_TWL4030_CORE_T2
+	dss_control |= (DSS_CONTROL_TV_REF | DSS_CONTROL_DAC_DEMEN |
+			DSS_CONTROL_VENC_CLOCK_4X_ENABLE);
+#endif
+
+#ifdef CONFIG_TWL4030_CORE_M1
+	dss_control |= (DSS_CONTROL_DAC_DEMEN |
+			DSS_CONTROL_VENC_CLOCK_4X_ENABLE);
+#endif
+#endif
+
+#if defined(CONFIG_MACH_OMAP_3430SDP) ||  defined(CONFIG_MACH_OMAP3EVM) \
+	|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
+	/* enabling S-video connector for 3430 SDP */
+#ifndef CONFIG_ARCH_OMAP3410
+	dss_control |= (DSS_CONTROL_DAC_DEMEN | DSS_CONTROL_TV_REF |
+			DSS_CONTROL_VENC_CLOCK_4X_ENABLE |
+			DSS_CONTROL_VENC_OUT);
+#else
+	dss_control |= (DSS_CONTROL_DAC_DEMEN |
+			DSS_CONTROL_VENC_CLOCK_4X_ENABLE |
+			DSS_CONTROL_VENC_OUT);
+#endif
+#endif
+
+	dss_control &= ~DSS_CONTROL_VENC_CLOCK_MODE;
+	dss_reg_out(DSS_CONTROL, dss_control);
+
+	/* By default, all layers go to LCD */
+	layer[OMAP_GRAPHICS].output_dev = OMAP_OUTPUT_TV;
+	layer[OMAP_VIDEO1].output_dev = OMAP_OUTPUT_TV;
+	layer[OMAP_VIDEO2].output_dev = OMAP_OUTPUT_TV;
+
+	/*
+	 * Set the default color conversion parameters for Video pipelines
+	 * by default the color space is set to JPEG
+	 */
+
+	update_colorconv_mtx(0, cc_bt601_full);
+	omap_disp_set_colorconv(0, FULL_COLOR_RANGE);
+
+	update_colorconv_mtx(1, cc_bt601_full);
+	omap_disp_set_colorconv(1, FULL_COLOR_RANGE);
+
+	/* Disable the Alpha blending for both TV and LCD
+	 * Also set the global alpha value for both
+	 * graphics and video2 pipeline to 255(Completely Opaque)
+	 */
+	omap_disp_set_alphablend(OMAP_OUTPUT_TV, 0);
+
+	omap_disp_set_global_alphablend_value(OMAP_VIDEO2, 0xFF);
+
+#ifndef CONFIG_ARCH_OMAP3410
+	omap_disp_set_bg_color(OMAP_OUTPUT_TV, 0x000000);
+#endif
+
+	if (request_irq(INT_24XX_DSS_IRQ, (void *) omap_disp_master_isr,
+			IRQF_SHARED, "OMAP Display", registered_isr)) {
+		printk(KERN_WARNING "omap_disp: request_irq failed\n");
+		omap_disp_irq = 0;
+	} else {
+		omap_disp_irq = 1;
+		for (i = 0; i < MAX_ISR_NR; i++) {
+			registered_isr[i].isr = NULL;
+			registered_isr[i].mask = 0;
+		}
+		/* Clear all the pending interrupts, if any */
+		dispc_reg_out(DISPC_IRQSTATUS, 0xFFFFFFFF);
+		omap_disp_register_isr(disp_synclost_isr, layer,
+					DISPC_IRQSTATUS_SYNCLOST);
+	}
+
+	omap_disp_register_isr(disp_synclost_isr, layer,
+				DISPC_IRQSTATUS_SYNCLOST);
+	omap_disp_put_all_clks();
+
+	return 0;
+
+}
+
+/* Start before devices */
+subsys_initcall(omap_disp_init);
diff --git a/arch/arm/plat-omap/omap-venc.c b/arch/arm/plat-omap/omap-venc.c
new file mode 100644
index 0000000..a6fbabf
--- /dev/null
+++ b/arch/arm/plat-omap/omap-venc.c
@@ -0,0 +1,485 @@
+/*
+ * arch/arm/plat-omap/omap-venc.c
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Leveraged code from the OMAP24xx camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author:  (@ti.com)
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ *
+ * History:
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/io.h>
+#ifdef CONFIG_TRACK_RESOURCES
+#include <linux/device.h>
+#endif
+#include <mach/omap-dss.h>
+#include <mach/omap-venc.h>
+#if defined(CONFIG_MACH_OMAP_2430SDP) ||  defined(CONFIG_MACH_OMAP3EVM) \
+|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
+#include <linux/i2c/twl4030.h>
+#endif
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+#include <linux/platform_device.h>
+
+#define OMAP_TV_DRIVER			"omap_tv"
+
+#ifdef CONFIG_MACH_OMAP_H4
+#define OMAP_TV_DEVICE		"h4_tv"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+#define OMAP_TV_DEVICE		"sdp2430_tv"
+#endif
+
+#if defined(CONFIG_MACH_OMAP_3430SDP) ||  defined(CONFIG_MACH_OMAP3EVM) \
+|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
+#define OMAP_TV_DEVICE		"omap_tv"
+#endif
+
+#define H4_TV_XRES		720
+#define H4_TV_YRES		482
+
+#define MENELAUS_I2C_ADAP_ID		0
+
+#define ENABLE_VDAC_DEDICATED		0x03
+#define ENABLE_VDAC_DEV_GRP		0x20
+#define ENABLE_VPLL2_DEDICATED		0x05
+#define ENABLE_VPLL2_DEV_GRP		0xE0
+
+#define CONFIG_TWL4030_CORE_T2
+#define CONFIG_I2C_TWL4030_CORE
+
+#define ENCODER_NAME	"TV_ENCODER"
+
+struct omap_output_info outputs[] = {
+	{"SVIDEO", (void *)tv_standards, ARRAY_SIZE(tv_standards), 5,
+	 0}
+};
+
+#define OMAP_VENC_NO_OUTPUTS 1
+static struct omap_enc_output_ops outputs_ops = {
+	.count = OMAP_VENC_NO_OUTPUTS,
+	.enumoutput = omap_venc_enumoutput,
+	.setoutput = omap_venc_setoutput,
+	.getoutput = NULL,
+};
+
+static struct omap_enc_mode_ops standards_ops = {
+	.setmode = omap_venc_setstd,
+	.getmode = omap_venc_getstd,
+};
+
+struct omap_encoder_device tv_enc = {
+	.name = ENCODER_NAME,
+	.channel_id = 1,
+	.current_output = 0,
+	.no_outputs = 1,
+	.initialize = tv_initialize,
+	.deinitialize = tv_deinitialize,
+	.output_ops = &outputs_ops,
+	.mode_ops = &standards_ops,
+};
+
+/*
+ * VENC register I/O Routines
+ */
+static inline u32 venc_reg_in(u32 offset)
+{
+	return omap_readl(DSS_REG_BASE + VENC_REG_OFFSET + offset);
+}
+
+static inline u32 venc_reg_out(u32 offset, u32 val)
+{
+	omap_writel(val, DSS_REG_BASE + VENC_REG_OFFSET + offset);
+	return val;
+}
+
+static inline u32 venc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr = DSS_REG_BASE + VENC_REG_OFFSET + offset;
+	u32 new_val = (omap_readl(addr) & ~mask) | (val & mask);
+
+	omap_writel(new_val, addr);
+	return new_val;
+}
+
+int tv_initialize(void *data)
+{
+	return 0;
+}
+
+int tv_deinitialize(void *data)
+{
+	return 0;
+}
+
+static void config_venc(struct tv_standard_config *tvstd)
+{
+	int i;
+
+	i = 0;
+	/*
+	 * Write 1 to the 8th bit of the F_Control register to reset the VENC
+	 */
+	venc_reg_merge(VENC_F_CONTROL, VENC_FCONTROL_RESET,
+			VENC_FCONTROL_RESET);
+	/* wait for reset to complete */
+	while ((venc_reg_in(VENC_F_CONTROL) & VENC_FCONTROL_RESET) ==
+			0x00000100) {
+		udelay(10);
+		if (i++ > 10)
+			break;
+	}
+
+	if (venc_reg_in(VENC_F_CONTROL) & VENC_FCONTROL_RESET) {
+		printk(KERN_WARNING
+				"omap_disp: timeout waiting for venc reset\n");
+		/* remove the reset */
+		venc_reg_merge(VENC_F_CONTROL, (0 << 8),
+				VENC_FCONTROL_RESET);
+	}
+
+	venc_reg_out(VENC_LLEN, tvstd->venc_llen);
+	venc_reg_out(VENC_FLENS, tvstd->venc_flens);
+	venc_reg_out(VENC_HFLTR_CTRL, tvstd->venc_hfltr_ctrl);
+	venc_reg_out(VENC_CC_CARR_WSS_CARR, tvstd->venc_cc_carr_wss_carr);
+	venc_reg_out(VENC_C_PHASE, tvstd->venc_c_phase);
+	venc_reg_out(VENC_GAIN_U, tvstd->venc_gain_u);
+	venc_reg_out(VENC_GAIN_V, tvstd->venc_gain_v);
+	venc_reg_out(VENC_GAIN_Y, tvstd->venc_gain_y);
+	venc_reg_out(VENC_BLACK_LEVEL, tvstd->venc_black_level);
+	venc_reg_out(VENC_BLANK_LEVEL, tvstd->venc_blank_level);
+	venc_reg_out(VENC_X_COLOR, tvstd->venc_x_color);
+	venc_reg_out(VENC_M_CONTROL, tvstd->venc_m_control);
+	venc_reg_out(VENC_BSTAMP_WSS_DATA, tvstd->venc_bstamp_wss_data);
+	venc_reg_out(VENC_S_CARR, tvstd->venc_s_carr);
+	venc_reg_out(VENC_LINE21, tvstd->venc_line21);
+	venc_reg_out(VENC_LN_SEL, tvstd->venc_ln_sel);
+	venc_reg_out(VENC_L21_WC_CTL, tvstd->venc_l21_wc_ctl);
+	venc_reg_out(VENC_HTRIGGER_VTRIGGER,
+			tvstd->venc_htrigger_vtrigger);
+	venc_reg_out(VENC_SAVID_EAVID, tvstd->venc_savid_eavid);
+	venc_reg_out(VENC_FLEN_FAL, tvstd->venc_flen_fal);
+	venc_reg_out(VENC_LAL_PHASE_RESET, tvstd->venc_lal_phase_reset);
+	venc_reg_out(VENC_HS_INT_START_STOP_X,
+			tvstd->venc_hs_int_start_stop_x);
+	venc_reg_out(VENC_HS_EXT_START_STOP_X,
+			tvstd->venc_hs_ext_start_stop_x);
+	venc_reg_out(VENC_VS_INT_START_X, tvstd->venc_vs_int_start_x);
+	venc_reg_out(VENC_VS_INT_STOP_X_VS_INT_START_Y,
+			tvstd->venc_vs_int_stop_x_vs_int_start_y);
+	venc_reg_out(VENC_VS_INT_STOP_Y_VS_EXT_START_X,
+			tvstd->venc_vs_int_stop_y_vs_ext_start_x);
+	venc_reg_out(VENC_VS_EXT_STOP_X_VS_EXT_START_Y,
+			tvstd->venc_vs_ext_stop_x_vs_ext_start_y);
+	venc_reg_out(VENC_VS_EXT_STOP_Y, tvstd->venc_vs_ext_stop_y);
+	venc_reg_out(VENC_AVID_START_STOP_X,
+			tvstd->venc_avid_start_stop_x);
+	venc_reg_out(VENC_AVID_START_STOP_Y,
+			tvstd->venc_avid_start_stop_y);
+	venc_reg_out(VENC_FID_INT_START_X_FID_INT_START_Y,
+			tvstd->venc_fid_int_start_x_fid_int_start_y);
+	venc_reg_out(VENC_FID_INT_OFFSET_Y_FID_EXT_START_X,
+			tvstd->venc_fid_int_offset_y_fid_ext_start_x);
+	venc_reg_out(VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y,
+			tvstd->venc_fid_ext_start_y_fid_ext_offset_y);
+	venc_reg_out(VENC_TVDETGP_INT_START_STOP_X,
+			tvstd->venc_tvdetgp_int_start_stop_x);
+	venc_reg_out(VENC_TVDETGP_INT_START_STOP_Y,
+			tvstd->venc_tvdetgp_int_start_stop_y);
+	venc_reg_out(VENC_GEN_CTRL, tvstd->venc_gen_ctrl);
+	venc_reg_out(VENC_DAC_TST, tvstd->venc_dac_tst);
+	venc_reg_out(VENC_DAC, venc_reg_in(VENC_DAC));
+	venc_reg_out(VENC_F_CONTROL, F_CONTROL_GEN);
+	venc_reg_out(VENC_SYNC_CONTROL, SYNC_CONTROL_GEN);
+}
+
+int omap_venc_setstd(char *mode_name, void *data)
+{
+	int i;
+	struct omap_encoder_device *enc_dev;
+
+	enc_dev = (struct omap_encoder_device *) data;
+
+	if (!mode_name)
+		return -1;
+	for (i = 0; i < ARRAY_SIZE(tv_standards); i++) {
+		if (!(strcmp(tv_standards[i].std_name, mode_name))) {
+			outputs[enc_dev->current_output].current_mode = i;
+			config_venc(&tv_standards[i]);
+			return 0;
+		}
+	}
+	return -1;
+
+}
+
+char *omap_venc_getstd(void *data)
+{
+	int mode_index;
+	struct omap_encoder_device *enc_dev =
+			(struct omap_encoder_device *) data;
+
+	mode_index = outputs[enc_dev->current_output].current_mode;
+	return tv_standards[mode_index].std_name;
+}
+
+int omap_venc_setoutput(int index, char *mode_name, void *data)
+{
+	struct omap_encoder_device *enc_dev =
+			(struct omap_encoder_device *)data;
+	u32 current_mode;
+
+	enc_dev->current_output = index;
+	current_mode = outputs[enc_dev->current_output].current_mode;
+	config_venc(&tv_standards[current_mode]);
+	strcpy(mode_name, tv_standards[current_mode].std_name);
+
+	return 0;
+}
+
+char *omap_venc_enumoutput(int index, void *data)
+{
+	return outputs[index].name;
+}
+
+static int tv_in_use;
+
+static void tvout_off(struct work_struct *work);
+static void tvout_on(struct work_struct *work);
+
+DECLARE_WORK(work_q_tvout_on, tvout_on);
+DECLARE_WORK(work_q_tvout_off, tvout_off);
+
+static void power_tv(int level)
+{
+	switch (level) {
+	case TV_OFF:
+		if (!in_interrupt())
+			tvout_off(NULL);
+		else
+			schedule_work(&work_q_tvout_off);
+		break;
+	default:
+		if (!in_interrupt())
+			tvout_on(NULL);
+		else
+			schedule_work(&work_q_tvout_on);
+		break;
+	}
+}
+
+static void tvout_off(struct work_struct *work)
+{
+#if defined(CONFIG_MACH_OMAP_H4) || defined(CONFIG_TWL4030_CORE_M1)
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	/*
+	 * Turn OFF TV block (AVDD and VREF) in menelaus chip
+	 * MENELAUS_LDO_CTRL8 (0x11 -> 0x03)
+	 */
+	adap = i2c_get_adapter(MENELAUS_I2C_ADAP_ID);
+	if (!adap)
+		printk(KERN_ERR DRIVER "Unable to get I2C adapter \n");
+	msg->addr = 0x72;	/* I2C address of Menelaus Chip */
+	msg->flags = 0;
+	msg->len = 2;
+	msg->buf = data;
+	data[0] = 0x11;		/* LD0_CTRL8 */
+	data[1] = 0x00;		/* Disable bits for the 0.5V reference LDO */
+	err = i2c_transfer(adap, msg, 1);
+	if (err > 2) {
+		printk(KERN_ERR DRIVER
+		       "Disabling TV block through Menelaus failed %d\n",
+		       err);
+	}
+#endif
+	omap_disp_set_tvref(TVREF_OFF);
+
+#if (defined(CONFIG_TWL4030_CORE_T2) && defined(CONFIG_I2C_TWL4030_CORE))  \
+		|| defined(CONFIG_MACH_OMAP_3430LABRADOR) \
+		|| defined(CONFIG_MACH_OMAP3EVM)
+	omap_disp_set_tvref(TVREF_OFF);
+	twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0x00,
+			     TWL4030_VDAC_DEDICATED);
+	twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0x00,
+			     TWL4030_VDAC_DEV_GRP);
+#endif
+}
+
+static void tvout_on(struct work_struct *work)
+{
+#if defined(CONFIG_MACH_OMAP_H4) || defined(CONFIG_TWL4030_CORE_M1)
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	/*
+	 * Turn ON TV block (AVDD and VREF) in menelaus chip
+	 * MENELAUS_LDO_CTRL8 (0x11 -> 0x03)
+	 */
+	adap = i2c_get_adapter(MENELAUS_I2C_ADAP_ID);
+	if (!adap)
+		printk(KERN_ERR DRIVER "Unable to get I2C adapter \n");
+	msg->addr = 0x72;	/* I2C address of Menelaus Chip */
+	msg->flags = 0;
+	msg->len = 2;
+	msg->buf = data;
+	data[0] = 0x11;		/* LD0_CTRL8 */
+	data[1] = 0x03;		/* Enable bits for the 0.5V reference
+				 * and the VADAC LDO
+				 */
+	err = i2c_transfer(adap, msg, 1);
+	if (err > 2) {
+		printk(KERN_ERR DRIVER
+		       "Enabling TV block through Menelaus failed %d\n",
+		       err);
+	}
+#endif
+	omap_disp_set_tvref(TVREF_ON);
+#if (defined(CONFIG_TWL4030_CORE_T2) && defined(CONFIG_I2C_TWL4030_CORE)) \
+		|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
+	omap_disp_set_tvref(TVREF_ON);
+
+	twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+			     ENABLE_VDAC_DEDICATED,
+			     TWL4030_VDAC_DEDICATED);
+	twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+			     ENABLE_VDAC_DEV_GRP, TWL4030_VDAC_DEV_GRP);
+#endif
+}
+
+static int tv_init(void)
+{
+	omap_disp_get_all_clks();
+	power_tv(TV_ON);
+	omap_disp_enable_output_dev(OMAP_OUTPUT_TV);
+	omap_disp_put_all_clks();
+	printk(KERN_DEBUG "TV %dx%d interlaced\n", H4_TV_XRES, H4_TV_YRES);
+	tv_in_use = 1;
+	if (omap_register_encoder(&tv_enc))
+		return -1;
+
+	return 0;
+}
+
+static int tv_exit(void)
+{
+	if (!tv_in_use)
+		return 0;
+
+	omap_disp_get_all_clks();
+	omap_disp_disable_output_dev(OMAP_OUTPUT_TV);
+	power_tv(TV_OFF);
+	omap_disp_put_all_clks();
+	tv_in_use = 0;
+	return 0;
+}
+
+static int __init tv_probe(struct platform_device *odev);
+#ifdef CONFIG_PM
+static int tv_suspend(struct platform_device *odev, pm_message_t state);
+static int tv_resume(struct platform_device *odev);
+#endif
+
+static struct platform_driver omap_tv_driver = {
+	.driver = {
+		   .name = OMAP_TV_DRIVER,
+		   },
+	.probe = tv_probe,
+#ifdef CONFIG_PM
+	.suspend = tv_suspend,
+	.resume = tv_resume,
+#endif
+};
+
+static struct platform_device tv_device = {
+	.name = OMAP_TV_DEVICE,
+	.id = 10,
+};
+
+static int __init tv_probe(struct platform_device *odev)
+{
+	return tv_init();
+}
+
+#ifdef CONFIG_PM
+static int tv_suspend(struct platform_device *odev, pm_message_t state)
+{
+	if (!tv_in_use)
+		return 0;
+
+	/* TODO-- need to delink DSS and TV clocks.. For now, TV is put to
+	 * off in fb_blank and put_dss */
+
+	tv_in_use = 0;
+
+	return 0;
+}
+
+static int tv_resume(struct platform_device *odev)
+{
+	if (tv_in_use)
+		return 0;
+
+	/* TODO-- need to delink DSS and TV clocks.. For now, TV is put to
+	 * on in fb_blank and get_dss */
+	tv_in_use = 1;
+	return 0;
+}
+
+#endif				/* CONFIG_PM */
+
+static int __init omap_tv_init(void)
+{
+	/* Register the driver with LDM */
+	if (platform_driver_register(&omap_tv_driver)) {
+		printk(KERN_ERR ": failed to register omap_tv driver\n");
+		return -ENODEV;
+	}
+	/* Register the device with LDM */
+	if (platform_device_register(&tv_device)) {
+		printk(KERN_ERR ": failed to register tv device\n");
+		platform_driver_unregister(&omap_tv_driver);
+		return -ENODEV;
+	}
+	return 0;
+
+}
+
+device_initcall(omap_tv_init);
+
+static void __exit
+omap_tv_exit(void)
+{
+
+	tv_exit();
+	platform_device_unregister(&tv_device);
+	platform_driver_unregister(&omap_tv_driver);
+}
+module_exit(omap_tv_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index f914577..4c5af13 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -762,7 +762,7 @@ source "drivers/media/video/au0828/Kconfig"
 
 source "drivers/media/video/ivtv/Kconfig"
 
-source drivers/media/video/omap/Kconfig
+source "drivers/media/video/omap/Kconfig"
 
 source "drivers/media/video/cx18/Kconfig"
 
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 3e580e8..cecdf98 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -97,6 +97,7 @@ obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
 
 obj-$(CONFIG_VIDEO_M32R_AR_M64278) += arv.o
 obj-$(CONFIG_VIDEO_OMAP_CAMERA) += omap/
+obj-$(CONFIG_VIDEO_OMAP3) += omap/
 
 obj-$(CONFIG_VIDEO_CX25840) += cx25840/
 obj-$(CONFIG_VIDEO_UPD64031A) += upd64031a.o
diff --git a/drivers/media/video/omap/Kconfig b/drivers/media/video/omap/Kconfig
index c8d1f4c..2a539f6 100644
--- a/drivers/media/video/omap/Kconfig
+++ b/drivers/media/video/omap/Kconfig
@@ -5,3 +5,22 @@ config VIDEO_OMAP_CAMERA
 	depends on VIDEO_DEV && (ARCH_OMAP16XX || ARCH_OMAP24XX)
 	help
 	  V4L2 camera driver support for OMAP1/2 based boards.
+
+config VIDEO_OMAP3
+	tristate "OMAP2/OMAP3 V4L2 drivers"
+	depends on VIDEO_DEV && (ARCH_OMAP24XX || ARCH_OMAP34XX)
+	help
+	  V4L2 DSS driver support for OMAP2/3 based boards.
+
+config VIDEO_OMAP_VIDEOLIB
+	tristate "Video out library"
+	depends on VIDEO_OMAP3
+	default VIDEO_OMAP3
+
+config VIDEO_OMAP_VIDEOOUT
+	tristate "Video out driver"
+	select VIDEOBUF_DMA_SG
+	select VIDEOBUF_GEN
+	depends on VIDEO_OMAP3
+	default VIDEO_OMAP3
+
diff --git a/drivers/media/video/omap/Makefile b/drivers/media/video/omap/Makefile
index 9b4a998..5d567a8 100644
--- a/drivers/media/video/omap/Makefile
+++ b/drivers/media/video/omap/Makefile
@@ -4,6 +4,9 @@ obj-$(CONFIG_VIDEO_OMAP_CAMERA) += omapcamera.o
 
 objs-y$(CONFIG_ARCH_OMAP16XX) += omap16xxcam.o camera_core.o
 
+obj-$(CONFIG_VIDEO_OMAP_VIDEOLIB) += omap_voutlib.o
+obj-$(CONFIG_VIDEO_OMAP_VIDEOOUT) += omap_vout.o
+
 omapcamera-objs := $(objs-yy)
 
 EXTRA_CFLAGS = -I$(src)/..
diff --git a/drivers/media/video/omap/omap_vout.c b/drivers/media/video/omap/omap_vout.c
new file mode 100644
index 0000000..da3c05b
--- /dev/null
+++ b/drivers/media/video/omap/omap_vout.c
@@ -0,0 +1,3527 @@
+/*
+ * drivers/media/video/omap2/omap_display.c
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Leveraged code from the OMAP2 camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * History:
+ * 20-APR-2006	Khasim		Modified VRFB based Rotation,
+ *				The image data is always read from 0 degree
+ *				view and written
+ *				to the virtual space of desired rotation angle
+ * 4-DEC-2006 Jian		Changed to support better memory management
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <media/videobuf-dma-sg.h>
+#include <linux/input.h>
+#include <linux/dma-mapping.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-dev.h>
+
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+#ifdef CONFIG_DPM
+#include <linux/dpm.h>
+#endif
+
+#include <mach/omap-dss.h>
+
+#include <linux/io.h>
+#include <asm/byteorder.h>
+#include <linux/irq.h>
+#include <linux/semaphore.h>
+#include <asm/processor.h>
+#include <mach/dma.h>
+
+#include "omap_voutlib.h"
+
+/*
+ * Un-comment this to use Debug Write call
+ */
+/* #define DEBUG_ALLOW_WRITE */
+
+#include "omap_voutdef.h"
+
+unsigned long timeout;
+
+/*
+ * Uncomment this if debugging support needs to be enabled
+ */
+
+/* #define DEBUG */
+
+#undef DEBUG
+#ifdef DEBUG
+#define DPRINTK(ARGS...)  (printk(KERN_DEBUG "<%s>: ", __func__); \
+				printk(KERN_DEBUG ARGS))
+#else
+#define DPRINTK(x...)
+#endif
+
+/*
+ * -1 means rotation support is disabled
+ * 0/90/180/270 are initial rotation angles
+ */
+
+static int rotation_support = -1;
+
+/* configuration macros */
+#define VOUT_NAME		"omap_vout"
+#define V1OUT_NAME		"omap_vout1"
+#define V2OUT_NAME		"omap_vout2"
+
+#define D1_PAL_WIDTH		720
+#define D1_PAL_HEIGHT		576
+#define QQVGA_WIDTH			160
+#define QQVGA_HEIGHT		120
+
+#define DMA_CHAN_ALLOTED	1
+#define DMA_CHAN_NOT_ALLOTED	0
+#define NUM_OF_VIDEO_CHANNELS	2
+#define VRF_SIZE		(MAX_PIXELS_PER_LINE * MAX_LINES * 4)
+#define SMS_RGB_PIXSIZE		2
+#define SMS_YUYV_PIXSIZE	4
+#define VRFB_TX_TIMEOUT		1000
+
+#define VID_MAX_WIDTH		D1_PAL_WIDTH	/* Largest width */
+#define VID_MAX_HEIGHT		D1_PAL_HEIGHT	/* Largest height */
+#define VID_MIN_WIDTH		0
+#define VID_MIN_HEIGHT		0
+
+#define OMAP_VOUT_MAX_BUF_SIZE (VID_MAX_WIDTH*VID_MAX_HEIGHT*4)
+#define OMAP_VOUT_VIDEO1_SMS_START	(0xE0000000)
+#define OMAP_VOUT_VIDEO2_SMS_START	(0xF0000000)
+
+static struct omap_vout_device *saved_v1out, *saved_v2out;
+
+#define STREAMING_IS_ON()	((saved_v1out && saved_v1out->streaming) || \
+				(saved_v2out && saved_v2out->streaming))
+
+/*
+ * this is the layer being linked to (slave layer). possible values are:
+ * OMAP_VIDEO1:  V1 is linked to V2. V1 uses V2's pix and crop.
+ * OMAP_VIDEO2:  V2 is linked to V1. V2 uses V1's pix and crop.
+ * -1: no link.
+ */
+
+static int vout_linked;
+static spinlock_t vout_link_lock;
+
+static struct videobuf_queue_ops video_vbq_ops;
+
+static u32 video1_numbuffers = 3;
+static u32 video2_numbuffers = 3;
+static u32 video1_bufsize = OMAP_VOUT_MAX_BUF_SIZE;
+static u32 video2_bufsize = OMAP_VOUT_MAX_BUF_SIZE;
+module_param(video1_numbuffers, uint, S_IRUGO);
+module_param(video2_numbuffers, uint, S_IRUGO);
+module_param(video1_bufsize, uint, S_IRUGO);
+module_param(video2_bufsize, uint, S_IRUGO);
+
+static void omap_vout_isr(void *arg, struct pt_regs *regs,
+		      unsigned int irqstatus);
+/* module parameters */
+
+/*
+ * Maximum amount of memory to use for rendering buffers.
+ * Default is enough to four (RGB24) VGA buffers.
+ */
+#define MAX_ALLOWED_VIDBUFFERS            4
+
+/* list of image formats supported by OMAP2 video pipelines */
+const static struct v4l2_fmtdesc omap_formats[] = {
+	{
+	 /* Note:  V4L2 defines RGB565 as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      g2 g1 g0 r4 r3 r2 r1 r0   b4 b3 b2 b1 b0 g5 g4 g3
+	  *
+	  * We interpret RGB565 as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      g2 g1 g0 b4 b3 b2 b1 b0   r4 r3 r2 r1 r0 g5 g4 g3
+	  */
+	 .description = "RGB565, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB565,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB565X as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      b4 b3 b2 b1 b0 g5 g4 g3   g2 g1 g0 r4 r3 r2 r1 r0
+	  *
+	  * We interpret RGB565X as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      r4 r3 r2 r1 r0 g5 g4 g3   g2 g1 g0 b4 b3 b2 b1 b0
+	  */
+	 .description = "RGB565, be",
+	 .pixelformat = V4L2_PIX_FMT_RGB565X,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB32 as: RGB-8-8-8-8  we use
+	  *  this for RGB24 unpack mode, the last 8 bits are ignored
+	  * */
+	 .description = "RGB32, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB32,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB24 as: RGB-8-8-8  we use
+	  *        this for RGB24 packed mode
+	  *
+	  */
+	 .description = "RGB24, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB24,
+	 },
+	{
+	 .description = "YUYV (YUV 4:2:2), packed",
+	 .pixelformat = V4L2_PIX_FMT_YUYV,
+	 },
+	{
+	 .description = "UYVY, packed",
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	 },
+};
+
+#define NUM_OUTPUT_FORMATS (sizeof(omap_formats)/sizeof(omap_formats[0]))
+
+struct omap_vout_std_id_name {
+	v4l2_std_id id;
+	char name[25];
+};
+struct omap_vout_std_id_name id_name[] = {
+	{V4L2_STD_NTSC_M, "ntsc_m"},
+	{V4L2_STD_NTSC_M_JP, "ntsc_j"},
+	{V4L2_STD_NTSC_443, "ntsc_443"},
+	{V4L2_STD_PAL, "pal_bdghi"},
+	{V4L2_STD_PAL_Nc, "pal_nc"},
+	{V4L2_STD_PAL_N, "pal_n"},
+	{V4L2_STD_PAL_M, "pal_m"},
+	{V4L2_STD_PAL_60, "pal_60"},
+};
+
+/* CONFIG_PM */
+#ifdef CONFIG_PM
+#define omap_vout_suspend_lockout(s, f) \
+	if ((s)->suspended) {\
+		if ((f)->f_flags & O_NONBLOCK)\
+			return -EBUSY;\
+		wait_event_interruptible((s)->suspend_wq, \
+					(s)->suspended == 0);\
+	}
+#else
+#define omap_vout_suspend_lockout(s, f) do {(s)->suspended = 0; } while (0)
+#endif
+
+void
+omap_vout_config_vlayer(int ltype, struct v4l2_pix_format *pix,
+			   struct v4l2_rect *crop, struct v4l2_window *win,
+			   int rotation_deg, int mirroring)
+{
+
+	int vid_position_x, vid_position_y, ps = 2, vr_ps = 1;
+	unsigned long vid_attributes = 0;
+	struct omap_scaling_params scale_params;
+	struct omap_video_params vid_params;
+	int winheight, winwidth, cropheight, cropwidth, pixheight,
+	    pixwidth;
+	int cleft, ctop;
+	int panelwidth, panelheight, row_inc_value = 0, pixel_inc_value =
+	    0;
+	int flicker_filter = 0;
+	int output_dev;
+	int v;
+	int full_range_conversion = 0;
+
+	output_dev = omap_disp_get_output_dev(ltype);
+
+	if (ltype == OMAP_VIDEO1)
+		v = 0;
+	else if (ltype == OMAP_VIDEO2)
+		v = 1;
+	else
+		return;
+
+	if ((output_dev == OMAP_OUTPUT_TV) &&
+	    ((win->w.width == crop->width)
+	     && (win->w.height == crop->height)))
+		flicker_filter = 1;
+
+	/* make sure the video overlay is disabled before we reconfigure it */
+	omap_disp_disable_layer(ltype);
+
+	/* configure the video attributes register */
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		if (pix->pixelformat == V4L2_PIX_FMT_YUYV) {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_YUV2;
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDCOLORCONVENABLE;
+		} else {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_UYVY;
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDCOLORCONVENABLE;
+		}
+
+		if (mirroring == 1 || rotation_deg >= 0) {
+			/*
+			 * ps      - In VRFB space the pixel size for YUYV/UYVY
+			 * is 4 bytes
+			 * vr_ps - Actual pixel size for YUYV/UYVY  is 2 bytes
+			 */
+			ps = 4;
+			vr_ps = 2;
+		}
+		if (rotation_deg >= 0) {
+			if (mirroring == 1) {
+				vid_attributes |= (rotation_deg == 90) ?
+				    ((0x3) << DISPC_VID_ATTRIBUTES_VIDROT)
+				    : (rotation_deg ==
+				       270) ? ((0x1) <<
+					       DISPC_VID_ATTRIBUTES_VIDROT)
+				    : (rotation_deg ==
+				       0) ? (0x2 <<
+					     DISPC_VID_ATTRIBUTES_VIDROT)
+				    : (0 << DISPC_VID_ATTRIBUTES_VIDROT);
+			} else {
+				vid_attributes |= (rotation_deg == 90) ?
+				    ((0x3) << DISPC_VID_ATTRIBUTES_VIDROT)
+				    : (rotation_deg ==
+				       270) ? ((0x1) <<
+					       DISPC_VID_ATTRIBUTES_VIDROT)
+				    : ((rotation_deg /
+					90) <<
+				       DISPC_VID_ATTRIBUTES_VIDROT);
+			}
+			vid_attributes |= (rotation_deg == 90
+					   || rotation_deg ==
+					   270) ? (1 <<
+					   DISPC_VID_ATTRIBUTES_VIDROWREPEAT)
+			    : (0 << DISPC_VID_ATTRIBUTES_VIDROWREPEAT);
+		}
+		if (mirroring == 1 && rotation_deg == -1) {
+			vid_attributes |=
+			    (0x2 << DISPC_VID_ATTRIBUTES_VIDROT);
+		}
+
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		ps = 3;		/* pixel size is 3 bytes */
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB24P;
+		break;
+
+		/* The picture format is a bit confusing in V4L2.. as per
+		 * the V4L2 spec RGB32 and BGR32 are always with alpha bit
+		 * enabled.. (i.e always in packed mode) */
+	case V4L2_PIX_FMT_RGB32:
+		ps = 4;		/* pixel size is 4 bytes */
+		if ((is_sil_rev_less_than(OMAP3430_REV_ES2_0))
+		    || (ltype == OMAP_VIDEO1)) {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB24;
+		} else {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_ARGB32;
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDENDIANNESS;
+		}
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		ps = 4;		/* pixel size is 4 bytes */
+		if ((is_sil_rev_less_than(OMAP3430_REV_ES2_0))
+		    || (ltype == OMAP_VIDEO1)) {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB24;
+		} else {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDFORMAT_ARGB32;
+		}
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	default:
+		ps = 2;		/* pixel size is 2 bytes */
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB16;
+		vid_attributes |=
+		    DISPC_VID_ATTRIBUTES_VIDREPLICATIONENABLE;
+		break;
+	case V4L2_PIX_FMT_RGB565X:
+		ps = 2;		/* pixel size is 2 bytes */
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDFORMAT_RGB16;
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDENDIANNESS;
+		vid_attributes |=
+		    DISPC_VID_ATTRIBUTES_VIDREPLICATIONENABLE;
+		break;
+	}
+
+	if (output_dev == OMAP_OUTPUT_TV)
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDCHANNELOUT;
+
+	/* Enable 16 x 32 burst size */
+	vid_attributes |= DISPC_VID_ATTRIBUTES_VIDBURSTSIZE_BURST16X32;
+
+	/* Set FIFO */
+	omap_disp_set_fifothreshold(v);
+
+	if (pix->colorspace == V4L2_COLORSPACE_JPEG ||
+	    pix->colorspace == V4L2_COLORSPACE_SRGB) {
+		full_range_conversion = 1;
+	}
+	/* Set the color converion parameters */
+	omap_disp_set_colorconv(v, full_range_conversion);
+
+	if (rotation_deg == 90 || rotation_deg == 270) {
+		winheight = win->w.width;
+		winwidth = win->w.height;
+		cropheight = crop->width;
+		cropwidth = crop->height;
+		pixheight = pix->width;
+		pixwidth = pix->height;
+		cleft = crop->top;
+		ctop = crop->left;
+	} else {
+		winwidth = win->w.width;
+		winheight = win->w.height;
+		cropwidth = crop->width;
+		cropheight = crop->height;
+		pixheight = pix->height;
+		pixwidth = pix->width;
+		ctop = crop->top;
+		cleft = crop->left;
+	}
+
+	if (winwidth != cropwidth) {
+		vid_attributes |=
+		    DISPC_VID_ATTRIBUTES_VIDRESIZEENABLE_HRESIZE;
+	}
+	if (winheight != cropheight) {
+		vid_attributes |=
+		    DISPC_VID_ATTRIBUTES_VIDRESIZEENABLE_VRESIZE;
+		if (winheight < cropheight) {
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDVRESIZECONF;
+		} else {
+			/* Use Five tap filter for vertical up scaling */
+			vid_attributes |=
+			    DISPC_VID_ATTRIBUTES_VIDVERTICALTAPS;
+		}
+	}
+
+	if (flicker_filter == 1) {
+		vid_attributes |=
+		    DISPC_VID_ATTRIBUTES_VIDRESIZEENABLE_VRESIZE;
+		vid_attributes |= DISPC_VID_ATTRIBUTES_VIDVRESIZECONF;
+	}
+	omap_disp_set_vidattributes(v, vid_attributes);
+
+	scale_params.win_width = winwidth;
+	scale_params.crop_width = cropwidth;
+	scale_params.win_height = winheight;
+	scale_params.crop_height = cropheight;
+	scale_params.flicker_filter = flicker_filter;
+	scale_params.video_layer = v;
+	omap_disp_set_scaling(&scale_params);
+
+	omap_disp_get_panel_size(output_dev, &panelwidth, &panelheight);
+
+	/* configure the target window on the display */
+	switch (rotation_deg) {
+
+	case 90:
+		vid_position_y =
+		    (panelheight - win->w.width) - win->w.left;
+		vid_position_x = win->w.top;
+		break;
+
+	case 180:
+		vid_position_x = (panelwidth - win->w.width) - win->w.left;
+		vid_position_y =
+		    (panelheight - win->w.height) - win->w.top;
+		break;
+
+	case 270:
+		vid_position_y = win->w.left;
+		vid_position_x = (panelwidth - win->w.height) - win->w.top;
+		break;
+
+	default:
+		vid_position_x = win->w.left;
+		vid_position_y = win->w.top;
+		break;
+	}
+
+	if (output_dev == OMAP_OUTPUT_TV)
+		vid_position_y = vid_position_y / 2;
+
+	vid_params.vid_position =
+	    ((vid_position_x << DISPC_VID_POSITION_VIDPOSX_SHIFT) &
+	     DISPC_VID_POSITION_VIDPOSX) | ((vid_position_y <<
+					     DISPC_VID_POSITION_VIDPOSY_SHIFT)
+					    & DISPC_VID_POSITION_VIDPOSY);
+
+	/*
+	 * If Scaling is enabled for TV then the window height should be
+	 * divided by two
+	 */
+	if (((output_dev == OMAP_OUTPUT_TV) &&
+	     (winheight != cropheight)) || flicker_filter) {
+		vid_params.vid_size =
+		    (((winwidth - 1) << DISPC_VID_SIZE_VIDSIZEX_SHIFT)
+		     & DISPC_VID_SIZE_VIDSIZEX)
+		    |
+		    ((((winheight -
+			1) / 2) << DISPC_VID_SIZE_VIDSIZEY_SHIFT)
+		     & DISPC_VID_SIZE_VIDSIZEY);
+	} else {
+		vid_params.vid_size =
+		    (((winwidth - 1) << DISPC_VID_SIZE_VIDSIZEX_SHIFT)
+		     & DISPC_VID_SIZE_VIDSIZEX)
+		    | (((winheight - 1) << DISPC_VID_SIZE_VIDSIZEY_SHIFT)
+		       & DISPC_VID_SIZE_VIDSIZEY);
+#ifdef DMA_DECIMATE
+		vid_params.vid_size =
+		    (((winwidth - 1) / 2 << DISPC_VID_SIZE_VIDSIZEX_SHIFT)
+		     & DISPC_VID_SIZE_VIDSIZEX)
+		    |
+		    ((((winheight -
+			1) / 2) << DISPC_VID_SIZE_VIDSIZEY_SHIFT)
+		     & DISPC_VID_SIZE_VIDSIZEY);
+#endif
+	}
+
+	/* configure the source window in the framebuffer */
+	if (flicker_filter == 1) {
+		vid_params.vid_picture_size =
+		    (((cropwidth -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEX_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEX)
+		    | (((cropheight - 1)
+			<< DISPC_VID_PICTURE_SIZE_VIDORGSIZEY_SHIFT)
+		       & DISPC_VID_PICTURE_SIZE_VIDORGSIZEY);
+	} else if ((output_dev == OMAP_OUTPUT_TV)
+		   && (flicker_filter == 0)) {
+		vid_params.vid_picture_size =
+		    (((cropwidth -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEX_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEX) |
+		    (((cropheight / 2 -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEY_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEY);
+	} else {
+		vid_params.vid_picture_size =
+		    (((cropwidth -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEX_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEX) |
+		    (((cropheight -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEY_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEY);
+#ifdef DMA_DECIMATE
+		vid_params.vid_picture_size =
+		    (((cropwidth / 2 -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEX_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEX) |
+		    (((cropheight / 2 -
+		       1) << DISPC_VID_PICTURE_SIZE_VIDORGSIZEY_SHIFT)
+		     & DISPC_VID_PICTURE_SIZE_VIDORGSIZEY);
+#endif
+	}
+	vid_params.video_layer = v;
+	omap_disp_set_vid_params(&vid_params);
+
+	switch (mirroring) {
+	case 0:		/* No mirroring */
+		if (rotation_deg == 90 || rotation_deg == 270) {
+			row_inc_value =
+			    1 + (MAX_PIXELS_PER_LINE - pixwidth +
+				 (pixwidth - cropwidth - cleft) +
+				 cleft) * ps;
+
+		} else if (rotation_deg == 180 || rotation_deg == 0) {
+			if (V4L2_PIX_FMT_YUYV == pix->pixelformat
+			    || V4L2_PIX_FMT_UYVY == pix->pixelformat)
+				row_inc_value =
+				    1 + (MAX_PIXELS_PER_LINE -
+					 (pixwidth / vr_ps) +
+					 ((pixwidth - cropwidth -
+					   cleft) / vr_ps) +
+					 (cleft / vr_ps)) * ps;
+
+			else
+				row_inc_value =
+				    1 + (MAX_PIXELS_PER_LINE - pixwidth +
+					 (pixwidth - cropwidth - cleft) +
+					 cleft) * ps;
+#ifdef DMA_DECIMATE
+			row_inc_value =
+			    row_inc_value + (MAX_PIXELS_PER_LINE * ps);
+#endif
+		} else {
+			row_inc_value =
+			    1 + (pix->width * ps) - cropwidth * ps;
+#ifdef DMA_DECIMATE
+			row_inc_value =
+			    row_inc_value + ((pix->width + 1) * ps);
+#endif
+		}
+		pixel_inc_value = 1;
+#ifdef DMA_DECIMATE
+		pixel_inc_value = 1 + (1 * ps);
+#endif
+		break;
+
+	case 1:		/* Mirroring */
+		if (rotation_deg == 90 || rotation_deg == 270) {
+			row_inc_value =
+			    (-(MAX_PIXELS_PER_LINE + cropwidth) * ps) + 1;
+			pixel_inc_value = 1;
+		} else if (rotation_deg == 180 || rotation_deg == 0) {
+			row_inc_value =
+			    (-(MAX_PIXELS_PER_LINE + (cropwidth / vr_ps)) *
+			     ps) + 1;
+			pixel_inc_value = 1;
+		} else {
+			row_inc_value =
+			    2 * ((cropwidth / vr_ps) -
+				 1) * ps + 1 +
+			    ((pix->width * ps) / vr_ps) -
+			    (cropwidth / vr_ps) * ps;
+			pixel_inc_value = (-2 * ps) + 1;
+		}
+		break;
+	}			/* Mirroring Switch */
+
+	/*
+	 * For LCD row inc and pixel inc
+	 */
+	omap_disp_set_dma_params(ltype, OMAP_OUTPUT_LCD,
+				  0, 0, row_inc_value, pixel_inc_value);
+
+	if (output_dev == OMAP_OUTPUT_LCD || flicker_filter == 1) {
+		omap_disp_set_row_pix_inc_values(v, row_inc_value,
+						  pixel_inc_value);
+	}
+	/*
+	 * For TV the row increment should be done twice as the
+	 * TV operates in interlaced mode
+	 */
+	else {
+		if (rotation_deg >= 0) {
+			if (mirroring == 1)
+				row_inc_value =
+				    row_inc_value -
+				    MAX_PIXELS_PER_LINE * ps;
+			else
+				row_inc_value =
+				    row_inc_value +
+				    MAX_PIXELS_PER_LINE * ps;
+		} else {
+			if (mirroring == 1)
+				row_inc_value =
+				    row_inc_value +
+				    pix->width * ps / vr_ps;
+			else
+				row_inc_value =
+				    row_inc_value + pix->width * ps;
+		}
+		omap_disp_set_row_pix_inc_values(v, row_inc_value,
+						  pixel_inc_value);
+	}
+	/*
+	 * Store BA0 BA1 for TV, BA1 points to the alternate row
+	 */
+	if (flicker_filter == 1) {
+		;
+	} else if (rotation_deg >= 0) {
+		if (mirroring == 1)
+			row_inc_value =
+			    row_inc_value - MAX_PIXELS_PER_LINE * ps;
+		else
+			row_inc_value =
+			    row_inc_value + MAX_PIXELS_PER_LINE * ps;
+	} else {
+		if (mirroring == 1)
+			row_inc_value =
+			    row_inc_value + pix->width * ps / vr_ps;
+		else
+			row_inc_value = row_inc_value + pix->width * ps;
+
+	}
+	omap_disp_set_dma_params(ltype, OMAP_OUTPUT_TV,
+				  0, 0, row_inc_value, pixel_inc_value);
+
+	omap_set_crop_layer_parameters(v, cropwidth, cropheight);
+
+	omap_disp_save_initstate(ltype);
+
+}
+
+static unsigned long
+omap_vout_alloc_buffer(u32 buf_size, u32 *phys_addr)
+{
+	unsigned long virt_addr, addr;
+	u32 order, size;
+	size = PAGE_ALIGN(buf_size);
+	order = get_order(size);
+	virt_addr = __get_free_pages(GFP_KERNEL | GFP_DMA, order);
+	addr = virt_addr;
+	if (virt_addr) {
+		while (size > 0) {
+			SetPageReserved(virt_to_page(addr));
+			addr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	*phys_addr = (u32) virt_to_phys((void *) virt_addr);
+	return virt_addr;
+}
+
+static void
+omap_vout_free_buffer(unsigned long virtaddr, u32 phys_addr,
+			 u32 buf_size)
+{
+	unsigned long addr = virtaddr;
+	u32 order, size;
+	size = PAGE_ALIGN(buf_size);
+	order = get_order(size);
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages((unsigned long) virtaddr, order);
+}
+
+static int omap_vout_try_format(struct v4l2_pix_format *pix,
+				struct v4l2_pix_format *def_pix)
+{
+	int ifmt, bpp = 0;
+
+	if (pix->width > VID_MAX_WIDTH)
+		pix->width = VID_MAX_WIDTH;
+	if (pix->height > VID_MAX_HEIGHT)
+		pix->height = VID_MAX_HEIGHT;
+
+	if (pix->width <= VID_MIN_WIDTH)
+		pix->width = def_pix->width;
+	if (pix->height <= VID_MIN_HEIGHT)
+		pix->height = def_pix->height;
+
+	for (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {
+		if (pix->pixelformat == omap_formats[ifmt].pixelformat)
+			break;
+	}
+
+	if (ifmt == NUM_OUTPUT_FORMATS)
+		ifmt = 0;
+
+	pix->pixelformat = omap_formats[ifmt].pixelformat;
+	pix->field = /*V4L2_FIELD_NONE */ V4L2_FIELD_ANY;
+	pix->priv = 0;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	default:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		bpp = YUYV_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB565_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB24_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_BGR32:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB32_BPP;
+		break;
+	}
+	pix->bytesperline = pix->width * bpp;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	return bpp;
+}
+
+/*
+ * omap_vout_uservirt_to_phys: This inline function is used to convert user
+ * space virtual address to physical address.
+ */
+static inline u32 omap_vout_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	vma = find_vma(mm, virtp);
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *) virtp);
+	} else if ((vma) && (vma->vm_flags & VM_IO)
+		   && (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated,
+		   mmaped-to-usermode addresses */
+		physp =
+		    (vma->vm_pgoff << PAGE_SHIFT) + (virtp -
+						     vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp =
+			    __pa(page_address(&pages[0]) +
+				 (virtp & ~PAGE_MASK));
+		} else {
+			printk("omap_vout_uservirt_to_phys:\
+					get_user_pages failed\n");
+			return 0;
+		}
+	}
+
+	return physp;
+}
+
+static void omap_vout_vrfb_dma_tx_callback(int lch, u16 ch_status, void *data)
+{
+	struct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;
+	t->tx_status = 1;
+	wake_up_interruptible(&t->wait);
+}
+
+static void
+omap_vout_sync(struct omap_vout_device *dest,
+		  struct omap_vout_device *src)
+{
+	int rotation = -1;
+
+	if (dest->rotation >= 0)
+		rotation = dest->rotation;
+	/*
+	 * once linked, dest shares src's framebuffer, pix and crop
+	 */
+
+	dest->pix = src->pix;
+	dest->crop = src->crop;
+
+	if (src->streaming)
+		/* make sure the video overlay is disabled before
+		 * we reconfigure it
+		 */
+		omap_vout_config_vlayer(dest->vid, &dest->pix,
+					   &dest->crop, &dest->win,
+					   rotation, dest->mirror);
+
+}
+
+/* Buffer setup function is called by videobuf layer when REQBUF ioctl is
+ * called. This is used to setup buffers and return size and count of
+ * buffers allocated. After the call to this buffer, videobuf layer will
+ * setup buffer queue depending on the size and count of buffers
+ */
+static int
+omap_vout_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			  unsigned int *size)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+	int startindex = 0, i, j;
+	u32 phy_addr = 0, virt_addr = 0;
+
+	if (!vout)
+		return -EINVAL;
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT != q->type)
+		return -EINVAL;
+
+	startindex = (vout->vid == OMAP_VIDEO1) ? video1_numbuffers :
+	    video2_numbuffers;
+	if (V4L2_MEMORY_MMAP == vout->memory && *count < startindex)
+		*count = startindex;
+
+	if (vout->rotation != -1 && *count > 4)
+		*count = 4;
+
+	/* If rotation is enabled, allocate memory for VRFB space also */
+	if (vout->rotation >= 0) {
+		for (i = 0; i < *count; i++) {
+			if (!vout->smsshado_virt_addr[i]) {
+				vout->smsshado_virt_addr[i] =
+				omap_vout_alloc_buffer(vout->
+				smsshado_size,
+				&vout->smsshado_phy_addr[i]);
+			}
+
+			if (!vout->smsshado_virt_addr[i]) {
+				if (V4L2_MEMORY_MMAP == vout->memory
+				    && i >= startindex)
+					break;
+				for (j = 0; j < i; j++) {
+					omap_vout_free_buffer(vout->
+					smsshado_virt_addr[j],
+					 vout->smsshado_phy_addr[j],
+					 vout->smsshado_size);
+					vout->smsshado_virt_addr[j] = 0;
+					vout->smsshado_phy_addr[j] = 0;
+				}
+				*count = 0;
+				return -ENOMEM;
+			}
+
+			memset((void *) vout->smsshado_virt_addr[i], 0,
+			       vout->smsshado_size);
+
+			if (vout->rotation == 90 || vout->rotation == 270) {
+				omap_disp_set_vrfb(vout->vrfb_context[i],
+						    vout->
+						    smsshado_phy_addr[i],
+						    vout->pix.height,
+						    vout->pix.width,
+						    vout->bpp *
+						    vout->vrfb_bpp);
+			} else {
+				omap_disp_set_vrfb(vout->vrfb_context[i],
+						    vout->
+						    smsshado_phy_addr[i],
+						    vout->pix.width,
+						    vout->pix.height,
+						    vout->bpp *
+						    vout->vrfb_bpp);
+			}
+		}
+	}
+
+	if (V4L2_MEMORY_MMAP != vout->memory)
+		return 0;
+
+	*size = vout->buffer_size;
+	startindex = (vout->vid == OMAP_VIDEO1) ? video1_numbuffers :
+	    video2_numbuffers;
+	for (i = startindex; i < *count; i++) {
+		vout->buffer_size = *size;
+
+		virt_addr =
+		    omap_vout_alloc_buffer(vout->buffer_size,
+					      &phy_addr);
+		if (!virt_addr) {
+			if (vout->rotation < 0)
+				break;
+			for (j = i; j < *count; j++) {
+				omap_vout_free_buffer(vout->
+							 smsshado_virt_addr
+							 [j],
+							 vout->
+							 smsshado_phy_addr
+							 [j],
+							 vout->
+							 smsshado_size);
+				vout->smsshado_virt_addr[j] = 0;
+				vout->smsshado_phy_addr[j] = 0;
+			}
+			break;
+		}
+
+		vout->buf_virt_addr[i] = virt_addr;
+		vout->buf_phy_addr[i] = phy_addr;
+	}
+
+	*count = vout->buffer_allocated = i;
+	return 0;
+}
+
+/* This function will be called when VIDIOC_QBUF ioctl is called.
+ * It prepare buffers before give out for the display. This function
+ * user space virtual address into physical address if userptr memory
+ * exchange mechanism is used. If rotation is enabled, it copies entire
+ * buffer into VRFB memory space before giving it to the DSS.
+ */
+static int
+omap_vout_buffer_prepare(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb,
+			    enum v4l2_field field)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+	u32 dest_frame_index = 0, src_element_index = 0;
+	u32 dest_element_index = 0, src_frame_index = 0;
+	u32 elem_count = 0, frame_count = 0, pixsize = 2, mir_rot_deg = 0;
+	struct videobuf_dmabuf *dmabuf = NULL;
+
+	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+		vb->width = vout->pix.width;
+		vb->height = vout->pix.height;
+		vb->size = vb->width * vb->height * vout->bpp;
+		vb->field = field;
+	}
+	vb->state = VIDEOBUF_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == vb->memory) {
+		if (0 == vb->baddr)
+			return -EINVAL;
+		/* Virtual address */
+		/* priv points to struct videobuf_pci_sg_memory. But we went
+		 * pointer to videobuf_dmabuf, which is member of
+		 * videobuf_pci_sg_memory */
+		dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+		dmabuf->vmalloc = (void *) vb->baddr;
+
+		/* Physical address */
+		dmabuf->bus_addr =
+		    (dma_addr_t) omap_vout_uservirt_to_phys(vb->baddr);
+	}
+
+	if (vout->rotation >= 0) {
+		dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+
+		/* If rotation is enabled, copy input buffer into VRFB
+		 * memory space using DMA. We are copying input buffer
+		 * into VRFB memory space of desired angle and DSS will
+		 * read image VRFB memory for 0 degree angle
+		 */
+		pixsize = vout->bpp * vout->vrfb_bpp;
+		/*
+		 * DMA transfer in double index mode
+		 */
+
+		/* Frame index */
+		dest_frame_index = ((MAX_PIXELS_PER_LINE * pixsize) -
+				    (vout->pix.width * vout->bpp)) + 1;
+
+		/* Source and destination parameters */
+		src_element_index = 0;
+		src_frame_index = 0;
+		dest_element_index = 1;
+
+		/* Number of elements per frame */
+		elem_count = vout->pix.width * vout->bpp;
+		frame_count = vout->pix.height;
+		vout->vrfb_dma_tx.tx_status = 0;
+		omap_set_dma_transfer_params(vout->vrfb_dma_tx.dma_ch,
+					     OMAP_DMA_DATA_TYPE_S32,
+					     (elem_count / 4), frame_count,
+					     OMAP_DMA_SYNC_ELEMENT,
+					     vout->vrfb_dma_tx.dev_id,
+					     0x0);
+		/* src_port required only for OMAP1 */
+		omap_set_dma_src_params(vout->vrfb_dma_tx.dma_ch, 0,
+					OMAP_DMA_AMODE_POST_INC,
+					dmabuf->bus_addr,
+					src_element_index,
+					src_frame_index);
+
+		/*set dma source burst mode for VRFB */
+		omap_set_dma_src_burst_mode(vout->vrfb_dma_tx.dma_ch,
+					    OMAP_DMA_DATA_BURST_16);
+
+		if (vout->mirror == 1) {
+			/* Following is used to select appropriate VRFB
+			 * memory space for rotation with mirroring */
+			mir_rot_deg = (vout->rotation == 90) ? (270 / 90) :
+			    (vout->rotation == 270) ? (90 / 90) :
+			    (vout->rotation ==
+			     180) ? (0 / 90) : (180 / 90);
+			/* dest_port required only for OMAP1 */
+			omap_set_dma_dest_params(vout->vrfb_dma_tx.dma_ch, 0,
+						 OMAP_DMA_AMODE_DOUBLE_IDX,
+						 vout->sms_rot_phy[vb->
+								   i]
+						 [mir_rot_deg],
+						 dest_element_index,
+						 dest_frame_index);
+		} else {	/* No Mirroring */
+			/* dest_port required only for OMAP1 */
+			omap_set_dma_dest_params(vout->vrfb_dma_tx.dma_ch, 0,
+						 OMAP_DMA_AMODE_DOUBLE_IDX,
+						 vout->sms_rot_phy[vb->
+								   i]
+						 [vout->rotation / 90],
+						 dest_element_index,
+						 dest_frame_index);
+		}
+
+		/*set dma dest burst mode for VRFB */
+		omap_set_dma_dest_burst_mode(vout->vrfb_dma_tx.dma_ch,
+					     OMAP_DMA_DATA_BURST_16);
+		omap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);
+
+		omap_start_dma(vout->vrfb_dma_tx.dma_ch);
+		interruptible_sleep_on_timeout(&vout->vrfb_dma_tx.wait,
+					       VRFB_TX_TIMEOUT);
+
+		if (vout->vrfb_dma_tx.tx_status == 0) {
+			omap_stop_dma(vout->vrfb_dma_tx.dma_ch);
+			return -EINVAL;
+		}
+		/* Store buffers physical address into an array. Addresses
+		 * from this array will be used to configure DSS */
+		vout->queued_buf_addr[vb->i] =
+		    (u8 *) vout->sms_rot_phy[vb->i][0];
+	} else {
+		dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+
+		vout->queued_buf_addr[vb->i] = (u8 *) dmabuf->bus_addr;
+	}
+	return 0;
+}
+
+/* Buffer queue funtion will be called from the videobuf layer when _QBUF
+ * ioctl is called. It is used to enqueue buffer, which is ready to be
+ * displayed. */
+static void
+omap_vout_buffer_queue(struct videobuf_queue *q,
+			  struct videobuf_buffer *vb)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	/* Driver is also maintainig a queue. So enqueue buffer in the driver
+	 * queue */
+	list_add_tail(&vb->queue, &vout->dma_queue);
+
+	vb->state = VIDEOBUF_PREPARED;
+}
+
+/* Buffer release function is called from videobuf layer to release buffer
+ * which are already allocated */
+static void
+omap_vout_buffer_release(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	vb->state = VIDEOBUF_NEEDS_INIT;
+
+	if (V4L2_MEMORY_MMAP != vout->memory)
+		return;
+}
+
+static int omap_vout_calculate_offset(struct omap_vout_device *vout)
+{
+	struct v4l2_pix_format *pix = &(vout->pix);
+	struct v4l2_rect *crop = &(vout->crop);
+	struct v4l2_window *win = &(vout->win);
+	int rotation_deg;
+	int mirroring = vout->mirror;
+	int vr_ps = 1, ps = 2, temp_ps = 2;
+	int offset = 0, ctop = 0, cleft = 0, line_length = 0;
+	int *cropped_offset = &(vout->cropped_offset);
+
+	if ((omap_disp_get_output_dev(vout->vid) == OMAP_OUTPUT_TV) &&
+	    ((win->w.width == crop->width)
+	     && (win->w.height == crop->height)))
+		vout->flicker_filter = 1;
+	else
+		vout->flicker_filter = 0;
+
+	if (1 == vout->mirror && vout->rotation >= 0) {
+		rotation_deg = (vout->rotation == 90) ? 270 :
+		    (vout->rotation == 270) ? 90 : (vout->rotation ==
+						    180) ? 0 : 180;
+
+	} else if (vout->rotation >= 0) {
+		rotation_deg = vout->rotation;
+	} else {
+		rotation_deg = -1;
+	}
+
+	if (V4L2_PIX_FMT_YUYV == pix->pixelformat ||
+	    V4L2_PIX_FMT_UYVY == pix->pixelformat) {
+		if (rotation_deg >= 0 || mirroring == 1) {
+			/*
+			 * ps    - Actual pixel size for YUYV/UYVY for
+			 *              VRFB/Mirroring is 4 bytes
+			 * vr_ps - Virtually pixel size for YUYV/UYVY is
+			 *              2 bytes
+			 */
+			ps = 4;
+			vr_ps = 2;
+		} else {
+			ps = 2;	/* otherwise the pixel size is 2 byte */
+		}
+	} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {
+		ps = 4;
+	} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {
+		ps = 3;
+	}
+	vout->ps = ps;
+	vout->vr_ps = vr_ps;
+	if (rotation_deg >= 0) {
+		line_length = MAX_PIXELS_PER_LINE;
+		ctop = (pix->height - crop->height) - crop->top;
+		cleft = (pix->width - crop->width) - crop->left;
+	} else {
+		line_length = pix->width;
+	}
+	vout->line_length = line_length;
+	switch (rotation_deg) {
+	case 90:
+		offset = (omap_disp_get_vrfb_offset(pix->width, ps,
+						     SIDE_H) -
+			  (pix->width / vr_ps)) * ps * line_length;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+			    temp_ps * cleft + crop->top * temp_ps;
+		} else {
+			*cropped_offset = offset + line_length *
+			    temp_ps * cleft + crop->top *
+			    temp_ps +
+			    (line_length * ((crop->width / (vr_ps)) - 1) *
+			     ps);
+		}
+		break;
+
+	case 180:
+		offset = (omap_disp_get_vrfb_offset(pix->height, ps,
+						     SIDE_H) -
+			  pix->height) * ps * line_length +
+		    (omap_disp_get_vrfb_offset(pix->width, ps, SIDE_W) -
+		     (pix->width / vr_ps)) * ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + (line_length * ps *
+						    ctop) +
+			    (cleft / vr_ps) * ps;
+		} else {
+			*cropped_offset = offset + (line_length * ps *
+						    ctop) +
+			    (cleft / vr_ps) * ps +
+			    (line_length * (crop->height - 1) * ps);
+		}
+		break;
+
+	case 270:
+		offset = (omap_disp_get_vrfb_offset(pix->height, ps,
+						     SIDE_W) -
+			  pix->height) * ps;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+			    temp_ps * crop->left + ctop * ps;
+		} else {
+			*cropped_offset = offset + line_length *
+			    temp_ps * crop->left + ctop * ps +
+			    (line_length * ((crop->width / vr_ps) - 1) *
+			     ps);
+		}
+		break;
+	case 0:
+		if (mirroring == 0) {
+			*cropped_offset = (line_length * ps) *
+			    crop->top + (crop->left / vr_ps) * ps;
+		} else {
+			*cropped_offset = (line_length * ps) *
+			    crop->top + (crop->left / vr_ps) * ps +
+			    (line_length * (crop->height - 1) * ps);
+		}
+		break;
+	default:
+		if (mirroring == 0) {
+			*cropped_offset =
+			    line_length * ps * crop->top + crop->left * ps;
+		} else {
+			*cropped_offset = (line_length * ps *
+					   crop->top) / vr_ps +
+			    (crop->left * ps) / vr_ps +
+			    ((crop->width / vr_ps) - 1) * ps;
+		}
+		break;
+	}
+
+	if (vout->flicker_filter == 1)
+		vout->tv_field1_offset = 0;
+	else if (vout->rotation >= 0) {
+		if (vout->mirror == 1)
+			vout->tv_field1_offset =
+			    -vout->line_length * vout->ps;
+		else
+			vout->tv_field1_offset =
+			    vout->line_length * vout->ps;
+	} else {
+		if (vout->mirror == 1)
+			vout->tv_field1_offset =
+			    vout->line_length * vout->ps / vout->vr_ps;
+		else
+			vout->tv_field1_offset =
+			    vout->line_length * vout->ps;
+	}
+	return 0;
+}
+
+static int
+omap_vout_do_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, void *arg)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) file->private_data;
+	struct omap_vout_device *vout = fh->vout;
+	int err = -EINVAL;
+
+	switch (cmd) {
+
+	case VIDIOC_G_OUTPUT:
+		{
+			int *output = (int *) arg;
+			return omap_disp_get_output(1, output);
+		}
+
+	case VIDIOC_S_OUTPUT:
+		{
+			unsigned int *output = arg;
+			omap_disp_get_dss();
+			err = omap_disp_set_output(1, *output);
+			omap_disp_put_dss();
+			return err;
+		}
+
+	case VIDIOC_ENUMOUTPUT:
+		{
+			struct v4l2_output *output =
+			    (struct v4l2_output *) arg;
+
+			omap_disp_get_dss();
+			err = omap_disp_enum_output(1, output->index,
+							output->name);
+			if (!err)
+				output->type = V4L2_OUTPUT_TYPE_MODULATOR;
+
+			omap_disp_put_dss();
+			return err;
+		}
+
+	case VIDIOC_S_STD:
+		{
+			int i;
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			for (i = 0; i < ARRAY_SIZE(id_name); i++) {
+				if (*id == id_name[i].id) {
+					omap_disp_get_dss();
+					err = omap_disp_set_mode
+					    (1, id_name[i].name);
+					omap_disp_put_dss();
+				}
+			}
+			return err;
+
+		}
+
+	case VIDIOC_G_STD:
+		{
+			int i;
+			char *s;
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			omap_disp_get_dss();
+			s = omap_disp_get_mode(1);
+			omap_disp_put_dss();
+			for (i = 0; i < ARRAY_SIZE(id_name); i++) {
+				if (!(strcmp(s, id_name[i].name))) {
+					*id = id_name[i].id;
+					err = 0;
+				}
+			}
+			return err;
+		}
+#if 0
+	case VIDIOC_ENUMOUTPUT:
+		{
+			struct v4l2_output *output =
+			    (struct v4l2_output *) arg;
+			int index = output->index;
+
+			if (index > 0)
+				return -EINVAL;
+
+			memset(output, 0, sizeof(*output));
+			output->index = index;
+
+			strncpy(output->name, "video out",
+				sizeof(output->name));
+			output->type = V4L2_OUTPUT_TYPE_MODULATOR;
+			return 0;
+		}
+	case VIDIOC_G_OUTPUT:
+		{
+			unsigned int *output = arg;
+			*output = 0;
+			return 0;
+		}
+
+	case VIDIOC_S_OUTPUT:
+		{
+			unsigned int *output = arg;
+			if (*output > 0)
+				return -EINVAL;
+			return 0;
+		}
+#endif
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *) arg;
+			memset(cap, 0, sizeof(*cap));
+			strncpy(cap->driver, VOUT_NAME,
+				sizeof(cap->driver));
+			strncpy(cap->card, vout->vfd->name,
+				sizeof(cap->card));
+			cap->bus_info[0] = '\0';
+			cap->capabilities =
+			    V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+#ifdef DEBUG_ALLOW_WRITE
+			cap->capabilities |= V4L2_CAP_READWRITE;
+#endif
+			return 0;
+		}
+
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = arg;
+			int index = fmt->index;
+			enum v4l2_buf_type type = fmt->type;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			fmt->type = type;
+
+			switch (fmt->type) {
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+				if (index >= NUM_OUTPUT_FORMATS)
+					return -EINVAL;
+				break;
+			default:
+				return -EINVAL;
+			}
+
+			fmt->flags = omap_formats[index].flags;
+			strncpy(fmt->description,
+				omap_formats[index].description,
+				sizeof(fmt->description));
+			fmt->pixelformat =
+			    omap_formats[index].pixelformat;
+
+			return 0;
+		}
+
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *f = (struct v4l2_format *) arg;
+
+			switch (f->type) {
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					struct v4l2_pix_format *pix =
+					    &f->fmt.pix;
+					memset(pix, 0, sizeof(*pix));
+					*pix = vout->pix;
+					return 0;
+				}
+
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+				{
+					struct v4l2_window *win =
+					    &f->fmt.win;
+					memset(win, 0, sizeof(*win));
+
+					/*
+					 * The API has a bit of a problem here.
+					 * We're returning a v4l2_window
+					 * structure, but that structure
+					 * contains pointers to variable-sized
+					 * objects for clipping rectangles and
+					 * clipping bitmaps.  We will just
+					 * return NULLs for those pointers.
+					 */
+
+					win->w = vout->win.w;
+					win->field = vout->win.field;
+					win->chromakey =
+					    vout->win.chromakey;
+					return 0;
+				}
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *f = (struct v4l2_format *) arg;
+
+			if (vout->streaming)
+				return -EBUSY;
+
+			/* We dont support RGB24-packed mode if vrfb rotation
+			 * is enabled*/
+			if (vout->rotation != -1
+			    && f->fmt.pix.pixelformat ==
+			    V4L2_PIX_FMT_RGB24)
+				return -EINVAL;
+
+			switch (f->type) {
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+				{
+					struct v4l2_window *win =
+					    &f->fmt.win;
+					err =
+					    omap_vout_try_window(&vout->
+								    fbuf,
+								    win);
+					return err;
+				}
+
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					/* don't allow to change img for the
+					 * linked layer */
+					if (vout->vid == vout_linked)
+						return -EINVAL;
+					omap_disp_get_dss();
+					/* get the framebuffer parameters */
+					if (vout->rotation == 90 ||
+						vout->rotation == 270) {
+						omap_disp_get_panel_size(
+						omap_disp_get_output_dev
+							(vout->vid),
+							&(vout->fbuf.
+								fmt.height),
+							&(vout->fbuf.
+								fmt.width));
+					} else {
+						omap_disp_get_panel_size(
+						omap_disp_get_output_dev
+							(vout->vid),
+							&(vout->fbuf.
+								fmt.width),
+							&(vout->fbuf.
+								fmt.height));
+					}
+					omap_disp_put_dss();
+					omap_vout_try_format(&f->fmt.pix,
+						&vout->fbuf.fmt);
+					return 0;
+				}
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *f = (struct v4l2_format *) arg;
+
+			if (vout->streaming)
+				return -EBUSY;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			/* We dont support RGB24-packed mode if vrfb rotation
+			 * is enabled*/
+			if (vout->rotation != -1
+			    && f->fmt.pix.pixelformat ==
+			    V4L2_PIX_FMT_RGB24) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+
+			omap_disp_get_dss();
+
+			/* get the framebuffer parameters */
+			if (vout->rotation == 90 || vout->rotation == 270) {
+				omap_disp_get_panel_size
+				    (omap_disp_get_output_dev(vout->vid),
+				     &(vout->fbuf.fmt.height),
+				     &(vout->fbuf.fmt.width));
+			} else {
+				omap_disp_get_panel_size
+				    (omap_disp_get_output_dev(vout->vid),
+				     &(vout->fbuf.fmt.width),
+				     &(vout->fbuf.fmt.height));
+			}
+
+			omap_disp_put_dss();
+
+			switch (f->type) {
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+				{
+					struct v4l2_window *win =
+					    &f->fmt.win;
+					err =
+					    omap_vout_new_window(&vout->
+								    crop,
+								    &vout->
+								    win,
+								    &vout->
+								    fbuf,
+								    win);
+					up(&vout->lock);
+					return err;
+				}
+
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					int bpp;
+					/*
+					 * don't allow to change img for
+					 * the linked layer */
+					if (vout->vid == vout_linked) {
+						up(&vout->lock);
+						return -EINVAL;
+					}
+					/* change to samller size is OK */
+					bpp = omap_vout_try_format(&f->fmt.pix,
+							&vout->fbuf.fmt);
+					f->fmt.pix.sizeimage =
+					    f->fmt.pix.width *
+					    f->fmt.pix.height * bpp;
+
+					/* try & set the new output format */
+					vout->bpp = bpp;
+					vout->pix = f->fmt.pix;
+					vout->vrfb_bpp = 1;
+					/* If YUYV then vrfb bpp is 2, for
+					 * others its 1*/
+					if (V4L2_PIX_FMT_YUYV ==
+					    vout->pix.pixelformat
+					    || V4L2_PIX_FMT_UYVY ==
+					    vout->pix.pixelformat)
+						vout->vrfb_bpp = 2;
+
+					/* set default crop and win */
+					omap_vout_new_format(&vout->pix,
+								&vout->
+								fbuf,
+								&vout->
+								crop,
+								&vout->
+								win);
+					up(&vout->lock);
+					return 0;
+				}
+
+			default:
+				up(&vout->lock);
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cropcap =
+			    (struct v4l2_cropcap *) arg;
+			enum v4l2_buf_type type = cropcap->type;
+
+			memset(cropcap, 0, sizeof(*cropcap));
+			cropcap->type = type;
+			switch (type) {
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					struct v4l2_pix_format *pix =
+					    &vout->pix;
+
+					/* Width and height are always even */
+					cropcap->bounds.width =
+					    pix->width & ~1;
+					cropcap->bounds.height =
+					    pix->height & ~1;
+
+					omap_vout_default_crop(&vout->
+								  pix,
+								  &vout->
+								  fbuf,
+								  &cropcap->
+								  defrect);
+					cropcap->pixelaspect.numerator = 1;
+					cropcap->pixelaspect.denominator =
+					    1;
+					return 0;
+				}
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_G_CROP:
+		{
+			struct v4l2_crop *crop = (struct v4l2_crop *) arg;
+
+			switch (crop->type) {
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					crop->c = vout->crop;
+					return 0;
+				}
+			default:
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_S_CROP:
+		{
+			struct v4l2_crop *crop = (struct v4l2_crop *) arg;
+			if (vout->streaming)
+				return -EBUSY;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			omap_disp_get_dss();
+
+			/* get the framebuffer parameters */
+			if (vout->rotation == 90 || vout->rotation == 270) {
+				omap_disp_get_panel_size
+				    (omap_disp_get_output_dev(vout->vid),
+				     &(vout->fbuf.fmt.height),
+				     &(vout->fbuf.fmt.width));
+			} else {
+				omap_disp_get_panel_size
+				    (omap_disp_get_output_dev(vout->vid),
+				     &(vout->fbuf.fmt.width),
+				     &(vout->fbuf.fmt.height));
+
+			}
+			omap_disp_put_dss();
+
+			switch (crop->type) {
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				{
+					err =
+					    omap_vout_new_crop(&vout->
+								  pix,
+								  &vout->
+								  crop,
+								  &vout->
+								  win,
+								  &vout->
+								  fbuf,
+								  &crop->
+								  c);
+					up(&vout->lock);
+					return err;
+				}
+			default:
+				up(&vout->lock);
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *req =
+			    (struct v4l2_requestbuffers *) arg;
+			struct videobuf_queue *q = &fh->vbq;
+			unsigned int i, num_buffers = 0;
+			int ret = 0;
+			struct videobuf_dmabuf *dmabuf = NULL;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			/* don't allow to buffer request for the linked layer */
+			if (vout->vid == vout_linked) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+
+			if ((req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			    || (req->count < 0)) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+			/* if memory is not mmp or userptr
+			   return error */
+			if ((V4L2_MEMORY_MMAP != req->memory) &&
+			    (V4L2_MEMORY_USERPTR != req->memory)) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+
+			/* Cannot be requested when streaming is on */
+			if (vout->streaming) {
+				up(&vout->lock);
+				return -EBUSY;
+			}
+
+			/* If buffers are already allocated free them */
+			if (q->bufs[0]
+			    && (V4L2_MEMORY_MMAP == q->bufs[0]->memory)) {
+				if (vout->mmap_count) {
+					up(&vout->lock);
+					return -EBUSY;
+				}
+				num_buffers = (vout->vid == OMAP_VIDEO1) ?
+				    video1_numbuffers : video2_numbuffers;
+				for (i = num_buffers;
+				     i < vout->buffer_allocated; i++) {
+					dmabuf =
+					    videobuf_to_dma(q->bufs[i]);
+					omap_vout_free_buffer((u32)
+								 dmabuf->
+								 vmalloc,
+								 dmabuf->
+								 bus_addr,
+								 vout->
+								 buffer_size);
+					vout->buf_virt_addr[i] = 0;
+					vout->buf_phy_addr[i] = 0;
+				}
+				vout->buffer_allocated = num_buffers;
+				videobuf_mmap_free(q);
+			} else if (q->bufs[0]
+				   && (V4L2_MEMORY_USERPTR ==
+				       q->bufs[0]->memory)) {
+				if (vout->buffer_allocated) {
+					videobuf_mmap_free(q);
+					for (i = 0;
+					     i < vout->buffer_allocated;
+					     i++) {
+						kfree(q->bufs[i]);
+						q->bufs[i] = NULL;
+					}
+					vout->buffer_allocated = 0;
+				}
+			}
+			fh->io_allowed = 1;
+
+			/*store the memory type in data structure */
+			vout->memory = req->memory;
+
+			INIT_LIST_HEAD(&vout->dma_queue);
+
+			/* call videobuf_reqbufs api */
+			ret = videobuf_reqbufs(q, req);
+			if (ret < 0) {
+				up(&vout->lock);
+				return ret;
+			}
+
+			vout->buffer_allocated = req->count;
+			for (i = 0; i < req->count; i++) {
+				dmabuf = videobuf_to_dma(q->bufs[i]);
+				dmabuf->vmalloc =
+				    (void *) vout->buf_virt_addr[i];
+				dmabuf->bus_addr =
+				    (dma_addr_t) vout->buf_phy_addr[i];
+
+				dmabuf->sglen = 1;
+			}
+			up(&vout->lock);
+			return 0;
+		}
+
+	case VIDIOC_QUERYBUF:
+		return videobuf_querybuf(&fh->vbq, arg);
+
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer *buffer =
+			    (struct v4l2_buffer *) arg;
+			struct videobuf_queue *q = &fh->vbq;
+			int streaming_on = STREAMING_IS_ON(), ret = 0;
+
+			if (!fh->io_allowed)
+				return -EINVAL;
+
+			timeout = HZ / 5;
+			timeout += jiffies;
+
+			if (!streaming_on)
+				omap_disp_get_dss();
+
+			/* don't allow to queue buffer for the linked layer */
+			if (vout->vid == vout_linked) {
+				if (!streaming_on)
+					omap_disp_put_dss();
+				return -EINVAL;
+			}
+
+			if ((V4L2_BUF_TYPE_VIDEO_OUTPUT != buffer->type) ||
+			    (buffer->index >= vout->buffer_allocated) ||
+			    (q->bufs[buffer->index]->memory !=
+			     buffer->memory)) {
+				if (!streaming_on)
+					omap_disp_put_dss();
+				return -EINVAL;
+			}
+			if (V4L2_MEMORY_USERPTR == buffer->memory) {
+				if ((buffer->length < vout->pix.sizeimage)
+				    || (0 == buffer->m.userptr)) {
+					if (!streaming_on)
+						omap_disp_put_dss();
+					return -EINVAL;
+				}
+			}
+
+			if (vout->rotation >= 0
+			    && vout->vrfb_dma_tx.req_status ==
+			    DMA_CHAN_NOT_ALLOTED) {
+				if (!streaming_on)
+					omap_disp_put_dss();
+				return -EINVAL;
+			}
+
+			ret = videobuf_qbuf(q, buffer);
+			if (!streaming_on)
+				omap_disp_put_dss();
+			return ret;
+		}
+
+	case VIDIOC_DQBUF:
+		{
+			struct videobuf_queue *q = &fh->vbq;
+			int ret = 0;
+			/* don't allow to dequeue buffer for the linked layer */
+			if (vout->vid == vout_linked)
+				return -EINVAL;
+
+			if (!vout->streaming || !fh->io_allowed)
+				return -EINVAL;
+
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(q,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(q,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			return ret;
+		}
+
+	case VIDIOC_STREAMON:
+		{
+			struct videobuf_queue *q = &fh->vbq;
+			struct omap_vout_device *dest = NULL;
+			struct videobuf_dmabuf *dmabuf = NULL;
+			int ret = 0, rotation = -1, mask = 0;
+			u32 addr = 0;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if (!fh->io_allowed) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+
+			if (vout->streaming) {
+				up(&vout->lock);
+				return -EBUSY;
+			}
+
+			ret = videobuf_streamon(q);
+			if (ret < 0) {
+				up(&vout->lock);
+				return ret;
+			}
+
+			if (list_empty(&vout->dma_queue)) {
+				up(&vout->lock);
+				return -EIO;
+			}
+			/* Get the next frame from the buffer queue */
+			vout->nextFrm = vout->curFrm =
+			    list_entry(vout->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&vout->curFrm->queue);
+			/* Mark state of the current frame to active */
+			vout->curFrm->state = VIDEOBUF_ACTIVE;
+			/* Initialize field_id and started member */
+			vout->field_id = 0;
+
+			/* set flag here. Next QBUF will start DMA */
+			vout->streaming = fh;
+
+			vout->first_int = 1;
+
+			omap_disp_get_dss();
+			rotation =
+			    (vout->rotation >= 0) ? vout->rotation : -1;
+
+			omap_vout_config_vlayer(vout->vid, &vout->pix,
+						   &vout->crop, &vout->win,
+						   rotation, vout->mirror);
+			omap_vout_calculate_offset(vout);
+
+			addr =
+			    (unsigned long) vout->queued_buf_addr[vout->
+								  curFrm->
+								  i] +
+			    vout->cropped_offset;
+			omap_disp_set_addr(vout->vid, addr, addr,
+					    addr + vout->tv_field1_offset);
+
+			/* Configure also linked layer */
+			if (vout_linked != -1 && vout_linked != vout->vid) {
+				dest =
+				    (vout_linked ==
+				     OMAP_VIDEO1) ? saved_v1out :
+				    saved_v2out;
+				rotation =
+				    (dest->rotation >=
+				     0) ? dest->rotation : -1;
+				if (rotation > -1) {
+					if (!(vout->rotation > -1)) {
+						printk
+						("Rotation should be \
+						enabled in linking layer\n");
+						up(&vout->lock);
+						return -EINVAL;
+					}
+					if (rotation != vout->rotation) {
+						printk
+						("Rotation must be same \
+						in both the layers\n");
+						up(&vout->lock);
+						return -EINVAL;
+					}
+				}
+				omap_vout_calculate_offset(dest);
+
+				if (rotation >= 0) {
+					addr = (unsigned long)
+					    vout->queued_buf_addr[vout->
+								  curFrm->
+								  i] +
+					    dest->cropped_offset;
+				} else {
+					dmabuf =
+					    videobuf_to_dma(vout->curFrm);
+					addr =
+					    (unsigned long) dmabuf->
+					    bus_addr +
+					    dest->cropped_offset;
+				}
+
+				omap_vout_config_vlayer(dest->vid,
+							   &dest->pix,
+							   &dest->crop,
+							   &dest->win,
+							   rotation,
+							   dest->mirror);
+
+				omap_disp_set_addr(dest->vid, addr, addr,
+						    addr +
+						    dest->
+						    tv_field1_offset);
+			}
+			/* Register ISR handler */
+			mask =
+			    (DISPC_IRQSTATUS_EVSYNC_ODD |
+			     DISPC_IRQSTATUS_EVSYNC_EVEN |
+			     DISPC_IRQSTATUS_VSYNC);
+			ret =
+			    omap_disp_register_isr(omap_vout_isr, vout,
+						    mask);
+			if (ret < 0) {
+				up(&vout->lock);
+				return -EIO;
+			}
+
+			omap_disp_start_video_layer(vout->vid);
+			if (vout_linked != -1 && vout_linked != vout->vid)
+				omap_disp_start_video_layer(dest->vid);
+			up(&vout->lock);
+			return 0;
+		}
+
+	case VIDIOC_STREAMOFF:
+		{
+			struct videobuf_queue *q = &fh->vbq;
+			int ret = 0;
+			if (!fh->io_allowed)
+				return -EINVAL;
+			if (!vout->streaming)
+				return -EINVAL;
+			if (vout->streaming == fh) {
+				omap_disp_disable_layer(vout->vid);
+				vout->streaming = NULL;
+
+				/* stop the slave layer */
+				if (vout_linked != -1
+				    && vout_linked != vout->vid) {
+					omap_disp_disable_layer((vout->
+								  vid ==
+								  OMAP_VIDEO1)
+								 ?
+								 OMAP_VIDEO2
+								 :
+								 OMAP_VIDEO1);
+				}
+
+				ret = videobuf_streamoff(q);
+				omap_disp_unregister_isr
+				    (omap_vout_isr);
+
+				omap_disp_put_dss();
+
+				return 0;
+			}
+
+			return -EINVAL;
+		}
+
+	case VIDIOC_S_OMAP_LINK:
+		{
+			int *link = arg;
+
+			spin_lock(&vout_link_lock);
+			if ((*link == 0) && (vout_linked == vout->vid))
+				vout_linked = -1;
+
+			omap_disp_get_dss();
+			if ((*link == 1)
+			    && (vout_linked == -1
+				|| vout_linked == vout->vid)) {
+				vout_linked = vout->vid;
+
+				if (vout_linked == OMAP_VIDEO2) {
+					/* sync V2 to V1 for img and crop */
+					omap_vout_sync(saved_v2out,
+							  saved_v1out);
+				} else {
+					/* sync V1 to V2 */
+					omap_vout_sync(saved_v1out,
+							  saved_v2out);
+				}
+			}
+
+			omap_disp_put_dss();
+
+			spin_unlock(&vout_link_lock);
+			return 0;
+		}
+
+	case VIDIOC_G_OMAP_LINK:
+		{
+			int *link = arg;
+
+			spin_lock(&vout_link_lock);
+			if (vout_linked == vout->vid)
+				*link = 1;
+			else
+				*link = 0;
+			spin_unlock(&vout_link_lock);
+			return 0;
+		}
+
+	case VIDIOC_S_OMAP_MIRROR:
+		{
+			int *mirror = arg;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if ((*mirror == 0) && (vout->mirror == 1)) {
+				vout->mirror = 0;
+				up(&vout->lock);
+				return 0;
+			} else if ((*mirror == 1) && (vout->mirror == 0)) {
+				vout->mirror = 1;
+				up(&vout->lock);
+				return 0;
+			}
+			up(&vout->lock);
+			return -EINVAL;
+		}
+
+	case VIDIOC_G_OMAP_MIRROR:
+		{
+			int *mirror = arg;
+			*mirror = vout->mirror;
+			return 0;
+		}
+
+	case VIDIOC_S_OMAP_ROTATION:
+		{
+			int *rotation = arg;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if ((*rotation == 0) || (*rotation == 90) ||
+			    (*rotation == 180) || (*rotation == 270)
+			    || (*rotation == -1)) {
+				vout->rotation =
+				    (*rotation == 90) ? 270 : (*rotation ==
+							       270) ? 90 :
+				    *rotation;
+				up(&vout->lock);
+				rotation_support = vout->rotation;
+				return 0;
+			} else {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+		}
+
+	case VIDIOC_G_OMAP_ROTATION:
+		{
+			int *rotation = arg;
+			*rotation = (vout->rotation == 90) ? 270 :
+			    (vout->rotation == 270) ? 90 : vout->rotation;
+			return 0;
+		}
+
+	case VIDIOC_S_OMAP_COLORKEY:
+		{
+			struct omap_vout_colorkey *colorkey =
+			    (struct omap_vout_colorkey *) arg;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if ((colorkey->output_dev != OMAP_OUTPUT_LCD &&
+			     colorkey->output_dev != OMAP_OUTPUT_TV) ||
+			    (colorkey->key_type != OMAP_GFX_DESTINATION
+			     && colorkey->key_type != OMAP_VIDEO_SOURCE)) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+			omap_disp_get_dss();
+
+			omap_disp_set_colorkey(colorkey->output_dev,
+						colorkey->key_type,
+						colorkey->key_val);
+
+			omap_disp_put_dss();
+			up(&vout->lock);
+
+			return 0;
+		}
+
+	case VIDIOC_G_OMAP_COLORKEY:
+		{
+			struct omap_vout_colorkey *colorkey =
+			    (struct omap_vout_colorkey *) arg;
+
+			if (colorkey->output_dev != OMAP_OUTPUT_LCD
+			    && colorkey->output_dev != OMAP_OUTPUT_TV)
+				return -EINVAL;
+
+			omap_disp_get_dss();
+
+			omap_disp_get_colorkey(colorkey->output_dev,
+						&colorkey->key_type,
+						&colorkey->key_val);
+
+			omap_disp_put_dss();
+
+			return 0;
+
+		}
+
+	case VIDIOC_S_OMAP_BGCOLOR:
+		{
+			struct omap_vout_bgcolor *bgcolor =
+			    (struct omap_vout_bgcolor *) arg;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if (bgcolor->output_dev != OMAP_OUTPUT_LCD
+			    && bgcolor->output_dev != OMAP_OUTPUT_TV) {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+			omap_disp_get_dss();
+
+			omap_disp_set_bg_color(bgcolor->output_dev,
+						bgcolor->color);
+
+			omap_disp_put_dss();
+
+			up(&vout->lock);
+			return 0;
+		}
+
+	case VIDIOC_G_OMAP_BGCOLOR:
+		{
+			struct omap_vout_bgcolor *bgcolor =
+			    (struct omap_vout_bgcolor *) arg;
+
+			if (bgcolor->output_dev != OMAP_OUTPUT_LCD
+			    && bgcolor->output_dev != OMAP_OUTPUT_TV)
+				return -EINVAL;
+
+			omap_disp_get_dss();
+
+			omap_disp_get_bg_color(bgcolor->output_dev,
+						&bgcolor->color);
+
+			omap_disp_put_dss();
+
+			return 0;
+		}
+
+	case VIDIOC_OMAP_COLORKEY_ENABLE:
+		{
+			int *output_dev = arg;
+
+			if (*output_dev != OMAP_OUTPUT_LCD
+			    && *output_dev != OMAP_OUTPUT_TV)
+				return -EINVAL;
+
+			omap_disp_get_dss();
+
+			omap_disp_enable_colorkey(*output_dev);
+
+			omap_disp_put_dss();
+
+			return 0;
+		}
+
+	case VIDIOC_OMAP_COLORKEY_DISABLE:
+		{
+			int *output_dev = arg;
+
+			if (*output_dev != OMAP_OUTPUT_LCD
+			    && *output_dev != OMAP_OUTPUT_TV)
+				return -EINVAL;
+
+			omap_disp_get_dss();
+
+			omap_disp_disable_colorkey(*output_dev);
+
+			omap_disp_put_dss();
+
+			return 0;
+		}
+
+	case VIDIOC_S_OMAP_COLORCONV:
+		{
+			int v;
+			int full_range_conversion = 0;
+			struct omap_vout_colconv *ccmtx =
+			    (struct omap_vout_colconv *) arg;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if (vout->vid == OMAP_VIDEO1)
+				v = 0;
+			else
+				v = 1;
+
+			current_colorconv_values[v][0][0] = ccmtx->RY;
+			current_colorconv_values[v][0][1] = ccmtx->RCr;
+			current_colorconv_values[v][0][2] = ccmtx->RCb;
+			current_colorconv_values[v][1][0] = ccmtx->GY;
+			current_colorconv_values[v][1][1] = ccmtx->GCr;
+			current_colorconv_values[v][1][2] = ccmtx->GCb;
+			current_colorconv_values[v][2][0] = ccmtx->BY;
+			current_colorconv_values[v][2][1] = ccmtx->BCr;
+			current_colorconv_values[v][2][2] = ccmtx->BCb;
+			omap_disp_get_dss();
+
+			if (vout->pix.colorspace == V4L2_COLORSPACE_JPEG ||
+			    vout->pix.colorspace == V4L2_COLORSPACE_SRGB) {
+				full_range_conversion = 1;
+			}
+			omap_disp_set_colorconv(v, full_range_conversion);
+			omap_disp_put_dss();
+			up(&vout->lock);
+			return 0;
+		}
+
+	case VIDIOC_G_OMAP_COLORCONV:
+		{
+			int v;
+			struct omap_vout_colconv *ccmtx =
+			    (struct omap_vout_colconv *) arg;
+
+			if (vout->vid == OMAP_VIDEO1)
+				v = 0;
+			else
+				v = 1;
+
+			ccmtx->RY = current_colorconv_values[v][0][0];
+			ccmtx->RCr = current_colorconv_values[v][0][1];
+			ccmtx->RCb = current_colorconv_values[v][0][2];
+			ccmtx->GY = current_colorconv_values[v][1][0];
+			ccmtx->GCr = current_colorconv_values[v][1][1];
+			ccmtx->GCb = current_colorconv_values[v][1][2];
+			ccmtx->BY = current_colorconv_values[v][2][0];
+			ccmtx->BCr = current_colorconv_values[v][2][1];
+			ccmtx->BCb = current_colorconv_values[v][2][2];
+
+			return 0;
+		}
+
+	case VIDIOC_S_OMAP_DEFCOLORCONV:
+		{
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			omap_disp_get_dss();
+			switch (vout->pix.colorspace) {
+			case V4L2_COLORSPACE_SMPTE170M:
+			case V4L2_COLORSPACE_SMPTE240M:
+			case V4L2_COLORSPACE_BT878:
+			case V4L2_COLORSPACE_470_SYSTEM_M:
+			case V4L2_COLORSPACE_470_SYSTEM_BG:
+				omap_disp_set_default_colorconv(vout->vid,
+								 CC_BT601);
+				break;
+			case V4L2_COLORSPACE_REC709:
+				omap_disp_set_default_colorconv(vout->vid,
+								 CC_BT709);
+				break;
+			case V4L2_COLORSPACE_JPEG:
+			case V4L2_COLORSPACE_SRGB:
+				omap_disp_set_default_colorconv(vout->vid,
+								 CC_BT601_FULL);
+				break;
+			}
+
+			omap_disp_put_dss();
+			up(&vout->lock);
+			return 0;
+		}
+
+	default:
+		/* unrecognized ioctl */
+		return -ENOIOCTLCMD;
+
+	}			/* End of switch(cmd) */
+
+	return 0;
+}
+
+/*
+ *  file operations
+ */
+
+#ifdef DEBUG_ALLOW_WRITE
+
+static ssize_t
+omap_vout_write(struct file *file, const char *data,
+		   size_t count, loff_t *ppos)
+{
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	omap_disp_get_dss();
+
+	omap_vout_suspend_lockout(vout, file);
+	if ((*ppos) >= vout->pix.sizeimage) {
+		omap_disp_put_dss();
+		return 0;
+	}
+	if (count + (*ppos) > vout->pix.sizeimage)
+		count = vout->pix.sizeimage - (*ppos);
+	if (copy_from_user
+	    ((void *) (vout->framebuffer_base + (*ppos)), data, count)) {
+		printk(KERN_WARNING"error in copying data");
+	}
+	*ppos += count;
+
+#if 1
+	if (*ppos == vout->pix.sizeimage)
+		mdelay(5000);
+#endif
+
+	omap_disp_put_dss();
+
+	return count;
+}
+
+#endif
+
+static void omap_vout_vm_open(struct vm_area_struct *vma)
+{
+	struct omap_vout_device *vout = vma->vm_private_data;
+	DPRINTK("vm_open [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);
+	vout->mmap_count++;
+}
+
+static void omap_vout_vm_close(struct vm_area_struct *vma)
+{
+	struct omap_vout_device *vout = vma->vm_private_data;
+	DPRINTK("vm_close [vma=%08lx-%08lx]\n", vma->vm_start,
+		vma->vm_end);
+	vout->mmap_count--;
+}
+
+static struct vm_operations_struct omap_vout_vm_ops = {
+	.open = omap_vout_vm_open,
+	.close = omap_vout_vm_close,
+};
+
+static int omap_vout_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout = fh->vout;
+	struct videobuf_queue *q = &fh->vbq;
+	unsigned long size = (vma->vm_end - vma->vm_start);
+	unsigned long start = vma->vm_start;
+	int i;
+	void *pos;
+	struct videobuf_dmabuf *dmabuf = NULL;
+
+	DPRINTK("pgoff=0x%lx, start=0x%lx, end=0x%lx\n", vma->vm_pgoff,
+		vma->vm_start, vma->vm_end);
+
+	/* look for the buffer to map */
+	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+		if (NULL == q->bufs[i])
+			continue;
+		if (V4L2_MEMORY_MMAP != q->bufs[i]->memory)
+			continue;
+		if (q->bufs[i]->boff == (vma->vm_pgoff << PAGE_SHIFT))
+			break;
+	}
+
+	if (VIDEO_MAX_FRAME == i) {
+		DPRINTK("offset invalid [offset=0x%lx]\n",
+			(vma->vm_pgoff << PAGE_SHIFT));
+		return -EINVAL;
+	}
+	q->bufs[i]->baddr = vma->vm_start;
+
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	vma->vm_ops = &omap_vout_vm_ops;
+	vma->vm_private_data = (void *) vout;
+	dmabuf = videobuf_to_dma(q->bufs[i]);
+	pos = dmabuf->vmalloc;
+	while (size > 0) {
+		unsigned long pfn;
+		pfn = virt_to_phys((void *) pos) >> PAGE_SHIFT;
+		if (remap_pfn_range
+		    (vma, start, pfn, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	vout->mmap_count++;
+	return 0;
+}
+
+static int
+omap_vout_ioctl(struct inode *inode, struct file *file,
+		   unsigned int cmd, unsigned long arg)
+{
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	omap_vout_suspend_lockout(vout, file);
+	return video_usercopy(inode, file, cmd, arg,
+			      omap_vout_do_ioctl);
+}
+
+static void omap_vout_free_allbuffers(struct omap_vout_device *vout)
+{
+	int num_buffers = 0, i;
+	num_buffers = (vout->vid == OMAP_VIDEO1) ?
+	    video1_numbuffers : video2_numbuffers;
+	for (i = num_buffers; i < vout->buffer_allocated; i++) {
+		if (vout->buf_virt_addr[i]) {
+			omap_vout_free_buffer(vout->buf_virt_addr[i],
+						 vout->buf_phy_addr[i],
+						 vout->buffer_size);
+		}
+		vout->buf_virt_addr[i] = 0;
+		vout->buf_phy_addr[i] = 0;
+	}
+	for (i = 0; i < 4; i++) {
+		if (vout->smsshado_virt_addr[i]) {
+			omap_vout_free_buffer(vout->
+						 smsshado_virt_addr[i],
+						 vout->
+						 smsshado_phy_addr[i],
+						 vout->smsshado_size);
+			vout->smsshado_virt_addr[i] = 0;
+			vout->smsshado_phy_addr[i] = 0;
+		}
+	}
+	vout->buffer_allocated = num_buffers;
+}
+
+static int omap_vout_release(struct inode *inode, struct file *file)
+{
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout;
+	struct videobuf_queue *q;
+
+	DPRINTK("entering\n");
+
+	vout = fh->vout;
+	if (fh == 0)
+		return 0;
+	if (!vout)
+		return 0;
+	q = &fh->vbq;
+
+	omap_disp_get_dss();
+	omap_vout_suspend_lockout(vout, file);
+
+	/*
+	 * Check if the hidden buffer transfer is happening with DMA
+	 * if yes then stop it
+	 */
+
+	if (vout->rotation >= 0) {
+		if (vout->vrfb_dma_tx.tx_status == 0) {
+			/*
+			 * DMA will be stopped once here and again after
+			 * wakeup to avoid race conditions due to time
+			 * taken to wakeup the sleeping process
+			 */
+
+			omap_stop_dma(vout->vrfb_dma_tx.dma_ch);
+			wake_up_interruptible(&vout->vrfb_dma_tx.wait);
+		}
+	}
+
+	omap_disp_disable_layer(vout->vid);
+
+	if ((vout_linked != -1) && (vout->vid != vout_linked))
+		omap_disp_disable_layer((vout->vid == OMAP_VIDEO1) ?
+					 OMAP_VIDEO2 : OMAP_VIDEO1);
+
+	if (fh->io_allowed) {
+		videobuf_streamoff(q);
+		videobuf_queue_cancel(q);
+		/* Free all buffers */
+		omap_vout_free_allbuffers(vout);
+		videobuf_mmap_free(q);
+	}
+#ifdef DEBUG_ALLOW_WRITE
+	if (vout->framebuffer_base) {
+
+		dma_free_coherent(NULL, vout->framebuffer_size, (void *)
+				  vout->framebuffer_base,
+				  vout->framebuffer_base_phys);
+		vout->framebuffer_base = 0;
+	}
+	vout->framebuffer_base_phys = 0;
+#endif
+
+	if (vout->streaming == fh) {
+		omap_disp_unregister_isr(omap_vout_isr);
+		vout->streaming = NULL;
+	}
+
+	if (vout->mmap_count != 0) {
+		vout->mmap_count = 0;
+		printk("mmap count is not zero!\n");
+	}
+
+	omap_disp_release_layer(vout->vid);
+	omap_disp_put_dss();
+	vout->opened -= 1;
+	file->private_data = NULL;
+
+	if (vout->buffer_allocated)
+		videobuf_mmap_free(q);
+
+	kfree(fh);
+
+	/* need to remove the link when the either slave or master is gone */
+	spin_lock(&vout_link_lock);
+	if (vout_linked != -1)
+		vout_linked = -1;
+	spin_unlock(&vout_link_lock);
+
+	return 0;
+}
+
+static int omap_vout_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	struct omap_vout_device *vout = NULL;
+	struct omap_vout_fh *fh;
+	struct videobuf_queue *q;
+#ifdef DEBUG_ALLOW_WRITE
+	int rotation = -1;
+#endif
+	/*int i; */
+
+	DPRINTK("entering\n");
+
+	if (saved_v1out && saved_v1out->vfd
+	    && (saved_v1out->vfd->minor == minor)) {
+		vout = saved_v1out;
+	}
+
+	if (vout == NULL) {
+		if (saved_v2out && saved_v2out->vfd
+		    && (saved_v2out->vfd->minor == minor)) {
+			vout = saved_v2out;
+		}
+	}
+
+	if (vout == NULL)
+		return -ENODEV;
+
+	/* for now, we only support single open */
+	if (vout->opened)
+		return -EBUSY;
+
+	vout->opened += 1;
+	if (!omap_disp_request_layer(vout->vid)) {
+		vout->opened -= 1;
+		return -ENODEV;
+	}
+
+	omap_disp_get_dss();
+	omap_vout_suspend_lockout(vout, file);
+	/* allocate per-filehandle data */
+	fh = kmalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh) {
+		omap_disp_release_layer(vout->vid);
+		omap_disp_put_dss();
+		vout->opened -= 1;
+		return -ENOMEM;
+	}
+	memset(fh, 0, sizeof(*fh));
+
+	file->private_data = fh;
+	fh->vout = vout;
+	fh->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+#ifdef DEBUG_ALLOW_WRITE
+	vout->framebuffer_size = VID_MAX_HEIGHT * VID_MAX_HEIGHT * 2;
+	vout->framebuffer_base = dma_alloc_coherent(NULL,
+						    vout->framebuffer_size,
+						    (dma_addr_t *) &vout->
+						    framebuffer_base_phys,
+						    GFP_KERNEL | GFP_DMA);
+
+	if (!vout->framebuffer_base) {
+		kfree(fh);
+		omap_disp_release_layer(vout->vid);
+		omap_disp_put_dss();
+		vout->opened -= 1;
+		return -ENOMEM;
+	}
+	rotation = (vout->rotation >= 0) ? vout->rotation : -1;
+	memset((void *) vout->framebuffer_base, 0, vout->framebuffer_size);
+
+	omap_vout_config_vlayer(dest->vid, &dest->pix, &dest->crop,
+				   &dest->win, rotation, dest->mirror);
+	omap_disp_start_vlayer(vout->vid, &vout->pix, &vout->crop,
+				vout->framebuffer_base_phys, rotation,
+				vout->mirror);
+#endif
+
+	q = &fh->vbq;
+	video_vbq_ops.buf_setup = omap_vout_buffer_setup;
+	video_vbq_ops.buf_prepare = omap_vout_buffer_prepare;
+	video_vbq_ops.buf_release = omap_vout_buffer_release;
+	video_vbq_ops.buf_queue = omap_vout_buffer_queue;
+	spin_lock_init(&vout->vbq_lock);
+
+	videobuf_queue_sg_init(q, &video_vbq_ops, NULL, &vout->vbq_lock,
+			       fh->type, V4L2_FIELD_NONE, sizeof
+			       (struct videobuf_buffer), fh);
+
+	omap_disp_put_dss();
+
+	return 0;
+}
+
+static struct file_operations omap_vout_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+#ifdef DEBUG_ALLOW_WRITE
+	.write = omap_vout_write,
+#endif
+	.ioctl = omap_vout_ioctl,
+	.mmap = omap_vout_mmap,
+	.open = omap_vout_open,
+	.release = omap_vout_release,
+};
+
+#ifdef CONFIG_PM
+static int
+omap_vout_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct omap_vout_device *vout = platform_get_drvdata(dev);
+
+	/* lock-out applications during suspend */
+	if (vout->suspended == 1)
+		return 0;
+	if (vout->opened) {
+		/* stall vid DMA */
+		if (vout->streaming) {
+			omap_disp_disable_layer(vout->vid);
+			/*
+			 * Check if the hidden buffer transfer is happening
+			 * with DMA if yes then stop it
+			 */
+
+			if (vout->rotation >= 0) {
+				if (vout->vrfb_dma_tx.tx_status == 0) {
+					/*
+					 * DMA will be stopped once here
+					 * and again after wakeup to
+					 * avoid race conditions due to time
+					 * taken to wakeup the sleeping
+					 * process */
+					omap_stop_dma(vout->vrfb_dma_tx.
+						      dma_ch);
+					wake_up_interruptible(&vout->
+							      vrfb_dma_tx.
+							      wait);
+				}
+			}
+		}
+		vout->suspended = 1;
+		omap_disp_put_dss();
+	}
+
+	return 0;
+}
+
+static int omap_vout_resume(struct platform_device *dev)
+{
+	struct omap_vout_device *vout = platform_get_drvdata(dev);
+	if (vout->suspended == 0)
+		return 0;
+	if (vout->opened) {
+		omap_disp_get_dss();
+
+		/* resume vid DMA */
+		if (vout->streaming)
+			omap_disp_enable_layer(vout->vid);
+
+		/* wake up applications waiting on suspend queue */
+		vout->suspended = 0;
+		wake_up(&vout->suspend_wq);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_DPM
+
+static struct constraints omap_vout_constraints = {
+	.count = 2,
+	.param = {
+		  {DPM_MD_V, OMAP_V_MIN, OMAP_V_MAX},
+		  {DPM_MD_SLEEP_MODE, PM_SUSPEND_STANDBY, PM_SUSPEND_MEM},
+		  },
+};
+
+static int
+omap_vout_scale(int vid, struct notifier_block *op, unsigned long level)
+{
+	struct omap_vout_device *vout;
+	vout = (vid == OMAP_VIDEO1) ? saved_v1out : saved_v2out;
+	if (!vout->opened)
+		return 0;
+	switch (level) {
+	case SCALE_PRECHANGE:
+		if (vout->streaming) {
+			omap_disp_disable_layer(vout->vid);
+			if (vout->rotation >= 0) {
+				if (vout->vrfb_dma_tx.tx_status == 0) {
+					omap_stop_dma(vout->vrfb_dma_tx.
+						      dma_ch);
+				}
+			}
+		}
+		break;
+	case SCALE_POSTCHANGE:
+		if (vout->streaming) {
+			omap_disp_enable_layer(vout->vid);
+			if (vout->rotation >= 0) {
+				if (vout->vrfb_dma_tx.tx_status == 0) {
+					omap_start_dma(vout->vrfb_dma_tx.
+						       dma_ch);
+				}
+			}
+		}
+		break;
+	}
+	return 0;
+}
+
+static int
+omap_v1out_scale(struct notifier_block *op,
+		    unsigned long level, void *ptr)
+{
+	return omap_vout_scale(OMAP_VIDEO1, op, level);
+}
+
+static int
+omap_v2out_scale(struct notifier_block *op,
+		    unsigned long level, void *ptr)
+{
+	return omap_vout_scale(OMAP_VIDEO2, op, level);
+}
+
+static struct notifier_block omap_v1out_pre_scale = {
+	.notifier_call = omap_v1out_scale,
+};
+
+static struct notifier_block omap_v1out_post_scale = {
+	.notifier_call = omap_v1out_scale,
+};
+
+static struct notifier_block omap_v2out_pre_scale = {
+	.notifier_call = omap_v2out_scale,
+};
+
+static struct notifier_block omap_v2out_post_scale = {
+	.notifier_call = omap_v2out_scale,
+};
+
+#endif
+#endif				/* PM */
+
+static int omap_vout_probe(struct platform_device *dev)
+{
+	return 0;
+}
+static void omap_vout_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct platform_device omap_v1out_dev = {
+	.name = V1OUT_NAME,
+	.id = 11,
+	/*.devid = OMAP_V1OUT_DEVID, */
+	/*.busid = OMAP_BUS_L3, */
+	.dev = {
+#ifdef CONFIG_DPM
+		.constraints = &omap_vout_constraints,
+#endif
+		.release = omap_vout_platform_release,
+		},
+};
+
+static struct platform_device omap_v2out_dev = {
+	.name = V2OUT_NAME,
+	.id = 12,
+	/*.devid = OMAP_V2OUT_DEVID, */
+	/*.busid = OMAP_BUS_L3, */
+	.dev = {
+#ifdef CONFIG_DPM
+		.constraints = &omap_vout_constraints,
+#endif
+		.release = omap_vout_platform_release,
+		},
+};
+
+static struct platform_driver omap_v1out_driver = {
+	.driver = {
+		   .name = V1OUT_NAME,
+		   },
+	/*.devid   = OMAP_V1OUT_DEVID, */
+	/*.id   = 11, */
+	/*.busid   = OMAP_BUS_L3, */
+	/*.clocks  = 0, */
+	.probe = omap_vout_probe,
+#ifdef CONFIG_PM
+	.suspend = omap_vout_suspend,
+	.resume = omap_vout_resume,
+#endif
+};
+
+static struct platform_driver omap_v2out_driver = {
+	.driver = {
+		   .name = V2OUT_NAME,
+		   },
+	/*.id   = 12, */
+	/*.devid   = OMAP_V2OUT_DEVID, */
+	/*.busid   = OMAP_BUS_L3, */
+	/*.clocks  = 0, */
+	.probe = omap_vout_probe,
+#ifdef CONFIG_PM
+	.suspend = omap_vout_suspend,
+	.resume = omap_vout_resume,
+#endif
+};
+
+void
+omap_vout_isr(void *arg, struct pt_regs *regs, unsigned int irqstatus)
+{
+	struct timeval timevalue;
+	unsigned int out_dev;
+	struct omap_vout_device *vout =
+	    (struct omap_vout_device *) arg, *dest = NULL;
+	struct videobuf_dmabuf *dmabuf = NULL;
+	u32 addr, fid;
+
+	if (!vout->streaming)
+		return;
+
+	spin_lock(&vout->vbq_lock);
+	do_gettimeofday(&timevalue);
+	out_dev = omap_disp_get_output_dev(vout->vid);
+	if (out_dev == OMAP_OUTPUT_LCD) {
+		if (!(irqstatus & DISPC_IRQSTATUS_VSYNC))
+			return;
+		if (!vout->first_int && (vout->curFrm != vout->nextFrm)) {
+			vout->curFrm->ts = timevalue;
+			vout->curFrm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->curFrm->done);
+			vout->curFrm = vout->nextFrm;
+		}
+		vout->first_int = 0;
+		if (list_empty(&vout->dma_queue)) {
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		vout->nextFrm = list_entry(vout->dma_queue.next,
+					   struct videobuf_buffer, queue);
+		list_del(&vout->nextFrm->queue);
+
+		vout->nextFrm->state = VIDEOBUF_ACTIVE;
+
+		addr = (unsigned long)
+		    vout->queued_buf_addr[vout->nextFrm->i] +
+		    vout->cropped_offset;
+		omap_disp_set_addr(vout->vid, addr, addr,
+				    addr + vout->tv_field1_offset);
+		if (vout_linked != -1 && vout_linked != vout->vid) {
+			dmabuf = videobuf_to_dma(vout->nextFrm);
+			dest =
+			    (vout_linked ==
+			     OMAP_VIDEO1) ? saved_v1out : saved_v2out;
+			if (dest->rotation > -1)
+				addr = (unsigned long)
+				    vout->queued_buf_addr[vout->nextFrm->
+							  i] +
+				    dest->cropped_offset;
+			else
+				addr =
+				    dmabuf->bus_addr +
+				    dest->cropped_offset;
+			omap_disp_set_addr(dest->vid, addr, addr,
+					    addr + dest->tv_field1_offset);
+		}
+	} else {
+		if (vout->first_int) {
+			vout->first_int = 0;
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		if (irqstatus & DISPC_IRQSTATUS_EVSYNC_ODD)
+			fid = 1;
+		else if (irqstatus & DISPC_IRQSTATUS_EVSYNC_EVEN)
+			fid = 0;
+		else {
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		vout->field_id ^= 1;
+		if (fid != vout->field_id) {
+			if (0 == fid)
+				vout->field_id = fid;
+
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		if (0 == fid) {
+			if (vout->curFrm == vout->nextFrm) {
+				spin_unlock(&vout->vbq_lock);
+				return;
+			}
+			vout->curFrm->ts = timevalue;
+			vout->curFrm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->curFrm->done);
+			vout->curFrm = vout->nextFrm;
+		} else if (1 == fid) {
+			if (list_empty(&vout->dma_queue) ||
+			    (vout->curFrm != vout->nextFrm)) {
+				spin_unlock(&vout->vbq_lock);
+				return;
+			}
+
+			vout->nextFrm = list_entry(vout->dma_queue.next,
+						   struct videobuf_buffer,
+						   queue);
+
+			list_del(&vout->nextFrm->queue);
+
+			vout->nextFrm->state = VIDEOBUF_ACTIVE;
+
+			addr = (unsigned long)
+			    vout->queued_buf_addr[vout->nextFrm->i] +
+			    vout->cropped_offset;
+			omap_disp_set_addr(vout->vid, addr, addr,
+					    addr + vout->tv_field1_offset);
+			if (vout_linked != -1 && vout_linked != vout->vid) {
+				dmabuf = videobuf_to_dma(vout->nextFrm);
+				dest = (vout_linked == OMAP_VIDEO1) ?
+				    saved_v1out : saved_v2out;
+				if (dest->rotation > -1)
+					addr = (unsigned long)
+					    vout->queued_buf_addr
+					    [vout->nextFrm->i] +
+					    dest->cropped_offset;
+				else
+					addr =
+					    dmabuf->bus_addr +
+					    dest->cropped_offset;
+				omap_disp_set_addr(dest->vid, addr, addr,
+						    addr +
+						    dest->
+						    tv_field1_offset);
+			}
+		}
+	}
+	spin_unlock(&vout->vbq_lock);
+}
+
+static void omap_vout_cleanup_device(int vid)
+{
+	struct video_device *vfd;
+	struct omap_vout_device *vout;
+	int i, j, numbuffers;
+
+	vout = (vid == OMAP_VIDEO1) ? saved_v1out : saved_v2out;
+	if (!vout)
+		return;
+	vfd = vout->vfd;
+
+	if (vfd) {
+		if (vfd->minor == -1) {
+			/*
+			 * The device was never registered, so release the
+			 * video_device struct directly.
+			 */
+			video_device_release(vfd);
+		} else {
+			/*
+			 * The unregister function will release the video_device
+			 * struct as well as unregistering it.
+			 */
+			video_unregister_device(vfd);
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			release_mem_region(vout->sms_rot_phy[i][j],
+					   VRF_SIZE);
+		}
+	}
+
+	/* Allocate memory for the buffes */
+	numbuffers =
+	    (vid == OMAP_VIDEO1) ? video1_numbuffers : video2_numbuffers;
+	vout->buffer_size =
+	    (vid == OMAP_VIDEO1) ? video1_bufsize : video2_bufsize;
+	for (i = 0; i < numbuffers; i++) {
+		omap_vout_free_buffer(vout->buf_virt_addr[i],
+					 vout->buf_phy_addr[i],
+					 vout->buffer_size);
+		vout->buf_phy_addr[i] = 0;
+		vout->buf_virt_addr[i] = 0;
+	}
+
+	if (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+		omap_free_dma(vout->vrfb_dma_tx.dma_ch);
+	}
+	platform_device_unregister((vid == OMAP_VIDEO1) ?
+				   &omap_v1out_dev :
+				   &omap_v2out_dev);
+	platform_driver_unregister((vid ==
+				    OMAP_VIDEO1) ? &omap_v1out_driver :
+				   &omap_v2out_driver);
+
+#ifdef CONFIG_DPM
+	if (vid == OMAP_VIDEO1) {
+		dpm_unregister_scale(&omap_v1out_pre_scale,
+				     SCALE_PRECHANGE);
+		dpm_unregister_scale(&omap_v1out_post_scale,
+				     SCALE_POSTCHANGE);
+	} else {
+		dpm_unregister_scale(&omap_v2out_pre_scale,
+				     SCALE_PRECHANGE);
+		dpm_unregister_scale(&omap_v2out_pre_scale,
+				     SCALE_POSTCHANGE);
+	}
+#endif
+
+	kfree(vout);
+
+	if (vid == OMAP_VIDEO1)
+		saved_v1out = NULL;
+	else
+		saved_v2out = NULL;
+}
+
+static struct omap_vout_device *omap_vout_init_device(int vid)
+{
+	int r, i, j;
+	struct omap_vout_device *vout;
+	struct video_device *vfd;
+	struct v4l2_pix_format *pix;
+	struct platform_driver *this_driver;
+	struct platform_device *this_dev;
+	u32 sms_start_addr, numbuffers;
+	int index_i, index_j, image_width, image_height;
+
+	vout = kmalloc(sizeof(struct omap_vout_device), GFP_KERNEL);
+	if (!vout) {
+		printk(KERN_ERR VOUT_NAME ": could not allocate memory\n");
+		return NULL;
+	}
+
+	memset(vout, 0, sizeof(struct omap_vout_device));
+	vout->vid = vid;
+	vout->rotation = rotation_support;
+
+	/* set the default pix */
+	pix = &vout->pix;
+	pix->width = QQVGA_WIDTH;
+	pix->height = QQVGA_HEIGHT;
+
+	pix->pixelformat = V4L2_PIX_FMT_RGB565;
+	pix->field = V4L2_FIELD_ANY;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	pix->colorspace = V4L2_COLORSPACE_JPEG;
+
+	vout->bpp = RGB565_BPP;
+	vout->vrfb_bpp = 1;
+
+	/* get the screen parameters */
+	omap_disp_get_panel_size(omap_disp_get_output_dev(vout->vid),
+				  &(vout->fbuf.fmt.width),
+				  &(vout->fbuf.fmt.height));
+
+	/* set default crop and win */
+	omap_vout_new_format(pix, &vout->fbuf, &vout->crop, &vout->win);
+
+	/* initialize the video_device struct */
+	vfd = vout->vfd = video_device_alloc();
+	if (!vfd) {
+		printk(KERN_ERR VOUT_NAME ": could not allocate video \
+				device struct\n");
+		kfree(vout);
+		return NULL;
+	}
+	vfd->release = video_device_release;
+
+	strncpy(vfd->name, VOUT_NAME, sizeof(vfd->name));
+	vfd->vfl_type = VID_TYPE_OVERLAY | VID_TYPE_CHROMAKEY;
+	/* need to register for a VID_HARDWARE_* ID in videodev.h */
+	vfd->fops = &omap_vout_fops;
+	video_set_drvdata(vfd, vout);
+	vfd->minor = -1;
+
+	sms_start_addr =
+	    (vid ==
+	     OMAP_VIDEO1) ? OMAP_VOUT_VIDEO1_SMS_START :
+	    OMAP_VOUT_VIDEO2_SMS_START;
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			vout->sms_rot_phy[i][j] = sms_start_addr;
+			if (!request_mem_region(vout->sms_rot_phy[i][j],
+						VRF_SIZE, vfd->name)) {
+				printk(KERN_ERR
+				       "Cannot reserve smsm IO %x\n",
+				       vout->sms_rot_phy[i][j]);
+				index_i = i;
+				index_j = j;
+				goto rotation_free;
+			}
+			sms_start_addr += 0x1000000;
+		}
+	}
+	index_i = 4;
+	index_j = 0;
+
+	/* Allocate memory for the buffes */
+	numbuffers =
+	    (vid == OMAP_VIDEO1) ? video1_numbuffers : video2_numbuffers;
+	vout->buffer_size =
+	    (vid == OMAP_VIDEO1) ? video1_bufsize : video2_bufsize;
+	printk(KERN_INFO "Buffer Size = %d\n", vout->buffer_size);
+	for (i = 0; i < numbuffers; i++) {
+		vout->buf_virt_addr[i] =
+		    omap_vout_alloc_buffer(vout->buffer_size,
+					      (u32 *) &vout->
+					      buf_phy_addr[i]);
+		if (!vout->buf_virt_addr[i]) {
+			numbuffers = i;
+			goto free_buffer_memory;
+		}
+	}
+
+	vout->suspended = 0;
+	init_waitqueue_head(&vout->suspend_wq);
+	init_MUTEX(&vout->lock);
+
+	if (video_register_device(vfd, VFL_TYPE_GRABBER, vid) < 0) {
+		printk(KERN_ERR VOUT_NAME ": could not register Video for \
+				Linux device\n");
+		vfd->minor = -1;
+		goto free_buffer_memory;
+	}
+
+	this_driver = (vid == OMAP_VIDEO1) ?
+	    &omap_v1out_driver : &omap_v2out_driver;
+	this_dev =
+	    (vid ==
+	     OMAP_VIDEO1) ? &omap_v1out_dev : &omap_v2out_dev;
+	if (platform_driver_register(this_driver) != 0) {
+		printk(KERN_ERR VOUT_NAME ": could not register \
+				Video driver\n");
+		omap_vout_cleanup_device(vid);
+		return NULL;
+	}
+	if (platform_device_register(this_dev) != 0) {
+		printk(KERN_ERR VOUT_NAME ": could not register \
+				Video device\n");
+		omap_vout_cleanup_device(vid);
+		return NULL;
+	}
+	/* set driver specific data to use in power mgmt functions */
+	platform_set_drvdata(this_dev, vout);
+
+	if (vid == OMAP_VIDEO1) {
+		vout->vrfb_context[0] = 4;
+		vout->vrfb_context[1] = 5;
+		vout->vrfb_context[2] = 6;
+		vout->vrfb_context[3] = 7;
+	} else {
+		vout->vrfb_context[0] = 8;
+		vout->vrfb_context[1] = 9;
+		vout->vrfb_context[2] = 10;
+		vout->vrfb_context[3] = 11;
+	}
+	vout->cropped_offset = 0;
+
+#ifdef CONFIG_DPM
+	/* Scaling is enabled only when DPM is enabled */
+	if (vid == OMAP_VIDEO1) {
+		dpm_register_scale(&omap_v1out_pre_scale,
+				   SCALE_PRECHANGE);
+		dpm_register_scale(&omap_v1out_post_scale,
+				   SCALE_POSTCHANGE);
+	} else {
+		dpm_register_scale(&omap_v2out_pre_scale,
+				   SCALE_PRECHANGE);
+		dpm_register_scale(&omap_v2out_post_scale,
+				   SCALE_POSTCHANGE);
+	}
+#endif
+	/* Calculate VRFB memory size */
+	/* allocate for worst case size */
+	image_width = VID_MAX_WIDTH / TILE_SIZE;
+	if (VID_MAX_WIDTH % TILE_SIZE)
+		image_width++;
+
+	image_width = image_width * TILE_SIZE;
+	image_height = VID_MAX_HEIGHT / TILE_SIZE;
+
+	if (VID_MAX_HEIGHT % TILE_SIZE)
+		image_height++;
+
+	image_height = image_height * TILE_SIZE;
+	vout->smsshado_size =
+	    PAGE_ALIGN(image_width * image_height * 2 * 2);
+
+	/*
+	 * Request and Initialize DMA, for DMA based VRFB transfer
+	 */
+	vout->vrfb_dma_tx.dev_id = OMAP_DMA_NO_DEVICE;
+	vout->vrfb_dma_tx.dma_ch = -1;
+	vout->vrfb_dma_tx.req_status = DMA_CHAN_ALLOTED;
+	r = omap_request_dma(vout->vrfb_dma_tx.dev_id,
+			     "VRFB DMA TX", omap_vout_vrfb_dma_tx_callback,
+			     (void *) &vout->vrfb_dma_tx,
+			     &vout->vrfb_dma_tx.dma_ch);
+	if (r < 0)
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+
+	init_waitqueue_head(&vout->vrfb_dma_tx.wait);
+
+	/*if rotation support */
+	printk(KERN_INFO VOUT_NAME ": registered device video%d [v4l2]\n",
+	       vfd->minor);
+	return vout;
+
+free_buffer_memory:
+	for (i = 0; i < numbuffers; i++) {
+		omap_vout_free_buffer(vout->buf_virt_addr[i],
+					 vout->buf_phy_addr[i],
+					 vout->buffer_size);
+		vout->buf_virt_addr[i] = 0;
+		vout->buf_phy_addr[i] = 0;
+	}
+
+rotation_free:
+	for (i = 0; i < index_i; i++) {
+		for (j = 0; j < 4; j++) {
+			release_mem_region(vout->sms_rot_phy[i][j],
+					   VRF_SIZE);
+		}
+	}
+	for (j = 0; j < index_j; j++) {
+		release_mem_region(vout->sms_rot_phy[index_i][j],
+				   VRF_SIZE);
+	}
+	video_device_release(vfd);
+	kfree(vout);
+	return NULL;
+}
+
+static int __init omap_vout_init(void)
+{
+	omap_disp_get_dss();
+	omap_disp_get_dss();
+	saved_v1out = omap_vout_init_device(OMAP_VIDEO1);
+	if (saved_v1out == NULL) {
+		omap_disp_put_dss();
+		return -ENODEV;
+	}
+	omap_disp_save_initstate(OMAP_DSS_DISPC_GENERIC);
+	omap_disp_save_initstate(OMAP_VIDEO1);
+
+	saved_v2out = omap_vout_init_device(OMAP_VIDEO2);
+	if (saved_v2out == NULL) {
+		omap_vout_cleanup_device(OMAP_VIDEO1);
+		omap_disp_put_dss();
+		return -ENODEV;
+	}
+	omap_disp_save_initstate(OMAP_DSS_DISPC_GENERIC);
+	omap_disp_save_initstate(OMAP_VIDEO2);
+	omap_disp_put_dss();
+
+	vout_linked = -1;
+	spin_lock_init(&vout_link_lock);
+	return 0;
+}
+
+static void omap_vout_cleanup(void)
+{
+	omap_disp_get_dss();
+	omap_vout_cleanup_device(OMAP_VIDEO1);
+	omap_vout_cleanup_device(OMAP_VIDEO2);
+	omap_disp_put_dss();
+}
+
+#ifndef MODULE
+/*
+ *	omap_vout_setup - process command line options
+ *	@options: string of options
+ *
+ *	NOTE: This function is a __setup and __init function.
+ *
+ *	Returns zero.
+ */
+int __init omap_vout_setup(char *options)
+{
+	char *this_opt;
+	int i;
+
+	if (!options || !*options)
+		return 0;
+
+	DPRINTK("Options \"%s\"\n", options);
+	i = strlen(VOUT_NAME);
+	if (!strncmp(options, VOUT_NAME, i) && options[i] == ':') {
+		this_opt = options + i + 1;
+		if (!this_opt || !*this_opt)
+			return 0;
+
+		if (!strncmp(this_opt, "rotation=", 9)) {
+			int deg = simple_strtoul(this_opt + 9, NULL, 0);
+			switch (deg) {
+			case 0:
+			case 90:
+			case 180:
+			case 270:
+				rotation_support =
+				    (deg == 90) ? 270 : (deg ==
+							 270) ? 90 : deg;
+				break;
+			default:
+				rotation_support = -1;
+				break;
+			}
+			printk(KERN_INFO VOUT_NAME ": Rotation %s\n",
+			       (rotation_support ==
+				-1) ? "none (supported: \"rotation=\
+				[-1|0|90|180|270]\")" : this_opt + 9);
+		} else
+			printk(KERN_INFO VOUT_NAME ": Invalid parameter \
+					\"%s\" " "(supported: \
+				\"rotation = [-1|0|90|180|270]\")\n", this_opt);
+		return 0;
+	}
+
+	/*
+	 * If we get here no fb was specified.
+	 * We consider the argument to be a global video mode option.
+	 */
+	/* TODO - remove when FB is configured */
+	return 0;
+}
+
+__setup("videoout=", omap_vout_setup);
+#endif
+
+MODULE_AUTHOR("Texas Instruments.");
+MODULE_DESCRIPTION("OMAP Video for Linux Video out driver");
+MODULE_LICENSE("GPL");
+/* TODO -- Enabling it results in build erros, why?? */
+/*
+module_param(render_mem, uint, \
+		VID_MAX_WIDTH * VID_MAX_HEIGHT * 4 * MAX_ALLOWED_VIDBUFFERS);
+MODULE_PARM_DESC (render_mem,
+		  "Maximum rendering memory size (default 1.2MB)");
+*/
+/*module_init (omap_vout_init);*/
+late_initcall(omap_vout_init);
+module_exit(omap_vout_cleanup);
diff --git a/drivers/media/video/omap/omap_voutdef.h b/drivers/media/video/omap/omap_voutdef.h
new file mode 100644
index 0000000..84de18d
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutdef.h
@@ -0,0 +1,196 @@
+/*
+ * drivers/media/video/omap2/omap2_def.h
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef OMAP_VOUTDEF_H
+#define OMAP_VOUTDEF_H
+
+#include <linux/omap_vout.h>
+
+#define YUYV_BPP        2
+#define RGB565_BPP      2
+#define RGB24_BPP       3
+#define RGB32_BPP       4
+#define TILE_SIZE       32
+#define YUYV_VRFB_BPP   2
+#define RGB_VRFB_BPP    1
+
+/*
+ * This structure is used to store the DMA transfer parameters
+ * for VRFB hidden buffer
+ */
+struct vid_vrfb_dma {
+	int dev_id;
+	int dma_ch;
+	int req_status;
+	int tx_status;
+	wait_queue_head_t wait;
+};
+
+/* per-device data structure */
+struct omap_vout_device {
+	struct device dev;
+	struct video_device *vfd;
+	int vid;
+	int opened;
+
+	/* Power management suspend lockout stuff */
+	int suspended;
+	wait_queue_head_t suspend_wq;
+
+#ifdef DEBUG_ALLOW_WRITE
+	unsigned long framebuffer_base;
+	unsigned long framebuffer_base_phys;
+	unsigned long framebuffer_size;
+#endif
+
+	/* we don't allow to change image fmt/size once buffer has
+	 * been allocated
+	 */
+	int buffer_allocated;
+	/* allow to reuse previosuly allocated buffer which is big enough */
+	int buffer_size;
+	/* keep buffer info accross opens */
+	unsigned long buf_virt_addr[VIDEO_MAX_FRAME];
+	unsigned long buf_phy_addr[VIDEO_MAX_FRAME];
+	unsigned int buf_memory_type;
+
+	/* we don't allow to request new buffer when old buffers are
+	 * still mmaped
+	 */
+	int mmap_count;
+
+	spinlock_t vbq_lock;		/* spinlock for videobuf queues */
+	unsigned long field_count;	/* field counter for videobuf_buffer */
+
+	/* non-NULL means streaming is in progress. */
+	struct omap_vout_fh *streaming;
+
+	struct v4l2_pix_format pix;
+	struct v4l2_rect crop;
+	struct v4l2_window win;
+	struct v4l2_framebuffer fbuf;
+
+	/* Lock to protect the shared data structures in ioctl */
+	struct semaphore lock;
+
+	/* rotation variablse goes here */
+	unsigned long sms_rot_virt[4]; /* virtual addresss for four angles */
+					/* four angles */
+	dma_addr_t sms_rot_phy[4][4];
+
+	int mirror;
+	int rotation;
+
+	int bpp; /* bytes per pixel */
+	int vrfb_bpp; /* bytes per pixel with respect to VRFB */
+	unsigned int tile_aligned_psize;
+
+	struct vid_vrfb_dma vrfb_dma_tx;
+	unsigned int smsshado_phy_addr[4];
+	unsigned int smsshado_virt_addr[4];
+	unsigned int vrfb_context[4];
+	unsigned int smsshado_size;
+	unsigned char pos;
+
+	int flicker_filter;
+	int ps, vr_ps, line_length, first_int, field_id;
+	enum v4l2_memory memory;
+	struct videobuf_buffer *curFrm, *nextFrm;
+	struct list_head dma_queue;
+	u8 *queued_buf_addr[32];
+	u32 cropped_offset;
+	s32 tv_field1_offset;
+
+};
+
+/* per-filehandle data structure */
+struct omap_vout_fh {
+	struct omap_vout_device *vout;
+	enum v4l2_buf_type type;
+	struct videobuf_queue vbq;
+	int io_allowed;
+};
+
+#ifdef CONFIG_ARCH_OMAP34XX
+
+/*******************************************************************/
+/* auxiliary display buffer type */
+struct aux_disp_buf {
+	int index;
+	void *data;
+};
+
+struct aux_disp_queue_hdr {
+	int queue_depth;
+	int queued;
+	int dequeued;
+	int processed;
+	struct aux_disp_buf *aux_disp_queue;
+};
+
+/* auxiliary device data structure */
+struct omap3_aux_disp_device {
+	struct device dev;
+	struct video_device *vfd;
+	int opened;
+
+	/* Power management suspend lockout stuff */
+	int suspended;
+	wait_queue_head_t suspend_wq;
+
+#ifdef DEBUG_ALLOW_WRITE
+	unsigned long framebuffer_base;
+	unsigned long framebuffer_base_phys;
+	unsigned long framebuffer_size;
+#endif
+
+	/* we don't allow to change image fmt/size once buffer
+	 * has been allocated
+	 */
+	int buffer_allocated;
+	/* allow to reuse previosuly allocated buffer which is big enough */
+	int buffer_size;
+	/* keep buffer info accross opens */
+	unsigned long buf_virt_addr[VIDEO_MAX_FRAME];
+	unsigned long buf_phy_addr[VIDEO_MAX_FRAME];
+	unsigned int buf_memory_type;
+
+	/* we don't allow to request new buffer when old buffers
+	 * are still mmaped
+	 */
+	int mmap_count;
+
+	spinlock_t vbq_lock;		/* spinlock for videobuf queues */
+	unsigned long field_count;	/* field counter for videobuf_buffer */
+
+	/* non-NULL means streaming is in progress. */
+	struct omap_vout_fh *streaming;
+
+	struct v4l2_pix_format pix;
+	struct v4l2_rect crop;
+	struct v4l2_window win;
+	struct v4l2_framebuffer fbuf;
+
+	int mirror;
+	int rotation;
+
+	int bpp; /* bytes per pixel */
+	struct aux_disp_queue_hdr	aux_queue_hdr;
+};
+
+/* per-filehandle data structure */
+struct omap3_aux_disp_fh {
+	struct omap3_aux_disp_device *vout;
+	enum v4l2_buf_type type;
+	struct videobuf_queue vbq;
+};
+#endif
+
+#endif	/* ifndef OMAP_VOUTDEF_H */
diff --git a/drivers/media/video/omap/omap_voutlib.c b/drivers/media/video/omap/omap_voutlib.c
new file mode 100644
index 0000000..627d843
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutlib.c
@@ -0,0 +1,284 @@
+/*
+ * drivers/media/video/omap2/omap2_lib.c
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Based on the OMAP2 camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include <linux/semaphore.h>
+
+#include <mach/omap-dss.h>
+#include <asm/byteorder.h>
+
+/* Return the default overlay cropping rectangle in crop given the image
+ * size in pix and the video display size in fbuf.  The default
+ * cropping rectangle is the largest rectangle no larger than the capture size
+ * that will fit on the display.  The default cropping rectangle is centered in
+ * the image.  All dimensions and offsets are rounded down to even numbers.
+ */
+void omap_vout_default_crop(struct v4l2_pix_format *pix,
+		  struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop)
+{
+	crop->width = (pix->width < fbuf->fmt.width) ?
+		pix->width : fbuf->fmt.width;
+	crop->height = (pix->height < fbuf->fmt.height) ?
+		pix->height : fbuf->fmt.height;
+	crop->width &= ~1;
+	crop->height &= ~1;
+	crop->left = ((pix->width - crop->width) >> 1) & ~1;
+	crop->top = ((pix->height - crop->height) >> 1) & ~1;
+}
+EXPORT_SYMBOL_GPL(omap_vout_default_crop);
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The adjusted window parameters are
+ * returned in new_win.
+ * Returns zero if succesful, or -EINVAL if the requested window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
+			struct v4l2_window *new_win)
+{
+	struct v4l2_rect try_win;
+
+	/* make a working copy of the new_win rectangle */
+	try_win = new_win->w;
+
+	/* adjust the preview window so it fits on the display by clipping any
+	 * offscreen areas
+	 */
+	if (try_win.left < 0) {
+		try_win.width += try_win.left;
+		try_win.left = 0;
+	}
+	if (try_win.top < 0) {
+		try_win.height += try_win.top;
+		try_win.top = 0;
+	}
+	try_win.width = (try_win.width < fbuf->fmt.width) ?
+		try_win.width : fbuf->fmt.width;
+	try_win.height = (try_win.height < fbuf->fmt.height) ?
+		try_win.height : fbuf->fmt.height;
+	if (try_win.left + try_win.width > fbuf->fmt.width)
+		try_win.width = fbuf->fmt.width - try_win.left;
+	if (try_win.top + try_win.height > fbuf->fmt.height)
+		try_win.height = fbuf->fmt.height - try_win.top;
+	try_win.width &= ~1;
+	try_win.height &= ~1;
+
+	if (try_win.width <= 0 || try_win.height <= 0)
+		return -EINVAL;
+
+	/* We now have a valid preview window, so go with it */
+	new_win->w = try_win;
+	new_win->field = /*V4L2_FIELD_NONE*/V4L2_FIELD_ANY;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_try_window);
+
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The image cropping window in crop
+ * will also be adjusted if necessary.  Preference is given to keeping the
+ * the window as close to the requested configuration as possible.  If
+ * successful, new_win, vout->win, and crop are updated.
+ * Returns zero if succesful, or -EINVAL if the requested preview window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_new_window(struct v4l2_rect *crop,
+		struct v4l2_window *win, struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win)
+{
+	int err;
+
+	err = omap_vout_try_window(fbuf, new_win);
+	if (err)
+		return err;
+
+	/* update our preview window */
+	win->w = new_win->w;
+	win->field = new_win->field;
+	win->chromakey = new_win->chromakey;
+
+	/* adjust the cropping window to allow for resizing limitations */
+	if ((crop->height/win->w.height) >= 2) {
+		/* The maximum vertical downsizing ratio is 2:1 */
+		crop->height = win->w.height * 2;
+	}
+	if ((crop->width/win->w.width) >= 2) {
+		/* The maximum horizontal downsizing ratio is 2:1 */
+		crop->width = win->w.width * 2;
+	}
+	if (crop->width > 768) {
+		/* The OMAP2420 vertical resizing line buffer is 768 pixels
+		 * wide.  If the cropped image is wider than 768 pixels then it
+		 * cannot be vertically resized.
+		 */
+		if (crop->height != win->w.height)
+			crop->width = 768;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_window);
+
+/* Given a new cropping rectangle in new_crop, adjust the cropping rectangle to
+ * the nearest supported configuration.  The image render window in win will
+ * also be adjusted if necessary.  The preview window is adjusted such that the
+ * horizontal and vertical rescaling ratios stay constant.  If the render
+ * window would fall outside the display boundaries, the cropping rectangle
+ * will also be adjusted to maintain the rescaling ratios.  If successful, crop
+ * and win are updated.
+ * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_new_crop(struct v4l2_pix_format *pix,
+	      struct v4l2_rect *crop, struct v4l2_window *win,
+	      struct v4l2_framebuffer *fbuf, const struct v4l2_rect *new_crop)
+{
+	struct v4l2_rect try_crop;
+	unsigned long vresize, hresize;
+
+	/* make a working copy of the new_crop rectangle */
+	try_crop = *new_crop;
+
+	/* adjust the cropping rectangle so it fits in the image */
+	if (try_crop.left < 0) {
+		try_crop.width += try_crop.left;
+		try_crop.left = 0;
+	}
+	if (try_crop.top < 0) {
+		try_crop.height += try_crop.top;
+		try_crop.top = 0;
+	}
+	try_crop.width = (try_crop.width < pix->width) ?
+		try_crop.width : pix->width;
+	try_crop.height = (try_crop.height < pix->height) ?
+		try_crop.height : pix->height;
+	if (try_crop.left + try_crop.width > pix->width)
+		try_crop.width = pix->width - try_crop.left;
+	if (try_crop.top + try_crop.height > pix->height)
+		try_crop.height = pix->height - try_crop.top;
+	try_crop.width &= ~1;
+	try_crop.height &= ~1;
+	if (try_crop.width <= 0 || try_crop.height <= 0)
+		return -EINVAL;
+
+	if (crop->height != win->w.height) {
+		/* If we're resizing vertically, we can't support a crop width
+		 * wider than 768 pixels.
+		 */
+		if (try_crop.width > 768)
+			try_crop.width = 768;
+	}
+	/* vertical resizing */
+	vresize = (1024 * crop->height) / win->w.height;
+	if (vresize > 2048)
+		vresize = 2048;
+	else if (vresize == 0)
+		vresize = 1;
+	win->w.height = ((1024 * try_crop.height) / vresize) & ~1;
+	if (win->w.height == 0)
+		win->w.height = 2;
+	if (win->w.height + win->w.top > fbuf->fmt.height) {
+		/* We made the preview window extend below the bottom of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping height to maintain the vertical resizing ratio.
+		 */
+		win->w.height = (fbuf->fmt.height - win->w.top) & ~1;
+		if (try_crop.height == 0)
+			try_crop.height = 2;
+	}
+	/* horizontal resizing */
+	hresize = (1024 * crop->width) / win->w.width;
+	if (hresize > 2048)
+		hresize = 2048;
+	else if (hresize == 0)
+		hresize = 1;
+	win->w.width = ((1024 * try_crop.width) / hresize) & ~1;
+	if (win->w.width == 0)
+		win->w.width = 2;
+	if (win->w.width + win->w.left > fbuf->fmt.width) {
+		/* We made the preview window extend past the right side of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping width to maintain the horizontal resizing ratio.
+		 */
+		win->w.width = (fbuf->fmt.width - win->w.left) & ~1;
+		if (try_crop.width == 0)
+			try_crop.width = 2;
+	}
+
+	/* Check for resizing constraints */
+	if ((try_crop.height/win->w.height) >= 2) {
+		/* The maximum vertical downsizing ratio is 2:1 */
+		try_crop.height = win->w.height * 2;
+	}
+	if ((try_crop.width/win->w.width) >= 2) {
+		/* The maximum horizontal downsizing ratio is 2:1 */
+		try_crop.width = win->w.width * 2;
+	}
+	if (try_crop.width > 768) {
+		/* The OMAP2420 vertical resizing line buffer is 768 pixels
+		 * wide.  If the cropped image is wider than 768 pixels then it
+		 * cannot be vertically resized.
+		 */
+		if (try_crop.height != win->w.height)
+			try_crop.width = 768;
+	}
+
+	/* update our cropping rectangle and we're done */
+	*crop = try_crop;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_crop);
+
+/* Given a new format in pix and fbuf,  crop and win
+ * structures are initialized to default values. crop
+ * is initialized to the largest window size that will fit on the display.  The
+ * crop window is centered in the image. win is initialized to
+ * the same size as crop and is centered on the display.
+ * All sizes and offsets are constrained to be even numbers.
+ */
+void omap_vout_new_format(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,
+		struct v4l2_window *win)
+{
+	/* crop defines the preview source window in the image capture
+	 * buffer
+	 */
+	omap_vout_default_crop(pix, fbuf, crop);
+
+	/* win defines the preview target window on the display */
+	win->w.width = crop->width;
+	win->w.height = crop->height;
+	win->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;
+	win->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_format);
+
+MODULE_AUTHOR("Texas Instruments.");
+MODULE_DESCRIPTION("OMAP Video library");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/omap/omap_voutlib.h b/drivers/media/video/omap/omap_voutlib.h
new file mode 100644
index 0000000..c7efce1
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutlib.h
@@ -0,0 +1,34 @@
+/*
+ * drivers/media/video/omap/omap2_lib.h
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#ifndef OMAP_VOUTLIB_H
+#define OMAP_VOUTLIB_H
+
+extern void omap_vout_default_crop(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop);
+
+extern int omap_vout_new_crop(struct v4l2_pix_format *pix,
+		struct v4l2_rect *crop, struct v4l2_window *win,
+		struct v4l2_framebuffer *fbuf,
+		const struct v4l2_rect *new_crop);
+
+extern int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win);
+
+extern int omap_vout_new_window(struct v4l2_rect *crop,
+		struct v4l2_window *win, struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win);
+
+extern void omap_vout_new_format(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,
+		struct v4l2_window *win);
+#endif	/* #ifndef OMAP_LIB_H */
+
diff --git a/include/linux/omap_vout.h b/include/linux/omap_vout.h
new file mode 100644
index 0000000..6c7135a
--- /dev/null
+++ b/include/linux/omap_vout.h
@@ -0,0 +1,60 @@
+/*
+ * include/linux/omap2_display.h
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef OMAP_VOUT_H
+#define OMAP_VOUT_H
+
+/* This is for user apps */
+#define OMAP_VOUT_OUTPUT_LCD        4
+#define OMAP_VOUT_OUTPUT_TV         5
+#define OMAP_VOUT_GFX_DESTINATION   100
+#define OMAP_VOUT_VIDEO_SOURCE      101
+
+struct omap_vout_colorkey {
+	unsigned int output_dev;
+	unsigned int key_type;
+	unsigned int key_val;
+};
+
+struct omap_vout_bgcolor {
+	unsigned int color;
+	unsigned int output_dev;
+};
+
+struct omap_vout_colconv {
+	short int RY, RCr, RCb;
+	short int GY, GCr, GCb;
+	short int BY, BCr, BCb;
+};
+
+/* non-standard V4L2 ioctls that are specific to OMAP */
+#define VIDIOC_S_OMAP_MIRROR		_IOW('V', 1, int)
+#define VIDIOC_G_OMAP_MIRROR		_IOR('V', 2, int)
+#define VIDIOC_S_OMAP_ROTATION		_IOW('V', 3, int)
+#define VIDIOC_G_OMAP_ROTATION		_IOR('V', 4, int)
+#define VIDIOC_S_OMAP_LINK		_IOW('V', 5, int)
+#define VIDIOC_G_OMAP_LINK		_IOR('V', 6, int)
+#define VIDIOC_S_OMAP_COLORKEY		_IOW('V', 7,\
+					struct omap_vout_colorkey)
+#define VIDIOC_G_OMAP_COLORKEY		_IOW('V', 8,\
+					struct omap_vout_colorkey)
+#define VIDIOC_S_OMAP_BGCOLOR		_IOW('V', 9,\
+					struct omap_vout_bgcolor)
+#define VIDIOC_G_OMAP_BGCOLOR		_IOW('V', 10,\
+					struct omap_vout_bgcolor)
+#define VIDIOC_OMAP_COLORKEY_ENABLE	_IOW('V', 11, int)
+#define VIDIOC_OMAP_COLORKEY_DISABLE	_IOW('V', 12, int)
+#define VIDIOC_S_OMAP_DEFCOLORCONV	_IOW('V', 13, int)
+#define VIDIOC_S_OMAP_COLORCONV	_IOW('V', 14,\
+					struct omap_vout_colconv)
+#define VIDIOC_G_OMAP_COLORCONV	_IOR('V', 15,\
+					struct omap_vout_colconv)
+
+#endif	/* #ifndef OMAP_VOUT_H */
-- 
1.6.5.2

