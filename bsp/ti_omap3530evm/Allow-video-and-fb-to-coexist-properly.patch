From dc40e7a20ef40126aca5e0638601dbff108a9332 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Mon, 9 Mar 2009 22:52:12 -0400
Subject: [PATCH 04/20] Allow video and fb to coexist properly

This patch is from TI's PSP 2.0 with very little
modification required to apply to 2.6.27.  It
essentially deals with the clocks to allow both
video and the fb to be usable.  Without this patch you
can only configure and use one or the other.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/arm/plat-omap/omap-dss.c |    8 +-
 drivers/video/omap/dispc.c    |  328 +++++++++++------------------------------
 2 files changed, 90 insertions(+), 246 deletions(-)

diff --git a/arch/arm/plat-omap/omap-dss.c b/arch/arm/plat-omap/omap-dss.c
index 9fb6866..65a891b 100644
--- a/arch/arm/plat-omap/omap-dss.c
+++ b/arch/arm/plat-omap/omap-dss.c
@@ -543,7 +543,7 @@ static void disp_ll_config_tv_clocks(int sleep_state)
 {
 	static int start = 1;
 	static struct clk *tv_clk;
-#ifdef CONFIG_MACH_OMAP_3430LABRADOR
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR) || defined(CONFIG_MACH_OMAP3EVM)
 	static struct clk *dac_clk;
 #endif
 	static int disabled;
@@ -557,7 +557,7 @@ static void disp_ll_config_tv_clocks(int sleep_state)
 	|| defined(CONFIG_MACH_OMAP_3430LABRADOR)
 		tv_clk = clk_get(NULL, "dss_tv_fck");
 #endif
-#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR) || defined(CONFIG_MACH_OMAP3EVM)
 		dac_clk = clk_get(NULL, "dss_96m_fck");
 		if (IS_ERR(dac_clk)) {
 			printk(KERN_WARNING
@@ -576,7 +576,7 @@ static void disp_ll_config_tv_clocks(int sleep_state)
 	if (sleep_state == 1) {
 		if (disabled == 0) {
 			clk_disable(tv_clk);
-#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR) || defined(CONFIG_MACH_OMAP3EVM)
 			clk_disable(dac_clk);
 #endif
 			disabled = 1;
@@ -589,7 +589,7 @@ static void disp_ll_config_tv_clocks(int sleep_state)
 				       "\n UNABLE to enable dss TV fclk \n");
 				return;
 			}
-#if defined(CONFIG_MACH_OMAP_3430LABRADOR)
+#if defined(CONFIG_MACH_OMAP_3430LABRADOR) || defined(CONFIG_MACH_OMAP3EVM)
 			if (clk_enable(dac_clk) != 0) {
 				printk(KERN_WARNING
 				       "\n UNABLE to enable dss 96MHz fclk \n");
diff --git a/drivers/video/omap/dispc.c b/drivers/video/omap/dispc.c
index c140c21..754f272 100644
--- a/drivers/video/omap/dispc.c
+++ b/drivers/video/omap/dispc.c
@@ -28,105 +28,20 @@
 #include <mach/sram.h>
 #include <mach/omapfb.h>
 #include <mach/board.h>
+#include <mach/omap-dss.h>
 
 #include "dispc.h"
 
 #define MODULE_NAME			"dispc"
 
-#define DSS_BASE			0x48050000
-#define DSS_SYSCONFIG			0x0010
-
-#define DISPC_BASE			0x48050400
-
-/* DISPC common */
-#define DISPC_REVISION			0x0000
-#define DISPC_SYSCONFIG			0x0010
-#define DISPC_SYSSTATUS			0x0014
-#define DISPC_IRQSTATUS			0x0018
-#define DISPC_IRQENABLE			0x001C
-#define DISPC_CONTROL			0x0040
-#define DISPC_CONFIG			0x0044
-#define DISPC_CAPABLE			0x0048
-#define DISPC_DEFAULT_COLOR0		0x004C
-#define DISPC_DEFAULT_COLOR1		0x0050
-#define DISPC_TRANS_COLOR0		0x0054
-#define DISPC_TRANS_COLOR1		0x0058
-#define DISPC_LINE_STATUS		0x005C
-#define DISPC_LINE_NUMBER		0x0060
-#define DISPC_TIMING_H			0x0064
-#define DISPC_TIMING_V			0x0068
-#define DISPC_POL_FREQ			0x006C
-#define DISPC_DIVISOR			0x0070
-#define DISPC_SIZE_DIG			0x0078
-#define DISPC_SIZE_LCD			0x007C
-
-#define DISPC_DATA_CYCLE1		0x01D4
-#define DISPC_DATA_CYCLE2		0x01D8
-#define DISPC_DATA_CYCLE3		0x01DC
-
-/* DISPC GFX plane */
-#define DISPC_GFX_BA0			0x0080
-#define DISPC_GFX_BA1			0x0084
-#define DISPC_GFX_POSITION		0x0088
-#define DISPC_GFX_SIZE			0x008C
-#define DISPC_GFX_ATTRIBUTES		0x00A0
-#define DISPC_GFX_FIFO_THRESHOLD	0x00A4
-#define DISPC_GFX_FIFO_SIZE_STATUS	0x00A8
-#define DISPC_GFX_ROW_INC		0x00AC
-#define DISPC_GFX_PIXEL_INC		0x00B0
-#define DISPC_GFX_WINDOW_SKIP		0x00B4
-#define DISPC_GFX_TABLE_BA		0x00B8
-
-/* DISPC Video plane 1/2 */
-#define DISPC_VID1_BASE			0x00BC
-#define DISPC_VID2_BASE			0x014C
-
-/* Offsets into DISPC_VID1/2_BASE */
-#define DISPC_VID_BA0			0x0000
-#define DISPC_VID_BA1			0x0004
-#define DISPC_VID_POSITION		0x0008
-#define DISPC_VID_SIZE			0x000C
-#define DISPC_VID_ATTRIBUTES		0x0010
-#define DISPC_VID_FIFO_THRESHOLD	0x0014
-#define DISPC_VID_FIFO_SIZE_STATUS	0x0018
-#define DISPC_VID_ROW_INC		0x001C
-#define DISPC_VID_PIXEL_INC		0x0020
-#define DISPC_VID_FIR			0x0024
-#define DISPC_VID_PICTURE_SIZE		0x0028
-#define DISPC_VID_ACCU0			0x002C
-#define DISPC_VID_ACCU1			0x0030
-
-/* 8 elements in 8 byte increments */
-#define DISPC_VID_FIR_COEF_H0		0x0034
-/* 8 elements in 8 byte increments */
-#define DISPC_VID_FIR_COEF_HV0		0x0038
-/* 5 elements in 4 byte increments */
-#define DISPC_VID_CONV_COEF0		0x0074
-
-#define DISPC_IRQ_FRAMEMASK		0x0001
-#define DISPC_IRQ_VSYNC			0x0002
-#define DISPC_IRQ_EVSYNC_EVEN		0x0004
-#define DISPC_IRQ_EVSYNC_ODD		0x0008
-#define DISPC_IRQ_ACBIAS_COUNT_STAT	0x0010
-#define DISPC_IRQ_PROG_LINE_NUM		0x0020
-#define DISPC_IRQ_GFX_FIFO_UNDERFLOW	0x0040
-#define DISPC_IRQ_GFX_END_WIN		0x0080
-#define DISPC_IRQ_PAL_GAMMA_MASK	0x0100
-#define DISPC_IRQ_OCP_ERR		0x0200
-#define DISPC_IRQ_VID1_FIFO_UNDERFLOW	0x0400
-#define DISPC_IRQ_VID1_END_WIN		0x0800
-#define DISPC_IRQ_VID2_FIFO_UNDERFLOW	0x1000
-#define DISPC_IRQ_VID2_END_WIN		0x2000
-#define DISPC_IRQ_SYNC_LOST		0x4000
-
+#define DISPC_BASE                     (DSS_REG_BASE + DISPC_REG_OFFSET)
 #define DISPC_IRQ_MASK_ALL		0x7fff
 
-#define DISPC_IRQ_MASK_ERROR		(DISPC_IRQ_GFX_FIFO_UNDERFLOW |	\
-					     DISPC_IRQ_VID1_FIFO_UNDERFLOW | \
-					     DISPC_IRQ_VID2_FIFO_UNDERFLOW | \
-					     DISPC_IRQ_SYNC_LOST)
+#define DISPC_IRQ_MASK_ERROR		(DISPC_IRQSTATUS_GFXFIFOUNDERFLOW |\
+					DISPC_IRQSTATUS_VID2FIFOUNDERFLOW | \
+					DISPC_IRQSTATUS_VID2FIFOUNDERFLOW | \
+					DISPC_IRQSTATUS_SYNCLOST)
 
-#define RFBI_CONTROL			0x48050040
 
 #define MAX_PALETTE_SIZE		(256 * 16)
 
@@ -188,8 +103,6 @@ static struct {
 	struct omapfb_color_key	color_key;
 } dispc;
 
-static void enable_lcd_clocks(int enable);
-
 static void inline dispc_write_reg(int idx, u32 val)
 {
 	__raw_writel(val, dispc.base + idx);
@@ -216,9 +129,9 @@ static void enable_rfbi_mode(int enable)
 	dispc_write_reg(DISPC_CONTROL, l);
 
 	/* Set bypass mode in RFBI module */
-	l = __raw_readl(IO_ADDRESS(RFBI_CONTROL));
+	l = __raw_readl(IO_ADDRESS(DSS_REG_BASE + DSS_CONTROL));
 	l |= enable ? 0 : (1 << 1);
-	__raw_writel(l, IO_ADDRESS(RFBI_CONTROL));
+	__raw_writel(l, IO_ADDRESS(DSS_REG_BASE + DSS_CONTROL));
 }
 
 static void set_lcd_data_lines(int data_lines)
@@ -259,31 +172,31 @@ static void set_load_mode(int mode)
 void omap_dispc_set_lcd_size(int x, int y)
 {
 	BUG_ON((x > (1 << 11)) || (y > (1 << 11)));
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_SIZE_LCD, FLD_MASK(16, 11) | FLD_MASK(0, 11),
 			((y - 1) << 16) | (x - 1));
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 }
 EXPORT_SYMBOL(omap_dispc_set_lcd_size);
 
 void omap_dispc_set_digit_size(int x, int y)
 {
 	BUG_ON((x > (1 << 11)) || (y > (1 << 11)));
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_SIZE_DIG, FLD_MASK(16, 11) | FLD_MASK(0, 11),
 			((y - 1) << 16) | (x - 1));
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 }
 EXPORT_SYMBOL(omap_dispc_set_digit_size);
 
 static void setup_plane_fifo(int plane, int ext_mode)
 {
 	const u32 ftrs_reg[] = { DISPC_GFX_FIFO_THRESHOLD,
-				DISPC_VID1_BASE + DISPC_VID_FIFO_THRESHOLD,
-			        DISPC_VID2_BASE + DISPC_VID_FIFO_THRESHOLD };
-	const u32 fsz_reg[] = { DISPC_GFX_FIFO_SIZE_STATUS,
-				DISPC_VID1_BASE + DISPC_VID_FIFO_SIZE_STATUS,
-				DISPC_VID2_BASE + DISPC_VID_FIFO_SIZE_STATUS };
+				DISPC_VID_FIFO_THRESHOLD(0),
+				DISPC_VID_FIFO_THRESHOLD(1) };
+	const u32 fsz_reg[] = { DISPC_GFX_FIFO_SIZE,
+				DISPC_VID_FIFO_SIZE(0),
+				DISPC_VID_FIFO_SIZE(1) };
 	int low, high;
 	u32 l;
 
@@ -304,17 +217,17 @@ static void setup_plane_fifo(int plane, int ext_mode)
 
 void omap_dispc_enable_lcd_out(int enable)
 {
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_CONTROL, 1, enable ? 1 : 0);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 }
 EXPORT_SYMBOL(omap_dispc_enable_lcd_out);
 
 void omap_dispc_enable_digit_out(int enable)
 {
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_CONTROL, 1 << 1, enable ? 1 << 1 : 0);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 }
 EXPORT_SYMBOL(omap_dispc_enable_digit_out);
 
@@ -324,21 +237,21 @@ static inline int _setup_plane(int plane, int channel_out,
 				  int color_mode)
 {
 	const u32 at_reg[] = { DISPC_GFX_ATTRIBUTES,
-				DISPC_VID1_BASE + DISPC_VID_ATTRIBUTES,
-			        DISPC_VID2_BASE + DISPC_VID_ATTRIBUTES };
-	const u32 ba_reg[] = { DISPC_GFX_BA0, DISPC_VID1_BASE + DISPC_VID_BA0,
-				DISPC_VID2_BASE + DISPC_VID_BA0 };
+				DISPC_VID_ATTRIBUTES(0),
+				DISPC_VID_ATTRIBUTES(1) };
+	const u32 ba_reg[] = { DISPC_GFX_BA0, DISPC_VID_BA0(0),
+				DISPC_VID_BA0(1) };
 	const u32 ps_reg[] = { DISPC_GFX_POSITION,
-				DISPC_VID1_BASE + DISPC_VID_POSITION,
-				DISPC_VID2_BASE + DISPC_VID_POSITION };
+				DISPC_VID_POSITION(0),
+				DISPC_VID_POSITION(1) };
 	const u32 sz_reg[] = { DISPC_GFX_SIZE,
-				DISPC_VID1_BASE + DISPC_VID_PICTURE_SIZE,
-				DISPC_VID2_BASE + DISPC_VID_PICTURE_SIZE };
+				DISPC_VID_PICTURE_SIZE(0),
+				DISPC_VID_PICTURE_SIZE(1) };
 	const u32 ri_reg[] = { DISPC_GFX_ROW_INC,
-				DISPC_VID1_BASE + DISPC_VID_ROW_INC,
-			        DISPC_VID2_BASE + DISPC_VID_ROW_INC };
-	const u32 vs_reg[] = { 0, DISPC_VID1_BASE + DISPC_VID_SIZE,
-				DISPC_VID2_BASE + DISPC_VID_SIZE };
+				DISPC_VID_ROW_INC(0),
+				DISPC_VID_ROW_INC(1) };
+	const u32 vs_reg[] = { 0, DISPC_VID_SIZE(0),
+				DISPC_VID_SIZE(1) };
 
 	int chout_shift, burst_shift;
 	int chout_val;
@@ -455,11 +368,11 @@ static int omap_dispc_setup_plane(int plane, int channel_out,
 	if ((unsigned)plane > dispc.mem_desc.region_cnt)
 		return -EINVAL;
 	paddr = dispc.mem_desc.region[plane].paddr + offset;
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	r = _setup_plane(plane, channel_out, paddr,
 			screen_width,
 			pos_x, pos_y, width, height, color_mode);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 	return r;
 }
 
@@ -468,10 +381,10 @@ static void write_firh_reg(int plane, int reg, u32 value)
 	u32 base;
 
 	if (plane == 1)
-		base = DISPC_VID1_BASE + DISPC_VID_FIR_COEF_H0;
+		base = DISPC_VID_FIR_COEF_H(0, reg);
 	else
-		base = DISPC_VID2_BASE + DISPC_VID_FIR_COEF_H0;
-	dispc_write_reg(base + reg * 8,	value);
+		base = DISPC_VID_FIR_COEF_H(1, reg);
+	dispc_write_reg(base, value);
 }
 
 static void write_firhv_reg(int plane, int reg, u32 value)
@@ -479,10 +392,10 @@ static void write_firhv_reg(int plane, int reg, u32 value)
 	u32 base;
 
 	if (plane == 1)
-		base = DISPC_VID1_BASE + DISPC_VID_FIR_COEF_HV0;
+		base = DISPC_VID_FIR_COEF_HV(0, reg);
 	else
-		base = DISPC_VID2_BASE + DISPC_VID_FIR_COEF_HV0;
-	dispc_write_reg(base + reg * 8,	value);
+		base = DISPC_VID_FIR_COEF_HV(1, reg);
+	dispc_write_reg(base, value);
 }
 
 static void set_upsampling_coef_table(int plane)
@@ -509,12 +422,12 @@ static int omap_dispc_set_scale(int plane,
 				int orig_width, int orig_height,
 				int out_width, int out_height)
 {
-	const u32 at_reg[]  = { 0, DISPC_VID1_BASE + DISPC_VID_ATTRIBUTES,
-				DISPC_VID2_BASE + DISPC_VID_ATTRIBUTES };
-	const u32 vs_reg[]  = { 0, DISPC_VID1_BASE + DISPC_VID_SIZE,
-				DISPC_VID2_BASE + DISPC_VID_SIZE };
-	const u32 fir_reg[] = { 0, DISPC_VID1_BASE + DISPC_VID_FIR,
-				DISPC_VID2_BASE + DISPC_VID_FIR };
+	const u32 at_reg[]  = { 0, DISPC_VID_ATTRIBUTES(0),
+				DISPC_VID_ATTRIBUTES(1) };
+	const u32 vs_reg[]  = { 0, DISPC_VID_SIZE(0),
+				DISPC_VID_SIZE(1) };
+	const u32 fir_reg[] = { 0, DISPC_VID_FIR(0),
+				DISPC_VID_FIR(1) };
 
 	u32 l;
 	int fir_hinc;
@@ -526,7 +439,7 @@ static int omap_dispc_set_scale(int plane,
 	if (out_width != orig_width || out_height != orig_height)
 		return -EINVAL;
 
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	if (orig_width < out_width) {
 		/*
 		 * Upsampling.
@@ -535,7 +448,7 @@ static int omap_dispc_set_scale(int plane,
 		if (orig_height > out_height ||
 		    orig_width * 8 < out_width ||
 		    orig_height * 8 < out_height) {
-			enable_lcd_clocks(0);
+			omap_disp_put_dss();
 			return -EINVAL;
 		}
 		set_upsampling_coef_table(plane);
@@ -543,7 +456,7 @@ static int omap_dispc_set_scale(int plane,
 		/* Downsampling not yet supported
 		*/
 
-		enable_lcd_clocks(0);
+		omap_disp_put_dss();
 		return -EINVAL;
 	}
 	if (!orig_width || orig_width == out_width)
@@ -577,21 +490,21 @@ static int omap_dispc_set_scale(int plane,
 	l |= fir_vinc ? (1 << 6) : 0;
 	dispc_write_reg(at_reg[plane], l);
 
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 	return 0;
 }
 
 static int omap_dispc_enable_plane(int plane, int enable)
 {
 	const u32 at_reg[] = { DISPC_GFX_ATTRIBUTES,
-				DISPC_VID1_BASE + DISPC_VID_ATTRIBUTES,
-				DISPC_VID2_BASE + DISPC_VID_ATTRIBUTES };
+				DISPC_VID_ATTRIBUTES(0),
+				DISPC_VID_ATTRIBUTES(1) };
 	if ((unsigned int)plane > dispc.mem_desc.region_cnt)
 		return -EINVAL;
 
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(at_reg[plane], 1, enable ? 1 : 0);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 
 	return 0;
 }
@@ -628,13 +541,13 @@ static int omap_dispc_set_color_key(struct omapfb_color_key *ck)
 	default:
 		return -EINVAL;
 	}
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_CONFIG, FLD_MASK(shift, 2), val << shift);
 
 	if (val != 0)
 		dispc_write_reg(tr_reg, ck->trans_key);
 	dispc_write_reg(df_reg, ck->background);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 
 	dispc.color_key = *ck;
 
@@ -659,7 +572,7 @@ static int omap_dispc_set_update_mode(enum omapfb_update_mode mode)
 		switch (mode) {
 		case OMAPFB_AUTO_UPDATE:
 		case OMAPFB_MANUAL_UPDATE:
-			enable_lcd_clocks(1);
+			omap_disp_get_dss();
 			omap_dispc_enable_lcd_out(1);
 			dispc.update_mode = mode;
 			break;
@@ -672,7 +585,7 @@ static int omap_dispc_set_update_mode(enum omapfb_update_mode mode)
 					 "timeout waiting for FRAME DONE\n");
 			}
 			dispc.update_mode = mode;
-			enable_lcd_clocks(0);
+			omap_disp_put_dss();
 			break;
 		default:
 			r = -EINVAL;
@@ -706,10 +619,10 @@ static enum omapfb_update_mode omap_dispc_get_update_mode(void)
 static void setup_color_conv_coef(void)
 {
 	u32 mask = FLD_MASK(16, 11) | FLD_MASK(0, 11);
-	int cf1_reg = DISPC_VID1_BASE + DISPC_VID_CONV_COEF0;
-	int cf2_reg = DISPC_VID2_BASE + DISPC_VID_CONV_COEF0;
-	int at1_reg = DISPC_VID1_BASE + DISPC_VID_ATTRIBUTES;
-	int at2_reg = DISPC_VID2_BASE + DISPC_VID_ATTRIBUTES;
+	int cf1_reg = DISPC_VID_CONV_COEF0(0);
+	int cf2_reg = DISPC_VID_CONV_COEF0(1);
+	int at1_reg = DISPC_VID_ATTRIBUTES(0);
+	int at2_reg = DISPC_VID_ATTRIBUTES(1);
 	const struct color_conv_coef {
 		int  ry,  rcr,  rcb,   gy,  gcr,  gcb,   by,  bcr,  bcb;
 		int  full_range;
@@ -824,9 +737,9 @@ static void recalc_irq_mask(void)
 		irq_mask |= dispc.irq_handlers[i].irq_mask;
 	}
 
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 	MOD_REG_FLD(DISPC_IRQENABLE, 0x7fff, irq_mask);
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 }
 
 int omap_dispc_request_irq(unsigned long irq_mask, void (*callback)(void *data),
@@ -877,10 +790,10 @@ static irqreturn_t omap_dispc_irq_handler(int irq, void *dev)
 	u32 stat;
 	int i = 0;
 
-	enable_lcd_clocks(1);
+	omap_disp_get_dss();
 
 	stat = dispc_read_reg(DISPC_IRQSTATUS);
-	if (stat & DISPC_IRQ_FRAMEMASK)
+	if (stat & DISPC_IRQSTATUS_FRAMEDONE)
 		complete(&dispc.frame_done);
 
 	if (stat & DISPC_IRQ_MASK_ERROR) {
@@ -898,65 +811,11 @@ static irqreturn_t omap_dispc_irq_handler(int irq, void *dev)
 
 	dispc_write_reg(DISPC_IRQSTATUS, stat);
 
-	enable_lcd_clocks(0);
+	omap_disp_put_dss();
 
 	return IRQ_HANDLED;
 }
 
-static int get_dss_clocks(void)
-{
-	char *dss_ick = "dss_ick";
-	char *dss1_fck = cpu_is_omap34xx() ? "dss1_alwon_fck" : "dss1_fck";
-	char *tv_fck = cpu_is_omap34xx() ? "dss_tv_fck" : "dss_54m_fck";
-
-	if (IS_ERR((dispc.dss_ick = clk_get(dispc.fbdev->dev, dss_ick)))) {
-		dev_err(dispc.fbdev->dev, "can't get %s", dss_ick);
-		return PTR_ERR(dispc.dss_ick);
-	}
-
-	if (IS_ERR((dispc.dss1_fck = clk_get(dispc.fbdev->dev, dss1_fck)))) {
-		dev_err(dispc.fbdev->dev, "can't get %s", dss1_fck);
-		clk_put(dispc.dss_ick);
-		return PTR_ERR(dispc.dss1_fck);
-	}
-
-	if (IS_ERR((dispc.dss_54m_fck =
-				clk_get(dispc.fbdev->dev, tv_fck)))) {
-		dev_err(dispc.fbdev->dev, "can't get %s", tv_fck);
-		clk_put(dispc.dss_ick);
-		clk_put(dispc.dss1_fck);
-		return PTR_ERR(dispc.dss_54m_fck);
-	}
-
-	return 0;
-}
-
-static void put_dss_clocks(void)
-{
-	clk_put(dispc.dss_54m_fck);
-	clk_put(dispc.dss1_fck);
-	clk_put(dispc.dss_ick);
-}
-
-static void enable_lcd_clocks(int enable)
-{
-	if (enable) {
-		clk_enable(dispc.dss_ick);
-		clk_enable(dispc.dss1_fck);
-	} else {
-		clk_disable(dispc.dss1_fck);
-		clk_disable(dispc.dss_ick);
-	}
-}
-
-static void enable_digit_clocks(int enable)
-{
-	if (enable)
-		clk_enable(dispc.dss_54m_fck);
-	else
-		clk_disable(dispc.dss_54m_fck);
-}
-
 static void omap_dispc_suspend(void)
 {
 	if (dispc.update_mode == OMAPFB_AUTO_UPDATE) {
@@ -967,14 +826,14 @@ static void omap_dispc_suspend(void)
 			dev_err(dispc.fbdev->dev,
 				"timeout waiting for FRAME DONE\n");
 		}
-		enable_lcd_clocks(0);
+		omap_disp_put_dss();
 	}
 }
 
 static void omap_dispc_resume(void)
 {
 	if (dispc.update_mode == OMAPFB_AUTO_UPDATE) {
-		enable_lcd_clocks(1);
+		omap_disp_get_dss();
 		if (!dispc.ext_mode) {
 			set_lcd_timings();
 			load_palette();
@@ -983,7 +842,6 @@ static void omap_dispc_resume(void)
 	}
 }
 
-
 static int omap_dispc_update_window(struct fb_info *fbi,
 				 struct omapfb_update_window *win,
 				 void (*complete_callback)(void *arg),
@@ -1364,7 +1222,7 @@ static void cleanup_fbmem(void)
 static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 			   struct omapfb_mem_desc *req_vram)
 {
-	int r;
+	int r = 0;
 	u32 l;
 	struct lcd_panel *panel = fbdev->panel;
 	int tmo = 10000;
@@ -1383,25 +1241,23 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	dispc.ext_mode = ext_mode;
 
 	init_completion(&dispc.frame_done);
+	omap_disp_get_dss();
+	dispc.dss_ick = clk_get(fbdev->dev, "dss_ick");
+	dispc.dss1_fck = clk_get(fbdev->dev, cpu_is_omap34xx() ?
+					"dss1_alwon_fck" : "dss1_fck");
+	dispc.dss_54m_fck = clk_get(fbdev->dev, cpu_is_omap34xx() ?
+					"dss_tv_fck" : "dss_54m_fck");
 
-	if ((r = get_dss_clocks()) < 0)
-		goto fail0;
-
-	enable_lcd_clocks(1);
-
-#ifdef CONFIG_FB_OMAP_BOOTLOADER_INIT
 	l = dispc_read_reg(DISPC_CONTROL);
 	/* LCD enabled ? */
-	if (l & 1) {
+	if ((l & 1) || (l & 0x2)) {
+
 		pr_info("omapfb: skipping hardware initialization\n");
 		skip_init = 1;
 	}
-#endif
 
 	if (!skip_init) {
 		/* Reset monitoring works only w/ the 54M clk */
-		enable_digit_clocks(1);
-
 		/* Soft reset */
 		MOD_REG_FLD(DISPC_SYSCONFIG, 1 << 1, 1 << 1);
 
@@ -1409,12 +1265,9 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 			if (!--tmo) {
 				dev_err(dispc.fbdev->dev, "soft reset failed\n");
 				r = -ENODEV;
-				enable_digit_clocks(0);
 				goto fail1;
 			}
 		}
-
-		enable_digit_clocks(0);
 	}
 
 	/* Enable smart standby/idle, autoidle and wakeup */
@@ -1422,7 +1275,6 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	l &= ~((3 << 12) | (3 << 3));
 	l |= (2 << 12) | (2 << 3) | (1 << 2) | (1 << 0);
 	dispc_write_reg(DISPC_SYSCONFIG, l);
-	omap_writel(1 << 0, DSS_BASE + DSS_SYSCONFIG);
 
 	/* Set functional clock autogating */
 	l = dispc_read_reg(DISPC_CONFIG);
@@ -1432,10 +1284,11 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	l = dispc_read_reg(DISPC_IRQSTATUS);
 	dispc_write_reg(DISPC_IRQSTATUS, l);
 
-	recalc_irq_mask();
+	/* Enable those that we handle always */
+	if (omap_disp_register_isr((omap_disp_isr_t)omap_dispc_irq_handler,
+					fbdev, DISPC_IRQENABLE_FRAMEDONE |
+					DISPC_IRQSTATUS_GFXFIFOUNDERFLOW)) {
 
-	if ((r = request_irq(INT_24XX_DSS_IRQ, omap_dispc_irq_handler,
-			   0, MODULE_NAME, fbdev)) < 0) {
 		dev_err(dispc.fbdev->dev, "can't get DSS IRQ\n");
 		goto fail1;
 	}
@@ -1449,7 +1302,6 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	if ((r = setup_fbmem(req_vram)) < 0)
 		goto fail3;
 
-	if (!skip_init) {
 		for (i = 0; i < dispc.mem_desc.region_cnt; i++) {
 			memset(dispc.mem_desc.region[i].vaddr, 0,
 				dispc.mem_desc.region[i].size);
@@ -1460,11 +1312,6 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 		MOD_REG_FLD(DISPC_DIVISOR, FLD_MASK(0, 8), 2 << 0);
 
 		setup_plane_fifo(0, ext_mode);
-		setup_plane_fifo(1, ext_mode);
-		setup_plane_fifo(2, ext_mode);
-
-		setup_color_conv_coef();
-
 		set_lcd_tft_mode(panel->config & OMAP_LCDC_PANEL_TFT);
 		set_load_mode(DISPC_LOAD_FRAME_ONLY);
 
@@ -1475,21 +1322,18 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 		} else
 			set_lcd_data_lines(panel->bpp);
 		enable_rfbi_mode(ext_mode);
-	}
 
 	l = dispc_read_reg(DISPC_REVISION);
 	pr_info("omapfb: DISPC version %d.%d initialized\n",
 		 l >> 4 & 0x0f, l & 0x0f);
-	enable_lcd_clocks(0);
 
-	return 0;
+	return r;
 fail3:
 	free_palette_ram();
 fail2:
 	free_irq(INT_24XX_DSS_IRQ, fbdev);
 fail1:
-	enable_lcd_clocks(0);
-	put_dss_clocks();
+	omap_disp_put_dss();
 fail0:
 	iounmap(dispc.base);
 	return r;
@@ -1506,7 +1350,7 @@ static void omap_dispc_cleanup(void)
 	cleanup_fbmem();
 	free_palette_ram();
 	free_irq(INT_24XX_DSS_IRQ, dispc.fbdev);
-	put_dss_clocks();
+	omap_disp_put_dss();
 	iounmap(dispc.base);
 }
 
-- 
1.6.5.2

