From 3a5ad5e6dd221738e64c1f1eb0fdf84ab58e502a Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Fri, 18 Dec 2009 14:06:34 +0800
Subject: [PATCH 12/20] ti_omap3530/nand: add plain nand device detection and registration

There are 2 type of omap3530 processor modules, one is based on 0.4mm
chip which is shipped with 128M OneNAND by PoP(package on package),
the other is based on 0.65mm chip which is externally connected with
256M plain nand. Here adding plain nand detection and regisration for
the latter module.

Original patch taken from OMAP35x-PSP-SDK-02.01.01.08 package.
http://software-dl.ti.com/dsps/dsps_registered_sw/sdo_sb/ \
targetcontent/psp/omap35x/index.html

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-omap2/board-omap3evm-flash.c |  100 ++++++++++++++++++++++++----
 1 files changed, 86 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-omap2/board-omap3evm-flash.c b/arch/arm/mach-omap2/board-omap3evm-flash.c
index 5f3663d..fac5a87 100644
--- a/arch/arm/mach-omap2/board-omap3evm-flash.c
+++ b/arch/arm/mach-omap2/board-omap3evm-flash.c
@@ -27,29 +27,29 @@ static int omap3evm_onenand_setup(void __iomem *, int freq);
 
 static struct mtd_partition omap3evm_onenand_partitions[] = {
 	{
-		.name           = "xloader",
+		.name           = "xloader-onenand",
 		.offset         = 0,
 		.size           = 4*(64*2048),
 		.mask_flags     = MTD_WRITEABLE
 	},
 	{
-		.name           = "uboot",
+		.name           = "uboot-onenand",
 		.offset         = MTDPART_OFS_APPEND,
 		.size           =  15*(64*2048),
 		.mask_flags     = MTD_WRITEABLE
 	},
 	{
-		.name           = "params",
+		.name           = "params-onenand",
 		.offset         = MTDPART_OFS_APPEND,
 		.size           = 1*(64*2048),
 	},
 	{
-		.name           = "linux",
+		.name           = "linux-onenand",
 		.offset         = MTDPART_OFS_APPEND,
 		.size           = 40*(64*2048),
 	},
 	{
-		.name           = "jffs2",
+		.name           = "jffs2-onenand",
 		.offset         = MTDPART_OFS_APPEND,
 		.size           = MTDPART_SIZ_FULL,
 	},
@@ -70,6 +70,60 @@ static struct platform_device omap3evm_onenand_device = {
 	},
 };
 
+static struct mtd_partition omap3evm_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "xloader-nand",
+		.offset		= 0,
+		.size		= 4*(128 * 1024),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "uboot-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 14*(128 * 1024),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "params-nand",
+
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 2*(128 * 1024)
+	},
+	{
+		.name		= "linux-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 40*(128 * 1024)
+	},
+	{
+		.name		= "jffs2-nand",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND,
+	},
+};
+
+static struct omap_nand_platform_data omap3evm_nand_data = {
+	.parts		= omap3evm_nand_partitions,
+	.nr_parts	= ARRAY_SIZE(omap3evm_nand_partitions),
+	.nand_setup	= NULL,
+	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
+	.dev_ready	= NULL,
+};
+
+static struct resource omap3evm_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device omap3evm_nand_device = {
+	.name		= "omap2-nand",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &omap3evm_nand_data,
+	},
+	.num_resources	= 1,
+	.resource	= &omap3evm_nand_resource,
+};
+
 /*
  *      omap3evm_onenand_setup - Set the onenand sync mode
  *      @onenand_base:  The onenand base address in GPMC memory map
@@ -85,33 +139,51 @@ static int omap3evm_onenand_setup(void __iomem *onenand_base, int freq)
 void __init omap3evm_flash_init(void)
 {
 	u8		cs = 0;
-	u8		onenandcs = GPMC_CS_NUM + 1;
+	u8		onenandcs = GPMC_CS_NUM + 1, nandcs = GPMC_CS_NUM + 1;
+	u32		gpmc_base_add = OMAP34XX_GPMC_VIRT;
 
 	while (cs < GPMC_CS_NUM) {
 		u32 ret = 0;
-		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
 
 		/*
-		* xloader/Uboot would have programmed the oneNAND
+		* xloader/Uboot would have programmed the NAND/oneNAND
 		* base address for us This is a ugly hack. The proper
 		* way of doing this is to pass the setup of u-boot up
 		* to kernel using kernel params - something on the
-		* lines of machineID. Check if oneNAND is configured
+		* lines of machineID. Check if NAND/oneNAND is configured
 		*/
-		if ((ret & 0x3F) == (ONENAND_MAP >> 24))
-			onenandcs = cs;
+		if ((ret & 0xC00) == 0x800) {
+			/* Found it!! */
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		} else {
+			ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);
+			if ((ret & 0x3F) == (ONENAND_MAP >> 24))
+				onenandcs = cs;
+		}
 		cs++;
 	}
-	if (onenandcs > GPMC_CS_NUM) {
-		printk(KERN_INFO "OneNAND: Unable to find configuration "
+	if ((nandcs > GPMC_CS_NUM) && (onenandcs > GPMC_CS_NUM)) {
+		printk(KERN_INFO "NAND/OneNAND: Unable to find configuration "
 				" in GPMC\n ");
 		return;
 	}
 
+	if (nandcs < GPMC_CS_NUM) {
+		omap3evm_nand_data.cs	= nandcs;
+		omap3evm_nand_data.gpmc_cs_baseaddr = (void *)(gpmc_base_add +
+					GPMC_CS0_BASE + nandcs*GPMC_CS_SIZE);
+		omap3evm_nand_data.gpmc_baseaddr   = (void *) (gpmc_base_add);
+
+		if (platform_device_register(&omap3evm_nand_device) < 0) {
+			printk(KERN_ERR "Unable to register NAND device\n");
+		}
+	}
+
 	if (onenandcs < GPMC_CS_NUM) {
 		omap3evm_onenand_data.cs = onenandcs;
 		if (platform_device_register(&omap3evm_onenand_device) < 0)
 			printk(KERN_ERR "Unable to register OneNAND device\n");
 	}
 }
-
-- 
1.6.5.2

